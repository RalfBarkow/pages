{
  "title": "Software Metrics",
  "story": [
    {
      "type": "html",
      "text": "Much has been written about software metrics from a product point of view.  This author (craig@hubley.com) considers the most useful metrics to be those which measure the degree to which the software development effort reflects the priorities of its end users and funders, not necessarily in that order.",
      "id": "6d554a588af007e9647f3ca24e4359a1"
    },
    {
      "type": "html",
      "text": "\nSome such useful metrics include the 'churn' of a project, which is the percentage of lines of code written that are changed before (next) release, and the 'dross' of a project, which is the number of lines which are never executed or omitted before release.  A more technical metric, measuring the cohesion of the source code, is the number of places in the code body that a programmer must reference and/or change while making what he, psychologically, considers to be 'one bug fix' or 'one change'.",
      "id": "f42eced49f82cb15c22b9fa915063c9f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "<b>Overview of [[Software Metrics]]</b>",
      "id": "b02813ba410b1db44c18017781a41639"
    },
    {
      "type": "html",
      "text": "[[System Size Metrics]]",
      "id": "fd98c1e92891d55789bdb8c790d2ff82"
    },
    {
      "type": "html",
      "text": "[[Lines Of Code]]",
      "id": "8e7075ffd4b5c990da69a75d5e95fc33"
    },
    {
      "type": "html",
      "text": "[[Function Count]]",
      "id": "f98e2b951f16cbee214c31d754c59774"
    },
    {
      "type": "html",
      "text": "[[Function Point]]s",
      "id": "028ae8b1f377a9b1fae403cc5c319b62"
    },
    {
      "type": "html",
      "text": "[[Number Of Files]] ",
      "id": "228340fd4450dde016b7f7e6a7e0679c"
    },
    {
      "type": "html",
      "text": "[[Object Oriented Metrics]]",
      "id": "48c2e81e5083c0cc57628ea82026fc80"
    },
    {
      "type": "html",
      "text": "[[Number Of Classes]]",
      "id": "8b24160eab8246600f58cf440c493036"
    },
    {
      "type": "html",
      "text": "NumberIfChildCLasses",
      "id": "c959b5351186c72813f6e39e40186c0e"
    },
    {
      "type": "html",
      "text": "[[Number Of Return Points]]",
      "id": "ecdb88ddfe6521b40e61d94b495d3b67"
    },
    {
      "type": "html",
      "text": "[[Depth Of Inheritance Tree]] ",
      "id": "89a41fcc0570b69a210a66135375f864"
    },
    {
      "type": "html",
      "text": "[[Complexity Metrics]]",
      "id": "3bfac5b1abbf4a947330b38c21d22b5f"
    },
    {
      "type": "html",
      "text": "[[Boolean Expression Complexity]]",
      "id": "90c0c247a75049180667836c25d7f5e4"
    },
    {
      "type": "html",
      "text": "[[Class Data Abstraction Coupling]]",
      "id": "deb0d8cbcdd76550f367303d7b5099f6"
    },
    {
      "type": "html",
      "text": "[[Class Fan Out Complexity]]",
      "id": "8b25807cd9281ee665167d443cdb2187"
    },
    {
      "type": "html",
      "text": "[[Cyclomatic Complexity]]",
      "id": "eae3afaff086a4dfccf4af73006c4964"
    },
    {
      "type": "html",
      "text": "[[Function Interface Complexity]] ",
      "id": "1fc6e5363c0aa4e1b241ad48e57ddcc2"
    },
    {
      "type": "html",
      "text": "NPathComplexity",
      "id": "77a5a67a42844a5bbd7538315161af18"
    },
    {
      "type": "html",
      "text": "[[Quality Metrics]]",
      "id": "0c1e4f5f6cee5dce575c1b7e57ddfff7"
    },
    {
      "type": "html",
      "text": "[[Design Velocity]]",
      "id": "969037fcbd6c75c006fbdce4e41fd43c"
    },
    {
      "type": "html",
      "text": "[[Running Tested Features]]",
      "id": "84bdf9869dfb1b961a7bf5f4c8b74c20"
    },
    {
      "type": "html",
      "text": "[[Shodan Input Metric]]",
      "id": "62cc5356efd21ac001f38390c8e10c03"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "I want both Agility and the spirit of ISO and CMMI.  I want lightweight metrics that are practical for a small informal team.  They should be concrete, concise, and unbiased.",
      "id": "6a953b419cfa79939a7f06f55af5d339"
    },
    {
      "type": "html",
      "text": "\nMy small team at IBM has worked with Laurie Williams at NC State over the last year to measure our XP project.  We found we improved our defect injection rate by a factor of two.  But more importantly, we came up with a measurement framework for anyone who wants to replicate our study.",
      "id": "550da532c58c6beed6cc128c4423867b"
    },
    {
      "type": "html",
      "text": "\nWe give you [[Xp Evaluation Framework]].  Please let me know if you have feedback or suggestions.  You don't have to use it, but if you're looking for ideas on what to measure it may helpful to you. I plan to continue to use it on my projects.",
      "id": "aa178b1f00feee3e63273a4beb298588"
    },
    {
      "type": "html",
      "text": "\n[[Bill Krebs]]",
      "id": "260b6ad6e66551b6190500ff72770c45"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "\nGoing a bit afield from the first paragraph above, ... a vastly more general (and therefore vague question): What is the role of metrics in ideal software development ? ",
      "id": "a88a1acfee1184f6d1ffeb78099d8925"
    },
    {
      "type": "html",
      "text": "\nThe motivation for this question is simple: I want to be a  better programmer. How do I get there ? Well, some of the  standard wiki answers (deduced from recent traffic here and  some more general desiderata) might include:",
      "id": "9ea7a5aa76d6c6c3cf9549212ccc4ef5"
    },
    {
      "type": "html",
      "text": " Write programs. Becoming better involves experience",
      "id": "3fbc66c8d572fa3137b970393288a794"
    },
    {
      "type": "html",
      "text": " Reflect upon your code. Strive to understand what worked and what didn't.",
      "id": "dcd4cbcba648d4b06077e2b285c1583e"
    },
    {
      "type": "html",
      "text": " Read Tomes of Lore. These range from generic OO (Booch or Meyer) to language specific (Coplien or Beck) to project-type specific (Greenspun) to patterns (the PLOPs) to ...",
      "id": "f1c833c667fb0a815e5ea7895839fdb2"
    },
    {
      "type": "html",
      "text": " Practice [[Extreme Programming]]",
      "id": "322fdb8c3382cc633f64ad4dd21f1a4d"
    },
    {
      "type": "html",
      "text": " Perform [[Unit Test]]s",
      "id": "7d965d0cb7452ba8c5404737aa606ad6"
    },
    {
      "type": "html",
      "text": "\nBut the question remains: What is it that these things do ? If I  hand you an application (both source and executable), it should  take under a day to get an idea of the author's skill levels and whether the code is any good (which is not the same as whether the program is any good or whether the requirements were met or ...).",
      "id": "20d1af0c0d1f5bc5b87eb63651207b1e"
    },
    {
      "type": "html",
      "text": "\nWhich means that, in principle, there ought to be tools that can measure this as well (based on the general principle that  <i>Anything I can be certain of deducing in a single day can be deduced by a computer program</i> )",
      "id": "3869b93fa92fcba7c3d583d41ac4e1ec"
    },
    {
      "type": "html",
      "text": "\nThis, I think, is the idea behind metrics. Or, at least, one of the ideas.",
      "id": "369ae93762ae788141042dd88b1d4e26"
    },
    {
      "type": "html",
      "text": "\nBut, it seems to me, in all the talk here, formal metrics don't  appear much. Can the benefits of [[Refactor Mercilessly]] be put in terms of metrics ? Are there general heuristics for doing  so ? The [[Law Of Demeter]] seems to be somewhat measurable. But what about the other practices espoused on Wiki ?",
      "id": "a927fcd9d1097a64db3193fa73ee0f55"
    },
    {
      "type": "html",
      "text": "\nAs I said, a vague question. But I seem to be getting more interested in metrics these days and so I thought I'd ask.",
      "id": "6713568b28fcb056295fb65d9e377ea2"
    },
    {
      "type": "html",
      "text": "-- [[William Grosso]]",
      "id": "9fb2952df371244b035ddb58a8b31e0b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "Refactoring improves coupling and cohesion. This can be measured. The tool [[Pattern Lint]] [1] helps pinpoint some kinds of design warts by weighting static and dynamic object communication and comparing them. Two papers accessible from the above link have some examples. -- [[Aamod Sane]]",
      "id": "a0c8a2a3fbca098272f9ba2c08900aa6"
    },
    {
      "type": "html",
      "text": "<i>Aamod - are you asserting that it is possible to measure coupling and (especially) cohesion mechanically?  I wouldn't have thought so; have you a reference? --[[Ron Jeffries]]</i>",
      "id": "c4fa523f19714f781fb31ba53c38fafd"
    },
    {
      "type": "html",
      "text": "\nS.R. Chidamber and C.F. Kemerer, \"A Metrics Suite for Object Oriented Design,\" IEEE Trans. Software Eng., vol. 20, no. 6, pp. 476-493, 1994",
      "id": "0d7bca0c1d1e015e09277ccb7c78100e"
    },
    {
      "type": "html",
      "text": "\nand",
      "id": "1e2daf8f2d9063e7fe7b41cfb0cd0cdb"
    },
    {
      "type": "html",
      "text": "\nL.C. Briand, J.W. Daly, and J.K. W�st, \"A Unified Framework for Coupling Measurement in Object-Oriented Systems,\" IEEE Trans. Software Eng., vol. 25, no. 1, 1999 (don't know the exact pages)",
      "id": "11fce27293e678693f6325d91b5d7efb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "<i>Anything I can be certain of deducing in a single day can be deduced by a computer program</i>",
      "id": "f5ac47fc9b65ee6e5892211f5ac17cf3"
    },
    {
      "type": "html",
      "text": "\nWell, fortunately for us humans, it ain't necessarily so.  We can look at a class and say whether the instance names and method names are meaningful: computers can't.  We can quickly see whether the class seems to have one function or more than one: computers can't.",
      "id": "75249dc54bf1c2913df609d757ff843e"
    },
    {
      "type": "html",
      "text": "\nThere are some metrics that might be interesting: for example, you could look for duplicate code, or multiple messages sent to the same variable, or messages implemented but never sent.  You could identify how many classes do not have [[Unit Test]]s.",
      "id": "d8f346b6339df3b431663c9fe439bf7e"
    },
    {
      "type": "html",
      "text": "\nThe \"only\" metrics that matter to [[Extreme Programming]] are things like the number of [[Unit Test]]s and the [[Functional Test]] scores (Quality), your Resource levels, the number of cards done (Scope), whether you are working overtime (Time).  Many of us like to know other things, like number of classes and methods over time, average number of methods per class, average number of lines per method.  Once I actually used lines per method to find some bad code to look at ... but 99 times out of 100, the code metrics we've done have been literally useless. ",
      "id": "2ca6125003057554014dc8cc1a48dc39"
    },
    {
      "type": "html",
      "text": "\nI'm sure some folks will disagree strongly on this topic. Let's hear it, \"some folks\"!",
      "id": "59248fe3458a10d673f152b7f40c4676"
    },
    {
      "type": "html",
      "text": "-- [[Ron Jeffries]]",
      "id": "1e746648e595966c7dbb5fadba59bf9f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "\nJust a thought.  If [[The Source Code Is The Design]] and programming is designing, then I want to know whether electrical and mechanical engineers use metrics to evaluate their ability to create detailed designs in a particular amount of time, or whether this is just one of software's petty masochisms. -- [[Michael Feathers]]",
      "id": "e9031be4d53cd84c0bb9a4beae23ea88"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "\nAs far as software metrics go, I am interested in only a few measurements:",
      "id": "d0db76c02c8a9b4ad68c7dd189d1de9f"
    },
    {
      "type": "html",
      "text": "Time on task",
      "id": "284fb3cc2e6c9a118d70974895e18868"
    },
    {
      "type": "html",
      "text": "LOC",
      "id": "b24d9b91890e87ae81db6a5a609039b5"
    },
    {
      "type": "html",
      "text": "Defects",
      "id": "fc102ff808293fa3769b54b3c76dcbc7"
    },
    {
      "type": "html",
      "text": "(these are basically what PSP gathers)",
      "id": "98167973f125d45437fac01c4b098d60"
    },
    {
      "type": "html",
      "text": "\nWhat I need more than anything in the world is a way that I can collect this information reliably as I work without having to slow down excessively.  I already face the fact that management does not feel that metrics have anything to offer us in our environment so I have to quickly prove their value.",
      "id": "75381a2ee647b8508dfce9311d45a380"
    },
    {
      "type": "html",
      "text": "\nAnybody want to jump in and give me some advice?  I'm very willing to share my results with the community.",
      "id": "fbbd02b98353f9597b01fa53c0513a4d"
    },
    {
      "type": "html",
      "text": "-- [[Jake Watkins]]",
      "id": "73aed842c7b8970aba5c5b7db1139287"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "I was recently trying to get a handle on some new code (that is, old code that was new to me). People had pride in this old code, and I wanted a few measures that could be used to quantify some of my uneasiness. I didn't have and fancy tools, so I want for something very simple: LOC per class",
      "id": "fc21492736fefab0961418a4f4ecea0d"
    },
    {
      "type": "html",
      "text": "\nThis is obtained very easily. in C++, I got number of classes (in a package) as",
      "id": "cdd348dfe0ee86c8dac38280f68b882c"
    },
    {
      "type": "code",
      "text": " grep <dir>/*.h \"class \" | grep -v \\; | wc -l",
      "id": "ae233508f38b95e8903ac4e26920ee55"
    },
    {
      "type": "html",
      "text": "\nand LOC as",
      "id": "7749552124be5f639bd4e613de5611bc"
    },
    {
      "type": "code",
      "text": " cat <dir>/*.cc | wc -l",
      "id": "b4f5a43deef1aa249b521b4b21c61d66"
    },
    {
      "type": "html",
      "text": "\nWhen expressed as a ratio, I found that the code I had felt comfortable with had a ratio of about 200 LOC/class and the less good had about 800 LOC/class. The 'better' code also had more whitespace, so the ratios underestimate the difference.",
      "id": "36529932e36ade141afac6af9a9fe87d"
    },
    {
      "type": "html",
      "text": "\nThese figures served their purpose, which was simply to seed a discussion. Is this a useful metric more generally?",
      "id": "0ccad665fb20255756bf128117fee270"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "\nIn automotive software we haven't found metrics useful, beyond our continual need to be aware of code and data size and execution speed.  There are some pretty horrific measures of complexity, which we like to see small, but we don't enforce it after the event (which is the only time you can get the metrics), because we encourage practices which lead to non-complex code.",
      "id": "ceef72629d68c6b01be84b1b03be38df"
    },
    {
      "type": "html",
      "text": "\nWhen I was at Rover Group, I invented a very simple metric for prioritising tests.  Our overall process was: design it, code it, check it on the bench, check it in a vehicle, do formal white box tests (using ICE), release it.  The theory was that some stuff was more likely to be buggy than some other stuff, and I decided that more complexity probably means more chances of bugs.  I 'measured' complexity by multiplying <i>object size</i> in bytes by <i>number of branches</i>.  We then test the big numbers first, and ignore the ones below a threshold.  The down side for you guys is that we were programming in assembler, which makes it trivial to count branches.",
      "id": "7ed01640ae85084b59d14495858151c5"
    },
    {
      "type": "html",
      "text": "\nWhen I look at the ideas espoused by XP, I see most benefit for me in the concept of writing the tests first, then writing code to pass the tests.  The main difference I see is that you seem to be using the tests to confirm that the code is correct.  I always write tests in an attempt to break the code.  I'm then only happy if I fail to break the code.  I've read somewhere else around here that your end users are more interested in the service they get (presumably in response to bug reports) than in whether there are any bugs in the shipped product.  I can't afford to ship product with any bugs <b>at all</b> -- peoples lives may depend on it -- which means I have to take what you've done and massage it into a form suitable for safety critical development.",
      "id": "2fc9081007672ab502db6859827bbccf"
    },
    {
      "type": "html",
      "text": "\nLike it says in my home page, I'm open to ideas...",
      "id": "59dfe776af28ab8c007abc7da64de0a3"
    },
    {
      "type": "html",
      "text": "-- <i>[[Paul Tiplady]], 2000/07/14</i>",
      "id": "f165fdfbfdf406f0418cb1c15a0f6c09"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "\nSoftware is about risks, threats, and iterators that tell you where to find risks or threats next.  If you didn't think there were any cogent risks or threats, you wouldn't have a computer in front of you, you'd just be doing the job without it's \"help\".  Software is a negative abstraction activity - it removes doubt, it doesn't add anything... if you make the user pay attention to something he could have ignored, you have just increased the danger. -- Craig Hubley, 2002/07/26",
      "id": "dc2d82c2a98b1baf051af060776180da"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "\nThe key evaluation criteria for any project, software or otherwise, is \"does it increase productivity?\"  When the current software is eventually replaced, did it cost less to develop and maintain the software than to not use the software and hire additional operational personnel instead.  This is essentially what projects try to predict with a Cost-Benefit Analysis, unfortunately \"costs\" and \"benefits\" are highly subjective and there is not an agreed upon measurement system for either, but some imperfect surrogates could be defined.  The key issue, is that \"costs\" come from the development side and \"benefits\" comes from the operations side.  Any software metric needs to compare changes on the development side with changes on the operations side.  Any metric that only considers the development side (which is true of most so-call software metrics), is not useful.  -- [[Wayne Mack]] ",
      "id": "8883e89098322b7859e714c0423105c9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "\nOften I find projects struggling because the definition of project success was too narrow (features delivered on time, usually). As nasty as metrics can be, they can help to build a broader and more balanced picture of progress, taking into account factors like maintainability, total cost of ownership, organisational learning and so on. The danger with metrics is that you often get what you measure, so their design and implementation - as well as how they're acted upon - need to be refined along with the code itself.",
      "id": "e780a89f0f50225cc13c105e8ec62a0a"
    },
    {
      "type": "html",
      "text": "\nJason Gorman",
      "id": "1532594c52793d6bbcb829d7ca03f3a4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5b9b3514b2238b820818a081da872727"
    },
    {
      "type": "html",
      "text": "See [[Are These Metrics]] [[Category Metrics]]",
      "id": "632ec078e4e0d3278de2086adce20005"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?SoftwareMetrics c2.com]",
      "id": "3b3bff04e7b5b42d4a928e438f0c3ddb"
    }
  ],
  "journal": [
    {
      "date": 1278249247000,
      "id": "4723f763d721d5ccf121a80a58fddeb1",
      "type": "create",
      "item": {
        "title": "Software Metrics",
        "story": [
          {
            "type": "html",
            "text": "Much has been written about software metrics from a product point of view.  This author (craig@hubley.com) considers the most useful metrics to be those which measure the degree to which the software development effort reflects the priorities of its end users and funders, not necessarily in that order.",
            "id": "6d554a588af007e9647f3ca24e4359a1"
          },
          {
            "type": "html",
            "text": "\nSome such useful metrics include the 'churn' of a project, which is the percentage of lines of code written that are changed before (next) release, and the 'dross' of a project, which is the number of lines which are never executed or omitted before release.  A more technical metric, measuring the cohesion of the source code, is the number of places in the code body that a programmer must reference and/or change while making what he, psychologically, considers to be 'one bug fix' or 'one change'.",
            "id": "f42eced49f82cb15c22b9fa915063c9f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "<b>Overview of [[Software Metrics]]</b>",
            "id": "b02813ba410b1db44c18017781a41639"
          },
          {
            "type": "html",
            "text": "[[System Size Metrics]]",
            "id": "fd98c1e92891d55789bdb8c790d2ff82"
          },
          {
            "type": "html",
            "text": "[[Lines Of Code]]",
            "id": "8e7075ffd4b5c990da69a75d5e95fc33"
          },
          {
            "type": "html",
            "text": "[[Function Count]]",
            "id": "f98e2b951f16cbee214c31d754c59774"
          },
          {
            "type": "html",
            "text": "[[Function Point]]s",
            "id": "028ae8b1f377a9b1fae403cc5c319b62"
          },
          {
            "type": "html",
            "text": "[[Number Of Files]] ",
            "id": "228340fd4450dde016b7f7e6a7e0679c"
          },
          {
            "type": "html",
            "text": "[[Object Oriented Metrics]]",
            "id": "48c2e81e5083c0cc57628ea82026fc80"
          },
          {
            "type": "html",
            "text": "[[Number Of Classes]]",
            "id": "8b24160eab8246600f58cf440c493036"
          },
          {
            "type": "html",
            "text": "NumberIfChildCLasses",
            "id": "c959b5351186c72813f6e39e40186c0e"
          },
          {
            "type": "html",
            "text": "[[Number Of Return Points]]",
            "id": "ecdb88ddfe6521b40e61d94b495d3b67"
          },
          {
            "type": "html",
            "text": "[[Depth Of Inheritance Tree]] ",
            "id": "89a41fcc0570b69a210a66135375f864"
          },
          {
            "type": "html",
            "text": "[[Complexity Metrics]]",
            "id": "3bfac5b1abbf4a947330b38c21d22b5f"
          },
          {
            "type": "html",
            "text": "[[Boolean Expression Complexity]]",
            "id": "90c0c247a75049180667836c25d7f5e4"
          },
          {
            "type": "html",
            "text": "[[Class Data Abstraction Coupling]]",
            "id": "deb0d8cbcdd76550f367303d7b5099f6"
          },
          {
            "type": "html",
            "text": "[[Class Fan Out Complexity]]",
            "id": "8b25807cd9281ee665167d443cdb2187"
          },
          {
            "type": "html",
            "text": "[[Cyclomatic Complexity]]",
            "id": "eae3afaff086a4dfccf4af73006c4964"
          },
          {
            "type": "html",
            "text": "[[Function Interface Complexity]] ",
            "id": "1fc6e5363c0aa4e1b241ad48e57ddcc2"
          },
          {
            "type": "html",
            "text": "NPathComplexity",
            "id": "77a5a67a42844a5bbd7538315161af18"
          },
          {
            "type": "html",
            "text": "[[Quality Metrics]]",
            "id": "0c1e4f5f6cee5dce575c1b7e57ddfff7"
          },
          {
            "type": "html",
            "text": "[[Design Velocity]]",
            "id": "969037fcbd6c75c006fbdce4e41fd43c"
          },
          {
            "type": "html",
            "text": "[[Running Tested Features]]",
            "id": "84bdf9869dfb1b961a7bf5f4c8b74c20"
          },
          {
            "type": "html",
            "text": "[[Shodan Input Metric]]",
            "id": "62cc5356efd21ac001f38390c8e10c03"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "I want both Agility and the spirit of ISO and CMMI.  I want lightweight metrics that are practical for a small informal team.  They should be concrete, concise, and unbiased.",
            "id": "6a953b419cfa79939a7f06f55af5d339"
          },
          {
            "type": "html",
            "text": "\nMy small team at IBM has worked with Laurie Williams at NC State over the last year to measure our XP project.  We found we improved our defect injection rate by a factor of two.  But more importantly, we came up with a measurement framework for anyone who wants to replicate our study.",
            "id": "550da532c58c6beed6cc128c4423867b"
          },
          {
            "type": "html",
            "text": "\nWe give you [[Xp Evaluation Framework]].  Please let me know if you have feedback or suggestions.  You don't have to use it, but if you're looking for ideas on what to measure it may helpful to you. I plan to continue to use it on my projects.",
            "id": "aa178b1f00feee3e63273a4beb298588"
          },
          {
            "type": "html",
            "text": "\n[[Bill Krebs]]",
            "id": "260b6ad6e66551b6190500ff72770c45"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "\nGoing a bit afield from the first paragraph above, ... a vastly more general (and therefore vague question): What is the role of metrics in ideal software development ? ",
            "id": "a88a1acfee1184f6d1ffeb78099d8925"
          },
          {
            "type": "html",
            "text": "\nThe motivation for this question is simple: I want to be a  better programmer. How do I get there ? Well, some of the  standard wiki answers (deduced from recent traffic here and  some more general desiderata) might include:",
            "id": "9ea7a5aa76d6c6c3cf9549212ccc4ef5"
          },
          {
            "type": "html",
            "text": " Write programs. Becoming better involves experience",
            "id": "3fbc66c8d572fa3137b970393288a794"
          },
          {
            "type": "html",
            "text": " Reflect upon your code. Strive to understand what worked and what didn't.",
            "id": "dcd4cbcba648d4b06077e2b285c1583e"
          },
          {
            "type": "html",
            "text": " Read Tomes of Lore. These range from generic OO (Booch or Meyer) to language specific (Coplien or Beck) to project-type specific (Greenspun) to patterns (the PLOPs) to ...",
            "id": "f1c833c667fb0a815e5ea7895839fdb2"
          },
          {
            "type": "html",
            "text": " Practice [[Extreme Programming]]",
            "id": "322fdb8c3382cc633f64ad4dd21f1a4d"
          },
          {
            "type": "html",
            "text": " Perform [[Unit Test]]s",
            "id": "7d965d0cb7452ba8c5404737aa606ad6"
          },
          {
            "type": "html",
            "text": "\nBut the question remains: What is it that these things do ? If I  hand you an application (both source and executable), it should  take under a day to get an idea of the author's skill levels and whether the code is any good (which is not the same as whether the program is any good or whether the requirements were met or ...).",
            "id": "20d1af0c0d1f5bc5b87eb63651207b1e"
          },
          {
            "type": "html",
            "text": "\nWhich means that, in principle, there ought to be tools that can measure this as well (based on the general principle that  <i>Anything I can be certain of deducing in a single day can be deduced by a computer program</i> )",
            "id": "3869b93fa92fcba7c3d583d41ac4e1ec"
          },
          {
            "type": "html",
            "text": "\nThis, I think, is the idea behind metrics. Or, at least, one of the ideas.",
            "id": "369ae93762ae788141042dd88b1d4e26"
          },
          {
            "type": "html",
            "text": "\nBut, it seems to me, in all the talk here, formal metrics don't  appear much. Can the benefits of [[Refactor Mercilessly]] be put in terms of metrics ? Are there general heuristics for doing  so ? The [[Law Of Demeter]] seems to be somewhat measurable. But what about the other practices espoused on Wiki ?",
            "id": "a927fcd9d1097a64db3193fa73ee0f55"
          },
          {
            "type": "html",
            "text": "\nAs I said, a vague question. But I seem to be getting more interested in metrics these days and so I thought I'd ask.",
            "id": "6713568b28fcb056295fb65d9e377ea2"
          },
          {
            "type": "html",
            "text": "-- [[William Grosso]]",
            "id": "9fb2952df371244b035ddb58a8b31e0b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "Refactoring improves coupling and cohesion. This can be measured. The tool [[Pattern Lint]] [1] helps pinpoint some kinds of design warts by weighting static and dynamic object communication and comparing them. Two papers accessible from the above link have some examples. -- [[Aamod Sane]]",
            "id": "a0c8a2a3fbca098272f9ba2c08900aa6"
          },
          {
            "type": "html",
            "text": "<i>Aamod - are you asserting that it is possible to measure coupling and (especially) cohesion mechanically?  I wouldn't have thought so; have you a reference? --[[Ron Jeffries]]</i>",
            "id": "c4fa523f19714f781fb31ba53c38fafd"
          },
          {
            "type": "html",
            "text": "\nS.R. Chidamber and C.F. Kemerer, \"A Metrics Suite for Object Oriented Design,\" IEEE Trans. Software Eng., vol. 20, no. 6, pp. 476-493, 1994",
            "id": "0d7bca0c1d1e015e09277ccb7c78100e"
          },
          {
            "type": "html",
            "text": "\nand",
            "id": "1e2daf8f2d9063e7fe7b41cfb0cd0cdb"
          },
          {
            "type": "html",
            "text": "\nL.C. Briand, J.W. Daly, and J.K. W�st, \"A Unified Framework for Coupling Measurement in Object-Oriented Systems,\" IEEE Trans. Software Eng., vol. 25, no. 1, 1999 (don't know the exact pages)",
            "id": "11fce27293e678693f6325d91b5d7efb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "<i>Anything I can be certain of deducing in a single day can be deduced by a computer program</i>",
            "id": "f5ac47fc9b65ee6e5892211f5ac17cf3"
          },
          {
            "type": "html",
            "text": "\nWell, fortunately for us humans, it ain't necessarily so.  We can look at a class and say whether the instance names and method names are meaningful: computers can't.  We can quickly see whether the class seems to have one function or more than one: computers can't.",
            "id": "75249dc54bf1c2913df609d757ff843e"
          },
          {
            "type": "html",
            "text": "\nThere are some metrics that might be interesting: for example, you could look for duplicate code, or multiple messages sent to the same variable, or messages implemented but never sent.  You could identify how many classes do not have [[Unit Test]]s.",
            "id": "d8f346b6339df3b431663c9fe439bf7e"
          },
          {
            "type": "html",
            "text": "\nThe \"only\" metrics that matter to [[Extreme Programming]] are things like the number of [[Unit Test]]s and the [[Functional Test]] scores (Quality), your Resource levels, the number of cards done (Scope), whether you are working overtime (Time).  Many of us like to know other things, like number of classes and methods over time, average number of methods per class, average number of lines per method.  Once I actually used lines per method to find some bad code to look at ... but 99 times out of 100, the code metrics we've done have been literally useless. ",
            "id": "2ca6125003057554014dc8cc1a48dc39"
          },
          {
            "type": "html",
            "text": "\nI'm sure some folks will disagree strongly on this topic. Let's hear it, \"some folks\"!",
            "id": "59248fe3458a10d673f152b7f40c4676"
          },
          {
            "type": "html",
            "text": "-- [[Ron Jeffries]]",
            "id": "1e746648e595966c7dbb5fadba59bf9f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "\nJust a thought.  If [[The Source Code Is The Design]] and programming is designing, then I want to know whether electrical and mechanical engineers use metrics to evaluate their ability to create detailed designs in a particular amount of time, or whether this is just one of software's petty masochisms. -- [[Michael Feathers]]",
            "id": "e9031be4d53cd84c0bb9a4beae23ea88"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "\nAs far as software metrics go, I am interested in only a few measurements:",
            "id": "d0db76c02c8a9b4ad68c7dd189d1de9f"
          },
          {
            "type": "html",
            "text": "Time on task",
            "id": "284fb3cc2e6c9a118d70974895e18868"
          },
          {
            "type": "html",
            "text": "LOC",
            "id": "b24d9b91890e87ae81db6a5a609039b5"
          },
          {
            "type": "html",
            "text": "Defects",
            "id": "fc102ff808293fa3769b54b3c76dcbc7"
          },
          {
            "type": "html",
            "text": "(these are basically what PSP gathers)",
            "id": "98167973f125d45437fac01c4b098d60"
          },
          {
            "type": "html",
            "text": "\nWhat I need more than anything in the world is a way that I can collect this information reliably as I work without having to slow down excessively.  I already face the fact that management does not feel that metrics have anything to offer us in our environment so I have to quickly prove their value.",
            "id": "75381a2ee647b8508dfce9311d45a380"
          },
          {
            "type": "html",
            "text": "\nAnybody want to jump in and give me some advice?  I'm very willing to share my results with the community.",
            "id": "fbbd02b98353f9597b01fa53c0513a4d"
          },
          {
            "type": "html",
            "text": "-- [[Jake Watkins]]",
            "id": "73aed842c7b8970aba5c5b7db1139287"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "I was recently trying to get a handle on some new code (that is, old code that was new to me). People had pride in this old code, and I wanted a few measures that could be used to quantify some of my uneasiness. I didn't have and fancy tools, so I want for something very simple: LOC per class",
            "id": "fc21492736fefab0961418a4f4ecea0d"
          },
          {
            "type": "html",
            "text": "\nThis is obtained very easily. in C++, I got number of classes (in a package) as",
            "id": "cdd348dfe0ee86c8dac38280f68b882c"
          },
          {
            "type": "code",
            "text": " grep <dir>/*.h \"class \" | grep -v \\; | wc -l",
            "id": "ae233508f38b95e8903ac4e26920ee55"
          },
          {
            "type": "html",
            "text": "\nand LOC as",
            "id": "7749552124be5f639bd4e613de5611bc"
          },
          {
            "type": "code",
            "text": " cat <dir>/*.cc | wc -l",
            "id": "b4f5a43deef1aa249b521b4b21c61d66"
          },
          {
            "type": "html",
            "text": "\nWhen expressed as a ratio, I found that the code I had felt comfortable with had a ratio of about 200 LOC/class and the less good had about 800 LOC/class. The 'better' code also had more whitespace, so the ratios underestimate the difference.",
            "id": "36529932e36ade141afac6af9a9fe87d"
          },
          {
            "type": "html",
            "text": "\nThese figures served their purpose, which was simply to seed a discussion. Is this a useful metric more generally?",
            "id": "0ccad665fb20255756bf128117fee270"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "\nIn automotive software we haven't found metrics useful, beyond our continual need to be aware of code and data size and execution speed.  There are some pretty horrific measures of complexity, which we like to see small, but we don't enforce it after the event (which is the only time you can get the metrics), because we encourage practices which lead to non-complex code.",
            "id": "ceef72629d68c6b01be84b1b03be38df"
          },
          {
            "type": "html",
            "text": "\nWhen I was at Rover Group, I invented a very simple metric for prioritising tests.  Our overall process was: design it, code it, check it on the bench, check it in a vehicle, do formal white box tests (using ICE), release it.  The theory was that some stuff was more likely to be buggy than some other stuff, and I decided that more complexity probably means more chances of bugs.  I 'measured' complexity by multiplying <i>object size</i> in bytes by <i>number of branches</i>.  We then test the big numbers first, and ignore the ones below a threshold.  The down side for you guys is that we were programming in assembler, which makes it trivial to count branches.",
            "id": "7ed01640ae85084b59d14495858151c5"
          },
          {
            "type": "html",
            "text": "\nWhen I look at the ideas espoused by XP, I see most benefit for me in the concept of writing the tests first, then writing code to pass the tests.  The main difference I see is that you seem to be using the tests to confirm that the code is correct.  I always write tests in an attempt to break the code.  I'm then only happy if I fail to break the code.  I've read somewhere else around here that your end users are more interested in the service they get (presumably in response to bug reports) than in whether there are any bugs in the shipped product.  I can't afford to ship product with any bugs <b>at all</b> -- peoples lives may depend on it -- which means I have to take what you've done and massage it into a form suitable for safety critical development.",
            "id": "2fc9081007672ab502db6859827bbccf"
          },
          {
            "type": "html",
            "text": "\nLike it says in my home page, I'm open to ideas...",
            "id": "59dfe776af28ab8c007abc7da64de0a3"
          },
          {
            "type": "html",
            "text": "-- <i>[[Paul Tiplady]], 2000/07/14</i>",
            "id": "f165fdfbfdf406f0418cb1c15a0f6c09"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "\nSoftware is about risks, threats, and iterators that tell you where to find risks or threats next.  If you didn't think there were any cogent risks or threats, you wouldn't have a computer in front of you, you'd just be doing the job without it's \"help\".  Software is a negative abstraction activity - it removes doubt, it doesn't add anything... if you make the user pay attention to something he could have ignored, you have just increased the danger. -- Craig Hubley, 2002/07/26",
            "id": "dc2d82c2a98b1baf051af060776180da"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "\nThe key evaluation criteria for any project, software or otherwise, is \"does it increase productivity?\"  When the current software is eventually replaced, did it cost less to develop and maintain the software than to not use the software and hire additional operational personnel instead.  This is essentially what projects try to predict with a Cost-Benefit Analysis, unfortunately \"costs\" and \"benefits\" are highly subjective and there is not an agreed upon measurement system for either, but some imperfect surrogates could be defined.  The key issue, is that \"costs\" come from the development side and \"benefits\" comes from the operations side.  Any software metric needs to compare changes on the development side with changes on the operations side.  Any metric that only considers the development side (which is true of most so-call software metrics), is not useful.  -- [[Wayne Mack]] ",
            "id": "8883e89098322b7859e714c0423105c9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "\nOften I find projects struggling because the definition of project success was too narrow (features delivered on time, usually). As nasty as metrics can be, they can help to build a broader and more balanced picture of progress, taking into account factors like maintainability, total cost of ownership, organisational learning and so on. The danger with metrics is that you often get what you measure, so their design and implementation - as well as how they're acted upon - need to be refined along with the code itself.",
            "id": "e780a89f0f50225cc13c105e8ec62a0a"
          },
          {
            "type": "html",
            "text": "\nJason Gorman",
            "id": "1532594c52793d6bbcb829d7ca03f3a4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5b9b3514b2238b820818a081da872727"
          },
          {
            "type": "html",
            "text": "See [[Are These Metrics]] [[Category Metrics]]",
            "id": "632ec078e4e0d3278de2086adce20005"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?SoftwareMetrics c2.com]",
            "id": "3b3bff04e7b5b42d4a928e438f0c3ddb"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1628162060882
    }
  ]
}