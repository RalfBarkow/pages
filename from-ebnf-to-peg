{
  "title": "From EBNF to PEG",
  "story": [
    {
      "type": "paragraph",
      "id": "42531c0e8c60ef88",
      "text": "[[Parsing Expression Grammar]] ([[PEG]]) encodes a [[recursive-descent parser]] with limited backtracking. The parser has many useful properties, and with the use of [[Memoization]], it works in a linear time. In its appearance, PEG is almost identical to a grammar in Extended Backus-Naur Form ([[EBNF]]), but usually defines a different language."
    },
    {
      "type": "paragraph",
      "id": "13ad5c26869815c7",
      "text": "However, in some cases only minor typographical changes are sufficient to convert an EBNF grammar into its PEG parser. As recently shown by Medeiros, this is, in particular, true for LL(1) grammars. But this is also true for many non-LL(1) grammars, which is interesting because the backtracking of PEG is often a convenient way to circumvent just the LL(1) restriction."
    },
    {
      "type": "paragraph",
      "id": "a1948a15d1e332d2",
      "text": "We formulate a number of conditions for EBNF grammar to become its own PEG parser, and arrive at a condition that we call LL(1p), meaning that a top-down parser can choose its next action by looking at the input within the reach of one parsing procedure (rather than by looking at the next letter). An extension to LL(kp) for k > 1 seems possible."
    },
    {
      "type": "pagefold",
      "id": "ec77ee9e90ba8350",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "80fb73927f1864df",
      "text": "REDZIEJOWSKI, Roman R., 2013. From EBNF to PEG. Fundamenta Informaticae. 1 January 2013. Vol. 128, no. 1–2, p. 177–191. DOI 10.3233/FI-2013-940."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "From EBNF to PEG",
        "story": []
      },
      "date": 1696424947284
    },
    {
      "item": {
        "type": "factory",
        "id": "80fb73927f1864df"
      },
      "id": "80fb73927f1864df",
      "type": "add",
      "date": 1696424950572
    },
    {
      "type": "edit",
      "id": "80fb73927f1864df",
      "item": {
        "type": "paragraph",
        "id": "80fb73927f1864df",
        "text": "REDZIEJOWSKI, Roman R., 2013. From EBNF to PEG. Fundamenta Informaticae. 1 January 2013. Vol. 128, no. 1–2, p. 177–191. DOI 10.3233/FI-2013-940."
      },
      "date": 1696424959730
    },
    {
      "type": "add",
      "id": "42531c0e8c60ef88",
      "item": {
        "type": "paragraph",
        "id": "42531c0e8c60ef88",
        "text": "Parsing Expression Grammar (PEG) encodes a recursive-descent parser with limited backtracking. The parser has many useful properties, and with the use of memoization, it works in a linear time. In its appearance, PEG is almost identical to a grammar"
      },
      "after": "80fb73927f1864df",
      "date": 1696424960184
    },
    {
      "type": "edit",
      "id": "42531c0e8c60ef88",
      "item": {
        "type": "paragraph",
        "id": "42531c0e8c60ef88",
        "text": "Parsing Expression Grammar (PEG) encodes a recursive-descent parser with limited backtracking. The parser has many useful properties, and with the use of memoization, it works in a linear time. In its appearance, PEG is almost identical to a grammar in Extended Backus-Naur Form (EBNF), but usually defines a different language. However, in some cases only minor typographical changes are sufficient to convert an EBNF grammar into its PEG parser. As recently shown by Medeiros, this is, in particular, true for LL(1) grammars. But this is also true for many non-LL(1) grammars, which is interesting because the backtracking of PEG is often a convenient way to circumvent just the LL(1) restriction. We formulate a number of conditions for EBNF grammar to become its own PEG parser, and arrive at a condition that we call LL(1p), meaning that a top-down parser can choose its next action by looking at the input within the reach of one parsing procedure (rather than by looking at the next letter). An extension to LL(kp) for k > 1 seems possible."
      },
      "date": 1696424983646
    },
    {
      "id": "42531c0e8c60ef88",
      "type": "move",
      "order": [
        "42531c0e8c60ef88",
        "80fb73927f1864df"
      ],
      "date": 1696424987007
    },
    {
      "item": {
        "type": "factory",
        "id": "ec77ee9e90ba8350"
      },
      "id": "ec77ee9e90ba8350",
      "type": "add",
      "after": "80fb73927f1864df",
      "date": 1696424989256
    },
    {
      "id": "ec77ee9e90ba8350",
      "type": "move",
      "order": [
        "42531c0e8c60ef88",
        "ec77ee9e90ba8350",
        "80fb73927f1864df"
      ],
      "date": 1696424992292
    },
    {
      "type": "edit",
      "id": "ec77ee9e90ba8350",
      "item": {
        "type": "pagefold",
        "id": "ec77ee9e90ba8350",
        "text": "~"
      },
      "date": 1696424995277
    },
    {
      "type": "edit",
      "id": "42531c0e8c60ef88",
      "item": {
        "type": "paragraph",
        "id": "42531c0e8c60ef88",
        "text": "Parsing Expression Grammar (PEG) encodes a recursive-descent parser with limited backtracking. The parser has many useful properties, and with the use of [[memoization]], it works in a linear time. In its appearance, PEG is almost identical to a grammar in Extended Backus-Naur Form (EBNF), but usually defines a different language. However, in some cases only minor typographical changes are sufficient to convert an EBNF grammar into its PEG parser. As recently shown by Medeiros, this is, in particular, true for LL(1) grammars. But this is also true for many non-LL(1) grammars, which is interesting because the backtracking of PEG is often a convenient way to circumvent just the LL(1) restriction. We formulate a number of conditions for EBNF grammar to become its own PEG parser, and arrive at a condition that we call LL(1p), meaning that a top-down parser can choose its next action by looking at the input within the reach of one parsing procedure (rather than by looking at the next letter). An extension to LL(kp) for k > 1 seems possible."
      },
      "date": 1696425026088
    },
    {
      "type": "edit",
      "id": "42531c0e8c60ef88",
      "item": {
        "type": "paragraph",
        "id": "42531c0e8c60ef88",
        "text": "Parsing Expression Grammar (PEG) encodes a recursive-descent parser with limited backtracking. The parser has many useful properties, and with the use of [[Memoization]], it works in a linear time. In its appearance, PEG is almost identical to a grammar in Extended Backus-Naur Form (EBNF), but usually defines a different language. However, in some cases only minor typographical changes are sufficient to convert an EBNF grammar into its PEG parser. As recently shown by Medeiros, this is, in particular, true for LL(1) grammars. But this is also true for many non-LL(1) grammars, which is interesting because the backtracking of PEG is often a convenient way to circumvent just the LL(1) restriction. We formulate a number of conditions for EBNF grammar to become its own PEG parser, and arrive at a condition that we call LL(1p), meaning that a top-down parser can choose its next action by looking at the input within the reach of one parsing procedure (rather than by looking at the next letter). An extension to LL(kp) for k > 1 seems possible."
      },
      "date": 1696425037510
    },
    {
      "type": "edit",
      "id": "42531c0e8c60ef88",
      "item": {
        "type": "paragraph",
        "id": "42531c0e8c60ef88",
        "text": "[[Parsing Expression Grammar]] ([[PEG]]) encodes a recursive-descent parser with limited backtracking. The parser has many useful properties, and with the use of [[Memoization]], it works in a linear time. In its appearance, PEG is almost identical to a grammar in Extended Backus-Naur Form (EBNF), but usually defines a different language. However, in some cases only minor typographical changes are sufficient to convert an EBNF grammar into its PEG parser. As recently shown by Medeiros, this is, in particular, true for LL(1) grammars. But this is also true for many non-LL(1) grammars, which is interesting because the backtracking of PEG is often a convenient way to circumvent just the LL(1) restriction. We formulate a number of conditions for EBNF grammar to become its own PEG parser, and arrive at a condition that we call LL(1p), meaning that a top-down parser can choose its next action by looking at the input within the reach of one parsing procedure (rather than by looking at the next letter). An extension to LL(kp) for k > 1 seems possible."
      },
      "date": 1696425114960
    },
    {
      "type": "edit",
      "id": "42531c0e8c60ef88",
      "item": {
        "type": "paragraph",
        "id": "42531c0e8c60ef88",
        "text": "[[Parsing Expression Grammar]] ([[PEG]]) encodes a recursive-descent parser with limited backtracking. The parser has many useful properties, and with the use of [[Memoization]], it works in a linear time. In its appearance, PEG is almost identical to a grammar in Extended Backus-Naur Form ([[EBNF]]), but usually defines a different language. However, in some cases only minor typographical changes are sufficient to convert an EBNF grammar into its PEG parser. As recently shown by Medeiros, this is, in particular, true for LL(1) grammars. But this is also true for many non-LL(1) grammars, which is interesting because the backtracking of PEG is often a convenient way to circumvent just the LL(1) restriction. We formulate a number of conditions for EBNF grammar to become its own PEG parser, and arrive at a condition that we call LL(1p), meaning that a top-down parser can choose its next action by looking at the input within the reach of one parsing procedure (rather than by looking at the next letter). An extension to LL(kp) for k > 1 seems possible."
      },
      "date": 1696425142376
    },
    {
      "type": "edit",
      "id": "42531c0e8c60ef88",
      "item": {
        "type": "paragraph",
        "id": "42531c0e8c60ef88",
        "text": "[[Parsing Expression Grammar]] ([[PEG]]) encodes a recursive-descent parser with limited backtracking. The parser has many useful properties, and with the use of [[Memoization]], it works in a linear time. In its appearance, PEG is almost identical to a grammar in Extended Backus-Naur Form ([[EBNF]]), but usually defines a different language."
      },
      "date": 1696425325716
    },
    {
      "type": "add",
      "id": "13ad5c26869815c7",
      "item": {
        "type": "paragraph",
        "id": "13ad5c26869815c7",
        "text": "However, in some cases only minor typographical changes are sufficient to convert an EBNF grammar into its PEG parser. As recently shown by Medeiros, this is, in particular, true for LL(1) grammars. But this is also true for many non-LL(1) grammars, which is interesting because the backtracking of PEG is often a convenient way to circumvent just the LL(1) restriction. We formulate a number of conditions for EBNF grammar to become its own PEG parser, and arrive at a condition that we call LL(1p), meaning that a top-down parser can choose its next action by looking at the input within the reach of one parsing procedure (rather than by looking at the next letter). An extension to LL(kp) for k > 1 seems possible."
      },
      "after": "42531c0e8c60ef88",
      "date": 1696425326746
    },
    {
      "type": "edit",
      "id": "13ad5c26869815c7",
      "item": {
        "type": "paragraph",
        "id": "13ad5c26869815c7",
        "text": "However, in some cases only minor typographical changes are sufficient to convert an EBNF grammar into its PEG parser. As recently shown by Medeiros, this is, in particular, true for LL(1) grammars. But this is also true for many non-LL(1) grammars, which is interesting because the backtracking of PEG is often a convenient way to circumvent just the LL(1) restriction."
      },
      "date": 1696425348425
    },
    {
      "type": "add",
      "id": "a1948a15d1e332d2",
      "item": {
        "type": "paragraph",
        "id": "a1948a15d1e332d2",
        "text": "We formulate a number of conditions for EBNF grammar to become its own PEG parser, and arrive at a condition that we call LL(1p), meaning that a top-down parser can choose its next action by looking at the input within the reach of one parsing procedure (rather than by looking at the next letter). An extension to LL(kp) for k > 1 seems possible."
      },
      "after": "13ad5c26869815c7",
      "date": 1696425349153
    },
    {
      "type": "edit",
      "id": "42531c0e8c60ef88",
      "item": {
        "type": "paragraph",
        "id": "42531c0e8c60ef88",
        "text": "[[Parsing Expression Grammar]] ([[PEG]]) encodes a [[recursive-descent parser]] with limited backtracking. The parser has many useful properties, and with the use of [[Memoization]], it works in a linear time. In its appearance, PEG is almost identical to a grammar in Extended Backus-Naur Form ([[EBNF]]), but usually defines a different language."
      },
      "date": 1696434871400
    }
  ]
}