{
  "title": "Eiffel Language",
  "story": [
    {
      "type": "html",
      "text": "Eiffel is a statically typed, Object Oriented language designed by [[Bertrand Meyer]].  Eiffel features an \n[[Ada Language]]-like syntax, a robust type system, and direct language support for [[Design By Contract]]. Although overlooked by the mainstream programming community, those who actually use it are very excited about it.",
      "id": "734a4849e56f1f3a3308690fc5195c96"
    },
    {
      "type": "html",
      "text": "\nSee [http://www.cetus-links.org/oo_eiffel.html www.cetus-links.org] for info.",
      "id": "854cab4be0768f6f232e725c983d70d6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "\nEiffel separates the developers from the hackers.  The Eiffel language has no dark corners to be explored.  There are no \"Eiffel gurus\".  You can learn the language in a couple of hours, and master it in a day.  Within a week, the act of coding in Eiffel becomes as automatic as the act of typing, and suddenly you no longer think of \"programming\" as being \"the black art of convincing a compiler to turn out your desired object code\".",
      "id": "b0287952f943722dccae3023d763b0d4"
    },
    {
      "type": "html",
      "text": "<i>Wow, this is condescending. Wrong, too, but mainly condescending.</i>",
      "id": "972a9f128aad228910562afe7b05eacc"
    },
    {
      "type": "html",
      "text": "<i>Sure, but there's a big difference between 'learning' a language, and learning to program <b>in</b> that language. You can 'learn' [[Common Lisp]] pretty quickly, but learning to program 'the Lisp way' is a different story. Is Eiffel so un-mind-expanding that there's nothing new to bend your mind around? Or is it just so natural that all of the new concepts it provides are super-intuitive? Or what?</i>",
      "id": "0297ee473b4a114769462d6d23bddc30"
    },
    {
      "type": "html",
      "text": "[Yes, since when do we learn programming languages in a couple of hours. I don't even know English yet, and I've been studying and using it for <i>quite</i> some years. i.e. It's my native language.]",
      "id": "0a01fff4ad3363961ced12dd4286a7ca"
    },
    {
      "type": "html",
      "text": "\nEiffel developers spend most of their time in system design, including design of software contracts. Little time, and almost no conscious thought, needs to go into producing the actual code which implements the design and the contracts. <i>Then why have the code at all? Can't it be auto-generated from the contracts?</i>",
      "id": "e9e0577f081df947449c39c9c5303587"
    },
    {
      "type": "html",
      "text": "\nWhich isn't to say that Eiffel developers don't learn something new about their craft every day.  But instead of fussing over obscure quirks of the language, or how to trick the compiler into doing something, Eiffel developers are studying the available class libraries, investigating design patterns, and learning the ins and outs of writing solid software contracts.",
      "id": "ac3ebd4765441c6b752c9db7b6ce9927"
    },
    {
      "type": "html",
      "text": "\nThose who aspire to be famous as an expert in a language will hate Eiffel.  Those who enjoy designing OO software and have grown weary of compiler-wrestling will love it.",
      "id": "09890520a692410026912e823d9d2ed6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "\"Eiffel separates the developers from the hackers.\" In which case, why is there virtually no finished software *developed* in Eiffel? And thousands of useful programs in C, C++, and Perl? Even exotic's like Erlang and Poplog have actually been used to achieve more.",
      "id": "39a608d035ff962d5cd081ad1eee2048"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "\nI don't think your ignorance about Eiffel really consititutes as fact about the use of Eiffel, there is plenty of Development in Eiffel, only you know nothing about it.",
      "id": "6f5ecb90abd84d69113f8461073fd80d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "<i>What is the situation about case-sensitivity in Eiffel ?  I once got a compiler error for not using ALL_UPPER_CASE in a class name?</i>",
      "id": "fc206665844ead5b472647be49ee795b"
    },
    {
      "type": "html",
      "text": "\nAs defined, Eiffel the language does not care what case you use.  In fact, Eiffel is case-insensitive.  Of the four main Eiffel compilers, only [[Small Eiffel]] (not Meyer's) is case-sensitive by default, and that option can be turned off.",
      "id": "edd7c866b77cc0b2d1878383f9b491fa"
    },
    {
      "type": "html",
      "text": "<i>Eiffel is designed for building systems by integrating components written by multiple third-party vendors and/or projects.  A standard naming convention and [[System Of Names]] is</i> <b>vital</b> <i>for that to be successful.  Look how messy C++ code becomes when you integrate libraries provided by different vendors, compared to Java code where there is has a standard naming convention.  The same holds for Eiffel, having compiler support to help you is a boon.  After all, the more tasks that a machine can do for me, the more time I have to actually design and build the system.</i>",
      "id": "a34d24d50836b0827c0f5ca11ca46970"
    },
    {
      "type": "html",
      "text": "\nIt appears that [[Smart Eiffel]] in 2006 does require all class names to be ALL_UPPER_CASE and I have not been able to find the option to turn this off discussed above. I want to implement some code written in Eiffel about 1998 when this restriction did not apply. I have been searching for information about when Eiffel (or the implementations) changed in order to understand how to adapt the 1998 code. Does anyone know where to find this, or can anyone recommend a different (preferably free) implementation which does not have the restriction. ",
      "id": "3bf22cf457245d59717e8b6b9ae49d02"
    },
    {
      "type": "html",
      "text": "\nI have now had a look at a copy of <i>Eiffel the Language</i> (see lower down) from 1992 which on p.484 definitely gives a <i>guide line</i> that all identifiers, including class names, should be all capital letters. At some time this has become enforced, at least by some compilers.",
      "id": "241a58285103c1a777a7bf4d46ec600d"
    },
    {
      "type": "html",
      "text": "-- [[John Fletcher]]",
      "id": "a9773340e927c8e4054337a0f878f961"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "<i>I have heard most of the above argument applied to several languages. In the latest issue of \"Linux Journal\", Eric Raymond makes a similar argument for Python in the Python supplement. The same argument has been applied to Smalltalk & Java here and in several other places. In conclusion, this seems to be a matter of personal preference.</i>",
      "id": "8537dc4013ea9cfae44b58ad647df3c2"
    },
    {
      "type": "html",
      "text": "<i>One might well assert, however, that it's not </i>true<i> of [[Python Language]], [[Smalltalk Language]], or [[Java Language]].  Certainly it isn't of Java; the API is immense.</i>",
      "id": "c3cd47de4562e5b554da44a5b77085be"
    },
    {
      "type": "html",
      "text": "\nThat's a statement about the <i>libraries</i>, not the <i>language</i>, surely? I think it's good in general for a library to be big. (See [[Large And Small Languages]].) Doubtless the Java libraries could be simplified somewhat while still providing the same facilities, but some degree of complexity is inevitable if you offer a lot of functionality.",
      "id": "0a8304f310800cbe179e173ab611a119"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "Eiffel References:",
      "id": "44ec44d15fc46d3ca94363c6f48188f7"
    },
    {
      "type": "html",
      "text": " <i>Eiffel, the Language</i>, [[Bertrand Meyer]], Prentice Hall, ",
      "id": "f546b1d1e1c6618074ea86b451abebad"
    },
    {
      "type": "image",
      "url": "http://images.amazon.com/images/P/0132479257.01._PE_PI_SCMZZZZZZZ_.jpg",
      "text": "images.amazon.com",
      "id": "13c0ae3ee7ef38c21b42b52edac0f18f"
    },
    {
      "type": "html",
      "text": "\n",
      "id": "26ec5b6e0f1765b6d6a1ee0385f324f0"
    },
    {
      "type": "html",
      "text": "(ISBN 0-13-247925-7).",
      "id": "d0d31efbd2867cba30c7e302a97281cb"
    },
    {
      "type": "html",
      "text": " <i>[[Object Oriented Software Construction]]</i>, [[Bertrand Meyer]],  ",
      "id": "241c2a9ec8d31ae69aef9874b7102eb1"
    },
    {
      "type": "image",
      "url": "http://images.amazon.com/images/P/0136291554.01._PE_PI_SCMZZZZZZZ_.jpg",
      "text": "images.amazon.com",
      "id": "ef0bdb60a72df3f1d248b962c2cf4adb"
    },
    {
      "type": "html",
      "text": "\n",
      "id": "26ec5b6e0f1765b6d6a1ee0385f324f0"
    },
    {
      "type": "html",
      "text": "(ISBN 0136291554).",
      "id": "3852a9de6659373e48ae93ee3c33c981"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "\nEiffel is also 600USD for the pro version, and 2000USD for the enterprise version, unless you're using non-Linux Unix, at which point it becomes 3000/5000. Embedded and VMS are even more...",
      "id": "dacec39d96121e0bbfec88d2babcfe0f"
    },
    {
      "type": "html",
      "text": "\nI've never used Eiffel, but I've heard that sort of argument\nagainst Lisp, for example.  I'm curious: how long would it take\nto recoup the cost of the development environment, if it makes\nthe programmer say, 10% more productive?\nPerhaps [[Free Compilers Are Tragic]]?",
      "id": "951b7789bc624190784bcb1f48c50be7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "There's a free Eiffel to C compiler, GNU Eiffel, usually known as [[Small Eiffel]]. It doesn't support (at least in version -0.79 didn't) loading dynamic libraries, but most of the other stuff was working pretty fine. It produces a really fast code in ANSI C, so it's very portable. [[Small Eiffel]] is written in Eiffel itself, and all the libraries are free. There's a home page at Loria, France[1].",
      "id": "482a44b6191939be8ede8f47c567a33d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "The [[Small Eiffel]] compiler also compiles to java byte code and can call and be called from Java. It is possible to dynamically load java, though not eiffel, libraries.",
      "id": "dc425880620bc6a2f2a12248715aa9c3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "[[Ian Joyner]]'s book [[Objects Unencapsulated]] takes a close, comparitive look at [[Cee Plus Plus]], [[Java Language]] and Eiffel. It is meticulous and very instructive.",
      "id": "2ef235b8112f146f48a8e1492789ccbb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "\nWhen I read [[Object Oriented Software Construction]] 2, I was struck hard by Eiffel's concurrency. It's really nifty. It's based on a distributed computing metaphor: you have a collection of nodes, each of which has a collection of local Eiffel objects and runs with its own single thread of execution. Since there is one thread per node, there are no local synchronisation issues - it's only inter-node (\"remote\") calls that require synchronisation. This is where it gets clever and interesting.",
      "id": "03338bdfd473492002970cc8ad2eab32"
    },
    {
      "type": "html",
      "text": "\nWhen you make a call to a remote object, its preconditions are interpreted not as \"crash if they aren't satisfied\", but as \"wait until they are satisfied\", so your call is queued until the object you're calling is in a position to answer your request. In other words, how does Eiffel handle synchronisation? In exactly the same way that it handles correctness. Very elegant.",
      "id": "c20f96be92d8be29fe771de30963fa6d"
    },
    {
      "type": "html",
      "text": "\nFor example, if you're asking for the <i>top</i> element of a remote <i>QUEUE</i> object, but it's empty and this query has the precondition <i>not empty</i>, then you have to block. Sooner or later, somebody else on another node calls that <i>QUEUE</i>'s <i>enqueue</i> method, which has a postcondition of <i>not empty</i>. So now the queue isn't empty, so our query for its top element can finally proceed--and it does.",
      "id": "4ae6c9e561d141ee9314f4801a97f9f7"
    },
    {
      "type": "html",
      "text": "\nSo what does your node do when its calls to other nodes are waiting on preconditions, sit around twiddling its thumbs and browsing [[Recent Changes]]? Surely not! As any devoted Eiffel programmer knows, each method does only one of two things: report information about an object (<i>query</i>), or change an object (<i>command</i>). If I've sent a few <i>commands</i> to a queue object on another node, there's no compelling reason for me to wait around for it to acknowledge them before continuing - I can run off and do a whole lot of useful local computation that's completely independent of the remote queue. So Eiffel uses a scheme called <i>wait by necessity</i> which says that <i>commands</i> can be dispatched asynchronously, and we just need to maintain an invariant: before a <i>query</i> is executed on a remote object, all of our previous <i>commands</i> must have already been processed, and in the same order they were issued. That just means that we're lazy about synchronisation, we only get our world views synchronised when there is an immediate need to do so.",
      "id": "85ed5718fb4c8a1045e6dcaacec0e2a0"
    },
    {
      "type": "html",
      "text": "\nThat's how I remember it from reading [[Object Oriented Software Construction]] 2, anyway. It's very unfortunate that (as of a year or two ago) nobody has actually *implemented* this model in an Eiffel compiler. It's a very elegant model, but it's not obvious to this observer whether it would actually work or not.",
      "id": "194c9b5145c431800a49ceb572f96a4f"
    },
    {
      "type": "html",
      "text": "<i>If you're a bona-fide Eiffel programmer, please edit the above to better reflect reality. I particularly dodged the issue of synchronising multiple nodes, because I don't remember how it's done. -- [[Luke Gorrie]]</i>",
      "id": "bf821338959d43e45bb5fa62ef9c86dd"
    },
    {
      "type": "html",
      "text": "\nLooking at it again now, I see that Eiffel's concurrency model, like Erlang's, borrows a lot from [[Communicating Sequential Processes]].",
      "id": "2b1b95a4f89bbb818390a96a1738618f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "\nBy the way, is still Eiffel type-unsafe because of argument covariance? And are Eiffel proponents still claiming it as \"the purest of 'em all\"? I'm just curious, because I don't have the money and the time necessary to further investigate myself.",
      "id": "7ac62a0ddccaa6cfabf547009bd3d277"
    },
    {
      "type": "html",
      "text": "<i>Money is not necessary: [[Small Eiffel]] is free (as in beer and speech).  Time is not much of an issue either: the entire Eiffel language can be learnt in half a day of programming, including all Eiffel-specific idioms.</i>",
      "id": "37ca1167c7850d121c3e185631620482"
    },
    {
      "type": "html",
      "text": "\nNote: half a day of <i>programming</i>, not half a day of skimming language specs.",
      "id": "d876aa4e8ee4ed9bac34901db9558aad"
    },
    {
      "type": "html",
      "text": "Sounds [[Too Good To Be True]]. Why teach children English in school if this two hour kindergarten graduate class is available? ",
      "id": "a3cf7329cbfcf8d24555ab3e1a247b45"
    },
    {
      "type": "html",
      "text": "<i>Argument covariance has not been removed from the language... even if it were, Eiffel allows features defined in base classes to be removed (or renamed and not replace) in derived classes, so argument covariance is the least of the problems with Eiffel's type system. </i>",
      "id": "059f9a6757fb9e00827ef4aeb5061a2c"
    },
    {
      "type": "html",
      "text": "<i>What's worse--in some implementations, at least, these type holes caused [[Undefined Behavior]] as opposed to a controlled [[Runtime Exception]].</i>",
      "id": "e45318941c897148b705a899f772e4f3"
    },
    {
      "type": "html",
      "text": "''For more info, see the Eiffel faq at [http://www.faqs.org/faqs/eiffel-faq/ www.faqs.org].  ",
      "id": "4df6efc01e290edb2f56246c8e47a2a1"
    },
    {
      "type": "html",
      "text": "<i>In [[Object Oriented Software Construction]], an interesting proposal (in some minds, a grotesque hack) called [[No Polymorphic Catcalls]] has been proposed.  Essentially, the proposal calls for allowing method (\"feature\" in Eiffel nomenclature) calls of the form f.x(), where f is a reference to a base class object, only if there are no derived classes in the system which has redefined x() in such a way that a call allowed by the base class preconditions might fail (including undefining the feature), OR when it can be proven that the dynamic type of f is not one of the classes that redefine x() in the manner described above.</i>",
      "id": "f5e2202bab069118fc6c8b12db136094"
    },
    {
      "type": "html",
      "text": "<i>This has the unfortunate properties that a) an entire system must be analyzed to determine whether a call is legal or not, and b) adding a derived class to the system, even if not used (or used only in a limited context) can <b>break existing code</b> (i.e. cause it to not compile anymore.)</i>",
      "id": "02ea0c3ca6885c013f5073529bac7b50"
    },
    {
      "type": "html",
      "text": "<i>Why [[Eiffel Language]] just doesn't specfiy dynamic typechecks in these cases (i.e, if a derived class feature has covariant arguments or reduced visibility, it automatically gets a runtime type check) is beyond me.  [[Bertrand Meyer]] analyzes several other solutions, but doesn't even consider this one in [[Object Oriented Software Construction]].  He seems to have an allergic reaction to dynamic typechecks of any sort (and is harsh in his criticism of [[Dynamic Typing]]).</i>",
      "id": "149452435996f111486f76e374ab4f6a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "I am investigating usage of Eiffel for developing infrastructure software. I have read the documentation and realize that there is merit in the language features.",
      "id": "e50e8a577c8844b2044586f42e54278e"
    },
    {
      "type": "html",
      "text": "\nIs there any large scale product developed using Eiffel? for example a browser, or a network management system or perhaps a search engine. Is it just that people don't know much about Eiffel and hence don't write software using this *french* language or are there are some sound technical reasons why this cannot be done?",
      "id": "cbba039ef2db67fc794ecee7609c5d42"
    },
    {
      "type": "html",
      "text": "\nIf one wrote a broswer (with equivalent capabilities as in [[Hot Java]] Browser) in Eiffel vis-a-vis in C++, will the eiffel application run faster? have a better GUI?\nwill have less crashes? will be internationalizable?",
      "id": "45dcac7edc8d191893ff5019cb6d6182"
    },
    {
      "type": "html",
      "text": "\nHow does one implement Networking libraries in Eiffel if one wants to? Assume that I don't want to use Eiffel networking support, then is there a way to implement the same from scratch?",
      "id": "7a062bf40253346a440f329d3d9d1a93"
    },
    {
      "type": "html",
      "text": "\nAre there any French software companies or research institutions that use Eiffel for their software development requirements?",
      "id": "75a52e00b585ed3017368e38972e1e8e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "\nI can't answer all your questions, but I can lend you my perspective, as I've played around with the language a bit. I really like the language, and its ideas, I just don't like the available implementations. The only free implementation ([[Smart Eiffel]]) kinda sucks. With all the new languages coming out today which are built on technology such as LLVM, JVM, or Parrot, [[Smart Eiffel]]'s compiler which compiles to C code and doesn't support dynamic library loading is kinda an anachronism. You can link to C code and thus load libraries that way, but it's slightly ugly and unwieldy to do so, and the means of doing so is not standard across implementations. ",
      "id": "83fef05555befe4658e0482b06ef6b5a"
    },
    {
      "type": "html",
      "text": "\nI briefly experimented with Meyer's IDE, and it seems to have powerful features, but I don't like the licensing terms. I prefer free tools.",
      "id": "888d52afce30f17a453bd4477bd9b8bf"
    },
    {
      "type": "html",
      "text": "\nI think this is the main reason it hasn't caught on. It's a kick ass language, quite solid IMO, but nobody has come out with an implementation of it that makes enough sense to a large enough group of people. ",
      "id": "0165d81fd97082b724a2a01d4028059b"
    },
    {
      "type": "html",
      "text": "\nThere is a Modern Eiffel project now which I think seeks to address many of these problems.",
      "id": "da89c7a8a0ace9d09a00b4d47093df51"
    },
    {
      "type": "html",
      "text": "\nIf I had to sum up the language's strengths, I would say that it's a good clean sheet OO design which smoothly and logically implements a lot of more advanced OO techniques such as generics, multiple inheritance, design by contract, while implementing them in such a manner that the syntax is always kept clean and easy to read. This is actually the reasoning behind the \"ALL_CAPS\" class name convention (not a forced rule, but Eiffel code not in this style will look strange to you after a while), which is one part of a larger naming scheme. This does make the code much more uniform and readable IMO, and fits right in to the overall theme of simplicity and consistency leading to maintainability. The language is descriptive, and powerful, yet not verbose like Java. Its features definitely make it much more likely that you will spend your time churning out code and thinking about logic instead of fighting with the language, and will likely result in much higher quality code as well. ",
      "id": "272665993910f61478eeb86c0e503a6b"
    },
    {
      "type": "html",
      "text": "\nIf someone comes out with a good Eiffel compiler for LLVM, with dynamic library loading and optionally a simpler way to call external functions, I would love to give the language a second look. ",
      "id": "e8961983612d202f91aad498c59b52a3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "\nFor free Eiffel resources try...",
      "id": "c12bfc42e41108976cfbfbaa6e400b10"
    },
    {
      "type": "html",
      "text": "\n[[Small Eiffel]] is now called [[Smart Eiffel]] and is available here [http://smarteiffel.loria.fr/ smarteiffel.loria.fr]",
      "id": "786d5dc5f6b8604affd7e5a5e3b0c94e"
    },
    {
      "type": "html",
      "text": "\nEiffel Software, Inc. [http://www.eiffel.com/ www.eiffel.com]  As of April 5th, 2006, the compiler is released under a dual GPL/non-free license (in the same style and the same buisness model as the QT library)",
      "id": "43ae182c02e7574756728d818c9f2047"
    },
    {
      "type": "html",
      "text": "\nFrom Object tools [http://www.visual-eiffel.com/ www.visual-eiffel.com] Another free version of their Visual Eiffel.",
      "id": "2926923b4394bf11d44ebc5cb22987aa"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "See also [[Eiffel Sharp Language]], [[Eiffel Unit]]",
      "id": "e97f4c74ed42d83292c1aab31578d387"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3a4c9164ba75a65e016694b735168956"
    },
    {
      "type": "html",
      "text": "[[Category Programming Language]] [[Category Eiffel]]",
      "id": "9cafd28ce8284fb6a088d036b756e4cb"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?EiffelLanguage c2.com]",
      "id": "2bcdaac09499b6bf913239e2ecda53f6"
    }
  ],
  "journal": [
    {
      "date": 1361226116000,
      "id": "b87e6a26ba05d2960756ac115b5dc267",
      "type": "create",
      "item": {
        "title": "Eiffel Language",
        "story": [
          {
            "type": "html",
            "text": "Eiffel is a statically typed, Object Oriented language designed by [[Bertrand Meyer]].  Eiffel features an \n[[Ada Language]]-like syntax, a robust type system, and direct language support for [[Design By Contract]]. Although overlooked by the mainstream programming community, those who actually use it are very excited about it.",
            "id": "734a4849e56f1f3a3308690fc5195c96"
          },
          {
            "type": "html",
            "text": "\nSee [http://www.cetus-links.org/oo_eiffel.html www.cetus-links.org] for info.",
            "id": "854cab4be0768f6f232e725c983d70d6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "\nEiffel separates the developers from the hackers.  The Eiffel language has no dark corners to be explored.  There are no \"Eiffel gurus\".  You can learn the language in a couple of hours, and master it in a day.  Within a week, the act of coding in Eiffel becomes as automatic as the act of typing, and suddenly you no longer think of \"programming\" as being \"the black art of convincing a compiler to turn out your desired object code\".",
            "id": "b0287952f943722dccae3023d763b0d4"
          },
          {
            "type": "html",
            "text": "<i>Wow, this is condescending. Wrong, too, but mainly condescending.</i>",
            "id": "972a9f128aad228910562afe7b05eacc"
          },
          {
            "type": "html",
            "text": "<i>Sure, but there's a big difference between 'learning' a language, and learning to program <b>in</b> that language. You can 'learn' [[Common Lisp]] pretty quickly, but learning to program 'the Lisp way' is a different story. Is Eiffel so un-mind-expanding that there's nothing new to bend your mind around? Or is it just so natural that all of the new concepts it provides are super-intuitive? Or what?</i>",
            "id": "0297ee473b4a114769462d6d23bddc30"
          },
          {
            "type": "html",
            "text": "[Yes, since when do we learn programming languages in a couple of hours. I don't even know English yet, and I've been studying and using it for <i>quite</i> some years. i.e. It's my native language.]",
            "id": "0a01fff4ad3363961ced12dd4286a7ca"
          },
          {
            "type": "html",
            "text": "\nEiffel developers spend most of their time in system design, including design of software contracts. Little time, and almost no conscious thought, needs to go into producing the actual code which implements the design and the contracts. <i>Then why have the code at all? Can't it be auto-generated from the contracts?</i>",
            "id": "e9e0577f081df947449c39c9c5303587"
          },
          {
            "type": "html",
            "text": "\nWhich isn't to say that Eiffel developers don't learn something new about their craft every day.  But instead of fussing over obscure quirks of the language, or how to trick the compiler into doing something, Eiffel developers are studying the available class libraries, investigating design patterns, and learning the ins and outs of writing solid software contracts.",
            "id": "ac3ebd4765441c6b752c9db7b6ce9927"
          },
          {
            "type": "html",
            "text": "\nThose who aspire to be famous as an expert in a language will hate Eiffel.  Those who enjoy designing OO software and have grown weary of compiler-wrestling will love it.",
            "id": "09890520a692410026912e823d9d2ed6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "\"Eiffel separates the developers from the hackers.\" In which case, why is there virtually no finished software *developed* in Eiffel? And thousands of useful programs in C, C++, and Perl? Even exotic's like Erlang and Poplog have actually been used to achieve more.",
            "id": "39a608d035ff962d5cd081ad1eee2048"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "\nI don't think your ignorance about Eiffel really consititutes as fact about the use of Eiffel, there is plenty of Development in Eiffel, only you know nothing about it.",
            "id": "6f5ecb90abd84d69113f8461073fd80d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "<i>What is the situation about case-sensitivity in Eiffel ?  I once got a compiler error for not using ALL_UPPER_CASE in a class name?</i>",
            "id": "fc206665844ead5b472647be49ee795b"
          },
          {
            "type": "html",
            "text": "\nAs defined, Eiffel the language does not care what case you use.  In fact, Eiffel is case-insensitive.  Of the four main Eiffel compilers, only [[Small Eiffel]] (not Meyer's) is case-sensitive by default, and that option can be turned off.",
            "id": "edd7c866b77cc0b2d1878383f9b491fa"
          },
          {
            "type": "html",
            "text": "<i>Eiffel is designed for building systems by integrating components written by multiple third-party vendors and/or projects.  A standard naming convention and [[System Of Names]] is</i> <b>vital</b> <i>for that to be successful.  Look how messy C++ code becomes when you integrate libraries provided by different vendors, compared to Java code where there is has a standard naming convention.  The same holds for Eiffel, having compiler support to help you is a boon.  After all, the more tasks that a machine can do for me, the more time I have to actually design and build the system.</i>",
            "id": "a34d24d50836b0827c0f5ca11ca46970"
          },
          {
            "type": "html",
            "text": "\nIt appears that [[Smart Eiffel]] in 2006 does require all class names to be ALL_UPPER_CASE and I have not been able to find the option to turn this off discussed above. I want to implement some code written in Eiffel about 1998 when this restriction did not apply. I have been searching for information about when Eiffel (or the implementations) changed in order to understand how to adapt the 1998 code. Does anyone know where to find this, or can anyone recommend a different (preferably free) implementation which does not have the restriction. ",
            "id": "3bf22cf457245d59717e8b6b9ae49d02"
          },
          {
            "type": "html",
            "text": "\nI have now had a look at a copy of <i>Eiffel the Language</i> (see lower down) from 1992 which on p.484 definitely gives a <i>guide line</i> that all identifiers, including class names, should be all capital letters. At some time this has become enforced, at least by some compilers.",
            "id": "241a58285103c1a777a7bf4d46ec600d"
          },
          {
            "type": "html",
            "text": "-- [[John Fletcher]]",
            "id": "a9773340e927c8e4054337a0f878f961"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "<i>I have heard most of the above argument applied to several languages. In the latest issue of \"Linux Journal\", Eric Raymond makes a similar argument for Python in the Python supplement. The same argument has been applied to Smalltalk & Java here and in several other places. In conclusion, this seems to be a matter of personal preference.</i>",
            "id": "8537dc4013ea9cfae44b58ad647df3c2"
          },
          {
            "type": "html",
            "text": "<i>One might well assert, however, that it's not </i>true<i> of [[Python Language]], [[Smalltalk Language]], or [[Java Language]].  Certainly it isn't of Java; the API is immense.</i>",
            "id": "c3cd47de4562e5b554da44a5b77085be"
          },
          {
            "type": "html",
            "text": "\nThat's a statement about the <i>libraries</i>, not the <i>language</i>, surely? I think it's good in general for a library to be big. (See [[Large And Small Languages]].) Doubtless the Java libraries could be simplified somewhat while still providing the same facilities, but some degree of complexity is inevitable if you offer a lot of functionality.",
            "id": "0a8304f310800cbe179e173ab611a119"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "Eiffel References:",
            "id": "44ec44d15fc46d3ca94363c6f48188f7"
          },
          {
            "type": "html",
            "text": " <i>Eiffel, the Language</i>, [[Bertrand Meyer]], Prentice Hall, ",
            "id": "f546b1d1e1c6618074ea86b451abebad"
          },
          {
            "type": "image",
            "url": "http://images.amazon.com/images/P/0132479257.01._PE_PI_SCMZZZZZZZ_.jpg",
            "text": "images.amazon.com",
            "id": "13c0ae3ee7ef38c21b42b52edac0f18f"
          },
          {
            "type": "html",
            "text": "\n",
            "id": "26ec5b6e0f1765b6d6a1ee0385f324f0"
          },
          {
            "type": "html",
            "text": "(ISBN 0-13-247925-7).",
            "id": "d0d31efbd2867cba30c7e302a97281cb"
          },
          {
            "type": "html",
            "text": " <i>[[Object Oriented Software Construction]]</i>, [[Bertrand Meyer]],  ",
            "id": "241c2a9ec8d31ae69aef9874b7102eb1"
          },
          {
            "type": "image",
            "url": "http://images.amazon.com/images/P/0136291554.01._PE_PI_SCMZZZZZZZ_.jpg",
            "text": "images.amazon.com",
            "id": "ef0bdb60a72df3f1d248b962c2cf4adb"
          },
          {
            "type": "html",
            "text": "\n",
            "id": "26ec5b6e0f1765b6d6a1ee0385f324f0"
          },
          {
            "type": "html",
            "text": "(ISBN 0136291554).",
            "id": "3852a9de6659373e48ae93ee3c33c981"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "\nEiffel is also 600USD for the pro version, and 2000USD for the enterprise version, unless you're using non-Linux Unix, at which point it becomes 3000/5000. Embedded and VMS are even more...",
            "id": "dacec39d96121e0bbfec88d2babcfe0f"
          },
          {
            "type": "html",
            "text": "\nI've never used Eiffel, but I've heard that sort of argument\nagainst Lisp, for example.  I'm curious: how long would it take\nto recoup the cost of the development environment, if it makes\nthe programmer say, 10% more productive?\nPerhaps [[Free Compilers Are Tragic]]?",
            "id": "951b7789bc624190784bcb1f48c50be7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "There's a free Eiffel to C compiler, GNU Eiffel, usually known as [[Small Eiffel]]. It doesn't support (at least in version -0.79 didn't) loading dynamic libraries, but most of the other stuff was working pretty fine. It produces a really fast code in ANSI C, so it's very portable. [[Small Eiffel]] is written in Eiffel itself, and all the libraries are free. There's a home page at Loria, France[1].",
            "id": "482a44b6191939be8ede8f47c567a33d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "The [[Small Eiffel]] compiler also compiles to java byte code and can call and be called from Java. It is possible to dynamically load java, though not eiffel, libraries.",
            "id": "dc425880620bc6a2f2a12248715aa9c3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "[[Ian Joyner]]'s book [[Objects Unencapsulated]] takes a close, comparitive look at [[Cee Plus Plus]], [[Java Language]] and Eiffel. It is meticulous and very instructive.",
            "id": "2ef235b8112f146f48a8e1492789ccbb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "\nWhen I read [[Object Oriented Software Construction]] 2, I was struck hard by Eiffel's concurrency. It's really nifty. It's based on a distributed computing metaphor: you have a collection of nodes, each of which has a collection of local Eiffel objects and runs with its own single thread of execution. Since there is one thread per node, there are no local synchronisation issues - it's only inter-node (\"remote\") calls that require synchronisation. This is where it gets clever and interesting.",
            "id": "03338bdfd473492002970cc8ad2eab32"
          },
          {
            "type": "html",
            "text": "\nWhen you make a call to a remote object, its preconditions are interpreted not as \"crash if they aren't satisfied\", but as \"wait until they are satisfied\", so your call is queued until the object you're calling is in a position to answer your request. In other words, how does Eiffel handle synchronisation? In exactly the same way that it handles correctness. Very elegant.",
            "id": "c20f96be92d8be29fe771de30963fa6d"
          },
          {
            "type": "html",
            "text": "\nFor example, if you're asking for the <i>top</i> element of a remote <i>QUEUE</i> object, but it's empty and this query has the precondition <i>not empty</i>, then you have to block. Sooner or later, somebody else on another node calls that <i>QUEUE</i>'s <i>enqueue</i> method, which has a postcondition of <i>not empty</i>. So now the queue isn't empty, so our query for its top element can finally proceed--and it does.",
            "id": "4ae6c9e561d141ee9314f4801a97f9f7"
          },
          {
            "type": "html",
            "text": "\nSo what does your node do when its calls to other nodes are waiting on preconditions, sit around twiddling its thumbs and browsing [[Recent Changes]]? Surely not! As any devoted Eiffel programmer knows, each method does only one of two things: report information about an object (<i>query</i>), or change an object (<i>command</i>). If I've sent a few <i>commands</i> to a queue object on another node, there's no compelling reason for me to wait around for it to acknowledge them before continuing - I can run off and do a whole lot of useful local computation that's completely independent of the remote queue. So Eiffel uses a scheme called <i>wait by necessity</i> which says that <i>commands</i> can be dispatched asynchronously, and we just need to maintain an invariant: before a <i>query</i> is executed on a remote object, all of our previous <i>commands</i> must have already been processed, and in the same order they were issued. That just means that we're lazy about synchronisation, we only get our world views synchronised when there is an immediate need to do so.",
            "id": "85ed5718fb4c8a1045e6dcaacec0e2a0"
          },
          {
            "type": "html",
            "text": "\nThat's how I remember it from reading [[Object Oriented Software Construction]] 2, anyway. It's very unfortunate that (as of a year or two ago) nobody has actually *implemented* this model in an Eiffel compiler. It's a very elegant model, but it's not obvious to this observer whether it would actually work or not.",
            "id": "194c9b5145c431800a49ceb572f96a4f"
          },
          {
            "type": "html",
            "text": "<i>If you're a bona-fide Eiffel programmer, please edit the above to better reflect reality. I particularly dodged the issue of synchronising multiple nodes, because I don't remember how it's done. -- [[Luke Gorrie]]</i>",
            "id": "bf821338959d43e45bb5fa62ef9c86dd"
          },
          {
            "type": "html",
            "text": "\nLooking at it again now, I see that Eiffel's concurrency model, like Erlang's, borrows a lot from [[Communicating Sequential Processes]].",
            "id": "2b1b95a4f89bbb818390a96a1738618f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "\nBy the way, is still Eiffel type-unsafe because of argument covariance? And are Eiffel proponents still claiming it as \"the purest of 'em all\"? I'm just curious, because I don't have the money and the time necessary to further investigate myself.",
            "id": "7ac62a0ddccaa6cfabf547009bd3d277"
          },
          {
            "type": "html",
            "text": "<i>Money is not necessary: [[Small Eiffel]] is free (as in beer and speech).  Time is not much of an issue either: the entire Eiffel language can be learnt in half a day of programming, including all Eiffel-specific idioms.</i>",
            "id": "37ca1167c7850d121c3e185631620482"
          },
          {
            "type": "html",
            "text": "\nNote: half a day of <i>programming</i>, not half a day of skimming language specs.",
            "id": "d876aa4e8ee4ed9bac34901db9558aad"
          },
          {
            "type": "html",
            "text": "Sounds [[Too Good To Be True]]. Why teach children English in school if this two hour kindergarten graduate class is available? ",
            "id": "a3cf7329cbfcf8d24555ab3e1a247b45"
          },
          {
            "type": "html",
            "text": "<i>Argument covariance has not been removed from the language... even if it were, Eiffel allows features defined in base classes to be removed (or renamed and not replace) in derived classes, so argument covariance is the least of the problems with Eiffel's type system. </i>",
            "id": "059f9a6757fb9e00827ef4aeb5061a2c"
          },
          {
            "type": "html",
            "text": "<i>What's worse--in some implementations, at least, these type holes caused [[Undefined Behavior]] as opposed to a controlled [[Runtime Exception]].</i>",
            "id": "e45318941c897148b705a899f772e4f3"
          },
          {
            "type": "html",
            "text": "''For more info, see the Eiffel faq at [http://www.faqs.org/faqs/eiffel-faq/ www.faqs.org].  ",
            "id": "4df6efc01e290edb2f56246c8e47a2a1"
          },
          {
            "type": "html",
            "text": "<i>In [[Object Oriented Software Construction]], an interesting proposal (in some minds, a grotesque hack) called [[No Polymorphic Catcalls]] has been proposed.  Essentially, the proposal calls for allowing method (\"feature\" in Eiffel nomenclature) calls of the form f.x(), where f is a reference to a base class object, only if there are no derived classes in the system which has redefined x() in such a way that a call allowed by the base class preconditions might fail (including undefining the feature), OR when it can be proven that the dynamic type of f is not one of the classes that redefine x() in the manner described above.</i>",
            "id": "f5e2202bab069118fc6c8b12db136094"
          },
          {
            "type": "html",
            "text": "<i>This has the unfortunate properties that a) an entire system must be analyzed to determine whether a call is legal or not, and b) adding a derived class to the system, even if not used (or used only in a limited context) can <b>break existing code</b> (i.e. cause it to not compile anymore.)</i>",
            "id": "02ea0c3ca6885c013f5073529bac7b50"
          },
          {
            "type": "html",
            "text": "<i>Why [[Eiffel Language]] just doesn't specfiy dynamic typechecks in these cases (i.e, if a derived class feature has covariant arguments or reduced visibility, it automatically gets a runtime type check) is beyond me.  [[Bertrand Meyer]] analyzes several other solutions, but doesn't even consider this one in [[Object Oriented Software Construction]].  He seems to have an allergic reaction to dynamic typechecks of any sort (and is harsh in his criticism of [[Dynamic Typing]]).</i>",
            "id": "149452435996f111486f76e374ab4f6a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "I am investigating usage of Eiffel for developing infrastructure software. I have read the documentation and realize that there is merit in the language features.",
            "id": "e50e8a577c8844b2044586f42e54278e"
          },
          {
            "type": "html",
            "text": "\nIs there any large scale product developed using Eiffel? for example a browser, or a network management system or perhaps a search engine. Is it just that people don't know much about Eiffel and hence don't write software using this *french* language or are there are some sound technical reasons why this cannot be done?",
            "id": "cbba039ef2db67fc794ecee7609c5d42"
          },
          {
            "type": "html",
            "text": "\nIf one wrote a broswer (with equivalent capabilities as in [[Hot Java]] Browser) in Eiffel vis-a-vis in C++, will the eiffel application run faster? have a better GUI?\nwill have less crashes? will be internationalizable?",
            "id": "45dcac7edc8d191893ff5019cb6d6182"
          },
          {
            "type": "html",
            "text": "\nHow does one implement Networking libraries in Eiffel if one wants to? Assume that I don't want to use Eiffel networking support, then is there a way to implement the same from scratch?",
            "id": "7a062bf40253346a440f329d3d9d1a93"
          },
          {
            "type": "html",
            "text": "\nAre there any French software companies or research institutions that use Eiffel for their software development requirements?",
            "id": "75a52e00b585ed3017368e38972e1e8e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "\nI can't answer all your questions, but I can lend you my perspective, as I've played around with the language a bit. I really like the language, and its ideas, I just don't like the available implementations. The only free implementation ([[Smart Eiffel]]) kinda sucks. With all the new languages coming out today which are built on technology such as LLVM, JVM, or Parrot, [[Smart Eiffel]]'s compiler which compiles to C code and doesn't support dynamic library loading is kinda an anachronism. You can link to C code and thus load libraries that way, but it's slightly ugly and unwieldy to do so, and the means of doing so is not standard across implementations. ",
            "id": "83fef05555befe4658e0482b06ef6b5a"
          },
          {
            "type": "html",
            "text": "\nI briefly experimented with Meyer's IDE, and it seems to have powerful features, but I don't like the licensing terms. I prefer free tools.",
            "id": "888d52afce30f17a453bd4477bd9b8bf"
          },
          {
            "type": "html",
            "text": "\nI think this is the main reason it hasn't caught on. It's a kick ass language, quite solid IMO, but nobody has come out with an implementation of it that makes enough sense to a large enough group of people. ",
            "id": "0165d81fd97082b724a2a01d4028059b"
          },
          {
            "type": "html",
            "text": "\nThere is a Modern Eiffel project now which I think seeks to address many of these problems.",
            "id": "da89c7a8a0ace9d09a00b4d47093df51"
          },
          {
            "type": "html",
            "text": "\nIf I had to sum up the language's strengths, I would say that it's a good clean sheet OO design which smoothly and logically implements a lot of more advanced OO techniques such as generics, multiple inheritance, design by contract, while implementing them in such a manner that the syntax is always kept clean and easy to read. This is actually the reasoning behind the \"ALL_CAPS\" class name convention (not a forced rule, but Eiffel code not in this style will look strange to you after a while), which is one part of a larger naming scheme. This does make the code much more uniform and readable IMO, and fits right in to the overall theme of simplicity and consistency leading to maintainability. The language is descriptive, and powerful, yet not verbose like Java. Its features definitely make it much more likely that you will spend your time churning out code and thinking about logic instead of fighting with the language, and will likely result in much higher quality code as well. ",
            "id": "272665993910f61478eeb86c0e503a6b"
          },
          {
            "type": "html",
            "text": "\nIf someone comes out with a good Eiffel compiler for LLVM, with dynamic library loading and optionally a simpler way to call external functions, I would love to give the language a second look. ",
            "id": "e8961983612d202f91aad498c59b52a3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "\nFor free Eiffel resources try...",
            "id": "c12bfc42e41108976cfbfbaa6e400b10"
          },
          {
            "type": "html",
            "text": "\n[[Small Eiffel]] is now called [[Smart Eiffel]] and is available here [http://smarteiffel.loria.fr/ smarteiffel.loria.fr]",
            "id": "786d5dc5f6b8604affd7e5a5e3b0c94e"
          },
          {
            "type": "html",
            "text": "\nEiffel Software, Inc. [http://www.eiffel.com/ www.eiffel.com]  As of April 5th, 2006, the compiler is released under a dual GPL/non-free license (in the same style and the same buisness model as the QT library)",
            "id": "43ae182c02e7574756728d818c9f2047"
          },
          {
            "type": "html",
            "text": "\nFrom Object tools [http://www.visual-eiffel.com/ www.visual-eiffel.com] Another free version of their Visual Eiffel.",
            "id": "2926923b4394bf11d44ebc5cb22987aa"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "See also [[Eiffel Sharp Language]], [[Eiffel Unit]]",
            "id": "e97f4c74ed42d83292c1aab31578d387"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3a4c9164ba75a65e016694b735168956"
          },
          {
            "type": "html",
            "text": "[[Category Programming Language]] [[Category Eiffel]]",
            "id": "9cafd28ce8284fb6a088d036b756e4cb"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?EiffelLanguage c2.com]",
            "id": "2bcdaac09499b6bf913239e2ecda53f6"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1707812086376
    }
  ]
}