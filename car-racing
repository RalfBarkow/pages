{
  "title": "Car Racing",
  "story": [
    {
      "type": "paragraph",
      "id": "567a58069cc93fdf",
      "text": "In this example, we define a RaceCar ADT as shown in Figure 4.2. There are three state variables defined in the ADT: _vO, _a, and _v. In view of the motion of uniform acceleration, these represent the initial velocity, the acceleration, and the current velocity, in their standard units respectively. The two modifier methods, ACCELERATE and STOP, apply the rules of uniform acceleration to the state variables. ACCELERATE accelerates the race car for t seconds whereas STOP brings the car to a total stop."
    },
    {
      "type": "paragraph",
      "id": "8e09e44e82cb2f67",
      "text": "The only accessor method for this ADT is GETSPEED which is meant to reveal the current velocity of a car. AlI three methods are public, as they are present in the parameter list. The other two variables in the parameter list are vO and a. They specifiy the initial values for states _vO and _a. Obviously their values need to be provided when the RaceCar ADT is instantiated. This example also shows how domains of type computation are declared. It is important to declare aIl domains in the parameter list of an ADT before the declaration of the ADT itself."
    },
    {
      "type": "pagefold",
      "id": "2e72790e936d77c2",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "093d7dd59c1fde8b",
      "text": "ZHENG, Yi, 2002. Abstract data types and extended domain operations in a nested relational algebra.  [https://escholarship.mcgill.ca/concern/theses/6395w789c page]"
    },
    {
      "type": "reference",
      "id": "52056b6994aba7ab",
      "site": "sfw.c2.com",
      "slug": "accessor-events",
      "title": "Accessor Events",
      "text": "Accessor events are automatic and syntactically transparent accessor methods. For example, in [[Visual Fox Pro]] 6, if a method named property_Assign() exists, this method fires automatically when property is modified.  If a method named property_Access() is defined, this method fires automatically when property is read.  The property_Assign() and property_Access() methods, if they exist, are responsible for completing the transaction and circularities are preempted by the class internals."
    },
    {
      "type": "reference",
      "id": "5f2e72ad5a94b726",
      "site": "wiki.ralfbarkow.ch",
      "slug": "elm-accessors",
      "title": "elm-accessors",
      "text": "This library provides a way to describe relations between a [[Container]] and its [[Content]], and use that description to manipulate arbitrary data more easily. [https://package.elm-lang.org/packages/MackeyRMS/elm-accessors/3.0.0/ package] [https://github.com/MackeyRMS/elm-accessors/tree/3.0.0 github]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Car Racing",
        "story": []
      },
      "date": 1696577162466
    },
    {
      "item": {
        "type": "factory",
        "id": "093d7dd59c1fde8b"
      },
      "id": "093d7dd59c1fde8b",
      "type": "add",
      "date": 1696577163583
    },
    {
      "type": "edit",
      "id": "093d7dd59c1fde8b",
      "item": {
        "type": "paragraph",
        "id": "093d7dd59c1fde8b",
        "text": "ZHENG, Yi, 2002. Abstract data types and extended domain operations in a nested relational algebra.  [https://escholarship.mcgill.ca/concern/theses/6395w789c page]"
      },
      "date": 1696577187627
    },
    {
      "item": {
        "type": "factory",
        "id": "567a58069cc93fdf"
      },
      "id": "567a58069cc93fdf",
      "type": "add",
      "after": "093d7dd59c1fde8b",
      "date": 1696577213918
    },
    {
      "id": "567a58069cc93fdf",
      "type": "move",
      "order": [
        "567a58069cc93fdf",
        "093d7dd59c1fde8b"
      ],
      "date": 1696577215617
    },
    {
      "type": "edit",
      "id": "567a58069cc93fdf",
      "item": {
        "type": "paragraph",
        "id": "567a58069cc93fdf",
        "text": "In this example, we define a RaceCar ADT as shown in Figure 4.2. There are three state variables defined in the ADT: _vO, _a, and _v. In view of the motion of uniform acceleration, these represent the initial velocity, the acceleration, and the current velocity, in their standard units respectively. The two modifier methods, ACCELERATE and STOP, apply the rules of uniform acceleration to the state variables. ACCELERATE accelerates the race car for t seconds whereas STOP brings the car to a total stop. The only accessor method for this ADT is GETSPEED which is meant to reveal the current velocity of a car. AlI three methods are public, as they are present in the parameter list. The other two variables in the parameter list are vO and a. They specifiy the initial values for states _vO and _a. Obviously their values need to be provided when the RaceCar ADT is instantiated. This example also shows how domains of type computation are declared. It is important to declare aIl domains in the parameter list of an ADT before the declaration of the ADT itself."
      },
      "date": 1696577216858
    },
    {
      "item": {
        "type": "factory",
        "id": "2e72790e936d77c2"
      },
      "id": "2e72790e936d77c2",
      "type": "add",
      "after": "093d7dd59c1fde8b",
      "date": 1696577218069
    },
    {
      "id": "2e72790e936d77c2",
      "type": "move",
      "order": [
        "567a58069cc93fdf",
        "2e72790e936d77c2",
        "093d7dd59c1fde8b"
      ],
      "date": 1696577219750
    },
    {
      "type": "edit",
      "id": "2e72790e936d77c2",
      "item": {
        "type": "pagefold",
        "id": "2e72790e936d77c2",
        "text": "~"
      },
      "date": 1696577223703
    },
    {
      "type": "edit",
      "id": "567a58069cc93fdf",
      "item": {
        "type": "paragraph",
        "id": "567a58069cc93fdf",
        "text": "In this example, we define a RaceCar ADT as shown in Figure 4.2. There are three state variables defined in the ADT: _vO, _a, and _v. In view of the motion of uniform acceleration, these represent the initial velocity, the acceleration, and the current velocity, in their standard units respectively. The two modifier methods, ACCELERATE and STOP, apply the rules of uniform acceleration to the state variables. ACCELERATE accelerates the race car for t seconds whereas STOP brings the car to a total stop."
      },
      "date": 1696577275499
    },
    {
      "type": "add",
      "id": "8e09e44e82cb2f67",
      "item": {
        "type": "paragraph",
        "id": "8e09e44e82cb2f67",
        "text": "The only accessor method for this ADT is GETSPEED which is meant to reveal the current velocity of a car. AlI three methods are public, as they are present in the parameter list. The other two variables in the parameter list are vO and a. They specifiy the initial values for states _vO and _a. Obviously their values need to be provided when the RaceCar ADT is instantiated. This example also shows how domains of type computation are declared. It is important to declare aIl domains in the parameter list of an ADT before the declaration of the ADT itself."
      },
      "after": "567a58069cc93fdf",
      "date": 1696577276906
    },
    {
      "item": {
        "type": "factory",
        "id": "52056b6994aba7ab"
      },
      "id": "52056b6994aba7ab",
      "type": "add",
      "after": "093d7dd59c1fde8b",
      "date": 1696577295325
    },
    {
      "type": "edit",
      "id": "52056b6994aba7ab",
      "item": {
        "type": "reference",
        "id": "52056b6994aba7ab",
        "site": "sfw.c2.com",
        "slug": "accessor-events",
        "title": "Accessor Events",
        "text": "Accessor events are automatic and syntactically transparent accessor methods. For example, in [[Visual Fox Pro]] 6, if a method named property_Assign() exists, this method fires automatically when property is modified.  If a method named property_Access() is defined, this method fires automatically when property is read.  The property_Assign() and property_Access() methods, if they exist, are responsible for completing the transaction and circularities are preempted by the class internals."
      },
      "date": 1696577303383
    },
    {
      "id": "39b553f2a2aec4d4",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "39b553f2a2aec4d4",
        "text": "â‡’ The Accessors library [https://package.elm-lang.org/packages/MackeyRMS/elm-accessors/3.0.0/ package]"
      },
      "after": "52056b6994aba7ab",
      "attribution": {
        "page": "2023-10-06"
      },
      "date": 1696577388634
    },
    {
      "item": {
        "type": "factory",
        "id": "5f2e72ad5a94b726"
      },
      "id": "5f2e72ad5a94b726",
      "type": "add",
      "after": "39b553f2a2aec4d4",
      "date": 1696577585694
    },
    {
      "type": "edit",
      "id": "5f2e72ad5a94b726",
      "item": {
        "type": "reference",
        "id": "5f2e72ad5a94b726",
        "site": "wiki.ralfbarkow.ch",
        "slug": "elm-accessors",
        "title": "elm-accessors",
        "text": "This library provides a way to describe relations between a [[Container]] and its [[Content]], and use that description to manipulate arbitrary data more easily. [https://package.elm-lang.org/packages/MackeyRMS/elm-accessors/3.0.0/ package] [https://github.com/MackeyRMS/elm-accessors/tree/3.0.0 github]"
      },
      "date": 1696577591843
    },
    {
      "type": "remove",
      "id": "39b553f2a2aec4d4",
      "date": 1696577594244
    }
  ]
}