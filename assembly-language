{
  "title": "Assembly Language",
  "story": [
    {
      "type": "html",
      "text": "The next step up above [[Machine Code]]. The folks at [[Intel Corporation]] (for example) decide what [[Instruction Set]] the computer will understand.\nThis instruction set is usually of the form <register>, <register>, <operation>, <register> or variations using <memory address>.\n[[Assembly Language]] is a shorthand way to represent these machine instructions, for example",
      "id": "444cef7c01ba1fb599a886cab5d21a6e"
    },
    {
      "type": "code",
      "text": "  MOV ES, 13h",
      "id": "ea87cf0974645aea9834d8b3ae454695"
    },
    {
      "type": "html",
      "text": "to move hex 13 to register ES. [[Real Programmer]]s program in [[Assembly Language]] (well, in the 1960's they did).",
      "id": "0a34886d65e3cb3859bb0c2fb6befc53"
    },
    {
      "type": "html",
      "text": "<i>They still do - [[Steve Gibson]] is one well-known example.</i>",
      "id": "63df697c63c7401a1b634b6cf1459e3c"
    },
    {
      "type": "html",
      "text": "\nIt is also necessary to understand [[Assembly Language]] and to do some programming in it when doing operating system and compiler work.",
      "id": "790555b466e4bc875b1092e102d83bd5"
    },
    {
      "type": "html",
      "text": "<i>It is also frequently necessary to look at the [[Assembly Language]] code generated by your compiler to figure out what it is </i>really<i> doing!</i>",
      "id": "618d8f1030290f7d24b9318f5cbc3904"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "\nAssembly Language: an interpreted language for executing microcode. Real programmers program microcode.",
      "id": "484b86d9bcaeeca7a2c201b64f06abc6"
    },
    {
      "type": "html",
      "text": "<i>Wrong on two counts: Assembly is seldom if ever \"interpreted\" (in the computer science sense, it's almost always translated); and many architectures don't use microcode. Did you mean binary opcodes?</i>",
      "id": "04cf52a9f1cd9fc6f67815e50bf69ca3"
    },
    {
      "type": "html",
      "text": "\nOthers claim that since you use a program to convert a text file (assembly) to a binary file ([[Machine Code]]) then it's really a compiled language. Some processors don't have microcode.",
      "id": "2454a0427cadd735b0e5766cc8a922ab"
    },
    {
      "type": "html",
      "text": "<i>One can argue this is true or false depending on how much intelligence you expect something to have to be a \"compiler\".  In some cases though, an assembler can qualify as a compiler by most any definition.  For example, [[Ge Os]] was developed by [[Geoworks Corporation]] (now belongs to [[Breadbox Computer Company]]) in an [[Object Oriented Assembler]] of their own making.  That assembler was once available for purchase as part of a developer package for [[Ge Os]], and might still be available from Breadbox for all I know.</i>",
      "id": "b1bebfc99d821088d9ac98ed471e3339"
    },
    {
      "type": "html",
      "text": "\nAny machine that uses more than one machine cycle per instruction or has variable size instructions runs microcode. If the machine has an instruction width that equals its data width, it must be running microcode (How else could you direct a 32 bit value to a particular register without using more than 32 bits?). Inside of every processor is a smaller processor that fetches a machine instruction (a read operation), decodes and executes the operation (an execution operation), and determines the address of the next machine instruction (a calculation operation). The process repeats the above cycle over and over; that is microcode.",
      "id": "0cc72f784e4568b4e4d96fcf8e28bb1c"
    },
    {
      "type": "html",
      "text": "<i>Actually, you can do multi-cycle instructions without microcode; the Power 4 (IIRC) handles certain instructions, which are too complex to do in one cycle, by splitting them into two single-cycle instructions, thus letting the core be a pure single-cycle machine, and so simplifying its design. Since this splitting is simple and mechanical, and doesn't involve any actual microcode </i>per se<i>. Or something.</i>",
      "id": "f899224d5a09e67c1df2cf84812fbeca"
    },
    {
      "type": "html",
      "text": "\nAnd how does it fetch opcodes from memory except if it has microcode maintaining a program counter, dumping the address out on the address bus, reading the instruction back in from the data bus, incrementing the program counter, and possibly reloading the program counter? A JSR (Jump to Subroutine) is actually a complex operation and it is a program written in microcode. Microcode is the core of every currently available microprocessor that I am aware of.",
      "id": "39e08a713d63e2e1ed88c8e7fc97da40"
    },
    {
      "type": "html",
      "text": "<i>A lot of what you are talking about can be done with state machines. Microcode is only necessary for </i>really<i> complicated instructions, such as FSIN on the x86.</i>",
      "id": "bb3adc51b442f8e46f33050529a85347"
    },
    {
      "type": "html",
      "text": "\nComments from an old-timer to the youngsters commenting in this section. Try again - you are all wrong on at least one count each - even when you are mostly right. My point is that there are no absolutes. The S/360 series had models that were really NOTHING like the 360 architecture and had microcode options to emulate (as opposed to simulate) other machines. Most notably the 360/30 could \"be\" a 1401 and the /40 a 1410. At the other end of the line, there was NO microcode in the 360/95, and possibly none in the 65 (sorry, my memory is not perfect). One thing I know for CERTAIN - there was NO microcode of any kind in the Amdahl 470 (the first PCM - Plug-Compatible Mainframe). How do I know that? Because I still have the internal architecture diagrams from when I worked on them. The 470 was a \"pure\" machine - NO other machine running S/370 architecture was. I could go into a long dissertation as to how a hardwired machine could do things like move data longer than it's bus width, but the reader would have to understand basic digital electronics. If you know how to build an adder and comparator out of NAND gates, you know I'm right. If you don't, you're speaking from a position of ignorance. Same argument applies to the \"more than one cycle per instruction\" contention - especially when you consider pipelined execution where it becomes obvious that a \"single-cycle\" instruction (there really is no such thing) takes several discrete steps to execute.",
      "id": "f964785f6f5f40cea5fa9ff29d5fd0bd"
    },
    {
      "type": "html",
      "text": "\nRegarding assemblers vs. compilers, a useful distinction is an assembler (excluding macros) creates ONE machine instruction per source statement and a compiler [usually] creates more than one.",
      "id": "26dd96b8a3d5d66f5375e2e46c67e971"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "\nWell, regarding x86, where ES is a segment register, you can't MOV immediate values into segment registers directly, so you'd need to PUSH it and POP ES or use another register. And more likely it would be (e.g.) MOV EAX,13h (Intel style, Windows/DOS assemblers like MASM, TASM, etc.) or mov $0x13,%eax (AT&T style, e.g. GNU as).",
      "id": "f5503343a15781e5d0811426875fffd1"
    },
    {
      "type": "html",
      "text": "\nOh yeah, and Intel isn't the only player... far from it. You forget Motorola, ARM, Texas Instruments, SUN, Transmeta, Zilog, etc. etc. And an instruction is more like <opcode> <arguments> (usually 1-3 arguments); opcodes are short instruction names like MOV and PUSH and RST and CALL and RET. An opcode and its arguments (usually) corresponds to a single machine language instruction (which may be multiple bytes).",
      "id": "c2592ab6b72120fb2e2b122ea52f40ba"
    },
    {
      "type": "html",
      "text": "<i>You are aware that the \"bit-fielding\" of certain opcodes does in fact produce a machine-code-level syntax where things like <reg>[<reg>]<operation><operand> are the actual result, even though the mnemonics say MOV AX,[BX] or that sort of thing?</i>",
      "id": "909416361ecf1fb1b3b9163fad80e8e2"
    },
    {
      "type": "html",
      "text": "<i>More and more people are using FPGAs to implement their own custom [[Instruction Set]]</i>",
      "id": "c42f3dadc86be4ad975d24cb6923bfe8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "<b>32 bit ASM is easy to program</b>",
      "id": "86fc6f5b2c3ca424812d045071770fff"
    },
    {
      "type": "html",
      "text": "\nCheck out: [http://www.menuetos.org/ www.menuetos.org] - a GUI OS written entirely by hand in assembly.",
      "id": "aba904b444061a8beb443f6dcf2f836d"
    },
    {
      "type": "html",
      "text": "\nA statement of particular interest (and the reason I make mention of this project here) in the FAQ is \"32bit asm is generally almost as easy to program as C or Pascal.\"",
      "id": "908ecf76ca96ae582fa59ab6f605fe0a"
    },
    {
      "type": "html",
      "text": "\nAnyone care to say how this could possibly be true?",
      "id": "ccfe62807172e02e7392dedcdf940a16"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "\nIt <b>is</b> true. Just recently, I started writing a program in Assembly<b></b>Language that is intended to run before the main OS boot loader. I found that writing code in assembly actually led to <i>less</i> mistakes than writing it in C++ (though to be fair, when you make a mistake in assembler it's much more likely to crash the system). And there are several code constructs you can use in assembly that you can't in C++... perhaps some people would call some of them bad coding practises, but it makes things much simpler and it's still easily understandable. Besides which, you can run into trouble with C++ library calls (this routine makes a DOS call, unbeknownst to you. DOS? DOS isn't even loaded yet!) -- [[Gavin Lambert]]",
      "id": "63bbe7e1da3433c06cd7d59004795077"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "\nI too would like to say that coding in <i>flat-model</i>, 32bit, x86 assembler is just about as easy as writing C or Pascal. First, much of the mystery and complexity of assembler on the x86 lineage comes from its segmented memory model. I'll never understand entirely why they did this, considering its direct competition (at the time), the MC680xx family from Motorola, used a flat, linear memory model.",
      "id": "f84dbc0668858f2e93061e2f354f3455"
    },
    {
      "type": "html",
      "text": "<i>I think you'll find that this was because they started with an 8-bit processor with 16-bit extras (the 8080, 8085 and Z80) and then grafted on some 32-bit registers. To get enough memory addressing they then used two 16-bit registers and a small amount silicon to build a 28-bit </i>[actually 20-bit]<i> address. Of course, I could be wrong, but I suspect it all stems from trying to modify the original processors and use the previous silicon as much as possible. They were doing the [[Simplest Thing]] that could possibly work.</i>",
      "id": "486a5859de597c53b06b587e3862fc13"
    },
    {
      "type": "html",
      "text": "\nAt the time ('76, '77, there abouts), it was clear that larger address spaces were needed but you were limited in what you could do: you could attempt to keep both source <i>and</i> object (binary) compatibility, so you can still use existing development systems and programs; keep just source compatibility (so you just have to recompile existing programs); or abandon both and go for a clean slate.",
      "id": "26e08a63542c5cc9cf862268adabd8b8"
    },
    {
      "type": "html",
      "text": "\nMotorola decided to do the clean slate and ended up with the 68000 series (which internally was a 32-bit architecture; externally it depended upon which CPU was in use). Intel, on the other hand, decided to stick with source compatibility (to a degree - you can mechanically translate 8080 source code to 8086 code) but destroyed binary compatibility. To address more memory, the engineers at Intel went to a segmented architecture that wasn't <i>that bad</i> a method - it's just that programs grew faster than I think the engineers at Intel expected (or they didn't expect that particular architecture to become as popular as it did). The initial address space was 1M (20 bits) - a physical address consisted of a segment register (16 bits), multiplied by 16 (shifted left four bits) then the offset (another 16 bits) added to that. You had four segment registers, once for code, one for data, one for the stack, and an extra one (that in all my programs at least, was set to the data segment).",
      "id": "350de0370fe31e2a10e748f3259a3d1c"
    },
    {
      "type": "html",
      "text": "\nThe assembly language I think is the nicest (if not the largest and one of the most CISCish in nature) is the VAX assembly. Sixteen general purpose registers (of which the program counter is one of them), and a completely orthogonal instruction set makes it nice to program in. It may not be the fastest, but it is nice. -- [[Sean Conner]]",
      "id": "ad676384dcecc40bd6f59edc3098d642"
    },
    {
      "type": "html",
      "text": "<i>You clearly haven't programmed in ARM or StrongARM code. 16 general purpose registers (one is PC), completely orthogonal instruction set, every instruction can be made conditional, and whether or not the flags are set is optional on every instruction. Most instructions execute in one clock cycle. Extremely powerful.</i>",
      "id": "1ca5ac9a1e2ec568660717aa5ca6d0b8"
    },
    {
      "type": "html",
      "text": "\nHowever, for our benefit, Intel finally realized that memory segmentation is horrible and provided us with a flat memory model, thus greatly simplifying assembler on these microprocessors. (This happened in the 80386 and in all chips to follow it in the family).",
      "id": "b52d7ee8fdf508bd6fb20a58bc32ede3"
    },
    {
      "type": "html",
      "text": "<i>The 80386 (and later) does not have a flat memory model. It has a segmented memory model in the original sense of \"segmentation\", in which the segments are variable size. Few operating systems use this facility, they just set all the segment registers to point to a flat 4GB virtual space for each process.</i>",
      "id": "a77bb845e6d47b616acfedcaa582d529"
    },
    {
      "type": "html",
      "text": " It's true that x86 variable sized segments were not all that heavily used, historically (although that may have changed more recently) but it's not true that most OSes do what you said. I think that may have been true of Windows, and Windows only, but not Windows NT, and pre-Windows XP at that. For one thing, \"real\" operating systems usually wouldn't make it as large as 4GB, it would be only as large as needed, and for another thing, VM paging means that use of multiple segments to tile the user address space are desirable. The typical setup of having stack space grow downward from the opposite end of the address space than does other data also tends to force the use of at least two segments, each growing toward each other either by adding more segments or by actually stretching existing segments.",
      "id": "8ebeebf46be733f5999f6c85b1498c5f"
    },
    {
      "type": "html",
      "text": "\nIt might sound counterintuitive, but writing Win32 programs in assembler isn't that complicated, and as Gavin points out above, writing programs in assembler can sometimes be faster and more direct than high level languages. -- [[Jeff Panici]]",
      "id": "abf537fc135233b94ab104b2c2c0f9ca"
    },
    {
      "type": "html",
      "text": "<i>My program was in 16-bit real-mode code. It had to be, it was running before the OS loaded and I didn't want to bother with writing the instructions to get the processor in and out of protected mode. I used register-passing exclusively (and it doesn't make them non-reusable, you just have to be careful to document what the input and output registers are, and whether it preserves or destroys the other registers). And optimisation wasn't an issue. After looking at the output from my C compiler, I can make better ASM code than it can (it's not its fault, it's just that I know what I'm trying to do, whereas the compiler is just mindlessly following its ruleset). But even so, the major time factor in my program was waiting for a vertical sync to flip the backbuffer into video memory. I could have easily upped the framerate if I didn't have to actually display it :P -- [[Gavin Lambert]]</i>",
      "id": "82b3e22f02664e70d8c2103eac4a1ba2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "<b>segment registers</b>",
      "id": "819ec6c25c360ab6274f4fc89247ad29"
    },
    {
      "type": "html",
      "text": "<i>One final thing - the segmented addressing modes use 20 bit addresses, not 28 bit. The flat address of a segment:offset pair is (segment shl 4) + offset. The only real advantage that I've encountered when using it is that you can store only a 16-bit pointer (just the segment) if you ensure that the offset of the start of the data is zero. And in 16-bit code it is very slightly cheaper to load the segment from memory and clear the offset register than to load both from memory. Flat-model would have been nicer, though :) -- [[Gavin Lambert]]</i>",
      "id": "84793e8686ed5c48d973510a8b5cadd2"
    },
    {
      "type": "html",
      "text": "\nIf you don't truncate to 20 bits after doing (segment shl 4) + offset, you notice it is actually possible to set bit 20 to binary 1.\nThat way, segment:offset can actually address slightly more than 2^20 (1 megabyte). This is the A20-gate (\"Addressline 20-gate\") trick exploited by HIMEM.SYS on 286's and up: the hardware can address more than 20 bits, and by enabling this A20-gate software can address slightly more (just under 64 kilobyte extra) without leaving real mode. -- [[Peter Van Dijk]]",
      "id": "679332bbc3239294c3d9ad1e1f71dc33"
    },
    {
      "type": "html",
      "text": "<i>But note that this doesn't work in v86 mode ([http://www.codecomments.com/A86_Assembler/message237872.html www.codecomments.com]).</i>",
      "id": "f19622d6c1b220fc4fad1331d7631eb9"
    },
    {
      "type": "html",
      "text": "\nAbove link is broken. Regardless, the extra 65520 bytes at linear address 100000h are addressable in either real-address mode or V86 mode (both of which translate segmented addresses to linear addresses in exactly the same way). What is effectively accessed depends on paging and A20 masking though. Note that paging is typically \"disabled\" on x86 unless protection is enabled, thus (lacking modern vendor-specific virtualisation extensions) it is only applicable to V86 mode.",
      "id": "696fef1d36476cfa563c2e0e15f53a1c"
    },
    {
      "type": "html",
      "text": "\nPaging is done by the MMU, A20 masking generally was a hack in the chipset's memory controller (now that the memory controller has been moved onto the CPU, it may have moved there as well - if it is still supported at all). Disabling the actual A20 line (with the original A20 masking implementation) causes each odd MiB (at linear address 100000h, 300000h, 500000h, etc) to alias the even MiB right below it (0, 200000h, etc) - a typical V86 mode monitor (and software written ca. 1985 or later in general) doesn't want that.",
      "id": "132f805bc8f4a263dbb2bc182f81d49c"
    },
    {
      "type": "html",
      "text": "\nHowever a V86 mode monitor trivially can emulate the legacy A20 masking behaviour by intercepting attempts to reprogram the chipset's A20 masking facility, then appropriately modifying the V86 task's page tables to toggle a paging wrap effect (aliasing the 16 pages in the extra range to the first 16 pages iff to wrap). To legacy code running in the V86 task it is indistinguishable whether the wrap is caused by physical A20 masking or by paging. Of course a V86 mode monitor may lack such A20 emulation if it isn't deemed necessary.",
      "id": "4e4ff6ff3945e5530e2c5095c05e75da"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "<b>C++ better at matrix inversion; ASM better at CRCs and [[Big Nums]]</b>",
      "id": "0fdf284b4c8104fe901a12ecb023e658"
    },
    {
      "type": "html",
      "text": "\nHmm. I'd agree that for some processors and some problems, asm is as easy as C++ - it might even be easier. But it's a lot less portable. Win32 code is a good example because:",
      "id": "a081cff6b3e666da06ea9c354298326b"
    },
    {
      "type": "html",
      "text": " it's event driven, so the chunks of code are small",
      "id": "e130c64c5f0ca28f19453f5f540df498"
    },
    {
      "type": "html",
      "text": " there are many system calls",
      "id": "2be70344b6381b8fc05e8c568c652d70"
    },
    {
      "type": "html",
      "text": " you don't care about performance",
      "id": "d7e0cc98802deb9b5667803d69ebeacb"
    },
    {
      "type": "html",
      "text": " you probably don't intend to port it",
      "id": "6430b6be6e55cb81e1f0d49420a3c79e"
    },
    {
      "type": "html",
      "text": "\nHand-optimizing assembler code is very difficult; compilers are usually much better at it than humans (exceptions include things like DSP code). If you don't believe me, you should attempt to write an NxN matrix inversion routine (in assember) that beats the performance of the [[Matrix Template Library]] (actually, that's pretty-much impossible in C, too).",
      "id": "783d778ef5304273cfb2515b5d925c28"
    },
    {
      "type": "html",
      "text": "\nSome processors are easier than others. If you use a typical purist RISC processor, you'll find that the pipeline is exposed to the assember programmer. Once you start worrying about things like delay slots and manual resource scheduling, you'll find that hand-coded assembler isn't such a good idea.",
      "id": "4aeda9df512b6ae27fe39e03a169c111"
    },
    {
      "type": "html",
      "text": "-- [[Dave Whipp]]",
      "id": "1664d5d3a005bb7e6cb97633ea4faf7d"
    },
    {
      "type": "html",
      "text": "<i>Writing in assembler makes some things <b>very</b> much easier because you have access to the processor flags. Computing CRCs one bit at a time requires shifting a bit into the bottom of a register, and then doing an XOR with a magic word if the shift generated a carry. You can't do that in C.</i>",
      "id": "2395a31c5bcfd9b4d6c79c2a0c4e7b50"
    },
    {
      "type": "html",
      "text": "\nIf you really want to hand tune assembly, then you can pass values in registers instead of pushing them onto the stack. This eliminates memory access times and greatly reduces the cost of subroutine calls. The downside is that your subroutines become very tightly coupled and almost non-reuseable. I have used this optimization in the past, but would probably avoid it now and really insist on a faster processor. -- [[Wayne Mack]]",
      "id": "2fe5e1521a75a9e9ca7d49d187e92014"
    },
    {
      "type": "html",
      "text": "\nOr a compiler that can put procedure arguments in registers, and that can do interprocedural register targeting. E.g. the Larcency Scheme compiler does this, and even better, you can read all about it at \n[http://www.ccs.neu.edu/home/will/Twobit/ultimate.html www.ccs.neu.edu]. -- [[Stephan Houben]]",
      "id": "7faa98fd468e7dc64d76f014dc8f1588"
    },
    {
      "type": "html",
      "text": "\nx86 assembly language is better at math than C. In the x86, addition and subtraction update the carry flag (the carry flag is used for borrows in subtraction), and there are \"add with carry\" and \"subtract with borrow\" operations which you can use to achieve arbitrary precision. You can also multiply two 32-bit numbers to produce a 64-bit result, and you can divide a 64-bit number by a 32-bit number to get a 32-bit result (producing a divide overflow if the result doesn't fit in 32 bits) and a 32-bit remainder. These are the building blocks you need to produce arbitrary precision math. In C, if you multiply two 32-bit numbers, you get only the 32 least significant bits of the result; the upper half is truncated. If you want a 64-bit result, you have to cast the factors to 64-bit, and then if your compiler is stupid about such things, it will generate code which paranoidly checks the the upper 32-bits of both 64-bit factors, even though in this specific case they should be zero. It is also useful that in assembly language the quotient and the remainder are generated at the same time; in C and C++ you have to write two separate operations, and a stupid enough compiler might actually emit the divide opcode twice.",
      "id": "93611ecac43f6615a1038c4b3b089c4a"
    },
    {
      "type": "html",
      "text": "\nIn floating point, x86 assembly allows you to set the rounding modes. This is a feature that the [[Ieee Seven Fifty Four]] floating-point standard requires CPUs to make available, but most languages don't make it available. (Sometimes it is available as a library function.) It makes it possible to calculate upper and lower bounds for a value, and detect whether round-off error is significant in a specific calculation.",
      "id": "e91a1e27b3da115b3255954efa512f94"
    },
    {
      "type": "html",
      "text": "<i>But beware, the OS you're using may or may not save and restore your floating point mode on context switches (due to the expense of doing so). If it does not, then your settings may screw up other processes, and their changes to it may screw up your process.</i>",
      "id": "78fcd9e77216646cf3263759928581dd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "<b>asm is as easy as C++</b>",
      "id": "2679bc9d445076c97733b1b8712d6438"
    },
    {
      "type": "html",
      "text": "\nAssembly language has its place, mainly to do things that higher level languages cannot do. Obviously, everything a higher level language can do, assembly can do. This does not mean that it is easier in assembly. For example:",
      "id": "268790c09e5097fd23f73a09c8cf3a39"
    },
    {
      "type": "html",
      "text": " Pushing parameters onto a stack and pulling them off for function calls. In assembly, one must do this manually for each function call. In C++, this is hidden by the function declaration.",
      "id": "1ddb8d43ffb9000dbef7146fec22d139"
    },
    {
      "type": "html",
      "text": " Declaring local variables. In assembly, one must manually allocate stack space for local variables and ensure the size fits the need. In C++, this is hidden by the variable declaration and variables in different scopes are overlaid for efficiency.",
      "id": "c62b8e8b0b294eb510b200ee157a09fb"
    },
    {
      "type": "html",
      "text": " Writing complex evaluations. In assembly, each value in an expression must be evaluated separately and a branch decision made on each one. In C++, an evaluation consisting of multiple ANDs and ORs can be written in a single IF statement.",
      "id": "05a894568e1c938dae8c57555e55427a"
    },
    {
      "type": "html",
      "text": " Writing polymorphic methods. Jump tables came from assembly, but managing multiple tables and keeping the offsets within the tables synchronized is tedious and error prone. In C++, this is handled by header declarations.",
      "id": "ff37dd8f3441eac76ada3f2718985fa5"
    },
    {
      "type": "html",
      "text": " Writing an exception walkback. In assembly, one can write code to walk up the stack and identify an error handling routine at the appropriate level. In C++, this is handled with a simple Throw/Catch syntax.",
      "id": "07dfd558a8fbdbb8ec03992c21fee2f1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "\nAnyone got any short sample programs?",
      "id": "fe83e2de58905956dd12a46e72430f2f"
    },
    {
      "type": "html",
      "text": " short (useful) sample program appended below at <b>SET9600.COM</b>\n[http://web.archive.org/web/20020203150017/http://www.webgurru.com/tutorials/assembly/chap6.htm#2 web.archive.org]",
      "id": "b507bed337896d754d56203367a23a73"
    },
    {
      "type": "html",
      "text": "\nA short sample: <i>RET</i>",
      "id": "5e8cf6526cfa231c918416ba7507ac7b"
    },
    {
      "type": "html",
      "text": "\nExample of reboot: <i>jmp 0xFFFF:0x0000</i>",
      "id": "44d030046b7fe870d5e43047723e8af2"
    },
    {
      "type": "html",
      "text": "\nSee also [[Forth Assisted Hand Assembly]].",
      "id": "1447dad3e7a93f2036dc9267ebe4c210"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "<i>Assembly vs Assembler</i>",
      "id": "37b290d69050bb763b2be846abe72de4"
    },
    {
      "type": "html",
      "text": "\nMy understanding was that the Assembler assembles binary code from [[Assembly Language]]. I think the two phrases get interchanged a lot now that few people use [[Assembly Language]]. -- [[Brian Mc Callister]]",
      "id": "22465475f1a137460c9de26ff99d76d9"
    },
    {
      "type": "html",
      "text": " The two terms have always been interchanged a lot, not just in recent years, nor is it completely incorrect; it's just a case of <b>metonymy</b>, which is extremely common in natural language.",
      "id": "08e7034ff2e4bd29b3996b2130f8dea4"
    },
    {
      "type": "html",
      "text": "<i>You are quite correct. An assembler is the \"compiler\" for [[Assembly Language]].</i> -- [[Garry Hamilton]]",
      "id": "6d92032f2ccc8fc2560a244d1d5289cd"
    },
    {
      "type": "html",
      "text": "[When Assembly is compiled, does the Assembler perform any notable optimizations, or is the process just something similar to macro expansion into [[Machine Code]]?]",
      "id": "d92cce30a51cc0a2b7bbfe0d5ea0bf2d"
    },
    {
      "type": "html",
      "text": "\nTraditionally, no, but vendors often try to spice up their assembler with extensions to take some of the burden off of the programmer. Borland's Turbo Assembler, for instance, included extensions that automatically handle C-style subroutine declarations, local variables, and certain kinds of loops. These things are not all that commonly used.",
      "id": "e6f55b2c90173023205962632fdd6921"
    },
    {
      "type": "html",
      "text": " There are two types of assemblers: Those that are primarily intended to serve as the final stage of a compiler (assuming the compiler doesn't emit opcodes directly); and those intended for human code-writing. The former has far fewer features than the latter; often containing only that necessary to assemble the compiler's output.",
      "id": "8687f898f6e61418ded3faae56aa7ba0"
    },
    {
      "type": "html",
      "text": "\nOptimizing assemblers have been implemented from time to time, but this is relatively unusual, since the usual point of writing in assembly is to get 100% control over what is going on, and if a compilation from a higher level language is involved, the optimizer is usually a completely different pass, rather than being combined with the assembler. When RISC processors were new, it became more common for assemblers to do certain minor kinds of optimizations, such as automatically filling branch delay slots, but usually not full fledged peephole optimization.",
      "id": "924d8dfd35566508985f634ee41bb5d7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "<i>The first step beyond machine code, where human readable (relatively speaking) symbols are used to generate programs. </i>",
      "id": "5a3b3cb6d323bebf0b8a508854332333"
    },
    {
      "type": "html",
      "text": "\nRelatively speaking, as in an assembly program is as easy to read as an old BASIC program, even when decompiled from machine code. You just need to know how the processor behaves when it encounters a particular opcode, and handle it.",
      "id": "67619d2be043a585c602c693caf81234"
    },
    {
      "type": "html",
      "text": "\nHand-coded assembly is easy to write and maintain if you're good about naming the call and jump flags, and put in decent comments. The operations might be lower-level and constrained to certain integer maths, but that's no reason to write something unmaintainable or unreadable.",
      "id": "0bf4c8bb8d11872dd5622612558c9728"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "\n[[Assembly Language]] is one of the few (readable) levels at which the actual processor behaviors are exposed. Consequently, the most complete control of the \"currently defined\" processor behaviors is available in [[Assembly Language]] and those few others that grant direct access to the CPU.",
      "id": "9a42795766b915c63a2bda724ee62020"
    },
    {
      "type": "html",
      "text": "\nMost high-level languages will not represent the low-level behaviors of the processor - [[Forth Language]] and derivatives being exceptions.",
      "id": "42a88c9b77249466156db1ff7d44163e"
    },
    {
      "type": "html",
      "text": "\nThe \"currently defined\" behaviors of the processor are the subject of [[Micro Code]], which establishes the behaviors of the processor. Some exotic processors have writable [[Micro Code]], but for the vast majority of cases this will only be a curiosity: for all intents and purposes, the [[Micro Code]] can be considered part of the processor.",
      "id": "feeaf25820385123ceffa37a11b38123"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "\nProgramming at any level requires reasoning about the semantic structures at hand. High level languages claim to offer simpler or more appropriate structures, but often fall short of this goal when needs change or one is forced to reason about lower levels anyway. A regular dose of assembly programming will remind us what we should demand of our higher level languages. ",
      "id": "96eae1b1934a24fdd7d99a542e22ff0a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "\nMost of the discussion here seems to concern PC Assembly Language(s) - I am wondering if we should have a separate page for [[Mainframe Assembler Language]] (esp. IBM S/360/370/390/z90 Assembler Language). I think there is quite a lot to be said about this - in particular it has been going strong for almost 40 years, which has got to be some kind of record for a computer language... ",
      "id": "f055ab302fed66b83b5f219b874e3289"
    },
    {
      "type": "html",
      "text": "<i>No new page required. The title says [[Assembly Language]]; that's generic. Most of the discussion is about x86 assembly because that's what most people are familiar with. If you want to talk about 360 assembly, go right ahead. If the discussion becomes huge, <b>then</b> it would be interesting to calve a new page.</i> Now that pure x86 is pretty much a thing of the past as of 2004, is there going to be a discussion about AMD64 assembly?",
      "id": "f20eaf6c8a726f5cbd1fd93ad3011795"
    },
    {
      "type": "html",
      "text": "<i>So...how 'bout them base registers? Can't beat 'em.</i> ",
      "id": "2a55c4c70d65c0132745d1170488d5e8"
    },
    {
      "type": "html",
      "text": "<i>Hey, I think ARM assembly language is pretty cool.</i>",
      "id": "d60d5fea079445e6bd952ee9f4c78b74"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "<b>humorous assembly language</b>",
      "id": "ab5ea7c6f2531ed6565a50d5f6c4e3cd"
    },
    {
      "type": "html",
      "text": "\nfictional opcodes:",
      "id": "cd76fa87c4c985ca794fd4f7b96a53a8"
    },
    {
      "type": "code",
      "text": " BBW  Branch Both Ways\n DWIM  Do What I Mean\n FLI  Flash Lights Impressively\n HCF  Halt and Catch Fire\n HTS  Halt and Throw Sparks\n CMFRM  Come From",
      "id": "cdb8b864cc7996ffe2eb30a957dc0cee"
    },
    {
      "type": "html",
      "text": "\n[http://rdrop.com/users/jimka/assembly.html rdrop.com]",
      "id": "8a3129895a6f2715e63a4e01158cb4af"
    },
    {
      "type": "code",
      "text": " Hey, I remember doing assembly where BBW was available (threads implemented in microcode, yum!).",
      "id": "9bf88ccdfdf582e1241174e1ea60c838"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "<b>[[Better Assembly]]</b>",
      "id": "69118602775ef8bcdd913b2a36371eba"
    },
    {
      "type": "html",
      "text": "\n[[Preferred Order Of Src Dst Arguments]] and [[Forth Assisted Hand Assembly]] and [http://terse.com/ terse.com] have some interesting ideas on how to make a \"better\" assembly language (without going all the way to C).",
      "id": "107b6c217819f6ce1887d44297c82a99"
    },
    {
      "type": "html",
      "text": "\n[[Development Tools]]",
      "id": "61de4038e739c832680a3f82ed98b35a"
    },
    {
      "type": "html",
      "text": "\n[[Object Oriented Assembler]] mentions <i>\"assembler doesn't give any support for non-procedural methods\"</i>. Would it be crazy to write a \"better\" assembly language that provides some support for object-oriented methods?",
      "id": "4061b8dcfed482dd1f7d19294f066b01"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "<i>Anyone got any short sample programs?</i>",
      "id": "9cfff8b339ea8bae97c1eb4f2eb982e9"
    },
    {
      "type": "html",
      "text": " Here's a DEBUG script to create simple baud rate setup program.",
      "id": "561d7979b74721ad50d1ef367986be46"
    },
    {
      "type": "code",
      "text": "  C:\\>DEBUG\n  :  a 100            ; begin assembly code entry\n  :  mov al,0         ; zero, for \"off\"\n  :  mov dx,03F9      ; Com1 address + 1 = int enable register\n  :  out b al,dx      ; interrupts off\n  :  mov al,13        ; DTR+RTS+LBK (loop back mode)\n  :  mov dl,FC        ; Com1 address + 4 = modem ctrl register\n  :  out b al,dx      ; set loopback mode for Com1\n  :  mov al,83        ; 80 = DLAB, 03 = 8-bit mode mask\n  :  mov dl,FB        ; Com1 address + 3 = line ctrl register\n  :  out b al,dx      ; turn on divisor latch access\n  :  mov al,00        ; high-order byte of 000C\n  :  mov dl,F9        ; \"ie\" reg now high-order divisor byte\n  :  out b al,dx      ; place first half of divisor value\n  :  mov al,0C        ; low-order byte (that's 12)\n  :  mov dl,F8        ; \"data\" reg now low-order divisor byte\n  :  out b al,dx      ; place second half of divisor value\n  :  mov al,03        ; 8-bit mode mask without DLAB\n  :  mov dl,FB        ; Com1 address + 3 = line ctrl register\n  :  out b al,dx      ; turn off divisor latch access\n  :  nop              ; waste a cycle\n  :  mov dl,F8        ; Com1 base address = data register\n  :  in al,dx         ; clear the (first) RX data register\n  :  nop              ; just killing time\n  :  in al,dx         ; clear the (other) RX data register\n  :  mov al,03        ; DTR+RTS (without loop back bit)\n  :  mov dl,FC        ; Com1 address + 4 = modem ctrl register\n  :  out b al,dx      ; clear loopback mode for Com1\n  :  mov ax,4C00      ; terminate program, errorlevel=0\n  :  int 21           ; call DOS to end ; just press <Enter> next\n  :  n set9600.com    ; where to write the program\n  :  r cx             ; alter contents of CX register\n  :  003A             ; that's 58 for you civilians\n  :  w                ; create file and save program\n  :  q                ; leave DEBUG\n  dir set9600.com",
      "id": "4096df6eb7228dcdb8530c5d5db5fe93"
    },
    {
      "type": "html",
      "text": "You now have SET9600.com which ... does exactly that.",
      "id": "2d85f6a9994c77f78c35e41a4d54b6f3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "291b95de9761336b471b215819b4b579"
    },
    {
      "type": "html",
      "text": "[[Preferred Order Of Src Dst Arguments]]\n[[Digital Signal Processing]]\n[[Object Oriented Assembler]]\n[[Write Assembler]]",
      "id": "b6e7a74bc4bb7fcbbd41bb411d908661"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?AssemblyLanguage c2.com]",
      "id": "ba6a4b897b52d2f0ad9ce53b5bcb2d7b"
    }
  ],
  "journal": [
    {
      "date": 1415861150000,
      "id": "5468c499136a4a1dc0160dfd8e92d35e",
      "type": "create",
      "item": {
        "title": "Assembly Language",
        "story": [
          {
            "type": "html",
            "text": "The next step up above [[Machine Code]]. The folks at [[Intel Corporation]] (for example) decide what [[Instruction Set]] the computer will understand.\nThis instruction set is usually of the form <register>, <register>, <operation>, <register> or variations using <memory address>.\n[[Assembly Language]] is a shorthand way to represent these machine instructions, for example",
            "id": "444cef7c01ba1fb599a886cab5d21a6e"
          },
          {
            "type": "code",
            "text": "  MOV ES, 13h",
            "id": "ea87cf0974645aea9834d8b3ae454695"
          },
          {
            "type": "html",
            "text": "to move hex 13 to register ES. [[Real Programmer]]s program in [[Assembly Language]] (well, in the 1960's they did).",
            "id": "0a34886d65e3cb3859bb0c2fb6befc53"
          },
          {
            "type": "html",
            "text": "<i>They still do - [[Steve Gibson]] is one well-known example.</i>",
            "id": "63df697c63c7401a1b634b6cf1459e3c"
          },
          {
            "type": "html",
            "text": "\nIt is also necessary to understand [[Assembly Language]] and to do some programming in it when doing operating system and compiler work.",
            "id": "790555b466e4bc875b1092e102d83bd5"
          },
          {
            "type": "html",
            "text": "<i>It is also frequently necessary to look at the [[Assembly Language]] code generated by your compiler to figure out what it is </i>really<i> doing!</i>",
            "id": "618d8f1030290f7d24b9318f5cbc3904"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "\nAssembly Language: an interpreted language for executing microcode. Real programmers program microcode.",
            "id": "484b86d9bcaeeca7a2c201b64f06abc6"
          },
          {
            "type": "html",
            "text": "<i>Wrong on two counts: Assembly is seldom if ever \"interpreted\" (in the computer science sense, it's almost always translated); and many architectures don't use microcode. Did you mean binary opcodes?</i>",
            "id": "04cf52a9f1cd9fc6f67815e50bf69ca3"
          },
          {
            "type": "html",
            "text": "\nOthers claim that since you use a program to convert a text file (assembly) to a binary file ([[Machine Code]]) then it's really a compiled language. Some processors don't have microcode.",
            "id": "2454a0427cadd735b0e5766cc8a922ab"
          },
          {
            "type": "html",
            "text": "<i>One can argue this is true or false depending on how much intelligence you expect something to have to be a \"compiler\".  In some cases though, an assembler can qualify as a compiler by most any definition.  For example, [[Ge Os]] was developed by [[Geoworks Corporation]] (now belongs to [[Breadbox Computer Company]]) in an [[Object Oriented Assembler]] of their own making.  That assembler was once available for purchase as part of a developer package for [[Ge Os]], and might still be available from Breadbox for all I know.</i>",
            "id": "b1bebfc99d821088d9ac98ed471e3339"
          },
          {
            "type": "html",
            "text": "\nAny machine that uses more than one machine cycle per instruction or has variable size instructions runs microcode. If the machine has an instruction width that equals its data width, it must be running microcode (How else could you direct a 32 bit value to a particular register without using more than 32 bits?). Inside of every processor is a smaller processor that fetches a machine instruction (a read operation), decodes and executes the operation (an execution operation), and determines the address of the next machine instruction (a calculation operation). The process repeats the above cycle over and over; that is microcode.",
            "id": "0cc72f784e4568b4e4d96fcf8e28bb1c"
          },
          {
            "type": "html",
            "text": "<i>Actually, you can do multi-cycle instructions without microcode; the Power 4 (IIRC) handles certain instructions, which are too complex to do in one cycle, by splitting them into two single-cycle instructions, thus letting the core be a pure single-cycle machine, and so simplifying its design. Since this splitting is simple and mechanical, and doesn't involve any actual microcode </i>per se<i>. Or something.</i>",
            "id": "f899224d5a09e67c1df2cf84812fbeca"
          },
          {
            "type": "html",
            "text": "\nAnd how does it fetch opcodes from memory except if it has microcode maintaining a program counter, dumping the address out on the address bus, reading the instruction back in from the data bus, incrementing the program counter, and possibly reloading the program counter? A JSR (Jump to Subroutine) is actually a complex operation and it is a program written in microcode. Microcode is the core of every currently available microprocessor that I am aware of.",
            "id": "39e08a713d63e2e1ed88c8e7fc97da40"
          },
          {
            "type": "html",
            "text": "<i>A lot of what you are talking about can be done with state machines. Microcode is only necessary for </i>really<i> complicated instructions, such as FSIN on the x86.</i>",
            "id": "bb3adc51b442f8e46f33050529a85347"
          },
          {
            "type": "html",
            "text": "\nComments from an old-timer to the youngsters commenting in this section. Try again - you are all wrong on at least one count each - even when you are mostly right. My point is that there are no absolutes. The S/360 series had models that were really NOTHING like the 360 architecture and had microcode options to emulate (as opposed to simulate) other machines. Most notably the 360/30 could \"be\" a 1401 and the /40 a 1410. At the other end of the line, there was NO microcode in the 360/95, and possibly none in the 65 (sorry, my memory is not perfect). One thing I know for CERTAIN - there was NO microcode of any kind in the Amdahl 470 (the first PCM - Plug-Compatible Mainframe). How do I know that? Because I still have the internal architecture diagrams from when I worked on them. The 470 was a \"pure\" machine - NO other machine running S/370 architecture was. I could go into a long dissertation as to how a hardwired machine could do things like move data longer than it's bus width, but the reader would have to understand basic digital electronics. If you know how to build an adder and comparator out of NAND gates, you know I'm right. If you don't, you're speaking from a position of ignorance. Same argument applies to the \"more than one cycle per instruction\" contention - especially when you consider pipelined execution where it becomes obvious that a \"single-cycle\" instruction (there really is no such thing) takes several discrete steps to execute.",
            "id": "f964785f6f5f40cea5fa9ff29d5fd0bd"
          },
          {
            "type": "html",
            "text": "\nRegarding assemblers vs. compilers, a useful distinction is an assembler (excluding macros) creates ONE machine instruction per source statement and a compiler [usually] creates more than one.",
            "id": "26dd96b8a3d5d66f5375e2e46c67e971"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "\nWell, regarding x86, where ES is a segment register, you can't MOV immediate values into segment registers directly, so you'd need to PUSH it and POP ES or use another register. And more likely it would be (e.g.) MOV EAX,13h (Intel style, Windows/DOS assemblers like MASM, TASM, etc.) or mov $0x13,%eax (AT&T style, e.g. GNU as).",
            "id": "f5503343a15781e5d0811426875fffd1"
          },
          {
            "type": "html",
            "text": "\nOh yeah, and Intel isn't the only player... far from it. You forget Motorola, ARM, Texas Instruments, SUN, Transmeta, Zilog, etc. etc. And an instruction is more like <opcode> <arguments> (usually 1-3 arguments); opcodes are short instruction names like MOV and PUSH and RST and CALL and RET. An opcode and its arguments (usually) corresponds to a single machine language instruction (which may be multiple bytes).",
            "id": "c2592ab6b72120fb2e2b122ea52f40ba"
          },
          {
            "type": "html",
            "text": "<i>You are aware that the \"bit-fielding\" of certain opcodes does in fact produce a machine-code-level syntax where things like <reg>[<reg>]<operation><operand> are the actual result, even though the mnemonics say MOV AX,[BX] or that sort of thing?</i>",
            "id": "909416361ecf1fb1b3b9163fad80e8e2"
          },
          {
            "type": "html",
            "text": "<i>More and more people are using FPGAs to implement their own custom [[Instruction Set]]</i>",
            "id": "c42f3dadc86be4ad975d24cb6923bfe8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "<b>32 bit ASM is easy to program</b>",
            "id": "86fc6f5b2c3ca424812d045071770fff"
          },
          {
            "type": "html",
            "text": "\nCheck out: [http://www.menuetos.org/ www.menuetos.org] - a GUI OS written entirely by hand in assembly.",
            "id": "aba904b444061a8beb443f6dcf2f836d"
          },
          {
            "type": "html",
            "text": "\nA statement of particular interest (and the reason I make mention of this project here) in the FAQ is \"32bit asm is generally almost as easy to program as C or Pascal.\"",
            "id": "908ecf76ca96ae582fa59ab6f605fe0a"
          },
          {
            "type": "html",
            "text": "\nAnyone care to say how this could possibly be true?",
            "id": "ccfe62807172e02e7392dedcdf940a16"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "\nIt <b>is</b> true. Just recently, I started writing a program in Assembly<b></b>Language that is intended to run before the main OS boot loader. I found that writing code in assembly actually led to <i>less</i> mistakes than writing it in C++ (though to be fair, when you make a mistake in assembler it's much more likely to crash the system). And there are several code constructs you can use in assembly that you can't in C++... perhaps some people would call some of them bad coding practises, but it makes things much simpler and it's still easily understandable. Besides which, you can run into trouble with C++ library calls (this routine makes a DOS call, unbeknownst to you. DOS? DOS isn't even loaded yet!) -- [[Gavin Lambert]]",
            "id": "63bbe7e1da3433c06cd7d59004795077"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "\nI too would like to say that coding in <i>flat-model</i>, 32bit, x86 assembler is just about as easy as writing C or Pascal. First, much of the mystery and complexity of assembler on the x86 lineage comes from its segmented memory model. I'll never understand entirely why they did this, considering its direct competition (at the time), the MC680xx family from Motorola, used a flat, linear memory model.",
            "id": "f84dbc0668858f2e93061e2f354f3455"
          },
          {
            "type": "html",
            "text": "<i>I think you'll find that this was because they started with an 8-bit processor with 16-bit extras (the 8080, 8085 and Z80) and then grafted on some 32-bit registers. To get enough memory addressing they then used two 16-bit registers and a small amount silicon to build a 28-bit </i>[actually 20-bit]<i> address. Of course, I could be wrong, but I suspect it all stems from trying to modify the original processors and use the previous silicon as much as possible. They were doing the [[Simplest Thing]] that could possibly work.</i>",
            "id": "486a5859de597c53b06b587e3862fc13"
          },
          {
            "type": "html",
            "text": "\nAt the time ('76, '77, there abouts), it was clear that larger address spaces were needed but you were limited in what you could do: you could attempt to keep both source <i>and</i> object (binary) compatibility, so you can still use existing development systems and programs; keep just source compatibility (so you just have to recompile existing programs); or abandon both and go for a clean slate.",
            "id": "26e08a63542c5cc9cf862268adabd8b8"
          },
          {
            "type": "html",
            "text": "\nMotorola decided to do the clean slate and ended up with the 68000 series (which internally was a 32-bit architecture; externally it depended upon which CPU was in use). Intel, on the other hand, decided to stick with source compatibility (to a degree - you can mechanically translate 8080 source code to 8086 code) but destroyed binary compatibility. To address more memory, the engineers at Intel went to a segmented architecture that wasn't <i>that bad</i> a method - it's just that programs grew faster than I think the engineers at Intel expected (or they didn't expect that particular architecture to become as popular as it did). The initial address space was 1M (20 bits) - a physical address consisted of a segment register (16 bits), multiplied by 16 (shifted left four bits) then the offset (another 16 bits) added to that. You had four segment registers, once for code, one for data, one for the stack, and an extra one (that in all my programs at least, was set to the data segment).",
            "id": "350de0370fe31e2a10e748f3259a3d1c"
          },
          {
            "type": "html",
            "text": "\nThe assembly language I think is the nicest (if not the largest and one of the most CISCish in nature) is the VAX assembly. Sixteen general purpose registers (of which the program counter is one of them), and a completely orthogonal instruction set makes it nice to program in. It may not be the fastest, but it is nice. -- [[Sean Conner]]",
            "id": "ad676384dcecc40bd6f59edc3098d642"
          },
          {
            "type": "html",
            "text": "<i>You clearly haven't programmed in ARM or StrongARM code. 16 general purpose registers (one is PC), completely orthogonal instruction set, every instruction can be made conditional, and whether or not the flags are set is optional on every instruction. Most instructions execute in one clock cycle. Extremely powerful.</i>",
            "id": "1ca5ac9a1e2ec568660717aa5ca6d0b8"
          },
          {
            "type": "html",
            "text": "\nHowever, for our benefit, Intel finally realized that memory segmentation is horrible and provided us with a flat memory model, thus greatly simplifying assembler on these microprocessors. (This happened in the 80386 and in all chips to follow it in the family).",
            "id": "b52d7ee8fdf508bd6fb20a58bc32ede3"
          },
          {
            "type": "html",
            "text": "<i>The 80386 (and later) does not have a flat memory model. It has a segmented memory model in the original sense of \"segmentation\", in which the segments are variable size. Few operating systems use this facility, they just set all the segment registers to point to a flat 4GB virtual space for each process.</i>",
            "id": "a77bb845e6d47b616acfedcaa582d529"
          },
          {
            "type": "html",
            "text": " It's true that x86 variable sized segments were not all that heavily used, historically (although that may have changed more recently) but it's not true that most OSes do what you said. I think that may have been true of Windows, and Windows only, but not Windows NT, and pre-Windows XP at that. For one thing, \"real\" operating systems usually wouldn't make it as large as 4GB, it would be only as large as needed, and for another thing, VM paging means that use of multiple segments to tile the user address space are desirable. The typical setup of having stack space grow downward from the opposite end of the address space than does other data also tends to force the use of at least two segments, each growing toward each other either by adding more segments or by actually stretching existing segments.",
            "id": "8ebeebf46be733f5999f6c85b1498c5f"
          },
          {
            "type": "html",
            "text": "\nIt might sound counterintuitive, but writing Win32 programs in assembler isn't that complicated, and as Gavin points out above, writing programs in assembler can sometimes be faster and more direct than high level languages. -- [[Jeff Panici]]",
            "id": "abf537fc135233b94ab104b2c2c0f9ca"
          },
          {
            "type": "html",
            "text": "<i>My program was in 16-bit real-mode code. It had to be, it was running before the OS loaded and I didn't want to bother with writing the instructions to get the processor in and out of protected mode. I used register-passing exclusively (and it doesn't make them non-reusable, you just have to be careful to document what the input and output registers are, and whether it preserves or destroys the other registers). And optimisation wasn't an issue. After looking at the output from my C compiler, I can make better ASM code than it can (it's not its fault, it's just that I know what I'm trying to do, whereas the compiler is just mindlessly following its ruleset). But even so, the major time factor in my program was waiting for a vertical sync to flip the backbuffer into video memory. I could have easily upped the framerate if I didn't have to actually display it :P -- [[Gavin Lambert]]</i>",
            "id": "82b3e22f02664e70d8c2103eac4a1ba2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "<b>segment registers</b>",
            "id": "819ec6c25c360ab6274f4fc89247ad29"
          },
          {
            "type": "html",
            "text": "<i>One final thing - the segmented addressing modes use 20 bit addresses, not 28 bit. The flat address of a segment:offset pair is (segment shl 4) + offset. The only real advantage that I've encountered when using it is that you can store only a 16-bit pointer (just the segment) if you ensure that the offset of the start of the data is zero. And in 16-bit code it is very slightly cheaper to load the segment from memory and clear the offset register than to load both from memory. Flat-model would have been nicer, though :) -- [[Gavin Lambert]]</i>",
            "id": "84793e8686ed5c48d973510a8b5cadd2"
          },
          {
            "type": "html",
            "text": "\nIf you don't truncate to 20 bits after doing (segment shl 4) + offset, you notice it is actually possible to set bit 20 to binary 1.\nThat way, segment:offset can actually address slightly more than 2^20 (1 megabyte). This is the A20-gate (\"Addressline 20-gate\") trick exploited by HIMEM.SYS on 286's and up: the hardware can address more than 20 bits, and by enabling this A20-gate software can address slightly more (just under 64 kilobyte extra) without leaving real mode. -- [[Peter Van Dijk]]",
            "id": "679332bbc3239294c3d9ad1e1f71dc33"
          },
          {
            "type": "html",
            "text": "<i>But note that this doesn't work in v86 mode ([http://www.codecomments.com/A86_Assembler/message237872.html www.codecomments.com]).</i>",
            "id": "f19622d6c1b220fc4fad1331d7631eb9"
          },
          {
            "type": "html",
            "text": "\nAbove link is broken. Regardless, the extra 65520 bytes at linear address 100000h are addressable in either real-address mode or V86 mode (both of which translate segmented addresses to linear addresses in exactly the same way). What is effectively accessed depends on paging and A20 masking though. Note that paging is typically \"disabled\" on x86 unless protection is enabled, thus (lacking modern vendor-specific virtualisation extensions) it is only applicable to V86 mode.",
            "id": "696fef1d36476cfa563c2e0e15f53a1c"
          },
          {
            "type": "html",
            "text": "\nPaging is done by the MMU, A20 masking generally was a hack in the chipset's memory controller (now that the memory controller has been moved onto the CPU, it may have moved there as well - if it is still supported at all). Disabling the actual A20 line (with the original A20 masking implementation) causes each odd MiB (at linear address 100000h, 300000h, 500000h, etc) to alias the even MiB right below it (0, 200000h, etc) - a typical V86 mode monitor (and software written ca. 1985 or later in general) doesn't want that.",
            "id": "132f805bc8f4a263dbb2bc182f81d49c"
          },
          {
            "type": "html",
            "text": "\nHowever a V86 mode monitor trivially can emulate the legacy A20 masking behaviour by intercepting attempts to reprogram the chipset's A20 masking facility, then appropriately modifying the V86 task's page tables to toggle a paging wrap effect (aliasing the 16 pages in the extra range to the first 16 pages iff to wrap). To legacy code running in the V86 task it is indistinguishable whether the wrap is caused by physical A20 masking or by paging. Of course a V86 mode monitor may lack such A20 emulation if it isn't deemed necessary.",
            "id": "4e4ff6ff3945e5530e2c5095c05e75da"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "<b>C++ better at matrix inversion; ASM better at CRCs and [[Big Nums]]</b>",
            "id": "0fdf284b4c8104fe901a12ecb023e658"
          },
          {
            "type": "html",
            "text": "\nHmm. I'd agree that for some processors and some problems, asm is as easy as C++ - it might even be easier. But it's a lot less portable. Win32 code is a good example because:",
            "id": "a081cff6b3e666da06ea9c354298326b"
          },
          {
            "type": "html",
            "text": " it's event driven, so the chunks of code are small",
            "id": "e130c64c5f0ca28f19453f5f540df498"
          },
          {
            "type": "html",
            "text": " there are many system calls",
            "id": "2be70344b6381b8fc05e8c568c652d70"
          },
          {
            "type": "html",
            "text": " you don't care about performance",
            "id": "d7e0cc98802deb9b5667803d69ebeacb"
          },
          {
            "type": "html",
            "text": " you probably don't intend to port it",
            "id": "6430b6be6e55cb81e1f0d49420a3c79e"
          },
          {
            "type": "html",
            "text": "\nHand-optimizing assembler code is very difficult; compilers are usually much better at it than humans (exceptions include things like DSP code). If you don't believe me, you should attempt to write an NxN matrix inversion routine (in assember) that beats the performance of the [[Matrix Template Library]] (actually, that's pretty-much impossible in C, too).",
            "id": "783d778ef5304273cfb2515b5d925c28"
          },
          {
            "type": "html",
            "text": "\nSome processors are easier than others. If you use a typical purist RISC processor, you'll find that the pipeline is exposed to the assember programmer. Once you start worrying about things like delay slots and manual resource scheduling, you'll find that hand-coded assembler isn't such a good idea.",
            "id": "4aeda9df512b6ae27fe39e03a169c111"
          },
          {
            "type": "html",
            "text": "-- [[Dave Whipp]]",
            "id": "1664d5d3a005bb7e6cb97633ea4faf7d"
          },
          {
            "type": "html",
            "text": "<i>Writing in assembler makes some things <b>very</b> much easier because you have access to the processor flags. Computing CRCs one bit at a time requires shifting a bit into the bottom of a register, and then doing an XOR with a magic word if the shift generated a carry. You can't do that in C.</i>",
            "id": "2395a31c5bcfd9b4d6c79c2a0c4e7b50"
          },
          {
            "type": "html",
            "text": "\nIf you really want to hand tune assembly, then you can pass values in registers instead of pushing them onto the stack. This eliminates memory access times and greatly reduces the cost of subroutine calls. The downside is that your subroutines become very tightly coupled and almost non-reuseable. I have used this optimization in the past, but would probably avoid it now and really insist on a faster processor. -- [[Wayne Mack]]",
            "id": "2fe5e1521a75a9e9ca7d49d187e92014"
          },
          {
            "type": "html",
            "text": "\nOr a compiler that can put procedure arguments in registers, and that can do interprocedural register targeting. E.g. the Larcency Scheme compiler does this, and even better, you can read all about it at \n[http://www.ccs.neu.edu/home/will/Twobit/ultimate.html www.ccs.neu.edu]. -- [[Stephan Houben]]",
            "id": "7faa98fd468e7dc64d76f014dc8f1588"
          },
          {
            "type": "html",
            "text": "\nx86 assembly language is better at math than C. In the x86, addition and subtraction update the carry flag (the carry flag is used for borrows in subtraction), and there are \"add with carry\" and \"subtract with borrow\" operations which you can use to achieve arbitrary precision. You can also multiply two 32-bit numbers to produce a 64-bit result, and you can divide a 64-bit number by a 32-bit number to get a 32-bit result (producing a divide overflow if the result doesn't fit in 32 bits) and a 32-bit remainder. These are the building blocks you need to produce arbitrary precision math. In C, if you multiply two 32-bit numbers, you get only the 32 least significant bits of the result; the upper half is truncated. If you want a 64-bit result, you have to cast the factors to 64-bit, and then if your compiler is stupid about such things, it will generate code which paranoidly checks the the upper 32-bits of both 64-bit factors, even though in this specific case they should be zero. It is also useful that in assembly language the quotient and the remainder are generated at the same time; in C and C++ you have to write two separate operations, and a stupid enough compiler might actually emit the divide opcode twice.",
            "id": "93611ecac43f6615a1038c4b3b089c4a"
          },
          {
            "type": "html",
            "text": "\nIn floating point, x86 assembly allows you to set the rounding modes. This is a feature that the [[Ieee Seven Fifty Four]] floating-point standard requires CPUs to make available, but most languages don't make it available. (Sometimes it is available as a library function.) It makes it possible to calculate upper and lower bounds for a value, and detect whether round-off error is significant in a specific calculation.",
            "id": "e91a1e27b3da115b3255954efa512f94"
          },
          {
            "type": "html",
            "text": "<i>But beware, the OS you're using may or may not save and restore your floating point mode on context switches (due to the expense of doing so). If it does not, then your settings may screw up other processes, and their changes to it may screw up your process.</i>",
            "id": "78fcd9e77216646cf3263759928581dd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "<b>asm is as easy as C++</b>",
            "id": "2679bc9d445076c97733b1b8712d6438"
          },
          {
            "type": "html",
            "text": "\nAssembly language has its place, mainly to do things that higher level languages cannot do. Obviously, everything a higher level language can do, assembly can do. This does not mean that it is easier in assembly. For example:",
            "id": "268790c09e5097fd23f73a09c8cf3a39"
          },
          {
            "type": "html",
            "text": " Pushing parameters onto a stack and pulling them off for function calls. In assembly, one must do this manually for each function call. In C++, this is hidden by the function declaration.",
            "id": "1ddb8d43ffb9000dbef7146fec22d139"
          },
          {
            "type": "html",
            "text": " Declaring local variables. In assembly, one must manually allocate stack space for local variables and ensure the size fits the need. In C++, this is hidden by the variable declaration and variables in different scopes are overlaid for efficiency.",
            "id": "c62b8e8b0b294eb510b200ee157a09fb"
          },
          {
            "type": "html",
            "text": " Writing complex evaluations. In assembly, each value in an expression must be evaluated separately and a branch decision made on each one. In C++, an evaluation consisting of multiple ANDs and ORs can be written in a single IF statement.",
            "id": "05a894568e1c938dae8c57555e55427a"
          },
          {
            "type": "html",
            "text": " Writing polymorphic methods. Jump tables came from assembly, but managing multiple tables and keeping the offsets within the tables synchronized is tedious and error prone. In C++, this is handled by header declarations.",
            "id": "ff37dd8f3441eac76ada3f2718985fa5"
          },
          {
            "type": "html",
            "text": " Writing an exception walkback. In assembly, one can write code to walk up the stack and identify an error handling routine at the appropriate level. In C++, this is handled with a simple Throw/Catch syntax.",
            "id": "07dfd558a8fbdbb8ec03992c21fee2f1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "\nAnyone got any short sample programs?",
            "id": "fe83e2de58905956dd12a46e72430f2f"
          },
          {
            "type": "html",
            "text": " short (useful) sample program appended below at <b>SET9600.COM</b>\n[http://web.archive.org/web/20020203150017/http://www.webgurru.com/tutorials/assembly/chap6.htm#2 web.archive.org]",
            "id": "b507bed337896d754d56203367a23a73"
          },
          {
            "type": "html",
            "text": "\nA short sample: <i>RET</i>",
            "id": "5e8cf6526cfa231c918416ba7507ac7b"
          },
          {
            "type": "html",
            "text": "\nExample of reboot: <i>jmp 0xFFFF:0x0000</i>",
            "id": "44d030046b7fe870d5e43047723e8af2"
          },
          {
            "type": "html",
            "text": "\nSee also [[Forth Assisted Hand Assembly]].",
            "id": "1447dad3e7a93f2036dc9267ebe4c210"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "<i>Assembly vs Assembler</i>",
            "id": "37b290d69050bb763b2be846abe72de4"
          },
          {
            "type": "html",
            "text": "\nMy understanding was that the Assembler assembles binary code from [[Assembly Language]]. I think the two phrases get interchanged a lot now that few people use [[Assembly Language]]. -- [[Brian Mc Callister]]",
            "id": "22465475f1a137460c9de26ff99d76d9"
          },
          {
            "type": "html",
            "text": " The two terms have always been interchanged a lot, not just in recent years, nor is it completely incorrect; it's just a case of <b>metonymy</b>, which is extremely common in natural language.",
            "id": "08e7034ff2e4bd29b3996b2130f8dea4"
          },
          {
            "type": "html",
            "text": "<i>You are quite correct. An assembler is the \"compiler\" for [[Assembly Language]].</i> -- [[Garry Hamilton]]",
            "id": "6d92032f2ccc8fc2560a244d1d5289cd"
          },
          {
            "type": "html",
            "text": "[When Assembly is compiled, does the Assembler perform any notable optimizations, or is the process just something similar to macro expansion into [[Machine Code]]?]",
            "id": "d92cce30a51cc0a2b7bbfe0d5ea0bf2d"
          },
          {
            "type": "html",
            "text": "\nTraditionally, no, but vendors often try to spice up their assembler with extensions to take some of the burden off of the programmer. Borland's Turbo Assembler, for instance, included extensions that automatically handle C-style subroutine declarations, local variables, and certain kinds of loops. These things are not all that commonly used.",
            "id": "e6f55b2c90173023205962632fdd6921"
          },
          {
            "type": "html",
            "text": " There are two types of assemblers: Those that are primarily intended to serve as the final stage of a compiler (assuming the compiler doesn't emit opcodes directly); and those intended for human code-writing. The former has far fewer features than the latter; often containing only that necessary to assemble the compiler's output.",
            "id": "8687f898f6e61418ded3faae56aa7ba0"
          },
          {
            "type": "html",
            "text": "\nOptimizing assemblers have been implemented from time to time, but this is relatively unusual, since the usual point of writing in assembly is to get 100% control over what is going on, and if a compilation from a higher level language is involved, the optimizer is usually a completely different pass, rather than being combined with the assembler. When RISC processors were new, it became more common for assemblers to do certain minor kinds of optimizations, such as automatically filling branch delay slots, but usually not full fledged peephole optimization.",
            "id": "924d8dfd35566508985f634ee41bb5d7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "<i>The first step beyond machine code, where human readable (relatively speaking) symbols are used to generate programs. </i>",
            "id": "5a3b3cb6d323bebf0b8a508854332333"
          },
          {
            "type": "html",
            "text": "\nRelatively speaking, as in an assembly program is as easy to read as an old BASIC program, even when decompiled from machine code. You just need to know how the processor behaves when it encounters a particular opcode, and handle it.",
            "id": "67619d2be043a585c602c693caf81234"
          },
          {
            "type": "html",
            "text": "\nHand-coded assembly is easy to write and maintain if you're good about naming the call and jump flags, and put in decent comments. The operations might be lower-level and constrained to certain integer maths, but that's no reason to write something unmaintainable or unreadable.",
            "id": "0bf4c8bb8d11872dd5622612558c9728"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "\n[[Assembly Language]] is one of the few (readable) levels at which the actual processor behaviors are exposed. Consequently, the most complete control of the \"currently defined\" processor behaviors is available in [[Assembly Language]] and those few others that grant direct access to the CPU.",
            "id": "9a42795766b915c63a2bda724ee62020"
          },
          {
            "type": "html",
            "text": "\nMost high-level languages will not represent the low-level behaviors of the processor - [[Forth Language]] and derivatives being exceptions.",
            "id": "42a88c9b77249466156db1ff7d44163e"
          },
          {
            "type": "html",
            "text": "\nThe \"currently defined\" behaviors of the processor are the subject of [[Micro Code]], which establishes the behaviors of the processor. Some exotic processors have writable [[Micro Code]], but for the vast majority of cases this will only be a curiosity: for all intents and purposes, the [[Micro Code]] can be considered part of the processor.",
            "id": "feeaf25820385123ceffa37a11b38123"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "\nProgramming at any level requires reasoning about the semantic structures at hand. High level languages claim to offer simpler or more appropriate structures, but often fall short of this goal when needs change or one is forced to reason about lower levels anyway. A regular dose of assembly programming will remind us what we should demand of our higher level languages. ",
            "id": "96eae1b1934a24fdd7d99a542e22ff0a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "\nMost of the discussion here seems to concern PC Assembly Language(s) - I am wondering if we should have a separate page for [[Mainframe Assembler Language]] (esp. IBM S/360/370/390/z90 Assembler Language). I think there is quite a lot to be said about this - in particular it has been going strong for almost 40 years, which has got to be some kind of record for a computer language... ",
            "id": "f055ab302fed66b83b5f219b874e3289"
          },
          {
            "type": "html",
            "text": "<i>No new page required. The title says [[Assembly Language]]; that's generic. Most of the discussion is about x86 assembly because that's what most people are familiar with. If you want to talk about 360 assembly, go right ahead. If the discussion becomes huge, <b>then</b> it would be interesting to calve a new page.</i> Now that pure x86 is pretty much a thing of the past as of 2004, is there going to be a discussion about AMD64 assembly?",
            "id": "f20eaf6c8a726f5cbd1fd93ad3011795"
          },
          {
            "type": "html",
            "text": "<i>So...how 'bout them base registers? Can't beat 'em.</i> ",
            "id": "2a55c4c70d65c0132745d1170488d5e8"
          },
          {
            "type": "html",
            "text": "<i>Hey, I think ARM assembly language is pretty cool.</i>",
            "id": "d60d5fea079445e6bd952ee9f4c78b74"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "<b>humorous assembly language</b>",
            "id": "ab5ea7c6f2531ed6565a50d5f6c4e3cd"
          },
          {
            "type": "html",
            "text": "\nfictional opcodes:",
            "id": "cd76fa87c4c985ca794fd4f7b96a53a8"
          },
          {
            "type": "code",
            "text": " BBW  Branch Both Ways\n DWIM  Do What I Mean\n FLI  Flash Lights Impressively\n HCF  Halt and Catch Fire\n HTS  Halt and Throw Sparks\n CMFRM  Come From",
            "id": "cdb8b864cc7996ffe2eb30a957dc0cee"
          },
          {
            "type": "html",
            "text": "\n[http://rdrop.com/users/jimka/assembly.html rdrop.com]",
            "id": "8a3129895a6f2715e63a4e01158cb4af"
          },
          {
            "type": "code",
            "text": " Hey, I remember doing assembly where BBW was available (threads implemented in microcode, yum!).",
            "id": "9bf88ccdfdf582e1241174e1ea60c838"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "<b>[[Better Assembly]]</b>",
            "id": "69118602775ef8bcdd913b2a36371eba"
          },
          {
            "type": "html",
            "text": "\n[[Preferred Order Of Src Dst Arguments]] and [[Forth Assisted Hand Assembly]] and [http://terse.com/ terse.com] have some interesting ideas on how to make a \"better\" assembly language (without going all the way to C).",
            "id": "107b6c217819f6ce1887d44297c82a99"
          },
          {
            "type": "html",
            "text": "\n[[Development Tools]]",
            "id": "61de4038e739c832680a3f82ed98b35a"
          },
          {
            "type": "html",
            "text": "\n[[Object Oriented Assembler]] mentions <i>\"assembler doesn't give any support for non-procedural methods\"</i>. Would it be crazy to write a \"better\" assembly language that provides some support for object-oriented methods?",
            "id": "4061b8dcfed482dd1f7d19294f066b01"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "<i>Anyone got any short sample programs?</i>",
            "id": "9cfff8b339ea8bae97c1eb4f2eb982e9"
          },
          {
            "type": "html",
            "text": " Here's a DEBUG script to create simple baud rate setup program.",
            "id": "561d7979b74721ad50d1ef367986be46"
          },
          {
            "type": "code",
            "text": "  C:\\>DEBUG\n  :  a 100            ; begin assembly code entry\n  :  mov al,0         ; zero, for \"off\"\n  :  mov dx,03F9      ; Com1 address + 1 = int enable register\n  :  out b al,dx      ; interrupts off\n  :  mov al,13        ; DTR+RTS+LBK (loop back mode)\n  :  mov dl,FC        ; Com1 address + 4 = modem ctrl register\n  :  out b al,dx      ; set loopback mode for Com1\n  :  mov al,83        ; 80 = DLAB, 03 = 8-bit mode mask\n  :  mov dl,FB        ; Com1 address + 3 = line ctrl register\n  :  out b al,dx      ; turn on divisor latch access\n  :  mov al,00        ; high-order byte of 000C\n  :  mov dl,F9        ; \"ie\" reg now high-order divisor byte\n  :  out b al,dx      ; place first half of divisor value\n  :  mov al,0C        ; low-order byte (that's 12)\n  :  mov dl,F8        ; \"data\" reg now low-order divisor byte\n  :  out b al,dx      ; place second half of divisor value\n  :  mov al,03        ; 8-bit mode mask without DLAB\n  :  mov dl,FB        ; Com1 address + 3 = line ctrl register\n  :  out b al,dx      ; turn off divisor latch access\n  :  nop              ; waste a cycle\n  :  mov dl,F8        ; Com1 base address = data register\n  :  in al,dx         ; clear the (first) RX data register\n  :  nop              ; just killing time\n  :  in al,dx         ; clear the (other) RX data register\n  :  mov al,03        ; DTR+RTS (without loop back bit)\n  :  mov dl,FC        ; Com1 address + 4 = modem ctrl register\n  :  out b al,dx      ; clear loopback mode for Com1\n  :  mov ax,4C00      ; terminate program, errorlevel=0\n  :  int 21           ; call DOS to end ; just press <Enter> next\n  :  n set9600.com    ; where to write the program\n  :  r cx             ; alter contents of CX register\n  :  003A             ; that's 58 for you civilians\n  :  w                ; create file and save program\n  :  q                ; leave DEBUG\n  dir set9600.com",
            "id": "4096df6eb7228dcdb8530c5d5db5fe93"
          },
          {
            "type": "html",
            "text": "You now have SET9600.com which ... does exactly that.",
            "id": "2d85f6a9994c77f78c35e41a4d54b6f3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "291b95de9761336b471b215819b4b579"
          },
          {
            "type": "html",
            "text": "[[Preferred Order Of Src Dst Arguments]]\n[[Digital Signal Processing]]\n[[Object Oriented Assembler]]\n[[Write Assembler]]",
            "id": "b6e7a74bc4bb7fcbbd41bb411d908661"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?AssemblyLanguage c2.com]",
            "id": "ba6a4b897b52d2f0ad9ce53b5bcb2d7b"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1708035568933
    }
  ]
}