{
  "title": "Global Variables Considered Harmful",
  "story": [
    {
      "type": "html",
      "text": "W.A. Wulf, M. Shaw; <i>Global Variables Considered Harmful</i>, ACM SIGPLAN Notices 8:2, Feb 1973, pp. 80-86",
      "id": "43a6bb5113fc0ad3a7cfe67686407556"
    },
    {
      "type": "html",
      "text": "\nConsidered by many to be one of the classic papers of computer science. Nowadays seems obvious - global variables enjoy a reputation only slightly better than that of the infamous [[Go To]] statement. I still use 'em occasionally, but cringe whenever I do.",
      "id": "0727bcb52ce7b161815aaba57ac8e72b"
    },
    {
      "type": "html",
      "text": "\nHowever, the interesting thing about this paper is that it claims to skewer one prominent language feature - with an effect similar to that of [[Global Variable]]s - embraced by many here on [[Wards Wiki]] - [[Lexical Scoping]], as found in languages such as [[Pascal Language]], [[Algol Language]], and, more importantly, [[Lisp Language]] (and to a lesser extent, [[Smalltalk Language]]).",
      "id": "a8bc1def1e0940393a32d1de130267e5"
    },
    {
      "type": "html",
      "text": "\nIn fact, the arguments in the paper are really targeted at [[Nested Scopes]]; they apply equally (or more forcefully) to [[Dynamic Scoping]] combined with [[Nested Scopes]].",
      "id": "a9f8b8409fb7e5c2dd7a96a3d74e2afb"
    },
    {
      "type": "html",
      "text": "\nIn any case, the paper gives four main arguments:",
      "id": "89da2f600486247113f7bc18749401b9"
    },
    {
      "type": "html",
      "text": " <b>Side effects</b>. Just like with globals; functions modifying variables other than their own locals can cause surprises of all sorts; if pass-by-reference is used then aliasing can occur when it isn't expected.",
      "id": "b12125bed264d18d632537016678a077"
    },
    {
      "type": "html",
      "text": " <b>Indiscriminate access</b>. The programmer cannot prevent sub-procedures from modifying the values of a local variable's procedures.",
      "id": "96bd186a99caaa570b95b1f6b3a40b92"
    },
    {
      "type": "html",
      "text": " <b>Vulnerability</b>. New declarations may be interposed between when a variable is declared in an outer scope and when it is used in an inner scope.",
      "id": "a83fba2b58a7b98c0be307ad2608338a"
    },
    {
      "type": "html",
      "text": " <b>No overlapping definitions</b>. It is difficult to control shared access to variables.",
      "id": "2e0728467e5c05ec9323738ebe88a880"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6f12a458d2ce576418bb43a555354229"
    },
    {
      "type": "html",
      "text": "This paper is outdated; nested lexical scoping is considered a very desirable feature these days. Here are counterarguments to each of the points above:",
      "id": "70f301d01f635cb5beab7d3dc02f2903"
    },
    {
      "type": "html",
      "text": "<b>Side effects</b>: Some languages have \"final\" or immutable variables. In that case, accessing only final variables in outer scopes (either as a coding convention, or enforced by the language) would eliminate any concerns about \"surprising\" side effects. Note that nested lexical scoping is also applicable to [[Pure Functional Language]]s, in which all variables are immutable.",
      "id": "306f49c5941bb8f2e6f8b110d1fc5c66"
    },
    {
      "type": "html",
      "text": "The point about pass-by-reference is largely irrelevant since very few modern programming languages use pass-by-reference. (Languages that pass \"references\" <b>by value</b> are not pass-by-reference.)",
      "id": "56a36333f34bc298974cf21df75234ed"
    },
    {
      "type": "html",
      "text": "[Huh? Pass-by-reference ALWAYS requires passing a reference by value. That's how it works. The question is whether the referenced object is a COPY of the caller's object, or an ALIAS for the user's value. Most modern languages pass by reference for non-primitive types.]",
      "id": "57c7b2b8de8100a863613b1c89d5445a"
    },
    {
      "type": "html",
      "text": "<b>Indiscriminate access</b>: Essentially a repetition of point 1, and the same counterargument applies.",
      "id": "a68669735fa3e05636ade3b900f0ce5d"
    },
    {
      "type": "html",
      "text": "<b>Vulnerability</b>: \"New declarations may be interposed between when a variable is declared in an outer scope and when it is used in an inner scope.\" So [[Dont Do That]]. This is not difficult to avoid, and it would be easy for a compiler to warn about this situation (it should not be an error).",
      "id": "a11136126f8403e886587ae7b34a243e"
    },
    {
      "type": "html",
      "text": "Note that any rule other than accessing the \"innermost\" declaration of a variable, would change the meaning of a code fragment if it is moved to another context, and some local variable coincidentally shadows a variable in an outer scope. In any case, variables can and should be renamed in cases where shadowing makes a program too confusing.",
      "id": "5204d7f929512b70a5759fb4c15317b5"
    },
    {
      "type": "html",
      "text": "<b>No overlapping definitions</b>: It is <b>not</b> difficult to control shared access to variables because of [[Lexical Scoping]]. On the contrary, [[Object Capability Language]]s generally support nested lexical scoping precisely because it makes it easier to avoid using global variables, and thereby makes controlling shared access to variables <b>easier</b>.",
      "id": "1f2b47ff45aac6347effb38ec964d31e"
    },
    {
      "type": "html",
      "text": "\nMany arguments against global variables that are independent of both [[Lexical Scoping]] and [[Nested Scopes]] are given in [[Global Variables Are Bad]].",
      "id": "2f61a5dc64cace8efacbe72ffa367560"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6f12a458d2ce576418bb43a555354229"
    },
    {
      "type": "html",
      "text": "In addition (the paper doesn't discuss this); implementing [[Lexical Scoping]] (with inner functions having access to outer function variables) poses lots of implementation difficulties for the language. You need a [[Static Chain]] (or a \"display\") to be able to access variables defined in enclosing scopes; implementing [[First Class]] [[Lexical Closure]]s becomes a pain in the butt.",
      "id": "ce0f9efcc359759894ee434ce0894759"
    },
    {
      "type": "html",
      "text": "\nThis is merely conjecture on my part; but I think one of the reasons that [[Cee Language]] was so successful early on is that it threw [[Lexical Scoping]] into the bin. It simplified both the semantics and the implementation of the language greatly. The success of C (and C++, [[No Flames Please]]) are good evidence that [[Lexical Scoping]] is not needed.",
      "id": "b927cbd7213a211b94a5816fc74bea99"
    },
    {
      "type": "html",
      "text": "[Huh? C <i>is</i> lexically scoped. And lexical scope has nothing to do with \"procedures being able to modify global variables\". That is a totally orthogonal issue. How is it any better when a dynamically scoped language allows global variables to be altered by a procedure? In fact, it can be much worse, since the name of the variable, built into the procedure, could then enable the procedure to refer to some variable some poor sap who calls the procedure just happened to name the same way]",
      "id": "442165abab0da6ad378fdef1d0a79cf2"
    },
    {
      "type": "html",
      "text": "<i>Yes, C is lexically scoped. The above comments were made before this page was changed to distinguish between [[Lexical Scoping]] and [[Nested Scopes]]. It is [[Lexical Scoping]] <b>combined</b> with [[Nested Scopes]] that causes the implementation difficulty.</i>",
      "id": "0c3be47cbfe333308a243a9ff92fda6f"
    },
    {
      "type": "html",
      "text": "<i>In fact [[Dynamic Scoping]] combined with [[Nested Scopes]] is even more difficult. [[Henry Baker]] wrote a paper on this, which is on-line at [http://home.pipeline.com/~hbaker1/BuriedStale.html home.pipeline.com] . Despite the title \"The Buried Binding and Dead Binding Problems of Lisp 1.5\", the problems it describes apply to [[Dynamic Scoping]] in general.</i>",
      "id": "36eb29399bfe8be10a7186bda763849f"
    },
    {
      "type": "html",
      "text": "<The [[Dynamic Scoping]]/[[Lexical Scoping]] thing doesn't apply to C/C++; as you cannot have functions within functions in either language. However, you can have classes within functions (and member functions within those classes) in C++; a member function has access to the attributes of the defining class; but not to any other outer scope. A class defined in another class has no access to the members of the outer class, either - except through a reference to the outer class. Java [[Inner Class]]es do bring back some elements of [[Lexical Scoping]] - in inner class defined in a function is similar to a [[Lexical Closure]] in some ways.>",
      "id": "84f825dd1aa8d46a21a3074ecb7bf0f6"
    },
    {
      "type": "html",
      "text": "\nClass-like variables can be used in C by declaring them static within a .C file. These variables will be visible to all methods within the file, but hidden to methods outside the file.",
      "id": "f1a8a61796a91c5b5558abbf4b94103d"
    },
    {
      "type": "html",
      "text": "[This misunderstands the point. Here's an example of C extended to have nested lexical scoping:]",
      "id": "ef9ce16ec034b751d88ba615b461a47a"
    },
    {
      "type": "code",
      "text": "  typedef (*FuncPtr)();\n  FuncPtr  /* f returns pointer to function */\n  f() {\n  FuncPtr ret;\n  int i = 0;\n  /* here is a nested lexically scoped func that accesses i */\n  void g() { printf(\"%d\\n\", i); }\n  g();   /* ==> 0 */\n  ++i;\n  g();   /* ==> 1 */\n  return g;  /* return ptr to nested function g from f */\n  }\n  main() {\n  FuncPtr h;\n  h = f();  /* prints 0, then 1 */\n  (*h)();  /* indirect call to g(), prints 1 */\n  }",
      "id": "7fb6a5981cf16e69955742a8edf4d858"
    },
    {
      "type": "html",
      "text": "\nThis indicates the difficulty. When f() is called via the [[Func Ptr]] h in main(), g() still has valid access to the stack variable i in f(), which means that the C compiler is not allowed to throw away the stack frame(s) created by f() when f() returns. Also, if f() is recursive, the i that g() references must be the one in the most recent stack frame created by f().",
      "id": "3266bdbd41bcd445ad4250fe19626767"
    },
    {
      "type": "html",
      "text": "\nThis is full \"nested lexical scoping\". As someone said above, it requires a [[Static Chain]]/display to achieve this effect, it has to do fancy stuff with tracking stack frames, etc. It's all hugely complicated compared with C semantics... and all of the obvious implementations can require an arbitrary amount of computation, in the worst case, just to access the value of \"i\".",
      "id": "8e6c6533ea75733bd1da6db6000b268e"
    },
    {
      "type": "html",
      "text": "<The [[Static Chain]]/display is required for any sort of nested lexical scoping, even in the absence of [[First Class]] [[Lexical Closure]]s.>",
      "id": "abe6e75d6971baa77e0eef367ff824d1"
    },
    {
      "type": "html",
      "text": "\nAs they said, it is indeed arguable that leaving out this crud helped with C's success.",
      "id": "ffe602045ac3e9f751d8f58c3759c7e4"
    },
    {
      "type": "html",
      "text": "\nFurthermore, although Lisp's \"modern\" lexical scoping is preferable to the older dynamic scoping, and although it is sort of necessary just to be able to create local variables with e.g. the LET macro, at least in the paradigm the Lisp world is accustomed to, there is indeed a strong argument that it is nonetheless evil in the absolute.",
      "id": "4df0819643a3495b4be7ef3c36fb7a01"
    },
    {
      "type": "html",
      "text": "<Macros, as opposed to functions, get [[Lexical Scoping]] for free - after all, when a macro is expanded it doesn't create a new scope (unless the macro definition contains code to cause a new scope to be created. Of course, macros are not first-class entities in <i>any</i> language that I'm aware of...>",
      "id": "4fb9d7cfda8414f805168fc3bf62dee2"
    },
    {
      "type": "html",
      "text": " Please tell me you don't mean \"first-class\" as equivalent to \"can be manipulated as a value or object at runtime\", because (A) I don't think that's the most accurate definition of \"first-class\", and (B) macros exist only at compile-read time by definition, in any language, including assembler where they were first invented, so of course they can never be manipulated at run-time, that would be self-contradictory. But they <b>could</b> be [[First Class]] at compile-read time... I would have thought that there were indeed Lisp dialects that did so.",
      "id": "b08ecac2121aea48e5f197954de718a2"
    },
    {
      "type": "html",
      "text": "<That's what I meant; I couldn't think of a better way to say it. It <i>might</i> be possible to [[Unify Macros And Functions]] at some point - [[Lisp Language]] comes close in that it can read in new code on the fly (and process macros invoked therein). As discussed in [[Cee Preprocessor Statements]]; there are things that can be done only with macros (and things that can only be done with functions, at least in current languages).>",
      "id": "48d8cbf02cbcbd4e5660b225d1a5c194"
    },
    {
      "type": "html",
      "text": "\nAnd from the point of view of the innermost function, it is all about a variable that is in fact \"global\" from that nested function's point of view.",
      "id": "ccc049600ac77f28ae043858a92ed0a2"
    },
    {
      "type": "html",
      "text": "-- [[Doug Merritt]]",
      "id": "2c3b652593f544937156fd7e638a9029"
    },
    {
      "type": "html",
      "text": "[No, macros are dynamic scoping, and C/C++ (as opposed to C/C++ considering macros as part of the language) are lexically scoped. Lexical/dynamic scope have nothing to do with whether or not nested scopes are allowed. C is simpler to implement (and in many cases simpler to understand) than the Algol family of languages because it does not have nested scopes, not because it does not have lexical scope. When you define a global variable in a file with a function, that one level of scope allowed is lexical. The function, when called, always refers to that variable which is in its own <i>lexical</i> scope. However, when a macro is expanded, if it has a free variable in its definition, that free variable will end up referring to the free variable in its context of expansion. So, macros are scoped dynamically, not lexically]",
      "id": "fde473bdb1efc6a892b7ddb2d540d876"
    },
    {
      "type": "html",
      "text": "[[More precisely, macros are [[Shallow Binding]] dynamic scoping. They look up variables in the scope of their expansion, but they don't trace unbound variables down the dynamic call stack. [[Dynamic Scoping]], as used in early Lisp dialects and Elisp, will continue searching the call stack until it finds the appropriate variable. This is [[Deep Binding]]]]",
      "id": "3daf65fc5052ae954e5f4f80a03cc95d"
    },
    {
      "type": "html",
      "text": "<You're correct, of course - with the possible exception of [[Hygienic Macros]]. However, I wasn't considering those>",
      "id": "433032487bb043edb1bf4d5b5ba3ab65"
    },
    {
      "type": "html",
      "text": "<Perhaps we need a page for [[Nested Scopes]]?>",
      "id": "480758801479f7db8d9d30ac19abcd4c"
    },
    {
      "type": "html",
      "text": "<i>Perhaps, but now I'm wondering if there's an authoritative source for getting the terminology right, because after all, you can have scoping based on lexical level as well as [[Nested Scopes]] but still not need chains/displays; many of these issues are more often than not all crammed together into a single term, like [[Lexical Scoping]] has done.</i>",
      "id": "8d29d0d6578f1b1c72ca0f7c0b2addcd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6f12a458d2ce576418bb43a555354229"
    },
    {
      "type": "html",
      "text": "See also [[Global Variables Are Bad]], [[Global Constants Considered Harmful]]",
      "id": "faa9de620a6231485931a0496ef392b0"
    },
    {
      "type": "html",
      "text": "\n[[Category Paper]] [[Considered Harmful]]",
      "id": "19aa11bf048158fafd1526e05ff2348d"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?GlobalVariablesConsideredHarmful c2.com]",
      "id": "264c9366b57d4b2b25b1e3a6b846d994"
    }
  ],
  "journal": [
    {
      "date": 1278787772000,
      "id": "00b254582ba9c9e81c7cf5d6925ddf31",
      "type": "create",
      "item": {
        "title": "Global Variables Considered Harmful",
        "story": [
          {
            "type": "html",
            "text": "W.A. Wulf, M. Shaw; <i>Global Variables Considered Harmful</i>, ACM SIGPLAN Notices 8:2, Feb 1973, pp. 80-86",
            "id": "43a6bb5113fc0ad3a7cfe67686407556"
          },
          {
            "type": "html",
            "text": "\nConsidered by many to be one of the classic papers of computer science. Nowadays seems obvious - global variables enjoy a reputation only slightly better than that of the infamous [[Go To]] statement. I still use 'em occasionally, but cringe whenever I do.",
            "id": "0727bcb52ce7b161815aaba57ac8e72b"
          },
          {
            "type": "html",
            "text": "\nHowever, the interesting thing about this paper is that it claims to skewer one prominent language feature - with an effect similar to that of [[Global Variable]]s - embraced by many here on [[Wards Wiki]] - [[Lexical Scoping]], as found in languages such as [[Pascal Language]], [[Algol Language]], and, more importantly, [[Lisp Language]] (and to a lesser extent, [[Smalltalk Language]]).",
            "id": "a8bc1def1e0940393a32d1de130267e5"
          },
          {
            "type": "html",
            "text": "\nIn fact, the arguments in the paper are really targeted at [[Nested Scopes]]; they apply equally (or more forcefully) to [[Dynamic Scoping]] combined with [[Nested Scopes]].",
            "id": "a9f8b8409fb7e5c2dd7a96a3d74e2afb"
          },
          {
            "type": "html",
            "text": "\nIn any case, the paper gives four main arguments:",
            "id": "89da2f600486247113f7bc18749401b9"
          },
          {
            "type": "html",
            "text": " <b>Side effects</b>. Just like with globals; functions modifying variables other than their own locals can cause surprises of all sorts; if pass-by-reference is used then aliasing can occur when it isn't expected.",
            "id": "b12125bed264d18d632537016678a077"
          },
          {
            "type": "html",
            "text": " <b>Indiscriminate access</b>. The programmer cannot prevent sub-procedures from modifying the values of a local variable's procedures.",
            "id": "96bd186a99caaa570b95b1f6b3a40b92"
          },
          {
            "type": "html",
            "text": " <b>Vulnerability</b>. New declarations may be interposed between when a variable is declared in an outer scope and when it is used in an inner scope.",
            "id": "a83fba2b58a7b98c0be307ad2608338a"
          },
          {
            "type": "html",
            "text": " <b>No overlapping definitions</b>. It is difficult to control shared access to variables.",
            "id": "2e0728467e5c05ec9323738ebe88a880"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6f12a458d2ce576418bb43a555354229"
          },
          {
            "type": "html",
            "text": "This paper is outdated; nested lexical scoping is considered a very desirable feature these days. Here are counterarguments to each of the points above:",
            "id": "70f301d01f635cb5beab7d3dc02f2903"
          },
          {
            "type": "html",
            "text": "<b>Side effects</b>: Some languages have \"final\" or immutable variables. In that case, accessing only final variables in outer scopes (either as a coding convention, or enforced by the language) would eliminate any concerns about \"surprising\" side effects. Note that nested lexical scoping is also applicable to [[Pure Functional Language]]s, in which all variables are immutable.",
            "id": "306f49c5941bb8f2e6f8b110d1fc5c66"
          },
          {
            "type": "html",
            "text": "The point about pass-by-reference is largely irrelevant since very few modern programming languages use pass-by-reference. (Languages that pass \"references\" <b>by value</b> are not pass-by-reference.)",
            "id": "56a36333f34bc298974cf21df75234ed"
          },
          {
            "type": "html",
            "text": "[Huh? Pass-by-reference ALWAYS requires passing a reference by value. That's how it works. The question is whether the referenced object is a COPY of the caller's object, or an ALIAS for the user's value. Most modern languages pass by reference for non-primitive types.]",
            "id": "57c7b2b8de8100a863613b1c89d5445a"
          },
          {
            "type": "html",
            "text": "<b>Indiscriminate access</b>: Essentially a repetition of point 1, and the same counterargument applies.",
            "id": "a68669735fa3e05636ade3b900f0ce5d"
          },
          {
            "type": "html",
            "text": "<b>Vulnerability</b>: \"New declarations may be interposed between when a variable is declared in an outer scope and when it is used in an inner scope.\" So [[Dont Do That]]. This is not difficult to avoid, and it would be easy for a compiler to warn about this situation (it should not be an error).",
            "id": "a11136126f8403e886587ae7b34a243e"
          },
          {
            "type": "html",
            "text": "Note that any rule other than accessing the \"innermost\" declaration of a variable, would change the meaning of a code fragment if it is moved to another context, and some local variable coincidentally shadows a variable in an outer scope. In any case, variables can and should be renamed in cases where shadowing makes a program too confusing.",
            "id": "5204d7f929512b70a5759fb4c15317b5"
          },
          {
            "type": "html",
            "text": "<b>No overlapping definitions</b>: It is <b>not</b> difficult to control shared access to variables because of [[Lexical Scoping]]. On the contrary, [[Object Capability Language]]s generally support nested lexical scoping precisely because it makes it easier to avoid using global variables, and thereby makes controlling shared access to variables <b>easier</b>.",
            "id": "1f2b47ff45aac6347effb38ec964d31e"
          },
          {
            "type": "html",
            "text": "\nMany arguments against global variables that are independent of both [[Lexical Scoping]] and [[Nested Scopes]] are given in [[Global Variables Are Bad]].",
            "id": "2f61a5dc64cace8efacbe72ffa367560"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6f12a458d2ce576418bb43a555354229"
          },
          {
            "type": "html",
            "text": "In addition (the paper doesn't discuss this); implementing [[Lexical Scoping]] (with inner functions having access to outer function variables) poses lots of implementation difficulties for the language. You need a [[Static Chain]] (or a \"display\") to be able to access variables defined in enclosing scopes; implementing [[First Class]] [[Lexical Closure]]s becomes a pain in the butt.",
            "id": "ce0f9efcc359759894ee434ce0894759"
          },
          {
            "type": "html",
            "text": "\nThis is merely conjecture on my part; but I think one of the reasons that [[Cee Language]] was so successful early on is that it threw [[Lexical Scoping]] into the bin. It simplified both the semantics and the implementation of the language greatly. The success of C (and C++, [[No Flames Please]]) are good evidence that [[Lexical Scoping]] is not needed.",
            "id": "b927cbd7213a211b94a5816fc74bea99"
          },
          {
            "type": "html",
            "text": "[Huh? C <i>is</i> lexically scoped. And lexical scope has nothing to do with \"procedures being able to modify global variables\". That is a totally orthogonal issue. How is it any better when a dynamically scoped language allows global variables to be altered by a procedure? In fact, it can be much worse, since the name of the variable, built into the procedure, could then enable the procedure to refer to some variable some poor sap who calls the procedure just happened to name the same way]",
            "id": "442165abab0da6ad378fdef1d0a79cf2"
          },
          {
            "type": "html",
            "text": "<i>Yes, C is lexically scoped. The above comments were made before this page was changed to distinguish between [[Lexical Scoping]] and [[Nested Scopes]]. It is [[Lexical Scoping]] <b>combined</b> with [[Nested Scopes]] that causes the implementation difficulty.</i>",
            "id": "0c3be47cbfe333308a243a9ff92fda6f"
          },
          {
            "type": "html",
            "text": "<i>In fact [[Dynamic Scoping]] combined with [[Nested Scopes]] is even more difficult. [[Henry Baker]] wrote a paper on this, which is on-line at [http://home.pipeline.com/~hbaker1/BuriedStale.html home.pipeline.com] . Despite the title \"The Buried Binding and Dead Binding Problems of Lisp 1.5\", the problems it describes apply to [[Dynamic Scoping]] in general.</i>",
            "id": "36eb29399bfe8be10a7186bda763849f"
          },
          {
            "type": "html",
            "text": "<The [[Dynamic Scoping]]/[[Lexical Scoping]] thing doesn't apply to C/C++; as you cannot have functions within functions in either language. However, you can have classes within functions (and member functions within those classes) in C++; a member function has access to the attributes of the defining class; but not to any other outer scope. A class defined in another class has no access to the members of the outer class, either - except through a reference to the outer class. Java [[Inner Class]]es do bring back some elements of [[Lexical Scoping]] - in inner class defined in a function is similar to a [[Lexical Closure]] in some ways.>",
            "id": "84f825dd1aa8d46a21a3074ecb7bf0f6"
          },
          {
            "type": "html",
            "text": "\nClass-like variables can be used in C by declaring them static within a .C file. These variables will be visible to all methods within the file, but hidden to methods outside the file.",
            "id": "f1a8a61796a91c5b5558abbf4b94103d"
          },
          {
            "type": "html",
            "text": "[This misunderstands the point. Here's an example of C extended to have nested lexical scoping:]",
            "id": "ef9ce16ec034b751d88ba615b461a47a"
          },
          {
            "type": "code",
            "text": "  typedef (*FuncPtr)();\n  FuncPtr  /* f returns pointer to function */\n  f() {\n  FuncPtr ret;\n  int i = 0;\n  /* here is a nested lexically scoped func that accesses i */\n  void g() { printf(\"%d\\n\", i); }\n  g();   /* ==> 0 */\n  ++i;\n  g();   /* ==> 1 */\n  return g;  /* return ptr to nested function g from f */\n  }\n  main() {\n  FuncPtr h;\n  h = f();  /* prints 0, then 1 */\n  (*h)();  /* indirect call to g(), prints 1 */\n  }",
            "id": "7fb6a5981cf16e69955742a8edf4d858"
          },
          {
            "type": "html",
            "text": "\nThis indicates the difficulty. When f() is called via the [[Func Ptr]] h in main(), g() still has valid access to the stack variable i in f(), which means that the C compiler is not allowed to throw away the stack frame(s) created by f() when f() returns. Also, if f() is recursive, the i that g() references must be the one in the most recent stack frame created by f().",
            "id": "3266bdbd41bcd445ad4250fe19626767"
          },
          {
            "type": "html",
            "text": "\nThis is full \"nested lexical scoping\". As someone said above, it requires a [[Static Chain]]/display to achieve this effect, it has to do fancy stuff with tracking stack frames, etc. It's all hugely complicated compared with C semantics... and all of the obvious implementations can require an arbitrary amount of computation, in the worst case, just to access the value of \"i\".",
            "id": "8e6c6533ea75733bd1da6db6000b268e"
          },
          {
            "type": "html",
            "text": "<The [[Static Chain]]/display is required for any sort of nested lexical scoping, even in the absence of [[First Class]] [[Lexical Closure]]s.>",
            "id": "abe6e75d6971baa77e0eef367ff824d1"
          },
          {
            "type": "html",
            "text": "\nAs they said, it is indeed arguable that leaving out this crud helped with C's success.",
            "id": "ffe602045ac3e9f751d8f58c3759c7e4"
          },
          {
            "type": "html",
            "text": "\nFurthermore, although Lisp's \"modern\" lexical scoping is preferable to the older dynamic scoping, and although it is sort of necessary just to be able to create local variables with e.g. the LET macro, at least in the paradigm the Lisp world is accustomed to, there is indeed a strong argument that it is nonetheless evil in the absolute.",
            "id": "4df0819643a3495b4be7ef3c36fb7a01"
          },
          {
            "type": "html",
            "text": "<Macros, as opposed to functions, get [[Lexical Scoping]] for free - after all, when a macro is expanded it doesn't create a new scope (unless the macro definition contains code to cause a new scope to be created. Of course, macros are not first-class entities in <i>any</i> language that I'm aware of...>",
            "id": "4fb9d7cfda8414f805168fc3bf62dee2"
          },
          {
            "type": "html",
            "text": " Please tell me you don't mean \"first-class\" as equivalent to \"can be manipulated as a value or object at runtime\", because (A) I don't think that's the most accurate definition of \"first-class\", and (B) macros exist only at compile-read time by definition, in any language, including assembler where they were first invented, so of course they can never be manipulated at run-time, that would be self-contradictory. But they <b>could</b> be [[First Class]] at compile-read time... I would have thought that there were indeed Lisp dialects that did so.",
            "id": "b08ecac2121aea48e5f197954de718a2"
          },
          {
            "type": "html",
            "text": "<That's what I meant; I couldn't think of a better way to say it. It <i>might</i> be possible to [[Unify Macros And Functions]] at some point - [[Lisp Language]] comes close in that it can read in new code on the fly (and process macros invoked therein). As discussed in [[Cee Preprocessor Statements]]; there are things that can be done only with macros (and things that can only be done with functions, at least in current languages).>",
            "id": "48d8cbf02cbcbd4e5660b225d1a5c194"
          },
          {
            "type": "html",
            "text": "\nAnd from the point of view of the innermost function, it is all about a variable that is in fact \"global\" from that nested function's point of view.",
            "id": "ccc049600ac77f28ae043858a92ed0a2"
          },
          {
            "type": "html",
            "text": "-- [[Doug Merritt]]",
            "id": "2c3b652593f544937156fd7e638a9029"
          },
          {
            "type": "html",
            "text": "[No, macros are dynamic scoping, and C/C++ (as opposed to C/C++ considering macros as part of the language) are lexically scoped. Lexical/dynamic scope have nothing to do with whether or not nested scopes are allowed. C is simpler to implement (and in many cases simpler to understand) than the Algol family of languages because it does not have nested scopes, not because it does not have lexical scope. When you define a global variable in a file with a function, that one level of scope allowed is lexical. The function, when called, always refers to that variable which is in its own <i>lexical</i> scope. However, when a macro is expanded, if it has a free variable in its definition, that free variable will end up referring to the free variable in its context of expansion. So, macros are scoped dynamically, not lexically]",
            "id": "fde473bdb1efc6a892b7ddb2d540d876"
          },
          {
            "type": "html",
            "text": "[[More precisely, macros are [[Shallow Binding]] dynamic scoping. They look up variables in the scope of their expansion, but they don't trace unbound variables down the dynamic call stack. [[Dynamic Scoping]], as used in early Lisp dialects and Elisp, will continue searching the call stack until it finds the appropriate variable. This is [[Deep Binding]]]]",
            "id": "3daf65fc5052ae954e5f4f80a03cc95d"
          },
          {
            "type": "html",
            "text": "<You're correct, of course - with the possible exception of [[Hygienic Macros]]. However, I wasn't considering those>",
            "id": "433032487bb043edb1bf4d5b5ba3ab65"
          },
          {
            "type": "html",
            "text": "<Perhaps we need a page for [[Nested Scopes]]?>",
            "id": "480758801479f7db8d9d30ac19abcd4c"
          },
          {
            "type": "html",
            "text": "<i>Perhaps, but now I'm wondering if there's an authoritative source for getting the terminology right, because after all, you can have scoping based on lexical level as well as [[Nested Scopes]] but still not need chains/displays; many of these issues are more often than not all crammed together into a single term, like [[Lexical Scoping]] has done.</i>",
            "id": "8d29d0d6578f1b1c72ca0f7c0b2addcd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6f12a458d2ce576418bb43a555354229"
          },
          {
            "type": "html",
            "text": "See also [[Global Variables Are Bad]], [[Global Constants Considered Harmful]]",
            "id": "faa9de620a6231485931a0496ef392b0"
          },
          {
            "type": "html",
            "text": "\n[[Category Paper]] [[Considered Harmful]]",
            "id": "19aa11bf048158fafd1526e05ff2348d"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?GlobalVariablesConsideredHarmful c2.com]",
            "id": "264c9366b57d4b2b25b1e3a6b846d994"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1674055549358
    }
  ]
}