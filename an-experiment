{
  "title": "An Experiment",
  "story": [
    {
      "type": "paragraph",
      "id": "515a642b7f7052ff",
      "text": "Well, but if it is truly about [[labels]] and [[distinctions]], how does it actually happen for us? At this point, it may be good to consider the following interpretation."
    },
    {
      "type": "paragraph",
      "id": "29d4ddedad9a36a2",
      "text": "There is a soup of labels. The labels are in a space which contains all the things we can experience. Each point of this space has a corresponding label, which can be thought of its position indicator in the space (note the dual behavior of labels)."
    },
    {
      "type": "paragraph",
      "id": "362f52a26f060a51",
      "text": "Perceiving things in this label space corresponds to the act of distinguishing, out of the soup, a few individual labels and putting them inside a distinction. The idea behind doing this is that of clustering, as we saw earlier in the book. Then, according to your intentions, give a distinct label to each of the labels inside a distinction. Give a label to the distinction itself as well."
    },
    {
      "type": "paragraph",
      "id": "b3b2781dffe7451f",
      "text": "At this point, we just recognize things out of the soup of labels, and these things have no behavior associated to them. So now we need to model behavior."
    },
    {
      "type": "markdown",
      "id": "506067e348ecf075",
      "text": "Behavior, as we saw when discussing the optimization of `match:`, is a map between two label spaces, which in our case happen to be the same universal space. So a behavior is a label map living inside our soup of labels."
    },
    {
      "type": "paragraph",
      "id": "03aa0eadce2b3e9b",
      "text": "As we discussed, behavior may have a static context. But what if it refers to names that do not live in the static context? These would be the “arguments”, so to speak. Let’s write behavior assuming these names will be provided — note that this is what we do when we write methods and blocks. Then, invoking or even mounting behavior on top of a distinction requires us to provide a name map between the names the behavior uses, and the names inside the distinction. In Smalltalk, this renaming occurs automatically when we send messages or evaluate blocks."
    },
    {
      "type": "paragraph",
      "id": "6712b8c551efe790",
      "text": "Note how Smalltalk classes would be more or less permanent mountings of particular behavior on top of distinctions which contain a fixed amount of labeled distinctions."
    },
    {
      "type": "paragraph",
      "id": "4a8b603614217af5",
      "text": "Now, behavior is a name map. The name map that connects behaviors and distinctions is evidently a name map. And our distinction is a label map as well. Should we write our programs in these terms instead?"
    },
    {
      "type": "paragraph",
      "id": "d41a0d3e89e69825",
      "text": "After writing a prototype, [[Andrés Valloud]] has to answer no to this question: "
    },
    {
      "type": "markdown",
      "id": "a372eb3aca4281eb",
      "text": "> In my experience, the code was much more verbose than Smalltalk. "
    },
    {
      "type": "paragraph",
      "id": "fac1dc1eea56f2c4",
      "text": "At the same time, Smalltalk code could be seen as a way to express the ideas in this section. The lesson, therefore, is that it is not necessary to express the whole  thought in the computer, just the result of the thought process is enough as long its expression is intention revealing.\n\n"
    },
    {
      "type": "markdown",
      "id": "71aedfc4f137bc2d",
      "text": "> “Well, that is what [Smalltalk] is designed to do.” —Dan Ingalls"
    },
    {
      "type": "paragraph",
      "id": "2746fe8830d0418d",
      "text": "The reasons for this are fundamentally and critically important. As we know, we can only hold 7 ± 2 things in our minds. Consequently, as long as we carry most of our thoughts with things allocated to our local scratch ram, our speed of thought will be very fast. But if we now allocate some of the things we need to think into the computer, referencing such things will cause human interface traffic. In the same way that swap space thrashing brings any computer to its knees, excess of communication between us and the computer will considerably reduce our performance. Moreover, stressing our paging system will invariably lead to a higher probability of error."
    },
    {
      "type": "paragraph",
      "id": "a8c2b719b53bc473",
      "text": "Language design is an exercise of [[scratch ram register allocation]]. And as such, we can think of soups of labels, or even typed lambda calculus if we so desire — as long as the artifacts representing the results of such thought are extremely concise to minimize the impact of human interface chatter on our performance, yet intention revealing enough so that we can quickly reconstruct the thought processes that led to the particular expression of our solution."
    },
    {
      "type": "pagefold",
      "id": "4ea5a2c2a88ed650",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "cd720f2b5bc13498",
      "text": "Appendix A.2 of [[A Mentoring Course on Smalltalk]], [[Design Distinctions behind Smalltalk]]"
    },
    {
      "type": "reference",
      "id": "cf0abb38fc65fb30",
      "site": "wellspring.fed.wiki",
      "slug": "an-experiment",
      "title": "An Experiment",
      "text": "Seven years ago Jami Fluke and I embarked on an experiment inspired by a single question: If we introduced the mindset of this new age – called the agile mindset – to her school, might she be able to unleash the creative genius of her students?"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "An Experiment",
        "story": []
      },
      "date": 1660200194421
    },
    {
      "item": {
        "type": "factory",
        "id": "515a642b7f7052ff"
      },
      "id": "515a642b7f7052ff",
      "type": "add",
      "date": 1660200204116
    },
    {
      "type": "edit",
      "id": "515a642b7f7052ff",
      "item": {
        "type": "paragraph",
        "id": "515a642b7f7052ff",
        "text": "Well, but if it is truly about labels and distinctions, how does it actually happen for us? At this point, it may be good to consider the following interpretation."
      },
      "date": 1660200205610
    },
    {
      "item": {
        "type": "factory",
        "id": "29d4ddedad9a36a2"
      },
      "id": "29d4ddedad9a36a2",
      "type": "add",
      "after": "515a642b7f7052ff",
      "date": 1660200221973
    },
    {
      "type": "edit",
      "id": "29d4ddedad9a36a2",
      "item": {
        "type": "paragraph",
        "id": "29d4ddedad9a36a2",
        "text": "There is a soup of labels. The labels are in a space which contains all the things we can experience. Each point of this space has a corresponding label, which can be thought of its position indicator in the space (note the dual behavior of labels)."
      },
      "date": 1660200223904
    },
    {
      "item": {
        "type": "factory",
        "id": "362f52a26f060a51"
      },
      "id": "362f52a26f060a51",
      "type": "add",
      "after": "29d4ddedad9a36a2",
      "date": 1660200239703
    },
    {
      "type": "edit",
      "id": "362f52a26f060a51",
      "item": {
        "type": "paragraph",
        "id": "362f52a26f060a51",
        "text": "Perceiving things in this label space corresponds to the act of distinguishing, out of the soup, a few individual labels and putting them inside a distinction. The idea behind doing this is that of clustering, as we saw earlier in the book. Then, according to your intentions, give a distinct label to each of the labels inside a distinction. Give a label to the distinction itself as well."
      },
      "date": 1660200241247
    },
    {
      "item": {
        "type": "factory",
        "id": "b3b2781dffe7451f"
      },
      "id": "b3b2781dffe7451f",
      "type": "add",
      "after": "362f52a26f060a51",
      "date": 1660200249725
    },
    {
      "type": "edit",
      "id": "b3b2781dffe7451f",
      "item": {
        "type": "paragraph",
        "id": "b3b2781dffe7451f",
        "text": "At this point, we just recognize things out of the soup of labels, and these things have no behavior associated to them. So now we need to model behavior."
      },
      "date": 1660200251410
    },
    {
      "item": {
        "type": "factory",
        "id": "506067e348ecf075"
      },
      "id": "506067e348ecf075",
      "type": "add",
      "after": "b3b2781dffe7451f",
      "date": 1660200548366
    },
    {
      "type": "edit",
      "id": "506067e348ecf075",
      "item": {
        "type": "paragraph",
        "id": "506067e348ecf075",
        "text": "Behavior, as we saw when discussing the optimization of match:, is a map between two label spaces, which in our case happen to be the same universal space. So a behavior is a label map living inside our soup of labels."
      },
      "date": 1660200549803
    },
    {
      "type": "edit",
      "id": "506067e348ecf075",
      "item": {
        "type": "paragraph",
        "id": "506067e348ecf075",
        "text": "Behavior, as we saw when discussing the optimization of `match:`, is a map between two label spaces, which in our case happen to be the same universal space. So a behavior is a label map living inside our soup of labels."
      },
      "date": 1660200565390
    },
    {
      "type": "edit",
      "id": "506067e348ecf075",
      "item": {
        "type": "markdown",
        "id": "506067e348ecf075",
        "text": "Behavior, as we saw when discussing the optimization of `match:`, is a map between two label spaces, which in our case happen to be the same universal space. So a behavior is a label map living inside our soup of labels."
      },
      "date": 1660200566632
    },
    {
      "item": {
        "type": "factory",
        "id": "03aa0eadce2b3e9b"
      },
      "id": "03aa0eadce2b3e9b",
      "type": "add",
      "after": "506067e348ecf075",
      "date": 1660200584959
    },
    {
      "type": "edit",
      "id": "03aa0eadce2b3e9b",
      "item": {
        "type": "paragraph",
        "id": "03aa0eadce2b3e9b",
        "text": "As we discussed, behavior may have a static context. But what if it refers to names that do not live in the static context? These would be the “arguments”, so to speak. Let’s write behavior assuming these names will be provided — note that this is what we do when we write methods and blocks. Then, invoking or"
      },
      "date": 1660200587772
    },
    {
      "type": "edit",
      "id": "03aa0eadce2b3e9b",
      "item": {
        "type": "paragraph",
        "id": "03aa0eadce2b3e9b",
        "text": "As we discussed, behavior may have a static context. But what if it refers to names that do not live in the static context? These would be the “arguments”, so to speak. Let’s write behavior assuming these names will be provided — note that this is what we do when we write methods and blocks. Then, invoking or even mounting behavior on top of a distinction requires us to provide a name map between the names the behavior uses, and the names inside the distinction. In Smalltalk, this renaming occurs automatically when we send messages or evaluate blocks"
      },
      "date": 1660200599535
    },
    {
      "type": "edit",
      "id": "03aa0eadce2b3e9b",
      "item": {
        "type": "paragraph",
        "id": "03aa0eadce2b3e9b",
        "text": "As we discussed, behavior may have a static context. But what if it refers to names that do not live in the static context? These would be the “arguments”, so to speak. Let’s write behavior assuming these names will be provided — note that this is what we do when we write methods and blocks. Then, invoking or even mounting behavior on top of a distinction requires us to provide a name map between the names the behavior uses, and the names inside the distinction. In Smalltalk, this renaming occurs automatically when we send messages or evaluate blocks."
      },
      "date": 1660200632808
    },
    {
      "item": {
        "type": "factory",
        "id": "6712b8c551efe790"
      },
      "id": "6712b8c551efe790",
      "type": "add",
      "after": "03aa0eadce2b3e9b",
      "date": 1660200663013
    },
    {
      "type": "edit",
      "id": "6712b8c551efe790",
      "item": {
        "type": "paragraph",
        "id": "6712b8c551efe790",
        "text": "Note how Smalltalk classes would be more or less permanent mountings of particular behavior on top of distinctions which contain a fixed amount of labeled distinctions."
      },
      "date": 1660200666222
    },
    {
      "item": {
        "type": "factory",
        "id": "4a8b603614217af5"
      },
      "id": "4a8b603614217af5",
      "type": "add",
      "after": "6712b8c551efe790",
      "date": 1660200683512
    },
    {
      "type": "edit",
      "id": "4a8b603614217af5",
      "item": {
        "type": "paragraph",
        "id": "4a8b603614217af5",
        "text": "Now, behavior is a name map. The name map that connects behaviors and distinctions is evidently a name map. And our distinction is a label map as well. Should we write our programs in these terms instead?"
      },
      "date": 1660200685455
    },
    {
      "item": {
        "type": "factory",
        "id": "d41a0d3e89e69825"
      },
      "id": "d41a0d3e89e69825",
      "type": "add",
      "after": "4a8b603614217af5",
      "date": 1660200959836
    },
    {
      "type": "edit",
      "id": "d41a0d3e89e69825",
      "item": {
        "type": "paragraph",
        "id": "d41a0d3e89e69825",
        "text": "After writing a prototype, I would have to say the answer to that question is no. In my experience, the code was much more verbose than Smalltalk. At the same time, Smalltalk code could be seen as a way to express the ideas in this section. The lesson, therefore, is that it is not necessary to express the whole  thought in the computer, just the result of the thought process is enough as long its expression is intention revealing.\n\n"
      },
      "date": 1660200964031
    },
    {
      "type": "add",
      "id": "71aedfc4f137bc2d",
      "item": {
        "type": "paragraph",
        "id": "71aedfc4f137bc2d",
        "text": "> “Well, that is what [Smalltalk] is designed to do.” —Dan Ingalls"
      },
      "after": "d41a0d3e89e69825",
      "date": 1660200969485
    },
    {
      "type": "edit",
      "id": "71aedfc4f137bc2d",
      "item": {
        "type": "markdown",
        "id": "71aedfc4f137bc2d",
        "text": "> “Well, that is what [Smalltalk] is designed to do.” —Dan Ingalls"
      },
      "date": 1660200976010
    },
    {
      "item": {
        "type": "factory",
        "id": "2746fe8830d0418d"
      },
      "id": "2746fe8830d0418d",
      "type": "add",
      "after": "71aedfc4f137bc2d",
      "date": 1660201050096
    },
    {
      "type": "edit",
      "id": "2746fe8830d0418d",
      "item": {
        "type": "paragraph",
        "id": "2746fe8830d0418d",
        "text": "The reasons for this are fundamentally and critically important. As we know, we can only hold 7 ± 2 things in our minds. Consequently, as long as we carry most of our thoughts with things allocated to our local scratch ram, our speed of thought will be very fast. But if we now allocate some of the things we need to think into the computer, referencing such things will cause human interface traffic. In the same way that swap space thrashing brings any computer to its knees, excess of communication between us and the computer will considerably reduce our performance. Moreover, stressing our paging system will invariably lead to a higher probability of error"
      },
      "date": 1660201052162
    },
    {
      "item": {
        "type": "factory",
        "id": "a8c2b719b53bc473"
      },
      "id": "a8c2b719b53bc473",
      "type": "add",
      "after": "2746fe8830d0418d",
      "date": 1660201105142
    },
    {
      "type": "edit",
      "id": "a8c2b719b53bc473",
      "item": {
        "type": "paragraph",
        "id": "a8c2b719b53bc473",
        "text": "Language design is an exercise of scratch ram register allocation. And as such, we can think of soups of labels, or even typed lambda calculus if we so desire — as long as the artifacts representing the results of such thought are extremely concise to minimize the impact of human interface chatter on our performance, yet intention revealing enough so that we can quickly reconstruct the thought processes that led to the particular expression of our solution."
      },
      "date": 1660201107134
    },
    {
      "item": {
        "type": "factory",
        "id": "4ea5a2c2a88ed650"
      },
      "id": "4ea5a2c2a88ed650",
      "type": "add",
      "after": "a8c2b719b53bc473",
      "date": 1660201582701
    },
    {
      "type": "edit",
      "id": "4ea5a2c2a88ed650",
      "item": {
        "type": "pagefold",
        "id": "4ea5a2c2a88ed650",
        "text": "~"
      },
      "date": 1660201588905
    },
    {
      "item": {
        "type": "factory",
        "id": "cd720f2b5bc13498"
      },
      "id": "cd720f2b5bc13498",
      "type": "add",
      "after": "4ea5a2c2a88ed650",
      "date": 1660201592810
    },
    {
      "type": "edit",
      "id": "cd720f2b5bc13498",
      "item": {
        "type": "paragraph",
        "id": "cd720f2b5bc13498",
        "text": "Appendix A.2 of [[A Mentoring Course on Smalltalk]]"
      },
      "date": 1660201600366
    },
    {
      "type": "edit",
      "id": "cd720f2b5bc13498",
      "item": {
        "type": "paragraph",
        "id": "cd720f2b5bc13498",
        "text": "Appendix A.2 of [[A Mentoring Course on Smalltalk]], [[Design Distinctions behind Smalltalk]]"
      },
      "date": 1660201639434
    },
    {
      "type": "edit",
      "id": "d41a0d3e89e69825",
      "item": {
        "type": "paragraph",
        "id": "d41a0d3e89e69825",
        "text": "After writing a prototype, [[Andrés Valloud]] would have to say the answer to that question is no. In my experience, the code was much more verbose than Smalltalk. At the same time, Smalltalk code could be seen as a way to express the ideas in this section. The lesson, therefore, is that it is not necessary to express the whole  thought in the computer, just the result of the thought process is enough as long its expression is intention revealing.\n\n"
      },
      "date": 1660201661209
    },
    {
      "type": "edit",
      "id": "d41a0d3e89e69825",
      "item": {
        "type": "paragraph",
        "id": "d41a0d3e89e69825",
        "text": "After writing a prototype, [[Andrés Valloud]] has to answer no to this question: In my experience, the code was much more verbose than Smalltalk. At the same time, Smalltalk code could be seen as a way to express the ideas in this section. The lesson, therefore, is that it is not necessary to express the whole  thought in the computer, just the result of the thought process is enough as long its expression is intention revealing.\n\n"
      },
      "date": 1660201727097
    },
    {
      "type": "edit",
      "id": "d41a0d3e89e69825",
      "item": {
        "type": "paragraph",
        "id": "d41a0d3e89e69825",
        "text": "After writing a prototype, [[Andrés Valloud]] has to answer no to this question: "
      },
      "date": 1660201748545
    },
    {
      "type": "add",
      "id": "a372eb3aca4281eb",
      "item": {
        "type": "paragraph",
        "id": "a372eb3aca4281eb",
        "text": "> In my experience, the code was much more verbose than Smalltalk. "
      },
      "after": "d41a0d3e89e69825",
      "date": 1660201754287
    },
    {
      "type": "edit",
      "id": "a372eb3aca4281eb",
      "item": {
        "type": "markdown",
        "id": "a372eb3aca4281eb",
        "text": "> In my experience, the code was much more verbose than Smalltalk. "
      },
      "date": 1660201757053
    },
    {
      "type": "add",
      "id": "fac1dc1eea56f2c4",
      "item": {
        "type": "paragraph",
        "id": "fac1dc1eea56f2c4",
        "text": "At the same time, Smalltalk code could be seen as a way to express the ideas in this section. The lesson, therefore, is that it is not necessary to express the whole  thought in the computer, just the result of the thought process is enough as long its expression is intention revealing.\n\n"
      },
      "after": "a372eb3aca4281eb",
      "date": 1660201759445
    },
    {
      "type": "edit",
      "id": "a8c2b719b53bc473",
      "item": {
        "type": "paragraph",
        "id": "a8c2b719b53bc473",
        "text": "Language design is an exercise of [[scratch ram register allocation]]. And as such, we can think of soups of labels, or even typed lambda calculus if we so desire — as long as the artifacts representing the results of such thought are extremely concise to minimize the impact of human interface chatter on our performance, yet intention revealing enough so that we can quickly reconstruct the thought processes that led to the particular expression of our solution."
      },
      "date": 1660206986967
    },
    {
      "type": "edit",
      "id": "2746fe8830d0418d",
      "item": {
        "type": "paragraph",
        "id": "2746fe8830d0418d",
        "text": "The reasons for this are fundamentally and critically important. As we know, we can only hold 7 ± 2 things in our minds. Consequently, as long as we carry most of our thoughts with things allocated to our local scratch ram, our speed of thought will be very fast. But if we now allocate some of the things we need to think into the computer, referencing such things will cause human interface traffic. In the same way that swap space thrashing brings any computer to its knees, excess of communication between us and the computer will considerably reduce our performance. Moreover, stressing our paging system will invariably lead to a higher probability of error."
      },
      "date": 1660207471239
    },
    {
      "type": "edit",
      "id": "515a642b7f7052ff",
      "item": {
        "type": "paragraph",
        "id": "515a642b7f7052ff",
        "text": "Well, but if it is truly about [[labels]] and [[distinctions]], how does it actually happen for us? At this point, it may be good to consider the following interpretation."
      },
      "date": 1660207547479
    },
    {
      "item": {
        "type": "factory",
        "id": "cf0abb38fc65fb30"
      },
      "id": "cf0abb38fc65fb30",
      "type": "add",
      "after": "cd720f2b5bc13498",
      "date": 1660231953743
    },
    {
      "type": "edit",
      "id": "cf0abb38fc65fb30",
      "item": {
        "type": "reference",
        "id": "cf0abb38fc65fb30",
        "site": "wellspring.fed.wiki",
        "slug": "an-experiment",
        "title": "An Experiment",
        "text": "Seven years ago Jami Fluke and I embarked on an experiment inspired by a single question: If we introduced the mindset of this new age – called the agile mindset – to her school, might she be able to unleash the creative genius of her students?"
      },
      "date": 1660231958383
    }
  ]
}