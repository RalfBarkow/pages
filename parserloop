{
  "title": "Parser.loop",
  "story": [
    {
      "type": "reference",
      "id": "86962b7d4524a676",
      "site": "wiki.ralfbarkow.ch",
      "slug": "loop",
      "title": "Loop",
      "text": "A [[Parser]] that can loop indefinitely. [https://package.elm-lang.org/packages/elm/parser/latest/Parser#loop page]"
    },
    {
      "type": "code",
      "id": "20d90d1829635580",
      "text": "loop : state -> (state -> Parser (Step state a)) -> Parser a"
    },
    {
      "type": "paragraph",
      "id": "ef781fda1d6db3ba",
      "text": "This can be helpful when parsing repeated structures, like a bunch of statements:"
    },
    {
      "type": "code",
      "id": "6e1c13061624de37",
      "text": "statements : Parser (List Stmt)\nstatements =\n  loop [] statementsHelp\n\nstatementsHelp : List Stmt -> Parser (Step (List Stmt) (List Stmt))\nstatementsHelp revStmts =\n  oneOf\n    [ succeed (\\stmt -> Loop (stmt :: revStmts))\n        |= statement\n        |. spaces\n        |. symbol \";\"\n        |. spaces\n    , succeed ()\n        |> map (\\_ -> Done (List.reverse revStmts))\n    ]\n\n-- statement : Parser Stmt\n"
    },
    {
      "type": "paragraph",
      "id": "f60f58d21e281fff",
      "text": "Notice that the statements are tracked in reverse as we Loop, and we reorder them only once we are Done. This is a very common pattern with loop!"
    },
    {
      "type": "paragraph",
      "id": "2e265a2d6c5badea",
      "text": "Check out DoubleQuoteString.elm [https://github.com/elm/parser/blob/master/examples/DoubleQuoteString.elm code] for another example."
    },
    {
      "type": "paragraph",
      "id": "2348ca61019a3977",
      "text": "IMPORTANT NOTE: Parsers like succeed () and chompWhile Char.isAlpha can succeed without consuming any characters. So in some cases you may want to use getOffset to ensure that each step actually consumed characters. Otherwise you could end up in an infinite loop!"
    },
    {
      "type": "paragraph",
      "id": "5390d1126fd213da",
      "text": "Note: Anything you can write with loop, you can also write as a parser that chomps some characters andThen calls itself with new arguments. The problem with calling andThen recursively is that it grows the stack, so you cannot do it indefinitely. So loop is important because it enables [[Tail-Call Elimination]], allowing you to parse however many repeats you want."
    },
    {
      "type": "pagefold",
      "id": "18d149594f50ed91",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "a7b3d877c77067a1",
      "text": "Tail Call Elimination [https://www.geeksforgeeks.org/tail-call-elimination/ geeksforgeeks]"
    },
    {
      "type": "paragraph",
      "id": "10eef01eeac3f36a",
      "text": "What is tail call optimization? [https://stackoverflow.com/questions/310974/what-is-tail-call-optimization stackoverflow]"
    },
    {
      "type": "paragraph",
      "id": "cd39ee2239b98847",
      "text": "Tail call [https://en.wikipedia.org/wiki/Tail_call wikipedia]"
    },
    {
      "type": "paragraph",
      "id": "65aae444b7333ed8",
      "text": "Tail Call Elimination [https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/tail-call-elimination/ post] by [[Christopher Roman]] "
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Parser.loop",
        "story": []
      },
      "date": 1696947229950
    },
    {
      "item": {
        "type": "factory",
        "id": "86962b7d4524a676"
      },
      "id": "86962b7d4524a676",
      "type": "add",
      "date": 1696947231388
    },
    {
      "type": "edit",
      "id": "86962b7d4524a676",
      "item": {
        "type": "reference",
        "id": "86962b7d4524a676",
        "site": "wiki.ralfbarkow.ch",
        "slug": "loop",
        "title": "Loop",
        "text": "A [[Parser]] that can loop indefinitely. [https://package.elm-lang.org/packages/elm/parser/latest/Parser#loop page]"
      },
      "date": 1696947233419
    },
    {
      "id": "20d90d1829635580",
      "type": "add",
      "item": {
        "type": "code",
        "id": "20d90d1829635580",
        "text": "loop : state -> (state -> Parser (Step state a)) -> Parser a"
      },
      "after": "86962b7d4524a676",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947271777
    },
    {
      "id": "ef781fda1d6db3ba",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "ef781fda1d6db3ba",
        "text": "This can be helpful when parsing repeated structures, like a bunch of statements:"
      },
      "after": "20d90d1829635580",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947301691
    },
    {
      "id": "6e1c13061624de37",
      "type": "add",
      "item": {
        "type": "code",
        "id": "6e1c13061624de37",
        "text": "statements : Parser (List Stmt)\nstatements =\n  loop [] statementsHelp\n\nstatementsHelp : List Stmt -> Parser (Step (List Stmt) (List Stmt))\nstatementsHelp revStmts =\n  oneOf\n    [ succeed (\\stmt -> Loop (stmt :: revStmts))\n        |= statement\n        |. spaces\n        |. symbol \";\"\n        |. spaces\n    , succeed ()\n        |> map (\\_ -> Done (List.reverse revStmts))\n    ]\n\n-- statement : Parser Stmt\n"
      },
      "after": "ef781fda1d6db3ba",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947304957
    },
    {
      "id": "f60f58d21e281fff",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "f60f58d21e281fff",
        "text": "Notice that the statements are tracked in reverse as we Loop, and we reorder them only once we are Done. This is a very common pattern with loop!"
      },
      "after": "6e1c13061624de37",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947318808
    },
    {
      "id": "2e265a2d6c5badea",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "2e265a2d6c5badea",
        "text": "Check out DoubleQuoteString.elm [https://github.com/elm/parser/blob/master/examples/DoubleQuoteString.elm code] for another example."
      },
      "after": "f60f58d21e281fff",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947322758
    },
    {
      "id": "2348ca61019a3977",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "2348ca61019a3977",
        "text": "IMPORTANT NOTE: Parsers like succeed () and chompWhile Char.isAlpha can succeed without consuming any characters. So in some cases you may want to use getOffset to ensure that each step actually consumed characters. Otherwise you could end up in an infinite loop!"
      },
      "after": "2e265a2d6c5badea",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947327791
    },
    {
      "id": "5390d1126fd213da",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "5390d1126fd213da",
        "text": "Note: Anything you can write with loop, you can also write as a parser that chomps some characters andThen calls itself with new arguments. The problem with calling andThen recursively is that it grows the stack, so you cannot do it indefinitely. So loop is important because it enables [[Tail-Call Elimination]], allowing you to parse however many repeats you want."
      },
      "after": "2348ca61019a3977",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947335324
    },
    {
      "id": "18d149594f50ed91",
      "type": "add",
      "item": {
        "type": "pagefold",
        "id": "18d149594f50ed91",
        "text": "~"
      },
      "after": "5390d1126fd213da",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947343073
    },
    {
      "id": "a7b3d877c77067a1",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "a7b3d877c77067a1",
        "text": "Tail Call Elimination [https://www.geeksforgeeks.org/tail-call-elimination/ geeksforgeeks]"
      },
      "after": "18d149594f50ed91",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947345825
    },
    {
      "id": "10eef01eeac3f36a",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "10eef01eeac3f36a",
        "text": "What is tail call optimization? [https://stackoverflow.com/questions/310974/what-is-tail-call-optimization stackoverflow]"
      },
      "after": "a7b3d877c77067a1",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947349723
    },
    {
      "id": "cd39ee2239b98847",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "cd39ee2239b98847",
        "text": "Tail call [https://en.wikipedia.org/wiki/Tail_call wikipedia]"
      },
      "after": "10eef01eeac3f36a",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947353157
    },
    {
      "id": "65aae444b7333ed8",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "65aae444b7333ed8",
        "text": "Tail Call Elimination [https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/tail-call-elimination/ post] by [[Christopher Roman]] "
      },
      "after": "cd39ee2239b98847",
      "attribution": {
        "page": "Loop"
      },
      "date": 1696947355907
    }
  ]
}