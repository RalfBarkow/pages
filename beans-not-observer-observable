{
  "title": "Beans Not Observer Observable",
  "story": [
    {
      "type": "html",
      "text": "See [[Observer Pattern]] in the [[Gang Of Four]] book, [[Design Patterns]].",
      "id": "c7825639bb94599730dce0190e576921"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "798c5485076ddd81c2948f2edf62f601"
    },
    {
      "type": "html",
      "text": "In developing a user interface framework patterned on MVC, the most obvious approach is to use the Observer interface and Observable class, or some approximation of these classes to provide synchronization between models and views.",
      "id": "47bf4906114a6319455bc695eef92581"
    },
    {
      "type": "html",
      "text": "\nI would suggest instead that the developer study the [[Java Beans]] framework, in particular the [[Design Signatures]] having to do with Bound Properties, Vetoable Properties, and Events.",
      "id": "210baa5764f67778794b112fd079e271"
    },
    {
      "type": "html",
      "text": "\nThese [[Design Signatures]] are basically protocol for classes which are [[Java Beans]] and specify how classes should define public properties which have a notion of being \"bindable\" in that \"observers\" or \"interested parties\" can bind themselves to the class and be notified when the property changes.  In addition, such changes that follow the signature for Vetoable Properties have the feature that the changes can be \"vetoed\" by the \"observers\".",
      "id": "127ecfcb5b682dba3a00fbf5ce9bfae9"
    },
    {
      "type": "html",
      "text": "\nBy adhering to these [[Design Signatures]] (protocol, essentially) the developer will find that in addition to the advantages of utilizing an existing framework he will benefit from the opportunities opened up by having classes which can be trivially packaged as [[Java Beans]], a useful platform independent Component architecture.",
      "id": "185d08ebea628589e430958106bafc89"
    },
    {
      "type": "html",
      "text": "\n[[Bill Kayser]]",
      "id": "f947e82fb43f85a24872de090fd91340"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "798c5485076ddd81c2948f2edf62f601"
    },
    {
      "type": "html",
      "text": "Having studied this a little more closely, I'm pretty much convinced that there's not a lot of difference between the general Observer pattern as implemented in [[Observer Observable]] and the same pattern as implemented by the JDK 1.1 Events model (which [[Java Beans]] use).  ",
      "id": "9ee655e6debd62645d1d041f7b5ea9c1"
    },
    {
      "type": "html",
      "text": "\nThe major difference seems to be that using the JDK 1.1 Events model involves creating a new [[Event Object]] class for each new event that you will be generating in your component (or bean).  This gives you more information than simply sending along a general parameter the way you do with the update(observable, argument) method but it seems that it still works the same way.  ",
      "id": "ba06041f6555bf17e15904955e33b2c8"
    },
    {
      "type": "html",
      "text": "\nIf anything, I'm a bit annoyed that they made you implement an interface for each Event type -- the problem with that is if you're a listener on several objects with the same event you have to check to see WHICH one sent you the message.  It's not as flexible as the [[Self Addressed Stamped Envelope]] pattern used in all three of the major Smalltalk dialects.  The sad thing is that the JDK 1.1 HAS reflection -- they could have implemented [[Self Addressed Stamped Envelope]] and not had to mess with  all this.",
      "id": "05c9e6eebd7b8f3cd019d61862fae036"
    },
    {
      "type": "html",
      "text": "\n[[Kyle Brown]]",
      "id": "4335adf4c8322333e6e98a2d3586fa30"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "798c5485076ddd81c2948f2edf62f601"
    },
    {
      "type": "html",
      "text": "Good point.  Take a look at [[Inner Classes As Event Handlers]] to see how I deal with this in Java using anonymous inner classes.  ",
      "id": "16c58bb244913714b2448a469e612591"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "798c5485076ddd81c2948f2edf62f601"
    },
    {
      "type": "html",
      "text": "There are a few problems with the [[Observer Observable]] class/interface pair which makes using them rather problematic. For me, the biggest is that Observable is a class rather than an interface, which means that you have to use their implementation, or Observable is worthless.  Coupled with the [[Single Inheritance]] restriction, that rules it out for many situations.  While the given implementation is not terrible in general, I have times when I need to decouple the pair into separate threads to avoid blocking a remote process which is calling back to a client hidden in a browser.",
      "id": "5a3255d493e722d3087f0a2d0d16e860"
    },
    {
      "type": "html",
      "text": "\n[[Russell Gold]]",
      "id": "0f961a470dca6cb917fa3c51bc5a29d9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "798c5485076ddd81c2948f2edf62f601"
    },
    {
      "type": "html",
      "text": "Russel, instead of using [[Observer Observable]], use bound bean properties.  Check out the java.beans.[[Property Change Support]].  It's the delegate to use with the interface-based bean notification.",
      "id": "4afd9e35a9bf95390872f09e0135cd0f"
    },
    {
      "type": "html",
      "text": "\n[[Robb Shecter]]",
      "id": "053b6543b21ecfe918d673c0c8ff8db8"
    },
    {
      "type": "html",
      "text": "\nThat is exactly what I do. I was explaining 'why' I do that instead of using [[Observer Observable]]. -- [[Russell Gold]]",
      "id": "29d1bd0dbdc9bc8cc5461929d8be8a79"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?BeansNotObserverObservable c2.com]",
      "id": "03a556fc98cd666e7c50266e145ecd44"
    }
  ],
  "journal": [
    {
      "date": 1050170329000,
      "id": "ea9f42771c9b41dbc49a3190576f87f6",
      "type": "create",
      "item": {
        "title": "Beans Not Observer Observable",
        "story": [
          {
            "type": "html",
            "text": "See [[Observer Pattern]] in the [[Gang Of Four]] book, [[Design Patterns]].",
            "id": "c7825639bb94599730dce0190e576921"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "798c5485076ddd81c2948f2edf62f601"
          },
          {
            "type": "html",
            "text": "In developing a user interface framework patterned on MVC, the most obvious approach is to use the Observer interface and Observable class, or some approximation of these classes to provide synchronization between models and views.",
            "id": "47bf4906114a6319455bc695eef92581"
          },
          {
            "type": "html",
            "text": "\nI would suggest instead that the developer study the [[Java Beans]] framework, in particular the [[Design Signatures]] having to do with Bound Properties, Vetoable Properties, and Events.",
            "id": "210baa5764f67778794b112fd079e271"
          },
          {
            "type": "html",
            "text": "\nThese [[Design Signatures]] are basically protocol for classes which are [[Java Beans]] and specify how classes should define public properties which have a notion of being \"bindable\" in that \"observers\" or \"interested parties\" can bind themselves to the class and be notified when the property changes.  In addition, such changes that follow the signature for Vetoable Properties have the feature that the changes can be \"vetoed\" by the \"observers\".",
            "id": "127ecfcb5b682dba3a00fbf5ce9bfae9"
          },
          {
            "type": "html",
            "text": "\nBy adhering to these [[Design Signatures]] (protocol, essentially) the developer will find that in addition to the advantages of utilizing an existing framework he will benefit from the opportunities opened up by having classes which can be trivially packaged as [[Java Beans]], a useful platform independent Component architecture.",
            "id": "185d08ebea628589e430958106bafc89"
          },
          {
            "type": "html",
            "text": "\n[[Bill Kayser]]",
            "id": "f947e82fb43f85a24872de090fd91340"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "798c5485076ddd81c2948f2edf62f601"
          },
          {
            "type": "html",
            "text": "Having studied this a little more closely, I'm pretty much convinced that there's not a lot of difference between the general Observer pattern as implemented in [[Observer Observable]] and the same pattern as implemented by the JDK 1.1 Events model (which [[Java Beans]] use).  ",
            "id": "9ee655e6debd62645d1d041f7b5ea9c1"
          },
          {
            "type": "html",
            "text": "\nThe major difference seems to be that using the JDK 1.1 Events model involves creating a new [[Event Object]] class for each new event that you will be generating in your component (or bean).  This gives you more information than simply sending along a general parameter the way you do with the update(observable, argument) method but it seems that it still works the same way.  ",
            "id": "ba06041f6555bf17e15904955e33b2c8"
          },
          {
            "type": "html",
            "text": "\nIf anything, I'm a bit annoyed that they made you implement an interface for each Event type -- the problem with that is if you're a listener on several objects with the same event you have to check to see WHICH one sent you the message.  It's not as flexible as the [[Self Addressed Stamped Envelope]] pattern used in all three of the major Smalltalk dialects.  The sad thing is that the JDK 1.1 HAS reflection -- they could have implemented [[Self Addressed Stamped Envelope]] and not had to mess with  all this.",
            "id": "05c9e6eebd7b8f3cd019d61862fae036"
          },
          {
            "type": "html",
            "text": "\n[[Kyle Brown]]",
            "id": "4335adf4c8322333e6e98a2d3586fa30"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "798c5485076ddd81c2948f2edf62f601"
          },
          {
            "type": "html",
            "text": "Good point.  Take a look at [[Inner Classes As Event Handlers]] to see how I deal with this in Java using anonymous inner classes.  ",
            "id": "16c58bb244913714b2448a469e612591"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "798c5485076ddd81c2948f2edf62f601"
          },
          {
            "type": "html",
            "text": "There are a few problems with the [[Observer Observable]] class/interface pair which makes using them rather problematic. For me, the biggest is that Observable is a class rather than an interface, which means that you have to use their implementation, or Observable is worthless.  Coupled with the [[Single Inheritance]] restriction, that rules it out for many situations.  While the given implementation is not terrible in general, I have times when I need to decouple the pair into separate threads to avoid blocking a remote process which is calling back to a client hidden in a browser.",
            "id": "5a3255d493e722d3087f0a2d0d16e860"
          },
          {
            "type": "html",
            "text": "\n[[Russell Gold]]",
            "id": "0f961a470dca6cb917fa3c51bc5a29d9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "798c5485076ddd81c2948f2edf62f601"
          },
          {
            "type": "html",
            "text": "Russel, instead of using [[Observer Observable]], use bound bean properties.  Check out the java.beans.[[Property Change Support]].  It's the delegate to use with the interface-based bean notification.",
            "id": "4afd9e35a9bf95390872f09e0135cd0f"
          },
          {
            "type": "html",
            "text": "\n[[Robb Shecter]]",
            "id": "053b6543b21ecfe918d673c0c8ff8db8"
          },
          {
            "type": "html",
            "text": "\nThat is exactly what I do. I was explaining 'why' I do that instead of using [[Observer Observable]]. -- [[Russell Gold]]",
            "id": "29d1bd0dbdc9bc8cc5461929d8be8a79"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?BeansNotObserverObservable c2.com]",
            "id": "03a556fc98cd666e7c50266e145ecd44"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1651574224517
    }
  ]
}