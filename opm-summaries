{
  "title": "OPM Summaries",
  "story": [
    {
      "type": "markdown",
      "id": "d77a8f6af23b6fc0",
      "text": "**Notes on chapter summaries from: **\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 41-42). Springer New York. Kindle Edition. \n"
    },
    {
      "type": "markdown",
      "id": "abfcf0e53ada1c65",
      "text": "1.6 Summary \n* We have started modeling the Automatic Crash Responding system using OPM. \n* OPM has **a single diagram type**: the object-process diagram (OPD). \n* OPM is built of **objects**, which exist, and of **processes**, which transform objects. \n* **Object transformation** is object creation, object consumption, or object change. \n* We recognize **processes**—Automatic Crash Responding in our example—as stand-alone OPM **building blocks** that are separate from objects. \n* Objects and processes enable concurrent modeling of the system’s **structure and behavior** in the same OPD. \n* Transformation is **object creation, consumption, or state change**.\n\n"
    },
    {
      "type": "markdown",
      "id": "8cfda0d5582d1f60",
      "text": "2.4 Summary \n* OPM has two equivalent representation modalities: the graphic—object-process **diagram** (OPD) and the textual—object-process **language** (OPL). \n* The OPL sentence s and the OPD complement each other, as they appeal to the parallel visual and verbal **cognitive processing** channels of the human brain . \n* A **state** is a situation at which an object can be. \n* An **effect link** indicates some state change of the linked object by the linked process. \n* An **input–output link pair** indicates the specific state from and to which the process changes the object. \n* An OPM model is amenable to **animated simulation** , which facilitates understanding the system’s dynamic aspect and testing its logical flow.\n\n"
    },
    {
      "type": "markdown",
      "id": "c89ffadc634401e8",
      "text": "3.9 Summary \n* **Enablers** are required for a process to occur, but are not affected by the occurrence of that process. \n* An **agent** is a human enabler, while an instrument is a non-human enabler. \n* Two types of link s connect entities with each other: structural link s and procedural link s.  \n* **Procedural link** s, which are between a process and an object or one of its states, express the behavior of the system; for example, an effect link. \n* **Structural link** s express persistent , long-term relations between two connected objects or between two connected processes in the system; for example, an aggregation-participation link . \n* Since the structural and the procedural links are expressed in the same diagram, they help **integrate** the **structure and the behavior** of the system. \n* Thing s—that is, objects and processes—are classified by their  \n* **Essence** into physical thing s and informatical thing s, and by their \n* **Affiliation** into systemic thing s and environmental thing s. A process is triggered by an event link.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "3d02e6069fa83202",
      "text": "4.4 Summary \n* **SysML** has nine types of diagrams that model various aspects of the system. \n* The use case diagram is often the first to be prepared since it provides the context of the system and how actors interact with it. \n* **Block** is a basic unit, akin to class in UML , used in the block definition diagram and internal block diagram. It serves to define the structure of the system. \n"
    },
    {
      "type": "markdown",
      "id": "9864c74d640d2ea0",
      "text": " \n5.7 Summary \n* **In-zooming** is a refinement mechanism that helps manage system complexity . \n* Zooming into a process creates a new OPD with an inflated **in-zoomed process**. \n* Lower-level processes (subprocesses) are **nested** within this in-zoomed process and they can be **linked to lower-level objects** inside or outside the in-zoomed process. \n* Recursive in-zooming results in an **OPD set** that has a **tree structure**, in which lower-level OPDs model **increasingly refined details** about the system. \n* The **model fact** representation OPM principle stipulates that in order for an OPM model fact to be represented, it needs to **appear in at least one OPD** in order for it to be represented in the model. \n* Using this principle helps **decrease diagram clutter**, making each diagram **simple enough to be grasped** without cognitive overload.\n\n"
    },
    {
      "type": "markdown",
      "id": "c92bc0d23c982368",
      "text": "6.6 Summary \n* The **condition link** semantics is that if the object to which the link is attached exists, or if the state to which the link is attached is the current object state, then the process executes, otherwise it is skipped. \n* The **XOR relation** between procedural links indicates that exactly one of the possible interactions denoted by these links materializes. \n* XOR is **denoted graphically** by a common point from which all the XOR'ed links originate or at which they terminate, and a dashed arc through these links whose center is the common links’ point. \n* The **timeline OPM principle** stipulates that the timeline within the context of an in-zoomed process is directed by default from the top of the in-zoomed process ellipse to its bottom. \n* The **subprocess execution order** is determined by the height of the top subprocess ellipse points, such that the one at the top starts first. \n* If the top ellipse point of two or more sub processes is at the **same height**, within a predefined tolerance, they **start simultaneously**. This is the way to **model process synchronization**.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "f74fb3be2fa9a0f3",
      "text": "7.10 Summary \n* A **Boolean object** has **two states** and is used for modeling **flow of control**. \n* A **condition link** has a control modifier c added to a procedural link, augmenting its semantics with skip meaning. \n* **Generalization-specialization** is a fundamental structural relation that induces inheritance of features (attributes and operations), links, and states from the general thing to the specialized thing. \n* **Participation constraints** enable specifying how many objects of the same class participate in a relation. \n* **OR** is a relaxed version of the XOR logical operator that allows any subset of participating links to be active at once, rather than exactly one of them, as **XOR** does. \n* **Objects within an in-zoomed process** are recognized only in the scope of that process. If they are used in places outside that scope they must be placed outside the in-zoomed process.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "8544700eb5738841",
      "text": "7.10 Summary \n* A **Boolean object** has two states and is used for **modeling flow of control**. \n* A **condition link** has a control modifier c added to a procedural link, augmenting its semantics with **skip meaning**. \n* **Generalization-specialization** is a fundamental structural relation that induces inheritance of features (**attributes** and **operations**), links, and states from the general thing to the specialized thing. \n* **Participation constraints** enable specifying how many objects of the same class participate in a relation. \n* **OR** is a relaxed version of the XOR logical operator that allows **any subset of participating links** to be active at once, rather than exactly one of them, as XOR does. \n* **Objects within an in-zoomed process** are recognized only in the scope of that process. \n* If they are used in places outside that scope they must be **placed outside the in-zoomed process**.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "bd0ffa708c262c6c",
      "text": "8.4 Summary\n* While the objective of OPM-based modeling is to go top-down and refine model facts as we go, **to avoid diagram clutter** it is sometimes required to abstract two or more processes in the crowded OPD and create a new OPD at an interim level. \n* Abstraction can be achieved by process **out-zooming**: Creating an abstract process, which, when in-zoomed, will include the out-zoomed subprocesses (and possibly others). \n* Right after a process is **in-zoomed**, all the **procedural links** are still attached to it. \n* As subprocesses are added, **procedural link edges should be dragged** from the in-zoomed process ellipse to the appropriate subprocesses. \n* Only **links that apply to all the subprocesses** inside the in-zoomed process should remain attached to the in-zoomed process. \n* A **structural view** is achieved by removing all the processes and the procedural links from the model. \n* The structural view enables focusing on the system structure and examining possible **structural improvements**.\n"
    },
    {
      "type": "markdown",
      "id": "1fa3de92363f095d",
      "text": "9.6 Summary \n* **Science** can be thought of as reverse engineering of nature. \n* The **Minimal Ontology principle** states that if a system can be specified at the same level of accuracy and detail by two languages of different ontology sizes, then the language with the smaller size is preferred over the one with the larger size. \n* **Objects** exist, **processes** happen. \n* **Ontology** is a set of concepts and their relations in some domain of discourse. \n* A minimal **universal ontology** is the ontology that is necessary and sufficient to model the universe and systems in it. \n* The **Object-Process Theorem** : Stateful objects, processes, and relations among them constitute a minimal universal ontology. \n* The **Object-Process Assertion**: Using stateful objects, processes, and relations among them, along with refinement mechanisms of in-zooming and unfolding, one can conceptually model systems in any domain and at any level of complexity. \n* The **thing importance OPM principle** : The importance of a thing T in an OPM model is directly related to the highest OPD in the OPD hierarchy where T appears. \n* An **object** is a thing that exists or can exist physically or informatically. \n* A **state** is a possible situation or position at which an object can be for some positive amount of time. \n* **Transformation of an object** is (1) creation (generation, construction), (2) consumption (elimination, destruction), or (3) effect—change in the state of that object. \n* A **process** is a thing that transforms an object. \n* The **object transformation by process OPM principle** : In a complete OPM model, each process must be connected to at least one object that the process transforms or one state of the object that the process transforms. \n* A **system** is a function-providing object.\n> Very odd that he uses the term object for a system which must include Processes and Relationships. He must mean \"object\" in a different sense than in OPM.\n* A **stakeholder** is an individual, an organization, or a group of people that has an interest in, or might be affected by, a system being contemplated, developed, or deployed. \n* A **beneficiary** is a stakeholder who extracts value and benefits from the system. \n* A **customer** is the stakeholder who orders the system and sponsors its development, implementation, deployment, and support. \n* A **user** is a stakeholder who operates the system or directly interacts with it. \n* A **supplier** is a stakeholder who oversees the development, support, and maintenance of the system or product. \n* A **function** of an artificial system is its top-level value-providing process, as perceived by the beneficiary. \n* **Structure** of a system is its form—the assembly of its physical and informatical components along with the long-lasting relations among them. \n* **Behavior** of a system is it dynamics—the way the system changes over time by transforming systemic (internal) and/or environmental (external) objects. \n* **Architecture** of a system is the combination of the system’s structure and behavior which enables it to perform its function. \n* The system’s **environment** is a collection of objects that are outside the system but interact with it, causing the system and possibly its environment to change. \n* The **function-behavior distinction** : Behavior is how the system changes along the time dimension, while function is what value the system delivers to its beneficiary through its operation. \n* A **language** is a means of communication among humans, and possibly also machines, to express concepts, ideas, processes, and methods. \n* **Syntax** is the language’s set of symbols and rules that specify how the symbols can be combined to yield syntactically-legal constructs. \n* **Semantics** is the meaning that a subset of the language’s syntactically-legal constructs conveys. \n* A **model** is an abstraction of some portion of conceived reality or of a contemplated system expressed in some language. \n* A **modeling language** is a language for constructing models in some domain. \n* A **formal modeling language** is a modeling language that has a mathematically-grounded syntax definition, enabling its automated analysis, checking, and synthesis. \n* A **formal model** is a model expressed in a formal modeling language. \n* A **conceptual model** is a formal model of a system which expresses its architecture by depicting its structure and behavior to a level of detail that is sufficient for its subsequent detailed design and eventual materialization. \n* A **conceptual modeling language** is a formal modeling language for constructing conceptual models of systems.\n"
    },
    {
      "type": "markdown",
      "id": "48fa037ae9c377d7",
      "text": "10.12 Summary \n\n* A **property** is a metamodel attribute of an OPM element. \n* A **property value** of each element in an OPM model remains fixed. \n* The OPM approach considers **processes as \"first class citizens\"** alongside objects rather than below object. \n* An **object** is a thing that exists or has the potential of physical or informatical existence. \n* Two instances of a physical object are identical if and only if they occupy the same space at the same time. \n* From an informatical viewpoint, all the physical copies of some informatical object are the same . \n* **Transformation** is generation (construction, creation) or consumption (destruction, elimination) or change (effect, state transition), of an object. \n* A **process** is a mental construct representing a pattern of object transformation. \n* In “cause and effect” analysis, **cause** is a triggering event that attempts to cause a process to start executing. \n* The **effect** in “cause and effect” analysis is the transformation that one or more of the objects linked to the executing process undergo. \n* **Parts of speech** (noun, verb, adjective, adverb …) are syntactic constructs, while **OPM things** (object and process) are semantic constructs. \n* The **preprocess object set** of a process P, Pre(P), is the set of objects required to exist, possibly in certain states, in order for P to start executing once it was triggered. \n* The **postprocess object set** of process P, Post(P), is the set of one or more objects that exist, possibly in certain states, after P finished executing. \n* The **involved object set** of process P, Inv(P), is the union of P’s preprocess object set and postprocess object set: Inv(P) = Pre(P) ∪ Post(P). \n* The **object-process distinction problem** is the problem of telling whether a given a noun is an object or a process. \n* The **process test** is a formal procedure for solving the object-process distinction problem. The process test assumes that by default, a noun is an object, so to be a process it must meet three criteria : (1) object transformation, (2) time association , and (3) verb association.  \n* The **object transformation criterion** is satisfied if the noun in question transforms at least one of the objects in the involved object set. \n* The **time association criterion** is satisfied if the noun in question can be thought of as happening through time. \n* The **verb association criterion** is satisfied if the noun in question can be derived from, or has a common root with a verb or has a synonym which is a verb. \n* The **capitalization OPM convention** is that the first letter in each word of the name of a thing is capitalized, while states are lower-case. \n* The **singular name OPM principle** specifies that a name of an OPM thing must be singular. \n* The OPM **process naming convention** is to name a process by making its last word a gerund whenever this is possible and is acceptable and makes sense in the domain nomenclature . \n* **Thing** is a generalization of object and process. \n* A **state-preserving process** is a process that maintains a steady state of status quo, and can be suppressed by replacing it with a **tagged structural relation**. \n* A **transient object** is a short-lived object, and can be suppressed by replacing it with an **invocation link**.\n\n"
    },
    {
      "type": "markdown",
      "id": "e138f9711d9b69a1",
      "text": "11.8 Summary \n\n* **Object-Process Language (OPL)** is a subset of English that expresses textually the OPM model that the OPD set expresses graphically. \n* The **formal syntax for OPL* is expressed by a context-free grammar in Extended Backus-Naur Form (EBNF) in Annex A of ISO 19450 Publicly Available Specification (PAS). \n* A **model fact** is a relation between two or more things in an OPM model. \n* An **OPD element** is the graphical expression of a thing or a link. \n* An **OPD construct** is a collection of connected OPD elements. \n* OPL serves **two goals**, oriented to two directions: humans and machines. The **human-oriented OPL goal** is to convert the set of OPDs comprising the OPM model into a natural language text. The **machine-oriented OPL goal** is to provide a firm basis for automatically generating the infrastructure for the **application development**. \n* An **OPL paragraph** of an OPD is a collection of OPL sentences that express textually the same model facts that this OPD expresses graphically. \n* The **graphics-text equivalence OPM principle** : Any model fact expressed graphically in an OPD is also expressed textually in the corresponding OPL paragraph. \n* A **metamodel** is a model of a model. \n* The **metamodel of the structure** of an OPM system model shows two parallel hierarchies—the hierarchy of graphic objects and the corresponding hierarchy of text objects. \n* An **OPL specification** of an OPM model is the collection of OPL sentences that express textually all the model facts that the OPD set expresses graphically. \n* An **OPL phrase** is a sequence of one or more words. \n* A **non-reserved OPL phrase** is a modeler-defined OPL phrase that expresses a system- or domain-specific OPM model entity or relation name. \n* A **reserved OPL phrase** is an OPL phrase built into the **OPL EBNF syntax** definition that connects two or more non-reserved OPL phrases. \n* The **dual-channel assumption** is that humans possess separate systems for processing visual and verbal representations. \n* The **syntax and semantics** of OPL are defined as a subset of English , eliminating the ambiguity that is often inherent in natural languages. \n* **Tesperanto** is the next generation of OPL.\n\n"
    },
    {
      "type": "markdown",
      "id": "ef542e92a44f78c8",
      "text": "12.11 Summary\n\n* **Activity diagrams** are illustrations of workflows, which describe the flow among actions and are closest in semantics to OPDs. \n* An **action** is a basic unit in an activity diagram, but by using the rake symbol it can be elaborated into an entire activity diagram in its sown right, providing for a refinement mechanism similar to OPM in-zooming. \n* *Flows** in activity diagrams can be of two kinds: control flow and object flow. \n* **Accept, send, and time event action** nodes have special syntax and semantics. \n* **Join and fork** node s are used for synchronizing actions. \n* **Arrows** between an activity and an object in an activity diagram have flow semantics , while in OPM they have transformation semantics —creation, consumption, or state change. \n* **Flow of control** in activity diagrams is achieved through decision nodes, which are diamond-shaped nodes to which a decision input note s are often attached. \n* In **OPM, flow of control** is based in part on Boolean objects. \n* **Requirements diagrams** bridge typical requirements management tools and the system model. \n* **Parametric diagrams** use constraint property block s to bind system parameters to each other via mathematical expressions. \n* In OPM this can be done by expressing the mathematical formula as a **computation process**. \n* **Requirements and parametric diagrams** (like all the other SysML diagram kinds) can be modeled in OPM without special symbols.\n\n"
    },
    {
      "type": "markdown",
      "id": "62b44570fdfc68e4",
      "text": "13.11 Summary \n\n* A **change of an object** is an alteration in the state of that object. \n* **Effect** is a change in the state of an object that a process causes. \n* **Construction** is an extreme case of object effect, where the object’s input state is nonexistent and the output state is existent.\n* **Consumption** is an extreme case of object effect, where the object’s input state is existent and the output state is nonexistent. \n* When the transformation is extreme, a **change in object identity** takes place. \n* When the change is not profound or drastic, the object only **alters its state** while retaining its identity . \n* A **transformee** of process P is an object B that P transforms as a result of the occurrence of P.  \n* A **consumee** of a process P is a transformee of P that P consumes as a result of the occurrence of P. \n* A **resultee** of a process P is a transformee of P that P creates as a result of the occurrence of P. \n* An **affectee** of a process P is a transformee of P that that P affects as a result of the occurrence of P. \n* A **transforming link** is a procedural link that connects a process with a transformee of that process.  \n* A **result link** is a unidirectional transformation link from a process to the resultee that this process creates. \n* An **effect link** is a bidirectional transformation link that connects a process with an affectee of that process. \n* A **consumption link** is a unidirectional transformation link from a consumee to the process that consumes it. \n* An **enabler** E of a process P is an object that must exist and be available in order for P to start, and remain present throughout the occurrence of P in order for P to terminate normally, with E ultimately unaffected.  \n* An **agent** is an enabler who is a human or a group of humans. \n* An **instrument** is a non-human enabler. \n* An **enabling link** is a procedural link that connects a process with an enabler of that process.  \n* An **agent link** is an enabling link that connects a process with an agent of that process. \n* An **instrument link** is a procedural link that connects a process with an enabler of that process. \n* An **input state** of object B is a state s i of B at which B is when process P starts. \n* An **input link** is a link from the state s i to process P. \n* An **output state** of object B is a state s o of B at which B is when process P ends. \n* An **output link** is a link from process P to the state s o . \n* A **state-specified consumption link** is a consumption link that originates from an input state s i of the consumee C and ends at process P, denoting that in order for C to be consumed by P, it must be in state s i . \n* A **state-specified result link** is a result link that originates from process P and ends at a state s of the resultee R, denoting that when P terminates, it creates R in state s. \n* A **state-specified effect link** is an in-out (input–output) link pair, whose input link originates from an input state s i of the affectee A and ends at process P, and whose output link originates from P and ends at an output state s o of A, denoting that in order for A to be affected by P, A must be in s i , in which case when P terminates A will be at s o .  \n* An **in-out-specified effect link pair** of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to the output state s out of B. \n* An **input-specified effect link pair** of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to B. \n* An **output-specified effect link pair** of process P is a pair of links consisting of an input link from object B to P and an output link from P to the output state s out of B. \n* A **value changing link** is a link between a process and an unspecified value of an attribute which the process changes.\n\n\n\n"
    },
    {
      "type": "markdown",
      "id": "3672b9af7f3bdbe3",
      "text": "14.4 Summary \n\n* A **structural relation** is a linkage, connection, or association between two objects or between two processes that holds in the system for at least some time. \n* A **binary structural relation** is bidirectional. \n* A **structural link** is an arrow with an open head that represents a binary structural relation in an OPD from a source object to a destination object. \n* A **structural tag** is a phrase that expresses the semantics—the nature, meaning, or content—of the structural relation between the two things that participate in the relation. \n* A **tagged structural link** is structural link with a structural tag recorded along the link. \n* A **bidirectional tagged structural link** is a combination of two tagged structural links in opposite directions. \n* **Property** is an attribute of an OPM model element. \n* A **reciprocal structural relation** ℜ is a structural relation for which it holds that if A ℜ B and B ℜ′ A then ℜ = ℜ′. \n* A **reciprocal structural link** is a bidirectional tagged structural link, in which the identical forward and backward tags are replaced by a single reciprocity tag. \n* **Reciprocity** is a property of a structural relation that denotes whether its forward and backward structural relations have the same semantics. \n* A **transitive structural relation** ℜ is a structural relation for which it holds that if A ℜ B and B ℜ C then A ℜ C. \n* **Transitivity** is a property of a structural relation, which determines whether the structural relation is transitive. \n* The **values** of both the reciprocity and the transitivity properties of a structural relation can be positive, neutral, or negative. \n* The **unidirectional default null tag** is the default null tag for the unidirectional structural link, and its associated OPL reserved phrase is **“relates to”**. \n* The **bidirectional default null tag** is the default null tag for the bidirectional structural link, and its associated OPL reserved phrase is **“related”**. \n* A **user-defined null tag** is a tag defined by the system modeler that overrides the default null tags for a specific system model, an enterprise, or a domain. \n* **State-preserving processes** convey a message of continuity, stability, detachment from time, or steady state.\n"
    },
    {
      "type": "markdown",
      "id": "3cf00be0b2e937b6",
      "text": "15.9 Summary \n\n* A **participation constraint** is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (**number of repetitions**) of that object in that relation. \n* A **structural participation constraint** is a participation constraint recorded along a structural link. \n* A **procedural participation constraint** is a participation constraint recorded along a procedural link. \n* The **default participation constraint** is 1, and it is implicit. \n* A **parameterized participation constraint** is a participation constraint which is a mathematical expression with one or more parameters. \n* A **range participation constraint** is a participation constraint with lower and upper bounds, each possibly an expression, on the number of possible objects that can take part in the relation. \n* **Source participation constraint** is the participation constraint on the source side of the (structural or procedural) link. \n* **Destination participation constraint** is the participation constraint on the destination side of the (structural or procedural) link. \n* ???**Cardinality** is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. \n* ???The **distributive law of structural relations**: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). \n* A **fork** is a combination of two or more structural links with the same semantics expressed by the same tag. \n* **Handle** is the joint origin-side edge of the fork . \n* **Tine** is the split destination-side edge of the fork . \n* **Handle thing** is the thing linked to the handle of the fork link. \n* **Tine thing** is a thing linked to a tine of the fork link. \n* **Object fork** is a set of objects connected by a fork . \n* **Process fork** is a set of processes connected by a fork . \n* The **tine thing set of a fork** is the set of all the things linked to the tines of the fork. \n* **Fork degree** is a fork property that specifies the size of the tine object set. \n* ???**Fork comprehensiveness** is a Boolean fork property which is positive if all the things in the tine thing set are attached to the fork’s handle and negative otherwise. \n* ???**Orderability** is a Boolean fork property which is positive if the things in the tine thing set are ordered and negative otherwise. \n* ???**Order criterion** is a property of an ordered tine thing set, which specifies textually in the OPD the criterion according to which the things in the tine thing set are ordered.\n\n"
    },
    {
      "type": "markdown",
      "id": "fe04a9e143e6e484",
      "text": "15.9 Summary \n* A **participation constraint** is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (number of repetitions) of that object in that relation. \n* A **structural participation** constraint is a participation constraint recorded along a structural link. \n* A **procedural participation constraint** is a participation constraint recorded along a procedural link. \n* The **default participation constraint** is 1, and it is implicit. \n* A **parameterized participation constraint** is a participation constraint which is a mathematical expression with one or more parameters. \n* A **range participation constraint** is a participation constraint with lower and upper bounds, each possibly an expression, on the **number of possible objects that can take part in the relation**. \n* **Source participation constraint** is the participation constraint on the source side of the (structural or procedural) link. \n* **Destination participation constraint** is the participation constraint on the destination side of the (structural or procedural) link. \n* **Cardinality** is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. \n* The **distributive law of structural relations**: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). \n* A **fork** is a combination of two or more structural links with the same semantics expressed by the same tag. \n* **Handle** is the joint origin-side edge of the fork. \n* **Tine** is the split destination-side edge of the fork. \n* **Handle thing** is the thing linked to the handle of the fork link \n* **Tine thing** is a thing linked to a tine of the fork link. \n* **Object fork** is a set of objects connected by a fork. \n* **Process fork** is a set of processes connected by a fork. \n* The **tine thing set** of a fork is the set of all the things linked to the tines of the fork. \n* **Fork degree** is a fork property that specifies the size of the tine object set. \n* **Fork comprehensiveness** is a Boolean fork property which is positive if all the things in the tine thing set are attached to the fork’s handle and negative otherwise. \n* **Orderability** is a Boolean fork property which is positive if the things in the tine thing set are ordered and negative otherwise. \n* **Order criterion** is a property of an ordered tine thing set, which specifies textually in the OPD the criterion according to which the things in the tine thing set are ordered.\n\n"
    },
    {
      "type": "markdown",
      "id": "788813e9d88cf44e",
      "text": "16.4 Summary\n* **Four structural relations are fundamental** and therefore are assigned graphic symbols.  \n* **Refineable** is a thing amenable to refinement via a fundamental structural relation. \n* **Refinee** is a thing that refines a refineable . \n* The four fundamental structural relations are:  Aggregation-participation; Exhibition-characterization; Generalization-specialization; and Classification-instantiation. \n* Each fundamental structural relation has a unique triangular symbol . \n* The **symbol replaces the tag**, making the OPD more graphic and more quickly comprehensible. \n* Each fundamental structural relation **induces a hierarchy** . \n* **Complex hierarchies** can be created by mixing the four relations. \n* In certain domains, additional structural relations might be fundamental and **user-defined dedicated symbol s** can be allocated for them.\n\n"
    },
    {
      "type": "markdown",
      "id": "c93d644631974428",
      "text": "17.10 Summary \n\n* **Aggregation-participation** is a fundamental structural relation which denotes the fact that a refineable —the whole—aggregates one or more refineables—the parts. \n* Aggregation-participation is a **pair of forward and backward structural relations**. \n* The solid black triangle, ▲, is the aggregation-participation relation **symbol**. \n* It replaces the pair of forward and backward textual tags of the aggregation-participation relation. \n* **Aggregating** is the process of creating a whole from its parts, while participating is enumerating the parts that comprise the aggregate. \n* In UML 2 and SysML , there are two types of aggregation in class diagrams: shared—weak aggregation, marked as a white diamond, and composite—strong aggregation, marked as a black diamond. \n* In OPM the distinction between composite and shared aggregation is not necessary, since one can model exactly what part or parts are consumed when the whole is consumed and what parts remain. \n* **Orderability** is a Boolean property of the aggregation relation, inherited from fork . \n* To denote that the aggregation is ordered, we add the **symbol ordered** next to the aggregation triangle. \n* **Comprehensiveness** is another Boolean property of the aggregation relation, inherited from fork . \n* To denote that the aggregation is **non-comprehensive**, we add a short horizontal bar below the aggregation triangle. \n* The **Parameterized Participation Constraints** (PPC) **mini-language** has a small syntax that determines how to phrase a set of constraints for a parameter in a participation constraint.\n\n"
    },
    {
      "type": "markdown",
      "id": "77eeb9cf91a4e6de",
      "text": "18.9 Summary \n\n* **Exhibition-characterization** is a relation between a thing and the **features** that characterize it. \n* The shorthand name of this relation is characterization and its symbol is . \n* Characterization is the only fundamental structural relation for which **all four combinations** of an object and a process, as an **exhibitor** and a **feature**, are possible. \n* A feature which is an object, is called an **attribute** , while a feature which is a process is an **operation** .\n* An attribute is **implicit** if its values are assigned directly to the exhibitor with no specification of the attribute name. \n* An attribute is **explicit** if it is a separate object that is linked to the exhibitor with an exhibition-characterization relation. \n* **Explicitness** is an attribute of an attribute whose **values are explicit (the default) and implicit**. \n* An attribute is **qualitative** if its values are non-numerical. \n* An attribute is **quantitative** if its values are numerical. \n* An **operation** is quantitative if it transforms a quantitative attribute, otherwise it is quantitative. \n* **Mode** is a property of a feature that determines whether it is qualitative (the default) or quantitative. \n* A quantitative attribute is **hard** if its value cannot be deduced or computed from other attributes. \n* A quantitative attribute is **soft** if its value can be deduced or computed from other attributes. \n* **Touch** is an attribute of a quantitative attribute which determines whether it is hard (the default) or soft. \n* A feature of an object is **inherent** if a least one of the object’s parts exhibits it. \n* A feature of an object is **emergent** if no one of the object’s parts alone exhibits it. \n* **Emergence** is a property of an object whose values are inherent (the default) and emergent. \n* A link is **homogeneous** if it connects two things that exhibit the **same perseverance value**. \n* A link is non-homogeneous if it connects two things that exhibit **opposite perseverance values**. \n* **Homogeneity** is a property of a link whose values are homogeneous (the default for structural links) and non-homogeneous (the default for procedural links).\n\n"
    },
    {
      "type": "markdown",
      "id": "cf194dd67526d444",
      "text": "19.9 Summary\n\n* A **State** is a situation or position at which an object can exist, or a value an attribute can assume, for some period of time during its existence. \n* An **initial state** of an object B is a state at which B is upon its generation or as the system starts executing. A **final state** of an object B is a state from which B cannot exit. \n* A **default state** of an object B is the state which B is expected to be when its state is not specified. \n* **Value** is a state of an attribute, therefore it is a specialization of state. \n* In addition to being at some state, an object can also be **unstable**, when it is **in transition** between two states—the input state and the output state. \n* **State transition** is an unstable period of time for an object, which takes place when a process acts on it to change its state. \n* A **lifespan diagram** is a diagram which, for any point in time during the life of the system, shows what objects exists in the system, what state each object is at, and what processes are active. \n* A **state-specified tagged structural link** is a tagged structural link that connects a state of an object to another object or to a state of another object. \n* An **atomic state** is a state that is not combined of other states. \n* A **compound state** is a state that combines at least two other states. \n* The **state space** of an object is the **Cartesian product** of the sets of states of all the attributes and parts of the object\n\n"
    },
    {
      "type": "markdown",
      "id": "b519a18ae0ef656c",
      "text": "20.9 Summary \n\n* **Generalization-specialization** is the relation between a general thing and a specialization of that thing. \n* **Classification-instantiation** is the relation between a class of things and a unique instance that belongs that class. \n* Generalization-specialization gives rise to **inheritance** from the generalized thing to the specialized one(s). \n* **Inheritance is of features (attributes and operations), structural relations and procedural relations.** \n* **For objects, states are inherited too.** \n* OPM processes specialize in a manner similar to objects. \n* States of specialized objects can **override inherited states**. \n* A **class is a template**, from which things that instantiate the class can be generated as members of that class. \n* **Instance** is a relative term. \n* A specialization in one system can be an instance in another. \n* A **process instance** is a particular occurrence of a process at a given point in time and whose involved object set is a set of object instances.\n\n"
    },
    {
      "type": "markdown",
      "id": "2f46c1de610d8de4",
      "text": "21.21 Summary \n* **Complexity management** is essential for taming the complexity of real-world systems, both man-made and natural. \n* The **OPM Model Complexity Assertion** is that applying **refinement mechanisms** of **in-zooming** and **unfolding** to stateful objects or processes, OPM can conceptually model systems at any level of complexity. \n* OPM’s complexity management approach is **detail-level-based decomposition**, which is in contrast with UML and SysML approach of **aspect-based decomposition**. \n* The **completeness-clarity trade-off** is the tension between the need to specify the system such that all the model facts are represented, while maintaining a clear, comprehensible representation of the system. \n* The **three refinement-abstraction mechanisms** are unfolding–folding, in-zooming–out-zooming, and state-expressing–state-suppressing. \n* A fourth is view-creating–view-deleting. \n* **State-expressing** is showing one or more of an object’s states; **state-suppression** is hiding one or more of the object’s states. \n* Each of the **four fundamental structural relation links** may undergo unfolding and folding, so there are four kinds of unfolding-folding pairs. \n* **In-diagram unfolding** is unfolding in which the refineable and its refinees appear unfolded in the same OPD in which the refinee was originally. \n* **New-diagram unfolding** is unfolding in which the refineable and its refinees appear unfolded in a new OPD. \n* Unfolding is a mechanism for refinement, elaboration, or decomposition, which reveals a set of refineables—things that relate to the unfolded thing—the refineable . \n* A **synchronous process** is a process whose subprocesses have a predefined, fixed order. \n* An **asynchronous process** is a process whose subprocesses do not have a predefined, fixed order. \n* New-diagram in-zooming is in-zooming in which the refineable and its refinees appear in-zoomed in a new OPD. \n* In-diagram in-zooming is in-zooming in which no new OPD is created, and the refineable appear in-zoomed along with its refinees in the same OPD. \n* **In-zooming has the semantics of aggregation-participation plus positive orderability** . \n* Process in-zooming determines the (possibly partial) **temporal order** of its subprocess execution.\n* **Object in-zooming** determines the (possibly 2-dimensional) spatial order of its parts. \n* An **OPD tree** is a directed node- and edge-labeled tree graph whose nodes are OPDs obtained by recursive in-zooming or unfolding of processes in the system, starting with the function—the process in SD. \n* An **OPD set** is the set of all the nodes in the OPD tree. \n* **Detail level** of an OPD is the number of nodes in the OPD tree that need to be traversed from that OPD to the root, SD, including SD itself. \n* The **system map** is an elaborate OPD tree, in which each node in the tree is a miniaturized icon of the OPD, with thick grey arrows pointing from each process in one OPD to its refined (in-zoomed or unfolded) version in the child OPD. \n* The **ultimate OPD** is single flat representation of the OPM system model. \n* Out-zooming provides for incorporating the **middle-out approach to conceptual modeling** by simplifying a complicated OPD while adding an interim level of detail. \n* **Semantic strength** of a procedural link is the **significance** of the information that the link carries. \n* **Link precedence** is an ordered list of procedural links with **diminishing sematic strength**. \n* The **primary link precedence** is Consumption = Result > Effect > Agent > Instrument. \n* **View creating** is collecting model facts from various OPDs in the OPD set and putting them together in a new OPD called **View** for the purpose of **demonstrating a specific aspect**. \n* An **OPD model specification** is the collection of successive OPDs in the system’s OPD tree. \n* An OPL model specification is the collection of successive **OPL paragraphs** corresponding to the OPDs in the system’s OPD tree, from which **duplicate OPL sentences were removed**. \n* An OPM model specification is a **side-by-side presentation** of the OPD model specification and the OPL model specification, where to the right of each OPD the corresponding OPL paragraph is presented.\n\n"
    },
    {
      "type": "markdown",
      "id": "c98be62c5f497fb1",
      "text": "22.13 Summary \n\n* An **event** is a point in time at which something significant to the system execution happens. \n* **Events and preconditions** in concert specify OPM **flow of execution control** for process performance according to the event-condition-action paradigm. \n* The **event-condition-action paradigm** stipulates that starting the performance of a process (the \"action\") has two prerequisites: an **initiating event** and **satisfaction of a precondition** derived from the preprocess object set. \n* A **control modifier** is one of the two letter symbols e and c, added to a procedural link, which add to the semantics of that link the event and condition semantics, respectively. \n* A **control link** is a procedural link with the addition of a control modifier. \n* An **event link** is a procedural link with the control modifier e, indicating initiation of the link’s destination process, **triggering** that process’ **precondition evaluation**.\n* A **condition link** is a procedural link with the control modifier c, indicating that if the precondition of the link’s destination process is **not met**, then that process is **skipped**. \n* The **skip semantics precedence OPM principle** states that skip semantics, induced by a control link, takes **precedence over wait semantics**, induced by a **non-control link**. \n* A **maximal-timed process** is a process for which the modeler determines a maximal duration. An **overtime handling process** is a time exception process that determines what to do in case the time performance of a maximal-timed process exceeds its maximal allowable time. \n* An **overtime exception link** is a procedural link from a maximal-timed process to an overtime handling process, indicating that if the duration of a maximal-timed process exceeds its maximal duration, then the overtime exception process is initiated. \n* A **minimal-timed process** is a process for which the modeler determines a minimal duration. \n* An **undertime handling process** is a time exception process that determines what to do in case the time performance of a minimal timed process falls short of its minimal duration. \n* An **undertime exception link** is a procedural link from a minimal-timed process to an undertime exception process, indicating that if the time performance of a timed process falls short of its minimal allowable time, the undertime exception process is initiated.\n\n"
    },
    {
      "type": "markdown",
      "id": "ae9f1aab3a42e28b",
      "text": "23.9 Summary\n\n* **Logical operators**, including AND, OR, and XOR (exclusive OR) enable modeling complex conditions on performance of processes. \n* **Two or more procedural links of the same kind** that originate from, or arrive at, different points along the process ellipse circumference (the process context), have the semantics of the **logical AND** operator. \n* A **link fan** is a set of f ≥2 procedural links of the same kind that originate from a common point, or arrive at a common point, on the same object or process. \n* The **convergent end** of a link fan is the end that is common to the f fan links. \n* The **divergent end** of a link fan is the end that is not common to the f fan links. \n* A link fan with a **single dashed arc** denotes the **logical XOR** operator. \n* A link fan with a **double dashed arc** denotes the **logical OR** operator. \n* A **converging fan** is a link fan whose links point to its convergent end. \n* A **diverging fan** is a link fan whose links point to its divergent end. \n* Each one of the XOR link fans for consumption, result, effect, and enabling links and their state-specified versions has a corresponding **control-modified link fan**: an **event link fan** and a **condition link fan**. \n* **Link probability** is an optional attribute value assigned to a procedural link in a XOR diverging link fan that specifies the probability of following that particular link among the possible links in the fan link. \n* A **probabilistic link fan** is a link fan with a probability value assigned to each of its links, such that the sum of the probability values of all the links is exactly 1.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "bfc79de573eb2e6f",
      "text": "..."
    },
    {
      "type": "pagefold",
      "id": "1b4d6402c054250e",
      "text": "."
    },
    {
      "type": "markdown",
      "id": "971b73cd74d0962d",
      "text": "I wish to thank my three MIT collaborators, Prof. [[Ed Crawley]] and Prof. [[Oli de Weck]] from Engineering Systems Division and the Aero-Astro Department, and [[Pat Hale]], Director of Systems Design and Management Program. Special thanks to my PhD student, Yaniv Mordecai, who provided insightful comments on many of the chapters in this book. I thank the Technion, Israel Institute of Technology, which provided me with the environment to develop OPM and with the 2013–4 sabbatical to complete this book.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 15-16). Springer New York. Kindle Edition. \n"
    },
    {
      "type": "markdown",
      "id": "20f5618e5e924f24",
      "text": "# Prof. OLIVIER DE WECK "
    },
    {
      "type": "markdown",
      "id": "0ace4206e44db47f",
      "text": "Robert N. Noyce Assistant Professor of Aeronautics and Astronautics and Engineering Systems. Prof. de Weck has taught concept selection and conceptual design optimization in a class on System Architecture (16.882/ESD.34J) at MIT and created a new Multidisciplinary System Design Optimization class (16.888/ESD.77) for graduate level students. His research interests are in Multidisciplinary Design Optimization and System Architecture. Before joining MIT he worked in a CAD/CAE/CAM intensive environment at McDonnell Douglas (now Boeing) on the F/A-18 aircraft program from 1991-1996. \n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "OPM Summaries",
        "story": []
      },
      "date": 1646633159516
    },
    {
      "item": {
        "type": "factory",
        "id": "d77a8f6af23b6fc0"
      },
      "id": "d77a8f6af23b6fc0",
      "type": "add",
      "date": 1646633161434
    },
    {
      "type": "edit",
      "id": "d77a8f6af23b6fc0",
      "item": {
        "type": "markdown",
        "id": "d77a8f6af23b6fc0",
        "text": "1.6 Summary \n* We have started modeling the Automatic Crash Responding system using OPM. \n* OPM has a single diagram type: the object-process diagram (OPD). \n* OPM is built of objects, which exist, and of processes, which transform objects. \n* Object transformation is object creation, object consumption, or object change. \n* We recognize processes—Automatic Crash Responding in our example—as stand-alone OPM building blocks that are separate from objects. \n* Objects and processes enable concurrent modeling of the system’s structure and behavior in the same OPD. \n* Transformation is object creation, consumption, or state change.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 41-42). Springer New York. Kindle Edition. "
      },
      "date": 1646633234483
    },
    {
      "type": "edit",
      "id": "d77a8f6af23b6fc0",
      "item": {
        "type": "markdown",
        "id": "d77a8f6af23b6fc0",
        "text": "1.6 Summary \n* We have started modeling the Automatic Crash Responding system using OPM. \n* OPM has **a single diagram type**: the object-process diagram (OPD). \n* OPM is built of objects, which exist, and of processes, which transform objects. \n* Object transformation is object creation, object consumption, or object change. \n* We recognize processes—Automatic Crash Responding in our example—as stand-alone OPM building blocks that are separate from objects. \n* Objects and processes enable concurrent modeling of the system’s structure and behavior in the same OPD. \n* Transformation is object creation, consumption, or state change.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 41-42). Springer New York. Kindle Edition. "
      },
      "date": 1646633261563
    },
    {
      "type": "edit",
      "id": "d77a8f6af23b6fc0",
      "item": {
        "type": "markdown",
        "id": "d77a8f6af23b6fc0",
        "text": "1.6 Summary \n* We have started modeling the Automatic Crash Responding system using OPM. \n* OPM has **a single diagram type**: the object-process diagram (OPD). \n* OPM is built of **objects**, which exist, and of **processes**, which transform objects. \n* **Object transformation** is object creation, object consumption, or object change. \n* We recognize processes—Automatic Crash Responding in our example—as stand-alone OPM building blocks that are separate from objects. \n* Objects and processes enable concurrent modeling of the system’s **structure and behavior** in the same OPD. \n* Transformation is **object creation, consumption, or state change**.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 41-42). Springer New York. Kindle Edition. "
      },
      "date": 1646633368937
    },
    {
      "type": "edit",
      "id": "d77a8f6af23b6fc0",
      "item": {
        "type": "markdown",
        "id": "d77a8f6af23b6fc0",
        "text": "1.6 Summary \n* We have started modeling the Automatic Crash Responding system using OPM. \n* OPM has **a single diagram type**: the object-process diagram (OPD). \n* OPM is built of **objects**, which exist, and of **processes**, which transform objects. \n* **Object transformation** is object creation, object consumption, or object change. \n* We recognize **processes**—Automatic Crash Responding in our example—as stand-alone OPM **building blocks** that are separate from objects. \n* Objects and processes enable concurrent modeling of the system’s **structure and behavior** in the same OPD. \n* Transformation is **object creation, consumption, or state change**.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 41-42). Springer New York. Kindle Edition. "
      },
      "date": 1646633430302
    },
    {
      "item": {
        "type": "factory",
        "id": "8cfda0d5582d1f60"
      },
      "id": "8cfda0d5582d1f60",
      "type": "add",
      "after": "d77a8f6af23b6fc0",
      "date": 1646639459139
    },
    {
      "type": "edit",
      "id": "8cfda0d5582d1f60",
      "item": {
        "type": "markdown",
        "id": "8cfda0d5582d1f60",
        "text": "2.4 Summary \n* OPM has two equivalent representation modalities: the graphic—object-process **diagram** (OPD) and the textual—object-process **language** (OPL). \n* The OPL sentence s and the OPD complement each other, as they appeal to the parallel visual and verbal **cognitive processing** channels of the human brain . \n* A **state** is a situation at which an object can be. \n* An **effect link** indicates some state change of the linked object by the linked process. \n* An input–output link pair indicates the specific state from and to which the process changes the object. \n* An OPM model is amenable to animated simulation , which facilitates understanding the system’s dynamic aspect and testing its logical flow.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 52-53). Springer New York. Kindle Edition. "
      },
      "date": 1646639627591
    },
    {
      "type": "edit",
      "id": "8cfda0d5582d1f60",
      "item": {
        "type": "markdown",
        "id": "8cfda0d5582d1f60",
        "text": "2.4 Summary \n* OPM has two equivalent representation modalities: the graphic—object-process **diagram** (OPD) and the textual—object-process **language** (OPL). \n* The OPL sentence s and the OPD complement each other, as they appeal to the parallel visual and verbal **cognitive processing** channels of the human brain . \n* A **state** is a situation at which an object can be. \n* An **effect link** indicates some state change of the linked object by the linked process. \n* An **input–output link pair** indicates the specific state from and to which the process changes the object. \n* An OPM model is amenable to **animated simulation** , which facilitates understanding the system’s dynamic aspect and testing its logical flow.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 52-53). Springer New York. Kindle Edition. "
      },
      "date": 1646640110468
    },
    {
      "type": "edit",
      "id": "8cfda0d5582d1f60",
      "item": {
        "type": "markdown",
        "id": "8cfda0d5582d1f60",
        "text": "2.4 Summary \n* OPM has two equivalent representation modalities: the graphic—object-process **diagram** (OPD) and the textual—object-process **language** (OPL). \n* The OPL sentence s and the OPD complement each other, as they appeal to the parallel visual and verbal **cognitive processing** channels of the human brain . \n* A **state** is a situation at which an object can be. \n* An **effect link** indicates some state change of the linked object by the linked process. \n* An **input–output link pair** indicates the specific state from and to which the process changes the object. \n* An OPM model is amenable to **animated simulation** , which facilitates understanding the system’s dynamic aspect and testing its logical flow.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 52-53). Springer New York. Kindle Edition. \n"
      },
      "date": 1646963214517
    },
    {
      "type": "add",
      "id": "971b73cd74d0962d",
      "item": {
        "type": "markdown",
        "id": "971b73cd74d0962d",
        "text": "I wish to thank my three MIT collaborators, Prof. Ed Crawley and Prof. Oli de Weck from Engineering Systems Division and the Aero-Astro Department, and Pat Hale, Director of Systems Design and Management Program. Special thanks to my PhD student, Yaniv Mordecai, who provided insightful comments on many of the chapters in this book. I thank the Technion, Israel Institute of Technology, which provided me with the environment to develop OPM and with the 2013–4 sabbatical to complete this book.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 15-16). Springer New York. Kindle Edition. "
      },
      "after": "8cfda0d5582d1f60",
      "date": 1646963218314
    },
    {
      "type": "edit",
      "id": "971b73cd74d0962d",
      "item": {
        "type": "markdown",
        "id": "971b73cd74d0962d",
        "text": "I wish to thank my three MIT collaborators, Prof. [[Ed Crawley]] and Prof. [[Oli de Weck]] from Engineering Systems Division and the Aero-Astro Department, and Pat Hale, Director of Systems Design and Management Program. Special thanks to my PhD student, Yaniv Mordecai, who provided insightful comments on many of the chapters in this book. I thank the Technion, Israel Institute of Technology, which provided me with the environment to develop OPM and with the 2013–4 sabbatical to complete this book.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 15-16). Springer New York. Kindle Edition. "
      },
      "date": 1646963255789
    },
    {
      "type": "edit",
      "id": "971b73cd74d0962d",
      "item": {
        "type": "markdown",
        "id": "971b73cd74d0962d",
        "text": "I wish to thank my three MIT collaborators, Prof. [[Ed Crawley]] and Prof. [[Oli de Weck]] from Engineering Systems Division and the Aero-Astro Department, and [[Pat Hale]], Director of Systems Design and Management Program. Special thanks to my PhD student, Yaniv Mordecai, who provided insightful comments on many of the chapters in this book. I thank the Technion, Israel Institute of Technology, which provided me with the environment to develop OPM and with the 2013–4 sabbatical to complete this book.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 15-16). Springer New York. Kindle Edition. "
      },
      "date": 1646963290327
    },
    {
      "item": {
        "type": "factory",
        "id": "fc0ccd0497fa2700"
      },
      "id": "fc0ccd0497fa2700",
      "type": "add",
      "after": "971b73cd74d0962d",
      "date": 1646965778820
    },
    {
      "type": "edit",
      "id": "fc0ccd0497fa2700",
      "item": {
        "type": "markdown",
        "id": "fc0ccd0497fa2700",
        "text": "Prof. OLIVIER DE WECK "
      },
      "date": 1646965793350
    },
    {
      "type": "add",
      "id": "0ace4206e44db47f",
      "item": {
        "type": "markdown",
        "id": "0ace4206e44db47f",
        "text": "Robert N. Noyce Assistant Professor of Aeronautics and Astronautics and Engineering Systems. Prof. de Weck has taught concept selection and conceptual design optimization in a class on System Architecture (16.882/ESD.34J) at MIT and created a new Multidisciplinary System Design Optimization class (16.888/ESD.77) for graduate level students. His research interests are in Multidisciplinary Design Optimization and System Architecture. Before joining MIT he worked in a CAD/CAE/CAM intensive environment at McDonnell Douglas (now Boeing) on the F/A-18 aircraft program from 1991-1996. \n"
      },
      "after": "fc0ccd0497fa2700",
      "date": 1646965795739
    },
    {
      "type": "remove",
      "id": "fc0ccd0497fa2700",
      "date": 1646965802002
    },
    {
      "type": "edit",
      "id": "971b73cd74d0962d",
      "item": {
        "type": "markdown",
        "id": "971b73cd74d0962d",
        "text": "I wish to thank my three MIT collaborators, Prof. [[Ed Crawley]] and Prof. [[Oli de Weck]] from Engineering Systems Division and the Aero-Astro Department, and [[Pat Hale]], Director of Systems Design and Management Program. Special thanks to my PhD student, Yaniv Mordecai, who provided insightful comments on many of the chapters in this book. I thank the Technion, Israel Institute of Technology, which provided me with the environment to develop OPM and with the 2013–4 sabbatical to complete this book.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 15-16). Springer New York. Kindle Edition. Prof. OLIVIER DE WECK "
      },
      "date": 1646965802940
    },
    {
      "type": "edit",
      "id": "971b73cd74d0962d",
      "item": {
        "type": "markdown",
        "id": "971b73cd74d0962d",
        "text": "I wish to thank my three MIT collaborators, Prof. [[Ed Crawley]] and Prof. [[Oli de Weck]] from Engineering Systems Division and the Aero-Astro Department, and [[Pat Hale]], Director of Systems Design and Management Program. Special thanks to my PhD student, Yaniv Mordecai, who provided insightful comments on many of the chapters in this book. I thank the Technion, Israel Institute of Technology, which provided me with the environment to develop OPM and with the 2013–4 sabbatical to complete this book.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 15-16). Springer New York. Kindle Edition. \n"
      },
      "date": 1646965817280
    },
    {
      "type": "add",
      "id": "20f5618e5e924f24",
      "item": {
        "type": "markdown",
        "id": "20f5618e5e924f24",
        "text": "# Prof. OLIVIER DE WECK "
      },
      "after": "971b73cd74d0962d",
      "date": 1646965827230
    },
    {
      "type": "edit",
      "id": "8cfda0d5582d1f60",
      "item": {
        "type": "markdown",
        "id": "8cfda0d5582d1f60",
        "text": "2.4 Summary \n* OPM has two equivalent representation modalities: the graphic—object-process **diagram** (OPD) and the textual—object-process **language** (OPL). \n* The OPL sentence s and the OPD complement each other, as they appeal to the parallel visual and verbal **cognitive processing** channels of the human brain . \n* A **state** is a situation at which an object can be. \n* An **effect link** indicates some state change of the linked object by the linked process. \n* An **input–output link pair** indicates the specific state from and to which the process changes the object. \n* An OPM model is amenable to **animated simulation** , which facilitates understanding the system’s dynamic aspect and testing its logical flow.\n\n"
      },
      "date": 1647024944510
    },
    {
      "type": "add",
      "id": "c89ffadc634401e8",
      "item": {
        "type": "markdown",
        "id": "c89ffadc634401e8",
        "text": "There is ongoing work with modest funding to launch a co-op hosting of federated wiki sites."
      },
      "after": "8cfda0d5582d1f60",
      "date": 1647024954301
    },
    {
      "type": "edit",
      "id": "c89ffadc634401e8",
      "item": {
        "type": "markdown",
        "id": "c89ffadc634401e8",
        "text": "3.9 Summary \n* Enablers are required for a process to occur, but are not affected by the occurrence of that process. \n* An agent is a human enabler, while an instrument is a non-human enabler. \n* Two types of link s connect entities with each other: structural link s and procedural link s.  \n* Procedural link s, which are between a process and an object or one of its states, express the behavior of the system; for example, an effect link. Structural link s express persistent , long-term relations between two connected objects or between two connected processes in the system; for example, an aggregation-participation link . Since the structural and the procedural links are expressed in the same diagram, they help integrate the structure and the behavior of the system. Thing s—that is, objects and processes—are classified by their  Essence into physical thing s and informatical thing s, and by their Affiliation into systemic thing s and environmental thing s. A process is triggered by an event link.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 68-69). Springer New York. Kindle Edition. "
      },
      "date": 1647025014887
    },
    {
      "type": "edit",
      "id": "c89ffadc634401e8",
      "item": {
        "type": "markdown",
        "id": "c89ffadc634401e8",
        "text": "3.9 Summary \n* **Enablers** are required for a process to occur, but are not affected by the occurrence of that process. \n* An **agent** is a human enabler, while an instrument is a non-human enabler. \n* Two types of link s connect entities with each other: structural link s and procedural link s.  \n* **Procedural link** s, which are between a process and an object or one of its states, express the behavior of the system; for example, an effect link. \n* **Structural link** s express persistent , long-term relations between two connected objects or between two connected processes in the system; for example, an aggregation-participation link . \n* Since the structural and the procedural links are expressed in the same diagram, they help integrate the **structure and the behavior** of the system. \n* Thing s—that is, objects and processes—are classified by their  \n* **Essence** into physical thing s and informatical thing s, and by their \n* **Affiliation** into systemic thing s and environmental thing s. A process is triggered by an event link.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 68-69). Springer New York. Kindle Edition. "
      },
      "date": 1647025230948
    },
    {
      "type": "edit",
      "id": "c89ffadc634401e8",
      "item": {
        "type": "markdown",
        "id": "c89ffadc634401e8",
        "text": "3.9 Summary \n* **Enablers** are required for a process to occur, but are not affected by the occurrence of that process. \n* An **agent** is a human enabler, while an instrument is a non-human enabler. \n* Two types of link s connect entities with each other: structural link s and procedural link s.  \n* **Procedural link** s, which are between a process and an object or one of its states, express the behavior of the system; for example, an effect link. \n* **Structural link** s express persistent , long-term relations between two connected objects or between two connected processes in the system; for example, an aggregation-participation link . \n* Since the structural and the procedural links are expressed in the same diagram, they help **integrate** the **structure and the behavior** of the system. \n* Thing s—that is, objects and processes—are classified by their  \n* **Essence** into physical thing s and informatical thing s, and by their \n* **Affiliation** into systemic thing s and environmental thing s. A process is triggered by an event link.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 68-69). Springer New York. Kindle Edition. "
      },
      "date": 1647025262083
    },
    {
      "type": "edit",
      "id": "c89ffadc634401e8",
      "item": {
        "type": "markdown",
        "id": "c89ffadc634401e8",
        "text": "3.9 Summary \n* **Enablers** are required for a process to occur, but are not affected by the occurrence of that process. \n* An **agent** is a human enabler, while an instrument is a non-human enabler. \n* Two types of link s connect entities with each other: structural link s and procedural link s.  \n* **Procedural link** s, which are between a process and an object or one of its states, express the behavior of the system; for example, an effect link. \n* **Structural link** s express persistent , long-term relations between two connected objects or between two connected processes in the system; for example, an aggregation-participation link . \n* Since the structural and the procedural links are expressed in the same diagram, they help **integrate** the **structure and the behavior** of the system. \n* Thing s—that is, objects and processes—are classified by their  \n* **Essence** into physical thing s and informatical thing s, and by their \n* **Affiliation** into systemic thing s and environmental thing s. A process is triggered by an event link.\n\n\n"
      },
      "date": 1647025290242
    },
    {
      "type": "add",
      "id": "3d02e6069fa83202",
      "item": {
        "type": "markdown",
        "id": "3d02e6069fa83202",
        "text": "4.4 Summary \n* **SysML** has nine types of diagrams that model various aspects of the system. \n* The use case diagram is often the first to be prepared since it provides the context of the system and how actors interact with it. \n* **Block** is a basic unit, akin to class in UML , used in the block definition diagram and internal block diagram. It serves to define the structure of the system. \n* **State machine diagram** is a SysML diagram that specifies the possible states of relevant blocks in the system and transitions between these states.\n\n"
      },
      "after": "c89ffadc634401e8",
      "date": 1647025398948
    },
    {
      "type": "edit",
      "id": "3d02e6069fa83202",
      "item": {
        "type": "markdown",
        "id": "3d02e6069fa83202",
        "text": "4.4 Summary \n* **SysML** has nine types of diagrams that model various aspects of the system. \n* The use case diagram is often the first to be prepared since it provides the context of the system and how actors interact with it. \n* **Block** is a basic unit, akin to class in UML , used in the block definition diagram and internal block diagram. It serves to define the structure of the system. \n"
      },
      "date": 1647025457217
    },
    {
      "type": "add",
      "id": "9864c74d640d2ea0",
      "item": {
        "type": "markdown",
        "id": "9864c74d640d2ea0",
        "text": "4.4 Summary \n* SysML has nine types of diagrams that model various aspects of the system \n* The use case diagram is often the first to be prepared since it provides the context of the system and how actors interact with it. \n* Block is a basic unit, akin to class in UML , used in the block definition diagram and internal block diagram. \n* It serves to define the structure of the system. State machine diagram is a SysML diagram that specifies the possible states of relevant blocks in the system and transitions between these states.\n\n\n\n"
      },
      "after": "3d02e6069fa83202",
      "date": 1647025512131
    },
    {
      "type": "edit",
      "id": "9864c74d640d2ea0",
      "item": {
        "type": "markdown",
        "id": "9864c74d640d2ea0",
        "text": " \n5.7 Summary \n* In-zooming is a refinement mechanism that helps manage system complexity . \n* Zooming into a process creates a new OPD with an inflated in-zoomed process. \n* Lower-level processes (subprocesses) are nested within this in-zoomed process and they can be linked to lower-level objects inside or outside the in-zoomed process. \n* Recursive in-zooming results in an OPD set that has a tree structure, in which lower-level OPDs model increasingly refined details about the system. \n* The model fact representation OPM principle stipulates that in order for an OPM model fact to be represented, it needs to appear in at least one OPD in order for it to be represented in the model. \n* Using this principle helps decrease diagram clutter, making each diagram simple enough to be grasped without cognitive overload.\n\n"
      },
      "date": 1647025586089
    },
    {
      "type": "add",
      "id": "c92bc0d23c982368",
      "item": {
        "type": "markdown",
        "id": "c92bc0d23c982368",
        "text": "6.6 Summary \n* The **condition link** semantics is that if the object to which the link is attached exists, or if the state to which the link is attached is the current object state, then the process executes, otherwise it is skipped. \n* The **XOR relation** between procedural links indicates that exactly one of the possible interactions denoted by these links materializes. \n* XOR is **denoted graphically** by a common point from which all the XOR'ed links originate or at which they terminate, and a dashed arc through these links whose center is the common links’ point. \n* The **timeline OPM principle** stipulates that the timeline within the context of an in-zoomed process is directed by default from the top of the in-zoomed process ellipse to its bottom. \n* The **subprocess execution order** is determined by the height of the top subprocess ellipse points, such that the one at the top starts first. \n* If the top ellipse point of two or more sub processes is at the **same height**, within a predefined tolerance, they **start simultaneously**. This is the way to **model process synchronization**.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 97-98). Springer New York. Kindle Edition. "
      },
      "after": "9864c74d640d2ea0",
      "date": 1647025837649
    },
    {
      "type": "edit",
      "id": "c92bc0d23c982368",
      "item": {
        "type": "markdown",
        "id": "c92bc0d23c982368",
        "text": "6.6 Summary \n* The **condition link** semantics is that if the object to which the link is attached exists, or if the state to which the link is attached is the current object state, then the process executes, otherwise it is skipped. \n* The **XOR relation** between procedural links indicates that exactly one of the possible interactions denoted by these links materializes. \n* XOR is **denoted graphically** by a common point from which all the XOR'ed links originate or at which they terminate, and a dashed arc through these links whose center is the common links’ point. \n* The **timeline OPM principle** stipulates that the timeline within the context of an in-zoomed process is directed by default from the top of the in-zoomed process ellipse to its bottom. \n* The **subprocess execution order** is determined by the height of the top subprocess ellipse points, such that the one at the top starts first. \n* If the top ellipse point of two or more sub processes is at the **same height**, within a predefined tolerance, they **start simultaneously**. This is the way to **model process synchronization**.\n\n\n"
      },
      "date": 1647025922589
    },
    {
      "type": "add",
      "id": "f74fb3be2fa9a0f3",
      "item": {
        "type": "markdown",
        "id": "f74fb3be2fa9a0f3",
        "text": "7.10 Summary \n* A Boolean object has two states and is used for modeling flow of control. \n* A condition link has a control modifier c added to a procedural link, augmenting its semantics with skip meaning. \n* Generalization-specialization is a fundamental structural relation that induces inheritance of features (attributes and operations), links, and states from the general thing to the specialized thing. \n* Participation constrains enable specifying how many objects of the same class participate in a relation. \n* OR is a relaxed version of the XOR logical operator that allows any subset of participating links to be active at once, rather than exactly one of them, as XOR does. \n* Objects within an in-zoomed process are recognized only in the scope of that process. If they are used in places outside that scope they must be placed outside the in-zoomed process.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 112-113). Springer New York. Kindle Edition. "
      },
      "after": "c92bc0d23c982368",
      "date": 1647025987858
    },
    {
      "type": "edit",
      "id": "f74fb3be2fa9a0f3",
      "item": {
        "type": "markdown",
        "id": "f74fb3be2fa9a0f3",
        "text": "7.10 Summary \n* A Boolean object has two states and is used for modeling flow of control. \n* A condition link has a control modifier c added to a procedural link, augmenting its semantics with skip meaning. \n* Generalization-specialization is a fundamental structural relation that induces inheritance of features (attributes and operations), links, and states from the general thing to the specialized thing. \n* Participation constrains enable specifying how many objects of the same class participate in a relation. \n* OR is a relaxed version of the XOR logical operator that allows any subset of participating links to be active at once, rather than exactly one of them, as XOR does. \n* Objects within an in-zoomed process are recognized only in the scope of that process. If they are used in places outside that scope they must be placed outside the in-zoomed process.\n\n\n"
      },
      "date": 1647026058741
    },
    {
      "type": "add",
      "id": "8544700eb5738841",
      "item": {
        "type": "markdown",
        "id": "8544700eb5738841",
        "text": "7.10 Summary \n* A **Boolean object** has two states and is used for **modeling flow of control**. \n* A **condition link** has a control modifier c added to a procedural link, augmenting its semantics with **skip meaning**. \n* **Generalization-specialization** is a fundamental structural relation that induces inheritance of features (**attributes** and **operations**), links, and states from the general thing to the specialized thing. \n* Participation constrains enable specifying how many objects of the same class participate in a relation. \n* OR is a relaxed version of the XOR logical operator that allows any subset of participating links to be active at once, rather than exactly one of them, as XOR does. \n* Objects within an in-zoomed process are recognized only in the scope of that process. \n* If they are used in places outside that scope they must be placed outside the in-zoomed process.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 112-113). Springer New York. Kindle Edition. "
      },
      "after": "f74fb3be2fa9a0f3",
      "date": 1647026225258
    },
    {
      "type": "edit",
      "id": "8544700eb5738841",
      "item": {
        "type": "markdown",
        "id": "8544700eb5738841",
        "text": "7.10 Summary \n* A **Boolean object** has two states and is used for **modeling flow of control**. \n* A **condition link** has a control modifier c added to a procedural link, augmenting its semantics with **skip meaning**. \n* **Generalization-specialization** is a fundamental structural relation that induces inheritance of features (**attributes** and **operations**), links, and states from the general thing to the specialized thing. \n* **Participation constraints** enable specifying how many objects of the same class participate in a relation. \n* **OR** is a relaxed version of the XOR logical operator that allows **any subset of participating links** to be active at once, rather than exactly one of them, as XOR does. \n* **Objects within an in-zoomed process** are recognized only in the scope of that process. \n* If they are used in places outside that scope they must be **placed outside the in-zoomed process**.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 112-113). Springer New York. Kindle Edition. "
      },
      "date": 1647026400253
    },
    {
      "type": "edit",
      "id": "8544700eb5738841",
      "item": {
        "type": "markdown",
        "id": "8544700eb5738841",
        "text": "7.10 Summary \n* A **Boolean object** has two states and is used for **modeling flow of control**. \n* A **condition link** has a control modifier c added to a procedural link, augmenting its semantics with **skip meaning**. \n* **Generalization-specialization** is a fundamental structural relation that induces inheritance of features (**attributes** and **operations**), links, and states from the general thing to the specialized thing. \n* **Participation constraints** enable specifying how many objects of the same class participate in a relation. \n* **OR** is a relaxed version of the XOR logical operator that allows **any subset of participating links** to be active at once, rather than exactly one of them, as XOR does. \n* **Objects within an in-zoomed process** are recognized only in the scope of that process. \n* If they are used in places outside that scope they must be **placed outside the in-zoomed process**.\n\n"
      },
      "date": 1647027125804
    },
    {
      "type": "add",
      "id": "1fa3de92363f095d",
      "item": {
        "type": "markdown",
        "id": "1fa3de92363f095d",
        "text": "9.6 Summary Science can be thought of as reverse engineering of nature. The Minimal Ontology principle states that if a system can be specified at the same level of accuracy and detail by two languages of different ontology sizes, then the language with the smaller size is preferred over the one with the larger size. Objects exist, processes happen. Ontology is a set of concepts and their relations in some domain of discourse. A minimal universal ontology is the ontology that is necessary and sufficient to model the universe and systems in it. The Object-Process Theorem : Stateful objects, processes, and relations among them constitute a minimal universal ontology. The Object-Process Assertion : Using stateful objects, processes, and relations among them, along with refinement mechanisms of in-zooming and unfolding, one can conceptually model systems in any domain and at any level of complexity. The thing importance OPM principle : The importance of a thing T in an OPM model is directly related to the highest OPD in the OPD hierarchy where T appears. An object is a thing that exists or can exist physically or informatically. A state is a possible situation or position at which an object can be for some positive amount of time. Transformation of an object is (1) creation (generation, construction), (2) consumption (elimination, destruction), or (3) effect—change in the state of that object. A process is a thing that transforms an object. The object transformation by process OPM principle : In a complete OPM model, each process must be connected to at least one object that the process transforms or one state of the object that the process transforms. A system is a function-providing object.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 160-161). Springer New York. Kindle Edition. "
      },
      "after": "8544700eb5738841",
      "date": 1647027131900
    },
    {
      "type": "edit",
      "id": "1fa3de92363f095d",
      "item": {
        "type": "markdown",
        "id": "1fa3de92363f095d",
        "text": "9.6 Summary Science can be thought of as reverse engineering of nature. The Minimal Ontology principle states that if a system can be specified at the same level of accuracy and detail by two languages of different ontology sizes, then the language with the smaller size is preferred over the one with the larger size. Objects exist, processes happen. Ontology is a set of concepts and their relations in some domain of discourse. A minimal universal ontology is the ontology that is necessary and sufficient to model the universe and systems in it. The Object-Process Theorem : Stateful objects, processes, and relations among them constitute a minimal universal ontology. The Object-Process Assertion : Using stateful objects, processes, and relations among them, along with refinement mechanisms of in-zooming and unfolding, one can conceptually model systems in any domain and at any level of complexity. The thing importance OPM principle : The importance of a thing T in an OPM model is directly related to the highest OPD in the OPD hierarchy where T appears. An object is a thing that exists or can exist physically or informatically. A state is a possible situation or position at which an object can be for some positive amount of time. Transformation of an object is (1) creation (generation, construction), (2) consumption (elimination, destruction), or (3) effect—change in the state of that object. A process is a thing that transforms an object. The object transformation by process OPM principle : In a complete OPM model, each process must be connected to at least one object that the process transforms or one state of the object that the process transforms. A system is a function-providing object.\n\nA stakeholder is an individual, an organization, or a group of people that has an interest in, or might be affected by, a system being contemplated, developed, or deployed. A beneficiary is a stakeholder who extracts value and benefits from the system. A customer is the stakeholder who orders the system and sponsors its development, implementation, deployment, and support. A user is a stakeholder who operates the system or directly interacts with it. A supplier is a stakeholder who oversees the development, support, and maintenance of the system or product. A function of an artificial system is its top-level value-providing process, as perceived by the beneficiary. Structure of a system is its form—the assembly of its physical and informatical components along with the long-lasting relations among them. Behavior of a system is it dynamics—the way the system changes over time by transforming systemic (internal) and/or environmental (external) objects. Architecture of a system is the combination of the system’s structure and behavior which enables it to perform its function. The system’s environment is a collection of objects that are outside the system but interact with it, causing the system and possibly its environment to change. The function-behavior distinction : Behavior is how the system changes along the time dimension, while function is what value the system delivers to its beneficiary through its operation. A language is a means of communication among humans, and possibly also machines, to express concepts, ideas, processes, and methods. Syntax is the language’s set of symbols and rules that specify how the symbols can be combined to yield syntactically-legal constructs. Semantics is the meaning that a subset of the language’s syntactically-legal constructs conveys. A model is an abstraction of some portion of conceived reality or of a contemplated system expressed in some language. A modeling language is a language for constructing models in some domain. A formal modeling language is a modeling language that has a mathematically-grounded syntax definition, enabling its automated analysis, checking, and synthesis. A formal model is a model expressed in a formal modeling language. A conceptual model is a formal model of a system which expresses its architecture by depicting its structure and behavior to a level of detail that is sufficient for its subsequent detailed design and eventual materialization. A conceptual modeling language is a formal modeling language for constructing conceptual models of systems.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 161-163). Springer New York. Kindle Edition.  "
      },
      "date": 1647027165368
    },
    {
      "type": "edit",
      "id": "8544700eb5738841",
      "item": {
        "type": "markdown",
        "id": "8544700eb5738841",
        "text": "7.10 Summary \n* A **Boolean object** has two states and is used for **modeling flow of control**. \n* A **condition link** has a control modifier c added to a procedural link, augmenting its semantics with **skip meaning**. \n* **Generalization-specialization** is a fundamental structural relation that induces inheritance of features (**attributes** and **operations**), links, and states from the general thing to the specialized thing. \n* **Participation constraints** enable specifying how many objects of the same class participate in a relation. \n* **OR** is a relaxed version of the XOR logical operator that allows **any subset of participating links** to be active at once, rather than exactly one of them, as XOR does. \n* **Objects within an in-zoomed process** are recognized only in the scope of that process. \n* If they are used in places outside that scope they must be **placed outside the in-zoomed process**.\n\n\n"
      },
      "date": 1647027207886
    },
    {
      "type": "add",
      "id": "bd0ffa708c262c6c",
      "item": {
        "type": "markdown",
        "id": "bd0ffa708c262c6c",
        "text": "8.4 Summary\n**While the objective of OPM-based modeling is to go top-down and refine model facts as we go, to avoid diagram clutter it is sometimes required to abstract two or more processes in the crowded OPD and create a new OPD at an interim level. Abstraction can be achieved by process out-zooming: Creating an abstract process, which, when in-zoomed, will include the out-zoomed subprocesses (and possibly others). Right after a process is in-zoomed, all the procedural links are still attached to it. As subprocesses are added, procedural link edges should be dragged from the in-zoomed process ellipse to the appropriate subprocesses. Only links that apply to all the subprocesses inside the in-zoomed process should remain attached to the in-zoomed process. A structural view is achieved by removing all the processes and the procedural links from the model. The structural view enables focusing on the system structure and examining possible structural improvements.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (p. 123). Springer New York. Kindle Edition. "
      },
      "after": "8544700eb5738841",
      "date": 1647027232235
    },
    {
      "type": "edit",
      "id": "bd0ffa708c262c6c",
      "item": {
        "type": "markdown",
        "id": "bd0ffa708c262c6c",
        "text": "8.4 Summary\n* While the objective of OPM-based modeling is to go top-down and refine model facts as we go, **to avoid diagram clutter** it is sometimes required to abstract two or more processes in the crowded OPD and create a new OPD at an interim level. \n* Abstraction can be achieved by process **out-zooming**: Creating an abstract process, which, when in-zoomed, will include the out-zoomed subprocesses (and possibly others). \n* Right after a process is **in-zoomed**, all the **procedural links** are still attached to it. \n* As subprocesses are added, **procedural link edges should be dragged** from the in-zoomed process ellipse to the appropriate subprocesses. \n* Only **links that apply to all the subprocesses** inside the in-zoomed process should remain attached to the in-zoomed process. \n* A **structural view** is achieved by removing all the processes and the procedural links from the model. \n* The structural view enables focusing on the system structure and examining possible **structural improvements**.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (p. 123). Springer New York. Kindle Edition. "
      },
      "date": 1647027522549
    },
    {
      "type": "edit",
      "id": "bd0ffa708c262c6c",
      "item": {
        "type": "markdown",
        "id": "bd0ffa708c262c6c",
        "text": "8.4 Summary\n* While the objective of OPM-based modeling is to go top-down and refine model facts as we go, **to avoid diagram clutter** it is sometimes required to abstract two or more processes in the crowded OPD and create a new OPD at an interim level. \n* Abstraction can be achieved by process **out-zooming**: Creating an abstract process, which, when in-zoomed, will include the out-zoomed subprocesses (and possibly others). \n* Right after a process is **in-zoomed**, all the **procedural links** are still attached to it. \n* As subprocesses are added, **procedural link edges should be dragged** from the in-zoomed process ellipse to the appropriate subprocesses. \n* Only **links that apply to all the subprocesses** inside the in-zoomed process should remain attached to the in-zoomed process. \n* A **structural view** is achieved by removing all the processes and the procedural links from the model. \n* The structural view enables focusing on the system structure and examining possible **structural improvements**.\n"
      },
      "date": 1647027618697
    },
    {
      "type": "edit",
      "id": "1fa3de92363f095d",
      "item": {
        "type": "markdown",
        "id": "1fa3de92363f095d",
        "text": "9.6 Summary \n* Science can be thought of as reverse engineering of nature. \n* The Minimal Ontology principle states that if a system can be specified at the same level of accuracy and detail by two languages of different ontology sizes, then the language with the smaller size is preferred over the one with the larger size. Objects exist, processes happen. Ontology is a set of concepts and their relations in some domain of discourse. A minimal universal ontology is the ontology that is necessary and sufficient to model the universe and systems in it. The Object-Process Theorem : Stateful objects, processes, and relations among them constitute a minimal universal ontology. The Object-Process Assertion : Using stateful objects, processes, and relations among them, along with refinement mechanisms of in-zooming and unfolding, one can conceptually model systems in any domain and at any level of complexity. The thing importance OPM principle : The importance of a thing T in an OPM model is directly related to the highest OPD in the OPD hierarchy where T appears. An object is a thing that exists or can exist physically or informatically. A state is a possible situation or position at which an object can be for some positive amount of time. Transformation of an object is (1) creation (generation, construction), (2) consumption (elimination, destruction), or (3) effect—change in the state of that object. A process is a thing that transforms an object. The object transformation by process OPM principle : In a complete OPM model, each process must be connected to at least one object that the process transforms or one state of the object that the process transforms. A system is a function-providing object.\n\nA stakeholder is an individual, an organization, or a group of people that has an interest in, or might be affected by, a system being contemplated, developed, or deployed. A beneficiary is a stakeholder who extracts value and benefits from the system. A customer is the stakeholder who orders the system and sponsors its development, implementation, deployment, and support. A user is a stakeholder who operates the system or directly interacts with it. A supplier is a stakeholder who oversees the development, support, and maintenance of the system or product. A function of an artificial system is its top-level value-providing process, as perceived by the beneficiary. Structure of a system is its form—the assembly of its physical and informatical components along with the long-lasting relations among them. Behavior of a system is it dynamics—the way the system changes over time by transforming systemic (internal) and/or environmental (external) objects. Architecture of a system is the combination of the system’s structure and behavior which enables it to perform its function. The system’s environment is a collection of objects that are outside the system but interact with it, causing the system and possibly its environment to change. The function-behavior distinction : Behavior is how the system changes along the time dimension, while function is what value the system delivers to its beneficiary through its operation. A language is a means of communication among humans, and possibly also machines, to express concepts, ideas, processes, and methods. Syntax is the language’s set of symbols and rules that specify how the symbols can be combined to yield syntactically-legal constructs. Semantics is the meaning that a subset of the language’s syntactically-legal constructs conveys. A model is an abstraction of some portion of conceived reality or of a contemplated system expressed in some language. A modeling language is a language for constructing models in some domain. A formal modeling language is a modeling language that has a mathematically-grounded syntax definition, enabling its automated analysis, checking, and synthesis. A formal model is a model expressed in a formal modeling language. A conceptual model is a formal model of a system which expresses its architecture by depicting its structure and behavior to a level of detail that is sufficient for its subsequent detailed design and eventual materialization. A conceptual modeling language is a formal modeling language for constructing conceptual models of systems.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 161-163). Springer New York. Kindle Edition.  "
      },
      "date": 1647027657449
    },
    {
      "type": "edit",
      "id": "9864c74d640d2ea0",
      "item": {
        "type": "markdown",
        "id": "9864c74d640d2ea0",
        "text": " \n5.7 Summary \n* **In-zooming** is a refinement mechanism that helps manage system complexity . \n* Zooming into a process creates a new OPD with an inflated **in-zoomed process**. \n* Lower-level processes (subprocesses) are **nested** within this in-zoomed process and they can be **linked to lower-level objects** inside or outside the in-zoomed process. \n* Recursive in-zooming results in an **OPD set** that has a **tree structure**, in which lower-level OPDs model **increasingly refined details** about the system. \n* The **model fact** representation OPM principle stipulates that in order for an OPM model fact to be represented, it needs to **appear in at least one OPD** in order for it to be represented in the model. \n* Using this principle helps **decrease diagram clutter**, making each diagram **simple enough to be grasped** without cognitive overload.\n\n"
      },
      "date": 1647449076854
    },
    {
      "type": "edit",
      "id": "f74fb3be2fa9a0f3",
      "item": {
        "type": "markdown",
        "id": "f74fb3be2fa9a0f3",
        "text": "7.10 Summary \n* A **Boolean object** has **two states** and is used for modeling **flow of control**. \n* A **condition link** has a control modifier c added to a procedural link, augmenting its semantics with skip meaning. \n* **Generalization-specialization** is a fundamental structural relation that induces inheritance of features (attributes and operations), links, and states from the general thing to the specialized thing. \n* **Participation constraints** enable specifying how many objects of the same class participate in a relation. \n* **OR** is a relaxed version of the XOR logical operator that allows any subset of participating links to be active at once, rather than exactly one of them, as **XOR** does. \n* **Objects within an in-zoomed process** are recognized only in the scope of that process. If they are used in places outside that scope they must be placed outside the in-zoomed process.\n\n\n"
      },
      "date": 1647449376945
    },
    {
      "type": "edit",
      "id": "1fa3de92363f095d",
      "item": {
        "type": "markdown",
        "id": "1fa3de92363f095d",
        "text": "9.6 Summary \n* Science can be thought of as reverse engineering of nature. \n* The Minimal Ontology principle states that if a system can be specified at the same level of accuracy and detail by two languages of different ontology sizes, then the language with the smaller size is preferred over the one with the larger size. \n* Objects exist, processes happen. Ontology is a set of concepts and their relations in some domain of discourse. A minimal universal ontology is the ontology that is necessary and sufficient to model the universe and systems in it. The Object-Process Theorem : Stateful objects, processes, and relations among them constitute a minimal universal ontology. The Object-Process Assertion : Using stateful objects, processes, and relations among them, along with refinement mechanisms of in-zooming and unfolding, one can conceptually model systems in any domain and at any level of complexity. The thing importance OPM principle : The importance of a thing T in an OPM model is directly related to the highest OPD in the OPD hierarchy where T appears. An object is a thing that exists or can exist physically or informatically. A state is a possible situation or position at which an object can be for some positive amount of time. Transformation of an object is (1) creation (generation, construction), (2) consumption (elimination, destruction), or (3) effect—change in the state of that object. A process is a thing that transforms an object. The object transformation by process OPM principle : In a complete OPM model, each process must be connected to at least one object that the process transforms or one state of the object that the process transforms. A system is a function-providing object.\n\nA stakeholder is an individual, an organization, or a group of people that has an interest in, or might be affected by, a system being contemplated, developed, or deployed. A beneficiary is a stakeholder who extracts value and benefits from the system. A customer is the stakeholder who orders the system and sponsors its development, implementation, deployment, and support. A user is a stakeholder who operates the system or directly interacts with it. A supplier is a stakeholder who oversees the development, support, and maintenance of the system or product. A function of an artificial system is its top-level value-providing process, as perceived by the beneficiary. Structure of a system is its form—the assembly of its physical and informatical components along with the long-lasting relations among them. Behavior of a system is it dynamics—the way the system changes over time by transforming systemic (internal) and/or environmental (external) objects. Architecture of a system is the combination of the system’s structure and behavior which enables it to perform its function. The system’s environment is a collection of objects that are outside the system but interact with it, causing the system and possibly its environment to change. The function-behavior distinction : Behavior is how the system changes along the time dimension, while function is what value the system delivers to its beneficiary through its operation. A language is a means of communication among humans, and possibly also machines, to express concepts, ideas, processes, and methods. Syntax is the language’s set of symbols and rules that specify how the symbols can be combined to yield syntactically-legal constructs. Semantics is the meaning that a subset of the language’s syntactically-legal constructs conveys. A model is an abstraction of some portion of conceived reality or of a contemplated system expressed in some language. A modeling language is a language for constructing models in some domain. A formal modeling language is a modeling language that has a mathematically-grounded syntax definition, enabling its automated analysis, checking, and synthesis. A formal model is a model expressed in a formal modeling language. A conceptual model is a formal model of a system which expresses its architecture by depicting its structure and behavior to a level of detail that is sufficient for its subsequent detailed design and eventual materialization. A conceptual modeling language is a formal modeling language for constructing conceptual models of systems.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 161-163). Springer New York. Kindle Edition.  "
      },
      "date": 1647449482771
    },
    {
      "type": "edit",
      "id": "1fa3de92363f095d",
      "item": {
        "type": "markdown",
        "id": "1fa3de92363f095d",
        "text": "9.6 Summary \n* Science can be thought of as reverse engineering of nature. \n* The Minimal Ontology principle states that if a system can be specified at the same level of accuracy and detail by two languages of different ontology sizes, then the language with the smaller size is preferred over the one with the larger size. \n* Objects exist, processes happen. \n* Ontology is a set of concepts and their relations in some domain of discourse. \n* A minimal universal ontology is the ontology that is necessary and sufficient to model the universe and systems in it. \n* The Object-Process Theorem : Stateful objects, processes, and relations among them constitute a minimal universal ontology. \nThe Object-Process Assertion : Using stateful objects, processes, and relations among them, along with refinement mechanisms of in-zooming and unfolding, one can conceptually model systems in any domain and at any level of complexity. The thing importance OPM principle : The importance of a thing T in an OPM model is directly related to the highest OPD in the OPD hierarchy where T appears. An object is a thing that exists or can exist physically or informatically. A state is a possible situation or position at which an object can be for some positive amount of time. Transformation of an object is (1) creation (generation, construction), (2) consumption (elimination, destruction), or (3) effect—change in the state of that object. A process is a thing that transforms an object. The object transformation by process OPM principle : In a complete OPM model, each process must be connected to at least one object that the process transforms or one state of the object that the process transforms. A system is a function-providing object.\n\nA stakeholder is an individual, an organization, or a group of people that has an interest in, or might be affected by, a system being contemplated, developed, or deployed. A beneficiary is a stakeholder who extracts value and benefits from the system. A customer is the stakeholder who orders the system and sponsors its development, implementation, deployment, and support. A user is a stakeholder who operates the system or directly interacts with it. A supplier is a stakeholder who oversees the development, support, and maintenance of the system or product. A function of an artificial system is its top-level value-providing process, as perceived by the beneficiary. Structure of a system is its form—the assembly of its physical and informatical components along with the long-lasting relations among them. Behavior of a system is it dynamics—the way the system changes over time by transforming systemic (internal) and/or environmental (external) objects. Architecture of a system is the combination of the system’s structure and behavior which enables it to perform its function. The system’s environment is a collection of objects that are outside the system but interact with it, causing the system and possibly its environment to change. The function-behavior distinction : Behavior is how the system changes along the time dimension, while function is what value the system delivers to its beneficiary through its operation. A language is a means of communication among humans, and possibly also machines, to express concepts, ideas, processes, and methods. Syntax is the language’s set of symbols and rules that specify how the symbols can be combined to yield syntactically-legal constructs. Semantics is the meaning that a subset of the language’s syntactically-legal constructs conveys. A model is an abstraction of some portion of conceived reality or of a contemplated system expressed in some language. A modeling language is a language for constructing models in some domain. A formal modeling language is a modeling language that has a mathematically-grounded syntax definition, enabling its automated analysis, checking, and synthesis. A formal model is a model expressed in a formal modeling language. A conceptual model is a formal model of a system which expresses its architecture by depicting its structure and behavior to a level of detail that is sufficient for its subsequent detailed design and eventual materialization. A conceptual modeling language is a formal modeling language for constructing conceptual models of systems.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 161-163). Springer New York. Kindle Edition.  "
      },
      "date": 1647463370891
    },
    {
      "type": "edit",
      "id": "1fa3de92363f095d",
      "item": {
        "type": "markdown",
        "id": "1fa3de92363f095d",
        "text": "9.6 Summary \n* Science can be thought of as reverse engineering of nature. \n* The Minimal Ontology principle states that if a system can be specified at the same level of accuracy and detail by two languages of different ontology sizes, then the language with the smaller size is preferred over the one with the larger size. \n* Objects exist, processes happen. \n* Ontology is a set of concepts and their relations in some domain of discourse. \n* A minimal universal ontology is the ontology that is necessary and sufficient to model the universe and systems in it. \n* The Object-Process Theorem : Stateful objects, processes, and relations among them constitute a minimal universal ontology. \n* The Object-Process Assertion : Using stateful objects, processes, and relations among them, along with refinement mechanisms of in-zooming and unfolding, one can conceptually model systems in any domain and at any level of complexity. \n* The thing importance OPM principle : The importance of a thing T in an OPM model is directly related to the highest OPD in the OPD hierarchy where T appears. \n* An object is a thing that exists or can exist physically or informatically. \n* A state is a possible situation or position at which an object can be for some positive amount of time. \n* Transformation of an object is (1) creation (generation, construction), (2) consumption (elimination, destruction), or (3) effect—change in the state of that object. \n* A process is a thing that transforms an object. \n* The object transformation by process OPM principle : In a complete OPM model, each process must be connected to at least one object that the process transforms or one state of the object that the process transforms. \n* A system is a function-providing object.\n* A stakeholder is an individual, an organization, or a group of people that has an interest in, or might be affected by, a system being contemplated, developed, or deployed. \n* A beneficiary is a stakeholder who extracts value and benefits from the system. \n* A customer is the stakeholder who orders the system and sponsors its development, implementation, deployment, and support. \n* A user is a stakeholder who operates the system or directly interacts with it. \n* A supplier is a stakeholder who oversees the development, support, and maintenance of the system or product. \n* A function of an artificial system is its top-level value-providing process, as perceived by the beneficiary. \n* Structure of a system is its form—the assembly of its physical and informatical components along with the long-lasting relations among them. \n* Behavior of a system is it dynamics—the way the system changes over time by transforming systemic (internal) and/or environmental (external) objects. \n* Architecture of a system is the combination of the system’s structure and behavior which enables it to perform its function. \n* The system’s environment is a collection of objects that are outside the system but interact with it, causing the system and possibly its environment to change. \n* The function-behavior distinction : Behavior is how the system changes along the time dimension, while function is what value the system delivers to its beneficiary through its operation. \n* A language is a means of communication among humans, and possibly also machines, to express concepts, ideas, processes, and methods. \n* Syntax is the language’s set of symbols and rules that specify how the symbols can be combined to yield syntactically-legal constructs. \n* Semantics is the meaning that a subset of the language’s syntactically-legal constructs conveys. \n* A model is an abstraction of some portion of conceived reality or of a contemplated system expressed in some language. \n* A modeling language is a language for constructing models in some domain. \n* A formal modeling language is a modeling language that has a mathematically-grounded syntax definition, enabling its automated analysis, checking, and synthesis. A formal model is a model expressed in a formal modeling language. A conceptual model is a formal model of a system which expresses its architecture by depicting its structure and behavior to a level of detail that is sufficient for its subsequent detailed design and eventual materialization. A conceptual modeling language is a formal modeling language for constructing conceptual models of systems.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 161-163). Springer New York. Kindle Edition.  "
      },
      "date": 1647463614870
    },
    {
      "type": "edit",
      "id": "1fa3de92363f095d",
      "item": {
        "type": "markdown",
        "id": "1fa3de92363f095d",
        "text": "9.6 Summary \n* Science can be thought of as reverse engineering of nature. \n* The Minimal Ontology principle states that if a system can be specified at the same level of accuracy and detail by two languages of different ontology sizes, then the language with the smaller size is preferred over the one with the larger size. \n* Objects exist, processes happen. \n* Ontology is a set of concepts and their relations in some domain of discourse. \n* A minimal universal ontology is the ontology that is necessary and sufficient to model the universe and systems in it. \n* The Object-Process Theorem : Stateful objects, processes, and relations among them constitute a minimal universal ontology. \n* The Object-Process Assertion : Using stateful objects, processes, and relations among them, along with refinement mechanisms of in-zooming and unfolding, one can conceptually model systems in any domain and at any level of complexity. \n* The thing importance OPM principle : The importance of a thing T in an OPM model is directly related to the highest OPD in the OPD hierarchy where T appears. \n* An object is a thing that exists or can exist physically or informatically. \n* A state is a possible situation or position at which an object can be for some positive amount of time. \n* Transformation of an object is (1) creation (generation, construction), (2) consumption (elimination, destruction), or (3) effect—change in the state of that object. \n* A process is a thing that transforms an object. \n* The object transformation by process OPM principle : In a complete OPM model, each process must be connected to at least one object that the process transforms or one state of the object that the process transforms. \n* A system is a function-providing object.\n* A stakeholder is an individual, an organization, or a group of people that has an interest in, or might be affected by, a system being contemplated, developed, or deployed. \n* A beneficiary is a stakeholder who extracts value and benefits from the system. \n* A customer is the stakeholder who orders the system and sponsors its development, implementation, deployment, and support. \n* A user is a stakeholder who operates the system or directly interacts with it. \n* A supplier is a stakeholder who oversees the development, support, and maintenance of the system or product. \n* A function of an artificial system is its top-level value-providing process, as perceived by the beneficiary. \n* Structure of a system is its form—the assembly of its physical and informatical components along with the long-lasting relations among them. \n* Behavior of a system is it dynamics—the way the system changes over time by transforming systemic (internal) and/or environmental (external) objects. \n* Architecture of a system is the combination of the system’s structure and behavior which enables it to perform its function. \n* The system’s environment is a collection of objects that are outside the system but interact with it, causing the system and possibly its environment to change. \n* The function-behavior distinction : Behavior is how the system changes along the time dimension, while function is what value the system delivers to its beneficiary through its operation. \n* A language is a means of communication among humans, and possibly also machines, to express concepts, ideas, processes, and methods. \n* Syntax is the language’s set of symbols and rules that specify how the symbols can be combined to yield syntactically-legal constructs. \n* Semantics is the meaning that a subset of the language’s syntactically-legal constructs conveys. \n* A model is an abstraction of some portion of conceived reality or of a contemplated system expressed in some language. \n* A modeling language is a language for constructing models in some domain. \n* A formal modeling language is a modeling language that has a mathematically-grounded syntax definition, enabling its automated analysis, checking, and synthesis. \n* A formal model is a model expressed in a formal modeling language. \n* A conceptual model is a formal model of a system which expresses its architecture by depicting its structure and behavior to a level of detail that is sufficient for its subsequent detailed design and eventual materialization. \n* A conceptual modeling language is a formal modeling language for constructing conceptual models of systems.\n\n"
      },
      "date": 1647463762681
    },
    {
      "item": {
        "type": "factory",
        "id": "1b4d6402c054250e"
      },
      "id": "1b4d6402c054250e",
      "type": "add",
      "after": "0ace4206e44db47f",
      "date": 1647709544712
    },
    {
      "type": "edit",
      "id": "1b4d6402c054250e",
      "item": {
        "type": "pagefold",
        "id": "1b4d6402c054250e",
        "text": "."
      },
      "date": 1647709549175
    },
    {
      "id": "1b4d6402c054250e",
      "type": "move",
      "order": [
        "d77a8f6af23b6fc0",
        "8cfda0d5582d1f60",
        "c89ffadc634401e8",
        "3d02e6069fa83202",
        "9864c74d640d2ea0",
        "c92bc0d23c982368",
        "f74fb3be2fa9a0f3",
        "8544700eb5738841",
        "bd0ffa708c262c6c",
        "1fa3de92363f095d",
        "971b73cd74d0962d",
        "1b4d6402c054250e",
        "20f5618e5e924f24",
        "0ace4206e44db47f"
      ],
      "date": 1647709556231
    },
    {
      "id": "1b4d6402c054250e",
      "type": "move",
      "order": [
        "d77a8f6af23b6fc0",
        "8cfda0d5582d1f60",
        "c89ffadc634401e8",
        "3d02e6069fa83202",
        "9864c74d640d2ea0",
        "c92bc0d23c982368",
        "f74fb3be2fa9a0f3",
        "8544700eb5738841",
        "bd0ffa708c262c6c",
        "1fa3de92363f095d",
        "1b4d6402c054250e",
        "971b73cd74d0962d",
        "20f5618e5e924f24",
        "0ace4206e44db47f"
      ],
      "date": 1647709562347
    },
    {
      "type": "edit",
      "id": "1fa3de92363f095d",
      "item": {
        "type": "markdown",
        "id": "1fa3de92363f095d",
        "text": "9.6 Summary \n* **Science** can be thought of as reverse engineering of nature. \n* The **Minimal Ontology principle** states that if a system can be specified at the same level of accuracy and detail by two languages of different ontology sizes, then the language with the smaller size is preferred over the one with the larger size. \n* **Objects** exist, **processes** happen. \n* **Ontology** is a set of concepts and their relations in some domain of discourse. \n* A minimal **universal ontology** is the ontology that is necessary and sufficient to model the universe and systems in it. \n* The **Object-Process Theorem** : Stateful objects, processes, and relations among them constitute a minimal universal ontology. \n* The **Object-Process Assertion**: Using stateful objects, processes, and relations among them, along with refinement mechanisms of in-zooming and unfolding, one can conceptually model systems in any domain and at any level of complexity. \n* The **thing importance OPM principle** : The importance of a thing T in an OPM model is directly related to the highest OPD in the OPD hierarchy where T appears. \n* An **object** is a thing that exists or can exist physically or informatically. \n* A **state** is a possible situation or position at which an object can be for some positive amount of time. \n* **Transformation of an object** is (1) creation (generation, construction), (2) consumption (elimination, destruction), or (3) effect—change in the state of that object. \n* A **process** is a thing that transforms an object. \n* The **object transformation by process OPM principle** : In a complete OPM model, each process must be connected to at least one object that the process transforms or one state of the object that the process transforms. \n* A system is a function-providing object.\n* A stakeholder is an individual, an organization, or a group of people that has an interest in, or might be affected by, a system being contemplated, developed, or deployed. \n* A beneficiary is a stakeholder who extracts value and benefits from the system. \n* A customer is the stakeholder who orders the system and sponsors its development, implementation, deployment, and support. \n* A user is a stakeholder who operates the system or directly interacts with it. \n* A supplier is a stakeholder who oversees the development, support, and maintenance of the system or product. \n* A function of an artificial system is its top-level value-providing process, as perceived by the beneficiary. \n* Structure of a system is its form—the assembly of its physical and informatical components along with the long-lasting relations among them. \n* Behavior of a system is it dynamics—the way the system changes over time by transforming systemic (internal) and/or environmental (external) objects. \n* Architecture of a system is the combination of the system’s structure and behavior which enables it to perform its function. \n* The system’s environment is a collection of objects that are outside the system but interact with it, causing the system and possibly its environment to change. \n* The function-behavior distinction : Behavior is how the system changes along the time dimension, while function is what value the system delivers to its beneficiary through its operation. \n* A language is a means of communication among humans, and possibly also machines, to express concepts, ideas, processes, and methods. \n* Syntax is the language’s set of symbols and rules that specify how the symbols can be combined to yield syntactically-legal constructs. \n* Semantics is the meaning that a subset of the language’s syntactically-legal constructs conveys. \n* A model is an abstraction of some portion of conceived reality or of a contemplated system expressed in some language. \n* A modeling language is a language for constructing models in some domain. \n* A formal modeling language is a modeling language that has a mathematically-grounded syntax definition, enabling its automated analysis, checking, and synthesis. \n* A formal model is a model expressed in a formal modeling language. \n* A conceptual model is a formal model of a system which expresses its architecture by depicting its structure and behavior to a level of detail that is sufficient for its subsequent detailed design and eventual materialization. \n* A conceptual modeling language is a formal modeling language for constructing conceptual models of systems.\n\n"
      },
      "date": 1647709885486
    },
    {
      "type": "edit",
      "id": "1fa3de92363f095d",
      "item": {
        "type": "markdown",
        "id": "1fa3de92363f095d",
        "text": "9.6 Summary \n* **Science** can be thought of as reverse engineering of nature. \n* The **Minimal Ontology principle** states that if a system can be specified at the same level of accuracy and detail by two languages of different ontology sizes, then the language with the smaller size is preferred over the one with the larger size. \n* **Objects** exist, **processes** happen. \n* **Ontology** is a set of concepts and their relations in some domain of discourse. \n* A minimal **universal ontology** is the ontology that is necessary and sufficient to model the universe and systems in it. \n* The **Object-Process Theorem** : Stateful objects, processes, and relations among them constitute a minimal universal ontology. \n* The **Object-Process Assertion**: Using stateful objects, processes, and relations among them, along with refinement mechanisms of in-zooming and unfolding, one can conceptually model systems in any domain and at any level of complexity. \n* The **thing importance OPM principle** : The importance of a thing T in an OPM model is directly related to the highest OPD in the OPD hierarchy where T appears. \n* An **object** is a thing that exists or can exist physically or informatically. \n* A **state** is a possible situation or position at which an object can be for some positive amount of time. \n* **Transformation of an object** is (1) creation (generation, construction), (2) consumption (elimination, destruction), or (3) effect—change in the state of that object. \n* A **process** is a thing that transforms an object. \n* The **object transformation by process OPM principle** : In a complete OPM model, each process must be connected to at least one object that the process transforms or one state of the object that the process transforms. \n* A **system** is a function-providing object.\n> Very odd that he uses the term object for a system which must include Processes and Relationships. He must mean \"object\" in a different sense than in OPM.\n* A **stakeholder** is an individual, an organization, or a group of people that has an interest in, or might be affected by, a system being contemplated, developed, or deployed. \n* A **beneficiary** is a stakeholder who extracts value and benefits from the system. \n* A **customer** is the stakeholder who orders the system and sponsors its development, implementation, deployment, and support. \n* A **user** is a stakeholder who operates the system or directly interacts with it. \n* A **supplier** is a stakeholder who oversees the development, support, and maintenance of the system or product. \n* A **function** of an artificial system is its top-level value-providing process, as perceived by the beneficiary. \n* **Structure** of a system is its form—the assembly of its physical and informatical components along with the long-lasting relations among them. \n* **Behavior** of a system is it dynamics—the way the system changes over time by transforming systemic (internal) and/or environmental (external) objects. \n* **Architecture** of a system is the combination of the system’s structure and behavior which enables it to perform its function. \n* The system’s **environment** is a collection of objects that are outside the system but interact with it, causing the system and possibly its environment to change. \n* The **function-behavior distinction** : Behavior is how the system changes along the time dimension, while function is what value the system delivers to its beneficiary through its operation. \n* A **language** is a means of communication among humans, and possibly also machines, to express concepts, ideas, processes, and methods. \n* **Syntax** is the language’s set of symbols and rules that specify how the symbols can be combined to yield syntactically-legal constructs. \n* **Semantics** is the meaning that a subset of the language’s syntactically-legal constructs conveys. \n* A **model** is an abstraction of some portion of conceived reality or of a contemplated system expressed in some language. \n* A **modeling language** is a language for constructing models in some domain. \n* A **formal modeling language** is a modeling language that has a mathematically-grounded syntax definition, enabling its automated analysis, checking, and synthesis. \n* A **formal model** is a model expressed in a formal modeling language. \n* A **conceptual model** is a formal model of a system which expresses its architecture by depicting its structure and behavior to a level of detail that is sufficient for its subsequent detailed design and eventual materialization. \n* A **conceptual modeling language** is a formal modeling language for constructing conceptual models of systems.\n"
      },
      "date": 1647710460054
    },
    {
      "type": "add",
      "id": "48fa037ae9c377d7",
      "item": {
        "type": "markdown",
        "id": "48fa037ae9c377d7",
        "text": "...\n"
      },
      "after": "1fa3de92363f095d",
      "date": 1647710463798
    },
    {
      "type": "edit",
      "id": "48fa037ae9c377d7",
      "item": {
        "type": "markdown",
        "id": "48fa037ae9c377d7",
        "text": "10.12 Summary \n"
      },
      "date": 1647710570216
    },
    {
      "type": "edit",
      "id": "48fa037ae9c377d7",
      "item": {
        "type": "markdown",
        "id": "48fa037ae9c377d7",
        "text": "10.12 Summary \n\n* A **property** is a metamodel attribute of an OPM element. \n* A **property value** of each element in an OPM model remains fixed. \n* The OPM approach considers **processes as \"first class citizens\"** alongside objects rather than below object. \n* An **object** is a thing that exists or has the potential of physical or informatical existence. \n* Two instances of a physical object are identical if and only if they occupy the same space at the same time. \n* From an informatical viewpoint, all the physical copies of some informatical object are the same . \n"
      },
      "date": 1647710669328
    },
    {
      "type": "edit",
      "id": "48fa037ae9c377d7",
      "item": {
        "type": "markdown",
        "id": "48fa037ae9c377d7",
        "text": "10.12 Summary \n\n* A **property** is a metamodel attribute of an OPM element. \n* A **property value** of each element in an OPM model remains fixed. \n* The OPM approach considers **processes as \"first class citizens\"** alongside objects rather than below object. \n* An **object** is a thing that exists or has the potential of physical or informatical existence. \n* Two instances of a physical object are identical if and only if they occupy the same space at the same time. \n* From an informatical viewpoint, all the physical copies of some informatical object are the same . \n* **Transformation** is generation (construction, creation) or consumption (destruction, elimination) or change (effect, state transition), of an object. \n* A **process** is a mental construct representing a pattern of object transformation. \n* In “cause and effect” analysis, **cause** is a triggering event that attempts to cause a process to start executing. \n* The **effect** in “cause and effect” analysis is the transformation that one or more of the objects linked to the executing process undergo. \n* **Parts of speech** (noun, verb, adjective, adverb …) are syntactic constructs, while **OPM things** (object and process) are semantic constructs. \n* The **preprocess object set** of a process P, Pre(P), is the set of objects required to exist, possibly in certain states, in order for P to start executing once it was triggered. \n* The **postprocess object set** of process P, Post(P), is the set of one or more objects that exist, possibly in certain states, after P finished executing. \n* The **involved object set** of process P, Inv(P), is the union of P’s preprocess object set and postprocess object set: Inv(P) = Pre(P) ∪ Post(P). \n* The **object-process distinction problem** is the problem of telling whether a given a noun is an object or a process. \n* The **process test** is a formal procedure for solving the object-process distinction problem. The process test assumes that by default, a noun is an object, so to be a process it must meet three criteria : (1) object transformation, (2) time association , and (3) verb association.  \n* The **object transformation criterion** is satisfied if the noun in question transforms at least one of the objects in the involved object set. \n* The **time association criterion** is satisfied if the noun in question can be thought of as happening through time. \n* The **verb association criterion** is satisfied if the noun in question can be derived from, or has a common root with a verb or has a synonym which is a verb. \n* The **capitalization OPM convention** is that the first letter in each word of the name of a thing is capitalized, while states are lower-case. \n* The **singular name OPM principle** specifies that a name of an OPM thing must be singular. \n* The OPM **process naming convention** is to name a process by making its last word a gerund whenever this is possible and is acceptable and makes sense in the domain nomenclature . \n* **Thing** is a generalization of object and process. \n* A **state-preserving process** is a process that maintains a steady state of status quo, and can be suppressed by replacing it with a **tagged structural relation**. \n* A **transient object** is a short-lived object, and can be suppressed by replacing it with an **invocation link**.\n\n"
      },
      "date": 1647711152338
    },
    {
      "type": "add",
      "id": "e138f9711d9b69a1",
      "item": {
        "type": "markdown",
        "id": "e138f9711d9b69a1",
        "text": "..."
      },
      "after": "48fa037ae9c377d7",
      "date": 1647711163798
    },
    {
      "type": "edit",
      "id": "e138f9711d9b69a1",
      "item": {
        "type": "markdown",
        "id": "e138f9711d9b69a1",
        "text": "11.8 Summary \n"
      },
      "date": 1647711248629
    },
    {
      "type": "edit",
      "id": "e138f9711d9b69a1",
      "item": {
        "type": "markdown",
        "id": "e138f9711d9b69a1",
        "text": "11.8 Summary \n\n* **Object-Process Language (OPL)** is a subset of English that expresses textually the OPM model that the OPD set expresses graphically. \n* The **formal syntax for OPL* is expressed by a context-free grammar in Extended Backus-Naur Form (EBNF) in Annex A of ISO 19450 Publicly Available Specification (PAS). \n* A **model fact** is a relation between two or more things in an OPM model. \n* An **OPD element** is the graphical expression of a thing or a link. \n* An **OPD construct** is a collection of connected OPD elements. \n* OPL serves **two goals**, oriented to two directions: humans and machines. The **human-oriented OPL goal** is to convert the set of OPDs comprising the OPM model into a natural language text. The **machine-oriented OPL goal** is to provide a firm basis for automatically generating the infrastructure for the **application development**. \n* An **OPL paragraph** of an OPD is a collection of OPL sentences that express textually the same model facts that this OPD expresses graphically. \n* The **graphics-text equivalence OPM principle** : Any model fact expressed graphically in an OPD is also expressed textually in the corresponding OPL paragraph. \n* A **metamodel** is a model of a model. \n* The **metamodel of the structure** of an OPM system model shows two parallel hierarchies—the hierarchy of graphic objects and the corresponding hierarchy of text objects. \n* An **OPL specification** of an OPM model is the collection of OPL sentences that express textually all the model facts that the OPD set expresses graphically. \n* An **OPL phrase** is a sequence of one or more words. \n* A **non-reserved OPL phrase** is a modeler-defined OPL phrase that expresses a system- or domain-specific OPM model entity or relation name. \n* A **reserved OPL phrase** is an OPL phrase built into the **OPL EBNF syntax** definition that connects two or more non-reserved OPL phrases. \n* The **dual-channel assumption** is that humans possess separate systems for processing visual and verbal representations. \n* The **syntax and semantics** of OPL are defined as a subset of English , eliminating the ambiguity that is often inherent in natural languages. \n* **Tesperanto** is the next generation of OPL.\n\n"
      },
      "date": 1647711775248
    },
    {
      "type": "add",
      "id": "ef542e92a44f78c8",
      "item": {
        "type": "markdown",
        "id": "ef542e92a44f78c8",
        "text": "..."
      },
      "after": "e138f9711d9b69a1",
      "date": 1647711779740
    },
    {
      "type": "edit",
      "id": "ef542e92a44f78c8",
      "item": {
        "type": "markdown",
        "id": "ef542e92a44f78c8",
        "text": "12.11 Summary\n"
      },
      "date": 1647711835729
    },
    {
      "type": "edit",
      "id": "ef542e92a44f78c8",
      "item": {
        "type": "markdown",
        "id": "ef542e92a44f78c8",
        "text": "12.11 Summary\n\n* **Activity diagrams** are illustrations of workflows, which describe the flow among actions and are closest in semantics to OPDs. \n* An **action** is a basic unit in an activity diagram, but by using the rake symbol it can be elaborated into an entire activity diagram in its sown right, providing for a refinement mechanism similar to OPM in-zooming. \n* *Flows** in activity diagrams can be of two kinds: control flow and object flow. \n* **Accept, send, and time event action** nodes have special syntax and semantics. \n* **Join and fork** node s are used for synchronizing actions. \n* **Arrows** between an activity and an object in an activity diagram have flow semantics , while in OPM they have transformation semantics —creation, consumption, or state change. \n* **Flow of control** in activity diagrams is achieved through decision nodes, which are diamond-shaped nodes to which a decision input note s are often attached. \n* In **OPM, flow of control** is based in part on Boolean objects. \n* **Requirements diagrams** bridge typical requirements management tools and the system model. \n* **Parametric diagrams** use constraint property block s to bind system parameters to each other via mathematical expressions. \n* In OPM this can be done by expressing the mathematical formula as a **computation process**. \n* **Requirements and parametric diagrams** (like all the other SysML diagram kinds) can be modeled in OPM without special symbols.\n\n"
      },
      "date": 1647712079071
    },
    {
      "type": "add",
      "id": "62b44570fdfc68e4",
      "item": {
        "type": "markdown",
        "id": "62b44570fdfc68e4",
        "text": "..."
      },
      "after": "ef542e92a44f78c8",
      "date": 1647712086829
    },
    {
      "type": "edit",
      "id": "62b44570fdfc68e4",
      "item": {
        "type": "markdown",
        "id": "62b44570fdfc68e4",
        "text": "13.11 Summary \n"
      },
      "date": 1647712136521
    },
    {
      "type": "edit",
      "id": "62b44570fdfc68e4",
      "item": {
        "type": "markdown",
        "id": "62b44570fdfc68e4",
        "text": "13.11 Summary \n\nA change of an object is an alteration in the state of that object. Effect is a change in the state of an object that a process causes. Construction is an extreme case of object effect, where the object’s input state is nonexistent and the output state is existent.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (p. 288). Springer New York. Kindle Edition. "
      },
      "date": 1647712140872
    },
    {
      "type": "edit",
      "id": "62b44570fdfc68e4",
      "item": {
        "type": "markdown",
        "id": "62b44570fdfc68e4",
        "text": "13.11 Summary \n\n* A **change of an object** is an alteration in the state of that object. \n* **Effect** is a change in the state of an object that a process causes. \n* **Construction** is an extreme case of object effect, where the object’s input state is nonexistent and the output state is existent.\n* **Consumption** is an extreme case of object effect, where the object’s input state is existent and the output state is nonexistent. \nWhen the transformation is extreme, a change in object identity takes place. When the change is not profound or drastic, the object only alters its state while retaining its identity . A transformee of process P is an object B that P transforms as a result of the occurrence of P.  A consumee of a process P is a transformee of P that P consumes as a result of the occurrence of P. A resultee of a process P is a transformee of P that P creates as a result of the occurrence of P. An affectee of a process P is a transformee of P that that P affects as a result of the occurrence of P. A transforming link is a procedural link that connects a process with a transformee of that process.  A result link is a unidirectional transformation link from a process to the resultee that this process creates. An effect link is a bidirectional transformation link that connects a process with an affectee of that process. A consumption link is a unidirectional transformation link from a consumee to the process that consumes it. An enabler E of a process P is an object that must exist and be available in order for P to start, and remain present throughout the occurrence of P in order for P to terminate normally, with E ultimately unaffected.  An agent is an enabler who is a human or a group of humans. An instrument is a non-human enabler. An enabling link is a procedural link that connects a process with an enabler of that process.  An agent link is an enabling link that connects a process with an agent of that process. An instrument link is a procedural link that connects a process with an enabler of that process. An input state of object B is a state s i of B at which B is when process P starts. An input link is a link from the state s i to process P. An output state of object B is a state s o of B at which B is when process P ends. An output link is a link from process P to the state s o . A state-specified consumption link is a consumption link that originates from an input state s i of the consumee C and ends at process P, denoting that in order for C to be consumed by P, it must be in state s i . A state-specified result link is a result link that originates from process P and ends at a state s of the resultee R, denoting that when P terminates, it creates R in state s. A state-specified effect link is an in-out (input–output) link pair, whose input link originates from an input state s i of the affectee A and ends at process P, and whose output link originates from P and ends at an output state s o of A, denoting that in order for A to be affected by P, A must be in s i , in which case when P terminates A will be at s o .  An in-out-specified effect link pair of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to the output state s out of B. An input-specified effect link pair of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to B. An output-specified effect link pair of process P is a pair of links consisting of an input link from object B to P and an output link from P to the output state s out of B. A value changing link is a link between a process and an unspecified value of an attribute which the process changes.\n\n...\n\n"
      },
      "date": 1647712288393
    },
    {
      "type": "edit",
      "id": "62b44570fdfc68e4",
      "item": {
        "type": "markdown",
        "id": "62b44570fdfc68e4",
        "text": "13.11 Summary \n\n* A **change of an object** is an alteration in the state of that object. \n* **Effect** is a change in the state of an object that a process causes. \n* **Construction** is an extreme case of object effect, where the object’s input state is nonexistent and the output state is existent.\n* **Consumption** is an extreme case of object effect, where the object’s input state is existent and the output state is nonexistent. \n* When the transformation is extreme, a change in object identity takes place. \n* When the change is not profound or drastic, the object only alters its state while retaining its identity . \n* A transformee of process P is an object B that P transforms as a result of the occurrence of P.  \n* A consumee of a process P is a transformee of P that P consumes as a result of the occurrence of P. \n* A resultee of a process P is a transformee of P that P creates as a result of the occurrence of P. \n* An affectee of a process P is a transformee of P that that P affects as a result of the occurrence of P. \n* A transforming link is a procedural link that connects a process with a transformee of that process.  \n* A result link is a unidirectional transformation link from a process to the resultee that this process creates. \n* An effect link is a bidirectional transformation link that connects a process with an affectee of that process. \n* A consumption link is a unidirectional transformation link from a consumee to the process that consumes it. \n* An enabler E of a process P is an object that must exist and be available in order for P to start, and remain present throughout the occurrence of P in order for P to terminate normally, with E ultimately unaffected.  \n* An agent is an enabler who is a human or a group of humans. An instrument is a non-human enabler. \n* An enabling link is a procedural link that connects a process with an enabler of that process.  \n* An agent link is an enabling link that connects a process with an agent of that process. \n* An instrument link is a procedural link that connects a process with an enabler of that process. An input state of object B is a state s i of B at which B is when process P starts. An input link is a link from the state s i to process P. An output state of object B is a state s o of B at which B is when process P ends. An output link is a link from process P to the state s o . A state-specified consumption link is a consumption link that originates from an input state s i of the consumee C and ends at process P, denoting that in order for C to be consumed by P, it must be in state s i . A state-specified result link is a result link that originates from process P and ends at a state s of the resultee R, denoting that when P terminates, it creates R in state s. A state-specified effect link is an in-out (input–output) link pair, whose input link originates from an input state s i of the affectee A and ends at process P, and whose output link originates from P and ends at an output state s o of A, denoting that in order for A to be affected by P, A must be in s i , in which case when P terminates A will be at s o .  An in-out-specified effect link pair of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to the output state s out of B. An input-specified effect link pair of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to B. An output-specified effect link pair of process P is a pair of links consisting of an input link from object B to P and an output link from P to the output state s out of B. A value changing link is a link between a process and an unspecified value of an attribute which the process changes.\n\n...\n\n"
      },
      "date": 1647723691635
    },
    {
      "type": "edit",
      "id": "62b44570fdfc68e4",
      "item": {
        "type": "markdown",
        "id": "62b44570fdfc68e4",
        "text": "13.11 Summary \n\n* A **change of an object** is an alteration in the state of that object. \n* **Effect** is a change in the state of an object that a process causes. \n* **Construction** is an extreme case of object effect, where the object’s input state is nonexistent and the output state is existent.\n* **Consumption** is an extreme case of object effect, where the object’s input state is existent and the output state is nonexistent. \n* When the transformation is extreme, a change in object identity takes place. \n* When the change is not profound or drastic, the object only alters its state while retaining its identity . \n* A transformee of process P is an object B that P transforms as a result of the occurrence of P.  \n* A consumee of a process P is a transformee of P that P consumes as a result of the occurrence of P. \n* A resultee of a process P is a transformee of P that P creates as a result of the occurrence of P. \n* An affectee of a process P is a transformee of P that that P affects as a result of the occurrence of P. \n* A transforming link is a procedural link that connects a process with a transformee of that process.  \n* A result link is a unidirectional transformation link from a process to the resultee that this process creates. \n* An effect link is a bidirectional transformation link that connects a process with an affectee of that process. \n* A consumption link is a unidirectional transformation link from a consumee to the process that consumes it. \n* An enabler E of a process P is an object that must exist and be available in order for P to start, and remain present throughout the occurrence of P in order for P to terminate normally, with E ultimately unaffected.  \n* An agent is an enabler who is a human or a group of humans. An instrument is a non-human enabler. \n* An enabling link is a procedural link that connects a process with an enabler of that process.  \n* An agent link is an enabling link that connects a process with an agent of that process. \n* An instrument link is a procedural link that connects a process with an enabler of that process. \n* An input state of object B is a state s i of B at which B is when process P starts. \n* An input link is a link from the state s i to process P. \n* An output state of object B is a state s o of B at which B is when process P ends. \n* An output link is a link from process P to the state s o . \n* A state-specified consumption link is a consumption link that originates from an input state s i of the consumee C and ends at process P, denoting that in order for C to be consumed by P, it must be in state s i . \n* A state-specified result link is a result link that originates from process P and ends at a state s of the resultee R, denoting that when P terminates, it creates R in state s. \n* A state-specified effect link is an in-out (input–output) link pair, whose input link originates from an input state s i of the affectee A and ends at process P, and whose output link originates from P and ends at an output state s o of A, denoting that in order for A to be affected by P, A must be in s i , in which case when P terminates A will be at s o .  \n* An in-out-specified effect link pair of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to the output state s out of B. \n* An input-specified effect link pair of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to B. \n* An output-specified effect link pair of process P is a pair of links consisting of an input link from object B to P and an output link from P to the output state s out of B. \n* A value changing link is a link between a process and an unspecified value of an attribute which the process changes.\n\n\n"
      },
      "date": 1647723858888
    },
    {
      "type": "edit",
      "id": "62b44570fdfc68e4",
      "item": {
        "type": "markdown",
        "id": "62b44570fdfc68e4",
        "text": "13.11 Summary \n\n* A **change of an object** is an alteration in the state of that object. \n* **Effect** is a change in the state of an object that a process causes. \n* **Construction** is an extreme case of object effect, where the object’s input state is nonexistent and the output state is existent.\n* **Consumption** is an extreme case of object effect, where the object’s input state is existent and the output state is nonexistent. \n* When the transformation is extreme, a change in object identity takes place. \n* When the change is not profound or drastic, the object only alters its state while retaining its identity . \n* A transformee of process P is an object B that P transforms as a result of the occurrence of P.  \n* A consumee of a process P is a transformee of P that P consumes as a result of the occurrence of P. \n* A resultee of a process P is a transformee of P that P creates as a result of the occurrence of P. \n* An affectee of a process P is a transformee of P that that P affects as a result of the occurrence of P. \n* A transforming link is a procedural link that connects a process with a transformee of that process.  \n* A result link is a unidirectional transformation link from a process to the resultee that this process creates. \n* An effect link is a bidirectional transformation link that connects a process with an affectee of that process. \n* A consumption link is a unidirectional transformation link from a consumee to the process that consumes it. \n* An enabler E of a process P is an object that must exist and be available in order for P to start, and remain present throughout the occurrence of P in order for P to terminate normally, with E ultimately unaffected.  \n* An agent is an enabler who is a human or a group of humans. An instrument is a non-human enabler. \n* An enabling link is a procedural link that connects a process with an enabler of that process.  \n* An agent link is an enabling link that connects a process with an agent of that process. \n* An instrument link is a procedural link that connects a process with an enabler of that process. \n* An input state of object B is a state s i of B at which B is when process P starts. \n* An input link is a link from the state s i to process P. \n* An output state of object B is a state s o of B at which B is when process P ends. \n* An output link is a link from process P to the state s o . \n* A state-specified consumption link is a consumption link that originates from an input state s i of the consumee C and ends at process P, denoting that in order for C to be consumed by P, it must be in state s i . \n* A state-specified result link is a result link that originates from process P and ends at a state s of the resultee R, denoting that when P terminates, it creates R in state s. \n* A state-specified effect link is an in-out (input–output) link pair, whose input link originates from an input state s i of the affectee A and ends at process P, and whose output link originates from P and ends at an output state s o of A, denoting that in order for A to be affected by P, A must be in s i , in which case when P terminates A will be at s o .  \n* An in-out-specified effect link pair of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to the output state s out of B. \n* An input-specified effect link pair of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to B. \n* An output-specified effect link pair of process P is a pair of links consisting of an input link from object B to P and an output link from P to the output state s out of B. \n* A value changing link is a link between a process and an unspecified value of an attribute which the process changes.\n\n\n\n"
      },
      "date": 1647729121310
    },
    {
      "type": "add",
      "id": "3672b9af7f3bdbe3",
      "item": {
        "type": "markdown",
        "id": "3672b9af7f3bdbe3",
        "text": "https://www.sustasis.org/about_us"
      },
      "after": "62b44570fdfc68e4",
      "date": 1647729131911
    },
    {
      "type": "edit",
      "id": "3672b9af7f3bdbe3",
      "item": {
        "type": "markdown",
        "id": "3672b9af7f3bdbe3",
        "text": "14.4 Summary A structural relation is a linkage, connection, or association between two objects or between two processes that holds in the system for at least some time. A binary structural relation is bidirectional. A structural link is an arrow with an open head that represents a binary structural relation in an OPD from a source object to a destination object. A structural tag is a phrase that expresses the semantics—the nature, meaning, or content—of the structural relation between the two things that participate in the relation. A tagged structural link is structural link with a structural tag recorded along the link. A bidirectional tagged structural link is a combination of two tagged structural links in opposite directions. Property is an attribute of an OPM model element. A reciprocal structural relation ℜ is a structural relation for which it holds that if A ℜ B and B ℜ′ A then ℜ = ℜ′. A reciprocal structural link is a bidirectional tagged structural link, in which the identical forward and backward tags are replaced by a single reciprocity tag. Reciprocity is a property of a structural relation that denotes whether its forward and backward structural relations have the same semantics. A transitive structural relation ℜ is a structural relation for which it holds that if A ℜ B and B ℜ C then A ℜ C. Transitivity is a property of a structural relation, which determines whether the structural relation is transitive. The values of both the reciprocity and the transitivity properties of a structural relation can be positive, neutral, or negative. The unidirectional default null tag is the default null tag for the unidirectional structural link, and its associated OPL reserved phrase is “relates to”. The bidirectional default null tag is the default null tag for the bidirectional structural link, and its associated OPL reserved phrase is “related”. A user-defined null tag is a tag defined by the system modeler that overrides the default null tags for a specific system model, an enterprise, or a domain. State-preserving processes convey a message of continuity, stability, detachment from time, or steady state.\n\n..."
      },
      "date": 1647729183142
    },
    {
      "type": "edit",
      "id": "3672b9af7f3bdbe3",
      "item": {
        "type": "markdown",
        "id": "3672b9af7f3bdbe3",
        "text": "14.4 Summary \n"
      },
      "date": 1647729197995
    },
    {
      "type": "edit",
      "id": "3672b9af7f3bdbe3",
      "item": {
        "type": "markdown",
        "id": "3672b9af7f3bdbe3",
        "text": "14.4 Summary \n\nA structural relation is a linkage, connection, or association between two objects or between two processes that holds in the system for at least some time. "
      },
      "date": 1647729205213
    },
    {
      "type": "add",
      "id": "18eb138f228194a7",
      "item": {
        "type": "markdown",
        "id": "18eb138f228194a7",
        "text": "* A binary structural relation is bidirectional. A structural link is an arrow with an open head that represents a binary structural relation in an OPD from a source object to a destination object. A structural tag is a phrase that expresses the semantics—the nature, meaning, or content—of the structural relation between the two things that participate in the relation. A tagged structural link is structural link with a structural tag recorded along the link. A bidirectional tagged structural link is a combination of two tagged structural links in opposite directions. Property is an attribute of an OPM model element. A reciprocal structural relation ℜ is a structural relation for which it holds that if A ℜ B and B ℜ′ A then ℜ = ℜ′. A reciprocal structural link is a bidirectional tagged structural link, in which the identical forward and backward tags are replaced by a single reciprocity tag. Reciprocity is a property of a structural relation that denotes whether its forward and backward structural relations have the same semantics. A transitive structural relation ℜ is a structural relation for which it holds that if A ℜ B and B ℜ C then A ℜ C. Transitivity is a property of a structural relation, which determines whether the structural relation is transitive. The values of both the reciprocity and the transitivity properties of a structural relation can be positive, neutral, or negative. The unidirectional default null tag is the default null tag for the unidirectional structural link, and its associated OPL reserved phrase is “relates to”. The bidirectional default null tag is the default null tag for the bidirectional structural link, and its associated OPL reserved phrase is “related”. A user-defined null tag is a tag defined by the system modeler that overrides the default null tags for a specific system model, an enterprise, or a domain. State-preserving processes convey a message of continuity, stability, detachment from time, or steady state.\n\n..."
      },
      "after": "3672b9af7f3bdbe3",
      "date": 1647729209505
    },
    {
      "type": "edit",
      "id": "3672b9af7f3bdbe3",
      "item": {
        "type": "markdown",
        "id": "3672b9af7f3bdbe3",
        "text": "14.4 Summary \n\n* A structural relation is a linkage, connection, or association between two objects or between two processes that holds in the system for at least some time. "
      },
      "date": 1647729213756
    },
    {
      "type": "remove",
      "id": "18eb138f228194a7",
      "date": 1647729217608
    },
    {
      "type": "edit",
      "id": "3672b9af7f3bdbe3",
      "item": {
        "type": "markdown",
        "id": "3672b9af7f3bdbe3",
        "text": "14.4 Summary \n\n* A structural relation is a linkage, connection, or association between two objects or between two processes that holds in the system for at least some time. \n* A binary structural relation is bidirectional. "
      },
      "date": 1647729231628
    },
    {
      "type": "edit",
      "id": "3672b9af7f3bdbe3",
      "item": {
        "type": "markdown",
        "id": "3672b9af7f3bdbe3",
        "text": "14.4 Summary \n\n* A structural relation is a linkage, connection, or association between two objects or between two processes that holds in the system for at least some time. \n* A binary structural relation is bidirectional. \n* A structural link is an arrow with an open head that represents a binary structural relation in an OPD from a source object to a destination object. \n* A structural tag is a phrase that expresses the semantics—the nature, meaning, or content—of the structural relation between the two things that participate in the relation. \n* A tagged structural link is structural link with a structural tag recorded along the link. \n* A bidirectional tagged structural link is a combination of two tagged structural links in opposite directions. \n* Property is an attribute of an OPM model element. \n* A reciprocal structural relation ℜ is a structural relation for which it holds that if A ℜ B and B ℜ′ A then ℜ = ℜ′. \n* A reciprocal structural link is a bidirectional tagged structural link, in which the identical forward and backward tags are replaced by a single reciprocity tag. \n* Reciprocity is a property of a structural relation that denotes whether its forward and backward structural relations have the same semantics. \n* A transitive structural relation ℜ is a structural relation for which it holds that if A ℜ B and B ℜ C then A ℜ C. \n* Transitivity is a property of a structural relation, which determines whether the structural relation is transitive. \n* The values of both the reciprocity and the transitivity properties of a structural relation can be positive, neutral, or negative. \n* The unidirectional default null tag is the default null tag for the unidirectional structural link, and its associated OPL reserved phrase is “relates to”. \n* The bidirectional default null tag is the default null tag for the bidirectional structural link, and its associated OPL reserved phrase is “related”. \n* A user-defined null tag is a tag defined by the system modeler that overrides the default null tags for a specific system model, an enterprise, or a domain. \n* State-preserving processes convey a message of continuity, stability, detachment from time, or steady state.\n"
      },
      "date": 1647729325762
    },
    {
      "type": "add",
      "id": "3cf00be0b2e937b6",
      "item": {
        "type": "markdown",
        "id": "3cf00be0b2e937b6",
        "text": "\n..."
      },
      "after": "3672b9af7f3bdbe3",
      "date": 1647729336508
    },
    {
      "type": "edit",
      "id": "3cf00be0b2e937b6",
      "item": {
        "type": "markdown",
        "id": "3cf00be0b2e937b6",
        "text": "15.9 Summary A participation constraint is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (number of repetitions) of that object in that relation. A structural participation constraint is a participation constraint recorded along a structural link. A procedural participation constraint is a participation constraint recorded along a procedural link. The default participation constraint is 1, and it is implicit. A parameterized participation constraint is a participation constraint which is a mathematical expression with one or more parameters. A range participation constraint is a participation constraint with lower and upper bounds, each possibly an expression, on the number of possible objects that can take part in the relation. Source participation constraint is the participation constraint on the source side of the (structural or procedural) link. Destination participation constraint is the participation constraint on the destination side of the (structural or procedural) link. Cardinality is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. The distributive law of structural relations: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). A fork is a combination of two or more structural links with the same semantics expressed by the same tag. Handle is the joint origin-side edge of the fork . Tine is the split destination-side edge of the fork . Handle thing is the thing linked to the handle of the fork link Tine thing is a thing linked to a tine of the fork link. Object fork is a set of objects connected by a fork . Process fork is a set of processes connected by a fork . The tine thing set of a fork is the set of all the things linked to the tines of the fork. Fork degree is a fork property that specifies the size of the tine object set. Fork comprehensiveness is a Boolean fork property which is positive if all the things in the tine thing set are attached to the fork’s handle and negative otherwise. Orderability is a Boolean fork property which is positive if the things in the tine thing set are ordered and negative otherwise. Order criterion is a property of an ordered tine thing set, which specifies textually in the OPD the criterion according to which the things in the tine thing set are ordered.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 340-341). Springer New York. Kindle Edition. "
      },
      "date": 1647729426015
    },
    {
      "type": "edit",
      "id": "3cf00be0b2e937b6",
      "item": {
        "type": "markdown",
        "id": "3cf00be0b2e937b6",
        "text": "15.9 Summary \n"
      },
      "date": 1647729454191
    },
    {
      "type": "edit",
      "id": "3cf00be0b2e937b6",
      "item": {
        "type": "markdown",
        "id": "3cf00be0b2e937b6",
        "text": "15.9 Summary \n\nA participation constraint is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (number of repetitions) of that object in that relation. "
      },
      "date": 1647729560644
    },
    {
      "type": "add",
      "id": "fcc60d90baca87c9",
      "item": {
        "type": "markdown",
        "id": "fcc60d90baca87c9",
        "text": "A structural participation constraint is a participation constraint recorded along a structural link. A procedural participation constraint is a participation constraint recorded along a procedural link. The default participation constraint is 1, and it is implicit. A parameterized participation constraint is a participation constraint which is a mathematical expression with one or more parameters. A range participation constraint is a participation constraint with lower and upper bounds, each possibly an expression, on the number of possible objects that can take part in the relation. Source participation constraint is the participation constraint on the source side of the (structural or procedural) link. Destination participation constraint is the participation constraint on the destination side of the (structural or procedural) link. Cardinality is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. The distributive law of structural relations: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). A fork is a combination of two or more structural links with the same semantics expressed by the same tag. Handle is the joint origin-side edge of the fork . Tine is the split destination-side edge of the fork . Handle thing is the thing linked to the handle of the fork link Tine thing is a thing linked to a tine of the fork link. Object fork is a set of objects connected by a fork . Process fork is a set of processes connected by a fork . The tine thing set of a fork is the set of all the things linked to the tines of the fork. Fork degree is a fork property that specifies the size of the tine object set. Fork comprehensiveness is a Boolean fork property which is positive if all the things in the tine thing set are attached to the fork’s handle and negative otherwise. Orderability is a Boolean fork property which is positive if the things in the tine thing set are ordered and negative otherwise. Order criterion is a property of an ordered tine thing set, which specifies textually in the OPD the criterion according to which the things in the tine thing set are ordered.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 340-341). Springer New York. Kindle Edition. "
      },
      "after": "3cf00be0b2e937b6",
      "date": 1647729563587
    },
    {
      "type": "remove",
      "id": "fcc60d90baca87c9",
      "date": 1647729599247
    },
    {
      "type": "edit",
      "id": "3cf00be0b2e937b6",
      "item": {
        "type": "markdown",
        "id": "3cf00be0b2e937b6",
        "text": "15.9 Summary \n\n* A participation constraint is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (number of repetitions) of that object in that relation. \n* A structural participation constraint is a participation constraint recorded along a structural link. \n* A procedural participation constraint is a participation constraint recorded along a procedural link. \n* The default participation constraint is 1, and it is implicit. \n* A parameterized participation constraint is a participation constraint which is a mathematical expression with one or more parameters. \n* A range participation constraint is a participation constraint with lower and upper bounds, each possibly an expression, on the number of possible objects that can take part in the relation. \n* Source participation constraint is the participation constraint on the source side of the (structural or procedural) link. \n* Destination participation constraint is the participation constraint on the destination side of the (structural or procedural) link. \n* Cardinality is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. \n* The distributive law of structural relations: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). \n* A fork is a combination of two or more structural links with the same semantics expressed by the same tag. \n* Handle is the joint origin-side edge of the fork . Tine is the split destination-side edge of the fork . \n* Handle thing is the thing linked to the handle of the fork link Tine thing is a thing linked to a tine of the fork link. \n* Object fork is a set of objects connected by a fork . \n* Process fork is a set of processes connected by a fork . \n* The tine thing set of a fork is the set of all the things linked to the tines of the fork. \n* Fork degree is a fork property that specifies the size of the tine object set. \n* Fork comprehensiveness is a Boolean fork property which is positive if all the things in the tine thing set are attached to the fork’s handle and negative otherwise. \n* Orderability is a Boolean fork property which is positive if the things in the tine thing set are ordered and negative otherwise. \n* Order criterion is a property of an ordered tine thing set, which specifies textually in the OPD the criterion according to which the things in the tine thing set are ordered.\n\n..."
      },
      "date": 1647729762393
    },
    {
      "type": "edit",
      "id": "3cf00be0b2e937b6",
      "item": {
        "type": "markdown",
        "id": "3cf00be0b2e937b6",
        "text": "15.9 Summary \n\n* A participation constraint is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (number of repetitions) of that object in that relation. \n* A structural participation constraint is a participation constraint recorded along a structural link. \n* A procedural participation constraint is a participation constraint recorded along a procedural link. \n* The default participation constraint is 1, and it is implicit. \n* A parameterized participation constraint is a participation constraint which is a mathematical expression with one or more parameters. \n* A range participation constraint is a participation constraint with lower and upper bounds, each possibly an expression, on the number of possible objects that can take part in the relation. \n* Source participation constraint is the participation constraint on the source side of the (structural or procedural) link. \n* Destination participation constraint is the participation constraint on the destination side of the (structural or procedural) link. \n* Cardinality is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. \n* The distributive law of structural relations: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). \n* A fork is a combination of two or more structural links with the same semantics expressed by the same tag. \n* Handle is the joint origin-side edge of the fork . Tine is the split destination-side edge of the fork . \n* Handle thing is the thing linked to the handle of the fork link Tine thing is a thing linked to a tine of the fork link. \n* Object fork is a set of objects connected by a fork . \n* Process fork is a set of processes connected by a fork . \n* The tine thing set of a fork is the set of all the things linked to the tines of the fork. \n* Fork degree is a fork property that specifies the size of the tine object set. \n* Fork comprehensiveness is a Boolean fork property which is positive if all the things in the tine thing set are attached to the fork’s handle and negative otherwise. \n* Orderability is a Boolean fork property which is positive if the things in the tine thing set are ordered and negative otherwise. \n* Order criterion is a property of an ordered tine thing set, which specifies textually in the OPD the criterion according to which the things in the tine thing set are ordered.\n\n"
      },
      "date": 1647729842183
    },
    {
      "type": "add",
      "id": "fe04a9e143e6e484",
      "item": {
        "type": "markdown",
        "id": "fe04a9e143e6e484",
        "text": "15.9 Summary \n* A participation constraint is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (number of repetitions) of that object in that relation. \n* A structural participation constraint is a participation constraint recorded along a structural link. \n* A procedural participation constraint is a participation constraint recorded along a procedural link. \n* The default participation constraint is 1, and it is implicit. \n* A parameterized participation constraint is a participation constraint which is a mathematical expression with one or more parameters. \n* A range participation constraint is a participation constraint with lower and upper bounds, each possibly an expression, on the number of possible objects that can take part in the relation. \n* Source participation constraint is the participation constraint on the source side of the (structural or procedural) link. \n* Destination participation constraint is the participation constraint on the destination side of the (structural or procedural) link. \n* Cardinality is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. \n* The distributive law of structural relations: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). \n* A fork is a combination of two or more structural links with the same semantics expressed by the same tag. Handle is the joint origin-side edge of the fork \n. Tine is the split destination-side edge of the fork "
      },
      "after": "3cf00be0b2e937b6",
      "date": 1647730020270
    },
    {
      "type": "edit",
      "id": "fe04a9e143e6e484",
      "item": {
        "type": "markdown",
        "id": "fe04a9e143e6e484",
        "text": "15.9 Summary \n* A participation constraint is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (number of repetitions) of that object in that relation. \n* A structural participation constraint is a participation constraint recorded along a structural link. \n* A procedural participation constraint is a participation constraint recorded along a procedural link. \n* The default participation constraint is 1, and it is implicit. \n* A parameterized participation constraint is a participation constraint which is a mathematical expression with one or more parameters. \n* A range participation constraint is a participation constraint with lower and upper bounds, each possibly an expression, on the number of possible objects that can take part in the relation. \n* Source participation constraint is the participation constraint on the source side of the (structural or procedural) link. \n* Destination participation constraint is the participation constraint on the destination side of the (structural or procedural) link. \n* Cardinality is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. \n* The distributive law of structural relations: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). \n* A fork is a combination of two or more structural links with the same semantics expressed by the same tag. Handle is the joint origin-side edge of the fork \n. Tine is the split destination-side edge of the fork . Handle thing is the thing linked to the handle of the fork link Tine thing is a thing linked to a tine of the fork link. Object fork is a set of objects connected by a fork . Process fork is a set of processes connected by a fork . The tine thing set of a fork is the set of all the things linked to the tines of the fork. Fork degree is a fork property that specifies the size of the tine object set. Fork comprehensiveness is a Boolean fork property which is positive if all the things in the tine thing set are attached to the fork’s handle and negative otherwise. Orderability is a Boolean fork property which is positive if the things in the tine thing set are ordered and negative otherwise. Order criterion is a property of an ordered tine thing set, which specifies textually in the OPD the criterion according to which the things in the tine thing set are ordered.\n\n..."
      },
      "date": 1647730050959
    },
    {
      "type": "edit",
      "id": "fe04a9e143e6e484",
      "item": {
        "type": "markdown",
        "id": "fe04a9e143e6e484",
        "text": "15.9 Summary \n* A participation constraint is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (number of repetitions) of that object in that relation. \n* A structural participation constraint is a participation constraint recorded along a structural link. \n* A procedural participation constraint is a participation constraint recorded along a procedural link. \n* The default participation constraint is 1, and it is implicit. \n* A parameterized participation constraint is a participation constraint which is a mathematical expression with one or more parameters. \n* A range participation constraint is a participation constraint with lower and upper bounds, each possibly an expression, on the number of possible objects that can take part in the relation. \n* Source participation constraint is the participation constraint on the source side of the (structural or procedural) link. \n* Destination participation constraint is the participation constraint on the destination side of the (structural or procedural) link. \n* Cardinality is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. \n* The distributive law of structural relations: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). \n* A fork is a combination of two or more structural links with the same semantics expressed by the same tag. \n* Handle is the joint origin-side edge of the fork. \n* Tine is the split destination-side edge of the fork. \n* Handle thing is the thing linked to the handle of the fork link Tine thing is a thing linked to a tine of the fork link. \n* Object fork is a set of objects connected by a fork. \n* Process fork is a set of processes connected by a fork. \n* The tine thing set of a fork is the set of all the things linked to the tines of the fork. \n* Fork degree is a fork property that specifies the size of the tine object set. \n* Fork comprehensiveness is a Boolean fork property which is positive if all the things in the tine thing set are attached to the fork’s handle and negative otherwise. \n* Orderability is a Boolean fork property which is positive if the things in the tine thing set are ordered and negative otherwise. \n* Order criterion is a property of an ordered tine thing set, which specifies textually in the OPD the criterion according to which the things in the tine thing set are ordered.\n\n"
      },
      "date": 1647730206659
    },
    {
      "type": "add",
      "id": "788813e9d88cf44e",
      "item": {
        "type": "markdown",
        "id": "788813e9d88cf44e",
        "text": "..."
      },
      "after": "fe04a9e143e6e484",
      "date": 1647730221336
    },
    {
      "type": "edit",
      "id": "788813e9d88cf44e",
      "item": {
        "type": "markdown",
        "id": "788813e9d88cf44e",
        "text": "16.4 Summary Four structural relations are fundamental and therefore are assigned graphic symbols.  Refineable is a thing amenable to refinement via a fundamental structural relation. Refinee is a thing that refines a refineable . The four fundamental structural relations are:  Aggregation-participation; Exhibition-characterization; Generalization-specialization; and Classification-instantiation. Each fundamental structural relation has a unique triangular symbol . The symbol replaces the tag, making the OPD more graphic and more quickly comprehensible. Each fundamental structural relation induces a hierarchy . Complex hierarchies can be created by mixing the four relations. In certain domains, additional structural relations might be fundamental and user-defined dedicated symbol s can be allocated for them.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (p. 349). Springer New York. Kindle Edition. "
      },
      "date": 1647730291836
    },
    {
      "type": "edit",
      "id": "788813e9d88cf44e",
      "item": {
        "type": "markdown",
        "id": "788813e9d88cf44e",
        "text": "16.4 Summary\n* Four structural relations are fundamental and therefore are assigned graphic symbols.  \n* Refineable is a thing amenable to refinement via a fundamental structural relation. \n* Refinee is a thing that refines a refineable . \n* The four fundamental structural relations are:  Aggregation-participation; Exhibition-characterization; Generalization-specialization; and Classification-instantiation. \n* Each fundamental structural relation has a unique triangular symbol . \n* The symbol replaces the tag, making the OPD more graphic and more quickly comprehensible. \n* Each fundamental structural relation induces a hierarchy . \n* Complex hierarchies can be created by mixing the four relations. \n* In certain domains, additional structural relations might be fundamental and user-defined dedicated symbol s can be allocated for them.\n\n"
      },
      "date": 1647730376604
    },
    {
      "type": "add",
      "id": "c93d644631974428",
      "item": {
        "type": "markdown",
        "id": "c93d644631974428",
        "text": "... "
      },
      "after": "788813e9d88cf44e",
      "date": 1647730382004
    },
    {
      "type": "edit",
      "id": "c93d644631974428",
      "item": {
        "type": "markdown",
        "id": "c93d644631974428",
        "text": "17.10 Summary \n\n* Aggregation-participation is a fundamental structural relation which denotes the fact that a refineable —the whole—aggregates one or more refineables—the parts. \n* Aggregation-participation is a pair of forward and backward structural relations. \n* The solid black triangle, ▲, is the aggregation-participation relation symbol. \n* It replaces the pair of forward and backward textual tags of the aggregation-participation relation. \n* Aggregating is the process of creating a whole from its parts, while participating is enumerating the parts that comprise the aggregate. \n* In UML 2 and SysML , there are two types of aggregation in class diagrams: shared—weak aggregation, marked as a white diamond, and composite—strong aggregation, marked as a black diamond. \n* In OPM the distinction between composite and shared aggregation is not necessary, since one can model exactly what part or parts are consumed when the whole is consumed and what parts remain. \n* Orderability is a Boolean property of the aggregation relation, inherited from fork . \n* To denote that the aggregation is ordered, we add the symbol ordered next to the aggregation triangle. Comprehensiveness is another Boolean property of the aggregation relation, inherited from fork . \n* To denote that the aggregation is non-comprehensive, we add a short horizontal bar below the aggregation triangle. \n* The Parameterized Participation Constraints (PPC) mini-language has a small syntax that determines how to phrase a set of constraints for a parameter in a participation constraint.\n\n"
      },
      "date": 1647730600235
    },
    {
      "type": "add",
      "id": "77eeb9cf91a4e6de",
      "item": {
        "type": "markdown",
        "id": "77eeb9cf91a4e6de",
        "text": "..."
      },
      "after": "c93d644631974428",
      "date": 1647730607791
    },
    {
      "type": "edit",
      "id": "77eeb9cf91a4e6de",
      "item": {
        "type": "markdown",
        "id": "77eeb9cf91a4e6de",
        "text": "18.9 Summary Exhibition-characterization is a relation between a thing and the features that characterize it. The shorthand name of this relation is characterization and its symbol is . Characterization is the only fundamental structural relation for which all four combinations of an object and a process, as an exhibitor and a feature, are possible. A feature which is an object, is called an attribute , while a feature which is a process is an operation .\n\n"
      },
      "date": 1647730662263
    },
    {
      "type": "edit",
      "id": "77eeb9cf91a4e6de",
      "item": {
        "type": "markdown",
        "id": "77eeb9cf91a4e6de",
        "text": "18.9 Summary Exhibition-characterization is a relation between a thing and the features that characterize it. The shorthand name of this relation is characterization and its symbol is . Characterization is the only fundamental structural relation for which all four combinations of an object and a process, as an exhibitor and a feature, are possible. A feature which is an object, is called an attribute , while a feature which is a process is an operation .\nAn attribute is implicit if its values are assigned directly to the exhibitor with no specification of the attribute name. An attribute is explicit if it is a separate object that is linked to the exhibitor with an exhibition-characterization relation. Explicitness is an attribute of an attribute whose values are explicit (the default) and implicit. An attribute is qualitative if its values are non-numerical. An attribute is quantitative if its values are numerical. An operation is quantitative if it transforms a quantitative attribute, otherwise it is quantitative. Mode is a property of a feature that determines whether it is qualitative (the default) or quantitative. A quantitative attribute is hard if its value cannot be deduced or computed from other attributes. A quantitative attribute is soft if its value can be deduced or computed from other attributes. Touch is an attribute of a quantitative attribute which determines whether it is hard (the default) or soft. A feature of an object is inherent if a least one of the object’s parts exhibits it. A feature of an object is emergent if no one of the object’s parts alone exhibits it. Emergence is a property of an object whose values are inherent (the default) and emergent. A link is homogeneous if it connects two things that exhibit the same perseverance value. A link is non-homogeneous if it connects two things that exhibit opposite perseverance values. Homogeneity is a property of a link whose values are homogeneous (the default for structural links) and non-homogeneous (the default for procedural links).\n\n"
      },
      "date": 1647730693395
    },
    {
      "type": "add",
      "id": "cf194dd67526d444",
      "item": {
        "type": "markdown",
        "id": "cf194dd67526d444",
        "text": "...\n\n"
      },
      "after": "77eeb9cf91a4e6de",
      "date": 1647730695203
    },
    {
      "type": "edit",
      "id": "77eeb9cf91a4e6de",
      "item": {
        "type": "markdown",
        "id": "77eeb9cf91a4e6de",
        "text": "18.9 Summary \n"
      },
      "date": 1647730710465
    },
    {
      "type": "edit",
      "id": "77eeb9cf91a4e6de",
      "item": {
        "type": "markdown",
        "id": "77eeb9cf91a4e6de",
        "text": "18.9 Summary \n\n* Exhibition-characterization is a relation between a thing and the features that characterize it. \n* The shorthand name of this relation is characterization and its symbol is . \n* Characterization is the only fundamental structural relation for which all four combinations of an object and a process, as an exhibitor and a feature, are possible. "
      },
      "date": 1647731077743
    },
    {
      "type": "add",
      "id": "0d4f99df9a5f739d",
      "item": {
        "type": "markdown",
        "id": "0d4f99df9a5f739d",
        "text": "* A feature which is an object, is called an attribute , while a feature which is a process is an operation .\n* An attribute is implicit if its values are assigned directly to the exhibitor with no specification of the attribute name. \n* An attribute is explicit if it is a separate object that is linked to the exhibitor with an exhibition-characterization relation. \n* Explicitness is an attribute of an attribute whose values are explicit (the default) and implicit. \n* An attribute is qualitative if its values are non-numerical. \n* An attribute is quantitative if its values are numerical. \n* An operation is quantitative if it transforms a quantitative attribute, otherwise it is quantitative. \n* Mode is a property of a feature that determines whether it is qualitative (the default) or quantitative. \n* A quantitative attribute is hard if its value cannot be deduced or computed from other attributes. \n* A quantitative attribute is soft if its value can be deduced or computed from other attributes. \n* Touch is an attribute of a quantitative attribute which determines whether it is hard (the default) or soft. \n* A feature of an object is inherent if a least one of the object’s parts exhibits it. \n* A feature of an object is emergent if no one of the object’s parts alone exhibits it. \n* Emergence is a property of an object whose values are inherent (the default) and emergent. \n* A link is homogeneous if it connects two things that exhibit the same perseverance value. \n* A link is non-homogeneous if it connects two things that exhibit opposite perseverance values. \n* Homogeneity is a property of a link whose values are homogeneous (the default for structural links) and non-homogeneous (the default for procedural links).\n\n"
      },
      "after": "77eeb9cf91a4e6de",
      "date": 1647731200567
    },
    {
      "type": "edit",
      "id": "cf194dd67526d444",
      "item": {
        "type": "markdown",
        "id": "cf194dd67526d444",
        "text": "19.9 Summary A State is a situation or position at which an object can exist, or a value an attribute can assume, for some period of time during its existence. An initial state of an object B is a state at which B is upon its generation or as the system starts executing. A final state of an object B is a state from which B cannot exit. A default state of an object B is the state which B is expected to be when its state is not specified. Value is a state of an attribute, therefore it is a specialization of state. In addition to being at some state, an object can also be unstable , when it is in transition between two states—the input state and the output state. State transition is an unstable period of time for an object, which takes place when a process acts on it to change its state. A lifespan diagram is a diagram which, for any point in time during the life of the system, shows what objects exists in the system, what state each object is at, and what processes are active. A state-specified tagged structural link is a tagged structural link that connects a state of an object to another object or to a state of another object. An atomic state is a state that is not combined of other states. A compound state is a state that combines at least two other states. The state space of an object is the Cartesian product of the sets of states of all the attributes and parts of the object\n\n...\n\n"
      },
      "date": 1647731246586
    },
    {
      "type": "edit",
      "id": "cf194dd67526d444",
      "item": {
        "type": "markdown",
        "id": "cf194dd67526d444",
        "text": "19.9 Summary\n\n* A State is a situation or position at which an object can exist, or a value an attribute can assume, for some period of time during its existence. \n* An initial state of an object B is a state at which B is upon its generation or as the system starts executing. A final state of an object B is a state from which B cannot exit. \n* A default state of an object B is the state which B is expected to be when its state is not specified. * Value is a state of an attribute, therefore it is a specialization of state. \n* In addition to being at some state, an object can also be unstable , when it is in transition between two states—the input state and the output state. \n* State transition is an unstable period of time for an object, which takes place when a process acts on it to change its state. \n* A lifespan diagram is a diagram which, for any point in time during the life of the system, shows what objects exists in the system, what state each object is at, and what processes are active. \n* A state-specified tagged structural link is a tagged structural link that connects a state of an object to another object or to a state of another object. \n* An atomic state is a state that is not combined of other states. \n* A compound state is a state that combines at least two other states. \n* The state space of an object is the Cartesian product of the sets of states of all the attributes and parts of the object\n\n"
      },
      "date": 1647731508716
    },
    {
      "type": "add",
      "id": "b519a18ae0ef656c",
      "item": {
        "type": "markdown",
        "id": "b519a18ae0ef656c",
        "text": "...\n\n"
      },
      "after": "cf194dd67526d444",
      "date": 1647731533529
    },
    {
      "type": "edit",
      "id": "b519a18ae0ef656c",
      "item": {
        "type": "markdown",
        "id": "b519a18ae0ef656c",
        "text": "20.9 Summary \n"
      },
      "date": 1647731573476
    },
    {
      "type": "edit",
      "id": "b519a18ae0ef656c",
      "item": {
        "type": "markdown",
        "id": "b519a18ae0ef656c",
        "text": "20.9 Summary \n\n* Generalization-specialization is the relation between a general thing and a specialization of that thing. \n* Classification-instantiation is the relation between a class of things and a unique instance that belongs that class. \n* Generalization-specialization gives rise to inheritance from the generalized thing to the specialized one(s). \n* Inheritance is of features (attributes and operations), structural relations and procedural relations. \n* For objects, states are inherited too. \n* OPM processes specialize in a manner similar to objects. \n* States of specialized objects can override inherited states. \n* A class is a template, from which things that instantiate the class can be generated as members of that class. \n* Instance is a relative term. \n* A specialization in one system can be an instance in another. \n* A process instance is a particular occurrence of a process at a given point in time and whose involved object set is a set of object instances.\n\n"
      },
      "date": 1647731677510
    },
    {
      "type": "add",
      "id": "2f46c1de610d8de4",
      "item": {
        "type": "markdown",
        "id": "2f46c1de610d8de4",
        "text": "...\n"
      },
      "after": "b519a18ae0ef656c",
      "date": 1647731684520
    },
    {
      "type": "edit",
      "id": "2f46c1de610d8de4",
      "item": {
        "type": "markdown",
        "id": "2f46c1de610d8de4",
        "text": "21.21 Summary Complexity management is essential for taming the complexity of real-world systems, both man-made and natural. The OPM Model Complexity Assertion is that applying refinement mechanisms of in-zooming and unfolding to stateful objects or processes, OPM can conceptually model systems at any level of complexity. OPM’s complexity management approach is detail-level-based decomposition, which is in contrast with UML and SysML approach of aspect-based decomposition. The completeness-clarity trade-off is the tension between the need to specify the system such that all the model facts are represented, while maintaining a clear, comprehensible representation of the system. The three refinement-abstraction mechanisms are unfolding–folding, in-zooming–out-zooming, and state-expressing–state-suppressing. A fourth is view-creating–view-deleting. State-expressing is showing one or more of an object’s states; state-suppression is hiding one or more of the object’s states. Each of the four fundamental structural relation links may undergo unfolding and folding, so there are four kinds of unfolding-folding pairs. In-diagram unfolding is unfolding in which the refineable and its refinees appear unfolded in the same OPD in which the refinee was originally. New-diagram unfolding is unfolding in which the refineable and its refinees appear unfolded in a new OPD. Unfolding is a mechanism for refinement, elaboration, or decomposition, which reveals a set of refineables—things that relate to the unfolded thing—the refineable . A synchronous process is a process whose subprocesses have a predefined, fixed order. An asynchronous process is a process whose subprocesses do not have a predefined, fixed order. New-diagram in-zooming is in-zooming in which the refineable and its refinees appear in-zoomed in a new OPD. In-diagram in-zooming is in-zooming in which no new OPD is created, and the refineable appear in-zoomed along with its refinees in the same OPD. In-zooming has the semantics of aggregation-participation plus positive orderability . Process in-zooming determines the (possibly partial) temporal order of its subprocess execution.\n\n"
      },
      "date": 1647731727207
    },
    {
      "type": "edit",
      "id": "2f46c1de610d8de4",
      "item": {
        "type": "markdown",
        "id": "2f46c1de610d8de4",
        "text": "21.21 Summary Complexity management is essential for taming the complexity of real-world systems, both man-made and natural. The OPM Model Complexity Assertion is that applying refinement mechanisms of in-zooming and unfolding to stateful objects or processes, OPM can conceptually model systems at any level of complexity. OPM’s complexity management approach is detail-level-based decomposition, which is in contrast with UML and SysML approach of aspect-based decomposition. The completeness-clarity trade-off is the tension between the need to specify the system such that all the model facts are represented, while maintaining a clear, comprehensible representation of the system. The three refinement-abstraction mechanisms are unfolding–folding, in-zooming–out-zooming, and state-expressing–state-suppressing. A fourth is view-creating–view-deleting. State-expressing is showing one or more of an object’s states; state-suppression is hiding one or more of the object’s states. Each of the four fundamental structural relation links may undergo unfolding and folding, so there are four kinds of unfolding-folding pairs. In-diagram unfolding is unfolding in which the refineable and its refinees appear unfolded in the same OPD in which the refinee was originally. New-diagram unfolding is unfolding in which the refineable and its refinees appear unfolded in a new OPD. Unfolding is a mechanism for refinement, elaboration, or decomposition, which reveals a set of refineables—things that relate to the unfolded thing—the refineable . A synchronous process is a process whose subprocesses have a predefined, fixed order. An asynchronous process is a process whose subprocesses do not have a predefined, fixed order. New-diagram in-zooming is in-zooming in which the refineable and its refinees appear in-zoomed in a new OPD. In-diagram in-zooming is in-zooming in which no new OPD is created, and the refineable appear in-zoomed along with its refinees in the same OPD. In-zooming has the semantics of aggregation-participation plus positive orderability . Process in-zooming determines the (possibly partial) temporal order of its subprocess execution.\nObject in-zooming determines the (possibly 2-dimansional) spatial order of its parts. An OPD tree is a directed nod- and edge-labeled tree graph whose nodes are OPDs obtained by recursive in-zooming or unfolding of processes in the system, starting with the function—the process in SD. An OPD set is the set of all the nodes in the OPD tree. Detail level of an OPD is the number of nodes in the OPD tree that need to be traversed from that OPD to the root, SD, including SD itself. The system map is an elaborate OPD tree, in which each node in the tree is a miniaturized icon of the OPD, with thick grey arrows pointing from each process in one OPD to its refined (in-zoomed or unfolded) version in the child OPD. The ultimate OPD is single flat representation of the OPM system model. Out-zooming provides for incorporating the middle-out approach to conceptual modeling by simplifying a complicated OPD while adding an interim level of detail. Semantic strength of a procedural link is the significance of the information that the link carries. Link precedence is an ordered list of procedural links with diminishing sematic strength. The primary link precedence is Consumption = Result > Effect > Agent > Instrument. View creating is collecting model facts from various OPDs in the OPD set and putting them together in a new OPD called View for the purpose of demonstrating a specific aspect. An OPD model specification is the collection of successive OPDs in the system’s OPD tree. An OPL model specification is the collection of successive OPL paragraphs corresponding to the OPDs in the system’s OPD tree, from which duplicate OPL sentences were removed. An OPM model specification is a side-by-side presentation of the OPD model specification and the OPL model specification, where to the right of each OPD the corresponding OPL paragraph is presented.\n\n"
      },
      "date": 1647731764874
    },
    {
      "type": "add",
      "id": "c98be62c5f497fb1",
      "item": {
        "type": "markdown",
        "id": "c98be62c5f497fb1",
        "text": "...\n"
      },
      "after": "2f46c1de610d8de4",
      "date": 1647731767317
    },
    {
      "type": "edit",
      "id": "2f46c1de610d8de4",
      "item": {
        "type": "markdown",
        "id": "2f46c1de610d8de4",
        "text": "21.21 Summary \n* Complexity management is essential for taming the complexity of real-world systems, both man-made and natural. \n* The OPM Model Complexity Assertion is that applying refinement mechanisms of in-zooming and unfolding to stateful objects or processes, OPM can conceptually model systems at any level of complexity. \n* OPM’s complexity management approach is detail-level-based decomposition, which is in contrast with UML and SysML approach of aspect-based decomposition. \n* The completeness-clarity trade-off is the tension between the need to specify the system such that all the model facts are represented, while maintaining a clear, comprehensible representation of the system. "
      },
      "date": 1647731829079
    },
    {
      "type": "edit",
      "id": "2f46c1de610d8de4",
      "item": {
        "type": "markdown",
        "id": "2f46c1de610d8de4",
        "text": "21.21 Summary \n* Complexity management is essential for taming the complexity of real-world systems, both man-made and natural. \n* The OPM Model Complexity Assertion is that applying refinement mechanisms of in-zooming and unfolding to stateful objects or processes, OPM can conceptually model systems at any level of complexity. \n* OPM’s complexity management approach is detail-level-based decomposition, which is in contrast with UML and SysML approach of aspect-based decomposition. \n* The completeness-clarity trade-off is the tension between the need to specify the system such that all the model facts are represented, while maintaining a clear, comprehensible representation of the system. * The three refinement-abstraction mechanisms are unfolding–folding, in-zooming–out-zooming, and state-expressing–state-suppressing. \n* A fourth is view-creating–view-deleting. \n* State-expressing is showing one or more of an object’s states; state-suppression is hiding one or more of the object’s states. \n* Each of the four fundamental structural relation links may undergo unfolding and folding, so there are four kinds of unfolding-folding pairs. \n* In-diagram unfolding is unfolding in which the refineable and its refinees appear unfolded in the same OPD in which the refinee was originally. \n* New-diagram unfolding is unfolding in which the refineable and its refinees appear unfolded in a new OPD. \n* Unfolding is a mechanism for refinement, elaboration, or decomposition, which reveals a set of refineables—things that relate to the unfolded thing—the refineable . \n* A synchronous process is a process whose subprocesses have a predefined, fixed order. \n* An asynchronous process is a process whose subprocesses do not have a predefined, fixed order. \n* New-diagram in-zooming is in-zooming in which the refineable and its refinees appear in-zoomed in a new OPD. \n* In-diagram in-zooming is in-zooming in which no new OPD is created, and the refineable appear in-zoomed along with its refinees in the same OPD. \n* In-zooming has the semantics of aggregation-participation plus positive orderability . \n* Process in-zooming determines the (possibly partial) temporal order of its subprocess execution.\nObject in-zooming determines the (possibly 2-dimansional) spatial order of its parts. \n* An OPD tree is a directed nod- and edge-labeled tree graph whose nodes are OPDs obtained by recursive in-zooming or unfolding of processes in the system, starting with the function—the process in SD. \n* An OPD set is the set of all the nodes in the OPD tree. \n* Detail level of an OPD is the number of nodes in the OPD tree that need to be traversed from that OPD to the root, SD, including SD itself. \n* The system map is an elaborate OPD tree, in which each node in the tree is a miniaturized icon of the OPD, with thick grey arrows pointing from each process in one OPD to its refined (in-zoomed or unfolded) version in the child OPD. \n* The ultimate OPD is single flat representation of the OPM system model. \n* Out-zooming provides for incorporating the middle-out approach to conceptual modeling by simplifying a complicated OPD while adding an interim level of detail. \n* Semantic strength of a procedural link is the significance of the information that the link carries. \n* Link precedence is an ordered list of procedural links with diminishing sematic strength. \n* The primary link precedence is Consumption = Result > Effect > Agent > Instrument. \n* View creating is collecting model facts from various OPDs in the OPD set and putting them together in a new OPD called View for the purpose of demonstrating a specific aspect. \n* An OPD model specification is the collection of successive OPDs in the system’s OPD tree. \n* An OPL model specification is the collection of successive OPL paragraphs corresponding to the OPDs in the system’s OPD tree, from which duplicate OPL sentences were removed. \n* An OPM model specification is a side-by-side presentation of the OPD model specification and the OPL model specification, where to the right of each OPD the corresponding OPL paragraph is presented.\n\n"
      },
      "date": 1647732036190
    },
    {
      "type": "edit",
      "id": "c98be62c5f497fb1",
      "item": {
        "type": "markdown",
        "id": "c98be62c5f497fb1",
        "text": "22.13 Summary An event is a point in time at which something significant to the system execution happens. Events and preconditions in concert specify OPM flow of execution control for process performance according to the event-condition-action paradigm. The event-condition-action paradigm stipulates that starting the performance of a process (the \"action\") has two prerequisites: an initiating event and satisfaction of a precondition derived from the preprocess object set. A control modifier is one of the two letter symbols e and c, added to a procedural link, which add to the semantics of that link the event and condition semantics, respectively. A control link is a procedural link with the addition of a control modifier. An event link is a procedural link with the control modifier e, indicating initiation of the link’s destination process, triggering that process’ precondition evaluation.\n\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (p. 545). Springer New York. Kindle Edition. \n"
      },
      "date": 1647732153612
    },
    {
      "type": "edit",
      "id": "c98be62c5f497fb1",
      "item": {
        "type": "markdown",
        "id": "c98be62c5f497fb1",
        "text": "22.13 Summary An event is a point in time at which something significant to the system execution happens. Events and preconditions in concert specify OPM flow of execution control for process performance according to the event-condition-action paradigm. The event-condition-action paradigm stipulates that starting the performance of a process (the \"action\") has two prerequisites: an initiating event and satisfaction of a precondition derived from the preprocess object set. A control modifier is one of the two letter symbols e and c, added to a procedural link, which add to the semantics of that link the event and condition semantics, respectively. A control link is a procedural link with the addition of a control modifier. An event link is a procedural link with the control modifier e, indicating initiation of the link’s destination process, triggering that process’ precondition evaluation.\nA condition link is a procedural link with the control modifier c, indicating that if the precondition of the link’s destination process is not met, then that process is skipped. The skip semantics precedence OPM principle states that skip semantics, induced by a control link, takes precedence over wait semantics, induced by a non-control link. A maximal-timed process is a process for which the modeler determines a maximal duration. An overtime handling process is a time exception process that determines what to do in case the time performance of a maximal-timed process exceeds its maximal allowable time. An overtime exception link is a procedural link from a maximal-timed process to an overtime handling process, indicating that if the duration of a maximal-timed process exceeds its maximal duration, then the overtime exception process is initiated. A minimal-timed process is a process for which the modeler determines a minimal duration. An undertime handling process is a time exception process that determines what to do in case the time performance of a minimal timed process falls short of its minimal duration. An undertime exception link is a procedural link from a minimal-timed process to an undertime exception process, indicating that if the time performance of a timed process falls short of its minimal allowable time, the undertime exception process is initiated.\n\n..."
      },
      "date": 1647732232341
    },
    {
      "type": "edit",
      "id": "c98be62c5f497fb1",
      "item": {
        "type": "markdown",
        "id": "c98be62c5f497fb1",
        "text": "22.13 Summary \n\n* An event is a point in time at which something significant to the system execution happens. "
      },
      "date": 1647732267297
    },
    {
      "type": "add",
      "id": "4d267b55b6610e1c",
      "item": {
        "type": "markdown",
        "id": "4d267b55b6610e1c",
        "text": "* Events and preconditions in concert specify OPM flow of execution control for process performance according to the event-condition-action paradigm. \n* The event-condition-action paradigm stipulates that starting the performance of a process (the \"action\") has two prerequisites: an initiating event and satisfaction of a precondition derived from the preprocess object set. \n* A control modifier is one of the two letter symbols e and c, added to a procedural link, which add to the semantics of that link the event and condition semantics, respectively. A control link is a procedural link with the addition of a control modifier. An event link is a procedural link with the control modifier e, indicating initiation of the link’s destination process, triggering that process’ precondition evaluation.\nA condition link is a procedural link with the control modifier c, indicating that if the precondition of the link’s destination process is not met, then that process is skipped. The skip semantics precedence OPM principle states that skip semantics, induced by a control link, takes precedence over wait semantics, induced by a non-control link. A maximal-timed process is a process for which the modeler determines a maximal duration. An overtime handling process is a time exception process that determines what to do in case the time performance of a maximal-timed process exceeds its maximal allowable time. An overtime exception link is a procedural link from a maximal-timed process to an overtime handling process, indicating that if the duration of a maximal-timed process exceeds its maximal duration, then the overtime exception process is initiated. A minimal-timed process is a process for which the modeler determines a minimal duration. An undertime handling process is a time exception process that determines what to do in case the time performance of a minimal timed process falls short of its minimal duration. An undertime exception link is a procedural link from a minimal-timed process to an undertime exception process, indicating that if the time performance of a timed process falls short of its minimal allowable time, the undertime exception process is initiated.\n\n..."
      },
      "after": "c98be62c5f497fb1",
      "date": 1647732320174
    },
    {
      "type": "edit",
      "id": "4d267b55b6610e1c",
      "item": {
        "type": "markdown",
        "id": "4d267b55b6610e1c",
        "text": "* Events and preconditions in concert specify OPM flow of execution control for process performance according to the event-condition-action paradigm. \n* The event-condition-action paradigm stipulates that starting the performance of a process (the \"action\") has two prerequisites: an initiating event and satisfaction of a precondition derived from the preprocess object set. \n* A control modifier is one of the two letter symbols e and c, added to a procedural link, which add to the semantics of that link the event and condition semantics, respectively. A control link is a procedural link with the addition of a control modifier. An event link is a procedural link with the control modifier e, indicating initiation of the link’s destination process, triggering that process’ precondition evaluation.\nA condition link is a procedural link with the control modifier c, indicating that if the precondition of the link’s destination process is not met, then that process is skipped. The skip semantics precedence OPM principle states that skip semantics, induced by a control link, takes precedence over wait semantics, induced by a non-control link. A maximal-timed process is a process for which the modeler determines a maximal duration. An overtime handling process is a time exception process that determines what to do in case the time performance of a maximal-timed process exceeds its maximal allowable time. An overtime exception link is a procedural link from a maximal-timed process to an overtime handling process, indicating that if the duration of a maximal-timed process exceeds its maximal duration, then the overtime exception process is initiated. A minimal-timed process is a process for which the modeler determines a minimal duration. An undertime handling process is a time exception process that determines what to do in case the time performance of a minimal timed process falls short of its minimal duration. An undertime exception link is a procedural link from a minimal-timed process to an undertime exception process, indicating that if the time performance of a timed process falls short of its minimal allowable time, the undertime exception process is initiated.\n\n"
      },
      "date": 1647788892168
    },
    {
      "type": "add",
      "id": "ae9f1aab3a42e28b",
      "item": {
        "type": "markdown",
        "id": "ae9f1aab3a42e28b",
        "text": "23.9 Summary Logical operators, including AND, OR, and XOR (exclusive OR) enable modeling complex conditions on performance of processes. Two or more procedural links of the same kind that originate from, or arrive at, different points along the process ellipse circumference (the process context), have the semantics of the logical AND operator. A link fan is a set of f ≥2 procedural links of the same kind that originate from a common point, or arrive at a common point, on the same object or process. The convergent end of a link fan is the end that is common to the f fan links. The divergent end of a link fan is the end that is not common to the f fan links. A link fan with a single dashed arc denotes the logical XOR operator. A link fan with a double dashed arc denotes the logical OR operator. A converging fan is a link fan whose links point to its convergent end. A diverging fan is a link fan whose links point to its divergent end. Each one of the XOR link fans for consumption, result, effect, and enabling links and\n\n..."
      },
      "after": "4d267b55b6610e1c",
      "date": 1647788908876
    },
    {
      "type": "edit",
      "id": "ae9f1aab3a42e28b",
      "item": {
        "type": "markdown",
        "id": "ae9f1aab3a42e28b",
        "text": "23.9 Summary Logical operators, including AND, OR, and XOR (exclusive OR) enable modeling complex conditions on performance of processes. Two or more procedural links of the same kind that originate from, or arrive at, different points along the process ellipse circumference (the process context), have the semantics of the logical AND operator. A link fan is a set of f ≥2 procedural links of the same kind that originate from a common point, or arrive at a common point, on the same object or process. The convergent end of a link fan is the end that is common to the f fan links. The divergent end of a link fan is the end that is not common to the f fan links. A link fan with a single dashed arc denotes the logical XOR operator. A link fan with a double dashed arc denotes the logical OR operator. A converging fan is a link fan whose links point to its convergent end. A diverging fan is a link fan whose links point to its divergent end. Each one of the XOR link fans for consumption, result, effect, and enabling links and their state-specified versions has a corresponding control-modified link fan: an event link fan and a condition link fan. Link probability is an optional attribute value assigned to a procedural link in a XOR diverging link fan that specifies the probability of following that particular link among the possible links in the fan link. A probabilistic link fan is a link fan with a probability value assigned to each of its links, such that the sum of the probability values of all the links is exactly 1.\n\n\n"
      },
      "date": 1647788944958
    },
    {
      "type": "add",
      "id": "bfc79de573eb2e6f",
      "item": {
        "type": "markdown",
        "id": "bfc79de573eb2e6f",
        "text": "..."
      },
      "after": "ae9f1aab3a42e28b",
      "date": 1647788983081
    },
    {
      "type": "edit",
      "id": "ae9f1aab3a42e28b",
      "item": {
        "type": "markdown",
        "id": "ae9f1aab3a42e28b",
        "text": "23.9 Summary\n\n* Logical operators, including AND, OR, and XOR (exclusive OR) enable modeling complex conditions on performance of processes. "
      },
      "date": 1647789004188
    },
    {
      "type": "edit",
      "id": "ae9f1aab3a42e28b",
      "item": {
        "type": "markdown",
        "id": "ae9f1aab3a42e28b",
        "text": "23.9 Summary\n\n* Logical operators, including AND, OR, and XOR (exclusive OR) enable modeling complex conditions on performance of processes. \n* Two or more procedural links of the same kind that originate from, or arrive at, different points along the process ellipse circumference (the process context), have the semantics of the logical AND operator. "
      },
      "date": 1647789026652
    },
    {
      "type": "edit",
      "id": "ae9f1aab3a42e28b",
      "item": {
        "type": "factory",
        "id": "ae9f1aab3a42e28b",
        "text": "23.9 Summary\n\n* Logical operators, including AND, OR, and XOR (exclusive OR) enable modeling complex conditions on performance of processes. \n* Two or more procedural links of the same kind that originate from, or arrive at, different points along the process ellipse circumference (the process context), have the semantics of the logical AND operator. A link fan is a set of f ≥2 procedural links of the same kind that originate from a common point, or arrive at a common point, on the same object or process. The convergent end of a link fan is the end that is common to the f fan links. The divergent end of a link fan is the end that is not common to the f fan links. A link fan with a single dashed arc denotes the logical XOR operator. A link fan with a double dashed arc denotes the logical OR operator. A converging fan is a link fan whose links point to its convergent end. A diverging fan is a link fan whose links point to its divergent end. Each one of the XOR link fans for consumption, result, effect, and enabling links and their state-specified versions has a corresponding control-modified link fan: an event link fan and a condition link fan. Link probability is an optional attribute value assigned to a procedural link in a XOR diverging link fan that specifies the probability of following that particular link among the possible links in the fan link. A probabilistic link fan is a link fan with a probability value assigned to each of its links, such that the sum of the probability values of all the links is exactly 1.\n\n\n"
      },
      "date": 1647789037759
    },
    {
      "type": "edit",
      "id": "ae9f1aab3a42e28b",
      "item": {
        "type": "markdown",
        "id": "ae9f1aab3a42e28b",
        "text": "23.9 Summary\n\n* Logical operators, including AND, OR, and XOR (exclusive OR) enable modeling complex conditions on performance of processes. \n* Two or more procedural links of the same kind that originate from, or arrive at, different points along the process ellipse circumference (the process context), have the semantics of the logical AND operator. \n* A link fan is a set of f ≥2 procedural links of the same kind that originate from a common point, or arrive at a common point, on the same object or process. \n* The convergent end of a link fan is the end that is common to the f fan links. \n* The divergent end of a link fan is the end that is not common to the f fan links. \n* A link fan with a single dashed arc denotes the logical XOR operator. \n* A link fan with a double dashed arc denotes the logical OR operator. \n* A converging fan is a link fan whose links point to its convergent end. \n* A diverging fan is a link fan whose links point to its divergent end. \n* Each one of the XOR link fans for consumption, result, effect, and enabling links and their state-specified versions has a corresponding control-modified link fan: an event link fan and a condition link fan. \n* Link probability is an optional attribute value assigned to a procedural link in a XOR diverging link fan that specifies the probability of following that particular link among the possible links in the fan link. \n* A probabilistic link fan is a link fan with a probability value assigned to each of its links, such that the sum of the probability values of all the links is exactly 1.\n\n\n"
      },
      "date": 1647789120222
    },
    {
      "type": "remove",
      "id": "4d267b55b6610e1c",
      "date": 1647789190098
    },
    {
      "type": "edit",
      "id": "c98be62c5f497fb1",
      "item": {
        "type": "markdown",
        "id": "c98be62c5f497fb1",
        "text": "22.13 Summary \n\n* An event is a point in time at which something significant to the system execution happens. \n* Events and preconditions in concert specify OPM flow of execution control for process performance according to the event-condition-action paradigm. \n* The event-condition-action paradigm stipulates that starting the performance of a process (the \"action\") has two prerequisites: an initiating event and satisfaction of a precondition derived from the preprocess object set. \n* A control modifier is one of the two letter symbols e and c, added to a procedural link, which add to the semantics of that link the event and condition semantics, respectively. "
      },
      "date": 1647789202669
    },
    {
      "type": "edit",
      "id": "c98be62c5f497fb1",
      "item": {
        "type": "markdown",
        "id": "c98be62c5f497fb1",
        "text": "22.13 Summary \n\n* An event is a point in time at which something significant to the system execution happens. \n* Events and preconditions in concert specify OPM flow of execution control for process performance according to the event-condition-action paradigm. \n* The event-condition-action paradigm stipulates that starting the performance of a process (the \"action\") has two prerequisites: an initiating event and satisfaction of a precondition derived from the preprocess object set. \n* A control modifier is one of the two letter symbols e and c, added to a procedural link, which add to the semantics of that link the event and condition semantics, respectively. \n* A control link is a procedural link with the addition of a control modifier. \n* An event link is a procedural link with the control modifier e, indicating initiation of the link’s destination process, triggering that process’ precondition evaluation.\n* A condition link is a procedural link with the control modifier c, indicating that if the precondition of the link’s destination process is not met, then that process is skipped. \n* The skip semantics precedence OPM principle states that skip semantics, induced by a control link, takes precedence over wait semantics, induced by a non-control link. \n* A maximal-timed process is a process for which the modeler determines a maximal duration. An overtime handling process is a time exception process that determines what to do in case the time performance of a maximal-timed process exceeds its maximal allowable time. \n* An overtime exception link is a procedural link from a maximal-timed process to an overtime handling process, indicating that if the duration of a maximal-timed process exceeds its maximal duration, then the overtime exception process is initiated. \n* A minimal-timed process is a process for which the modeler determines a minimal duration. \n* An undertime handling process is a time exception process that determines what to do in case the time performance of a minimal timed process falls short of its minimal duration. \n* An undertime exception link is a procedural link from a minimal-timed process to an undertime exception process, indicating that if the time performance of a timed process falls short of its minimal allowable time, the undertime exception process is initiated.\n\n"
      },
      "date": 1647789271494
    },
    {
      "type": "edit",
      "id": "62b44570fdfc68e4",
      "item": {
        "type": "markdown",
        "id": "62b44570fdfc68e4",
        "text": "13.11 Summary \n\n* A **change of an object** is an alteration in the state of that object. \n* **Effect** is a change in the state of an object that a process causes. \n* **Construction** is an extreme case of object effect, where the object’s input state is nonexistent and the output state is existent.\n* **Consumption** is an extreme case of object effect, where the object’s input state is existent and the output state is nonexistent. \n* When the transformation is extreme, a **change in object identity** takes place. \n* When the change is not profound or drastic, the object only **alters its state** while retaining its identity . \n* A **transformee** of process P is an object B that P transforms as a result of the occurrence of P.  \n* A **consumee** of a process P is a transformee of P that P consumes as a result of the occurrence of P. \n* A **resultee** of a process P is a transformee of P that P creates as a result of the occurrence of P. \n* An **affectee** of a process P is a transformee of P that that P affects as a result of the occurrence of P. \n* A **transforming link** is a procedural link that connects a process with a transformee of that process.  \n* A **result link** is a unidirectional transformation link from a process to the resultee that this process creates. \n* An **effect link** is a bidirectional transformation link that connects a process with an affectee of that process. \n* A **consumption link** is a unidirectional transformation link from a consumee to the process that consumes it. \n* An **enabler** E of a process P is an object that must exist and be available in order for P to start, and remain present throughout the occurrence of P in order for P to terminate normally, with E ultimately unaffected.  \n* An **agent** is an enabler who is a human or a group of humans. \n* An **instrument** is a non-human enabler. \n* An **enabling link** is a procedural link that connects a process with an enabler of that process.  \n* An **agent link** is an enabling link that connects a process with an agent of that process. \n* An **instrument link** is a procedural link that connects a process with an enabler of that process. \n* An **input state** of object B is a state s i of B at which B is when process P starts. \n* An **input link** is a link from the state s i to process P. \n* An **output state** of object B is a state s o of B at which B is when process P ends. \n* An **output link** is a link from process P to the state s o . \n* A **state-specified consumption link** is a consumption link that originates from an input state s i of the consumee C and ends at process P, denoting that in order for C to be consumed by P, it must be in state s i . \n* A **state-specified result link** is a result link that originates from process P and ends at a state s of the resultee R, denoting that when P terminates, it creates R in state s. \n* A **state-specified effect link** is an in-out (input–output) link pair, whose input link originates from an input state s i of the affectee A and ends at process P, and whose output link originates from P and ends at an output state s o of A, denoting that in order for A to be affected by P, A must be in s i , in which case when P terminates A will be at s o .  \n* An **in-out-specified effect link pair** of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to the output state s out of B. \n* An **input-specified effect link pair** of process P is a pair of links consisting of an input link from the input state s in of object B to P and an output link from P to B. \n* An **output-specified effect link pair** of process P is a pair of links consisting of an input link from object B to P and an output link from P to the output state s out of B. \n* A **value changing link** is a link between a process and an unspecified value of an attribute which the process changes.\n\n\n\n"
      },
      "date": 1647789781117
    },
    {
      "type": "edit",
      "id": "3672b9af7f3bdbe3",
      "item": {
        "type": "markdown",
        "id": "3672b9af7f3bdbe3",
        "text": "14.4 Summary \n\n* A **structural relation** is a linkage, connection, or association between two objects or between two processes that holds in the system for at least some time. \n* A **binary structural relation** is bidirectional. \n* A **structural link** is an arrow with an open head that represents a binary structural relation in an OPD from a source object to a destination object. \n* A **structural tag** is a phrase that expresses the semantics—the nature, meaning, or content—of the structural relation between the two things that participate in the relation. \n* A **tagged structural link** is structural link with a structural tag recorded along the link. \n* A **bidirectional tagged structural link** is a combination of two tagged structural links in opposite directions. \n* **Property** is an attribute of an OPM model element. \n* A **reciprocal structural relation** ℜ is a structural relation for which it holds that if A ℜ B and B ℜ′ A then ℜ = ℜ′. \n* A **reciprocal structural link** is a bidirectional tagged structural link, in which the identical forward and backward tags are replaced by a single reciprocity tag. \n* **Reciprocity** is a property of a structural relation that denotes whether its forward and backward structural relations have the same semantics. \n* A **transitive structural relation** ℜ is a structural relation for which it holds that if A ℜ B and B ℜ C then A ℜ C. \n* **Transitivity** is a property of a structural relation, which determines whether the structural relation is transitive. \n* The **values** of both the reciprocity and the transitivity properties of a structural relation can be positive, neutral, or negative. \n* The **unidirectional default null tag** is the default null tag for the unidirectional structural link, and its associated OPL reserved phrase is **“relates to”**. \n* The **bidirectional default null tag** is the default null tag for the bidirectional structural link, and its associated OPL reserved phrase is **“related”**. \n* A **user-defined null tag** is a tag defined by the system modeler that overrides the default null tags for a specific system model, an enterprise, or a domain. \n* **State-preserving processes** convey a message of continuity, stability, detachment from time, or steady state.\n"
      },
      "date": 1647790142847
    },
    {
      "type": "edit",
      "id": "3cf00be0b2e937b6",
      "item": {
        "type": "markdown",
        "id": "3cf00be0b2e937b6",
        "text": "15.9 Summary \n\n* A **participation constraint** is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (**number of repetitions**) of that object in that relation. \n* A **structural participation constraint** is a participation constraint recorded along a structural link. \n* A **procedural participation constraint** is a participation constraint recorded along a procedural link. \n* The **default participation constraint** is 1, and it is implicit. \n* A **parameterized participation constraint** is a participation constraint which is a mathematical expression with one or more parameters. \n* A **range participation constraint** is a participation constraint with lower and upper bounds, each possibly an expression, on the number of possible objects that can take part in the relation. \n* **Source participation constraint** is the participation constraint on the source side of the (structural or procedural) link. \n* **Destination participation constraint** is the participation constraint on the destination side of the (structural or procedural) link. \n* ???**Cardinality** is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. \n* ???The **distributive law of structural relations**: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). \n* A **fork** is a combination of two or more structural links with the same semantics expressed by the same tag. \n* **Handle** is the joint origin-side edge of the fork . \n* **Tine** is the split destination-side edge of the fork . \n* **Handle thing** is the thing linked to the handle of the fork link. \n* **Tine thing** is a thing linked to a tine of the fork link. \n* **Object fork** is a set of objects connected by a fork . \n* **Process fork** is a set of processes connected by a fork . \n* The **tine thing set of a fork** is the set of all the things linked to the tines of the fork. \n* **Fork degree** is a fork property that specifies the size of the tine object set. \n* ???**Fork comprehensiveness** is a Boolean fork property which is positive if all the things in the tine thing set are attached to the fork’s handle and negative otherwise. \n* ???**Orderability** is a Boolean fork property which is positive if the things in the tine thing set are ordered and negative otherwise. \n* ???**Order criterion** is a property of an ordered tine thing set, which specifies textually in the OPD the criterion according to which the things in the tine thing set are ordered.\n\n"
      },
      "date": 1647790645849
    },
    {
      "type": "edit",
      "id": "fe04a9e143e6e484",
      "item": {
        "type": "markdown",
        "id": "fe04a9e143e6e484",
        "text": "15.9 Summary \n* A **participation constraint** is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (number of repetitions) of that object in that relation. \n* A **structural participation** constraint is a participation constraint recorded along a structural link. \n* A procedural participation constraint is a participation constraint recorded along a procedural link. \n* The default participation constraint is 1, and it is implicit. \n* A parameterized participation constraint is a participation constraint which is a mathematical expression with one or more parameters. \n* A range participation constraint is a participation constraint with lower and upper bounds, each possibly an expression, on the number of possible objects that can take part in the relation. \n* Source participation constraint is the participation constraint on the source side of the (structural or procedural) link. \n* Destination participation constraint is the participation constraint on the destination side of the (structural or procedural) link. \n* Cardinality is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. \n* The distributive law of structural relations: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). \n* A fork is a combination of two or more structural links with the same semantics expressed by the same tag. \n* Handle is the joint origin-side edge of the fork. \n* Tine is the split destination-side edge of the fork. \n* Handle thing is the thing linked to the handle of the fork link Tine thing is a thing linked to a tine of the fork link. \n* Object fork is a set of objects connected by a fork. \n* Process fork is a set of processes connected by a fork. \n* The tine thing set of a fork is the set of all the things linked to the tines of the fork. \n* Fork degree is a fork property that specifies the size of the tine object set. \n* Fork comprehensiveness is a Boolean fork property which is positive if all the things in the tine thing set are attached to the fork’s handle and negative otherwise. \n* Orderability is a Boolean fork property which is positive if the things in the tine thing set are ordered and negative otherwise. \n* Order criterion is a property of an ordered tine thing set, which specifies textually in the OPD the criterion according to which the things in the tine thing set are ordered.\n\n"
      },
      "date": 1647809960171
    },
    {
      "type": "edit",
      "id": "fe04a9e143e6e484",
      "item": {
        "type": "markdown",
        "id": "fe04a9e143e6e484",
        "text": "15.9 Summary \n* A **participation constraint** is a number or a mathematical expression recorded along a link next to an object, which denotes the multiplicity (number of repetitions) of that object in that relation. \n* A **structural participation** constraint is a participation constraint recorded along a structural link. \n* A **procedural participation constraint** is a participation constraint recorded along a procedural link. \n* The **default participation constraint** is 1, and it is implicit. \n* A **parameterized participation constraint** is a participation constraint which is a mathematical expression with one or more parameters. \n* A **range participation constraint** is a participation constraint with lower and upper bounds, each possibly an expression, on the **number of possible objects that can take part in the relation**. \n* **Source participation constraint** is the participation constraint on the source side of the (structural or procedural) link. \n* **Destination participation constraint** is the participation constraint on the destination side of the (structural or procedural) link. \n* **Cardinality** is a property of a link whose value depends on the combination of the source and destination participation constraints of the structural link. \n* The **distributive law of structural relations**: If A, B, and C are all objects or are all processes, and ℜ is a structural relation, then A ℜ B, A ℜ C ⇔ A ℜ (B, C ). \n* A **fork** is a combination of two or more structural links with the same semantics expressed by the same tag. \n* **Handle** is the joint origin-side edge of the fork. \n* **Tine** is the split destination-side edge of the fork. \n* **Handle thing** is the thing linked to the handle of the fork link \n* **Tine thing** is a thing linked to a tine of the fork link. \n* **Object fork** is a set of objects connected by a fork. \n* **Process fork** is a set of processes connected by a fork. \n* The **tine thing set** of a fork is the set of all the things linked to the tines of the fork. \n* **Fork degree** is a fork property that specifies the size of the tine object set. \n* **Fork comprehensiveness** is a Boolean fork property which is positive if all the things in the tine thing set are attached to the fork’s handle and negative otherwise. \n* **Orderability** is a Boolean fork property which is positive if the things in the tine thing set are ordered and negative otherwise. \n* **Order criterion** is a property of an ordered tine thing set, which specifies textually in the OPD the criterion according to which the things in the tine thing set are ordered.\n\n"
      },
      "date": 1647842051673
    },
    {
      "type": "edit",
      "id": "788813e9d88cf44e",
      "item": {
        "type": "markdown",
        "id": "788813e9d88cf44e",
        "text": "16.4 Summary\n* **Four structural relations are fundamental** and therefore are assigned graphic symbols.  \n* **Refineable** is a thing amenable to refinement via a fundamental structural relation. \n* **Refinee** is a thing that refines a refineable . \n* The four fundamental structural relations are:  Aggregation-participation; Exhibition-characterization; Generalization-specialization; and Classification-instantiation. \n* Each fundamental structural relation has a unique triangular symbol . \n* The **symbol replaces the tag**, making the OPD more graphic and more quickly comprehensible. \n* Each fundamental structural relation **induces a hierarchy** . \n* **Complex hierarchies** can be created by mixing the four relations. \n* In certain domains, additional structural relations might be fundamental and **user-defined dedicated symbol s** can be allocated for them.\n\n"
      },
      "date": 1647842236289
    },
    {
      "type": "edit",
      "id": "c93d644631974428",
      "item": {
        "type": "markdown",
        "id": "c93d644631974428",
        "text": "17.10 Summary \n\n* **Aggregation-participation** is a fundamental structural relation which denotes the fact that a refineable —the whole—aggregates one or more refineables—the parts. \n* Aggregation-participation is a **pair of forward and backward structural relations**. \n* The solid black triangle, ▲, is the aggregation-participation relation **symbol**. \n* It replaces the pair of forward and backward textual tags of the aggregation-participation relation. \n* **Aggregating** is the process of creating a whole from its parts, while participating is enumerating the parts that comprise the aggregate. \n* In UML 2 and SysML , there are two types of aggregation in class diagrams: shared—weak aggregation, marked as a white diamond, and composite—strong aggregation, marked as a black diamond. \n* In OPM the distinction between composite and shared aggregation is not necessary, since one can model exactly what part or parts are consumed when the whole is consumed and what parts remain. \n* **Orderability** is a Boolean property of the aggregation relation, inherited from fork . \n* To denote that the aggregation is ordered, we add the **symbol ordered** next to the aggregation triangle. \n* **Comprehensiveness** is another Boolean property of the aggregation relation, inherited from fork . \n* To denote that the aggregation is **non-comprehensive**, we add a short horizontal bar below the aggregation triangle. \n* The **Parameterized Participation Constraints** (PPC) **mini-language** has a small syntax that determines how to phrase a set of constraints for a parameter in a participation constraint.\n\n"
      },
      "date": 1647842616456
    },
    {
      "type": "edit",
      "id": "77eeb9cf91a4e6de",
      "item": {
        "type": "markdown",
        "id": "77eeb9cf91a4e6de",
        "text": "18.9 Summary \n\n* **Exhibition-characterization** is a relation between a thing and the **features** that characterize it. \n* The shorthand name of this relation is characterization and its symbol is . \n* Characterization is the only fundamental structural relation for which **all four combinations** of an object and a process, as an **exhibitor** and a **feature**, are possible. "
      },
      "date": 1647842739627
    },
    {
      "type": "fork",
      "date": 1647843259315
    },
    {
      "type": "remove",
      "id": "0d4f99df9a5f739d",
      "date": 1647843281761
    },
    {
      "type": "edit",
      "id": "77eeb9cf91a4e6de",
      "item": {
        "type": "markdown",
        "id": "77eeb9cf91a4e6de",
        "text": "18.9 Summary \n\n* **Exhibition-characterization** is a relation between a thing and the **features** that characterize it. \n* The shorthand name of this relation is characterization and its symbol is . \n* Characterization is the only fundamental structural relation for which **all four combinations** of an object and a process, as an **exhibitor** and a **feature**, are possible. \n* A feature which is an object, is called an **attribute** , while a feature which is a process is an **operation** .\n* An attribute is **implicit** if its values are assigned directly to the exhibitor with no specification of the attribute name. \n* An attribute is **explicit** if it is a separate object that is linked to the exhibitor with an exhibition-characterization relation. \n* **Explicitness** is an attribute of an attribute whose **values are explicit (the default) and implicit**. \n* An attribute is qualitative if its values are non-numerical. \n* An attribute is quantitative if its values are numerical. \n* An operation is quantitative if it transforms a quantitative attribute, otherwise it is quantitative. \n* Mode is a property of a feature that determines whether it is qualitative (the default) or quantitative. \n* A quantitative attribute is hard if its value cannot be deduced or computed from other attributes. \n* A quantitative attribute is soft if its value can be deduced or computed from other attributes. \n* Touch is an attribute of a quantitative attribute which determines whether it is hard (the default) or soft. \n* A feature of an object is inherent if a least one of the object’s parts exhibits it. \n* A feature of an object is emergent if no one of the object’s parts alone exhibits it. \n* Emergence is a property of an object whose values are inherent (the default) and emergent. \n* A link is homogeneous if it connects two things that exhibit the same perseverance value. \n* A link is non-homogeneous if it connects two things that exhibit opposite perseverance values. \n* Homogeneity is a property of a link whose values are homogeneous (the default for structural links) and non-homogeneous (the default for procedural links).\n\n"
      },
      "date": 1647843421480
    },
    {
      "type": "edit",
      "id": "77eeb9cf91a4e6de",
      "item": {
        "type": "markdown",
        "id": "77eeb9cf91a4e6de",
        "text": "18.9 Summary \n\n* **Exhibition-characterization** is a relation between a thing and the **features** that characterize it. \n* The shorthand name of this relation is characterization and its symbol is . \n* Characterization is the only fundamental structural relation for which **all four combinations** of an object and a process, as an **exhibitor** and a **feature**, are possible. \n* A feature which is an object, is called an **attribute** , while a feature which is a process is an **operation** .\n* An attribute is **implicit** if its values are assigned directly to the exhibitor with no specification of the attribute name. \n* An attribute is **explicit** if it is a separate object that is linked to the exhibitor with an exhibition-characterization relation. \n* **Explicitness** is an attribute of an attribute whose **values are explicit (the default) and implicit**. \n* An attribute is **qualitative** if its values are non-numerical. \n* An attribute is **quantitative** if its values are numerical. \n* An **operation** is quantitative if it transforms a quantitative attribute, otherwise it is quantitative. \n* **Mode** is a property of a feature that determines whether it is qualitative (the default) or quantitative. \n* A quantitative attribute is **hard** if its value cannot be deduced or computed from other attributes. \n* A quantitative attribute is **soft** if its value can be deduced or computed from other attributes. \n* **Touch** is an attribute of a quantitative attribute which determines whether it is hard (the default) or soft. \n* A feature of an object is **inherent** if a least one of the object’s parts exhibits it. \n* A feature of an object is **emergent** if no one of the object’s parts alone exhibits it. \n* **Emergence** is a property of an object whose values are inherent (the default) and emergent. \n* A link is **homogeneous** if it connects two things that exhibit the **same perseverance value**. \n* A link is non-homogeneous if it connects two things that exhibit **opposite perseverance values**. \n* **Homogeneity** is a property of a link whose values are homogeneous (the default for structural links) and non-homogeneous (the default for procedural links).\n\n"
      },
      "date": 1649183879626
    },
    {
      "type": "edit",
      "id": "cf194dd67526d444",
      "item": {
        "type": "markdown",
        "id": "cf194dd67526d444",
        "text": "19.9 Summary\n\n* A **State** is a situation or position at which an object can exist, or a value an attribute can assume, for some period of time during its existence. \n* An **initial state** of an object B is a state at which B is upon its generation or as the system starts executing. A **final state** of an object B is a state from which B cannot exit. \n* A **default state** of an object B is the state which B is expected to be when its state is not specified. \n* **Value** is a state of an attribute, therefore it is a specialization of state. \n* In addition to being at some state, an object can also be **unstable**, when it is **in transition** between two states—the input state and the output state. \n* **State transition** is an unstable period of time for an object, which takes place when a process acts on it to change its state. \n* A **lifespan diagram** is a diagram which, for any point in time during the life of the system, shows what objects exists in the system, what state each object is at, and what processes are active. \n* A **state-specified tagged structural link** is a tagged structural link that connects a state of an object to another object or to a state of another object. \n* An **atomic state** is a state that is not combined of other states. \n* A **compound state** is a state that combines at least two other states. \n* The **state space** of an object is the **Cartesian product** of the sets of states of all the attributes and parts of the object\n\n"
      },
      "date": 1649184083067
    },
    {
      "type": "edit",
      "id": "b519a18ae0ef656c",
      "item": {
        "type": "markdown",
        "id": "b519a18ae0ef656c",
        "text": "20.9 Summary \n\n* **Generalization-specialization** is the relation between a general thing and a specialization of that thing. \n* **Classification-instantiation** is the relation between a class of things and a unique instance that belongs that class. \n* Generalization-specialization gives rise to **inheritance** from the generalized thing to the specialized one(s). \n* **Inheritance is of features (attributes and operations), structural relations and procedural relations.** \n* **For objects, states are inherited too.** \n* OPM processes specialize in a manner similar to objects. \n* States of specialized objects can **override inherited states**. \n* A **class is a template**, from which things that instantiate the class can be generated as members of that class. \n* **Instance** is a relative term. \n* A specialization in one system can be an instance in another. \n* A **process instance** is a particular occurrence of a process at a given point in time and whose involved object set is a set of object instances.\n\n"
      },
      "date": 1649184325654
    },
    {
      "type": "edit",
      "id": "2f46c1de610d8de4",
      "item": {
        "type": "markdown",
        "id": "2f46c1de610d8de4",
        "text": "21.21 Summary \n* **Complexity management** is essential for taming the complexity of real-world systems, both man-made and natural. \n* The **OPM Model Complexity Assertion** is that applying **refinement mechanisms** of **in-zooming** and **unfolding** to stateful objects or processes, OPM can conceptually model systems at any level of complexity. \n* OPM’s complexity management approach is **detail-level-based decomposition**, which is in contrast with UML and SysML approach of **aspect-based decomposition**. \n* The **completeness-clarity trade-off** is the tension between the need to specify the system such that all the model facts are represented, while maintaining a clear, comprehensible representation of the system. \n* The **three refinement-abstraction mechanisms** are unfolding–folding, in-zooming–out-zooming, and state-expressing–state-suppressing. \n* A fourth is view-creating–view-deleting. \n* **State-expressing** is showing one or more of an object’s states; **state-suppression** is hiding one or more of the object’s states. \n* Each of the **four fundamental structural relation links** may undergo unfolding and folding, so there are four kinds of unfolding-folding pairs. \n* **In-diagram unfolding** is unfolding in which the refineable and its refinees appear unfolded in the same OPD in which the refinee was originally. \n* **New-diagram unfolding** is unfolding in which the refineable and its refinees appear unfolded in a new OPD. \n* Unfolding is a mechanism for refinement, elaboration, or decomposition, which reveals a set of refineables—things that relate to the unfolded thing—the refineable . \n* A **synchronous process** is a process whose subprocesses have a predefined, fixed order. \n* An **asynchronous process** is a process whose subprocesses do not have a predefined, fixed order. \n* New-diagram in-zooming is in-zooming in which the refineable and its refinees appear in-zoomed in a new OPD. \n* In-diagram in-zooming is in-zooming in which no new OPD is created, and the refineable appear in-zoomed along with its refinees in the same OPD. \n* **In-zooming has the semantics of aggregation-participation plus positive orderability** . \n* Process in-zooming determines the (possibly partial) **temporal order** of its subprocess execution.\n* **Object in-zooming** determines the (possibly 2-dimensional) spatial order of its parts. \n* An **OPD tree** is a directed node- and edge-labeled tree graph whose nodes are OPDs obtained by recursive in-zooming or unfolding of processes in the system, starting with the function—the process in SD. \n* An **OPD set** is the set of all the nodes in the OPD tree. \n* **Detail level** of an OPD is the number of nodes in the OPD tree that need to be traversed from that OPD to the root, SD, including SD itself. \n* The **system map** is an elaborate OPD tree, in which each node in the tree is a miniaturized icon of the OPD, with thick grey arrows pointing from each process in one OPD to its refined (in-zoomed or unfolded) version in the child OPD. \n* The **ultimate OPD** is single flat representation of the OPM system model. \n* Out-zooming provides for incorporating the **middle-out approach to conceptual modeling** by simplifying a complicated OPD while adding an interim level of detail. \n* **Semantic strength** of a procedural link is the **significance** of the information that the link carries. \n* **Link precedence** is an ordered list of procedural links with **diminishing sematic strength**. \n* The **primary link precedence** is Consumption = Result > Effect > Agent > Instrument. \n* **View creating** is collecting model facts from various OPDs in the OPD set and putting them together in a new OPD called **View** for the purpose of **demonstrating a specific aspect**. \n* An **OPD model specification** is the collection of successive OPDs in the system’s OPD tree. \n* An OPL model specification is the collection of successive **OPL paragraphs** corresponding to the OPDs in the system’s OPD tree, from which **duplicate OPL sentences were removed**. \n* An OPM model specification is a **side-by-side presentation** of the OPD model specification and the OPL model specification, where to the right of each OPD the corresponding OPL paragraph is presented.\n\n"
      },
      "date": 1649185179427
    },
    {
      "type": "edit",
      "id": "c98be62c5f497fb1",
      "item": {
        "type": "markdown",
        "id": "c98be62c5f497fb1",
        "text": "22.13 Summary \n\n* An **event** is a point in time at which something significant to the system execution happens. \n* **Events and preconditions** in concert specify OPM **flow of execution control** for process performance according to the event-condition-action paradigm. \n* The **event-condition-action paradigm** stipulates that starting the performance of a process (the \"action\") has two prerequisites: an **initiating event** and **satisfaction of a precondition** derived from the preprocess object set. \n* A **control modifier** is one of the two letter symbols e and c, added to a procedural link, which add to the semantics of that link the event and condition semantics, respectively. \n* A **control link** is a procedural link with the addition of a control modifier. \n* An **event link** is a procedural link with the control modifier e, indicating initiation of the link’s destination process, **triggering** that process’ **precondition evaluation**.\n* A **condition link** is a procedural link with the control modifier c, indicating that if the precondition of the link’s destination process is **not met**, then that process is **skipped**. \n* The **skip semantics precedence OPM principle** states that skip semantics, induced by a control link, takes **precedence over wait semantics**, induced by a **non-control link**. \n* A **maximal-timed process** is a process for which the modeler determines a maximal duration. An **overtime handling process** is a time exception process that determines what to do in case the time performance of a maximal-timed process exceeds its maximal allowable time. \n* An **overtime exception link** is a procedural link from a maximal-timed process to an overtime handling process, indicating that if the duration of a maximal-timed process exceeds its maximal duration, then the overtime exception process is initiated. \n* A **minimal-timed process** is a process for which the modeler determines a minimal duration. \n* An **undertime handling process** is a time exception process that determines what to do in case the time performance of a minimal timed process falls short of its minimal duration. \n* An **undertime exception link** is a procedural link from a minimal-timed process to an undertime exception process, indicating that if the time performance of a timed process falls short of its minimal allowable time, the undertime exception process is initiated.\n\n"
      },
      "date": 1649185559706
    },
    {
      "type": "edit",
      "id": "ae9f1aab3a42e28b",
      "item": {
        "type": "markdown",
        "id": "ae9f1aab3a42e28b",
        "text": "23.9 Summary\n\n* **Logical operators**, including AND, OR, and XOR (exclusive OR) enable modeling complex conditions on performance of processes. \n* **Two or more procedural links of the same kind** that originate from, or arrive at, different points along the process ellipse circumference (the process context), have the semantics of the **logical AND** operator. \n* A **link fan** is a set of f ≥2 procedural links of the same kind that originate from a common point, or arrive at a common point, on the same object or process. \n* The **convergent end** of a link fan is the end that is common to the f fan links. \n* The **divergent end** of a link fan is the end that is not common to the f fan links. \n* A link fan with a **single dashed arc** denotes the **logical XOR** operator. \n* A link fan with a **double dashed arc** denotes the **logical OR** operator. \n* A **converging fan** is a link fan whose links point to its convergent end. \n* A **diverging fan** is a link fan whose links point to its divergent end. \n* Each one of the XOR link fans for consumption, result, effect, and enabling links and their state-specified versions has a corresponding **control-modified link fan**: an **event link fan** and a **condition link fan**. \n* **Link probability** is an optional attribute value assigned to a procedural link in a XOR diverging link fan that specifies the probability of following that particular link among the possible links in the fan link. \n* A **probabilistic link fan** is a link fan with a probability value assigned to each of its links, such that the sum of the probability values of all the links is exactly 1.\n\n\n"
      },
      "date": 1649185824387
    },
    {
      "type": "edit",
      "id": "d77a8f6af23b6fc0",
      "item": {
        "type": "markdown",
        "id": "d77a8f6af23b6fc0",
        "text": "Notes on chapter summaries from: Dori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 41-42). Springer New York. Kindle Edition. \n"
      },
      "date": 1649185922853
    },
    {
      "type": "add",
      "id": "abfcf0e53ada1c65",
      "item": {
        "type": "markdown",
        "id": "abfcf0e53ada1c65",
        "text": "1.6 Summary \n* We have started modeling the Automatic Crash Responding system using OPM. \n* OPM has **a single diagram type**: the object-process diagram (OPD). \n* OPM is built of **objects**, which exist, and of **processes**, which transform objects. \n* **Object transformation** is object creation, object consumption, or object change. \n* We recognize **processes**—Automatic Crash Responding in our example—as stand-alone OPM **building blocks** that are separate from objects. \n* Objects and processes enable concurrent modeling of the system’s **structure and behavior** in the same OPD. \n* Transformation is **object creation, consumption, or state change**.\n\n"
      },
      "after": "d77a8f6af23b6fc0",
      "date": 1649185929622
    },
    {
      "type": "edit",
      "id": "d77a8f6af23b6fc0",
      "item": {
        "type": "markdown",
        "id": "d77a8f6af23b6fc0",
        "text": "Notes on chapter summaries from: \nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 41-42). Springer New York. Kindle Edition. \n"
      },
      "date": 1649185934220
    },
    {
      "type": "edit",
      "id": "d77a8f6af23b6fc0",
      "item": {
        "type": "markdown",
        "id": "d77a8f6af23b6fc0",
        "text": "**Notes on chapter summaries from: **\nDori, Dov. Model-Based Systems Engineering with OPM and SysML (pp. 41-42). Springer New York. Kindle Edition. \n"
      },
      "date": 1649185942260
    },
    {
      "type": "fork",
      "site": "marc.tries.fed.wiki",
      "date": 1651833873153
    }
  ]
}