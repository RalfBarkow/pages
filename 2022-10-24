{
  "title": "2022-10-24",
  "story": [
    {
      "type": "paragraph",
      "id": "0dcea96e2fae3a9d",
      "text": "⇒ [[Decentralized Autonomous Organizations]] ⇒ [[Regulating DAOs]]"
    },
    {
      "type": "markdown",
      "id": "78d574f006c8caf9",
      "text": "Greta @Greta@fosstodon.org [https://fosstodon.org/@Greta/109208269619882262 fosstodon]\nComparing the digital golem diagnosed in Schneier and Farrell to that in Barbrook and Cameron.\n\nThe latter: \"Yet, although technology can store or amplify labour, it can never remove the necessity for humans to invent, build and maintain these  machines in the first place.\"\n\nThe former: \"When your words are used not to persuade or argue, but to animate a mindless entity that will exist as long as the Ethereum blockchain exists ... \"\n\n* The Californian Ideology by Richard Barbrook and Andy Cameron. [http://www.imaginaryfutures.net/2007/04/17/the-californian-ideology-2 post] ⇒ [[Californian Ideology]]\n\n* [[Regulating DAOs]]. [https://www.schneier.com/blog/archives/2022/10/regulating-daos.html post]\n"
    },
    {
      "type": "markdown",
      "id": "6be677e9dc2751b4",
      "text": " In 1996, US District Judge Marilyn Hall Patel ruled that computer code is a language, just like German or French, and that coded programs deserve First Amendment protection. That such code is also functional, instructing a computer to do something, was irrelevant to its expressive capabilities, according to Patel’s ruling. However, both a concurring and dissenting opinion argued that computer code also has the “functional purpose of controlling computers and, in that regard, does not command protection under the First Amendment.”\n\nThis disagreement highlights the awkward distinction between ordinary language and computer code. Language does not change the world, except insofar as it persuades, informs, or compels other people. Code, however, is a language where words have inherent power. Type the appropriate instructions and the computer will implement them without hesitation, second-guessing, or independence of will. They are like the words inscribed on a golem’s forehead (or the written instructions that, in some versions of the folklore, are placed in its mouth). The golem has no choice, because it is incapable of making choices. The words are code, and the golem is no different from a computer.\n"
    },
    {
      "type": "markdown",
      "id": "6bc88a9021d80c11",
      "text": "**Note**: Cf. framing, cognitive linguistics. Is language a sort of code, activating associations automatically? For example: Have no fear! This phrase would supposedly activate all the associations and emotions associated with fear.\n"
    },
    {
      "type": "markdown",
      "id": "3a547fbb43aaca5e",
      "text": "ABDEL-RAHEEM, Ahmed, 2019. Pictorial framing in moral politics: a corpus-based experimental study. New York: Routledge. Routledge studies in multimodality, 28. ISBN 978-0-429-78692-1.\n\n"
    },
    {
      "type": "markdown",
      "id": "bc442c5d24d9b1b7",
      "text": "\nPIERRO, Giuseppe Antonio, 2021. Smart-Graph: Graphical Representations for Smart Contract on the Ethereum Blockchain. In: 2021 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER). Online. Honolulu, HI, USA: IEEE. March 2021. p. 708–714. [Accessed 25 October 2022]. ISBN 978-1-72819-630-5. DOI 10.1109/SANER50967.2021.00090. \n"
    },
    {
      "type": "markdown",
      "id": "b5ba4161a73daa49",
      "text": "> The Ethereum blockchain enables executing and recording smart contracts. The smart contracts can facilitate, verify, and implement the negotiation between multiple parties, also guaranteeing transactions without a traditional legal entity. Many tools supporting the smart contracts development in different areas are ﬂourishing because in Ethereum blockchain valuable assets are often involved. Some of the tools help the developer to ﬁnd security vulnerabilities via static and/or dynamic analysis or to reduce the Gas fees consumption. Despite the plethora of such tools, there is no tool supporting smart contracts evaluation and analysis via a graphical representation for expert developers.\n"
    },
    {
      "type": "pagefold",
      "id": "db9928c0fe5c95d3",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "4f3e24531c9e655d",
      "text": "https://192.168.178.36/plinth/sys/backups/b7e15046-5365-11ed-88fe-dca632200a65/restore-archive/scheduled:%20daily,%20weekly:%202022-10-23:02:05/"
    },
    {
      "type": "markdown",
      "id": "3b5986d09145d742",
      "text": "> Proxy Error\n> \n> The proxy server received an invalid response from an upstream server.\nThe proxy server could not handle the request\n>\n> Reason: Error reading from remote server\n> \n> Apache/2.4.54 (Raspbian) Server at 192.168.178.36 Port 443"
    },
    {
      "type": "pagefold",
      "id": "0e484fe909e157c8",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "3259cf29684a81b5",
      "text": "⇒ [[SpFileDatabase]] ⇒ [[SpStrategy]]"
    },
    {
      "type": "paragraph",
      "id": "459c44eaa1b2aabe",
      "text": "Serializing Complex Objects with [[Fuel]]. [https://book.huihoo.com/smalltalk/pharo/enterprise-pharo/book-result/Fuel/Fuel.html page]"
    },
    {
      "type": "paragraph",
      "id": "9cd65a85de78f993",
      "text": "⇒ [[serialize]]"
    },
    {
      "type": "paragraph",
      "id": "67352a87928b883c",
      "text": "\"Parcels\" demonstrates very nicely that the binary pickle format can be a good alternative to textual storage and that grouping of objects makes a lot of sense in object oriented systems. "
    },
    {
      "type": "paragraph",
      "id": "efe04566dd423467",
      "text": "pickle — Python object serialization. [https://docs.python.org/3/library/pickle.html page]"
    },
    {
      "type": "paragraph",
      "id": "b462bdfcabd3e623",
      "text": "Simple Binary Data Visualization. [https://martin.varela.fi/2017/09/09/simple-binary-data-visualization/ post], [https://news.ycombinator.com/item?id=15164166 hn], [https://codisec.com/binary-data-visualization/ page], [https://github.com/codilime/veles github]"
    },
    {
      "type": "graphviz",
      "id": "f2863ac813fc7a04",
      "text": "DOT FROM lambda-browsing"
    },
    {
      "type": "paragraph",
      "id": "94f6a8751b1bb96c",
      "text": "⇒ [[The Absence of Duration]]"
    },
    {
      "type": "paragraph",
      "id": "ea430d95d2384b32",
      "text": "Simple Image Based Persistence in Squeak. [http://onsmalltalk.com/simple-image-based-persistence-in-squeak/ post]."
    },
    {
      "type": "markdown",
      "id": "e8d53b52da2603e2",
      "text": "> The basic idea is to use a [[Command Pattern]] to apply changes to your model, you can then log the commands, snapshot the model, and replay the log in case of a crash to bring the last snapshot up to date. Nice idea, if you're OK creating commands for every state-changing action in your application and being careful with how you use timestamps so replaying the logs works properly. I'm not OK with that, it introduces a level of complexity that is overkill for many apps and is likely the reason more people don't use a Prevayler like approach.\n"
    },
    {
      "type": "markdown",
      "id": "bd0326c09f4b7224",
      "text": "\nDIAS, Martín, PECK, Mariano Martinez, DUCASSE, Stéphane and ARÉVALO, Gabriela, 2012. Fuel: a fast general purpose object graph serializer: FUEL: A FAST GENERAL PURPOSE OBJECT GRAPH SERIALIZER. Software: Practice and Experience. 2012. Vol. 44, no. 4, p. 433–453. DOI 10.1002/spe.2136. \n\n\n"
    },
    {
      "type": "markdown",
      "id": "83a79de5f3a61ec0",
      "text": "> Since objects need to be stored and reloaded on different environments, serializing object graphs is a very important activity. There is a plethora of serialization frameworks with different requirements and design trade-offs. Most of them are based on recursive parsing of the object graphs, an approach which often is too slow. In addition, most of them prioritize a language-agnostic format instead of speed and language-speciﬁc object serialization. For the same reason, such serializers usually do not support features like class-shape changes, global references or executing pre and post load actions. Looking for speed, some frameworks are partially implemented at Virtual Machine (VM) level, hampering code portability and making them difﬁcult to understand, maintain and extend.\n"
    },
    {
      "type": "paragraph",
      "id": "db91c20f2398cd2f",
      "text": "In object-oriented programming, since objects point to other objects, the runtime memory is an object graph. This graph of objects lives while the system is running and dies when the system is shutdown. However, sometimes it is necessary, for example, to backup a graph of objects into a non volatile memory so that it can be loaded back when necessary [14, 13, 5] or to export it so that the objects can be loaded in a different system. The same happens when doing migrations or when communicating with different systems. Besides this, databases normally need to serialize objects to write them to disk [8]. There are a lot of other possible uses for a serializer. For example, in case of remote objects, e.g., remote method invocation and distributed systems [3, 9, 29], objects need to be serialized and passed around the network. A Version Control System that deals with code represented as first-class objects needs to serialize and materialize those objects: Parcels [17] is a typical example. Today’s web applications need to store state in the HTTP sessions and move information between the client and the server."
    },
    {
      "type": "paragraph",
      "id": "84bddb3efeef3fab",
      "text": "[…] This paper presents [[Fuel]], a fast open-source general-purpose framework to serialize and deserialize object graphs using a pickle format, which clusters similar objects."
    },
    {
      "type": "paragraph",
      "id": "c5cead2204d0f295",
      "text": "[…] To avoid confusion, we define terms used in this paper. Serializing is the process of converting the whole object graph into a sequence of bytes. We consider the words pickling and marshaling as synonyms. Materializing is the inverse process of serializing, that is, regenerate the object graph from a sequence of bytes. We consider the words deserialize, unmarshaling and unpickling as synonyms. We understand the same for object serialization, object graph serialization and object subgraph serialization. An object can be seen as a subgraph because of its pointers to other objects. At the same time, everything is a subgraph if we consider the whole memory as a large graph."
    },
    {
      "type": "paragraph",
      "id": "cad84ba578efb20c",
      "text": "⇒ [[Pickle Format]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2022-10-24",
        "story": []
      },
      "date": 1666589875543
    },
    {
      "item": {
        "type": "factory",
        "id": "0dcea96e2fae3a9d"
      },
      "id": "0dcea96e2fae3a9d",
      "type": "add",
      "date": 1666589877164
    },
    {
      "type": "edit",
      "id": "0dcea96e2fae3a9d",
      "item": {
        "type": "paragraph",
        "id": "0dcea96e2fae3a9d",
        "text": "[[Decentralized Autonomous Organizations]]"
      },
      "date": 1666589884010
    },
    {
      "type": "edit",
      "id": "0dcea96e2fae3a9d",
      "item": {
        "type": "paragraph",
        "id": "0dcea96e2fae3a9d",
        "text": "⇒ [[Decentralized Autonomous Organizations]]"
      },
      "date": 1666589893795
    },
    {
      "item": {
        "type": "factory",
        "id": "78d574f006c8caf9"
      },
      "id": "78d574f006c8caf9",
      "type": "add",
      "after": "0dcea96e2fae3a9d",
      "date": 1666589980187
    },
    {
      "type": "edit",
      "id": "78d574f006c8caf9",
      "item": {
        "type": "paragraph",
        "id": "78d574f006c8caf9",
        "text": "Greta @Greta@fosstodon.org\nComparing the digital golem diagnosed in Schneier and Farrell to that in Barbrook and Cameron.\n\nThe latter: \"Yet, although technology can store or amplify labour, it can never remove the necessity for humans to invent, build and maintain these  machines in the first place.\"\n\nThe former: \"When your words are used not to persuade or argue, but to animate a mindless entity that will exist as long as the Ethereum blockchain exists ... \"\n\nhttps://www.imaginaryfutures.net/2007/04/17/the-californian-ideology-2\n\nhttps://www.schneier.com/blog/archives/2022/10/regulating-daos.html\n0\n"
      },
      "date": 1666589983863
    },
    {
      "type": "edit",
      "id": "78d574f006c8caf9",
      "item": {
        "type": "paragraph",
        "id": "78d574f006c8caf9",
        "text": "Greta @Greta@fosstodon.org [https://fosstodon.org/@Greta/109208269619882262 fosstodon]\nComparing the digital golem diagnosed in Schneier and Farrell to that in Barbrook and Cameron.\n\nThe latter: \"Yet, although technology can store or amplify labour, it can never remove the necessity for humans to invent, build and maintain these  machines in the first place.\"\n\nThe former: \"When your words are used not to persuade or argue, but to animate a mindless entity that will exist as long as the Ethereum blockchain exists ... \"\n\nhttps://www.imaginaryfutures.net/2007/04/17/the-californian-ideology-2\n\nhttps://www.schneier.com/blog/archives/2022/10/regulating-daos.html\n0\n"
      },
      "date": 1666590087044
    },
    {
      "type": "edit",
      "id": "78d574f006c8caf9",
      "item": {
        "type": "paragraph",
        "id": "78d574f006c8caf9",
        "text": "Greta @Greta@fosstodon.org [https://fosstodon.org/@Greta/109208269619882262 fosstodon]\nComparing the digital golem diagnosed in Schneier and Farrell to that in Barbrook and Cameron.\n\nThe latter: \"Yet, although technology can store or amplify labour, it can never remove the necessity for humans to invent, build and maintain these  machines in the first place.\"\n\nThe former: \"When your words are used not to persuade or argue, but to animate a mindless entity that will exist as long as the Ethereum blockchain exists ... \"\n\n* The Californian Ideology by Richard Barbrook and Andy Cameron. [http://www.imaginaryfutures.net/2007/04/17/the-californian-ideology-2 post]\n\nhttps://www.schneier.com/blog/archives/2022/10/regulating-daos.html\n0\n"
      },
      "date": 1666590290373
    },
    {
      "type": "edit",
      "id": "78d574f006c8caf9",
      "item": {
        "type": "markdown",
        "id": "78d574f006c8caf9",
        "text": "Greta @Greta@fosstodon.org [https://fosstodon.org/@Greta/109208269619882262 fosstodon]\nComparing the digital golem diagnosed in Schneier and Farrell to that in Barbrook and Cameron.\n\nThe latter: \"Yet, although technology can store or amplify labour, it can never remove the necessity for humans to invent, build and maintain these  machines in the first place.\"\n\nThe former: \"When your words are used not to persuade or argue, but to animate a mindless entity that will exist as long as the Ethereum blockchain exists ... \"\n\n* The Californian Ideology by Richard Barbrook and Andy Cameron. [http://www.imaginaryfutures.net/2007/04/17/the-californian-ideology-2 post]\n\nhttps://www.schneier.com/blog/archives/2022/10/regulating-daos.html\n0\n"
      },
      "date": 1666590305807
    },
    {
      "item": {
        "type": "factory",
        "id": "a0e0ad25631222e1"
      },
      "id": "a0e0ad25631222e1",
      "type": "add",
      "after": "78d574f006c8caf9",
      "date": 1666590433570
    },
    {
      "type": "edit",
      "id": "a0e0ad25631222e1",
      "item": {
        "type": "paragraph",
        "id": "a0e0ad25631222e1",
        "text": "[[Californian Ideology]]"
      },
      "date": 1666590440929
    },
    {
      "type": "edit",
      "id": "a0e0ad25631222e1",
      "item": {
        "type": "paragraph",
        "id": "a0e0ad25631222e1",
        "text": "⇒ [[Californian Ideology]]"
      },
      "date": 1666590450057
    },
    {
      "item": {
        "type": "factory",
        "id": "144e1a47bbb14e58"
      },
      "id": "144e1a47bbb14e58",
      "type": "add",
      "after": "a0e0ad25631222e1",
      "date": 1666590855293
    },
    {
      "type": "edit",
      "id": "144e1a47bbb14e58",
      "item": {
        "type": "paragraph",
        "id": "144e1a47bbb14e58",
        "text": "\nRegulating DAOs - Schneier on Security, [no date]. Online. [Accessed 24 October 2022]. Available from: https://www.schneier.com/blog/archives/2022/10/regulating-daos.html\n"
      },
      "date": 1666590866320
    },
    {
      "type": "edit",
      "id": "0dcea96e2fae3a9d",
      "item": {
        "type": "paragraph",
        "id": "0dcea96e2fae3a9d",
        "text": "⇒ [[Decentralized Autonomous Organizations]] ⇒ [[Regulating DAOs]]"
      },
      "date": 1666590879010
    },
    {
      "id": "144e1a47bbb14e58",
      "type": "remove",
      "date": 1666590891181
    },
    {
      "type": "edit",
      "id": "78d574f006c8caf9",
      "item": {
        "type": "markdown",
        "id": "78d574f006c8caf9",
        "text": "Greta @Greta@fosstodon.org [https://fosstodon.org/@Greta/109208269619882262 fosstodon]\nComparing the digital golem diagnosed in Schneier and Farrell to that in Barbrook and Cameron.\n\nThe latter: \"Yet, although technology can store or amplify labour, it can never remove the necessity for humans to invent, build and maintain these  machines in the first place.\"\n\nThe former: \"When your words are used not to persuade or argue, but to animate a mindless entity that will exist as long as the Ethereum blockchain exists ... \"\n\n* The Californian Ideology by Richard Barbrook and Andy Cameron. [http://www.imaginaryfutures.net/2007/04/17/the-californian-ideology-2 post]\n\n* Regulating DAOs [https://www.schneier.com/blog/archives/2022/10/regulating-daos.html post]\n"
      },
      "date": 1666590939513
    },
    {
      "type": "edit",
      "id": "78d574f006c8caf9",
      "item": {
        "type": "markdown",
        "id": "78d574f006c8caf9",
        "text": "Greta @Greta@fosstodon.org [https://fosstodon.org/@Greta/109208269619882262 fosstodon]\nComparing the digital golem diagnosed in Schneier and Farrell to that in Barbrook and Cameron.\n\nThe latter: \"Yet, although technology can store or amplify labour, it can never remove the necessity for humans to invent, build and maintain these  machines in the first place.\"\n\nThe former: \"When your words are used not to persuade or argue, but to animate a mindless entity that will exist as long as the Ethereum blockchain exists ... \"\n\n* The Californian Ideology by Richard Barbrook and Andy Cameron. [http://www.imaginaryfutures.net/2007/04/17/the-californian-ideology-2 post]\n\n* Regulating DAOs. [https://www.schneier.com/blog/archives/2022/10/regulating-daos.html post]\n"
      },
      "date": 1666590946747
    },
    {
      "type": "remove",
      "id": "a0e0ad25631222e1",
      "date": 1666590958730
    },
    {
      "type": "edit",
      "id": "78d574f006c8caf9",
      "item": {
        "type": "markdown",
        "id": "78d574f006c8caf9",
        "text": "Greta @Greta@fosstodon.org [https://fosstodon.org/@Greta/109208269619882262 fosstodon]\nComparing the digital golem diagnosed in Schneier and Farrell to that in Barbrook and Cameron.\n\nThe latter: \"Yet, although technology can store or amplify labour, it can never remove the necessity for humans to invent, build and maintain these  machines in the first place.\"\n\nThe former: \"When your words are used not to persuade or argue, but to animate a mindless entity that will exist as long as the Ethereum blockchain exists ... \"\n\n* The Californian Ideology by Richard Barbrook and Andy Cameron. [http://www.imaginaryfutures.net/2007/04/17/the-californian-ideology-2 post] ⇒ [[Californian Ideology]]\n\n* Regulating DAOs. [https://www.schneier.com/blog/archives/2022/10/regulating-daos.html post]\n"
      },
      "date": 1666590963527
    },
    {
      "type": "edit",
      "id": "78d574f006c8caf9",
      "item": {
        "type": "markdown",
        "id": "78d574f006c8caf9",
        "text": "Greta @Greta@fosstodon.org [https://fosstodon.org/@Greta/109208269619882262 fosstodon]\nComparing the digital golem diagnosed in Schneier and Farrell to that in Barbrook and Cameron.\n\nThe latter: \"Yet, although technology can store or amplify labour, it can never remove the necessity for humans to invent, build and maintain these  machines in the first place.\"\n\nThe former: \"When your words are used not to persuade or argue, but to animate a mindless entity that will exist as long as the Ethereum blockchain exists ... \"\n\n* The Californian Ideology by Richard Barbrook and Andy Cameron. [http://www.imaginaryfutures.net/2007/04/17/the-californian-ideology-2 post] ⇒ [[Californian Ideology]]\n\n* [[Regulating DAOs]]. [https://www.schneier.com/blog/archives/2022/10/regulating-daos.html post]\n"
      },
      "date": 1666590986571
    },
    {
      "item": {
        "type": "factory",
        "id": "14daaf517eced8ee"
      },
      "id": "14daaf517eced8ee",
      "type": "add",
      "after": "78d574f006c8caf9",
      "date": 1666593644588
    },
    {
      "item": {
        "type": "factory",
        "id": "db9928c0fe5c95d3"
      },
      "id": "db9928c0fe5c95d3",
      "type": "add",
      "after": "14daaf517eced8ee",
      "date": 1666593650693
    },
    {
      "type": "remove",
      "id": "14daaf517eced8ee",
      "date": 1666593653527
    },
    {
      "type": "edit",
      "id": "db9928c0fe5c95d3",
      "item": {
        "type": "pagefold",
        "id": "db9928c0fe5c95d3",
        "text": "~"
      },
      "date": 1666593656858
    },
    {
      "item": {
        "type": "factory",
        "id": "4f3e24531c9e655d"
      },
      "id": "4f3e24531c9e655d",
      "type": "add",
      "after": "db9928c0fe5c95d3",
      "date": 1666593658550
    },
    {
      "type": "edit",
      "id": "4f3e24531c9e655d",
      "item": {
        "type": "paragraph",
        "id": "4f3e24531c9e655d",
        "text": "https://192.168.178.36/plinth/sys/backups/b7e15046-5365-11ed-88fe-dca632200a65/restore-archive/scheduled:%20daily,%20weekly:%202022-10-23:02:05/"
      },
      "date": 1666593660671
    },
    {
      "item": {
        "type": "factory",
        "id": "3b5986d09145d742"
      },
      "id": "3b5986d09145d742",
      "type": "add",
      "after": "4f3e24531c9e655d",
      "date": 1666593675887
    },
    {
      "type": "edit",
      "id": "3b5986d09145d742",
      "item": {
        "type": "markdown",
        "id": "3b5986d09145d742",
        "text": "> Proxy Error\n\nThe proxy server received an invalid response from an upstream server.\nThe proxy server could not handle the request\n\nReason: Error reading from remote server\n\nApache/2.4.54 (Raspbian) Server at 192.168.178.36 Port 443"
      },
      "date": 1666593705186
    },
    {
      "type": "edit",
      "id": "3b5986d09145d742",
      "item": {
        "type": "markdown",
        "id": "3b5986d09145d742",
        "text": "> Proxy Error\n> \n> The proxy server received an invalid response from an upstream server.\nThe proxy server could not handle the request\n>\n> Reason: Error reading from remote server\n> \n> Apache/2.4.54 (Raspbian) Server at 192.168.178.36 Port 443"
      },
      "date": 1666593723950
    },
    {
      "item": {
        "type": "factory",
        "id": "2900597fe0238c21"
      },
      "id": "2900597fe0238c21",
      "type": "add",
      "after": "3b5986d09145d742",
      "date": 1666620615805
    },
    {
      "type": "remove",
      "id": "2900597fe0238c21",
      "date": 1666620619135
    },
    {
      "item": {
        "type": "factory",
        "id": "0e484fe909e157c8"
      },
      "id": "0e484fe909e157c8",
      "type": "add",
      "after": "3b5986d09145d742",
      "date": 1666620620668
    },
    {
      "type": "edit",
      "id": "0e484fe909e157c8",
      "item": {
        "type": "pagefold",
        "id": "0e484fe909e157c8",
        "text": "~"
      },
      "date": 1666620624654
    },
    {
      "item": {
        "type": "factory",
        "id": "459c44eaa1b2aabe"
      },
      "id": "459c44eaa1b2aabe",
      "type": "add",
      "after": "0e484fe909e157c8",
      "date": 1666620626790
    },
    {
      "type": "edit",
      "id": "459c44eaa1b2aabe",
      "item": {
        "type": "paragraph",
        "id": "459c44eaa1b2aabe",
        "text": "Serializing Complex Objects with Fuel"
      },
      "date": 1666620635423
    },
    {
      "type": "edit",
      "id": "459c44eaa1b2aabe",
      "item": {
        "type": "paragraph",
        "id": "459c44eaa1b2aabe",
        "text": "Serializing Complex Objects with [[Fuel]]. [https://book.huihoo.com/smalltalk/pharo/enterprise-pharo/book-result/Fuel/Fuel.html page]"
      },
      "date": 1666620653390
    },
    {
      "item": {
        "type": "factory",
        "id": "9cd65a85de78f993"
      },
      "id": "9cd65a85de78f993",
      "type": "add",
      "after": "459c44eaa1b2aabe",
      "date": 1666620838721
    },
    {
      "type": "edit",
      "id": "9cd65a85de78f993",
      "item": {
        "type": "paragraph",
        "id": "9cd65a85de78f993",
        "text": "[[serialize]]"
      },
      "date": 1666620845272
    },
    {
      "type": "edit",
      "id": "9cd65a85de78f993",
      "item": {
        "type": "paragraph",
        "id": "9cd65a85de78f993",
        "text": "⇒ [[serialize]]"
      },
      "date": 1666620851681
    },
    {
      "item": {
        "type": "factory",
        "id": "efe04566dd423467"
      },
      "id": "efe04566dd423467",
      "type": "add",
      "after": "9cd65a85de78f993",
      "date": 1666621225930
    },
    {
      "type": "edit",
      "id": "efe04566dd423467",
      "item": {
        "type": "paragraph",
        "id": "efe04566dd423467",
        "text": "pickle — Python object serialization¶"
      },
      "date": 1666621234029
    },
    {
      "item": {
        "type": "factory",
        "id": "67352a87928b883c"
      },
      "id": "67352a87928b883c",
      "type": "add",
      "after": "efe04566dd423467",
      "date": 1666621244262
    },
    {
      "type": "edit",
      "id": "67352a87928b883c",
      "item": {
        "type": "paragraph",
        "id": "67352a87928b883c",
        "text": "\"Parcels\" demonstrates very nicely that the binary pickle format can be a good alternative to textual storage and that grouping of objects makes a lot of sense in object oriented systems. "
      },
      "date": 1666621246502
    },
    {
      "id": "67352a87928b883c",
      "type": "move",
      "order": [
        "0dcea96e2fae3a9d",
        "78d574f006c8caf9",
        "db9928c0fe5c95d3",
        "4f3e24531c9e655d",
        "3b5986d09145d742",
        "0e484fe909e157c8",
        "459c44eaa1b2aabe",
        "9cd65a85de78f993",
        "67352a87928b883c",
        "efe04566dd423467"
      ],
      "date": 1666621248120
    },
    {
      "type": "edit",
      "id": "efe04566dd423467",
      "item": {
        "type": "paragraph",
        "id": "efe04566dd423467",
        "text": "pickle — Python object serialization"
      },
      "date": 1666621251891
    },
    {
      "type": "edit",
      "id": "efe04566dd423467",
      "item": {
        "type": "paragraph",
        "id": "efe04566dd423467",
        "text": "pickle — Python object serialization. [https://docs.python.org/3/library/pickle.html page]"
      },
      "date": 1666621266580
    },
    {
      "item": {
        "type": "factory",
        "id": "b462bdfcabd3e623"
      },
      "id": "b462bdfcabd3e623",
      "type": "add",
      "after": "efe04566dd423467",
      "date": 1666621360426
    },
    {
      "type": "edit",
      "id": "b462bdfcabd3e623",
      "item": {
        "type": "paragraph",
        "id": "b462bdfcabd3e623",
        "text": "Simple Binary Data Visualization"
      },
      "date": 1666621364996
    },
    {
      "type": "edit",
      "id": "b462bdfcabd3e623",
      "item": {
        "type": "paragraph",
        "id": "b462bdfcabd3e623",
        "text": "Simple Binary Data Visualization. [https://martin.varela.fi/2017/09/09/simple-binary-data-visualization/ post]"
      },
      "date": 1666621376086
    },
    {
      "type": "edit",
      "id": "b462bdfcabd3e623",
      "item": {
        "type": "paragraph",
        "id": "b462bdfcabd3e623",
        "text": "Simple Binary Data Visualization. [https://martin.varela.fi/2017/09/09/simple-binary-data-visualization/ post], [https://news.ycombinator.com/item?id=15164166 hn]"
      },
      "date": 1666621393887
    },
    {
      "type": "edit",
      "id": "b462bdfcabd3e623",
      "item": {
        "type": "paragraph",
        "id": "b462bdfcabd3e623",
        "text": "Simple Binary Data Visualization. [https://martin.varela.fi/2017/09/09/simple-binary-data-visualization/ post], [https://news.ycombinator.com/item?id=15164166 hn], [https://codisec.com/binary-data-visualization/ page]"
      },
      "date": 1666621418602
    },
    {
      "type": "edit",
      "id": "b462bdfcabd3e623",
      "item": {
        "type": "paragraph",
        "id": "b462bdfcabd3e623",
        "text": "Simple Binary Data Visualization. [https://martin.varela.fi/2017/09/09/simple-binary-data-visualization/ post], [https://news.ycombinator.com/item?id=15164166 hn], [https://codisec.com/binary-data-visualization/ page], [https://github.com/codilime/veles github]"
      },
      "date": 1666622183604
    },
    {
      "item": {
        "type": "factory",
        "id": "3259cf29684a81b5"
      },
      "id": "3259cf29684a81b5",
      "type": "add",
      "after": "b462bdfcabd3e623",
      "date": 1666622475249
    },
    {
      "type": "edit",
      "id": "3259cf29684a81b5",
      "item": {
        "type": "paragraph",
        "id": "3259cf29684a81b5",
        "text": "SpFileDatabase"
      },
      "date": 1666622479090
    },
    {
      "type": "edit",
      "id": "3259cf29684a81b5",
      "item": {
        "type": "paragraph",
        "id": "3259cf29684a81b5",
        "text": "⇒ [[SpFileDatabase]]"
      },
      "date": 1666622491500
    },
    {
      "type": "add",
      "id": "6be677e9dc2751b4",
      "item": {
        "type": "markdown",
        "id": "6be677e9dc2751b4",
        "text": " In 1996, US District Judge Marilyn Hall Patel ruled that computer code is a language, just like German or French, and that coded programs deserve First Amendment protection. That such code is also functional, instructing a computer to do something, was irrelevant to its expressive capabilities, according to Patel’s ruling. However, both a concurring and dissenting opinion argued that computer code also has the “functional purpose of controlling computers and, in that regard, does not command protection under the First Amendment.”\n\nThis disagreement highlights the awkward distinction between ordinary language and computer code. Language does not change the world, except insofar as it persuades, informs, or compels other people. Code, however, is a language where words have inherent power. Type the appropriate instructions and the computer will implement them without hesitation, second-guessing, or independence of will. They are like the words inscribed on a golem’s forehead (or the written instructions that, in some versions of the folklore, are placed in its mouth). The golem has no choice, because it is incapable of making choices. The words are code, and the golem is no different from a computer."
      },
      "after": "78d574f006c8caf9",
      "date": 1666623770438
    },
    {
      "type": "edit",
      "id": "6be677e9dc2751b4",
      "item": {
        "type": "markdown",
        "id": "6be677e9dc2751b4",
        "text": " In 1996, US District Judge Marilyn Hall Patel ruled that computer code is a language, just like German or French, and that coded programs deserve First Amendment protection. That such code is also functional, instructing a computer to do something, was irrelevant to its expressive capabilities, according to Patel’s ruling. However, both a concurring and dissenting opinion argued that computer code also has the “functional purpose of controlling computers and, in that regard, does not command protection under the First Amendment.”\n\nThis disagreement highlights the awkward distinction between ordinary language and computer code. Language does not change the world, except insofar as it persuades, informs, or compels other people. Code, however, is a language where words have inherent power. Type the appropriate instructions and the computer will implement them without hesitation, second-guessing, or independence of will. They are like the words inscribed on a golem’s forehead (or the written instructions that, in some versions of the folklore, are placed in its mouth). The golem has no choice, because it is incapable of making choices. The words are code, and the golem is no different from a computer.\n"
      },
      "date": 1666623794773
    },
    {
      "type": "add",
      "id": "6bc88a9021d80c11",
      "item": {
        "type": "markdown",
        "id": "6bc88a9021d80c11",
        "text": "**Note**: framing, cognitive linguistics. Is language a sort of code, activating associations automatically? For example: "
      },
      "after": "6be677e9dc2751b4",
      "date": 1666623849225
    },
    {
      "type": "edit",
      "id": "6bc88a9021d80c11",
      "item": {
        "type": "markdown",
        "id": "6bc88a9021d80c11",
        "text": "**Note**: framing, cognitive linguistics. Is language a sort of code, activating associations automatically? For example: Have no fear! "
      },
      "date": 1666623882586
    },
    {
      "type": "edit",
      "id": "6bc88a9021d80c11",
      "item": {
        "type": "markdown",
        "id": "6bc88a9021d80c11",
        "text": "**Note**: framing, cognitive linguistics. Is language a sort of code, activating associations automatically? For example: Have no fear! This phrase would supposedly activate all the associations and emotions associated with fear."
      },
      "date": 1666623917441
    },
    {
      "id": "3259cf29684a81b5",
      "type": "move",
      "order": [
        "0dcea96e2fae3a9d",
        "78d574f006c8caf9",
        "6be677e9dc2751b4",
        "6bc88a9021d80c11",
        "db9928c0fe5c95d3",
        "4f3e24531c9e655d",
        "3b5986d09145d742",
        "0e484fe909e157c8",
        "3259cf29684a81b5",
        "459c44eaa1b2aabe",
        "9cd65a85de78f993",
        "67352a87928b883c",
        "efe04566dd423467",
        "b462bdfcabd3e623"
      ],
      "date": 1666624062331
    },
    {
      "item": {
        "type": "factory",
        "id": "f2863ac813fc7a04"
      },
      "id": "f2863ac813fc7a04",
      "type": "add",
      "after": "b462bdfcabd3e623",
      "date": 1666624064063
    },
    {
      "type": "edit",
      "id": "f2863ac813fc7a04",
      "item": {
        "type": "graphviz",
        "id": "f2863ac813fc7a04",
        "text": "DOT FROM lambda-browsing"
      },
      "date": 1666624074843
    },
    {
      "type": "edit",
      "id": "6bc88a9021d80c11",
      "item": {
        "type": "markdown",
        "id": "6bc88a9021d80c11",
        "text": "**Note**: Cf. framing, cognitive linguistics. Is language a sort of code, activating associations automatically? For example: Have no fear! This phrase would supposedly activate all the associations and emotions associated with fear."
      },
      "date": 1666624138327
    },
    {
      "type": "edit",
      "id": "6bc88a9021d80c11",
      "item": {
        "type": "markdown",
        "id": "6bc88a9021d80c11",
        "text": "**Note**: Cf. framing, cognitive linguistics. Is language a sort of code, activating associations automatically? For example: Have no fear! This phrase would supposedly activate all the associations and emotions associated with fear.\n"
      },
      "date": 1666626438703
    },
    {
      "type": "add",
      "id": "3a547fbb43aaca5e",
      "item": {
        "type": "markdown",
        "id": "3a547fbb43aaca5e",
        "text": "\nABDEL-RAHEEM, Ahmed, 2019. Pictorial framing in moral politics: a corpus-based experimental study. . New York: Routledge. Routledge studies in multimodality, 28. ISBN 978-0-429-78692-1. P93.5\n"
      },
      "after": "6bc88a9021d80c11",
      "date": 1666626439928
    },
    {
      "type": "edit",
      "id": "3a547fbb43aaca5e",
      "item": {
        "type": "markdown",
        "id": "3a547fbb43aaca5e",
        "text": "ABDEL-RAHEEM, Ahmed, 2019. Pictorial framing in moral politics: a corpus-based experimental study. New York: Routledge. Routledge studies in multimodality, 28. ISBN 978-0-429-78692-1. P93.5\n"
      },
      "date": 1666626446774
    },
    {
      "type": "edit",
      "id": "3a547fbb43aaca5e",
      "item": {
        "type": "markdown",
        "id": "3a547fbb43aaca5e",
        "text": "ABDEL-RAHEEM, Ahmed, 2019. Pictorial framing in moral politics: a corpus-based experimental study. New York: Routledge. Routledge studies in multimodality, 28. ISBN 978-0-429-78692-1.\n"
      },
      "date": 1666626457861
    },
    {
      "type": "edit",
      "id": "3259cf29684a81b5",
      "item": {
        "type": "paragraph",
        "id": "3259cf29684a81b5",
        "text": "⇒ [[SpFileDatabase]] ⇒ [[SpStrategy]]"
      },
      "date": 1666626791908
    },
    {
      "item": {
        "type": "factory",
        "id": "e8d53b52da2603e2"
      },
      "id": "e8d53b52da2603e2",
      "type": "add",
      "after": "f2863ac813fc7a04",
      "date": 1666629202217
    },
    {
      "type": "edit",
      "id": "e8d53b52da2603e2",
      "item": {
        "type": "markdown",
        "id": "e8d53b52da2603e2",
        "text": "> Did you rename SpSerializer to SpStrategy?"
      },
      "date": 1666629206559
    },
    {
      "type": "edit",
      "id": "e8d53b52da2603e2",
      "item": {
        "type": "markdown",
        "id": "e8d53b52da2603e2",
        "text": "> The basic idea is to use a command pattern to apply changes to your model, you can then log the commands, snapshot the model, and replay the log in case of a crash to bring the last snapshot up to date. Nice idea, if you're OK creating commands for every state-changing action in your application and being careful with how you use timestamps so replaying the logs works properly. I'm not OK with that, it introduces a level of complexity that is overkill for many apps and is likely the reason more people don't use a Prevayler like approach."
      },
      "date": 1666629216512
    },
    {
      "item": {
        "type": "factory",
        "id": "ea430d95d2384b32"
      },
      "id": "ea430d95d2384b32",
      "type": "add",
      "after": "e8d53b52da2603e2",
      "date": 1666629224662
    },
    {
      "type": "edit",
      "id": "ea430d95d2384b32",
      "item": {
        "type": "paragraph",
        "id": "ea430d95d2384b32",
        "text": "Simple Image Based Persistence in Squeak"
      },
      "date": 1666629228419
    },
    {
      "id": "ea430d95d2384b32",
      "type": "move",
      "order": [
        "0dcea96e2fae3a9d",
        "78d574f006c8caf9",
        "6be677e9dc2751b4",
        "6bc88a9021d80c11",
        "3a547fbb43aaca5e",
        "db9928c0fe5c95d3",
        "4f3e24531c9e655d",
        "3b5986d09145d742",
        "0e484fe909e157c8",
        "3259cf29684a81b5",
        "459c44eaa1b2aabe",
        "9cd65a85de78f993",
        "67352a87928b883c",
        "efe04566dd423467",
        "b462bdfcabd3e623",
        "f2863ac813fc7a04",
        "ea430d95d2384b32",
        "e8d53b52da2603e2"
      ],
      "date": 1666629230567
    },
    {
      "type": "edit",
      "id": "ea430d95d2384b32",
      "item": {
        "type": "paragraph",
        "id": "ea430d95d2384b32",
        "text": "Simple Image Based Persistence in Squeak. [http://onsmalltalk.com/simple-image-based-persistence-in-squeak/ post]."
      },
      "date": 1666629248366
    },
    {
      "type": "edit",
      "id": "e8d53b52da2603e2",
      "item": {
        "type": "markdown",
        "id": "e8d53b52da2603e2",
        "text": "> The basic idea is to use a [[command pattern]] to apply changes to your model, you can then log the commands, snapshot the model, and replay the log in case of a crash to bring the last snapshot up to date. Nice idea, if you're OK creating commands for every state-changing action in your application and being careful with how you use timestamps so replaying the logs works properly. I'm not OK with that, it introduces a level of complexity that is overkill for many apps and is likely the reason more people don't use a Prevayler like approach."
      },
      "date": 1666629290751
    },
    {
      "type": "edit",
      "id": "e8d53b52da2603e2",
      "item": {
        "type": "markdown",
        "id": "e8d53b52da2603e2",
        "text": "> The basic idea is to use a [[Command Pattern]] to apply changes to your model, you can then log the commands, snapshot the model, and replay the log in case of a crash to bring the last snapshot up to date. Nice idea, if you're OK creating commands for every state-changing action in your application and being careful with how you use timestamps so replaying the logs works properly. I'm not OK with that, it introduces a level of complexity that is overkill for many apps and is likely the reason more people don't use a Prevayler like approach."
      },
      "date": 1666629316940
    },
    {
      "item": {
        "type": "factory",
        "id": "94f6a8751b1bb96c"
      },
      "id": "94f6a8751b1bb96c",
      "type": "add",
      "after": "e8d53b52da2603e2",
      "date": 1666641561615
    },
    {
      "type": "edit",
      "id": "94f6a8751b1bb96c",
      "item": {
        "type": "paragraph",
        "id": "94f6a8751b1bb96c",
        "text": "[[The Absence of Duration]]"
      },
      "date": 1666641572481
    },
    {
      "type": "edit",
      "id": "94f6a8751b1bb96c",
      "item": {
        "type": "paragraph",
        "id": "94f6a8751b1bb96c",
        "text": "⇒ [[The Absence of Duration]]"
      },
      "date": 1666641582565
    },
    {
      "item": {
        "type": "factory",
        "id": "3eae14a4340e8310"
      },
      "id": "3eae14a4340e8310",
      "type": "add",
      "after": "94f6a8751b1bb96c",
      "date": 1666642886786
    },
    {
      "type": "edit",
      "id": "3eae14a4340e8310",
      "item": {
        "type": "pagefold",
        "id": "3eae14a4340e8310",
        "text": "In object-oriented programming, since objects point to other objects, the runtime memory is an object graph. This graph of objects lives while the system is running and dies when the system is shutdown. However, sometimes it is necessary, for example, to backup a graph of objects into a non volatile memory so that it can be loaded back when necessary [14, 13, 5] or to export it so that the objects can be loaded in a different system. The same happens when doing migrations or when communicating with different systems. Besides this, databases normally need to serialize objects to write them to disk [8]. There are a lot of other possible uses for a serializer. For example, in case of remote objects, e.g., remote method invocation and distributed systems [3, 9, 29], objects need to be serialized and passed around the network. A Version Control System that deals with code represented as first-class objects needs to serialize and materialize those objects: Parcels [17] is a typical example. Today’s web applications need to store state in the HTTP sessions and move information between the client and the server."
      },
      "date": 1666642902215
    },
    {
      "type": "remove",
      "id": "3eae14a4340e8310",
      "date": 1666642909818
    },
    {
      "item": {
        "type": "factory",
        "id": "db91c20f2398cd2f"
      },
      "id": "db91c20f2398cd2f",
      "type": "add",
      "after": "94f6a8751b1bb96c",
      "date": 1666642911685
    },
    {
      "type": "edit",
      "id": "db91c20f2398cd2f",
      "item": {
        "type": "paragraph",
        "id": "db91c20f2398cd2f",
        "text": "In object-oriented programming, since objects point to other objects, the runtime memory is an object graph. This graph of objects lives while the system is running and dies when the system is shutdown. However, sometimes it is necessary, for example, to backup a graph of objects into a non volatile memory so that it can be loaded back when necessary [14, 13, 5] or to export it so that the objects can be loaded in a different system. The same happens when doing migrations or when communicating with different systems. Besides this, databases normally need to serialize objects to write them to disk [8]. There are a lot of other possible uses for a serializer. For example, in case of remote objects, e.g., remote method invocation and distributed systems [3, 9, 29], objects need to be serialized and passed around the network. A Version Control System that deals with code represented as first-class objects needs to serialize and materialize those objects: Parcels [17] is a typical example. Today’s web applications need to store state in the HTTP sessions and move information between the client and the server."
      },
      "date": 1666642913842
    },
    {
      "id": "94f6a8751b1bb96c",
      "type": "move",
      "order": [
        "0dcea96e2fae3a9d",
        "78d574f006c8caf9",
        "6be677e9dc2751b4",
        "6bc88a9021d80c11",
        "3a547fbb43aaca5e",
        "db9928c0fe5c95d3",
        "4f3e24531c9e655d",
        "3b5986d09145d742",
        "0e484fe909e157c8",
        "3259cf29684a81b5",
        "459c44eaa1b2aabe",
        "9cd65a85de78f993",
        "67352a87928b883c",
        "efe04566dd423467",
        "b462bdfcabd3e623",
        "f2863ac813fc7a04",
        "94f6a8751b1bb96c",
        "ea430d95d2384b32",
        "e8d53b52da2603e2",
        "db91c20f2398cd2f"
      ],
      "date": 1666642933544
    },
    {
      "item": {
        "type": "factory",
        "id": "84bddb3efeef3fab"
      },
      "id": "84bddb3efeef3fab",
      "type": "add",
      "after": "db91c20f2398cd2f",
      "date": 1666643220935
    },
    {
      "type": "edit",
      "id": "84bddb3efeef3fab",
      "item": {
        "type": "paragraph",
        "id": "84bddb3efeef3fab",
        "text": "[…] This paper presents [[Fuel]], a fast open-source general-purpose framework to serialize and deserialize object graphs using a pickle format, which clusters similar objects."
      },
      "date": 1666643232729
    },
    {
      "type": "edit",
      "id": "e8d53b52da2603e2",
      "item": {
        "type": "markdown",
        "id": "e8d53b52da2603e2",
        "text": "> The basic idea is to use a [[Command Pattern]] to apply changes to your model, you can then log the commands, snapshot the model, and replay the log in case of a crash to bring the last snapshot up to date. Nice idea, if you're OK creating commands for every state-changing action in your application and being careful with how you use timestamps so replaying the logs works properly. I'm not OK with that, it introduces a level of complexity that is overkill for many apps and is likely the reason more people don't use a Prevayler like approach.\n"
      },
      "date": 1666643318735
    },
    {
      "type": "add",
      "id": "bd0326c09f4b7224",
      "item": {
        "type": "markdown",
        "id": "bd0326c09f4b7224",
        "text": "\nDIAS, Martín, PECK, Mariano Martinez, DUCASSE, Stéphane and ARÉVALO, Gabriela, 2012. Fuel: a fast general purpose object graph serializer: FUEL: A FAST GENERAL PURPOSE OBJECT GRAPH SERIALIZER. Software: Practice and Experience. 2012. Vol. 44, no. 4, p. 433–453. DOI 10.1002/spe.2136. \n\n\n"
      },
      "after": "e8d53b52da2603e2",
      "date": 1666643332864
    },
    {
      "type": "add",
      "id": "83a79de5f3a61ec0",
      "item": {
        "type": "markdown",
        "id": "83a79de5f3a61ec0",
        "text": "> Since objects need to be stored and reloaded on different environments, serializing object graphs is a very important activity. There is a plethora of serialization frameworks with different requirements and design trade-offs. Most of them are based on recursive parsing of the object graphs, an approach which often is too slow. In addition, most of them prioritize a language-agnostic format instead of speed and language-speciﬁc object serialization. For the same reason, such serializers usually do not support features like class-shape changes, global references or executing pre and post load actions. Looking for speed, some frameworks are partially implemented at Virtual Machine (VM) level, hampering code portability and making them difﬁcult to understand, maintain and extend.\n"
      },
      "after": "bd0326c09f4b7224",
      "date": 1666643333427
    },
    {
      "item": {
        "type": "factory",
        "id": "c5cead2204d0f295"
      },
      "id": "c5cead2204d0f295",
      "type": "add",
      "after": "84bddb3efeef3fab",
      "date": 1666643510299
    },
    {
      "type": "edit",
      "id": "c5cead2204d0f295",
      "item": {
        "type": "paragraph",
        "id": "c5cead2204d0f295",
        "text": "[…] To avoid confusion, we define terms used in this paper. Serializing is the process of converting the whole object graph into a sequence of bytes. We consider the words pickling and marshaling as synonyms. Materializing is the inverse process of serializing, that is, regenerate the object graph from a sequence of bytes. We consider the words deserialize, unmarshaling and unpickling as synonyms. We understand the same for object serialization, object graph serialization and object subgraph serialization. An object can be seen as a subgraph because of its pointers to other objects. At the same time, everything is a subgraph if we consider the whole memory as a large graph."
      },
      "date": 1666643515484
    },
    {
      "item": {
        "type": "factory",
        "id": "cad84ba578efb20c"
      },
      "id": "cad84ba578efb20c",
      "type": "add",
      "after": "c5cead2204d0f295",
      "date": 1666643616567
    },
    {
      "type": "edit",
      "id": "cad84ba578efb20c",
      "item": {
        "type": "paragraph",
        "id": "cad84ba578efb20c",
        "text": "[[Pickle format]]"
      },
      "date": 1666643624971
    },
    {
      "type": "edit",
      "id": "cad84ba578efb20c",
      "item": {
        "type": "paragraph",
        "id": "cad84ba578efb20c",
        "text": "[[Pickle Format]]"
      },
      "date": 1666643645227
    },
    {
      "type": "edit",
      "id": "cad84ba578efb20c",
      "item": {
        "type": "paragraph",
        "id": "cad84ba578efb20c",
        "text": "⇒ [[Pickle Format]]"
      },
      "date": 1666643660345
    },
    {
      "type": "edit",
      "id": "3a547fbb43aaca5e",
      "item": {
        "type": "markdown",
        "id": "3a547fbb43aaca5e",
        "text": "ABDEL-RAHEEM, Ahmed, 2019. Pictorial framing in moral politics: a corpus-based experimental study. New York: Routledge. Routledge studies in multimodality, 28. ISBN 978-0-429-78692-1.\n\n"
      },
      "date": 1666649493502
    },
    {
      "type": "add",
      "id": "bc442c5d24d9b1b7",
      "item": {
        "type": "markdown",
        "id": "bc442c5d24d9b1b7",
        "text": "\nPIERRO, Giuseppe Antonio, 2021. Smart-Graph: Graphical Representations for Smart Contract on the Ethereum Blockchain. In: 2021 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER). Online. Honolulu, HI, USA: IEEE. March 2021. p. 708–714. [Accessed 25 October 2022]. ISBN 978-1-72819-630-5. DOI 10.1109/SANER50967.2021.00090. \n"
      },
      "after": "3a547fbb43aaca5e",
      "date": 1666649505316
    },
    {
      "type": "add",
      "id": "b5ba4161a73daa49",
      "item": {
        "type": "markdown",
        "id": "b5ba4161a73daa49",
        "text": "> The Ethereum blockchain enables executing and recording smart contracts. The smart contracts can facilitate, verify, and implement the negotiation between multiple parties, also guaranteeing transactions without a traditional legal entity. Many tools supporting the smart contracts development in different areas are ﬂourishing because in Ethereum blockchain valuable assets are often involved. Some of the tools help the developer to ﬁnd security vulnerabilities via static and/or dynamic analysis or to reduce the Gas fees consumption. Despite the plethora of such tools, there is no tool supporting smart contracts evaluation and analysis via a graphical representation for expert developers.\n"
      },
      "after": "bc442c5d24d9b1b7",
      "date": 1666649505885
    }
  ]
}