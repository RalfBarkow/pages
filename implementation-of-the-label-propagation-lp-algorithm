{
  "title": "Implementation of the Label Propagation (LP) algorithm",
  "story": [
    {
      "type": "paragraph",
      "id": "e47cc9cf1efd279b",
      "text": "Here's an implementation of the Label Propagation (LP) algorithm based on the provided procedure:"
    },
    {
      "type": "code",
      "id": "76a18fe0b3d6132e",
      "text": "// Function to initialize labels at all nodes\nfunction initializeLabels(graph) {\n    const labels = new Map();\n    graph.nodes.forEach(node => {\n        labels.set(node, node); // Initialize label at each node to itself\n    });\n    return labels;\n}"
    },
    {
      "type": "markdown",
      "id": "37e8bcd26b0207b8",
      "text": "# Shuffle"
    },
    {
      "type": "code",
      "id": "06201cdfbb888971",
      "text": "// Function to randomly shuffle an array\nfunction shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n}"
    },
    {
      "type": "code",
      "id": "4f46952fb4a34d06",
      "text": "// Function to randomly shuffle an array\nfunction shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n}"
    },
    {
      "type": "paragraph",
      "id": "8d14a08da81e3077",
      "text": "⇒ [[Linear Shuffle]] ⇒ [[shuffle]] ⇒ [[Shuffled Cards]]"
    },
    {
      "type": "code",
      "id": "b035ad7664d1a495",
      "text": "// Function to apply Label Propagation algorithm\nfunction labelPropagation(graph, tmax) {\n    const labels = initializeLabels(graph);\n\n    let t = 0;\n    while (t < tmax) {\n        let changed = false;\n        const nodes = shuffleArray(Array.from(graph.nodes)); // Randomize node order\n\n        nodes.forEach(node => {\n            const neighbors = graph.neighbors(node);\n            const neighborLabels = Array.from(neighbors.values()).map(neighbor => labels.get(neighbor));\n            const frequencies = new Map();\n\n            // Count frequencies of neighbor labels\n            neighborLabels.forEach(label => {\n                frequencies.set(label, (frequencies.get(label) || 0) + 1);\n            });\n\n            // Find label with highest frequency (ties broken randomly)\n            const maxFrequency = Math.max(...frequencies.values());\n            const maxLabels = Array.from(frequencies.entries()).filter(([label, freq]) => freq === maxFrequency);\n            const newLabel = maxLabels[Math.floor(Math.random() * maxLabels.length)][0];\n\n            // Update label if different from current label\n            if (newLabel !== labels.get(node)) {\n                labels.set(node, newLabel);\n                changed = true;\n            }\n        });\n\n        if (!changed) {\n            break; // Stop if no label changes occurred\n        }\n\n        t++;\n    }\n\n    return labels;\n}"
    },
    {
      "type": "code",
      "id": "9d7c3814458dc58f",
      "text": "// Example usage:\n// Assuming you have a graph object called 'graph'\nconst tmax = 100; // Maximum number of iterations\nconst communityLabels = labelPropagation(graph, tmax);\nconsole.log(\"Community Labels:\", communityLabels);"
    },
    {
      "type": "paragraph",
      "id": "0b30b229a689cc09",
      "text": "This implementation follows the steps outlined in the LP algorithm procedure. It initializes labels at all nodes, then iteratively updates the labels based on the labels of neighboring nodes until convergence or until reaching the maximum number of iterations (tmax). (ChatGPT 3.5)"
    },
    {
      "type": "pagefold",
      "id": "46c47ba73c9feace",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "7eb52230692290b1",
      "text": "COSCIA, Michele, ROSSETTI, Giulio, GIANNOTTI, Fosca and PEDRESCHI, Dino, 2012. DEMON: a local-first discovery method for overlapping communities. In: Proceedings of the 18th ACM SIGKDD international conference on Knowledge discovery and data mining. Beijing China: ACM. 12 August 2012. p. 615–623. ISBN 978-1-4503-1462-6. DOI 10.1145/2339530.2339630. [https://arxiv.org/pdf/1206.0629.pdf pdf]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Implementation of the Label Propagation (LP) algorithm",
        "story": []
      },
      "date": 1711038035607
    },
    {
      "item": {
        "type": "factory",
        "id": "e47cc9cf1efd279b"
      },
      "id": "e47cc9cf1efd279b",
      "type": "add",
      "date": 1711038046256
    },
    {
      "type": "edit",
      "id": "e47cc9cf1efd279b",
      "item": {
        "type": "paragraph",
        "id": "e47cc9cf1efd279b",
        "text": "Here's an implementation of the Label Propagation (LP) algorithm based on the provided procedure:"
      },
      "date": 1711038047929
    },
    {
      "item": {
        "type": "factory",
        "id": "76a18fe0b3d6132e"
      },
      "id": "76a18fe0b3d6132e",
      "type": "add",
      "after": "e47cc9cf1efd279b",
      "date": 1711038070561
    },
    {
      "type": "edit",
      "id": "76a18fe0b3d6132e",
      "item": {
        "type": "code",
        "id": "76a18fe0b3d6132e",
        "text": "// Function to initialize labels at all nodes\nfunction initializeLabels(graph) {\n    const labels = new Map();\n    graph.nodes.forEach(node => {\n        labels.set(node, node); // Initialize label at each node to itself\n    });\n    return labels;\n}"
      },
      "date": 1711038072621
    },
    {
      "item": {
        "type": "factory",
        "id": "06201cdfbb888971"
      },
      "id": "06201cdfbb888971",
      "type": "add",
      "after": "76a18fe0b3d6132e",
      "date": 1711038099524
    },
    {
      "type": "edit",
      "id": "06201cdfbb888971",
      "item": {
        "type": "code",
        "id": "06201cdfbb888971",
        "text": "// Function to randomly shuffle an array\nfunction shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n}"
      },
      "date": 1711038102591
    },
    {
      "item": {
        "type": "factory",
        "id": "37e8bcd26b0207b8"
      },
      "id": "37e8bcd26b0207b8",
      "type": "add",
      "after": "06201cdfbb888971",
      "date": 1711038138482
    },
    {
      "id": "37e8bcd26b0207b8",
      "type": "move",
      "order": [
        "e47cc9cf1efd279b",
        "76a18fe0b3d6132e",
        "37e8bcd26b0207b8",
        "06201cdfbb888971"
      ],
      "date": 1711038140745
    },
    {
      "type": "edit",
      "id": "37e8bcd26b0207b8",
      "item": {
        "type": "paragraph",
        "id": "37e8bcd26b0207b8",
        "text": "[[Shuffel]]"
      },
      "date": 1711038146712
    },
    {
      "type": "edit",
      "id": "37e8bcd26b0207b8",
      "item": {
        "type": "paragraph",
        "id": "37e8bcd26b0207b8",
        "text": "[[Shuffle]]"
      },
      "date": 1711038153951
    },
    {
      "item": {
        "type": "factory",
        "id": "b035ad7664d1a495"
      },
      "id": "b035ad7664d1a495",
      "type": "add",
      "after": "06201cdfbb888971",
      "date": 1711038211668
    },
    {
      "type": "edit",
      "id": "b035ad7664d1a495",
      "item": {
        "type": "code",
        "id": "b035ad7664d1a495",
        "text": "// Function to apply Label Propagation algorithm\nfunction labelPropagation(graph, tmax) {\n    const labels = initializeLabels(graph);\n\n    let t = 0;\n    while (t < tmax) {\n        let changed = false;\n        const nodes = shuffleArray(Array.from(graph.nodes)); // Randomize node order\n\n        nodes.forEach(node => {\n            const neighbors = graph.neighbors(node);\n            const neighborLabels = Array.from(neighbors.values()).map(neighbor => labels.get(neighbor));\n            const frequencies = new Map();\n\n            // Count frequencies of neighbor labels\n            neighborLabels.forEach(label => {\n                frequencies.set(label, (frequencies.get(label) || 0) + 1);\n            });\n\n            // Find label with highest frequency (ties broken randomly)\n            const maxFrequency = Math.max(...frequencies.values());\n            const maxLabels = Array.from(frequencies.entries()).filter(([label, freq]) => freq === maxFrequency);\n            const newLabel = maxLabels[Math.floor(Math.random() * maxLabels.length)][0];\n\n            // Update label if different from current label\n            if (newLabel !== labels.get(node)) {\n                labels.set(node, newLabel);\n                changed = true;\n            }\n        });\n\n        if (!changed) {\n            break; // Stop if no label changes occurred\n        }\n\n        t++;\n    }\n\n    return labels;\n}"
      },
      "date": 1711038214381
    },
    {
      "item": {
        "type": "factory",
        "id": "9d7c3814458dc58f"
      },
      "id": "9d7c3814458dc58f",
      "type": "add",
      "after": "b035ad7664d1a495",
      "date": 1711038265300
    },
    {
      "type": "edit",
      "id": "9d7c3814458dc58f",
      "item": {
        "type": "code",
        "id": "9d7c3814458dc58f",
        "text": "// Example usage:\n// Assuming you have a graph object called 'graph'\nconst tmax = 100; // Maximum number of iterations\nconst communityLabels = labelPropagation(graph, tmax);\nconsole.log(\"Community Labels:\", communityLabels);"
      },
      "date": 1711038268712
    },
    {
      "item": {
        "type": "factory",
        "id": "0b30b229a689cc09"
      },
      "id": "0b30b229a689cc09",
      "type": "add",
      "after": "9d7c3814458dc58f",
      "date": 1711038290252
    },
    {
      "type": "edit",
      "id": "0b30b229a689cc09",
      "item": {
        "type": "paragraph",
        "id": "0b30b229a689cc09",
        "text": "This implementation follows the steps outlined in the LP algorithm procedure. It initializes labels at all nodes, then iteratively updates the labels based on the labels of neighboring nodes until convergence or until reaching the maximum number of iterations (tmax). (ChatGPT 3.5)"
      },
      "date": 1711038313768
    },
    {
      "id": "46c47ba73c9feace",
      "type": "add",
      "item": {
        "type": "pagefold",
        "id": "46c47ba73c9feace",
        "text": "~"
      },
      "after": "0b30b229a689cc09",
      "attribution": {
        "page": "Implementation of the DEMON Algorithm"
      },
      "date": 1711038344450
    },
    {
      "id": "7eb52230692290b1",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "7eb52230692290b1",
        "text": "COSCIA, Michele, ROSSETTI, Giulio, GIANNOTTI, Fosca and PEDRESCHI, Dino, 2012. DEMON: a local-first discovery method for overlapping communities. In: Proceedings of the 18th ACM SIGKDD international conference on Knowledge discovery and data mining. Beijing China: ACM. 12 August 2012. p. 615–623. ISBN 978-1-4503-1462-6. DOI 10.1145/2339530.2339630. [https://arxiv.org/pdf/1206.0629.pdf pdf]"
      },
      "after": "46c47ba73c9feace",
      "attribution": {
        "page": "Implementation of the DEMON Algorithm"
      },
      "date": 1711038353134
    },
    {
      "id": "8d14a08da81e3077",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "8d14a08da81e3077",
        "text": "⇒ [[Linear Shuffle]] ⇒ [[shuffle]] ⇒ [[Shuffled Cards]]"
      },
      "after": "06201cdfbb888971",
      "attribution": {
        "page": "2024-02-28"
      },
      "date": 1711038388623
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1711038464387
    },
    {
      "type": "edit",
      "id": "37e8bcd26b0207b8",
      "item": {
        "type": "paragraph",
        "id": "37e8bcd26b0207b8",
        "text": "# Shuffle"
      },
      "date": 1711038514362
    },
    {
      "type": "edit",
      "id": "37e8bcd26b0207b8",
      "item": {
        "type": "markdown",
        "id": "37e8bcd26b0207b8",
        "text": "# Shuffle"
      },
      "date": 1711038516710
    },
    {
      "id": "4f46952fb4a34d06",
      "type": "add",
      "item": {
        "type": "code",
        "id": "4f46952fb4a34d06",
        "text": "function linearShuffle(deck) {\n  for (let i = deck.length - 1; i > 0; i--) {\n    // Generate a random index between 0 and i (inclusive)\n    const j = Math.floor(Math.random() * (i + 1));\n\n    // Swap deck[i] with deck[j]\n    [deck[i], deck[j]] = [deck[j], deck[i]];\n  }\n  return deck;\n}"
      },
      "after": "06201cdfbb888971",
      "attribution": {
        "page": "Shuffled Cards"
      },
      "date": 1711038571686
    },
    {
      "type": "edit",
      "id": "4f46952fb4a34d06",
      "item": {
        "type": "code",
        "id": "4f46952fb4a34d06",
        "text": "// Function to randomly shuffle an array\nfunction shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n}"
      },
      "date": 1711038576969
    }
  ]
}