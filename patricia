{
  "title": "Patricia",
  "story": [
    {
      "type": "paragraph",
      "id": "b1f46e993600b52a",
      "text": "Donald R. Morrison [JACM 15 (1968), 514–534] has discovered a very pretty way to form N-node search trees based on the binary representation of keys, without storing keys in the nodes. His method, called “Patricia” (Practical Algorithm To Retrieve Information Coded In Alphanumeric), is especially suitable for dealing with extremely long, variable-length keys such as titles or phrases stored within a large bulk file. A closely related algorithm was published at almost exactly the same time in Germany by G. Gwehenberger, Elektronische Rechenanlagen 10 (1968), 223–226."
    },
    {
      "type": "paragraph",
      "id": "c2192dab4cc7ded8",
      "text": "Patricia’s basic idea is to build a binary [[Trie]], but to avoid one-way branching by including in each node the number of bits to skip over before making the next test."
    },
    {
      "type": "paragraph",
      "id": "5f781068e6f6df42",
      "text": "There are several ways to exploit this idea; perhaps the simplest to explain is illustrated in Fig. 33. We have a TEXT array of bits, which is usually quite long; it may be stored as an external direct-access file, since each search accesses TEXT only once. Each key to be stored in our table is specified by a starting place in the text, and it can be imagined to go from this starting place all the way to the end of the text. (Patricia does not search for strict equality between key and argument; instead, it will determine whether or not there exists a key beginning with the argument.)"
    },
    {
      "type": "image",
      "id": "ff15fbf8b579c57f",
      "text": "Fig. 33. An example of Patricia's tree and TEXT.",
      "size": "wide",
      "width": 430,
      "height": 344,
      "url": "/assets/plugins/image/7415af4b0b7b316f81c001ebe222e33c.jpg"
    },
    {
      "type": "paragraph",
      "id": "3f575747120fd8c8",
      "text": "The situation depicted in Fig. 33 involves seven keys, one starting at each word, namely “THIS IS THE HOUSE THAT JACK BUILT?” and “IS THE HOUSE THAT JACK BUILT?” and . . . and “BUILT?”. There is one important restriction, namely that no one key may be a prefix of another; this restriction can be met if we end the text with a unique end-of-text code (in this case “?”) that appears nowhere else. The same restriction was implicit in the [[Trie]] scheme of Algorithm T, where “⊔” was the termination code."
    },
    {
      "type": "pagefold",
      "id": "3cebad850d80f616",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "59e308544ee5bdc9",
      "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. v. 3. Sorting and Searching. 2nd ed. Reading, Mass: Addison-Wesley. ISBN 0-201-89685-0, p. 498–499.\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Patricia",
        "story": []
      },
      "date": 1694788682937
    },
    {
      "id": "b1f46e993600b52a",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "b1f46e993600b52a",
        "text": "Donald R. Morrison [JACM 15 (1968), 514–534] has discovered a very pretty way to form N-node search trees based on the binary representation of keys, without storing keys in the nodes. His method, called “Patricia” (Practical Algorithm To Retrieve Information Coded In Alphanumeric), is especially suitable for dealing with extremely long, variable-length keys such as titles or phrases stored within a large bulk file. A closely related algorithm was published at almost exactly the same time in Germany by G. Gwehenberger, Elektronische Rechenanlagen 10 (1968), 223–226."
      },
      "attribution": {
        "page": "2023-09-15"
      },
      "date": 1694788685715
    },
    {
      "id": "ff15fbf8b579c57f",
      "type": "add",
      "item": {
        "type": "image",
        "id": "ff15fbf8b579c57f",
        "text": "Fig. 33. An example of Patricia's tree and TEXT.",
        "size": "wide",
        "width": 430,
        "height": 344,
        "url": "/assets/plugins/image/7415af4b0b7b316f81c001ebe222e33c.jpg"
      },
      "after": "b1f46e993600b52a",
      "attribution": {
        "page": "2023-09-15"
      },
      "date": 1694788687617
    },
    {
      "type": "add",
      "id": "c2192dab4cc7ded8",
      "item": {
        "type": "paragraph",
        "id": "c2192dab4cc7ded8",
        "text": "Patricia’s basic idea is to build a binary trie, but to avoid one-way branching by including in each node the number of bits to skip over before making the next test. There are several ways to exploit this idea; perhaps the simplest to explain is illustrated in Fig. 33. We have a TEXT array of bits, which is usually quite long; it may be stored as an external direct-access file, since each search accesses TEXT only once. Each key to be stored in our table is specified by a starting place in the text, and it can be imagined to go from this starting place all the way to the end of the text. (Patricia does not search for strict equality between key and argument; instead, it will determine whether or not there exists a key beginning with the argument.)"
      },
      "after": "b1f46e993600b52a",
      "date": 1694788721877
    },
    {
      "type": "edit",
      "id": "c2192dab4cc7ded8",
      "item": {
        "type": "paragraph",
        "id": "c2192dab4cc7ded8",
        "text": "Patricia’s basic idea is to build a binary [[Trie]], but to avoid one-way branching by including in each node the number of bits to skip over before making the next test. There are several ways to exploit this idea; perhaps the simplest to explain is illustrated in Fig. 33. We have a TEXT array of bits, which is usually quite long; it may be stored as an external direct-access file, since each search accesses TEXT only once. Each key to be stored in our table is specified by a starting place in the text, and it can be imagined to go from this starting place all the way to the end of the text. (Patricia does not search for strict equality between key and argument; instead, it will determine whether or not there exists a key beginning with the argument.)"
      },
      "date": 1694788735157
    },
    {
      "item": {
        "type": "factory",
        "id": "3f575747120fd8c8"
      },
      "id": "3f575747120fd8c8",
      "type": "add",
      "after": "ff15fbf8b579c57f",
      "date": 1694788766272
    },
    {
      "type": "edit",
      "id": "3f575747120fd8c8",
      "item": {
        "type": "paragraph",
        "id": "3f575747120fd8c8",
        "text": "The situation depicted in Fig. 33 involves seven keys, one starting at each word, namely “THIS IS THE HOUSE THAT JACK BUILT?” and “IS THE HOUSE THAT JACK BUILT?” and . . . and “BUILT?”. There is one important restriction, namely that no one key may be a prefix of another; this restriction can be met if we end the text with a unique end-of-text code (in this case “?”) that appears nowhere else. The same restriction was implicit in the trie scheme of Algorithm T, where “ ” was the termination code."
      },
      "date": 1694788767803
    },
    {
      "id": "3cebad850d80f616",
      "type": "add",
      "item": {
        "type": "pagefold",
        "id": "3cebad850d80f616",
        "text": "~"
      },
      "after": "3f575747120fd8c8",
      "attribution": {
        "page": "Digital Searching"
      },
      "date": 1694788900213
    },
    {
      "id": "59e308544ee5bdc9",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "59e308544ee5bdc9",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. v. 3. Sorting and Searching. 2nd ed. Reading, Mass: Addison-Wesley. ISBN 0-201-89685-0, p. 492–493.\n"
      },
      "after": "3f575747120fd8c8",
      "attribution": {
        "page": "Digital Searching"
      },
      "date": 1694788905386
    },
    {
      "id": "3cebad850d80f616",
      "type": "move",
      "order": [
        "b1f46e993600b52a",
        "c2192dab4cc7ded8",
        "ff15fbf8b579c57f",
        "3f575747120fd8c8",
        "3cebad850d80f616",
        "59e308544ee5bdc9"
      ],
      "date": 1694788906945
    },
    {
      "type": "edit",
      "id": "59e308544ee5bdc9",
      "item": {
        "type": "paragraph",
        "id": "59e308544ee5bdc9",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. v. 3. Sorting and Searching. 2nd ed. Reading, Mass: Addison-Wesley. ISBN 0-201-89685-0, p. 498–499.\n"
      },
      "date": 1694788917973
    },
    {
      "type": "edit",
      "id": "3f575747120fd8c8",
      "item": {
        "type": "paragraph",
        "id": "3f575747120fd8c8",
        "text": "The situation depicted in Fig. 33 involves seven keys, one starting at each word, namely “THIS IS THE HOUSE THAT JACK BUILT?” and “IS THE HOUSE THAT JACK BUILT?” and . . . and “BUILT?”. There is one important restriction, namely that no one key may be a prefix of another; this restriction can be met if we end the text with a unique end-of-text code (in this case “?”) that appears nowhere else. The same restriction was implicit in the trie scheme of Algorithm T, where “⊔” was the termination code."
      },
      "date": 1694789106084
    },
    {
      "type": "edit",
      "id": "3f575747120fd8c8",
      "item": {
        "type": "paragraph",
        "id": "3f575747120fd8c8",
        "text": "The situation depicted in Fig. 33 involves seven keys, one starting at each word, namely “THIS IS THE HOUSE THAT JACK BUILT?” and “IS THE HOUSE THAT JACK BUILT?” and . . . and “BUILT?”. There is one important restriction, namely that no one key may be a prefix of another; this restriction can be met if we end the text with a unique end-of-text code (in this case “?”) that appears nowhere else. The same restriction was implicit in the [[Trie]] scheme of Algorithm T, where “⊔” was the termination code."
      },
      "date": 1694791745808
    },
    {
      "type": "edit",
      "id": "c2192dab4cc7ded8",
      "item": {
        "type": "paragraph",
        "id": "c2192dab4cc7ded8",
        "text": "Patricia’s basic idea is to build a binary [[Trie]], but to avoid one-way branching by including in each node the number of bits to skip over before making the next test."
      },
      "date": 1694792218215
    },
    {
      "type": "add",
      "id": "5f781068e6f6df42",
      "item": {
        "type": "paragraph",
        "id": "5f781068e6f6df42",
        "text": "There are several ways to exploit this idea; perhaps the simplest to explain is illustrated in Fig. 33. We have a TEXT array of bits, which is usually quite long; it may be stored as an external direct-access file, since each search accesses TEXT only once. Each key to be stored in our table is specified by a starting place in the text, and it can be imagined to go from this starting place all the way to the end of the text. (Patricia does not search for strict equality between key and argument; instead, it will determine whether or not there exists a key beginning with the argument.)"
      },
      "after": "c2192dab4cc7ded8",
      "date": 1694792219381
    }
  ]
}