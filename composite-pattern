{
  "title": "Composite Pattern",
  "story": [
    {
      "type": "html",
      "text": "<b>Intent:</b> Compose objects into tree structures that represent whole-part hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly. A leaf has the same interface as a node. ",
      "id": "06ce5fde715af39116f1ded7782ebeed"
    },
    {
      "type": "html",
      "text": "\nContrast this to the <i>Restricted Composite Pattern</i> discussed in [[Cpp Utx Overview]] that uses [[External Polymorphism]] so that a <i>leaf</i> need not inherit the collection interface needed by a <i>node</i>.",
      "id": "74af0b6cbf435c9a8b8d49a544e97d94"
    },
    {
      "type": "html",
      "text": "<b>See also:</b> [[Visitor Pattern]], [[Hierarchical Visitor Pattern]], [[Design Patterns]]",
      "id": "c0f4294963c6dd6ab28e4f397bc23301"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
    },
    {
      "type": "html",
      "text": "[[Comments On Composite]],\n[[Dark Side Of Composite Pattern]],\n[[Composite Pattern Example]],\n[[Composite Considered Harmful]],\n[[Interpreter Vs Composite]]",
      "id": "ded0573a5a278db58cb94a070a6762a2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
    },
    {
      "type": "html",
      "text": "\nA <i>leaf</i> does not have to have the same interface as the <i>node</i> base-class. It typically extends the <i>node</i> interface with methods that are not used polymorphically. Similarly, leaves do not usually implement collection interfaces. The composite node extends the basic node class with the collection behaviour and interface. -- [[Anonymous Donor]]",
      "id": "5f017ccf4d60fed382d45161366b39ef"
    },
    {
      "type": "html",
      "text": "\nHmmm.. Well I guess it depends on which description of the [[Composite Pattern]] you follow. Are you saying that <i>Leaf</i> doesn't descend from <i>Composite</i> or that <i>Composite</i> doesn't define the collection interface? If we go back to the [[Gang Of Four]] [[Design Patterns Book]], the <i>Component</i> class establishes an interface including <i>Add( Component )</i>, <i>Remove( Component )</i>, and <i>Get<b></b>Child( int )</i>. The <i>Leaf</i> and <i>Composite</i> classes both descend from <i>Component</i>. In fact, if you go to the <i>Participants</i> section, the third bullet for <b>Component</b> states that a Component <i>\"declares an interface for accessing and managing its child components.\"</i> What's optional is the fourth bullet, which are members for accessing a component's parent. What am I missing? While I prefer your comments and have <i>always</i> used <i>Composite</i> in this way, it seems to be <i>a variation on the original [[Composite Pattern]]</i>. -- [[Robert Di Falco]]",
      "id": "bb60f0268a8272c81edfe945d283935c"
    },
    {
      "type": "html",
      "text": "\nThe [[Anonymous Donor]] is wrong, and [[Robert Di Falco]] is right. In the [[Design Patterns Book]], we intended a Leaf to have the same interface as the base class, and for a Composite too, as well. The discussion on page 167-169 is based on that fact that it is usually impossible to make them all exactly the same, but it is worth trying. In practice, the interfaces are usually almost identical, but not quite. -- [[Ralph Johnson]]",
      "id": "af4bbb5e18d447f56bd5ffca85647ce6"
    },
    {
      "type": "html",
      "text": "\nSo what's the point of trying it?? Why is it worth trying? I cannot think of an example... Even in the Unix filesystem, where directories are files, the solution is to make Composite implement the interface of Leaf... -- Euyyn at Wikipedia",
      "id": "c477e1582de0bcb563bc0aa213cc7791"
    },
    {
      "type": "html",
      "text": "\nI sometime use (what I guess is) a degenerate [[Composite Pattern]] in which the Leaf and Composite have the same interface as the base class, but only the Composite has the collection interface. In BNF:",
      "id": "6cd89a98d10d9fd3afc5aff3ef376660"
    },
    {
      "type": "code",
      "text": "  <node>          ::= <leafnode> | <compositenode>\n  <compositenode> ::= <node>*",
      "id": "3b37b5d4d19ac5b94bd04f1c8e503fb5"
    },
    {
      "type": "html",
      "text": "Perhaps this would be better termed a Compound<b></b>Pattern rather than [[Composite Pattern]] (but this [[Wiki Word]] is already taken).  Comments? -- [[George Dinwiddie]]",
      "id": "fc4c43dcf237fc1afaffc3711f7091d7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
    },
    {
      "type": "html",
      "text": "\nRight or wrong?",
      "id": "a595c08c234463fc87293b3c68b5e307"
    },
    {
      "type": "html",
      "text": "\nThere are designs where the leaves should have dummy child management method, and designs where they shouldn't; structures which are not general trees or where the interface of <i>Add( Component )</i>, <i>Remove( Component )</i>, and <i>Get<b></b>Child( int )</i> is too free; algorithms which use parent links in the tree and algorithms which don't need them; and so on.\nThere is a continuous space of possible solutions; the Composite as described in the [[Design Patterns Book]] is a typical example, not the only right way to define aggregates. -- [[Lorenzo Gatti]]",
      "id": "a5b675c27dad887830756107ef4ce6ee"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
    },
    {
      "type": "html",
      "text": "This just in (June 2006): Rebecca Wirfs-Brock has written an article entitled \"Refreshing Patterns\" in the IEEE Software Magazine (Vol 23 No 3 May/June 2006)pages 45-47. She argues that patterns need to evolve and uses the [[Composite Pattern]] as\nan example. Quotes one of the GoF authors... -- [[Richard Botting]]",
      "id": "105e33982aed870521cd240f4568e2e6"
    },
    {
      "type": "html",
      "text": "\nBy the way, why do we say that the [[Composite Pattern]] makes a [[Tree Structure]]? Surely we can add components that are already part of the structure? Did the GoF discuss this? Doesn't the remove method need to be a little complicated to avoid collecting garbage twice? -- [[Richard Botting]] (I've been bitten by this bug in the past. It took months to diagnose.)",
      "id": "58d50ccbc0f86ed2d22a5070b2fee3a8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
    },
    {
      "type": "html",
      "text": "\n[[Composite Pattern]] suggests [[Navigational Database]] / [[Object Oriented Database]] and inherits many weaknesses thereof (especially in the face of concurrency). It is worth considering alternatives. If [[Composite Pattern]] is being used to represent structured messages or values, consider use of immutable structures and functional construction (without [[Side Effect]]s). If [[Composite Pattern]] is being used to represent data - such as a world-model or [[Scene Graph]] or [[Document Object Model]] - consider introducing a dedicated [[Data Base]] object, possibly one well proven to achieve both performance and flexibility, such as [[Relational Model]]. ",
      "id": "e76fbb9f1f621b6de827d55826a532f3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
    },
    {
      "type": "html",
      "text": "\n[http://home.earthlink.net/~huston2/dp/composite.html home.earthlink.net]",
      "id": "92a37b23f942f55a1c2629df2f21f939"
    },
    {
      "type": "html",
      "text": "\n[http://wiki.cs.uiuc.edu/patternStories/CompositePattern wiki.cs.uiuc.edu]",
      "id": "249139d1755b3423c675ed7e342bff0f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
    },
    {
      "type": "html",
      "text": "[[Category Pattern]] | [[Category Structural Patterns]]",
      "id": "30677634c0c685340e7fe970e0fa05e2"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?CompositePattern c2.com]",
      "id": "e818cb72fa6cea28ca4702739f37bb88"
    }
  ],
  "journal": [
    {
      "date": 1278726288000,
      "id": "224ffe257c293bc25bab413566ae6315",
      "type": "create",
      "item": {
        "title": "Composite Pattern",
        "story": [
          {
            "type": "html",
            "text": "<b>Intent:</b> Compose objects into tree structures that represent whole-part hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly. A leaf has the same interface as a node. ",
            "id": "06ce5fde715af39116f1ded7782ebeed"
          },
          {
            "type": "html",
            "text": "\nContrast this to the <i>Restricted Composite Pattern</i> discussed in [[Cpp Utx Overview]] that uses [[External Polymorphism]] so that a <i>leaf</i> need not inherit the collection interface needed by a <i>node</i>.",
            "id": "74af0b6cbf435c9a8b8d49a544e97d94"
          },
          {
            "type": "html",
            "text": "<b>See also:</b> [[Visitor Pattern]], [[Hierarchical Visitor Pattern]], [[Design Patterns]]",
            "id": "c0f4294963c6dd6ab28e4f397bc23301"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
          },
          {
            "type": "html",
            "text": "[[Comments On Composite]],\n[[Dark Side Of Composite Pattern]],\n[[Composite Pattern Example]],\n[[Composite Considered Harmful]],\n[[Interpreter Vs Composite]]",
            "id": "ded0573a5a278db58cb94a070a6762a2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
          },
          {
            "type": "html",
            "text": "\nA <i>leaf</i> does not have to have the same interface as the <i>node</i> base-class. It typically extends the <i>node</i> interface with methods that are not used polymorphically. Similarly, leaves do not usually implement collection interfaces. The composite node extends the basic node class with the collection behaviour and interface. -- [[Anonymous Donor]]",
            "id": "5f017ccf4d60fed382d45161366b39ef"
          },
          {
            "type": "html",
            "text": "\nHmmm.. Well I guess it depends on which description of the [[Composite Pattern]] you follow. Are you saying that <i>Leaf</i> doesn't descend from <i>Composite</i> or that <i>Composite</i> doesn't define the collection interface? If we go back to the [[Gang Of Four]] [[Design Patterns Book]], the <i>Component</i> class establishes an interface including <i>Add( Component )</i>, <i>Remove( Component )</i>, and <i>Get<b></b>Child( int )</i>. The <i>Leaf</i> and <i>Composite</i> classes both descend from <i>Component</i>. In fact, if you go to the <i>Participants</i> section, the third bullet for <b>Component</b> states that a Component <i>\"declares an interface for accessing and managing its child components.\"</i> What's optional is the fourth bullet, which are members for accessing a component's parent. What am I missing? While I prefer your comments and have <i>always</i> used <i>Composite</i> in this way, it seems to be <i>a variation on the original [[Composite Pattern]]</i>. -- [[Robert Di Falco]]",
            "id": "bb60f0268a8272c81edfe945d283935c"
          },
          {
            "type": "html",
            "text": "\nThe [[Anonymous Donor]] is wrong, and [[Robert Di Falco]] is right. In the [[Design Patterns Book]], we intended a Leaf to have the same interface as the base class, and for a Composite too, as well. The discussion on page 167-169 is based on that fact that it is usually impossible to make them all exactly the same, but it is worth trying. In practice, the interfaces are usually almost identical, but not quite. -- [[Ralph Johnson]]",
            "id": "af4bbb5e18d447f56bd5ffca85647ce6"
          },
          {
            "type": "html",
            "text": "\nSo what's the point of trying it?? Why is it worth trying? I cannot think of an example... Even in the Unix filesystem, where directories are files, the solution is to make Composite implement the interface of Leaf... -- Euyyn at Wikipedia",
            "id": "c477e1582de0bcb563bc0aa213cc7791"
          },
          {
            "type": "html",
            "text": "\nI sometime use (what I guess is) a degenerate [[Composite Pattern]] in which the Leaf and Composite have the same interface as the base class, but only the Composite has the collection interface. In BNF:",
            "id": "6cd89a98d10d9fd3afc5aff3ef376660"
          },
          {
            "type": "code",
            "text": "  <node>          ::= <leafnode> | <compositenode>\n  <compositenode> ::= <node>*",
            "id": "3b37b5d4d19ac5b94bd04f1c8e503fb5"
          },
          {
            "type": "html",
            "text": "Perhaps this would be better termed a Compound<b></b>Pattern rather than [[Composite Pattern]] (but this [[Wiki Word]] is already taken).  Comments? -- [[George Dinwiddie]]",
            "id": "fc4c43dcf237fc1afaffc3711f7091d7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
          },
          {
            "type": "html",
            "text": "\nRight or wrong?",
            "id": "a595c08c234463fc87293b3c68b5e307"
          },
          {
            "type": "html",
            "text": "\nThere are designs where the leaves should have dummy child management method, and designs where they shouldn't; structures which are not general trees or where the interface of <i>Add( Component )</i>, <i>Remove( Component )</i>, and <i>Get<b></b>Child( int )</i> is too free; algorithms which use parent links in the tree and algorithms which don't need them; and so on.\nThere is a continuous space of possible solutions; the Composite as described in the [[Design Patterns Book]] is a typical example, not the only right way to define aggregates. -- [[Lorenzo Gatti]]",
            "id": "a5b675c27dad887830756107ef4ce6ee"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
          },
          {
            "type": "html",
            "text": "This just in (June 2006): Rebecca Wirfs-Brock has written an article entitled \"Refreshing Patterns\" in the IEEE Software Magazine (Vol 23 No 3 May/June 2006)pages 45-47. She argues that patterns need to evolve and uses the [[Composite Pattern]] as\nan example. Quotes one of the GoF authors... -- [[Richard Botting]]",
            "id": "105e33982aed870521cd240f4568e2e6"
          },
          {
            "type": "html",
            "text": "\nBy the way, why do we say that the [[Composite Pattern]] makes a [[Tree Structure]]? Surely we can add components that are already part of the structure? Did the GoF discuss this? Doesn't the remove method need to be a little complicated to avoid collecting garbage twice? -- [[Richard Botting]] (I've been bitten by this bug in the past. It took months to diagnose.)",
            "id": "58d50ccbc0f86ed2d22a5070b2fee3a8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
          },
          {
            "type": "html",
            "text": "\n[[Composite Pattern]] suggests [[Navigational Database]] / [[Object Oriented Database]] and inherits many weaknesses thereof (especially in the face of concurrency). It is worth considering alternatives. If [[Composite Pattern]] is being used to represent structured messages or values, consider use of immutable structures and functional construction (without [[Side Effect]]s). If [[Composite Pattern]] is being used to represent data - such as a world-model or [[Scene Graph]] or [[Document Object Model]] - consider introducing a dedicated [[Data Base]] object, possibly one well proven to achieve both performance and flexibility, such as [[Relational Model]]. ",
            "id": "e76fbb9f1f621b6de827d55826a532f3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
          },
          {
            "type": "html",
            "text": "\n[http://home.earthlink.net/~huston2/dp/composite.html home.earthlink.net]",
            "id": "92a37b23f942f55a1c2629df2f21f939"
          },
          {
            "type": "html",
            "text": "\n[http://wiki.cs.uiuc.edu/patternStories/CompositePattern wiki.cs.uiuc.edu]",
            "id": "249139d1755b3423c675ed7e342bff0f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d2b16e2d5fd30d6fd7c7c8e9fb26ac72"
          },
          {
            "type": "html",
            "text": "[[Category Pattern]] | [[Category Structural Patterns]]",
            "id": "30677634c0c685340e7fe970e0fa05e2"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?CompositePattern c2.com]",
            "id": "e818cb72fa6cea28ca4702739f37bb88"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1640690323904
    }
  ]
}