{
  "title": "Design Principles Behind Smalltalk",
  "story": [
    {
      "type": "html",
      "text": "BYTE Magazine, August 1981. (c) by The McGraw-Hill Companies, Inc., NY.\nCopied from [http://users.ipa.net/~dwighth/smalltalk/byte_aug81/design_principles_behind_smalltalk.html users.ipa.net] [https://web.archive.org/web/19991110010817/http://users.ipa.net/~dwighth/smalltalk/byte_aug81/design_principles_behind_smalltalk.html wayback]\nScanned in and converted to HTML (with recreated graphics) by Dwight Hughes. [https://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html page]",
      "id": "0de99186f6e224bfebf829c0f5d94237"
    },
    {
      "type": "html",
      "text": "\nInteresting to see the phrases \"factoring\" and \"well-factored system\" already in 1981.",
      "id": "f5887696a262ebe0bdf17da8566c5b10"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "fd9a89c217ff37196ae0409b278cf29c"
    },
    {
      "type": "html",
      "text": "<i>I don't know about '81 but when I started programming '86, people were always using terms like </i>'factoring<i>, </i>well-factored<i>, and even </i>re-factoring<i>. At the time, this was the preferred term to 're-tooling</i>.''",
      "id": "942eb8b09be7f86d1fda0e7a4ab3647c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "fd9a89c217ff37196ae0409b278cf29c"
    },
    {
      "type": "html",
      "text": "\nI'll never forget the thrill of reading this article in late 1982.",
      "id": "38eb4116216eeb72070d637eec12dc02"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "fd9a89c217ff37196ae0409b278cf29c"
    },
    {
      "type": "html",
      "text": "I just grabbed a copy of this entire issue of BYTE and its just great. It's just as good a read now as it was then.",
      "id": "394d4b4419312495d04c58b4cb4199ba"
    },
    {
      "type": "html",
      "text": "----WONTFIX bug should be reopened.",
      "id": "0243fb1e6664d021ef7a6aebaec57346"
    },
    {
      "type": "html",
      "text": "\nI just read this for the first time, and the introductory sentence was absolutely startling:",
      "id": "262d7de43d527efad26d9c68b5aa7f8c"
    },
    {
      "type": "html",
      "text": "<i>The purpose of the Smalltalk project is to provide computer support for the creative spirit in everyone.</i> ",
      "id": "f27c8c3a16147263dd1426ef6428d58e"
    },
    {
      "type": "html",
      "text": "-- [[Dan Ingalls]]",
      "id": "392df92e566f10a15827eb7a8b94a2e6"
    },
    {
      "type": "html",
      "text": "\nThis seems an unusual thing for a computer scientist to write in a paper. I'm used to seeing papers about languages talk about efficiency, performance, garbage collection, \"compact representations\", etc., etc. -- [[Robert Church]]",
      "id": "9ba074b9b7e6e6a6eefb600ce4e68184"
    },
    {
      "type": "html",
      "text": "<i>That is classic [[Dan Ingalls]], and offers a crisp illustration of the essential difference Smalltalk has for some of us. -- [[Tom Stambaugh]]</i>",
      "id": "4c13c08421a895b98984b1e5f19f1733"
    },
    {
      "type": "html",
      "text": "\nIt may also provide some insight into why Smalltalk is not the prevalent language for commercial software development.  Unfortunately, the creative spirit in everyone is usually irrelevant in that realm.  --[[Kris Johnson]]",
      "id": "d72965286a5282028c82cf4289f05f6b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "fd9a89c217ff37196ae0409b278cf29c"
    },
    {
      "type": "html",
      "text": "\nThe design principles of Smalltalk, the language:",
      "id": "fe4caa1cbf38926fb67caeac3a78e509"
    },
    {
      "type": "html",
      "text": " Every element is an object. Classes, methods, integers, chars, bytecodes, all are objects.",
      "id": "69c9d402286b6270e593c6e2cfd02b21"
    },
    {
      "type": "html",
      "text": " All objects belong to a class that defines their behavior.",
      "id": "e4c286ddce7e60533b97a85dabd02804"
    },
    {
      "type": "html",
      "text": " All classes belong to a class (its metaclass) that defines the class behavior.",
      "id": "681ad9af0a964b75f147cab3516ae90e"
    },
    {
      "type": "html",
      "text": "\nThe design principles of Smalltalk, the environment:",
      "id": "5b31da2eb6862490ff9826686c867c78"
    },
    {
      "type": "html",
      "text": " The environment is written in Smalltalk and it is interpreted in the environment itself.",
      "id": "eb92e77367959344bc84db7a0ed4b586"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "fd9a89c217ff37196ae0409b278cf29c"
    },
    {
      "type": "html",
      "text": "\nThough [[Smalltalk Language]] is very human-oriented, it does seem to borrow a lot of concepts and terminology and notation from dizzy heights of [[Set Theory]]. ",
      "id": "f5054cd2ce72fc9240da8dd1d4214295"
    },
    {
      "type": "html",
      "text": " Classes are another name for Sets ",
      "id": "5674440199e2dd964e2b72b9642c1348"
    },
    {
      "type": "html",
      "text": " The Smalltalk class called Object (the class that contains everything) is the [[Set Theory]] [[Universal Set]] (the set that contains everything).",
      "id": "ba56dd2673e96188dad0e81fac8ef8e9"
    },
    {
      "type": "html",
      "text": " A Smalltalk Set is a [[Set Theory]] Set. ",
      "id": "3b2709fd33a8b2ac3961ef1f5e37dda6"
    },
    {
      "type": "html",
      "text": " A Smalltalk [[Ordered Collection]] is a [[Set Theory]] Ordered Set.",
      "id": "6f843ae5d2540fa8fc63426b0b4bb4ff"
    },
    {
      "type": "html",
      "text": " A Smalltalk Association is [[Set Theory]] Ordered Pair. ",
      "id": "ea31ff533381ffb2d8743c15cb0bb1f3"
    },
    {
      "type": "html",
      "text": " A Smalltalk Dictionary (which is defined in Smalltalk as a collection of Associations) is the same as a [[Set Theory]] function (which in [[Set Theory]] is defined as a Set of Ordered Pairs).",
      "id": "e1a64c3d54de8b2d45d194532eb5820f"
    },
    {
      "type": "html",
      "text": " A Smalltalk [[Block Closure]] (e.g. [ :x | x > 0 ]) looks a lot like a [[Set Theory]] set comprehension (e.g. {x | x > 0}), though [[Block Closures]] are used for a lot of things other than performing a set comprehension.",
      "id": "82d5a174361954a221d31ac56b006f3c"
    },
    {
      "type": "html",
      "text": "\nThere are of course some implementation issues that means that this mapping is not pure. ",
      "id": "52b8472e5b8fb324e2b4b9a582709a29"
    },
    {
      "type": "html",
      "text": " Classes must form a partial ordering",
      "id": "9a8533d36c205d9cdab112aa6fc4939e"
    },
    {
      "type": "html",
      "text": " Clearly you can't change the membership of an object's class once it's created, but you can change what sets it belongs to. ",
      "id": "782fffaea31dea8dde2cee56064d6639"
    },
    {
      "type": "html",
      "text": " Classes are generally used to define behaviour, sets are used to to define state",
      "id": "f1956b11f217905e379a32325b6c24e0"
    },
    {
      "type": "html",
      "text": "--Daniel Poon",
      "id": "b4de64e4cbb8de2ca86651e207b79399"
    },
    {
      "type": "html",
      "text": "\nI'm not convinced.",
      "id": "8ebf8c15e4f26ad62458722f58c7e3b0"
    },
    {
      "type": "html",
      "text": "\nClasses are not the same thing as sets. You can think of a class as a particular kind of set, just as you can think of a group or a manifold or any other mathematical object as a particular kind of set, but that isn't very interesting. What Smalltalk calls a Set is indeed a set, but it's more specifically a <i>finite</i> set. (Er, maybe you can subclass Set to get certain kinds of infinite set?) Similarly, Smalltalk's [[Ordered Set]]s and Dictionary<b></b>s are specifically <i>finite</i> things. A Smalltalk block need not be a predicate. A block can represent any (computable) function, and of course a block can actually <i>do</i> things (i.e., have side effects), which takes us right outside the realm of set theory.",
      "id": "2cc1822ef5e40849f7df408a1349edd6"
    },
    {
      "type": "html",
      "text": "\nYou can say most of what's said above about Smalltalk about plenty of programming languages. All that's really going on, I think, is that some of the concepts set theorists work with (like, er, that of \"set\") are widely applicable. One exception: I think the decision to say that a Dictionary <i>is</i> a set of associations must have been inspired by the conventions of set theory. -- [[Gareth Mc Caughan]]",
      "id": "eda73b9ee28d87e7dacad109ab8921ca"
    },
    {
      "type": "html",
      "text": "\nYou have pointed out many restrictions in the analogy. Indeed, everything in a computer is finite. You could also point out that a Smalltalk Integer is not really an integer, since it is a finite size. Plus blocks do have side effects. My point is that a lot of ideas and notation are borrowed from pure maths. ",
      "id": "3838782e12ed46d9bd8ae14903d3f0d4"
    },
    {
      "type": "html",
      "text": "\nContrast this with the early computing languages such as FORTRAN that were used for numerical work, so concepts would have been borrowed from applied maths. For example a <i>function</i> in these languages usually refers to an algorithm, such as computing y=x^2. This is quite a different abstraction to saying a function is a set of associations, wouldn't you say?  -- Daniel Poon",
      "id": "565c5d3876ce22c685e7908c4629b4a5"
    },
    {
      "type": "html",
      "text": "\nCertainly is. But Smalltalk doesn't use the word \"function\" for its sets of associations.\nSmalltalk's nearest equivalent of Fortran's functions are the methods, and -- guess what? --\nthey're (implementations of) algorithms. Smalltalk has more data structures than Fortran,\nand inevitably some of them look like ones pure mathematicians use. Anyway, this isn't\nworth arguing about, and I'm sorry if my tone has been too confrontational. I agree that\nat least one thing in Smalltalk looks like it was inspired by the conventions of set theory",
      "id": "9775c2c7a6cda006f0e6e968668fa14d"
    },
    {
      "type": "html",
      "text": "(namely, considering mappings as sets of associations). I just don't think the borrowing\nis all that widespread, and I don't think it makes sense to say \"classes are sets, so\nSmalltalk is borrowing from set theory there\". -- [[Gareth Mc Caughan]]",
      "id": "2fee015c53dc71bb0057aeb42f4658be"
    },
    {
      "type": "html",
      "text": "\nWhat I find is that when I look at a problem, I divide everything up into sets and functions (in the set theoretic sense of function) and draw a few [[Commuting Diagrams]] to clarify the relationships to myself. That mapping all of this onto Smalltalk is then quite easy, Im sure is at least partly coincidence. But I also think some things were put there by design. I guess we will have to wait for a Smalltalk founder to tell us where he/she got the idea for classes and collections -- Daniel Poon. ",
      "id": "e0682f1b88fcc6c1b7d4142924ea7e4d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "fd9a89c217ff37196ae0409b278cf29c"
    },
    {
      "type": "html",
      "text": "\nThe paper also offers insights in why subsequently Smalltalk failed to conquer the world. Almost all items in Future Work failed to materialize. ",
      "id": "a0c83ce4a7f32c94e98fb08465b9be68"
    },
    {
      "type": "html",
      "text": "\nIn particular the prediction: \"Through the use of microcode, and ultimately hardware, system performance can be improved dramatically without any compromise to the other virtues of the system.\" ",
      "id": "63f72e2bf9b0896ccae3871c23a0b4b4"
    },
    {
      "type": "html",
      "text": "<i>At the time, it would have seemed reasonable, as the idea of a 'stock platform' didn't really exist. High-performance computers of the time were all special-purpose designs such as the [[Cray One]], the [[Super Foonly]], or the various [[Lisp Machine]] variants; the Alto was actually a typical system of its time in this regard. Even the mainstream systems such as the 370 might have very different hardware for different models of the product line. The small systems of the time were distinctly underpowered, and came in a vast profusion - even the 'standard' systems built around CP/M and the s100 bus were often incompatible with each other. While Moore's Law was already known, it was assumed that it was these sorts of custom systems that would push the speeds along. Also, the most powerful software of the time (Smalltalk and Lisp) required special hardware in the form of tagged memory and so on, and the idea that these lush, elaborate (but very expensive) systems would be abandoned for droves of Unix and MS-DOS/Windows workstations that provided only a small fraction of their capabilities but which could give far superior cost/performance ratios would have been inconceivable. The fact that this is what actually happened was something that could not have been predicted in 1981. - [[Jay Osako]]</i>",
      "id": "7611c5ef11d7e26245bf409e1dbd927d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "fd9a89c217ff37196ae0409b278cf29c"
    },
    {
      "type": "html",
      "text": "[[Category Paper]] [[Category Smalltalk]]",
      "id": "5b85499fdff616dfcd668878df7f5938"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?DesignPrinciplesBehindSmalltalk c2.com]",
      "id": "212edae2fd0ea424a040aed707f5fe9e"
    }
  ],
  "journal": [
    {
      "date": 1361843613000,
      "id": "adac79d0a4cb04fb92749bfcb3db042f",
      "type": "create",
      "item": {
        "title": "Design Principles Behind Smalltalk",
        "story": [
          {
            "type": "html",
            "text": "[http://users.ipa.net/~dwighth/smalltalk/byte_aug81/design_principles_behind_smalltalk.html users.ipa.net]",
            "id": "0de99186f6e224bfebf829c0f5d94237"
          },
          {
            "type": "html",
            "text": "\nInteresting to see the phrases \"factoring\" and \"well-factored system\" already in 1981.",
            "id": "f5887696a262ebe0bdf17da8566c5b10"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "fd9a89c217ff37196ae0409b278cf29c"
          },
          {
            "type": "html",
            "text": "<i>I don't know about '81 but when I started programming '86, people were always using terms like </i>'factoring<i>, </i>well-factored<i>, and even </i>re-factoring<i>. At the time, this was the preferred term to 're-tooling</i>.''",
            "id": "942eb8b09be7f86d1fda0e7a4ab3647c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "fd9a89c217ff37196ae0409b278cf29c"
          },
          {
            "type": "html",
            "text": "\nI'll never forget the thrill of reading this article in late 1982.",
            "id": "38eb4116216eeb72070d637eec12dc02"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "fd9a89c217ff37196ae0409b278cf29c"
          },
          {
            "type": "html",
            "text": "I just grabbed a copy of this entire issue of BYTE and its just great. It's just as good a read now as it was then.",
            "id": "394d4b4419312495d04c58b4cb4199ba"
          },
          {
            "type": "html",
            "text": "----WONTFIX bug should be reopened.",
            "id": "0243fb1e6664d021ef7a6aebaec57346"
          },
          {
            "type": "html",
            "text": "\nI just read this for the first time, and the introductory sentence was absolutely startling:",
            "id": "262d7de43d527efad26d9c68b5aa7f8c"
          },
          {
            "type": "html",
            "text": "<i>The purpose of the Smalltalk project is to provide computer support for the creative spirit in everyone.</i> ",
            "id": "f27c8c3a16147263dd1426ef6428d58e"
          },
          {
            "type": "html",
            "text": "-- [[Dan Ingalls]]",
            "id": "392df92e566f10a15827eb7a8b94a2e6"
          },
          {
            "type": "html",
            "text": "\nThis seems an unusual thing for a computer scientist to write in a paper. I'm used to seeing papers about languages talk about efficiency, performance, garbage collection, \"compact representations\", etc., etc. -- [[Robert Church]]",
            "id": "9ba074b9b7e6e6a6eefb600ce4e68184"
          },
          {
            "type": "html",
            "text": "<i>That is classic [[Dan Ingalls]], and offers a crisp illustration of the essential difference Smalltalk has for some of us. -- [[Tom Stambaugh]]</i>",
            "id": "4c13c08421a895b98984b1e5f19f1733"
          },
          {
            "type": "html",
            "text": "\nIt may also provide some insight into why Smalltalk is not the prevalent language for commercial software development.  Unfortunately, the creative spirit in everyone is usually irrelevant in that realm.  --[[Kris Johnson]]",
            "id": "d72965286a5282028c82cf4289f05f6b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "fd9a89c217ff37196ae0409b278cf29c"
          },
          {
            "type": "html",
            "text": "\nThe design principles of Smalltalk, the language:",
            "id": "fe4caa1cbf38926fb67caeac3a78e509"
          },
          {
            "type": "html",
            "text": " Every element is an object. Classes, methods, integers, chars, bytecodes, all are objects.",
            "id": "69c9d402286b6270e593c6e2cfd02b21"
          },
          {
            "type": "html",
            "text": " All objects belong to a class that defines their behavior.",
            "id": "e4c286ddce7e60533b97a85dabd02804"
          },
          {
            "type": "html",
            "text": " All classes belong to a class (its metaclass) that defines the class behavior.",
            "id": "681ad9af0a964b75f147cab3516ae90e"
          },
          {
            "type": "html",
            "text": "\nThe design principles of Smalltalk, the environment:",
            "id": "5b31da2eb6862490ff9826686c867c78"
          },
          {
            "type": "html",
            "text": " The environment is written in Smalltalk and it is interpreted in the environment itself.",
            "id": "eb92e77367959344bc84db7a0ed4b586"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "fd9a89c217ff37196ae0409b278cf29c"
          },
          {
            "type": "html",
            "text": "\nThough [[Smalltalk Language]] is very human-oriented, it does seem to borrow a lot of concepts and terminology and notation from dizzy heights of [[Set Theory]]. ",
            "id": "f5054cd2ce72fc9240da8dd1d4214295"
          },
          {
            "type": "html",
            "text": " Classes are another name for Sets ",
            "id": "5674440199e2dd964e2b72b9642c1348"
          },
          {
            "type": "html",
            "text": " The Smalltalk class called Object (the class that contains everything) is the [[Set Theory]] [[Universal Set]] (the set that contains everything).",
            "id": "ba56dd2673e96188dad0e81fac8ef8e9"
          },
          {
            "type": "html",
            "text": " A Smalltalk Set is a [[Set Theory]] Set. ",
            "id": "3b2709fd33a8b2ac3961ef1f5e37dda6"
          },
          {
            "type": "html",
            "text": " A Smalltalk [[Ordered Collection]] is a [[Set Theory]] Ordered Set.",
            "id": "6f843ae5d2540fa8fc63426b0b4bb4ff"
          },
          {
            "type": "html",
            "text": " A Smalltalk Association is [[Set Theory]] Ordered Pair. ",
            "id": "ea31ff533381ffb2d8743c15cb0bb1f3"
          },
          {
            "type": "html",
            "text": " A Smalltalk Dictionary (which is defined in Smalltalk as a collection of Associations) is the same as a [[Set Theory]] function (which in [[Set Theory]] is defined as a Set of Ordered Pairs).",
            "id": "e1a64c3d54de8b2d45d194532eb5820f"
          },
          {
            "type": "html",
            "text": " A Smalltalk [[Block Closure]] (e.g. [ :x | x > 0 ]) looks a lot like a [[Set Theory]] set comprehension (e.g. {x | x > 0}), though [[Block Closures]] are used for a lot of things other than performing a set comprehension.",
            "id": "82d5a174361954a221d31ac56b006f3c"
          },
          {
            "type": "html",
            "text": "\nThere are of course some implementation issues that means that this mapping is not pure. ",
            "id": "52b8472e5b8fb324e2b4b9a582709a29"
          },
          {
            "type": "html",
            "text": " Classes must form a partial ordering",
            "id": "9a8533d36c205d9cdab112aa6fc4939e"
          },
          {
            "type": "html",
            "text": " Clearly you can't change the membership of an object's class once it's created, but you can change what sets it belongs to. ",
            "id": "782fffaea31dea8dde2cee56064d6639"
          },
          {
            "type": "html",
            "text": " Classes are generally used to define behaviour, sets are used to to define state",
            "id": "f1956b11f217905e379a32325b6c24e0"
          },
          {
            "type": "html",
            "text": "--Daniel Poon",
            "id": "b4de64e4cbb8de2ca86651e207b79399"
          },
          {
            "type": "html",
            "text": "\nI'm not convinced.",
            "id": "8ebf8c15e4f26ad62458722f58c7e3b0"
          },
          {
            "type": "html",
            "text": "\nClasses are not the same thing as sets. You can think of a class as a particular kind of set, just as you can think of a group or a manifold or any other mathematical object as a particular kind of set, but that isn't very interesting. What Smalltalk calls a Set is indeed a set, but it's more specifically a <i>finite</i> set. (Er, maybe you can subclass Set to get certain kinds of infinite set?) Similarly, Smalltalk's [[Ordered Set]]s and Dictionary<b></b>s are specifically <i>finite</i> things. A Smalltalk block need not be a predicate. A block can represent any (computable) function, and of course a block can actually <i>do</i> things (i.e., have side effects), which takes us right outside the realm of set theory.",
            "id": "2cc1822ef5e40849f7df408a1349edd6"
          },
          {
            "type": "html",
            "text": "\nYou can say most of what's said above about Smalltalk about plenty of programming languages. All that's really going on, I think, is that some of the concepts set theorists work with (like, er, that of \"set\") are widely applicable. One exception: I think the decision to say that a Dictionary <i>is</i> a set of associations must have been inspired by the conventions of set theory. -- [[Gareth Mc Caughan]]",
            "id": "eda73b9ee28d87e7dacad109ab8921ca"
          },
          {
            "type": "html",
            "text": "\nYou have pointed out many restrictions in the analogy. Indeed, everything in a computer is finite. You could also point out that a Smalltalk Integer is not really an integer, since it is a finite size. Plus blocks do have side effects. My point is that a lot of ideas and notation are borrowed from pure maths. ",
            "id": "3838782e12ed46d9bd8ae14903d3f0d4"
          },
          {
            "type": "html",
            "text": "\nContrast this with the early computing languages such as FORTRAN that were used for numerical work, so concepts would have been borrowed from applied maths. For example a <i>function</i> in these languages usually refers to an algorithm, such as computing y=x^2. This is quite a different abstraction to saying a function is a set of associations, wouldn't you say?  -- Daniel Poon",
            "id": "565c5d3876ce22c685e7908c4629b4a5"
          },
          {
            "type": "html",
            "text": "\nCertainly is. But Smalltalk doesn't use the word \"function\" for its sets of associations.\nSmalltalk's nearest equivalent of Fortran's functions are the methods, and -- guess what? --\nthey're (implementations of) algorithms. Smalltalk has more data structures than Fortran,\nand inevitably some of them look like ones pure mathematicians use. Anyway, this isn't\nworth arguing about, and I'm sorry if my tone has been too confrontational. I agree that\nat least one thing in Smalltalk looks like it was inspired by the conventions of set theory",
            "id": "9775c2c7a6cda006f0e6e968668fa14d"
          },
          {
            "type": "html",
            "text": "(namely, considering mappings as sets of associations). I just don't think the borrowing\nis all that widespread, and I don't think it makes sense to say \"classes are sets, so\nSmalltalk is borrowing from set theory there\". -- [[Gareth Mc Caughan]]",
            "id": "2fee015c53dc71bb0057aeb42f4658be"
          },
          {
            "type": "html",
            "text": "\nWhat I find is that when I look at a problem, I divide everything up into sets and functions (in the set theoretic sense of function) and draw a few [[Commuting Diagrams]] to clarify the relationships to myself. That mapping all of this onto Smalltalk is then quite easy, Im sure is at least partly coincidence. But I also think some things were put there by design. I guess we will have to wait for a Smalltalk founder to tell us where he/she got the idea for classes and collections -- Daniel Poon. ",
            "id": "e0682f1b88fcc6c1b7d4142924ea7e4d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "fd9a89c217ff37196ae0409b278cf29c"
          },
          {
            "type": "html",
            "text": "\nThe paper also offers insights in why subsequently Smalltalk failed to conquer the world. Almost all items in Future Work failed to materialize. ",
            "id": "a0c83ce4a7f32c94e98fb08465b9be68"
          },
          {
            "type": "html",
            "text": "\nIn particular the prediction: \"Through the use of microcode, and ultimately hardware, system performance can be improved dramatically without any compromise to the other virtues of the system.\" ",
            "id": "63f72e2bf9b0896ccae3871c23a0b4b4"
          },
          {
            "type": "html",
            "text": "<i>At the time, it would have seemed reasonable, as the idea of a 'stock platform' didn't really exist. High-performance computers of the time were all special-purpose designs such as the [[Cray One]], the [[Super Foonly]], or the various [[Lisp Machine]] variants; the Alto was actually a typical system of its time in this regard. Even the mainstream systems such as the 370 might have very different hardware for different models of the product line. The small systems of the time were distinctly underpowered, and came in a vast profusion - even the 'standard' systems built around CP/M and the s100 bus were often incompatible with each other. While Moore's Law was already known, it was assumed that it was these sorts of custom systems that would push the speeds along. Also, the most powerful software of the time (Smalltalk and Lisp) required special hardware in the form of tagged memory and so on, and the idea that these lush, elaborate (but very expensive) systems would be abandoned for droves of Unix and MS-DOS/Windows workstations that provided only a small fraction of their capabilities but which could give far superior cost/performance ratios would have been inconceivable. The fact that this is what actually happened was something that could not have been predicted in 1981. - [[Jay Osako]]</i>",
            "id": "7611c5ef11d7e26245bf409e1dbd927d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "fd9a89c217ff37196ae0409b278cf29c"
          },
          {
            "type": "html",
            "text": "[[Category Paper]] [[Category Smalltalk]]",
            "id": "5b85499fdff616dfcd668878df7f5938"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?DesignPrinciplesBehindSmalltalk c2.com]",
            "id": "212edae2fd0ea424a040aed707f5fe9e"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1626125919518
    },
    {
      "type": "edit",
      "id": "0de99186f6e224bfebf829c0f5d94237",
      "item": {
        "type": "html",
        "text": "[https://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html page]",
        "id": "0de99186f6e224bfebf829c0f5d94237"
      },
      "date": 1641221281193
    },
    {
      "type": "edit",
      "id": "0de99186f6e224bfebf829c0f5d94237",
      "item": {
        "type": "html",
        "text": "BYTE Magazine, August 1981. (c) by The McGraw-Hill Companies, Inc., NY.\nCopied from http://users.ipa.net/~dwighth/smalltalk/byte_aug81/design_principles_behind_smalltalk.html\nScanned in and converted to HTML (with recreated graphics) by Dwight Hughes. [https://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html page]",
        "id": "0de99186f6e224bfebf829c0f5d94237"
      },
      "date": 1641221301172
    },
    {
      "type": "edit",
      "id": "0de99186f6e224bfebf829c0f5d94237",
      "item": {
        "type": "html",
        "text": "BYTE Magazine, August 1981. (c) by The McGraw-Hill Companies, Inc., NY.\nCopied from [http://users.ipa.net/~dwighth/smalltalk/byte_aug81/design_principles_behind_smalltalk.html users.ipa.net]\nScanned in and converted to HTML (with recreated graphics) by Dwight Hughes. [https://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html page]",
        "id": "0de99186f6e224bfebf829c0f5d94237"
      },
      "date": 1641221343277
    },
    {
      "type": "edit",
      "id": "0de99186f6e224bfebf829c0f5d94237",
      "item": {
        "type": "html",
        "text": "BYTE Magazine, August 1981. (c) by The McGraw-Hill Companies, Inc., NY.\nCopied from [http://users.ipa.net/~dwighth/smalltalk/byte_aug81/design_principles_behind_smalltalk.html users.ipa.net] [https://web.archive.org/web/19991110010817/http://users.ipa.net/~dwighth/smalltalk/byte_aug81/design_principles_behind_smalltalk.html wayback]\nScanned in and converted to HTML (with recreated graphics) by Dwight Hughes. [https://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html page]",
        "id": "0de99186f6e224bfebf829c0f5d94237"
      },
      "date": 1641221407286
    }
  ]
}