{
  "title": "Prolog Language",
  "story": [
    {
      "type": "html",
      "text": "<i>The Prolog programming language has a long history and a bright future.</i> - taken from this good attempt at a home site (archived): [http://web.archive.org/web/20011031081230/http://www.practical-applications.co.uk/Prolog/ web.archive.org]",
      "id": "ab70bdbcfe4f5f66bd1767c4ea2579cb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "Programming in [[Horn Clauses]] with a built-in unification algorithm. If you do it right, every program can run multiple ways. For example, code that multiplies 2 numbers to give a third will, if just given the third, provide all the factors. If traditional languages are like prose, Prolog is like poetry.",
      "id": "ecb46018fbeac8c6494b4d18611fdb47"
    },
    {
      "type": "html",
      "text": "\nProlog is the classical [[Logic Programming Language]].",
      "id": "a8ba44ce5afeaf819a2204142d9a4275"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "\n[[Obligatory Quote]]s",
      "id": "6e95193fb39bac4c2f60a7f6ec9f4f3d"
    },
    {
      "type": "html",
      "text": "\"It was invented by [[Bob Kowalski]] in 1974 and implemented by [[Alain Colmerauer]] in 1973.\"",
      "id": "7592d24d3e6c3bf144c0d79883e3e92d"
    },
    {
      "type": "html",
      "text": "1972 - Alain Colmerauer designs the logic language Prolog. His goal is to create a language with the intelligence of a two year old. He proves he has reached his goal by showing a Prolog session that says \"No.\" to every query. -- <i>From A Brief, Incomplete, and Mostly Wrong History of Programming Languages - [http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html james-iry.blogspot.com]</i>",
      "id": "ee24dca7522258535dde4d2b68ef80e0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "I've done some Prolog for school assignments. I suppose that I could learn to love it, but it is hard to get over what I felt was a deception. I was led to believe that you didn't have to care as much about the operational model of the language. I thought it was going to be more purely declarative.",
      "id": "49bf92c401473d51be3364405f42b84b"
    },
    {
      "type": "html",
      "text": "<i>Prolog is not completely declarative because you sometimes need to control the backtracking of the unification algorithm with the \"cut\" operator. More modern logic programming languages, such as [[Mercury Language]] [and [[Data Log]]], completely separate the unification algorithm from the program code, and so are [more] declarative.</i>",
      "id": "cad2b154f3a43a0a3f65dd0c765543ac"
    },
    {
      "type": "html",
      "text": "\nBut Mercury and other languages similar to it, such as [[Oz Language]] (as seen in the [[Mozart Programming System]] environment) and Godel are committed choice languages, because they curb Prolog-style backtracking and unification in order to provide parallelism and concurrency. They're certainly similar and share Prolog's influence, and are characteristic of logic-based languages in general, but they aren't Prolog in a classical sense (not that I'm implying anyone is saying that they are, I just wanted to add that to the discussion). -- [[Dan Moniz]]",
      "id": "6dbe0cc47059d37773b99904ca3d9767"
    },
    {
      "type": "html",
      "text": "<i>Excuse me! Although [[Mercury Language]] indeed has [[Committed Choice]] (a.k.a. [[Dont Care Nondeterminism]]), which is used for concurrency, (amongst other things), it also has ordinary Prolog-style nondeterminism (sometimes known as [[Dont Know Nondeterminism]]) (of which [[Back Tracking]] is one possible implementation technique). Regarding unification it is true that (currently) in [[Mercury Language]] one can't use variable-sharing, as in, e.g., [[Difference List]]s. This is due to not having a way to express sharing uninstantiated terms in the (statically checked) mode/inst language. -- [[Stefan Ljungstrand]]</i>",
      "id": "027956f2dc9ad8a0fe218adaab4813fb"
    },
    {
      "type": "html",
      "text": "\nSee [[Non Deterministic]]",
      "id": "590b1dc4bff9173d61781bf0a2b45544"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "\nI used Prolog in a comparative languages course. The biggest program we did was a map-coloring one (color a map with only four colors so that no bordering items have the same color, given a mapping of things that border each other). I say biggest because we were given the most time with it. I started out like most people in my class trying to hack the language into letting me code a stinking algorithm to color a stinking map. Then I wrote a test function to check if the map was colored and, in a flash of prolog, realized that that was really all I needed to code.",
      "id": "24588498605f5dc5f02ccb843ee2b838"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "<i>[...] it is hard to get over what I felt was a deception.</i>",
      "id": "6cad9b1d42bced4175f186988e4fa7dc"
    },
    {
      "type": "html",
      "text": "\nI think this is what most people exposed to [[Prolog Language]] remember strongly, the initial disappointment. It takes a lot of good experiences to overcome that feeling, and few ever get that chance. -- [[Anders Bengtsson]]",
      "id": "7e18e5926e0190695c9f275cce23404a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "Here's a taste of Prolog, for those who haven't used it. Using the code below, you can get Prolog to generate all bit strings of length 3:",
      "id": "37126b89fa8b2869034fee9e41630f2b"
    },
    {
      "type": "html",
      "text": " ?- bits(3,Bits).",
      "id": "5bc57724449e0dcfdc42ea94b8b27b36"
    },
    {
      "type": "code",
      "text": " Bits = [0, 0, 0] ;\n Bits = [0, 0, 1] ;\n Bits = [0, 1, 0] ;\n Bits = [0, 1, 1] ;\n Bits = [1, 0, 0] ;\n Bits = [1, 0, 1] ;\n Bits = [1, 1, 0] ;\n Bits = [1, 1, 1] ;\n No",
      "id": "ad600c697f4a568cec1ddd0d7c6136e4"
    },
    {
      "type": "html",
      "text": "Here's the code:",
      "id": "899a020030beba3b853124127d93d60c"
    },
    {
      "type": "code",
      "text": " % Non-deterministically returns a string of N bits.\n %  bits(+N,?Bit_string)\n bits(0,[]).\n bits(N, [R | Rs]) :-\n  N > 0,\n  bit(R),\n  N1 is N - 1,\n  bits(N1,Rs).",
      "id": "4c15168ed1d1580357b70296665562c6"
    },
    {
      "type": "code",
      "text": " bit(0). bit(1).",
      "id": "9f923e55a15f011e7ba9b37a79c5f175"
    },
    {
      "type": "html",
      "text": "\nHere is another example.",
      "id": "f851b8db043dfdd39722e22f4982ace7"
    },
    {
      "type": "code",
      "text": " bit(0). bit(1). \n bits(X,Y,Z) :-       \n  bit(X),\n  bit(Y),\n  bit(Z),\n  write(X),\n  write(Y),\n  write(Z),\n  nl,\n  fail.",
      "id": "6570b7040d6754477f858751a38a5609"
    },
    {
      "type": "html",
      "text": "\nThe predicate (something like a function, though it doesn't work like a function) <i>bits</i> is non-deterministic, and returns multiple answers. In this example, it generates all bit strings of length 3. This is a quick and dirty tool for combinatorial computing, and you can easily use it to generate bits strings as input to other functions. You can also use <i>bits</i> to check if a list is a bit string, e.g.:",
      "id": "cc5691f03f93c5bcda1ee3f3e85b8f45"
    },
    {
      "type": "html",
      "text": " ?- bits(5,[1,0,1,1,1]).",
      "id": "182442809877b380ab172cb25cd5671b"
    },
    {
      "type": "code",
      "text": "  Yes",
      "id": "61830d2cf052c672bb75c68cb04f9847"
    },
    {
      "type": "html",
      "text": " ?- bits(5,[1,1,1,1,0,1]).",
      "id": "e22f3c4bd14aee80375d5ac9a5c482cd"
    },
    {
      "type": "code",
      "text": "  No",
      "id": "98fde78cf49462aaa3c0ce958e361d15"
    },
    {
      "type": "html",
      "text": "But, and this is one of the frustrating parts of Prolog, this particular predicate doesn't work if the first parameter is a variable, e.g.",
      "id": "8b91e3a4681ba4bcfe415f2534d4cdba"
    },
    {
      "type": "html",
      "text": " ?-  bits(N,[1,1,1,1,0,1]).",
      "id": "569058ab4942b33741349e98a7a50032"
    },
    {
      "type": "html",
      "text": "ERROR:<br>Arguments are not sufficiently instantiated",
      "id": "4497e9a1bca87dfd71b8dadb9c88755c"
    },
    {
      "type": "html",
      "text": "This error refers to the line <i>N > 0</i>, which requires that <i>N</i> be instantiated. [[Constraint Logic Programming]] is a useful extension of [[Logic Programming]] that partially solves this sort of problem.",
      "id": "e42f1383a1b67a258c9c7e4b07c3d684"
    },
    {
      "type": "html",
      "text": "\nIf you would like to have the predicate also count the length of bit strings, add a second clause that checks for an uninstantiated variable, cuts choice point for the other recursive case, checks the first element of the list for being a bit, make a recursive call and increment the count as the stack unwinds.  The new predicate would be,",
      "id": "0b16b2070d4097832b8510573146d0e0"
    },
    {
      "type": "code",
      "text": " % Non-deterministically returns a string of N bits or returns the length of a bit string.\n %  bits(+N,?Bit_string)\n %  bits(?N,+Bit_string)\n  bits(0,[]).\n  bits(N, [R | Rs]) :-\n  var(N), !,\n  bit(R),\n  bits(N1, Rs),\n  N is N1 + 1.\n  bits(N, [R | Rs]) :-\n   N > 0,\n  bit(R),\n  N1 is N - 1,\n  bits(N1,Rs).\n  bit(0). bit(1).",
      "id": "05ebdbd3a2482fb81d3d2817fe86c478"
    },
    {
      "type": "html",
      "text": "\nThis modified version gives the expected,",
      "id": "4820c0cd98dd6e8385de2d2217557b8e"
    },
    {
      "type": "code",
      "text": "  | ?-  bits(N,[1,1,1,1,0,1]).",
      "id": "6b5a236fcc68d9dd0ed99030ed786342"
    },
    {
      "type": "code",
      "text": "  N = 6 ? ;",
      "id": "e5580019b42ca17a1a3dfbd955ed3708"
    },
    {
      "type": "code",
      "text": "  no",
      "id": "6a2fcde9c5f61e878f98c6543bbc1597"
    },
    {
      "type": "html",
      "text": "\nwith no dangling choice points.  What may be less obvious is the result of bits(X,Y) in this modified version or even what modifications would allow it to generate all combinations of bits for increasing length lists.",
      "id": "e95a63b33ec1cc65fa77ba7be12e6244"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "\nAn operational way to understand Prolog is to say that predicates are actually what ordinary people would call procedure calls.",
      "id": "7a89032424db18c2865ebbf229147485"
    },
    {
      "type": "html",
      "text": "<i>Regrettably, this is insufficient. Using predicates procedurally is possible with judicious use of the cut operator, but to do that removes all the advantages of using [[Prolog Language]]. Think of a predicate instead as a search string. [[Prolog Language]] will then become something else for you, something a lot closer to poetry than to prose.</i>",
      "id": "2e338925d889e5992a828589192b540e"
    },
    {
      "type": "html",
      "text": "<i>For this reason, [[Prolog Programs]] are typically extremely short compared with their procedural equivalents. It's a common experience that 1,000 lines of COBOL -> 100 lines of C -> 10 lines of [[Small Talk]] -> 1 line of [[Prolog Language]].</i>",
      "id": "8e2f80aa1926d00b47c6a3e5c8369cc4"
    },
    {
      "type": "html",
      "text": "<i>So why don't professional software developments use it more? Well, it's slower than most procedural languages, and it can be extremely difficult to maintain. The last time I saw it used on any large scale was code for pacemaker/defibrillators, where it was combined with [[Tony Hoare]]'s program correctness-proving techniques to reduce legal liabilities. In that problem domain you understand that a fatal error is really a <b>fatal error</b>.</i>",
      "id": "a9087c40beeceea1fc70cf2b0db07162"
    },
    {
      "type": "html",
      "text": "<i>Still ... perhaps [[Prolog Language]] might be neat for [[Acceptance Test]]ing?</i> -- [[Peter Merel]]",
      "id": "7301c587cae8ed7e78f0007bdf2816c4"
    },
    {
      "type": "html",
      "text": "\nPerhaps the difficulty with using the [[Prolog Language]] is that [[Prolog Programmers]] are good and hard to find. [[Logic Programming]] is hard to fake and does not come easy to a mind used to procedural programming. Since [[Prolog Programmers]] tend to have a logical or philosophical disposition, they are often considered hard to manage and often are hard to replace. Many folks only recall the [[Prolog Language]] as something they never really understood from some graduate course in [[Symbolic Programming]]. Perhaps [http://www.gnu.org/software/gprolog/ www.gnu.org] will encourage a wider audience to experiment with [[Logic Programming]] in the open and comfortable environment of the bazaar. -- [[Vic Bancroft]]",
      "id": "75f8b5e1f15acee7254af6e1394eac9a"
    },
    {
      "type": "html",
      "text": "\nI like [[Prolog Language]] very much, others might like other languages. As a tool, any languages have the possibility to solve a particular problem, and if not, probably it is just a matter to wait for a future release powerful enough that shall solve its weaknesses.  I would also say, that the use of a particular language is more related with the expertise, time available to learn alternative languages, economics, former source code available, ideas.... well you name it. There is little benefit in stating if a particular language is better than other, each one will eventually fall in its place. In my case, I am so used to think in prolog terms that I found difficult to learn a new/switch back to a procedural programming -- even though I�m really interested-. I would like to encourage those who do not feel comfortable with your actual choose, to try prolog.  but please keep in mind  that there are different flavors of prolog, choose wisely before you get hooked.",
      "id": "2960e6d31ff343017c2120dd18fa7c0d"
    },
    {
      "type": "html",
      "text": "\nIt would indeed be nice to combine the power of Prolog with a \"normal\" language such as C or C++. Many \"trivial\" problems in, say C, are non-trivial in Prolog and vice versa. A hybrid language merging the best of both worlds would indeed be very interesting. A reason why Prolog isn't used as much among commercial developers could simply be the fact that it's difficult to grasp, or at least more difficult than procedural and even OO languages. -- Lennart Frid�n",
      "id": "e9f8ee4f39bc419c20746a4913006ec2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "From the days of Borland [[Turbo Prolog]] and TurboC (early 90s) it was relatively easy to call one from the other. Nowadays MSWindows languages can call each other using COM (DLLs), corba, or on unix (static or dynamic) libraries. For both also object methods can be packaged as [[Web Services]] so you could have a dynamic web application using C, Java or Perl as the main \"glue\" that calls Prolog functors behind the scenes for special processing. Same is true for other [[Symbolic Processing]] languages like scheme ie [[Jay Scheme]] embeds scheme in Java you can architect a [[Hybrid Application]] to use each language for what it's best at.",
      "id": "446137650aa3a71059b926d77e79627e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "A good open source Prolog implementation is SWI-Prolog (both Windows and Unix, see [http://www.swi-prolog.org/ www.swi-prolog.org]). It has the ability to make GUI front ends using xpce.",
      "id": "cb1de43c5e80bdef34f448da3f3dcda3"
    },
    {
      "type": "html",
      "text": "\nThere is also a [[Pocket Pc]] port at\n[http://www.rainer-keuchel.de/wince/swi-prolog.html www.rainer-keuchel.de]",
      "id": "98d8a8f3a07dac517a904656e7b196af"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "I have a collection of resources on Prolog -- syntax, semantics, glossary, predicates, examples, etc. at\n[http://csci.csusb.edu/dick/samples/prolog.html csci.csusb.edu]",
      "id": "f9c38f87d6d560dcf87e6d431573373d"
    },
    {
      "type": "html",
      "text": "--[[Richard Botting]]",
      "id": "ccfc636809d94f0d350bb5bedad40f8d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "Eclipse Prolog meanwhile has gone open source and comes with various constraint solvers:\n[http://www.sourceforge.net/projects/eclipse-clp www.sourceforge.net]",
      "id": "9ef5854a3adf5adcb3f82a9680cf0e8b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "My idea is to make  Prolog  easier by using if-then-else clauses.",
      "id": "d3a2fe678bea39725c43192c02b461d0"
    },
    {
      "type": "html",
      "text": "<i>How would that work?  Prolog has implicit flow control (apart from the cut operator, which is a wart).</i>",
      "id": "5ac8d94faf916db3b2c5441011186516"
    },
    {
      "type": "code",
      "text": " if(Condition, TrueClause, FalseClause) :-\n  Condition, !, TrueClause;\n  !, FalseClause)",
      "id": "a7acd1d728d50803f1591d0e15d0743c"
    },
    {
      "type": "html",
      "text": "- I think. I don't have an implementation installed at the moment to check it, though. --[[Dor Kleiman]]",
      "id": "0991aa163341a6b7ca31235cd51c16f9"
    },
    {
      "type": "html",
      "text": "\nProlog already has an \"if_then_\" operator:",
      "id": "463311cb5531b19df3ffd7b4d8351459"
    },
    {
      "type": "code",
      "text": "  Condition -> TrueClause; !, FalseClause",
      "id": "ae0e6dc762adc4ed3eb599dcaafa0784"
    },
    {
      "type": "html",
      "text": "--[[Richard Botting]]",
      "id": "ccfc636809d94f0d350bb5bedad40f8d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "Java:",
      "id": "e4ff7b7033002ffb925f1f3627ff3fe5"
    },
    {
      "type": "code",
      "text": " if (x == 1) {\n  y = 0;\n } else {\n  y = 1;\n }",
      "id": "6bb12089d3677e4fdb4240a0ba71b4f2"
    },
    {
      "type": "code",
      "text": " Alternatively:\n  y = (x == 1) ? 0 : 1;",
      "id": "e2b7cb19a25f925732559a4aa3326974"
    },
    {
      "type": "html",
      "text": "\nProlog:",
      "id": "9ab4cd12d67af3d0055fcec05d8c78ec"
    },
    {
      "type": "code",
      "text": " if(X, Y) :-\n  \\+ var(X),\n  var(Y),\n  X is 1,  % if this fails, prolog tries the next clause of if/2\n  Y is 0.",
      "id": "edfedf0351d89cb4005f970e20f8f926"
    },
    {
      "type": "code",
      "text": " if(X, Y) :-\n  \\+ var(X),\n  var(Y),\n  Y is 0.",
      "id": "a80163badbd221b9e371a79f4284bdbe"
    },
    {
      "type": "code",
      "text": " ?- if(0, A).\n A = 1.",
      "id": "c91945ad178bd52f1d89f985641d61e1"
    },
    {
      "type": "code",
      "text": " ?- if(1, A).\n A = 0.",
      "id": "50bda9f142feca9d39509810ab3c2e48"
    },
    {
      "type": "html",
      "text": "\nmoral:\nProlog CAN handle if-then-else clauses but not in the conventional sense. As [[Dor Kleiman]] says above, flow control is implicit and much of it is handled by the implementation.",
      "id": "7d63f694c2bf444031bda81921bc160f"
    },
    {
      "type": "html",
      "text": "<i>This is can be even simpler in Prolog:</i>",
      "id": "89fa7e114ba7b82633b03a3e1de1750f"
    },
    {
      "type": "code",
      "text": " if(1, 0).\n if(_, 1).",
      "id": "e55ffa824d88f491399820ac4dff87f0"
    },
    {
      "type": "code",
      "text": " ?- if(0, A).\n A = 1.",
      "id": "c91945ad178bd52f1d89f985641d61e1"
    },
    {
      "type": "code",
      "text": " ?- if(1, A).\n A = 0.",
      "id": "50bda9f142feca9d39509810ab3c2e48"
    },
    {
      "type": "html",
      "text": "<i>Of course, now the word 'if' is consumed for this purpose... a rather poor choice, seriously.</i>",
      "id": "1951cf6db53d729f8d71f7d4e933e043"
    },
    {
      "type": "html",
      "text": "\nThe prolog program above does not reflect the Java snippet, it would translate to",
      "id": "3dd00d076fac6e98f271f249965e5ddf"
    },
    {
      "type": "html",
      "text": "\npublic int ifx(int x) { //for lack of a better name",
      "id": "b47ff1860d13ad0a7e5cc1b6df027c9c"
    },
    {
      "type": "html",
      "text": "return  (x == 1) ? 0 :<br>1;",
      "id": "f36b1a6a8cb0176431e440d36a5f6744"
    },
    {
      "type": "html",
      "text": "}",
      "id": "6c11f82fb23d14ade77eac5965a616ee"
    },
    {
      "type": "html",
      "text": "\nThe -> operator reflects the if-then-else more closely, and is, as stated above a short form for  (condition, ! thenClause); !, elseClause.",
      "id": "89f77b95282d31899392ecca53a3701e"
    },
    {
      "type": "html",
      "text": "\nBy the way, a constraint language could express the same thing as x#=\\=y (unequal), given appropriate domain definitions.",
      "id": "a6586ba1631797d8375a8bf19d431922"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "\nProlog and RDF. ",
      "id": "eb54b4c132cb807ef2129b4163fe42f0"
    },
    {
      "type": "html",
      "text": "\nA lot of people have mentioned (both positively and negatively) the similarities between Prolog and RDF ([[Resource Description Framework]]) / [[Semantic Web]] stuff. I'm wondering, if anyone is evolving either Prolog or some derivative to be a good Semantic Web language. My limited experience with Prolog suggests that the idea is interesting, but it <i>feels</i> a bit bogged down and brittle. For example, does a state-of-the-art logic programming language still have to use capitalization to make the difference between variables and tokens? -- [[Phil Jones]]",
      "id": "bac3b25e7a5f705c20909387f952bdd3"
    },
    {
      "type": "html",
      "text": "<i>The SML family ([[Sml Language]]) seems to get along with significant case.  If you want to avoid collisions, the alternative is going to be to use some kind of sigil (yuck) as overlapping the namespaces would be really quite tricky and error-prone.</i>",
      "id": "484732bece1f07ef170a133edea8da0e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "\nThere is a built in symbol that is very similar to an If-Then statement - \"Condition -> Action\".\nTo make it clearer:",
      "id": "ffabdd537b8d22bd3d1bef5ad48ebd2d"
    },
    {
      "type": "html",
      "text": "[If] Condition -> [Then] Action ; [Else] Action.",
      "id": "d6aeea40c25fab6731fdddae01577d28"
    },
    {
      "type": "html",
      "text": "<i>This comes from plain old logic, where -> means \"implies\", in the mathematical sense. </i>",
      "id": "4c6f48bc6d49d0fa44ebbf68e4fb8780"
    },
    {
      "type": "html",
      "text": "<i>x->y is equivalent to \"if x, then y\" or \"y if x\". I would imagine (not having used the language)</i>",
      "id": "aa5f933c6f31a616dad3abc7bdbc2b53"
    },
    {
      "type": "html",
      "text": "<i>that the prolog way of doing things doesn't fit the if/then/else paradigm, but more that the results</i>",
      "id": "693e2faa6c87175aa255af75a702e82f"
    },
    {
      "type": "html",
      "text": "<i>of an implication would be further used in a program without the need for an explicit else. -[[Jason Espinosa]]</i>",
      "id": "5d8a272ba696626e523a5e3b7d55e64e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "There is a related language PARLOG which is a concurrent logic programming language - see [http://www.parlog.com/en/parlog.html www.parlog.com]",
      "id": "b208f26c920d2feb93d56acc71b98510"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "There is another Windows Prolog evolving at [http://dobrev.com dobrev.com] as Strawberry Prolog in Sofia, Bulgaria.\n[[Strawberry Prolog]]?.",
      "id": "6a8cc26ef600ef1709a90043d3bcee45"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cae669344d156644d90278680c31cd6"
    },
    {
      "type": "html",
      "text": "See [[Non Deterministic]]",
      "id": "6286b7ee14721b652966869ccac90672"
    },
    {
      "type": "html",
      "text": "\n[[Category Programming Language]]",
      "id": "28961595a5875f48be75bcdb6cb259f6"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?PrologLanguage c2.com]",
      "id": "25cb7d726af68e5b07a7eda5d0ee196f"
    }
  ],
  "journal": [
    {
      "date": 1397143948000,
      "id": "24dd2f3d1dcc309f21de9d405e08f023",
      "type": "create",
      "item": {
        "title": "Prolog Language",
        "story": [
          {
            "type": "html",
            "text": "<i>The Prolog programming language has a long history and a bright future.</i> - taken from this good attempt at a home site (archived): [http://web.archive.org/web/20011031081230/http://www.practical-applications.co.uk/Prolog/ web.archive.org]",
            "id": "ab70bdbcfe4f5f66bd1767c4ea2579cb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "Programming in [[Horn Clauses]] with a built-in unification algorithm. If you do it right, every program can run multiple ways. For example, code that multiplies 2 numbers to give a third will, if just given the third, provide all the factors. If traditional languages are like prose, Prolog is like poetry.",
            "id": "ecb46018fbeac8c6494b4d18611fdb47"
          },
          {
            "type": "html",
            "text": "\nProlog is the classical [[Logic Programming Language]].",
            "id": "a8ba44ce5afeaf819a2204142d9a4275"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "\n[[Obligatory Quote]]s",
            "id": "6e95193fb39bac4c2f60a7f6ec9f4f3d"
          },
          {
            "type": "html",
            "text": "\"It was invented by [[Bob Kowalski]] in 1974 and implemented by [[Alain Colmerauer]] in 1973.\"",
            "id": "7592d24d3e6c3bf144c0d79883e3e92d"
          },
          {
            "type": "html",
            "text": "1972 - Alain Colmerauer designs the logic language Prolog. His goal is to create a language with the intelligence of a two year old. He proves he has reached his goal by showing a Prolog session that says \"No.\" to every query. -- <i>From A Brief, Incomplete, and Mostly Wrong History of Programming Languages - [http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html james-iry.blogspot.com]</i>",
            "id": "ee24dca7522258535dde4d2b68ef80e0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "I've done some Prolog for school assignments. I suppose that I could learn to love it, but it is hard to get over what I felt was a deception. I was led to believe that you didn't have to care as much about the operational model of the language. I thought it was going to be more purely declarative.",
            "id": "49bf92c401473d51be3364405f42b84b"
          },
          {
            "type": "html",
            "text": "<i>Prolog is not completely declarative because you sometimes need to control the backtracking of the unification algorithm with the \"cut\" operator. More modern logic programming languages, such as [[Mercury Language]] [and [[Data Log]]], completely separate the unification algorithm from the program code, and so are [more] declarative.</i>",
            "id": "cad2b154f3a43a0a3f65dd0c765543ac"
          },
          {
            "type": "html",
            "text": "\nBut Mercury and other languages similar to it, such as [[Oz Language]] (as seen in the [[Mozart Programming System]] environment) and Godel are committed choice languages, because they curb Prolog-style backtracking and unification in order to provide parallelism and concurrency. They're certainly similar and share Prolog's influence, and are characteristic of logic-based languages in general, but they aren't Prolog in a classical sense (not that I'm implying anyone is saying that they are, I just wanted to add that to the discussion). -- [[Dan Moniz]]",
            "id": "6dbe0cc47059d37773b99904ca3d9767"
          },
          {
            "type": "html",
            "text": "<i>Excuse me! Although [[Mercury Language]] indeed has [[Committed Choice]] (a.k.a. [[Dont Care Nondeterminism]]), which is used for concurrency, (amongst other things), it also has ordinary Prolog-style nondeterminism (sometimes known as [[Dont Know Nondeterminism]]) (of which [[Back Tracking]] is one possible implementation technique). Regarding unification it is true that (currently) in [[Mercury Language]] one can't use variable-sharing, as in, e.g., [[Difference List]]s. This is due to not having a way to express sharing uninstantiated terms in the (statically checked) mode/inst language. -- [[Stefan Ljungstrand]]</i>",
            "id": "027956f2dc9ad8a0fe218adaab4813fb"
          },
          {
            "type": "html",
            "text": "\nSee [[Non Deterministic]]",
            "id": "590b1dc4bff9173d61781bf0a2b45544"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "\nI used Prolog in a comparative languages course. The biggest program we did was a map-coloring one (color a map with only four colors so that no bordering items have the same color, given a mapping of things that border each other). I say biggest because we were given the most time with it. I started out like most people in my class trying to hack the language into letting me code a stinking algorithm to color a stinking map. Then I wrote a test function to check if the map was colored and, in a flash of prolog, realized that that was really all I needed to code.",
            "id": "24588498605f5dc5f02ccb843ee2b838"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "<i>[...] it is hard to get over what I felt was a deception.</i>",
            "id": "6cad9b1d42bced4175f186988e4fa7dc"
          },
          {
            "type": "html",
            "text": "\nI think this is what most people exposed to [[Prolog Language]] remember strongly, the initial disappointment. It takes a lot of good experiences to overcome that feeling, and few ever get that chance. -- [[Anders Bengtsson]]",
            "id": "7e18e5926e0190695c9f275cce23404a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "Here's a taste of Prolog, for those who haven't used it. Using the code below, you can get Prolog to generate all bit strings of length 3:",
            "id": "37126b89fa8b2869034fee9e41630f2b"
          },
          {
            "type": "html",
            "text": " ?- bits(3,Bits).",
            "id": "5bc57724449e0dcfdc42ea94b8b27b36"
          },
          {
            "type": "code",
            "text": " Bits = [0, 0, 0] ;\n Bits = [0, 0, 1] ;\n Bits = [0, 1, 0] ;\n Bits = [0, 1, 1] ;\n Bits = [1, 0, 0] ;\n Bits = [1, 0, 1] ;\n Bits = [1, 1, 0] ;\n Bits = [1, 1, 1] ;\n No",
            "id": "ad600c697f4a568cec1ddd0d7c6136e4"
          },
          {
            "type": "html",
            "text": "Here's the code:",
            "id": "899a020030beba3b853124127d93d60c"
          },
          {
            "type": "code",
            "text": " % Non-deterministically returns a string of N bits.\n %  bits(+N,?Bit_string)\n bits(0,[]).\n bits(N, [R | Rs]) :-\n  N > 0,\n  bit(R),\n  N1 is N - 1,\n  bits(N1,Rs).",
            "id": "4c15168ed1d1580357b70296665562c6"
          },
          {
            "type": "code",
            "text": " bit(0). bit(1).",
            "id": "9f923e55a15f011e7ba9b37a79c5f175"
          },
          {
            "type": "html",
            "text": "\nHere is another example.",
            "id": "f851b8db043dfdd39722e22f4982ace7"
          },
          {
            "type": "code",
            "text": " bit(0). bit(1). \n bits(X,Y,Z) :-       \n  bit(X),\n  bit(Y),\n  bit(Z),\n  write(X),\n  write(Y),\n  write(Z),\n  nl,\n  fail.",
            "id": "6570b7040d6754477f858751a38a5609"
          },
          {
            "type": "html",
            "text": "\nThe predicate (something like a function, though it doesn't work like a function) <i>bits</i> is non-deterministic, and returns multiple answers. In this example, it generates all bit strings of length 3. This is a quick and dirty tool for combinatorial computing, and you can easily use it to generate bits strings as input to other functions. You can also use <i>bits</i> to check if a list is a bit string, e.g.:",
            "id": "cc5691f03f93c5bcda1ee3f3e85b8f45"
          },
          {
            "type": "html",
            "text": " ?- bits(5,[1,0,1,1,1]).",
            "id": "182442809877b380ab172cb25cd5671b"
          },
          {
            "type": "code",
            "text": "  Yes",
            "id": "61830d2cf052c672bb75c68cb04f9847"
          },
          {
            "type": "html",
            "text": " ?- bits(5,[1,1,1,1,0,1]).",
            "id": "e22f3c4bd14aee80375d5ac9a5c482cd"
          },
          {
            "type": "code",
            "text": "  No",
            "id": "98fde78cf49462aaa3c0ce958e361d15"
          },
          {
            "type": "html",
            "text": "But, and this is one of the frustrating parts of Prolog, this particular predicate doesn't work if the first parameter is a variable, e.g.",
            "id": "8b91e3a4681ba4bcfe415f2534d4cdba"
          },
          {
            "type": "html",
            "text": " ?-  bits(N,[1,1,1,1,0,1]).",
            "id": "569058ab4942b33741349e98a7a50032"
          },
          {
            "type": "html",
            "text": "ERROR:<br>Arguments are not sufficiently instantiated",
            "id": "4497e9a1bca87dfd71b8dadb9c88755c"
          },
          {
            "type": "html",
            "text": "This error refers to the line <i>N > 0</i>, which requires that <i>N</i> be instantiated. [[Constraint Logic Programming]] is a useful extension of [[Logic Programming]] that partially solves this sort of problem.",
            "id": "e42f1383a1b67a258c9c7e4b07c3d684"
          },
          {
            "type": "html",
            "text": "\nIf you would like to have the predicate also count the length of bit strings, add a second clause that checks for an uninstantiated variable, cuts choice point for the other recursive case, checks the first element of the list for being a bit, make a recursive call and increment the count as the stack unwinds.  The new predicate would be,",
            "id": "0b16b2070d4097832b8510573146d0e0"
          },
          {
            "type": "code",
            "text": " % Non-deterministically returns a string of N bits or returns the length of a bit string.\n %  bits(+N,?Bit_string)\n %  bits(?N,+Bit_string)\n  bits(0,[]).\n  bits(N, [R | Rs]) :-\n  var(N), !,\n  bit(R),\n  bits(N1, Rs),\n  N is N1 + 1.\n  bits(N, [R | Rs]) :-\n   N > 0,\n  bit(R),\n  N1 is N - 1,\n  bits(N1,Rs).\n  bit(0). bit(1).",
            "id": "05ebdbd3a2482fb81d3d2817fe86c478"
          },
          {
            "type": "html",
            "text": "\nThis modified version gives the expected,",
            "id": "4820c0cd98dd6e8385de2d2217557b8e"
          },
          {
            "type": "code",
            "text": "  | ?-  bits(N,[1,1,1,1,0,1]).",
            "id": "6b5a236fcc68d9dd0ed99030ed786342"
          },
          {
            "type": "code",
            "text": "  N = 6 ? ;",
            "id": "e5580019b42ca17a1a3dfbd955ed3708"
          },
          {
            "type": "code",
            "text": "  no",
            "id": "6a2fcde9c5f61e878f98c6543bbc1597"
          },
          {
            "type": "html",
            "text": "\nwith no dangling choice points.  What may be less obvious is the result of bits(X,Y) in this modified version or even what modifications would allow it to generate all combinations of bits for increasing length lists.",
            "id": "e95a63b33ec1cc65fa77ba7be12e6244"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "\nAn operational way to understand Prolog is to say that predicates are actually what ordinary people would call procedure calls.",
            "id": "7a89032424db18c2865ebbf229147485"
          },
          {
            "type": "html",
            "text": "<i>Regrettably, this is insufficient. Using predicates procedurally is possible with judicious use of the cut operator, but to do that removes all the advantages of using [[Prolog Language]]. Think of a predicate instead as a search string. [[Prolog Language]] will then become something else for you, something a lot closer to poetry than to prose.</i>",
            "id": "2e338925d889e5992a828589192b540e"
          },
          {
            "type": "html",
            "text": "<i>For this reason, [[Prolog Programs]] are typically extremely short compared with their procedural equivalents. It's a common experience that 1,000 lines of COBOL -> 100 lines of C -> 10 lines of [[Small Talk]] -> 1 line of [[Prolog Language]].</i>",
            "id": "8e2f80aa1926d00b47c6a3e5c8369cc4"
          },
          {
            "type": "html",
            "text": "<i>So why don't professional software developments use it more? Well, it's slower than most procedural languages, and it can be extremely difficult to maintain. The last time I saw it used on any large scale was code for pacemaker/defibrillators, where it was combined with [[Tony Hoare]]'s program correctness-proving techniques to reduce legal liabilities. In that problem domain you understand that a fatal error is really a <b>fatal error</b>.</i>",
            "id": "a9087c40beeceea1fc70cf2b0db07162"
          },
          {
            "type": "html",
            "text": "<i>Still ... perhaps [[Prolog Language]] might be neat for [[Acceptance Test]]ing?</i> -- [[Peter Merel]]",
            "id": "7301c587cae8ed7e78f0007bdf2816c4"
          },
          {
            "type": "html",
            "text": "\nPerhaps the difficulty with using the [[Prolog Language]] is that [[Prolog Programmers]] are good and hard to find. [[Logic Programming]] is hard to fake and does not come easy to a mind used to procedural programming. Since [[Prolog Programmers]] tend to have a logical or philosophical disposition, they are often considered hard to manage and often are hard to replace. Many folks only recall the [[Prolog Language]] as something they never really understood from some graduate course in [[Symbolic Programming]]. Perhaps [http://www.gnu.org/software/gprolog/ www.gnu.org] will encourage a wider audience to experiment with [[Logic Programming]] in the open and comfortable environment of the bazaar. -- [[Vic Bancroft]]",
            "id": "75f8b5e1f15acee7254af6e1394eac9a"
          },
          {
            "type": "html",
            "text": "\nI like [[Prolog Language]] very much, others might like other languages. As a tool, any languages have the possibility to solve a particular problem, and if not, probably it is just a matter to wait for a future release powerful enough that shall solve its weaknesses.  I would also say, that the use of a particular language is more related with the expertise, time available to learn alternative languages, economics, former source code available, ideas.... well you name it. There is little benefit in stating if a particular language is better than other, each one will eventually fall in its place. In my case, I am so used to think in prolog terms that I found difficult to learn a new/switch back to a procedural programming -- even though I�m really interested-. I would like to encourage those who do not feel comfortable with your actual choose, to try prolog.  but please keep in mind  that there are different flavors of prolog, choose wisely before you get hooked.",
            "id": "2960e6d31ff343017c2120dd18fa7c0d"
          },
          {
            "type": "html",
            "text": "\nIt would indeed be nice to combine the power of Prolog with a \"normal\" language such as C or C++. Many \"trivial\" problems in, say C, are non-trivial in Prolog and vice versa. A hybrid language merging the best of both worlds would indeed be very interesting. A reason why Prolog isn't used as much among commercial developers could simply be the fact that it's difficult to grasp, or at least more difficult than procedural and even OO languages. -- Lennart Frid�n",
            "id": "e9f8ee4f39bc419c20746a4913006ec2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "From the days of Borland [[Turbo Prolog]] and TurboC (early 90s) it was relatively easy to call one from the other. Nowadays MSWindows languages can call each other using COM (DLLs), corba, or on unix (static or dynamic) libraries. For both also object methods can be packaged as [[Web Services]] so you could have a dynamic web application using C, Java or Perl as the main \"glue\" that calls Prolog functors behind the scenes for special processing. Same is true for other [[Symbolic Processing]] languages like scheme ie [[Jay Scheme]] embeds scheme in Java you can architect a [[Hybrid Application]] to use each language for what it's best at.",
            "id": "446137650aa3a71059b926d77e79627e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "A good open source Prolog implementation is SWI-Prolog (both Windows and Unix, see [http://www.swi-prolog.org/ www.swi-prolog.org]). It has the ability to make GUI front ends using xpce.",
            "id": "cb1de43c5e80bdef34f448da3f3dcda3"
          },
          {
            "type": "html",
            "text": "\nThere is also a [[Pocket Pc]] port at\n[http://www.rainer-keuchel.de/wince/swi-prolog.html www.rainer-keuchel.de]",
            "id": "98d8a8f3a07dac517a904656e7b196af"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "I have a collection of resources on Prolog -- syntax, semantics, glossary, predicates, examples, etc. at\n[http://csci.csusb.edu/dick/samples/prolog.html csci.csusb.edu]",
            "id": "f9c38f87d6d560dcf87e6d431573373d"
          },
          {
            "type": "html",
            "text": "--[[Richard Botting]]",
            "id": "ccfc636809d94f0d350bb5bedad40f8d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "Eclipse Prolog meanwhile has gone open source and comes with various constraint solvers:\n[http://www.sourceforge.net/projects/eclipse-clp www.sourceforge.net]",
            "id": "9ef5854a3adf5adcb3f82a9680cf0e8b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "My idea is to make  Prolog  easier by using if-then-else clauses.",
            "id": "d3a2fe678bea39725c43192c02b461d0"
          },
          {
            "type": "html",
            "text": "<i>How would that work?  Prolog has implicit flow control (apart from the cut operator, which is a wart).</i>",
            "id": "5ac8d94faf916db3b2c5441011186516"
          },
          {
            "type": "code",
            "text": " if(Condition, TrueClause, FalseClause) :-\n  Condition, !, TrueClause;\n  !, FalseClause)",
            "id": "a7acd1d728d50803f1591d0e15d0743c"
          },
          {
            "type": "html",
            "text": "- I think. I don't have an implementation installed at the moment to check it, though. --[[Dor Kleiman]]",
            "id": "0991aa163341a6b7ca31235cd51c16f9"
          },
          {
            "type": "html",
            "text": "\nProlog already has an \"if_then_\" operator:",
            "id": "463311cb5531b19df3ffd7b4d8351459"
          },
          {
            "type": "code",
            "text": "  Condition -> TrueClause; !, FalseClause",
            "id": "ae0e6dc762adc4ed3eb599dcaafa0784"
          },
          {
            "type": "html",
            "text": "--[[Richard Botting]]",
            "id": "ccfc636809d94f0d350bb5bedad40f8d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "Java:",
            "id": "e4ff7b7033002ffb925f1f3627ff3fe5"
          },
          {
            "type": "code",
            "text": " if (x == 1) {\n  y = 0;\n } else {\n  y = 1;\n }",
            "id": "6bb12089d3677e4fdb4240a0ba71b4f2"
          },
          {
            "type": "code",
            "text": " Alternatively:\n  y = (x == 1) ? 0 : 1;",
            "id": "e2b7cb19a25f925732559a4aa3326974"
          },
          {
            "type": "html",
            "text": "\nProlog:",
            "id": "9ab4cd12d67af3d0055fcec05d8c78ec"
          },
          {
            "type": "code",
            "text": " if(X, Y) :-\n  \\+ var(X),\n  var(Y),\n  X is 1,  % if this fails, prolog tries the next clause of if/2\n  Y is 0.",
            "id": "edfedf0351d89cb4005f970e20f8f926"
          },
          {
            "type": "code",
            "text": " if(X, Y) :-\n  \\+ var(X),\n  var(Y),\n  Y is 0.",
            "id": "a80163badbd221b9e371a79f4284bdbe"
          },
          {
            "type": "code",
            "text": " ?- if(0, A).\n A = 1.",
            "id": "c91945ad178bd52f1d89f985641d61e1"
          },
          {
            "type": "code",
            "text": " ?- if(1, A).\n A = 0.",
            "id": "50bda9f142feca9d39509810ab3c2e48"
          },
          {
            "type": "html",
            "text": "\nmoral:\nProlog CAN handle if-then-else clauses but not in the conventional sense. As [[Dor Kleiman]] says above, flow control is implicit and much of it is handled by the implementation.",
            "id": "7d63f694c2bf444031bda81921bc160f"
          },
          {
            "type": "html",
            "text": "<i>This is can be even simpler in Prolog:</i>",
            "id": "89fa7e114ba7b82633b03a3e1de1750f"
          },
          {
            "type": "code",
            "text": " if(1, 0).\n if(_, 1).",
            "id": "e55ffa824d88f491399820ac4dff87f0"
          },
          {
            "type": "code",
            "text": " ?- if(0, A).\n A = 1.",
            "id": "c91945ad178bd52f1d89f985641d61e1"
          },
          {
            "type": "code",
            "text": " ?- if(1, A).\n A = 0.",
            "id": "50bda9f142feca9d39509810ab3c2e48"
          },
          {
            "type": "html",
            "text": "<i>Of course, now the word 'if' is consumed for this purpose... a rather poor choice, seriously.</i>",
            "id": "1951cf6db53d729f8d71f7d4e933e043"
          },
          {
            "type": "html",
            "text": "\nThe prolog program above does not reflect the Java snippet, it would translate to",
            "id": "3dd00d076fac6e98f271f249965e5ddf"
          },
          {
            "type": "html",
            "text": "\npublic int ifx(int x) { //for lack of a better name",
            "id": "b47ff1860d13ad0a7e5cc1b6df027c9c"
          },
          {
            "type": "html",
            "text": "return  (x == 1) ? 0 :<br>1;",
            "id": "f36b1a6a8cb0176431e440d36a5f6744"
          },
          {
            "type": "html",
            "text": "}",
            "id": "6c11f82fb23d14ade77eac5965a616ee"
          },
          {
            "type": "html",
            "text": "\nThe -> operator reflects the if-then-else more closely, and is, as stated above a short form for  (condition, ! thenClause); !, elseClause.",
            "id": "89f77b95282d31899392ecca53a3701e"
          },
          {
            "type": "html",
            "text": "\nBy the way, a constraint language could express the same thing as x#=\\=y (unequal), given appropriate domain definitions.",
            "id": "a6586ba1631797d8375a8bf19d431922"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "\nProlog and RDF. ",
            "id": "eb54b4c132cb807ef2129b4163fe42f0"
          },
          {
            "type": "html",
            "text": "\nA lot of people have mentioned (both positively and negatively) the similarities between Prolog and RDF ([[Resource Description Framework]]) / [[Semantic Web]] stuff. I'm wondering, if anyone is evolving either Prolog or some derivative to be a good Semantic Web language. My limited experience with Prolog suggests that the idea is interesting, but it <i>feels</i> a bit bogged down and brittle. For example, does a state-of-the-art logic programming language still have to use capitalization to make the difference between variables and tokens? -- [[Phil Jones]]",
            "id": "bac3b25e7a5f705c20909387f952bdd3"
          },
          {
            "type": "html",
            "text": "<i>The SML family ([[Sml Language]]) seems to get along with significant case.  If you want to avoid collisions, the alternative is going to be to use some kind of sigil (yuck) as overlapping the namespaces would be really quite tricky and error-prone.</i>",
            "id": "484732bece1f07ef170a133edea8da0e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "\nThere is a built in symbol that is very similar to an If-Then statement - \"Condition -> Action\".\nTo make it clearer:",
            "id": "ffabdd537b8d22bd3d1bef5ad48ebd2d"
          },
          {
            "type": "html",
            "text": "[If] Condition -> [Then] Action ; [Else] Action.",
            "id": "d6aeea40c25fab6731fdddae01577d28"
          },
          {
            "type": "html",
            "text": "<i>This comes from plain old logic, where -> means \"implies\", in the mathematical sense. </i>",
            "id": "4c6f48bc6d49d0fa44ebbf68e4fb8780"
          },
          {
            "type": "html",
            "text": "<i>x->y is equivalent to \"if x, then y\" or \"y if x\". I would imagine (not having used the language)</i>",
            "id": "aa5f933c6f31a616dad3abc7bdbc2b53"
          },
          {
            "type": "html",
            "text": "<i>that the prolog way of doing things doesn't fit the if/then/else paradigm, but more that the results</i>",
            "id": "693e2faa6c87175aa255af75a702e82f"
          },
          {
            "type": "html",
            "text": "<i>of an implication would be further used in a program without the need for an explicit else. -[[Jason Espinosa]]</i>",
            "id": "5d8a272ba696626e523a5e3b7d55e64e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "There is a related language PARLOG which is a concurrent logic programming language - see [http://www.parlog.com/en/parlog.html www.parlog.com]",
            "id": "b208f26c920d2feb93d56acc71b98510"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "There is another Windows Prolog evolving at [http://dobrev.com dobrev.com] as Strawberry Prolog in Sofia, Bulgaria.\n[[Strawberry Prolog]]?.",
            "id": "6a8cc26ef600ef1709a90043d3bcee45"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cae669344d156644d90278680c31cd6"
          },
          {
            "type": "html",
            "text": "See [[Non Deterministic]]",
            "id": "6286b7ee14721b652966869ccac90672"
          },
          {
            "type": "html",
            "text": "\n[[Category Programming Language]]",
            "id": "28961595a5875f48be75bcdb6cb259f6"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?PrologLanguage c2.com]",
            "id": "25cb7d726af68e5b07a7eda5d0ee196f"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1627632360356
    }
  ]
}