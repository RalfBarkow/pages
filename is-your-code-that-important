{
  "title": "Is Your Code That Important",
  "story": [
    {
      "type": "html",
      "text": "Software quality is a multifaceted thing. Depending on the project and the task you might be worried about reliability, scalability, security, or usability, for example. How do we [[balance]] these facets of quality against themselves? How do we guard against [[Gold Plating]] on one hand, and on sloppiness on the other?",
      "id": "7f8a71d395cbd53f1c266f220a4023a6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "A lot of programmers believe all code has to be bullet-proof. This can lead to a multitude of sins:",
      "id": "da34795d7fcec35c542d396cc7c5d42d"
    },
    {
      "type": "html",
      "text": " <b>Overemphasis on security</b>:<br>\"We have to spend an extra week writing this password system because somebody could crack it with a cross-channel attack.\"",
      "id": "0e11ea5153510a629508ae4c2131efe2"
    },
    {
      "type": "html",
      "text": " <b>Overemphasis on efficiency</b>:<br>\"I'm going to write my own garbage collector because I want this to be the fastest bulletin-board system the Web has ever seen.\"",
      "id": "d7091ff0d90537461472b82b35a6f9b3"
    },
    {
      "type": "html",
      "text": " <b>Overemphasis on reliability</b>:<br>\"Let's make our content-management system load-balanced, because if we got [[Slash Dotted]] the site would be down for a day or two, which would be pretty catastrophic.\"",
      "id": "47c3f0ea0ba284bd0b056564abc92bdd"
    },
    {
      "type": "html",
      "text": "\nAll these things cost something, and sometimes we as programmers are too willing to incur those costs. If you're writing MP3 jukebox software for the next LAN party, a bubble-sort will do just fine. If you're writing a login system for a Web bulletin board, you probably don't need a security audit.",
      "id": "907336a825103c35db69712ef2d63b25"
    },
    {
      "type": "html",
      "text": "\nLet's be honest with ourselves: The vast majority of the work we do isn't really that difficult. Sure, you want it to work most of the time. But most of us are not making software for financial transactions or pacemakers or missile guidance. The bread-and-butter of the software industry is harmless stuff: Content-management, marketing reports, you know the drill. If it's a little pokey, if it has a downtime of a few hours once in a great while, it won't be the end of the world.",
      "id": "140a79d6a94c0068ba51cf16d2227a9b"
    },
    {
      "type": "html",
      "text": "\nPerhaps we have a tendency to act is if our work is difficult because we consider that to be the highest form of programming. The work is only important if it's difficult. Maybe we should think differently. Maybe the work is important if it <i>helps people</i> - and sometimes helping people is deceptively easy.",
      "id": "c36cfad70916431d76944b3f9d650d93"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "<i>most of us are not making software for financial transactions or pacemakers</i>  This is perhaps a slightly skewed worldview.  While I've done my share of working in the e-world building gee-whiz things, I've spent most of my career working in fields where slightly more care is required.  I cut my teeth working in a medical educational institution.  Among the tools I worked on were some that directly affected patient care - certainly not pacemakers, but things like software to ensure that accurate lab reports reach the physician who requested the lab work in a timely and secure way.  Patients and doctors do <b>not</b> appreciate inaccurate or late results on tests for the presence of potentially fatal conditions.  Now I work for an insurance company.  Claims management, HIPAA, disability payments, retirement plans - all forms and forces on financial transactions.  These sorts of things, IMHO, are the bread and butter of software development. -- [[Steven Newton]]",
      "id": "94346a9473ab203c84c2b00377c7db3b"
    },
    {
      "type": "html",
      "text": "\nYeah, perhaps I was overgeneralizing from my personal experience. I have yet to ever code anything of life-and-death importance, though obviously there are people out there who do so. I haven't met many of them, and I have this inkling that numbers-wise most programming is not actually life-and-death, but I certainly don't have a hard numbers to back up such an intuition.",
      "id": "6401e9f0858c8eafc3ae98c44059bbd5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "Wow. You live in a pretty different world than mine. In <i>my</i> world, software is inefficient, insecure, and breaks down <i>all</i> the time. So I doubt there really is a surfeit of programmers adding too much bulletproofing to everything. Oh, and I believe it <i>helps people</i> when their systems aren't regularly getting hacked and their files aren't regularly getting corrupted. -- [[Alain Picard]]",
      "id": "c7887d22d993507bfa89dab851f509dc"
    },
    {
      "type": "html",
      "text": "\nIt's not that software is always efficient, secure, and extremely reliable. But in aiming for these goals, programmers often incur other costs, and sometimes those goals aren't that important. Some programmers often say things like \"That'll be too slow\" or \"That isn't scalable\" or \"That won't be five-nines\" ... This is why some people here say stuff like [[You Arent Gonna Need It]], because there are a lot of people who think you always will.",
      "id": "266d9f12134adb3bcc8fb92acc56ac5c"
    },
    {
      "type": "html",
      "text": "\nThese are always ideals, but they're not always necessary. I was once at a hacker conversation and overheard a conversation with someone who was running his own relatively insecure server, and didn't care. \"Sure, someone will hack it one day,\" he said, \"but none of the data is private, and it's regularly backed up, so if something happens, I can just reformat the drive and start from scratch.\"",
      "id": "b528800f7280f747c479a0687c062118"
    },
    {
      "type": "html",
      "text": "\nOf course, such a lackadaisical approach does not apply in many situations. But there are many positions where it <i>does</i> apply, and the tendency to take the code overly seriously may blind us to recognizing the times when we can do things quick and sloppy.",
      "id": "e2724a1e4e7395315e505b92bc302920"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "\nAs if the level of amateurism in our industry is not big enough ! Here we even try to make a case for it. \"Sloppy is not acceptable under any circumstances when you get paid for it.\" Go upfront and tell your customer or to your manager that by normal standards you're goping to do a sloppy job. Or deliver a shring wrapped software package clearly labelled: \"sloppy quality, but it costs you 50$ instead of 100$\". See if you get paid. ",
      "id": "6cd188ce23768755b5c36fefc2308caf"
    },
    {
      "type": "html",
      "text": "\nThe only seeming justification for \"sloppyness\", is the price. What is contended is that even decent quality has to be obtained most of the times by substantial effort, resulting in significantly increased costs. That's a [[Red Herring]]. What it really costs is to [[Give Up On Amateurism]], and this price should be paid by the many developers who have barely minimum education and training for their job, and should be paid with their own private time. The solution to produce better software is most of the times not to work more or to work harder, but to work <b>better</b>. ",
      "id": "06eb5cdd4e6f9adbb1aab63cc2f8e9e1"
    },
    {
      "type": "html",
      "text": "\nSome of the examples given are all too unfortunate and all too present. Simply said that guy was probably doing a poor job and even worse, he was proud of his amateurism. To run a secure server vs. an insecure one is largely a matter of having a well trained and knowledgeable sysadmin vs an amateurish one. It is very little a matter of someone having to put substantially more effort into administration tasks. Similarly, \"planning\" for hours of downtime is just as ridiculous even if we're talking only about marketing reports. -- [[Costin Cozianu]]",
      "id": "18cabe884023030ef6ca595f3350abd8"
    },
    {
      "type": "html",
      "text": "\nOn rereading the example of the hacker with the poor server, I realized I did not explain it clearly - it was his own server I was talking about, meaning he's effectively the client and is allowed to make the decision to be half-assed about security. (I've amended the description above.)",
      "id": "8b3787c49e35423cbba17484318a8f5f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "\nLet's say, for the sake of discussion, that you <i>could</i> make a strong argument for de-emphasizing things like Security, Efficiency, and Reliability.  (I find such an argument ridiculous.)  There is still no good purpose in pointing out that argument, because owing to the [[Rampant Amateurism]] in our field that Costin points out, we <b>already</b> have such a de-emphasis in place.  Most programmers are either too stupid or too unskilled to build Secure, Efficient, Reliable systems.  The 5% who can reach a reasonable level on those aspects don't need to spend an inordinate amount of time on them.  Those who need high quality hire great programmers.  Those who don't, hire the dregs.  So to some extent, the programmer market already assigns importance to high quality wherever it's needed.  (If the salary gap between the dregs and the best were greater, the market would be much more effective at this assignment task.)",
      "id": "cb07ec46905d2282b208d568db731c3d"
    },
    {
      "type": "html",
      "text": "<i>Are you're saying that such an idea could be dangerous, therefore it should be suppressed?</i>",
      "id": "368b1f9fdb1bcb6e8edbe4d83cd5f4a7"
    },
    {
      "type": "html",
      "text": "\nI wasn't thinking in terms of danger, but usefulness.  But depending on your audience, yes the idea could be dangerous.  To tell the average programmer this, there is no harm.  He can't achieve those goals anyway, so he need not waste valuable thought cycles on them.  To tell the good programmer this, there isn't any real harm either.  She can achieve those goals to a reasonable degree without taking great pains, and she knows when to ignore advice.  To tell a manager this could be dangerous if he needlessly prevents the good programmer from attempting those goals.  The danger is not tremendous though, because the good programmer can ignore that manager or go work someplace better.",
      "id": "4bbfa0865a19dfacfd17016791aef608"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "\nThis week (late March 2002), I convinced a system architect for a national organization that having all the branch offices send self-extracting ZIP files (EXEs) was a bad idea - that ordinary ZIP files would be better.",
      "id": "ceec4cfe8f5739bc218a19ea0b301578"
    },
    {
      "type": "html",
      "text": "<i>Lessee...</i>",
      "id": "8d308bc0d06bee5a8888bc2e54e64b90"
    },
    {
      "type": "html",
      "text": "<i>If <b>one</b> hacker got a part-time job at <b>any</b> branch office in the U.S. and took a look around, it wouldn't take them long to recognize the naming standard for EXE files sent up to be <b>executed automatically on the central server with \"root\" authority.</b> (And given the nature of the business, questionable part-time help is <b>very common!</b>)</i>",
      "id": "ce0a84fcb8e5a8b05b119627116f7008"
    },
    {
      "type": "html",
      "text": "\nNot a good plan. Plain ordinary data files are a <b>much</b> better idea than importing and running suspect code.",
      "id": "728f91c1f5ed5d91041d18f88c3facc9"
    },
    {
      "type": "html",
      "text": "-- OneOfTheOnesWearingA<b>White</b>Hat",
      "id": "e6f82a01b6effefb83d8bf761b8c4840"
    },
    {
      "type": "code",
      "text": "  ;->",
      "id": "173add5bbc18bd0686021c9ed9c57155"
    },
    {
      "type": "html",
      "text": "<i>That \"architect\" is a perfect example of someone too stupid to build secure systems - par for the course.  It also serves as an example that holding the </i>title<i> architect does not make one a true architect, nor does mere title imply one has much brain.  As often as not, a holder of the title architect serves merely to call out the supreme incompetency of the hiring manager - also par for the course.</i>",
      "id": "ad08ddd4ebd61743d5db8a6b2c5eb1d6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "<i>deliver a shring wrapped software package clearly labelled: \"sloppy quality, but it costs you 50$ instead of 100$\". See if you get paid. </i>",
      "id": "6ae07dd9f98223cef526124f9ca9c8b7"
    },
    {
      "type": "html",
      "text": "\nSure you'd get paid. Show me a shrink-wrapped product without one of those weasel-word warranties that say, in effect, \"the product you have just paid good money for does not work, and we never said it would. If by some chance the one you have does work, it won't do what you're expecting it to.\" Show me a company that produces shrink-wrapped (or even bespoke) software that has a genuine warranty guarenteeing merchantability, fitness for purpose, that the product will be fixed <i>at no charge</i> if it doesn't work as advertised, as one would expect with any other complex technological poduct with no user-serviceable parts inside (we aren't talking about open source here), and then we might have something to talk about.",
      "id": "03f727613f379fce50b6df4c0989fb87"
    },
    {
      "type": "html",
      "text": " This brings up a side point: are such disclaimers in EULAs legal? I have occasionally heard it said that they might not be, but that no case testing their validity has ever come up. IANAL, so I have no basis for agreeing or disagreeing with the claim, though I find it hard to believe that no one has ever contested such an ubiquitous practice, even if only as an arranged test case. Does anyone know if any EULA of that type has stood up to a legal challenge? - [[Jay Osako]]",
      "id": "bd016350d6cbb698d1002c46380d6d82"
    },
    {
      "type": "html",
      "text": "\nThe original poster does have a point. It seems that insufficient thought is put into what balance is required, and where the costs and benefits lie. The \"e-\" world suffers especially with this. There seems to be an idea around that every page on every e-commerce site needs to be up at full effectiveness 24/7, even if it can only  be used by people in a small number of time-zones. That every page of every coporate website has to have enough capacity behind it that it can remain available when slashdotted twice over. That every byte of every file of corporate data needs to be protected from the massed onslaught of every hacker in the world.",
      "id": "c59517d5a05bdfbdf2262413e911c3b5"
    },
    {
      "type": "html",
      "text": "\nAnd maybe yours <i>do</i>. So fire ahead. And maybe they don't. Has anyone bothered to find out, either way? Has anyone worked out if the cost of downtime at 2 am in the only timezone where the site may be used exceeds the cost of making the system be up 24/7? Has anyone worked out how likely it is that the site will be slashdotted? How much it would cost if it was unavailable for a while, once in a blue moon? Whether that cost would exceed the cost of the extra capacity that sits idle almost all the time? (The real villains here, by the way, are not gold-plating developers, but eager consultants from the hardware vendors.)",
      "id": "cc519ab252f864a6d650cc65147d4a69"
    },
    {
      "type": "html",
      "text": "\nI'd love to be in a world were I was able to make the kind of decisions that Costin derides. I'd love to know that I was able, as a consumer of software, to balance purchase price against reliability, or functionality. It seems, though, that the idea that every piece of software has to be bullet proof infects the transaction, so that vendors are extremely reluctant to admit that their product has any deficiencies or limitations at all, even thought they all do. To the extent that little in the way of comparison can be made. I can't even identify a baseline. Consider motorcycles. I can compare motorcycles by cost and by functionality, and I can see that I can pay extra for, lets say, increased power and torque, rider comfort and long-range crusing reliabilty. But that would make no sense if what I'll be mostly using the bike for is hacking down to the shops and back. But even the smaller, relatively uncomfortable, relatively unreliable bike I buy for tooling around town will meet certain minimum standards for safety and reliability. Can't do that kind of thinking with software.",
      "id": "b1def303aaf7080d5db1f8d16be9e567"
    },
    {
      "type": "html",
      "text": "<i>I rode a motorcycle around with some friends a while back, meeting the minimum standards.  Hit a pothole.  Ten minutes of riding later, another rider noticed that a weld had failed, and the pin holding the front wheel to the frame had come out on one side, and was nearly out on the other as well.  Decided it would be prudent to stop riding :)</i>",
      "id": "a3fa6177fdc870c67dff9e2b3c42369a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "Perhaps the idea needs to be stated more precisely. There are different types of quality, and perhaps some are negotiable while others are not. For example, all code should be well-factored and easy-to-read, unless technical demands justified difficult-to-read code - for example, if parts had to be optimized. Furthermore, software shouldn't fail under unexceptional circumstances. These would be analogous to the minimal safety and reliability standards for consumer products, whether those are power drills or concentrated orange juice. Your power drills can't fly apart when you're drilling through drywall, and your orange juice can't have botulism in it.",
      "id": "535e75791d1f87a04b7acc323bfdd7c2"
    },
    {
      "type": "html",
      "text": "\nBut perhaps there are other types of quality that are not the minimum. Not every website needs SSL-based login. Not every database needs to spend the money to have five-nines uptime. Not every possible function in a piece of software needs to be highly optimized. These things would all be good, but they cost money and time. And any feature, no matter how useful, can have a price that is too high. How much it costs depends on your own engineering ability - which we should always be striving to improve - but how much it's worth depends on what the client needs. The client has a finite amount of money, and if we sell em software features that e doesn't need, then we've scammed em. Even if those features work.",
      "id": "b09fd24b156e2f4c9f0cf5ad50b38288"
    },
    {
      "type": "html",
      "text": "\nYes, there's a quality problem in the software world, and it's something we should all strive to eliminate. But when something qualifies as [[Gold Plating]], that's not a solution. There are different sorts of quality, maybe the point of this page is that we should learn to focus on the ones that really matter to the client. (And if we don't know what matters to the client, we should learn how to ask.)",
      "id": "eda36c0d850e317527676a942d8a955b"
    },
    {
      "type": "html",
      "text": "<i>For more on what happens if you don't ask, see [[The Customers Are Idiots]]</i>",
      "id": "8d715fd52a10fbe1b6f9551c14c7c00f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "There's often a conflict between two priorities: 1) Overall security / performance / reliability and 2) Making deadlines and including new features. I personally favor 2), as have most of my managers, though my code almost always has good performance and reliability. Many of my coworkers, who strike me as perfectionists, have focused on 1), even if it means missing deadlines or adding fewer valuable features. Customers generally seem pleased with products that have good, though not extraordinary, quality, as long as they receive deliverables, bug fixes, and enhancements promptly. -- [[Jared Levy]]",
      "id": "22e32aa2378928b7bb2dcd24d321728b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "In one of his follow-ups the original poster suggested that <i>sloppy</i> code is sometimes acceptable. I would take issue with this - in my experience sloppy code almost always comes back to bite you.",
      "id": "1dba3e9fe19e02957f0c15197b6ff6f7"
    },
    {
      "type": "html",
      "text": "\nHowever, I totally agree with his original point that programmers often overemphasize security, efficiency and reliability without even realizing they are doing it. These are all forms of [[Premature Optimization]]. [[Keep It Simple]] then spend time improving the security, efficiency or reliability if you <b>need</b> to. -- [[David Peterson]]",
      "id": "17947f7358bc4ce2d37a4634be1494cd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "Lacking any other input, programmers tend to emphasize things that were important in their last project and that they now know well. Any disfunctionality this may induce is easily avoided by paying careful attention the passage of time and the needs of those served. I think this is what is being asked for at the top of this page. -- [[Ward Cunningham]]",
      "id": "b4072e6235cc8a1255e10db1b70a9523"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "One thing that I continually see is programmers hand rolling things that aren't important to the customer and for which off the shelf components are already available and often better.",
      "id": "8d72b50003c5096ad7c3bca53218071b"
    },
    {
      "type": "html",
      "text": "<i>One thing </i>I<i> continually see is programmers working extremely hard to shoehorn in some off the shelf component that is already available, ostensibly better, but just a little different than what is needed.  Quite often it takes far more work to make an off the shelf component fit your problem than it takes to write an exact fit yourself.  Top programmers are best qualified to guess which would be the best route, so let them decide.</i>",
      "id": "c227d350b3ff54f7ce7fcc0beacb660f"
    },
    {
      "type": "html",
      "text": "<b>And I often see engineers investigating an off-the-shelf component; finding some trivial and/or stupid excuse why \"it won't work\" or \"it's too complicated\", patting themselves on the back, and then [[Reinventing The Wheel]] like they planned to do in the first place. -- [[Scott Johnson]]</b>. ",
      "id": "c697bc8b03dd4176b5da9efd60f6e0e7"
    },
    {
      "type": "html",
      "text": "\nOf course, if the component is truly small enough; maybe reinventing is better than shoehorning.  But if it's that small, it probably isn't worth reusing.  Things that are worth reusing are worth adapting (and probably adaptable with a reasonable amount of effort). ",
      "id": "c33927cb1e421841c16d6bf281b94689"
    },
    {
      "type": "html",
      "text": "<i>If the thing is </i>truly<i> not important to the customer, then you do not need one in the first place.</i>",
      "id": "cd27b79ee97ba4b7f832dd8606989a87"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "Only inexperienced developers think that perfect software is (a) always possible and (b) always worth the cost.  Anyone who has ever been responsible for meeting a schedule and budget knows better.  Responsible professionals should constantly be asking themselves this question, and bringing the issues to their managers when the answers aren't clear.  See [[Help Your Manager]].",
      "id": "92e991d94855975690d887b4bdd24a92"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "\nOur code is <b>absolutely important</b>. Period. How about that?",
      "id": "07b63d5bc5548adee948cc45081968de"
    },
    {
      "type": "html",
      "text": "\nOf course that includes that we shouldn't blow up the costs or the whole project and a lot of many other things. But also including the fact that writing a bubble sort is as inexcusable as writing a garbage collector for the next bulletin board. At a minimum, the code should not be <b>sloppy</b> and <b>pokey</b> even if it's <i>only</i> a report for the marketing department, or whatever else might be considered <i>not that important</i>. The idea that your code isn't <i>that important</i> is also dangerous, because there's no lower bound. And so it is a terribly convenient excuse for the lack of profesionalism that apparently is overly abundant (or some see it that way). ",
      "id": "1b42a352751010208e3d3435e0211f6a"
    },
    {
      "type": "html",
      "text": "<i>In most cases, you should have a sorting library available; even C has one (though given C's lack of any sort of polymorphism other than [[Pointer Cast Polymorphism]], generic algorithms are a royal pain in C).  If, OTOH, the number of things you need to sort is very small; bubble-sort is reasonable.  I would bother writing a quicksort routine to sort an eight-element list; that borders on [[Gold Plating]].  I would, however, keep the sort code in its own routine, so if I do need to replace it with quicksort (or something better) later, I can do this with minimal disruption.</i>",
      "id": "0e07b17a05d3168a795439b9ec21d23f"
    },
    {
      "type": "html",
      "text": "\nWell, other people might think that  the problem is in the opposite direction: writing overly complicated code for simple problems. Yes, that happens - IMHO way less than just plain sloppy code, where \"sloppy\" is an euphemism. But when that happens it is (usually) not because developers over-emphasize the \"importance\" of their code, on the contrary. ",
      "id": "775b8951d29d5b02033cfad014ed5e89"
    },
    {
      "type": "html",
      "text": "\nLet's pick a hypothetical but very real example (more realistic than the examples on the top of the page): a simple transactional web/database application . So a bunch of over hyped developers will create an ellaborate MVC/n-layered architecture, with session beans, entity beans and the whole enchilada (you can throw your favorite O/R mapping tool in there). And in the end the whole damn thing is likely to crash on them : huge costs, poor performance, long development time, etc.  If they'd had employed my absolute favorite pattern: [[Put The Damn Data On The Damn Screen]] they'd be finnished a lot sooner with guaranteed good performance, maintainable code and so on. So was it because they considered the code too important ? ",
      "id": "8efbc7cafc0e4da082bc2db76d1a2394"
    },
    {
      "type": "html",
      "text": "\nI don't think so. If the quality of the code is really that important, [[Put The Damn Data On The Damn Screen]] is the first thing you need to think about and actually use it. -- [[Costin Cozianu]]",
      "id": "e63166a52a62f8b48be3dcdf9404960d"
    },
    {
      "type": "html",
      "text": "<i>[[Put The Damn Data On The Damn Screen]] has absolutely nothing to do with what the original poster is talking about.  [[Is Your Code That Important]] is closely related to [[Do The Simplest Thing That Could Possibly Work]], with an emphasis on accepting ugly code that works, and not trying too hard to solve the general cases that the customer doesn't care about.</i>",
      "id": "f480cb5cbcd36763675766553db8a536"
    },
    {
      "type": "html",
      "text": "\nWell, ugly is one thing (although I have no idea what ugly code means other than a personal <i>de gustibus</i> kind of rambling), but Francis was talking about lowering quality (well, that's what sloppy and pokey apparently means). ",
      "id": "141feefa6e413668a59a83cf7c68d478"
    },
    {
      "type": "html",
      "text": "\nSo the question is how low(er) can we get ? This has been unanswered. And there's the interesting relation between the costs, the quality, and the professionalism of the developers involved, which has to be taken into account. ",
      "id": "ea4fdbcc3bb2e251f9ac489c84817150"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "On further reflection: What's in question is not whether the code overall is important - if code is your job, it should be at least somewhat important, or you should find another career. What's important is that realizing that of all the different metrics of quality - reliability, scalability, security, efficiency, etc., etc. - some are more important than others, and that 100% quality is probably unattainable. Even if it was attainable, most clients wouldn't want to pay the costs of such perfect software.",
      "id": "d83fda7d4098e6e50deaab0cfa1df49f"
    },
    {
      "type": "html",
      "text": "\nTo state the problem another way:",
      "id": "7d3109b8973476ff54ed28a76fb81c84"
    },
    {
      "type": "html",
      "text": " In almost any software project, somebody needs to make decisions to prioritize certain aspects over others. This is because time and money are almost always insufficient to satisfy all demands.",
      "id": "14eb3961971bb95af1846760d459f328"
    },
    {
      "type": "html",
      "text": " This process of prioritizing is extremely difficult, for a number of reasons.",
      "id": "482eb9150c7b32bd4f01d698ed426daf"
    },
    {
      "type": "html",
      "text": " Some of the difficulty in prioritizing comes from the developers themselves, who have various emotional reasons for suggesting [[Gold Plating]], [[Premature Optimization]].",
      "id": "4eac08c7097173fd13a6dfe07e6e08a8"
    },
    {
      "type": "html",
      "text": "\nPerhaps part of this might be a legacy of organizational problems: In lots of companies, developers are kept cloistered away from the clients. So a developer's sense of what's important grows separately from the clients' sense of what's important. To make things worse, developers often think that clients (and project managers) don't know what they're doing, which makes them more eager, subconsciously, to take more stewardship of the direction of the project.",
      "id": "094987643d06894a7e47775b21c2bd92"
    },
    {
      "type": "html",
      "text": "<i>\"Subconciously\"? Just look at pages all over this wiki, many of which assume incompetance or worse in the project (and other) managers...</i>",
      "id": "649406deba78b60541b29d05bf7b6dd2"
    },
    {
      "type": "html",
      "text": "\nWell, in my experience that would cover about 40% of projects.  YMMV, of course.",
      "id": "0602deb5e3e5f31691672dd83c0b667b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "\nThere's a valid concept called <i>over training</i> in which you, say, train a muscle by lifting more weight than it will be required to lift in the activity being trained for.  I view metaphorical \"mission critical\" in this light.  What happens when you pretend that every mistake matters?  I guess that depends on you, but for some people it results in a successful training effect, leaving them able to produce more and better than before.  There are at two reasons why this works when it does.  First, it helps isolate and remove lazy or sloppy habits.  That's the obvious one.  Second is because in all crafts (and we're agreed that software is craft, not science, aren't we?), there is value in <i>slow practice</i>.  When you do something slowly enough to maintain full mental and physical control, you are also building the capability to do it faster without losing control.  When you always do things a little too fast and a little out of control, you plateau rather quickly.  I'm thinking about piano playing as I write this, but it applies to almost any physical ability that requires control.  This may not apply directly to software development, since SD is not purely a motor skill, but in my mind's eye I see the connection.",
      "id": "4345c9e0a0d8e87a114a972c73c9346e"
    },
    {
      "type": "html",
      "text": "\nWe're talking about the quest for perfection.  Let's not assume this quest arises from life threatening need to be perfect, at least not all the time.  Art is partly about showing off the limits of human ability.  The symphony played flawlessly.  The high wire act.  Fine marksmanship.  It's not the code that's so important, it's us.  So let's pretend.",
      "id": "4ad72630633ac21a5f1168e58297749d"
    },
    {
      "type": "html",
      "text": "-- [[Walden Mathews]]",
      "id": "c9fd54837ba1feebd81cdf8d9cff65bf"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "\nSome people seem to be equating <i>sloppiness</i> with failure to indulge in [[Gold Plating]].  <b>They are not the same.</b>.  In fact, [[Gold Plating]] often causes defects, rather than fixing them.",
      "id": "07833303abb380d62c32bdebad356802"
    },
    {
      "type": "html",
      "text": "\nOne is failing to correctly implement the requirements as specified.  The other is manufacturing requirements out of whole cloth, under the arrogant (and sometimes correct) assumption that [[You Are Gonna Need It]] (but remember [[You Arent Gonna Need It]]).  In many cases, [[Gold Plating]] invites sloppiness (and defects), when the gold is incorrectly implemented and turns to [[Iron Pyrite]].  To make matters worse, many who are guilty of [[Gold Plating]] due so because they find that more interesting work to do than working on (and [[Unit Test]]ing) the more pedestrian requirements that are in fact in the spec.",
      "id": "376d0caefa1dfedf092d431dd84dc511"
    },
    {
      "type": "html",
      "text": "\nA related fallacy is confusing several different types of \"quality\".  One is freedom from defects; in the absence of a better metric this means compliance with a requirements specification.  (Many would say that the requirements spec is the ONLY meausure of this form of quality).  Another definition, used by some, is the closeness to some idealized set of requirements (which may or may not be useful to the customer).  This definition of quality is the one invoked by folks who engage in [[Gold Plating]]; when confronted with their activities they loudly insist that they are merely designing in quality, and that anyone who opposes their [[Gold Plating]] is thereby promoting development of an inferior product.",
      "id": "51489208aa1e3c2c993f8f516f5cbd21"
    },
    {
      "type": "html",
      "text": "-- [[Scott Johnson]]",
      "id": "dab6bb985fd4eae63ee8fbff2c7c51bd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "625cd4d82a6927975260dc79a54e0560"
    },
    {
      "type": "html",
      "text": "See also [[Quality Elbow]], [[Quality Is Not Free]]",
      "id": "ce6677dab388fc858c154e36e903cbad"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?IsYourCodeThatImportant c2.com]",
      "id": "96c6303454fe2dc1b9848463b01080c0"
    }
  ],
  "journal": [
    {
      "date": 1115966891000,
      "id": "7d275f2373aab60b43c16e631747186d",
      "type": "create",
      "item": {
        "title": "Is Your Code That Important",
        "story": [
          {
            "type": "html",
            "text": "Software quality is a multifaceted thing. Depending on the project and the task you might be worried about reliability, scalability, security, or usability, for example. How do we balance these facets of quality against themselves? How do we guard against [[Gold Plating]] on one hand, and on sloppiness on the other?",
            "id": "7f8a71d395cbd53f1c266f220a4023a6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "A lot of programmers believe all code has to be bullet-proof. This can lead to a multitude of sins:",
            "id": "da34795d7fcec35c542d396cc7c5d42d"
          },
          {
            "type": "html",
            "text": " <b>Overemphasis on security</b>:<br>\"We have to spend an extra week writing this password system because somebody could crack it with a cross-channel attack.\"",
            "id": "0e11ea5153510a629508ae4c2131efe2"
          },
          {
            "type": "html",
            "text": " <b>Overemphasis on efficiency</b>:<br>\"I'm going to write my own garbage collector because I want this to be the fastest bulletin-board system the Web has ever seen.\"",
            "id": "d7091ff0d90537461472b82b35a6f9b3"
          },
          {
            "type": "html",
            "text": " <b>Overemphasis on reliability</b>:<br>\"Let's make our content-management system load-balanced, because if we got [[Slash Dotted]] the site would be down for a day or two, which would be pretty catastrophic.\"",
            "id": "47c3f0ea0ba284bd0b056564abc92bdd"
          },
          {
            "type": "html",
            "text": "\nAll these things cost something, and sometimes we as programmers are too willing to incur those costs. If you're writing MP3 jukebox software for the next LAN party, a bubble-sort will do just fine. If you're writing a login system for a Web bulletin board, you probably don't need a security audit.",
            "id": "907336a825103c35db69712ef2d63b25"
          },
          {
            "type": "html",
            "text": "\nLet's be honest with ourselves: The vast majority of the work we do isn't really that difficult. Sure, you want it to work most of the time. But most of us are not making software for financial transactions or pacemakers or missile guidance. The bread-and-butter of the software industry is harmless stuff: Content-management, marketing reports, you know the drill. If it's a little pokey, if it has a downtime of a few hours once in a great while, it won't be the end of the world.",
            "id": "140a79d6a94c0068ba51cf16d2227a9b"
          },
          {
            "type": "html",
            "text": "\nPerhaps we have a tendency to act is if our work is difficult because we consider that to be the highest form of programming. The work is only important if it's difficult. Maybe we should think differently. Maybe the work is important if it <i>helps people</i> - and sometimes helping people is deceptively easy.",
            "id": "c36cfad70916431d76944b3f9d650d93"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "<i>most of us are not making software for financial transactions or pacemakers</i>  This is perhaps a slightly skewed worldview.  While I've done my share of working in the e-world building gee-whiz things, I've spent most of my career working in fields where slightly more care is required.  I cut my teeth working in a medical educational institution.  Among the tools I worked on were some that directly affected patient care - certainly not pacemakers, but things like software to ensure that accurate lab reports reach the physician who requested the lab work in a timely and secure way.  Patients and doctors do <b>not</b> appreciate inaccurate or late results on tests for the presence of potentially fatal conditions.  Now I work for an insurance company.  Claims management, HIPAA, disability payments, retirement plans - all forms and forces on financial transactions.  These sorts of things, IMHO, are the bread and butter of software development. -- [[Steven Newton]]",
            "id": "94346a9473ab203c84c2b00377c7db3b"
          },
          {
            "type": "html",
            "text": "\nYeah, perhaps I was overgeneralizing from my personal experience. I have yet to ever code anything of life-and-death importance, though obviously there are people out there who do so. I haven't met many of them, and I have this inkling that numbers-wise most programming is not actually life-and-death, but I certainly don't have a hard numbers to back up such an intuition.",
            "id": "6401e9f0858c8eafc3ae98c44059bbd5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "Wow. You live in a pretty different world than mine. In <i>my</i> world, software is inefficient, insecure, and breaks down <i>all</i> the time. So I doubt there really is a surfeit of programmers adding too much bulletproofing to everything. Oh, and I believe it <i>helps people</i> when their systems aren't regularly getting hacked and their files aren't regularly getting corrupted. -- [[Alain Picard]]",
            "id": "c7887d22d993507bfa89dab851f509dc"
          },
          {
            "type": "html",
            "text": "\nIt's not that software is always efficient, secure, and extremely reliable. But in aiming for these goals, programmers often incur other costs, and sometimes those goals aren't that important. Some programmers often say things like \"That'll be too slow\" or \"That isn't scalable\" or \"That won't be five-nines\" ... This is why some people here say stuff like [[You Arent Gonna Need It]], because there are a lot of people who think you always will.",
            "id": "266d9f12134adb3bcc8fb92acc56ac5c"
          },
          {
            "type": "html",
            "text": "\nThese are always ideals, but they're not always necessary. I was once at a hacker conversation and overheard a conversation with someone who was running his own relatively insecure server, and didn't care. \"Sure, someone will hack it one day,\" he said, \"but none of the data is private, and it's regularly backed up, so if something happens, I can just reformat the drive and start from scratch.\"",
            "id": "b528800f7280f747c479a0687c062118"
          },
          {
            "type": "html",
            "text": "\nOf course, such a lackadaisical approach does not apply in many situations. But there are many positions where it <i>does</i> apply, and the tendency to take the code overly seriously may blind us to recognizing the times when we can do things quick and sloppy.",
            "id": "e2724a1e4e7395315e505b92bc302920"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "\nAs if the level of amateurism in our industry is not big enough ! Here we even try to make a case for it. \"Sloppy is not acceptable under any circumstances when you get paid for it.\" Go upfront and tell your customer or to your manager that by normal standards you're goping to do a sloppy job. Or deliver a shring wrapped software package clearly labelled: \"sloppy quality, but it costs you 50$ instead of 100$\". See if you get paid. ",
            "id": "6cd188ce23768755b5c36fefc2308caf"
          },
          {
            "type": "html",
            "text": "\nThe only seeming justification for \"sloppyness\", is the price. What is contended is that even decent quality has to be obtained most of the times by substantial effort, resulting in significantly increased costs. That's a [[Red Herring]]. What it really costs is to [[Give Up On Amateurism]], and this price should be paid by the many developers who have barely minimum education and training for their job, and should be paid with their own private time. The solution to produce better software is most of the times not to work more or to work harder, but to work <b>better</b>. ",
            "id": "06eb5cdd4e6f9adbb1aab63cc2f8e9e1"
          },
          {
            "type": "html",
            "text": "\nSome of the examples given are all too unfortunate and all too present. Simply said that guy was probably doing a poor job and even worse, he was proud of his amateurism. To run a secure server vs. an insecure one is largely a matter of having a well trained and knowledgeable sysadmin vs an amateurish one. It is very little a matter of someone having to put substantially more effort into administration tasks. Similarly, \"planning\" for hours of downtime is just as ridiculous even if we're talking only about marketing reports. -- [[Costin Cozianu]]",
            "id": "18cabe884023030ef6ca595f3350abd8"
          },
          {
            "type": "html",
            "text": "\nOn rereading the example of the hacker with the poor server, I realized I did not explain it clearly - it was his own server I was talking about, meaning he's effectively the client and is allowed to make the decision to be half-assed about security. (I've amended the description above.)",
            "id": "8b3787c49e35423cbba17484318a8f5f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "\nLet's say, for the sake of discussion, that you <i>could</i> make a strong argument for de-emphasizing things like Security, Efficiency, and Reliability.  (I find such an argument ridiculous.)  There is still no good purpose in pointing out that argument, because owing to the [[Rampant Amateurism]] in our field that Costin points out, we <b>already</b> have such a de-emphasis in place.  Most programmers are either too stupid or too unskilled to build Secure, Efficient, Reliable systems.  The 5% who can reach a reasonable level on those aspects don't need to spend an inordinate amount of time on them.  Those who need high quality hire great programmers.  Those who don't, hire the dregs.  So to some extent, the programmer market already assigns importance to high quality wherever it's needed.  (If the salary gap between the dregs and the best were greater, the market would be much more effective at this assignment task.)",
            "id": "cb07ec46905d2282b208d568db731c3d"
          },
          {
            "type": "html",
            "text": "<i>Are you're saying that such an idea could be dangerous, therefore it should be suppressed?</i>",
            "id": "368b1f9fdb1bcb6e8edbe4d83cd5f4a7"
          },
          {
            "type": "html",
            "text": "\nI wasn't thinking in terms of danger, but usefulness.  But depending on your audience, yes the idea could be dangerous.  To tell the average programmer this, there is no harm.  He can't achieve those goals anyway, so he need not waste valuable thought cycles on them.  To tell the good programmer this, there isn't any real harm either.  She can achieve those goals to a reasonable degree without taking great pains, and she knows when to ignore advice.  To tell a manager this could be dangerous if he needlessly prevents the good programmer from attempting those goals.  The danger is not tremendous though, because the good programmer can ignore that manager or go work someplace better.",
            "id": "4bbfa0865a19dfacfd17016791aef608"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "\nThis week (late March 2002), I convinced a system architect for a national organization that having all the branch offices send self-extracting ZIP files (EXEs) was a bad idea - that ordinary ZIP files would be better.",
            "id": "ceec4cfe8f5739bc218a19ea0b301578"
          },
          {
            "type": "html",
            "text": "<i>Lessee...</i>",
            "id": "8d308bc0d06bee5a8888bc2e54e64b90"
          },
          {
            "type": "html",
            "text": "<i>If <b>one</b> hacker got a part-time job at <b>any</b> branch office in the U.S. and took a look around, it wouldn't take them long to recognize the naming standard for EXE files sent up to be <b>executed automatically on the central server with \"root\" authority.</b> (And given the nature of the business, questionable part-time help is <b>very common!</b>)</i>",
            "id": "ce0a84fcb8e5a8b05b119627116f7008"
          },
          {
            "type": "html",
            "text": "\nNot a good plan. Plain ordinary data files are a <b>much</b> better idea than importing and running suspect code.",
            "id": "728f91c1f5ed5d91041d18f88c3facc9"
          },
          {
            "type": "html",
            "text": "-- OneOfTheOnesWearingA<b>White</b>Hat",
            "id": "e6f82a01b6effefb83d8bf761b8c4840"
          },
          {
            "type": "code",
            "text": "  ;->",
            "id": "173add5bbc18bd0686021c9ed9c57155"
          },
          {
            "type": "html",
            "text": "<i>That \"architect\" is a perfect example of someone too stupid to build secure systems - par for the course.  It also serves as an example that holding the </i>title<i> architect does not make one a true architect, nor does mere title imply one has much brain.  As often as not, a holder of the title architect serves merely to call out the supreme incompetency of the hiring manager - also par for the course.</i>",
            "id": "ad08ddd4ebd61743d5db8a6b2c5eb1d6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "<i>deliver a shring wrapped software package clearly labelled: \"sloppy quality, but it costs you 50$ instead of 100$\". See if you get paid. </i>",
            "id": "6ae07dd9f98223cef526124f9ca9c8b7"
          },
          {
            "type": "html",
            "text": "\nSure you'd get paid. Show me a shrink-wrapped product without one of those weasel-word warranties that say, in effect, \"the product you have just paid good money for does not work, and we never said it would. If by some chance the one you have does work, it won't do what you're expecting it to.\" Show me a company that produces shrink-wrapped (or even bespoke) software that has a genuine warranty guarenteeing merchantability, fitness for purpose, that the product will be fixed <i>at no charge</i> if it doesn't work as advertised, as one would expect with any other complex technological poduct with no user-serviceable parts inside (we aren't talking about open source here), and then we might have something to talk about.",
            "id": "03f727613f379fce50b6df4c0989fb87"
          },
          {
            "type": "html",
            "text": " This brings up a side point: are such disclaimers in EULAs legal? I have occasionally heard it said that they might not be, but that no case testing their validity has ever come up. IANAL, so I have no basis for agreeing or disagreeing with the claim, though I find it hard to believe that no one has ever contested such an ubiquitous practice, even if only as an arranged test case. Does anyone know if any EULA of that type has stood up to a legal challenge? - [[Jay Osako]]",
            "id": "bd016350d6cbb698d1002c46380d6d82"
          },
          {
            "type": "html",
            "text": "\nThe original poster does have a point. It seems that insufficient thought is put into what balance is required, and where the costs and benefits lie. The \"e-\" world suffers especially with this. There seems to be an idea around that every page on every e-commerce site needs to be up at full effectiveness 24/7, even if it can only  be used by people in a small number of time-zones. That every page of every coporate website has to have enough capacity behind it that it can remain available when slashdotted twice over. That every byte of every file of corporate data needs to be protected from the massed onslaught of every hacker in the world.",
            "id": "c59517d5a05bdfbdf2262413e911c3b5"
          },
          {
            "type": "html",
            "text": "\nAnd maybe yours <i>do</i>. So fire ahead. And maybe they don't. Has anyone bothered to find out, either way? Has anyone worked out if the cost of downtime at 2 am in the only timezone where the site may be used exceeds the cost of making the system be up 24/7? Has anyone worked out how likely it is that the site will be slashdotted? How much it would cost if it was unavailable for a while, once in a blue moon? Whether that cost would exceed the cost of the extra capacity that sits idle almost all the time? (The real villains here, by the way, are not gold-plating developers, but eager consultants from the hardware vendors.)",
            "id": "cc519ab252f864a6d650cc65147d4a69"
          },
          {
            "type": "html",
            "text": "\nI'd love to be in a world were I was able to make the kind of decisions that Costin derides. I'd love to know that I was able, as a consumer of software, to balance purchase price against reliability, or functionality. It seems, though, that the idea that every piece of software has to be bullet proof infects the transaction, so that vendors are extremely reluctant to admit that their product has any deficiencies or limitations at all, even thought they all do. To the extent that little in the way of comparison can be made. I can't even identify a baseline. Consider motorcycles. I can compare motorcycles by cost and by functionality, and I can see that I can pay extra for, lets say, increased power and torque, rider comfort and long-range crusing reliabilty. But that would make no sense if what I'll be mostly using the bike for is hacking down to the shops and back. But even the smaller, relatively uncomfortable, relatively unreliable bike I buy for tooling around town will meet certain minimum standards for safety and reliability. Can't do that kind of thinking with software.",
            "id": "b1def303aaf7080d5db1f8d16be9e567"
          },
          {
            "type": "html",
            "text": "<i>I rode a motorcycle around with some friends a while back, meeting the minimum standards.  Hit a pothole.  Ten minutes of riding later, another rider noticed that a weld had failed, and the pin holding the front wheel to the frame had come out on one side, and was nearly out on the other as well.  Decided it would be prudent to stop riding :)</i>",
            "id": "a3fa6177fdc870c67dff9e2b3c42369a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "Perhaps the idea needs to be stated more precisely. There are different types of quality, and perhaps some are negotiable while others are not. For example, all code should be well-factored and easy-to-read, unless technical demands justified difficult-to-read code - for example, if parts had to be optimized. Furthermore, software shouldn't fail under unexceptional circumstances. These would be analogous to the minimal safety and reliability standards for consumer products, whether those are power drills or concentrated orange juice. Your power drills can't fly apart when you're drilling through drywall, and your orange juice can't have botulism in it.",
            "id": "535e75791d1f87a04b7acc323bfdd7c2"
          },
          {
            "type": "html",
            "text": "\nBut perhaps there are other types of quality that are not the minimum. Not every website needs SSL-based login. Not every database needs to spend the money to have five-nines uptime. Not every possible function in a piece of software needs to be highly optimized. These things would all be good, but they cost money and time. And any feature, no matter how useful, can have a price that is too high. How much it costs depends on your own engineering ability - which we should always be striving to improve - but how much it's worth depends on what the client needs. The client has a finite amount of money, and if we sell em software features that e doesn't need, then we've scammed em. Even if those features work.",
            "id": "b09fd24b156e2f4c9f0cf5ad50b38288"
          },
          {
            "type": "html",
            "text": "\nYes, there's a quality problem in the software world, and it's something we should all strive to eliminate. But when something qualifies as [[Gold Plating]], that's not a solution. There are different sorts of quality, maybe the point of this page is that we should learn to focus on the ones that really matter to the client. (And if we don't know what matters to the client, we should learn how to ask.)",
            "id": "eda36c0d850e317527676a942d8a955b"
          },
          {
            "type": "html",
            "text": "<i>For more on what happens if you don't ask, see [[The Customers Are Idiots]]</i>",
            "id": "8d715fd52a10fbe1b6f9551c14c7c00f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "There's often a conflict between two priorities: 1) Overall security / performance / reliability and 2) Making deadlines and including new features. I personally favor 2), as have most of my managers, though my code almost always has good performance and reliability. Many of my coworkers, who strike me as perfectionists, have focused on 1), even if it means missing deadlines or adding fewer valuable features. Customers generally seem pleased with products that have good, though not extraordinary, quality, as long as they receive deliverables, bug fixes, and enhancements promptly. -- [[Jared Levy]]",
            "id": "22e32aa2378928b7bb2dcd24d321728b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "In one of his follow-ups the original poster suggested that <i>sloppy</i> code is sometimes acceptable. I would take issue with this - in my experience sloppy code almost always comes back to bite you.",
            "id": "1dba3e9fe19e02957f0c15197b6ff6f7"
          },
          {
            "type": "html",
            "text": "\nHowever, I totally agree with his original point that programmers often overemphasize security, efficiency and reliability without even realizing they are doing it. These are all forms of [[Premature Optimization]]. [[Keep It Simple]] then spend time improving the security, efficiency or reliability if you <b>need</b> to. -- [[David Peterson]]",
            "id": "17947f7358bc4ce2d37a4634be1494cd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "Lacking any other input, programmers tend to emphasize things that were important in their last project and that they now know well. Any disfunctionality this may induce is easily avoided by paying careful attention the passage of time and the needs of those served. I think this is what is being asked for at the top of this page. -- [[Ward Cunningham]]",
            "id": "b4072e6235cc8a1255e10db1b70a9523"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "One thing that I continually see is programmers hand rolling things that aren't important to the customer and for which off the shelf components are already available and often better.",
            "id": "8d72b50003c5096ad7c3bca53218071b"
          },
          {
            "type": "html",
            "text": "<i>One thing </i>I<i> continually see is programmers working extremely hard to shoehorn in some off the shelf component that is already available, ostensibly better, but just a little different than what is needed.  Quite often it takes far more work to make an off the shelf component fit your problem than it takes to write an exact fit yourself.  Top programmers are best qualified to guess which would be the best route, so let them decide.</i>",
            "id": "c227d350b3ff54f7ce7fcc0beacb660f"
          },
          {
            "type": "html",
            "text": "<b>And I often see engineers investigating an off-the-shelf component; finding some trivial and/or stupid excuse why \"it won't work\" or \"it's too complicated\", patting themselves on the back, and then [[Reinventing The Wheel]] like they planned to do in the first place. -- [[Scott Johnson]]</b>. ",
            "id": "c697bc8b03dd4176b5da9efd60f6e0e7"
          },
          {
            "type": "html",
            "text": "\nOf course, if the component is truly small enough; maybe reinventing is better than shoehorning.  But if it's that small, it probably isn't worth reusing.  Things that are worth reusing are worth adapting (and probably adaptable with a reasonable amount of effort). ",
            "id": "c33927cb1e421841c16d6bf281b94689"
          },
          {
            "type": "html",
            "text": "<i>If the thing is </i>truly<i> not important to the customer, then you do not need one in the first place.</i>",
            "id": "cd27b79ee97ba4b7f832dd8606989a87"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "Only inexperienced developers think that perfect software is (a) always possible and (b) always worth the cost.  Anyone who has ever been responsible for meeting a schedule and budget knows better.  Responsible professionals should constantly be asking themselves this question, and bringing the issues to their managers when the answers aren't clear.  See [[Help Your Manager]].",
            "id": "92e991d94855975690d887b4bdd24a92"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "\nOur code is <b>absolutely important</b>. Period. How about that?",
            "id": "07b63d5bc5548adee948cc45081968de"
          },
          {
            "type": "html",
            "text": "\nOf course that includes that we shouldn't blow up the costs or the whole project and a lot of many other things. But also including the fact that writing a bubble sort is as inexcusable as writing a garbage collector for the next bulletin board. At a minimum, the code should not be <b>sloppy</b> and <b>pokey</b> even if it's <i>only</i> a report for the marketing department, or whatever else might be considered <i>not that important</i>. The idea that your code isn't <i>that important</i> is also dangerous, because there's no lower bound. And so it is a terribly convenient excuse for the lack of profesionalism that apparently is overly abundant (or some see it that way). ",
            "id": "1b42a352751010208e3d3435e0211f6a"
          },
          {
            "type": "html",
            "text": "<i>In most cases, you should have a sorting library available; even C has one (though given C's lack of any sort of polymorphism other than [[Pointer Cast Polymorphism]], generic algorithms are a royal pain in C).  If, OTOH, the number of things you need to sort is very small; bubble-sort is reasonable.  I would bother writing a quicksort routine to sort an eight-element list; that borders on [[Gold Plating]].  I would, however, keep the sort code in its own routine, so if I do need to replace it with quicksort (or something better) later, I can do this with minimal disruption.</i>",
            "id": "0e07b17a05d3168a795439b9ec21d23f"
          },
          {
            "type": "html",
            "text": "\nWell, other people might think that  the problem is in the opposite direction: writing overly complicated code for simple problems. Yes, that happens - IMHO way less than just plain sloppy code, where \"sloppy\" is an euphemism. But when that happens it is (usually) not because developers over-emphasize the \"importance\" of their code, on the contrary. ",
            "id": "775b8951d29d5b02033cfad014ed5e89"
          },
          {
            "type": "html",
            "text": "\nLet's pick a hypothetical but very real example (more realistic than the examples on the top of the page): a simple transactional web/database application . So a bunch of over hyped developers will create an ellaborate MVC/n-layered architecture, with session beans, entity beans and the whole enchilada (you can throw your favorite O/R mapping tool in there). And in the end the whole damn thing is likely to crash on them : huge costs, poor performance, long development time, etc.  If they'd had employed my absolute favorite pattern: [[Put The Damn Data On The Damn Screen]] they'd be finnished a lot sooner with guaranteed good performance, maintainable code and so on. So was it because they considered the code too important ? ",
            "id": "8efbc7cafc0e4da082bc2db76d1a2394"
          },
          {
            "type": "html",
            "text": "\nI don't think so. If the quality of the code is really that important, [[Put The Damn Data On The Damn Screen]] is the first thing you need to think about and actually use it. -- [[Costin Cozianu]]",
            "id": "e63166a52a62f8b48be3dcdf9404960d"
          },
          {
            "type": "html",
            "text": "<i>[[Put The Damn Data On The Damn Screen]] has absolutely nothing to do with what the original poster is talking about.  [[Is Your Code That Important]] is closely related to [[Do The Simplest Thing That Could Possibly Work]], with an emphasis on accepting ugly code that works, and not trying too hard to solve the general cases that the customer doesn't care about.</i>",
            "id": "f480cb5cbcd36763675766553db8a536"
          },
          {
            "type": "html",
            "text": "\nWell, ugly is one thing (although I have no idea what ugly code means other than a personal <i>de gustibus</i> kind of rambling), but Francis was talking about lowering quality (well, that's what sloppy and pokey apparently means). ",
            "id": "141feefa6e413668a59a83cf7c68d478"
          },
          {
            "type": "html",
            "text": "\nSo the question is how low(er) can we get ? This has been unanswered. And there's the interesting relation between the costs, the quality, and the professionalism of the developers involved, which has to be taken into account. ",
            "id": "ea4fdbcc3bb2e251f9ac489c84817150"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "On further reflection: What's in question is not whether the code overall is important - if code is your job, it should be at least somewhat important, or you should find another career. What's important is that realizing that of all the different metrics of quality - reliability, scalability, security, efficiency, etc., etc. - some are more important than others, and that 100% quality is probably unattainable. Even if it was attainable, most clients wouldn't want to pay the costs of such perfect software.",
            "id": "d83fda7d4098e6e50deaab0cfa1df49f"
          },
          {
            "type": "html",
            "text": "\nTo state the problem another way:",
            "id": "7d3109b8973476ff54ed28a76fb81c84"
          },
          {
            "type": "html",
            "text": " In almost any software project, somebody needs to make decisions to prioritize certain aspects over others. This is because time and money are almost always insufficient to satisfy all demands.",
            "id": "14eb3961971bb95af1846760d459f328"
          },
          {
            "type": "html",
            "text": " This process of prioritizing is extremely difficult, for a number of reasons.",
            "id": "482eb9150c7b32bd4f01d698ed426daf"
          },
          {
            "type": "html",
            "text": " Some of the difficulty in prioritizing comes from the developers themselves, who have various emotional reasons for suggesting [[Gold Plating]], [[Premature Optimization]].",
            "id": "4eac08c7097173fd13a6dfe07e6e08a8"
          },
          {
            "type": "html",
            "text": "\nPerhaps part of this might be a legacy of organizational problems: In lots of companies, developers are kept cloistered away from the clients. So a developer's sense of what's important grows separately from the clients' sense of what's important. To make things worse, developers often think that clients (and project managers) don't know what they're doing, which makes them more eager, subconsciously, to take more stewardship of the direction of the project.",
            "id": "094987643d06894a7e47775b21c2bd92"
          },
          {
            "type": "html",
            "text": "<i>\"Subconciously\"? Just look at pages all over this wiki, many of which assume incompetance or worse in the project (and other) managers...</i>",
            "id": "649406deba78b60541b29d05bf7b6dd2"
          },
          {
            "type": "html",
            "text": "\nWell, in my experience that would cover about 40% of projects.  YMMV, of course.",
            "id": "0602deb5e3e5f31691672dd83c0b667b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "\nThere's a valid concept called <i>over training</i> in which you, say, train a muscle by lifting more weight than it will be required to lift in the activity being trained for.  I view metaphorical \"mission critical\" in this light.  What happens when you pretend that every mistake matters?  I guess that depends on you, but for some people it results in a successful training effect, leaving them able to produce more and better than before.  There are at two reasons why this works when it does.  First, it helps isolate and remove lazy or sloppy habits.  That's the obvious one.  Second is because in all crafts (and we're agreed that software is craft, not science, aren't we?), there is value in <i>slow practice</i>.  When you do something slowly enough to maintain full mental and physical control, you are also building the capability to do it faster without losing control.  When you always do things a little too fast and a little out of control, you plateau rather quickly.  I'm thinking about piano playing as I write this, but it applies to almost any physical ability that requires control.  This may not apply directly to software development, since SD is not purely a motor skill, but in my mind's eye I see the connection.",
            "id": "4345c9e0a0d8e87a114a972c73c9346e"
          },
          {
            "type": "html",
            "text": "\nWe're talking about the quest for perfection.  Let's not assume this quest arises from life threatening need to be perfect, at least not all the time.  Art is partly about showing off the limits of human ability.  The symphony played flawlessly.  The high wire act.  Fine marksmanship.  It's not the code that's so important, it's us.  So let's pretend.",
            "id": "4ad72630633ac21a5f1168e58297749d"
          },
          {
            "type": "html",
            "text": "-- [[Walden Mathews]]",
            "id": "c9fd54837ba1feebd81cdf8d9cff65bf"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "\nSome people seem to be equating <i>sloppiness</i> with failure to indulge in [[Gold Plating]].  <b>They are not the same.</b>.  In fact, [[Gold Plating]] often causes defects, rather than fixing them.",
            "id": "07833303abb380d62c32bdebad356802"
          },
          {
            "type": "html",
            "text": "\nOne is failing to correctly implement the requirements as specified.  The other is manufacturing requirements out of whole cloth, under the arrogant (and sometimes correct) assumption that [[You Are Gonna Need It]] (but remember [[You Arent Gonna Need It]]).  In many cases, [[Gold Plating]] invites sloppiness (and defects), when the gold is incorrectly implemented and turns to [[Iron Pyrite]].  To make matters worse, many who are guilty of [[Gold Plating]] due so because they find that more interesting work to do than working on (and [[Unit Test]]ing) the more pedestrian requirements that are in fact in the spec.",
            "id": "376d0caefa1dfedf092d431dd84dc511"
          },
          {
            "type": "html",
            "text": "\nA related fallacy is confusing several different types of \"quality\".  One is freedom from defects; in the absence of a better metric this means compliance with a requirements specification.  (Many would say that the requirements spec is the ONLY meausure of this form of quality).  Another definition, used by some, is the closeness to some idealized set of requirements (which may or may not be useful to the customer).  This definition of quality is the one invoked by folks who engage in [[Gold Plating]]; when confronted with their activities they loudly insist that they are merely designing in quality, and that anyone who opposes their [[Gold Plating]] is thereby promoting development of an inferior product.",
            "id": "51489208aa1e3c2c993f8f516f5cbd21"
          },
          {
            "type": "html",
            "text": "-- [[Scott Johnson]]",
            "id": "dab6bb985fd4eae63ee8fbff2c7c51bd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "625cd4d82a6927975260dc79a54e0560"
          },
          {
            "type": "html",
            "text": "See also [[Quality Elbow]], [[Quality Is Not Free]]",
            "id": "ce6677dab388fc858c154e36e903cbad"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?IsYourCodeThatImportant c2.com]",
            "id": "96c6303454fe2dc1b9848463b01080c0"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "code.sfw.c2.com",
      "date": 1706860329728
    },
    {
      "type": "edit",
      "id": "7f8a71d395cbd53f1c266f220a4023a6",
      "item": {
        "type": "html",
        "text": "Software quality is a multifaceted thing. Depending on the project and the task you might be worried about reliability, scalability, security, or usability, for example. How do we [[balance]] these facets of quality against themselves? How do we guard against [[Gold Plating]] on one hand, and on sloppiness on the other?",
        "id": "7f8a71d395cbd53f1c266f220a4023a6"
      },
      "date": 1706860352301
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1706871577958
    }
  ]
}