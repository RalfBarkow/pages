{
  "title": "Water Fall",
  "story": [
    {
      "type": "html",
      "text": "The \"traditional\" model of software development lifecycle. Largely discredited*, but still widely used. Development is broken into sequential steps: Analysis, Design, Coding, and Testing. (aka. [[Drive By Analysis]] and [[Big Design Up Front]] followed by [[Big Coding In The Middle]] and [[Big Bang Testing]]). Called \"[[Water Fall]]\" because each artifact in the model \"flows\" logically into the next.",
      "id": "c101e2cdc093cfbeecfd83ec485de49d"
    },
    {
      "type": "html",
      "text": "\nThe \"traditional\" [[Water Fall]] model with its [[Big Design Up Front]] and months of [[Big Coding In The Middle]], the [[Era Of Silence]], inhibits (or prohibits) evolution of understanding leading to fourth and fifth steps, [[Big Last Minute Changes]] followed by [[An Unacceptable Way Of Failing]]. ",
      "id": "f74c310fb768633bce9a9bae9e0dde7e"
    },
    {
      "type": "html",
      "text": "\n[[Water Fall]] is based on the empirical observation of 30 years ago (ref: [[Barry Boehm]], Software Engineering Economics, Prentice Hall, 1981.) that the cost of change rises exponentially (base 10) by phases. The conclusion\nis that you should make the big decisions up front, because changing them is so expensive. 30 years of progress in languages, databases, and development practices has largely voided this assumption, but it is buried so deep that it seems certain to last for some time.",
      "id": "bd2c3f286492a0cd2bcd419f8c19c813"
    },
    {
      "type": "html",
      "text": "(*) Discredited as a literal, followable software process. (see [[Is Water Fall Discredited]])",
      "id": "d6397cfa3593ec66aad319eb136f401c"
    },
    {
      "type": "html",
      "text": "\nWould anyone care to refactor even some of the extensive discussion that follows into [[Document Mode]]? This page is extremely large.",
      "id": "f28f7553e4e561d49f5e30fd0b370b63"
    },
    {
      "type": "html",
      "text": "<i>And Larry Constantine remarked at OOPSLA2005, \"I created one of the first 'waterfall' approaches but I did not create analysis paralysis\".</i>",
      "id": "33a951f769b6dfa1995ffee7c1bfdff3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "\nNow with its own conference!  [http://www.waterfall2006.com/ www.waterfall2006.com]",
      "id": "473939c4ec82778d48a2a72a051364ec"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "Alistair, thanks again for saying [[Water Fall]] is [[An Acceptable Way Of Failing]]. It took us close to a whole load of things that so badly needed saying that I and others produced a few [[Emotional Burp]]s in immediate response. In fact I believe that it's fair enough to feel emotional about [[Water Fall]]. It's so often been destructive of the productive team work and real creative joy that should characterize delivering great software with and to customers.",
      "id": "62485012b2f7eef9db708dd2737c9b9b"
    },
    {
      "type": "html",
      "text": "\n[[Ignorance Fear Pride Or Fraud]] is the mild overview of the issues raised that I've been able to come up with having disconnected from Wiki for 48 hours and (slightly) calmed down! -- [[Richard Drake]]",
      "id": "a745b676b811a54571bcecd124dd284f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "<i>Per the WF write-up at [http://www.objectmentor.com www.objectmentor.com], WF got invented as the following theory: \"When you code,</i> data <i>typically flow from Analysis to Design to Coding to Testing.\" Unfortunately this was easily mis-interpreted to mean, \"</i> time <i>flows from Analysis to Design to Coding to Testing.\" Bad news.</i>",
      "id": "538651bdcf5fb50eba340dd040142d3c"
    },
    {
      "type": "html",
      "text": "<i>Under pressure, even the best of project managers fall back to WF practices.</i> That's <i>the bugbear we all fear here. -- PCP</i>",
      "id": "eb4f0c31cacb4bd588ed6d25d6d29f03"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "The assumption that is usually invalid in a waterfall process is that the requirements will not change during the lifecycle of the project. In reality, requirements change a lot in most (though not all) projects, especially once the customer gets their hands on it. The failure of traditional waterfall process to recognize this is a fundamental flaw. A mistake in the requirements phase can not be detected in a waterfall process until near the end, when the customer gets to see the (nearly finished) product. This leads to a huge cost in correcting the mistake (the old cost-of-change curve again). XP, and most [[Agile Processes]], attack this area explicitly, putting a high emphasis on getting something to the customer early on, so that feedback can be obtained.",
      "id": "bb7570bfdb7a591ae9ffb9159595c02f"
    },
    {
      "type": "html",
      "text": "-- [[Robert Watkins]]",
      "id": "826ffb628b26686a733640e08c004765"
    },
    {
      "type": "html",
      "text": "\nTo put things into perspective a bit, the process most likely to allow a requirements mistake to go undetected until the end is the oblivious one, i.e., the process where developers don't \"get\" requirements. With waterfall, at least requirements are on the map. There's no law against prototyping and verifying with users, either. Maybe waterfall is the toddling process, if you get my analogy. Toddlers don't walk so good, but at least they're walking. Let the balance come with practice. [[Walk Before You Run]]. -- [[Walden Mathews]]",
      "id": "3ec684eccb8358526fbbf42440c2be76"
    },
    {
      "type": "html",
      "text": "\nWalden: I would disagree that your <i>Toddler</i> analogy IS an example of a [[Water Fall]] method. I would see \"crawling\", \"steadied standing\", \"wobbly walking\", \"walking\", \"running\" & \"Olympic sprinting\" <i>(very optimistic)</i> as more an incremental approach.",
      "id": "0e5bdf3f5d76768a21ca0e25606855bb"
    },
    {
      "type": "html",
      "text": "<i>Yikes, I misunderstood your point on first, second and third readings, but I think I got it now. My point is that Waterfall IS the toddler of incremental approaches. See Jaime Gonzalez' better explanation below. -- wm</i>",
      "id": "882be0249ec47313d3fb1067e37b4758"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "The original waterfall model, as presented by Winston Royce in \"Managing Development of Large Scale Software Systems\" (Proceeding of IEEE WESCON, August 1970 [<i>[http://facweb.cs.depaul.edu/jhuang/is553/Royce.pdf facweb.cs.depaul.edu]</i>]) actually made a lot of sense, and does not resemble at all what is portrayed as a Waterfall in the preceding entries. What Royce said was that there are two essential steps to develop a program: analysis and coding; but precisely because you need to manage all the intellectual freedom associated with software development, you must introduce several other \"overhead\" steps, which for a large project are:",
      "id": "afa791530b084e9b86c06734c33dbea4"
    },
    {
      "type": "code",
      "text": "  System requirements\n  Software requirements\n   Analysis\n    Program design\n    Coding\n      Testing\n      Operations",
      "id": "f6620a258c7cce3b93badb1844dac771"
    },
    {
      "type": "html",
      "text": "\nMany of Royce's ideas would be considered obsolete today, but I don't think the problem lies so much with his model as with the cheap (not in terms of money, of course) and rigoristic ways of misunderstanding what became an engineering and project management \"standard\". This \"standard\" is what became [[An Acceptable Way Of Failing]]. ",
      "id": "4863cc4d30996fad3a1924d95e8e96d0"
    },
    {
      "type": "html",
      "text": "\nRoyce's valuable ideas must be understood before we simplistically discard the Waterfall. For example, when he advised to do some things twice he was postulating what we can call an embryonic form of iterative development. Also, some features of the Waterfall are inevitable: as [[Alistair Cockburn]] has said elsewhere ([http://members.aol.com/acockburn/papers/vwstage.htm members.aol.com])ï¿½how can you get to do testing if you have not coded?. <i>Easy. [[Code Unit Tests First]]</i>",
      "id": "7a9261e4f35f3d62a33a791a22f7b833"
    },
    {
      "type": "html",
      "text": "\nThe main problem has not been the Waterfall, but the schematicism involved in a \"standard box for all projects\". The variety of possible routes to follow is enormous: under many circumstances, training and empowering users to do their own computing will be a radical alternative not only to analysis and design, but to coding as well (after all, as Emiliano Zapata would have said, applications should belong to those who make a living out of them). Under other circumstances, the best way to enhance team collaboration is to design the database through a diagram that makes the objects visible to all participants.",
      "id": "0c8c1b14e8675cf795ca56ce5b443966"
    },
    {
      "type": "html",
      "text": "\nFor metrics and data on software project failure, see Capers Jones' books (<i>Patterns of Software Systems Failure and Success</i> is probably the best known).",
      "id": "2fd0f9fbf729a40c61b24d1b5281f150"
    },
    {
      "type": "html",
      "text": "-- Jaime Gonzalez",
      "id": "dd3807433bff579833af6ebd02f01d50"
    },
    {
      "type": "html",
      "text": "<i>Well put, Jaime. Better than my earlier, somewhat frustrated efforts. Thanks. -- [[Walden Mathews]]</i>",
      "id": "e20b156e62a48486ceba5cac9e0c63a6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "The problem with the [[Water Fall]] model, even as explained above, is that it tries to create phases that do not exist, and reflects a fear of writing software that may be wrong.",
      "id": "37f4433f1e3f209daf3759517273ee3d"
    },
    {
      "type": "html",
      "text": "\nThe truth of the matter is that it is no more difficult to write a requirement directly in source code than into a requirements document and it is far easier to validate the requirement as running software. The result of the [[Water Fall]] is that we first attempt to create the system in prose as a requirements document, then translate the requirements document into a design document in prose, then translate the design document into source code. It is no wonder the intent of the user gets lost by the time the software is actually created.",
      "id": "3ec3c85ee6b32764881c5e1e316c6e86"
    },
    {
      "type": "html",
      "text": "\nThe massiveness of the process is not due to a misunderstanding of the [[Water Fall]], but a direct result of it. Each phase can be no more correct than the preceding phase and is likely to be less correct. Translation, errors creep in as we convert requirements prose to design prose and design prose into software. Correctness in one phase requires near perfection in the preceding phase, thus each phase slows down to ensure that errors do not creep in. As the time for each phase grows, the cycle time from concept to actual delivery of software grows. As the cycle time grows, there is more and more pressure to include more and more functionality that the users can't wait for. This in turn inflates each phase even more and increases the cycle time.",
      "id": "be5354fa616a22525780bdc75169208e"
    },
    {
      "type": "html",
      "text": "\nIn effect, the [[Water Fall]] method creates a control loop whose output explodes. The phases may make nice diagrams in books, but they do not exist in reality. English prose is not inherently easier to write than software nor inherently easier to evaluate nor easier to change. The instincts of programmers have been right, go directly to the code.",
      "id": "e7e760ffb0d0947e069aaaeb154942c7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "[[Water Fall]] is a solution to a problem that no longer exists, as a process it was designed for a era where [[Machine Time]] was orders of magnitude more expensive than [[Human Resource]], it really was cheaper to rework a requirement 3 or 4 times in requirement capture, analysis, coding and testing that make a mistake once with the machine. Today [[Machine Time]] is vastly cheaper when compared to professionals time. -- [[Martin Spamer]].",
      "id": "d74210daca62d82c90dea6a69556603b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "<i>See [[Design By Contract]], [[Test Driven Development]].</i>",
      "id": "0f223f0dc2d2893c226b863ade1a977f"
    },
    {
      "type": "html",
      "text": "<i>But none of these are the >real< reason not to use [[Water Fall]].</i>",
      "id": "b000974076b93cec85b38b5702a2abec"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "If you work in a semiconductor fab, and if you make a tiny mistake with a batch of wafers, you have just burned the entire cost of all the processes your wafers previously went thru, plus the cost of sending an entire new batch of wafers thru the fab to this point.",
      "id": "8b7d4edcbaacb98bd0374d4fc14ba9fd"
    },
    {
      "type": "html",
      "text": "\nIf you use [[Water Fall]] the way it was designed to be used, if you make a mistake in an early process and discover it in a late process, you must go back to the early phase and <i>do all the affected phases again</i>. This is because the phase is important (else why are you doing it?), and during the phase you must manually cross-check the fix with everything else. Then you must run the subsequent phases using only the output of the previously re-done phase. Read more about it here at [http://www.waterfall-model.com www.waterfall-model.com]",
      "id": "5d64bff39684c437f01ed9c82ac484d0"
    },
    {
      "type": "html",
      "text": "\nEveryone who says they have [[Water Fall]] experience most likely allowed minor tweaks without re-baking everything. But if you take [[Water Fall]] seriously (because you are using hardware and each phase really is irrevocable, or if you are using software but a militant environment believes it <i>must</i> do [[Water Fall]]), then you must do it right and rebake each phase at mistake time.",
      "id": "38020bf3a1f82a5125022d91166f5d06"
    },
    {
      "type": "html",
      "text": "<i>As noted above, trying to create \"phases\" slows the development of software down. It is not going back to previous phases that creates the problem, but doing the same work multiple times in order to define phases.</i>",
      "id": "7616caffc56ab3e4db3a84a639c7a4a8"
    },
    {
      "type": "html",
      "text": "\nI think I see the problem here. It comes out through phrases like \"[[Water Fall]] the way it was designed to be used\" and \"take [[Water Fall]] seriously\". There's no way to know how [[Water Fall]] was designed to be used, or even to know who designed it or if it was designed at all. And taking something seriously doesn't mean aborting common sense. These words belie a problem with authority and enforced inappropriate applications, not with the model in question.",
      "id": "38f285339ecf8a6f14eee66cd69a350c"
    },
    {
      "type": "html",
      "text": "\nIt makes no sense to judge [[Water Fall]] (strictly or loosely interpreted) without establishing a risk context. There's no reason, [[Water Fall]] notwithstanding, not to write code on the first day of a project if you smell significant technological risk. Even though you're coding, you're still (big picture) focused on requirements, because you are determining the feasibility of the system the customer wants. Don't lose the forest for the trees. The phases of [[Water Fall]] are not absolute, and they are not characterized by specific activities (like coding) but rather by the <i>type of decision being made</i>. [[Water Fall]] prioritizes decisions of the kind where a change in decision can invalidate the entire project.",
      "id": "321421af3087bdf503c1126522166aae"
    },
    {
      "type": "html",
      "text": "\nThe risk of postponing coding and testing until very late (someone's bum idea of what [[Water Fall]] means) needs no explanation. The risk of not assessing a critical body of requirement before committing a lot of code probably does need explanation, to this audience. I have never seen a system in which requirements were not related to each other through interdependence. I have never seen a system in which simplistic and isolated requirement understanding didn't fail when requirements were integrated (built) into a system.",
      "id": "72fd1dcf04d7622af18fceb0bf0d3a08"
    },
    {
      "type": "html",
      "text": "\nWhile it's true that there's only so much planning you can do before planning loses its value (and that varies widely according to style and skill set), why wouldn't you want to know about requirements that <i>must change already, not because the customer is fickle, but because they don't make sense together</i>? Even if you have no strategy but \"let's build it anyway and see what we can do\", why wouldn't you want to know?",
      "id": "b336f36c04d90ca69b1cb10a58b26f37"
    },
    {
      "type": "html",
      "text": "\nSkills matter in the selection of tools and processes. Analysis relies on advanced abstraction ability which seems to develop with experience (no offense, young 'uns). Deep and early analysis by someone with the ability can save you eons of time and wasted effort, but it's a skilled act. Reluctance to use skills not yet attained is wise. If [[Water Fall]] doesn't fit because of missing skills on the team, then it's only common sense to pick another strategy. In this case, dismiss [[Water Fall]] for cause, but please be clear about the cause.",
      "id": "5068dd51aa3e6c44ad1379f9194ff81a"
    },
    {
      "type": "html",
      "text": "\nI believe that the better you get with a given problem and technology domain, the more your work will converge on the simple [[Water Fall]]. (In the life of every teen-ager, there comes that epiphanic moment when you realize you <i>are</i> your parents.) When you switch environments, it's another matter. When you can see a lot of the project coming, you can [[Water Fall]] it. It's really just a matter of knowing when planning will pay off and when it is a waste. When throwing out the [[Water Fall]], be sure to check for babies.",
      "id": "cfd6d492624dc63fbba417fae9bef8df"
    },
    {
      "type": "html",
      "text": "\nAlso, [[Water Fall]] is the simplest (batch) process for building software. How much should you elaborate that process in order to mitigate risk? When reducing risk A, watch out for increase in risk B. What about the risk of an elaborated process? I would rather see a team start with a simple [[Water Fall]] plan for building software and then deal with its weaknesses incrementally than begin with an over-elaborated process and try to figure out which risk reduction parts are not needed. I think you can see that an optimal balance for risk reduction is never a trivial thing. But neither do you have to get it perfect.",
      "id": "73977f52b0a5a97591db7f0ac58279f3"
    },
    {
      "type": "html",
      "text": "-- [[Walden Mathews]]",
      "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
    },
    {
      "type": "html",
      "text": "<i>Deep and early analysis by someone with the ability can save you eons of time and wasted effort...</i>",
      "id": "4c2c55aa0758c075926117f4cc4eb6f6"
    },
    {
      "type": "html",
      "text": "\nCare to justify this assertion?",
      "id": "2a4e3008400aafe44c4026470ca80950"
    },
    {
      "type": "html",
      "text": "<i>Certainly. Not too long ago I went to a meeting in which the participants were gearing up to build a complex system for tracking per-quote charges for customers who receive stock exchange data feeds. Domain analysis revealed that this pricing model was invalid, hence no need to build such a system. The analysis wasn't so deep, but if you took a \"code now\" approach, you wouldn't know until you submitted a bill. In another example, a workstation customer requested more advanced security features, providing a list of functions. Analysis of this list revealed an inconsistence such that some of their proposed features were entirely superfluous. They were removed from the project before a line of code was written.</i>",
      "id": "77610492fb2396efd48700de63819643"
    },
    {
      "type": "html",
      "text": "<i>As a general rule, there's tremendous leverage in the requirements of a project. Failure to fully explore the meaning behind a collection of requirements can be a huge mistake. Early coding shifts focus from semantic depth to implementability, which proved irrelevant in the two cases above.</i>",
      "id": "ed67403b984c4aababf0aacebd4bd3c0"
    },
    {
      "type": "html",
      "text": "\nIt appears the natural conclusion to statements such as \"There's no reason ... not to write code on the first day of a project if you smell significant technological risk.\" and \"When you can see a lot of the project coming, you can [[Water Fall]] it.\" is that [[Water Fall]] is only appropriate for low risk projects. If the [[Water Fall]] does not provide risk reduction, then why do it for even low risk projects?",
      "id": "75527154d973d9cefcbeeeb56bc822a2"
    },
    {
      "type": "html",
      "text": "<i>Good question. You caught me up in sloppy use of terminology. In the first place, [[Water Fall]] calls out prototyping and backtracking as standard practices, so even technological risk and the risk of misunderstood requirements is addressed by [[Water Fall]]. It's just that the current generation chooses to ignore the upward arrows on the diagram, preferring to immerse itself in the metaphor of liquid and gravity. But even if we address the popular notions of [[Water Fall]], being strictly phased and so forth, if you look at what the model is saying you find a heap of risk reduction in that. Code design is all about reducing the risk of poor maintainability, for example. Treating requirements as a system, as I've touched on above, reduces the risk of implementing nonsense. But the harsh reality is that any structure we choose reduces some risks while ignoring (perhaps increasing) others. I have used discrete phases on occasion just because I can and because the project permitted. Whether or not you should use discrete phases when there is no unacceptable risk in so doing is a good question. Could be that matters of style eclipse matters of hard practicality in this area.</i>",
      "id": "c08c3f1c3a9e41f39fbe5e30a7f11766"
    },
    {
      "type": "html",
      "text": "\nWhy is time and effort spent generating paper more productive than generating software that actually runs? Why would paper explanations of complex processes and interactions be more understandable than actual running software showing them?",
      "id": "78fecf382a12a7efc30c113bfe6fc07c"
    },
    {
      "type": "html",
      "text": "<i>The question is not \"Why\" but \"When\". The answer is when the \"paper\" fits the ideal commitment curve for the project you have in front of you. The \"paper\" we're talking about is models, and its purpose is to verify what we can when we can before moving on. This is risk reduction again. But for models to be effective, they have to be meaningful, small, cheap and disposable according to localized measures. Executable models are fine, provided they meet these criteria. A thread-safe running system does not automatically demonstrate thread safety through casual observation. A paper diagram may do a better job.</i>",
      "id": "57047154522a7371e1d01a9b48237e5d"
    },
    {
      "type": "html",
      "text": "\nWhy would a single individual doing thought experiments inside his own head be more effective than multiple people actually trying to use running software?",
      "id": "b6503ce42659909fc1ecd905ae0edec8"
    },
    {
      "type": "html",
      "text": "<i>Summoning the utmost of my intuition, I think you're actually objecting to the situation in which people are expected to invent without feedback. Well, yes and no. In the first place, do you appreciate your full power to validate or invalidate a proposal on what you already know? There's an important tradeoff here. If you have to perform a CPU experiment for every decision you will make in building a given program, you might as well give up now. The question is, when can you rely on memory and when can you not? The answer is: experience. This is an interesting sideline, not strongly connected to the [[Water Fall]] model as I see it.</i>",
      "id": "80cf1cdafb7a9847566afa235e2bf0a7"
    },
    {
      "type": "html",
      "text": "\nThe [[Water Fall]] is not the simplest process for building software, instead it is the iterative experimental approach; the approach all of us used to make our first, custom program.",
      "id": "9f57ab8e064b11b79ea0f6461296ea95"
    },
    {
      "type": "html",
      "text": "<i>[[Water Fall]] is the simplest model for building substantially sized software, but it is not the most intuitive one, nor is it the simplest one for building little programs. How do you decide what's simple and what's not?</i>",
      "id": "9cea0dfeab6820cbeba763dad94cc074"
    },
    {
      "type": "html",
      "text": "<i>-- [[Walden Mathews]]</i>",
      "id": "5409097a6c9c2f0986f1bd3e339692a5"
    },
    {
      "type": "html",
      "text": "\nI can find the references, if desired, but during the discussions of Ronald Reagan's [[Star Wars Missile Defense System]] proposal, it was stated the size of the project was so enormous as to be impossible. It was also noted, however, that programs of that size existed, but had come into being through an evolutionary approach rather than planned design. It seems that the iterative, experimental approach is the only feasible way to build extremely large programs.",
      "id": "2e9e55082e13a83949f478ed98f5196c"
    },
    {
      "type": "html",
      "text": "<i>No argument there. What size chunks are extremely large programs built in, and what does the lifecycle look like within a chunk? By countering false claims about [[Water Fall]], I'm neither dismissing all other approaches nor claiming that [[Water Fall]] has no faults. All lifecycle models are essentially the same, the exception being that [[Water Fall]] is the most fully abstracted and generally applicable one. [[Water Fall]] is the meta-model of software process. It's the XML from which your particular schema is written. 'Iterative' is a minor invention upon a major theme. -- [[Walden Mathews]]</i>",
      "id": "ecabfe141fdec1fd3b9141c0f090982f"
    },
    {
      "type": "html",
      "text": "\nHow is the iterative process based on the waterfall? Perhaps you should define your use of waterfall to support your claim that everything is waterfall. You appear to have stripped all meaning from the term.",
      "id": "7f0209516476803b00663d86343f1810"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "<i>How is iterative process based on the waterfall?</i>",
      "id": "ec7a433902c968193435e44cfd032ae9"
    },
    {
      "type": "html",
      "text": "\nThe iterative lifecycle (not process, if we want to be exacting) takes a bite-size of requirements and follows the steps of [[Water Fall]] over them, then takes the next bite-size of requirements and follows the same steps plus the additional integration that wasn't planned, and so on. Or, as is said many times in our midst, \"little waterfalls\". So the question is, How little does a waterfall have to be before it's not a waterfall?",
      "id": "b21b3915e5ed941e312dba655e8548ee"
    },
    {
      "type": "html",
      "text": "<i>When I am saying iterative approach, I am talking about a fully parallel approach of defining requirements in conjunction with coding in conjunction with testing. I am not talking about \"mini-waterfalls.\" The waterfall approach addresses threads of functionality broken across phases of requirements, design, implementation, and test (or pick your specific sequence). Instead, we can rotate that model 90 degrees and have threads of requirements, design, implementation, and test broken across phases of added functionality.</i>",
      "id": "901aea48118337b4eddbbb442c40bec4"
    },
    {
      "type": "html",
      "text": "\"Fully parallel\" is illusion, like time sharing. You have to ignore some known detail to believe that. You can switch back and forth rapidly from decision about \"what makes sense to build\" and \"what is feasible to build\" and \"how would we build that\", but you can't really do them all at the same time, not as a conscious process. More importantly, when most of this activity is really geared toward answering the first question, you're essentially defining requirement, even if you're coding much of the time. I've made this point three times now. Even if as a byproduct of all your prototyping (requirements phase) you magically ended up with totally usable and mature code, you're still in step with the model. The real problem is that [[Water Fall]] model describes what you do in spite of your attitude toward it. It does not describe the granularity of problem you will attack in one chunk. If granularity is the main issue, we should clearly state that and distinguish between model and granularity of application.",
      "id": "d485f5e65e858a7061e83c8ee8f640e8"
    },
    {
      "type": "html",
      "text": "-- [[Walden Mathews]]",
      "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "Exactly. Every attempt to successfully alter our environment, whether coding software or hitting a golf ball, can be described in terms of the [[Water Fall]] model. NEEDS - PLANS - ACTIONS - ANALYSIS - FEEDBACK. This basic loop is conceptually present in every attempt humans make to reach any goal whatsoever. Rarely does anybody seriously attempt to complete a major development in a strictly linear, one pass through approach, but these things are almost always iterative in reality, as with the [[Spiral Model]]. There may be large debate over how big a chunk you should bite off at a time, but even XP methods move through the basic concepts inherent in the waterfall description, maybe just in much smaller pieces at a time. I want to hit the ball; I'll look over there and swing like this; I swing; I see where it goes; I adjust my swing based on the results. I talk to the customer about what they want; I think of a function to test this requirement; I write the code and test it; I see if it passes or fails; I adjust as necessary. needs; plans; actions; analysis; feedback. There is no escaping this loop regardless of the development model one uses, it will simply be applied using different methods, on different scales. XP may advocate doing this on a smaller scale, with smaller gaps between the steps, but as was said that is a distinction between granularity of application, not of model.",
      "id": "29bc1d0c3b5b67de2ac3270164129bc2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "<b>\"Fully parallel\" is illusion....</b>",
      "id": "d71664e146db001b3251b16b8c7a79bf"
    },
    {
      "type": "html",
      "text": "<i>Sure, if you only have one processor. Waterfall methodologies that I've endured in real projects, up to and including RUP, treat the entire project team as a single processor: the project as a whole is in one phase at a time. This is understandable, if not excusable, given that the main purpose of these phases is to produce the [[Impression Of Control]].</i>",
      "id": "ee6f399abb615f3a09953ee76d38566d"
    },
    {
      "type": "html",
      "text": "<i>XP et al allow individual processors to be in different \"phases\" at a given time. In fact, I can't remember the page, but I saw a mention of [[Unit Test]]s running in an automated loop \"in the background\" while code was being developed. Are we having \"parallel\" yet? -- [[Tom Rossen]]</i>",
      "id": "2304d84d3193aca8c3329424cb8ad03a"
    },
    {
      "type": "html",
      "text": "<i>How is parallelism an illusion? The iterative approach is no more than a restatement of a basic control loop. A control loop constantly generates output, compares it against the desired output, and adjusts. All three tasks occur simultaneously. What I have stated is that the Waterfall model is a different model from the iterative model. The waterfall model views software development as containing separate serialized phases while the iterative model views software development as ongoing parallel operations. Within the context of one model, the other is impossible, hence these must be two independent models. The only remaining question is to determine when each model best reflects reality (and never confuse models with reality).</i>",
      "id": "ed29b5e78ca210d5fe175067aba5e0e8"
    },
    {
      "type": "html",
      "text": "\nN.B. We're getting to something significant here, finally. Much of the rest of this page can be trimmed down, including all my amateur rhetoric. This is technical. Let's dive in with care and precision. I'll take the points one at a time.",
      "id": "c4ca1d89877a2734b517459c253212ba"
    },
    {
      "type": "html",
      "text": "<i>How is parallelism an illusion? ... A control loop constantly generates output, compares it against the desired output, and adjusts. All three tasks occur simultaneously.</i>",
      "id": "82e14210cc9987ae05c8e991416d03ab"
    },
    {
      "type": "html",
      "text": "\nThey may occur with minimum delay between them, but they can't be both simultaneous and meaningful controls at the same time. Here's why. If the evaluation is really simultaneous with output production, then evaluation has defective inputs, just like what happens when you judge my sentence when you're only half way through. This is because output production, evaluation and adjustment are all <i>processes</i> as opposed to <i>events</i>. Similarly, if you are taking corrective action simultaneous with evaluating, then you're taking the wrong corrective action because again your input was incomplete (ergo wrong).",
      "id": "9ef89721ba09c224a6dd48e550216b69"
    },
    {
      "type": "html",
      "text": "<i>The waterfall model views software development as containing separate serialized phases while the iterative model views software development as ongoing parallel operations.</i>",
      "id": "b17b0d29aa22d1e5b978b7e17ccac62b"
    },
    {
      "type": "html",
      "text": "\nI've never heard it stated that way. I've always thought of <i>iterative</i> meaning just that; you take a small subset of the whole problem and explore it deeply (through implementation), then iterate for the remaining subsets. Maybe we want to check some sources on this. I can try to do that, but maybe the task belongs to you.",
      "id": "2ee79fc49d72341eac679b3d5e501961"
    },
    {
      "type": "html",
      "text": "<i>Within the context of one model, the other is impossible, hence these must be two independent models.</i>",
      "id": "f7a7eb7317b4d3588cb23ea2a0333334"
    },
    {
      "type": "html",
      "text": "\nI'll agree that a model of absolutely simultaneous activity differs from the Waterfall model in which temporally and semantically separate stages occur. I should point out that in Waterfall, the semantic phasing is absolute while you can mess around with the temporal thing by changing the granularity of the problem. In other words, you could write some code first (without thinking at all), then go discover some requirements, then compare life with and without the running program to see if it satisfies the requirements. You <i>could</i>, and I'm aware that to a degree, we all do this from time to time, but is it a real strategy for software development? More importantly, can you map your control loop on it? When you do, does the mapping try to \"tell\" you anything?",
      "id": "67fecf79433ad90786c4ceac8bb17015"
    },
    {
      "type": "html",
      "text": " Actually, this is a very common approach in software development. The programmer will take a \"Hello World\" program or another program he has previously written and use that as a starting point. Initially, the program meets none of his needs, but he begins to adapt it to improve its fit with its intended purpose.",
      "id": "14022a2f640b484f29983da7cd0b8bca"
    },
    {
      "type": "html",
      "text": "<i>The only remaining question is to determine when each model best reflects reality (and never confuse models with reality).</i>",
      "id": "906312b813dd95f89696104269947a38"
    },
    {
      "type": "html",
      "text": "\nGlad your life is so simple! A resounding \"+1\" on the \"never confuse\" part. It's because those pointy haired managers confused waterfall <i>model</i> for waterfall ''process' that we have this mess in the first place. I'm casting some serious stones at your version of parallel \"reality\" above, so I'll wait to hear where we stand on that. I think, though, that the real \"reality\" question has mostly to do with the granularity you can tolerate/leverage while solving a given unique problem. Top-down approaches make sense when you have all or nearly all the knowledge you need to do a job, and you just need to organize that. Low frequency Waterfall (big chunks) is a kind of top-down strategy. When you try to use that in a setting where you don't have the knowledge, then you're forced to either guess (and commit to guesswork) or shift gears. And of course, it's the guesswork that isn't \"real\".",
      "id": "3329600c0271ef937a283608d3e04a51"
    },
    {
      "type": "html",
      "text": "\nI don't advocate that anyone try to follow a waterfall <i>process</i>, except as an etude. It's a useful etude because you find out exactly how much you do and do not know, and how much concrete feedback it actually takes to build the thing. In reality, we have uncommon sense to tell us both when we are biting off too much (your criticism of [[Water Fall]]) <i>and</i> when we are biting off too little (what do you call that, by the way?).",
      "id": "d20488bcf25cb76e7e9a4d42d5d734fc"
    },
    {
      "type": "html",
      "text": "\nContrary to late popular belief, Waterfall is not an anti-feedback model. If anything, it's a fast-track feedback model, but as this name implies, it requires a skilled driver. I can write down on paper something like \"user will keep getting the login screen (with error advice, if available) until login succeeds\" much faster than you can implement that idea in code, and I can get feedback from the affected parties that much sooner (almost \"simultaneously\", if you must know). There are some concepts that can't be well verified without experiencing them (proof of the pudding and all that), but there are so many that can be dealt with this way, it's a shame not to. And of course the more you can reason <i>correctly</i> through abstraction, the better you get, and so on. From a bird's eye view, the goal of the Waterfall model is to provide early feedback, the mechanism being abstraction. Look:",
      "id": "65d5ffd90bf7619b0655810ed485cc27"
    },
    {
      "type": "html",
      "text": "START:<br>Specify -> Review -> Identify Errors -> START",
      "id": "e68c8f8b337284d581be633fb510e592"
    },
    {
      "type": "html",
      "text": "START:<br>Specify -> Design -> Code -> Run -> Identify Errors -> START",
      "id": "5c75702e6625c0c179e7712da2224cbf"
    },
    {
      "type": "html",
      "text": "The top loop is significantly tighter, but it doesn't help when there are surprises down the line. The bottom loop ferrets out the surprises, but it postpones feedback to achieve that. Which is the holy grail and which is the devil's forked tongue? Both and neither; why do we have to decide now for all cases? In the wrong context, they both suck. If you're hung up on needing broad consensus on which approach is right, then you're making the mistake that makes [[Water Fall]] suck. Stop doing that.",
      "id": "8c45236b510c5eed8210ba53af32c42d"
    },
    {
      "type": "html",
      "text": "-- [[Walden Mathews]]",
      "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
    },
    {
      "type": "html",
      "text": "<i>Just to reset the stage, I am merely suggesting that there are at least two different models of reality. A model is a simplified subset of reality and different models have different subsets. Different models give different views of reality, by definition; so to compare models to determine which is \"right\" is pointless. Use the different models to give yourself different views and come to a better understanding of reality.</i>",
      "id": "f59a8c6503b63cb2120ad85dbbd27938"
    },
    {
      "type": "html",
      "text": "<i>The only way to evaluate a model is through its implementation. Unfortunately, the act of implementing the model changes it; aspects are added, removed, and changed. As you have noted above, the implementation of the waterfall may very well differ from the pure model of the waterfall, but the implementations are all we have to use to evaluate the model.</i>",
      "id": "5da202afaa260058d09692ae71952d61"
    },
    {
      "type": "html",
      "text": "<i>The iterative approach to software design reflects successive approximation, with each step being a change in functionality. We hope the step is an improvement, but it is not guaranteed; this is the equivalent of undershoots and overshoots in a control loop. In this model, there is no \"understanding\" of requirements, only improved understanding of requirements. Also, this model permits the implementation of the software to influence our understanding of the requirements.</i>",
      "id": "f7fea0ebb335e3515c000f30242b4fbe"
    },
    {
      "type": "html",
      "text": "<i>Just as the \"parallelism\" in the iterative approach may be an illusion, so is the \"serialization\" in the waterfall approach. A requirement cannot be fully understood except in the context of its implementation. Using the log on example posted elsewhere on this page, what was validated through the paper model? What were the significant features of the paper model that needed to be included in the actual software? What were the insignificant features that could be changed or removed? What were the missing features? How long does the log on window take to display? How many characters fit within the user name and password areas? Is the password displayed in clear text? Are there different modes of operation which should also be selected at log on? Is the user name remembered between log ons? The password? If the user name or password needs to be changed, what does typing a character do: append the character at the end, replace the existing text with the typed character, something else? Understanding the requirement of a log on is difficult and goes through iteration as the implementation improves understanding of what is required. Note how switching models affects the view of reality. It does not say the other model was wrong, but it certainly gives a completely different view.</i>",
      "id": "1242146b65aeae94a6b274335ce0bc1b"
    },
    {
      "type": "html",
      "text": "\nThe answer is that to the extent that any of those details are critical to acceptance, they might be written into a simple description that the user can understand and approve. It makes no sense to argue that because there are infinite details to a logon, there is no point in trying to describe the features that matter. In the example above, one critical feature of the application is that you can't use it (at all) until you log on. This is taken from a project I'm now doing. Some of the program's functions are \"safe\" for anonymous users, while some aren't. The sponsors want to sidestep the intricacies and require logon for all users all the time. The requirement says that. It short-circuits tons of wasteful coding that might provide examples of how the system looks with a \"late binding\" logon as opposed to the one decided on.",
      "id": "7c63f2a2ba4ad034de6a74d1c5aafcfa"
    },
    {
      "type": "html",
      "text": "\nNot all models are created equal. It's easy to create a model that doesn't make sense in the real world. Your model of \"parallel phases\" is such a model. While in some respects a rigid [[Water Fall]] \"doesn't make sense\", we're at a different level of semantics in saying that. Parallel phases don't make sense in the same way that Escher drawings don't. Lengthy phases may be suboptimal in most familiar development contexts, but they make logical sense at least.",
      "id": "1cba6d19cad7a3eb863b90546ba18428"
    },
    {
      "type": "html",
      "text": "\nThe logical sense of [[Water Fall]] makes a huge contribution to the management of projects, even if it lends itself readily to misapplication. That contribution is something unique to human intellect. The ability to describe what does not exist but is desired, to use that description as a standard by which to build, and then to use it again to verify that what was built was what we wanted - that ability provides a complexity-taming [[Separation Of Concerns]] that is essentially the same as the separation between interface and implementation in object oriented and other strongly modular approaches to programming.",
      "id": "3989db55733d8755f5a7ecfa651c61b5"
    },
    {
      "type": "html",
      "text": "-- [[Walden Mathews]]",
      "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
    },
    {
      "type": "html",
      "text": "<i>The answer is that to the extent that any of those details are critical to acceptance, they might be written into a simple description that the user can understand and approve.</i>",
      "id": "8e249f54989d59aebe209e2cb3e503bc"
    },
    {
      "type": "html",
      "text": "\nDoes your definition of waterfall require the simple description to be written in prose or does it allow the details to be written as a running program?",
      "id": "ec9ac15c377dd9c5d0abb5c6a87f7912"
    },
    {
      "type": "html",
      "text": "\nThe description has to be in the <i>optative mood</i>, in other words, it has to identify an existing condition and a wished-for condition, and the wished-for-ness has to be explicit in the language of the description. If you can do that in a programming language, it's fine (but can you?). Here's a caveat: pointing to the execution of a program and saying \"There's your requirement\" is bogus, because it lacks a minimum second point of view. Something cannot be its own standard without eroding the meaning of \"standard\". Validity is always a matter of comparison. I think that gets to the heart of your question.",
      "id": "cd90a59b08efb7aabb900e280af38fe4"
    },
    {
      "type": "html",
      "text": "-- [[Walden Mathews]]",
      "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
    },
    {
      "type": "html",
      "text": "<i>Okay, when is a requirement considered defined? Can a requirement be considered defined before it is validated?</i>",
      "id": "47b01214d422716a00eff5c5584d3695"
    },
    {
      "type": "html",
      "text": "\"Defined\" may be too strong a word. It's possible to do very good work with requirements that are clear and complete enough, but by no means rigorous definitions in the formal sense. Strictly speaking, it makes no sense to validate something that is lacking the expected level of definition (being careful to avoid absolutes in that), just as you wouldn't attempt to validate a not well-formed bunch of XML. Similar to how [[Water Fall]] is \"defined\" (well-formed) but not \"validated\" (in simplest form) for use on your project.",
      "id": "38233522cfe5d42819301a5ccfdce300"
    },
    {
      "type": "html",
      "text": "-- [[Walden Mathews]]",
      "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
    },
    {
      "type": "html",
      "text": "<i>Okay, when is a requirement considered \"clear and complete enough\" to move from the requirement phase to the next phase? How is this determined?</i>",
      "id": "6acd5532b80c3da5aff6bce18efe1a0f"
    },
    {
      "type": "html",
      "text": "\nWhen the people who care about it think it is. You seem to be fishing. Catching anything?",
      "id": "89e520fa29ee5f65d7897b8deb97169a"
    },
    {
      "type": "html",
      "text": "<i>Nothing yet. Still trying to get a definition of what the Waterfall Model is. So far every time I propose something I just get told, \"No, it's not that.\" If the purported serial phases exist, surely they must have starting points and ending points? What are they?</i>",
      "id": "123028289d1640a03b0316c801fd5be2"
    },
    {
      "type": "html",
      "text": "\nHave you read the Royce paper? It's probably as \"definitive\" as you're going to get. We could focus our questions and answers on that material if you like. Careful, though, because [[Water Fall]] is a <i>lifecycle</i> model, not a process model, the latter being a more detailed thing defining entry and exit criteria for process steps and all that. Also, you will find reasonable analogs to your questions in XP, if you look for them. For instance, relating to the \"write unit tests first\" dictum: <i>When is a test considered complete enough to begin coding? How is that determined?</i>.",
      "id": "916a4b3ecd18001eecb41824878e0d71"
    },
    {
      "type": "html",
      "text": "\nA [[Unit Test]] is considered complete enough to start coding when it fails.",
      "id": "1523ce67a2c4e3aab3b607d885117ae5"
    },
    {
      "type": "html",
      "text": "<i>No I haven't read the Royce paper. Perhaps you could provide a summary?</i>",
      "id": "cd48ba06aa46a3758d0243f0ad96345d"
    },
    {
      "type": "html",
      "text": "<i>I have read the Royce paper. It describes the 'classic' [[Water Fall]] and says of it that it \"is risky and invites failure\". It recommends doing design before analysis. It recommends 240 pages of spec per million dollars of system. It recommends that you [[Plan To Throw One Away]]. It recommends testing everything (but doing so at the end). It recommends involving the customer. The conclusion I take away from reading the acknowledged defining work on the topic is that the industry has been, for 30 years, using what Royce used as a [[Straw Man]] to recommend fairly reasonable things for his time, and calling it [[Water Fall]]. -- [[Laurent Bossavit]]</i>",
      "id": "25e956a7fd722f25e398bfd30acd2b9c"
    },
    {
      "type": "html",
      "text": "\nLet me propose a strawman for discussion. An aspect of a requirement can only be understood or communicated through an example. The example describes the aspect of the requirement, its implementation, and a means of verification, thus each of these become known simultaneously. These are inseparable, parallel actions. As more and more examples are known, more aspects of the requirement are known. The requirement is never fully known, but our understanding of it should continue to increase.",
      "id": "bc1b76fee32b5d7937f956caf49f4350"
    },
    {
      "type": "html",
      "text": "\nThere are two ways I can record my understanding of a requirement. I can record it in a written document or I can record it in executable software. The waterfall approach has me record the information in a written document (or more usually a series of written documents) and then generate the software from the written document. What I am calling the parallel or iterative approach has the understanding of the requirement recorded directly as software.",
      "id": "682da8c5882eace74fe78a8a5c62fb9f"
    },
    {
      "type": "html",
      "text": "<i>Real world problems constitute an example- and problem-space that's not small according to your local measurements (otherwise, you don't regard them as problems). When a space is sufficiently large, there typically presents more than one way to traverse that space. For example, there are depth-first searches and breadth-first searches. Your example sounds like depth-first, while strawman [[Water Fall]] sounds like breadth first. Breadth-first resembles batch processing, in which the process is uniform across an entire tier. Depth-first resembles piece work, in which you never have large quantities of intermediate results lying around. Each addresses certain risks and ignores others. In reality, you can search that space freely, now delving deep, now reaching broadly. Your sense of effectiveness - a combination of risk awareness, ROI-sensitivity, self-consciousness, etc. - is the guiding force. Models merely describe some of your options regarding that search. A good model is simple, and like a good tool it works well when it works well, and it works dismally when you try to force it to fit. It also works well when </i>you<i> use </i>it<i>, rather than the other way around.</i>",
      "id": "86cec993c052b70ef67560c2e71741e4"
    },
    {
      "type": "html",
      "text": "<i>That said, you understand what you do about this largely because you can fit it into a framework known as [[Water Fall]].</i>",
      "id": "c35a5c9ad3f44c7b306110056a2da529"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "<i>Perhaps you should define your use of waterfall to support your claim that everything is waterfall.</i>",
      "id": "ff87e0f304db18e97d10742cec236c8a"
    },
    {
      "type": "html",
      "text": "\nI've tried in the past to \"define\" waterfall for the purpose of enhanced discussion, but failed to trace waterfall to its historic roots. Please help me do that, if you have a lead. The best reference I have is the Royce paper (see top of [[Waterfall Model]]), but that's incomplete. In the first place, Royce never says \"waterfall\" in the paper, and in the second place, a waterfall-like lifecycle is already assumed at the time of the Royce writing, but apparently without any emphasis on prototyping or code design.",
      "id": "b86773b3c688fa305b25871a81127224"
    },
    {
      "type": "html",
      "text": "<i>You appear to have stripped all meaning from the term.</i>",
      "id": "070e3cde744d890e1a834e61df5e73f3"
    },
    {
      "type": "html",
      "text": "\nProbably only the meaning that you love to hate. If so, I'm succeeding in my crusade.",
      "id": "36b350881131f42fd8d6ef34f9bf95d0"
    },
    {
      "type": "html",
      "text": "\nI gather that the real beef against [[Water Fall]] (or whatever) is the dogmatic persistence in staying \"in phase\" when common sense dictates otherwise, and I gather that there is a maidenhead of resentment built up against managers who obliviously steered projects this way, defeating all the talent inherent in its people. I share the resentment over that practice. However, I would rather that people understand the depth of the waterfall model and the criticality of appropriate application than to think that we've shifted paradigms so that the model is no longer relevant. That smells too much of reinventing the wheel.",
      "id": "be725eb97461017787a95bb17ccadac0"
    },
    {
      "type": "html",
      "text": "\nI also acknowledge that total departures are sometimes called for when a pattern has gone wrong yet remains too strong an attractor to allow improvement within the system. Could it be that we've had our bloody revolution against you-know-what, that we're \"better\" now, and we're secure enough to allow the entry of a historical perspective on software development?",
      "id": "3b92d8521eaf2b965119b040e66558ba"
    },
    {
      "type": "html",
      "text": "-- [[Walden Mathews]]",
      "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "Cheers to Walden for picking up the task of defending the bad mouthed [[Water Fall]] model. I happen to agree entirely with his viewpoints. It makes a lot of sense to review if bad results of [[Water Fall]] approach (by the way, haven't there been any good results at all ?), were consequences of logical flaws in the model, or consequences of bad practice. It's also worth exploring if differences between [[Water Fall]] and other development models are logical/structural differences or just differences of accent, nuances, etc. In particular approaches that start <b>a priori</b> with all kinds of prejudiced ideas like \"requirements are bad\", \"documentation is bad\", [[Big Design Up Front]] is bad and so on, no matter what the context may be, are definitely fishy. --[[Costin Cozianu]]",
      "id": "583d8fafc7fc2a6c096a5b89c9dec382"
    },
    {
      "type": "html",
      "text": "<i>Neither kinder nor truer words have ever been spoken, Costin. Thank you. -- wm</i>",
      "id": "6a71725e97072c8a448afd735fb2bd21"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "This is really wonderful stuff Walden. Coming from a [[Large Scale]] background, much of what you say rings true. About two years ago I was involved in a project where we put together a network management application suite together with a couple of remote design centers. The mess that resulted with conflicting and uncooperative technologies could have been mitigated if we had considered the interdependence of requirements earlier on.",
      "id": "e02ce9c4dddf757bbb888f43012682cd"
    },
    {
      "type": "html",
      "text": "\nConsideration of this interdependence should also help a project get the most out of [[Large Scale Reuse]]. The ideal scenario for my design team would be one where all the standards, protocols, technologies and tools were presented to us (packaged in our favorite language) at the start of a project as if they were the output of a single XP project held for our benefit. And then if all the other design teams and sub-projects also used this set of tools <i>by default</i>, life would be a lot simpler for us. This, of course, is never the case. In the rush to go agile I <i>had</i> forgotten that there are certain decisions that can't or shouldn't be made ad hoc.",
      "id": "da920621c5204b7c91c5ff4c63a15ad3"
    },
    {
      "type": "html",
      "text": "\nThis suggests that small iterations have certain pre-conditions, one of them being a stable technology base. Are there any other parameters controlling iteration size? You already mentioned skill sets. One thing I have noticed is that the developers often <i>are</i> the experts (sometimes they are even the customers in a sense). When this happens, up-front analysis and design starts to sound reasonable again. -- [[Chris Steinbach]]",
      "id": "17fbd8a0dde385fec137c6b08e86f057"
    },
    {
      "type": "html",
      "text": "<i>Chris, the kind words are much appreciated. I come from an environment where \"agile\" is like water to the fish, so pervasive it goes mostly unnoticed. In that environment, I observed many of the kinds of failings you describe above, so my inclination has been to push in a particular direction in search of \"center\". But others have had contrary experience so that \"center\" is someplace else and I appear to be the enemy, or at least someone barking up the wrong sluice.</i>",
      "id": "459c8b43637049ed044a19f620c55c24"
    },
    {
      "type": "html",
      "text": "<i>You're saying that only when the technology base is stable can you afford small iterations? I'm not sure we've got quite the right separation there. I see it more like that a stable technology base (some consistency to deployed technology) has to be maintained as a project goal, but I wouldn't say that long iterations serve better when technology is up in the air. Was that your meaning? -- [[Walden Mathews]]</i>",
      "id": "fbcbb9456623bf09776c508f0e8255b0"
    },
    {
      "type": "html",
      "text": "\nYes this was my meaning. Ensuring the necessary technological stability for the first productive iteration is going to take some time and is therefore a limiting factor. This, however, says nothing about the size and form of the following iterations. In the datacom/telecom industry we are ruled by technology. Every new project comes as a shock to the system. The projects tend to be structured as a [[Water Fall]] with an iterative model in the middle. -- [[Chris Steinbach]]",
      "id": "2edfbe37f6b71666eb96eeb802950f85"
    },
    {
      "type": "html",
      "text": "<i>What technology needs to be stable and why is it necessary?</i>",
      "id": "e9350ee1f2901763423520032967eea4"
    },
    {
      "type": "html",
      "text": "\nI mean the technology used in development, deployment and operation. What's the worst thing that could happen if you ignore this. You might have to rewrite the whole code base if, for example, the chosen language is found to be unsuitable. You might waste time and write a lot of code that is later provided by a 3rd party component. Above all, you can't estimate properly without this stability.",
      "id": "7c78481544b2a8d624bcb15d2d4f49b8"
    },
    {
      "type": "html",
      "text": "\nA strength of any method must be to what extent it functions as a guide. XP provides a lot of guidance. It suggests a number of practices with complex interrelations. These map to a structure of continuous refinement using small iterations. To jump-start this whole process and to overcome, what are considered, minor difficulties some standard advice is offered. But the simplest project model that offers any guidance is, almost certainly, [[Water Fall]]. While XP requires some amount of learning to make it 'pop', [[Water Fall]] tells you what to do, almost in bullet point form. If XP advocates are serious and are not just repeating slogans, then in the spirit of [[Do The Simplest Thing That Could Possibly Work]] they should start with [[Water Fall]] as a project model. Any premature attempt at adding practices, iterations and structure should be met with a firm and resounding: [[You Arent Gonna Need It]]. -- [[Chris Steinbach]]",
      "id": "16ef54128cf1b305ab63baf04e56e60e"
    },
    {
      "type": "html",
      "text": "<i>You might have to rewrite the whole code base if, for example, the chosen language is found to be unsuitable.</i>",
      "id": "d4d501210a835eb2e376f1b1020c5090"
    },
    {
      "type": "html",
      "text": "\nShort of writing some code, how are you going to determine whether a language is suitable? If rewriting the code base is a risk, I would think that would be an argument in favor of a short first iteration, not for a long one.",
      "id": "55d23aab7f3c9613e8a00c0d4103da03"
    },
    {
      "type": "html",
      "text": "<i>It's a tough question. Sometimes it is the mixture of tools that decides. If I can take a network management app as an example. I may have customers who want to access the management system using a certain CORBA version. Then on the network element side maybe I have a mixture of CMIP and SNMP interfaces. It can also be the core competence of a design team or a project that decides.</i>",
      "id": "7b6f6dbd198270f5f452426f02937b5b"
    },
    {
      "type": "html",
      "text": "<i>I think you are correct to say that writing code is an important part of this process. But now we are not talking about production code right? Deployment involves all manner of awful things such as licensing, backwards compatibility, upgrade with data migration. Maybe I have overstated the case for technological stability during development and understated the deployment aspect.</i>",
      "id": "4fed4b20b550fc393d64f1735fecb638"
    },
    {
      "type": "html",
      "text": "\nAlso, please explain the statement about the Waterfall being the simplest project model.",
      "id": "e0c4e57d25c3e66d7b2166d67d1dd49f"
    },
    {
      "type": "html",
      "text": "<i>Read above, I say [[Water Fall]] captures the project structure 'almost in bullet point form'. I don't want to suggest that there is nothing more to it, but it <b>is</b> simpler to explain, conceptualize, learn and (conditions permitting) realize than most other project models. If only because there is less to it.</i>",
      "id": "f0e61a71b2ae1f3bf4f1a885a5c63b14"
    },
    {
      "type": "html",
      "text": "<i>However, I only say that [[Water Fall]] is the first place you should visit. You might not want to stay there. -- [[Chris Steinbach]]</i>",
      "id": "4aa628cfd0e7ad982e05fe6320039ce0"
    },
    {
      "type": "html",
      "text": "\nI will agree that most projects usually are structured along the lines of the waterfall method, but I don't think it necessarily follows that the waterfall method is the most natural or appropriate method to use for most projects. I contend the parallel approach is the more natural and simpler approach and is the one most developers will follow without an outside force causing them to use the waterfall. The simple control loop is the model most often used for other human activities, why not software development?",
      "id": "673f3ae5c1d97738cb9fc4f1803d44e0"
    },
    {
      "type": "html",
      "text": "<i>I think that I have concentrated on structure too much here. The technological problems I started out with ought to be solved, in part at least, by standardization and improvements to technology. My appeal to simplicity is also bogus. Both XP and [[Water Fall]] have simple structures at some level. These structures are not useful until they combine with human activities.</i> -- [[Chris Steinbach]]",
      "id": "2719b6869cfd64a090ed81c792d6c18d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "<i>A strength of any method must be to what extent it functions as a guide. XP provides a lot of guidance...</i>",
      "id": "bbecdbf1187dfc3d60ce75e00a33efdf"
    },
    {
      "type": "html",
      "text": "\nIt's important, in discussions like this, to beware of comparing apples and oranges, such as [[Water Fall]] and XP. [[Water Fall]] is a lifecycle <i>model</i>, something quite abstract and insufficient on its own to guide a development effort. XP, as a collection of heuristics, fills a different role in the software process landscape. The manufactured dichotomy of \"XP versus [[Water Fall]]\" is, frankly, childish, and bears all ths shtick inherent in adolescent upheaval and identity search. Nor does this attitude forward the helpful cause of XP, big picture. -- [[Walden Mathews]]",
      "id": "1ed6918256660d2a698b7159a497ae9b"
    },
    {
      "type": "html",
      "text": "<i>Comparing and contrasting different models is the only way to reach greater understanding. We must be always be careful not allow this process to degrade to one versus the other, because at that point, all learning shuts down.</i>",
      "id": "64006c9ef35400881649988657a7c620"
    },
    {
      "type": "html",
      "text": "\nI think in this case I really did make the wrong comparison. However, we don't have to accept my overly abstract characterization of [[Water Fall]]. Once you start to reintroduce all the details from feasibility study to review, you have something much stronger than a skeletal lifecycle model. You have something that can be (and has been) used as a guide.",
      "id": "217da340bf015236256010880dfe1843"
    },
    {
      "type": "html",
      "text": "\nWithout wanting to pursue the [[Water Fall Vs Xp]] motif here, I do have one last comment. If XP and [[Water Fall]] really are like apples and oranges, then this must be a result of, not a barrier to comparison. But don't they have some overlap? They are, after all, both aimed squarely at supporting software development. If they are at odds with one another, then this only makes the comparison difficult. Not necessarily less rewarding. -- [[Chris Steinbach]]",
      "id": "a193a2c697a8bb77cfa39f9fa66d08f7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "To appreciate the difference in roles between [[Water Fall]] and XP, try mapping the activities of XP onto the [[Water Fall]] model. We can do that here. I'll start.",
      "id": "08237e5f6e26ad9f3d56e44a82921a0a"
    },
    {
      "type": "code",
      "text": " User stories -> Requirements\n \"Tests\" written before \"code\" -> Specifications\n Refactoring -> Design\n etc.",
      "id": "3f30889c5b25e640bdd0c59536d323db"
    },
    {
      "type": "html",
      "text": "\nIn other words, XP can be understood in terms of [[Water Fall]]. Can that be stated the other way around? -- [[Walden Mathews]]",
      "id": "9c66510fc3f5f022c905da669f5e7427"
    },
    {
      "type": "html",
      "text": "<i>How do you explain the onsite customer? The point about XP is that it uses ongoing requirements definitions. And tests are not fully written before the code, but developed in conjunction with the code.</i>",
      "id": "db220539ad7ed2c2306cea34dba4ecbc"
    },
    {
      "type": "html",
      "text": "\nThe \"onsite customer\" rule is a requirements feature; the \"ongoing\" part is an elaboration of the model. \"In conjunction\" is not process language because it doesn't imply an ordering, yet ordering exists to the careful observer. Doesn't the rule say \"write tests first\"? Doesn't \"first\" mean \"before something\"? -- wm",
      "id": "1d51214708a91c6d69945995053ea5a3"
    },
    {
      "type": "html",
      "text": "<i>I believe the phrase is \"test first coding\" and it is really trying to emphasize not writing the tests after the code. The definition of test and the code being tested should be the same. They are two alternate implementations of the same concept that must be brought into agreement. In practice, you will find yourself constantly alternating between adding, modifying, and correcting the test code and the tested code. For many languages, the code to be tested is the first code actually modified, if for no other reason than to add the method to be tested. Imposing sequential operations inappropriately is one of the difficulties with the waterfall model.</i>",
      "id": "372b48861eb54955bb576347532550ef"
    },
    {
      "type": "html",
      "text": "\nI'm not sure what the phrase is, but I can relate the gist of an email I exchanged with [[Kent Beck]] a couple of years ago in which he said (almost verbatim), \"Have you tried writing your tests before you write your code? This to me was one of the most powerful insights...\".",
      "id": "9160ebc5852b23eb934772c59a5f5de2"
    },
    {
      "type": "html",
      "text": "\nSorry if I seem to be splitting hairs, but I don't believe you are observing what is really happening. \"Not writing the tests after the code\" is equivalent to writing them <i>before</i> the code, unless you type with both hands on two keyboards at the same time. <i>That</i> would be extreme!",
      "id": "ac1cb7b3e3550d72c0ca76bda2c9ce8c"
    },
    {
      "type": "html",
      "text": "\"Constantly alternating between adding, modifying ...\". Precisely. You alternate, which is different from doing them simultaneously. You seem to blur the distinction in the name of XP, and I don't think that's \"cricket\", but since I'm no XP XPert (heh), I wish someone who is would chime in at this point. -- wm",
      "id": "d13d3a2d5148a558dd54a26239f7bbd5"
    },
    {
      "type": "html",
      "text": "<i>The argument is the opposite, the argument being presented is that requirements, design, and test are not separable tasks. The blurring is based on trying to take micro-increments of time and map them into \"phases.\" A requirement is defined by the test that validates it. The test is validated by the use of the implementation. Characteristics revealed during the use of the implementation both validate and modify the understanding of the requirements, tests, and implementation. All three types of operation are completed at the same time (assuming that they ever can be completed). What may be less obvious is that all three types of operation begin at the same time. Furthermore, the three items are so tightly coupled, it is not possible to determine where one begins and another ends. The realities suggested by each view are some different, it is not surprising that semantic difficulties arise when mapping one to another. A highly iterative approach is quite different from a waterfall approach; one cannot be mapped onto the other.</i>",
      "id": "a172cb3b6c56e1c083693e869302ab50"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "One of the main purposes of good design is to produce good code. We are only human, and often cannot recognize bad design except in retrospect, by seeing the bad code that the design results in.\nThe fallacy of waterfall, perhaps, is that design can be done without reference to code. ",
      "id": "ececa0e7b6e3d2f0c9dac0f5afedbea2"
    },
    {
      "type": "html",
      "text": "''A different view of the fallacy of the waterfall is that it consists of repeated approximation. A requirements document is written that approximates what the user wants. A design document is written that approximates what is in the requirements document. Software is written that approximates the design document. No wonder the final software differs from what the user originally wanted. As for cost, we have written the same thing three times in three different forms. \nNo wonder the cost and the cost of change go up.''",
      "id": "8821cb04522e42897f0e178161b73138"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "image",
      "url": "http://www.artchive.com/artchive/e/escher/escher_waterfall.jpg",
      "text": "www.artchive.com",
      "id": "d8b062562104b7eba11829cb637c4e1a"
    },
    {
      "type": "html",
      "text": "",
      "id": "774de0237ac71e6913d902cca9e65969"
    },
    {
      "type": "html",
      "text": "\nDoes it not always somehow seem to come back to haunt you? Ahh, the above mentioned retrospect...",
      "id": "18fd763f54e8b5a8a32bb941acbf1322"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "At least one paper on the history of software development (I cannot recall the authors or title) has suggested that the position of the [[Waterfall Model]] as the 'traditional' design model is itself specious, a myth established by a misunderstanding of the Royce paper - but not the misunderstanding usually attributed. The argument was that the majority of papers, design documents and press releases which mention 'waterfall' did so in the same way Royce did - as a [[Straw Man]] - to <i>contrast</i> with the approach the paper claims to describe. That is to say, they asserted that [[Waterfall Model]] was not the traditional design approach, but rather the traditional [[Straw Man]] which all designers sought to refute, and that 'waterfall' was never actually a live practice.",
      "id": "2e9efb413b0ed8df2c2d1741bd8e69b4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "See [[Waterfall Model]], [[Job Security]], [[Water Fall Myths]], [[Design Approach Tina]], [[Falling Water]], [[Customer Information Analysis Design Coding]]",
      "id": "883c883670c6b8cf989893828c0180f5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74ddfb90ace4e2931480f3b206cfcee8"
    },
    {
      "type": "html",
      "text": "[[Category Application Development]]",
      "id": "a99e12274b395ac20bdfc433ca6e4fd0"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?WaterFall c2.com]",
      "id": "5f0f7670973c81cd3f7f2d519c2ac4d1"
    }
  ],
  "journal": [
    {
      "date": 1305678464000,
      "id": "91e961bc5dafd76b1199f1896f3dd38e",
      "type": "create",
      "item": {
        "title": "Water Fall",
        "story": [
          {
            "type": "html",
            "text": "The \"traditional\" model of software development lifecycle. Largely discredited*, but still widely used. Development is broken into sequential steps: Analysis, Design, Coding, and Testing. (aka. [[Drive By Analysis]] and [[Big Design Up Front]] followed by [[Big Coding In The Middle]] and [[Big Bang Testing]]). Called \"[[Water Fall]]\" because each artifact in the model \"flows\" logically into the next.",
            "id": "c101e2cdc093cfbeecfd83ec485de49d"
          },
          {
            "type": "html",
            "text": "\nThe \"traditional\" [[Water Fall]] model with its [[Big Design Up Front]] and months of [[Big Coding In The Middle]], the [[Era Of Silence]], inhibits (or prohibits) evolution of understanding leading to fourth and fifth steps, [[Big Last Minute Changes]] followed by [[An Unacceptable Way Of Failing]]. ",
            "id": "f74c310fb768633bce9a9bae9e0dde7e"
          },
          {
            "type": "html",
            "text": "\n[[Water Fall]] is based on the empirical observation of 30 years ago (ref: [[Barry Boehm]], Software Engineering Economics, Prentice Hall, 1981.) that the cost of change rises exponentially (base 10) by phases. The conclusion\nis that you should make the big decisions up front, because changing them is so expensive. 30 years of progress in languages, databases, and development practices has largely voided this assumption, but it is buried so deep that it seems certain to last for some time.",
            "id": "bd2c3f286492a0cd2bcd419f8c19c813"
          },
          {
            "type": "html",
            "text": "(*) Discredited as a literal, followable software process. (see [[Is Water Fall Discredited]])",
            "id": "d6397cfa3593ec66aad319eb136f401c"
          },
          {
            "type": "html",
            "text": "\nWould anyone care to refactor even some of the extensive discussion that follows into [[Document Mode]]? This page is extremely large.",
            "id": "f28f7553e4e561d49f5e30fd0b370b63"
          },
          {
            "type": "html",
            "text": "<i>And Larry Constantine remarked at OOPSLA2005, \"I created one of the first 'waterfall' approaches but I did not create analysis paralysis\".</i>",
            "id": "33a951f769b6dfa1995ffee7c1bfdff3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "\nNow with its own conference!  [http://www.waterfall2006.com/ www.waterfall2006.com]",
            "id": "473939c4ec82778d48a2a72a051364ec"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "Alistair, thanks again for saying [[Water Fall]] is [[An Acceptable Way Of Failing]]. It took us close to a whole load of things that so badly needed saying that I and others produced a few [[Emotional Burp]]s in immediate response. In fact I believe that it's fair enough to feel emotional about [[Water Fall]]. It's so often been destructive of the productive team work and real creative joy that should characterize delivering great software with and to customers.",
            "id": "62485012b2f7eef9db708dd2737c9b9b"
          },
          {
            "type": "html",
            "text": "\n[[Ignorance Fear Pride Or Fraud]] is the mild overview of the issues raised that I've been able to come up with having disconnected from Wiki for 48 hours and (slightly) calmed down! -- [[Richard Drake]]",
            "id": "a745b676b811a54571bcecd124dd284f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "<i>Per the WF write-up at [http://www.objectmentor.com www.objectmentor.com], WF got invented as the following theory: \"When you code,</i> data <i>typically flow from Analysis to Design to Coding to Testing.\" Unfortunately this was easily mis-interpreted to mean, \"</i> time <i>flows from Analysis to Design to Coding to Testing.\" Bad news.</i>",
            "id": "538651bdcf5fb50eba340dd040142d3c"
          },
          {
            "type": "html",
            "text": "<i>Under pressure, even the best of project managers fall back to WF practices.</i> That's <i>the bugbear we all fear here. -- PCP</i>",
            "id": "eb4f0c31cacb4bd588ed6d25d6d29f03"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "The assumption that is usually invalid in a waterfall process is that the requirements will not change during the lifecycle of the project. In reality, requirements change a lot in most (though not all) projects, especially once the customer gets their hands on it. The failure of traditional waterfall process to recognize this is a fundamental flaw. A mistake in the requirements phase can not be detected in a waterfall process until near the end, when the customer gets to see the (nearly finished) product. This leads to a huge cost in correcting the mistake (the old cost-of-change curve again). XP, and most [[Agile Processes]], attack this area explicitly, putting a high emphasis on getting something to the customer early on, so that feedback can be obtained.",
            "id": "bb7570bfdb7a591ae9ffb9159595c02f"
          },
          {
            "type": "html",
            "text": "-- [[Robert Watkins]]",
            "id": "826ffb628b26686a733640e08c004765"
          },
          {
            "type": "html",
            "text": "\nTo put things into perspective a bit, the process most likely to allow a requirements mistake to go undetected until the end is the oblivious one, i.e., the process where developers don't \"get\" requirements. With waterfall, at least requirements are on the map. There's no law against prototyping and verifying with users, either. Maybe waterfall is the toddling process, if you get my analogy. Toddlers don't walk so good, but at least they're walking. Let the balance come with practice. [[Walk Before You Run]]. -- [[Walden Mathews]]",
            "id": "3ec684eccb8358526fbbf42440c2be76"
          },
          {
            "type": "html",
            "text": "\nWalden: I would disagree that your <i>Toddler</i> analogy IS an example of a [[Water Fall]] method. I would see \"crawling\", \"steadied standing\", \"wobbly walking\", \"walking\", \"running\" & \"Olympic sprinting\" <i>(very optimistic)</i> as more an incremental approach.",
            "id": "0e5bdf3f5d76768a21ca0e25606855bb"
          },
          {
            "type": "html",
            "text": "<i>Yikes, I misunderstood your point on first, second and third readings, but I think I got it now. My point is that Waterfall IS the toddler of incremental approaches. See Jaime Gonzalez' better explanation below. -- wm</i>",
            "id": "882be0249ec47313d3fb1067e37b4758"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "The original waterfall model, as presented by Winston Royce in \"Managing Development of Large Scale Software Systems\" (Proceeding of IEEE WESCON, August 1970 [<i>[http://facweb.cs.depaul.edu/jhuang/is553/Royce.pdf facweb.cs.depaul.edu]</i>]) actually made a lot of sense, and does not resemble at all what is portrayed as a Waterfall in the preceding entries. What Royce said was that there are two essential steps to develop a program: analysis and coding; but precisely because you need to manage all the intellectual freedom associated with software development, you must introduce several other \"overhead\" steps, which for a large project are:",
            "id": "afa791530b084e9b86c06734c33dbea4"
          },
          {
            "type": "code",
            "text": "  System requirements\n  Software requirements\n   Analysis\n    Program design\n    Coding\n      Testing\n      Operations",
            "id": "f6620a258c7cce3b93badb1844dac771"
          },
          {
            "type": "html",
            "text": "\nMany of Royce's ideas would be considered obsolete today, but I don't think the problem lies so much with his model as with the cheap (not in terms of money, of course) and rigoristic ways of misunderstanding what became an engineering and project management \"standard\". This \"standard\" is what became [[An Acceptable Way Of Failing]]. ",
            "id": "4863cc4d30996fad3a1924d95e8e96d0"
          },
          {
            "type": "html",
            "text": "\nRoyce's valuable ideas must be understood before we simplistically discard the Waterfall. For example, when he advised to do some things twice he was postulating what we can call an embryonic form of iterative development. Also, some features of the Waterfall are inevitable: as [[Alistair Cockburn]] has said elsewhere ([http://members.aol.com/acockburn/papers/vwstage.htm members.aol.com])ï¿½how can you get to do testing if you have not coded?. <i>Easy. [[Code Unit Tests First]]</i>",
            "id": "7a9261e4f35f3d62a33a791a22f7b833"
          },
          {
            "type": "html",
            "text": "\nThe main problem has not been the Waterfall, but the schematicism involved in a \"standard box for all projects\". The variety of possible routes to follow is enormous: under many circumstances, training and empowering users to do their own computing will be a radical alternative not only to analysis and design, but to coding as well (after all, as Emiliano Zapata would have said, applications should belong to those who make a living out of them). Under other circumstances, the best way to enhance team collaboration is to design the database through a diagram that makes the objects visible to all participants.",
            "id": "0c8c1b14e8675cf795ca56ce5b443966"
          },
          {
            "type": "html",
            "text": "\nFor metrics and data on software project failure, see Capers Jones' books (<i>Patterns of Software Systems Failure and Success</i> is probably the best known).",
            "id": "2fd0f9fbf729a40c61b24d1b5281f150"
          },
          {
            "type": "html",
            "text": "-- Jaime Gonzalez",
            "id": "dd3807433bff579833af6ebd02f01d50"
          },
          {
            "type": "html",
            "text": "<i>Well put, Jaime. Better than my earlier, somewhat frustrated efforts. Thanks. -- [[Walden Mathews]]</i>",
            "id": "e20b156e62a48486ceba5cac9e0c63a6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "The problem with the [[Water Fall]] model, even as explained above, is that it tries to create phases that do not exist, and reflects a fear of writing software that may be wrong.",
            "id": "37f4433f1e3f209daf3759517273ee3d"
          },
          {
            "type": "html",
            "text": "\nThe truth of the matter is that it is no more difficult to write a requirement directly in source code than into a requirements document and it is far easier to validate the requirement as running software. The result of the [[Water Fall]] is that we first attempt to create the system in prose as a requirements document, then translate the requirements document into a design document in prose, then translate the design document into source code. It is no wonder the intent of the user gets lost by the time the software is actually created.",
            "id": "3ec3c85ee6b32764881c5e1e316c6e86"
          },
          {
            "type": "html",
            "text": "\nThe massiveness of the process is not due to a misunderstanding of the [[Water Fall]], but a direct result of it. Each phase can be no more correct than the preceding phase and is likely to be less correct. Translation, errors creep in as we convert requirements prose to design prose and design prose into software. Correctness in one phase requires near perfection in the preceding phase, thus each phase slows down to ensure that errors do not creep in. As the time for each phase grows, the cycle time from concept to actual delivery of software grows. As the cycle time grows, there is more and more pressure to include more and more functionality that the users can't wait for. This in turn inflates each phase even more and increases the cycle time.",
            "id": "be5354fa616a22525780bdc75169208e"
          },
          {
            "type": "html",
            "text": "\nIn effect, the [[Water Fall]] method creates a control loop whose output explodes. The phases may make nice diagrams in books, but they do not exist in reality. English prose is not inherently easier to write than software nor inherently easier to evaluate nor easier to change. The instincts of programmers have been right, go directly to the code.",
            "id": "e7e760ffb0d0947e069aaaeb154942c7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "[[Water Fall]] is a solution to a problem that no longer exists, as a process it was designed for a era where [[Machine Time]] was orders of magnitude more expensive than [[Human Resource]], it really was cheaper to rework a requirement 3 or 4 times in requirement capture, analysis, coding and testing that make a mistake once with the machine. Today [[Machine Time]] is vastly cheaper when compared to professionals time. -- [[Martin Spamer]].",
            "id": "d74210daca62d82c90dea6a69556603b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "<i>See [[Design By Contract]], [[Test Driven Development]].</i>",
            "id": "0f223f0dc2d2893c226b863ade1a977f"
          },
          {
            "type": "html",
            "text": "<i>But none of these are the >real< reason not to use [[Water Fall]].</i>",
            "id": "b000974076b93cec85b38b5702a2abec"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "If you work in a semiconductor fab, and if you make a tiny mistake with a batch of wafers, you have just burned the entire cost of all the processes your wafers previously went thru, plus the cost of sending an entire new batch of wafers thru the fab to this point.",
            "id": "8b7d4edcbaacb98bd0374d4fc14ba9fd"
          },
          {
            "type": "html",
            "text": "\nIf you use [[Water Fall]] the way it was designed to be used, if you make a mistake in an early process and discover it in a late process, you must go back to the early phase and <i>do all the affected phases again</i>. This is because the phase is important (else why are you doing it?), and during the phase you must manually cross-check the fix with everything else. Then you must run the subsequent phases using only the output of the previously re-done phase. Read more about it here at [http://www.waterfall-model.com www.waterfall-model.com]",
            "id": "5d64bff39684c437f01ed9c82ac484d0"
          },
          {
            "type": "html",
            "text": "\nEveryone who says they have [[Water Fall]] experience most likely allowed minor tweaks without re-baking everything. But if you take [[Water Fall]] seriously (because you are using hardware and each phase really is irrevocable, or if you are using software but a militant environment believes it <i>must</i> do [[Water Fall]]), then you must do it right and rebake each phase at mistake time.",
            "id": "38020bf3a1f82a5125022d91166f5d06"
          },
          {
            "type": "html",
            "text": "<i>As noted above, trying to create \"phases\" slows the development of software down. It is not going back to previous phases that creates the problem, but doing the same work multiple times in order to define phases.</i>",
            "id": "7616caffc56ab3e4db3a84a639c7a4a8"
          },
          {
            "type": "html",
            "text": "\nI think I see the problem here. It comes out through phrases like \"[[Water Fall]] the way it was designed to be used\" and \"take [[Water Fall]] seriously\". There's no way to know how [[Water Fall]] was designed to be used, or even to know who designed it or if it was designed at all. And taking something seriously doesn't mean aborting common sense. These words belie a problem with authority and enforced inappropriate applications, not with the model in question.",
            "id": "38f285339ecf8a6f14eee66cd69a350c"
          },
          {
            "type": "html",
            "text": "\nIt makes no sense to judge [[Water Fall]] (strictly or loosely interpreted) without establishing a risk context. There's no reason, [[Water Fall]] notwithstanding, not to write code on the first day of a project if you smell significant technological risk. Even though you're coding, you're still (big picture) focused on requirements, because you are determining the feasibility of the system the customer wants. Don't lose the forest for the trees. The phases of [[Water Fall]] are not absolute, and they are not characterized by specific activities (like coding) but rather by the <i>type of decision being made</i>. [[Water Fall]] prioritizes decisions of the kind where a change in decision can invalidate the entire project.",
            "id": "321421af3087bdf503c1126522166aae"
          },
          {
            "type": "html",
            "text": "\nThe risk of postponing coding and testing until very late (someone's bum idea of what [[Water Fall]] means) needs no explanation. The risk of not assessing a critical body of requirement before committing a lot of code probably does need explanation, to this audience. I have never seen a system in which requirements were not related to each other through interdependence. I have never seen a system in which simplistic and isolated requirement understanding didn't fail when requirements were integrated (built) into a system.",
            "id": "72fd1dcf04d7622af18fceb0bf0d3a08"
          },
          {
            "type": "html",
            "text": "\nWhile it's true that there's only so much planning you can do before planning loses its value (and that varies widely according to style and skill set), why wouldn't you want to know about requirements that <i>must change already, not because the customer is fickle, but because they don't make sense together</i>? Even if you have no strategy but \"let's build it anyway and see what we can do\", why wouldn't you want to know?",
            "id": "b336f36c04d90ca69b1cb10a58b26f37"
          },
          {
            "type": "html",
            "text": "\nSkills matter in the selection of tools and processes. Analysis relies on advanced abstraction ability which seems to develop with experience (no offense, young 'uns). Deep and early analysis by someone with the ability can save you eons of time and wasted effort, but it's a skilled act. Reluctance to use skills not yet attained is wise. If [[Water Fall]] doesn't fit because of missing skills on the team, then it's only common sense to pick another strategy. In this case, dismiss [[Water Fall]] for cause, but please be clear about the cause.",
            "id": "5068dd51aa3e6c44ad1379f9194ff81a"
          },
          {
            "type": "html",
            "text": "\nI believe that the better you get with a given problem and technology domain, the more your work will converge on the simple [[Water Fall]]. (In the life of every teen-ager, there comes that epiphanic moment when you realize you <i>are</i> your parents.) When you switch environments, it's another matter. When you can see a lot of the project coming, you can [[Water Fall]] it. It's really just a matter of knowing when planning will pay off and when it is a waste. When throwing out the [[Water Fall]], be sure to check for babies.",
            "id": "cfd6d492624dc63fbba417fae9bef8df"
          },
          {
            "type": "html",
            "text": "\nAlso, [[Water Fall]] is the simplest (batch) process for building software. How much should you elaborate that process in order to mitigate risk? When reducing risk A, watch out for increase in risk B. What about the risk of an elaborated process? I would rather see a team start with a simple [[Water Fall]] plan for building software and then deal with its weaknesses incrementally than begin with an over-elaborated process and try to figure out which risk reduction parts are not needed. I think you can see that an optimal balance for risk reduction is never a trivial thing. But neither do you have to get it perfect.",
            "id": "73977f52b0a5a97591db7f0ac58279f3"
          },
          {
            "type": "html",
            "text": "-- [[Walden Mathews]]",
            "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
          },
          {
            "type": "html",
            "text": "<i>Deep and early analysis by someone with the ability can save you eons of time and wasted effort...</i>",
            "id": "4c2c55aa0758c075926117f4cc4eb6f6"
          },
          {
            "type": "html",
            "text": "\nCare to justify this assertion?",
            "id": "2a4e3008400aafe44c4026470ca80950"
          },
          {
            "type": "html",
            "text": "<i>Certainly. Not too long ago I went to a meeting in which the participants were gearing up to build a complex system for tracking per-quote charges for customers who receive stock exchange data feeds. Domain analysis revealed that this pricing model was invalid, hence no need to build such a system. The analysis wasn't so deep, but if you took a \"code now\" approach, you wouldn't know until you submitted a bill. In another example, a workstation customer requested more advanced security features, providing a list of functions. Analysis of this list revealed an inconsistence such that some of their proposed features were entirely superfluous. They were removed from the project before a line of code was written.</i>",
            "id": "77610492fb2396efd48700de63819643"
          },
          {
            "type": "html",
            "text": "<i>As a general rule, there's tremendous leverage in the requirements of a project. Failure to fully explore the meaning behind a collection of requirements can be a huge mistake. Early coding shifts focus from semantic depth to implementability, which proved irrelevant in the two cases above.</i>",
            "id": "ed67403b984c4aababf0aacebd4bd3c0"
          },
          {
            "type": "html",
            "text": "\nIt appears the natural conclusion to statements such as \"There's no reason ... not to write code on the first day of a project if you smell significant technological risk.\" and \"When you can see a lot of the project coming, you can [[Water Fall]] it.\" is that [[Water Fall]] is only appropriate for low risk projects. If the [[Water Fall]] does not provide risk reduction, then why do it for even low risk projects?",
            "id": "75527154d973d9cefcbeeeb56bc822a2"
          },
          {
            "type": "html",
            "text": "<i>Good question. You caught me up in sloppy use of terminology. In the first place, [[Water Fall]] calls out prototyping and backtracking as standard practices, so even technological risk and the risk of misunderstood requirements is addressed by [[Water Fall]]. It's just that the current generation chooses to ignore the upward arrows on the diagram, preferring to immerse itself in the metaphor of liquid and gravity. But even if we address the popular notions of [[Water Fall]], being strictly phased and so forth, if you look at what the model is saying you find a heap of risk reduction in that. Code design is all about reducing the risk of poor maintainability, for example. Treating requirements as a system, as I've touched on above, reduces the risk of implementing nonsense. But the harsh reality is that any structure we choose reduces some risks while ignoring (perhaps increasing) others. I have used discrete phases on occasion just because I can and because the project permitted. Whether or not you should use discrete phases when there is no unacceptable risk in so doing is a good question. Could be that matters of style eclipse matters of hard practicality in this area.</i>",
            "id": "c08c3f1c3a9e41f39fbe5e30a7f11766"
          },
          {
            "type": "html",
            "text": "\nWhy is time and effort spent generating paper more productive than generating software that actually runs? Why would paper explanations of complex processes and interactions be more understandable than actual running software showing them?",
            "id": "78fecf382a12a7efc30c113bfe6fc07c"
          },
          {
            "type": "html",
            "text": "<i>The question is not \"Why\" but \"When\". The answer is when the \"paper\" fits the ideal commitment curve for the project you have in front of you. The \"paper\" we're talking about is models, and its purpose is to verify what we can when we can before moving on. This is risk reduction again. But for models to be effective, they have to be meaningful, small, cheap and disposable according to localized measures. Executable models are fine, provided they meet these criteria. A thread-safe running system does not automatically demonstrate thread safety through casual observation. A paper diagram may do a better job.</i>",
            "id": "57047154522a7371e1d01a9b48237e5d"
          },
          {
            "type": "html",
            "text": "\nWhy would a single individual doing thought experiments inside his own head be more effective than multiple people actually trying to use running software?",
            "id": "b6503ce42659909fc1ecd905ae0edec8"
          },
          {
            "type": "html",
            "text": "<i>Summoning the utmost of my intuition, I think you're actually objecting to the situation in which people are expected to invent without feedback. Well, yes and no. In the first place, do you appreciate your full power to validate or invalidate a proposal on what you already know? There's an important tradeoff here. If you have to perform a CPU experiment for every decision you will make in building a given program, you might as well give up now. The question is, when can you rely on memory and when can you not? The answer is: experience. This is an interesting sideline, not strongly connected to the [[Water Fall]] model as I see it.</i>",
            "id": "80cf1cdafb7a9847566afa235e2bf0a7"
          },
          {
            "type": "html",
            "text": "\nThe [[Water Fall]] is not the simplest process for building software, instead it is the iterative experimental approach; the approach all of us used to make our first, custom program.",
            "id": "9f57ab8e064b11b79ea0f6461296ea95"
          },
          {
            "type": "html",
            "text": "<i>[[Water Fall]] is the simplest model for building substantially sized software, but it is not the most intuitive one, nor is it the simplest one for building little programs. How do you decide what's simple and what's not?</i>",
            "id": "9cea0dfeab6820cbeba763dad94cc074"
          },
          {
            "type": "html",
            "text": "<i>-- [[Walden Mathews]]</i>",
            "id": "5409097a6c9c2f0986f1bd3e339692a5"
          },
          {
            "type": "html",
            "text": "\nI can find the references, if desired, but during the discussions of Ronald Reagan's [[Star Wars Missile Defense System]] proposal, it was stated the size of the project was so enormous as to be impossible. It was also noted, however, that programs of that size existed, but had come into being through an evolutionary approach rather than planned design. It seems that the iterative, experimental approach is the only feasible way to build extremely large programs.",
            "id": "2e9e55082e13a83949f478ed98f5196c"
          },
          {
            "type": "html",
            "text": "<i>No argument there. What size chunks are extremely large programs built in, and what does the lifecycle look like within a chunk? By countering false claims about [[Water Fall]], I'm neither dismissing all other approaches nor claiming that [[Water Fall]] has no faults. All lifecycle models are essentially the same, the exception being that [[Water Fall]] is the most fully abstracted and generally applicable one. [[Water Fall]] is the meta-model of software process. It's the XML from which your particular schema is written. 'Iterative' is a minor invention upon a major theme. -- [[Walden Mathews]]</i>",
            "id": "ecabfe141fdec1fd3b9141c0f090982f"
          },
          {
            "type": "html",
            "text": "\nHow is the iterative process based on the waterfall? Perhaps you should define your use of waterfall to support your claim that everything is waterfall. You appear to have stripped all meaning from the term.",
            "id": "7f0209516476803b00663d86343f1810"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "<i>How is iterative process based on the waterfall?</i>",
            "id": "ec7a433902c968193435e44cfd032ae9"
          },
          {
            "type": "html",
            "text": "\nThe iterative lifecycle (not process, if we want to be exacting) takes a bite-size of requirements and follows the steps of [[Water Fall]] over them, then takes the next bite-size of requirements and follows the same steps plus the additional integration that wasn't planned, and so on. Or, as is said many times in our midst, \"little waterfalls\". So the question is, How little does a waterfall have to be before it's not a waterfall?",
            "id": "b21b3915e5ed941e312dba655e8548ee"
          },
          {
            "type": "html",
            "text": "<i>When I am saying iterative approach, I am talking about a fully parallel approach of defining requirements in conjunction with coding in conjunction with testing. I am not talking about \"mini-waterfalls.\" The waterfall approach addresses threads of functionality broken across phases of requirements, design, implementation, and test (or pick your specific sequence). Instead, we can rotate that model 90 degrees and have threads of requirements, design, implementation, and test broken across phases of added functionality.</i>",
            "id": "901aea48118337b4eddbbb442c40bec4"
          },
          {
            "type": "html",
            "text": "\"Fully parallel\" is illusion, like time sharing. You have to ignore some known detail to believe that. You can switch back and forth rapidly from decision about \"what makes sense to build\" and \"what is feasible to build\" and \"how would we build that\", but you can't really do them all at the same time, not as a conscious process. More importantly, when most of this activity is really geared toward answering the first question, you're essentially defining requirement, even if you're coding much of the time. I've made this point three times now. Even if as a byproduct of all your prototyping (requirements phase) you magically ended up with totally usable and mature code, you're still in step with the model. The real problem is that [[Water Fall]] model describes what you do in spite of your attitude toward it. It does not describe the granularity of problem you will attack in one chunk. If granularity is the main issue, we should clearly state that and distinguish between model and granularity of application.",
            "id": "d485f5e65e858a7061e83c8ee8f640e8"
          },
          {
            "type": "html",
            "text": "-- [[Walden Mathews]]",
            "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "Exactly. Every attempt to successfully alter our environment, whether coding software or hitting a golf ball, can be described in terms of the [[Water Fall]] model. NEEDS - PLANS - ACTIONS - ANALYSIS - FEEDBACK. This basic loop is conceptually present in every attempt humans make to reach any goal whatsoever. Rarely does anybody seriously attempt to complete a major development in a strictly linear, one pass through approach, but these things are almost always iterative in reality, as with the [[Spiral Model]]. There may be large debate over how big a chunk you should bite off at a time, but even XP methods move through the basic concepts inherent in the waterfall description, maybe just in much smaller pieces at a time. I want to hit the ball; I'll look over there and swing like this; I swing; I see where it goes; I adjust my swing based on the results. I talk to the customer about what they want; I think of a function to test this requirement; I write the code and test it; I see if it passes or fails; I adjust as necessary. needs; plans; actions; analysis; feedback. There is no escaping this loop regardless of the development model one uses, it will simply be applied using different methods, on different scales. XP may advocate doing this on a smaller scale, with smaller gaps between the steps, but as was said that is a distinction between granularity of application, not of model.",
            "id": "29bc1d0c3b5b67de2ac3270164129bc2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "<b>\"Fully parallel\" is illusion....</b>",
            "id": "d71664e146db001b3251b16b8c7a79bf"
          },
          {
            "type": "html",
            "text": "<i>Sure, if you only have one processor. Waterfall methodologies that I've endured in real projects, up to and including RUP, treat the entire project team as a single processor: the project as a whole is in one phase at a time. This is understandable, if not excusable, given that the main purpose of these phases is to produce the [[Impression Of Control]].</i>",
            "id": "ee6f399abb615f3a09953ee76d38566d"
          },
          {
            "type": "html",
            "text": "<i>XP et al allow individual processors to be in different \"phases\" at a given time. In fact, I can't remember the page, but I saw a mention of [[Unit Test]]s running in an automated loop \"in the background\" while code was being developed. Are we having \"parallel\" yet? -- [[Tom Rossen]]</i>",
            "id": "2304d84d3193aca8c3329424cb8ad03a"
          },
          {
            "type": "html",
            "text": "<i>How is parallelism an illusion? The iterative approach is no more than a restatement of a basic control loop. A control loop constantly generates output, compares it against the desired output, and adjusts. All three tasks occur simultaneously. What I have stated is that the Waterfall model is a different model from the iterative model. The waterfall model views software development as containing separate serialized phases while the iterative model views software development as ongoing parallel operations. Within the context of one model, the other is impossible, hence these must be two independent models. The only remaining question is to determine when each model best reflects reality (and never confuse models with reality).</i>",
            "id": "ed29b5e78ca210d5fe175067aba5e0e8"
          },
          {
            "type": "html",
            "text": "\nN.B. We're getting to something significant here, finally. Much of the rest of this page can be trimmed down, including all my amateur rhetoric. This is technical. Let's dive in with care and precision. I'll take the points one at a time.",
            "id": "c4ca1d89877a2734b517459c253212ba"
          },
          {
            "type": "html",
            "text": "<i>How is parallelism an illusion? ... A control loop constantly generates output, compares it against the desired output, and adjusts. All three tasks occur simultaneously.</i>",
            "id": "82e14210cc9987ae05c8e991416d03ab"
          },
          {
            "type": "html",
            "text": "\nThey may occur with minimum delay between them, but they can't be both simultaneous and meaningful controls at the same time. Here's why. If the evaluation is really simultaneous with output production, then evaluation has defective inputs, just like what happens when you judge my sentence when you're only half way through. This is because output production, evaluation and adjustment are all <i>processes</i> as opposed to <i>events</i>. Similarly, if you are taking corrective action simultaneous with evaluating, then you're taking the wrong corrective action because again your input was incomplete (ergo wrong).",
            "id": "9ef89721ba09c224a6dd48e550216b69"
          },
          {
            "type": "html",
            "text": "<i>The waterfall model views software development as containing separate serialized phases while the iterative model views software development as ongoing parallel operations.</i>",
            "id": "b17b0d29aa22d1e5b978b7e17ccac62b"
          },
          {
            "type": "html",
            "text": "\nI've never heard it stated that way. I've always thought of <i>iterative</i> meaning just that; you take a small subset of the whole problem and explore it deeply (through implementation), then iterate for the remaining subsets. Maybe we want to check some sources on this. I can try to do that, but maybe the task belongs to you.",
            "id": "2ee79fc49d72341eac679b3d5e501961"
          },
          {
            "type": "html",
            "text": "<i>Within the context of one model, the other is impossible, hence these must be two independent models.</i>",
            "id": "f7a7eb7317b4d3588cb23ea2a0333334"
          },
          {
            "type": "html",
            "text": "\nI'll agree that a model of absolutely simultaneous activity differs from the Waterfall model in which temporally and semantically separate stages occur. I should point out that in Waterfall, the semantic phasing is absolute while you can mess around with the temporal thing by changing the granularity of the problem. In other words, you could write some code first (without thinking at all), then go discover some requirements, then compare life with and without the running program to see if it satisfies the requirements. You <i>could</i>, and I'm aware that to a degree, we all do this from time to time, but is it a real strategy for software development? More importantly, can you map your control loop on it? When you do, does the mapping try to \"tell\" you anything?",
            "id": "67fecf79433ad90786c4ceac8bb17015"
          },
          {
            "type": "html",
            "text": " Actually, this is a very common approach in software development. The programmer will take a \"Hello World\" program or another program he has previously written and use that as a starting point. Initially, the program meets none of his needs, but he begins to adapt it to improve its fit with its intended purpose.",
            "id": "14022a2f640b484f29983da7cd0b8bca"
          },
          {
            "type": "html",
            "text": "<i>The only remaining question is to determine when each model best reflects reality (and never confuse models with reality).</i>",
            "id": "906312b813dd95f89696104269947a38"
          },
          {
            "type": "html",
            "text": "\nGlad your life is so simple! A resounding \"+1\" on the \"never confuse\" part. It's because those pointy haired managers confused waterfall <i>model</i> for waterfall ''process' that we have this mess in the first place. I'm casting some serious stones at your version of parallel \"reality\" above, so I'll wait to hear where we stand on that. I think, though, that the real \"reality\" question has mostly to do with the granularity you can tolerate/leverage while solving a given unique problem. Top-down approaches make sense when you have all or nearly all the knowledge you need to do a job, and you just need to organize that. Low frequency Waterfall (big chunks) is a kind of top-down strategy. When you try to use that in a setting where you don't have the knowledge, then you're forced to either guess (and commit to guesswork) or shift gears. And of course, it's the guesswork that isn't \"real\".",
            "id": "3329600c0271ef937a283608d3e04a51"
          },
          {
            "type": "html",
            "text": "\nI don't advocate that anyone try to follow a waterfall <i>process</i>, except as an etude. It's a useful etude because you find out exactly how much you do and do not know, and how much concrete feedback it actually takes to build the thing. In reality, we have uncommon sense to tell us both when we are biting off too much (your criticism of [[Water Fall]]) <i>and</i> when we are biting off too little (what do you call that, by the way?).",
            "id": "d20488bcf25cb76e7e9a4d42d5d734fc"
          },
          {
            "type": "html",
            "text": "\nContrary to late popular belief, Waterfall is not an anti-feedback model. If anything, it's a fast-track feedback model, but as this name implies, it requires a skilled driver. I can write down on paper something like \"user will keep getting the login screen (with error advice, if available) until login succeeds\" much faster than you can implement that idea in code, and I can get feedback from the affected parties that much sooner (almost \"simultaneously\", if you must know). There are some concepts that can't be well verified without experiencing them (proof of the pudding and all that), but there are so many that can be dealt with this way, it's a shame not to. And of course the more you can reason <i>correctly</i> through abstraction, the better you get, and so on. From a bird's eye view, the goal of the Waterfall model is to provide early feedback, the mechanism being abstraction. Look:",
            "id": "65d5ffd90bf7619b0655810ed485cc27"
          },
          {
            "type": "html",
            "text": "START:<br>Specify -> Review -> Identify Errors -> START",
            "id": "e68c8f8b337284d581be633fb510e592"
          },
          {
            "type": "html",
            "text": "START:<br>Specify -> Design -> Code -> Run -> Identify Errors -> START",
            "id": "5c75702e6625c0c179e7712da2224cbf"
          },
          {
            "type": "html",
            "text": "The top loop is significantly tighter, but it doesn't help when there are surprises down the line. The bottom loop ferrets out the surprises, but it postpones feedback to achieve that. Which is the holy grail and which is the devil's forked tongue? Both and neither; why do we have to decide now for all cases? In the wrong context, they both suck. If you're hung up on needing broad consensus on which approach is right, then you're making the mistake that makes [[Water Fall]] suck. Stop doing that.",
            "id": "8c45236b510c5eed8210ba53af32c42d"
          },
          {
            "type": "html",
            "text": "-- [[Walden Mathews]]",
            "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
          },
          {
            "type": "html",
            "text": "<i>Just to reset the stage, I am merely suggesting that there are at least two different models of reality. A model is a simplified subset of reality and different models have different subsets. Different models give different views of reality, by definition; so to compare models to determine which is \"right\" is pointless. Use the different models to give yourself different views and come to a better understanding of reality.</i>",
            "id": "f59a8c6503b63cb2120ad85dbbd27938"
          },
          {
            "type": "html",
            "text": "<i>The only way to evaluate a model is through its implementation. Unfortunately, the act of implementing the model changes it; aspects are added, removed, and changed. As you have noted above, the implementation of the waterfall may very well differ from the pure model of the waterfall, but the implementations are all we have to use to evaluate the model.</i>",
            "id": "5da202afaa260058d09692ae71952d61"
          },
          {
            "type": "html",
            "text": "<i>The iterative approach to software design reflects successive approximation, with each step being a change in functionality. We hope the step is an improvement, but it is not guaranteed; this is the equivalent of undershoots and overshoots in a control loop. In this model, there is no \"understanding\" of requirements, only improved understanding of requirements. Also, this model permits the implementation of the software to influence our understanding of the requirements.</i>",
            "id": "f7fea0ebb335e3515c000f30242b4fbe"
          },
          {
            "type": "html",
            "text": "<i>Just as the \"parallelism\" in the iterative approach may be an illusion, so is the \"serialization\" in the waterfall approach. A requirement cannot be fully understood except in the context of its implementation. Using the log on example posted elsewhere on this page, what was validated through the paper model? What were the significant features of the paper model that needed to be included in the actual software? What were the insignificant features that could be changed or removed? What were the missing features? How long does the log on window take to display? How many characters fit within the user name and password areas? Is the password displayed in clear text? Are there different modes of operation which should also be selected at log on? Is the user name remembered between log ons? The password? If the user name or password needs to be changed, what does typing a character do: append the character at the end, replace the existing text with the typed character, something else? Understanding the requirement of a log on is difficult and goes through iteration as the implementation improves understanding of what is required. Note how switching models affects the view of reality. It does not say the other model was wrong, but it certainly gives a completely different view.</i>",
            "id": "1242146b65aeae94a6b274335ce0bc1b"
          },
          {
            "type": "html",
            "text": "\nThe answer is that to the extent that any of those details are critical to acceptance, they might be written into a simple description that the user can understand and approve. It makes no sense to argue that because there are infinite details to a logon, there is no point in trying to describe the features that matter. In the example above, one critical feature of the application is that you can't use it (at all) until you log on. This is taken from a project I'm now doing. Some of the program's functions are \"safe\" for anonymous users, while some aren't. The sponsors want to sidestep the intricacies and require logon for all users all the time. The requirement says that. It short-circuits tons of wasteful coding that might provide examples of how the system looks with a \"late binding\" logon as opposed to the one decided on.",
            "id": "7c63f2a2ba4ad034de6a74d1c5aafcfa"
          },
          {
            "type": "html",
            "text": "\nNot all models are created equal. It's easy to create a model that doesn't make sense in the real world. Your model of \"parallel phases\" is such a model. While in some respects a rigid [[Water Fall]] \"doesn't make sense\", we're at a different level of semantics in saying that. Parallel phases don't make sense in the same way that Escher drawings don't. Lengthy phases may be suboptimal in most familiar development contexts, but they make logical sense at least.",
            "id": "1cba6d19cad7a3eb863b90546ba18428"
          },
          {
            "type": "html",
            "text": "\nThe logical sense of [[Water Fall]] makes a huge contribution to the management of projects, even if it lends itself readily to misapplication. That contribution is something unique to human intellect. The ability to describe what does not exist but is desired, to use that description as a standard by which to build, and then to use it again to verify that what was built was what we wanted - that ability provides a complexity-taming [[Separation Of Concerns]] that is essentially the same as the separation between interface and implementation in object oriented and other strongly modular approaches to programming.",
            "id": "3989db55733d8755f5a7ecfa651c61b5"
          },
          {
            "type": "html",
            "text": "-- [[Walden Mathews]]",
            "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
          },
          {
            "type": "html",
            "text": "<i>The answer is that to the extent that any of those details are critical to acceptance, they might be written into a simple description that the user can understand and approve.</i>",
            "id": "8e249f54989d59aebe209e2cb3e503bc"
          },
          {
            "type": "html",
            "text": "\nDoes your definition of waterfall require the simple description to be written in prose or does it allow the details to be written as a running program?",
            "id": "ec9ac15c377dd9c5d0abb5c6a87f7912"
          },
          {
            "type": "html",
            "text": "\nThe description has to be in the <i>optative mood</i>, in other words, it has to identify an existing condition and a wished-for condition, and the wished-for-ness has to be explicit in the language of the description. If you can do that in a programming language, it's fine (but can you?). Here's a caveat: pointing to the execution of a program and saying \"There's your requirement\" is bogus, because it lacks a minimum second point of view. Something cannot be its own standard without eroding the meaning of \"standard\". Validity is always a matter of comparison. I think that gets to the heart of your question.",
            "id": "cd90a59b08efb7aabb900e280af38fe4"
          },
          {
            "type": "html",
            "text": "-- [[Walden Mathews]]",
            "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
          },
          {
            "type": "html",
            "text": "<i>Okay, when is a requirement considered defined? Can a requirement be considered defined before it is validated?</i>",
            "id": "47b01214d422716a00eff5c5584d3695"
          },
          {
            "type": "html",
            "text": "\"Defined\" may be too strong a word. It's possible to do very good work with requirements that are clear and complete enough, but by no means rigorous definitions in the formal sense. Strictly speaking, it makes no sense to validate something that is lacking the expected level of definition (being careful to avoid absolutes in that), just as you wouldn't attempt to validate a not well-formed bunch of XML. Similar to how [[Water Fall]] is \"defined\" (well-formed) but not \"validated\" (in simplest form) for use on your project.",
            "id": "38233522cfe5d42819301a5ccfdce300"
          },
          {
            "type": "html",
            "text": "-- [[Walden Mathews]]",
            "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
          },
          {
            "type": "html",
            "text": "<i>Okay, when is a requirement considered \"clear and complete enough\" to move from the requirement phase to the next phase? How is this determined?</i>",
            "id": "6acd5532b80c3da5aff6bce18efe1a0f"
          },
          {
            "type": "html",
            "text": "\nWhen the people who care about it think it is. You seem to be fishing. Catching anything?",
            "id": "89e520fa29ee5f65d7897b8deb97169a"
          },
          {
            "type": "html",
            "text": "<i>Nothing yet. Still trying to get a definition of what the Waterfall Model is. So far every time I propose something I just get told, \"No, it's not that.\" If the purported serial phases exist, surely they must have starting points and ending points? What are they?</i>",
            "id": "123028289d1640a03b0316c801fd5be2"
          },
          {
            "type": "html",
            "text": "\nHave you read the Royce paper? It's probably as \"definitive\" as you're going to get. We could focus our questions and answers on that material if you like. Careful, though, because [[Water Fall]] is a <i>lifecycle</i> model, not a process model, the latter being a more detailed thing defining entry and exit criteria for process steps and all that. Also, you will find reasonable analogs to your questions in XP, if you look for them. For instance, relating to the \"write unit tests first\" dictum: <i>When is a test considered complete enough to begin coding? How is that determined?</i>.",
            "id": "916a4b3ecd18001eecb41824878e0d71"
          },
          {
            "type": "html",
            "text": "\nA [[Unit Test]] is considered complete enough to start coding when it fails.",
            "id": "1523ce67a2c4e3aab3b607d885117ae5"
          },
          {
            "type": "html",
            "text": "<i>No I haven't read the Royce paper. Perhaps you could provide a summary?</i>",
            "id": "cd48ba06aa46a3758d0243f0ad96345d"
          },
          {
            "type": "html",
            "text": "<i>I have read the Royce paper. It describes the 'classic' [[Water Fall]] and says of it that it \"is risky and invites failure\". It recommends doing design before analysis. It recommends 240 pages of spec per million dollars of system. It recommends that you [[Plan To Throw One Away]]. It recommends testing everything (but doing so at the end). It recommends involving the customer. The conclusion I take away from reading the acknowledged defining work on the topic is that the industry has been, for 30 years, using what Royce used as a [[Straw Man]] to recommend fairly reasonable things for his time, and calling it [[Water Fall]]. -- [[Laurent Bossavit]]</i>",
            "id": "25e956a7fd722f25e398bfd30acd2b9c"
          },
          {
            "type": "html",
            "text": "\nLet me propose a strawman for discussion. An aspect of a requirement can only be understood or communicated through an example. The example describes the aspect of the requirement, its implementation, and a means of verification, thus each of these become known simultaneously. These are inseparable, parallel actions. As more and more examples are known, more aspects of the requirement are known. The requirement is never fully known, but our understanding of it should continue to increase.",
            "id": "bc1b76fee32b5d7937f956caf49f4350"
          },
          {
            "type": "html",
            "text": "\nThere are two ways I can record my understanding of a requirement. I can record it in a written document or I can record it in executable software. The waterfall approach has me record the information in a written document (or more usually a series of written documents) and then generate the software from the written document. What I am calling the parallel or iterative approach has the understanding of the requirement recorded directly as software.",
            "id": "682da8c5882eace74fe78a8a5c62fb9f"
          },
          {
            "type": "html",
            "text": "<i>Real world problems constitute an example- and problem-space that's not small according to your local measurements (otherwise, you don't regard them as problems). When a space is sufficiently large, there typically presents more than one way to traverse that space. For example, there are depth-first searches and breadth-first searches. Your example sounds like depth-first, while strawman [[Water Fall]] sounds like breadth first. Breadth-first resembles batch processing, in which the process is uniform across an entire tier. Depth-first resembles piece work, in which you never have large quantities of intermediate results lying around. Each addresses certain risks and ignores others. In reality, you can search that space freely, now delving deep, now reaching broadly. Your sense of effectiveness - a combination of risk awareness, ROI-sensitivity, self-consciousness, etc. - is the guiding force. Models merely describe some of your options regarding that search. A good model is simple, and like a good tool it works well when it works well, and it works dismally when you try to force it to fit. It also works well when </i>you<i> use </i>it<i>, rather than the other way around.</i>",
            "id": "86cec993c052b70ef67560c2e71741e4"
          },
          {
            "type": "html",
            "text": "<i>That said, you understand what you do about this largely because you can fit it into a framework known as [[Water Fall]].</i>",
            "id": "c35a5c9ad3f44c7b306110056a2da529"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "<i>Perhaps you should define your use of waterfall to support your claim that everything is waterfall.</i>",
            "id": "ff87e0f304db18e97d10742cec236c8a"
          },
          {
            "type": "html",
            "text": "\nI've tried in the past to \"define\" waterfall for the purpose of enhanced discussion, but failed to trace waterfall to its historic roots. Please help me do that, if you have a lead. The best reference I have is the Royce paper (see top of [[Waterfall Model]]), but that's incomplete. In the first place, Royce never says \"waterfall\" in the paper, and in the second place, a waterfall-like lifecycle is already assumed at the time of the Royce writing, but apparently without any emphasis on prototyping or code design.",
            "id": "b86773b3c688fa305b25871a81127224"
          },
          {
            "type": "html",
            "text": "<i>You appear to have stripped all meaning from the term.</i>",
            "id": "070e3cde744d890e1a834e61df5e73f3"
          },
          {
            "type": "html",
            "text": "\nProbably only the meaning that you love to hate. If so, I'm succeeding in my crusade.",
            "id": "36b350881131f42fd8d6ef34f9bf95d0"
          },
          {
            "type": "html",
            "text": "\nI gather that the real beef against [[Water Fall]] (or whatever) is the dogmatic persistence in staying \"in phase\" when common sense dictates otherwise, and I gather that there is a maidenhead of resentment built up against managers who obliviously steered projects this way, defeating all the talent inherent in its people. I share the resentment over that practice. However, I would rather that people understand the depth of the waterfall model and the criticality of appropriate application than to think that we've shifted paradigms so that the model is no longer relevant. That smells too much of reinventing the wheel.",
            "id": "be725eb97461017787a95bb17ccadac0"
          },
          {
            "type": "html",
            "text": "\nI also acknowledge that total departures are sometimes called for when a pattern has gone wrong yet remains too strong an attractor to allow improvement within the system. Could it be that we've had our bloody revolution against you-know-what, that we're \"better\" now, and we're secure enough to allow the entry of a historical perspective on software development?",
            "id": "3b92d8521eaf2b965119b040e66558ba"
          },
          {
            "type": "html",
            "text": "-- [[Walden Mathews]]",
            "id": "e3cedd1efb9d9cddb43405c75db2f8c0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "Cheers to Walden for picking up the task of defending the bad mouthed [[Water Fall]] model. I happen to agree entirely with his viewpoints. It makes a lot of sense to review if bad results of [[Water Fall]] approach (by the way, haven't there been any good results at all ?), were consequences of logical flaws in the model, or consequences of bad practice. It's also worth exploring if differences between [[Water Fall]] and other development models are logical/structural differences or just differences of accent, nuances, etc. In particular approaches that start <b>a priori</b> with all kinds of prejudiced ideas like \"requirements are bad\", \"documentation is bad\", [[Big Design Up Front]] is bad and so on, no matter what the context may be, are definitely fishy. --[[Costin Cozianu]]",
            "id": "583d8fafc7fc2a6c096a5b89c9dec382"
          },
          {
            "type": "html",
            "text": "<i>Neither kinder nor truer words have ever been spoken, Costin. Thank you. -- wm</i>",
            "id": "6a71725e97072c8a448afd735fb2bd21"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "This is really wonderful stuff Walden. Coming from a [[Large Scale]] background, much of what you say rings true. About two years ago I was involved in a project where we put together a network management application suite together with a couple of remote design centers. The mess that resulted with conflicting and uncooperative technologies could have been mitigated if we had considered the interdependence of requirements earlier on.",
            "id": "e02ce9c4dddf757bbb888f43012682cd"
          },
          {
            "type": "html",
            "text": "\nConsideration of this interdependence should also help a project get the most out of [[Large Scale Reuse]]. The ideal scenario for my design team would be one where all the standards, protocols, technologies and tools were presented to us (packaged in our favorite language) at the start of a project as if they were the output of a single XP project held for our benefit. And then if all the other design teams and sub-projects also used this set of tools <i>by default</i>, life would be a lot simpler for us. This, of course, is never the case. In the rush to go agile I <i>had</i> forgotten that there are certain decisions that can't or shouldn't be made ad hoc.",
            "id": "da920621c5204b7c91c5ff4c63a15ad3"
          },
          {
            "type": "html",
            "text": "\nThis suggests that small iterations have certain pre-conditions, one of them being a stable technology base. Are there any other parameters controlling iteration size? You already mentioned skill sets. One thing I have noticed is that the developers often <i>are</i> the experts (sometimes they are even the customers in a sense). When this happens, up-front analysis and design starts to sound reasonable again. -- [[Chris Steinbach]]",
            "id": "17fbd8a0dde385fec137c6b08e86f057"
          },
          {
            "type": "html",
            "text": "<i>Chris, the kind words are much appreciated. I come from an environment where \"agile\" is like water to the fish, so pervasive it goes mostly unnoticed. In that environment, I observed many of the kinds of failings you describe above, so my inclination has been to push in a particular direction in search of \"center\". But others have had contrary experience so that \"center\" is someplace else and I appear to be the enemy, or at least someone barking up the wrong sluice.</i>",
            "id": "459c8b43637049ed044a19f620c55c24"
          },
          {
            "type": "html",
            "text": "<i>You're saying that only when the technology base is stable can you afford small iterations? I'm not sure we've got quite the right separation there. I see it more like that a stable technology base (some consistency to deployed technology) has to be maintained as a project goal, but I wouldn't say that long iterations serve better when technology is up in the air. Was that your meaning? -- [[Walden Mathews]]</i>",
            "id": "fbcbb9456623bf09776c508f0e8255b0"
          },
          {
            "type": "html",
            "text": "\nYes this was my meaning. Ensuring the necessary technological stability for the first productive iteration is going to take some time and is therefore a limiting factor. This, however, says nothing about the size and form of the following iterations. In the datacom/telecom industry we are ruled by technology. Every new project comes as a shock to the system. The projects tend to be structured as a [[Water Fall]] with an iterative model in the middle. -- [[Chris Steinbach]]",
            "id": "2edfbe37f6b71666eb96eeb802950f85"
          },
          {
            "type": "html",
            "text": "<i>What technology needs to be stable and why is it necessary?</i>",
            "id": "e9350ee1f2901763423520032967eea4"
          },
          {
            "type": "html",
            "text": "\nI mean the technology used in development, deployment and operation. What's the worst thing that could happen if you ignore this. You might have to rewrite the whole code base if, for example, the chosen language is found to be unsuitable. You might waste time and write a lot of code that is later provided by a 3rd party component. Above all, you can't estimate properly without this stability.",
            "id": "7c78481544b2a8d624bcb15d2d4f49b8"
          },
          {
            "type": "html",
            "text": "\nA strength of any method must be to what extent it functions as a guide. XP provides a lot of guidance. It suggests a number of practices with complex interrelations. These map to a structure of continuous refinement using small iterations. To jump-start this whole process and to overcome, what are considered, minor difficulties some standard advice is offered. But the simplest project model that offers any guidance is, almost certainly, [[Water Fall]]. While XP requires some amount of learning to make it 'pop', [[Water Fall]] tells you what to do, almost in bullet point form. If XP advocates are serious and are not just repeating slogans, then in the spirit of [[Do The Simplest Thing That Could Possibly Work]] they should start with [[Water Fall]] as a project model. Any premature attempt at adding practices, iterations and structure should be met with a firm and resounding: [[You Arent Gonna Need It]]. -- [[Chris Steinbach]]",
            "id": "16ef54128cf1b305ab63baf04e56e60e"
          },
          {
            "type": "html",
            "text": "<i>You might have to rewrite the whole code base if, for example, the chosen language is found to be unsuitable.</i>",
            "id": "d4d501210a835eb2e376f1b1020c5090"
          },
          {
            "type": "html",
            "text": "\nShort of writing some code, how are you going to determine whether a language is suitable? If rewriting the code base is a risk, I would think that would be an argument in favor of a short first iteration, not for a long one.",
            "id": "55d23aab7f3c9613e8a00c0d4103da03"
          },
          {
            "type": "html",
            "text": "<i>It's a tough question. Sometimes it is the mixture of tools that decides. If I can take a network management app as an example. I may have customers who want to access the management system using a certain CORBA version. Then on the network element side maybe I have a mixture of CMIP and SNMP interfaces. It can also be the core competence of a design team or a project that decides.</i>",
            "id": "7b6f6dbd198270f5f452426f02937b5b"
          },
          {
            "type": "html",
            "text": "<i>I think you are correct to say that writing code is an important part of this process. But now we are not talking about production code right? Deployment involves all manner of awful things such as licensing, backwards compatibility, upgrade with data migration. Maybe I have overstated the case for technological stability during development and understated the deployment aspect.</i>",
            "id": "4fed4b20b550fc393d64f1735fecb638"
          },
          {
            "type": "html",
            "text": "\nAlso, please explain the statement about the Waterfall being the simplest project model.",
            "id": "e0c4e57d25c3e66d7b2166d67d1dd49f"
          },
          {
            "type": "html",
            "text": "<i>Read above, I say [[Water Fall]] captures the project structure 'almost in bullet point form'. I don't want to suggest that there is nothing more to it, but it <b>is</b> simpler to explain, conceptualize, learn and (conditions permitting) realize than most other project models. If only because there is less to it.</i>",
            "id": "f0e61a71b2ae1f3bf4f1a885a5c63b14"
          },
          {
            "type": "html",
            "text": "<i>However, I only say that [[Water Fall]] is the first place you should visit. You might not want to stay there. -- [[Chris Steinbach]]</i>",
            "id": "4aa628cfd0e7ad982e05fe6320039ce0"
          },
          {
            "type": "html",
            "text": "\nI will agree that most projects usually are structured along the lines of the waterfall method, but I don't think it necessarily follows that the waterfall method is the most natural or appropriate method to use for most projects. I contend the parallel approach is the more natural and simpler approach and is the one most developers will follow without an outside force causing them to use the waterfall. The simple control loop is the model most often used for other human activities, why not software development?",
            "id": "673f3ae5c1d97738cb9fc4f1803d44e0"
          },
          {
            "type": "html",
            "text": "<i>I think that I have concentrated on structure too much here. The technological problems I started out with ought to be solved, in part at least, by standardization and improvements to technology. My appeal to simplicity is also bogus. Both XP and [[Water Fall]] have simple structures at some level. These structures are not useful until they combine with human activities.</i> -- [[Chris Steinbach]]",
            "id": "2719b6869cfd64a090ed81c792d6c18d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "<i>A strength of any method must be to what extent it functions as a guide. XP provides a lot of guidance...</i>",
            "id": "bbecdbf1187dfc3d60ce75e00a33efdf"
          },
          {
            "type": "html",
            "text": "\nIt's important, in discussions like this, to beware of comparing apples and oranges, such as [[Water Fall]] and XP. [[Water Fall]] is a lifecycle <i>model</i>, something quite abstract and insufficient on its own to guide a development effort. XP, as a collection of heuristics, fills a different role in the software process landscape. The manufactured dichotomy of \"XP versus [[Water Fall]]\" is, frankly, childish, and bears all ths shtick inherent in adolescent upheaval and identity search. Nor does this attitude forward the helpful cause of XP, big picture. -- [[Walden Mathews]]",
            "id": "1ed6918256660d2a698b7159a497ae9b"
          },
          {
            "type": "html",
            "text": "<i>Comparing and contrasting different models is the only way to reach greater understanding. We must be always be careful not allow this process to degrade to one versus the other, because at that point, all learning shuts down.</i>",
            "id": "64006c9ef35400881649988657a7c620"
          },
          {
            "type": "html",
            "text": "\nI think in this case I really did make the wrong comparison. However, we don't have to accept my overly abstract characterization of [[Water Fall]]. Once you start to reintroduce all the details from feasibility study to review, you have something much stronger than a skeletal lifecycle model. You have something that can be (and has been) used as a guide.",
            "id": "217da340bf015236256010880dfe1843"
          },
          {
            "type": "html",
            "text": "\nWithout wanting to pursue the [[Water Fall Vs Xp]] motif here, I do have one last comment. If XP and [[Water Fall]] really are like apples and oranges, then this must be a result of, not a barrier to comparison. But don't they have some overlap? They are, after all, both aimed squarely at supporting software development. If they are at odds with one another, then this only makes the comparison difficult. Not necessarily less rewarding. -- [[Chris Steinbach]]",
            "id": "a193a2c697a8bb77cfa39f9fa66d08f7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "To appreciate the difference in roles between [[Water Fall]] and XP, try mapping the activities of XP onto the [[Water Fall]] model. We can do that here. I'll start.",
            "id": "08237e5f6e26ad9f3d56e44a82921a0a"
          },
          {
            "type": "code",
            "text": " User stories -> Requirements\n \"Tests\" written before \"code\" -> Specifications\n Refactoring -> Design\n etc.",
            "id": "3f30889c5b25e640bdd0c59536d323db"
          },
          {
            "type": "html",
            "text": "\nIn other words, XP can be understood in terms of [[Water Fall]]. Can that be stated the other way around? -- [[Walden Mathews]]",
            "id": "9c66510fc3f5f022c905da669f5e7427"
          },
          {
            "type": "html",
            "text": "<i>How do you explain the onsite customer? The point about XP is that it uses ongoing requirements definitions. And tests are not fully written before the code, but developed in conjunction with the code.</i>",
            "id": "db220539ad7ed2c2306cea34dba4ecbc"
          },
          {
            "type": "html",
            "text": "\nThe \"onsite customer\" rule is a requirements feature; the \"ongoing\" part is an elaboration of the model. \"In conjunction\" is not process language because it doesn't imply an ordering, yet ordering exists to the careful observer. Doesn't the rule say \"write tests first\"? Doesn't \"first\" mean \"before something\"? -- wm",
            "id": "1d51214708a91c6d69945995053ea5a3"
          },
          {
            "type": "html",
            "text": "<i>I believe the phrase is \"test first coding\" and it is really trying to emphasize not writing the tests after the code. The definition of test and the code being tested should be the same. They are two alternate implementations of the same concept that must be brought into agreement. In practice, you will find yourself constantly alternating between adding, modifying, and correcting the test code and the tested code. For many languages, the code to be tested is the first code actually modified, if for no other reason than to add the method to be tested. Imposing sequential operations inappropriately is one of the difficulties with the waterfall model.</i>",
            "id": "372b48861eb54955bb576347532550ef"
          },
          {
            "type": "html",
            "text": "\nI'm not sure what the phrase is, but I can relate the gist of an email I exchanged with [[Kent Beck]] a couple of years ago in which he said (almost verbatim), \"Have you tried writing your tests before you write your code? This to me was one of the most powerful insights...\".",
            "id": "9160ebc5852b23eb934772c59a5f5de2"
          },
          {
            "type": "html",
            "text": "\nSorry if I seem to be splitting hairs, but I don't believe you are observing what is really happening. \"Not writing the tests after the code\" is equivalent to writing them <i>before</i> the code, unless you type with both hands on two keyboards at the same time. <i>That</i> would be extreme!",
            "id": "ac1cb7b3e3550d72c0ca76bda2c9ce8c"
          },
          {
            "type": "html",
            "text": "\"Constantly alternating between adding, modifying ...\". Precisely. You alternate, which is different from doing them simultaneously. You seem to blur the distinction in the name of XP, and I don't think that's \"cricket\", but since I'm no XP XPert (heh), I wish someone who is would chime in at this point. -- wm",
            "id": "d13d3a2d5148a558dd54a26239f7bbd5"
          },
          {
            "type": "html",
            "text": "<i>The argument is the opposite, the argument being presented is that requirements, design, and test are not separable tasks. The blurring is based on trying to take micro-increments of time and map them into \"phases.\" A requirement is defined by the test that validates it. The test is validated by the use of the implementation. Characteristics revealed during the use of the implementation both validate and modify the understanding of the requirements, tests, and implementation. All three types of operation are completed at the same time (assuming that they ever can be completed). What may be less obvious is that all three types of operation begin at the same time. Furthermore, the three items are so tightly coupled, it is not possible to determine where one begins and another ends. The realities suggested by each view are some different, it is not surprising that semantic difficulties arise when mapping one to another. A highly iterative approach is quite different from a waterfall approach; one cannot be mapped onto the other.</i>",
            "id": "a172cb3b6c56e1c083693e869302ab50"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "One of the main purposes of good design is to produce good code. We are only human, and often cannot recognize bad design except in retrospect, by seeing the bad code that the design results in.\nThe fallacy of waterfall, perhaps, is that design can be done without reference to code. ",
            "id": "ececa0e7b6e3d2f0c9dac0f5afedbea2"
          },
          {
            "type": "html",
            "text": "''A different view of the fallacy of the waterfall is that it consists of repeated approximation. A requirements document is written that approximates what the user wants. A design document is written that approximates what is in the requirements document. Software is written that approximates the design document. No wonder the final software differs from what the user originally wanted. As for cost, we have written the same thing three times in three different forms. \nNo wonder the cost and the cost of change go up.''",
            "id": "8821cb04522e42897f0e178161b73138"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "image",
            "url": "http://www.artchive.com/artchive/e/escher/escher_waterfall.jpg",
            "text": "www.artchive.com",
            "id": "d8b062562104b7eba11829cb637c4e1a"
          },
          {
            "type": "html",
            "text": "",
            "id": "774de0237ac71e6913d902cca9e65969"
          },
          {
            "type": "html",
            "text": "\nDoes it not always somehow seem to come back to haunt you? Ahh, the above mentioned retrospect...",
            "id": "18fd763f54e8b5a8a32bb941acbf1322"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "At least one paper on the history of software development (I cannot recall the authors or title) has suggested that the position of the [[Waterfall Model]] as the 'traditional' design model is itself specious, a myth established by a misunderstanding of the Royce paper - but not the misunderstanding usually attributed. The argument was that the majority of papers, design documents and press releases which mention 'waterfall' did so in the same way Royce did - as a [[Straw Man]] - to <i>contrast</i> with the approach the paper claims to describe. That is to say, they asserted that [[Waterfall Model]] was not the traditional design approach, but rather the traditional [[Straw Man]] which all designers sought to refute, and that 'waterfall' was never actually a live practice.",
            "id": "2e9efb413b0ed8df2c2d1741bd8e69b4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "See [[Waterfall Model]], [[Job Security]], [[Water Fall Myths]], [[Design Approach Tina]], [[Falling Water]], [[Customer Information Analysis Design Coding]]",
            "id": "883c883670c6b8cf989893828c0180f5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74ddfb90ace4e2931480f3b206cfcee8"
          },
          {
            "type": "html",
            "text": "[[Category Application Development]]",
            "id": "a99e12274b395ac20bdfc433ca6e4fd0"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?WaterFall c2.com]",
            "id": "5f0f7670973c81cd3f7f2d519c2ac4d1"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1627290953239
    }
  ]
}