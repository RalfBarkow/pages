{
  "title": "A Story of a Bug Found Fuzzing",
  "story": [
    {
      "type": "paragraph",
      "id": "2ac7c733cf6694e7",
      "text": "In a previous blogpost, it covered and mentioned automation and how it is great at finding memory issues. We also got some feedback to expand on fuzzing, so this post will cover how we came to develop a fuzzer and how it found its first security issue early in development."
    },
    {
      "type": "paragraph",
      "id": "9ef7b9bdb411eab5",
      "text": "The main intention of this fuzzer is to use the signal from MSRC cases and see if it can find the next bug before it gets reported which follows the same pattern. The result was a cool browser fuzzer and the experiment yielded interesting results."
    },
    {
      "type": "paragraph",
      "id": "c36f456b57079edd",
      "text": "The Target"
    },
    {
      "type": "paragraph",
      "id": "acdc8c065aa4b9a4",
      "text": "We noticed a pattern in recent memory corruption bugs affecting both Edge and Chromium where an extension was used as a proof of concept. This was particularly interesting to me because I looked at extensions [https://leucosite.com/WebExtension-Security-Part-2/ https://leucosite.com/WebExtension-Security-Part-2/] a few years ago and only found logic bugs and, with an itch to make an experimental fuzzer why not try to create an extension based fuzzer for some variant hunting."
    },
    {
      "type": "paragraph",
      "id": "10e36e68385e4afe",
      "text": "Now that I have a general component (Web Extensions) as a target, where to start?"
    },
    {
      "type": "paragraph",
      "id": "e84413536744f7b1",
      "text": "When reading through all of the publicly disclosed chromium bugs that involved an extension and a browser crash, two bugs from David Erceg [https://twitter.com/david_erceg https://twitter.com/david_erceg] stood out (1188889 [https://bugs.chromium.org/p/chromium/issues/detail?id=1188889 https://bugs.chromium.org/p/chromium/issues/detail?id=1188889], 1190550 [https://bugs.chromium.org/p/chromium/issues/detail?id=1190550 https://bugs.chromium.org/p/chromium/issues/detail?id=1190550]) where the chrome.debugger.sendCommand was used and it was interesting."
    },
    {
      "type": "paragraph",
      "id": "ad6c70272ecc5166",
      "text": "The chrome.debugger extension API allows you to control some tabs using the devtools protocol [https://chromedevtools.github.io/devtools-protocol/ https://chromedevtools.github.io/devtools-protocol/], this is the same protocol remote debugging uses. The function sendCommand stood out which looks like the following:"
    },
    {
      "type": "paragraph",
      "id": "80d59e7639666327",
      "text": "chrome.debugger.sendCommand(   target: Debuggee,   method: string,   commandParams?: object,   callback?: function, )"
    },
    {
      "type": "paragraph",
      "id": "3c53f84aa29ec5e2",
      "text": "This looks like a promising function to start fuzzing.  [...]"
    },
    {
      "type": "paragraph",
      "id": "12bae7adbfbec583",
      "text": "[https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/ https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/]"
    },
    {
      "type": "markdown",
      "id": "32cb02f4408cac4a",
      "text": "Source: Microsoft Browser Vulnerability Research via [https://catless.ncl.ac.uk/Risks/33/28/#subj7.1 The Risks Digest]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "date": 1655251264000,
      "item": {
        "title": "A Story of a Bug Found Fuzzing",
        "story": [
          {
            "type": "paragraph",
            "id": "2ac7c733cf6694e7",
            "text": "In a previous blogpost, it covered and mentioned automation and how it is great at finding memory issues. We also got some feedback to expand on fuzzing, so this post will cover how we came to develop a fuzzer and how it found its first security issue early in development."
          },
          {
            "type": "paragraph",
            "id": "9ef7b9bdb411eab5",
            "text": "The main intention of this fuzzer is to use the signal from MSRC cases and see if it can find the next bug before it gets reported which follows the same pattern. The result was a cool browser fuzzer and the experiment yielded interesting results."
          },
          {
            "type": "paragraph",
            "id": "c36f456b57079edd",
            "text": "The Target"
          },
          {
            "type": "paragraph",
            "id": "acdc8c065aa4b9a4",
            "text": "We noticed a pattern in recent memory corruption bugs affecting both Edge and Chromium where an extension was used as a proof of concept. This was particularly interesting to me because I looked at extensions [https://leucosite.com/WebExtension-Security-Part-2/ https://leucosite.com/WebExtension-Security-Part-2/] a few years ago and only found logic bugs and, with an itch to make an experimental fuzzer why not try to create an extension based fuzzer for some variant hunting."
          },
          {
            "type": "paragraph",
            "id": "10e36e68385e4afe",
            "text": "Now that I have a general component (Web Extensions) as a target, where to start?"
          },
          {
            "type": "paragraph",
            "id": "e84413536744f7b1",
            "text": "When reading through all of the publicly disclosed chromium bugs that involved an extension and a browser crash, two bugs from David Erceg [https://twitter.com/david_erceg https://twitter.com/david_erceg] stood out (1188889 [https://bugs.chromium.org/p/chromium/issues/detail?id=1188889 https://bugs.chromium.org/p/chromium/issues/detail?id=1188889], 1190550 [https://bugs.chromium.org/p/chromium/issues/detail?id=1190550 https://bugs.chromium.org/p/chromium/issues/detail?id=1190550]) where the chrome.debugger.sendCommand was used and it was interesting."
          },
          {
            "type": "paragraph",
            "id": "ad6c70272ecc5166",
            "text": "The chrome.debugger extension API allows you to control some tabs using the devtools protocol [https://chromedevtools.github.io/devtools-protocol/ https://chromedevtools.github.io/devtools-protocol/], this is the same protocol remote debugging uses. The function sendCommand stood out which looks like the following:"
          },
          {
            "type": "paragraph",
            "id": "80d59e7639666327",
            "text": "chrome.debugger.sendCommand(   target: Debuggee,   method: string,   commandParams?: object,   callback?: function, )"
          },
          {
            "type": "paragraph",
            "id": "3c53f84aa29ec5e2",
            "text": "This looks like a promising function to start fuzzing.  [...]"
          },
          {
            "type": "paragraph",
            "id": "12bae7adbfbec583",
            "text": "[https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/ https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/]"
          },
          {
            "type": "markdown",
            "id": "32cb02f4408cac4a",
            "text": "Source: Microsoft Browser Vulnerability Research via [https://catless.ncl.ac.uk/Risks/33/28/#subj7.1 The Risks Digest]"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "risks.rodwell.me",
      "date": 1655297052237
    }
  ]
}