{
  "title": "Haskell Language",
  "story": [
    {
      "type": "html",
      "text": "Haskell is a purely [[Functional Programming Language]] using [[Non Strict Semantics]] (typically implemented as [[Lazy Evaluation]]) and a polymorphic type system (an extension of the classical [[Hindley Milner Type Inference]] algorithm). It was named after [[Haskell Curry]].",
      "id": "af5aaccce756f5d8da4c1bc65d82506c"
    },
    {
      "type": "html",
      "text": "\nSee [http://www.haskell.org/ www.haskell.org] and the [[Haskell Wiki]].",
      "id": "f975dee9a816cfd75be80d1491682ea2"
    },
    {
      "type": "html",
      "text": "\nSome nice features:",
      "id": "47a2d8cee06e995fe37582f68317033c"
    },
    {
      "type": "html",
      "text": " Functions can be defined by [[Pattern Matching]], as in several other functional languages.",
      "id": "a6022c4ad4aa7f6abdd567d4269a6174"
    },
    {
      "type": "html",
      "text": " [[List Comprehension]]s provide a nice way to write mapping and filtering operations.",
      "id": "2f2610039f3e909eb34737ca476aa5e6"
    },
    {
      "type": "html",
      "text": " Syntactic support for a simple variety of [[Literate Programming]].",
      "id": "d03c659d8de85e7ff76d628c4eb04add"
    },
    {
      "type": "html",
      "text": " You can define your own infix operators.",
      "id": "19867f294d64cb4ef8d53c72bade0d38"
    },
    {
      "type": "html",
      "text": " [[Type Classes]] allow the introduction of overloaded functions.",
      "id": "f1eaddfb530262396e8778093ff81f24"
    },
    {
      "type": "html",
      "text": " Readily available package system, [[Hackage Db]] ([http://hackage.haskell.org hackage.haskell.org]) and user-side tool 'cabal', with thousands of open-source packages.",
      "id": "e1c9278d2ebd7b7176e3a120884e809a"
    },
    {
      "type": "html",
      "text": " Indentation-sensitive syntax and curly brace syntax are both possible, depending on your preference.",
      "id": "7ad7ab3bdd678d23b3fef2aa21bcd5ee"
    },
    {
      "type": "html",
      "text": "\nI/O is done via monads (see [[On Monads]]). Monads (which have far wider applications than just I/O) are hard for some to grasp, but there are a lot of good tutorials right now on the net that deal with them. A good place to start is [http://www.haskell.org/learning.html www.haskell.org].",
      "id": "e79087070e54e00fb6afc6c7a55bcab5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "<b>Implementation</b>",
      "id": "0bcfc5939753332246aeec63901d8ac1"
    },
    {
      "type": "html",
      "text": " [[Haskell Platform]]",
      "id": "44b5f43e3c5c86f622593f8eaaf23d81"
    },
    {
      "type": "html",
      "text": " [[Glasgow Haskell Compiler]]",
      "id": "998de0d9dad6e543e530012ff2b32dc3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "<b>Books</b>",
      "id": "2a01e92e989c076be5e23493fc3c1809"
    },
    {
      "type": "html",
      "text": " [[Real World Haskell]]",
      "id": "18f6b82b4cd7bac223e28de79d98abae"
    },
    {
      "type": "html",
      "text": " [[Parallel And Concurrent Programming In Haskell]]",
      "id": "15f0308ef20c08935feb3d3f025f437e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "[[David Mertz]] has a small tutorial on Haskell ([http://gnosis.cx/publish/programming/Haskell.pdf gnosis.cx]).",
      "id": "de00f13aa51bf7b00cdaece9e203e52d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "[[Jim Bender]] maintains a growing \"Online Bibliography of Haskell Research\" at [http://haskell.readscheme.org/ haskell.readscheme.org] that references many research papers about monads and their even more abstract and scary generalization, arrows. [[Haskell Arrows]] were introduced by [[John Hughes]] and are also explained at [http://www.haskell.org/arrows/ www.haskell.org].",
      "id": "536b37bc84d48ae95b6debec75decf5f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "In \"Wearing the hair shirt: a retrospective on Haskell\" (2003, available as a set of [[Power Point]] slides at [http://www.research.microsoft.com/~simonpj/papers/haskell-retrospective/ www.research.microsoft.com]) [[Simon Peyton Jones]] provides an overview of the (rather short) history of Haskell. He concludes that [[Lazy Evaluation]] is rather less important than one might think while purity and type classes and monads are essential. \"<i>Our biggest mistake: using the scary term 'Monad' rather than 'Warm Fuzzy Thing' </i>\"",
      "id": "d0c4989cb208e00a4c325041f8c44119"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "Haskell now has its very own International Obfuscated Code Contest (see [http://www.ScannedInAvian.org/iohcc/ www.ScannedInAvian.org]).",
      "id": "c1b1008273ef5abd7474ff4c4c69dd80"
    },
    {
      "type": "html",
      "text": "<i>[[Broken Link]] as of 16 February 2010, but available through [[Wayback Machine]] at [http://web.archive.org/web/20050409013040/www.scannedinavian.org/iohcc/ web.archive.org].</i>",
      "id": "32da99f4d0ff269bd7c21ad2dab29dfd"
    },
    {
      "type": "html",
      "text": "\nAnd its very own Lambdacats site (see [http://arcanux.org/lambdacats.html arcanux.org]).",
      "id": "827ee1e2f776da8b6f2e2e17f69402de"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "See [[Quick Sort In Haskell]] for a short example of Haskell code. See [[The Evolution Ofa Haskell Programmer]] for some more examples.",
      "id": "0b235ec543b71ed4ecd1e2c49edeef58"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "Some people are running the [[Language Of The Year]] project over on the Pragmatic Programmer mailing list and chose Haskell as [[Language Of The Year]] 2002. Check it out: [http://groups.yahoo.com/group/pragprog groups.yahoo.com].",
      "id": "8f6537b268aed00f521b0e55dddcbda5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "<b>[[Haskell Language]] [[Quick Questions]]</b>",
      "id": "0cde14ffc1e542d51eebb87f1571c8f4"
    },
    {
      "type": "html",
      "text": "<b>Q</b> IBM article In 2001 ([http://www-106.ibm.com/developerworks/xml/library/x-matters14.html www-106.ibm.com]) advocated use of [[Haskell Language]] based [[Ha Xml]] to overcome the limitations of XML processing tools. Is his idea a flash in the pan? Are there better alternatives to DOM/SAX/XSLT?",
      "id": "8c7d6e7b5465f518b23c399ed3875aa7"
    },
    {
      "type": "html",
      "text": "<b>A</b> The combinators of [[Ha Xml]] are designed to do about the same thing as XSLT. However, have you ever tried using XSLT? Anything that does the same will be simpler and easier to use. [[Ha Xml]], being embedded in Haskell gives the full power of a programming language on top of the easy XML transformations. Another popular Haskell XML library is HXT, which is also notable in that one way to use it is through its arrow-based API.",
      "id": "e2b373d59dd18b72710f63053f44b732"
    },
    {
      "type": "html",
      "text": "<b>Q</b> Is there a good IDE usable for Haskell under Windows?",
      "id": "61ba97c9ebbda8b3c1de0334c10e741f"
    },
    {
      "type": "html",
      "text": "<b>A</b> [http://www.haskell.org/libraries/#ide www.haskell.org] (mentions hIDE and jCreator)",
      "id": "751ea01597382cb37ed0717b4e668fac"
    },
    {
      "type": "html",
      "text": "\nI've also heard of editor support in jEdit, Eclipse, and some other editors. I'm mostly happy with the haskell-mode in Emacs.",
      "id": "9acde3d25facc58fe5bdc574b9938f71"
    },
    {
      "type": "html",
      "text": "<i>See also [http://www.haskell.org/visualhaskell/ www.haskell.org] for a Haskell plugin for [[Visual Studio]] (not to be confused with a similar project at [http://www.cin.ufpe.br/~haskell/vhs/index.html www.cin.ufpe.br]). This plugin ties directly into the GHC compiler, providing all of the usual VS features like syntax highlighting and name completion, but it also goes a step further. If the plugin doesn't squiggly-highlight any code in your program, it is guaranteed to compile with GHC. -- [[Michael Sparks]]</i>",
      "id": "b6fbf21d626af29041a6da06fd642bf1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "I love Haskell mostly for the elegant and beautiful syntax you get when doing [[Point Free Programming]]. However, Haskell's strict FP discipline and affinity for abstruse concepts like Arrows really hurts when trying to put together quick scripts, or when just hacking for fun. Are there other languages that support the inline . and $ operators or other syntax like it? I just can't go back to (compose #'foo #'bar) after getting used to foo . bar, to say nothing of all the fun with the $ operator in avoiding needless parenthesis.",
      "id": "d1c30aa90359ed053a8ec0aeecea7a78"
    },
    {
      "type": "html",
      "text": " You might find [[Concatenative Language]]s interesting, such as [[Forth Language]], [[Joy Language]], or [[Factor Language]]. Unlike [[Applicative Language]]s, juxtaposition of symbols indicates a composition operation (e.g., <b>A B</b> means to compute A first, then compute B on A's results; this is equivalent to B $ A or B . A in Haskell, depending on your precise context). -- [[Samuel Falvo]]",
      "id": "ba5750a6a757ce811ec19cc4f3dc6e72"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": " Sounds like it isn't a [[Real Programming Language]]",
      "id": "aa9179680f8fb0b4de426f852582f9b1"
    },
    {
      "type": "html",
      "text": "... I suppose I can't hold my breath on that, since to get point-free programming, I also need automatic currying, which I've only seen in [[Ml Language]]s. I suppose I can live with [[Sml Language]] and the 'o' operator, but no $ operator I'm aware of.",
      "id": "4f3af7cd57d477e24db922ca3cc608ea"
    },
    {
      "type": "html",
      "text": "<i>Abstruse concepts? I have a whole book about abstruse concepts sitting on my shelf, only it's imported from that other, backwards world, where functions are only known as methods and abstruse concepts are sold as Design Patterns, where the capital letters apparently enchant them into something desirable... Really, compared to [[Rube Goldberg Devices]] like Visitor, Arrows and Monads are astonishingly simple. Perhaps that's why imperative programmers distrust these powerful structures.</i>",
      "id": "c4559ef40f11dedb88cccde0b14cf4cc"
    },
    {
      "type": "html",
      "text": " Monads rhymes with..",
      "id": "6666cef2e5e565d3749643e5bf1df053"
    },
    {
      "type": "html",
      "text": "<i>That would make a nice T-shirt:</i> \"I have the GONADS to work with MONADS.\"",
      "id": "2c92f27fc6428101305d71bf549d2da1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "\nWith languages with pervasive effects such as C, you need machinery such as Hoare logic to handle proofs about programs. One of the benefits of Haskell's purity is that its expressions are already in the right form for traditional mathematical proof. You can even use Haskell functions in specifications because they are pure.",
      "id": "6197a31236d1d001fa5f379c59a9c50a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "The [[Lindows Os]] folks have apparently standardized on Haskell for core operating system development. See [http://urchin.earth.li/pipermail/debian-haskell/2006-May/000169.html urchin.earth.li]",
      "id": "483e019bfed9ebef9614096e06541b64"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "A useful reference to details of Haskell is at [http://www.zvon.org/other/haskell/Outputglobal/index.html www.zvon.org]",
      "id": "abed4bcf750ff838d2227e4bd6c6903f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "See also [[Template Haskell]], [[Iwanna Learn Haskell]], [[Haskell Unit]], [[Co Monads]], [[Haskell Arrows]]",
      "id": "f6c9b30ec147ce68dc68416149fbc2e9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "613e2d74e4143d430328e033dffab5aa"
    },
    {
      "type": "html",
      "text": "[[Category Programming Language]] [[Functional Programming Language]] [[Category Haskell]] [[Category Functional Programming]] [[Category Literate Programming]]",
      "id": "a40bd351798abd6440d2270ec1ea81c6"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?HaskellLanguage c2.com]",
      "id": "c3d7730f57759a7a91447adf74bf525e"
    }
  ],
  "journal": [
    {
      "date": 1396326846000,
      "id": "369a59a148f60faaefd439c376b0ac50",
      "type": "create",
      "item": {
        "title": "Haskell Language",
        "story": [
          {
            "type": "html",
            "text": "Haskell is a purely [[Functional Programming Language]] using [[Non Strict Semantics]] (typically implemented as [[Lazy Evaluation]]) and a polymorphic type system (an extension of the classical [[Hindley Milner Type Inference]] algorithm). It was named after [[Haskell Curry]].",
            "id": "af5aaccce756f5d8da4c1bc65d82506c"
          },
          {
            "type": "html",
            "text": "\nSee [http://www.haskell.org/ www.haskell.org] and the [[Haskell Wiki]].",
            "id": "f975dee9a816cfd75be80d1491682ea2"
          },
          {
            "type": "html",
            "text": "\nSome nice features:",
            "id": "47a2d8cee06e995fe37582f68317033c"
          },
          {
            "type": "html",
            "text": " Functions can be defined by [[Pattern Matching]], as in several other functional languages.",
            "id": "a6022c4ad4aa7f6abdd567d4269a6174"
          },
          {
            "type": "html",
            "text": " [[List Comprehension]]s provide a nice way to write mapping and filtering operations.",
            "id": "2f2610039f3e909eb34737ca476aa5e6"
          },
          {
            "type": "html",
            "text": " Syntactic support for a simple variety of [[Literate Programming]].",
            "id": "d03c659d8de85e7ff76d628c4eb04add"
          },
          {
            "type": "html",
            "text": " You can define your own infix operators.",
            "id": "19867f294d64cb4ef8d53c72bade0d38"
          },
          {
            "type": "html",
            "text": " [[Type Classes]] allow the introduction of overloaded functions.",
            "id": "f1eaddfb530262396e8778093ff81f24"
          },
          {
            "type": "html",
            "text": " Readily available package system, [[Hackage Db]] ([http://hackage.haskell.org hackage.haskell.org]) and user-side tool 'cabal', with thousands of open-source packages.",
            "id": "e1c9278d2ebd7b7176e3a120884e809a"
          },
          {
            "type": "html",
            "text": " Indentation-sensitive syntax and curly brace syntax are both possible, depending on your preference.",
            "id": "7ad7ab3bdd678d23b3fef2aa21bcd5ee"
          },
          {
            "type": "html",
            "text": "\nI/O is done via monads (see [[On Monads]]). Monads (which have far wider applications than just I/O) are hard for some to grasp, but there are a lot of good tutorials right now on the net that deal with them. A good place to start is [http://www.haskell.org/learning.html www.haskell.org].",
            "id": "e79087070e54e00fb6afc6c7a55bcab5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "<b>Implementation</b>",
            "id": "0bcfc5939753332246aeec63901d8ac1"
          },
          {
            "type": "html",
            "text": " [[Haskell Platform]]",
            "id": "44b5f43e3c5c86f622593f8eaaf23d81"
          },
          {
            "type": "html",
            "text": " [[Glasgow Haskell Compiler]]",
            "id": "998de0d9dad6e543e530012ff2b32dc3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "<b>Books</b>",
            "id": "2a01e92e989c076be5e23493fc3c1809"
          },
          {
            "type": "html",
            "text": " [[Real World Haskell]]",
            "id": "18f6b82b4cd7bac223e28de79d98abae"
          },
          {
            "type": "html",
            "text": " [[Parallel And Concurrent Programming In Haskell]]",
            "id": "15f0308ef20c08935feb3d3f025f437e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "[[David Mertz]] has a small tutorial on Haskell ([http://gnosis.cx/publish/programming/Haskell.pdf gnosis.cx]).",
            "id": "de00f13aa51bf7b00cdaece9e203e52d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "[[Jim Bender]] maintains a growing \"Online Bibliography of Haskell Research\" at [http://haskell.readscheme.org/ haskell.readscheme.org] that references many research papers about monads and their even more abstract and scary generalization, arrows. [[Haskell Arrows]] were introduced by [[John Hughes]] and are also explained at [http://www.haskell.org/arrows/ www.haskell.org].",
            "id": "536b37bc84d48ae95b6debec75decf5f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "In \"Wearing the hair shirt: a retrospective on Haskell\" (2003, available as a set of [[Power Point]] slides at [http://www.research.microsoft.com/~simonpj/papers/haskell-retrospective/ www.research.microsoft.com]) [[Simon Peyton Jones]] provides an overview of the (rather short) history of Haskell. He concludes that [[Lazy Evaluation]] is rather less important than one might think while purity and type classes and monads are essential. \"<i>Our biggest mistake: using the scary term 'Monad' rather than 'Warm Fuzzy Thing' </i>\"",
            "id": "d0c4989cb208e00a4c325041f8c44119"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "Haskell now has its very own International Obfuscated Code Contest (see [http://www.ScannedInAvian.org/iohcc/ www.ScannedInAvian.org]).",
            "id": "c1b1008273ef5abd7474ff4c4c69dd80"
          },
          {
            "type": "html",
            "text": "<i>[[Broken Link]] as of 16 February 2010, but available through [[Wayback Machine]] at [http://web.archive.org/web/20050409013040/www.scannedinavian.org/iohcc/ web.archive.org].</i>",
            "id": "32da99f4d0ff269bd7c21ad2dab29dfd"
          },
          {
            "type": "html",
            "text": "\nAnd its very own Lambdacats site (see [http://arcanux.org/lambdacats.html arcanux.org]).",
            "id": "827ee1e2f776da8b6f2e2e17f69402de"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "See [[Quick Sort In Haskell]] for a short example of Haskell code. See [[The Evolution Ofa Haskell Programmer]] for some more examples.",
            "id": "0b235ec543b71ed4ecd1e2c49edeef58"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "Some people are running the [[Language Of The Year]] project over on the Pragmatic Programmer mailing list and chose Haskell as [[Language Of The Year]] 2002. Check it out: [http://groups.yahoo.com/group/pragprog groups.yahoo.com].",
            "id": "8f6537b268aed00f521b0e55dddcbda5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "<b>[[Haskell Language]] [[Quick Questions]]</b>",
            "id": "0cde14ffc1e542d51eebb87f1571c8f4"
          },
          {
            "type": "html",
            "text": "<b>Q</b> IBM article In 2001 ([http://www-106.ibm.com/developerworks/xml/library/x-matters14.html www-106.ibm.com]) advocated use of [[Haskell Language]] based [[Ha Xml]] to overcome the limitations of XML processing tools. Is his idea a flash in the pan? Are there better alternatives to DOM/SAX/XSLT?",
            "id": "8c7d6e7b5465f518b23c399ed3875aa7"
          },
          {
            "type": "html",
            "text": "<b>A</b> The combinators of [[Ha Xml]] are designed to do about the same thing as XSLT. However, have you ever tried using XSLT? Anything that does the same will be simpler and easier to use. [[Ha Xml]], being embedded in Haskell gives the full power of a programming language on top of the easy XML transformations. Another popular Haskell XML library is HXT, which is also notable in that one way to use it is through its arrow-based API.",
            "id": "e2b373d59dd18b72710f63053f44b732"
          },
          {
            "type": "html",
            "text": "<b>Q</b> Is there a good IDE usable for Haskell under Windows?",
            "id": "61ba97c9ebbda8b3c1de0334c10e741f"
          },
          {
            "type": "html",
            "text": "<b>A</b> [http://www.haskell.org/libraries/#ide www.haskell.org] (mentions hIDE and jCreator)",
            "id": "751ea01597382cb37ed0717b4e668fac"
          },
          {
            "type": "html",
            "text": "\nI've also heard of editor support in jEdit, Eclipse, and some other editors. I'm mostly happy with the haskell-mode in Emacs.",
            "id": "9acde3d25facc58fe5bdc574b9938f71"
          },
          {
            "type": "html",
            "text": "<i>See also [http://www.haskell.org/visualhaskell/ www.haskell.org] for a Haskell plugin for [[Visual Studio]] (not to be confused with a similar project at [http://www.cin.ufpe.br/~haskell/vhs/index.html www.cin.ufpe.br]). This plugin ties directly into the GHC compiler, providing all of the usual VS features like syntax highlighting and name completion, but it also goes a step further. If the plugin doesn't squiggly-highlight any code in your program, it is guaranteed to compile with GHC. -- [[Michael Sparks]]</i>",
            "id": "b6fbf21d626af29041a6da06fd642bf1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "I love Haskell mostly for the elegant and beautiful syntax you get when doing [[Point Free Programming]]. However, Haskell's strict FP discipline and affinity for abstruse concepts like Arrows really hurts when trying to put together quick scripts, or when just hacking for fun. Are there other languages that support the inline . and $ operators or other syntax like it? I just can't go back to (compose #'foo #'bar) after getting used to foo . bar, to say nothing of all the fun with the $ operator in avoiding needless parenthesis.",
            "id": "d1c30aa90359ed053a8ec0aeecea7a78"
          },
          {
            "type": "html",
            "text": " You might find [[Concatenative Language]]s interesting, such as [[Forth Language]], [[Joy Language]], or [[Factor Language]]. Unlike [[Applicative Language]]s, juxtaposition of symbols indicates a composition operation (e.g., <b>A B</b> means to compute A first, then compute B on A's results; this is equivalent to B $ A or B . A in Haskell, depending on your precise context). -- [[Samuel Falvo]]",
            "id": "ba5750a6a757ce811ec19cc4f3dc6e72"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": " Sounds like it isn't a [[Real Programming Language]]",
            "id": "aa9179680f8fb0b4de426f852582f9b1"
          },
          {
            "type": "html",
            "text": "... I suppose I can't hold my breath on that, since to get point-free programming, I also need automatic currying, which I've only seen in [[Ml Language]]s. I suppose I can live with [[Sml Language]] and the 'o' operator, but no $ operator I'm aware of.",
            "id": "4f3af7cd57d477e24db922ca3cc608ea"
          },
          {
            "type": "html",
            "text": "<i>Abstruse concepts? I have a whole book about abstruse concepts sitting on my shelf, only it's imported from that other, backwards world, where functions are only known as methods and abstruse concepts are sold as Design Patterns, where the capital letters apparently enchant them into something desirable... Really, compared to [[Rube Goldberg Devices]] like Visitor, Arrows and Monads are astonishingly simple. Perhaps that's why imperative programmers distrust these powerful structures.</i>",
            "id": "c4559ef40f11dedb88cccde0b14cf4cc"
          },
          {
            "type": "html",
            "text": " Monads rhymes with..",
            "id": "6666cef2e5e565d3749643e5bf1df053"
          },
          {
            "type": "html",
            "text": "<i>That would make a nice T-shirt:</i> \"I have the GONADS to work with MONADS.\"",
            "id": "2c92f27fc6428101305d71bf549d2da1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "\nWith languages with pervasive effects such as C, you need machinery such as Hoare logic to handle proofs about programs. One of the benefits of Haskell's purity is that its expressions are already in the right form for traditional mathematical proof. You can even use Haskell functions in specifications because they are pure.",
            "id": "6197a31236d1d001fa5f379c59a9c50a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "The [[Lindows Os]] folks have apparently standardized on Haskell for core operating system development. See [http://urchin.earth.li/pipermail/debian-haskell/2006-May/000169.html urchin.earth.li]",
            "id": "483e019bfed9ebef9614096e06541b64"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "A useful reference to details of Haskell is at [http://www.zvon.org/other/haskell/Outputglobal/index.html www.zvon.org]",
            "id": "abed4bcf750ff838d2227e4bd6c6903f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "See also [[Template Haskell]], [[Iwanna Learn Haskell]], [[Haskell Unit]], [[Co Monads]], [[Haskell Arrows]]",
            "id": "f6c9b30ec147ce68dc68416149fbc2e9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "613e2d74e4143d430328e033dffab5aa"
          },
          {
            "type": "html",
            "text": "[[Category Programming Language]] [[Functional Programming Language]] [[Category Haskell]] [[Category Functional Programming]] [[Category Literate Programming]]",
            "id": "a40bd351798abd6440d2270ec1ea81c6"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?HaskellLanguage c2.com]",
            "id": "c3d7730f57759a7a91447adf74bf525e"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1644991023125
    }
  ]
}