{
  "title": "Value Object",
  "story": [
    {
      "type": "html",
      "text": "See also: [[Value Object Hypotheses]], [[Value Objects Can Be Mutable]], [[Value Objects Should Be Immutable]], [[Value Objects Should Be Passed By Value]], [[Value Object Framework]], [[Java Value]], [[Value Object Literature]], [[Proto Value]]",
      "id": "b669afabc2255b786fc0167d20b88ea2"
    },
    {
      "type": "html",
      "text": "\nExamples of value objects are things like numbers, dates, monies and strings. Usually, they are small objects which are used quite widely. Their identity is based on their state rather than on their object identity. This way, you can have multiple copies of the same conceptual value object. <i>Every $5 note has its own identity (thanks to its serial number), but the cash economy relies on every $5 note having the same value as every other $5 note.</i>",
      "id": "5ca53474f8807492213ed552f8c9b755"
    },
    {
      "type": "html",
      "text": "\nSo I can have multiple copies of an object that represents the date 16 Jan 1998. Any of these copies will be equal to each other. For a small object such as this, it is often easier to create new ones and move them around rather than rely on a single object to represent the date.",
      "id": "a2afac4f05599c5fee40b91124e520ec"
    },
    {
      "type": "html",
      "text": "\nA value object should always override .equals() in Java (or = in Smalltalk). (Remember to override .hashCode() as well.)",
      "id": "d7925cea83dd7c6b14ac207a9b0b091b"
    },
    {
      "type": "html",
      "text": "\nA value object is not a [[Business Object]]/[[Reference Object]].\nA [[Business Object]]/[[Reference Object]] is something you find in the world, while a [[Value Object]] is a measure or description of something.",
      "id": "ad9aa61e48bb0a494a93f6dd7f821560"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6d1c31648f69f5ba51c39928b63aea17"
    },
    {
      "type": "html",
      "text": "\n[http://www.riehle.org/computer-science/research/1998/ubilab-tr-1998-10-1.html www.riehle.org] presents an in-depth discussion of why and where you want value objects and how to implement them efficiently in different languages.",
      "id": "1404912f8b192aa64484654a59336dcc"
    },
    {
      "type": "html",
      "text": "\nChapter 9 of [[Functional Pattern System For Object Oriented Design]] describes [[Value Object]].",
      "id": "16460a85d7d77000105a7890fc6a5d31"
    },
    {
      "type": "html",
      "text": "\nI haven't read it yet, but there is an article on [[Value Object]](s) in the July/August 1998 issue of the [[Journal Of Object Oriented Programming]]. It is 'Values and Objects Revisited' by [[Peter Van Der Werf]]. -- [[Michael Feathers]]",
      "id": "95ed5d6bfc596f3ff33ce67b1fd21c8c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6d1c31648f69f5ba51c39928b63aea17"
    },
    {
      "type": "html",
      "text": "Someone good with C++ can explain what to do with that language for value objects.",
      "id": "374330bd7416e48637bd4165183de930"
    },
    {
      "type": "html",
      "text": "\n[[Value Objects Should Be Immutable]]",
      "id": "e2e604f49c77bd6a465a76bef5e9f89e"
    },
    {
      "type": "html",
      "text": "\nCompare this with a [[Reference Object]].",
      "id": "1cba8e2a8e769fe01b32998c5f4f6337"
    },
    {
      "type": "html",
      "text": "-- [[Martin Fowler]]",
      "id": "815333f22e2ae51bdb74780431bca8f6"
    },
    {
      "type": "html",
      "text": "<i>Comment: In C++, you typically implement value objects using reference-counted copy-on-write classes (body/handle idiom). [[Jim Coplien]] explains this idiom well in his book on Advanced C++. Otherwise, see our technical report. -- [[Dirk Riehle]]</i>",
      "id": "b959294acad96f646b92b4e4ca362ff3"
    },
    {
      "type": "html",
      "text": "\nIf the definition of value object is an object whose identity is defined by its state rather than by its address, I'm inclined to think that they are defined in C++ as objects that override the copy constructor, assignment and comparison operators to assign and compare state between two objects. Overriding the assignment operator is key and means that in C++ [[Value Objects Can Be Mutable]] and usually are. The aliasing problems addressed in [[Value Objects Should Be Immutable]] are generally taken care of by using pass-by-value semantics. -- [[Phil Goodwin]] ",
      "id": "7c7442c10937edd1f38402af8e76ae96"
    },
    {
      "type": "html",
      "text": "\nI think there's a useful distinction to be drawn between assignment and mutation in general, especially in C++. Say you have a plain old int, \"i,\" whose value is five. This object is mutable in the sense that, yes, you can change it. But <i>what</i> you're changing is not <i>the</i> value, but <i>which</i> value. In other words, if I assign a value of ten to \"i,\" I'm not effecting any mutation upon the value \"five;\" I'm <i>replacing</i> the value \"five.\" Such is the general case with value types in C++. In some sense, assignment for a value type on which assignment is the only \"mutating\" operation can be thought of as a shorthand for a manual destructor call followed by a placement new. Borrowing from the \"Point\" example below, modulo stylistic choices:",
      "id": "36cb0523a3eab411e25b40c8a397abda"
    },
    {
      "type": "code",
      "text": "    struct point {\n      const int x;\n      const int y;",
      "id": "014cbb00a4e1d1036e5495ea783d82e7"
    },
    {
      "type": "code",
      "text": "      point (const point&) = default;",
      "id": "764f30a9ee30594cdd883657ebd729a5"
    },
    {
      "type": "code",
      "text": "      point& operator = (const point& other) {\n        this->~point ();\n        return *new (this) point (other);\n      }\n    };",
      "id": "3836192a0821a6180d9f232bf72abc94"
    },
    {
      "type": "html",
      "text": "\nEven this is really a folded version of a pair of types, one of which represents <i>the</i> point (x, y), the other <i>a</i> point (x, y). We fold them together because C++ makes it so much cheaper and easier than putting \"the\" objects on the heap, and implementing \"a\" objects as references thereon (IIRC, this is the behaviour (though not necessarily implementation) Scheme defines for integers: as though an integer is a <i>reference</i> to <i>the</i> value encoded). The latter approach, I suspect, is a potential reason to argue that [[Value Objects Require Garbage Collection]]. -- [[Stuart Olsen]]",
      "id": "fef22aa1e42f1c4235a1e036f0176a21"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6d1c31648f69f5ba51c39928b63aea17"
    },
    {
      "type": "html",
      "text": "In C++, creating a [[Value Object]] is almost trivial. For example:",
      "id": "5af3f5c00ce2cf46c6457040c6907646"
    },
    {
      "type": "html",
      "text": "\nclass Point {",
      "id": "387ac62dd6ece63fd46b7ee656b26ec7"
    },
    {
      "type": "code",
      "text": "  public:\n  Point( int x, int y ): _x(x), _y(y) {}",
      "id": "209d89070919086b96092bd68f6bd655"
    },
    {
      "type": "code",
      "text": "  int getX() const { return _x; }\n  int getY() const { return _y; }\n  void setX( int x ) { _x = x; }\n  void setY( int y ) { _y = y; }",
      "id": "8aef91aaee756f4d528265512052e033"
    },
    {
      "type": "code",
      "text": "  private:\n  int _x;\n  int _y;\n  }",
      "id": "f5666eba75a0e5d79f8605ab0b3239ad"
    },
    {
      "type": "html",
      "text": "\nNow you can declare both mutable and immutable Point objects:",
      "id": "9a71c7de12927d306d011bce28e61e58"
    },
    {
      "type": "code",
      "text": " Point aMutablePoint( 4, 10 );\n const Point anImmutablePoint( 5, 5 );",
      "id": "9b0ce398296284992034f0a9289bba0e"
    },
    {
      "type": "html",
      "text": "\nThe compiler will not allow you to call setX() or setY() on anImmutablePoint, since they are not declared as const methods.",
      "id": "76469e465e48454c752a010d66d310ca"
    },
    {
      "type": "html",
      "text": "\nOf course, you can get around this if you really want to:",
      "id": "d0cd71d824979ca902cc803f1391f22f"
    },
    {
      "type": "html",
      "text": "((Point) anImmutablePoint). setX( 7 );",
      "id": "48c6dd6f4f6fe5c9c94cd0914033cc68"
    },
    {
      "type": "html",
      "text": "\nbut this is cheating - akin to writing self-modifying code.",
      "id": "747c46800a25590425c4a9a3201fb78d"
    },
    {
      "type": "html",
      "text": "-- [[Russell Gold]]\t",
      "id": "e70965f1f96d67e0586a8dbcfffce926"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6d1c31648f69f5ba51c39928b63aea17"
    },
    {
      "type": "html",
      "text": "You need to be aware of the difference between logical state and physical state. Sometimes, what [[Russell Gold]] calls \"cheating\" above is due to this difference.",
      "id": "1d3b706053abde83917f58416db30f4e"
    },
    {
      "type": "html",
      "text": "\n[[Logical State]] is when the externally visible behaviour of an object depends on its history. [[Physical State]] is about its implementation. For example, updating a cache usually means a change in the physical state but not the logical state. ",
      "id": "0b1db225a73aaf50b1e1a939eab3b126"
    },
    {
      "type": "html",
      "text": "\nOptimizers are usually interested in implementations and the physical state. For example, to store a value object in [[Read Only Memory]], its physical state needs to be immutable. Programmers are usually interested in interfaces and logical state. They want to be free to change implementation state, introduce caches etc. This can invalidate the assumptions the optimizer makes.",
      "id": "ba61e05c616a67bc692bbc9ac0c6538c"
    },
    {
      "type": "html",
      "text": "\nThus in the context of [[Value Object]](s), these two forces are present and in conflict. Care may be needed to balance their requirements. (Modern C++ has extra language features to help, including",
      "id": "a25fe007f0e6dfe0b7e991ce1759e8b0"
    },
    {
      "type": "html",
      "text": "<i>const</i>,",
      "id": "95cdd8c6815e6f897d61fe7130d4fa53"
    },
    {
      "type": "html",
      "text": "<i>mutable</i>,",
      "id": "3229595cc83f3b577813de71c7b14831"
    },
    {
      "type": "html",
      "text": "<i><const cast></i>)",
      "id": "bf6d6b5ee2c895e445c0e49d46cc2fee"
    },
    {
      "type": "html",
      "text": "-- [[Dave Harris]]",
      "id": "f63099f9c083503d4af69f191d237ad5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6d1c31648f69f5ba51c39928b63aea17"
    },
    {
      "type": "html",
      "text": "Given that",
      "id": "c8668621d9ab6d44007ff13fe5a7437f"
    },
    {
      "type": "html",
      "text": " [[Value Objects Should Be Immutable]], and that",
      "id": "1385c1793f019933607989733a9236a1"
    },
    {
      "type": "html",
      "text": " [[Value Objects Should Be Side Effect Free]] (i.e. all non-constructor methods are queries or accessors)",
      "id": "04c3b5f5cf7abb5a039f423beee08665"
    },
    {
      "type": "html",
      "text": "... [[Value Object]]s become particularly amenable to processing with [[Pipes And Filters]]-style architecture (since ordering of processing becomes irrelevant).",
      "id": "2c982ea4e20610158ee621e438f4e30f"
    },
    {
      "type": "html",
      "text": "--",
      "id": "faa7bd40654d1fed5be9badecfe52eeb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6d1c31648f69f5ba51c39928b63aea17"
    },
    {
      "type": "html",
      "text": "Sometimes you have too many arguments for a [[Single Step Constructor]] to be convenient. Then you may have a 2-phase object: it's mutable during the set-up processes, but then becomes immutable once it is complete. Or you have set-once variables. Thus:",
      "id": "16229135fdd3cb7d1ce2e5b18c4c6cfb"
    },
    {
      "type": "code",
      "text": "  void synchronized setTarget( Point target ) {\n    Assert.assert( this.target == null );\n    Assert.assert( target != null );\n    this.target = target;\n  }",
      "id": "5d016fa64692c3fb4349d95527c79345"
    },
    {
      "type": "html",
      "text": "This falls short of a full [[Value Object]] but has many of the advantages. -- [[Dave Harris]]",
      "id": "8eb151d76ebd3d2fd1d0483828d86321"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6d1c31648f69f5ba51c39928b63aea17"
    },
    {
      "type": "html",
      "text": "\nIf I had too many arguments for a single constructor call, I would create a 'warehouse' object and pass that to my object's constructor. I can even modify the warehouse object (which is mutable) incrementally and when it's just right, pass it to my object, which sets its own state within its constructor, so it can still be const. (This is related to [[Memento Pattern]], except the memento is created from scratch, rather than from an existing object). Anyone else [[Have This Pattern]]? (I've <i>wanted</i> to say that!) -- [[Joshua Juran]]",
      "id": "923ee5825ec05faec07b5617b3a916f1"
    },
    {
      "type": "html",
      "text": "\nSuch an object is called an [[Essence Object]].",
      "id": "9cb0719fc538c7f869a6ebd192816f5a"
    },
    {
      "type": "html",
      "text": "<i>Kinda sounds like a [[Builder Pattern]]. -- [[Craig Putnam]]</i>",
      "id": "88a239887ec650e60dad533b9a3a5ed0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6d1c31648f69f5ba51c39928b63aea17"
    },
    {
      "type": "html",
      "text": "<b>Here are some examples of value object classes:</b>",
      "id": "d8a3ed5a47a54e5e590acbdf3469d18b"
    },
    {
      "type": "html",
      "text": " The elements of the periodic table. (Atomic number, atomic mass, group and so on  shouldn't change over time.)",
      "id": "9474c023e67f081d22b5f47899667772"
    },
    {
      "type": "html",
      "text": " The instances of a class that represents a www client request.",
      "id": "b063d0da3679ad4b493e53cdb61f3773"
    },
    {
      "type": "html",
      "text": " The direct instances of classes that model enumerated types.",
      "id": "909e663558623d4b96f8f530783aff12"
    },
    {
      "type": "html",
      "text": "<b>There is an interesting proposal for immutable value classes in Java</b>:\n[http://java.sun.com/people/jag/FP.html#classes java.sun.com]",
      "id": "288b233a121551b480a0f2b0e574ebc8"
    },
    {
      "type": "html",
      "text": "--",
      "id": "faa7bd40654d1fed5be9badecfe52eeb"
    },
    {
      "type": "html",
      "text": "\nIn Java, hashcode of [[Value Object]] must be calculated only once and then reused.  <i>(Or, more accurately, if equals() returns true for two objects, then the result of hashCode() must be the same for each.  You can calculate the value as much as you want as long as that rule is upheld.)</i>",
      "id": "1b76372abc0e478836def7927d6fdbe7"
    },
    {
      "type": "html",
      "text": "-- [[Kirill Stepanosov]]",
      "id": "e78775173ca38f6ac6a2f89cd268164c"
    },
    {
      "type": "html",
      "text": "\nI have a couple of nice (IMHO) base classes for c++ that wrap a pointer to create a concrete object that has either value- or reference- semantics: [http://www.geocities.com/dave_whipp/manage.html www.geocities.com] ",
      "id": "b281fe4eeea6c2eb198cef39d2553709"
    },
    {
      "type": "html",
      "text": "<i>([[Broken Link]], available instead at [http://web.archive.org/web/20091025210910/http://geocities.com/dave_whipp/manage.html web.archive.org] )</i>",
      "id": "fa0c276b472d176d71839e3c0aa7bc8c"
    },
    {
      "type": "html",
      "text": "\nSee also: ",
      "id": "a67a415308081e67edf8883217d9c06d"
    },
    {
      "type": "html",
      "text": "[[Separate Transaction Processing From Archival]] ",
      "id": "2e2f30b14d3cd77ee9b62e29d168b745"
    },
    {
      "type": "html",
      "text": "[http://wiki.cs.uiuc.edu/cs497rej/Value+Object wiki.cs.uiuc.edu]",
      "id": "252e3c0ba529e1e9bc55de2fd2f0ea6a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6d1c31648f69f5ba51c39928b63aea17"
    },
    {
      "type": "html",
      "text": "\nSun uses the term [[Value Object]] to refer to a local cache of instance variables from a remote object. Perhaps a better name for their pattern would be [[Remote Values Cache]] or something similar.",
      "id": "062210e3ffd9102208ae909d78e012af"
    },
    {
      "type": "html",
      "text": " [http://java.sun.com/j2ee/blueprints/design_patterns/value_object/ java.sun.com]",
      "id": "9b46eaa96ac4eca5943ea5763b752c05"
    },
    {
      "type": "html",
      "text": "<i>More like a portable version of the heavy server-side object.</i> -- [[Geraldo Xexeo]]",
      "id": "225bc0bce3f23d0ab997e3d8b0b34c5a"
    },
    {
      "type": "html",
      "text": "\nHehe, looks like they *did* change the name:",
      "id": "e4356437c5bf75b4f8d2a5f07ec3f37b"
    },
    {
      "type": "html",
      "text": " [http://java.sun.com/blueprints/patterns/TransferObject.html java.sun.com]",
      "id": "fc8b47966df36b43f2861c86a6f9e68a"
    },
    {
      "type": "html",
      "text": "(now I have to go and rename all of my [[Value Object]]s, I guess ...) -- [[Mike Colbert]]",
      "id": "0ba83ecd4947f18e7f3868b171d5e591"
    },
    {
      "type": "html",
      "text": "\nsee [[Data Transfer Object]] -- [[Ben Arnold]]",
      "id": "97fa21079a15463df70283801781fb73"
    },
    {
      "type": "html",
      "text": "\nOne of the [[Object Object]]s",
      "id": "755fc5e0a17e1bc46017661735eed587"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6d1c31648f69f5ba51c39928b63aea17"
    },
    {
      "type": "html",
      "text": "There is a very insightful lecture on this topic by Rich Hickey (creator of Clojure) titled 'The Value of Values':\n[http://www.infoq.com/presentations/Value-Values www.infoq.com]",
      "id": "788f8edb09695f894200cba22dda9369"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "6d1c31648f69f5ba51c39928b63aea17"
    },
    {
      "type": "html",
      "text": "[[Category Object Functional Patterns]]",
      "id": "b36c92ae65428d75432f9e560c58c1e9"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ValueObject c2.com]",
      "id": "0a755e6161c9aa25d90b2433673bafa7"
    }
  ],
  "journal": [
    {
      "date": 1391935301000,
      "id": "ed4e5c796858bc58576b2141f075bf88",
      "type": "create",
      "item": {
        "title": "Value Object",
        "story": [
          {
            "type": "html",
            "text": "See also: [[Value Object Hypotheses]], [[Value Objects Can Be Mutable]], [[Value Objects Should Be Immutable]], [[Value Objects Should Be Passed By Value]], [[Value Object Framework]], [[Java Value]], [[Value Object Literature]], [[Proto Value]]",
            "id": "b669afabc2255b786fc0167d20b88ea2"
          },
          {
            "type": "html",
            "text": "\nExamples of value objects are things like numbers, dates, monies and strings. Usually, they are small objects which are used quite widely. Their identity is based on their state rather than on their object identity. This way, you can have multiple copies of the same conceptual value object. <i>Every $5 note has its own identity (thanks to its serial number), but the cash economy relies on every $5 note having the same value as every other $5 note.</i>",
            "id": "5ca53474f8807492213ed552f8c9b755"
          },
          {
            "type": "html",
            "text": "\nSo I can have multiple copies of an object that represents the date 16 Jan 1998. Any of these copies will be equal to each other. For a small object such as this, it is often easier to create new ones and move them around rather than rely on a single object to represent the date.",
            "id": "a2afac4f05599c5fee40b91124e520ec"
          },
          {
            "type": "html",
            "text": "\nA value object should always override .equals() in Java (or = in Smalltalk). (Remember to override .hashCode() as well.)",
            "id": "d7925cea83dd7c6b14ac207a9b0b091b"
          },
          {
            "type": "html",
            "text": "\nA value object is not a [[Business Object]]/[[Reference Object]].\nA [[Business Object]]/[[Reference Object]] is something you find in the world, while a [[Value Object]] is a measure or description of something.",
            "id": "ad9aa61e48bb0a494a93f6dd7f821560"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6d1c31648f69f5ba51c39928b63aea17"
          },
          {
            "type": "html",
            "text": "\n[http://www.riehle.org/computer-science/research/1998/ubilab-tr-1998-10-1.html www.riehle.org] presents an in-depth discussion of why and where you want value objects and how to implement them efficiently in different languages.",
            "id": "1404912f8b192aa64484654a59336dcc"
          },
          {
            "type": "html",
            "text": "\nChapter 9 of [[Functional Pattern System For Object Oriented Design]] describes [[Value Object]].",
            "id": "16460a85d7d77000105a7890fc6a5d31"
          },
          {
            "type": "html",
            "text": "\nI haven't read it yet, but there is an article on [[Value Object]](s) in the July/August 1998 issue of the [[Journal Of Object Oriented Programming]]. It is 'Values and Objects Revisited' by [[Peter Van Der Werf]]. -- [[Michael Feathers]]",
            "id": "95ed5d6bfc596f3ff33ce67b1fd21c8c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6d1c31648f69f5ba51c39928b63aea17"
          },
          {
            "type": "html",
            "text": "Someone good with C++ can explain what to do with that language for value objects.",
            "id": "374330bd7416e48637bd4165183de930"
          },
          {
            "type": "html",
            "text": "\n[[Value Objects Should Be Immutable]]",
            "id": "e2e604f49c77bd6a465a76bef5e9f89e"
          },
          {
            "type": "html",
            "text": "\nCompare this with a [[Reference Object]].",
            "id": "1cba8e2a8e769fe01b32998c5f4f6337"
          },
          {
            "type": "html",
            "text": "-- [[Martin Fowler]]",
            "id": "815333f22e2ae51bdb74780431bca8f6"
          },
          {
            "type": "html",
            "text": "<i>Comment: In C++, you typically implement value objects using reference-counted copy-on-write classes (body/handle idiom). [[Jim Coplien]] explains this idiom well in his book on Advanced C++. Otherwise, see our technical report. -- [[Dirk Riehle]]</i>",
            "id": "b959294acad96f646b92b4e4ca362ff3"
          },
          {
            "type": "html",
            "text": "\nIf the definition of value object is an object whose identity is defined by its state rather than by its address, I'm inclined to think that they are defined in C++ as objects that override the copy constructor, assignment and comparison operators to assign and compare state between two objects. Overriding the assignment operator is key and means that in C++ [[Value Objects Can Be Mutable]] and usually are. The aliasing problems addressed in [[Value Objects Should Be Immutable]] are generally taken care of by using pass-by-value semantics. -- [[Phil Goodwin]] ",
            "id": "7c7442c10937edd1f38402af8e76ae96"
          },
          {
            "type": "html",
            "text": "\nI think there's a useful distinction to be drawn between assignment and mutation in general, especially in C++. Say you have a plain old int, \"i,\" whose value is five. This object is mutable in the sense that, yes, you can change it. But <i>what</i> you're changing is not <i>the</i> value, but <i>which</i> value. In other words, if I assign a value of ten to \"i,\" I'm not effecting any mutation upon the value \"five;\" I'm <i>replacing</i> the value \"five.\" Such is the general case with value types in C++. In some sense, assignment for a value type on which assignment is the only \"mutating\" operation can be thought of as a shorthand for a manual destructor call followed by a placement new. Borrowing from the \"Point\" example below, modulo stylistic choices:",
            "id": "36cb0523a3eab411e25b40c8a397abda"
          },
          {
            "type": "code",
            "text": "    struct point {\n      const int x;\n      const int y;",
            "id": "014cbb00a4e1d1036e5495ea783d82e7"
          },
          {
            "type": "code",
            "text": "      point (const point&) = default;",
            "id": "764f30a9ee30594cdd883657ebd729a5"
          },
          {
            "type": "code",
            "text": "      point& operator = (const point& other) {\n        this->~point ();\n        return *new (this) point (other);\n      }\n    };",
            "id": "3836192a0821a6180d9f232bf72abc94"
          },
          {
            "type": "html",
            "text": "\nEven this is really a folded version of a pair of types, one of which represents <i>the</i> point (x, y), the other <i>a</i> point (x, y). We fold them together because C++ makes it so much cheaper and easier than putting \"the\" objects on the heap, and implementing \"a\" objects as references thereon (IIRC, this is the behaviour (though not necessarily implementation) Scheme defines for integers: as though an integer is a <i>reference</i> to <i>the</i> value encoded). The latter approach, I suspect, is a potential reason to argue that [[Value Objects Require Garbage Collection]]. -- [[Stuart Olsen]]",
            "id": "fef22aa1e42f1c4235a1e036f0176a21"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6d1c31648f69f5ba51c39928b63aea17"
          },
          {
            "type": "html",
            "text": "In C++, creating a [[Value Object]] is almost trivial. For example:",
            "id": "5af3f5c00ce2cf46c6457040c6907646"
          },
          {
            "type": "html",
            "text": "\nclass Point {",
            "id": "387ac62dd6ece63fd46b7ee656b26ec7"
          },
          {
            "type": "code",
            "text": "  public:\n  Point( int x, int y ): _x(x), _y(y) {}",
            "id": "209d89070919086b96092bd68f6bd655"
          },
          {
            "type": "code",
            "text": "  int getX() const { return _x; }\n  int getY() const { return _y; }\n  void setX( int x ) { _x = x; }\n  void setY( int y ) { _y = y; }",
            "id": "8aef91aaee756f4d528265512052e033"
          },
          {
            "type": "code",
            "text": "  private:\n  int _x;\n  int _y;\n  }",
            "id": "f5666eba75a0e5d79f8605ab0b3239ad"
          },
          {
            "type": "html",
            "text": "\nNow you can declare both mutable and immutable Point objects:",
            "id": "9a71c7de12927d306d011bce28e61e58"
          },
          {
            "type": "code",
            "text": " Point aMutablePoint( 4, 10 );\n const Point anImmutablePoint( 5, 5 );",
            "id": "9b0ce398296284992034f0a9289bba0e"
          },
          {
            "type": "html",
            "text": "\nThe compiler will not allow you to call setX() or setY() on anImmutablePoint, since they are not declared as const methods.",
            "id": "76469e465e48454c752a010d66d310ca"
          },
          {
            "type": "html",
            "text": "\nOf course, you can get around this if you really want to:",
            "id": "d0cd71d824979ca902cc803f1391f22f"
          },
          {
            "type": "html",
            "text": "((Point) anImmutablePoint). setX( 7 );",
            "id": "48c6dd6f4f6fe5c9c94cd0914033cc68"
          },
          {
            "type": "html",
            "text": "\nbut this is cheating - akin to writing self-modifying code.",
            "id": "747c46800a25590425c4a9a3201fb78d"
          },
          {
            "type": "html",
            "text": "-- [[Russell Gold]]\t",
            "id": "e70965f1f96d67e0586a8dbcfffce926"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6d1c31648f69f5ba51c39928b63aea17"
          },
          {
            "type": "html",
            "text": "You need to be aware of the difference between logical state and physical state. Sometimes, what [[Russell Gold]] calls \"cheating\" above is due to this difference.",
            "id": "1d3b706053abde83917f58416db30f4e"
          },
          {
            "type": "html",
            "text": "\n[[Logical State]] is when the externally visible behaviour of an object depends on its history. [[Physical State]] is about its implementation. For example, updating a cache usually means a change in the physical state but not the logical state. ",
            "id": "0b1db225a73aaf50b1e1a939eab3b126"
          },
          {
            "type": "html",
            "text": "\nOptimizers are usually interested in implementations and the physical state. For example, to store a value object in [[Read Only Memory]], its physical state needs to be immutable. Programmers are usually interested in interfaces and logical state. They want to be free to change implementation state, introduce caches etc. This can invalidate the assumptions the optimizer makes.",
            "id": "ba61e05c616a67bc692bbc9ac0c6538c"
          },
          {
            "type": "html",
            "text": "\nThus in the context of [[Value Object]](s), these two forces are present and in conflict. Care may be needed to balance their requirements. (Modern C++ has extra language features to help, including",
            "id": "a25fe007f0e6dfe0b7e991ce1759e8b0"
          },
          {
            "type": "html",
            "text": "<i>const</i>,",
            "id": "95cdd8c6815e6f897d61fe7130d4fa53"
          },
          {
            "type": "html",
            "text": "<i>mutable</i>,",
            "id": "3229595cc83f3b577813de71c7b14831"
          },
          {
            "type": "html",
            "text": "<i><const cast></i>)",
            "id": "bf6d6b5ee2c895e445c0e49d46cc2fee"
          },
          {
            "type": "html",
            "text": "-- [[Dave Harris]]",
            "id": "f63099f9c083503d4af69f191d237ad5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6d1c31648f69f5ba51c39928b63aea17"
          },
          {
            "type": "html",
            "text": "Given that",
            "id": "c8668621d9ab6d44007ff13fe5a7437f"
          },
          {
            "type": "html",
            "text": " [[Value Objects Should Be Immutable]], and that",
            "id": "1385c1793f019933607989733a9236a1"
          },
          {
            "type": "html",
            "text": " [[Value Objects Should Be Side Effect Free]] (i.e. all non-constructor methods are queries or accessors)",
            "id": "04c3b5f5cf7abb5a039f423beee08665"
          },
          {
            "type": "html",
            "text": "... [[Value Object]]s become particularly amenable to processing with [[Pipes And Filters]]-style architecture (since ordering of processing becomes irrelevant).",
            "id": "2c982ea4e20610158ee621e438f4e30f"
          },
          {
            "type": "html",
            "text": "--",
            "id": "faa7bd40654d1fed5be9badecfe52eeb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6d1c31648f69f5ba51c39928b63aea17"
          },
          {
            "type": "html",
            "text": "Sometimes you have too many arguments for a [[Single Step Constructor]] to be convenient. Then you may have a 2-phase object: it's mutable during the set-up processes, but then becomes immutable once it is complete. Or you have set-once variables. Thus:",
            "id": "16229135fdd3cb7d1ce2e5b18c4c6cfb"
          },
          {
            "type": "code",
            "text": "  void synchronized setTarget( Point target ) {\n    Assert.assert( this.target == null );\n    Assert.assert( target != null );\n    this.target = target;\n  }",
            "id": "5d016fa64692c3fb4349d95527c79345"
          },
          {
            "type": "html",
            "text": "This falls short of a full [[Value Object]] but has many of the advantages. -- [[Dave Harris]]",
            "id": "8eb151d76ebd3d2fd1d0483828d86321"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6d1c31648f69f5ba51c39928b63aea17"
          },
          {
            "type": "html",
            "text": "\nIf I had too many arguments for a single constructor call, I would create a 'warehouse' object and pass that to my object's constructor. I can even modify the warehouse object (which is mutable) incrementally and when it's just right, pass it to my object, which sets its own state within its constructor, so it can still be const. (This is related to [[Memento Pattern]], except the memento is created from scratch, rather than from an existing object). Anyone else [[Have This Pattern]]? (I've <i>wanted</i> to say that!) -- [[Joshua Juran]]",
            "id": "923ee5825ec05faec07b5617b3a916f1"
          },
          {
            "type": "html",
            "text": "\nSuch an object is called an [[Essence Object]].",
            "id": "9cb0719fc538c7f869a6ebd192816f5a"
          },
          {
            "type": "html",
            "text": "<i>Kinda sounds like a [[Builder Pattern]]. -- [[Craig Putnam]]</i>",
            "id": "88a239887ec650e60dad533b9a3a5ed0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6d1c31648f69f5ba51c39928b63aea17"
          },
          {
            "type": "html",
            "text": "<b>Here are some examples of value object classes:</b>",
            "id": "d8a3ed5a47a54e5e590acbdf3469d18b"
          },
          {
            "type": "html",
            "text": " The elements of the periodic table. (Atomic number, atomic mass, group and so on  shouldn't change over time.)",
            "id": "9474c023e67f081d22b5f47899667772"
          },
          {
            "type": "html",
            "text": " The instances of a class that represents a www client request.",
            "id": "b063d0da3679ad4b493e53cdb61f3773"
          },
          {
            "type": "html",
            "text": " The direct instances of classes that model enumerated types.",
            "id": "909e663558623d4b96f8f530783aff12"
          },
          {
            "type": "html",
            "text": "<b>There is an interesting proposal for immutable value classes in Java</b>:\n[http://java.sun.com/people/jag/FP.html#classes java.sun.com]",
            "id": "288b233a121551b480a0f2b0e574ebc8"
          },
          {
            "type": "html",
            "text": "--",
            "id": "faa7bd40654d1fed5be9badecfe52eeb"
          },
          {
            "type": "html",
            "text": "\nIn Java, hashcode of [[Value Object]] must be calculated only once and then reused.  <i>(Or, more accurately, if equals() returns true for two objects, then the result of hashCode() must be the same for each.  You can calculate the value as much as you want as long as that rule is upheld.)</i>",
            "id": "1b76372abc0e478836def7927d6fdbe7"
          },
          {
            "type": "html",
            "text": "-- [[Kirill Stepanosov]]",
            "id": "e78775173ca38f6ac6a2f89cd268164c"
          },
          {
            "type": "html",
            "text": "\nI have a couple of nice (IMHO) base classes for c++ that wrap a pointer to create a concrete object that has either value- or reference- semantics: [http://www.geocities.com/dave_whipp/manage.html www.geocities.com] ",
            "id": "b281fe4eeea6c2eb198cef39d2553709"
          },
          {
            "type": "html",
            "text": "<i>([[Broken Link]], available instead at [http://web.archive.org/web/20091025210910/http://geocities.com/dave_whipp/manage.html web.archive.org] )</i>",
            "id": "fa0c276b472d176d71839e3c0aa7bc8c"
          },
          {
            "type": "html",
            "text": "\nSee also: ",
            "id": "a67a415308081e67edf8883217d9c06d"
          },
          {
            "type": "html",
            "text": "[[Separate Transaction Processing From Archival]] ",
            "id": "2e2f30b14d3cd77ee9b62e29d168b745"
          },
          {
            "type": "html",
            "text": "[http://wiki.cs.uiuc.edu/cs497rej/Value+Object wiki.cs.uiuc.edu]",
            "id": "252e3c0ba529e1e9bc55de2fd2f0ea6a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6d1c31648f69f5ba51c39928b63aea17"
          },
          {
            "type": "html",
            "text": "\nSun uses the term [[Value Object]] to refer to a local cache of instance variables from a remote object. Perhaps a better name for their pattern would be [[Remote Values Cache]] or something similar.",
            "id": "062210e3ffd9102208ae909d78e012af"
          },
          {
            "type": "html",
            "text": " [http://java.sun.com/j2ee/blueprints/design_patterns/value_object/ java.sun.com]",
            "id": "9b46eaa96ac4eca5943ea5763b752c05"
          },
          {
            "type": "html",
            "text": "<i>More like a portable version of the heavy server-side object.</i> -- [[Geraldo Xexeo]]",
            "id": "225bc0bce3f23d0ab997e3d8b0b34c5a"
          },
          {
            "type": "html",
            "text": "\nHehe, looks like they *did* change the name:",
            "id": "e4356437c5bf75b4f8d2a5f07ec3f37b"
          },
          {
            "type": "html",
            "text": " [http://java.sun.com/blueprints/patterns/TransferObject.html java.sun.com]",
            "id": "fc8b47966df36b43f2861c86a6f9e68a"
          },
          {
            "type": "html",
            "text": "(now I have to go and rename all of my [[Value Object]]s, I guess ...) -- [[Mike Colbert]]",
            "id": "0ba83ecd4947f18e7f3868b171d5e591"
          },
          {
            "type": "html",
            "text": "\nsee [[Data Transfer Object]] -- [[Ben Arnold]]",
            "id": "97fa21079a15463df70283801781fb73"
          },
          {
            "type": "html",
            "text": "\nOne of the [[Object Object]]s",
            "id": "755fc5e0a17e1bc46017661735eed587"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6d1c31648f69f5ba51c39928b63aea17"
          },
          {
            "type": "html",
            "text": "There is a very insightful lecture on this topic by Rich Hickey (creator of Clojure) titled 'The Value of Values':\n[http://www.infoq.com/presentations/Value-Values www.infoq.com]",
            "id": "788f8edb09695f894200cba22dda9369"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "6d1c31648f69f5ba51c39928b63aea17"
          },
          {
            "type": "html",
            "text": "[[Category Object Functional Patterns]]",
            "id": "b36c92ae65428d75432f9e560c58c1e9"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ValueObject c2.com]",
            "id": "0a755e6161c9aa25d90b2433673bafa7"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1628376607464
    }
  ]
}