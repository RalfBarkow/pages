{
  "title": "VM and Compiler",
  "story": [
    {
      "type": "markdown",
      "id": "3c7fc8d8571474ee",
      "text": "The VM has an interpreter, it will work fine (and much more memory-efficient) without loading a compiler. The compiler plugs into the VM by providing the `Squeak.Compiler` global. It can be easily replaced by just loading a different script providing `Squeak.Compiler`. [https://raw.githubusercontent.com/codefrau/SqueakJS/main/jit.js raw.githubusercontent]"
    },
    {
      "type": "markdown",
      "id": "169916c018284e39",
      "text": "The VM creates the compiler instance after an image has been loaded and the VM been initialized. Whenever a method is activated that was not compiled yet, the compiler gets a chance to compile it. The compiler may decide to wait for a couple of activations before actually compiling it. This might prevent do-its from ever getting compiled, because they are only activated once. Therefore, the compiler is also called when a long-running non-optimized loop calls `checkForInterrupts`.\nFinally, whenever the interpreter is about to execute a bytecode, it calls the compiled method instead (which typically will execute many bytecodes):"
    },
    {
      "type": "code",
      "id": "71f02769b27eb64f",
      "text": "    initialize:\n        compiler = new Squeak.Compiler(vm);\n\n    executeNewMethod, checkForInterrupts:\n        if (!method.compiled && compiler)\n            compiler.compile(method);\n\n    interpret:\n        if (method.compiled) method.compiled(vm);"
    },
    {
      "type": "markdown",
      "id": "58d16399de2458e6",
      "text": "Note that a compiler could hook itself into a compiled method by dispatching to `vm.compiler` in the generated code. This would allow gathering statistics, recompiling with optimized code etc."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "VM and Compiler",
        "story": []
      },
      "date": 1644566635078
    },
    {
      "id": "3c7fc8d8571474ee",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "3c7fc8d8571474ee",
        "text": "The VM has an interpreter, it will work fine (and much more memory-efficient)\nwithout loading a compiler. The compiler plugs into the VM by providing the\nSqueak.Compiler global. It can be easily replaced by just loading a different\nscript providing Squeak.Compiler.\n\nThe VM creates the compiler instance after an image has been loaded and the VM\nbeen initialized. Whenever a method is activated that was not compiled yet, the\ncompiler gets a chance to compile it. The compiler may decide to wait for a couple\nof activations before actually compiling it. This might prevent do-its from ever\ngetting compiled, because they are only activated once. Therefore, the compiler\nis also called when a long-running non-optimized loop calls checkForInterrupts.\nFinally, whenever the interpreter is about to execute a bytecode, it calls the\ncompiled method instead (which typically will execute many bytecodes):\n\n    initialize:\n        compiler = new Squeak.Compiler(vm);\n\n    executeNewMethod, checkForInterrupts:\n        if (!method.compiled && compiler)\n            compiler.compile(method);\n\n    interpret:\n        if (method.compiled) method.compiled(vm);\n\nNote that a compiler could hook itself into a compiled method by dispatching\nto vm.compiler in the generated code. This would allow gathering statistics,\nrecompiling with optimized code etc."
      },
      "date": 1644566639974
    },
    {
      "type": "edit",
      "id": "3c7fc8d8571474ee",
      "item": {
        "type": "paragraph",
        "id": "3c7fc8d8571474ee",
        "text": "The VM has an interpreter, it will work fine (and much more memory-efficient) without loading a compiler. The compiler plugs into the VM by providing the Squeak.Compiler global. It can be easily replaced by just loading a different\nscript providing Squeak.Compiler."
      },
      "date": 1644566678283
    },
    {
      "type": "add",
      "id": "169916c018284e39",
      "item": {
        "type": "paragraph",
        "id": "169916c018284e39",
        "text": "\nThe VM creates the compiler instance after an image has been loaded and the VM\nbeen initialized. Whenever a method is activated that was not compiled yet, the\ncompiler gets a chance to compile it. The compiler may decide to wait for a couple\nof activations before actually compiling it. This might prevent do-its from ever\ngetting compiled, because they are only activated once. Therefore, the compiler\nis also called when a long-running non-optimized loop calls checkForInterrupts.\nFinally, whenever the interpreter is about to execute a bytecode, it calls the\ncompiled method instead (which typically will execute many bytecodes):\n\n    initialize:\n        compiler = new Squeak.Compiler(vm);\n\n    executeNewMethod, checkForInterrupts:\n        if (!method.compiled && compiler)\n            compiler.compile(method);\n\n    interpret:\n        if (method.compiled) method.compiled(vm);\n\nNote that a compiler could hook itself into a compiled method by dispatching\nto vm.compiler in the generated code. This would allow gathering statistics,\nrecompiling with optimized code etc."
      },
      "after": "3c7fc8d8571474ee",
      "date": 1644566681190
    },
    {
      "type": "edit",
      "id": "3c7fc8d8571474ee",
      "item": {
        "type": "paragraph",
        "id": "3c7fc8d8571474ee",
        "text": "The VM has an interpreter, it will work fine (and much more memory-efficient) without loading a compiler. The compiler plugs into the VM by providing the Squeak.Compiler global. It can be easily replaced by just loading a different\nscript providing Squeak.Compiler. [https://raw.githubusercontent.com/codefrau/SqueakJS/main/jit.js raw.githubusercontent]"
      },
      "date": 1644566702036
    },
    {
      "type": "edit",
      "id": "3c7fc8d8571474ee",
      "item": {
        "type": "paragraph",
        "id": "3c7fc8d8571474ee",
        "text": "The VM has an interpreter, it will work fine (and much more memory-efficient) without loading a compiler. The compiler plugs into the VM by providing the `Squeak.Compiler` global. It can be easily replaced by just loading a different\nscript providing Squeak.Compiler. [https://raw.githubusercontent.com/codefrau/SqueakJS/main/jit.js raw.githubusercontent]"
      },
      "date": 1644566725973
    },
    {
      "type": "edit",
      "id": "3c7fc8d8571474ee",
      "item": {
        "type": "markdown",
        "id": "3c7fc8d8571474ee",
        "text": "The VM has an interpreter, it will work fine (and much more memory-efficient) without loading a compiler. The compiler plugs into the VM by providing the `Squeak.Compiler` global. It can be easily replaced by just loading a different\nscript providing Squeak.Compiler. [https://raw.githubusercontent.com/codefrau/SqueakJS/main/jit.js raw.githubusercontent]"
      },
      "date": 1644566726872
    },
    {
      "type": "edit",
      "id": "3c7fc8d8571474ee",
      "item": {
        "type": "markdown",
        "id": "3c7fc8d8571474ee",
        "text": "The VM has an interpreter, it will work fine (and much more memory-efficient) without loading a compiler. The compiler plugs into the VM by providing the `Squeak.Compiler` global. It can be easily replaced by just loading a different script providing Squeak.Compiler. [https://raw.githubusercontent.com/codefrau/SqueakJS/main/jit.js raw.githubusercontent]"
      },
      "date": 1644566739826
    },
    {
      "type": "edit",
      "id": "3c7fc8d8571474ee",
      "item": {
        "type": "markdown",
        "id": "3c7fc8d8571474ee",
        "text": "The VM has an interpreter, it will work fine (and much more memory-efficient) without loading a compiler. The compiler plugs into the VM by providing the `Squeak.Compiler` global. It can be easily replaced by just loading a different script providing `Squeak.Compiler`. [https://raw.githubusercontent.com/codefrau/SqueakJS/main/jit.js raw.githubusercontent]"
      },
      "date": 1644566767207
    },
    {
      "item": {
        "type": "factory",
        "id": "71f02769b27eb64f"
      },
      "id": "71f02769b27eb64f",
      "type": "add",
      "after": "169916c018284e39",
      "date": 1644566771800
    },
    {
      "type": "edit",
      "id": "169916c018284e39",
      "item": {
        "type": "paragraph",
        "id": "169916c018284e39",
        "text": "The VM creates the compiler instance after an image has been loaded and the VM\nbeen initialized. Whenever a method is activated that was not compiled yet, the\ncompiler gets a chance to compile it. The compiler may decide to wait for a couple\nof activations before actually compiling it. This might prevent do-its from ever\ngetting compiled, because they are only activated once. Therefore, the compiler\nis also called when a long-running non-optimized loop calls checkForInterrupts.\nFinally, whenever the interpreter is about to execute a bytecode, it calls the\ncompiled method instead (which typically will execute many bytecodes):\n\n    initialize:\n        compiler = new Squeak.Compiler(vm);\n\n    executeNewMethod, checkForInterrupts:\n        if (!method.compiled && compiler)\n            compiler.compile(method);\n\n    interpret:\n        if (method.compiled) method.compiled(vm);\n\nNote that a compiler could hook itself into a compiled method by dispatching\nto vm.compiler in the generated code. This would allow gathering statistics,\nrecompiling with optimized code etc."
      },
      "date": 1644566775502
    },
    {
      "type": "edit",
      "id": "169916c018284e39",
      "item": {
        "type": "paragraph",
        "id": "169916c018284e39",
        "text": "The VM creates the compiler instance after an image has been loaded and the VM\nbeen initialized. Whenever a method is activated that was not compiled yet, the\ncompiler gets a chance to compile it. The compiler may decide to wait for a couple\nof activations before actually compiling it. This might prevent do-its from ever\ngetting compiled, because they are only activated once. Therefore, the compiler\nis also called when a long-running non-optimized loop calls checkForInterrupts.\nFinally, whenever the interpreter is about to execute a bytecode, it calls the\ncompiled method instead (which typically will execute many bytecodes):\n\n\nNote that a compiler could hook itself into a compiled method by dispatching\nto vm.compiler in the generated code. This would allow gathering statistics,\nrecompiling with optimized code etc."
      },
      "date": 1644566787200
    },
    {
      "type": "edit",
      "id": "71f02769b27eb64f",
      "item": {
        "type": "code",
        "id": "71f02769b27eb64f",
        "text": "\n    initialize:\n        compiler = new Squeak.Compiler(vm);\n\n    executeNewMethod, checkForInterrupts:\n        if (!method.compiled && compiler)\n            compiler.compile(method);\n\n    interpret:\n        if (method.compiled) method.compiled(vm);"
      },
      "date": 1644566787948
    },
    {
      "type": "edit",
      "id": "169916c018284e39",
      "item": {
        "type": "paragraph",
        "id": "169916c018284e39",
        "text": "The VM creates the compiler instance after an image has been loaded and the VM\nbeen initialized. Whenever a method is activated that was not compiled yet, the\ncompiler gets a chance to compile it. The compiler may decide to wait for a couple\nof activations before actually compiling it. This might prevent do-its from ever\ngetting compiled, because they are only activated once. Therefore, the compiler\nis also called when a long-running non-optimized loop calls checkForInterrupts.\nFinally, whenever the interpreter is about to execute a bytecode, it calls the\ncompiled method instead (which typically will execute many bytecodes):"
      },
      "date": 1644566797503
    },
    {
      "type": "add",
      "id": "58d16399de2458e6",
      "item": {
        "type": "paragraph",
        "id": "58d16399de2458e6",
        "text": "\n\nNote that a compiler could hook itself into a compiled method by dispatching\nto vm.compiler in the generated code. This would allow gathering statistics,\nrecompiling with optimized code etc."
      },
      "after": "169916c018284e39",
      "date": 1644566798789
    },
    {
      "id": "71f02769b27eb64f",
      "type": "move",
      "order": [
        "3c7fc8d8571474ee",
        "169916c018284e39",
        "71f02769b27eb64f",
        "58d16399de2458e6"
      ],
      "date": 1644566800604
    },
    {
      "type": "edit",
      "id": "71f02769b27eb64f",
      "item": {
        "type": "code",
        "id": "71f02769b27eb64f",
        "text": "    initialize:\n        compiler = new Squeak.Compiler(vm);\n\n    executeNewMethod, checkForInterrupts:\n        if (!method.compiled && compiler)\n            compiler.compile(method);\n\n    interpret:\n        if (method.compiled) method.compiled(vm);"
      },
      "date": 1644566809547
    },
    {
      "type": "edit",
      "id": "169916c018284e39",
      "item": {
        "type": "paragraph",
        "id": "169916c018284e39",
        "text": "The VM creates the compiler instance after an image has been loaded and the VM been initialized. Whenever a method is activated that was not compiled yet, the compiler gets a chance to compile it. The compiler may decide to wait for a couple of activations before actually compiling it. This might prevent do-its from ever getting compiled, because they are only activated once. Therefore, the compiler is also called when a long-running non-optimized loop calls `checkForInterrupts`.\nFinally, whenever the interpreter is about to execute a bytecode, it calls the\ncompiled method instead (which typically will execute many bytecodes):d"
      },
      "date": 1644566865533
    },
    {
      "type": "edit",
      "id": "169916c018284e39",
      "item": {
        "type": "markdown",
        "id": "169916c018284e39",
        "text": "The VM creates the compiler instance after an image has been loaded and the VM been initialized. Whenever a method is activated that was not compiled yet, the compiler gets a chance to compile it. The compiler may decide to wait for a couple of activations before actually compiling it. This might prevent do-its from ever getting compiled, because they are only activated once. Therefore, the compiler is also called when a long-running non-optimized loop calls `checkForInterrupts`.\nFinally, whenever the interpreter is about to execute a bytecode, it calls the\ncompiled method instead (which typically will execute many bytecodes):d"
      },
      "date": 1644566867186
    },
    {
      "type": "edit",
      "id": "169916c018284e39",
      "item": {
        "type": "markdown",
        "id": "169916c018284e39",
        "text": "The VM creates the compiler instance after an image has been loaded and the VM been initialized. Whenever a method is activated that was not compiled yet, the compiler gets a chance to compile it. The compiler may decide to wait for a couple of activations before actually compiling it. This might prevent do-its from ever getting compiled, because they are only activated once. Therefore, the compiler is also called when a long-running non-optimized loop calls `checkForInterrupts`.\nFinally, whenever the interpreter is about to execute a bytecode, it calls the compiled method instead (which typically will execute many bytecodes):"
      },
      "date": 1644566889533
    },
    {
      "type": "edit",
      "id": "58d16399de2458e6",
      "item": {
        "type": "paragraph",
        "id": "58d16399de2458e6",
        "text": "Note that a compiler could hook itself into a compiled method by dispatching to `vm.compiler` in the generated code. This would allow gathering statistics, recompiling with optimized code etc."
      },
      "date": 1644566931404
    },
    {
      "type": "edit",
      "id": "58d16399de2458e6",
      "item": {
        "type": "markdown",
        "id": "58d16399de2458e6",
        "text": "Note that a compiler could hook itself into a compiled method by dispatching to `vm.compiler` in the generated code. This would allow gathering statistics, recompiling with optimized code etc."
      },
      "date": 1644566936113
    }
  ]
}