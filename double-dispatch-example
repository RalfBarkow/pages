{
  "title": "Double Dispatch Example",
  "story": [
    {
      "type": "html",
      "text": "[----\nA bunch of this should be removed!\nit is meant to be an example to the [[Double Dispatch]] discussion in other single dispatch languages. \nThe request was made by people who didn't understand the example there. \nIts not meant to describe how to handle the cartesian product \"printer X shapes\" problem specifically its meant to illustrate and explore \"doubledispatch\" as a concept.",
      "id": "000186a5a8709b9094c9285cf70c731a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "[ quoted from the page [[Double Dispatch]]] ",
      "id": "a603fd805095db6605f7c1544e58bc29"
    },
    {
      "type": "html",
      "text": "\nWe'll assume that the printers all have a common base class (APrinter), and the shapes also have a common base class (AShape).",
      "id": "71942072e6b6c59598ac93c4805c2a29"
    },
    {
      "type": "html",
      "text": "\nIn the simplest case, as you say, you extend the printer interface with a separate function per shape that it can render. Now, given some code where you have a printer object, and a shape object. But the code only knows the printer object to be of type APrinter (assuming a statically typed language), and the shape object to be of type AShape. How do you, or the compiler, know which printer method to call? That's the crux of the problem. You need to select the method based on the run-time types, not the static types, of two objects. ",
      "id": "1fb02679292ecf06abdfe5598121a7fe"
    },
    {
      "type": "html",
      "text": "\n[[Double Dispatch]] is a pattern for solving this problem in a typical OO language that can dispatch only on one object's type. It requires a bit of extra work by the programmer. ",
      "id": "24051220e702a2b61a6389457f63f46d"
    },
    {
      "type": "html",
      "text": "-- [[Dan Muller]]",
      "id": "c60062efe40f9d12bd702f1f8cdc1e98"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "]",
      "id": "559177f1e514de2cef3642d39a4bec3e"
    },
    {
      "type": "html",
      "text": "\nOn [[Double Dispatch]], someone said: <i>Would someone be willing to create a more verbose example? (hopefully in Java or C++)</i>",
      "id": "36df665c69ffb8835a210e86aad6f182"
    },
    {
      "type": "html",
      "text": "\nHere it is:",
      "id": "a8fcc77a88969ee54c5cee2819604b22"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "<b>Problem:</b>",
      "id": "036c7c1f06b5f56251f1c30c6b4b2214"
    },
    {
      "type": "html",
      "text": "\nAssume we are writing a print library. We want the client code of our library to be able to do something like this:",
      "id": "ff76e3b89fcb3ed9e731cf8c2791fc04"
    },
    {
      "type": "code",
      "text": " class Client {",
      "id": "360c5f254a7523c0ca92e3d12d2a3fe0"
    },
    {
      "type": "code",
      "text": "  /** Prints all figures on each of the printers. */\n  void printAllEverywhere( Figure[] figures, Printer[] printers ) {\n  for ( int i = 0; i < figures.length; i++ ) {\n  Figure figure = figures[ i ];\n  for ( int j = 0; j < printers.length; j++ ) {\n   Printer printer = printers[ j ];\n     \n   figure.printOn( printer ); \n   // must work for any printer or figure !\n  }\n  }\n  }\n }",
      "id": "ef1cfa074520d6793f2276f8d30a9623"
    },
    {
      "type": "html",
      "text": "Of course, when we add new printers or figures to our library, we want client code such as the above to immediately work with these new printers and figures, without a change in their code or even a recompile. How can we implement our library to allow this?",
      "id": "6b48ec0ffdd31f31d25f3c38ae711af4"
    },
    {
      "type": "html",
      "text": "\nAnother way to state this is that we need a [[Cartesian Product]] of drivers or methods of printer kinds and shape kinds.",
      "id": "e5569b4b8bb61aa9ae73ab172c5fe551"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "<b>Solution:</b>",
      "id": "f05ff83e39e1f2c5595d5896517e7516"
    },
    {
      "type": "html",
      "text": "\nFirst, we define two interfaces for our figures and printers:",
      "id": "452f10debc94cb05b2265f89fd8db6fb"
    },
    {
      "type": "code",
      "text": " interface Figure {\n  void printOn( Printer printer );\n }\n interface Printer {\n  void printCircle( Circle circle );\n  void printRectangle( Rectangle rectangle );\n }",
      "id": "4c56ff8b6eb35d496d6da99dae4e190b"
    },
    {
      "type": "html",
      "text": "Next, we write our two printers:",
      "id": "e6432be46d0ee9c4b46b2dff45050245"
    },
    {
      "type": "code",
      "text": " class I''''''nkjetPrinter implements Printer {\n  public void printCircle( Circle circle ) {\n  // ... rasterizing logic for inkjet printing of circles here ...\n  System.out.println( \"Inkjet printer prints a cirlce.\" );\n  }\n  public void printRectangle( Rectangle rectangle ) {\n  // ... rasterizing logic for inkjet printing of rectangles here ...\n  System.out.println( \"Inkjet printer prints a rectangle.\" );\n  }\n }\n class P''''''ostscriptPrinter implements Printer {\n  public void printCircle( Circle circle ) {\n  // ... postscript preprocessing logic for circles here ...\n  System.out.println( \"P''''''ostScript printer prints a cirlce.\" );\n  }\n  public void printRectangle( Rectangle rectangle ) {\n  // ... postscript preprocessing logic for rectangles here ...\n  System.out.println( \"P''''''ostScript printer prints a rectangle.\" );\n  }\n }",
      "id": "fc88fd2edcaf25c4cd2c1fba911cad5f"
    },
    {
      "type": "html",
      "text": "Now, all we have to make sure is that calling the <i>figure.printOn( printer )</i> method results in the correct <i>printXyz</i> implementation being executed, such as <i>postscriptPrinter.printRectangle( rectangle )</i>.",
      "id": "f4a9f30b27e17fb9a01a72d4f9a5ac3a"
    },
    {
      "type": "html",
      "text": "This can be achieved through a simple indirection in the implementation of <i>printOn</i> in the individual figure classes:",
      "id": "db5c8c4a4323e94a95aeeb082eca1e0d"
    },
    {
      "type": "code",
      "text": " class Circle implements Figure {\n  public void printOn( Printer printer ) {\n  printer.printCircle( this ); // <-- the \"trick\" !\n  }\n }\n class Rectangle implements Figure {\n  public void printOn( Printer printer ) {\n  printer.printRectangle( this );\n  }\n }",
      "id": "ce716a00a9cda4a2605f053c5c5ab0dc"
    },
    {
      "type": "html",
      "text": "That's it!",
      "id": "cafec0a8d8860384fa351e72f02620ca"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "To test the above code, just add the following class:",
      "id": "37b93e7b7dc26b072b2809a27fa83ad3"
    },
    {
      "type": "code",
      "text": " public class Main {\n  public static void main( String[] args ) {\n  Figure [] figures = new Figure [] { \n  new Circle(), new Rectangle() };\n  Printer [] printers = new Printer [] { \n  new P''''''ostscriptPrinter(), new I''''''nkjetPrinter() };",
      "id": "7fa66e26189e5499fa7a1bbe1ba4ffa4"
    },
    {
      "type": "code",
      "text": "  new Client().printAllEverywhere( figures, printers );\n  }\n }",
      "id": "bd8562edca625cdb7edd9e1b86cb7b8b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "<b>Explanation:</b>",
      "id": "3fe3d5cac0146d1cda4fd08c0994aa0a"
    },
    {
      "type": "html",
      "text": "\nWhat happens when <i>figure.printOn( printer )</i> is called at runtime? This depends on the types of the objects referenced by the <i>figure</i> and <i>printer</i> variables at that time. Let's assume that at the moment, <i>figure</i> points to an instance of class Circle, and <i>printer</i> to an I<b></b>nkjetPrinter. So, the implementation of <i>printOn( printer )</i> being called will be that of the circle instance, defined in the Circle class (first dispatch). This method just contains one line: <i>printer.printCircle( this )</i>, which delegates the work to the printer object. As this object is of the class I<b></b>nkjetPrinter, the <i>printCircle( circle )</i> method of the I<b></b>nkjetPrinter class will be executed (second dispatch), which is just what we wanted.",
      "id": "5c7fce88b3c3980034ee2359575e4b07"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "\nThe same code recast in [[Cee Plus Plus]] (jives with both [[Gnu Cpp]] 3.0.3 and Microsoft [[Visual Cee Plus Plus]] 6.0):",
      "id": "3e659df8c22045fb5f4d63006624311b"
    },
    {
      "type": "code",
      "text": " #include <iostream>",
      "id": "a47912a29fdc84d91b133cc9f7ebd399"
    },
    {
      "type": "code",
      "text": " using std::cout;\n using std::endl;",
      "id": "1f02d561e8df04dd61ca929cacde95af"
    },
    {
      "type": "code",
      "text": " class Printer;\n class Figure {\n  public:\n  virtual void printOn(Printer* printer) = 0;\n };",
      "id": "93baffc252d95a4e091b962ea4fab4e9"
    },
    {
      "type": "code",
      "text": " class Circle;\n class Rectangle;\n class Printer {\n  public:\n  virtual void printCircle(const Circle* circle) = 0;\n  virtual void printRectangle(const Rectangle* rectangle) = 0;\n };",
      "id": "aebbda96099c92f74a3fc8da561ca5f6"
    },
    {
      "type": "code",
      "text": " class Client {\n  public:\n  // Prints all figures on each of the printers.\n  void printAllEverywhere(Figure **figures, Printer **printers) {\n  Figure  **figure;\n  Printer **printer;",
      "id": "8baef0c7b101b0e03e146b3445d3acb9"
    },
    {
      "type": "code",
      "text": "  for (figure = figures; *figure; figure++) {\n  for (printer = printers; *printer; printer++) {\n   Figure *fig = *figure;\n   fig->printOn(*printer);  // must work for any printer or figure !\n  }\n  }\n  }\n };",
      "id": "3bb184ed9337571a52357ff9c1135b3c"
    },
    {
      "type": "html",
      "text": "class Inkjet<b></b>Printer :<br>public Printer {",
      "id": "42d5fe9a3b35d46aa8725e92572ad9ae"
    },
    {
      "type": "code",
      "text": "  public:\n  void printCircle(const Circle *circle) {\n  // ... rasterizing logic for inkjet printing of circles here ...\n  cout << \"Inkjet printer prints a circle.\" << endl;\n  }\n  void printRectangle(const Rectangle *rectangle) {\n  // ... rasterizing logic for inkjet printing of rectangles here ...\n  cout << \"Inkjet printer prints a rectangle.\" << endl;\n  }\n };",
      "id": "837752eff928dfb6de8cfe7e30c2015e"
    },
    {
      "type": "html",
      "text": "class Postscript<b></b>Printer :<br>public Printer {",
      "id": "955894c13319debecdf303882782601d"
    },
    {
      "type": "code",
      "text": "  public:\n  void printCircle(const Circle *circle) {\n  // ... postscript preprocessing logic for circles here ...\n  cout << \"Post''''''Script printer prints a cirlce.\" << endl;\n  }\n  void printRectangle(const Rectangle *rectangle) {\n  // ... postscript preprocessing logic for rectangles here ...\n  cout << \"Post''''''Script printer prints a rectangle.\" << endl;\n  }\n };",
      "id": "0f890dfb484e2c0ea42933648e2054ad"
    },
    {
      "type": "html",
      "text": "class Circle :<br>public Figure {",
      "id": "11a91eed150a2c72f5b4eba288f414e4"
    },
    {
      "type": "code",
      "text": "  public:\n  void printOn(Printer* printer) {\n  printer->printCircle(this); // <-- the \"trick\" !\n  }\n };",
      "id": "1f173e1250f28a89ffbdcdb1ecdf247a"
    },
    {
      "type": "html",
      "text": "class Rectangle :<br>public Figure {",
      "id": "f54de8f8e8f120531964e6832af892f1"
    },
    {
      "type": "code",
      "text": "  public:\n  void printOn(Printer* printer) {\n  printer->printRectangle(this);\n  }\n };",
      "id": "4d9b7b369389bd9b24e023e4893458f3"
    },
    {
      "type": "code",
      "text": " int\n main()\n {\n  Figure  *figures[]  = { new Circle,    new Rectangle,  0 };\n  Printer *printers[] = { new Postscript''''''Printer, new Inkjet''''''Printer, 0 };",
      "id": "f040934ada50639377f208c3dd08f698"
    },
    {
      "type": "code",
      "text": "  Client c;\n  c.printAllEverywhere(figures, printers);\n  return 0;\n }",
      "id": "36d036bab51f33b9cc006b7dc89627e1"
    },
    {
      "type": "html",
      "text": "-- [[Greg Bacon]]",
      "id": "5af8b7c3b6b7bde41c553e575bebbad1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "\nA possible [[Relational Weenie]] solution would look something like this:",
      "id": "0b57c60d8797862b79ba0d332f6c1291"
    },
    {
      "type": "html",
      "text": "Table:<br>printerShapes",
      "id": "ca68d0dce19114d1e2e71301a0ccb8c9"
    },
    {
      "type": "code",
      "text": "  --------------------------\n  printerRef  (foreign key to Printers table)\n  shapeRef  (shape name or ID)\n  implementation  (reference or container for algorithm)",
      "id": "f1f72f7866c54c61004bf630330ead01"
    },
    {
      "type": "code",
      "text": "  The code might resemble:",
      "id": "a14dd729aa1b894c006ca79399b7773c"
    },
    {
      "type": "code",
      "text": "  rs = query(\"select * from printerShapes where [criteria])\n  while (getNext(rs)) {    // for each row in result\n    execute(rs['implementation'])   // or 'eval'\n  }",
      "id": "f052affb86aabe438e804296f658c6f3"
    },
    {
      "type": "html",
      "text": "Some might argue that this violates the criteria of non-intrusive addition of new printers or shapes because we have to append to an existing table. However, every solution has to \"append\" to something. No paradigm lets stuff just float in dark space unlinked or unhitched to everything. Otherwise, we could never reference it. Adding to \"object space\" is appending to something also. There's often a [[Laynes Law]] risk in using physical vocabulary to describe virtual things.",
      "id": "951db25dbf785468af35f09642e98804"
    },
    {
      "type": "html",
      "text": "<b>Using the File System</b>",
      "id": "08cd1c7cd2eaa02c8b54501e7707ef30"
    },
    {
      "type": "html",
      "text": "\nAnother approach that may at least appear less connected would be to name the implementation libraries or scripts with a combination of printer name and shape name:",
      "id": "6ce6949c6e951416d71532d8fcf9a9c4"
    },
    {
      "type": "code",
      "text": "  function runShape(printerName, shapeName) {\n  filename = stdPath . printerName . '_' . shapeName . '.driver'\n  status = executeFile(filename)\n  if (not status.good) {  // check status array\n    errorReport(status.errDescript)\n  }\n  }",
      "id": "a27177177a238acf05ec1b391aa2af03"
    },
    {
      "type": "html",
      "text": "This is basically using the file-system like a two-key hash array. Running them as a group is tougher than in the table example, I would note.",
      "id": "9395740e4e2f21b3c3e1941176083979"
    },
    {
      "type": "html",
      "text": "\nFiles may resemble:",
      "id": "a5d13da90d0b3e7799887c3569eb44ab"
    },
    {
      "type": "code",
      "text": "  Lexmark1000_circle.driver\n  Lexmark1000_square.driver\n  HP4270jet_circle.driver\n  HP4270jet_square.driver\n  ...etc...",
      "id": "0b9ed29f883a661807f36cf5e29ee9fb"
    },
    {
      "type": "html",
      "text": "The advantage of this approach is that we can add new drivers without having to open or alter any existing driver files. However, the drawback is that we cannot ship new printers or new shapes in a single file for better packaging. The optimum solution depends on the [[Change Pattern]](s) that one expects or observes. If mostly new printers are added and not new shapes, then grouping them by printer (a single printer per file) would be the most convenient. However, if new shapes were added more often than new printers, then making shape files (with all printers in them) would be the way to go. If the pattern is pretty even or chaotic, then either approach, or the finer granularity approach shown above may be the way to go.",
      "id": "1bc2efc239bd53a514bd533a91894808"
    },
    {
      "type": "html",
      "text": "\nHowever, an installation utility may be more appropriate than allowing the user to insert and/or replace files by themselves. If we go that route, then the database approach can also be used since the \"storage mechanism\" is not something the user directly faces anyhow. They just receive a file of changes to load in and let a Wizard-like thing guide them through loading. Some may argue that a database is an [[Abstraction Inversion]] (overkill), but if flexibility with regard to change-pattern is what you really want, then it may be the best approach. (I used to use [[Nimble Database]] technology extensively, so don't view DB's as inherently bulky.) But if there are only a few hundred rather than thousands, then files are sufficient.",
      "id": "a23367a9793620c790e3324ab5b1e76f"
    },
    {
      "type": "html",
      "text": "{Code indentation damaged due to [[Tab Munging]]}",
      "id": "cd0992041610a97517486843b1c9c4d7"
    },
    {
      "type": "html",
      "text": "--top",
      "id": "d8a78936d330fbf309ec8246097fa3df"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "\nBelow is an example in [[Perl Language]] that uses the Class::Multimethods module by [[Damian Conway]]. For details, see the following resources:",
      "id": "46b255476546c5c6de74ff7ed204ad68"
    },
    {
      "type": "html",
      "text": " <b>Tutorial:</b> [http://search.cpan.org/src/DCONWAY/Class-Multimethods-1.70/tutorial.html search.cpan.org]",
      "id": "1d5c92762b5f38aea7112bc945041a0d"
    },
    {
      "type": "html",
      "text": " <b>[[The Perl Journal]] article:</b> [http://www.samag.com/documents/s=1274/sam05010010/ www.samag.com]",
      "id": "ea659f3c9d68cf5f2270a946d73380be"
    },
    {
      "type": "html",
      "text": " <b>CPAN:</b> [http://search.cpan.org/author/DCONWAY/Class-Multimethods/lib/Class/Multimethods.pod search.cpan.org]",
      "id": "f26b69571019d4890fb226ef8ce864cd"
    },
    {
      "type": "html",
      "text": "-- [[Greg Bacon]]",
      "id": "5af8b7c3b6b7bde41c553e575bebbad1"
    },
    {
      "type": "code",
      "text": " #! /usr/local/bin/perl",
      "id": "fe9327472fab5ff1fe224959bc4dc534"
    },
    {
      "type": "code",
      "text": " use 5.005;\n use warnings;\n use strict;",
      "id": "72d223f8d2460f14fe48e58fff89a106"
    },
    {
      "type": "code",
      "text": " package Figure;\n # dummy placeholder\n $Figure::VERSION = '1.0';",
      "id": "8333e6d10d5df72c887630695570c0fa"
    },
    {
      "type": "code",
      "text": " package Printer;\n use Carp;\n use Class::Multimethods;\n # catchall\n multimethod\n  printFigure => ('Printer', 'Figure') =>\n   sub {\n    my $p = ref $_[0];\n    my $f = ref $_[1];\n    confess \"$0: printFigure: unknown combination: $p, $f\";\n   };",
      "id": "b773a4119807912ab8da91e5b119bc61"
    },
    {
      "type": "code",
      "text": " package Inkjet''''''Printer;\n use base 'Printer';\n use Class::Multimethods;",
      "id": "0b5a8e86dbdece2bcd343def24530b85"
    },
    {
      "type": "code",
      "text": " { # register in Printer class\n  package Printer;\n  multimethod\n   printFigure => ('Inkjet''''''Printer', 'Circle') =>\n    sub {\n     Inkjet''''''Printer::printCircle($_[0], $_[1]);\n    };\n  multimethod\n   printFigure => ('Inkjet''''''Printer', 'Rectangle') =>\n    sub {\n     Inkjet''''''Printer::printRectangle($_[0], $_[1]);\n    };\n }\n sub new {\n  my $class = shift;\n  bless [] => $class;\n }\n sub printCircle {\n  # ... rasterizing logic for inkjet printing of circles here ...\n  print \"Inkjet printer prints a circle.\\n\";\n }\n sub printRectangle {\n  # ... rasterizing logic for inkjet printing of rectangles here ...\n  print \"Inkjet printer prints a rectangle.\\n\";\n }",
      "id": "1bf3ee0dfb5e7f091264cd81ec466740"
    },
    {
      "type": "code",
      "text": " package Postscript''''''Printer;\n use base 'Printer';\n use Class::Multimethods;",
      "id": "0fc43e5ab28ff99bdef3ddb2c1de4f98"
    },
    {
      "type": "code",
      "text": " { # register in Printer class\n  package Printer;\n  multimethod\n   printFigure => ('Postscript''''''Printer', 'Circle') =>\n    sub {\n     Postscript''''''Printer::printCircle($_[0], $_[1]);\n    };\n  multimethod\n   printFigure => ('Postscript''''''Printer', 'Rectangle') =>\n    sub {\n     Postscript''''''Printer::printRectangle($_[0], $_[1]);\n    };\n }\n sub new {\n  my $class = shift;\n  bless [] => $class;\n }\n sub printCircle {\n  # ... postscript preprocessing logic for circles here ...\n  print \"Post''''''Script printer prints a cirlce.\\n\";\n }\n sub printRectangle {\n  # ... postscript preprocessing logic for rectangles here ...\n  print \"Post''''''Script printer prints a rectangle.\\n\";\n }",
      "id": "196a3356807cd982fedd8ee33714f8a3"
    },
    {
      "type": "code",
      "text": " package Circle;\n use base 'Figure';\n sub new {\n  my $class = shift;\n  bless [] => $class;\n }",
      "id": "376f3b35c798a3194ecfb85934ac0a49"
    },
    {
      "type": "code",
      "text": " package Rectangle;\n use base 'Figure';\n sub new {\n  my $class = shift;\n  bless [] => $class;\n }",
      "id": "266199fcf92cc0c8bb8e90503052b979"
    },
    {
      "type": "code",
      "text": " ## main\n package main;",
      "id": "e7338ff99191be34a8e27f403a43d19d"
    },
    {
      "type": "code",
      "text": " my @figures  = (Circle->new,    Rectangle->new);\n my @printers = (Postscript''''''Printer->new, Inkjet''''''Printer->new);\n foreach my $f (@figures) {\n  foreach my $p (@printers) {\n   # must work for any Printer or Figure!\n   $p->printFigure($f);\n  }\n }",
      "id": "99245e1feeecc403cd40733aa7b35a06"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "\nI'm surprised nobody's offered a solution in a language that supports [[Multi Methods]], as this is exactly what they're for. Here's one in [[Dylan Language]] (the [[Common Lisp]] solution would be similar, just with more parentheses):",
      "id": "0696bccf55999b68a71655f9fa980229"
    },
    {
      "type": "code",
      "text": "  define class <figure> (<object>) end;\n  define class <printer> (<object>) end;",
      "id": "3d438abdb96f6e0b731046b815ba5c62"
    },
    {
      "type": "code",
      "text": "  define class <circle> (<figure>) end;\n  define class <rectangle> (<figure>) end;\n  define class <inkjet-printer> (<printer>) end;\n  define class <postscript-printer> (<printer>) end;",
      "id": "32d4d80e4786a9a87afe6a9c29c4ef72"
    },
    {
      "type": "html",
      "text": "define generic print (printer ::<br><printer>, shape :: <figure>);",
      "id": "6f1a70a5560f952352f1005c2f59cd25"
    },
    {
      "type": "html",
      "text": "define method print (printer ::<br><inkjet-printer>, shape :: <circle>)",
      "id": "3b5f128027b843564c2999a9166f9372"
    },
    {
      "type": "code",
      "text": "  format-out(\"Inkjet printer prints a circle.\");\n  end;",
      "id": "53e881c7b7cc110e6288a186e59de6fc"
    },
    {
      "type": "html",
      "text": "define method print (printer ::<br><postscript-printer>, shape :: <circle>)",
      "id": "07b9f817163f00b13d018cf9d0d5f45c"
    },
    {
      "type": "code",
      "text": "  format-out(\"Postscript printer prints a circle.\");\n  end;",
      "id": "0bcccfc5f7642281c6b619888094e227"
    },
    {
      "type": "html",
      "text": "define method print (printer ::<br><inkjet-printer>, shape :: <rectangle>)",
      "id": "d01c422ef979566be242cc04de1dd089"
    },
    {
      "type": "code",
      "text": "  format-out(\"Inkjet printer prints a rectangle.\");\n  end;",
      "id": "08c1a69f6d79a03f0b761b825424fd7d"
    },
    {
      "type": "html",
      "text": "define method print (printer ::<br><postscript-printer>, shape :: <rectangle>)",
      "id": "b58ba669a0271ee126ddc54642d1fb3c"
    },
    {
      "type": "code",
      "text": "  format-out(\"Postscript printer prints a rectangle.\");\n  end;",
      "id": "f523183e1356f6e28e413a07ae08e16b"
    },
    {
      "type": "code",
      "text": "  // Client code...\n  define method print-all-everywhere (\n  client :: <client>,\n  printers :: limited(<collection>, of: <printer>\n  shapes :: limited(<collection>, of: <figure>)\n  do(curry(do, print, printers), shapes);\n  end;",
      "id": "0c198877406e8a2f86283cbd1edd3639"
    },
    {
      "type": "html",
      "text": "All the functionality of the original, and no code bloat. The language handles all the dispatching. The standard library handles the iteration (do is a function that takes a function and a collection, and applies the function to every element in the collection). If you want to define a new shape or printer, you just subclass <figure> or <printer> and then define the appropriate methods on print. If there's common functionality, you can define an intermediate subclass and factor out the appropriate functionality into methods on that class.",
      "id": "c25a285d0683920a679c3f2fdd4ccbb7"
    },
    {
      "type": "html",
      "text": "-- [[Jonathan Tang]]",
      "id": "13ff33ebabf07bd98e097183396a0d05"
    },
    {
      "type": "html",
      "text": "\nThe same solution in the [[Nice Language]]. It might be more readable to some, since the syntax is close to Java.",
      "id": "f023d0e083e9593c2dc908e5d04cff32"
    },
    {
      "type": "code",
      "text": "  abstract class Figure {}\n  abstract class Printer {}",
      "id": "d2c8177329acb6e0e4a839d7246a8d4f"
    },
    {
      "type": "code",
      "text": "  class Circle extends Figure {}\n  class Rectangle extends Figure {}",
      "id": "14d271022531a05df4d52399e5a835e2"
    },
    {
      "type": "code",
      "text": "  class Inkjet''''''Printer extends Printer {}\n  class Postscript''''''Printer extends Printer {}",
      "id": "4524421d54916894accb02c9dac6ff17"
    },
    {
      "type": "code",
      "text": "  void print(Printer printer, Figure shape);",
      "id": "2d890f9d1b2937036cdaa1bc4980073e"
    },
    {
      "type": "code",
      "text": "  print(Inkjet''''''Printer printer, Circle shape) {\n  println(\"Inkjet printer prints a circle.\");\n  }",
      "id": "d6e2a1c60b04f86764f9740f85c11e89"
    },
    {
      "type": "code",
      "text": "  print(Postscript''''''Printer printer, Circle shape) {\n  println(\"Postscript printer prints a circle.\");\n  }",
      "id": "d72378ffacecf17b2c3a5e2dbeb21535"
    },
    {
      "type": "code",
      "text": "  print(Inkjet''''''Printer printer, Rectangle shape) {\n  println(\"Inkjet printer prints a rectangle.\");\n  }",
      "id": "819cd58ca408cfe07968a86a65a2bc30"
    },
    {
      "type": "code",
      "text": "  print(Postscript''''''Printer printer, Rectangle shape) {\n  println(\"Postscript printer prints a rectangle.\");\n  }",
      "id": "5f014f956fcf90da2e7e75e6929c943c"
    },
    {
      "type": "code",
      "text": "  // Client code...\n  void printAllEverywhere\n  (Collection<Printer> printers,\n  Collection<Figure> shapes)\n  {\n  printers.foreach(Printer p => shapes.foreach(Figure s => print(p,s)));\n  }",
      "id": "13d5798ddadfad7e8b1db92822e08e03"
    },
    {
      "type": "code",
      "text": "  void main(String[] args)\n  {\n  printAllEverywhere\n  ([ new Postscript''''''Printer(), new Inkjet''''''Printer() ],\n  [ new Circle(), new Rectangle() ]);\n  }",
      "id": "c5ffbfac1946a62f38c02276d79b6cb3"
    },
    {
      "type": "html",
      "text": "-- [[Daniel Bonniot]]",
      "id": "04e5d1d9d10ec360224b0810315a90df"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "\nI don't like the Java and C++ examples at all. If I add a new shape I have to modify every existing printer. I'd rather abstract the way shapes draw themselves to work with any printer (or the way printers draw shapes), then leave all shape knowledge in the shape class hierarchy. Then I can add new printers without touching shapes and new shapes without touching printers. -- [[Eric Hodges]]",
      "id": "f40c6dbcb79353bb4816370cff8b36d3"
    },
    {
      "type": "html",
      "text": "\nThat is, in general, very difficult to do. What would be the lowest-common denominator used by printers? Cubic bezier curves? Then you can't draw true circles. Pixels? Then you can't use your framework to output to a plotter. Etc. etc. At some point, you have to have a [[Lingua Franca]] that specifies the primitive Printer operations, and those operations will be reified as Figure classes. -- [[Anonymous Donor]]",
      "id": "0db1d73629f43f13ae0094b492f8c9e6"
    },
    {
      "type": "html",
      "text": "\nIt isn't too hard to do or it wouldn't be done. See [[Post Script]] and PCL. -- [[Eric Hodges]]",
      "id": "6658cc81dc4b029b5328e068b3fd5310"
    },
    {
      "type": "html",
      "text": "\nBut those might not recognize the printer's internal primitives. There are different ways to specify ellipses, for example: by two center points, by bounding rectangle, and by circle plus a \"flatness\" factor and angle. True, there might be groupings such that some printers will fall into one interface group and another will fall into another group. Of course, this is mostly a hypothetical thought experiment anyhow. But in reality there might be some efficiency trade-off between using a standard meta-layer and native primitives. The standard meta-layer may not match up one-to-one with a given printer's primitives. For example, some printers may have built-in dashed line patterns that don't match what the meta-language has. If you want to match, you have to use a bunch of small lines and dots to emulate the dashing of the other brand. -- top",
      "id": "11d65d76d29b078c18a12c8bc66a2d8a"
    },
    {
      "type": "html",
      "text": "\n[[Post Script]] and PCL don't have to recognize the printer's internal primitives. Each printer recognizes [[Post Script]] and/or PCL. -- bottom",
      "id": "cf5c3a13cd117ddaf54b3b6628e95c73"
    },
    {
      "type": "html",
      "text": "\nThen are [[Post Script]] and PCL examples of [[Bridge Pattern]] at work? -- [[Greg Bacon]]",
      "id": "0257d5b712186f1a5526c2e151b01eec"
    },
    {
      "type": "html",
      "text": "\nYou're not actually saying you've never heard of a printer that works with [[Post Script]], are you? -- francis",
      "id": "004ad9b5447ea3a9e052da8c6e6eed9b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "I am surprised that nobody mentioned how many real world solves this printer-shape problem, perhaps I am miss the point here? In C/C++ in Windows and OS/2 (likely in other windowing systems too) and in Java, you introduce a third entity, some kind of drawing space (Presentation Space in OS/2, Graphics in Java), that can draw some arbitrary shape \"primitives\" such as lines, circles, text, etc. All graphics drawing applications can draw to any given drawing space. Any new printer simply implements a method to provide the drawing space. -- [[Oliver Chung]]",
      "id": "9893582da157aa960098408c5f707277"
    },
    {
      "type": "html",
      "text": "\nThis problem is more of a thought experiment than an exercise in production printing drivers. -- [[Anonymous Donor]]",
      "id": "ddbe00e76696fcc77b73d5be5ed453f5"
    },
    {
      "type": "html",
      "text": "\nThe thought experiment reveals a weakness of the double dispatch strategy. It requires a two dimensional matrix of methods. Adding an element to one dimension forces the creation of a method for each element along the other dimension. Compare the cost of change curve with a [[Bridge Pattern]]. -- [[Eric Hodges]]",
      "id": "a0225ecc0c32eaa4e8b56e2ed86a59c9"
    },
    {
      "type": "html",
      "text": "\nThat makes for an interesting challenge: be able to add methods (or whatever they are called in other paradigms) where the number of dimensions is arbitrary without changing existing code or replacing an existing data structure. My first inclination would be to use the \"file name lookup\" approach above, but use names like \"d1=foo,d2=bar,d3=glob\", etc. (However, we would have to use something besides equal signs and commas, for they don't make safe filename characters.) \"d1=foo,d2=bar\" would not conflict with \"d1=foo,d2=bar,d3=glob\" because they are different strings. However, adding a file is \"changing an existing data structure\" if you view the file system as a data structure, which it is. No way out? -- top",
      "id": "cc5347fe53630b4e99cfa3ba413e697a"
    },
    {
      "type": "html",
      "text": "\nNo, the challenge isn't to add methods without changing code. Methods are code. The challenge is to add elements to one dimension of the matrix without adding a method for each element in the other dimension. If a new printer shows up you don't have to write a method to draw every shape on that printer. Or vice versa, if a new shape shows up you don't have to write a method to draw that shape on every printer. See [[Bridge Pattern]] for a common solution to this challenge. See the Java virtual machine for a widespread example of its use. -- bottom",
      "id": "9a206a4439db13f6edb2069b79d4a698"
    },
    {
      "type": "html",
      "text": "\nI don't think this is possible, unless there's some behavior common to the algorithms that you can factor out. Your [[Bridge Pattern]] solution relies on this toy example having these common data structures or behavior; all shapes can be rendered by [[Post Script]] as a \"current path\" plus the stroke, fill, or clipping operators, and then all printers can convert [[Post Script]] drawing primitives into colored regions on the page. But imagine that the problem was defined like this:",
      "id": "f9f071b2e6df902d3b4ed74a11216c09"
    },
    {
      "type": "code",
      "text": " (inkjet, circle) => print \"Foo\"\n (inkjet, rectangle) => print \"Bar\"\n (postscript, circle) => print \"Goo\"\n (postscript, rectangle) => print \"Gaa\"",
      "id": "46cc10a88eec31e88aac87185f94ceb0"
    },
    {
      "type": "html",
      "text": "This time, there's no common behavior that you can abstract to use as your \"bridge\". There're 4 different behaviors needed, to go with the 4 combinations of types. And if you had to add a new shape:",
      "id": "8e54a4367818c0023bbe179376802fc4"
    },
    {
      "type": "code",
      "text": " (inkjet, triangle) => print \"Glob\"\n (postscript, triangle) => print \"Blurp\"",
      "id": "8ed0b5c2fe0fb1ee1e69c5511dd708e2"
    },
    {
      "type": "html",
      "text": "It's pretty obvious that you would need to define new methods for each combination of types, because the problem now explicitly says that each required behavior is different, with no possibilities for factoring.",
      "id": "d5405fae06924a07a0cc9d4e14fd2160"
    },
    {
      "type": "html",
      "text": "\nGranted, in every real-world system I've worked with, there <i>have</i> been opportunities for factoring and I've been able to use the [[Bridge Pattern]], but this toy example was intended to illustrate a concept. ;)",
      "id": "28c05b17a782ce6b319267f187a1ec5c"
    },
    {
      "type": "html",
      "text": "\nMy solution to the general case would be to use an n-dimensional array filled with function objects (Runnables in Java). Indexing the array's quite tricky, at least with C/C++/Java family languages. I guess the simplest solution is to assign each class a sequential ordering within the hierarchy, and then add each Runnable to the dispatch table manually. Yes, this means keeping track of the class indexes manually. There's some superclass constructor magic you can pull to avoid this, but the best algorithm I can think of for this requires a hashtable lookup for every object instantiation (could you use static{} blocks to get around this?), and so may be performance-unacceptable.",
      "id": "1f1fc6c34e62a4386e5a6feeba2338ec"
    },
    {
      "type": "html",
      "text": "\nThis is all assuming I'm not allowed to use a language with [[Multi Methods]], of course. Makes you appreciate the trouble implementors of those languages go through for us.",
      "id": "f8b12f926fecac4c2e8653e84b7d1ea2"
    },
    {
      "type": "html",
      "text": "\nIncidentally, this approach is very similar to the optimum (so far) algorithm for [[Generic Function]] dispatch. That also uses an n-dimensional array, but it's compressed to reflect the inheritance graph (if a class doesn't define a method, it calls the method from its nearest superclass). The language also handles computation of the class indexes automatically, as well as linearizing the class hierarchy (both [[Dylan Language]] and [[Common Lisp]] support multiple inheritance). See\n[http://citeseer.nj.nec.com/dujardin96fast.html citeseer.nj.nec.com] and\n[http://www.cs.dartmouth.edu/reports/abstracts/TR2001-404/ www.cs.dartmouth.edu]",
      "id": "49f05aaf27c655a97eb07748a0d0dd38"
    },
    {
      "type": "html",
      "text": "-- [[Jonathan Tang]]",
      "id": "13ff33ebabf07bd98e097183396a0d05"
    },
    {
      "type": "html",
      "text": "\nThe fact that it's always been possible for you and me to find a bridge indicates something significant. We're asking different printers to produce the same output. The abstraction of that output ([[Post Script]] in this case) provides the bridge. Double dispatch is used when two abstractions intersect. Neither of us have ever wanted entirely different behavior for each intersection. We want similar realizations of the same abstraction in different contexts. -- [[Eric Hodges]]",
      "id": "388123b9fee84f53180a5ac2760fe03f"
    },
    {
      "type": "html",
      "text": "\nAnyone else remember <i>[[Display Postscript]]</i>? Sun spent a bunch of time and money proving that having a nice abstraction layer can turn your successful product into unusable MIP-sucking garbage, and that sometimes you need to go back and write MxN different pieces of code to do high-speed rendering. -- [[Austin Hastings]]",
      "id": "6a176b29ec40fb1ed125aec8634f0ea2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "[[Double Dispatch]] provides two levels of dispatch in a language context that only supports one, such as [[Java Language]], [[Smalltalk Language]], or [[Cee Plus Plus]]. One level of dispatch is always \"easy\", in that it can be extended without changing existing code. The second is always \"harder\", in that the new elements have to added to the existing first-level dispatch code.",
      "id": "1b313409515e9580a4a07a1a7c8e0b8f"
    },
    {
      "type": "html",
      "text": "\nIn the code example above, adding new kinds of printers is easy - the new printer must provide implementations of printCircle and printRectangle. Adding new shapes is hard - a new printNewShape method has to be added to each existing printer.",
      "id": "bc41bfbfc754a8d7756b759d889634c5"
    },
    {
      "type": "html",
      "text": "\nThis means that guessing which set of classes will change more frequently is an important design decision when using [[Double Dispatch]]. In the [[Visitor Pattern]], the implication is that adding Visitors is easy. Adding Visitees is hard.",
      "id": "0e0bfda3361f12dd60c33fb7c37a4bf3"
    },
    {
      "type": "html",
      "text": "\nIt's a bit like choosing row-major or column-major order in a 2-D array. It's simply a choice, we have to do the best we can.",
      "id": "e39866fce1fc919202743df43a0baf08"
    },
    {
      "type": "html",
      "text": "\nThe discussion about beziers, postscript and so on, is interesting but distracts from the [[Double Dispatch Example]]. Similarly, if a language has method overloading or multimethods, then [[Double Dispatch]] is still needed, it's just done by the language for you.",
      "id": "3fe96df63e38034a454c61a473676c53"
    },
    {
      "type": "html",
      "text": "<i>If I understand what we mean by \"method overloading\", then Java at least <b>does</b> take inheritance into account. I think \"method overloading\" means that several methods with the same name but different argument types are distinguished by the compiler. In Java, a method in a subclass that has the same signature as a method in its superclass is correctly inherited/overridden. I don't remember what [[Cee Plus Plus]] does in this case.</i>",
      "id": "a1a257d7f623cb2be8429e4551a6c64c"
    },
    {
      "type": "html",
      "text": "\nJava does not take inheritance into account when passing parameters at runtime, only at compile time, this isn't sufficient and is not at all like multimethods. Multimethods take the actual runtime type of the parameter into account when selecting the method to run. This is called [[Multiple Dispatch]], and is better than [[Double Dispatch]].",
      "id": "9bd67d636c152987d09bb7916b1ac270"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "\nIn practice, what appears to be the way it's done more often now is that an intermediate \"meta\" format or document is created. Each printer driver then reads this meta format and translates it as needed for its own needs. It is a declarative (data driven) solution rather than a behavioral one. Perhaps this was not the way it was done in the early days because it requires a fairly large work buffer on disk or RAM for the meta document. That space was too expensive on early machines. Thus, the above printer driver example is mostly an academic exercise. (I'm not sure if Postscript counts as a meta-format for printers.) -- top",
      "id": "21c39a984744c93e35127e2f2bbc8836"
    },
    {
      "type": "html",
      "text": "<i>So we should have stuck with Shapes, one of the [[Over Used Oop Examples]], and done intersection as that one doesn't have an IR that allows Bridging?</i>",
      "id": "4164941993f1813b223b48a670875e1f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "\nMoved game example to [[Delta Isolation]].\nSee also: [[International Ui Example]], [[Extrapolating Device Drivers]]",
      "id": "5815152b573ab1030fc9f1c9f828aed1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
    },
    {
      "type": "html",
      "text": "[[Category Comparisons]], [[Category Example]], [[Category Conditionals And Dispatching]]",
      "id": "c30304bf78d1c863e6a8ee01b9be961b"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?DoubleDispatchExample c2.com]",
      "id": "b35045f674015053b77b07865a4ac62a"
    }
  ],
  "journal": [
    {
      "date": 1300053208000,
      "id": "6f708e527ac89caff9cffc66d3bca9c0",
      "type": "create",
      "item": {
        "title": "Double Dispatch Example",
        "story": [
          {
            "type": "html",
            "text": "[----\nA bunch of this should be removed!\nit is meant to be an example to the [[Double Dispatch]] discussion in other single dispatch languages. \nThe request was made by people who didn't understand the example there. \nIts not meant to describe how to handle the cartesian product \"printer X shapes\" problem specifically its meant to illustrate and explore \"doubledispatch\" as a concept.",
            "id": "000186a5a8709b9094c9285cf70c731a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "[ quoted from the page [[Double Dispatch]]] ",
            "id": "a603fd805095db6605f7c1544e58bc29"
          },
          {
            "type": "html",
            "text": "\nWe'll assume that the printers all have a common base class (APrinter), and the shapes also have a common base class (AShape).",
            "id": "71942072e6b6c59598ac93c4805c2a29"
          },
          {
            "type": "html",
            "text": "\nIn the simplest case, as you say, you extend the printer interface with a separate function per shape that it can render. Now, given some code where you have a printer object, and a shape object. But the code only knows the printer object to be of type APrinter (assuming a statically typed language), and the shape object to be of type AShape. How do you, or the compiler, know which printer method to call? That's the crux of the problem. You need to select the method based on the run-time types, not the static types, of two objects. ",
            "id": "1fb02679292ecf06abdfe5598121a7fe"
          },
          {
            "type": "html",
            "text": "\n[[Double Dispatch]] is a pattern for solving this problem in a typical OO language that can dispatch only on one object's type. It requires a bit of extra work by the programmer. ",
            "id": "24051220e702a2b61a6389457f63f46d"
          },
          {
            "type": "html",
            "text": "-- [[Dan Muller]]",
            "id": "c60062efe40f9d12bd702f1f8cdc1e98"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "]",
            "id": "559177f1e514de2cef3642d39a4bec3e"
          },
          {
            "type": "html",
            "text": "\nOn [[Double Dispatch]], someone said: <i>Would someone be willing to create a more verbose example? (hopefully in Java or C++)</i>",
            "id": "36df665c69ffb8835a210e86aad6f182"
          },
          {
            "type": "html",
            "text": "\nHere it is:",
            "id": "a8fcc77a88969ee54c5cee2819604b22"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "<b>Problem:</b>",
            "id": "036c7c1f06b5f56251f1c30c6b4b2214"
          },
          {
            "type": "html",
            "text": "\nAssume we are writing a print library. We want the client code of our library to be able to do something like this:",
            "id": "ff76e3b89fcb3ed9e731cf8c2791fc04"
          },
          {
            "type": "code",
            "text": " class Client {",
            "id": "360c5f254a7523c0ca92e3d12d2a3fe0"
          },
          {
            "type": "code",
            "text": "  /** Prints all figures on each of the printers. */\n  void printAllEverywhere( Figure[] figures, Printer[] printers ) {\n  for ( int i = 0; i < figures.length; i++ ) {\n  Figure figure = figures[ i ];\n  for ( int j = 0; j < printers.length; j++ ) {\n   Printer printer = printers[ j ];\n     \n   figure.printOn( printer ); \n   // must work for any printer or figure !\n  }\n  }\n  }\n }",
            "id": "ef1cfa074520d6793f2276f8d30a9623"
          },
          {
            "type": "html",
            "text": "Of course, when we add new printers or figures to our library, we want client code such as the above to immediately work with these new printers and figures, without a change in their code or even a recompile. How can we implement our library to allow this?",
            "id": "6b48ec0ffdd31f31d25f3c38ae711af4"
          },
          {
            "type": "html",
            "text": "\nAnother way to state this is that we need a [[Cartesian Product]] of drivers or methods of printer kinds and shape kinds.",
            "id": "e5569b4b8bb61aa9ae73ab172c5fe551"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "<b>Solution:</b>",
            "id": "f05ff83e39e1f2c5595d5896517e7516"
          },
          {
            "type": "html",
            "text": "\nFirst, we define two interfaces for our figures and printers:",
            "id": "452f10debc94cb05b2265f89fd8db6fb"
          },
          {
            "type": "code",
            "text": " interface Figure {\n  void printOn( Printer printer );\n }\n interface Printer {\n  void printCircle( Circle circle );\n  void printRectangle( Rectangle rectangle );\n }",
            "id": "4c56ff8b6eb35d496d6da99dae4e190b"
          },
          {
            "type": "html",
            "text": "Next, we write our two printers:",
            "id": "e6432be46d0ee9c4b46b2dff45050245"
          },
          {
            "type": "code",
            "text": " class I''''''nkjetPrinter implements Printer {\n  public void printCircle( Circle circle ) {\n  // ... rasterizing logic for inkjet printing of circles here ...\n  System.out.println( \"Inkjet printer prints a cirlce.\" );\n  }\n  public void printRectangle( Rectangle rectangle ) {\n  // ... rasterizing logic for inkjet printing of rectangles here ...\n  System.out.println( \"Inkjet printer prints a rectangle.\" );\n  }\n }\n class P''''''ostscriptPrinter implements Printer {\n  public void printCircle( Circle circle ) {\n  // ... postscript preprocessing logic for circles here ...\n  System.out.println( \"P''''''ostScript printer prints a cirlce.\" );\n  }\n  public void printRectangle( Rectangle rectangle ) {\n  // ... postscript preprocessing logic for rectangles here ...\n  System.out.println( \"P''''''ostScript printer prints a rectangle.\" );\n  }\n }",
            "id": "fc88fd2edcaf25c4cd2c1fba911cad5f"
          },
          {
            "type": "html",
            "text": "Now, all we have to make sure is that calling the <i>figure.printOn( printer )</i> method results in the correct <i>printXyz</i> implementation being executed, such as <i>postscriptPrinter.printRectangle( rectangle )</i>.",
            "id": "f4a9f30b27e17fb9a01a72d4f9a5ac3a"
          },
          {
            "type": "html",
            "text": "This can be achieved through a simple indirection in the implementation of <i>printOn</i> in the individual figure classes:",
            "id": "db5c8c4a4323e94a95aeeb082eca1e0d"
          },
          {
            "type": "code",
            "text": " class Circle implements Figure {\n  public void printOn( Printer printer ) {\n  printer.printCircle( this ); // <-- the \"trick\" !\n  }\n }\n class Rectangle implements Figure {\n  public void printOn( Printer printer ) {\n  printer.printRectangle( this );\n  }\n }",
            "id": "ce716a00a9cda4a2605f053c5c5ab0dc"
          },
          {
            "type": "html",
            "text": "That's it!",
            "id": "cafec0a8d8860384fa351e72f02620ca"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "To test the above code, just add the following class:",
            "id": "37b93e7b7dc26b072b2809a27fa83ad3"
          },
          {
            "type": "code",
            "text": " public class Main {\n  public static void main( String[] args ) {\n  Figure [] figures = new Figure [] { \n  new Circle(), new Rectangle() };\n  Printer [] printers = new Printer [] { \n  new P''''''ostscriptPrinter(), new I''''''nkjetPrinter() };",
            "id": "7fa66e26189e5499fa7a1bbe1ba4ffa4"
          },
          {
            "type": "code",
            "text": "  new Client().printAllEverywhere( figures, printers );\n  }\n }",
            "id": "bd8562edca625cdb7edd9e1b86cb7b8b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "<b>Explanation:</b>",
            "id": "3fe3d5cac0146d1cda4fd08c0994aa0a"
          },
          {
            "type": "html",
            "text": "\nWhat happens when <i>figure.printOn( printer )</i> is called at runtime? This depends on the types of the objects referenced by the <i>figure</i> and <i>printer</i> variables at that time. Let's assume that at the moment, <i>figure</i> points to an instance of class Circle, and <i>printer</i> to an I<b></b>nkjetPrinter. So, the implementation of <i>printOn( printer )</i> being called will be that of the circle instance, defined in the Circle class (first dispatch). This method just contains one line: <i>printer.printCircle( this )</i>, which delegates the work to the printer object. As this object is of the class I<b></b>nkjetPrinter, the <i>printCircle( circle )</i> method of the I<b></b>nkjetPrinter class will be executed (second dispatch), which is just what we wanted.",
            "id": "5c7fce88b3c3980034ee2359575e4b07"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "\nThe same code recast in [[Cee Plus Plus]] (jives with both [[Gnu Cpp]] 3.0.3 and Microsoft [[Visual Cee Plus Plus]] 6.0):",
            "id": "3e659df8c22045fb5f4d63006624311b"
          },
          {
            "type": "code",
            "text": " #include <iostream>",
            "id": "a47912a29fdc84d91b133cc9f7ebd399"
          },
          {
            "type": "code",
            "text": " using std::cout;\n using std::endl;",
            "id": "1f02d561e8df04dd61ca929cacde95af"
          },
          {
            "type": "code",
            "text": " class Printer;\n class Figure {\n  public:\n  virtual void printOn(Printer* printer) = 0;\n };",
            "id": "93baffc252d95a4e091b962ea4fab4e9"
          },
          {
            "type": "code",
            "text": " class Circle;\n class Rectangle;\n class Printer {\n  public:\n  virtual void printCircle(const Circle* circle) = 0;\n  virtual void printRectangle(const Rectangle* rectangle) = 0;\n };",
            "id": "aebbda96099c92f74a3fc8da561ca5f6"
          },
          {
            "type": "code",
            "text": " class Client {\n  public:\n  // Prints all figures on each of the printers.\n  void printAllEverywhere(Figure **figures, Printer **printers) {\n  Figure  **figure;\n  Printer **printer;",
            "id": "8baef0c7b101b0e03e146b3445d3acb9"
          },
          {
            "type": "code",
            "text": "  for (figure = figures; *figure; figure++) {\n  for (printer = printers; *printer; printer++) {\n   Figure *fig = *figure;\n   fig->printOn(*printer);  // must work for any printer or figure !\n  }\n  }\n  }\n };",
            "id": "3bb184ed9337571a52357ff9c1135b3c"
          },
          {
            "type": "html",
            "text": "class Inkjet<b></b>Printer :<br>public Printer {",
            "id": "42d5fe9a3b35d46aa8725e92572ad9ae"
          },
          {
            "type": "code",
            "text": "  public:\n  void printCircle(const Circle *circle) {\n  // ... rasterizing logic for inkjet printing of circles here ...\n  cout << \"Inkjet printer prints a circle.\" << endl;\n  }\n  void printRectangle(const Rectangle *rectangle) {\n  // ... rasterizing logic for inkjet printing of rectangles here ...\n  cout << \"Inkjet printer prints a rectangle.\" << endl;\n  }\n };",
            "id": "837752eff928dfb6de8cfe7e30c2015e"
          },
          {
            "type": "html",
            "text": "class Postscript<b></b>Printer :<br>public Printer {",
            "id": "955894c13319debecdf303882782601d"
          },
          {
            "type": "code",
            "text": "  public:\n  void printCircle(const Circle *circle) {\n  // ... postscript preprocessing logic for circles here ...\n  cout << \"Post''''''Script printer prints a cirlce.\" << endl;\n  }\n  void printRectangle(const Rectangle *rectangle) {\n  // ... postscript preprocessing logic for rectangles here ...\n  cout << \"Post''''''Script printer prints a rectangle.\" << endl;\n  }\n };",
            "id": "0f890dfb484e2c0ea42933648e2054ad"
          },
          {
            "type": "html",
            "text": "class Circle :<br>public Figure {",
            "id": "11a91eed150a2c72f5b4eba288f414e4"
          },
          {
            "type": "code",
            "text": "  public:\n  void printOn(Printer* printer) {\n  printer->printCircle(this); // <-- the \"trick\" !\n  }\n };",
            "id": "1f173e1250f28a89ffbdcdb1ecdf247a"
          },
          {
            "type": "html",
            "text": "class Rectangle :<br>public Figure {",
            "id": "f54de8f8e8f120531964e6832af892f1"
          },
          {
            "type": "code",
            "text": "  public:\n  void printOn(Printer* printer) {\n  printer->printRectangle(this);\n  }\n };",
            "id": "4d9b7b369389bd9b24e023e4893458f3"
          },
          {
            "type": "code",
            "text": " int\n main()\n {\n  Figure  *figures[]  = { new Circle,    new Rectangle,  0 };\n  Printer *printers[] = { new Postscript''''''Printer, new Inkjet''''''Printer, 0 };",
            "id": "f040934ada50639377f208c3dd08f698"
          },
          {
            "type": "code",
            "text": "  Client c;\n  c.printAllEverywhere(figures, printers);\n  return 0;\n }",
            "id": "36d036bab51f33b9cc006b7dc89627e1"
          },
          {
            "type": "html",
            "text": "-- [[Greg Bacon]]",
            "id": "5af8b7c3b6b7bde41c553e575bebbad1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "\nA possible [[Relational Weenie]] solution would look something like this:",
            "id": "0b57c60d8797862b79ba0d332f6c1291"
          },
          {
            "type": "html",
            "text": "Table:<br>printerShapes",
            "id": "ca68d0dce19114d1e2e71301a0ccb8c9"
          },
          {
            "type": "code",
            "text": "  --------------------------\n  printerRef  (foreign key to Printers table)\n  shapeRef  (shape name or ID)\n  implementation  (reference or container for algorithm)",
            "id": "f1f72f7866c54c61004bf630330ead01"
          },
          {
            "type": "code",
            "text": "  The code might resemble:",
            "id": "a14dd729aa1b894c006ca79399b7773c"
          },
          {
            "type": "code",
            "text": "  rs = query(\"select * from printerShapes where [criteria])\n  while (getNext(rs)) {    // for each row in result\n    execute(rs['implementation'])   // or 'eval'\n  }",
            "id": "f052affb86aabe438e804296f658c6f3"
          },
          {
            "type": "html",
            "text": "Some might argue that this violates the criteria of non-intrusive addition of new printers or shapes because we have to append to an existing table. However, every solution has to \"append\" to something. No paradigm lets stuff just float in dark space unlinked or unhitched to everything. Otherwise, we could never reference it. Adding to \"object space\" is appending to something also. There's often a [[Laynes Law]] risk in using physical vocabulary to describe virtual things.",
            "id": "951db25dbf785468af35f09642e98804"
          },
          {
            "type": "html",
            "text": "<b>Using the File System</b>",
            "id": "08cd1c7cd2eaa02c8b54501e7707ef30"
          },
          {
            "type": "html",
            "text": "\nAnother approach that may at least appear less connected would be to name the implementation libraries or scripts with a combination of printer name and shape name:",
            "id": "6ce6949c6e951416d71532d8fcf9a9c4"
          },
          {
            "type": "code",
            "text": "  function runShape(printerName, shapeName) {\n  filename = stdPath . printerName . '_' . shapeName . '.driver'\n  status = executeFile(filename)\n  if (not status.good) {  // check status array\n    errorReport(status.errDescript)\n  }\n  }",
            "id": "a27177177a238acf05ec1b391aa2af03"
          },
          {
            "type": "html",
            "text": "This is basically using the file-system like a two-key hash array. Running them as a group is tougher than in the table example, I would note.",
            "id": "9395740e4e2f21b3c3e1941176083979"
          },
          {
            "type": "html",
            "text": "\nFiles may resemble:",
            "id": "a5d13da90d0b3e7799887c3569eb44ab"
          },
          {
            "type": "code",
            "text": "  Lexmark1000_circle.driver\n  Lexmark1000_square.driver\n  HP4270jet_circle.driver\n  HP4270jet_square.driver\n  ...etc...",
            "id": "0b9ed29f883a661807f36cf5e29ee9fb"
          },
          {
            "type": "html",
            "text": "The advantage of this approach is that we can add new drivers without having to open or alter any existing driver files. However, the drawback is that we cannot ship new printers or new shapes in a single file for better packaging. The optimum solution depends on the [[Change Pattern]](s) that one expects or observes. If mostly new printers are added and not new shapes, then grouping them by printer (a single printer per file) would be the most convenient. However, if new shapes were added more often than new printers, then making shape files (with all printers in them) would be the way to go. If the pattern is pretty even or chaotic, then either approach, or the finer granularity approach shown above may be the way to go.",
            "id": "1bc2efc239bd53a514bd533a91894808"
          },
          {
            "type": "html",
            "text": "\nHowever, an installation utility may be more appropriate than allowing the user to insert and/or replace files by themselves. If we go that route, then the database approach can also be used since the \"storage mechanism\" is not something the user directly faces anyhow. They just receive a file of changes to load in and let a Wizard-like thing guide them through loading. Some may argue that a database is an [[Abstraction Inversion]] (overkill), but if flexibility with regard to change-pattern is what you really want, then it may be the best approach. (I used to use [[Nimble Database]] technology extensively, so don't view DB's as inherently bulky.) But if there are only a few hundred rather than thousands, then files are sufficient.",
            "id": "a23367a9793620c790e3324ab5b1e76f"
          },
          {
            "type": "html",
            "text": "{Code indentation damaged due to [[Tab Munging]]}",
            "id": "cd0992041610a97517486843b1c9c4d7"
          },
          {
            "type": "html",
            "text": "--top",
            "id": "d8a78936d330fbf309ec8246097fa3df"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "\nBelow is an example in [[Perl Language]] that uses the Class::Multimethods module by [[Damian Conway]]. For details, see the following resources:",
            "id": "46b255476546c5c6de74ff7ed204ad68"
          },
          {
            "type": "html",
            "text": " <b>Tutorial:</b> [http://search.cpan.org/src/DCONWAY/Class-Multimethods-1.70/tutorial.html search.cpan.org]",
            "id": "1d5c92762b5f38aea7112bc945041a0d"
          },
          {
            "type": "html",
            "text": " <b>[[The Perl Journal]] article:</b> [http://www.samag.com/documents/s=1274/sam05010010/ www.samag.com]",
            "id": "ea659f3c9d68cf5f2270a946d73380be"
          },
          {
            "type": "html",
            "text": " <b>CPAN:</b> [http://search.cpan.org/author/DCONWAY/Class-Multimethods/lib/Class/Multimethods.pod search.cpan.org]",
            "id": "f26b69571019d4890fb226ef8ce864cd"
          },
          {
            "type": "html",
            "text": "-- [[Greg Bacon]]",
            "id": "5af8b7c3b6b7bde41c553e575bebbad1"
          },
          {
            "type": "code",
            "text": " #! /usr/local/bin/perl",
            "id": "fe9327472fab5ff1fe224959bc4dc534"
          },
          {
            "type": "code",
            "text": " use 5.005;\n use warnings;\n use strict;",
            "id": "72d223f8d2460f14fe48e58fff89a106"
          },
          {
            "type": "code",
            "text": " package Figure;\n # dummy placeholder\n $Figure::VERSION = '1.0';",
            "id": "8333e6d10d5df72c887630695570c0fa"
          },
          {
            "type": "code",
            "text": " package Printer;\n use Carp;\n use Class::Multimethods;\n # catchall\n multimethod\n  printFigure => ('Printer', 'Figure') =>\n   sub {\n    my $p = ref $_[0];\n    my $f = ref $_[1];\n    confess \"$0: printFigure: unknown combination: $p, $f\";\n   };",
            "id": "b773a4119807912ab8da91e5b119bc61"
          },
          {
            "type": "code",
            "text": " package Inkjet''''''Printer;\n use base 'Printer';\n use Class::Multimethods;",
            "id": "0b5a8e86dbdece2bcd343def24530b85"
          },
          {
            "type": "code",
            "text": " { # register in Printer class\n  package Printer;\n  multimethod\n   printFigure => ('Inkjet''''''Printer', 'Circle') =>\n    sub {\n     Inkjet''''''Printer::printCircle($_[0], $_[1]);\n    };\n  multimethod\n   printFigure => ('Inkjet''''''Printer', 'Rectangle') =>\n    sub {\n     Inkjet''''''Printer::printRectangle($_[0], $_[1]);\n    };\n }\n sub new {\n  my $class = shift;\n  bless [] => $class;\n }\n sub printCircle {\n  # ... rasterizing logic for inkjet printing of circles here ...\n  print \"Inkjet printer prints a circle.\\n\";\n }\n sub printRectangle {\n  # ... rasterizing logic for inkjet printing of rectangles here ...\n  print \"Inkjet printer prints a rectangle.\\n\";\n }",
            "id": "1bf3ee0dfb5e7f091264cd81ec466740"
          },
          {
            "type": "code",
            "text": " package Postscript''''''Printer;\n use base 'Printer';\n use Class::Multimethods;",
            "id": "0fc43e5ab28ff99bdef3ddb2c1de4f98"
          },
          {
            "type": "code",
            "text": " { # register in Printer class\n  package Printer;\n  multimethod\n   printFigure => ('Postscript''''''Printer', 'Circle') =>\n    sub {\n     Postscript''''''Printer::printCircle($_[0], $_[1]);\n    };\n  multimethod\n   printFigure => ('Postscript''''''Printer', 'Rectangle') =>\n    sub {\n     Postscript''''''Printer::printRectangle($_[0], $_[1]);\n    };\n }\n sub new {\n  my $class = shift;\n  bless [] => $class;\n }\n sub printCircle {\n  # ... postscript preprocessing logic for circles here ...\n  print \"Post''''''Script printer prints a cirlce.\\n\";\n }\n sub printRectangle {\n  # ... postscript preprocessing logic for rectangles here ...\n  print \"Post''''''Script printer prints a rectangle.\\n\";\n }",
            "id": "196a3356807cd982fedd8ee33714f8a3"
          },
          {
            "type": "code",
            "text": " package Circle;\n use base 'Figure';\n sub new {\n  my $class = shift;\n  bless [] => $class;\n }",
            "id": "376f3b35c798a3194ecfb85934ac0a49"
          },
          {
            "type": "code",
            "text": " package Rectangle;\n use base 'Figure';\n sub new {\n  my $class = shift;\n  bless [] => $class;\n }",
            "id": "266199fcf92cc0c8bb8e90503052b979"
          },
          {
            "type": "code",
            "text": " ## main\n package main;",
            "id": "e7338ff99191be34a8e27f403a43d19d"
          },
          {
            "type": "code",
            "text": " my @figures  = (Circle->new,    Rectangle->new);\n my @printers = (Postscript''''''Printer->new, Inkjet''''''Printer->new);\n foreach my $f (@figures) {\n  foreach my $p (@printers) {\n   # must work for any Printer or Figure!\n   $p->printFigure($f);\n  }\n }",
            "id": "99245e1feeecc403cd40733aa7b35a06"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "\nI'm surprised nobody's offered a solution in a language that supports [[Multi Methods]], as this is exactly what they're for. Here's one in [[Dylan Language]] (the [[Common Lisp]] solution would be similar, just with more parentheses):",
            "id": "0696bccf55999b68a71655f9fa980229"
          },
          {
            "type": "code",
            "text": "  define class <figure> (<object>) end;\n  define class <printer> (<object>) end;",
            "id": "3d438abdb96f6e0b731046b815ba5c62"
          },
          {
            "type": "code",
            "text": "  define class <circle> (<figure>) end;\n  define class <rectangle> (<figure>) end;\n  define class <inkjet-printer> (<printer>) end;\n  define class <postscript-printer> (<printer>) end;",
            "id": "32d4d80e4786a9a87afe6a9c29c4ef72"
          },
          {
            "type": "html",
            "text": "define generic print (printer ::<br><printer>, shape :: <figure>);",
            "id": "6f1a70a5560f952352f1005c2f59cd25"
          },
          {
            "type": "html",
            "text": "define method print (printer ::<br><inkjet-printer>, shape :: <circle>)",
            "id": "3b5f128027b843564c2999a9166f9372"
          },
          {
            "type": "code",
            "text": "  format-out(\"Inkjet printer prints a circle.\");\n  end;",
            "id": "53e881c7b7cc110e6288a186e59de6fc"
          },
          {
            "type": "html",
            "text": "define method print (printer ::<br><postscript-printer>, shape :: <circle>)",
            "id": "07b9f817163f00b13d018cf9d0d5f45c"
          },
          {
            "type": "code",
            "text": "  format-out(\"Postscript printer prints a circle.\");\n  end;",
            "id": "0bcccfc5f7642281c6b619888094e227"
          },
          {
            "type": "html",
            "text": "define method print (printer ::<br><inkjet-printer>, shape :: <rectangle>)",
            "id": "d01c422ef979566be242cc04de1dd089"
          },
          {
            "type": "code",
            "text": "  format-out(\"Inkjet printer prints a rectangle.\");\n  end;",
            "id": "08c1a69f6d79a03f0b761b825424fd7d"
          },
          {
            "type": "html",
            "text": "define method print (printer ::<br><postscript-printer>, shape :: <rectangle>)",
            "id": "b58ba669a0271ee126ddc54642d1fb3c"
          },
          {
            "type": "code",
            "text": "  format-out(\"Postscript printer prints a rectangle.\");\n  end;",
            "id": "f523183e1356f6e28e413a07ae08e16b"
          },
          {
            "type": "code",
            "text": "  // Client code...\n  define method print-all-everywhere (\n  client :: <client>,\n  printers :: limited(<collection>, of: <printer>\n  shapes :: limited(<collection>, of: <figure>)\n  do(curry(do, print, printers), shapes);\n  end;",
            "id": "0c198877406e8a2f86283cbd1edd3639"
          },
          {
            "type": "html",
            "text": "All the functionality of the original, and no code bloat. The language handles all the dispatching. The standard library handles the iteration (do is a function that takes a function and a collection, and applies the function to every element in the collection). If you want to define a new shape or printer, you just subclass <figure> or <printer> and then define the appropriate methods on print. If there's common functionality, you can define an intermediate subclass and factor out the appropriate functionality into methods on that class.",
            "id": "c25a285d0683920a679c3f2fdd4ccbb7"
          },
          {
            "type": "html",
            "text": "-- [[Jonathan Tang]]",
            "id": "13ff33ebabf07bd98e097183396a0d05"
          },
          {
            "type": "html",
            "text": "\nThe same solution in the [[Nice Language]]. It might be more readable to some, since the syntax is close to Java.",
            "id": "f023d0e083e9593c2dc908e5d04cff32"
          },
          {
            "type": "code",
            "text": "  abstract class Figure {}\n  abstract class Printer {}",
            "id": "d2c8177329acb6e0e4a839d7246a8d4f"
          },
          {
            "type": "code",
            "text": "  class Circle extends Figure {}\n  class Rectangle extends Figure {}",
            "id": "14d271022531a05df4d52399e5a835e2"
          },
          {
            "type": "code",
            "text": "  class Inkjet''''''Printer extends Printer {}\n  class Postscript''''''Printer extends Printer {}",
            "id": "4524421d54916894accb02c9dac6ff17"
          },
          {
            "type": "code",
            "text": "  void print(Printer printer, Figure shape);",
            "id": "2d890f9d1b2937036cdaa1bc4980073e"
          },
          {
            "type": "code",
            "text": "  print(Inkjet''''''Printer printer, Circle shape) {\n  println(\"Inkjet printer prints a circle.\");\n  }",
            "id": "d6e2a1c60b04f86764f9740f85c11e89"
          },
          {
            "type": "code",
            "text": "  print(Postscript''''''Printer printer, Circle shape) {\n  println(\"Postscript printer prints a circle.\");\n  }",
            "id": "d72378ffacecf17b2c3a5e2dbeb21535"
          },
          {
            "type": "code",
            "text": "  print(Inkjet''''''Printer printer, Rectangle shape) {\n  println(\"Inkjet printer prints a rectangle.\");\n  }",
            "id": "819cd58ca408cfe07968a86a65a2bc30"
          },
          {
            "type": "code",
            "text": "  print(Postscript''''''Printer printer, Rectangle shape) {\n  println(\"Postscript printer prints a rectangle.\");\n  }",
            "id": "5f014f956fcf90da2e7e75e6929c943c"
          },
          {
            "type": "code",
            "text": "  // Client code...\n  void printAllEverywhere\n  (Collection<Printer> printers,\n  Collection<Figure> shapes)\n  {\n  printers.foreach(Printer p => shapes.foreach(Figure s => print(p,s)));\n  }",
            "id": "13d5798ddadfad7e8b1db92822e08e03"
          },
          {
            "type": "code",
            "text": "  void main(String[] args)\n  {\n  printAllEverywhere\n  ([ new Postscript''''''Printer(), new Inkjet''''''Printer() ],\n  [ new Circle(), new Rectangle() ]);\n  }",
            "id": "c5ffbfac1946a62f38c02276d79b6cb3"
          },
          {
            "type": "html",
            "text": "-- [[Daniel Bonniot]]",
            "id": "04e5d1d9d10ec360224b0810315a90df"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "\nI don't like the Java and C++ examples at all. If I add a new shape I have to modify every existing printer. I'd rather abstract the way shapes draw themselves to work with any printer (or the way printers draw shapes), then leave all shape knowledge in the shape class hierarchy. Then I can add new printers without touching shapes and new shapes without touching printers. -- [[Eric Hodges]]",
            "id": "f40c6dbcb79353bb4816370cff8b36d3"
          },
          {
            "type": "html",
            "text": "\nThat is, in general, very difficult to do. What would be the lowest-common denominator used by printers? Cubic bezier curves? Then you can't draw true circles. Pixels? Then you can't use your framework to output to a plotter. Etc. etc. At some point, you have to have a [[Lingua Franca]] that specifies the primitive Printer operations, and those operations will be reified as Figure classes. -- [[Anonymous Donor]]",
            "id": "0db1d73629f43f13ae0094b492f8c9e6"
          },
          {
            "type": "html",
            "text": "\nIt isn't too hard to do or it wouldn't be done. See [[Post Script]] and PCL. -- [[Eric Hodges]]",
            "id": "6658cc81dc4b029b5328e068b3fd5310"
          },
          {
            "type": "html",
            "text": "\nBut those might not recognize the printer's internal primitives. There are different ways to specify ellipses, for example: by two center points, by bounding rectangle, and by circle plus a \"flatness\" factor and angle. True, there might be groupings such that some printers will fall into one interface group and another will fall into another group. Of course, this is mostly a hypothetical thought experiment anyhow. But in reality there might be some efficiency trade-off between using a standard meta-layer and native primitives. The standard meta-layer may not match up one-to-one with a given printer's primitives. For example, some printers may have built-in dashed line patterns that don't match what the meta-language has. If you want to match, you have to use a bunch of small lines and dots to emulate the dashing of the other brand. -- top",
            "id": "11d65d76d29b078c18a12c8bc66a2d8a"
          },
          {
            "type": "html",
            "text": "\n[[Post Script]] and PCL don't have to recognize the printer's internal primitives. Each printer recognizes [[Post Script]] and/or PCL. -- bottom",
            "id": "cf5c3a13cd117ddaf54b3b6628e95c73"
          },
          {
            "type": "html",
            "text": "\nThen are [[Post Script]] and PCL examples of [[Bridge Pattern]] at work? -- [[Greg Bacon]]",
            "id": "0257d5b712186f1a5526c2e151b01eec"
          },
          {
            "type": "html",
            "text": "\nYou're not actually saying you've never heard of a printer that works with [[Post Script]], are you? -- francis",
            "id": "004ad9b5447ea3a9e052da8c6e6eed9b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "I am surprised that nobody mentioned how many real world solves this printer-shape problem, perhaps I am miss the point here? In C/C++ in Windows and OS/2 (likely in other windowing systems too) and in Java, you introduce a third entity, some kind of drawing space (Presentation Space in OS/2, Graphics in Java), that can draw some arbitrary shape \"primitives\" such as lines, circles, text, etc. All graphics drawing applications can draw to any given drawing space. Any new printer simply implements a method to provide the drawing space. -- [[Oliver Chung]]",
            "id": "9893582da157aa960098408c5f707277"
          },
          {
            "type": "html",
            "text": "\nThis problem is more of a thought experiment than an exercise in production printing drivers. -- [[Anonymous Donor]]",
            "id": "ddbe00e76696fcc77b73d5be5ed453f5"
          },
          {
            "type": "html",
            "text": "\nThe thought experiment reveals a weakness of the double dispatch strategy. It requires a two dimensional matrix of methods. Adding an element to one dimension forces the creation of a method for each element along the other dimension. Compare the cost of change curve with a [[Bridge Pattern]]. -- [[Eric Hodges]]",
            "id": "a0225ecc0c32eaa4e8b56e2ed86a59c9"
          },
          {
            "type": "html",
            "text": "\nThat makes for an interesting challenge: be able to add methods (or whatever they are called in other paradigms) where the number of dimensions is arbitrary without changing existing code or replacing an existing data structure. My first inclination would be to use the \"file name lookup\" approach above, but use names like \"d1=foo,d2=bar,d3=glob\", etc. (However, we would have to use something besides equal signs and commas, for they don't make safe filename characters.) \"d1=foo,d2=bar\" would not conflict with \"d1=foo,d2=bar,d3=glob\" because they are different strings. However, adding a file is \"changing an existing data structure\" if you view the file system as a data structure, which it is. No way out? -- top",
            "id": "cc5347fe53630b4e99cfa3ba413e697a"
          },
          {
            "type": "html",
            "text": "\nNo, the challenge isn't to add methods without changing code. Methods are code. The challenge is to add elements to one dimension of the matrix without adding a method for each element in the other dimension. If a new printer shows up you don't have to write a method to draw every shape on that printer. Or vice versa, if a new shape shows up you don't have to write a method to draw that shape on every printer. See [[Bridge Pattern]] for a common solution to this challenge. See the Java virtual machine for a widespread example of its use. -- bottom",
            "id": "9a206a4439db13f6edb2069b79d4a698"
          },
          {
            "type": "html",
            "text": "\nI don't think this is possible, unless there's some behavior common to the algorithms that you can factor out. Your [[Bridge Pattern]] solution relies on this toy example having these common data structures or behavior; all shapes can be rendered by [[Post Script]] as a \"current path\" plus the stroke, fill, or clipping operators, and then all printers can convert [[Post Script]] drawing primitives into colored regions on the page. But imagine that the problem was defined like this:",
            "id": "f9f071b2e6df902d3b4ed74a11216c09"
          },
          {
            "type": "code",
            "text": " (inkjet, circle) => print \"Foo\"\n (inkjet, rectangle) => print \"Bar\"\n (postscript, circle) => print \"Goo\"\n (postscript, rectangle) => print \"Gaa\"",
            "id": "46cc10a88eec31e88aac87185f94ceb0"
          },
          {
            "type": "html",
            "text": "This time, there's no common behavior that you can abstract to use as your \"bridge\". There're 4 different behaviors needed, to go with the 4 combinations of types. And if you had to add a new shape:",
            "id": "8e54a4367818c0023bbe179376802fc4"
          },
          {
            "type": "code",
            "text": " (inkjet, triangle) => print \"Glob\"\n (postscript, triangle) => print \"Blurp\"",
            "id": "8ed0b5c2fe0fb1ee1e69c5511dd708e2"
          },
          {
            "type": "html",
            "text": "It's pretty obvious that you would need to define new methods for each combination of types, because the problem now explicitly says that each required behavior is different, with no possibilities for factoring.",
            "id": "d5405fae06924a07a0cc9d4e14fd2160"
          },
          {
            "type": "html",
            "text": "\nGranted, in every real-world system I've worked with, there <i>have</i> been opportunities for factoring and I've been able to use the [[Bridge Pattern]], but this toy example was intended to illustrate a concept. ;)",
            "id": "28c05b17a782ce6b319267f187a1ec5c"
          },
          {
            "type": "html",
            "text": "\nMy solution to the general case would be to use an n-dimensional array filled with function objects (Runnables in Java). Indexing the array's quite tricky, at least with C/C++/Java family languages. I guess the simplest solution is to assign each class a sequential ordering within the hierarchy, and then add each Runnable to the dispatch table manually. Yes, this means keeping track of the class indexes manually. There's some superclass constructor magic you can pull to avoid this, but the best algorithm I can think of for this requires a hashtable lookup for every object instantiation (could you use static{} blocks to get around this?), and so may be performance-unacceptable.",
            "id": "1f1fc6c34e62a4386e5a6feeba2338ec"
          },
          {
            "type": "html",
            "text": "\nThis is all assuming I'm not allowed to use a language with [[Multi Methods]], of course. Makes you appreciate the trouble implementors of those languages go through for us.",
            "id": "f8b12f926fecac4c2e8653e84b7d1ea2"
          },
          {
            "type": "html",
            "text": "\nIncidentally, this approach is very similar to the optimum (so far) algorithm for [[Generic Function]] dispatch. That also uses an n-dimensional array, but it's compressed to reflect the inheritance graph (if a class doesn't define a method, it calls the method from its nearest superclass). The language also handles computation of the class indexes automatically, as well as linearizing the class hierarchy (both [[Dylan Language]] and [[Common Lisp]] support multiple inheritance). See\n[http://citeseer.nj.nec.com/dujardin96fast.html citeseer.nj.nec.com] and\n[http://www.cs.dartmouth.edu/reports/abstracts/TR2001-404/ www.cs.dartmouth.edu]",
            "id": "49f05aaf27c655a97eb07748a0d0dd38"
          },
          {
            "type": "html",
            "text": "-- [[Jonathan Tang]]",
            "id": "13ff33ebabf07bd98e097183396a0d05"
          },
          {
            "type": "html",
            "text": "\nThe fact that it's always been possible for you and me to find a bridge indicates something significant. We're asking different printers to produce the same output. The abstraction of that output ([[Post Script]] in this case) provides the bridge. Double dispatch is used when two abstractions intersect. Neither of us have ever wanted entirely different behavior for each intersection. We want similar realizations of the same abstraction in different contexts. -- [[Eric Hodges]]",
            "id": "388123b9fee84f53180a5ac2760fe03f"
          },
          {
            "type": "html",
            "text": "\nAnyone else remember <i>[[Display Postscript]]</i>? Sun spent a bunch of time and money proving that having a nice abstraction layer can turn your successful product into unusable MIP-sucking garbage, and that sometimes you need to go back and write MxN different pieces of code to do high-speed rendering. -- [[Austin Hastings]]",
            "id": "6a176b29ec40fb1ed125aec8634f0ea2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "[[Double Dispatch]] provides two levels of dispatch in a language context that only supports one, such as [[Java Language]], [[Smalltalk Language]], or [[Cee Plus Plus]]. One level of dispatch is always \"easy\", in that it can be extended without changing existing code. The second is always \"harder\", in that the new elements have to added to the existing first-level dispatch code.",
            "id": "1b313409515e9580a4a07a1a7c8e0b8f"
          },
          {
            "type": "html",
            "text": "\nIn the code example above, adding new kinds of printers is easy - the new printer must provide implementations of printCircle and printRectangle. Adding new shapes is hard - a new printNewShape method has to be added to each existing printer.",
            "id": "bc41bfbfc754a8d7756b759d889634c5"
          },
          {
            "type": "html",
            "text": "\nThis means that guessing which set of classes will change more frequently is an important design decision when using [[Double Dispatch]]. In the [[Visitor Pattern]], the implication is that adding Visitors is easy. Adding Visitees is hard.",
            "id": "0e0bfda3361f12dd60c33fb7c37a4bf3"
          },
          {
            "type": "html",
            "text": "\nIt's a bit like choosing row-major or column-major order in a 2-D array. It's simply a choice, we have to do the best we can.",
            "id": "e39866fce1fc919202743df43a0baf08"
          },
          {
            "type": "html",
            "text": "\nThe discussion about beziers, postscript and so on, is interesting but distracts from the [[Double Dispatch Example]]. Similarly, if a language has method overloading or multimethods, then [[Double Dispatch]] is still needed, it's just done by the language for you.",
            "id": "3fe96df63e38034a454c61a473676c53"
          },
          {
            "type": "html",
            "text": "<i>If I understand what we mean by \"method overloading\", then Java at least <b>does</b> take inheritance into account. I think \"method overloading\" means that several methods with the same name but different argument types are distinguished by the compiler. In Java, a method in a subclass that has the same signature as a method in its superclass is correctly inherited/overridden. I don't remember what [[Cee Plus Plus]] does in this case.</i>",
            "id": "a1a257d7f623cb2be8429e4551a6c64c"
          },
          {
            "type": "html",
            "text": "\nJava does not take inheritance into account when passing parameters at runtime, only at compile time, this isn't sufficient and is not at all like multimethods. Multimethods take the actual runtime type of the parameter into account when selecting the method to run. This is called [[Multiple Dispatch]], and is better than [[Double Dispatch]].",
            "id": "9bd67d636c152987d09bb7916b1ac270"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "\nIn practice, what appears to be the way it's done more often now is that an intermediate \"meta\" format or document is created. Each printer driver then reads this meta format and translates it as needed for its own needs. It is a declarative (data driven) solution rather than a behavioral one. Perhaps this was not the way it was done in the early days because it requires a fairly large work buffer on disk or RAM for the meta document. That space was too expensive on early machines. Thus, the above printer driver example is mostly an academic exercise. (I'm not sure if Postscript counts as a meta-format for printers.) -- top",
            "id": "21c39a984744c93e35127e2f2bbc8836"
          },
          {
            "type": "html",
            "text": "<i>So we should have stuck with Shapes, one of the [[Over Used Oop Examples]], and done intersection as that one doesn't have an IR that allows Bridging?</i>",
            "id": "4164941993f1813b223b48a670875e1f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "\nMoved game example to [[Delta Isolation]].\nSee also: [[International Ui Example]], [[Extrapolating Device Drivers]]",
            "id": "5815152b573ab1030fc9f1c9f828aed1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a4eb5e9da97f6e8b742942e5fd3c40fc"
          },
          {
            "type": "html",
            "text": "[[Category Comparisons]], [[Category Example]], [[Category Conditionals And Dispatching]]",
            "id": "c30304bf78d1c863e6a8ee01b9be961b"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?DoubleDispatchExample c2.com]",
            "id": "b35045f674015053b77b07865a4ac62a"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1699944331310
    }
  ]
}