{
  "title": "Live Programming",
  "story": [
    {
      "type": "html",
      "text": "A [[Live Programming]] environment is one where objects exist and interact in a continuous manner across updates and manipulations to the program. That is, the program can continue to process inputs and produce outputs even as it is being updated by a human programmer.",
      "id": "814ddd9d22139768405beb7561ab46b3"
    },
    {
      "type": "html",
      "text": "\n[[Live Programming]] is heavily used for digital DJs, combining and creating music on the fly with commands, updates, loops, etc. The 'liveness' of the [[Live Programming]] environment is also very useful for quick feedback from changes. [[Live Programming]] is considerably more 'alive' than a [[Read Eval Print Loop]] in that one is actively editing objects or relationships between them as they continue to interact. One is not 'pausing' the program to make an edit. A [[Live Programming]] environment doesn't imply a [[Read Eval Print Loop]] exists... though one might (if the language provides the needed features) dynamically hook the live program into a console or other GUI to allow the programmer to inject inputs or receive outputs.",
      "id": "9d77a3f1349f908309d8392aebf71f34"
    },
    {
      "type": "html",
      "text": "\n[[Smalltalk Language]] is one of the original languages providing a [[Live Programming]] environment. [[Lambda Moo]] would be another. Today, these have branched into [[Open Croquet]] and [[Second Life]].",
      "id": "46cedce30f0253e67d5e2f91a7074329"
    },
    {
      "type": "html",
      "text": "\nA [[Programming Language]] for [[Live Programming]] should be designed to localize the 'extent' of syntax errors. That is, an error in one part of the program shouldn't affect the interpretation of other parts of the program. For this reason, [[Graphical Programming Language]]s are very useful, as are [[Object Oriented Programming Language]]s that allow edits to the source-code of individual methods for individual objects (i.e. prototype-based). ",
      "id": "9e64480715a44c68362d6cf1f37ea061"
    },
    {
      "type": "html",
      "text": "\nAdditionally, to support [[Live Programming]], features such as '[[Compile Time Resolution]]' should generally be avoided, as the semantics of when they are to 'execute' become very unclear, and one may not wish to continuously execute code while editing it. Ensuring that execution of [[Side Effect]]s is either driven by input or demand-for-output rather than by 'staging' is useful for allowing one to control and manage a [[Live Programming]] system.",
      "id": "1354661673d3bb25349a8131c3ccba25"
    },
    {
      "type": "html",
      "text": "\nAlso, <i>runtime allocation</i> hurts [[Live Programming]] a bit. I.e. if one is creating and deleting objects at runtime, it becomes difficult for a human to track and update the system, and semantics for updates become a bit less clear (i.e. if you change a procedure that creates an object, to which degree should it change the objects it has already created?). Defining a clear [[Meta Object Protocol]] can help get past this hurt.",
      "id": "8df38bab71b72359c49a00967183942f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c41915364d9ac02df45a82473bb6eecc"
    },
    {
      "type": "html",
      "text": "<i>In 2002, I developed (and almost instantly grew disillusioned with) an experimental [[Live Programming]] [[Graphical Programming Language]] for the [[Java Platform]].  See [http://tomatoide.sourceforge.net/ tomatoide.sourceforge.net]  As I wrote at the time, \"modifying an application while it executes is an unusual and strangely exhilarating experience.\"</i>",
      "id": "d23c53296e4a4a948b6d8b495750841f"
    },
    {
      "type": "html",
      "text": "\nInteresting. What disillusioned you?",
      "id": "5a2702f5a29b4a98177fe9712ab3bcb4"
    },
    {
      "type": "html",
      "text": "<i>Amongst a number of problems that I believe to be entirely solvable and not worth discussing here, I ran up against two relatively-unsolvable issues that are mentioned particularly in connection with the \"icons on strings\" style of [[Graphical Programming Language]], but tend to apply to graphical programming in general:  First, graphical programming tends to produce a lower density of semantic content per unit of screen area than the corresponding text-based code.[1]  The amount of zooming and scrolling needed to grok the code is considerably more than that required for the corresponding text-based code.  Second, graphical programming forces the developer to consider the aesthetics and style of code in at least two geometrical dimensions (i.e., positioning of icons and connections in a 2D or 3D space) compared to only one required for text-based code (indentation).  It's notable that while icons-on-strings essentially represents code as something like a circuit diagram, complex circuit design tends to favour VHDL, for example, that represents circuits as a text-based programming language.</i>",
      "id": "4abf5dbb1a0a3af3d6e98718c58eaa30"
    },
    {
      "type": "html",
      "text": "<i>That said, I'm not dispensing entirely with [[Graphical Programming Language]]s, I simply deprecate the applicability of icons-on-strings to general-purpose programming.  There are certainly niche areas where GPLs work well (e.g., designing virtual instrumentation, audio processing, or implementing pixel shaders), and it was my interest in applying graphical programming to data-processing and database applications that led me (in part) to develop the [[Rel Project]] as a foundation for further work on higher-level (possibly graphical) database languages.  It's something to which I will eventually return.</i>",
      "id": "add96c4a41a9e273edd9962a2e8a47ac"
    },
    {
      "type": "html",
      "text": "--",
      "id": "02875b5704233454aa1e8e4c1c4ea08e"
    },
    {
      "type": "html",
      "text": "<i>[1] This is not to say that the use of icons or pictographs </i>inherently<i> forces lower semantic density.  Note that written Chinese, for example, demonstrates higher semantic density than written English.  The implications in terms of graphical programming are manifold, and probably do not belong here.</i>",
      "id": "218be0e276f1e7acd01c4d93c2ae7995"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c41915364d9ac02df45a82473bb6eecc"
    },
    {
      "type": "html",
      "text": "Musical Live Coding:<br>Quoth : [http://netjam.org/projects/quoth/ netjam.org]",
      "id": "ddce4d3487a06d09d9690f721d005762"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?LiveProgramming c2.com]",
      "id": "f6bae926a4cee0ac2d4492f8ee50ded7"
    }
  ],
  "journal": [
    {
      "date": 1301137689000,
      "id": "34a13b5036e7c7d1121f8d75736d8834",
      "type": "create",
      "item": {
        "title": "Live Programming",
        "story": [
          {
            "type": "html",
            "text": "A [[Live Programming]] environment is one where objects exist and interact in a continuous manner across updates and manipulations to the program. That is, the program can continue to process inputs and produce outputs even as it is being updated by a human programmer.",
            "id": "814ddd9d22139768405beb7561ab46b3"
          },
          {
            "type": "html",
            "text": "\n[[Live Programming]] is heavily used for digital DJs, combining and creating music on the fly with commands, updates, loops, etc. The 'liveness' of the [[Live Programming]] environment is also very useful for quick feedback from changes. [[Live Programming]] is considerably more 'alive' than a [[Read Eval Print Loop]] in that one is actively editing objects or relationships between them as they continue to interact. One is not 'pausing' the program to make an edit. A [[Live Programming]] environment doesn't imply a [[Read Eval Print Loop]] exists... though one might (if the language provides the needed features) dynamically hook the live program into a console or other GUI to allow the programmer to inject inputs or receive outputs.",
            "id": "9d77a3f1349f908309d8392aebf71f34"
          },
          {
            "type": "html",
            "text": "\n[[Smalltalk Language]] is one of the original languages providing a [[Live Programming]] environment. [[Lambda Moo]] would be another. Today, these have branched into [[Open Croquet]] and [[Second Life]].",
            "id": "46cedce30f0253e67d5e2f91a7074329"
          },
          {
            "type": "html",
            "text": "\nA [[Programming Language]] for [[Live Programming]] should be designed to localize the 'extent' of syntax errors. That is, an error in one part of the program shouldn't affect the interpretation of other parts of the program. For this reason, [[Graphical Programming Language]]s are very useful, as are [[Object Oriented Programming Language]]s that allow edits to the source-code of individual methods for individual objects (i.e. prototype-based). ",
            "id": "9e64480715a44c68362d6cf1f37ea061"
          },
          {
            "type": "html",
            "text": "\nAdditionally, to support [[Live Programming]], features such as '[[Compile Time Resolution]]' should generally be avoided, as the semantics of when they are to 'execute' become very unclear, and one may not wish to continuously execute code while editing it. Ensuring that execution of [[Side Effect]]s is either driven by input or demand-for-output rather than by 'staging' is useful for allowing one to control and manage a [[Live Programming]] system.",
            "id": "1354661673d3bb25349a8131c3ccba25"
          },
          {
            "type": "html",
            "text": "\nAlso, <i>runtime allocation</i> hurts [[Live Programming]] a bit. I.e. if one is creating and deleting objects at runtime, it becomes difficult for a human to track and update the system, and semantics for updates become a bit less clear (i.e. if you change a procedure that creates an object, to which degree should it change the objects it has already created?). Defining a clear [[Meta Object Protocol]] can help get past this hurt.",
            "id": "8df38bab71b72359c49a00967183942f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c41915364d9ac02df45a82473bb6eecc"
          },
          {
            "type": "html",
            "text": "<i>In 2002, I developed (and almost instantly grew disillusioned with) an experimental [[Live Programming]] [[Graphical Programming Language]] for the [[Java Platform]].  See [http://tomatoide.sourceforge.net/ tomatoide.sourceforge.net]  As I wrote at the time, \"modifying an application while it executes is an unusual and strangely exhilarating experience.\"</i>",
            "id": "d23c53296e4a4a948b6d8b495750841f"
          },
          {
            "type": "html",
            "text": "\nInteresting. What disillusioned you?",
            "id": "5a2702f5a29b4a98177fe9712ab3bcb4"
          },
          {
            "type": "html",
            "text": "<i>Amongst a number of problems that I believe to be entirely solvable and not worth discussing here, I ran up against two relatively-unsolvable issues that are mentioned particularly in connection with the \"icons on strings\" style of [[Graphical Programming Language]], but tend to apply to graphical programming in general:  First, graphical programming tends to produce a lower density of semantic content per unit of screen area than the corresponding text-based code.[1]  The amount of zooming and scrolling needed to grok the code is considerably more than that required for the corresponding text-based code.  Second, graphical programming forces the developer to consider the aesthetics and style of code in at least two geometrical dimensions (i.e., positioning of icons and connections in a 2D or 3D space) compared to only one required for text-based code (indentation).  It's notable that while icons-on-strings essentially represents code as something like a circuit diagram, complex circuit design tends to favour VHDL, for example, that represents circuits as a text-based programming language.</i>",
            "id": "4abf5dbb1a0a3af3d6e98718c58eaa30"
          },
          {
            "type": "html",
            "text": "<i>That said, I'm not dispensing entirely with [[Graphical Programming Language]]s, I simply deprecate the applicability of icons-on-strings to general-purpose programming.  There are certainly niche areas where GPLs work well (e.g., designing virtual instrumentation, audio processing, or implementing pixel shaders), and it was my interest in applying graphical programming to data-processing and database applications that led me (in part) to develop the [[Rel Project]] as a foundation for further work on higher-level (possibly graphical) database languages.  It's something to which I will eventually return.</i>",
            "id": "add96c4a41a9e273edd9962a2e8a47ac"
          },
          {
            "type": "html",
            "text": "--",
            "id": "02875b5704233454aa1e8e4c1c4ea08e"
          },
          {
            "type": "html",
            "text": "<i>[1] This is not to say that the use of icons or pictographs </i>inherently<i> forces lower semantic density.  Note that written Chinese, for example, demonstrates higher semantic density than written English.  The implications in terms of graphical programming are manifold, and probably do not belong here.</i>",
            "id": "218be0e276f1e7acd01c4d93c2ae7995"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c41915364d9ac02df45a82473bb6eecc"
          },
          {
            "type": "html",
            "text": "Musical Live Coding:<br>Quoth : [http://netjam.org/projects/quoth/ netjam.org]",
            "id": "ddce4d3487a06d09d9690f721d005762"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?LiveProgramming c2.com]",
            "id": "f6bae926a4cee0ac2d4492f8ee50ded7"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1626125144812
    }
  ]
}