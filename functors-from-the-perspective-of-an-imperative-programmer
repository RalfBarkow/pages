{
  "title": "Functors from the Perspective of an Imperative Programmer",
  "story": [
    {
      "type": "markdown",
      "id": "16a7c58d445edf4b",
      "text": "[https://bartoszmilewski.com/2015/01/20/functors/ Functors] manifest themselves in functional programming as containers in which the elements may be transformed. In Haskell this is represented by the function `fmap` with the type signature"
    },
    {
      "type": "code",
      "id": "9f1406c4c5829d47",
      "text": "fmap :: Functor f => (a -> b) -> f a -> f b\n"
    },
    {
      "type": "markdown",
      "id": "c1734f25ff76f57f",
      "text": "This perspective unifies different containers, for example [https://blog.ploeh.dk/2018/03/22/functors/ lists] and [https://blog.ploeh.dk/2018/08/06/a-tree-functor/ trees]. The list type\n"
    },
    {
      "type": "code",
      "id": "70e0ab23d47d2a17",
      "text": "data List a = Nil \n            | Cons a (List a)\n"
    },
    {
      "type": "markdown",
      "id": "6ce23fdad5cea3e5",
      "text": "is a recursive data type whose elements may be transformed by the `map` function. Thus, the implementation for `fmap` is just `map`.\n"
    },
    {
      "type": "code",
      "id": "81af3ab7420bbccc",
      "text": "fmap _ Nil = Nil\nfmap f x:xs = (f x):fmap f xs \n"
    },
    {
      "type": "markdown",
      "id": "aa6bdd7708b73571",
      "text": "Similarly, the implementation for a tree "
    },
    {
      "type": "code",
      "id": "ec1ee4154711e331",
      "text": "data Tree a = Leaf\n            | Node a \n                   (Tree a) \n                   (Tree a)\n\n"
    },
    {
      "type": "markdown",
      "id": "01a1f125a6fa266c",
      "text": "walks recursively through the right and left sub trees: "
    },
    {
      "type": "code",
      "id": "76d65e783b09d477",
      "text": "fmap _ Leaf = Leaf\nfmap f (Node a l r) = Node (f a) \n                           (fmap f l) \n                           (fmap f r)"
    },
    {
      "type": "markdown",
      "id": "ff93d2436ba2b420",
      "text": "In imperative programming tree traversal is often implemented with the [https://blog.ploeh.dk/2018/08/13/a-visitor-functor/ visitor pattern]."
    },
    {
      "type": "markdown",
      "id": "ccb5057a25dc6130",
      "text": "This leaves many imperative programmers with the questions why the abstraction of a functor is needed here. The introduction of category theory to such well known matters seems overly ambitious. One reason for this impression is that functors in Haskell are just a special case of a richer abstraction. Functors translate between different categories. The Haskell data types and functions form the [https://ncatlab.org/nlab/show/Haskell category Hask]. Thus, in Haskell functors only translate beween `Hask` and `Hask`. "
    },
    {
      "type": "markdown",
      "id": "0296bbd81a63ee3f",
      "text": "A general functor `F` maps the objects and morphisms from a category `A` to the objects and morphisms in `B`. The functor has to obey the identity and composition laws. This contributes to the terse representation in category theory through because many coherence conditions are implicitly defined."
    },
    {
      "type": "mathjax",
      "id": "89d7d145b1697e7c",
      "text": "F : A -> B"
    },
    {
      "type": "markdown",
      "id": "243ea24246849894",
      "text": "A functor in `Hask`, for example the list and tree functor discussed above maps from `Hask` to `Hask`."
    },
    {
      "type": "mathjax",
      "id": "5f97ba7136da3539",
      "text": "G: Hask -> Hask"
    },
    {
      "type": "markdown",
      "id": "229aec36e55c3403",
      "text": "This is never made explicit because it is a degenerate case."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Functors from the Perspective of an Imperative Programmer",
        "story": []
      },
      "date": 1676533396161
    },
    {
      "item": {
        "type": "factory",
        "id": "8b0cfe7786de0338"
      },
      "id": "8b0cfe7786de0338",
      "type": "add",
      "date": 1676533399666
    },
    {
      "type": "edit",
      "id": "8b0cfe7786de0338",
      "item": {
        "type": "paragraph",
        "id": "8b0cfe7786de0338",
        "text": "Functors "
      },
      "date": 1676726259156
    },
    {
      "type": "edit",
      "id": "8b0cfe7786de0338",
      "item": {
        "type": "paragraph",
        "id": "8b0cfe7786de0338",
        "text": "Functors manifest themselves in functional programming as containers in which the elements may be transformed. In Haskell this is represented by the function"
      },
      "date": 1676726329588
    },
    {
      "item": {
        "type": "factory",
        "id": "779eb2fc0332cd63"
      },
      "id": "779eb2fc0332cd63",
      "type": "add",
      "after": "a45346bedbd56aad",
      "date": 1676726331508
    },
    {
      "type": "remove",
      "id": "779eb2fc0332cd63",
      "date": 1676726337601
    },
    {
      "item": {
        "type": "factory",
        "id": "9f1406c4c5829d47"
      },
      "id": "9f1406c4c5829d47",
      "type": "add",
      "after": "8b0cfe7786de0338",
      "date": 1676726340230
    },
    {
      "type": "edit",
      "id": "9f1406c4c5829d47",
      "item": {
        "type": "code",
        "id": "9f1406c4c5829d47",
        "text": "fmap :: Functor f => (a -> b) -> f a -> f b\n"
      },
      "date": 1676726367013
    },
    {
      "type": "edit",
      "id": "8b0cfe7786de0338",
      "item": {
        "type": "paragraph",
        "id": "8b0cfe7786de0338",
        "text": "Functors manifest themselves in functional programming as containers in which the elements may be transformed. In Haskell this is represented by the function `fmap` with the type signature"
      },
      "date": 1676726384178
    },
    {
      "type": "remove",
      "id": "8b0cfe7786de0338",
      "date": 1676726390271
    },
    {
      "item": {
        "type": "factory",
        "id": "16a7c58d445edf4b"
      },
      "id": "16a7c58d445edf4b",
      "type": "add",
      "after": "9f1406c4c5829d47",
      "date": 1676726391867
    },
    {
      "type": "edit",
      "id": "16a7c58d445edf4b",
      "item": {
        "type": "markdown",
        "id": "16a7c58d445edf4b",
        "text": "Functors manifest themselves in functional programming as containers in which the elements may be transformed. In Haskell this is represented by the function `fmap` with the type signature"
      },
      "date": 1676726395204
    },
    {
      "id": "16a7c58d445edf4b",
      "type": "move",
      "order": [
        "16a7c58d445edf4b",
        "9f1406c4c5829d47"
      ],
      "date": 1676726397677
    },
    {
      "item": {
        "type": "factory",
        "id": "c1734f25ff76f57f"
      },
      "id": "c1734f25ff76f57f",
      "type": "add",
      "after": "9f1406c4c5829d47",
      "date": 1676726403994
    },
    {
      "type": "edit",
      "id": "c1734f25ff76f57f",
      "item": {
        "type": "markdown",
        "id": "c1734f25ff76f57f",
        "text": "This perspective unifies "
      },
      "date": 1676726424005
    },
    {
      "type": "edit",
      "id": "c1734f25ff76f57f",
      "item": {
        "type": "markdown",
        "id": "c1734f25ff76f57f",
        "text": "This perspective unifies the different containers, for example lists and trees. The list type\n"
      },
      "date": 1676726704702
    },
    {
      "item": {
        "type": "factory",
        "id": "70e0ab23d47d2a17"
      },
      "id": "70e0ab23d47d2a17",
      "type": "add",
      "after": "c1734f25ff76f57f",
      "date": 1676726706498
    },
    {
      "type": "edit",
      "id": "70e0ab23d47d2a17",
      "item": {
        "type": "code",
        "id": "70e0ab23d47d2a17",
        "text": "data List a = Nil \n            | Cons a (List a)\n"
      },
      "date": 1676726733521
    },
    {
      "item": {
        "type": "factory",
        "id": "6ce23fdad5cea3e5"
      },
      "id": "6ce23fdad5cea3e5",
      "type": "add",
      "after": "70e0ab23d47d2a17",
      "date": 1676726735562
    },
    {
      "type": "edit",
      "id": "6ce23fdad5cea3e5",
      "item": {
        "type": "markdown",
        "id": "6ce23fdad5cea3e5",
        "text": "is a recursive data type whose elements may be transformed by the `map` function. Thus the implementation for `fmap` is just `map`.\n"
      },
      "date": 1676726801587
    },
    {
      "item": {
        "type": "factory",
        "id": "04cd4d3336541d0b"
      },
      "id": "04cd4d3336541d0b",
      "type": "add",
      "after": "6ce23fdad5cea3e5",
      "date": 1676726803954
    },
    {
      "type": "edit",
      "id": "04cd4d3336541d0b",
      "item": {
        "type": "mathjax",
        "id": "04cd4d3336541d0b",
        "text": "fmap _ Nil = Nil\nfmap f x:xs = (f x):fmap f xs "
      },
      "date": 1676726850864
    },
    {
      "item": {
        "type": "factory",
        "id": "81af3ab7420bbccc"
      },
      "id": "81af3ab7420bbccc",
      "type": "add",
      "after": "04cd4d3336541d0b",
      "date": 1676726855615
    },
    {
      "type": "remove",
      "id": "04cd4d3336541d0b",
      "date": 1676726859509
    },
    {
      "type": "edit",
      "id": "81af3ab7420bbccc",
      "item": {
        "type": "code",
        "id": "81af3ab7420bbccc",
        "text": "fmap _ Nil = Nil\nfmap f x:xs = (f x):fmap f xs \n"
      },
      "date": 1676726861544
    },
    {
      "item": {
        "type": "factory",
        "id": "aa6bdd7708b73571"
      },
      "id": "aa6bdd7708b73571",
      "type": "add",
      "after": "81af3ab7420bbccc",
      "date": 1676726867031
    },
    {
      "type": "edit",
      "id": "aa6bdd7708b73571",
      "item": {
        "type": "markdown",
        "id": "aa6bdd7708b73571",
        "text": "Similarly, the implementation for a tree "
      },
      "date": 1676726904927
    },
    {
      "item": {
        "type": "factory",
        "id": "99ce344c4947c7dd"
      },
      "id": "99ce344c4947c7dd",
      "type": "add",
      "after": "aa6bdd7708b73571",
      "date": 1676726906420
    },
    {
      "type": "edit",
      "id": "99ce344c4947c7dd",
      "item": {
        "type": "mathjax",
        "id": "99ce344c4947c7dd",
        "text": "data Tree a = Leaf\n            | (Node a (Tree a) (Tree a)\n\n"
      },
      "date": 1676726954184
    },
    {
      "item": {
        "type": "factory",
        "id": "ec1ee4154711e331"
      },
      "id": "ec1ee4154711e331",
      "type": "add",
      "after": "99ce344c4947c7dd",
      "date": 1676726958584
    },
    {
      "type": "remove",
      "id": "99ce344c4947c7dd",
      "date": 1676726959984
    },
    {
      "type": "edit",
      "id": "ec1ee4154711e331",
      "item": {
        "type": "code",
        "id": "ec1ee4154711e331",
        "text": "data Tree a = Leaf\n            | (Node a (Tree a) (Tree a)\n\n"
      },
      "date": 1676726961455
    },
    {
      "item": {
        "type": "factory",
        "id": "01a1f125a6fa266c"
      },
      "id": "01a1f125a6fa266c",
      "type": "add",
      "after": "ec1ee4154711e331",
      "date": 1676726964940
    },
    {
      "type": "edit",
      "id": "01a1f125a6fa266c",
      "item": {
        "type": "markdown",
        "id": "01a1f125a6fa266c",
        "text": "walks recursively through the right and left sub trees: "
      },
      "date": 1676726997604
    },
    {
      "item": {
        "type": "factory",
        "id": "76d65e783b09d477"
      },
      "id": "76d65e783b09d477",
      "type": "add",
      "after": "01a1f125a6fa266c",
      "date": 1676726999044
    },
    {
      "type": "edit",
      "id": "76d65e783b09d477",
      "item": {
        "type": "code",
        "id": "76d65e783b09d477",
        "text": "fmap _ Leaf = Leaf\nfmap f (Node a l r) = Node (f a) \n                           (fmap f l) \n                           (fmap f r)"
      },
      "date": 1676727066123
    },
    {
      "type": "edit",
      "id": "ec1ee4154711e331",
      "item": {
        "type": "code",
        "id": "ec1ee4154711e331",
        "text": "data Tree a = Leaf\n            | Node a \n                   (Tree a) \n                   (Tree a)\n\n"
      },
      "date": 1676727081671
    },
    {
      "type": "edit",
      "id": "c1734f25ff76f57f",
      "item": {
        "type": "markdown",
        "id": "c1734f25ff76f57f",
        "text": "This perspective unifies the different containers, for example lists and [https://blog.ploeh.dk/2018/08/06/a-tree-functor/ trees]. The list type\n"
      },
      "date": 1676727169177
    },
    {
      "type": "edit",
      "id": "c1734f25ff76f57f",
      "item": {
        "type": "markdown",
        "id": "c1734f25ff76f57f",
        "text": "This perspective unifies the different containers, for example [https://blog.ploeh.dk/2018/03/22/functors/ lists] and [https://blog.ploeh.dk/2018/08/06/a-tree-functor/ trees]. The list type\n"
      },
      "date": 1676727231606
    },
    {
      "item": {
        "type": "factory",
        "id": "d8325f98ea8e0036"
      },
      "id": "d8325f98ea8e0036",
      "type": "add",
      "after": "76d65e783b09d477",
      "date": 1676727246566
    },
    {
      "type": "edit",
      "id": "d8325f98ea8e0036",
      "item": {
        "type": "markdown",
        "id": "d8325f98ea8e0036",
        "text": "This leaves many imperative programmers with the questions why the abstraction of a functor is needed here. Fi"
      },
      "date": 1676727288815
    },
    {
      "type": "edit",
      "id": "16a7c58d445edf4b",
      "item": {
        "type": "markdown",
        "id": "16a7c58d445edf4b",
        "text": "[https://bartoszmilewski.com/2015/01/20/functors/ Functors] manifest themselves in functional programming as containers in which the elements may be transformed. In Haskell this is represented by the function `fmap` with the type signature"
      },
      "date": 1676727316390
    },
    {
      "type": "edit",
      "id": "d8325f98ea8e0036",
      "item": {
        "type": "markdown",
        "id": "d8325f98ea8e0036",
        "text": "This leaves many imperative programmers with the questions why the abstraction of a functor is needed here. The introduction of category theory to such well known matters"
      },
      "date": 1676727381581
    },
    {
      "item": {
        "type": "factory",
        "id": "ff93d2436ba2b420"
      },
      "id": "ff93d2436ba2b420",
      "type": "add",
      "after": "d8325f98ea8e0036",
      "date": 1676727399470
    },
    {
      "type": "edit",
      "id": "ff93d2436ba2b420",
      "item": {
        "type": "markdown",
        "id": "ff93d2436ba2b420",
        "text": "In imperative programming tree traversal is often implemented with the [https://blog.ploeh.dk/2018/08/13/a-visitor-functor/ visitor pattern]"
      },
      "date": 1676727448264
    },
    {
      "id": "ff93d2436ba2b420",
      "type": "move",
      "order": [
        "16a7c58d445edf4b",
        "9f1406c4c5829d47",
        "c1734f25ff76f57f",
        "70e0ab23d47d2a17",
        "6ce23fdad5cea3e5",
        "81af3ab7420bbccc",
        "aa6bdd7708b73571",
        "ec1ee4154711e331",
        "01a1f125a6fa266c",
        "76d65e783b09d477",
        "ff93d2436ba2b420",
        "d8325f98ea8e0036"
      ],
      "date": 1676727452586
    },
    {
      "type": "edit",
      "id": "ff93d2436ba2b420",
      "item": {
        "type": "markdown",
        "id": "ff93d2436ba2b420",
        "text": "In imperative programming tree traversal is often implemented with the [https://blog.ploeh.dk/2018/08/13/a-visitor-functor/ visitor pattern]."
      },
      "date": 1676727457964
    },
    {
      "type": "edit",
      "id": "d8325f98ea8e0036",
      "item": {
        "type": "markdown",
        "id": "d8325f98ea8e0036",
        "text": "This leaves many imperative programmers with the questions why the abstraction of a functor is needed here. The introduction of category theory to such well known matters seems overly ambitious. On reason for this impression is that functors in Haskell are just a special case of a richer abstraction. The Haskell data types and "
      },
      "date": 1676727563660
    },
    {
      "type": "edit",
      "id": "d8325f98ea8e0036",
      "item": {
        "type": "markdown",
        "id": "d8325f98ea8e0036",
        "text": "This leaves many imperative programmers with the questions why the abstraction of a functor is needed here. The introduction of category theory to such well known matters seems overly ambitious. On reason for this impression is that functors in Haskell are just a special case of a richer abstraction. The Haskell data types and functions form the [https://ncatlab.org/nlab/show/Haskell category `Hask`]"
      },
      "date": 1676727608097
    },
    {
      "type": "remove",
      "id": "d8325f98ea8e0036",
      "date": 1676727611747
    },
    {
      "item": {
        "type": "factory",
        "id": "ccb5057a25dc6130"
      },
      "id": "ccb5057a25dc6130",
      "type": "add",
      "after": "ff93d2436ba2b420",
      "date": 1676727612918
    },
    {
      "type": "edit",
      "id": "ccb5057a25dc6130",
      "item": {
        "type": "markdown",
        "id": "ccb5057a25dc6130",
        "text": "This leaves many imperative programmers with the questions why the abstraction of a functor is needed here. The introduction of category theory to such well known matters seems overly ambitious. On reason for this impression is that functors in Haskell are just a special case of a richer abstraction. The Haskell data types and functions form the [https://ncatlab.org/nlab/show/Haskell category `Hask`]"
      },
      "date": 1676727615898
    },
    {
      "type": "edit",
      "id": "ccb5057a25dc6130",
      "item": {
        "type": "markdown",
        "id": "ccb5057a25dc6130",
        "text": "This leaves many imperative programmers with the questions why the abstraction of a functor is needed here. The introduction of category theory to such well known matters seems overly ambitious. On reason for this impression is that functors in Haskell are just a special case of a richer abstraction. The Haskell data types and functions form the [https://ncatlab.org/nlab/show/Haskell category Hask]. "
      },
      "date": 1676727629767
    },
    {
      "type": "edit",
      "id": "ccb5057a25dc6130",
      "item": {
        "type": "markdown",
        "id": "ccb5057a25dc6130",
        "text": "This leaves many imperative programmers with the questions why the abstraction of a functor is needed here. The introduction of category theory to such well known matters seems overly ambitious. One reason for this impression is that functors in Haskell are just a special case of a richer abstraction. The Haskell data types and functions form the [https://ncatlab.org/nlab/show/Haskell category Hask]. "
      },
      "date": 1676727793780
    },
    {
      "type": "edit",
      "id": "ccb5057a25dc6130",
      "item": {
        "type": "markdown",
        "id": "ccb5057a25dc6130",
        "text": "This leaves many imperative programmers with the questions why the abstraction of a functor is needed here. The introduction of category theory to such well known matters seems overly ambitious. One reason for this impression is that functors in Haskell are just a special case of a richer abstraction. Functors translate between different categories. The Haskell data types and functions form the [https://ncatlab.org/nlab/show/Haskell category Hask]. This, in Haskell functors only translate beween `Hask` and `Hask`. "
      },
      "date": 1676727883935
    },
    {
      "item": {
        "type": "factory",
        "id": "9a7147c8381b550c"
      },
      "id": "9a7147c8381b550c",
      "type": "add",
      "after": "ccb5057a25dc6130",
      "date": 1676727893864
    },
    {
      "type": "remove",
      "id": "9a7147c8381b550c",
      "date": 1676727901925
    },
    {
      "item": {
        "type": "factory",
        "id": "89d7d145b1697e7c"
      },
      "id": "89d7d145b1697e7c",
      "type": "add",
      "after": "ccb5057a25dc6130",
      "date": 1676727904040
    },
    {
      "type": "edit",
      "id": "89d7d145b1697e7c",
      "item": {
        "type": "mathjax",
        "id": "89d7d145b1697e7c",
        "text": "F : A -> B"
      },
      "date": 1676727925577
    },
    {
      "item": {
        "type": "factory",
        "id": "0296bbd81a63ee3f"
      },
      "id": "0296bbd81a63ee3f",
      "type": "add",
      "after": "89d7d145b1697e7c",
      "date": 1676727947978
    },
    {
      "type": "edit",
      "id": "0296bbd81a63ee3f",
      "item": {
        "type": "markdown",
        "id": "0296bbd81a63ee3f",
        "text": "A general functor `F` maps the objects and morphisms from a category `A` to the objects and morphisms in `B`.  "
      },
      "date": 1676728041704
    },
    {
      "id": "0296bbd81a63ee3f",
      "type": "move",
      "order": [
        "16a7c58d445edf4b",
        "9f1406c4c5829d47",
        "c1734f25ff76f57f",
        "70e0ab23d47d2a17",
        "6ce23fdad5cea3e5",
        "81af3ab7420bbccc",
        "aa6bdd7708b73571",
        "ec1ee4154711e331",
        "01a1f125a6fa266c",
        "76d65e783b09d477",
        "ff93d2436ba2b420",
        "ccb5057a25dc6130",
        "0296bbd81a63ee3f",
        "89d7d145b1697e7c"
      ],
      "date": 1676728044332
    },
    {
      "item": {
        "type": "factory",
        "id": "243ea24246849894"
      },
      "id": "243ea24246849894",
      "type": "add",
      "after": "89d7d145b1697e7c",
      "date": 1676728054978
    },
    {
      "type": "edit",
      "id": "243ea24246849894",
      "item": {
        "type": "markdown",
        "id": "243ea24246849894",
        "text": "A functor in `Hask`, for example the list and tree functor discussed above maps from `Hask` to `Hask`."
      },
      "date": 1676728100244
    },
    {
      "item": {
        "type": "factory",
        "id": "5f97ba7136da3539"
      },
      "id": "5f97ba7136da3539",
      "type": "add",
      "after": "243ea24246849894",
      "date": 1676728103675
    },
    {
      "type": "edit",
      "id": "5f97ba7136da3539",
      "item": {
        "type": "mathjax",
        "id": "5f97ba7136da3539",
        "text": "G: Hask -> Hask"
      },
      "date": 1676728114135
    },
    {
      "item": {
        "type": "factory",
        "id": "229aec36e55c3403"
      },
      "id": "229aec36e55c3403",
      "type": "add",
      "after": "5f97ba7136da3539",
      "date": 1676728118219
    },
    {
      "type": "edit",
      "id": "229aec36e55c3403",
      "item": {
        "type": "markdown",
        "id": "229aec36e55c3403",
        "text": "This is never made explicit because it is a degenerate case."
      },
      "date": 1676728169225
    },
    {
      "type": "edit",
      "id": "0296bbd81a63ee3f",
      "item": {
        "type": "markdown",
        "id": "0296bbd81a63ee3f",
        "text": "A general functor `F` maps the objects and morphisms from a category `A` to the objects and morphisms in `B`. The functor has to obey the identity and "
      },
      "date": 1676728190400
    },
    {
      "type": "edit",
      "id": "0296bbd81a63ee3f",
      "item": {
        "type": "markdown",
        "id": "0296bbd81a63ee3f",
        "text": "A general functor `F` maps the objects and morphisms from a category `A` to the objects and morphisms in `B`. The functor has to obey the identity and composition laws. This contributes to the terse representation in category theory through [Cohesion]"
      },
      "date": 1676728253684
    },
    {
      "type": "edit",
      "id": "c1734f25ff76f57f",
      "item": {
        "type": "markdown",
        "id": "c1734f25ff76f57f",
        "text": "This perspective unifies different containers, for example [https://blog.ploeh.dk/2018/03/22/functors/ lists] and [https://blog.ploeh.dk/2018/08/06/a-tree-functor/ trees]. The list type\n"
      },
      "date": 1676728776662
    },
    {
      "type": "edit",
      "id": "6ce23fdad5cea3e5",
      "item": {
        "type": "markdown",
        "id": "6ce23fdad5cea3e5",
        "text": "is a recursive data type whose elements may be transformed by the `map` function. Thus, the implementation for `fmap` is just `map`.\n"
      },
      "date": 1676728801890
    },
    {
      "type": "edit",
      "id": "ccb5057a25dc6130",
      "item": {
        "type": "markdown",
        "id": "ccb5057a25dc6130",
        "text": "This leaves many imperative programmers with the questions why the abstraction of a functor is needed here. The introduction of category theory to such well known matters seems overly ambitious. One reason for this impression is that functors in Haskell are just a special case of a richer abstraction. Functors translate between different categories. The Haskell data types and functions form the [https://ncatlab.org/nlab/show/Haskell category Hask]. Thus, in Haskell functors only translate beween `Hask` and `Hask`. "
      },
      "date": 1676728864594
    },
    {
      "type": "edit",
      "id": "0296bbd81a63ee3f",
      "item": {
        "type": "markdown",
        "id": "0296bbd81a63ee3f",
        "text": "A general functor `F` maps the objects and morphisms from a category `A` to the objects and morphisms in `B`. The functor has to obey the identity and composition laws. This contributes to the terse representation in category theory through because many coherence conditions are implicitly defined."
      },
      "date": 1676732722410
    },
    {
      "item": {
        "type": "factory",
        "id": "611b44ad767411d7"
      },
      "id": "611b44ad767411d7",
      "type": "add",
      "after": "229aec36e55c3403",
      "date": 1676981653317
    },
    {
      "type": "remove",
      "id": "611b44ad767411d7",
      "date": 1676981677723
    },
    {
      "type": "fork",
      "site": "johannes.tries.fed.wiki",
      "date": 1676997436239
    }
  ]
}