{
  "title": "Smart Pointer",
  "story": [
    {
      "type": "html",
      "text": "Any C++ class that overrides the -> operator can be used as a pointer. Smart pointers are usually used to automatically manage the lifetime of the object that they point to using the [[Resource Acquisition Is Initialization]] idiom. This is necessary to make code exception-safe: in robust C++ code there should (almost) never be raw pointers to dynamically allocated objects on the stack because those objects will not get deleted if an exception unwinds the stack.",
      "id": "20dcabb7ab735c8a9fe79211522cc8a0"
    },
    {
      "type": "html",
      "text": "\nThe -> operator of a [[Smart Pointer]] must return a pointer or another object that also has the -> operator. Thus, smart pointers can be \"chained\" by returning temporary smart pointers that do clever things in their constructor or destructor. For example, a smart pointer could return a chained smart pointer that locks/unlocks a mutex on the pointed-to object.",
      "id": "e87b96d0fe5a0556ebc77f1a67f38804"
    },
    {
      "type": "html",
      "text": "\nSmart pointers should also implement the * operator to return a reference to the pointee, in the same manner as built in pointers. However, this is not enforced by the language. Misuse of this feature can make code difficult to understand.",
      "id": "a303135fabb4f220d40456abcf1af68e"
    },
    {
      "type": "html",
      "text": "\nKnown uses:",
      "id": "75811682c2a34490d2700c7c1255a060"
    },
    {
      "type": "html",
      "text": " [[Auto Ptr]]:<br>the standard library contains one smart pointer class, auto_ptr<T> that deletes its pointee when destroyed.",
      "id": "2cf98efc51fba31bf8a3ad4e360344ad"
    },
    {
      "type": "html",
      "text": " Deprecated in C++11.",
      "id": "ac975e44155f8395c23792ec136e04a0"
    },
    {
      "type": "html",
      "text": " [[Unique Ptr]]:<br>the standard library added (in C++11) two smart pointer classes, one, unique_ptr<T>, is similar to auto_ptr<T>, but it can be moved.",
      "id": "b5132edd49c466ef6946bd403703170f"
    },
    {
      "type": "html",
      "text": " [[Shared Ptr]]:<br>the other, shared_ptr<T>, standardizes what used to be boost:shared_ptr<T>.",
      "id": "a2229162727ff7248a356c762d097830"
    },
    {
      "type": "html",
      "text": " C++ Programmers typically roll their own smart pointers to implement reference-counted garbage collection, because this is not provided by the standard library. (cf. [[Reference Counting]])",
      "id": "e9ad2ab6b80a792fd51ccb47de36d275"
    },
    {
      "type": "html",
      "text": " STL iterators implement the -> operator, and so can be used as smart pointers.  However, old implementations of the STL do not provide the -> operator.",
      "id": "ef4b0f6492133039506ab5df63d2d868"
    },
    {
      "type": "html",
      "text": " Most libraries designed to use Microsoft's [[Component Object Model]] provide smart-pointer types to manage object reference counts.",
      "id": "257136c2cdfef808373ee0ce0b1e3ffe"
    },
    {
      "type": "html",
      "text": " The CORBA C++ language mapping specifies smart-pointer types to manage reference counts on proxies and to manage memory for data used by the CORBA implementation.",
      "id": "6783f01715bbf70e0a6c470488501b60"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a63b0defdd116f01105d0b354fb9bc9c"
    },
    {
      "type": "html",
      "text": "<i>Does anyone know why this is not provided by the standard library? I think it should be.</i>",
      "id": "9c5a8137b4feb5f7801f411739844427"
    },
    {
      "type": "html",
      "text": "\nIt turns out the semantics are hard to get Right(TM).  And you need still 'dumb' pointers sometimes, so you can't just mandate only smart pointers. I think the comittee punted on this one.",
      "id": "d36d2a298adea34a4792eedc987dfaca"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a63b0defdd116f01105d0b354fb9bc9c"
    },
    {
      "type": "html",
      "text": "\nOne of the [[Cee Plus Plus Idioms]]",
      "id": "44bcedc49665a3b085e0dbf77ff73202"
    },
    {
      "type": "html",
      "text": "<i>You can find some smart pointer implementations at [http://www.boost.org www.boost.org]</i>",
      "id": "44d87bee0219554251c1d8dba7530228"
    },
    {
      "type": "html",
      "text": "\nSee also [[Cpp Counted Pointer Implementation]]",
      "id": "dd2fa5cffbe75151655cdf5bcc9a0166"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a63b0defdd116f01105d0b354fb9bc9c"
    },
    {
      "type": "html",
      "text": "\nCould someone tell me why a [[Smart Pointer]] does not violate [[Keep It Simple]]?",
      "id": "785e06d5e36bc63276ea943af7d5a81d"
    },
    {
      "type": "html",
      "text": "\nI agree that the convenience is desirable but it seems that this comes at the expense of additional complexity. There doesn't seem to be much simplicity about it. Even the author above admits that some of the finer implementation details of [[Smart Pointer]]s <i>can make code difficult to understand</i>.",
      "id": "323470131cdc60546cec8a516679f80b"
    },
    {
      "type": "html",
      "text": "<i>Although smart pointers themselves can be somewhat complex to design and implement, using them is usually very easy, and in fact simplifies a lot of code. The most common use of smart pointers is management of object lifetimes, which can be very hard to get right in some contexts. Choosing an appropriate smart pointer can make this management almost completely transparent. As usual, you pay with complexity in a low-level library utility in order to gain simplicity and ease-of-use in application code. It has always seemed like a good trade-off to me.</i>",
      "id": "de2f7465edc755790d78220933ad681b"
    },
    {
      "type": "html",
      "text": "<i>BTW, the phrase you quoted was almost certainly intended to apply to unconventional implementations of operator*, rather than to smart pointers in general. Overloading </i>any<i> operator with unusual semantics is invariably confusing and should be avoided.</i> -- [[Dan Muller]]",
      "id": "fb3682ab32bd603defe6688bd991ed17"
    },
    {
      "type": "html",
      "text": "[Thanks for your reply - I've clarified my question above to remove the misquote.]",
      "id": "3d62d326faf95bdeaca749572f53562c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a63b0defdd116f01105d0b354fb9bc9c"
    },
    {
      "type": "html",
      "text": "\nUse of smart pointers generally does simplify code.  A problem arises if you have lots of different kinds of smart pointers with different semantics.  For example, if you are writing a C++ application that uses ATL COM objects and CORBA, things can get confusing as you try to remember all the rules for all the pointer types.  But it's still easier than using raw pointers.",
      "id": "9ee482757662a63eb97f6801fb33c5bb"
    },
    {
      "type": "html",
      "text": "\nIt's important to remember that every [[Smart Pointer]] implementation you run into is going to be different from the ones you've seen before, and you need to investigate the subtleties.",
      "id": "b9313e54e0683702737ac24c73b4d5ee"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a63b0defdd116f01105d0b354fb9bc9c"
    },
    {
      "type": "html",
      "text": "(Years later...)",
      "id": "dce3bc94994d87555cd5f40a109652f8"
    },
    {
      "type": "html",
      "text": "\nI worked extensively with C++ for about a decade, and saw first-hand how disciplined use of smart pointers in a large C++ program gradually all but eliminated the kinds of memory management problems that plague C programs. In addition, due to the deterministic timing of object destruction in C++, the management of other kinds of resources was also eased. Now I've also worked for several years intensively with C#, and seen how dynamic memory management helps with the former, and helps not at all with the latter, leading to the introduction of mechanisms (IDispose) that are similar to C++-style smart pointers for scope-based resource management. Having again worked with C++ for the past few months, I find that the C++ approach is still appealing.",
      "id": "df9818470c1b9af31d5e362b94f27572"
    },
    {
      "type": "html",
      "text": "\nSpecifically, the choice of a smart pointer type is a succinct form of documentation. Use of auto_ptr indicates sole ownership, so that when reading existing code, you know immediately that aliasing of the reference object is unlikely, and you can see fairly clearly when ownership is transferred. In C# programs, I've often had great difficulty tracking down all the concurrent references to a given object in a (sometimes needlessly) complex program. If the object is mutable, being aware of these multiple references is critical to understanding runtime behavior.",
      "id": "b783d63a259f8e9e99d5ff9d28d15b0a"
    },
    {
      "type": "html",
      "text": "-- [[Dan Muller]]",
      "id": "34b3002aba012286bd8d39848ff57d40"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a63b0defdd116f01105d0b354fb9bc9c"
    },
    {
      "type": "html",
      "text": "See [[Smart Pointers Are Not]]",
      "id": "fead41821a998ed95461cfc8e2b590c2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a63b0defdd116f01105d0b354fb9bc9c"
    },
    {
      "type": "html",
      "text": "[[Category Garbage Collection]] [[Category Pointer]]",
      "id": "0127c34a1623d7df62fc119ae779e812"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?SmartPointer c2.com]",
      "id": "d2522e19fcff8a763fdcee240d967365"
    }
  ],
  "journal": [
    {
      "date": 1415455003000,
      "id": "5547f390300177157c0dbf7e840c9d19",
      "type": "create",
      "item": {
        "title": "Smart Pointer",
        "story": [
          {
            "type": "html",
            "text": "Any C++ class that overrides the -> operator can be used as a pointer. Smart pointers are usually used to automatically manage the lifetime of the object that they point to using the [[Resource Acquisition Is Initialization]] idiom. This is necessary to make code exception-safe: in robust C++ code there should (almost) never be raw pointers to dynamically allocated objects on the stack because those objects will not get deleted if an exception unwinds the stack.",
            "id": "20dcabb7ab735c8a9fe79211522cc8a0"
          },
          {
            "type": "html",
            "text": "\nThe -> operator of a [[Smart Pointer]] must return a pointer or another object that also has the -> operator. Thus, smart pointers can be \"chained\" by returning temporary smart pointers that do clever things in their constructor or destructor. For example, a smart pointer could return a chained smart pointer that locks/unlocks a mutex on the pointed-to object.",
            "id": "e87b96d0fe5a0556ebc77f1a67f38804"
          },
          {
            "type": "html",
            "text": "\nSmart pointers should also implement the * operator to return a reference to the pointee, in the same manner as built in pointers. However, this is not enforced by the language. Misuse of this feature can make code difficult to understand.",
            "id": "a303135fabb4f220d40456abcf1af68e"
          },
          {
            "type": "html",
            "text": "\nKnown uses:",
            "id": "75811682c2a34490d2700c7c1255a060"
          },
          {
            "type": "html",
            "text": " [[Auto Ptr]]:<br>the standard library contains one smart pointer class, auto_ptr<T> that deletes its pointee when destroyed.",
            "id": "2cf98efc51fba31bf8a3ad4e360344ad"
          },
          {
            "type": "html",
            "text": " Deprecated in C++11.",
            "id": "ac975e44155f8395c23792ec136e04a0"
          },
          {
            "type": "html",
            "text": " [[Unique Ptr]]:<br>the standard library added (in C++11) two smart pointer classes, one, unique_ptr<T>, is similar to auto_ptr<T>, but it can be moved.",
            "id": "b5132edd49c466ef6946bd403703170f"
          },
          {
            "type": "html",
            "text": " [[Shared Ptr]]:<br>the other, shared_ptr<T>, standardizes what used to be boost:shared_ptr<T>.",
            "id": "a2229162727ff7248a356c762d097830"
          },
          {
            "type": "html",
            "text": " C++ Programmers typically roll their own smart pointers to implement reference-counted garbage collection, because this is not provided by the standard library. (cf. [[Reference Counting]])",
            "id": "e9ad2ab6b80a792fd51ccb47de36d275"
          },
          {
            "type": "html",
            "text": " STL iterators implement the -> operator, and so can be used as smart pointers.  However, old implementations of the STL do not provide the -> operator.",
            "id": "ef4b0f6492133039506ab5df63d2d868"
          },
          {
            "type": "html",
            "text": " Most libraries designed to use Microsoft's [[Component Object Model]] provide smart-pointer types to manage object reference counts.",
            "id": "257136c2cdfef808373ee0ce0b1e3ffe"
          },
          {
            "type": "html",
            "text": " The CORBA C++ language mapping specifies smart-pointer types to manage reference counts on proxies and to manage memory for data used by the CORBA implementation.",
            "id": "6783f01715bbf70e0a6c470488501b60"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a63b0defdd116f01105d0b354fb9bc9c"
          },
          {
            "type": "html",
            "text": "<i>Does anyone know why this is not provided by the standard library? I think it should be.</i>",
            "id": "9c5a8137b4feb5f7801f411739844427"
          },
          {
            "type": "html",
            "text": "\nIt turns out the semantics are hard to get Right(TM).  And you need still 'dumb' pointers sometimes, so you can't just mandate only smart pointers. I think the comittee punted on this one.",
            "id": "d36d2a298adea34a4792eedc987dfaca"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a63b0defdd116f01105d0b354fb9bc9c"
          },
          {
            "type": "html",
            "text": "\nOne of the [[Cee Plus Plus Idioms]]",
            "id": "44bcedc49665a3b085e0dbf77ff73202"
          },
          {
            "type": "html",
            "text": "<i>You can find some smart pointer implementations at [http://www.boost.org www.boost.org]</i>",
            "id": "44d87bee0219554251c1d8dba7530228"
          },
          {
            "type": "html",
            "text": "\nSee also [[Cpp Counted Pointer Implementation]]",
            "id": "dd2fa5cffbe75151655cdf5bcc9a0166"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a63b0defdd116f01105d0b354fb9bc9c"
          },
          {
            "type": "html",
            "text": "\nCould someone tell me why a [[Smart Pointer]] does not violate [[Keep It Simple]]?",
            "id": "785e06d5e36bc63276ea943af7d5a81d"
          },
          {
            "type": "html",
            "text": "\nI agree that the convenience is desirable but it seems that this comes at the expense of additional complexity. There doesn't seem to be much simplicity about it. Even the author above admits that some of the finer implementation details of [[Smart Pointer]]s <i>can make code difficult to understand</i>.",
            "id": "323470131cdc60546cec8a516679f80b"
          },
          {
            "type": "html",
            "text": "<i>Although smart pointers themselves can be somewhat complex to design and implement, using them is usually very easy, and in fact simplifies a lot of code. The most common use of smart pointers is management of object lifetimes, which can be very hard to get right in some contexts. Choosing an appropriate smart pointer can make this management almost completely transparent. As usual, you pay with complexity in a low-level library utility in order to gain simplicity and ease-of-use in application code. It has always seemed like a good trade-off to me.</i>",
            "id": "de2f7465edc755790d78220933ad681b"
          },
          {
            "type": "html",
            "text": "<i>BTW, the phrase you quoted was almost certainly intended to apply to unconventional implementations of operator*, rather than to smart pointers in general. Overloading </i>any<i> operator with unusual semantics is invariably confusing and should be avoided.</i> -- [[Dan Muller]]",
            "id": "fb3682ab32bd603defe6688bd991ed17"
          },
          {
            "type": "html",
            "text": "[Thanks for your reply - I've clarified my question above to remove the misquote.]",
            "id": "3d62d326faf95bdeaca749572f53562c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a63b0defdd116f01105d0b354fb9bc9c"
          },
          {
            "type": "html",
            "text": "\nUse of smart pointers generally does simplify code.  A problem arises if you have lots of different kinds of smart pointers with different semantics.  For example, if you are writing a C++ application that uses ATL COM objects and CORBA, things can get confusing as you try to remember all the rules for all the pointer types.  But it's still easier than using raw pointers.",
            "id": "9ee482757662a63eb97f6801fb33c5bb"
          },
          {
            "type": "html",
            "text": "\nIt's important to remember that every [[Smart Pointer]] implementation you run into is going to be different from the ones you've seen before, and you need to investigate the subtleties.",
            "id": "b9313e54e0683702737ac24c73b4d5ee"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a63b0defdd116f01105d0b354fb9bc9c"
          },
          {
            "type": "html",
            "text": "(Years later...)",
            "id": "dce3bc94994d87555cd5f40a109652f8"
          },
          {
            "type": "html",
            "text": "\nI worked extensively with C++ for about a decade, and saw first-hand how disciplined use of smart pointers in a large C++ program gradually all but eliminated the kinds of memory management problems that plague C programs. In addition, due to the deterministic timing of object destruction in C++, the management of other kinds of resources was also eased. Now I've also worked for several years intensively with C#, and seen how dynamic memory management helps with the former, and helps not at all with the latter, leading to the introduction of mechanisms (IDispose) that are similar to C++-style smart pointers for scope-based resource management. Having again worked with C++ for the past few months, I find that the C++ approach is still appealing.",
            "id": "df9818470c1b9af31d5e362b94f27572"
          },
          {
            "type": "html",
            "text": "\nSpecifically, the choice of a smart pointer type is a succinct form of documentation. Use of auto_ptr indicates sole ownership, so that when reading existing code, you know immediately that aliasing of the reference object is unlikely, and you can see fairly clearly when ownership is transferred. In C# programs, I've often had great difficulty tracking down all the concurrent references to a given object in a (sometimes needlessly) complex program. If the object is mutable, being aware of these multiple references is critical to understanding runtime behavior.",
            "id": "b783d63a259f8e9e99d5ff9d28d15b0a"
          },
          {
            "type": "html",
            "text": "-- [[Dan Muller]]",
            "id": "34b3002aba012286bd8d39848ff57d40"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a63b0defdd116f01105d0b354fb9bc9c"
          },
          {
            "type": "html",
            "text": "See [[Smart Pointers Are Not]]",
            "id": "fead41821a998ed95461cfc8e2b590c2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a63b0defdd116f01105d0b354fb9bc9c"
          },
          {
            "type": "html",
            "text": "[[Category Garbage Collection]] [[Category Pointer]]",
            "id": "0127c34a1623d7df62fc119ae779e812"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?SmartPointer c2.com]",
            "id": "d2522e19fcff8a763fdcee240d967365"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1628112672094
    }
  ]
}