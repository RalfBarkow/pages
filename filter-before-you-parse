{
  "title": "Filter before You Parse",
  "story": [
    {
      "type": "paragraph",
      "id": "80583dbd3fe498be",
      "text": "Exploratory big data applications often run on raw unstructured or semi-structured data formats, such as JSON files or text logs. These applications can spend 80–90% of their execution time parsing the data. "
    },
    {
      "type": "paragraph",
      "id": "712da11c905a2d2c",
      "text": "In this paper, we propose a new approach for reducing this overhead: apply filters on the data’s raw bytestream before parsing. This technique, which we call raw filtering, leverages the features of modern hardware and the high selectivity of queries found in many exploratory applications. "
    },
    {
      "type": "markdown",
      "id": "95172c60870ebdfa",
      "text": "# Raw Filtering"
    },
    {
      "type": "paragraph",
      "id": "f625af5539f8eb70",
      "text": "With raw filtering, a user-specified query predicate is compiled into a set of filtering primitives called raw filters (RFs). RFs are fast, SIMD-based operators that occasionally yield false positives, but never false negatives. We combine multiple RFs into an RF cascade to decrease the false positive rate and maximize parsing throughput. Because the best RF cascade is data-dependent, we propose an optimizer that dynamically selects the combination of RFs with the best expected throughput, achieving within 10% of the global optimum cascade while adding less than 1.2% overhead. "
    },
    {
      "type": "markdown",
      "id": "2c18c7214ea0cb65",
      "text": "# Sparser"
    },
    {
      "type": "paragraph",
      "id": "e195ae683597bf18",
      "text": "We implement these techniques in a system called Sparser, which automatically manages a parsing cascade given a data stream in a supported format (e.g., JSON, Avro, Parquet) and a user query. We show that many real-world applications are highly selective and benefit from Sparser. Across diverse workloads, Sparser accelerates state-of-the-art parsers such as Mison by up to 22 × and improves end-to-end application performance by up to 9 ×.\n"
    },
    {
      "type": "pagefold",
      "id": "2e8c582c481b6a2c",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "9c902ad3f6d64775",
      "text": "PALKAR, Shoumik, ABUZAID, Firas, BAILIS, Peter and ZAHARIA, Matei, 2018. Filter before you parse: faster analytics on raw data with sparser. Proceedings of the VLDB Endowment. 1 July 2018. Vol. 11, no. 11, p. 1576–1589. DOI 10.14778/3236187.3236207. "
    },
    {
      "type": "markdown",
      "id": "192cb963d11cc576",
      "text": "* state-machine-based algorithms that execute a series of instructions per byte of input [18, 49]\n"
    },
    {
      "type": "markdown",
      "id": "672a20329b9a9d31",
      "text": "* Mison JSON parser [36], which uses SIMD instructions to find special characters such as brackets and colons to build a *structural index* over a raw JSON string, enabling efficient field projection without deserializing the record completely."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Filter before You Parse",
        "story": []
      },
      "date": 1686462872558
    },
    {
      "id": "9c902ad3f6d64775",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "9c902ad3f6d64775",
        "text": "PALKAR, Shoumik, ABUZAID, Firas, BAILIS, Peter and ZAHARIA, Matei, 2018. Filter before you parse: faster analytics on raw data with sparser. Proceedings of the VLDB Endowment. 1 July 2018. Vol. 11, no. 11, p. 1576–1589. DOI 10.14778/3236187.3236207. Exploratory big data applications often run on raw unstructured or semi-structured data formats, such as JSON files or text logs. These applications can spend 80--90% of their execution time parsing the data. In this paper, we propose a new approach for reducing this overhead: apply filters on the data’s raw bytestream before parsing. This technique, which we call raw filtering, leverages the features of modern hardware and the high selectivity of queries found in many exploratory applications. With raw filtering, a user-specified query predicate is compiled into a set of filtering primitives called raw filters (RFs). RFs are fast, SIMD-based operators that occasionally yield false positives, but never false negatives. We combine multiple RFs into an RF cascade to decrease the false positive rate and maximize parsing throughput. Because the best RF cascade is data-dependent, we propose an optimizer that dynamically selects the combination of RFs with the best expected throughput, achieving within 10% of the global optimum cascade while adding less than 1.2% overhead. We implement these techniques in a system called Sparser, which automatically manages a parsing cascade given a data stream in a supported format (e.g., JSON, Avro, Parquet) and a user query. We show that many real-world applications are highly selective and benefit from Sparser. Across diverse workloads, Sparser accelerates state-of-the-art parsers such as Mison by up to 22 × and improves end-to-end application performance by up to 9 ×.\n"
      },
      "attribution": {
        "page": "2023-06-11"
      },
      "date": 1686462878884
    },
    {
      "type": "edit",
      "id": "9c902ad3f6d64775",
      "item": {
        "type": "paragraph",
        "id": "9c902ad3f6d64775",
        "text": "PALKAR, Shoumik, ABUZAID, Firas, BAILIS, Peter and ZAHARIA, Matei, 2018. Filter before you parse: faster analytics on raw data with sparser. Proceedings of the VLDB Endowment. 1 July 2018. Vol. 11, no. 11, p. 1576–1589. DOI 10.14778/3236187.3236207. "
      },
      "date": 1686462886265
    },
    {
      "type": "add",
      "id": "80583dbd3fe498be",
      "item": {
        "type": "paragraph",
        "id": "80583dbd3fe498be",
        "text": "Exploratory big data applications often run on raw unstructured or semi-structured data formats, such as JSON files or text logs. These applications can spend 80--90% of their execution time parsing the data. In this paper, we propose a new approach for reducing this overhead: apply filters on the data’s raw bytestream before parsing. This technique, which we call raw filtering, leverages the features of modern hardware and the high selectivity of queries found in many exploratory applications. With raw filtering, a user-specified query predicate is compiled into a set of filtering primitives called raw filters (RFs). RFs are fast, SIMD-based operators that occasionally yield false positives, but never false negatives. We combine multiple RFs into an RF cascade to decrease the false positive rate and maximize parsing throughput. Because the best RF cascade is data-dependent, we propose an optimizer that dynamically selects the combination of RFs with the best expected throughput, achieving within 10% of the global optimum cascade while adding less than 1.2% overhead. We implement these techniques in a system called Sparser, which automatically manages a parsing cascade given a data stream in a supported format (e.g., JSON, Avro, Parquet) and a user query. We show that many real-world applications are highly selective and benefit from Sparser. Across diverse workloads, Sparser accelerates state-of-the-art parsers such as Mison by up to 22 × and improves end-to-end application performance by up to 9 ×.\n"
      },
      "after": "9c902ad3f6d64775",
      "date": 1686462888417
    },
    {
      "item": {
        "type": "factory",
        "id": "2e8c582c481b6a2c"
      },
      "id": "2e8c582c481b6a2c",
      "type": "add",
      "after": "80583dbd3fe498be",
      "date": 1686462891495
    },
    {
      "type": "edit",
      "id": "2e8c582c481b6a2c",
      "item": {
        "type": "pagefold",
        "id": "2e8c582c481b6a2c",
        "text": "~"
      },
      "date": 1686462896059
    },
    {
      "id": "9c902ad3f6d64775",
      "type": "move",
      "order": [
        "80583dbd3fe498be",
        "9c902ad3f6d64775",
        "2e8c582c481b6a2c"
      ],
      "date": 1686462905399
    },
    {
      "id": "2e8c582c481b6a2c",
      "type": "move",
      "order": [
        "80583dbd3fe498be",
        "2e8c582c481b6a2c",
        "9c902ad3f6d64775"
      ],
      "date": 1686462907700
    },
    {
      "type": "edit",
      "id": "80583dbd3fe498be",
      "item": {
        "type": "paragraph",
        "id": "80583dbd3fe498be",
        "text": "Exploratory big data applications often run on raw unstructured or semi-structured data formats, such as JSON files or text logs. These applications can spend 80–90% of their execution time parsing the data. In this paper, we propose a new approach for reducing this overhead: apply filters on the data’s raw bytestream before parsing. This technique, which we call raw filtering, leverages the features of modern hardware and the high selectivity of queries found in many exploratory applications. With raw filtering, a user-specified query predicate is compiled into a set of filtering primitives called raw filters (RFs). RFs are fast, SIMD-based operators that occasionally yield false positives, but never false negatives. We combine multiple RFs into an RF cascade to decrease the false positive rate and maximize parsing throughput. Because the best RF cascade is data-dependent, we propose an optimizer that dynamically selects the combination of RFs with the best expected throughput, achieving within 10% of the global optimum cascade while adding less than 1.2% overhead. We implement these techniques in a system called Sparser, which automatically manages a parsing cascade given a data stream in a supported format (e.g., JSON, Avro, Parquet) and a user query. We show that many real-world applications are highly selective and benefit from Sparser. Across diverse workloads, Sparser accelerates state-of-the-art parsers such as Mison by up to 22 × and improves end-to-end application performance by up to 9 ×.\n"
      },
      "date": 1686463017813
    },
    {
      "type": "edit",
      "id": "80583dbd3fe498be",
      "item": {
        "type": "paragraph",
        "id": "80583dbd3fe498be",
        "text": "Exploratory big data applications often run on raw unstructured or semi-structured data formats, such as JSON files or text logs. These applications can spend 80–90% of their execution time parsing the data. "
      },
      "date": 1686463024686
    },
    {
      "type": "add",
      "id": "712da11c905a2d2c",
      "item": {
        "type": "paragraph",
        "id": "712da11c905a2d2c",
        "text": "In this paper, we propose a new approach for reducing this overhead: apply filters on the data’s raw bytestream before parsing. This technique, which we call raw filtering, leverages the features of modern hardware and the high selectivity of queries found in many exploratory applications. With raw filtering, a user-specified query predicate is compiled into a set of filtering primitives called raw filters (RFs). RFs are fast, SIMD-based operators that occasionally yield false positives, but never false negatives. We combine multiple RFs into an RF cascade to decrease the false positive rate and maximize parsing throughput. Because the best RF cascade is data-dependent, we propose an optimizer that dynamically selects the combination of RFs with the best expected throughput, achieving within 10% of the global optimum cascade while adding less than 1.2% overhead. We implement these techniques in a system called Sparser, which automatically manages a parsing cascade given a data stream in a supported format (e.g., JSON, Avro, Parquet) and a user query. We show that many real-world applications are highly selective and benefit from Sparser. Across diverse workloads, Sparser accelerates state-of-the-art parsers such as Mison by up to 22 × and improves end-to-end application performance by up to 9 ×.\n"
      },
      "after": "80583dbd3fe498be",
      "date": 1686463025365
    },
    {
      "type": "edit",
      "id": "712da11c905a2d2c",
      "item": {
        "type": "paragraph",
        "id": "712da11c905a2d2c",
        "text": "In this paper, we propose a new approach for reducing this overhead: apply filters on the data’s raw bytestream before parsing. This technique, which we call raw filtering, leverages the features of modern hardware and the high selectivity of queries found in many exploratory applications. "
      },
      "date": 1686463074545
    },
    {
      "type": "add",
      "id": "f625af5539f8eb70",
      "item": {
        "type": "paragraph",
        "id": "f625af5539f8eb70",
        "text": "With raw filtering, a user-specified query predicate is compiled into a set of filtering primitives called raw filters (RFs). RFs are fast, SIMD-based operators that occasionally yield false positives, but never false negatives. We combine multiple RFs into an RF cascade to decrease the false positive rate and maximize parsing throughput. Because the best RF cascade is data-dependent, we propose an optimizer that dynamically selects the combination of RFs with the best expected throughput, achieving within 10% of the global optimum cascade while adding less than 1.2% overhead. We implement these techniques in a system called Sparser, which automatically manages a parsing cascade given a data stream in a supported format (e.g., JSON, Avro, Parquet) and a user query. We show that many real-world applications are highly selective and benefit from Sparser. Across diverse workloads, Sparser accelerates state-of-the-art parsers such as Mison by up to 22 × and improves end-to-end application performance by up to 9 ×.\n"
      },
      "after": "712da11c905a2d2c",
      "date": 1686463083555
    },
    {
      "type": "add",
      "id": "95172c60870ebdfa",
      "item": {
        "type": "paragraph",
        "id": "95172c60870ebdfa",
        "text": "# Raw Filtering"
      },
      "after": "712da11c905a2d2c",
      "date": 1686463091787
    },
    {
      "type": "edit",
      "id": "95172c60870ebdfa",
      "item": {
        "type": "markdown",
        "id": "95172c60870ebdfa",
        "text": "# Raw Filtering"
      },
      "date": 1686463093353
    },
    {
      "type": "edit",
      "id": "f625af5539f8eb70",
      "item": {
        "type": "paragraph",
        "id": "f625af5539f8eb70",
        "text": "With raw filtering, a user-specified query predicate is compiled into a set of filtering primitives called raw filters (RFs). RFs are fast, SIMD-based operators that occasionally yield false positives, but never false negatives. We combine multiple RFs into an RF cascade to decrease the false positive rate and maximize parsing throughput. Because the best RF cascade is data-dependent, we propose an optimizer that dynamically selects the combination of RFs with the best expected throughput, achieving within 10% of the global optimum cascade while adding less than 1.2% overhead. "
      },
      "date": 1686463143952
    },
    {
      "type": "add",
      "id": "e195ae683597bf18",
      "item": {
        "type": "paragraph",
        "id": "e195ae683597bf18",
        "text": "We implement these techniques in a system called Sparser, which automatically manages a parsing cascade given a data stream in a supported format (e.g., JSON, Avro, Parquet) and a user query. We show that many real-world applications are highly selective and benefit from Sparser. Across diverse workloads, Sparser accelerates state-of-the-art parsers such as Mison by up to 22 × and improves end-to-end application performance by up to 9 ×.\n"
      },
      "after": "f625af5539f8eb70",
      "date": 1686463147331
    },
    {
      "type": "add",
      "id": "2c18c7214ea0cb65",
      "item": {
        "type": "paragraph",
        "id": "2c18c7214ea0cb65",
        "text": "# Sparser"
      },
      "after": "f625af5539f8eb70",
      "date": 1686463150992
    },
    {
      "type": "edit",
      "id": "2c18c7214ea0cb65",
      "item": {
        "type": "markdown",
        "id": "2c18c7214ea0cb65",
        "text": "# Sparser"
      },
      "date": 1686463152296
    },
    {
      "id": "192cb963d11cc576",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "192cb963d11cc576",
        "text": "state-machine-based"
      },
      "after": "9c902ad3f6d64775",
      "attribution": {
        "page": "2023-06-11"
      },
      "date": 1686463188823
    },
    {
      "type": "edit",
      "id": "192cb963d11cc576",
      "item": {
        "type": "paragraph",
        "id": "192cb963d11cc576",
        "text": "state-machine-based "
      },
      "date": 1686463222088
    },
    {
      "type": "edit",
      "id": "192cb963d11cc576",
      "item": {
        "type": "paragraph",
        "id": "192cb963d11cc576",
        "text": "state-machine-based algorithms that execute a series of instructions per byte of input "
      },
      "date": 1686463257639
    },
    {
      "type": "edit",
      "id": "192cb963d11cc576",
      "item": {
        "type": "paragraph",
        "id": "192cb963d11cc576",
        "text": "state-machine-based algorithms that execute a series of instructions per byte of input [18,"
      },
      "date": 1686463265937
    },
    {
      "type": "edit",
      "id": "192cb963d11cc576",
      "item": {
        "type": "paragraph",
        "id": "192cb963d11cc576",
        "text": "state-machine-based algorithms that execute a series of instructions per byte of input [18, 49]"
      },
      "date": 1686463272098
    },
    {
      "type": "edit",
      "id": "192cb963d11cc576",
      "item": {
        "type": "paragraph",
        "id": "192cb963d11cc576",
        "text": "* state-machine-based algorithms that execute a series of instructions per byte of input [18, 49]"
      },
      "date": 1686463322327
    },
    {
      "type": "edit",
      "id": "192cb963d11cc576",
      "item": {
        "type": "markdown",
        "id": "192cb963d11cc576",
        "text": "* state-machine-based algorithms that execute a series of instructions per byte of input [18, 49]"
      },
      "date": 1686463323614
    },
    {
      "type": "edit",
      "id": "192cb963d11cc576",
      "item": {
        "type": "markdown",
        "id": "192cb963d11cc576",
        "text": "* state-machine-based algorithms that execute a series of instructions per byte of input [18, 49]\n"
      },
      "date": 1686463330955
    },
    {
      "type": "add",
      "id": "672a20329b9a9d31",
      "item": {
        "type": "markdown",
        "id": "672a20329b9a9d31",
        "text": "* Mison JSON parser [36], which uses SIMD instructions to find special characters such as brackets and colons to build a *structural index* over a raw JSON string enabling efficient field projection without deserializing the record completely."
      },
      "after": "192cb963d11cc576",
      "date": 1686463467154
    },
    {
      "type": "edit",
      "id": "672a20329b9a9d31",
      "item": {
        "type": "markdown",
        "id": "672a20329b9a9d31",
        "text": "* Mison JSON parser [36], which uses SIMD instructions to find special characters such as brackets and colons to build a *structural index* over a raw JSON string, enabling efficient field projection without deserializing the record completely."
      },
      "date": 1686463498418
    }
  ]
}