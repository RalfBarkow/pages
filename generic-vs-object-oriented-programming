{
  "title": "Generic Vs Object Oriented Programming",
  "story": [
    {
      "type": "html",
      "text": "In an interesting interview at [http://www.stlport.org/resources/StepanovUSA.html www.stlport.org] [[Alexander Stepanov]] says: \"I think that object orientedness is almost as much of a hoax as [[Artificial Intelligence]].\" See [[Object Orientation Isa Hoax]].",
      "id": "b40cb73f9002cd5d911681bde2b5fc06"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "Stepanov is IMO needlessly hostile in his opinions towards OO. I'll try to describe the differences between generics and objects, as I've felt them, briefly in here. The more aggressive discussion follows further below...",
      "id": "391f3c97556009320cbc4ca8ad027a61"
    },
    {
      "type": "html",
      "text": "\nGenerics cannot:",
      "id": "493e4be2ba79f71130ef18edaf8ecfbe"
    },
    {
      "type": "html",
      "text": " use behaviorally heterogeneous collections (for example, list of different implementations of common ABC)",
      "id": "ff19c5b1786ef92c7ccab7f9aae9e925"
    },
    {
      "type": "html",
      "text": " more generally, forget anything about the type of a datum",
      "id": "0f71fd104cbde6e241a2c65ab8bf91a7"
    },
    {
      "type": "html",
      "text": "\nObjects cannot (in a language which uses [[Static Typing]]; [[Dynamic Typing]] doesn't have these restrictions):",
      "id": "d1cd8982f81c0a69a0d139d0b2a30066"
    },
    {
      "type": "html",
      "text": " allow routines on compound types which make no assumptions about the component types",
      "id": "36f7b1e627ebe014bb76fea9a2bf46c9"
    },
    {
      "type": "html",
      "text": " more generally, define any polymorphic behavior without first defining an interface.",
      "id": "3b5e35cf2123ab3d6f3ead06c8f22df5"
    },
    {
      "type": "html",
      "text": "\nWorkarounds for overcoming the limitations exist in both directions. Java's downcasts are one such mechanism, and you can put objects or something providing equivalent power (functions / collections of functions) into a generic data structure.",
      "id": "0e9ade6f8dd400d71da7f8274b070c6a"
    },
    {
      "type": "html",
      "text": "\nNote that there are two kinds of generics:",
      "id": "fa528b4fe1442444ba20eeea1109140b"
    },
    {
      "type": "html",
      "text": " compile-time generics, familiar from C++, which are much akin to macros for code synthesis.",
      "id": "444482183b32f3b5591e66dd7bf83f7a"
    },
    {
      "type": "html",
      "text": " runtime generics, familiar from the [[Sml Language]] ([[Objective Caml]]) and other [[Functional Programming Language]]s, which are no use without [[Higher Order Function]]s.",
      "id": "42642c456cab58a58da177d2bcaa03da"
    },
    {
      "type": "html",
      "text": "\n[[Objective Caml]] and [[Haskell Language]] both have both of the above, the former in the form of modules, the latter in the form of existential classes.",
      "id": "e1a410fbfd0b1d07b77f38e7def90af6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "\nLater in the interview there is the following:",
      "id": "736ee9360d783cae40ff60ae9c7dcdc8"
    },
    {
      "type": "html",
      "text": "<b>Q:</b> This mean a radical change of mind from both imperative and OO thinking. What are the benefits, and the drawbacks, of this paradigm compared to the \"standard\" OO programming of [[Small Talk]] or, say, Java? ",
      "id": "f81da5c5cf7bc8928eaae66bede916a8"
    },
    {
      "type": "html",
      "text": "<b>A:</b> My approach works, theirs does not work. Try to implement a simple thing in the object oriented way, say, max. I do not know how it can be done. Using generic programming I can write: ",
      "id": "37d5dd6b29d8a8561dba8bee2b3402c1"
    },
    {
      "type": "code",
      "text": " template <class S''''''trictWeakOrdered>\n inline S''''''trictWeakOrdered& max(S''''''trictWeakOrdered& x,\n S''''''trictWeakOrdered& y) {\n  return x < y ? y : x;\n }",
      "id": "6542f352ff4c672a252df19f72bd690b"
    },
    {
      "type": "html",
      "text": "\nand",
      "id": "23a212d761a38af668e8938516e93544"
    },
    {
      "type": "code",
      "text": " template <class S''''''trictWeakOrdered>\n inline const S''''''trictWeakOrdered& max(const S''''''trictWeakOrdered& x,\n const S''''''trictWeakOrdered& y) {\n  return x < y ? y : x;\n }",
      "id": "8fae65c70f09695597583922b65eee87"
    },
    {
      "type": "html",
      "text": "<i>Yeah, that's pretty easy. In Smalltalk it's much harder. Implement this method on object:</i>",
      "id": "f80381797ab7065f51157433f1a80ee6"
    },
    {
      "type": "html",
      "text": "max:<br>anObject",
      "id": "bdf4225de07f8ca23e69648354e5c858"
    },
    {
      "type": "code",
      "text": "  ^self > anObject\n  ifTrue: [self]\n  ifFalse: [anObject]",
      "id": "e244c391c440a58cf47ee5fc162146c1"
    },
    {
      "type": "html",
      "text": "<i>Much more difficult.</i>",
      "id": "0fb2395dc5a778467432ef1634847565"
    },
    {
      "type": "html",
      "text": "'",
      "id": "b87472cc23651bb885c97b23fe932d6d"
    },
    {
      "type": "html",
      "text": "(you do need both & and const &). And then I define what strict weak ordered means. Try doing it in Java. You can't write a generic max() in Java that takes two arguments of some type and has a return value of that same type. Inheritance and interfaces don't help. And if they cannot implement max or swap or linear search, what chances do they have to implement really complex stuff? These are my litmus tests: if a language allows me to implement max and swap and linear search generically - then it has some potential.",
      "id": "486faf6990512b4b212258b4d197a255"
    },
    {
      "type": "html",
      "text": "\nCan someone who knows explain what he is getting at? Is G<b></b>enericProgramming that much superior?",
      "id": "fdf01e6cf1e47bb033ea5b8b2e04beff"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "The name S<b></b>trictWeakOrdered is just a placeholder here. There doesn't need to be a class named S<b></b>trictWeakOrdered anywhere in the system. Including a header file containing this code in a source file allows the programmer to invoke <b>max(x, y)</b> anywhere therein, no matter what object types <b>x</b> and <b>y</b> are. However, the statement will fail to compile iff the statement <b>x < y</b> would cause a compile error. Thus, the only restriction on x and y is that <b>operator<()</b> exists, either as a free function taking x and y as arguments, or as a member function for the class of x taking y as argument. If x and y are native types, this is automatic.",
      "id": "c6935d4a891e63d2bfd577d30c96993f"
    },
    {
      "type": "html",
      "text": "\nIn Java, on the other hand, there are no generic functions. Some people consider this good, of course. So, the appropriate way to do this is to have x and y be members of a <b>Comparable</b> class (or to provide an extra <b>Comparator</b>), and declare a utility class:",
      "id": "4462125677a37959dfc6610c3d169374"
    },
    {
      "type": "code",
      "text": "  public final class Ordering {\n  public final static Comparable max(Comparable x, Comparable y) {\n  return (x.compareTo(y) < 0) ? y : x;\n  }",
      "id": "070c7c215ff35eafe43afa0686544b90"
    },
    {
      "type": "code",
      "text": "  // Optional:\n  public final static Object max(Object x, Object y, Comparator cmp) {\n  return (cmp.compareTo(x, y) < 0) ? y : x;\n  }",
      "id": "6bacf0801f85bd162845d8df1bf06777"
    },
    {
      "type": "code",
      "text": "  // Min, median, etc.\n  }",
      "id": "60ddb719f4abd6bb156c88612900162c"
    },
    {
      "type": "html",
      "text": "\nYou can then invoke Ordering.max(x,y) as appropriate. Note that Alexander Stepanov could have provided a three-argument version too.",
      "id": "b5365534cad979a0d3052e03c3bd996c"
    },
    {
      "type": "html",
      "text": "\nThe question is, which is appropriate to your needs?",
      "id": "397f4c39bee7f74be15c3f2381dc7933"
    },
    {
      "type": "html",
      "text": "-- [[Eric Jablow]]",
      "id": "de6f0e2e32e7e1a5759392d9fa7c10f0"
    },
    {
      "type": "html",
      "text": "<i>It's difficult to see what need there would be for the approach in this examples while using language with dynamic typing. It's a few years since I worked in C++, but back then we used C++ templates to fake up many things that Lisp and Smalltalk people take for granted (closures, strong collections, functoids etc). Apart from that, the advantage of <b>C++ templates</b>, which are only one form of genericity, is a particular form of late binding. It'd be interesting to know what Stepanov would have to say about other forms of genericity.</i>",
      "id": "b9db35e398a9240e9f0828245fd05871"
    },
    {
      "type": "html",
      "text": "<i>It's not clear to me quite what he's getting at with this example. Certainly, an OO (or any other kind of) language that has static typing can benefit from some explicit mechanism for genericity. Languages with dynamic typing have other mechanisms for doing the same things.</i>",
      "id": "8223addf3aeae0bbdac3e4b2207d808a"
    },
    {
      "type": "html",
      "text": "<i>As for the idea of expressing your algorithms in as abstract a fashion as possible well, probably [[You Arent Gonna Need It]], plus, things like Beck's [[Template Method]] do something very similar. -- [[Keith Braithwaite]]</i>",
      "id": "b7a04ddd69df7b0022dcc248a10f6db3"
    },
    {
      "type": "html",
      "text": "\nJava is pretty much screwed without the generics introduced in 1.5. However, for a language like [[Small Talk]] or Lisp you are exactly right. There is no need for templates in these languages. In fact [[Generative Programming]] (and unfortunate name choice that is too close to [[Generative Communication]]) talks about this at length. A language with a dynamic type system does not need templates. The problem with Java is that it really rode the fence and has neither a static type system nor is it truly dynamic. As a result, it requires even more type casting than a language like C or [[Cee Plus Plus]]. For this reason, it really requires templates. However, one should not confuse genericity with [[Generic Programming]]. -- [[Robert Di Falco]]",
      "id": "67c6237acb7f19f62bad981361afac9b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "\nStepanov, although clearly a very smart person, apparently never recovered from that bacterial infection that sparked off the development of the [[Standard Template Library]]. -- [[Andrew Queisser]]",
      "id": "f99f4494c895d0a9114b397988cd7462"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "\nThe problem I have with both the C++ and [[Small Talk]] ways of doing things is that they don't explicitly specify the requirements for the arguments to max(). I'm very happy with Java's interfaces and would like to see a Java-like language that looks something like this:",
      "id": "a739440981715cff728c5f0d7b445ea6"
    },
    {
      "type": "code",
      "text": " interface WeaklyComparable {\n  boolean operator<(ThisClass other);\n  boolean operator>(ThisClass other);\n };",
      "id": "8f2f22ec24df45238957ac06fe94ac56"
    },
    {
      "type": "code",
      "text": " int implements WeaklyComparable;\n float implements WeaklyComparable;",
      "id": "0a38cd36bbd96d630223437a72ce56f6"
    },
    {
      "type": "code",
      "text": " where class T implements WeaklyComparable:\n boolean max(T a, T b) {\n  if(a<b) { return a; } else { return b; }\n }",
      "id": "9e0370cfef49f7d8dac1291f66bc03ee"
    },
    {
      "type": "html",
      "text": "\nThat is, the user of a class should be able to retroactively declare that the class implements an interface, provided that it already supports all the methods. (If not you might need to write an adapter class.)",
      "id": "98558b4954f7e608bc8b2247a3693fce"
    },
    {
      "type": "html",
      "text": "\nNote also that max() doesn't use the greater-than operator but requires it anyway. This allows the implementation of max() to be more easily changed later.",
      "id": "07a816dbb61b1a1158a0caf9d22fefb7"
    },
    {
      "type": "html",
      "text": "(Also, built-in-types should be structs, like in C#.)",
      "id": "5dbfba831d439ef80666174d66a4f518"
    },
    {
      "type": "html",
      "text": "(Also, the type system needs to make sense unlike my example.)",
      "id": "2bdd723de1c03b8a2c8123d289a7b688"
    },
    {
      "type": "html",
      "text": "-- [[Brian Slesinsky]]",
      "id": "89f5a1075be511892b4441ad4b7f3ded"
    },
    {
      "type": "html",
      "text": "<i>The problem with this is that you'd need to explicitly recognize and assert that your type implements every single property/interface that you use on it. That means you'd have to keep going back to your original type and changing its definition. This is no better than declaring an object that implements many interfaces. The advantage of the [[Generic Programming]] approach is that the definition of the object implicitly specifies the ways it can be used. In other words, if it has a < operator, it must also have a strict-weak ordering. The Ruby example below is also nice; but it's fundamentally different from the C++ example in that the C++ version won't be used unless it can be compiled, i.e. unless the < operator has been defined. This allows one to do interesting recursion with templates. See [[Compile Time Generic Average Function In Cee Plus Plus]].</i> -- DavidKTurner",
      "id": "ae7292133061a9d991ef341b72141d67"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "This code above looks almost exactly like Haskell typeclasses. Standard typeclasses are Eq for equality, Ord for ordering (requires that the type already be an instance of Eq), Num for numeric types, etc. It's easy to make new typeclasses also",
      "id": "5374a2b0f0ccd03c7c0e2d5ec0880bf8"
    },
    {
      "type": "html",
      "text": "\nthis is some helpful demo info: [http://www.syntaxpolice.org/lectures/haskellTalk2/slides/x169.html www.syntaxpolice.org]\nthere's a simple typeclass in my Haskell tutorial for the impatient. I create a [[Char Exts]] class that has isVowel and isConsonant methods. [http://www.scannedinavian.org/AvianWiki/HaskellDemo www.scannedinavian.org]",
      "id": "bc44a9b5210eec6e1abcf77eccdf8798"
    },
    {
      "type": "html",
      "text": "\nAs for true generics in Haskell, there's much more cool stuff, check this out:\n[http://www.scannedinavian.org/AvianWiki/GenericsDemo www.scannedinavian.org]\nIn this demo, the XML typeclass is defined, and later how to turn different types into XML. composition is defined separately, you don't need a type specific visitor method for example.",
      "id": "5cfa2c08176b8556cd5597a03e0f668b"
    },
    {
      "type": "html",
      "text": "\nAnother step past this is [[Generic Haskell]], which is much more powerful than this basic support of Generics. -- [[Shae Erisson]]",
      "id": "83bf7e26b8b698610289c8cba729448b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "\nRuby can do this, only nicer.",
      "id": "b85816a81375112fdffde0994a765ff3"
    },
    {
      "type": "html",
      "text": "-Snippet (test.rb):",
      "id": "977dd45773777dc55c7b22649f781781"
    },
    {
      "type": "code",
      "text": "  x,y=12,23.7",
      "id": "387f3cc495ca9faeec3985248c00a8d3"
    },
    {
      "type": "code",
      "text": "  def max(x,y)\n  raise ArgumentError unless x.respond_to?(\"<\")\n  return x<y ? y : x\n  end",
      "id": "bd440ca0aafa2d46ec3bc8fe2ea46580"
    },
    {
      "type": "code",
      "text": "  print \"x=#{x},  y=#{y},  max(x,y)=#{max(x,y)}\\n\"",
      "id": "c0e65a7fd29245601f2db24cb40d4b23"
    },
    {
      "type": "code",
      "text": "  def max(x,y)\n  unless y.kind_of?(Comparable) and x.kind_of?(Comparable)\n  raise ArgumentError, \"Arguments must be Comparable!\", caller\n  end\n  return x<y ? y : x\n  end",
      "id": "fb1d2ef170a16a56e5351bbd255573d8"
    },
    {
      "type": "code",
      "text": "  print \"x=#{x},  y=#{y},  max(x,y)=#{max(x,y)}\\n\"\n  x=proc { print \"bla\" }\n  print \"x=#{x},  y=#{y},  max(x,y)=#{max(x,y)}\\n\"",
      "id": "0a4b7b607e60db42c33b84fa2431fb19"
    },
    {
      "type": "html",
      "text": "-Output:",
      "id": "37c4ba842215a9b308bf4c3232b9e846"
    },
    {
      "type": "code",
      "text": "  >ruby test.rb\n  test.rb:19: Arguments must be Comparable! (ArgumentError)\n  x=12,  y=23.7,  max(x,y)=23.7\n  x=12,  y=23.7,  max(x,y)=23.7\n  >Exit code: 1",
      "id": "38d3d772b225c115a759c05ca7eed913"
    },
    {
      "type": "html",
      "text": "-- [[Peter Thoman]] (my first ever Wiki edit, hope this works)",
      "id": "fe509395a32afb185dbe5e605e0912ce"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "<i>Can someone who knows explain what he is getting at? Is [[Generic Programming]] that much superior? </i>",
      "id": "df88f1ab49f2bbf26b5a0164aa2b4ddc"
    },
    {
      "type": "html",
      "text": "\nI think this is a silly argument. No OO does not provide a mechanism for easily creating simple functions or programs. The intent is to manage large numbers of functions in complex programs. The value OO brings is scoping. It binds functions to their appropriate types. Note that the \"generic\" max() function fails when used with dissimilar data types or with types which do not have the > operator defined. -- [[Wayne Mack]]",
      "id": "6ec9acc7315c135a425a61c7dae9fa42"
    },
    {
      "type": "html",
      "text": "Right, and I think the current discussion of generic-vs-OO doesn't address the \"scoping\" advantages of OO languages. Those advantages are relatively well understood and the discussion has moved on. What's being discussed is whether the interface of a class should be tied to its type. In [[Small Talk]] and other dynamically typed languages type and interface are not directly tied to each other but in C++ a regular (non-template) function can only accept arguments of a specific type or subtype. A template (generic) function can accept anything that supports the operations used within the function (max needs the < operator.) The main difference now is that interface mismatches are detected at compile time (C++) or runtime ([[Small Talk]], etc.) It seems to me that the generic-vs-OO discussion is carried out mostly within the C++ community because for the dynamic typing crowd there is nothing to discuss. (I'm extrapolating here, being C++ myself.) -- [[Andrew Queisser]]",
      "id": "1f0cb7ddf6cd46bbb6a678810112de07"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "[[Wayne Mack]] identifies a problem when the max() function is called with the wrong sort of object. This problem has been addressed, by using [[Sets Of Requirements]]. There is a lot of information on this in [[The Boost Graph Library]]. -- [[John Fletcher]]",
      "id": "4e57b6882028a51704bccb2c6a526815"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "\n[[Bertrand Meyer]] gives an excellent summary of the debate in [[Object Oriented Software Construction]]; for a summary of his summary see [[Generics Vs Subtyping]]",
      "id": "993a0e92563d19be6de325e04223e4e1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "\nThe expressive difference between Generics and [[Object Orientation]] is in:",
      "id": "21f84374f081f117e503729e9934b0c1"
    },
    {
      "type": "html",
      "text": " How easy it is to write a program.",
      "id": "86ddd8d86f9cd94d86e68ff71334846f"
    },
    {
      "type": "html",
      "text": " How easy it is to read a program.",
      "id": "5c261cccce3e18828e222e3b57fe4993"
    },
    {
      "type": "html",
      "text": " How easy it is to debug a program.",
      "id": "eee2c4a9dc3b5849d1fa5eaf1d897b13"
    },
    {
      "type": "html",
      "text": " How easy it is to modify a program.",
      "id": "b8efd538d1822daff6cf61f5596f6c92"
    },
    {
      "type": "html",
      "text": "\nIf you think [[Static Typing]] is better than [[Dynamic Typing]] because you always make mistakes on method parameters, then you will very easily fix that 5% of the typing mistakes. Most mistakes are not typing mistakes though, so they can't be caught by [[Static Typing]].",
      "id": "c9913c400708565837ee58693a9b19a3"
    },
    {
      "type": "html",
      "text": " I personally think both have their points, but you are oversimplifying. For one thing, there are formal approaches in which <b>all</b> computation can be reduced to a matter of types, so you can't just wave your hands and say that mistakes in types are \"5%\" of all errors. In truth, you (and the rest of us, too) don't know the percentage in general, even if 5% happens to be true of your own code.",
      "id": "0ca5cd163086943d19e87b63304995ca"
    },
    {
      "type": "html",
      "text": " It is widely believed that there is excellent evidence that it is advantageous to catch as many errors as possible as early as possible, e.g. at compile time rather than run time, so even if it <b>were</b> only 5%, there might be a good argument.",
      "id": "58542c0939287093d2d289a149e8f894"
    },
    {
      "type": "html",
      "text": " Pure functional languages such as Haskell raise static typing to a high art, and accomplish vastly more at compile time than is traditional in languages like C++ and Java.",
      "id": "c235a4a6c5f3a9a50bf6bde5f8f5bfa7"
    },
    {
      "type": "html",
      "text": "\nWriting Generics doesn't seem simpler than writing [[Object Oriented]] programs. ",
      "id": "4ccf4efb50bd191aa2dd39bea56cfd89"
    },
    {
      "type": "html",
      "text": " You seem to be talking only about C++, and you are correct that generic programming with templates in C++ is difficult and kludgy, but this is a phenomenon confined to C++ (and possibly the forthcoming Java generics); it does not reflect on [[Generic Programming]] in <b>all</b> languages.",
      "id": "8b492afc672275a1fb51d6e6d80b6ea3"
    },
    {
      "type": "html",
      "text": "\nConsider the following template declarations:",
      "id": "ab1e6307d61968914d8df07a8e75cdd5"
    },
    {
      "type": "code",
      "text": " typedef xstr::xstring<\n  xstr::fixed_char_buf<64> > \n  small_string;",
      "id": "af169e8643749899fc436ea9c3f957fc"
    },
    {
      "type": "code",
      "text": " template <size_t SIZE, \n    class CharT=char, \n    class Traits=std::char_traits<CharT> > \n  class fixed_char_buf;",
      "id": "aec0a3e8205dcfc67fedb13122c985d4"
    },
    {
      "type": "html",
      "text": "\nContrary to what rookie developers may think, the above declarations are simple compared to real production code that uses templates extensively. And that's nothing compared to the compiler errors you will get and the difficulty for debugging it. And only to achieve a 5% speed increase that never materializes because you are always debugging your code.",
      "id": "80a0891c5526acd57863aee9f267dbfc"
    },
    {
      "type": "html",
      "text": "\nCompare with:",
      "id": "9762e91bca4c55d51ee8256d1d5d9731"
    },
    {
      "type": "html",
      "text": "\ntemplate<class R0, class R1, class R2>",
      "id": "d01ad3d783e531fad332282a7e063d22"
    },
    {
      "type": "code",
      "text": "  _bi::bind_t<R0, Find_SZ R0 (Find_CCH *) (R1), typename _bi::list_av_1<R2>::type>\n  Find(Find_SZ R0 (Find_CCH *f) (R1), R2 r2)",
      "id": "8c5738fc8bbb2e81abe504abcaf76e1b"
    },
    {
      "type": "html",
      "text": "{",
      "id": "e2e622cd883b0b9e71cbe80f6f48ef94"
    },
    {
      "type": "code",
      "text": "  typedef Find_SZ R0 (Find_CCH *F) (R1);\n  typedef typename _bi::list_av_1<R2>::type list_type;\n  return _bi::bind_t<R0, F, list_type> (f, list_type(r2));",
      "id": "0015c999fefb9085e6d2c5601ec3b1b1"
    },
    {
      "type": "html",
      "text": "}",
      "id": "aab2becec261fdf52382f7d263019f7e"
    },
    {
      "type": "html",
      "text": "\nAlso keep in mind that the code above has another disadvantage: whenever you declare new variables, there is the possibility of creating a new class at compile time, just because the parameter happens to be sightly different. The code is therefore massive and it takes too long to load.",
      "id": "819617696e8fc4c8fb8e41d167999274"
    },
    {
      "type": "html",
      "text": "-- [[Guillermo Schwarz]].",
      "id": "05b3a65404a48c9873192d997d15d984"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b19d9473360ad2506b252233b10b19"
    },
    {
      "type": "html",
      "text": "[[Category Cpp]] [[Category Cpp Templates]] [[Category Polymorphism]] [[Category Programming Language Comparisons]]",
      "id": "a336d54596ea4a596f7415408c0fd6eb"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?GenericVsObjectOrientedProgramming c2.com]",
      "id": "61ee618903c95ab73698a1817f3a3bbb"
    }
  ],
  "journal": [
    {
      "date": 1102258865000,
      "id": "ba0547b5deb44345f5fdcd40ad22b5b9",
      "type": "create",
      "item": {
        "title": "Generic Vs Object Oriented Programming",
        "story": [
          {
            "type": "html",
            "text": "In an interesting interview at [http://www.stlport.org/resources/StepanovUSA.html www.stlport.org] [[Alexander Stepanov]] says: \"I think that object orientedness is almost as much of a hoax as [[Artificial Intelligence]].\" See [[Object Orientation Isa Hoax]].",
            "id": "b40cb73f9002cd5d911681bde2b5fc06"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "Stepanov is IMO needlessly hostile in his opinions towards OO. I'll try to describe the differences between generics and objects, as I've felt them, briefly in here. The more aggressive discussion follows further below...",
            "id": "391f3c97556009320cbc4ca8ad027a61"
          },
          {
            "type": "html",
            "text": "\nGenerics cannot:",
            "id": "493e4be2ba79f71130ef18edaf8ecfbe"
          },
          {
            "type": "html",
            "text": " use behaviorally heterogeneous collections (for example, list of different implementations of common ABC)",
            "id": "ff19c5b1786ef92c7ccab7f9aae9e925"
          },
          {
            "type": "html",
            "text": " more generally, forget anything about the type of a datum",
            "id": "0f71fd104cbde6e241a2c65ab8bf91a7"
          },
          {
            "type": "html",
            "text": "\nObjects cannot (in a language which uses [[Static Typing]]; [[Dynamic Typing]] doesn't have these restrictions):",
            "id": "d1cd8982f81c0a69a0d139d0b2a30066"
          },
          {
            "type": "html",
            "text": " allow routines on compound types which make no assumptions about the component types",
            "id": "36f7b1e627ebe014bb76fea9a2bf46c9"
          },
          {
            "type": "html",
            "text": " more generally, define any polymorphic behavior without first defining an interface.",
            "id": "3b5e35cf2123ab3d6f3ead06c8f22df5"
          },
          {
            "type": "html",
            "text": "\nWorkarounds for overcoming the limitations exist in both directions. Java's downcasts are one such mechanism, and you can put objects or something providing equivalent power (functions / collections of functions) into a generic data structure.",
            "id": "0e9ade6f8dd400d71da7f8274b070c6a"
          },
          {
            "type": "html",
            "text": "\nNote that there are two kinds of generics:",
            "id": "fa528b4fe1442444ba20eeea1109140b"
          },
          {
            "type": "html",
            "text": " compile-time generics, familiar from C++, which are much akin to macros for code synthesis.",
            "id": "444482183b32f3b5591e66dd7bf83f7a"
          },
          {
            "type": "html",
            "text": " runtime generics, familiar from the [[Sml Language]] ([[Objective Caml]]) and other [[Functional Programming Language]]s, which are no use without [[Higher Order Function]]s.",
            "id": "42642c456cab58a58da177d2bcaa03da"
          },
          {
            "type": "html",
            "text": "\n[[Objective Caml]] and [[Haskell Language]] both have both of the above, the former in the form of modules, the latter in the form of existential classes.",
            "id": "e1a410fbfd0b1d07b77f38e7def90af6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "\nLater in the interview there is the following:",
            "id": "736ee9360d783cae40ff60ae9c7dcdc8"
          },
          {
            "type": "html",
            "text": "<b>Q:</b> This mean a radical change of mind from both imperative and OO thinking. What are the benefits, and the drawbacks, of this paradigm compared to the \"standard\" OO programming of [[Small Talk]] or, say, Java? ",
            "id": "f81da5c5cf7bc8928eaae66bede916a8"
          },
          {
            "type": "html",
            "text": "<b>A:</b> My approach works, theirs does not work. Try to implement a simple thing in the object oriented way, say, max. I do not know how it can be done. Using generic programming I can write: ",
            "id": "37d5dd6b29d8a8561dba8bee2b3402c1"
          },
          {
            "type": "code",
            "text": " template <class S''''''trictWeakOrdered>\n inline S''''''trictWeakOrdered& max(S''''''trictWeakOrdered& x,\n S''''''trictWeakOrdered& y) {\n  return x < y ? y : x;\n }",
            "id": "6542f352ff4c672a252df19f72bd690b"
          },
          {
            "type": "html",
            "text": "\nand",
            "id": "23a212d761a38af668e8938516e93544"
          },
          {
            "type": "code",
            "text": " template <class S''''''trictWeakOrdered>\n inline const S''''''trictWeakOrdered& max(const S''''''trictWeakOrdered& x,\n const S''''''trictWeakOrdered& y) {\n  return x < y ? y : x;\n }",
            "id": "8fae65c70f09695597583922b65eee87"
          },
          {
            "type": "html",
            "text": "<i>Yeah, that's pretty easy. In Smalltalk it's much harder. Implement this method on object:</i>",
            "id": "f80381797ab7065f51157433f1a80ee6"
          },
          {
            "type": "html",
            "text": "max:<br>anObject",
            "id": "bdf4225de07f8ca23e69648354e5c858"
          },
          {
            "type": "code",
            "text": "  ^self > anObject\n  ifTrue: [self]\n  ifFalse: [anObject]",
            "id": "e244c391c440a58cf47ee5fc162146c1"
          },
          {
            "type": "html",
            "text": "<i>Much more difficult.</i>",
            "id": "0fb2395dc5a778467432ef1634847565"
          },
          {
            "type": "html",
            "text": "'",
            "id": "b87472cc23651bb885c97b23fe932d6d"
          },
          {
            "type": "html",
            "text": "(you do need both & and const &). And then I define what strict weak ordered means. Try doing it in Java. You can't write a generic max() in Java that takes two arguments of some type and has a return value of that same type. Inheritance and interfaces don't help. And if they cannot implement max or swap or linear search, what chances do they have to implement really complex stuff? These are my litmus tests: if a language allows me to implement max and swap and linear search generically - then it has some potential.",
            "id": "486faf6990512b4b212258b4d197a255"
          },
          {
            "type": "html",
            "text": "\nCan someone who knows explain what he is getting at? Is G<b></b>enericProgramming that much superior?",
            "id": "fdf01e6cf1e47bb033ea5b8b2e04beff"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "The name S<b></b>trictWeakOrdered is just a placeholder here. There doesn't need to be a class named S<b></b>trictWeakOrdered anywhere in the system. Including a header file containing this code in a source file allows the programmer to invoke <b>max(x, y)</b> anywhere therein, no matter what object types <b>x</b> and <b>y</b> are. However, the statement will fail to compile iff the statement <b>x < y</b> would cause a compile error. Thus, the only restriction on x and y is that <b>operator<()</b> exists, either as a free function taking x and y as arguments, or as a member function for the class of x taking y as argument. If x and y are native types, this is automatic.",
            "id": "c6935d4a891e63d2bfd577d30c96993f"
          },
          {
            "type": "html",
            "text": "\nIn Java, on the other hand, there are no generic functions. Some people consider this good, of course. So, the appropriate way to do this is to have x and y be members of a <b>Comparable</b> class (or to provide an extra <b>Comparator</b>), and declare a utility class:",
            "id": "4462125677a37959dfc6610c3d169374"
          },
          {
            "type": "code",
            "text": "  public final class Ordering {\n  public final static Comparable max(Comparable x, Comparable y) {\n  return (x.compareTo(y) < 0) ? y : x;\n  }",
            "id": "070c7c215ff35eafe43afa0686544b90"
          },
          {
            "type": "code",
            "text": "  // Optional:\n  public final static Object max(Object x, Object y, Comparator cmp) {\n  return (cmp.compareTo(x, y) < 0) ? y : x;\n  }",
            "id": "6bacf0801f85bd162845d8df1bf06777"
          },
          {
            "type": "code",
            "text": "  // Min, median, etc.\n  }",
            "id": "60ddb719f4abd6bb156c88612900162c"
          },
          {
            "type": "html",
            "text": "\nYou can then invoke Ordering.max(x,y) as appropriate. Note that Alexander Stepanov could have provided a three-argument version too.",
            "id": "b5365534cad979a0d3052e03c3bd996c"
          },
          {
            "type": "html",
            "text": "\nThe question is, which is appropriate to your needs?",
            "id": "397f4c39bee7f74be15c3f2381dc7933"
          },
          {
            "type": "html",
            "text": "-- [[Eric Jablow]]",
            "id": "de6f0e2e32e7e1a5759392d9fa7c10f0"
          },
          {
            "type": "html",
            "text": "<i>It's difficult to see what need there would be for the approach in this examples while using language with dynamic typing. It's a few years since I worked in C++, but back then we used C++ templates to fake up many things that Lisp and Smalltalk people take for granted (closures, strong collections, functoids etc). Apart from that, the advantage of <b>C++ templates</b>, which are only one form of genericity, is a particular form of late binding. It'd be interesting to know what Stepanov would have to say about other forms of genericity.</i>",
            "id": "b9db35e398a9240e9f0828245fd05871"
          },
          {
            "type": "html",
            "text": "<i>It's not clear to me quite what he's getting at with this example. Certainly, an OO (or any other kind of) language that has static typing can benefit from some explicit mechanism for genericity. Languages with dynamic typing have other mechanisms for doing the same things.</i>",
            "id": "8223addf3aeae0bbdac3e4b2207d808a"
          },
          {
            "type": "html",
            "text": "<i>As for the idea of expressing your algorithms in as abstract a fashion as possible well, probably [[You Arent Gonna Need It]], plus, things like Beck's [[Template Method]] do something very similar. -- [[Keith Braithwaite]]</i>",
            "id": "b7a04ddd69df7b0022dcc248a10f6db3"
          },
          {
            "type": "html",
            "text": "\nJava is pretty much screwed without the generics introduced in 1.5. However, for a language like [[Small Talk]] or Lisp you are exactly right. There is no need for templates in these languages. In fact [[Generative Programming]] (and unfortunate name choice that is too close to [[Generative Communication]]) talks about this at length. A language with a dynamic type system does not need templates. The problem with Java is that it really rode the fence and has neither a static type system nor is it truly dynamic. As a result, it requires even more type casting than a language like C or [[Cee Plus Plus]]. For this reason, it really requires templates. However, one should not confuse genericity with [[Generic Programming]]. -- [[Robert Di Falco]]",
            "id": "67c6237acb7f19f62bad981361afac9b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "\nStepanov, although clearly a very smart person, apparently never recovered from that bacterial infection that sparked off the development of the [[Standard Template Library]]. -- [[Andrew Queisser]]",
            "id": "f99f4494c895d0a9114b397988cd7462"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "\nThe problem I have with both the C++ and [[Small Talk]] ways of doing things is that they don't explicitly specify the requirements for the arguments to max(). I'm very happy with Java's interfaces and would like to see a Java-like language that looks something like this:",
            "id": "a739440981715cff728c5f0d7b445ea6"
          },
          {
            "type": "code",
            "text": " interface WeaklyComparable {\n  boolean operator<(ThisClass other);\n  boolean operator>(ThisClass other);\n };",
            "id": "8f2f22ec24df45238957ac06fe94ac56"
          },
          {
            "type": "code",
            "text": " int implements WeaklyComparable;\n float implements WeaklyComparable;",
            "id": "0a38cd36bbd96d630223437a72ce56f6"
          },
          {
            "type": "code",
            "text": " where class T implements WeaklyComparable:\n boolean max(T a, T b) {\n  if(a<b) { return a; } else { return b; }\n }",
            "id": "9e0370cfef49f7d8dac1291f66bc03ee"
          },
          {
            "type": "html",
            "text": "\nThat is, the user of a class should be able to retroactively declare that the class implements an interface, provided that it already supports all the methods. (If not you might need to write an adapter class.)",
            "id": "98558b4954f7e608bc8b2247a3693fce"
          },
          {
            "type": "html",
            "text": "\nNote also that max() doesn't use the greater-than operator but requires it anyway. This allows the implementation of max() to be more easily changed later.",
            "id": "07a816dbb61b1a1158a0caf9d22fefb7"
          },
          {
            "type": "html",
            "text": "(Also, built-in-types should be structs, like in C#.)",
            "id": "5dbfba831d439ef80666174d66a4f518"
          },
          {
            "type": "html",
            "text": "(Also, the type system needs to make sense unlike my example.)",
            "id": "2bdd723de1c03b8a2c8123d289a7b688"
          },
          {
            "type": "html",
            "text": "-- [[Brian Slesinsky]]",
            "id": "89f5a1075be511892b4441ad4b7f3ded"
          },
          {
            "type": "html",
            "text": "<i>The problem with this is that you'd need to explicitly recognize and assert that your type implements every single property/interface that you use on it. That means you'd have to keep going back to your original type and changing its definition. This is no better than declaring an object that implements many interfaces. The advantage of the [[Generic Programming]] approach is that the definition of the object implicitly specifies the ways it can be used. In other words, if it has a < operator, it must also have a strict-weak ordering. The Ruby example below is also nice; but it's fundamentally different from the C++ example in that the C++ version won't be used unless it can be compiled, i.e. unless the < operator has been defined. This allows one to do interesting recursion with templates. See [[Compile Time Generic Average Function In Cee Plus Plus]].</i> -- DavidKTurner",
            "id": "ae7292133061a9d991ef341b72141d67"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "This code above looks almost exactly like Haskell typeclasses. Standard typeclasses are Eq for equality, Ord for ordering (requires that the type already be an instance of Eq), Num for numeric types, etc. It's easy to make new typeclasses also",
            "id": "5374a2b0f0ccd03c7c0e2d5ec0880bf8"
          },
          {
            "type": "html",
            "text": "\nthis is some helpful demo info: [http://www.syntaxpolice.org/lectures/haskellTalk2/slides/x169.html www.syntaxpolice.org]\nthere's a simple typeclass in my Haskell tutorial for the impatient. I create a [[Char Exts]] class that has isVowel and isConsonant methods. [http://www.scannedinavian.org/AvianWiki/HaskellDemo www.scannedinavian.org]",
            "id": "bc44a9b5210eec6e1abcf77eccdf8798"
          },
          {
            "type": "html",
            "text": "\nAs for true generics in Haskell, there's much more cool stuff, check this out:\n[http://www.scannedinavian.org/AvianWiki/GenericsDemo www.scannedinavian.org]\nIn this demo, the XML typeclass is defined, and later how to turn different types into XML. composition is defined separately, you don't need a type specific visitor method for example.",
            "id": "5cfa2c08176b8556cd5597a03e0f668b"
          },
          {
            "type": "html",
            "text": "\nAnother step past this is [[Generic Haskell]], which is much more powerful than this basic support of Generics. -- [[Shae Erisson]]",
            "id": "83bf7e26b8b698610289c8cba729448b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "\nRuby can do this, only nicer.",
            "id": "b85816a81375112fdffde0994a765ff3"
          },
          {
            "type": "html",
            "text": "-Snippet (test.rb):",
            "id": "977dd45773777dc55c7b22649f781781"
          },
          {
            "type": "code",
            "text": "  x,y=12,23.7",
            "id": "387f3cc495ca9faeec3985248c00a8d3"
          },
          {
            "type": "code",
            "text": "  def max(x,y)\n  raise ArgumentError unless x.respond_to?(\"<\")\n  return x<y ? y : x\n  end",
            "id": "bd440ca0aafa2d46ec3bc8fe2ea46580"
          },
          {
            "type": "code",
            "text": "  print \"x=#{x},  y=#{y},  max(x,y)=#{max(x,y)}\\n\"",
            "id": "c0e65a7fd29245601f2db24cb40d4b23"
          },
          {
            "type": "code",
            "text": "  def max(x,y)\n  unless y.kind_of?(Comparable) and x.kind_of?(Comparable)\n  raise ArgumentError, \"Arguments must be Comparable!\", caller\n  end\n  return x<y ? y : x\n  end",
            "id": "fb1d2ef170a16a56e5351bbd255573d8"
          },
          {
            "type": "code",
            "text": "  print \"x=#{x},  y=#{y},  max(x,y)=#{max(x,y)}\\n\"\n  x=proc { print \"bla\" }\n  print \"x=#{x},  y=#{y},  max(x,y)=#{max(x,y)}\\n\"",
            "id": "0a4b7b607e60db42c33b84fa2431fb19"
          },
          {
            "type": "html",
            "text": "-Output:",
            "id": "37c4ba842215a9b308bf4c3232b9e846"
          },
          {
            "type": "code",
            "text": "  >ruby test.rb\n  test.rb:19: Arguments must be Comparable! (ArgumentError)\n  x=12,  y=23.7,  max(x,y)=23.7\n  x=12,  y=23.7,  max(x,y)=23.7\n  >Exit code: 1",
            "id": "38d3d772b225c115a759c05ca7eed913"
          },
          {
            "type": "html",
            "text": "-- [[Peter Thoman]] (my first ever Wiki edit, hope this works)",
            "id": "fe509395a32afb185dbe5e605e0912ce"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "<i>Can someone who knows explain what he is getting at? Is [[Generic Programming]] that much superior? </i>",
            "id": "df88f1ab49f2bbf26b5a0164aa2b4ddc"
          },
          {
            "type": "html",
            "text": "\nI think this is a silly argument. No OO does not provide a mechanism for easily creating simple functions or programs. The intent is to manage large numbers of functions in complex programs. The value OO brings is scoping. It binds functions to their appropriate types. Note that the \"generic\" max() function fails when used with dissimilar data types or with types which do not have the > operator defined. -- [[Wayne Mack]]",
            "id": "6ec9acc7315c135a425a61c7dae9fa42"
          },
          {
            "type": "html",
            "text": "Right, and I think the current discussion of generic-vs-OO doesn't address the \"scoping\" advantages of OO languages. Those advantages are relatively well understood and the discussion has moved on. What's being discussed is whether the interface of a class should be tied to its type. In [[Small Talk]] and other dynamically typed languages type and interface are not directly tied to each other but in C++ a regular (non-template) function can only accept arguments of a specific type or subtype. A template (generic) function can accept anything that supports the operations used within the function (max needs the < operator.) The main difference now is that interface mismatches are detected at compile time (C++) or runtime ([[Small Talk]], etc.) It seems to me that the generic-vs-OO discussion is carried out mostly within the C++ community because for the dynamic typing crowd there is nothing to discuss. (I'm extrapolating here, being C++ myself.) -- [[Andrew Queisser]]",
            "id": "1f0cb7ddf6cd46bbb6a678810112de07"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "[[Wayne Mack]] identifies a problem when the max() function is called with the wrong sort of object. This problem has been addressed, by using [[Sets Of Requirements]]. There is a lot of information on this in [[The Boost Graph Library]]. -- [[John Fletcher]]",
            "id": "4e57b6882028a51704bccb2c6a526815"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "\n[[Bertrand Meyer]] gives an excellent summary of the debate in [[Object Oriented Software Construction]]; for a summary of his summary see [[Generics Vs Subtyping]]",
            "id": "993a0e92563d19be6de325e04223e4e1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "\nThe expressive difference between Generics and [[Object Orientation]] is in:",
            "id": "21f84374f081f117e503729e9934b0c1"
          },
          {
            "type": "html",
            "text": " How easy it is to write a program.",
            "id": "86ddd8d86f9cd94d86e68ff71334846f"
          },
          {
            "type": "html",
            "text": " How easy it is to read a program.",
            "id": "5c261cccce3e18828e222e3b57fe4993"
          },
          {
            "type": "html",
            "text": " How easy it is to debug a program.",
            "id": "eee2c4a9dc3b5849d1fa5eaf1d897b13"
          },
          {
            "type": "html",
            "text": " How easy it is to modify a program.",
            "id": "b8efd538d1822daff6cf61f5596f6c92"
          },
          {
            "type": "html",
            "text": "\nIf you think [[Static Typing]] is better than [[Dynamic Typing]] because you always make mistakes on method parameters, then you will very easily fix that 5% of the typing mistakes. Most mistakes are not typing mistakes though, so they can't be caught by [[Static Typing]].",
            "id": "c9913c400708565837ee58693a9b19a3"
          },
          {
            "type": "html",
            "text": " I personally think both have their points, but you are oversimplifying. For one thing, there are formal approaches in which <b>all</b> computation can be reduced to a matter of types, so you can't just wave your hands and say that mistakes in types are \"5%\" of all errors. In truth, you (and the rest of us, too) don't know the percentage in general, even if 5% happens to be true of your own code.",
            "id": "0ca5cd163086943d19e87b63304995ca"
          },
          {
            "type": "html",
            "text": " It is widely believed that there is excellent evidence that it is advantageous to catch as many errors as possible as early as possible, e.g. at compile time rather than run time, so even if it <b>were</b> only 5%, there might be a good argument.",
            "id": "58542c0939287093d2d289a149e8f894"
          },
          {
            "type": "html",
            "text": " Pure functional languages such as Haskell raise static typing to a high art, and accomplish vastly more at compile time than is traditional in languages like C++ and Java.",
            "id": "c235a4a6c5f3a9a50bf6bde5f8f5bfa7"
          },
          {
            "type": "html",
            "text": "\nWriting Generics doesn't seem simpler than writing [[Object Oriented]] programs. ",
            "id": "4ccf4efb50bd191aa2dd39bea56cfd89"
          },
          {
            "type": "html",
            "text": " You seem to be talking only about C++, and you are correct that generic programming with templates in C++ is difficult and kludgy, but this is a phenomenon confined to C++ (and possibly the forthcoming Java generics); it does not reflect on [[Generic Programming]] in <b>all</b> languages.",
            "id": "8b492afc672275a1fb51d6e6d80b6ea3"
          },
          {
            "type": "html",
            "text": "\nConsider the following template declarations:",
            "id": "ab1e6307d61968914d8df07a8e75cdd5"
          },
          {
            "type": "code",
            "text": " typedef xstr::xstring<\n  xstr::fixed_char_buf<64> > \n  small_string;",
            "id": "af169e8643749899fc436ea9c3f957fc"
          },
          {
            "type": "code",
            "text": " template <size_t SIZE, \n    class CharT=char, \n    class Traits=std::char_traits<CharT> > \n  class fixed_char_buf;",
            "id": "aec0a3e8205dcfc67fedb13122c985d4"
          },
          {
            "type": "html",
            "text": "\nContrary to what rookie developers may think, the above declarations are simple compared to real production code that uses templates extensively. And that's nothing compared to the compiler errors you will get and the difficulty for debugging it. And only to achieve a 5% speed increase that never materializes because you are always debugging your code.",
            "id": "80a0891c5526acd57863aee9f267dbfc"
          },
          {
            "type": "html",
            "text": "\nCompare with:",
            "id": "9762e91bca4c55d51ee8256d1d5d9731"
          },
          {
            "type": "html",
            "text": "\ntemplate<class R0, class R1, class R2>",
            "id": "d01ad3d783e531fad332282a7e063d22"
          },
          {
            "type": "code",
            "text": "  _bi::bind_t<R0, Find_SZ R0 (Find_CCH *) (R1), typename _bi::list_av_1<R2>::type>\n  Find(Find_SZ R0 (Find_CCH *f) (R1), R2 r2)",
            "id": "8c5738fc8bbb2e81abe504abcaf76e1b"
          },
          {
            "type": "html",
            "text": "{",
            "id": "e2e622cd883b0b9e71cbe80f6f48ef94"
          },
          {
            "type": "code",
            "text": "  typedef Find_SZ R0 (Find_CCH *F) (R1);\n  typedef typename _bi::list_av_1<R2>::type list_type;\n  return _bi::bind_t<R0, F, list_type> (f, list_type(r2));",
            "id": "0015c999fefb9085e6d2c5601ec3b1b1"
          },
          {
            "type": "html",
            "text": "}",
            "id": "aab2becec261fdf52382f7d263019f7e"
          },
          {
            "type": "html",
            "text": "\nAlso keep in mind that the code above has another disadvantage: whenever you declare new variables, there is the possibility of creating a new class at compile time, just because the parameter happens to be sightly different. The code is therefore massive and it takes too long to load.",
            "id": "819617696e8fc4c8fb8e41d167999274"
          },
          {
            "type": "html",
            "text": "-- [[Guillermo Schwarz]].",
            "id": "05b3a65404a48c9873192d997d15d984"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b19d9473360ad2506b252233b10b19"
          },
          {
            "type": "html",
            "text": "[[Category Cpp]] [[Category Cpp Templates]] [[Category Polymorphism]] [[Category Programming Language Comparisons]]",
            "id": "a336d54596ea4a596f7415408c0fd6eb"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?GenericVsObjectOrientedProgramming c2.com]",
            "id": "61ee618903c95ab73698a1817f3a3bbb"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1669144132269
    }
  ]
}