{
  "title": "The “Mirrors” Design Principles",
  "story": [
    {
      "type": "markdown",
      "id": "130c9268ec9127a1",
      "text": "[…] after many years of experience with Smalltalk- and (similar) Java-style reflection, Bracha and Ungar (2004) articulated the “mirrors” design principles which effectively rectified several shortcomings with these VMs’ approaches to reflection. -- [[Unix, Plan 9 and the Lurking Smalltalk]], p. 203\n"
    },
    {
      "type": "markdown",
      "id": "a0a8f6c1aa78825b",
      "text": "Unix-style reflection adheres remarkably tightly to the very same principles, which we summarise as follows."
    },
    {
      "type": "markdown",
      "id": "29bfce86cf104829",
      "text": "* **Encapsulation**, meaning “the ability to write metaprogramming applications that are independent of a specific metaprogramming implementation”, holds that metaprogramming interfaces should not impose undue restrictions on clients, such as reflecting only on the host program (a weakness of Java core reflection).\n* **Stratification**, meaning “making it easy to eliminate reflection when it is not needed”, intends that reflection can be eliminated on embedded platforms or in applications which happen not to use it.\n* **Ontological correspondence**, meaning that metaprogramming interfaces should retain user-meaningful concepts, encompasses both structural (e.g. preserving source code features in the metamodel) and temporal considerations (e.g. the distinction between inactive “code” and active “computation”).\n\nThe Unix approach to debug-time reflection satisfies all of these principles either fully or very nearly; we discuss each in turn.\n"
    },
    {
      "type": "markdown",
      "id": "5786e149a9f6ac86",
      "text": "Next: [[Encapsulation]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "The “Mirrors” Design Principles",
        "story": []
      },
      "date": 1635927690439
    },
    {
      "item": {
        "type": "factory",
        "id": "130c9268ec9127a1"
      },
      "id": "130c9268ec9127a1",
      "type": "add",
      "date": 1635927705952
    },
    {
      "type": "edit",
      "id": "130c9268ec9127a1",
      "item": {
        "type": "markdown",
        "id": "130c9268ec9127a1",
        "text": "[…] after many years of experience with Smalltalk- and (similar) Java-style reflection, Bracha and Ungar (2004) articulated the “mirrors” design principles which effectively rectified several shortcomings with these VMs’ approaches to reflection. -- "
      },
      "date": 1635927720074
    },
    {
      "type": "edit",
      "id": "130c9268ec9127a1",
      "item": {
        "type": "markdown",
        "id": "130c9268ec9127a1",
        "text": "[…] after many years of experience with Smalltalk- and (similar) Java-style reflection, Bracha and Ungar (2004) articulated the “mirrors” design principles which effectively rectified several shortcomings with these VMs’ approaches to reflection. -- [[Unix, Plan 9 and the Lurking Smalltalk]], p. "
      },
      "date": 1635927728913
    },
    {
      "type": "edit",
      "id": "130c9268ec9127a1",
      "item": {
        "type": "markdown",
        "id": "130c9268ec9127a1",
        "text": "[…] after many years of experience with Smalltalk- and (similar) Java-style reflection, Bracha and Ungar (2004) articulated the “mirrors” design principles which effectively rectified several shortcomings with these VMs’ approaches to reflection. -- [[Unix, Plan 9 and the Lurking Smalltalk]], p. 203"
      },
      "date": 1635927739075
    },
    {
      "type": "edit",
      "id": "130c9268ec9127a1",
      "item": {
        "type": "markdown",
        "id": "130c9268ec9127a1",
        "text": "[…] after many years of experience with Smalltalk- and (similar) Java-style reflection, Bracha and Ungar (2004) articulated the “mirrors” design principles which effectively rectified several shortcomings with these VMs’ approaches to reflection. -- [[Unix, Plan 9 and the Lurking Smalltalk]], p. 203\n"
      },
      "date": 1635927786492
    },
    {
      "type": "add",
      "id": "a0a8f6c1aa78825b",
      "item": {
        "type": "markdown",
        "id": "a0a8f6c1aa78825b",
        "text": "Unix-style reflection adheres remarkably tightly to the very same principles, which we summarise as follows."
      },
      "after": "130c9268ec9127a1",
      "date": 1635927789772
    },
    {
      "item": {
        "type": "factory",
        "id": "29bfce86cf104829"
      },
      "id": "29bfce86cf104829",
      "type": "add",
      "after": "a0a8f6c1aa78825b",
      "date": 1635927794330
    },
    {
      "type": "edit",
      "id": "29bfce86cf104829",
      "item": {
        "type": "markdown",
        "id": "29bfce86cf104829",
        "text": "• Encapsulation, meaning “the ability to write metaprogramming applications that are independent of a specific metaprogramming implementation”, holds that metaprogramming interfaces should not impose undue restrictions on clients, such as reflecting only on the host program (a weakness of Java core reflection).\n• Stratification, meaning “making it easy to eliminate reflection when it is not needed”, intends that reflection can be eliminated on embedded platforms or in applications which happen not to use it.\n• Ontological correspondence, meaning that metaprogramming interfaces should retain user-meaningful concepts, encompasses both structural (e.g. preserving source code features in the metamodel) and temporal considerations (e.g. the distinction between inactive “code” and active “computation”).\nThe Unix approach to debug-time reflection satisfies all of these principles either fully or very nearly; we discuss each in turn."
      },
      "date": 1635927795943
    },
    {
      "type": "edit",
      "id": "29bfce86cf104829",
      "item": {
        "type": "markdown",
        "id": "29bfce86cf104829",
        "text": "* Encapsulation, meaning “the ability to write metaprogramming applications that are independent of a specific metaprogramming implementation”, holds that metaprogramming interfaces should not impose undue restrictions on clients, such as reflecting only on the host program (a weakness of Java core reflection).\n* Stratification, meaning “making it easy to eliminate reflection when it is not needed”, intends that reflection can be eliminated on embedded platforms or in applications which happen not to use it.\n* Ontological correspondence, meaning that metaprogramming interfaces should retain user-meaningful concepts, encompasses both structural (e.g. preserving source code features in the metamodel) and temporal considerations (e.g. the distinction between inactive “code” and active “computation”).\n\nThe Unix approach to debug-time reflection satisfies all of these principles either fully or very nearly; we discuss each in turn."
      },
      "date": 1635927815089
    },
    {
      "type": "edit",
      "id": "29bfce86cf104829",
      "item": {
        "type": "markdown",
        "id": "29bfce86cf104829",
        "text": "* **Encapsulation**, meaning “the ability to write metaprogramming applications that are independent of a specific metaprogramming implementation”, holds that metaprogramming interfaces should not impose undue restrictions on clients, such as reflecting only on the host program (a weakness of Java core reflection).\n* **Stratification**, meaning “making it easy to eliminate reflection when it is not needed”, intends that reflection can be eliminated on embedded platforms or in applications which happen not to use it.\n* **Ontological correspondence**, meaning that metaprogramming interfaces should retain user-meaningful concepts, encompasses both structural (e.g. preserving source code features in the metamodel) and temporal considerations (e.g. the distinction between inactive “code” and active “computation”).\n\nThe Unix approach to debug-time reflection satisfies all of these principles either fully or very nearly; we discuss each in turn."
      },
      "date": 1635927838187
    },
    {
      "type": "edit",
      "id": "29bfce86cf104829",
      "item": {
        "type": "markdown",
        "id": "29bfce86cf104829",
        "text": "* **Encapsulation**, meaning “the ability to write metaprogramming applications that are independent of a specific metaprogramming implementation”, holds that metaprogramming interfaces should not impose undue restrictions on clients, such as reflecting only on the host program (a weakness of Java core reflection).\n* **Stratification**, meaning “making it easy to eliminate reflection when it is not needed”, intends that reflection can be eliminated on embedded platforms or in applications which happen not to use it.\n* **Ontological correspondence**, meaning that metaprogramming interfaces should retain user-meaningful concepts, encompasses both structural (e.g. preserving source code features in the metamodel) and temporal considerations (e.g. the distinction between inactive “code” and active “computation”).\n\nThe Unix approach to debug-time reflection satisfies all of these principles either fully or very nearly; we discuss each in turn.\n"
      },
      "date": 1635927870199
    },
    {
      "type": "add",
      "id": "5786e149a9f6ac86",
      "item": {
        "type": "markdown",
        "id": "5786e149a9f6ac86",
        "text": "Next: [[Encapsulation[["
      },
      "after": "29bfce86cf104829",
      "date": 1635927875116
    },
    {
      "type": "edit",
      "id": "5786e149a9f6ac86",
      "item": {
        "type": "markdown",
        "id": "5786e149a9f6ac86",
        "text": "Next: [[Encapsulation]]"
      },
      "date": 1635927880796
    }
  ]
}