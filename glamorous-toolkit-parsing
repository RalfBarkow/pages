{
  "title": "Glamorous Toolkit Parsing",
  "story": [
    {
      "type": "markdown",
      "id": "5ce0312577c6960b",
      "text": "Konrad Hinsen — 03.06.2022\nInteresting idea, I have to try that. I'd have to create another package for the extensions then, as the generated classes are in my main package.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "4292d4ab7fe21b1d",
      "text": "Konrad Hinsen — 03.06.2022\n[[Visitors]] is what I do now, but I have three visitors for my [[AST]] and some code is duplicated in each of them. It would make more sense to have it attached to the AST nodes, given that all it does is preprocessing data in the nodes' elements.\n\n"
    },
    {
      "type": "graphviz",
      "id": "1dcc0b011d8cf610",
      "text": "DOT FROM lambda-browsing",
      "dot": "strict digraph {rankdir=LR\n\n\n\n\n\n\nnode [style=filled fillcolor=lightyellow penwidth=3 color=black fontname=\"Helvetica\"]\n\"Glamorous\nToolkit\nParsing\"\nnode [style=filled fillcolor=lightblue]\nnode [style=filled fillcolor=white penwidth=3 color=black]\n\"Glamorous\nToolkit\nParsing\" -> \"Visitors\"\n\"Glamorous\nToolkit\nParsing\" -> \"AST\"\n\"Glamorous\nToolkit\nParsing\" -> \"PetitParser2\"\n\"Glamorous\nToolkit\nParsing\" -> \"SmaCC\"\n\"Glamorous\nToolkit\nParsing\" -> \"EBNF\"\nnode [style=filled fillcolor=white penwidth=1 color=black]\nnode [style=filled fillcolor=white penwidth=1 color=black]\n\"AST\"\n\"AST\" -> \"ReflectiveMethod\"\n\"AST\" -> \"CompiledMethod\"\n\"AST\" -> \"Twin\"\nnode [style=filled fillcolor=white penwidth=1 color=black]\nnode [style=filled fillcolor=white penwidth=1 color=black]\n\"SmaCC\"\n\"SmaCC\" -> \"SmaCC\"\n\"SmaCC\" -> \"John\nBrant\"\n\"SmaCC\" -> \"Don\nRoberts\"\nnode [style=filled fillcolor=white penwidth=1 color=black]\nnode [style=\"filled,rounded,dotted\" fillcolor=white]\nedge [style=dotted]\n\"Glamorous\nToolkit\nParsing\"}",
      "svg": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<!-- Generated by graphviz version 2.44.0 (20200518.1210)\n -->\n<!-- Pages: 1 -->\n<svg width=\"499pt\" height=\"308pt\"\n viewBox=\"0.00 0.00 498.99 308.42\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 304.42)\">\n<polygon fill=\"white\" stroke=\"transparent\" points=\"-4,4 -4,-304.42 494.99,-304.42 494.99,4 -4,4\"/>\n<!-- Glamorous\nToolkit\nParsing -->\n<g id=\"node1\" class=\"node\">\n<title>Glamorous\nToolkit\nParsing</title>\n<ellipse fill=\"lightyellow\" stroke=\"black\" stroke-width=\"3\" cx=\"59.71\" cy=\"-174.42\" rx=\"59.93\" ry=\"41.09\"/>\n<text text-anchor=\"middle\" x=\"59.71\" y=\"-187.02\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">Glamorous</text>\n<text text-anchor=\"middle\" x=\"59.71\" y=\"-170.22\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">Toolkit</text>\n<text text-anchor=\"middle\" x=\"59.71\" y=\"-153.42\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">Parsing</text>\n</g>\n<!-- Visitors -->\n<g id=\"node2\" class=\"node\">\n<title>Visitors</title>\n<ellipse fill=\"white\" stroke=\"black\" stroke-width=\"3\" cx=\"219.59\" cy=\"-282.42\" rx=\"42.87\" ry=\"18\"/>\n<text text-anchor=\"middle\" x=\"219.59\" y=\"-278.22\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">Visitors</text>\n</g>\n<!-- Glamorous\nToolkit\nParsing&#45;&gt;Visitors -->\n<g id=\"edge1\" class=\"edge\">\n<title>Glamorous\nToolkit\nParsing&#45;&gt;Visitors</title>\n<path fill=\"none\" stroke=\"black\" d=\"M94.7,-207.91C111.92,-223.68 133.74,-241.95 155.43,-255.42 162.2,-259.62 169.73,-263.47 177.17,-266.86\"/>\n<polygon fill=\"black\" stroke=\"black\" points=\"175.92,-270.13 186.49,-270.9 178.71,-263.71 175.92,-270.13\"/>\n</g>\n<!-- AST -->\n<g id=\"node3\" class=\"node\">\n<title>AST</title>\n<ellipse fill=\"white\" stroke=\"black\" stroke-width=\"3\" cx=\"219.59\" cy=\"-228.42\" rx=\"29.63\" ry=\"18\"/>\n<text text-anchor=\"middle\" x=\"219.59\" y=\"-224.22\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">AST</text>\n</g>\n<!-- Glamorous\nToolkit\nParsing&#45;&gt;AST -->\n<g id=\"edge2\" class=\"edge\">\n<title>Glamorous\nToolkit\nParsing&#45;&gt;AST</title>\n<path fill=\"none\" stroke=\"black\" d=\"M113.72,-192.55C136.82,-200.45 163.24,-209.49 183.79,-216.51\"/>\n<polygon fill=\"black\" stroke=\"black\" points=\"182.77,-219.86 193.36,-219.79 185.03,-213.24 182.77,-219.86\"/>\n</g>\n<!-- PetitParser2 -->\n<g id=\"node4\" class=\"node\">\n<title>PetitParser2</title>\n<ellipse fill=\"white\" stroke=\"black\" stroke-width=\"3\" cx=\"219.59\" cy=\"-174.42\" rx=\"64.32\" ry=\"18\"/>\n<text text-anchor=\"middle\" x=\"219.59\" y=\"-170.22\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">PetitParser2</text>\n</g>\n<!-- Glamorous\nToolkit\nParsing&#45;&gt;PetitParser2 -->\n<g id=\"edge3\" class=\"edge\">\n<title>Glamorous\nToolkit\nParsing&#45;&gt;PetitParser2</title>\n<path fill=\"none\" stroke=\"black\" d=\"M119.5,-174.42C127.88,-174.42 136.59,-174.42 145.2,-174.42\"/>\n<polygon fill=\"black\" stroke=\"black\" points=\"145.25,-177.92 155.25,-174.42 145.25,-170.92 145.25,-177.92\"/>\n</g>\n<!-- SmaCC -->\n<g id=\"node5\" class=\"node\">\n<title>SmaCC</title>\n<ellipse fill=\"white\" stroke=\"black\" stroke-width=\"3\" cx=\"219.59\" cy=\"-102.42\" rx=\"44.66\" ry=\"18\"/>\n<text text-anchor=\"middle\" x=\"219.59\" y=\"-98.22\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">SmaCC</text>\n</g>\n<!-- Glamorous\nToolkit\nParsing&#45;&gt;SmaCC -->\n<g id=\"edge4\" class=\"edge\">\n<title>Glamorous\nToolkit\nParsing&#45;&gt;SmaCC</title>\n<path fill=\"none\" stroke=\"black\" d=\"M110.23,-151.83C132.66,-141.6 158.79,-129.69 179.76,-120.12\"/>\n<polygon fill=\"black\" stroke=\"black\" points=\"181.36,-123.24 189.01,-115.91 178.46,-116.87 181.36,-123.24\"/>\n</g>\n<!-- EBNF -->\n<g id=\"node6\" class=\"node\">\n<title>EBNF</title>\n<ellipse fill=\"white\" stroke=\"black\" stroke-width=\"3\" cx=\"219.59\" cy=\"-48.42\" rx=\"36.58\" ry=\"18\"/>\n<text text-anchor=\"middle\" x=\"219.59\" y=\"-44.22\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">EBNF</text>\n</g>\n<!-- Glamorous\nToolkit\nParsing&#45;&gt;EBNF -->\n<g id=\"edge5\" class=\"edge\">\n<title>Glamorous\nToolkit\nParsing&#45;&gt;EBNF</title>\n<path fill=\"none\" stroke=\"black\" d=\"M89.3,-137.92C106.72,-117.5 130.4,-92.75 155.43,-75.42 162.69,-70.39 171.03,-66.01 179.22,-62.33\"/>\n<polygon fill=\"black\" stroke=\"black\" points=\"180.84,-65.44 188.69,-58.33 178.12,-58.99 180.84,-65.44\"/>\n</g>\n<!-- ReflectiveMethod -->\n<g id=\"node7\" class=\"node\">\n<title>ReflectiveMethod</title>\n<ellipse fill=\"white\" stroke=\"black\" cx=\"405.37\" cy=\"-282.42\" rx=\"85.75\" ry=\"18\"/>\n<text text-anchor=\"middle\" x=\"405.37\" y=\"-278.22\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">ReflectiveMethod</text>\n</g>\n<!-- AST&#45;&gt;ReflectiveMethod -->\n<g id=\"edge6\" class=\"edge\">\n<title>AST&#45;&gt;ReflectiveMethod</title>\n<path fill=\"none\" stroke=\"black\" d=\"M246.92,-236.15C272.28,-243.61 311.55,-255.14 344.53,-264.83\"/>\n<polygon fill=\"black\" stroke=\"black\" points=\"343.96,-268.31 354.54,-267.77 345.93,-261.6 343.96,-268.31\"/>\n</g>\n<!-- CompiledMethod -->\n<g id=\"node8\" class=\"node\">\n<title>CompiledMethod</title>\n<ellipse fill=\"white\" stroke=\"black\" cx=\"405.37\" cy=\"-228.42\" rx=\"84.02\" ry=\"18\"/>\n<text text-anchor=\"middle\" x=\"405.37\" y=\"-224.22\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">CompiledMethod</text>\n</g>\n<!-- AST&#45;&gt;CompiledMethod -->\n<g id=\"edge7\" class=\"edge\">\n<title>AST&#45;&gt;CompiledMethod</title>\n<path fill=\"none\" stroke=\"black\" d=\"M249.71,-228.42C266.47,-228.42 288.58,-228.42 310.81,-228.42\"/>\n<polygon fill=\"black\" stroke=\"black\" points=\"311.02,-231.92 321.02,-228.42 311.02,-224.92 311.02,-231.92\"/>\n</g>\n<!-- Twin -->\n<g id=\"node9\" class=\"node\">\n<title>Twin</title>\n<ellipse fill=\"white\" stroke=\"black\" cx=\"405.37\" cy=\"-174.42\" rx=\"31.34\" ry=\"18\"/>\n<text text-anchor=\"middle\" x=\"405.37\" y=\"-170.22\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">Twin</text>\n</g>\n<!-- AST&#45;&gt;Twin -->\n<g id=\"edge8\" class=\"edge\">\n<title>AST&#45;&gt;Twin</title>\n<path fill=\"none\" stroke=\"black\" d=\"M246.92,-220.68C278.45,-211.42 331.46,-195.84 367.16,-185.35\"/>\n<polygon fill=\"black\" stroke=\"black\" points=\"368.58,-188.58 377.19,-182.4 366.61,-181.86 368.58,-188.58\"/>\n</g>\n<!-- SmaCC&#45;&gt;SmaCC -->\n<g id=\"edge9\" class=\"edge\">\n<title>SmaCC&#45;&gt;SmaCC</title>\n<path fill=\"none\" stroke=\"black\" d=\"M193.15,-117.21C184.54,-127.83 193.36,-138.42 219.59,-138.42 237.62,-138.42 247.42,-133.41 248.99,-126.83\"/>\n<polygon fill=\"black\" stroke=\"black\" points=\"252.31,-125.73 246.02,-117.21 245.62,-127.79 252.31,-125.73\"/>\n</g>\n<!-- John\nBrant -->\n<g id=\"node10\" class=\"node\">\n<title>John\nBrant</title>\n<ellipse fill=\"white\" stroke=\"black\" cx=\"405.37\" cy=\"-106.42\" rx=\"34.94\" ry=\"29.33\"/>\n<text text-anchor=\"middle\" x=\"405.37\" y=\"-110.62\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">John</text>\n<text text-anchor=\"middle\" x=\"405.37\" y=\"-93.82\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">Brant</text>\n</g>\n<!-- SmaCC&#45;&gt;John\nBrant -->\n<g id=\"edge10\" class=\"edge\">\n<title>SmaCC&#45;&gt;John\nBrant</title>\n<path fill=\"none\" stroke=\"black\" d=\"M264.61,-103.37C293.45,-104 331.03,-104.82 359.96,-105.45\"/>\n<polygon fill=\"black\" stroke=\"black\" points=\"360.11,-108.95 370.19,-105.67 360.27,-101.95 360.11,-108.95\"/>\n</g>\n<!-- Don\nRoberts -->\n<g id=\"node11\" class=\"node\">\n<title>Don\nRoberts</title>\n<ellipse fill=\"white\" stroke=\"black\" cx=\"405.37\" cy=\"-29.42\" rx=\"45.93\" ry=\"29.33\"/>\n<text text-anchor=\"middle\" x=\"405.37\" y=\"-33.62\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">Don</text>\n<text text-anchor=\"middle\" x=\"405.37\" y=\"-16.82\" font-family=\"Helvetica,sans-Serif\" font-size=\"14.00\">Roberts</text>\n</g>\n<!-- SmaCC&#45;&gt;Don\nRoberts -->\n<g id=\"edge11\" class=\"edge\">\n<title>SmaCC&#45;&gt;Don\nRoberts</title>\n<path fill=\"none\" stroke=\"black\" d=\"M252.18,-89.87C280.86,-78.48 323.56,-61.51 356.44,-48.45\"/>\n<polygon fill=\"black\" stroke=\"black\" points=\"357.86,-51.65 365.87,-44.71 355.28,-45.15 357.86,-51.65\"/>\n</g>\n</g>\n</svg>\n"
    },
    {
      "type": "markdown",
      "id": "f9edaebdc1ae4d22",
      "text": "esmiralha — 03.06.2022\nCan't you move the common code to a common visitor base class?\nKonrad Hinsen — 04.06.2022\nThey already inherit from something else. But I could make it a trait…\nesmiralha — 04.06.2022\n@lukego we have a \"parsing club\" down here. You are welcome to join. 😁\n\n"
    },
    {
      "type": "markdown",
      "id": "58327ff2cc96ee75",
      "text": "lukego — 04.06.2022\nOh cool :-). So I want to write a mostly ad-hoc parser, the kind of thing that I'd normally do in awk, and my first thought is to reach for [[PetitParser2]]. But it looks like that is kind of abandoned, in that in the \"old\" GT it seemed like the main parser and had quite a bit of tooling (custom browser etc.) So now I'm wondering, do I need to read a book about [[SmaCC]] or something? 😄\nI see that PetitParser2 is still there in the image, and the code snippets will still work (and there are a few senders of asPParser as minor examples), but it looks hugely scaled back in terms of tooling and usage if I'm reading this right.\n\n"
    },
    {
      "type": "markdown",
      "id": "db486af44f39cec6",
      "text": "esmiralha — 04.06.2022\nSmaCC starts with a [[EBNF]] grammar. There's a booklet in Smacc that you can download from the Pharo website.\n\n"
    },
    {
      "type": "markdown",
      "id": "c19c4985ef8f5cb9",
      "text": "SeanDeNigris — 04.06.2022\nI guess the petit parser tools were never ported to bloc, but honestly it’s so straightforward that I usually just code it up in a playground. I wouldn’t say it’s unsupported, just that there hasn’t been much integration into new GT \n\n"
    },
    {
      "type": "markdown",
      "id": "0368997e1c86c95c",
      "text": "tudor girba — 04.06.2022\nPetitParser2 is not scaled back. It is quite well suited for ad-hoc parsing. It's just that we focused more on language support and for that we constructed a more elaborate infrastructure around SmaCC.\n\n"
    },
    {
      "type": "markdown",
      "id": "458b3796a11e3f88",
      "text": "Carcaj0u — 05.06.2022\n@lukego And the booklet link is http://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html\n\n"
    },
    {
      "type": "reference",
      "id": "49469a89253466cf",
      "site": "wiki.ralfbarkow.ch",
      "slug": "smacc-a-compiler-compiler",
      "title": "SmaCC: A Compiler-Compiler",
      "text": "Booklet. [https://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccIntro.html#about%20this%20booklet page]"
    },
    {
      "type": "markdown",
      "id": "37b610a9ed7d3a18",
      "text": "Carcaj0u — 05.06.2022\nRight. So does the SmaCC recompilation affect everything in the \"my\" SmaCC package, or could these inheriting classes atay near to the generated ASTVisitor class?? \n\n"
    },
    {
      "type": "markdown",
      "id": "ee00772ebc99e821",
      "text": "Konrad Hinsen — 05.06.2022\nI wish I knew. SmaCC is a very powerful but also a mostly undocumented tool.\n\n"
    },
    {
      "type": "markdown",
      "id": "f8d3f12f23bcdfaa",
      "text": "esmiralha — 05.06.2022\nWhat kind of behavior you want to attach to the nodes?\n\n"
    },
    {
      "type": "markdown",
      "id": "2ef45c8fd8e1e426",
      "text": "Konrad Hinsen — 05.06.2022\nBasic example: many of my nodes have an \"options\" field which holds a sequence of \"key=value\" items. I'd like to attach a method that returns these key-value pairs as a dictionary.\n\n"
    },
    {
      "type": "markdown",
      "id": "87e2788729ba73a1",
      "text": "esmiralha — 05.06.2022\nMaybe you can use the [[visitor]] to dynamically add the methods to the nodes? Is this even possible?\n\n"
    },
    {
      "type": "markdown",
      "id": "c146b080c2ea38e3",
      "text": "Konrad Hinsen — 06.06.2022\nProbably yes, but it's probably also bad practice in the sense that it will cause maintenance headaches later on.\nWhat I was hoping for is a mechanism that is part of SmaCC. For example a method that is called at the end of AST class generation and that I could override to add modifications like this.\nThread\nExtending AST nodes\n3 Nachrichten ›\nIn diesem Thread gibt es keine aktuellen Nachrichten.\nesmiralha\n hat einen Thread begonnen: \nExtending AST nodes\n. Alle \nThreads\n anzeigen.\n — 06.06.2022\n\n"
    },
    {
      "type": "markdown",
      "id": "727747c87c687d55",
      "text": "Konrad Hinsen — 07.06.2022\nWhat's the best technique for debugging SmaCC parsers in GT? My problem is that SmaCCErrors provide no information about what went wrong. And I can't get anything clearer from the GT tools, but that's perhaps just my ignorance.\nExample: I have this token definition, and the simulator says that \"a\" is a valid token:\nBild\nThen I have a production rule that uses this token, but it looks like the parser considers the token wrong/inappropriate/whatever:\nBild\nAll I get is \"Error\". So what should I do next to figure out what's going wrong?\n\n"
    },
    {
      "type": "markdown",
      "id": "b52d5e23b196eff2",
      "text": "esmiralha — 07.06.2022\nDoes the Transcript show anything?\n\n"
    },
    {
      "type": "markdown",
      "id": "c10f93713e64ecab",
      "text": "Konrad Hinsen — 07.06.2022\nNothing at all.\n\n"
    },
    {
      "type": "markdown",
      "id": "0689dbd2e07a4ea2",
      "text": "esmiralha — 07.06.2022\nhave you set the [[root directive]] for the AST? \nalso, do you have a [[whitespace token]]?\nasking for the things where I have tripped when trying to parse a very simple language\n\n"
    },
    {
      "type": "markdown",
      "id": "2333862791eb791e",
      "text": "Konrad Hinsen — 07.06.2022\nYes, I have a root directive, and the AST classes are generated correctly. I also have the standard whitespace token. It's actually a medium-sized parser that works very well overall. It's just my last addition that doesn't work, for reasons that I don't understand at all.\n\n"
    },
    {
      "type": "markdown",
      "id": "3d597ab450486775",
      "text": "Konrad Hinsen — 07.06.2022\nI just did another test: extract the minimal subset of my parser that supports the rule I have problems with. And that minimal subset works just fine. So it's the presence of additional tokens and production rules that perturbs the two I am looking at.\n\n"
    },
    {
      "type": "markdown",
      "id": "7e75f1bf9eeef3a6",
      "text": "esmiralha — 07.06.2022\nmaybe there is overlap on the tokens?\nand the order of their definition is messing with the parsing?\ni could get an error like yours \nBild\n\n"
    },
    {
      "type": "markdown",
      "id": "7788494ce30e9c25",
      "text": "esmiralha — 07.06.2022\nsection 3.2 of the [[SmaCC booklet]] deals with token overlap\n\n"
    },
    {
      "type": "markdown",
      "id": "5bc749e7440236c8",
      "text": "⇒ [[Overlapping Tokens]]. [https://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccScanner.html#overlapping%20tokens booklet-Smacc]"
    },
    {
      "type": "markdown",
      "id": "2b8cb79d6ae5b963",
      "text": "Konrad Hinsen — 07.06.2022\nAhh.... thanks, that was very helpful. I have indeed another token definition that overlaps in many cases.\n\nThat brings me back to my original question: how could GT help me diagnose such a problem? It would be great, for example, if I could see the tokens coming out of the scanner. I would immediately have spotted that the token is not the one I expected.\n\n"
    },
    {
      "type": "markdown",
      "id": "2ef92c69ee9c8e10",
      "text": "Damien — 07.06.2022\nsome tool could also analyze all tokens from a given scanner and tell you about the overlap\n\n"
    },
    {
      "type": "markdown",
      "id": "625f696d6b02435a",
      "text": "esmiralha — 07.06.2022\nnote that overlapping is supported and that SmaCC will select the longest match\n\n"
    },
    {
      "type": "markdown",
      "id": "933184286dfa0711",
      "text": "Konrad Hinsen — 07.06.2022\nFine, but that doesn't remove the need for debugging tools. The scanner is pretty much inaccessible now (unless I am missing something). You only see the final output from the parser.\n\n"
    },
    {
      "type": "markdown",
      "id": "565f96e913da84cd",
      "text": "esmiralha — 07.06.2022\n@Konrad Hinsen I found some stuff that may interest you in section 5.4 of the SmacCC booklet. It talks about AST directives that can change the node classes generation process.\n\n"
    },
    {
      "type": "markdown",
      "id": "48938f83b9fd7898",
      "text": "Konrad Hinsen — 08.06.2022\nI studied that section in detail a while ago. But all these mechanisms are very specific, for problems different from those I am dealing with. What I am looking for is a more general mechanism for modifying a parser's behavior, probably doable only at the Smalltalk level.\n\n"
    },
    {
      "type": "markdown",
      "id": "2b78b593e286742e",
      "text": "tudor girba — 08.06.2022\nYep, the SmaCC debugging support can be improved. One thing you could try is to use the actual debugger:\nBild\n\n"
    },
    {
      "type": "markdown",
      "id": "64a710d273a95345",
      "text": "esmiralha — 08.06.2022\nThere is an attributes directive where you can create attributes in your nodes. I could conceive extending ng the idea to a methods directive that would attach custom methods to nodes, as well.\nThere is also a hierarchy directive that allows you to state that some node types will be subclasses of a specific class. Not sure if it helps with your specific  case .\nThe general case of transforming an AST tree can be handled by a [[custom visitor]].  I would give it a shot and see if it is really too complicated.\n\n"
    },
    {
      "type": "markdown",
      "id": "3172d1e443fbeecb",
      "text": "Konrad Hinsen — 08.06.2022\nThat looks promising! Parsing a Lepiter snippet never raises an exception that would open a debugger. I just see error nodes in the AST. So I guess I have to use the parser outside of Lepiter. Will try...\n\n"
    },
    {
      "type": "markdown",
      "id": "c423d7af93a0245a",
      "text": "Konrad Hinsen — 08.06.2022\nFound \"attributes\" in the manual: \"The %attributes directive allows you to add some extra instance variables to your classes. This enables you to later extend the generated classes to use those variables.\" That sounds very promising. But I have no idea how \"extending the generated classes\" could work. There is little point in adding instance variables to a Pharo class unless corresponding methods can be added as well. From the outside, those instance variables are only accessible through reflection.\n\n"
    },
    {
      "type": "markdown",
      "id": "7e920dc3592d3df0",
      "text": "Konrad Hinsen — 08.06.2022\nI am doing this, it works well, but I am not happy with the code structure imposed by the [[Visitor Pattern]], which I find hard to navigate.\n\n"
    },
    {
      "type": "markdown",
      "id": "1747120464cbd043",
      "text": "tudor girba — 08.06.2022\nYes, execute the parser explicitly from a Pharo snippet\n\n"
    },
    {
      "type": "markdown",
      "id": "1d40aefc89fad4e0",
      "text": "Konrad Hinsen — 08.06.2022\nGreat. Just what the doctor ordered 🙂\n\n"
    },
    {
      "type": "markdown",
      "id": "151f8d8b48bcb4db",
      "text": "Konrad Hinsen — heute um 08:19 Uhr\nThat's so useful that now I find myself introducing deliberate errors into my string to get a debugger which lets me inspect the scanner output.\n\n"
    },
    {
      "type": "markdown",
      "id": "d40698e8de87f004",
      "text": "tudor girba — heute um 08:55 Uhr\n:))). We definitely need to bring (some) of that information in the inspector\n"
    },
    {
      "type": "pagefold",
      "id": "94d386e9262b8fd8",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "67935b18e7a1f8d2",
      "text": "⇒ [[Parsing For Agile Modeling]] ⇒ [[Exploratory Parsing]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Glamorous Toolkit Parsing",
        "story": []
      },
      "date": 1654861213880
    },
    {
      "item": {
        "type": "factory",
        "id": "5ce0312577c6960b"
      },
      "id": "5ce0312577c6960b",
      "type": "add",
      "date": 1654861229986
    },
    {
      "type": "edit",
      "id": "5ce0312577c6960b",
      "item": {
        "type": "markdown",
        "id": "5ce0312577c6960b",
        "text": "Konrad Hinsen — 03.06.2022\nInteresting idea, I have to try that. I'd have to create another package for the extensions then, as the generated classes are in my main package.\nKonrad Hinsen — 03.06.2022\nVisitors is what I do now, but I have three visitors for my AST and some code is duplicated in each of them. It would make more sense to have it attached to the AST nodes, given that all it does is preprocessing data in the nodes' elements.\nesmiralha — 03.06.2022\nCan't you move the common code to a common visitor base class?\nKonrad Hinsen — 04.06.2022\nThey already inherit from something else. But I could make it a trait…\nesmiralha — 04.06.2022\n@lukego we have a \"parsing club\" down here. You are welcome to join. 😁\nlukego — 04.06.2022\nOh cool :-). So I want to write a mostly ad-hoc parser, the kind of thing that I'd normally do in awk, and my first thought is to reach for PetitParser2. But it looks like that is kind of abandoned, in that in the \"old\" GT it seemed like the main parser and had quite a bit of tooling (custom browser etc.) So now I'm wondering, do I need to read a book about SmaCC or something? 😄\nI see that PetitParser2 is still there in the image, and the code snippets will still work (and there are a few senders of asPParser as minor examples), but it looks hugely scaled back in terms of tooling and usage if I'm reading this right.\nesmiralha — 04.06.2022\nSmaCC starts with a EBNF grammar. There's a booklet in Smacc that you can download from the Pharo website.\nSeanDeNigris — 04.06.2022\nI guess the petit parser tools were never ported to bloc, but honestly it’s so straightforward that I usually just code it up in a playground. I wouldn’t say it’s unsupported, just that there hasn’t been much integration into new GT \ntudor girba — 04.06.2022\nPetitParser2 is not scaled back. It is quite well suited for ad-hoc parsing. It's just that we focused more on language support and for that we constructed a more elaborate infrastructure around SmaCC.\nCarcaj0u — 05.06.2022\n@lukego And the booklet link is http://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html\nCarcaj0u — 05.06.2022\nRight. So does the SmaCC recompilation affect everything in the \"my\" SmaCC package, or could these inheriting classes atay near to the generated ASTVisitor class?? \nKonrad Hinsen — 05.06.2022\nI wish I knew. SmaCC is a very powerful but also a mostly undocumented tool.\nesmiralha — 05.06.2022\nWhat kind of behavior you want to attach to the nodes?\nKonrad Hinsen — 05.06.2022\nBasic example: many of my nodes have an \"options\" field which holds a sequence of \"key=value\" items. I'd like to attach a method that returns these key-value pairs as a dictionary.\nesmiralha — 05.06.2022\nMaybe you can use the visitor to dynamically add the methods to the nodes? Is this even possible?\nKonrad Hinsen — 06.06.2022\nProbably yes, but it's probably also bad practice in the sense that it will cause maintenance headaches later on.\nWhat I was hoping for is a mechanism that is part of SmaCC. For example a method that is called at the end of AST class generation and that I could override to add modifications like this.\nThread\nExtending AST nodes\n3 Nachrichten ›\nIn diesem Thread gibt es keine aktuellen Nachrichten.\nesmiralha\n hat einen Thread begonnen: \nExtending AST nodes\n. Alle \nThreads\n anzeigen.\n — 06.06.2022\nKonrad Hinsen — 07.06.2022\nWhat's the best technique for debugging SmaCC parsers in GT? My problem is that SmaCCErrors provide no information about what went wrong. And I can't get anything clearer from the GT tools, but that's perhaps just my ignorance.\nExample: I have this token definition, and the simulator says that \"a\" is a valid token:\nBild\nThen I have a production rule that uses this token, but it looks like the parser considers the token wrong/inappropriate/whatever:\nBild\nAll I get is \"Error\". So what should I do next to figure out what's going wrong?\nesmiralha — 07.06.2022\nDoes the Transcript show anything?\nKonrad Hinsen — 07.06.2022\nNothing at all.\nesmiralha — 07.06.2022\nhave you set the root directive for the AST? \nalso, do you have a whitespace token?\nasking for the things where I have tripped when trying to parse a very simple language\nKonrad Hinsen — 07.06.2022\nYes, I have a root directive, and the AST classes are generated correctly. I also have the standard whitespace token. It's actually a medium-sized parser that works very well overall. It's just my last addition that doesn't work, for reasons that I don't understand at all.\nKonrad Hinsen — 07.06.2022\nI just did another test: extract the minimal subset of my parser that supports the rule I have problems with. And that minimal subset works just fine. So it's the presence of additional tokens and production rules that perturbs the two I am looking at.\nesmiralha — 07.06.2022\nmaybe there is overlap on the tokens?\nand the order of their definition is messing with the parsing?\ni could get an error like yours \nBild\nesmiralha — 07.06.2022\nsection 3.2 of the SmaCC booklet deals with token overlap\nKonrad Hinsen — 07.06.2022\nAhh.... thanks, that was very helpful. I have indeed another token definition that overlaps in many cases.\n\nThat brings me back to my original question: how could GT help me diagnose such a problem? It would be great, for example, if I could see the tokens coming out of the scanner. I would immediately have spotted that the token is not the one I expected.\nDamien — 07.06.2022\nsome tool could also analyze all tokens from a given scanner and tell you about the overlap\nesmiralha — 07.06.2022\nnote that overlapping is supported and that SmaCC will select the longest match\nKonrad Hinsen — 07.06.2022\nFine, but that doesn't remove the need for debugging tools. The scanner is pretty much inaccessible now (unless I am missing something). You only see the final output from the parser.\nesmiralha — 07.06.2022\n@Konrad Hinsen I found some stuff that may interest you in section 5.4 of the SmacCC booklet. It talks about AST directives that can change the node classes generation process.\nKonrad Hinsen — 08.06.2022\nI studied that section in detail a while ago. But all these mechanisms are very specific, for problems different from those I am dealing with. What I am looking for is a more general mechanism for modifying a parser's behavior, probably doable only at the Smalltalk level.\ntudor girba — 08.06.2022\nYep, the SmaCC debugging support can be improved. One thing you could try is to use the actual debugger:\nBild\nesmiralha — 08.06.2022\nThere is an attributes directive where you can create attributes in your nodes. I could conceive extending ng the idea to a methods directive that would attach custom methods to nodes, as well.\nThere is also a hierarchy directive that allows you to state that some node types will be subclasses of a specific class. Not sure if it helps with your specific  case .\nThe general case of transforming an AST tree can be handled by a custom visitor.  I would give it a shot and see if it is really too complicated.\nKonrad Hinsen — 08.06.2022\nThat looks promising! Parsing a Lepiter snippet never raises an exception that would open a debugger. I just see error nodes in the AST. So I guess I have to use the parser outside of Lepiter. Will try...\nKonrad Hinsen — 08.06.2022\nFound \"attributes\" in the manual: \"The %attributes directive allows you to add some extra instance variables to your classes. This enables you to later extend the generated classes to use those variables.\" That sounds very promising. But I have no idea how \"extending the generated classes\" could work. There is little point in adding instance variables to a Pharo class unless corresponding methods can be added as well. From the outside, those instance variables are only accessible through reflection.\nKonrad Hinsen — 08.06.2022\nI am doing this, it works well, but I am not happy with the code structure imposed by the visitor pattern, which I find hard to navigate.\ntudor girba — 08.06.2022\nYes, execute the parser explicitly from a Pharo snippet\nKonrad Hinsen — 08.06.2022\nGreat. Just what the doctor ordered 🙂\nKonrad Hinsen — heute um 08:19 Uhr\nThat's so useful that now I find myself introducing deliberate errors into my string to get a debugger which lets me inspect the scanner output.\ntudor girba — heute um 08:55 Uhr\n:))). We definitely need to bring (some) of that information in the inspector\n"
      },
      "date": 1654861232917
    },
    {
      "type": "edit",
      "id": "5ce0312577c6960b",
      "item": {
        "type": "markdown",
        "id": "5ce0312577c6960b",
        "text": "Konrad Hinsen — 03.06.2022\nInteresting idea, I have to try that. I'd have to create another package for the extensions then, as the generated classes are in my main package.\nKonrad Hinsen — 03.06.2022\n[[Visitors]] is what I do now, but I have three visitors for my AST and some code is duplicated in each of them. It would make more sense to have it attached to the AST nodes, given that all it does is preprocessing data in the nodes' elements.\nesmiralha — 03.06.2022\nCan't you move the common code to a common visitor base class?\nKonrad Hinsen — 04.06.2022\nThey already inherit from something else. But I could make it a trait…\nesmiralha — 04.06.2022\n@lukego we have a \"parsing club\" down here. You are welcome to join. 😁\nlukego — 04.06.2022\nOh cool :-). So I want to write a mostly ad-hoc parser, the kind of thing that I'd normally do in awk, and my first thought is to reach for PetitParser2. But it looks like that is kind of abandoned, in that in the \"old\" GT it seemed like the main parser and had quite a bit of tooling (custom browser etc.) So now I'm wondering, do I need to read a book about SmaCC or something? 😄\nI see that PetitParser2 is still there in the image, and the code snippets will still work (and there are a few senders of asPParser as minor examples), but it looks hugely scaled back in terms of tooling and usage if I'm reading this right.\nesmiralha — 04.06.2022\nSmaCC starts with a EBNF grammar. There's a booklet in Smacc that you can download from the Pharo website.\nSeanDeNigris — 04.06.2022\nI guess the petit parser tools were never ported to bloc, but honestly it’s so straightforward that I usually just code it up in a playground. I wouldn’t say it’s unsupported, just that there hasn’t been much integration into new GT \ntudor girba — 04.06.2022\nPetitParser2 is not scaled back. It is quite well suited for ad-hoc parsing. It's just that we focused more on language support and for that we constructed a more elaborate infrastructure around SmaCC.\nCarcaj0u — 05.06.2022\n@lukego And the booklet link is http://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html\nCarcaj0u — 05.06.2022\nRight. So does the SmaCC recompilation affect everything in the \"my\" SmaCC package, or could these inheriting classes atay near to the generated ASTVisitor class?? \nKonrad Hinsen — 05.06.2022\nI wish I knew. SmaCC is a very powerful but also a mostly undocumented tool.\nesmiralha — 05.06.2022\nWhat kind of behavior you want to attach to the nodes?\nKonrad Hinsen — 05.06.2022\nBasic example: many of my nodes have an \"options\" field which holds a sequence of \"key=value\" items. I'd like to attach a method that returns these key-value pairs as a dictionary.\nesmiralha — 05.06.2022\nMaybe you can use the visitor to dynamically add the methods to the nodes? Is this even possible?\nKonrad Hinsen — 06.06.2022\nProbably yes, but it's probably also bad practice in the sense that it will cause maintenance headaches later on.\nWhat I was hoping for is a mechanism that is part of SmaCC. For example a method that is called at the end of AST class generation and that I could override to add modifications like this.\nThread\nExtending AST nodes\n3 Nachrichten ›\nIn diesem Thread gibt es keine aktuellen Nachrichten.\nesmiralha\n hat einen Thread begonnen: \nExtending AST nodes\n. Alle \nThreads\n anzeigen.\n — 06.06.2022\nKonrad Hinsen — 07.06.2022\nWhat's the best technique for debugging SmaCC parsers in GT? My problem is that SmaCCErrors provide no information about what went wrong. And I can't get anything clearer from the GT tools, but that's perhaps just my ignorance.\nExample: I have this token definition, and the simulator says that \"a\" is a valid token:\nBild\nThen I have a production rule that uses this token, but it looks like the parser considers the token wrong/inappropriate/whatever:\nBild\nAll I get is \"Error\". So what should I do next to figure out what's going wrong?\nesmiralha — 07.06.2022\nDoes the Transcript show anything?\nKonrad Hinsen — 07.06.2022\nNothing at all.\nesmiralha — 07.06.2022\nhave you set the root directive for the AST? \nalso, do you have a whitespace token?\nasking for the things where I have tripped when trying to parse a very simple language\nKonrad Hinsen — 07.06.2022\nYes, I have a root directive, and the AST classes are generated correctly. I also have the standard whitespace token. It's actually a medium-sized parser that works very well overall. It's just my last addition that doesn't work, for reasons that I don't understand at all.\nKonrad Hinsen — 07.06.2022\nI just did another test: extract the minimal subset of my parser that supports the rule I have problems with. And that minimal subset works just fine. So it's the presence of additional tokens and production rules that perturbs the two I am looking at.\nesmiralha — 07.06.2022\nmaybe there is overlap on the tokens?\nand the order of their definition is messing with the parsing?\ni could get an error like yours \nBild\nesmiralha — 07.06.2022\nsection 3.2 of the SmaCC booklet deals with token overlap\nKonrad Hinsen — 07.06.2022\nAhh.... thanks, that was very helpful. I have indeed another token definition that overlaps in many cases.\n\nThat brings me back to my original question: how could GT help me diagnose such a problem? It would be great, for example, if I could see the tokens coming out of the scanner. I would immediately have spotted that the token is not the one I expected.\nDamien — 07.06.2022\nsome tool could also analyze all tokens from a given scanner and tell you about the overlap\nesmiralha — 07.06.2022\nnote that overlapping is supported and that SmaCC will select the longest match\nKonrad Hinsen — 07.06.2022\nFine, but that doesn't remove the need for debugging tools. The scanner is pretty much inaccessible now (unless I am missing something). You only see the final output from the parser.\nesmiralha — 07.06.2022\n@Konrad Hinsen I found some stuff that may interest you in section 5.4 of the SmacCC booklet. It talks about AST directives that can change the node classes generation process.\nKonrad Hinsen — 08.06.2022\nI studied that section in detail a while ago. But all these mechanisms are very specific, for problems different from those I am dealing with. What I am looking for is a more general mechanism for modifying a parser's behavior, probably doable only at the Smalltalk level.\ntudor girba — 08.06.2022\nYep, the SmaCC debugging support can be improved. One thing you could try is to use the actual debugger:\nBild\nesmiralha — 08.06.2022\nThere is an attributes directive where you can create attributes in your nodes. I could conceive extending ng the idea to a methods directive that would attach custom methods to nodes, as well.\nThere is also a hierarchy directive that allows you to state that some node types will be subclasses of a specific class. Not sure if it helps with your specific  case .\nThe general case of transforming an AST tree can be handled by a custom visitor.  I would give it a shot and see if it is really too complicated.\nKonrad Hinsen — 08.06.2022\nThat looks promising! Parsing a Lepiter snippet never raises an exception that would open a debugger. I just see error nodes in the AST. So I guess I have to use the parser outside of Lepiter. Will try...\nKonrad Hinsen — 08.06.2022\nFound \"attributes\" in the manual: \"The %attributes directive allows you to add some extra instance variables to your classes. This enables you to later extend the generated classes to use those variables.\" That sounds very promising. But I have no idea how \"extending the generated classes\" could work. There is little point in adding instance variables to a Pharo class unless corresponding methods can be added as well. From the outside, those instance variables are only accessible through reflection.\nKonrad Hinsen — 08.06.2022\nI am doing this, it works well, but I am not happy with the code structure imposed by the visitor pattern, which I find hard to navigate.\ntudor girba — 08.06.2022\nYes, execute the parser explicitly from a Pharo snippet\nKonrad Hinsen — 08.06.2022\nGreat. Just what the doctor ordered 🙂\nKonrad Hinsen — heute um 08:19 Uhr\nThat's so useful that now I find myself introducing deliberate errors into my string to get a debugger which lets me inspect the scanner output.\ntudor girba — heute um 08:55 Uhr\n:))). We definitely need to bring (some) of that information in the inspector\n"
      },
      "date": 1654861250228
    },
    {
      "type": "edit",
      "id": "5ce0312577c6960b",
      "item": {
        "type": "markdown",
        "id": "5ce0312577c6960b",
        "text": "Konrad Hinsen — 03.06.2022\nInteresting idea, I have to try that. I'd have to create another package for the extensions then, as the generated classes are in my main package.\n\nKonrad Hinsen — 03.06.2022\n[[Visitors]] is what I do now, but I have three visitors for my AST and some code is duplicated in each of them. It would make more sense to have it attached to the AST nodes, given that all it does is preprocessing data in the nodes' elements.\n\n"
      },
      "date": 1654861265369
    },
    {
      "type": "add",
      "id": "f9edaebdc1ae4d22",
      "item": {
        "type": "markdown",
        "id": "f9edaebdc1ae4d22",
        "text": "esmiralha — 03.06.2022\nCan't you move the common code to a common visitor base class?\nKonrad Hinsen — 04.06.2022\nThey already inherit from something else. But I could make it a trait…\nesmiralha — 04.06.2022\n@lukego we have a \"parsing club\" down here. You are welcome to join. 😁\nlukego — 04.06.2022\nOh cool :-). So I want to write a mostly ad-hoc parser, the kind of thing that I'd normally do in awk, and my first thought is to reach for PetitParser2. But it looks like that is kind of abandoned, in that in the \"old\" GT it seemed like the main parser and had quite a bit of tooling (custom browser etc.) So now I'm wondering, do I need to read a book about SmaCC or something? 😄\nI see that PetitParser2 is still there in the image, and the code snippets will still work (and there are a few senders of asPParser as minor examples), but it looks hugely scaled back in terms of tooling and usage if I'm reading this right.\nesmiralha — 04.06.2022\nSmaCC starts with a EBNF grammar. There's a booklet in Smacc that you can download from the Pharo website.\nSeanDeNigris — 04.06.2022\nI guess the petit parser tools were never ported to bloc, but honestly it’s so straightforward that I usually just code it up in a playground. I wouldn’t say it’s unsupported, just that there hasn’t been much integration into new GT \ntudor girba — 04.06.2022\nPetitParser2 is not scaled back. It is quite well suited for ad-hoc parsing. It's just that we focused more on language support and for that we constructed a more elaborate infrastructure around SmaCC.\nCarcaj0u — 05.06.2022\n@lukego And the booklet link is http://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html\nCarcaj0u — 05.06.2022\nRight. So does the SmaCC recompilation affect everything in the \"my\" SmaCC package, or could these inheriting classes atay near to the generated ASTVisitor class?? \nKonrad Hinsen — 05.06.2022\nI wish I knew. SmaCC is a very powerful but also a mostly undocumented tool.\nesmiralha — 05.06.2022\nWhat kind of behavior you want to attach to the nodes?\nKonrad Hinsen — 05.06.2022\nBasic example: many of my nodes have an \"options\" field which holds a sequence of \"key=value\" items. I'd like to attach a method that returns these key-value pairs as a dictionary.\nesmiralha — 05.06.2022\nMaybe you can use the visitor to dynamically add the methods to the nodes? Is this even possible?\nKonrad Hinsen — 06.06.2022\nProbably yes, but it's probably also bad practice in the sense that it will cause maintenance headaches later on.\nWhat I was hoping for is a mechanism that is part of SmaCC. For example a method that is called at the end of AST class generation and that I could override to add modifications like this.\nThread\nExtending AST nodes\n3 Nachrichten ›\nIn diesem Thread gibt es keine aktuellen Nachrichten.\nesmiralha\n hat einen Thread begonnen: \nExtending AST nodes\n. Alle \nThreads\n anzeigen.\n — 06.06.2022\nKonrad Hinsen — 07.06.2022\nWhat's the best technique for debugging SmaCC parsers in GT? My problem is that SmaCCErrors provide no information about what went wrong. And I can't get anything clearer from the GT tools, but that's perhaps just my ignorance.\nExample: I have this token definition, and the simulator says that \"a\" is a valid token:\nBild\nThen I have a production rule that uses this token, but it looks like the parser considers the token wrong/inappropriate/whatever:\nBild\nAll I get is \"Error\". So what should I do next to figure out what's going wrong?\nesmiralha — 07.06.2022\nDoes the Transcript show anything?\nKonrad Hinsen — 07.06.2022\nNothing at all.\nesmiralha — 07.06.2022\nhave you set the root directive for the AST? \nalso, do you have a whitespace token?\nasking for the things where I have tripped when trying to parse a very simple language\nKonrad Hinsen — 07.06.2022\nYes, I have a root directive, and the AST classes are generated correctly. I also have the standard whitespace token. It's actually a medium-sized parser that works very well overall. It's just my last addition that doesn't work, for reasons that I don't understand at all.\nKonrad Hinsen — 07.06.2022\nI just did another test: extract the minimal subset of my parser that supports the rule I have problems with. And that minimal subset works just fine. So it's the presence of additional tokens and production rules that perturbs the two I am looking at.\nesmiralha — 07.06.2022\nmaybe there is overlap on the tokens?\nand the order of their definition is messing with the parsing?\ni could get an error like yours \nBild\nesmiralha — 07.06.2022\nsection 3.2 of the SmaCC booklet deals with token overlap\nKonrad Hinsen — 07.06.2022\nAhh.... thanks, that was very helpful. I have indeed another token definition that overlaps in many cases.\n\nThat brings me back to my original question: how could GT help me diagnose such a problem? It would be great, for example, if I could see the tokens coming out of the scanner. I would immediately have spotted that the token is not the one I expected.\nDamien — 07.06.2022\nsome tool could also analyze all tokens from a given scanner and tell you about the overlap\nesmiralha — 07.06.2022\nnote that overlapping is supported and that SmaCC will select the longest match\nKonrad Hinsen — 07.06.2022\nFine, but that doesn't remove the need for debugging tools. The scanner is pretty much inaccessible now (unless I am missing something). You only see the final output from the parser.\nesmiralha — 07.06.2022\n@Konrad Hinsen I found some stuff that may interest you in section 5.4 of the SmacCC booklet. It talks about AST directives that can change the node classes generation process.\nKonrad Hinsen — 08.06.2022\nI studied that section in detail a while ago. But all these mechanisms are very specific, for problems different from those I am dealing with. What I am looking for is a more general mechanism for modifying a parser's behavior, probably doable only at the Smalltalk level.\ntudor girba — 08.06.2022\nYep, the SmaCC debugging support can be improved. One thing you could try is to use the actual debugger:\nBild\nesmiralha — 08.06.2022\nThere is an attributes directive where you can create attributes in your nodes. I could conceive extending ng the idea to a methods directive that would attach custom methods to nodes, as well.\nThere is also a hierarchy directive that allows you to state that some node types will be subclasses of a specific class. Not sure if it helps with your specific  case .\nThe general case of transforming an AST tree can be handled by a custom visitor.  I would give it a shot and see if it is really too complicated.\nKonrad Hinsen — 08.06.2022\nThat looks promising! Parsing a Lepiter snippet never raises an exception that would open a debugger. I just see error nodes in the AST. So I guess I have to use the parser outside of Lepiter. Will try...\nKonrad Hinsen — 08.06.2022\nFound \"attributes\" in the manual: \"The %attributes directive allows you to add some extra instance variables to your classes. This enables you to later extend the generated classes to use those variables.\" That sounds very promising. But I have no idea how \"extending the generated classes\" could work. There is little point in adding instance variables to a Pharo class unless corresponding methods can be added as well. From the outside, those instance variables are only accessible through reflection.\nKonrad Hinsen — 08.06.2022\nI am doing this, it works well, but I am not happy with the code structure imposed by the visitor pattern, which I find hard to navigate.\ntudor girba — 08.06.2022\nYes, execute the parser explicitly from a Pharo snippet\nKonrad Hinsen — 08.06.2022\nGreat. Just what the doctor ordered 🙂\nKonrad Hinsen — heute um 08:19 Uhr\nThat's so useful that now I find myself introducing deliberate errors into my string to get a debugger which lets me inspect the scanner output.\ntudor girba — heute um 08:55 Uhr\n:))). We definitely need to bring (some) of that information in the inspector\n"
      },
      "after": "5ce0312577c6960b",
      "date": 1654861267734
    },
    {
      "type": "edit",
      "id": "5ce0312577c6960b",
      "item": {
        "type": "markdown",
        "id": "5ce0312577c6960b",
        "text": "Konrad Hinsen — 03.06.2022\nInteresting idea, I have to try that. I'd have to create another package for the extensions then, as the generated classes are in my main package.\n\n\n"
      },
      "date": 1654861270018
    },
    {
      "type": "add",
      "id": "4292d4ab7fe21b1d",
      "item": {
        "type": "markdown",
        "id": "4292d4ab7fe21b1d",
        "text": "Konrad Hinsen — 03.06.2022\n[[Visitors]] is what I do now, but I have three visitors for my [[AST]] and some code is duplicated in each of them. It would make more sense to have it attached to the AST nodes, given that all it does is preprocessing data in the nodes' elements.\n\n"
      },
      "after": "5ce0312577c6960b",
      "date": 1654861277009
    },
    {
      "type": "edit",
      "id": "f9edaebdc1ae4d22",
      "item": {
        "type": "markdown",
        "id": "f9edaebdc1ae4d22",
        "text": "esmiralha — 03.06.2022\nCan't you move the common code to a common visitor base class?\nKonrad Hinsen — 04.06.2022\nThey already inherit from something else. But I could make it a trait…\nesmiralha — 04.06.2022\n@lukego we have a \"parsing club\" down here. You are welcome to join. 😁\n\n"
      },
      "date": 1654861455524
    },
    {
      "type": "add",
      "id": "58327ff2cc96ee75",
      "item": {
        "type": "markdown",
        "id": "58327ff2cc96ee75",
        "text": "lukego — 04.06.2022\nOh cool :-). So I want to write a mostly ad-hoc parser, the kind of thing that I'd normally do in awk, and my first thought is to reach for [[PetitParser2]]. But it looks like that is kind of abandoned, in that in the \"old\" GT it seemed like the main parser and had quite a bit of tooling (custom browser etc.) So now I'm wondering, do I need to read a book about SmaCC or something? 😄\nI see that PetitParser2 is still there in the image, and the code snippets will still work (and there are a few senders of asPParser as minor examples), but it looks hugely scaled back in terms of tooling and usage if I'm reading this right.\nesmiralha — 04.06.2022\nSmaCC starts with a EBNF grammar. There's a booklet in Smacc that you can download from the Pharo website.\nSeanDeNigris — 04.06.2022\nI guess the petit parser tools were never ported to bloc, but honestly it’s so straightforward that I usually just code it up in a playground. I wouldn’t say it’s unsupported, just that there hasn’t been much integration into new GT \ntudor girba — 04.06.2022\nPetitParser2 is not scaled back. It is quite well suited for ad-hoc parsing. It's just that we focused more on language support and for that we constructed a more elaborate infrastructure around SmaCC.\nCarcaj0u — 05.06.2022\n@lukego And the booklet link is http://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html\nCarcaj0u — 05.06.2022\nRight. So does the SmaCC recompilation affect everything in the \"my\" SmaCC package, or could these inheriting classes atay near to the generated ASTVisitor class?? \nKonrad Hinsen — 05.06.2022\nI wish I knew. SmaCC is a very powerful but also a mostly undocumented tool.\nesmiralha — 05.06.2022\nWhat kind of behavior you want to attach to the nodes?\nKonrad Hinsen — 05.06.2022\nBasic example: many of my nodes have an \"options\" field which holds a sequence of \"key=value\" items. I'd like to attach a method that returns these key-value pairs as a dictionary.\nesmiralha — 05.06.2022\nMaybe you can use the visitor to dynamically add the methods to the nodes? Is this even possible?\nKonrad Hinsen — 06.06.2022\nProbably yes, but it's probably also bad practice in the sense that it will cause maintenance headaches later on.\nWhat I was hoping for is a mechanism that is part of SmaCC. For example a method that is called at the end of AST class generation and that I could override to add modifications like this.\nThread\nExtending AST nodes\n3 Nachrichten ›\nIn diesem Thread gibt es keine aktuellen Nachrichten.\nesmiralha\n hat einen Thread begonnen: \nExtending AST nodes\n. Alle \nThreads\n anzeigen.\n — 06.06.2022\nKonrad Hinsen — 07.06.2022\nWhat's the best technique for debugging SmaCC parsers in GT? My problem is that SmaCCErrors provide no information about what went wrong. And I can't get anything clearer from the GT tools, but that's perhaps just my ignorance.\nExample: I have this token definition, and the simulator says that \"a\" is a valid token:\nBild\nThen I have a production rule that uses this token, but it looks like the parser considers the token wrong/inappropriate/whatever:\nBild\nAll I get is \"Error\". So what should I do next to figure out what's going wrong?\nesmiralha — 07.06.2022\nDoes the Transcript show anything?\nKonrad Hinsen — 07.06.2022\nNothing at all.\nesmiralha — 07.06.2022\nhave you set the root directive for the AST? \nalso, do you have a whitespace token?\nasking for the things where I have tripped when trying to parse a very simple language\nKonrad Hinsen — 07.06.2022\nYes, I have a root directive, and the AST classes are generated correctly. I also have the standard whitespace token. It's actually a medium-sized parser that works very well overall. It's just my last addition that doesn't work, for reasons that I don't understand at all.\nKonrad Hinsen — 07.06.2022\nI just did another test: extract the minimal subset of my parser that supports the rule I have problems with. And that minimal subset works just fine. So it's the presence of additional tokens and production rules that perturbs the two I am looking at.\nesmiralha — 07.06.2022\nmaybe there is overlap on the tokens?\nand the order of their definition is messing with the parsing?\ni could get an error like yours \nBild\nesmiralha — 07.06.2022\nsection 3.2 of the SmaCC booklet deals with token overlap\nKonrad Hinsen — 07.06.2022\nAhh.... thanks, that was very helpful. I have indeed another token definition that overlaps in many cases.\n\nThat brings me back to my original question: how could GT help me diagnose such a problem? It would be great, for example, if I could see the tokens coming out of the scanner. I would immediately have spotted that the token is not the one I expected.\nDamien — 07.06.2022\nsome tool could also analyze all tokens from a given scanner and tell you about the overlap\nesmiralha — 07.06.2022\nnote that overlapping is supported and that SmaCC will select the longest match\nKonrad Hinsen — 07.06.2022\nFine, but that doesn't remove the need for debugging tools. The scanner is pretty much inaccessible now (unless I am missing something). You only see the final output from the parser.\nesmiralha — 07.06.2022\n@Konrad Hinsen I found some stuff that may interest you in section 5.4 of the SmacCC booklet. It talks about AST directives that can change the node classes generation process.\nKonrad Hinsen — 08.06.2022\nI studied that section in detail a while ago. But all these mechanisms are very specific, for problems different from those I am dealing with. What I am looking for is a more general mechanism for modifying a parser's behavior, probably doable only at the Smalltalk level.\ntudor girba — 08.06.2022\nYep, the SmaCC debugging support can be improved. One thing you could try is to use the actual debugger:\nBild\nesmiralha — 08.06.2022\nThere is an attributes directive where you can create attributes in your nodes. I could conceive extending ng the idea to a methods directive that would attach custom methods to nodes, as well.\nThere is also a hierarchy directive that allows you to state that some node types will be subclasses of a specific class. Not sure if it helps with your specific  case .\nThe general case of transforming an AST tree can be handled by a custom visitor.  I would give it a shot and see if it is really too complicated.\nKonrad Hinsen — 08.06.2022\nThat looks promising! Parsing a Lepiter snippet never raises an exception that would open a debugger. I just see error nodes in the AST. So I guess I have to use the parser outside of Lepiter. Will try...\nKonrad Hinsen — 08.06.2022\nFound \"attributes\" in the manual: \"The %attributes directive allows you to add some extra instance variables to your classes. This enables you to later extend the generated classes to use those variables.\" That sounds very promising. But I have no idea how \"extending the generated classes\" could work. There is little point in adding instance variables to a Pharo class unless corresponding methods can be added as well. From the outside, those instance variables are only accessible through reflection.\nKonrad Hinsen — 08.06.2022\nI am doing this, it works well, but I am not happy with the code structure imposed by the visitor pattern, which I find hard to navigate.\ntudor girba — 08.06.2022\nYes, execute the parser explicitly from a Pharo snippet\nKonrad Hinsen — 08.06.2022\nGreat. Just what the doctor ordered 🙂\nKonrad Hinsen — heute um 08:19 Uhr\nThat's so useful that now I find myself introducing deliberate errors into my string to get a debugger which lets me inspect the scanner output.\ntudor girba — heute um 08:55 Uhr\n:))). We definitely need to bring (some) of that information in the inspector\n"
      },
      "after": "f9edaebdc1ae4d22",
      "date": 1654861465107
    },
    {
      "type": "edit",
      "id": "58327ff2cc96ee75",
      "item": {
        "type": "markdown",
        "id": "58327ff2cc96ee75",
        "text": "lukego — 04.06.2022\nOh cool :-). So I want to write a mostly ad-hoc parser, the kind of thing that I'd normally do in awk, and my first thought is to reach for [[PetitParser2]]. But it looks like that is kind of abandoned, in that in the \"old\" GT it seemed like the main parser and had quite a bit of tooling (custom browser etc.) So now I'm wondering, do I need to read a book about SmaCC or something? 😄\nI see that PetitParser2 is still there in the image, and the code snippets will still work (and there are a few senders of asPParser as minor examples), but it looks hugely scaled back in terms of tooling and usage if I'm reading this right.\n\n"
      },
      "date": 1654861489560
    },
    {
      "type": "add",
      "id": "db486af44f39cec6",
      "item": {
        "type": "markdown",
        "id": "db486af44f39cec6",
        "text": "esmiralha — 04.06.2022\nSmaCC starts with a EBNF grammar. There's a booklet in Smacc that you can download from the Pharo website.\nSeanDeNigris — 04.06.2022\nI guess the petit parser tools were never ported to bloc, but honestly it’s so straightforward that I usually just code it up in a playground. I wouldn’t say it’s unsupported, just that there hasn’t been much integration into new GT \ntudor girba — 04.06.2022\nPetitParser2 is not scaled back. It is quite well suited for ad-hoc parsing. It's just that we focused more on language support and for that we constructed a more elaborate infrastructure around SmaCC.\nCarcaj0u — 05.06.2022\n@lukego And the booklet link is http://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html\nCarcaj0u — 05.06.2022\nRight. So does the SmaCC recompilation affect everything in the \"my\" SmaCC package, or could these inheriting classes atay near to the generated ASTVisitor class?? \nKonrad Hinsen — 05.06.2022\nI wish I knew. SmaCC is a very powerful but also a mostly undocumented tool.\nesmiralha — 05.06.2022\nWhat kind of behavior you want to attach to the nodes?\nKonrad Hinsen — 05.06.2022\nBasic example: many of my nodes have an \"options\" field which holds a sequence of \"key=value\" items. I'd like to attach a method that returns these key-value pairs as a dictionary.\nesmiralha — 05.06.2022\nMaybe you can use the visitor to dynamically add the methods to the nodes? Is this even possible?\nKonrad Hinsen — 06.06.2022\nProbably yes, but it's probably also bad practice in the sense that it will cause maintenance headaches later on.\nWhat I was hoping for is a mechanism that is part of SmaCC. For example a method that is called at the end of AST class generation and that I could override to add modifications like this.\nThread\nExtending AST nodes\n3 Nachrichten ›\nIn diesem Thread gibt es keine aktuellen Nachrichten.\nesmiralha\n hat einen Thread begonnen: \nExtending AST nodes\n. Alle \nThreads\n anzeigen.\n — 06.06.2022\nKonrad Hinsen — 07.06.2022\nWhat's the best technique for debugging SmaCC parsers in GT? My problem is that SmaCCErrors provide no information about what went wrong. And I can't get anything clearer from the GT tools, but that's perhaps just my ignorance.\nExample: I have this token definition, and the simulator says that \"a\" is a valid token:\nBild\nThen I have a production rule that uses this token, but it looks like the parser considers the token wrong/inappropriate/whatever:\nBild\nAll I get is \"Error\". So what should I do next to figure out what's going wrong?\nesmiralha — 07.06.2022\nDoes the Transcript show anything?\nKonrad Hinsen — 07.06.2022\nNothing at all.\nesmiralha — 07.06.2022\nhave you set the root directive for the AST? \nalso, do you have a whitespace token?\nasking for the things where I have tripped when trying to parse a very simple language\nKonrad Hinsen — 07.06.2022\nYes, I have a root directive, and the AST classes are generated correctly. I also have the standard whitespace token. It's actually a medium-sized parser that works very well overall. It's just my last addition that doesn't work, for reasons that I don't understand at all.\nKonrad Hinsen — 07.06.2022\nI just did another test: extract the minimal subset of my parser that supports the rule I have problems with. And that minimal subset works just fine. So it's the presence of additional tokens and production rules that perturbs the two I am looking at.\nesmiralha — 07.06.2022\nmaybe there is overlap on the tokens?\nand the order of their definition is messing with the parsing?\ni could get an error like yours \nBild\nesmiralha — 07.06.2022\nsection 3.2 of the SmaCC booklet deals with token overlap\nKonrad Hinsen — 07.06.2022\nAhh.... thanks, that was very helpful. I have indeed another token definition that overlaps in many cases.\n\nThat brings me back to my original question: how could GT help me diagnose such a problem? It would be great, for example, if I could see the tokens coming out of the scanner. I would immediately have spotted that the token is not the one I expected.\nDamien — 07.06.2022\nsome tool could also analyze all tokens from a given scanner and tell you about the overlap\nesmiralha — 07.06.2022\nnote that overlapping is supported and that SmaCC will select the longest match\nKonrad Hinsen — 07.06.2022\nFine, but that doesn't remove the need for debugging tools. The scanner is pretty much inaccessible now (unless I am missing something). You only see the final output from the parser.\nesmiralha — 07.06.2022\n@Konrad Hinsen I found some stuff that may interest you in section 5.4 of the SmacCC booklet. It talks about AST directives that can change the node classes generation process.\nKonrad Hinsen — 08.06.2022\nI studied that section in detail a while ago. But all these mechanisms are very specific, for problems different from those I am dealing with. What I am looking for is a more general mechanism for modifying a parser's behavior, probably doable only at the Smalltalk level.\ntudor girba — 08.06.2022\nYep, the SmaCC debugging support can be improved. One thing you could try is to use the actual debugger:\nBild\nesmiralha — 08.06.2022\nThere is an attributes directive where you can create attributes in your nodes. I could conceive extending ng the idea to a methods directive that would attach custom methods to nodes, as well.\nThere is also a hierarchy directive that allows you to state that some node types will be subclasses of a specific class. Not sure if it helps with your specific  case .\nThe general case of transforming an AST tree can be handled by a custom visitor.  I would give it a shot and see if it is really too complicated.\nKonrad Hinsen — 08.06.2022\nThat looks promising! Parsing a Lepiter snippet never raises an exception that would open a debugger. I just see error nodes in the AST. So I guess I have to use the parser outside of Lepiter. Will try...\nKonrad Hinsen — 08.06.2022\nFound \"attributes\" in the manual: \"The %attributes directive allows you to add some extra instance variables to your classes. This enables you to later extend the generated classes to use those variables.\" That sounds very promising. But I have no idea how \"extending the generated classes\" could work. There is little point in adding instance variables to a Pharo class unless corresponding methods can be added as well. From the outside, those instance variables are only accessible through reflection.\nKonrad Hinsen — 08.06.2022\nI am doing this, it works well, but I am not happy with the code structure imposed by the visitor pattern, which I find hard to navigate.\ntudor girba — 08.06.2022\nYes, execute the parser explicitly from a Pharo snippet\nKonrad Hinsen — 08.06.2022\nGreat. Just what the doctor ordered 🙂\nKonrad Hinsen — heute um 08:19 Uhr\nThat's so useful that now I find myself introducing deliberate errors into my string to get a debugger which lets me inspect the scanner output.\ntudor girba — heute um 08:55 Uhr\n:))). We definitely need to bring (some) of that information in the inspector\n"
      },
      "after": "58327ff2cc96ee75",
      "date": 1654861491664
    },
    {
      "type": "edit",
      "id": "58327ff2cc96ee75",
      "item": {
        "type": "markdown",
        "id": "58327ff2cc96ee75",
        "text": "lukego — 04.06.2022\nOh cool :-). So I want to write a mostly ad-hoc parser, the kind of thing that I'd normally do in awk, and my first thought is to reach for [[PetitParser2]]. But it looks like that is kind of abandoned, in that in the \"old\" GT it seemed like the main parser and had quite a bit of tooling (custom browser etc.) So now I'm wondering, do I need to read a book about [[SmaCC]] or something? 😄\nI see that PetitParser2 is still there in the image, and the code snippets will still work (and there are a few senders of asPParser as minor examples), but it looks hugely scaled back in terms of tooling and usage if I'm reading this right.\n\n"
      },
      "date": 1654861506582
    },
    {
      "type": "edit",
      "id": "db486af44f39cec6",
      "item": {
        "type": "markdown",
        "id": "db486af44f39cec6",
        "text": "esmiralha — 04.06.2022\nSmaCC starts with a [[EBNF]] grammar. There's a booklet in Smacc that you can download from the Pharo website.\nSeanDeNigris — 04.06.2022\nI guess the petit parser tools were never ported to bloc, but honestly it’s so straightforward that I usually just code it up in a playground. I wouldn’t say it’s unsupported, just that there hasn’t been much integration into new GT \ntudor girba — 04.06.2022\nPetitParser2 is not scaled back. It is quite well suited for ad-hoc parsing. It's just that we focused more on language support and for that we constructed a more elaborate infrastructure around SmaCC.\nCarcaj0u — 05.06.2022\n@lukego And the booklet link is http://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html\nCarcaj0u — 05.06.2022\nRight. So does the SmaCC recompilation affect everything in the \"my\" SmaCC package, or could these inheriting classes atay near to the generated ASTVisitor class?? \nKonrad Hinsen — 05.06.2022\nI wish I knew. SmaCC is a very powerful but also a mostly undocumented tool.\nesmiralha — 05.06.2022\nWhat kind of behavior you want to attach to the nodes?\nKonrad Hinsen — 05.06.2022\nBasic example: many of my nodes have an \"options\" field which holds a sequence of \"key=value\" items. I'd like to attach a method that returns these key-value pairs as a dictionary.\nesmiralha — 05.06.2022\nMaybe you can use the visitor to dynamically add the methods to the nodes? Is this even possible?\nKonrad Hinsen — 06.06.2022\nProbably yes, but it's probably also bad practice in the sense that it will cause maintenance headaches later on.\nWhat I was hoping for is a mechanism that is part of SmaCC. For example a method that is called at the end of AST class generation and that I could override to add modifications like this.\nThread\nExtending AST nodes\n3 Nachrichten ›\nIn diesem Thread gibt es keine aktuellen Nachrichten.\nesmiralha\n hat einen Thread begonnen: \nExtending AST nodes\n. Alle \nThreads\n anzeigen.\n — 06.06.2022\nKonrad Hinsen — 07.06.2022\nWhat's the best technique for debugging SmaCC parsers in GT? My problem is that SmaCCErrors provide no information about what went wrong. And I can't get anything clearer from the GT tools, but that's perhaps just my ignorance.\nExample: I have this token definition, and the simulator says that \"a\" is a valid token:\nBild\nThen I have a production rule that uses this token, but it looks like the parser considers the token wrong/inappropriate/whatever:\nBild\nAll I get is \"Error\". So what should I do next to figure out what's going wrong?\nesmiralha — 07.06.2022\nDoes the Transcript show anything?\nKonrad Hinsen — 07.06.2022\nNothing at all.\nesmiralha — 07.06.2022\nhave you set the root directive for the AST? \nalso, do you have a whitespace token?\nasking for the things where I have tripped when trying to parse a very simple language\nKonrad Hinsen — 07.06.2022\nYes, I have a root directive, and the AST classes are generated correctly. I also have the standard whitespace token. It's actually a medium-sized parser that works very well overall. It's just my last addition that doesn't work, for reasons that I don't understand at all.\nKonrad Hinsen — 07.06.2022\nI just did another test: extract the minimal subset of my parser that supports the rule I have problems with. And that minimal subset works just fine. So it's the presence of additional tokens and production rules that perturbs the two I am looking at.\nesmiralha — 07.06.2022\nmaybe there is overlap on the tokens?\nand the order of their definition is messing with the parsing?\ni could get an error like yours \nBild\nesmiralha — 07.06.2022\nsection 3.2 of the SmaCC booklet deals with token overlap\nKonrad Hinsen — 07.06.2022\nAhh.... thanks, that was very helpful. I have indeed another token definition that overlaps in many cases.\n\nThat brings me back to my original question: how could GT help me diagnose such a problem? It would be great, for example, if I could see the tokens coming out of the scanner. I would immediately have spotted that the token is not the one I expected.\nDamien — 07.06.2022\nsome tool could also analyze all tokens from a given scanner and tell you about the overlap\nesmiralha — 07.06.2022\nnote that overlapping is supported and that SmaCC will select the longest match\nKonrad Hinsen — 07.06.2022\nFine, but that doesn't remove the need for debugging tools. The scanner is pretty much inaccessible now (unless I am missing something). You only see the final output from the parser.\nesmiralha — 07.06.2022\n@Konrad Hinsen I found some stuff that may interest you in section 5.4 of the SmacCC booklet. It talks about AST directives that can change the node classes generation process.\nKonrad Hinsen — 08.06.2022\nI studied that section in detail a while ago. But all these mechanisms are very specific, for problems different from those I am dealing with. What I am looking for is a more general mechanism for modifying a parser's behavior, probably doable only at the Smalltalk level.\ntudor girba — 08.06.2022\nYep, the SmaCC debugging support can be improved. One thing you could try is to use the actual debugger:\nBild\nesmiralha — 08.06.2022\nThere is an attributes directive where you can create attributes in your nodes. I could conceive extending ng the idea to a methods directive that would attach custom methods to nodes, as well.\nThere is also a hierarchy directive that allows you to state that some node types will be subclasses of a specific class. Not sure if it helps with your specific  case .\nThe general case of transforming an AST tree can be handled by a custom visitor.  I would give it a shot and see if it is really too complicated.\nKonrad Hinsen — 08.06.2022\nThat looks promising! Parsing a Lepiter snippet never raises an exception that would open a debugger. I just see error nodes in the AST. So I guess I have to use the parser outside of Lepiter. Will try...\nKonrad Hinsen — 08.06.2022\nFound \"attributes\" in the manual: \"The %attributes directive allows you to add some extra instance variables to your classes. This enables you to later extend the generated classes to use those variables.\" That sounds very promising. But I have no idea how \"extending the generated classes\" could work. There is little point in adding instance variables to a Pharo class unless corresponding methods can be added as well. From the outside, those instance variables are only accessible through reflection.\nKonrad Hinsen — 08.06.2022\nI am doing this, it works well, but I am not happy with the code structure imposed by the visitor pattern, which I find hard to navigate.\ntudor girba — 08.06.2022\nYes, execute the parser explicitly from a Pharo snippet\nKonrad Hinsen — 08.06.2022\nGreat. Just what the doctor ordered 🙂\nKonrad Hinsen — heute um 08:19 Uhr\nThat's so useful that now I find myself introducing deliberate errors into my string to get a debugger which lets me inspect the scanner output.\ntudor girba — heute um 08:55 Uhr\n:))). We definitely need to bring (some) of that information in the inspector\n"
      },
      "date": 1654861518855
    },
    {
      "type": "edit",
      "id": "db486af44f39cec6",
      "item": {
        "type": "markdown",
        "id": "db486af44f39cec6",
        "text": "esmiralha — 04.06.2022\nSmaCC starts with a [[EBNF]] grammar. There's a booklet in Smacc that you can download from the Pharo website.\n\n"
      },
      "date": 1654861540813
    },
    {
      "type": "add",
      "id": "c19c4985ef8f5cb9",
      "item": {
        "type": "markdown",
        "id": "c19c4985ef8f5cb9",
        "text": "SeanDeNigris — 04.06.2022\nI guess the petit parser tools were never ported to bloc, but honestly it’s so straightforward that I usually just code it up in a playground. I wouldn’t say it’s unsupported, just that there hasn’t been much integration into new GT \n\n"
      },
      "after": "db486af44f39cec6",
      "date": 1654861543545
    },
    {
      "type": "add",
      "id": "0368997e1c86c95c",
      "item": {
        "type": "markdown",
        "id": "0368997e1c86c95c",
        "text": "tudor girba — 04.06.2022\nPetitParser2 is not scaled back. It is quite well suited for ad-hoc parsing. It's just that we focused more on language support and for that we constructed a more elaborate infrastructure around SmaCC.\nCarcaj0u — 05.06.2022\n\n"
      },
      "after": "c19c4985ef8f5cb9",
      "date": 1654861551146
    },
    {
      "type": "add",
      "id": "035dabeac634fb32",
      "item": {
        "type": "markdown",
        "id": "035dabeac634fb32",
        "text": "@lukego And the booklet link is http://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html\n\n"
      },
      "after": "0368997e1c86c95c",
      "date": 1654861572627
    },
    {
      "type": "add",
      "id": "37b610a9ed7d3a18",
      "item": {
        "type": "markdown",
        "id": "37b610a9ed7d3a18",
        "text": "Carcaj0u — 05.06.2022\nRight. So does the SmaCC recompilation affect everything in the \"my\" SmaCC package, or could these inheriting classes atay near to the generated ASTVisitor class?? \n\n"
      },
      "after": "035dabeac634fb32",
      "date": 1654861575529
    },
    {
      "type": "add",
      "id": "ee00772ebc99e821",
      "item": {
        "type": "markdown",
        "id": "ee00772ebc99e821",
        "text": "Konrad Hinsen — 05.06.2022\nI wish I knew. SmaCC is a very powerful but also a mostly undocumented tool.\n\n"
      },
      "after": "37b610a9ed7d3a18",
      "date": 1654861578882
    },
    {
      "type": "add",
      "id": "f8d3f12f23bcdfaa",
      "item": {
        "type": "markdown",
        "id": "f8d3f12f23bcdfaa",
        "text": "esmiralha — 05.06.2022\nWhat kind of behavior you want to attach to the nodes?\n\n"
      },
      "after": "ee00772ebc99e821",
      "date": 1654861581119
    },
    {
      "type": "add",
      "id": "2ef45c8fd8e1e426",
      "item": {
        "type": "markdown",
        "id": "2ef45c8fd8e1e426",
        "text": "Konrad Hinsen — 05.06.2022\nBasic example: many of my nodes have an \"options\" field which holds a sequence of \"key=value\" items. I'd like to attach a method that returns these key-value pairs as a dictionary.\n\n"
      },
      "after": "f8d3f12f23bcdfaa",
      "date": 1654861583803
    },
    {
      "type": "add",
      "id": "87e2788729ba73a1",
      "item": {
        "type": "markdown",
        "id": "87e2788729ba73a1",
        "text": "esmiralha — 05.06.2022\nMaybe you can use the visitor to dynamically add the methods to the nodes? Is this even possible?\n\n"
      },
      "after": "2ef45c8fd8e1e426",
      "date": 1654861588853
    },
    {
      "type": "add",
      "id": "c146b080c2ea38e3",
      "item": {
        "type": "markdown",
        "id": "c146b080c2ea38e3",
        "text": "Konrad Hinsen — 06.06.2022\nProbably yes, but it's probably also bad practice in the sense that it will cause maintenance headaches later on.\nWhat I was hoping for is a mechanism that is part of SmaCC. For example a method that is called at the end of AST class generation and that I could override to add modifications like this.\nThread\nExtending AST nodes\n3 Nachrichten ›\nIn diesem Thread gibt es keine aktuellen Nachrichten.\nesmiralha\n hat einen Thread begonnen: \nExtending AST nodes\n. Alle \nThreads\n anzeigen.\n — 06.06.2022\n\n"
      },
      "after": "87e2788729ba73a1",
      "date": 1654861597582
    },
    {
      "type": "add",
      "id": "727747c87c687d55",
      "item": {
        "type": "markdown",
        "id": "727747c87c687d55",
        "text": "Konrad Hinsen — 07.06.2022\nWhat's the best technique for debugging SmaCC parsers in GT? My problem is that SmaCCErrors provide no information about what went wrong. And I can't get anything clearer from the GT tools, but that's perhaps just my ignorance.\nExample: I have this token definition, and the simulator says that \"a\" is a valid token:\nBild\nThen I have a production rule that uses this token, but it looks like the parser considers the token wrong/inappropriate/whatever:\nBild\nAll I get is \"Error\". So what should I do next to figure out what's going wrong?\n\n"
      },
      "after": "c146b080c2ea38e3",
      "date": 1654861603503
    },
    {
      "type": "add",
      "id": "b52d5e23b196eff2",
      "item": {
        "type": "markdown",
        "id": "b52d5e23b196eff2",
        "text": "esmiralha — 07.06.2022\nDoes the Transcript show anything?\n\n"
      },
      "after": "727747c87c687d55",
      "date": 1654861607284
    },
    {
      "type": "add",
      "id": "c10f93713e64ecab",
      "item": {
        "type": "markdown",
        "id": "c10f93713e64ecab",
        "text": "Konrad Hinsen — 07.06.2022\nNothing at all.\n\n"
      },
      "after": "b52d5e23b196eff2",
      "date": 1654861608556
    },
    {
      "type": "add",
      "id": "0689dbd2e07a4ea2",
      "item": {
        "type": "markdown",
        "id": "0689dbd2e07a4ea2",
        "text": "esmiralha — 07.06.2022\nhave you set the root directive for the AST? \nalso, do you have a whitespace token?\nasking for the things where I have tripped when trying to parse a very simple language\n\n"
      },
      "after": "c10f93713e64ecab",
      "date": 1654861611734
    },
    {
      "type": "add",
      "id": "2333862791eb791e",
      "item": {
        "type": "markdown",
        "id": "2333862791eb791e",
        "text": "Konrad Hinsen — 07.06.2022\nYes, I have a root directive, and the AST classes are generated correctly. I also have the standard whitespace token. It's actually a medium-sized parser that works very well overall. It's just my last addition that doesn't work, for reasons that I don't understand at all.\n\n"
      },
      "after": "0689dbd2e07a4ea2",
      "date": 1654861614960
    },
    {
      "type": "add",
      "id": "3d597ab450486775",
      "item": {
        "type": "markdown",
        "id": "3d597ab450486775",
        "text": "Konrad Hinsen — 07.06.2022\nI just did another test: extract the minimal subset of my parser that supports the rule I have problems with. And that minimal subset works just fine. So it's the presence of additional tokens and production rules that perturbs the two I am looking at.\n\n"
      },
      "after": "2333862791eb791e",
      "date": 1654861618042
    },
    {
      "type": "add",
      "id": "7e75f1bf9eeef3a6",
      "item": {
        "type": "markdown",
        "id": "7e75f1bf9eeef3a6",
        "text": "esmiralha — 07.06.2022\nmaybe there is overlap on the tokens?\nand the order of their definition is messing with the parsing?\ni could get an error like yours \nBild\n\n"
      },
      "after": "3d597ab450486775",
      "date": 1654861621247
    },
    {
      "type": "add",
      "id": "7788494ce30e9c25",
      "item": {
        "type": "markdown",
        "id": "7788494ce30e9c25",
        "text": "esmiralha — 07.06.2022\nsection 3.2 of the SmaCC booklet deals with token overlap\n\n"
      },
      "after": "7e75f1bf9eeef3a6",
      "date": 1654861623758
    },
    {
      "type": "add",
      "id": "2b8cb79d6ae5b963",
      "item": {
        "type": "markdown",
        "id": "2b8cb79d6ae5b963",
        "text": "Konrad Hinsen — 07.06.2022\nAhh.... thanks, that was very helpful. I have indeed another token definition that overlaps in many cases.\n\nThat brings me back to my original question: how could GT help me diagnose such a problem? It would be great, for example, if I could see the tokens coming out of the scanner. I would immediately have spotted that the token is not the one I expected.\n\n"
      },
      "after": "7788494ce30e9c25",
      "date": 1654861639238
    },
    {
      "type": "add",
      "id": "2ef92c69ee9c8e10",
      "item": {
        "type": "markdown",
        "id": "2ef92c69ee9c8e10",
        "text": "Damien — 07.06.2022\nsome tool could also analyze all tokens from a given scanner and tell you about the overlap\n\n"
      },
      "after": "2b8cb79d6ae5b963",
      "date": 1654861645788
    },
    {
      "type": "add",
      "id": "625f696d6b02435a",
      "item": {
        "type": "markdown",
        "id": "625f696d6b02435a",
        "text": "esmiralha — 07.06.2022\nnote that overlapping is supported and that SmaCC will select the longest match\n\n"
      },
      "after": "2ef92c69ee9c8e10",
      "date": 1654861648035
    },
    {
      "type": "add",
      "id": "933184286dfa0711",
      "item": {
        "type": "markdown",
        "id": "933184286dfa0711",
        "text": "Konrad Hinsen — 07.06.2022\nFine, but that doesn't remove the need for debugging tools. The scanner is pretty much inaccessible now (unless I am missing something). You only see the final output from the parser.\n\n"
      },
      "after": "625f696d6b02435a",
      "date": 1654861651385
    },
    {
      "type": "add",
      "id": "565f96e913da84cd",
      "item": {
        "type": "markdown",
        "id": "565f96e913da84cd",
        "text": "esmiralha — 07.06.2022\n@Konrad Hinsen I found some stuff that may interest you in section 5.4 of the SmacCC booklet. It talks about AST directives that can change the node classes generation process.\n\n"
      },
      "after": "933184286dfa0711",
      "date": 1654861658212
    },
    {
      "type": "add",
      "id": "48938f83b9fd7898",
      "item": {
        "type": "markdown",
        "id": "48938f83b9fd7898",
        "text": "Konrad Hinsen — 08.06.2022\nI studied that section in detail a while ago. But all these mechanisms are very specific, for problems different from those I am dealing with. What I am looking for is a more general mechanism for modifying a parser's behavior, probably doable only at the Smalltalk level.\n\n"
      },
      "after": "565f96e913da84cd",
      "date": 1654861669260
    },
    {
      "type": "add",
      "id": "2b78b593e286742e",
      "item": {
        "type": "markdown",
        "id": "2b78b593e286742e",
        "text": "tudor girba — 08.06.2022\nYep, the SmaCC debugging support can be improved. One thing you could try is to use the actual debugger:\nBild\n\n"
      },
      "after": "48938f83b9fd7898",
      "date": 1654861677248
    },
    {
      "type": "add",
      "id": "64a710d273a95345",
      "item": {
        "type": "markdown",
        "id": "64a710d273a95345",
        "text": "esmiralha — 08.06.2022\nThere is an attributes directive where you can create attributes in your nodes. I could conceive extending ng the idea to a methods directive that would attach custom methods to nodes, as well.\nThere is also a hierarchy directive that allows you to state that some node types will be subclasses of a specific class. Not sure if it helps with your specific  case .\nThe general case of transforming an AST tree can be handled by a custom visitor.  I would give it a shot and see if it is really too complicated.\n\n"
      },
      "after": "2b78b593e286742e",
      "date": 1654861704610
    },
    {
      "type": "add",
      "id": "3172d1e443fbeecb",
      "item": {
        "type": "markdown",
        "id": "3172d1e443fbeecb",
        "text": "Konrad Hinsen — 08.06.2022\nThat looks promising! Parsing a Lepiter snippet never raises an exception that would open a debugger. I just see error nodes in the AST. So I guess I have to use the parser outside of Lepiter. Will try...\n\n"
      },
      "after": "64a710d273a95345",
      "date": 1654861714927
    },
    {
      "type": "add",
      "id": "c423d7af93a0245a",
      "item": {
        "type": "markdown",
        "id": "c423d7af93a0245a",
        "text": "Konrad Hinsen — 08.06.2022\nFound \"attributes\" in the manual: \"The %attributes directive allows you to add some extra instance variables to your classes. This enables you to later extend the generated classes to use those variables.\" That sounds very promising. But I have no idea how \"extending the generated classes\" could work. There is little point in adding instance variables to a Pharo class unless corresponding methods can be added as well. From the outside, those instance variables are only accessible through reflection.\n\n"
      },
      "after": "3172d1e443fbeecb",
      "date": 1654861740810
    },
    {
      "type": "add",
      "id": "7e920dc3592d3df0",
      "item": {
        "type": "markdown",
        "id": "7e920dc3592d3df0",
        "text": "Konrad Hinsen — 08.06.2022\nI am doing this, it works well, but I am not happy with the code structure imposed by the visitor pattern, which I find hard to navigate.\n\n"
      },
      "after": "c423d7af93a0245a",
      "date": 1654861751712
    },
    {
      "type": "add",
      "id": "1747120464cbd043",
      "item": {
        "type": "markdown",
        "id": "1747120464cbd043",
        "text": "tudor girba — 08.06.2022\nYes, execute the parser explicitly from a Pharo snippet\n\n"
      },
      "after": "7e920dc3592d3df0",
      "date": 1654861755460
    },
    {
      "type": "add",
      "id": "1d40aefc89fad4e0",
      "item": {
        "type": "markdown",
        "id": "1d40aefc89fad4e0",
        "text": "Konrad Hinsen — 08.06.2022\nGreat. Just what the doctor ordered 🙂\n\n"
      },
      "after": "1747120464cbd043",
      "date": 1654861759702
    },
    {
      "type": "add",
      "id": "151f8d8b48bcb4db",
      "item": {
        "type": "markdown",
        "id": "151f8d8b48bcb4db",
        "text": "Konrad Hinsen — heute um 08:19 Uhr\nThat's so useful that now I find myself introducing deliberate errors into my string to get a debugger which lets me inspect the scanner output.\n\n"
      },
      "after": "1d40aefc89fad4e0",
      "date": 1654861774839
    },
    {
      "type": "add",
      "id": "d40698e8de87f004",
      "item": {
        "type": "markdown",
        "id": "d40698e8de87f004",
        "text": "tudor girba — heute um 08:55 Uhr\n:))). We definitely need to bring (some) of that information in the inspector\n"
      },
      "after": "151f8d8b48bcb4db",
      "date": 1654861803981
    },
    {
      "item": {
        "type": "factory",
        "id": "1dcc0b011d8cf610"
      },
      "id": "1dcc0b011d8cf610",
      "type": "add",
      "after": "d40698e8de87f004",
      "date": 1654861811486
    },
    {
      "id": "1dcc0b011d8cf610",
      "type": "move",
      "order": [
        "5ce0312577c6960b",
        "4292d4ab7fe21b1d",
        "1dcc0b011d8cf610",
        "f9edaebdc1ae4d22",
        "58327ff2cc96ee75",
        "db486af44f39cec6",
        "c19c4985ef8f5cb9",
        "0368997e1c86c95c",
        "035dabeac634fb32",
        "37b610a9ed7d3a18",
        "ee00772ebc99e821",
        "f8d3f12f23bcdfaa",
        "2ef45c8fd8e1e426",
        "87e2788729ba73a1",
        "c146b080c2ea38e3",
        "727747c87c687d55",
        "b52d5e23b196eff2",
        "c10f93713e64ecab",
        "0689dbd2e07a4ea2",
        "2333862791eb791e",
        "3d597ab450486775",
        "7e75f1bf9eeef3a6",
        "7788494ce30e9c25",
        "2b8cb79d6ae5b963",
        "2ef92c69ee9c8e10",
        "625f696d6b02435a",
        "933184286dfa0711",
        "565f96e913da84cd",
        "48938f83b9fd7898",
        "2b78b593e286742e",
        "64a710d273a95345",
        "3172d1e443fbeecb",
        "c423d7af93a0245a",
        "7e920dc3592d3df0",
        "1747120464cbd043",
        "1d40aefc89fad4e0",
        "151f8d8b48bcb4db",
        "d40698e8de87f004"
      ],
      "date": 1654861822247
    },
    {
      "type": "edit",
      "id": "1dcc0b011d8cf610",
      "item": {
        "type": "graphviz",
        "id": "1dcc0b011d8cf610",
        "text": "DOT FROM lambda-browsing"
      },
      "date": 1654861831601
    },
    {
      "type": "edit",
      "id": "0368997e1c86c95c",
      "item": {
        "type": "markdown",
        "id": "0368997e1c86c95c",
        "text": "tudor girba — 04.06.2022\nPetitParser2 is not scaled back. It is quite well suited for ad-hoc parsing. It's just that we focused more on language support and for that we constructed a more elaborate infrastructure around SmaCC.\n\n"
      },
      "date": 1654862104633
    },
    {
      "type": "add",
      "id": "458b3796a11e3f88",
      "item": {
        "type": "markdown",
        "id": "458b3796a11e3f88",
        "text": "Carcaj0u — 05.06.2022\n\n"
      },
      "after": "0368997e1c86c95c",
      "date": 1654862106537
    },
    {
      "type": "remove",
      "id": "035dabeac634fb32",
      "date": 1654862107924
    },
    {
      "type": "edit",
      "id": "458b3796a11e3f88",
      "item": {
        "type": "markdown",
        "id": "458b3796a11e3f88",
        "text": "Carcaj0u — 05.06.2022\n@lukego And the booklet link is http://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccDirectives.html\n\n"
      },
      "date": 1654862111562
    },
    {
      "item": {
        "type": "reference",
        "id": "49469a89253466cf",
        "site": "wiki.ralfbarkow.ch",
        "slug": "smacc-a-compiler-compiler",
        "title": "SmaCC: A Compiler-Compiler",
        "text": "Booklet. [https://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccIntro.html#about%20this%20booklet page]"
      },
      "id": "49469a89253466cf",
      "type": "add",
      "after": "d40698e8de87f004",
      "date": 1654862408463
    },
    {
      "id": "49469a89253466cf",
      "type": "move",
      "order": [
        "5ce0312577c6960b",
        "4292d4ab7fe21b1d",
        "1dcc0b011d8cf610",
        "f9edaebdc1ae4d22",
        "58327ff2cc96ee75",
        "db486af44f39cec6",
        "c19c4985ef8f5cb9",
        "0368997e1c86c95c",
        "458b3796a11e3f88",
        "49469a89253466cf",
        "b6b525ac634977ad",
        "37b610a9ed7d3a18",
        "ee00772ebc99e821",
        "f8d3f12f23bcdfaa",
        "2ef45c8fd8e1e426",
        "87e2788729ba73a1",
        "c146b080c2ea38e3",
        "727747c87c687d55",
        "b52d5e23b196eff2",
        "c10f93713e64ecab",
        "0689dbd2e07a4ea2",
        "2333862791eb791e",
        "3d597ab450486775",
        "7e75f1bf9eeef3a6",
        "7788494ce30e9c25",
        "2b8cb79d6ae5b963",
        "2ef92c69ee9c8e10",
        "625f696d6b02435a",
        "933184286dfa0711",
        "565f96e913da84cd",
        "48938f83b9fd7898",
        "2b78b593e286742e",
        "64a710d273a95345",
        "3172d1e443fbeecb",
        "c423d7af93a0245a",
        "7e920dc3592d3df0",
        "1747120464cbd043",
        "1d40aefc89fad4e0",
        "151f8d8b48bcb4db",
        "d40698e8de87f004"
      ],
      "date": 1654862424340,
      "error": {
        "type": "error",
        "msg": "Internal Server Error",
        "response": "Server Ignoring move. Try reload."
      }
    },
    {
      "type": "edit",
      "id": "49469a89253466cf",
      "item": {
        "type": "reference",
        "id": "49469a89253466cf",
        "site": "wiki.ralfbarkow.ch",
        "slug": "smacc-a-compiler-compiler",
        "title": "SmaCC: A Compiler-Compiler",
        "text": "Booklet. [https://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccIntro.html#about%20this%20booklet page]"
      },
      "date": 1654862427191
    },
    {
      "type": "fork",
      "date": 1654862433419
    },
    {
      "type": "edit",
      "id": "87e2788729ba73a1",
      "item": {
        "type": "markdown",
        "id": "87e2788729ba73a1",
        "text": "esmiralha — 05.06.2022\nMaybe you can use the [[visitor]] to dynamically add the methods to the nodes? Is this even possible?\n\n"
      },
      "date": 1654862494709
    },
    {
      "type": "edit",
      "id": "0689dbd2e07a4ea2",
      "item": {
        "type": "markdown",
        "id": "0689dbd2e07a4ea2",
        "text": "esmiralha — 07.06.2022\nhave you set the [[root directive]] for the AST? \nalso, do you have a [[whitespace token]]?\nasking for the things where I have tripped when trying to parse a very simple language\n\n"
      },
      "date": 1654862609797
    },
    {
      "type": "edit",
      "id": "7788494ce30e9c25",
      "item": {
        "type": "markdown",
        "id": "7788494ce30e9c25",
        "text": "esmiralha — 07.06.2022\nsection 3.2 of the [[SmaCC booklet]] deals with token overlap\n\n"
      },
      "date": 1654862616627
    },
    {
      "type": "add",
      "id": "5bc749e7440236c8",
      "item": {
        "type": "markdown",
        "id": "5bc749e7440236c8",
        "text": "https://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccScanner.html#overlapping%20tokens"
      },
      "after": "7788494ce30e9c25",
      "date": 1654862783219
    },
    {
      "type": "edit",
      "id": "5bc749e7440236c8",
      "item": {
        "type": "markdown",
        "id": "5bc749e7440236c8",
        "text": "⇒ [[Overlapping Tokens]] [https://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccScanner.html#overlapping%20tokens booklet-Smacc]"
      },
      "date": 1654862827567
    },
    {
      "type": "edit",
      "id": "5bc749e7440236c8",
      "item": {
        "type": "markdown",
        "id": "5bc749e7440236c8",
        "text": "⇒ [[Overlapping Tokens]]. [https://books.pharo.org/booklet-Smacc/html/Chapters/Smacc/SmaccScanner.html#overlapping%20tokens booklet-Smacc]"
      },
      "date": 1654862833090
    },
    {
      "type": "edit",
      "id": "64a710d273a95345",
      "item": {
        "type": "markdown",
        "id": "64a710d273a95345",
        "text": "esmiralha — 08.06.2022\nThere is an attributes directive where you can create attributes in your nodes. I could conceive extending ng the idea to a methods directive that would attach custom methods to nodes, as well.\nThere is also a hierarchy directive that allows you to state that some node types will be subclasses of a specific class. Not sure if it helps with your specific  case .\nThe general case of transforming an AST tree can be handled by a [[custom visitor]].  I would give it a shot and see if it is really too complicated.\n\n"
      },
      "date": 1654862990881
    },
    {
      "type": "edit",
      "id": "7e920dc3592d3df0",
      "item": {
        "type": "markdown",
        "id": "7e920dc3592d3df0",
        "text": "Konrad Hinsen — 08.06.2022\nI am doing this, it works well, but I am not happy with the code structure imposed by the [[visitor pattern]], which I find hard to navigate.\n\n"
      },
      "date": 1654863041568
    },
    {
      "type": "edit",
      "id": "7e920dc3592d3df0",
      "item": {
        "type": "markdown",
        "id": "7e920dc3592d3df0",
        "text": "Konrad Hinsen — 08.06.2022\nI am doing this, it works well, but I am not happy with the code structure imposed by the [[Visitor Pattern]], which I find hard to navigate.\n\n"
      },
      "date": 1654863052773
    },
    {
      "item": {
        "type": "factory",
        "id": "94d386e9262b8fd8"
      },
      "id": "94d386e9262b8fd8",
      "type": "add",
      "after": "d40698e8de87f004",
      "date": 1654863210690
    },
    {
      "type": "edit",
      "id": "94d386e9262b8fd8",
      "item": {
        "type": "pagefold",
        "id": "94d386e9262b8fd8",
        "text": "~"
      },
      "date": 1654863213528
    },
    {
      "item": {
        "type": "factory",
        "id": "67935b18e7a1f8d2"
      },
      "id": "67935b18e7a1f8d2",
      "type": "add",
      "after": "94d386e9262b8fd8",
      "date": 1654863215476
    },
    {
      "type": "edit",
      "id": "67935b18e7a1f8d2",
      "item": {
        "type": "paragraph",
        "id": "67935b18e7a1f8d2",
        "text": "⇒ [[Parsing For Agile Modeling]]"
      },
      "date": 1654863235678
    },
    {
      "type": "edit",
      "id": "67935b18e7a1f8d2",
      "item": {
        "type": "paragraph",
        "id": "67935b18e7a1f8d2",
        "text": "⇒ [[Parsing For Agile Modeling]] ⇒ [[Exploratory Parsing]]"
      },
      "date": 1654863249209
    }
  ]
}