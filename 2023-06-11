{
  "title": "2023-06-11",
  "story": [
    {
      "type": "paragraph",
      "id": "3e91b90bf8a51ae9",
      "text": "⇒ [[Decode JSON in Elm]]: Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$168641056274563grJEF:matrix.org?via=matrix.org&via=matrix.allmende.io&via=tchncs.de matrix]\nJson is to be admired for its balance between flexibility and interoperability. Users of json can easily push it off balance by expecting elaborate interpretation of that which json passes on as atomic types. Item types are just strings to json, but to a page json reader they represent the impossible: code today a handler for a type that will be invented tomorrow. […]"
    },
    {
      "type": "image",
      "id": "55064ce27a8141bb",
      "text": "Notes on the topic",
      "size": "wide",
      "width": 430,
      "height": 309,
      "url": "/assets/plugins/image/c27dd8d1d038edbaef2f992f52c8d529.jpg"
    },
    {
      "type": "paragraph",
      "id": "5f690ff7dd944198",
      "text": "I am not (yet) concerned with full text search at the moment. The current red test case in the \"Add Factory\" scenario marks a [[Tempo Interruption]] and allows to ask what happened to the obvious solution. In an earlier version/iteration, I had provided a placeholder in the UI instead of the parsed JSON to hold the Bracket Structure display, the bracket or [[Container]] structure."
    },
    {
      "type": "paragraph",
      "id": "2cb39e724135d46b",
      "text": "Yesterday I discovered a paper [⇒ [[Filter before You Parse]]] that talks about a structure index as a precursor to parsing. See also [[Exploratory Parsing]]."
    },
    {
      "type": "markdown",
      "id": "672a20329b9a9d31",
      "text": "* find special characters such as brackets and colons to build a *structural index* over a raw JSON string, enabling efficient field projection without deserializing the record completely"
    },
    {
      "type": "paragraph",
      "id": "8160502aee06af7a",
      "text": "The following \"actors\" play together during decoding: Server with the /view/slug and slug.json routes, client with the 2 iframes view and JSON."
    },
    {
      "type": "paragraph",
      "id": "9ca597a7da04844d",
      "text": "The model is the page with title, story and journal. The journal is a log of updates. (Cf. [[Write-Ahead-Log]])"
    },
    {
      "type": "paragraph",
      "id": "d65392ac3edce347",
      "text": "The client-side story view should be identical to the rawData HTML of the /view/slug server route. The story should become reproducible through the recorded journal. Each log entry in the journal represents an update (event), a message whose view corresponds to the story at that moment. This reconstructed view should be identical to the rawData HTML Msg of the /view/slug revision."
    },
    {
      "type": "paragraph",
      "id": "f7c590abde8deec0",
      "text": "The HTML, the HTML Msg of the reconstructed iframeView should be bit-identical with the /view/slug rawData HTML."
    },
    {
      "type": "paragraph",
      "id": "488316cc240cce27",
      "text": "iframeView plus z-index: superimpose both views and watch out for diffs – void equivalent?"
    },
    {
      "type": "reference",
      "id": "f3b21cd5aeb176dc",
      "site": "wiki.ralfbarkow.ch",
      "slug": "the-principle-of-void-equivalence",
      "title": "The Principle of Void-Equivalence",
      "text": "Void-equivalent forms are syntactically irrelevant and semantically inert."
    },
    {
      "type": "paragraph",
      "id": "8b96957391540660",
      "text": "It seems like you're exploring different concepts and approaches related to parsing and structuring JSON data within your application. The paper you mentioned discusses the idea of building a structural index over a raw JSON string to enable efficient field projection without fully deserializing the entire record. This approach can be useful when you want to extract specific information from JSON without the need for complete parsing. (ChatGPT May 24 Version)"
    },
    {
      "type": "paragraph",
      "id": "ebb60def9661677e",
      "text": "In your case, you have different actors involved, including the server with its routes, the client-side view with iframes, and JSON data. The model represents the page with its title, story, and journal. The journal acts as a log of updates, capturing the sequence of changes made over time."
    },
    {
      "type": "paragraph",
      "id": "6f2281abec88edd6",
      "text": "Your goal is to reconstruct the story view on the client-side using the recorded journal. Each log entry in the journal represents an update event, and the corresponding message's view should reflect the state of the story at that particular moment. By replaying the journal, you aim to reproduce the same view as the rawData HTML of the /view/slug server route."
    },
    {
      "type": "paragraph",
      "id": "19cbc2d732b3ab3f",
      "text": "Your goal is to reconstruct the story view on the client-side using the recorded journal. Each log entry in the journal represents an update event, and the corresponding message's view should reflect the state of the story at that particular moment. By replaying the journal, you aim to reproduce the same view as the rawData HTML of the /view/slug server route."
    },
    {
      "type": "paragraph",
      "id": "5df507540a9d6319",
      "text": "To achieve this, you plan to compare the reconstructed HTML Msg of the iframe view with the /view/slug rawData HTML, superimposing both views and watching for any differences. The concept of \"void-equivalence\" you mentioned refers to forms that are syntactically irrelevant and semantically inert, meaning they have no impact on the final result. By comparing the two views, you can identify any differences that might indicate discrepancies or issues in the parsing and rendering process."
    },
    {
      "type": "paragraph",
      "id": "f74ac9e5be491947",
      "text": "By considering these approaches and conducting thorough comparisons between different representations of the story view, you can ensure consistency and accuracy in your application's rendering of JSON data. This iterative and meticulous approach can help you identify and address any discrepancies or errors that may arise during the parsing and rendering processes."
    },
    {
      "type": "paragraph",
      "id": "0407bf9602dbbbd8",
      "text": "[…]"
    },
    {
      "type": "paragraph",
      "id": "c625d1e1bc53e8aa",
      "text": "The error message suggests that the type of page.journal is List Journal, but Encode.list expects the second argument to be of type List Event. (ChatGPT May 24 Version)"
    },
    {
      "type": "paragraph",
      "id": "15374294ef42b351",
      "text": "To resolve this issue, you need to make sure that the journalEncoder function is able to encode a single Journal value into a JSON representation. Currently, it seems like journalEncoder expects an argument of type Journal, but you are passing a list of Journal values (page.journal) to it."
    },
    {
      "type": "paragraph",
      "id": "148aacd0dd8700d8",
      "text": "You might need to update your code to handle the list of Journal values appropriately. Depending on your requirements, you could either modify the journalEncoder to handle a list of Journal values or change how you encode the page.journal list."
    },
    {
      "type": "paragraph",
      "id": "4e14a4b9b6d581fe",
      "text": "Please review your journalEncoder implementation and the usage of Encode.list to ensure consistency in the types being passed."
    },
    {
      "type": "paragraph",
      "id": "50806991aacb498e",
      "text": "⇒ test(WikiSpec): GREEN Unknown journal event types are passed through … [https://github.com/RalfBarkow/vite-elm-dojo/commit/1ae5c832f62301e6dd2d022e25842405fd82236d commit]"
    },
    {
      "type": "image",
      "id": "1617c3c54963c514",
      "text": "Surprise: Future among snippets",
      "size": "wide",
      "width": 430,
      "height": 319,
      "url": "/assets/plugins/image/bdabcd5fcabb47f12ed96a118e8c5dc0.jpg"
    },
    {
      "type": "paragraph",
      "id": "9b63a94e6923196b",
      "text": "If an unrecognized event is encountered during decoding, it will be decoded as an Unknown event with the raw JSON representation stored in a Json.Decode.Value. You can then handle these unknown events separately in your application logic. (ChatGPT May 24 Version)"
    },
    {
      "type": "paragraph",
      "id": "d51ea56bb225fd2c",
      "text": "⇒ refactor(Main): add a div with model.output to the view. [https://github.com/RalfBarkow/vite-elm-dojo/commit/a25bc46cf4333771ebb510e20395f8038eb2cc87 commit]"
    },
    {
      "type": "markdown",
      "id": "c036264ec3fd0b9b",
      "text": "> Commit: a25bc46cf4333771ebb510e20395f8038eb2cc87 [a25bc46]\nParents: 1ae5c832f6\nAutor RalfBarkow <[…]>\nDatum: 11. Juni 2023 um 16:53:31 MESZ\nLabels: HEAD main"
    },
    {
      "type": "paragraph",
      "id": "7924ce4061abd553",
      "text": "And as for the \"Future among snippets\" surprise, what does it mean to call a reference a Future story type?"
    },
    {
      "type": "markdown",
      "id": "4e84dcb052109d9b",
      "text": "[https://wiki.ralfbarkow.ch/view/2023-06-11/view/2023-06-11_rev124 2023-06-11_rev124]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2023-06-11",
        "story": []
      },
      "date": 1686460843861
    },
    {
      "item": {
        "type": "factory",
        "id": "3e91b90bf8a51ae9"
      },
      "id": "3e91b90bf8a51ae9",
      "type": "add",
      "date": 1686460846179
    },
    {
      "type": "edit",
      "id": "3e91b90bf8a51ae9",
      "item": {
        "type": "paragraph",
        "id": "3e91b90bf8a51ae9",
        "text": "⇒ [[Decode JSON in Elm]]: Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$168636214571224yXOCC:matrix.org?via=matrix.org&via=matrix.allmende.io&via=tchncs.de matrix]"
      },
      "date": 1686460851272
    },
    {
      "type": "edit",
      "id": "3e91b90bf8a51ae9",
      "item": {
        "type": "paragraph",
        "id": "3e91b90bf8a51ae9",
        "text": "⇒ [[Decode JSON in Elm]]: Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$168641056274563grJEF:matrix.org?via=matrix.org&via=matrix.allmende.io&via=converser.eu matrix]"
      },
      "date": 1686460878168
    },
    {
      "item": {
        "type": "factory",
        "id": "55064ce27a8141bb"
      },
      "id": "55064ce27a8141bb",
      "type": "add",
      "after": "3e91b90bf8a51ae9",
      "date": 1686460919266
    },
    {
      "type": "edit",
      "id": "55064ce27a8141bb",
      "item": {
        "type": "image",
        "id": "55064ce27a8141bb",
        "text": "Notes on the topic",
        "size": "wide",
        "width": 430,
        "height": 309,
        "url": "/assets/plugins/image/c27dd8d1d038edbaef2f992f52c8d529.jpg"
      },
      "date": 1686461045215
    },
    {
      "id": "56c6a6fb2fca9151",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "56c6a6fb2fca9151",
        "text": "Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$168641056274563grJEF:matrix.org?via=matrix.org&via=matrix.allmende.io&via=tchncs.de matrix]\nJson is to be admired for its balance between flexibility and interoperability. Users of json can easily push it off balance by expecting elaborate interpretation of that which json passes on as atomic types. Item types are just strings to json, but to a page json reader they represent the impossible: code today a handler for a type that will be invented tomorrow."
      },
      "after": "3e91b90bf8a51ae9",
      "attribution": {
        "page": "2023-06-10"
      },
      "date": 1686461117347
    },
    {
      "type": "remove",
      "id": "56c6a6fb2fca9151",
      "date": 1686461122974
    },
    {
      "type": "edit",
      "id": "3e91b90bf8a51ae9",
      "item": {
        "type": "paragraph",
        "id": "3e91b90bf8a51ae9",
        "text": "⇒ [[Decode JSON in Elm]]: Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$168641056274563grJEF:matrix.org?via=matrix.org&via=matrix.allmende.io&via=tchncs.de matrix]\nJson is to be admired for its balance between flexibility and interoperability. Users of json can easily push it off balance by expecting elaborate interpretation of that which json passes on as atomic types. Item types are just strings to json, but to a page json reader they represent the impossible: code today a handler for a type that will be invented tomorrow."
      },
      "date": 1686461130953
    },
    {
      "type": "edit",
      "id": "3e91b90bf8a51ae9",
      "item": {
        "type": "paragraph",
        "id": "3e91b90bf8a51ae9",
        "text": "⇒ [[Decode JSON in Elm]]: Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$168641056274563grJEF:matrix.org?via=matrix.org&via=matrix.allmende.io&via=tchncs.de matrix]\nJson is to be admired for its balance between flexibility and interoperability. Users of json can easily push it off balance by expecting elaborate interpretation of that which json passes on as atomic types. Item types are just strings to json, but to a page json reader they represent the impossible: code today a handler for a type that will be invented tomorrow. […]"
      },
      "date": 1686461197413
    },
    {
      "item": {
        "type": "factory",
        "id": "5f690ff7dd944198"
      },
      "id": "5f690ff7dd944198",
      "type": "add",
      "after": "55064ce27a8141bb",
      "date": 1686461490178
    },
    {
      "type": "edit",
      "id": "5f690ff7dd944198",
      "item": {
        "type": "paragraph",
        "id": "5f690ff7dd944198",
        "text": "I am not (yet) concerned with the full text search at the moment."
      },
      "date": 1686461493466
    },
    {
      "type": "edit",
      "id": "5f690ff7dd944198",
      "item": {
        "type": "paragraph",
        "id": "5f690ff7dd944198",
        "text": "I am not (yet) concerned with the full text search at the moment. The current red test case in the \"Add Factory\" scenario marks a tempo interruption and allows to ask what happened to the obvious solution."
      },
      "date": 1686461613591
    },
    {
      "type": "edit",
      "id": "5f690ff7dd944198",
      "item": {
        "type": "paragraph",
        "id": "5f690ff7dd944198",
        "text": "I am not (yet) concerned with the full text search at the moment. The current red test case in the \"Add Factory\" scenario marks a tempo interruption and allows to ask: What happened to the obvious solution?"
      },
      "date": 1686461639264
    },
    {
      "type": "edit",
      "id": "5f690ff7dd944198",
      "item": {
        "type": "paragraph",
        "id": "5f690ff7dd944198",
        "text": "I am not (yet) concerned with full text search at the moment. The current red test case in the \"Add Factory\" scenario marks a tempo interruption and allows to ask what happened to the obvious solution. In an earlier version/iteration, I had provided a placeholder in the UI instead of the parsed JSON to hold the Bracket Structure display, the bracket or container structure."
      },
      "date": 1686461771922
    },
    {
      "type": "add",
      "id": "2cb39e724135d46b",
      "item": {
        "type": "paragraph",
        "id": "2cb39e724135d46b",
        "text": "Yesterday I discovered a paper that talks about a structure index as a precursor to parsing."
      },
      "after": "5f690ff7dd944198",
      "date": 1686461903441
    },
    {
      "type": "add",
      "id": "9c902ad3f6d64775",
      "item": {
        "type": "paragraph",
        "id": "9c902ad3f6d64775",
        "text": "\nPALKAR, Shoumik, ABUZAID, Firas, BAILIS, Peter and ZAHARIA, Matei, 2018. Filter before you parse: faster analytics on raw data with sparser. Proceedings of the VLDB Endowment. 1 July 2018. Vol. 11, no. 11, p. 1576–1589. DOI 10.14778/3236187.3236207. Exploratory big data applications often run on raw unstructured or semi-structured data formats, such as JSON files or text logs. These applications can spend 80--90% of their execution time parsing the data. In this paper, we propose a new approach for reducing this overhead: apply filters on the data’s raw bytestream before parsing. This technique, which we call raw filtering, leverages the features of modern hardware and the high selectivity of queries found in many exploratory applications. With raw filtering, a user-specified query predicate is compiled into a set of filtering primitives called raw filters (RFs). RFs are fast, SIMD-based operators that occasionally yield false positives, but never false negatives. We combine multiple RFs into an RF cascade to decrease the false positive rate and maximize parsing throughput. Because the best RF cascade is data-dependent, we propose an optimizer that dynamically selects the combination of RFs with the best expected throughput, achieving within 10% of the global optimum cascade while adding less than 1.2% overhead. We implement these techniques in a system called Sparser, which automatically manages a parsing cascade given a data stream in a supported format (e.g., JSON, Avro, Parquet) and a user query. We show that many real-world applications are highly selective and benefit from Sparser. Across diverse workloads, Sparser accelerates state-of-the-art parsers such as Mison by up to 22 × and improves end-to-end application performance by up to 9 ×.\n"
      },
      "after": "2cb39e724135d46b",
      "date": 1686461919372
    },
    {
      "type": "edit",
      "id": "2cb39e724135d46b",
      "item": {
        "type": "paragraph",
        "id": "2cb39e724135d46b",
        "text": "Yesterday I discovered a paper that talks about a structure index as a precursor to parsing. See also [[Exploratory Parsing]]."
      },
      "date": 1686461952532
    },
    {
      "item": {
        "type": "factory",
        "id": "192cb963d11cc576"
      },
      "id": "192cb963d11cc576",
      "type": "add",
      "after": "9c902ad3f6d64775",
      "date": 1686462747885
    },
    {
      "type": "edit",
      "id": "192cb963d11cc576",
      "item": {
        "type": "paragraph",
        "id": "192cb963d11cc576",
        "text": "state-machine-based"
      },
      "date": 1686462756063
    },
    {
      "type": "edit",
      "id": "9c902ad3f6d64775",
      "item": {
        "type": "paragraph",
        "id": "9c902ad3f6d64775",
        "text": "PALKAR, Shoumik, ABUZAID, Firas, BAILIS, Peter and ZAHARIA, Matei, 2018. Filter before you parse: faster analytics on raw data with sparser. Proceedings of the VLDB Endowment. 1 July 2018. Vol. 11, no. 11, p. 1576–1589. DOI 10.14778/3236187.3236207. Exploratory big data applications often run on raw unstructured or semi-structured data formats, such as JSON files or text logs. These applications can spend 80--90% of their execution time parsing the data. In this paper, we propose a new approach for reducing this overhead: apply filters on the data’s raw bytestream before parsing. This technique, which we call raw filtering, leverages the features of modern hardware and the high selectivity of queries found in many exploratory applications. With raw filtering, a user-specified query predicate is compiled into a set of filtering primitives called raw filters (RFs). RFs are fast, SIMD-based operators that occasionally yield false positives, but never false negatives. We combine multiple RFs into an RF cascade to decrease the false positive rate and maximize parsing throughput. Because the best RF cascade is data-dependent, we propose an optimizer that dynamically selects the combination of RFs with the best expected throughput, achieving within 10% of the global optimum cascade while adding less than 1.2% overhead. We implement these techniques in a system called Sparser, which automatically manages a parsing cascade given a data stream in a supported format (e.g., JSON, Avro, Parquet) and a user query. We show that many real-world applications are highly selective and benefit from Sparser. Across diverse workloads, Sparser accelerates state-of-the-art parsers such as Mison by up to 22 × and improves end-to-end application performance by up to 9 ×.\n"
      },
      "date": 1686462765728
    },
    {
      "type": "edit",
      "id": "2cb39e724135d46b",
      "item": {
        "type": "paragraph",
        "id": "2cb39e724135d46b",
        "text": "Yesterday I discovered a paper [⇒ [[Filter before You Parse]]] that talks about a structure index as a precursor to parsing. See also [[Exploratory Parsing]]."
      },
      "date": 1686462865855
    },
    {
      "id": "9c902ad3f6d64775",
      "type": "remove",
      "removedTo": {
        "page": "Filter before You Parse"
      },
      "date": 1686462878883
    },
    {
      "id": "192cb963d11cc576",
      "type": "remove",
      "removedTo": {
        "page": "Filter before You Parse"
      },
      "date": 1686463188822
    },
    {
      "id": "672a20329b9a9d31",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "672a20329b9a9d31",
        "text": "* find special characters such as brackets and colons to build a *structural index* over a raw JSON string, enabling efficient field projection without deserializing the record completely"
      },
      "after": "2cb39e724135d46b",
      "attribution": {
        "page": "Filter before You Parse"
      },
      "date": 1686465614524
    },
    {
      "type": "edit",
      "id": "672a20329b9a9d31",
      "item": {
        "type": "markdown",
        "id": "672a20329b9a9d31",
        "text": "* find special characters such as brackets and colons to build a *structural index* over a raw JSON string, enabling efficient field projection without deserializing the record completely"
      },
      "date": 1686465620267
    },
    {
      "type": "edit",
      "id": "672a20329b9a9d31",
      "item": {
        "type": "markdown",
        "id": "672a20329b9a9d31",
        "text": "* find special characters such as brackets and colons to build a *structural index* over a raw JSON string, enabling efficient field projection without deserializing the record completely"
      },
      "date": 1686465628839
    },
    {
      "item": {
        "type": "paragraph",
        "id": "c20ddf78a55455b7",
        "text": ""
      },
      "id": "c20ddf78a55455b7",
      "type": "add",
      "after": "672a20329b9a9d31",
      "date": 1686465668257
    },
    {
      "type": "remove",
      "id": "c20ddf78a55455b7",
      "date": 1686465671087
    },
    {
      "item": {
        "type": "paragraph",
        "id": "8160502aee06af7a",
        "text": "The following \"actors\" play together during decoding: Server with the /view/slug and slug.json routes, client with the 2 iframes view and JSON."
      },
      "id": "8160502aee06af7a",
      "type": "add",
      "after": "672a20329b9a9d31",
      "date": 1686465678880
    },
    {
      "type": "edit",
      "id": "8160502aee06af7a",
      "item": {
        "type": "paragraph",
        "id": "8160502aee06af7a",
        "text": "The following \"actors\" play together during decoding: Server with the /view/slug and slug.json routes, client with the 2 iframes view and JSON."
      },
      "date": 1686465769671
    },
    {
      "type": "edit",
      "id": "8160502aee06af7a",
      "item": {
        "type": "paragraph",
        "id": "8160502aee06af7a",
        "text": "The following \"actors\" play together during decoding: Server with the /view/slug and slug.json routes, client with the 2 iframes view and JSON."
      },
      "date": 1686465784994
    },
    {
      "type": "edit",
      "id": "8160502aee06af7a",
      "item": {
        "type": "paragraph",
        "id": "8160502aee06af7a",
        "text": "The following \"actors\" play together during decoding: Server with the /view/slug and slug.json routes, client with the 2 iframes view and JSON."
      },
      "date": 1686465808089
    },
    {
      "type": "add",
      "id": "9ca597a7da04844d",
      "item": {
        "type": "paragraph",
        "id": "9ca597a7da04844d",
        "text": "The model is the page with title, story and journal. The journal is a log of updates. (Cf. [[Write-Ahead-Log]])"
      },
      "after": "8160502aee06af7a",
      "date": 1686465850130
    },
    {
      "type": "edit",
      "id": "9ca597a7da04844d",
      "item": {
        "type": "paragraph",
        "id": "9ca597a7da04844d",
        "text": "The model is the page with title, story and journal. The journal is a log of updates. (Cf. [[Write-Ahead-Log]])"
      },
      "date": 1686465864087
    },
    {
      "type": "edit",
      "id": "9ca597a7da04844d",
      "item": {
        "type": "paragraph",
        "id": "9ca597a7da04844d",
        "text": "The model is the page with title, story and journal. The journal is a log of updates. (Cf. [[Write-Ahead-Log]])"
      },
      "date": 1686465927361
    },
    {
      "type": "edit",
      "id": "9ca597a7da04844d",
      "item": {
        "type": "paragraph",
        "id": "9ca597a7da04844d",
        "text": "The model is the page with title, story and journal. The journal is a log of updates. (Cf. [[Write-Ahead-Log]])"
      },
      "date": 1686465963617
    },
    {
      "type": "add",
      "id": "8cc855bf1268df43",
      "item": {
        "type": "paragraph",
        "id": "8cc855bf1268df43",
        "text": ""
      },
      "after": "9ca597a7da04844d",
      "date": 1686466017241
    },
    {
      "type": "edit",
      "id": "8cc855bf1268df43",
      "item": {
        "type": "paragraph",
        "id": "8cc855bf1268df43",
        "text": ""
      },
      "date": 1686466034219
    },
    {
      "type": "edit",
      "id": "8cc855bf1268df43",
      "item": {
        "type": "paragraph",
        "id": "8cc855bf1268df43",
        "text": ""
      },
      "date": 1686466065192
    },
    {
      "type": "edit",
      "id": "5f690ff7dd944198",
      "item": {
        "type": "paragraph",
        "id": "5f690ff7dd944198",
        "text": "I am not (yet) concerned with full text search at the moment. The current red test case in the \"Add Factory\" scenario marks a [[Tempo Interruption]] and allows to ask what happened to the obvious solution. In an earlier version/iteration, I had provided a placeholder in the UI instead of the parsed JSON to hold the Bracket Structure display, the bracket or [[Container]] structure."
      },
      "date": 1686466094162
    },
    {
      "type": "edit",
      "id": "5f690ff7dd944198",
      "item": {
        "type": "paragraph",
        "id": "5f690ff7dd944198",
        "text": "I am not (yet) concerned with full text search at the moment. The current red test case in the \"Add Factory\" scenario marks a [[Tempo Interruption]] and allows to ask what happened to the obvious solution. In an earlier version/iteration, I had provided a placeholder in the UI instead of the parsed JSON to hold the Bracket Structure display, the bracket or [[Container]] structure."
      },
      "date": 1686466103057
    },
    {
      "type": "edit",
      "id": "8cc855bf1268df43",
      "item": {
        "type": "paragraph",
        "id": "8cc855bf1268df43",
        "text": ""
      },
      "date": 1686470203342
    },
    {
      "item": {
        "type": "paragraph",
        "id": "d65392ac3edce347",
        "text": "The client-side story view should be identical to the rawData HTML of the /view/slug server route. The story should become reproducible through the recorded journal. Each log entry in the journal represents an update (event), a message whose view corresponds to the story at that moment. This reconstructed view should be identical to the rawData HTML Msg of the /view/slug revision."
      },
      "id": "d65392ac3edce347",
      "type": "add",
      "after": "8cc855bf1268df43",
      "date": 1686470284324
    },
    {
      "type": "edit",
      "id": "d65392ac3edce347",
      "item": {
        "type": "paragraph",
        "id": "d65392ac3edce347",
        "text": "The client-side story view should be identical to the rawData HTML of the /view/slug server route. The story should become reproducible through the recorded journal. Each log entry in the journal represents an update (event), a message whose view corresponds to the story at that moment. This reconstructed view should be identical to the rawData HTML Msg of the /view/slug revision."
      },
      "date": 1686470303437
    },
    {
      "item": {
        "type": "paragraph",
        "id": "73ea51081e02fa11",
        "text": ""
      },
      "id": "73ea51081e02fa11",
      "type": "add",
      "after": "d65392ac3edce347",
      "date": 1686470466315
    },
    {
      "type": "edit",
      "id": "73ea51081e02fa11",
      "item": {
        "type": "paragraph",
        "id": "73ea51081e02fa11",
        "text": ""
      },
      "date": 1686470473809
    },
    {
      "type": "edit",
      "id": "73ea51081e02fa11",
      "item": {
        "type": "paragraph",
        "id": "73ea51081e02fa11",
        "text": ""
      },
      "date": 1686470561022
    },
    {
      "type": "remove",
      "id": "73ea51081e02fa11",
      "date": 1686470583029
    },
    {
      "type": "edit",
      "id": "d65392ac3edce347",
      "item": {
        "type": "paragraph",
        "id": "d65392ac3edce347",
        "text": "The client-side story view should be identical to the rawData HTML of the /view/slug server route. The story should become reproducible through the recorded journal. Each log entry in the journal represents an update (event), a message whose view corresponds to the story at that moment. This reconstructed view should be identical to the rawData HTML Msg of the /view/slug revision."
      },
      "date": 1686470584090
    },
    {
      "item": {
        "type": "paragraph",
        "id": "f7c590abde8deec0",
        "text": "The HTML, the HTML Msg of the reconstructed iframeView should be bit-identical with the /view/slug rawData HTML."
      },
      "id": "f7c590abde8deec0",
      "type": "add",
      "after": "d65392ac3edce347",
      "date": 1686470683492
    },
    {
      "type": "edit",
      "id": "f7c590abde8deec0",
      "item": {
        "type": "paragraph",
        "id": "f7c590abde8deec0",
        "text": "The HTML, the HTML Msg of the reconstructed iframeView should be bit-identical with the /view/slug rawData HTML."
      },
      "date": 1686470685243
    },
    {
      "type": "remove",
      "id": "8cc855bf1268df43",
      "date": 1686470700170
    },
    {
      "item": {
        "type": "paragraph",
        "id": "488316cc240cce27",
        "text": "iframeView plus z-index: superimpose both views and watch out for diffs – void equivalent?"
      },
      "id": "488316cc240cce27",
      "type": "add",
      "after": "f7c590abde8deec0",
      "date": 1686470824377
    },
    {
      "type": "edit",
      "id": "488316cc240cce27",
      "item": {
        "type": "paragraph",
        "id": "488316cc240cce27",
        "text": "iframeView plus z-index: superimpose both views and watch out for diffs – void equivalent?"
      },
      "date": 1686470826126
    },
    {
      "item": {
        "type": "reference",
        "id": "f3b21cd5aeb176dc",
        "site": "wiki.ralfbarkow.ch",
        "slug": "the-principle-of-void-equivalence",
        "title": "The Principle of Void-Equivalence",
        "text": "Void-equivalent forms are syntactically irrelevant and semantically inert."
      },
      "id": "f3b21cd5aeb176dc",
      "type": "add",
      "after": "488316cc240cce27",
      "date": 1686470842334
    },
    {
      "type": "edit",
      "id": "f3b21cd5aeb176dc",
      "item": {
        "type": "reference",
        "id": "f3b21cd5aeb176dc",
        "site": "wiki.ralfbarkow.ch",
        "slug": "the-principle-of-void-equivalence",
        "title": "The Principle of Void-Equivalence",
        "text": "Void-equivalent forms are syntactically irrelevant and semantically inert."
      },
      "date": 1686470844467
    },
    {
      "type": "edit",
      "id": "488316cc240cce27",
      "item": {
        "type": "paragraph",
        "id": "488316cc240cce27",
        "text": "iframeView plus z-index: superimpose both views and watch out for diffs – void equivalent?"
      },
      "date": 1686470870343
    },
    {
      "type": "edit",
      "id": "5f690ff7dd944198",
      "item": {
        "type": "paragraph",
        "id": "5f690ff7dd944198",
        "text": "I am not (yet) concerned with full text search at the moment. The current red test case in the \"Add Factory\" scenario marks a [[Tempo Interruption]] and allows to ask what happened to the obvious solution. In an earlier version/iteration, I had provided a placeholder in the UI instead of the parsed JSON to hold the Bracket Structure display, the bracket or [[Container]] structure."
      },
      "date": 1686471295936
    },
    {
      "item": {
        "type": "paragraph",
        "id": "8b96957391540660",
        "text": "It seems like you're exploring different concepts and approaches related to parsing and structuring JSON data within your application. The paper you mentioned discusses the idea of building a structural index over a raw JSON string to enable efficient field projection without fully deserializing the entire record. This approach can be useful when you want to extract specific information from JSON without the need for complete parsing. (ChatGPT May 24 Version)"
      },
      "id": "8b96957391540660",
      "type": "add",
      "after": "f3b21cd5aeb176dc",
      "date": 1686471485317
    },
    {
      "type": "edit",
      "id": "8b96957391540660",
      "item": {
        "type": "paragraph",
        "id": "8b96957391540660",
        "text": "It seems like you're exploring different concepts and approaches related to parsing and structuring JSON data within your application. The paper you mentioned discusses the idea of building a structural index over a raw JSON string to enable efficient field projection without fully deserializing the entire record. This approach can be useful when you want to extract specific information from JSON without the need for complete parsing. (ChatGPT May 24 Version)"
      },
      "date": 1686471489250
    },
    {
      "type": "edit",
      "id": "8b96957391540660",
      "item": {
        "type": "paragraph",
        "id": "8b96957391540660",
        "text": "It seems like you're exploring different concepts and approaches related to parsing and structuring JSON data within your application. The paper you mentioned discusses the idea of building a structural index over a raw JSON string to enable efficient field projection without fully deserializing the entire record. This approach can be useful when you want to extract specific information from JSON without the need for complete parsing. (ChatGPT May 24 Version)"
      },
      "date": 1686471502182
    },
    {
      "type": "edit",
      "id": "8b96957391540660",
      "item": {
        "type": "paragraph",
        "id": "8b96957391540660",
        "text": "It seems like you're exploring different concepts and approaches related to parsing and structuring JSON data within your application. The paper you mentioned discusses the idea of building a structural index over a raw JSON string to enable efficient field projection without fully deserializing the entire record. This approach can be useful when you want to extract specific information from JSON without the need for complete parsing. (ChatGPT May 24 Version)"
      },
      "date": 1686471550439
    },
    {
      "type": "add",
      "id": "ebb60def9661677e",
      "item": {
        "type": "paragraph",
        "id": "ebb60def9661677e",
        "text": "In your case, you have different actors involved, including the server with its routes, the client-side view with iframes, and JSON data. The model represents the page with its title, story, and journal. The journal acts as a log of updates, capturing the sequence of changes made over time."
      },
      "after": "8b96957391540660",
      "date": 1686471561699
    },
    {
      "type": "add",
      "id": "6f2281abec88edd6",
      "item": {
        "type": "paragraph",
        "id": "6f2281abec88edd6",
        "text": "Your goal is to reconstruct the story view on the client-side using the recorded journal. Each log entry in the journal represents an update event, and the corresponding message's view should reflect the state of the story at that particular moment. By replaying the journal, you aim to reproduce the same view as the rawData HTML of the /view/slug server route."
      },
      "after": "ebb60def9661677e",
      "date": 1686471570446
    },
    {
      "type": "add",
      "id": "19cbc2d732b3ab3f",
      "item": {
        "type": "paragraph",
        "id": "19cbc2d732b3ab3f",
        "text": "Your goal is to reconstruct the story view on the client-side using the recorded journal. Each log entry in the journal represents an update event, and the corresponding message's view should reflect the state of the story at that particular moment. By replaying the journal, you aim to reproduce the same view as the rawData HTML of the /view/slug server route."
      },
      "after": "6f2281abec88edd6",
      "date": 1686471594196
    },
    {
      "type": "add",
      "id": "5df507540a9d6319",
      "item": {
        "type": "paragraph",
        "id": "5df507540a9d6319",
        "text": "To achieve this, you plan to compare the reconstructed HTML Msg of the iframe view with the /view/slug rawData HTML, superimposing both views and watching for any differences. The concept of \"void-equivalence\" you mentioned refers to forms that are syntactically irrelevant and semantically inert, meaning they have no impact on the final result. By comparing the two views, you can identify any differences that might indicate discrepancies or issues in the parsing and rendering process."
      },
      "after": "19cbc2d732b3ab3f",
      "date": 1686471622017
    },
    {
      "type": "add",
      "id": "f74ac9e5be491947",
      "item": {
        "type": "paragraph",
        "id": "f74ac9e5be491947",
        "text": "By considering these approaches and conducting thorough comparisons between different representations of the story view, you can ensure consistency and accuracy in your application's rendering of JSON data. This iterative and meticulous approach can help you identify and address any discrepancies or errors that may arise during the parsing and rendering processes."
      },
      "after": "5df507540a9d6319",
      "date": 1686471654359
    },
    {
      "type": "edit",
      "id": "8b96957391540660",
      "item": {
        "type": "paragraph",
        "id": "8b96957391540660",
        "text": "It seems like you're exploring different concepts and approaches related to parsing and structuring JSON data within your application. The paper you mentioned discusses the idea of building a structural index over a raw JSON string to enable efficient field projection without fully deserializing the entire record. This approach can be useful when you want to extract specific information from JSON without the need for complete parsing. (ChatGPT May 24 Version)"
      },
      "date": 1686471723026
    },
    {
      "item": {
        "type": "paragraph",
        "id": "0407bf9602dbbbd8",
        "text": "[…]"
      },
      "id": "0407bf9602dbbbd8",
      "type": "add",
      "after": "f74ac9e5be491947",
      "date": 1686475591765
    },
    {
      "type": "edit",
      "id": "0407bf9602dbbbd8",
      "item": {
        "type": "paragraph",
        "id": "0407bf9602dbbbd8",
        "text": "[…]"
      },
      "date": 1686475596493
    },
    {
      "item": {
        "type": "paragraph",
        "id": "c625d1e1bc53e8aa",
        "text": "The error message suggests that the type of page.journal is List Journal, but Encode.list expects the second argument to be of type List Event. (ChatGPT May 24 Version)"
      },
      "id": "c625d1e1bc53e8aa",
      "type": "add",
      "after": "0407bf9602dbbbd8",
      "date": 1686475611756
    },
    {
      "type": "edit",
      "id": "c625d1e1bc53e8aa",
      "item": {
        "type": "paragraph",
        "id": "c625d1e1bc53e8aa",
        "text": "The error message suggests that the type of page.journal is List Journal, but Encode.list expects the second argument to be of type List Event. (ChatGPT May 24 Version)"
      },
      "date": 1686475615249
    },
    {
      "type": "edit",
      "id": "c625d1e1bc53e8aa",
      "item": {
        "type": "paragraph",
        "id": "c625d1e1bc53e8aa",
        "text": "The error message suggests that the type of page.journal is List Journal, but Encode.list expects the second argument to be of type List Event. (ChatGPT May 24 Version)"
      },
      "date": 1686475645920
    },
    {
      "type": "add",
      "id": "15374294ef42b351",
      "item": {
        "type": "paragraph",
        "id": "15374294ef42b351",
        "text": "To resolve this issue, you need to make sure that the journalEncoder function is able to encode a single Journal value into a JSON representation. Currently, it seems like journalEncoder expects an argument of type Journal, but you are passing a list of Journal values (page.journal) to it."
      },
      "after": "c625d1e1bc53e8aa",
      "date": 1686475662228
    },
    {
      "type": "add",
      "id": "148aacd0dd8700d8",
      "item": {
        "type": "paragraph",
        "id": "148aacd0dd8700d8",
        "text": "You might need to update your code to handle the list of Journal values appropriately. Depending on your requirements, you could either modify the journalEncoder to handle a list of Journal values or change how you encode the page.journal list."
      },
      "after": "15374294ef42b351",
      "date": 1686475696526
    },
    {
      "type": "add",
      "id": "4e14a4b9b6d581fe",
      "item": {
        "type": "paragraph",
        "id": "4e14a4b9b6d581fe",
        "text": "Please review your journalEncoder implementation and the usage of Encode.list to ensure consistency in the types being passed."
      },
      "after": "148aacd0dd8700d8",
      "date": 1686475714481
    },
    {
      "type": "fork",
      "date": 1686475736716
    },
    {
      "item": {
        "type": "factory",
        "id": "50806991aacb498e"
      },
      "id": "50806991aacb498e",
      "type": "add",
      "after": "4e14a4b9b6d581fe",
      "date": 1686480600992
    },
    {
      "type": "edit",
      "id": "50806991aacb498e",
      "item": {
        "type": "paragraph",
        "id": "50806991aacb498e",
        "text": "⇒ test(WikiSpec): GREEN Unknown journal event types are passed through … "
      },
      "date": 1686480610077
    },
    {
      "type": "edit",
      "id": "50806991aacb498e",
      "item": {
        "type": "paragraph",
        "id": "50806991aacb498e",
        "text": "⇒ test(WikiSpec): GREEN Unknown journal event types are passed through … [https://github.com/RalfBarkow/vite-elm-dojo/commit/1ae5c832f62301e6dd2d022e25842405fd82236d commit]"
      },
      "date": 1686480619643
    },
    {
      "item": {
        "type": "factory",
        "id": "628e63daddf5b719"
      },
      "id": "628e63daddf5b719",
      "type": "add",
      "after": "50806991aacb498e",
      "date": 1686483502486
    },
    {
      "type": "edit",
      "id": "628e63daddf5b719",
      "item": {
        "type": "image",
        "id": "628e63daddf5b719",
        "text": "Surprise: Future among snippets",
        "size": "wide",
        "width": 430,
        "height": 329,
        "url": "/assets/plugins/image/0005b16559f5cf73b4c0122040df856d.jpg"
      },
      "date": 1686483554218
    },
    {
      "type": "remove",
      "id": "628e63daddf5b719",
      "date": 1686483667985
    },
    {
      "item": {
        "type": "factory",
        "id": "1617c3c54963c514"
      },
      "id": "1617c3c54963c514",
      "type": "add",
      "after": "50806991aacb498e",
      "date": 1686483669260
    },
    {
      "type": "edit",
      "id": "1617c3c54963c514",
      "item": {
        "type": "image",
        "id": "1617c3c54963c514",
        "text": "Surprise: Future among snippets",
        "size": "wide",
        "width": 430,
        "height": 319,
        "url": "/assets/plugins/image/bdabcd5fcabb47f12ed96a118e8c5dc0.jpg"
      },
      "date": 1686483690835
    },
    {
      "item": {
        "type": "factory",
        "id": "9b63a94e6923196b"
      },
      "id": "9b63a94e6923196b",
      "type": "add",
      "after": "1617c3c54963c514",
      "date": 1686486270984
    },
    {
      "type": "edit",
      "id": "9b63a94e6923196b",
      "item": {
        "type": "paragraph",
        "id": "9b63a94e6923196b",
        "text": "If an unrecognized event is encountered during decoding, it will be decoded as an Unknown event with the raw JSON representation stored in a Json.Decode.Value. You can then handle these unknown events separately in your application logic."
      },
      "date": 1686486275021
    },
    {
      "type": "add",
      "id": "5b031bc866ac2608",
      "item": {
        "type": "paragraph",
        "id": "5b031bc866ac2608",
        "text": "To display the rawData JSON in an iframeJson view and the parsed events with relation lines, you'll need to create the necessary HTML and JavaScript code to render the two iframes and establish the communication between them. This part is outside the scope of the Elm code itself, as it involves DOM manipulation and rendering."
      },
      "after": "9b63a94e6923196b",
      "date": 1686486298202
    },
    {
      "type": "add",
      "id": "a8279145b4ad6a00",
      "item": {
        "type": "paragraph",
        "id": "a8279145b4ad6a00",
        "text": "Here's a high-level overview of the steps involved:"
      },
      "after": "5b031bc866ac2608",
      "date": 1686486320219
    },
    {
      "type": "add",
      "id": "5b2e4cd76cec7594",
      "item": {
        "type": "paragraph",
        "id": "5b2e4cd76cec7594",
        "text": "1. Create an HTML page with two iframes, one for the iframeJson view and another for displaying the parsed events with relation lines."
      },
      "after": "a8279145b4ad6a00",
      "date": 1686486337194
    },
    {
      "type": "add",
      "id": "aea8e60fdd70a2be",
      "item": {
        "type": "paragraph",
        "id": "aea8e60fdd70a2be",
        "text": "2. In the iframeJson view, display the raw JSON data."
      },
      "after": "5b2e4cd76cec7594",
      "date": 1686486349741
    },
    {
      "type": "add",
      "id": "bc7e96a59de0a47d",
      "item": {
        "type": "paragraph",
        "id": "bc7e96a59de0a47d",
        "text": "3. In the parsed events iframe, use JavaScript code to parse the raw JSON data and render the events along with the relation lines. You can use a library like D3.js to help with drawing the lines."
      },
      "after": "aea8e60fdd70a2be",
      "date": 1686486363145
    },
    {
      "type": "add",
      "id": "a7df41f7fdc51089",
      "item": {
        "type": "paragraph",
        "id": "a7df41f7fdc51089",
        "text": "4. Establish communication between the two iframes to pass the necessary data. You can use window.postMessage() to send messages between the iframes."
      },
      "after": "bc7e96a59de0a47d",
      "date": 1686486380743
    },
    {
      "type": "add",
      "id": "68a68fb30e51f899",
      "item": {
        "type": "paragraph",
        "id": "68a68fb30e51f899",
        "text": "Note that implementing the visualization and relation lines between the events and the corresponding words/lines in the raw JSON view can be a complex task. You may need to dive into specific JavaScript libraries and techniques for accomplishing this."
      },
      "after": "a7df41f7fdc51089",
      "date": 1686486396352
    },
    {
      "type": "add",
      "id": "a43f014ef6103e3f",
      "item": {
        "type": "paragraph",
        "id": "a43f014ef6103e3f",
        "text": "I hope this gives you a starting point for handling unknown events and implementing the visualization."
      },
      "after": "68a68fb30e51f899",
      "date": 1686486406656
    },
    {
      "type": "remove",
      "id": "5b031bc866ac2608",
      "date": 1686495263553
    },
    {
      "type": "remove",
      "id": "a8279145b4ad6a00",
      "date": 1686495266046
    },
    {
      "type": "remove",
      "id": "5b2e4cd76cec7594",
      "date": 1686495268057
    },
    {
      "type": "remove",
      "id": "bc7e96a59de0a47d",
      "date": 1686495271001
    },
    {
      "type": "remove",
      "id": "a7df41f7fdc51089",
      "date": 1686495272433
    },
    {
      "type": "remove",
      "id": "68a68fb30e51f899",
      "date": 1686495273992
    },
    {
      "type": "remove",
      "id": "a43f014ef6103e3f",
      "date": 1686495277223
    },
    {
      "type": "edit",
      "id": "9b63a94e6923196b",
      "item": {
        "type": "paragraph",
        "id": "9b63a94e6923196b",
        "text": "If an unrecognized event is encountered during decoding, it will be decoded as an Unknown event with the raw JSON representation stored in a Json.Decode.Value. You can then handle these unknown events separately in your application logic. (ChatGPT May 24 Version)"
      },
      "date": 1686495313007
    },
    {
      "type": "add",
      "id": "d51ea56bb225fd2c",
      "item": {
        "type": "paragraph",
        "id": "d51ea56bb225fd2c",
        "text": "⇒ refactor(Main): add a div with model.output to the view."
      },
      "after": "9b63a94e6923196b",
      "date": 1686495402764
    },
    {
      "item": {
        "type": "factory",
        "id": "6c1f6d5c42a69a92"
      },
      "id": "6c1f6d5c42a69a92",
      "type": "add",
      "after": "d51ea56bb225fd2c",
      "date": 1686495414267
    },
    {
      "type": "edit",
      "id": "6c1f6d5c42a69a92",
      "item": {
        "type": "markdown",
        "id": "6c1f6d5c42a69a92",
        "text": "Commit:\na25bc46cf4333771ebb510e20395f8038eb2cc87 [a25bc46]\nParents:\n1ae5c832f6\nAutor\nRalfBarkow <ralf.barkow@me.com>\nDatum:\n11. Juni 2023 um 16:53:31 MESZ\nLabels:\nHEAD main"
      },
      "date": 1686495416044
    },
    {
      "item": {
        "type": "factory",
        "id": "c036264ec3fd0b9b"
      },
      "id": "c036264ec3fd0b9b",
      "type": "add",
      "after": "6c1f6d5c42a69a92",
      "date": 1686495421602
    },
    {
      "type": "edit",
      "id": "c036264ec3fd0b9b",
      "item": {
        "type": "paragraph",
        "id": "c036264ec3fd0b9b",
        "text": "Commit:\na25bc46cf4333771ebb510e20395f8038eb2cc87 [a25bc46]\nParents:\n1ae5c832f6\nAutor\nRalfBarkow <ralf.barkow@me.com>\nDatum:\n11. Juni 2023 um 16:53:31 MESZ\nLabels:\nHEAD main"
      },
      "date": 1686495423345
    },
    {
      "type": "remove",
      "id": "6c1f6d5c42a69a92",
      "date": 1686495426290
    },
    {
      "type": "remove",
      "id": "aea8e60fdd70a2be",
      "date": 1686495525496
    },
    {
      "type": "add",
      "id": "7924ce4061abd553",
      "item": {
        "type": "paragraph",
        "id": "7924ce4061abd553",
        "text": "And as for the \"Future among snippets\" surprise, what does it mean to call a reference a Future story type?"
      },
      "after": "c036264ec3fd0b9b",
      "date": 1686495633465
    },
    {
      "type": "edit",
      "id": "7924ce4061abd553",
      "item": {
        "type": "paragraph",
        "id": "7924ce4061abd553",
        "text": "And as for the \"Future among snippets\" surprise, what does it mean to call a reference a Future story type?"
      },
      "date": 1686495852866
    },
    {
      "type": "edit",
      "id": "7924ce4061abd553",
      "item": {
        "type": "paragraph",
        "id": "7924ce4061abd553",
        "text": "And as for the \"Future among snippets\" surprise, what does it mean to call a reference a Future story type?"
      },
      "date": 1686495868762
    },
    {
      "type": "edit",
      "id": "7924ce4061abd553",
      "item": {
        "type": "paragraph",
        "id": "7924ce4061abd553",
        "text": "And as for the \"Future among snippets\" surprise, what does it mean to call a reference a Future story type?"
      },
      "date": 1686495903291
    },
    {
      "type": "edit",
      "id": "7924ce4061abd553",
      "item": {
        "type": "paragraph",
        "id": "7924ce4061abd553",
        "text": "And as for the \"Future among snippets\" surprise, what does it mean to call a reference a Future story type?"
      },
      "date": 1686496030167
    },
    {
      "type": "edit",
      "id": "7924ce4061abd553",
      "item": {
        "type": "paragraph",
        "id": "7924ce4061abd553",
        "text": "And as for the \"Future among snippets\" surprise, what does it mean to call a reference a Future story type?"
      },
      "date": 1686496113740
    },
    {
      "type": "edit",
      "id": "7924ce4061abd553",
      "item": {
        "type": "paragraph",
        "id": "7924ce4061abd553",
        "text": "And as for the \"Future among snippets\" surprise, what does it mean to call a reference a Future story type?"
      },
      "date": 1686496120489
    },
    {
      "type": "edit",
      "id": "7924ce4061abd553",
      "item": {
        "type": "paragraph",
        "id": "7924ce4061abd553",
        "text": "And as for the \"Future among snippets\" surprise, what does it mean to call a reference a Future story type?"
      },
      "date": 1686496168430
    },
    {
      "type": "edit",
      "id": "c036264ec3fd0b9b",
      "item": {
        "type": "markdown",
        "id": "c036264ec3fd0b9b",
        "text": "> Commit:\na25bc46cf4333771ebb510e20395f8038eb2cc87 [a25bc46]\nParents:\n1ae5c832f6\nAutor\nRalfBarkow <ralf.barkow@me.com>\nDatum:\n11. Juni 2023 um 16:53:31 MESZ\nLabels:\nHEAD main"
      },
      "date": 1686496243850
    },
    {
      "type": "edit",
      "id": "c036264ec3fd0b9b",
      "item": {
        "type": "markdown",
        "id": "c036264ec3fd0b9b",
        "text": "> Commit: a25bc46cf4333771ebb510e20395f8038eb2cc87 [a25bc46]\nParents: 1ae5c832f6\nAutor RalfBarkow <[…]>\nDatum: 11. Juni 2023 um 16:53:31 MESZ\nLabels: HEAD main"
      },
      "date": 1686496245113
    },
    {
      "type": "edit",
      "id": "c036264ec3fd0b9b",
      "item": {
        "type": "markdown",
        "id": "c036264ec3fd0b9b",
        "text": "> Commit: a25bc46cf4333771ebb510e20395f8038eb2cc87 [a25bc46]\nParents: 1ae5c832f6\nAutor RalfBarkow <[…]>\nDatum: 11. Juni 2023 um 16:53:31 MESZ\nLabels: HEAD main"
      },
      "date": 1686496257484
    },
    {
      "type": "edit",
      "id": "c036264ec3fd0b9b",
      "item": {
        "type": "markdown",
        "id": "c036264ec3fd0b9b",
        "text": "> Commit: a25bc46cf4333771ebb510e20395f8038eb2cc87 [a25bc46]\nParents: 1ae5c832f6\nAutor RalfBarkow <[…]>\nDatum: 11. Juni 2023 um 16:53:31 MESZ\nLabels: HEAD main"
      },
      "date": 1686496296262
    },
    {
      "type": "fork",
      "date": 1686496332082
    },
    {
      "type": "fork",
      "date": 1686496412785
    },
    {
      "item": {
        "type": "factory",
        "id": "4e84dcb052109d9b"
      },
      "id": "4e84dcb052109d9b",
      "type": "add",
      "after": "7924ce4061abd553",
      "date": 1686496481482
    },
    {
      "type": "edit",
      "id": "4e84dcb052109d9b",
      "item": {
        "type": "markdown",
        "id": "4e84dcb052109d9b",
        "text": "2023-06-11_rev124"
      },
      "date": 1686496484092
    },
    {
      "type": "edit",
      "id": "4e84dcb052109d9b",
      "item": {
        "type": "markdown",
        "id": "4e84dcb052109d9b",
        "text": "[https://wiki.ralfbarkow.ch/view/2023-06-11/view/2023-06-11_rev124 2023-06-11_rev124]"
      },
      "date": 1686496501071
    },
    {
      "type": "edit",
      "id": "d51ea56bb225fd2c",
      "item": {
        "type": "paragraph",
        "id": "d51ea56bb225fd2c",
        "text": "⇒ refactor(Main): add a div with model.output to the view. [https://github.com/RalfBarkow/vite-elm-dojo/commit/a25bc46cf4333771ebb510e20395f8038eb2cc87 commit"
      },
      "date": 1686496554630
    },
    {
      "type": "edit",
      "id": "d51ea56bb225fd2c",
      "item": {
        "type": "paragraph",
        "id": "d51ea56bb225fd2c",
        "text": "⇒ refactor(Main): add a div with model.output to the view. [https://github.com/RalfBarkow/vite-elm-dojo/commit/a25bc46cf4333771ebb510e20395f8038eb2cc87 commit]"
      },
      "date": 1686496559027
    }
  ]
}