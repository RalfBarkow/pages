{
  "title": "NeoJSONObject",
  "story": [
    {
      "type": "markdown",
      "id": "dcaef20867d5e0dc",
      "text": "I am NeoJSONObject.\nI am an OrderedDictionary.\n\nI behave more like a JavaScript object. I return nil for missing keys. I allow any property to be read or set by using a normal accessor message.\n\nThe following are equivalent:\n\n\tself foo.\n\tself at: #foo.\n\nAs are the following\n\n\tself foo: 1. \n\tself at: #foo put: 1.\n\t\nExcept that in the first case, self is returned.\n\nI can optionally be used by NeoJSONReader as mapClass (see #mapClass:).\n\nFor output, I act just like my superclass (it is thus not necessary to do any conversions).\n\nExample:\n\n\tNeoJSONObject fromString: '{\"foo\":1,\"bar\":-2}'.\n\tNeoJSONObject new foo: 1; bar: -2.\n\t{ #x -> 100. #y -> 200 } as: NeoJSONObject.\n\t(NeoJSONObject new data: (NeoJSONObject new id: #sensor1; value: 37.5)) asString.\n\nI use JSON as my printed representation. To convert me to JSON, use #printString or #asString.\n\nAdditionally, I support path access for nested instances of me, using #atPath: and #atPath:put:\n\nThe first is special because it returns nil as soon as a key is missing. The second is special because it creates extra levels (instances of me) as needed to follow the path of keys.\n\n\tNeoJSONObject new atPath: #(one two three) put: 42; yourself.\n\tNeoJSONObject new atPath: #(one two three) put: 42; atPath: #(one two three).\n\nThe fact that I am an OrderedDictionary means to I maintain the order of keys. This is meant as a convenience feature only as the official JSON specification clearly states \"An object is an unordered set of name/value pairs\".\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "NeoJSONObject",
        "story": []
      },
      "date": 1652967693855
    },
    {
      "item": {
        "type": "factory",
        "id": "dcaef20867d5e0dc"
      },
      "id": "dcaef20867d5e0dc",
      "type": "add",
      "date": 1652967700726
    },
    {
      "type": "edit",
      "id": "dcaef20867d5e0dc",
      "item": {
        "type": "markdown",
        "id": "dcaef20867d5e0dc",
        "text": "I am NeoJSONObject.\nI am an OrderedDictionary.\n\nI behave more like a JavaScript object. I return nil for missing keys. I allow any property to be read or set by using a normal accessor message.\n\nThe following are equivalent:\n\n\tself foo.\n\tself at: #foo.\n\nAs are the following\n\n\tself foo: 1. \n\tself at: #foo put: 1.\n\t\nExcept that in the first case, self is returned.\n\nI can optionally be used by NeoJSONReader as mapClass (see #mapClass:).\n\nFor output, I act just like my superclass (it is thus not necessary to do any conversions).\n\nExample:\n\n\tNeoJSONObject fromString: '{\"foo\":1,\"bar\":-2}'.\n\tNeoJSONObject new foo: 1; bar: -2.\n\t{ #x -> 100. #y -> 200 } as: NeoJSONObject.\n\t(NeoJSONObject new data: (NeoJSONObject new id: #sensor1; value: 37.5)) asString.\n\nI use JSON as my printed representation. To convert me to JSON, use #printString or #asString.\n\nAdditionally, I support path access for nested instances of me, using #atPath: and #atPath:put:\n\nThe first is special because it returns nil as soon as a key is missing. The second is special because it creates extra levels (instances of me) as needed to follow the path of keys.\n\n\tNeoJSONObject new atPath: #(one two three) put: 42; yourself.\n\tNeoJSONObject new atPath: #(one two three) put: 42; atPath: #(one two three).\n\nThe fact that I am an OrderedDictionary means to I maintain the order of keys. This is meant as a convenience feature only as the official JSON specification clearly states \"An object is an unordered set of name/value pairs\".\n"
      },
      "date": 1652967703224
    }
  ]
}