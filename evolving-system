{
  "title": "Evolving System",
  "story": [
    {
      "type": "html",
      "text": "An evolving system can be described as an [[Open Formal System]]. ",
      "id": "2b8e83784862b857ca3024de9e9e6474"
    },
    {
      "type": "html",
      "text": "\nSuch a [[Formal System]] is capable of describing its Avatars in its own terms and it has a time dimension associated with it. ",
      "id": "5ecdc5d7d85ef04424db1d6b3f9931e5"
    },
    {
      "type": "html",
      "text": "\nIf a language can be treated as an [[Evolving System]] then its grammar becomes a discrete function of time and language is not a single point in the space of language implementation but an entire region in that space. ",
      "id": "4e17b0f36e8e11e365652c138e8a0592"
    },
    {
      "type": "html",
      "text": "\n[[Language Grammar]] is associated with [[Design Patterns]] in such a way that the [[Evolving System]] appears to be engaged in the process of [[Pattern Mining]]. ",
      "id": "2637cbe1237a47473d99280a0b968e2d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3fc72ad98d4ba7f6881109845bc0462e"
    },
    {
      "type": "html",
      "text": "<b>Characteristics Of Evolving Systems</b>",
      "id": "3c160c5bb21f1782d0661c852407a21c"
    },
    {
      "type": "html",
      "text": "\nAn [[Evolving System]] is capable of regenerating itself. It appears to be in a state of continuous bootstrapping. Reflection is a very important aspect of such systems. Reflection is implemented using one or other [[Meta Object Protocol]]. See [[Reflective Programming]].",
      "id": "62ecd738c4766eb6d758167de60511ad"
    },
    {
      "type": "html",
      "text": "\nAn [[Evolving System]] allows reclassification of objects. An object may belong to different classes depending on time and other parameters (dimensions) in such a system. An object may even become a class. I know it is possible to do this with [[Visual Works]]. [[Neo Class Talk]] uses this to compose behavior. ",
      "id": "c985ae740685449c82239278dfc8fded"
    },
    {
      "type": "html",
      "text": "\n[[Evolving Frameworks]] gives good insights into the process of building an evolving system. [[Squeak Smalltalk]] is a very good example of an evolving system.",
      "id": "fc346461f7bf1a93e776bbcb5a913c61"
    },
    {
      "type": "html",
      "text": "\nAn [[Evolving System]] is not just an isolated piece of software/hardware. No system can evolve left to itself. It must allow interaction and interact with other systems. Evolution of a system is closely related with increasing complexity of interactions. Over time, as the system evolves (becomes more complex internally) the complexity of interactions is reduced and it becomes a more natural part of its environment. Evolution of a system drives it towards specialization(s) as if it is seeking its special role.  <i>Please explain.</i>",
      "id": "b2b219832d980b5d21796b7a5a0ba521"
    },
    {
      "type": "html",
      "text": "\nComplexity must increase in an expanding universe ([[Dissipative Systems]]). This is reflected in all systems, natural and man-made. Increasing complexity is not a bad thing. It only means that patterns become more and more interesting. Systems continue to survive and evolve as long they are able to recognize and internalize these patterns. \"In effect, any open system survives by its ability to change some aspects of its structure or behavior in order to maintain stability in those areas that define its core identity\"[2]. In other words, an evolving language must provide new words and grammatical constructs to describe more and more complex phenomena. It will become extinct if it fails to do so.",
      "id": "17155c7ad68b64d08ecfab8137a7ff25"
    },
    {
      "type": "html",
      "text": "\nThe problem of [[Evolving System]] is related with [[Pattern Recognition]] and [[Pattern Mining]]. It is important to include [[Market Processes]], [[Business Process]]es, [[Software Engineering Processes]] in this context. Other processes like [[Socio Psychological Process]], [[Organizational Processes]], and [[Technological Advancement]] also play a crucial role. ",
      "id": "e6171bb4e6e5cd2b3c5c9529d1ea451e"
    },
    {
      "type": "html",
      "text": "\nThe evolution of a system is reflected in the refinements it brings to its constituent processes. Process A' is a refinement of Process A when it is faster, cheaper and better (happier) than Process A. Also, Process A' consumes less energy. ",
      "id": "d4cbdc433848eae8b15de045dbd2e1b7"
    },
    {
      "type": "html",
      "text": "\nIt is important to remember that an [[Evolving System]] is not just a cartesian sum of its parts. Feedback loops abound not only within layers but across layers. [[Change And Stability]] become contradictory requirements. However, an [[Evolving System]] continuously renews itself. [[Illya Prigogene]], in his work on the characteristics of self-organizing systems, calls this \"irreversible non-linear transformation under conditions far from equilibrium.\" Stability apparently emerges from the depths of chaos.",
      "id": "bb366f4429c3f1d873afd6c671034512"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3fc72ad98d4ba7f6881109845bc0462e"
    },
    {
      "type": "html",
      "text": "<b>Measuring Evolving Systems</b>",
      "id": "f0025cd49c0e0ccefdda72e84cbc808d"
    },
    {
      "type": "html",
      "text": "\nYes, one way to do this is to learn to be happy no matter what. ",
      "id": "0794a018da88159f4881fbcae9afb2f7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3fc72ad98d4ba7f6881109845bc0462e"
    },
    {
      "type": "html",
      "text": "<b>Examples Of Evolving Systems</b>",
      "id": "345bae03daec91924b21144fe2e24695"
    },
    {
      "type": "code",
      "text": " PlanetEarth\n NeoClassTalk\n SqueakSmalltalk\n WikiWikiWeb",
      "id": "ba53393ec5495bb7d18017dd6ff0e7d2"
    },
    {
      "type": "html",
      "text": "\nSoftware applications are usually [[Evolving System]]s: see [[Evolutionary Programming]] .",
      "id": "3762d953392a854d9067f18d914c0e6d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3fc72ad98d4ba7f6881109845bc0462e"
    },
    {
      "type": "html",
      "text": "If you are interested in seeing how these concepts can be used in the real world of IT in support of commercial software you need to start using some softwarephysics.  As an IT professional, I have been using biological concepts to support commercial software for over 30 years.  Let me explain.",
      "id": "8e37f372d59f318b57489262fed379af"
    },
    {
      "type": "html",
      "text": "\nFrom 1975 – 1979, I was an exploration geophysicist exploring for oil, first with Shell and then with Amoco, until I made a career change into IT in 1979.  When I transitioned into IT from geophysics, I figured if you could apply physics to geology; why not apply physics to software?  So like the exploration team at Amoco that I had just left, consisting of geologists, geophysicists, paleontologists, geochemists, and petrophysicists, I decided to take all the physics, chemistry, biology, and geology that I could muster and throw it at the problem of software.  The basic idea was that it seemed as though over the past 60 years the IT community had accidentally created a pretty decent computer simulation of the physical Universe on a grand scale, a Software Universe so to speak, and that I could use this fantastic simulation in reverse, to better understand the behavior of commercial software by comparing it to how things behaved in the physical Universe.  Softwarephysics is a simulated science that depicts software as a virtual substance, and relies upon our understanding of the current theories in physics, chemistry, biology, and geology to help us model the nature of software behavior.  So in physics we use software to simulate the behavior of the Universe, while in softwarephysics we use the Universe to simulate the behavior of software.",
      "id": "f1369e087faa67728d3ee4582420ddf7"
    },
    {
      "type": "html",
      "text": "\nOver the past few years, I have been working on a blog on softwarephysics to help the IT community better cope with the daily mayhem of life in IT.  However, in laying down the postings for this blog an unintended consequence arose in my mind as I became profoundly aware of the enormity of this vast computer simulation of the physical Universe, and of its potential scientific value.  One of the nagging problems for many of the observational and experimental sciences is that many times there is only one example readily at hand to study or experiment with, and it is very difficult to do meaningful statistics with a population of N=1.  But the computer simulation of the physical Universe that the Software Universe presents provides another realm for comparison. For example, both biology and astrobiology only have one biosphere on Earth to study and even physics itself has only one Universe with which to engage. Imagine the possibilities if scientists had another Universe readily at hand in which to work! This is exactly what the Software Universe provides.",
      "id": "4de50719d3da4fc4cfd3c5dfcef2200e"
    },
    {
      "type": "html",
      "text": "\nFrom a paleobiological perspective, softwarephysics provides a good starting point for the comparison of the evolution of software architecture over the past 60 years with the evolution of life on Earth over the past 4 billion years.  Both have followed a very similar path due to convergence.  Software and living things are both forms of self-replicating information that have had to contend with the second law of thermodynamics and deterministic chaos in a nonlinear universe, and consequently, have both come up with very similar solutions.",
      "id": "fb8fa0b4d443f360a81ddd849ca31493"
    },
    {
      "type": "html",
      "text": "\nAll the postings for my blog on softwarephysics are available at:\n[http://softwarephysics.blogspot.com/ softwarephysics.blogspot.com]",
      "id": "cb2f5e935abebca98fa046728ba06763"
    },
    {
      "type": "html",
      "text": "\nHowever, to cut to the chase, I would recommend the following postings in this order:",
      "id": "9771962b9aaa67bc61fe3df56acd00f8"
    },
    {
      "type": "html",
      "text": "\nA Proposal For All Practicing Paleontologists:\n[http://softwarephysics.blogspot.com/2009/04/new-introduction-to-softwarephysics.html softwarephysics.blogspot.com]\nThis posting provides a road map for getting started.",
      "id": "930d5048422ecc96892f63884dcef356"
    },
    {
      "type": "html",
      "text": "\nIntroduction to Softwarephysics:\n[http://softwarephysics.blogspot.com/ softwarephysics.blogspot.com]\nThis posting provides an overview.  I keep pasting it in as the first posting as I add additional posts behind it.",
      "id": "bbe616fe02326ac96c6b94655f571c8a"
    },
    {
      "type": "html",
      "text": "\n[[Software Physics]]\n[http://softwarephysics.blogspot.com/2006/07/softwarephysics.html softwarephysics.blogspot.com]\nThis is my original post on softwarephysics.  The second half of the posting describes how softwarephysics was used by the IT department of Amoco (now a part of BP) from 1985 – 1991 to grow several million lines of production code with my BSDE – Bionic Systems Development Environment tool.  BSDE generated a 10,000 line of code embryo from a set of genes for a new business application.  The programmer then grew the embryo into a fully developed application by turning its genes on and off within BSDE, which performed a maternal function during development.  BSDE was also used to grow code for itself.  The next generation of BSDE was grown within the current version of BSDE, and over a period of 7 years, more than 1,000 generations of BSDE were generated, and BSDE slowly evolved into a very sophisticated tool through small incremental changes.  Below is a Google Docs document from 1989 featuring an overview of BSDE that I wrote for the Amoco IT Training Department’s course on BSDE. \n[https://docs.google.com/Doc?id=dhjzddgs_156dfzhf6kh docs.google.com]",
      "id": "14fdca39d265cdfeb2acbb2833d9ecd9"
    },
    {
      "type": "html",
      "text": "\n[[Software Biology]]:\n[http://softwarephysics.blogspot.com/2008/06/introduction-to-softwarephysics-ii.html softwarephysics.blogspot.com]\nThe second half of this posting will be of most interest.  The first half just covers Darwinian thought and a little geology for IT professionals, who frequently are quite lacking in these areas.  Just scroll down to the section on [[Software Paleontology]] which provides a thumbnail sketch of the evolution of software architecture.",
      "id": "9928201f197a69b02dbe457a97569488"
    },
    {
      "type": "html",
      "text": "\nSelf-Replicating Information:\n[http://softwarephysics.blogspot.com/2008/06/new-introduction-to-softwarephysics.html softwarephysics.blogspot.com]\nThis posting features Freeman Dyson’s two-stage theory for the origin of life as it pertains to the origin of software and the concept of self-replicating information.",
      "id": "cfd88582b5a1805171ca8dd886d3e3e1"
    },
    {
      "type": "html",
      "text": "\nThe Origin of Software the Origin of Life:\n[http://softwarephysics.blogspot.com/2010/05/another-introduction-to-softwarephysics.html softwarephysics.blogspot.com]\nThis posting features some of Stuart Kauffman’s work on complexity theory as it pertains to the origin of life and how it might have led to the origin of software as well.",
      "id": "293dd349a993d77e43dbecc28a7e9255"
    },
    {
      "type": "html",
      "text": "\nSoftware Symbiogenesis:\n[http://softwarephysics.blogspot.com/2008/07/introduction-to-softwarephysics-ii.html softwarephysics.blogspot.com]\nThis posting applies the ideas of Lynn Margulis to software evolution.",
      "id": "1368f19bbba07bcb7d1017bb5bb95074"
    },
    {
      "type": "html",
      "text": "\nWhen Toasters Fly:\n[http://softwarephysics.blogspot.com/2010/09/new-introduction-to-softwarephysics.html softwarephysics.blogspot.com]\nThis posting applies the ideas of Stephen Jay Gould to software evolution.",
      "id": "22f66c6540d548e09d3aeaa328f40fd8"
    },
    {
      "type": "html",
      "text": "\n[[Software Chemistry]]:\n[http://softwarephysics.blogspot.com/2008/01/softwarechemistry.html softwarephysics.blogspot.com]\nThis posting proposes that the interactions of lines of code in software represent a very good computer simulation for the interaction of organic molecules.",
      "id": "e3ec11feaa3d9c4acf734f0b8fbe10b2"
    },
    {
      "type": "html",
      "text": "\nHow to Think Like a Softwarephysicist\n[http://softwarephysics.blogspot.com/2008/10/introduction-to-softwarephysics.html softwarephysics.blogspot.com]\nThis posting sums up softwarephysics and explains how it can be used on a daily basis by IT professionals.",
      "id": "377d1030f7c06fd5390f995fa2470818"
    },
    {
      "type": "html",
      "text": "\n[[Cyber Cosmology]]:\n[http://softwarephysics.blogspot.com/2009/02/introduction-to-softwarephysics-ii.html softwarephysics.blogspot.com]\nThis posting covers where it may all be leading. ",
      "id": "6c7948dc78e614b66e5f5b3023058bfe"
    },
    {
      "type": "html",
      "text": "Regards,\nSteve Johnston",
      "id": "5baf4ef368c849e2a9836ccd8ed6136b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3fc72ad98d4ba7f6881109845bc0462e"
    },
    {
      "type": "html",
      "text": "\nSee Also: [[Systems As Living Things]]  [[Interfaces Are Formal Systems]]",
      "id": "eeff54fd0b235e32b416a07df0fece4c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3fc72ad98d4ba7f6881109845bc0462e"
    },
    {
      "type": "html",
      "text": "[[Category Evolution]]",
      "id": "69646ce8552d1276d18496304a233252"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?EvolvingSystem c2.com]",
      "id": "283f62ad7a3bb04edeeaf6b305a4c019"
    }
  ],
  "journal": [
    {
      "date": 1291989045000,
      "id": "08ffe95cc885a293481608100d0e4038",
      "type": "create",
      "item": {
        "title": "Evolving System",
        "story": [
          {
            "type": "html",
            "text": "An evolving system can be described as an [[Open Formal System]]. ",
            "id": "2b8e83784862b857ca3024de9e9e6474"
          },
          {
            "type": "html",
            "text": "\nSuch a [[Formal System]] is capable of describing its Avatars in its own terms and it has a time dimension associated with it. ",
            "id": "5ecdc5d7d85ef04424db1d6b3f9931e5"
          },
          {
            "type": "html",
            "text": "\nIf a language can be treated as an [[Evolving System]] then its grammar becomes a discrete function of time and language is not a single point in the space of language implementation but an entire region in that space. ",
            "id": "4e17b0f36e8e11e365652c138e8a0592"
          },
          {
            "type": "html",
            "text": "\n[[Language Grammar]] is associated with [[Design Patterns]] in such a way that the [[Evolving System]] appears to be engaged in the process of [[Pattern Mining]]. ",
            "id": "2637cbe1237a47473d99280a0b968e2d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3fc72ad98d4ba7f6881109845bc0462e"
          },
          {
            "type": "html",
            "text": "<b>Characteristics Of Evolving Systems</b>",
            "id": "3c160c5bb21f1782d0661c852407a21c"
          },
          {
            "type": "html",
            "text": "\nAn [[Evolving System]] is capable of regenerating itself. It appears to be in a state of continuous bootstrapping. Reflection is a very important aspect of such systems. Reflection is implemented using one or other [[Meta Object Protocol]]. See [[Reflective Programming]].",
            "id": "62ecd738c4766eb6d758167de60511ad"
          },
          {
            "type": "html",
            "text": "\nAn [[Evolving System]] allows reclassification of objects. An object may belong to different classes depending on time and other parameters (dimensions) in such a system. An object may even become a class. I know it is possible to do this with [[Visual Works]]. [[Neo Class Talk]] uses this to compose behavior. ",
            "id": "c985ae740685449c82239278dfc8fded"
          },
          {
            "type": "html",
            "text": "\n[[Evolving Frameworks]] gives good insights into the process of building an evolving system. [[Squeak Smalltalk]] is a very good example of an evolving system.",
            "id": "fc346461f7bf1a93e776bbcb5a913c61"
          },
          {
            "type": "html",
            "text": "\nAn [[Evolving System]] is not just an isolated piece of software/hardware. No system can evolve left to itself. It must allow interaction and interact with other systems. Evolution of a system is closely related with increasing complexity of interactions. Over time, as the system evolves (becomes more complex internally) the complexity of interactions is reduced and it becomes a more natural part of its environment. Evolution of a system drives it towards specialization(s) as if it is seeking its special role.  <i>Please explain.</i>",
            "id": "b2b219832d980b5d21796b7a5a0ba521"
          },
          {
            "type": "html",
            "text": "\nComplexity must increase in an expanding universe ([[Dissipative Systems]]). This is reflected in all systems, natural and man-made. Increasing complexity is not a bad thing. It only means that patterns become more and more interesting. Systems continue to survive and evolve as long they are able to recognize and internalize these patterns. \"In effect, any open system survives by its ability to change some aspects of its structure or behavior in order to maintain stability in those areas that define its core identity\"[2]. In other words, an evolving language must provide new words and grammatical constructs to describe more and more complex phenomena. It will become extinct if it fails to do so.",
            "id": "17155c7ad68b64d08ecfab8137a7ff25"
          },
          {
            "type": "html",
            "text": "\nThe problem of [[Evolving System]] is related with [[Pattern Recognition]] and [[Pattern Mining]]. It is important to include [[Market Processes]], [[Business Process]]es, [[Software Engineering Processes]] in this context. Other processes like [[Socio Psychological Process]], [[Organizational Processes]], and [[Technological Advancement]] also play a crucial role. ",
            "id": "e6171bb4e6e5cd2b3c5c9529d1ea451e"
          },
          {
            "type": "html",
            "text": "\nThe evolution of a system is reflected in the refinements it brings to its constituent processes. Process A' is a refinement of Process A when it is faster, cheaper and better (happier) than Process A. Also, Process A' consumes less energy. ",
            "id": "d4cbdc433848eae8b15de045dbd2e1b7"
          },
          {
            "type": "html",
            "text": "\nIt is important to remember that an [[Evolving System]] is not just a cartesian sum of its parts. Feedback loops abound not only within layers but across layers. [[Change And Stability]] become contradictory requirements. However, an [[Evolving System]] continuously renews itself. [[Illya Prigogene]], in his work on the characteristics of self-organizing systems, calls this \"irreversible non-linear transformation under conditions far from equilibrium.\" Stability apparently emerges from the depths of chaos.",
            "id": "bb366f4429c3f1d873afd6c671034512"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3fc72ad98d4ba7f6881109845bc0462e"
          },
          {
            "type": "html",
            "text": "<b>Measuring Evolving Systems</b>",
            "id": "f0025cd49c0e0ccefdda72e84cbc808d"
          },
          {
            "type": "html",
            "text": "\nYes, one way to do this is to learn to be happy no matter what. ",
            "id": "0794a018da88159f4881fbcae9afb2f7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3fc72ad98d4ba7f6881109845bc0462e"
          },
          {
            "type": "html",
            "text": "<b>Examples Of Evolving Systems</b>",
            "id": "345bae03daec91924b21144fe2e24695"
          },
          {
            "type": "code",
            "text": " PlanetEarth\n NeoClassTalk\n SqueakSmalltalk\n WikiWikiWeb",
            "id": "ba53393ec5495bb7d18017dd6ff0e7d2"
          },
          {
            "type": "html",
            "text": "\nSoftware applications are usually [[Evolving System]]s: see [[Evolutionary Programming]] .",
            "id": "3762d953392a854d9067f18d914c0e6d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3fc72ad98d4ba7f6881109845bc0462e"
          },
          {
            "type": "html",
            "text": "If you are interested in seeing how these concepts can be used in the real world of IT in support of commercial software you need to start using some softwarephysics.  As an IT professional, I have been using biological concepts to support commercial software for over 30 years.  Let me explain.",
            "id": "8e37f372d59f318b57489262fed379af"
          },
          {
            "type": "html",
            "text": "\nFrom 1975 – 1979, I was an exploration geophysicist exploring for oil, first with Shell and then with Amoco, until I made a career change into IT in 1979.  When I transitioned into IT from geophysics, I figured if you could apply physics to geology; why not apply physics to software?  So like the exploration team at Amoco that I had just left, consisting of geologists, geophysicists, paleontologists, geochemists, and petrophysicists, I decided to take all the physics, chemistry, biology, and geology that I could muster and throw it at the problem of software.  The basic idea was that it seemed as though over the past 60 years the IT community had accidentally created a pretty decent computer simulation of the physical Universe on a grand scale, a Software Universe so to speak, and that I could use this fantastic simulation in reverse, to better understand the behavior of commercial software by comparing it to how things behaved in the physical Universe.  Softwarephysics is a simulated science that depicts software as a virtual substance, and relies upon our understanding of the current theories in physics, chemistry, biology, and geology to help us model the nature of software behavior.  So in physics we use software to simulate the behavior of the Universe, while in softwarephysics we use the Universe to simulate the behavior of software.",
            "id": "f1369e087faa67728d3ee4582420ddf7"
          },
          {
            "type": "html",
            "text": "\nOver the past few years, I have been working on a blog on softwarephysics to help the IT community better cope with the daily mayhem of life in IT.  However, in laying down the postings for this blog an unintended consequence arose in my mind as I became profoundly aware of the enormity of this vast computer simulation of the physical Universe, and of its potential scientific value.  One of the nagging problems for many of the observational and experimental sciences is that many times there is only one example readily at hand to study or experiment with, and it is very difficult to do meaningful statistics with a population of N=1.  But the computer simulation of the physical Universe that the Software Universe presents provides another realm for comparison. For example, both biology and astrobiology only have one biosphere on Earth to study and even physics itself has only one Universe with which to engage. Imagine the possibilities if scientists had another Universe readily at hand in which to work! This is exactly what the Software Universe provides.",
            "id": "4de50719d3da4fc4cfd3c5dfcef2200e"
          },
          {
            "type": "html",
            "text": "\nFrom a paleobiological perspective, softwarephysics provides a good starting point for the comparison of the evolution of software architecture over the past 60 years with the evolution of life on Earth over the past 4 billion years.  Both have followed a very similar path due to convergence.  Software and living things are both forms of self-replicating information that have had to contend with the second law of thermodynamics and deterministic chaos in a nonlinear universe, and consequently, have both come up with very similar solutions.",
            "id": "fb8fa0b4d443f360a81ddd849ca31493"
          },
          {
            "type": "html",
            "text": "\nAll the postings for my blog on softwarephysics are available at:\n[http://softwarephysics.blogspot.com/ softwarephysics.blogspot.com]",
            "id": "cb2f5e935abebca98fa046728ba06763"
          },
          {
            "type": "html",
            "text": "\nHowever, to cut to the chase, I would recommend the following postings in this order:",
            "id": "9771962b9aaa67bc61fe3df56acd00f8"
          },
          {
            "type": "html",
            "text": "\nA Proposal For All Practicing Paleontologists:\n[http://softwarephysics.blogspot.com/2009/04/new-introduction-to-softwarephysics.html softwarephysics.blogspot.com]\nThis posting provides a road map for getting started.",
            "id": "930d5048422ecc96892f63884dcef356"
          },
          {
            "type": "html",
            "text": "\nIntroduction to Softwarephysics:\n[http://softwarephysics.blogspot.com/ softwarephysics.blogspot.com]\nThis posting provides an overview.  I keep pasting it in as the first posting as I add additional posts behind it.",
            "id": "bbe616fe02326ac96c6b94655f571c8a"
          },
          {
            "type": "html",
            "text": "\n[[Software Physics]]\n[http://softwarephysics.blogspot.com/2006/07/softwarephysics.html softwarephysics.blogspot.com]\nThis is my original post on softwarephysics.  The second half of the posting describes how softwarephysics was used by the IT department of Amoco (now a part of BP) from 1985 – 1991 to grow several million lines of production code with my BSDE – Bionic Systems Development Environment tool.  BSDE generated a 10,000 line of code embryo from a set of genes for a new business application.  The programmer then grew the embryo into a fully developed application by turning its genes on and off within BSDE, which performed a maternal function during development.  BSDE was also used to grow code for itself.  The next generation of BSDE was grown within the current version of BSDE, and over a period of 7 years, more than 1,000 generations of BSDE were generated, and BSDE slowly evolved into a very sophisticated tool through small incremental changes.  Below is a Google Docs document from 1989 featuring an overview of BSDE that I wrote for the Amoco IT Training Department’s course on BSDE. \n[https://docs.google.com/Doc?id=dhjzddgs_156dfzhf6kh docs.google.com]",
            "id": "14fdca39d265cdfeb2acbb2833d9ecd9"
          },
          {
            "type": "html",
            "text": "\n[[Software Biology]]:\n[http://softwarephysics.blogspot.com/2008/06/introduction-to-softwarephysics-ii.html softwarephysics.blogspot.com]\nThe second half of this posting will be of most interest.  The first half just covers Darwinian thought and a little geology for IT professionals, who frequently are quite lacking in these areas.  Just scroll down to the section on [[Software Paleontology]] which provides a thumbnail sketch of the evolution of software architecture.",
            "id": "9928201f197a69b02dbe457a97569488"
          },
          {
            "type": "html",
            "text": "\nSelf-Replicating Information:\n[http://softwarephysics.blogspot.com/2008/06/new-introduction-to-softwarephysics.html softwarephysics.blogspot.com]\nThis posting features Freeman Dyson’s two-stage theory for the origin of life as it pertains to the origin of software and the concept of self-replicating information.",
            "id": "cfd88582b5a1805171ca8dd886d3e3e1"
          },
          {
            "type": "html",
            "text": "\nThe Origin of Software the Origin of Life:\n[http://softwarephysics.blogspot.com/2010/05/another-introduction-to-softwarephysics.html softwarephysics.blogspot.com]\nThis posting features some of Stuart Kauffman’s work on complexity theory as it pertains to the origin of life and how it might have led to the origin of software as well.",
            "id": "293dd349a993d77e43dbecc28a7e9255"
          },
          {
            "type": "html",
            "text": "\nSoftware Symbiogenesis:\n[http://softwarephysics.blogspot.com/2008/07/introduction-to-softwarephysics-ii.html softwarephysics.blogspot.com]\nThis posting applies the ideas of Lynn Margulis to software evolution.",
            "id": "1368f19bbba07bcb7d1017bb5bb95074"
          },
          {
            "type": "html",
            "text": "\nWhen Toasters Fly:\n[http://softwarephysics.blogspot.com/2010/09/new-introduction-to-softwarephysics.html softwarephysics.blogspot.com]\nThis posting applies the ideas of Stephen Jay Gould to software evolution.",
            "id": "22f66c6540d548e09d3aeaa328f40fd8"
          },
          {
            "type": "html",
            "text": "\n[[Software Chemistry]]:\n[http://softwarephysics.blogspot.com/2008/01/softwarechemistry.html softwarephysics.blogspot.com]\nThis posting proposes that the interactions of lines of code in software represent a very good computer simulation for the interaction of organic molecules.",
            "id": "e3ec11feaa3d9c4acf734f0b8fbe10b2"
          },
          {
            "type": "html",
            "text": "\nHow to Think Like a Softwarephysicist\n[http://softwarephysics.blogspot.com/2008/10/introduction-to-softwarephysics.html softwarephysics.blogspot.com]\nThis posting sums up softwarephysics and explains how it can be used on a daily basis by IT professionals.",
            "id": "377d1030f7c06fd5390f995fa2470818"
          },
          {
            "type": "html",
            "text": "\n[[Cyber Cosmology]]:\n[http://softwarephysics.blogspot.com/2009/02/introduction-to-softwarephysics-ii.html softwarephysics.blogspot.com]\nThis posting covers where it may all be leading. ",
            "id": "6c7948dc78e614b66e5f5b3023058bfe"
          },
          {
            "type": "html",
            "text": "Regards,\nSteve Johnston",
            "id": "5baf4ef368c849e2a9836ccd8ed6136b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3fc72ad98d4ba7f6881109845bc0462e"
          },
          {
            "type": "html",
            "text": "\nSee Also: [[Systems As Living Things]]  [[Interfaces Are Formal Systems]]",
            "id": "eeff54fd0b235e32b416a07df0fece4c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3fc72ad98d4ba7f6881109845bc0462e"
          },
          {
            "type": "html",
            "text": "[[Category Evolution]]",
            "id": "69646ce8552d1276d18496304a233252"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?EvolvingSystem c2.com]",
            "id": "283f62ad7a3bb04edeeaf6b305a4c019"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1645326628829
    }
  ]
}