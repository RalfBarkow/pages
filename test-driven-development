{
  "title": "Test Driven Development",
  "story": [
    {
      "type": "html",
      "text": "",
      "id": "823ad45996ad870ddaebe940b7d1761f"
    },
    {
      "type": "markdown",
      "id": "bed3abbc9fa8853e",
      "text": "TDD was invented in Smalltalk via the introduction of the SUnit test library."
    },
    {
      "type": "html",
      "text": "When you code, alternate these activities:",
      "id": "0f0c58b17c7635a619b0f477a094d9f2"
    },
    {
      "type": "image",
      "url": "http://www.zeroplayer.com/tdd.png",
      "text": "www.zeroplayer.com",
      "id": "274b6d072f9fc0029f5bd4a55f954fa4"
    },
    {
      "type": "html",
      "text": " add a test, get it to fail, and write code to pass the test ([[Do Simple Things]], [[Code Unit Test First]])",
      "id": "89c2460740d82ee743a519dc09035a54"
    },
    {
      "type": "html",
      "text": " remove duplication ([[Once And Only Once]], [[Dont Repeat Yourself]], [[Three Strikes And You Automate]])",
      "id": "a4bd0bc48f402462359b4c149f137398"
    },
    {
      "type": "html",
      "text": "\nThis inner loop pumps the outer loops of [[Extreme Programming]] - [[Continuous Integration]], [[Daily Deployment]], [[Frequent Releases]], and [[Steering Software Projects]]. (<i>Hence the graphic.</i>) Tests help us keep promises regarding the quality, cost, and existence of previously installed features.",
      "id": "a64c03d17e2795e4dac0a8681e5a7782"
    },
    {
      "type": "html",
      "text": "\nUsing this system, all my code is highly decoupled (meaning easy to re-use) because it all already has two users - its clients, and its test rigs. Classes typically resist the transition from one user to two, then the rest are easy. I make reuse easy as a side-effect of coding very fast.",
      "id": "4a03d215b08eb79fffcf4c308d2d01df"
    },
    {
      "type": "html",
      "text": "\nThen, the \"remove duplication\" phase forces one to examine code for latent abstractions that one could express via virtual methods and other techniques that naturally make code more extendable. This is the \"reuse\" that the OO hype of the 1980s screamed about.",
      "id": "3e925b6705536cb30ba942e433bc9f4e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": " Think about what you want to do. ",
      "id": "f64644bdec4c3d497780182ece9ad87f"
    },
    {
      "type": "html",
      "text": " Think about how to test it. ",
      "id": "fc3d5b21ea21c14fe44638f616ca8603"
    },
    {
      "type": "html",
      "text": " Write a small test. Think about the desired API. ",
      "id": "eb8148172a9c266cd2ee6349c653758d"
    },
    {
      "type": "html",
      "text": " Write just enough code to fail the test. ",
      "id": "206d22b6adfb7e736492f6b013d4b357"
    },
    {
      "type": "html",
      "text": " Run and watch the test fail. (The test-runner, if you're using something like JUnit, shows the \"Red Bar\"). Now you know that your test is going to be executed. ",
      "id": "2e083c7b8426ab10f7ed21aa61dd6e6a"
    },
    {
      "type": "html",
      "text": " Write just enough code to pass the test (and pass all your previous tests). ",
      "id": "7a008f4897f2c81396ab70db4dbfd2a7"
    },
    {
      "type": "html",
      "text": " Run and watch all of the tests pass. (The test-runner, if you're using JUnit, etc., shows the \"Green Bar\"). If it doesn't pass, you did something wrong, fix it now since it's got to be something you just wrote. ",
      "id": "9243a580a2c3b883354a87fd1fbd6a26"
    },
    {
      "type": "html",
      "text": " If you have any duplicate logic, or inexpressive code, refactor to remove duplication and increase expressiveness -- this includes reducing coupling and increasing cohesion. ",
      "id": "e4b896745a8c88b9c056bbe9d371e41f"
    },
    {
      "type": "html",
      "text": " Run the tests again, you should still have the Green Bar. If you get the Red Bar, then you made a mistake in your refactoring. Fix it now and re-run. ",
      "id": "a321fecd0f97d91eca182d21c417c1f5"
    },
    {
      "type": "html",
      "text": " Repeat the steps above until you can't find any more tests that drive writing new code. ",
      "id": "fa99311c51a57f3cee6bab83e35bbd95"
    },
    {
      "type": "html",
      "text": "\nPlease note that first item is by far the most difficult, followed by the second item. But if you can't do those, you probably shouldn't start writing any code. The rest of the list is really pretty easy, but the first two are critical.",
      "id": "a96a0acf33c38c6b5cf5c07adf7ccef9"
    },
    {
      "type": "html",
      "text": "<i>Uh, item 1 is what your [[Onsite Customer]] keeps screaming about, and item 2 is just item 1 stated inside-out. They are all easy, especially in this order.</i>",
      "id": "c170e3d08e49fa0588d8fc44c0ee1304"
    },
    {
      "type": "html",
      "text": "\nThere is a big step between hearing the words of an [[Onsite Customer]] and understanding the meaning. Translating a business statement into technical language can be a difficult job and one should respect that difficulty. Item 2 recognizes that testing the code often requires exposing some things not necessarily required by the end user. There is a step to go beyond what the user needs to what the test will need. ",
      "id": "5aa025427fbe7057c54f30e894165e2c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "An example of TDD in action in a simple challenge - to write a programme that produces the correct answers to the game \"[[Fizz Buzz]]\": [https://www.youtube.com/watch?v=CHTep2zQVAc www.youtube.com]",
      "id": "88d5278562dbe7367b6508c9c47bc5ab"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "I use code to find patterns that I am interested in. I can imagine many possible solutions to programming problems but some are a lot better than others. Rather than use my brain to model the computer in high resolution, I use the computer itself to do the modeling and all I need is to start coding somewhere, make incremental changes and follow what turns out to be interesting. Most of this kind of code is thrown away so why would I want to make it bullet proof up front? If I was creating a UI for a piece of code, I would create many versions until I zeroed in on the one I like. Test first is great if you know exactly the best way to program an explicitly defined program but I rarely get that kind of explicit definition and even if I did, how would I know that technique \"best fits\" that problem? I would know that if I had coded something very like it before but if I had, then I would just take the code I wrote before and make modifications to it. Creating tests that proves the code works is very hard, except in the simple cases and those probably don't need a test in any case. Tests should be created for code that is a \"keeper\" which, in my case, is only a small fraction of the code I write.",
      "id": "d1a7f32cab62d6717b57ab0c217de7ff"
    },
    {
      "type": "html",
      "text": "\nHow do you write a test for something that is constantly changing and you don't know what it's shape or structure will look like?",
      "id": "65ef1f562080d3958c39ab027ecaf5d0"
    },
    {
      "type": "html",
      "text": "-- [[David Clarkd]]",
      "id": "0d7454123a2917a351e99716534ee72e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nSystems created using [[Code Unit Test First]], [[Relentless Testing]] & [[Acceptance Test]]s might just be better designed than traditional systems. But they all certainly would support [[Code Unit Test First]] while using them better than our current set of systems.",
      "id": "716f1947a6c1283c12025d68091671c4"
    },
    {
      "type": "html",
      "text": "\nBut because so danged many of them were not, we are a little blind to what we could have available on the shelf.",
      "id": "f1ec508f794d970e83f208f678819d16"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nA list of ways that test-first programming can affect design:",
      "id": "3224336ae52ca7c353dec3c0b5d83333"
    },
    {
      "type": "html",
      "text": " Re-use is good. Test first code is born with two clients, not one. This makes adding a third client twice as easy.",
      "id": "8db12ae600653ee2f019829eae0d94eb"
    },
    {
      "type": "html",
      "text": " Refactoring test-first code results in equally tested code, permitting more aggressive refactorings ([[Refactor Mercilessly]]). Cruft is not allowed, and code is generally in better shape to accept more refactorings.",
      "id": "3113a8e3807c77e04a40cc6e59cf98a4"
    },
    {
      "type": "html",
      "text": " When paying attention during all of the little steps, you may discover patterns in your code.",
      "id": "d7f68c232743e8b10a7480477f50eacc"
    },
    {
      "type": "html",
      "text": " Test code is easy to write. It's usually a couple calls to the server object, then a list of assertions. Writing the easy code first makes writing the hard code easy.",
      "id": "761188e6f4385f2da44e26355ab7ea35"
    },
    {
      "type": "html",
      "text": " [[Design Patterns]] may be incremented in, not added all of a bunch up front.",
      "id": "e86b22c82adfed79876d035a187ed302"
    },
    {
      "type": "html",
      "text": " Test-first code is written Interface first. You think of the simplest interface that can show function.",
      "id": "a80a8daad3a7f60aaba3679ab0c3104e"
    },
    {
      "type": "html",
      "text": " Code tends to be less coupled. Effective unit tests only test one thing. To do this you have to move the irrelevant portions out of the way (e.g., [[Mock Object]]s). This forces out what might be a poor design choice.",
      "id": "5d3246dd79c8d855b340a3b44c494da8"
    },
    {
      "type": "html",
      "text": " [[Unit Test]]s stand as canonical & tested documentation for objects' usage. Developers read them, and do what they do in production code to the same objects. This keeps projects annealed and on track.",
      "id": "733f9754c3f99ed8043320cc73616ff9"
    },
    {
      "type": "html",
      "text": " When the developer has to write tests for what he is going to do, he is far less likely to add extraneous capabilities. This really puts a damper on developer driven scope creep.",
      "id": "14b3b282044c1f70b417ab4374adb984"
    },
    {
      "type": "html",
      "text": " Test First Design forces you to really think about what you are going to do. It gets you away from \"It seemed like a good idea at the time\" programming.",
      "id": "9fc92c29d489a632ef028c08c585d032"
    },
    {
      "type": "html",
      "text": "- This sure isn't a page for irresponsible people. <i>Is any programming activity for irresponsible people?</i> See [[Code And Fix]], [[Water Fall]].",
      "id": "6211d97fa79443b6409887fd014f39ee"
    },
    {
      "type": "html",
      "text": "- <i>Nope. the problem is:</i> <b>They don't know!</b> [[[Unskilled And Unaware Of It]]]",
      "id": "75c57d6160f3bb313b21fd93b18f1dc7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nI have been working my way through Kent's TDD book for a while now, and applying the principles quite rigorously. I am a real dullard sometimes, because it takes me a horribly long time to understand even simple stuff. I had probably been applying TDD for more than a week before I realized why it works so well (at least for me). There are three parts to this:",
      "id": "18e54845da8e5ccfa3b67034819267e2"
    },
    {
      "type": "html",
      "text": " The tests (obviously) help find bugs in the application code, and the micro-steps taken with TDD mean that any \"bugs\" are in the very code I have just been writing and hence which still has a relevant mental model in my small brain",
      "id": "d8d36d221b307342ce2a7761767e6a46"
    },
    {
      "type": "html",
      "text": " By doing the absolutely simplest thing in the application code in order to get each test to run, I often have small [[Aha Moment]]s, where I see that I am writing such overly concrete code (i.e. just enough to get the tests to work) that the tests (even though they run) cannot possibly be adequate to cover the \"real\" requirements. So to justify writing more abstract application code, I need to add more test cases that demand that abstraction, and this forces me to explore the requirement further. Therefore, the application code actually helps me debug the tests. That is, since the tests are the specification, feedback from the application code helps me debug the specification.",
      "id": "a984cf66fb9746434ece7b0993d71a7a"
    },
    {
      "type": "html",
      "text": " As I have these \"aha!\" moments (mentioned in 2 above) I follow Kent's practice of adding them to the [[To Do List]]. It took my stupid head quite some time to realize that the TODO list is actually a list of Micro-Stories, which I constantly prioritize (since I am the customer at this level). Following [[Alistair Cockburn]]'s insight that Stories are promises to have a conversation with the customer, I see, then, that the Micro-Stories in the TODO list are a promise to have a conversation with myself (and, here is the weird bit) to have a conversation with the code (since it gives me feedback - it tells me things - and TDD tunes me in to listening to the code).",
      "id": "857e8e303954c41991dedca1ea44dcee"
    },
    {
      "type": "html",
      "text": "-- [[Anthony Lauder]]",
      "id": "e8aad65e474153cc2123e301292b4744"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "<i>Test Driven Development</i> (TDD) by [[Kent Beck]] ",
      "id": "8b6a3369359373aa1ad13b6127165856"
    },
    {
      "type": "image",
      "url": "http://images.amazon.com/images/P/0321146530.01._PE_PI_SCMZZZZZZZ_.jpg",
      "text": "images.amazon.com",
      "id": "604d0256c75d0f71fb9c655670de51d1"
    },
    {
      "type": "html",
      "text": "\n",
      "id": "1a74d337984baf3488c826d5def3b51f"
    },
    {
      "type": "html",
      "text": "[ISBN: 0321146530] A Book, ",
      "id": "a8902bfaa301092a58b4bffd1584c76f"
    },
    {
      "type": "html",
      "text": "\nMailing list: [http://groups.yahoo.com/group/testdrivendevelopment groups.yahoo.com].",
      "id": "0714bbc7c30adc76082337f964d73889"
    },
    {
      "type": "html",
      "text": "<i>Test Driven Development</i> (TDD) by [[David Astels]] ",
      "id": "ced7dbc00f19b9cfe7cd754acd69e793"
    },
    {
      "type": "html",
      "text": "[ISBN: 0131016490] another book",
      "id": "85722e0ff10c5327b34869eebbe08286"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\n[[John Rusk]] worries <i>that one danger of [[Test Driven Development]] is that developers may <b>not</b> take that step that you take. I.e. developers may stay with overly concrete code that satisfies the tests but not the \"real\" requirements.</i>",
      "id": "89f707230fceab8b4309811733dd328a"
    },
    {
      "type": "html",
      "text": "<i>To look at it another way, I have always felt that it was dangerous to approach design with (only) particular test cases in mind, since its usually necessary to think about boundary cases, and other unusual cases.</i>",
      "id": "4e9b53162f6134740ddb11038112cc52"
    },
    {
      "type": "html",
      "text": "<i>How does XP address that danger? By encouraging developers to write sufficiently comprehensive tests? Or by relying on developers to take that step which you mention, which is saying, \"OK, this actually passes my tests, but its not really adequate for the real world because....\".</i>",
      "id": "f6eafc91689fd2586768a2f4c6f4bbf8"
    },
    {
      "type": "html",
      "text": "\nXP addresses that danger with [[Pair Programming]]. When obvious boundary cases are overlooked by the programmer driving the keyboard, the programmer acting as navigator points out the oversight. This is an excellent example of a case where a single practice is, by itself, insufficient to reasonably guarantee success but, in combination with a complementary practice, provides excellent results.",
      "id": "df3def3520cabbc03ebb200519f01f51"
    },
    {
      "type": "html",
      "text": "<i>[[Test First]] is a cool way to program source code. XP extends [[Test First]] to all scales of the project. One tests the entire project by frequently releasing it and collecting feedback.</i>",
      "id": "5f7e65bd6366450d1e95b4e6675d5cc4"
    },
    {
      "type": "html",
      "text": "<b>Q: What \"real\" requirements can you not test?</b>",
      "id": "3e95b032b4549f80ab15b322b3ef11f4"
    },
    {
      "type": "html",
      "text": " Those requirements which are not stated.",
      "id": "9c889145ead055a673f157ab14c89f0e"
    },
    {
      "type": "html",
      "text": " Requirements which require highly specialized, unaffordable, or non-existent support hardware to test. E.g., with hardware such as the Intellasys SEAforth chips, it's possible to generate pulses on an I/O pin as narrow as 6ns under software control. To <i>see</i> these pulses, you need an oscilloscope with a bandwidth no less than 166MHz, and to make sure their waveform is accurate, you need a bandwidth no less than 500MHz, with 1GHz strongly preferred. However, at 1GHz bandwidths, you're looking at <i>incredibly</i> expensive sampling oscilloscopes. Thus, if you cannot afford this kind of hardware, you pretty much have to take it on faith things are OK. Then, you need some means of feeding this waveform data back to the test framework PC (which may or may not be the PC running the actual test), which adds to the cost.",
      "id": "1935c7f9d9b0c3acdd3ebda50de57c7e"
    },
    {
      "type": "html",
      "text": "\nTDD cannot automatically fix algorithms; neither can any other technique. Where rigorous testing helps is ensuring that the details of your algorithm remain the same even if you refactor or add features. A test case can easily check _too_ much, and fail even if the production code would have worked. For example, suppose one step of an algorithm returns an array. A test could fail if that array is not sorted, even if the algorithm does not require the array, at that juncture, to be sorted.",
      "id": "b93c7f794457b0b73041dc3a08be1fea"
    },
    {
      "type": "html",
      "text": "\nThis is a <b><i>good</b></i> thing; it makes you stop, revert your change, and try again.",
      "id": "e38535929c3bfdc7846da0b7cf38bdfe"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nNote: here is the link to the pdf file on the yahoo groups area:",
      "id": "74ac6fc37c3e27f67826606c5bf3a373"
    },
    {
      "type": "html",
      "text": " [http://groups.yahoo.com/group/testdrivendevelopment/files/TDD17Jul2002.pdf groups.yahoo.com]",
      "id": "a1db3d5e75ab1c6864c15cd37c638a2e"
    },
    {
      "type": "html",
      "text": "\nI found this unexpectedly awkward to locate by searching, so I thought I'd drop the link in here. -- [[David Plumpton]]",
      "id": "53f9ce26d9c583850385b361b3d619c6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nI've sometimes been an advocate of test driven development, but my enthusiasm has dropped after I've noticed that [[Code Unit Test First]] goes heavily against prototyping. I prefer a style of coding where the division of responsibility between units and the interfaces live a lot in the beginning of the development cycle, and writing a test for those before the actual code is written will seriously hinder the speed of development and almost certainly end testing the wrong thing.",
      "id": "48474ac73f89e4af611bf2dc1524e824"
    },
    {
      "type": "html",
      "text": "\nAgreed. Please see my blog entry about adapting TDD for mere mortals at [http://agileskills2.org/blog/2010/02/07/tdd-adapted-for-mere-mortals/ agileskills2.org] -- [[Kent Tong]]",
      "id": "b79b99fbe0e76e143dc6448b820c8baf"
    },
    {
      "type": "html",
      "text": ": <i>Assuming you're not shipping the prototype, there's nothing particularly in conflict. The prototype is in itself a sort of design test. The trouble with prototypes is that they have this habit of becoming the product...</i>",
      "id": "a1a828a1a0102b780859e6aa7e8ac58d"
    },
    {
      "type": "html",
      "text": "[RE: prototypes becoming \"the\" product. Arrg.. I agree. <i>No reason for it to happen. TDD makes rewriting slops as clean code absurdly easy</i>]",
      "id": "bc75e54c235419c9ef4b77ea16d0f9d8"
    },
    {
      "type": "html",
      "text": "\nDesign is a lot more difficult than implementing a design. But [[Unit Test]]s explicitly require one to define the design before making it work.",
      "id": "acf233856c8ae825336ad0ed5f70e5c9"
    },
    {
      "type": "html",
      "text": "\nThere are other problems, too. Like OO methodology, the difficulties which test driven development helps with are sometimes caused by itself. Every extra line of code adds to the complexity of the program, and tests slow down serious refactoring. This is most apparent in hard-to-test things like GUI's, databases and web applications, which sometimes get restructured to allow for testing and get complicated a lot. -- [[Panu Kalliokoski]]",
      "id": "08ff12647e329455a52d7afc11f96af9"
    },
    {
      "type": "html",
      "text": "<i>[[Code Unit Test First]] goes heavily against prototyping? Strange, I haven't found that to be true, myself. Closer to the opposite, in fact - I start with a very thin shell of a [[Proto Type]], and as I make progress it fills in with real features. I wonder how what you actually do differs from what I actually do.</i>",
      "id": "458e38ff137c010ff0f3485aed2d3f65"
    },
    {
      "type": "html",
      "text": "\nStrongly agree. A big side benefit of [[Code Unit Test First]] that doesn't get enough attention is how it rearranges your thinking. Instead of thinking \"oh I'll need these accessors on these classes, etc\" you think in terms of use cases. And you end up with *exactly* what you need, nothing more and nothing less.",
      "id": "12ff1e302106c7f9034a6af171d38b56"
    },
    {
      "type": "html",
      "text": "<i>I find I have a huge increase in speed in all areas of development when I [[Code Unit Test First]]. I honestly believe that anyone who doesn't experience this is either busy knocking down [[Straw Man]]s, isn't doing it right, or hasn't really given it a chance.</i>",
      "id": "5314e5035b13572d988c77baf9e10d0b"
    },
    {
      "type": "html",
      "text": "\nTDDing GUIs is quite frustrating. It may be a lot easier if there were a GUI toolkit available that has been TDDed itself, from the ground up. Anyone interested in such a TDDedGuiFramework project?",
      "id": "09ce88759d20cedd6fee410ba4ac93cc"
    },
    {
      "type": "html",
      "text": "<i>You mean like [[Ruby On Rails]]? -- [[Phl Ip]]</i>",
      "id": "12dc1ee152ae92e425c706879741563b"
    },
    {
      "type": "html",
      "text": ":-) No, I mean a toolkit for standalone clients (or maybe a hybrid one, people have been experimenting with this already). Something like SWT, but a lot more intuitive :-)",
      "id": "43ca5e155405fd69956bb4fbe67e4b53"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nNote that some TDDers abuse [[Mock Object]]s. Dynamic mock systems like [http://classmock.sf.net classmock.sf.net] can make this too easy. A TDD design should be sufficiently decoupled that its native object work fine as stubs and test resources. They help to test other objects without runaway dependencies. One should mock the few remaining things which are too hard to adapt to testing, such as random numbers or filesystem errors.",
      "id": "91ad5c2617e900b3d481377a62098826"
    },
    {
      "type": "html",
      "text": "\nSome of us disagree with that view, see [http://www.mockobjects.com/files/mockrolesnotobjects.pdf www.mockobjects.com] for an alternative.",
      "id": "de1bfbbac71ff2fb315989adcefa75bc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nI'd like to revisit a comment that [[John Rusk]] made above:",
      "id": "b3e066b6446018cf9701213d7fa4e088"
    },
    {
      "type": "html",
      "text": "<i>It seems to me that one danger of [[Test Driven Development]] is that developers may _not_ take that step that you take. I.e. developers may stay with overly concrete code that satisfies the tests but not the \"real\" requirements.</i>",
      "id": "08c1f1d0adb131483a96e0c917e3a06e"
    },
    {
      "type": "html",
      "text": "\nSee [[Fake It Until You Make It]]",
      "id": "6274a4faf9f91ed547ddb0534f097457"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nThe principles of TDD can be applied quite well to analysis and design, also. There's a tutorial on Test-driven Analysis & Design at [http://www.parlezuml.com/tutorials/tdad/index_files/frame.htm www.parlezuml.com] which neatly introduces the ideas.",
      "id": "2008a6f20336f457dff18297dec09d17"
    },
    {
      "type": "html",
      "text": "-- [[Dave Chan]]",
      "id": "5f43abf66de630d5028eb650d5c5e3ac"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nWhat about extended the principles of TDD beyond testing, analysis, and design. How about using the principles also on user documentation? This idea is described in Purpose Driven Development (PDD) at [http://jacekratzinger.blogspot.com/2012/01/purpose-driven-development-pdd.html jacekratzinger.blogspot.com]",
      "id": "f820514afe284334347d6e1dc61e39a0"
    },
    {
      "type": "html",
      "text": "-- [[Jacek Ratzinger]]",
      "id": "83a583a716f6de4168f09d73b71b4161"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\"Roman Numerals\" is often held up as a good sample project to learn TDD. I know TDD but I'm bad at math, so I tried the project, and put its results here:",
      "id": "28dbbd0f53829afaa7b5958fd40fd4f0"
    },
    {
      "type": "html",
      "text": " [http://www.xpsd.org/cgi-bin/wiki?TestDrivenDevelopmentTutorialRomanNumerals www.xpsd.org]",
      "id": "1ecef6767b057b77ab5c0c9ef32ad418"
    },
    {
      "type": "html",
      "text": "-- [[Phl Ip]]",
      "id": "1ba81ec83e014b9728d499a375057dd6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "<shameless plug> Up to date info on tools and practices at [http://testdriven.com testdriven.com]",
      "id": "b12d4ae62b66bb17543616fef9be2578"
    },
    {
      "type": "html",
      "text": "-- [[David Vydra]]",
      "id": "a2bd974c3dd84d12e22153939ab6cd84"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nI found GNU/Unix command line option parsing to be a good TDD exercise as well. My results here:",
      "id": "9c7fc093652fada57051ce62280fd035"
    },
    {
      "type": "html",
      "text": " [http://home.comcast.net/~pholser/software/pholser-getopts.zip home.comcast.net] (3.5Mb download; 4.7Mb unpacked)",
      "id": "8503ca0f45eb608f620789f6c1d23d9d"
    },
    {
      "type": "html",
      "text": "-- [[Paul Holser]]",
      "id": "76b9c39587956e9faefac32ba0452eca"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "[[Organic Testing]] of the [[Tgp Methodology]] is one way to practice [[Test Driven Development]]. Organic Testing is an [[Automated Test]]s methodology that share resemblance to both [[Unit Test]] and [[Integration Test]]. Like [[Unit Test]], they are run by the developers whenever they want (before check-in). Unlike [[Unit Test]], only the framework for the test is provided by the programmers, while the actual data of the test is given by [[Business Professionals]]. In Organic testing like [[Integration Test]]s, in each run the whole software (or a whole module) is activated. -- [[Ori Inbar]]",
      "id": "336fa59a42815273fd2a268ab5be9afc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nAnother reference: article \"Improving Application Quality Using Test-Driven Development\" from Methods & Tools",
      "id": "9731fc4c59e562460a6ddd3cfc650a22"
    },
    {
      "type": "html",
      "text": "\n[http://www.methodsandtools.com/archive/archive.php?id=20 www.methodsandtools.com]",
      "id": "dfe18eff90fa031ca1fe5e2128fa578e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nBut what about [[Secure Design]]? [[Security As An Afterthought]] is a bad idea and it seems that test-driven development (and a number of other agile processes, though perhaps not all) has a bad habit of ignoring security except as test cases, which isn't always the best way to approach the problem. ",
      "id": "74532369e2e0c433299e3972072cf308"
    },
    {
      "type": "html",
      "text": "-- [[Kyle Maxwell]] ",
      "id": "0f34bb16e655f3711673796769117f87"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nHmmmm. Seems to me that TDD deals with security (as well as things like performance) just like any other functional requirement. You have a story (or task) explicitly stating what functionality is needed (e.g., user needs 2 passwords to login, which are stored in an LDAP server; or algorithm needs to perform 5000 calculations per second). You then write tests that will verify functionality. And then you write the functionality itself.",
      "id": "e4ea51bb1b5d91a4cc190a42286df9cc"
    },
    {
      "type": "html",
      "text": "\nAnd unlike traditional development, you now have regression tests to make sure that this functionality never gets broken. (i.e., if, due to subsequent coding, the security code gets broken, or the algorithm performance drops off, you'll have a broken test to alert you of that.)",
      "id": "8a9e2df933247833b5d3a413b396f9e7"
    },
    {
      "type": "html",
      "text": "-- [[David Rosenstrauch]]",
      "id": "69cfc444879f7f238b3aa9388f09fccb"
    },
    {
      "type": "html",
      "text": "\nOne of the reasons that security is hard is that security is not just a piece of functionality. Okay, there are things like passwords which are security features, but the rest of the code also has to not have security holes, which are [[Negative Requirements]]; ie, code must not do X.",
      "id": "34fc1273862a04b5bcac685fc295a9f3"
    },
    {
      "type": "html",
      "text": "\nThis is obvious in the case of 'must not overflow buffer', which TDD does address, but is less obvious in things like 'component X should not be able to affect component Y'. How do you test that? (I probably read this in 'Security Engineering', by Ross Anderson, which is now free on the web).",
      "id": "526da69e406353e221db4ecbfe6a3710"
    },
    {
      "type": "html",
      "text": "-- [[Alex Burr]] ",
      "id": "68c8d034c124855a132943ea35f290fe"
    },
    {
      "type": "html",
      "text": "<i>In the case of \"Component A must not affect Component B\", how would you evaluate this </i>without<i> test-driven development? If you can't formally define this requirement, then TDD is no better or worse than hoping for the best. (One answer in this case may be rule-based formal validation of the system, which is easy enough to plug into a TDD framework.)</i> -- [[Jevon Wright]]",
      "id": "b9967de9ae48c66b3257242e4b1a9e2d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "Some interesting info on test driven development from E. Dijkstra:",
      "id": "c56a41bfd848e2b518e0205971583e23"
    },
    {
      "type": "html",
      "text": " [http://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1012.PDF www.cs.utexas.edu]",
      "id": "591ccb70ee925e0953b9ca873b950b77"
    },
    {
      "type": "html",
      "text": " (above is from [http://www.cs.utexas.edu/users/EWD/index10xx.html www.cs.utexas.edu])",
      "id": "f1a87e72829f93fbd0b35ad0b4c25444"
    },
    {
      "type": "html",
      "text": "\nBit Torrent founder (Bram) uses test driven development, and thinks Formal methods suck:",
      "id": "ed9141e8e480f3d3a8ceebacce083db0"
    },
    {
      "type": "html",
      "text": " [http://z505.com/cgi-bin/qkcont/qkcont.cgi?p=Bittorrent-Founder-Wrong z505.com]",
      "id": "ba6a4918d803d0fc6cb3fce50f517ac4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "IEEE Software will publish a special issue on Test-Driven Development in July 2007. For more information, see [[Ieee Software Special Issue On Test Driven Development]]",
      "id": "703c5bd10d2828d3529477203d3fc30a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "Found this useful illustration of TDD in .NET (Flash screen cast)\n[http://www.parlezuml.com/tutorials/tdd.html www.parlezuml.com]",
      "id": "9443401a8775ffa08338dd915e9887d7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "I can't help to mention the awesomeness of [[Doc Test]] in Python.  Not only do you get TDD, but you get code documentation for free, as it integrates [[Doc Strings]] into every Module, Class, and Method.  I'd like to see TDD really integrated tightly into programming environments. [[Doc Strings]] are accessed via a built-in help() function and encourage a friendly development community. [[Doc Test]] goes further, encouraging smart design of tests within the [[Doc Strings]] themselves in ways that simultaneously teach the User what your method and class is supposed to do. Ideally, Interpreted environments should integrate a test() built-in.  Then, [[Doc Test]] could be removed and built into the interpreter environment with it`s companion function \"help()\". This would allow the \"add a test, get it to fail, and write code to pass\" cycle to attain a most friendly goal of [[Literate Programming]]. -- [[Mark Janssen]]",
      "id": "d274bb68e31289dce047864abf0e7b4c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nBDD (Behavior Driven Development) is a form of TDD (Test Driven Development) where the tests are specified through definition of desired Behaviors, as opposed to writing tests in code (the same code language used for the product). The BDD camp says that you use natural language to describe desired behaviour, and employ testing tools which translate the natural language behaviour specification into tests which validate the product code. This approach recognizes and attempts to address a couple of challenges with testing which I elaborate upon below.",
      "id": "dd04244c3edf5f9d08957729c2d3fa64"
    },
    {
      "type": "html",
      "text": "\nSee 'Cucumber' ([http://cukes.info/ cukes.info]) as one example of a BDD test toolkit.",
      "id": "5c3d36bae7aa7d3c6e57a74340bcdee9"
    },
    {
      "type": "html",
      "text": "\nOne strategy with BDD is that you employ test (SDT) developers with much different skills than your product (SDE) developers. You can thereby segregate SDT and SDE developers by skills. Another strategy is that your developers use different tools for product development from test development. This suggests that you use people with different skills (less product intensive skills, btw), to write tests (or the same folks using different skills). But when you choose TDD or BDD as a methodology practice, you need to consider (answer) the questions exposed below.",
      "id": "43d1b8e2cd2d065a7264f6ba011f7838"
    },
    {
      "type": "html",
      "text": "\nBuilding test code to automate the testing of your product code produces a regression problem. You want to avoid placing 'faith' in the production code, and ensure that the code has been tested (verified), but now you have moved your 'faith' into the test code.",
      "id": "1f1efc5b06a476fa659465d0c7820f69"
    },
    {
      "type": "html",
      "text": "\nThis regression problem is a challenge with testing, where you must provide tests which cover the requirements and features of your product, so you have moved (regressed) the problem of (potential) defects in the development into a problem with (potential) defects in the test code. You have now written more code (probably in the same language), but possibly replicated or moved the defect into test code. You are still placing faith, but now in your test code, rather than in your production code.",
      "id": "bfb6a1392dfc39a74ed1d469c2b9480f"
    },
    {
      "type": "html",
      "text": "\nOne strategy is to use SDT's to develop tests, and SDE's to develop products. This can help catch misunderstandings in requirements (win), but only increases the amount of code written, and thus the potential number of defects, adding personnel to develop these tests, and thus adding costs. And you now have a recruiting and motivation problem. You must staff SDE's to build products and SDT's to build tests.",
      "id": "70d07e13e9b383c4b3edeffc356504af"
    },
    {
      "type": "html",
      "text": "\nHowever, we can consider that by using different personnel, defects are statistically less likely to align between product code and test code, because we assume that the SDE's and SDT's are independent. We assume a stochastically independent defect generation (SDE's and SDT's are different people). Thus we expect them to generate defects in different places.",
      "id": "553a1293c794eded7258dcd353c8ba19"
    },
    {
      "type": "html",
      "text": "\nBut are these activities stochastically independent? We are relying upon this independence. But agile asks that one agile team combine developers writing production code and developers writing test code. So the same (hard) problems are viewed by the same team, and the same conceptual issues are tackled in code by the same pool of developers. Using different developers to write product and test code gains little practical independence, as developers (SDE or SDT) have essentially the same training and experience.",
      "id": "38826ecd6bd1cda1b1104373d5f5cef8"
    },
    {
      "type": "html",
      "text": "\nConsider the strategy that you require different training and experience from SDE and SDT. This regains some missing independence. But unless all developers (SDE and SDT) have essentially the same training, capabilities, and skills, they cannot perform interchangeably on an agile team. And developers undertake extensive training. And now you must separate developers by skill and role. Now you face the choice whether to use more skilled developers to write the product, or to write the tests? Using less skilled developers to write the product impairs your product. Using less skilled developers to write your tests means that you impair your tests. This reduces to a Faustian choice, do you effectively subvert your testing and quality process, or do you sacrifice your product development?",
      "id": "79f5ae2f7f954258806f325512a9d2b1"
    },
    {
      "type": "html",
      "text": "\nRevisit the recruiting and motivation problem. Suppose you decide to staff SDT's to build tests and SDE's to build products. You have introduced stratification and competition into your development team. Are you going to get equally qualified candidates for both SDE and SDT? Even with the different requirements? Assume that most developers want to advance their careers, and gain recognition and rewards, and become the best developers they can become.",
      "id": "673807b3b14f736b07e4b34ef79ed44b"
    },
    {
      "type": "html",
      "text": "\nWhich path will the best and the brightest want to pursue? Consider that Google hires less than 1% of applicants (lots of people want to work there, so they must want to pursue the 'best' career path). Joel Spolsky (co-founder, Fog Creek Software) writes a blog on software development, ([http://www.joelonsoftware.com/ www.joelonsoftware.com]), says that you should hire people who are \"Smart, and Get Things Done\".",
      "id": "b83014929fd98a1e29262f301b78e708"
    },
    {
      "type": "html",
      "text": "\nCan you effectively use the same people writing both product code and test code? And gain the stochastic independence testing needs?  Can you use people with different training and skills, and have them independently build tests? And not sacrifice product development on the altar of quality?",
      "id": "2a579faadaf3c08317eb6772f8dff913"
    },
    {
      "type": "html",
      "text": "\nThe BDD camp says that you use natural language to describe desired behaviour, which would employ developers with much different skills, and thereby segregate developers by skills. This suggests that you use people with different skills (less product intensive skills, btw), to write tests. This has been exposed as a suspect strategy, but assuming you choose TDD or BDD as a methodology practice, anyway. How do you achieve the best results?",
      "id": "0d7f2f6f9819d4eaafa8182d24a6fc2c"
    },
    {
      "type": "html",
      "text": "-- [[Chuck Cottrill]]",
      "id": "dc16bc6dfb3f35e55d361cb673718714"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "\nTDD in general and [[Behavior Driven Development]] in particular are firmly grounded in [[Hoare Triple]]. I find a useful parallel between a written [[Use Case]]‎ document and BDD Feature / Story Narrative.",
      "id": "a23a2bc9984f98131a7bfe768755435a"
    },
    {
      "type": "html",
      "text": "-- [[Martin Spamer]]",
      "id": "8c88328197bd8b88137da39f63e77269"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "See [[Test First User Interfaces]] [[Calvin And Hobbes Discuss Tdd]] [[Test Driven Analysis And Design]] [[Test Driven Developmenta Practical Guide]] [[Test Driven Development Challenges]] [[Test Driven Design Phase Shift]], [[Power Of Tdd]], [[Ieee Software Special Issue On Test Driven Development]], [[Behavior Driven Development]], [[Test Food Pyramid]]",
      "id": "7f55c5e87d5f3820651e1ca70d9e026c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
    },
    {
      "type": "html",
      "text": "[[Category Testing]] [[Category Book]] [[Category Test Driven Development]] [[Category Extreme Programming]]",
      "id": "a505dd8e73b90f4a982992bda69533c1"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?TestDrivenDevelopment c2.com]",
      "id": "04f773bd1ae7413753f2212c3b54f392"
    }
  ],
  "journal": [
    {
      "date": 1415237237000,
      "id": "9b72b19812e60b3dfb3dcdc5dd48f38d",
      "type": "create",
      "item": {
        "title": "Test Driven Development",
        "story": [
          {
            "type": "image",
            "url": "http://www.zeroplayer.com/tdd.png",
            "text": "www.zeroplayer.com",
            "id": "274b6d072f9fc0029f5bd4a55f954fa4"
          },
          {
            "type": "html",
            "text": "",
            "id": "823ad45996ad870ddaebe940b7d1761f"
          },
          {
            "type": "html",
            "text": "\nWhen you code, alternate these activities:",
            "id": "0f0c58b17c7635a619b0f477a094d9f2"
          },
          {
            "type": "html",
            "text": " add a test, get it to fail, and write code to pass the test ([[Do Simple Things]], [[Code Unit Test First]])",
            "id": "89c2460740d82ee743a519dc09035a54"
          },
          {
            "type": "html",
            "text": " remove duplication ([[Once And Only Once]], [[Dont Repeat Yourself]], [[Three Strikes And You Automate]])",
            "id": "a4bd0bc48f402462359b4c149f137398"
          },
          {
            "type": "html",
            "text": "\nThis inner loop pumps the outer loops of [[Extreme Programming]] - [[Continuous Integration]], [[Daily Deployment]], [[Frequent Releases]], and [[Steering Software Projects]]. (<i>Hence the graphic.</i>) Tests help us keep promises regarding the quality, cost, and existence of previously installed features.",
            "id": "a64c03d17e2795e4dac0a8681e5a7782"
          },
          {
            "type": "html",
            "text": "\nUsing this system, all my code is highly decoupled (meaning easy to re-use) because it all already has two users - its clients, and its test rigs. Classes typically resist the transition from one user to two, then the rest are easy. I make reuse easy as a side-effect of coding very fast.",
            "id": "4a03d215b08eb79fffcf4c308d2d01df"
          },
          {
            "type": "html",
            "text": "\nThen, the \"remove duplication\" phase forces one to examine code for latent abstractions that one could express via virtual methods and other techniques that naturally make code more extendable. This is the \"reuse\" that the OO hype of the 1980s screamed about.",
            "id": "3e925b6705536cb30ba942e433bc9f4e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": " Think about what you want to do. ",
            "id": "f64644bdec4c3d497780182ece9ad87f"
          },
          {
            "type": "html",
            "text": " Think about how to test it. ",
            "id": "fc3d5b21ea21c14fe44638f616ca8603"
          },
          {
            "type": "html",
            "text": " Write a small test. Think about the desired API. ",
            "id": "eb8148172a9c266cd2ee6349c653758d"
          },
          {
            "type": "html",
            "text": " Write just enough code to fail the test. ",
            "id": "206d22b6adfb7e736492f6b013d4b357"
          },
          {
            "type": "html",
            "text": " Run and watch the test fail. (The test-runner, if you're using something like JUnit, shows the \"Red Bar\"). Now you know that your test is going to be executed. ",
            "id": "2e083c7b8426ab10f7ed21aa61dd6e6a"
          },
          {
            "type": "html",
            "text": " Write just enough code to pass the test (and pass all your previous tests). ",
            "id": "7a008f4897f2c81396ab70db4dbfd2a7"
          },
          {
            "type": "html",
            "text": " Run and watch all of the tests pass. (The test-runner, if you're using JUnit, etc., shows the \"Green Bar\"). If it doesn't pass, you did something wrong, fix it now since it's got to be something you just wrote. ",
            "id": "9243a580a2c3b883354a87fd1fbd6a26"
          },
          {
            "type": "html",
            "text": " If you have any duplicate logic, or inexpressive code, refactor to remove duplication and increase expressiveness -- this includes reducing coupling and increasing cohesion. ",
            "id": "e4b896745a8c88b9c056bbe9d371e41f"
          },
          {
            "type": "html",
            "text": " Run the tests again, you should still have the Green Bar. If you get the Red Bar, then you made a mistake in your refactoring. Fix it now and re-run. ",
            "id": "a321fecd0f97d91eca182d21c417c1f5"
          },
          {
            "type": "html",
            "text": " Repeat the steps above until you can't find any more tests that drive writing new code. ",
            "id": "fa99311c51a57f3cee6bab83e35bbd95"
          },
          {
            "type": "html",
            "text": "\nPlease note that first item is by far the most difficult, followed by the second item. But if you can't do those, you probably shouldn't start writing any code. The rest of the list is really pretty easy, but the first two are critical.",
            "id": "a96a0acf33c38c6b5cf5c07adf7ccef9"
          },
          {
            "type": "html",
            "text": "<i>Uh, item 1 is what your [[Onsite Customer]] keeps screaming about, and item 2 is just item 1 stated inside-out. They are all easy, especially in this order.</i>",
            "id": "c170e3d08e49fa0588d8fc44c0ee1304"
          },
          {
            "type": "html",
            "text": "\nThere is a big step between hearing the words of an [[Onsite Customer]] and understanding the meaning. Translating a business statement into technical language can be a difficult job and one should respect that difficulty. Item 2 recognizes that testing the code often requires exposing some things not necessarily required by the end user. There is a step to go beyond what the user needs to what the test will need. ",
            "id": "5aa025427fbe7057c54f30e894165e2c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "An example of TDD in action in a simple challenge - to write a programme that produces the correct answers to the game \"[[Fizz Buzz]]\": [https://www.youtube.com/watch?v=CHTep2zQVAc www.youtube.com]",
            "id": "88d5278562dbe7367b6508c9c47bc5ab"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "I use code to find patterns that I am interested in. I can imagine many possible solutions to programming problems but some are a lot better than others. Rather than use my brain to model the computer in high resolution, I use the computer itself to do the modeling and all I need is to start coding somewhere, make incremental changes and follow what turns out to be interesting. Most of this kind of code is thrown away so why would I want to make it bullet proof up front? If I was creating a UI for a piece of code, I would create many versions until I zeroed in on the one I like. Test first is great if you know exactly the best way to program an explicitly defined program but I rarely get that kind of explicit definition and even if I did, how would I know that technique \"best fits\" that problem? I would know that if I had coded something very like it before but if I had, then I would just take the code I wrote before and make modifications to it. Creating tests that proves the code works is very hard, except in the simple cases and those probably don't need a test in any case. Tests should be created for code that is a \"keeper\" which, in my case, is only a small fraction of the code I write.",
            "id": "d1a7f32cab62d6717b57ab0c217de7ff"
          },
          {
            "type": "html",
            "text": "\nHow do you write a test for something that is constantly changing and you don't know what it's shape or structure will look like?",
            "id": "65ef1f562080d3958c39ab027ecaf5d0"
          },
          {
            "type": "html",
            "text": "-- [[David Clarkd]]",
            "id": "0d7454123a2917a351e99716534ee72e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nSystems created using [[Code Unit Test First]], [[Relentless Testing]] & [[Acceptance Test]]s might just be better designed than traditional systems. But they all certainly would support [[Code Unit Test First]] while using them better than our current set of systems.",
            "id": "716f1947a6c1283c12025d68091671c4"
          },
          {
            "type": "html",
            "text": "\nBut because so danged many of them were not, we are a little blind to what we could have available on the shelf.",
            "id": "f1ec508f794d970e83f208f678819d16"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nA list of ways that test-first programming can affect design:",
            "id": "3224336ae52ca7c353dec3c0b5d83333"
          },
          {
            "type": "html",
            "text": " Re-use is good. Test first code is born with two clients, not one. This makes adding a third client twice as easy.",
            "id": "8db12ae600653ee2f019829eae0d94eb"
          },
          {
            "type": "html",
            "text": " Refactoring test-first code results in equally tested code, permitting more aggressive refactorings ([[Refactor Mercilessly]]). Cruft is not allowed, and code is generally in better shape to accept more refactorings.",
            "id": "3113a8e3807c77e04a40cc6e59cf98a4"
          },
          {
            "type": "html",
            "text": " When paying attention during all of the little steps, you may discover patterns in your code.",
            "id": "d7f68c232743e8b10a7480477f50eacc"
          },
          {
            "type": "html",
            "text": " Test code is easy to write. It's usually a couple calls to the server object, then a list of assertions. Writing the easy code first makes writing the hard code easy.",
            "id": "761188e6f4385f2da44e26355ab7ea35"
          },
          {
            "type": "html",
            "text": " [[Design Patterns]] may be incremented in, not added all of a bunch up front.",
            "id": "e86b22c82adfed79876d035a187ed302"
          },
          {
            "type": "html",
            "text": " Test-first code is written Interface first. You think of the simplest interface that can show function.",
            "id": "a80a8daad3a7f60aaba3679ab0c3104e"
          },
          {
            "type": "html",
            "text": " Code tends to be less coupled. Effective unit tests only test one thing. To do this you have to move the irrelevant portions out of the way (e.g., [[Mock Object]]s). This forces out what might be a poor design choice.",
            "id": "5d3246dd79c8d855b340a3b44c494da8"
          },
          {
            "type": "html",
            "text": " [[Unit Test]]s stand as canonical & tested documentation for objects' usage. Developers read them, and do what they do in production code to the same objects. This keeps projects annealed and on track.",
            "id": "733f9754c3f99ed8043320cc73616ff9"
          },
          {
            "type": "html",
            "text": " When the developer has to write tests for what he is going to do, he is far less likely to add extraneous capabilities. This really puts a damper on developer driven scope creep.",
            "id": "14b3b282044c1f70b417ab4374adb984"
          },
          {
            "type": "html",
            "text": " Test First Design forces you to really think about what you are going to do. It gets you away from \"It seemed like a good idea at the time\" programming.",
            "id": "9fc92c29d489a632ef028c08c585d032"
          },
          {
            "type": "html",
            "text": "- This sure isn't a page for irresponsible people. <i>Is any programming activity for irresponsible people?</i> See [[Code And Fix]], [[Water Fall]].",
            "id": "6211d97fa79443b6409887fd014f39ee"
          },
          {
            "type": "html",
            "text": "- <i>Nope. the problem is:</i> <b>They don't know!</b> [[[Unskilled And Unaware Of It]]]",
            "id": "75c57d6160f3bb313b21fd93b18f1dc7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nI have been working my way through Kent's TDD book for a while now, and applying the principles quite rigorously. I am a real dullard sometimes, because it takes me a horribly long time to understand even simple stuff. I had probably been applying TDD for more than a week before I realized why it works so well (at least for me). There are three parts to this:",
            "id": "18e54845da8e5ccfa3b67034819267e2"
          },
          {
            "type": "html",
            "text": " The tests (obviously) help find bugs in the application code, and the micro-steps taken with TDD mean that any \"bugs\" are in the very code I have just been writing and hence which still has a relevant mental model in my small brain",
            "id": "d8d36d221b307342ce2a7761767e6a46"
          },
          {
            "type": "html",
            "text": " By doing the absolutely simplest thing in the application code in order to get each test to run, I often have small [[Aha Moment]]s, where I see that I am writing such overly concrete code (i.e. just enough to get the tests to work) that the tests (even though they run) cannot possibly be adequate to cover the \"real\" requirements. So to justify writing more abstract application code, I need to add more test cases that demand that abstraction, and this forces me to explore the requirement further. Therefore, the application code actually helps me debug the tests. That is, since the tests are the specification, feedback from the application code helps me debug the specification.",
            "id": "a984cf66fb9746434ece7b0993d71a7a"
          },
          {
            "type": "html",
            "text": " As I have these \"aha!\" moments (mentioned in 2 above) I follow Kent's practice of adding them to the [[To Do List]]. It took my stupid head quite some time to realize that the TODO list is actually a list of Micro-Stories, which I constantly prioritize (since I am the customer at this level). Following [[Alistair Cockburn]]'s insight that Stories are promises to have a conversation with the customer, I see, then, that the Micro-Stories in the TODO list are a promise to have a conversation with myself (and, here is the weird bit) to have a conversation with the code (since it gives me feedback - it tells me things - and TDD tunes me in to listening to the code).",
            "id": "857e8e303954c41991dedca1ea44dcee"
          },
          {
            "type": "html",
            "text": "-- [[Anthony Lauder]]",
            "id": "e8aad65e474153cc2123e301292b4744"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "<i>Test Driven Development</i> (TDD) by [[Kent Beck]] ",
            "id": "8b6a3369359373aa1ad13b6127165856"
          },
          {
            "type": "image",
            "url": "http://images.amazon.com/images/P/0321146530.01._PE_PI_SCMZZZZZZZ_.jpg",
            "text": "images.amazon.com",
            "id": "604d0256c75d0f71fb9c655670de51d1"
          },
          {
            "type": "html",
            "text": "\n",
            "id": "1a74d337984baf3488c826d5def3b51f"
          },
          {
            "type": "html",
            "text": "[ISBN: 0321146530] A Book, ",
            "id": "a8902bfaa301092a58b4bffd1584c76f"
          },
          {
            "type": "html",
            "text": "\nMailing list: [http://groups.yahoo.com/group/testdrivendevelopment groups.yahoo.com].",
            "id": "0714bbc7c30adc76082337f964d73889"
          },
          {
            "type": "html",
            "text": "<i>Test Driven Development</i> (TDD) by [[David Astels]] ",
            "id": "ced7dbc00f19b9cfe7cd754acd69e793"
          },
          {
            "type": "html",
            "text": "[ISBN: 0131016490] another book",
            "id": "85722e0ff10c5327b34869eebbe08286"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\n[[John Rusk]] worries <i>that one danger of [[Test Driven Development]] is that developers may <b>not</b> take that step that you take. I.e. developers may stay with overly concrete code that satisfies the tests but not the \"real\" requirements.</i>",
            "id": "89f707230fceab8b4309811733dd328a"
          },
          {
            "type": "html",
            "text": "<i>To look at it another way, I have always felt that it was dangerous to approach design with (only) particular test cases in mind, since its usually necessary to think about boundary cases, and other unusual cases.</i>",
            "id": "4e9b53162f6134740ddb11038112cc52"
          },
          {
            "type": "html",
            "text": "<i>How does XP address that danger? By encouraging developers to write sufficiently comprehensive tests? Or by relying on developers to take that step which you mention, which is saying, \"OK, this actually passes my tests, but its not really adequate for the real world because....\".</i>",
            "id": "f6eafc91689fd2586768a2f4c6f4bbf8"
          },
          {
            "type": "html",
            "text": "\nXP addresses that danger with [[Pair Programming]]. When obvious boundary cases are overlooked by the programmer driving the keyboard, the programmer acting as navigator points out the oversight. This is an excellent example of a case where a single practice is, by itself, insufficient to reasonably guarantee success but, in combination with a complementary practice, provides excellent results.",
            "id": "df3def3520cabbc03ebb200519f01f51"
          },
          {
            "type": "html",
            "text": "<i>[[Test First]] is a cool way to program source code. XP extends [[Test First]] to all scales of the project. One tests the entire project by frequently releasing it and collecting feedback.</i>",
            "id": "5f7e65bd6366450d1e95b4e6675d5cc4"
          },
          {
            "type": "html",
            "text": "<b>Q: What \"real\" requirements can you not test?</b>",
            "id": "3e95b032b4549f80ab15b322b3ef11f4"
          },
          {
            "type": "html",
            "text": " Those requirements which are not stated.",
            "id": "9c889145ead055a673f157ab14c89f0e"
          },
          {
            "type": "html",
            "text": " Requirements which require highly specialized, unaffordable, or non-existent support hardware to test. E.g., with hardware such as the Intellasys SEAforth chips, it's possible to generate pulses on an I/O pin as narrow as 6ns under software control. To <i>see</i> these pulses, you need an oscilloscope with a bandwidth no less than 166MHz, and to make sure their waveform is accurate, you need a bandwidth no less than 500MHz, with 1GHz strongly preferred. However, at 1GHz bandwidths, you're looking at <i>incredibly</i> expensive sampling oscilloscopes. Thus, if you cannot afford this kind of hardware, you pretty much have to take it on faith things are OK. Then, you need some means of feeding this waveform data back to the test framework PC (which may or may not be the PC running the actual test), which adds to the cost.",
            "id": "1935c7f9d9b0c3acdd3ebda50de57c7e"
          },
          {
            "type": "html",
            "text": "\nTDD cannot automatically fix algorithms; neither can any other technique. Where rigorous testing helps is ensuring that the details of your algorithm remain the same even if you refactor or add features. A test case can easily check _too_ much, and fail even if the production code would have worked. For example, suppose one step of an algorithm returns an array. A test could fail if that array is not sorted, even if the algorithm does not require the array, at that juncture, to be sorted.",
            "id": "b93c7f794457b0b73041dc3a08be1fea"
          },
          {
            "type": "html",
            "text": "\nThis is a <b><i>good</b></i> thing; it makes you stop, revert your change, and try again.",
            "id": "e38535929c3bfdc7846da0b7cf38bdfe"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nNote: here is the link to the pdf file on the yahoo groups area:",
            "id": "74ac6fc37c3e27f67826606c5bf3a373"
          },
          {
            "type": "html",
            "text": " [http://groups.yahoo.com/group/testdrivendevelopment/files/TDD17Jul2002.pdf groups.yahoo.com]",
            "id": "a1db3d5e75ab1c6864c15cd37c638a2e"
          },
          {
            "type": "html",
            "text": "\nI found this unexpectedly awkward to locate by searching, so I thought I'd drop the link in here. -- [[David Plumpton]]",
            "id": "53f9ce26d9c583850385b361b3d619c6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nI've sometimes been an advocate of test driven development, but my enthusiasm has dropped after I've noticed that [[Code Unit Test First]] goes heavily against prototyping. I prefer a style of coding where the division of responsibility between units and the interfaces live a lot in the beginning of the development cycle, and writing a test for those before the actual code is written will seriously hinder the speed of development and almost certainly end testing the wrong thing.",
            "id": "48474ac73f89e4af611bf2dc1524e824"
          },
          {
            "type": "html",
            "text": "\nAgreed. Please see my blog entry about adapting TDD for mere mortals at [http://agileskills2.org/blog/2010/02/07/tdd-adapted-for-mere-mortals/ agileskills2.org] -- [[Kent Tong]]",
            "id": "b79b99fbe0e76e143dc6448b820c8baf"
          },
          {
            "type": "html",
            "text": ": <i>Assuming you're not shipping the prototype, there's nothing particularly in conflict. The prototype is in itself a sort of design test. The trouble with prototypes is that they have this habit of becoming the product...</i>",
            "id": "a1a828a1a0102b780859e6aa7e8ac58d"
          },
          {
            "type": "html",
            "text": "[RE: prototypes becoming \"the\" product. Arrg.. I agree. <i>No reason for it to happen. TDD makes rewriting slops as clean code absurdly easy</i>]",
            "id": "bc75e54c235419c9ef4b77ea16d0f9d8"
          },
          {
            "type": "html",
            "text": "\nDesign is a lot more difficult than implementing a design. But [[Unit Test]]s explicitly require one to define the design before making it work.",
            "id": "acf233856c8ae825336ad0ed5f70e5c9"
          },
          {
            "type": "html",
            "text": "\nThere are other problems, too. Like OO methodology, the difficulties which test driven development helps with are sometimes caused by itself. Every extra line of code adds to the complexity of the program, and tests slow down serious refactoring. This is most apparent in hard-to-test things like GUI's, databases and web applications, which sometimes get restructured to allow for testing and get complicated a lot. -- [[Panu Kalliokoski]]",
            "id": "08ff12647e329455a52d7afc11f96af9"
          },
          {
            "type": "html",
            "text": "<i>[[Code Unit Test First]] goes heavily against prototyping? Strange, I haven't found that to be true, myself. Closer to the opposite, in fact - I start with a very thin shell of a [[Proto Type]], and as I make progress it fills in with real features. I wonder how what you actually do differs from what I actually do.</i>",
            "id": "458e38ff137c010ff0f3485aed2d3f65"
          },
          {
            "type": "html",
            "text": "\nStrongly agree. A big side benefit of [[Code Unit Test First]] that doesn't get enough attention is how it rearranges your thinking. Instead of thinking \"oh I'll need these accessors on these classes, etc\" you think in terms of use cases. And you end up with *exactly* what you need, nothing more and nothing less.",
            "id": "12ff1e302106c7f9034a6af171d38b56"
          },
          {
            "type": "html",
            "text": "<i>I find I have a huge increase in speed in all areas of development when I [[Code Unit Test First]]. I honestly believe that anyone who doesn't experience this is either busy knocking down [[Straw Man]]s, isn't doing it right, or hasn't really given it a chance.</i>",
            "id": "5314e5035b13572d988c77baf9e10d0b"
          },
          {
            "type": "html",
            "text": "\nTDDing GUIs is quite frustrating. It may be a lot easier if there were a GUI toolkit available that has been TDDed itself, from the ground up. Anyone interested in such a TDDedGuiFramework project?",
            "id": "09ce88759d20cedd6fee410ba4ac93cc"
          },
          {
            "type": "html",
            "text": "<i>You mean like [[Ruby On Rails]]? -- [[Phl Ip]]</i>",
            "id": "12dc1ee152ae92e425c706879741563b"
          },
          {
            "type": "html",
            "text": ":-) No, I mean a toolkit for standalone clients (or maybe a hybrid one, people have been experimenting with this already). Something like SWT, but a lot more intuitive :-)",
            "id": "43ca5e155405fd69956bb4fbe67e4b53"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nNote that some TDDers abuse [[Mock Object]]s. Dynamic mock systems like [http://classmock.sf.net classmock.sf.net] can make this too easy. A TDD design should be sufficiently decoupled that its native object work fine as stubs and test resources. They help to test other objects without runaway dependencies. One should mock the few remaining things which are too hard to adapt to testing, such as random numbers or filesystem errors.",
            "id": "91ad5c2617e900b3d481377a62098826"
          },
          {
            "type": "html",
            "text": "\nSome of us disagree with that view, see [http://www.mockobjects.com/files/mockrolesnotobjects.pdf www.mockobjects.com] for an alternative.",
            "id": "de1bfbbac71ff2fb315989adcefa75bc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nI'd like to revisit a comment that [[John Rusk]] made above:",
            "id": "b3e066b6446018cf9701213d7fa4e088"
          },
          {
            "type": "html",
            "text": "<i>It seems to me that one danger of [[Test Driven Development]] is that developers may _not_ take that step that you take. I.e. developers may stay with overly concrete code that satisfies the tests but not the \"real\" requirements.</i>",
            "id": "08c1f1d0adb131483a96e0c917e3a06e"
          },
          {
            "type": "html",
            "text": "\nSee [[Fake It Until You Make It]]",
            "id": "6274a4faf9f91ed547ddb0534f097457"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nThe principles of TDD can be applied quite well to analysis and design, also. There's a tutorial on Test-driven Analysis & Design at [http://www.parlezuml.com/tutorials/tdad/index_files/frame.htm www.parlezuml.com] which neatly introduces the ideas.",
            "id": "2008a6f20336f457dff18297dec09d17"
          },
          {
            "type": "html",
            "text": "-- [[Dave Chan]]",
            "id": "5f43abf66de630d5028eb650d5c5e3ac"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nWhat about extended the principles of TDD beyond testing, analysis, and design. How about using the principles also on user documentation? This idea is described in Purpose Driven Development (PDD) at [http://jacekratzinger.blogspot.com/2012/01/purpose-driven-development-pdd.html jacekratzinger.blogspot.com]",
            "id": "f820514afe284334347d6e1dc61e39a0"
          },
          {
            "type": "html",
            "text": "-- [[Jacek Ratzinger]]",
            "id": "83a583a716f6de4168f09d73b71b4161"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\"Roman Numerals\" is often held up as a good sample project to learn TDD. I know TDD but I'm bad at math, so I tried the project, and put its results here:",
            "id": "28dbbd0f53829afaa7b5958fd40fd4f0"
          },
          {
            "type": "html",
            "text": " [http://www.xpsd.org/cgi-bin/wiki?TestDrivenDevelopmentTutorialRomanNumerals www.xpsd.org]",
            "id": "1ecef6767b057b77ab5c0c9ef32ad418"
          },
          {
            "type": "html",
            "text": "-- [[Phl Ip]]",
            "id": "1ba81ec83e014b9728d499a375057dd6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "<shameless plug> Up to date info on tools and practices at [http://testdriven.com testdriven.com]",
            "id": "b12d4ae62b66bb17543616fef9be2578"
          },
          {
            "type": "html",
            "text": "-- [[David Vydra]]",
            "id": "a2bd974c3dd84d12e22153939ab6cd84"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nI found GNU/Unix command line option parsing to be a good TDD exercise as well. My results here:",
            "id": "9c7fc093652fada57051ce62280fd035"
          },
          {
            "type": "html",
            "text": " [http://home.comcast.net/~pholser/software/pholser-getopts.zip home.comcast.net] (3.5Mb download; 4.7Mb unpacked)",
            "id": "8503ca0f45eb608f620789f6c1d23d9d"
          },
          {
            "type": "html",
            "text": "-- [[Paul Holser]]",
            "id": "76b9c39587956e9faefac32ba0452eca"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "[[Organic Testing]] of the [[Tgp Methodology]] is one way to practice [[Test Driven Development]]. Organic Testing is an [[Automated Test]]s methodology that share resemblance to both [[Unit Test]] and [[Integration Test]]. Like [[Unit Test]], they are run by the developers whenever they want (before check-in). Unlike [[Unit Test]], only the framework for the test is provided by the programmers, while the actual data of the test is given by [[Business Professionals]]. In Organic testing like [[Integration Test]]s, in each run the whole software (or a whole module) is activated. -- [[Ori Inbar]]",
            "id": "336fa59a42815273fd2a268ab5be9afc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nAnother reference: article \"Improving Application Quality Using Test-Driven Development\" from Methods & Tools",
            "id": "9731fc4c59e562460a6ddd3cfc650a22"
          },
          {
            "type": "html",
            "text": "\n[http://www.methodsandtools.com/archive/archive.php?id=20 www.methodsandtools.com]",
            "id": "dfe18eff90fa031ca1fe5e2128fa578e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nBut what about [[Secure Design]]? [[Security As An Afterthought]] is a bad idea and it seems that test-driven development (and a number of other agile processes, though perhaps not all) has a bad habit of ignoring security except as test cases, which isn't always the best way to approach the problem. ",
            "id": "74532369e2e0c433299e3972072cf308"
          },
          {
            "type": "html",
            "text": "-- [[Kyle Maxwell]] ",
            "id": "0f34bb16e655f3711673796769117f87"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nHmmmm. Seems to me that TDD deals with security (as well as things like performance) just like any other functional requirement. You have a story (or task) explicitly stating what functionality is needed (e.g., user needs 2 passwords to login, which are stored in an LDAP server; or algorithm needs to perform 5000 calculations per second). You then write tests that will verify functionality. And then you write the functionality itself.",
            "id": "e4ea51bb1b5d91a4cc190a42286df9cc"
          },
          {
            "type": "html",
            "text": "\nAnd unlike traditional development, you now have regression tests to make sure that this functionality never gets broken. (i.e., if, due to subsequent coding, the security code gets broken, or the algorithm performance drops off, you'll have a broken test to alert you of that.)",
            "id": "8a9e2df933247833b5d3a413b396f9e7"
          },
          {
            "type": "html",
            "text": "-- [[David Rosenstrauch]]",
            "id": "69cfc444879f7f238b3aa9388f09fccb"
          },
          {
            "type": "html",
            "text": "\nOne of the reasons that security is hard is that security is not just a piece of functionality. Okay, there are things like passwords which are security features, but the rest of the code also has to not have security holes, which are [[Negative Requirements]]; ie, code must not do X.",
            "id": "34fc1273862a04b5bcac685fc295a9f3"
          },
          {
            "type": "html",
            "text": "\nThis is obvious in the case of 'must not overflow buffer', which TDD does address, but is less obvious in things like 'component X should not be able to affect component Y'. How do you test that? (I probably read this in 'Security Engineering', by Ross Anderson, which is now free on the web).",
            "id": "526da69e406353e221db4ecbfe6a3710"
          },
          {
            "type": "html",
            "text": "-- [[Alex Burr]] ",
            "id": "68c8d034c124855a132943ea35f290fe"
          },
          {
            "type": "html",
            "text": "<i>In the case of \"Component A must not affect Component B\", how would you evaluate this </i>without<i> test-driven development? If you can't formally define this requirement, then TDD is no better or worse than hoping for the best. (One answer in this case may be rule-based formal validation of the system, which is easy enough to plug into a TDD framework.)</i> -- [[Jevon Wright]]",
            "id": "b9967de9ae48c66b3257242e4b1a9e2d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "Some interesting info on test driven development from E. Dijkstra:",
            "id": "c56a41bfd848e2b518e0205971583e23"
          },
          {
            "type": "html",
            "text": " [http://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1012.PDF www.cs.utexas.edu]",
            "id": "591ccb70ee925e0953b9ca873b950b77"
          },
          {
            "type": "html",
            "text": " (above is from [http://www.cs.utexas.edu/users/EWD/index10xx.html www.cs.utexas.edu])",
            "id": "f1a87e72829f93fbd0b35ad0b4c25444"
          },
          {
            "type": "html",
            "text": "\nBit Torrent founder (Bram) uses test driven development, and thinks Formal methods suck:",
            "id": "ed9141e8e480f3d3a8ceebacce083db0"
          },
          {
            "type": "html",
            "text": " [http://z505.com/cgi-bin/qkcont/qkcont.cgi?p=Bittorrent-Founder-Wrong z505.com]",
            "id": "ba6a4918d803d0fc6cb3fce50f517ac4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "IEEE Software will publish a special issue on Test-Driven Development in July 2007. For more information, see [[Ieee Software Special Issue On Test Driven Development]]",
            "id": "703c5bd10d2828d3529477203d3fc30a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "Found this useful illustration of TDD in .NET (Flash screen cast)\n[http://www.parlezuml.com/tutorials/tdd.html www.parlezuml.com]",
            "id": "9443401a8775ffa08338dd915e9887d7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "I can't help to mention the awesomeness of [[Doc Test]] in Python.  Not only do you get TDD, but you get code documentation for free, as it integrates [[Doc Strings]] into every Module, Class, and Method.  I'd like to see TDD really integrated tightly into programming environments. [[Doc Strings]] are accessed via a built-in help() function and encourage a friendly development community. [[Doc Test]] goes further, encouraging smart design of tests within the [[Doc Strings]] themselves in ways that simultaneously teach the User what your method and class is supposed to do. Ideally, Interpreted environments should integrate a test() built-in.  Then, [[Doc Test]] could be removed and built into the interpreter environment with it`s companion function \"help()\". This would allow the \"add a test, get it to fail, and write code to pass\" cycle to attain a most friendly goal of [[Literate Programming]]. -- [[Mark Janssen]]",
            "id": "d274bb68e31289dce047864abf0e7b4c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nBDD (Behavior Driven Development) is a form of TDD (Test Driven Development) where the tests are specified through definition of desired Behaviors, as opposed to writing tests in code (the same code language used for the product). The BDD camp says that you use natural language to describe desired behaviour, and employ testing tools which translate the natural language behaviour specification into tests which validate the product code. This approach recognizes and attempts to address a couple of challenges with testing which I elaborate upon below.",
            "id": "dd04244c3edf5f9d08957729c2d3fa64"
          },
          {
            "type": "html",
            "text": "\nSee 'Cucumber' ([http://cukes.info/ cukes.info]) as one example of a BDD test toolkit.",
            "id": "5c3d36bae7aa7d3c6e57a74340bcdee9"
          },
          {
            "type": "html",
            "text": "\nOne strategy with BDD is that you employ test (SDT) developers with much different skills than your product (SDE) developers. You can thereby segregate SDT and SDE developers by skills. Another strategy is that your developers use different tools for product development from test development. This suggests that you use people with different skills (less product intensive skills, btw), to write tests (or the same folks using different skills). But when you choose TDD or BDD as a methodology practice, you need to consider (answer) the questions exposed below.",
            "id": "43d1b8e2cd2d065a7264f6ba011f7838"
          },
          {
            "type": "html",
            "text": "\nBuilding test code to automate the testing of your product code produces a regression problem. You want to avoid placing 'faith' in the production code, and ensure that the code has been tested (verified), but now you have moved your 'faith' into the test code.",
            "id": "1f1efc5b06a476fa659465d0c7820f69"
          },
          {
            "type": "html",
            "text": "\nThis regression problem is a challenge with testing, where you must provide tests which cover the requirements and features of your product, so you have moved (regressed) the problem of (potential) defects in the development into a problem with (potential) defects in the test code. You have now written more code (probably in the same language), but possibly replicated or moved the defect into test code. You are still placing faith, but now in your test code, rather than in your production code.",
            "id": "bfb6a1392dfc39a74ed1d469c2b9480f"
          },
          {
            "type": "html",
            "text": "\nOne strategy is to use SDT's to develop tests, and SDE's to develop products. This can help catch misunderstandings in requirements (win), but only increases the amount of code written, and thus the potential number of defects, adding personnel to develop these tests, and thus adding costs. And you now have a recruiting and motivation problem. You must staff SDE's to build products and SDT's to build tests.",
            "id": "70d07e13e9b383c4b3edeffc356504af"
          },
          {
            "type": "html",
            "text": "\nHowever, we can consider that by using different personnel, defects are statistically less likely to align between product code and test code, because we assume that the SDE's and SDT's are independent. We assume a stochastically independent defect generation (SDE's and SDT's are different people). Thus we expect them to generate defects in different places.",
            "id": "553a1293c794eded7258dcd353c8ba19"
          },
          {
            "type": "html",
            "text": "\nBut are these activities stochastically independent? We are relying upon this independence. But agile asks that one agile team combine developers writing production code and developers writing test code. So the same (hard) problems are viewed by the same team, and the same conceptual issues are tackled in code by the same pool of developers. Using different developers to write product and test code gains little practical independence, as developers (SDE or SDT) have essentially the same training and experience.",
            "id": "38826ecd6bd1cda1b1104373d5f5cef8"
          },
          {
            "type": "html",
            "text": "\nConsider the strategy that you require different training and experience from SDE and SDT. This regains some missing independence. But unless all developers (SDE and SDT) have essentially the same training, capabilities, and skills, they cannot perform interchangeably on an agile team. And developers undertake extensive training. And now you must separate developers by skill and role. Now you face the choice whether to use more skilled developers to write the product, or to write the tests? Using less skilled developers to write the product impairs your product. Using less skilled developers to write your tests means that you impair your tests. This reduces to a Faustian choice, do you effectively subvert your testing and quality process, or do you sacrifice your product development?",
            "id": "79f5ae2f7f954258806f325512a9d2b1"
          },
          {
            "type": "html",
            "text": "\nRevisit the recruiting and motivation problem. Suppose you decide to staff SDT's to build tests and SDE's to build products. You have introduced stratification and competition into your development team. Are you going to get equally qualified candidates for both SDE and SDT? Even with the different requirements? Assume that most developers want to advance their careers, and gain recognition and rewards, and become the best developers they can become.",
            "id": "673807b3b14f736b07e4b34ef79ed44b"
          },
          {
            "type": "html",
            "text": "\nWhich path will the best and the brightest want to pursue? Consider that Google hires less than 1% of applicants (lots of people want to work there, so they must want to pursue the 'best' career path). Joel Spolsky (co-founder, Fog Creek Software) writes a blog on software development, ([http://www.joelonsoftware.com/ www.joelonsoftware.com]), says that you should hire people who are \"Smart, and Get Things Done\".",
            "id": "b83014929fd98a1e29262f301b78e708"
          },
          {
            "type": "html",
            "text": "\nCan you effectively use the same people writing both product code and test code? And gain the stochastic independence testing needs?  Can you use people with different training and skills, and have them independently build tests? And not sacrifice product development on the altar of quality?",
            "id": "2a579faadaf3c08317eb6772f8dff913"
          },
          {
            "type": "html",
            "text": "\nThe BDD camp says that you use natural language to describe desired behaviour, which would employ developers with much different skills, and thereby segregate developers by skills. This suggests that you use people with different skills (less product intensive skills, btw), to write tests. This has been exposed as a suspect strategy, but assuming you choose TDD or BDD as a methodology practice, anyway. How do you achieve the best results?",
            "id": "0d7f2f6f9819d4eaafa8182d24a6fc2c"
          },
          {
            "type": "html",
            "text": "-- [[Chuck Cottrill]]",
            "id": "dc16bc6dfb3f35e55d361cb673718714"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "\nTDD in general and [[Behavior Driven Development]] in particular are firmly grounded in [[Hoare Triple]]. I find a useful parallel between a written [[Use Case]]‎ document and BDD Feature / Story Narrative.",
            "id": "a23a2bc9984f98131a7bfe768755435a"
          },
          {
            "type": "html",
            "text": "-- [[Martin Spamer]]",
            "id": "8c88328197bd8b88137da39f63e77269"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "See [[Test First User Interfaces]] [[Calvin And Hobbes Discuss Tdd]] [[Test Driven Analysis And Design]] [[Test Driven Developmenta Practical Guide]] [[Test Driven Development Challenges]] [[Test Driven Design Phase Shift]], [[Power Of Tdd]], [[Ieee Software Special Issue On Test Driven Development]], [[Behavior Driven Development]], [[Test Food Pyramid]]",
            "id": "7f55c5e87d5f3820651e1ca70d9e026c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc61c4e0aab81a440ce2adb8d38b8d98"
          },
          {
            "type": "html",
            "text": "[[Category Testing]] [[Category Book]] [[Category Test Driven Development]] [[Category Extreme Programming]]",
            "id": "a505dd8e73b90f4a982992bda69533c1"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?TestDrivenDevelopment c2.com]",
            "id": "04f773bd1ae7413753f2212c3b54f392"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1627419219484
    },
    {
      "type": "edit",
      "id": "0f0c58b17c7635a619b0f477a094d9f2",
      "item": {
        "type": "html",
        "text": "When you code, alternate these activities:",
        "id": "0f0c58b17c7635a619b0f477a094d9f2"
      },
      "date": 1628111255965
    },
    {
      "item": {
        "type": "factory",
        "id": "bed3abbc9fa8853e"
      },
      "id": "bed3abbc9fa8853e",
      "type": "add",
      "after": "04f773bd1ae7413753f2212c3b54f392",
      "date": 1628111258203
    },
    {
      "type": "edit",
      "id": "bed3abbc9fa8853e",
      "item": {
        "type": "markdown",
        "id": "bed3abbc9fa8853e",
        "text": "TDD was invented"
      },
      "date": 1628111268079
    },
    {
      "id": "bed3abbc9fa8853e",
      "type": "move",
      "order": [
        "274b6d072f9fc0029f5bd4a55f954fa4",
        "823ad45996ad870ddaebe940b7d1761f",
        "bed3abbc9fa8853e",
        "0f0c58b17c7635a619b0f477a094d9f2",
        "89c2460740d82ee743a519dc09035a54",
        "a4bd0bc48f402462359b4c149f137398",
        "a64c03d17e2795e4dac0a8681e5a7782",
        "4a03d215b08eb79fffcf4c308d2d01df",
        "3e925b6705536cb30ba942e433bc9f4e",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "f64644bdec4c3d497780182ece9ad87f",
        "fc3d5b21ea21c14fe44638f616ca8603",
        "eb8148172a9c266cd2ee6349c653758d",
        "206d22b6adfb7e736492f6b013d4b357",
        "2e083c7b8426ab10f7ed21aa61dd6e6a",
        "7a008f4897f2c81396ab70db4dbfd2a7",
        "9243a580a2c3b883354a87fd1fbd6a26",
        "e4b896745a8c88b9c056bbe9d371e41f",
        "a321fecd0f97d91eca182d21c417c1f5",
        "fa99311c51a57f3cee6bab83e35bbd95",
        "a96a0acf33c38c6b5cf5c07adf7ccef9",
        "c170e3d08e49fa0588d8fc44c0ee1304",
        "5aa025427fbe7057c54f30e894165e2c",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "88d5278562dbe7367b6508c9c47bc5ab",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "d1a7f32cab62d6717b57ab0c217de7ff",
        "65ef1f562080d3958c39ab027ecaf5d0",
        "0d7454123a2917a351e99716534ee72e",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "716f1947a6c1283c12025d68091671c4",
        "f1ec508f794d970e83f208f678819d16",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "3224336ae52ca7c353dec3c0b5d83333",
        "8db12ae600653ee2f019829eae0d94eb",
        "3113a8e3807c77e04a40cc6e59cf98a4",
        "d7f68c232743e8b10a7480477f50eacc",
        "761188e6f4385f2da44e26355ab7ea35",
        "e86b22c82adfed79876d035a187ed302",
        "a80a8daad3a7f60aaba3679ab0c3104e",
        "5d3246dd79c8d855b340a3b44c494da8",
        "733f9754c3f99ed8043320cc73616ff9",
        "14b3b282044c1f70b417ab4374adb984",
        "9fc92c29d489a632ef028c08c585d032",
        "6211d97fa79443b6409887fd014f39ee",
        "75c57d6160f3bb313b21fd93b18f1dc7",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "18e54845da8e5ccfa3b67034819267e2",
        "d8d36d221b307342ce2a7761767e6a46",
        "a984cf66fb9746434ece7b0993d71a7a",
        "857e8e303954c41991dedca1ea44dcee",
        "e8aad65e474153cc2123e301292b4744",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "8b6a3369359373aa1ad13b6127165856",
        "604d0256c75d0f71fb9c655670de51d1",
        "1a74d337984baf3488c826d5def3b51f",
        "a8902bfaa301092a58b4bffd1584c76f",
        "0714bbc7c30adc76082337f964d73889",
        "ced7dbc00f19b9cfe7cd754acd69e793",
        "85722e0ff10c5327b34869eebbe08286",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "89f707230fceab8b4309811733dd328a",
        "4e9b53162f6134740ddb11038112cc52",
        "f6eafc91689fd2586768a2f4c6f4bbf8",
        "df3def3520cabbc03ebb200519f01f51",
        "5f7e65bd6366450d1e95b4e6675d5cc4",
        "3e95b032b4549f80ab15b322b3ef11f4",
        "9c889145ead055a673f157ab14c89f0e",
        "1935c7f9d9b0c3acdd3ebda50de57c7e",
        "b93c7f794457b0b73041dc3a08be1fea",
        "e38535929c3bfdc7846da0b7cf38bdfe",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "74ac6fc37c3e27f67826606c5bf3a373",
        "a1db3d5e75ab1c6864c15cd37c638a2e",
        "53f9ce26d9c583850385b361b3d619c6",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "48474ac73f89e4af611bf2dc1524e824",
        "b79b99fbe0e76e143dc6448b820c8baf",
        "a1a828a1a0102b780859e6aa7e8ac58d",
        "bc75e54c235419c9ef4b77ea16d0f9d8",
        "acf233856c8ae825336ad0ed5f70e5c9",
        "08ff12647e329455a52d7afc11f96af9",
        "458e38ff137c010ff0f3485aed2d3f65",
        "12ff1e302106c7f9034a6af171d38b56",
        "5314e5035b13572d988c77baf9e10d0b",
        "09ce88759d20cedd6fee410ba4ac93cc",
        "12dc1ee152ae92e425c706879741563b",
        "43ca5e155405fd69956bb4fbe67e4b53",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "91ad5c2617e900b3d481377a62098826",
        "de1bfbbac71ff2fb315989adcefa75bc",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "b3e066b6446018cf9701213d7fa4e088",
        "08c1f1d0adb131483a96e0c917e3a06e",
        "6274a4faf9f91ed547ddb0534f097457",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "2008a6f20336f457dff18297dec09d17",
        "5f43abf66de630d5028eb650d5c5e3ac",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "f820514afe284334347d6e1dc61e39a0",
        "83a583a716f6de4168f09d73b71b4161",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "28dbbd0f53829afaa7b5958fd40fd4f0",
        "1ecef6767b057b77ab5c0c9ef32ad418",
        "1ba81ec83e014b9728d499a375057dd6",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "b12d4ae62b66bb17543616fef9be2578",
        "a2bd974c3dd84d12e22153939ab6cd84",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "9c7fc093652fada57051ce62280fd035",
        "8503ca0f45eb608f620789f6c1d23d9d",
        "76b9c39587956e9faefac32ba0452eca",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "336fa59a42815273fd2a268ab5be9afc",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "9731fc4c59e562460a6ddd3cfc650a22",
        "dfe18eff90fa031ca1fe5e2128fa578e",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "74532369e2e0c433299e3972072cf308",
        "0f34bb16e655f3711673796769117f87",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "e4ea51bb1b5d91a4cc190a42286df9cc",
        "8a9e2df933247833b5d3a413b396f9e7",
        "69cfc444879f7f238b3aa9388f09fccb",
        "34fc1273862a04b5bcac685fc295a9f3",
        "526da69e406353e221db4ecbfe6a3710",
        "68c8d034c124855a132943ea35f290fe",
        "b9967de9ae48c66b3257242e4b1a9e2d",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "c56a41bfd848e2b518e0205971583e23",
        "591ccb70ee925e0953b9ca873b950b77",
        "f1a87e72829f93fbd0b35ad0b4c25444",
        "ed9141e8e480f3d3a8ceebacce083db0",
        "ba6a4918d803d0fc6cb3fce50f517ac4",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "703c5bd10d2828d3529477203d3fc30a",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "9443401a8775ffa08338dd915e9887d7",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "d274bb68e31289dce047864abf0e7b4c",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "dd04244c3edf5f9d08957729c2d3fa64",
        "5c3d36bae7aa7d3c6e57a74340bcdee9",
        "43d1b8e2cd2d065a7264f6ba011f7838",
        "1f1efc5b06a476fa659465d0c7820f69",
        "bfb6a1392dfc39a74ed1d469c2b9480f",
        "70d07e13e9b383c4b3edeffc356504af",
        "553a1293c794eded7258dcd353c8ba19",
        "38826ecd6bd1cda1b1104373d5f5cef8",
        "79f5ae2f7f954258806f325512a9d2b1",
        "673807b3b14f736b07e4b34ef79ed44b",
        "b83014929fd98a1e29262f301b78e708",
        "2a579faadaf3c08317eb6772f8dff913",
        "0d7f2f6f9819d4eaafa8182d24a6fc2c",
        "dc16bc6dfb3f35e55d361cb673718714",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "a23a2bc9984f98131a7bfe768755435a",
        "8c88328197bd8b88137da39f63e77269",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "7f55c5e87d5f3820651e1ca70d9e026c",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "a505dd8e73b90f4a982992bda69533c1",
        "04f773bd1ae7413753f2212c3b54f392"
      ],
      "date": 1628111286396
    },
    {
      "type": "edit",
      "id": "bed3abbc9fa8853e",
      "item": {
        "type": "markdown",
        "id": "bed3abbc9fa8853e",
        "text": "TDD was invented in Smalltalk via the introduction of the SUnit test library"
      },
      "date": 1628111299504
    },
    {
      "id": "274b6d072f9fc0029f5bd4a55f954fa4",
      "type": "move",
      "order": [
        "823ad45996ad870ddaebe940b7d1761f",
        "bed3abbc9fa8853e",
        "0f0c58b17c7635a619b0f477a094d9f2",
        "274b6d072f9fc0029f5bd4a55f954fa4",
        "89c2460740d82ee743a519dc09035a54",
        "a4bd0bc48f402462359b4c149f137398",
        "a64c03d17e2795e4dac0a8681e5a7782",
        "4a03d215b08eb79fffcf4c308d2d01df",
        "3e925b6705536cb30ba942e433bc9f4e",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "f64644bdec4c3d497780182ece9ad87f",
        "fc3d5b21ea21c14fe44638f616ca8603",
        "eb8148172a9c266cd2ee6349c653758d",
        "206d22b6adfb7e736492f6b013d4b357",
        "2e083c7b8426ab10f7ed21aa61dd6e6a",
        "7a008f4897f2c81396ab70db4dbfd2a7",
        "9243a580a2c3b883354a87fd1fbd6a26",
        "e4b896745a8c88b9c056bbe9d371e41f",
        "a321fecd0f97d91eca182d21c417c1f5",
        "fa99311c51a57f3cee6bab83e35bbd95",
        "a96a0acf33c38c6b5cf5c07adf7ccef9",
        "c170e3d08e49fa0588d8fc44c0ee1304",
        "5aa025427fbe7057c54f30e894165e2c",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "88d5278562dbe7367b6508c9c47bc5ab",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "d1a7f32cab62d6717b57ab0c217de7ff",
        "65ef1f562080d3958c39ab027ecaf5d0",
        "0d7454123a2917a351e99716534ee72e",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "716f1947a6c1283c12025d68091671c4",
        "f1ec508f794d970e83f208f678819d16",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "3224336ae52ca7c353dec3c0b5d83333",
        "8db12ae600653ee2f019829eae0d94eb",
        "3113a8e3807c77e04a40cc6e59cf98a4",
        "d7f68c232743e8b10a7480477f50eacc",
        "761188e6f4385f2da44e26355ab7ea35",
        "e86b22c82adfed79876d035a187ed302",
        "a80a8daad3a7f60aaba3679ab0c3104e",
        "5d3246dd79c8d855b340a3b44c494da8",
        "733f9754c3f99ed8043320cc73616ff9",
        "14b3b282044c1f70b417ab4374adb984",
        "9fc92c29d489a632ef028c08c585d032",
        "6211d97fa79443b6409887fd014f39ee",
        "75c57d6160f3bb313b21fd93b18f1dc7",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "18e54845da8e5ccfa3b67034819267e2",
        "d8d36d221b307342ce2a7761767e6a46",
        "a984cf66fb9746434ece7b0993d71a7a",
        "857e8e303954c41991dedca1ea44dcee",
        "e8aad65e474153cc2123e301292b4744",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "8b6a3369359373aa1ad13b6127165856",
        "604d0256c75d0f71fb9c655670de51d1",
        "1a74d337984baf3488c826d5def3b51f",
        "a8902bfaa301092a58b4bffd1584c76f",
        "0714bbc7c30adc76082337f964d73889",
        "ced7dbc00f19b9cfe7cd754acd69e793",
        "85722e0ff10c5327b34869eebbe08286",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "89f707230fceab8b4309811733dd328a",
        "4e9b53162f6134740ddb11038112cc52",
        "f6eafc91689fd2586768a2f4c6f4bbf8",
        "df3def3520cabbc03ebb200519f01f51",
        "5f7e65bd6366450d1e95b4e6675d5cc4",
        "3e95b032b4549f80ab15b322b3ef11f4",
        "9c889145ead055a673f157ab14c89f0e",
        "1935c7f9d9b0c3acdd3ebda50de57c7e",
        "b93c7f794457b0b73041dc3a08be1fea",
        "e38535929c3bfdc7846da0b7cf38bdfe",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "74ac6fc37c3e27f67826606c5bf3a373",
        "a1db3d5e75ab1c6864c15cd37c638a2e",
        "53f9ce26d9c583850385b361b3d619c6",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "48474ac73f89e4af611bf2dc1524e824",
        "b79b99fbe0e76e143dc6448b820c8baf",
        "a1a828a1a0102b780859e6aa7e8ac58d",
        "bc75e54c235419c9ef4b77ea16d0f9d8",
        "acf233856c8ae825336ad0ed5f70e5c9",
        "08ff12647e329455a52d7afc11f96af9",
        "458e38ff137c010ff0f3485aed2d3f65",
        "12ff1e302106c7f9034a6af171d38b56",
        "5314e5035b13572d988c77baf9e10d0b",
        "09ce88759d20cedd6fee410ba4ac93cc",
        "12dc1ee152ae92e425c706879741563b",
        "43ca5e155405fd69956bb4fbe67e4b53",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "91ad5c2617e900b3d481377a62098826",
        "de1bfbbac71ff2fb315989adcefa75bc",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "b3e066b6446018cf9701213d7fa4e088",
        "08c1f1d0adb131483a96e0c917e3a06e",
        "6274a4faf9f91ed547ddb0534f097457",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "2008a6f20336f457dff18297dec09d17",
        "5f43abf66de630d5028eb650d5c5e3ac",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "f820514afe284334347d6e1dc61e39a0",
        "83a583a716f6de4168f09d73b71b4161",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "28dbbd0f53829afaa7b5958fd40fd4f0",
        "1ecef6767b057b77ab5c0c9ef32ad418",
        "1ba81ec83e014b9728d499a375057dd6",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "b12d4ae62b66bb17543616fef9be2578",
        "a2bd974c3dd84d12e22153939ab6cd84",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "9c7fc093652fada57051ce62280fd035",
        "8503ca0f45eb608f620789f6c1d23d9d",
        "76b9c39587956e9faefac32ba0452eca",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "336fa59a42815273fd2a268ab5be9afc",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "9731fc4c59e562460a6ddd3cfc650a22",
        "dfe18eff90fa031ca1fe5e2128fa578e",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "74532369e2e0c433299e3972072cf308",
        "0f34bb16e655f3711673796769117f87",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "e4ea51bb1b5d91a4cc190a42286df9cc",
        "8a9e2df933247833b5d3a413b396f9e7",
        "69cfc444879f7f238b3aa9388f09fccb",
        "34fc1273862a04b5bcac685fc295a9f3",
        "526da69e406353e221db4ecbfe6a3710",
        "68c8d034c124855a132943ea35f290fe",
        "b9967de9ae48c66b3257242e4b1a9e2d",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "c56a41bfd848e2b518e0205971583e23",
        "591ccb70ee925e0953b9ca873b950b77",
        "f1a87e72829f93fbd0b35ad0b4c25444",
        "ed9141e8e480f3d3a8ceebacce083db0",
        "ba6a4918d803d0fc6cb3fce50f517ac4",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "703c5bd10d2828d3529477203d3fc30a",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "9443401a8775ffa08338dd915e9887d7",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "d274bb68e31289dce047864abf0e7b4c",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "dd04244c3edf5f9d08957729c2d3fa64",
        "5c3d36bae7aa7d3c6e57a74340bcdee9",
        "43d1b8e2cd2d065a7264f6ba011f7838",
        "1f1efc5b06a476fa659465d0c7820f69",
        "bfb6a1392dfc39a74ed1d469c2b9480f",
        "70d07e13e9b383c4b3edeffc356504af",
        "553a1293c794eded7258dcd353c8ba19",
        "38826ecd6bd1cda1b1104373d5f5cef8",
        "79f5ae2f7f954258806f325512a9d2b1",
        "673807b3b14f736b07e4b34ef79ed44b",
        "b83014929fd98a1e29262f301b78e708",
        "2a579faadaf3c08317eb6772f8dff913",
        "0d7f2f6f9819d4eaafa8182d24a6fc2c",
        "dc16bc6dfb3f35e55d361cb673718714",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "a23a2bc9984f98131a7bfe768755435a",
        "8c88328197bd8b88137da39f63e77269",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "7f55c5e87d5f3820651e1ca70d9e026c",
        "dc61c4e0aab81a440ce2adb8d38b8d98",
        "a505dd8e73b90f4a982992bda69533c1",
        "04f773bd1ae7413753f2212c3b54f392"
      ],
      "date": 1628111304653
    },
    {
      "type": "edit",
      "id": "bed3abbc9fa8853e",
      "item": {
        "type": "markdown",
        "id": "bed3abbc9fa8853e",
        "text": "TDD was invented in Smalltalk via the introduction of the SUnit test library."
      },
      "date": 1628111363150
    }
  ]
}