{
  "title": "2023-05-16",
  "story": [
    {
      "type": "paragraph",
      "id": "e5eae3a078ccc07a",
      "text": "â‡’ [[AST]] for any arbitrary programming language or IR [https://stackoverflow.com/questions/3868938/ast-for-any-arbitrary-programming-language-or-ir/3881982#3881982 stackoverflow]"
    },
    {
      "type": "paragraph",
      "id": "cb415f7a52c5f70d",
      "text": "Natural Language Parsing as Statistical Pattern Recognition [https://arxiv.org/abs/cmp-lg/9405009 arxiv]"
    },
    {
      "type": "paragraph",
      "id": "38851df7c9ae4f4f",
      "text": "Traditional natural language parsers are based on rewrite rule systems developed in an arduous, time-consuming manner by grammarians. A majority of the grammarian's efforts are devoted to the disambiguation process, first hypothesizing rules which dictate constituent categories and relationships among words in ambiguous sentences, and then seeking exceptions and corrections to these rules.\nIn this work, I propose an automatic method for acquiring a statistical parser from a set of parsed sentences which takes advantage of some initial linguistic input, but avoids the pitfalls of the iterative and seemingly endless grammar development process. Based on distributionally-derived and linguistically-based features of language, this parser acquires a set of statistical decision trees which assign a probability distribution on the space of parse trees given the input sentence. These decision trees take advantage of significant amount of contextual information, potentially including all of the lexical information in the sentence, to produce highly accurate statistical models of the disambiguation process. By basing the disambiguation criteria selection on entropy reduction rather than human intuition, this parser development method is able to consider more sentences than a human grammarian can when making individual disambiguation rules.\nIn experiments between a parser, acquired using this statistical framework, and a grammarian's rule-based parser, developed over a ten-year period, both using the same training material and test sentences, the decision tree parser significantly outperformed the grammar-based parser on the accuracy measure which the grammarian was trying to maximize, achieving an accuracy of 78% compared to the grammar-based parser's 69%."
    },
    {
      "type": "paragraph",
      "id": "2a97c6fd35f3aa80",
      "text": "â‡’ [[Decision Tree Parser]]"
    },
    {
      "type": "paragraph",
      "id": "5aba2f4567469bda",
      "text": "PEGs, Packrats and Parser Combinators [https://www.oscar.nierstrasz.org/teaching/2023-04-06-PEGs page]"
    },
    {
      "type": "paragraph",
      "id": "838cc5d781dbb921",
      "text": "NIERSTRASZ, Oscar, 2023. PEGs, Packrats and Parser Combinators. [[Oscar Nierstrasz]]. Online. 6 April 2023. [AccessedÂ 28Â AprilÂ 2023]. Available from: https://www.oscar.nierstrasz.org/teaching/2023-04-06-PEGs This was a guest lecture held on Thursday April 6 for the Masters course on Compiler Construction offered by [[Timo Kehrer]] at the University of Bern.The lecture provides an introduction to Parsing Expression Grammars, as a well as a live demo using the PetitParser framework to build an interpreter for a toy programming language.\n"
    },
    {
      "type": "video",
      "id": "f6af47a52ab1e1f4",
      "text": "YOUTUBE MbzE_PonAfQ\nPEGs, Packrats and Parser Combinators â€” Part 1: An Introduction to PEGs and PetitParser "
    },
    {
      "type": "pagefold",
      "id": "6e35bd93633fceff",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "0ab3a3f3c43754a7",
      "text": "[https://youtu.be/MbzE_PonAfQ?t=2445 video] â€“ Composing PetitParser parsers in a script [â€¦] a Symbol as a Parser"
    },
    {
      "type": "paragraph",
      "id": "f64a8eda39a6e54a",
      "text": "â‡’ [[gt]]: clone and install the latest code [https://gtoolkit.com/download/ page]"
    },
    {
      "type": "code",
      "id": "c4f06fb9584c21a0",
      "text": "curl https://dl.feenk.com/scripts/mac.sh | bash"
    },
    {
      "type": "code",
      "id": "a8cf640f41ebee56",
      "text": "[â€¦]\nðŸ”¨ Building Glamorous Toolkit...\nError: Command \"/Users/rgb/gt/glamoroustoolkit/GlamorousToolkit.app/Contents/MacOS/GlamorousToolkit-cli\" \"/Users/rgb/gt/glamoroustoolkit/GlamorousToolkit.image\" \"st\" \"--quit\" \"--save\" \"\" \"load-gt-main.st\" failed. See install.log or install-errors.log for more info"
    },
    {
      "type": "paragraph",
      "id": "bfdfefc9e6d1595d",
      "text": "Note: ssh-credentials.st needs to be available in ~/Library/Preferences/pharo:"
    },
    {
      "type": "code",
      "id": "fb9cf45f5ffeeaa6",
      "text": "| credentials |\ncredentials := IceSshCredentials new\n    host:  #'*';\n    username: 'git';\n    publicKey: '/Users/rgb/.ssh/id_ecdsa.pub';\n    privateKey: '/Users/rgb/.ssh/id_ecdsa';\n    yourself.\nIceCredentialStore current\n    storeSshCredential: credentials\n    forHostname: credentials host.\nIceCredentialsProvider useCustomSsh: true.\n"
    },
    {
      "type": "paragraph",
      "id": "5dc06dcfb0ae6d9b",
      "text": "â‡’ [[IceSshCredentials]]: [[connect]] to a git repository via ssh/scp."
    },
    {
      "type": "pagefold",
      "id": "586fc78f1989c74c",
      "text": "~"
    },
    {
      "type": "reference",
      "id": "83f2662f938b4a65",
      "site": "code.fed.wiki.org",
      "slug": "remote-database-schema-migration",
      "title": "Remote Database Schema Migration",
      "text": "Ward was sure that they would not get the schema for [[WyCash Plus]] right on the first try. He was familiar with the object migration mechanisms of Smaltalk-80. He designed a version that could serve them in a commercial software distribution environment."
    },
    {
      "type": "paragraph",
      "id": "7043172fc12e8bdc",
      "text": "â‡’ [[record]] mutation vectors for each version to the present."
    },
    {
      "type": "paragraph",
      "id": "dd73dd5fe59228ff",
      "text": "How to record mutation vectors for object migration in object-oriented programming languages like Smalltalk?"
    },
    {
      "type": "pagefold",
      "id": "fa4916f4d37b4eb4",
      "text": "chat.openai"
    },
    {
      "type": "mathjax",
      "id": "a1bd5f4297606ec5",
      "text": "In Smalltalk, you can record mutation vectors for object migration using the concept of \"change sets.\" Change sets are a mechanism in Smalltalk that allows you to track and manage changes to the code and the state of objects. They can be used to capture mutations made to objects, including their data and behavior, and apply those changes to another Smalltalk environment.\n"
    },
    {
      "type": "paragraph",
      "id": "0f1790180e923521",
      "text": "Here's a general approach to recording mutation vectors for object migration in Smalltalk using change sets:\n\n"
    },
    {
      "type": "paragraph",
      "id": "5acf9183f9671374",
      "text": "1. Create a new change set: In your Smalltalk development environment, create a new change set dedicated to tracking the mutations for the object migration. Change sets are typically represented as collections of code changes.\n"
    },
    {
      "type": "paragraph",
      "id": "9c4cd0f7313c9285",
      "text": "2. Identify the objects to be migrated: Determine which objects you want to migrate from one Smalltalk environment to another. These objects should be self-contained, with all the necessary data and behavior encapsulated within them.\n"
    },
    {
      "type": "paragraph",
      "id": "0085d9e96dd7fb17",
      "text": "3. Track mutations in the change set: As you make changes to the objects, such as modifying instance variables or adding/removing methods, ensure that these changes are recorded in the dedicated change set. This can be done by adding the code snippets representing these changes to the change set.\n"
    },
    {
      "type": "paragraph",
      "id": "de3f9fb9c8718599",
      "text": "4. Capture object state: To record the complete state of an object, including its instance variables, you can define methods on the object that return its state as a dictionary or any suitable data structure. You can then invoke these methods and store the resulting state in the change set.\n"
    },
    {
      "type": "paragraph",
      "id": "f90a873680ac27a9",
      "text": "5. Serialize the change set: Once you have recorded all the mutations related to the object migration, you can serialize the change set. This step involves converting the change set into a format that can be easily transferred to another Smalltalk environment. Smalltalk provides built-in mechanisms for serialization, such as saving the change set as a file.\n"
    },
    {
      "type": "paragraph",
      "id": "4f423c4246b1775d",
      "text": "6. Migrate the change set: Transfer the serialized change set to the target Smalltalk environment where you want to apply the recorded mutations.\n"
    },
    {
      "type": "paragraph",
      "id": "03d76d54be1c3b44",
      "text": "7. Apply the change set: Load the change set into the target Smalltalk environment and apply the recorded mutations to the appropriate objects. The specific steps for applying the change set may vary depending on the Smalltalk implementation you're using.\n"
    },
    {
      "type": "paragraph",
      "id": "a2949fa5d77f314a",
      "text": "By following these steps, you can record mutation vectors for object migration in Smalltalk using change sets. Change sets provide a convenient way to track and manage changes, making it easier to migrate objects between Smalltalk environments while preserving their state and behavior."
    },
    {
      "type": "pagefold",
      "id": "eb6b36e8a49a46af",
      "text": "End of chat.openai"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2023-05-16",
        "story": []
      },
      "date": 1684210039158
    },
    {
      "item": {
        "type": "factory",
        "id": "e5eae3a078ccc07a"
      },
      "id": "e5eae3a078ccc07a",
      "type": "add",
      "date": 1684210041073
    },
    {
      "type": "edit",
      "id": "e5eae3a078ccc07a",
      "item": {
        "type": "paragraph",
        "id": "e5eae3a078ccc07a",
        "text": "AST for any arbitrary programming language or IR"
      },
      "date": 1684210045830
    },
    {
      "type": "edit",
      "id": "e5eae3a078ccc07a",
      "item": {
        "type": "paragraph",
        "id": "e5eae3a078ccc07a",
        "text": "â‡’ [[AST]] for any arbitrary programming language or IR [https://stackoverflow.com/questions/3868938/ast-for-any-arbitrary-programming-language-or-ir/3881982#3881982 stackoverflow]"
      },
      "date": 1684210142462
    },
    {
      "item": {
        "type": "factory",
        "id": "cb415f7a52c5f70d"
      },
      "id": "cb415f7a52c5f70d",
      "type": "add",
      "after": "e5eae3a078ccc07a",
      "date": 1684210863360
    },
    {
      "type": "edit",
      "id": "cb415f7a52c5f70d",
      "item": {
        "type": "paragraph",
        "id": "cb415f7a52c5f70d",
        "text": "Natural Language Parsing as Statistical Pattern Recognition"
      },
      "date": 1684210868260
    },
    {
      "type": "edit",
      "id": "cb415f7a52c5f70d",
      "item": {
        "type": "paragraph",
        "id": "cb415f7a52c5f70d",
        "text": "Natural Language Parsing as Statistical Pattern Recognition [https://arxiv.org/abs/cmp-lg/9405009 arxiv]"
      },
      "date": 1684210882133
    },
    {
      "item": {
        "type": "factory",
        "id": "38851df7c9ae4f4f"
      },
      "id": "38851df7c9ae4f4f",
      "type": "add",
      "after": "cb415f7a52c5f70d",
      "date": 1684210969847
    },
    {
      "type": "edit",
      "id": "38851df7c9ae4f4f",
      "item": {
        "type": "paragraph",
        "id": "38851df7c9ae4f4f",
        "text": "Traditional natural language parsers are based on rewrite rule systems developed in an arduous, time-consuming manner by grammarians. A majority of the grammarian's efforts are devoted to the disambiguation process, first hypothesizing rules which dictate constituent categories and relationships among words in ambiguous sentences, and then seeking exceptions and corrections to these rules.\nIn this work, I propose an automatic method for acquiring a statistical parser from a set of parsed sentences which takes advantage of some initial linguistic input, but avoids the pitfalls of the iterative and seemingly endless grammar development process. Based on distributionally-derived and linguistically-based features of language, this parser acquires a set of statistical decision trees which assign a probability distribution on the space of parse trees given the input sentence. These decision trees take advantage of significant amount of contextual information, potentially including all of the lexical information in the sentence, to produce highly accurate statistical models of the disambiguation process. By basing the disambiguation criteria selection on entropy reduction rather than human intuition, this parser development method is able to consider more sentences than a human grammarian can when making individual disambiguation rules.\nIn experiments between a parser, acquired using this statistical framework, and a grammarian's rule-based parser, developed over a ten-year period, both using the same training material and test sentences, the decision tree parser significantly outperformed the grammar-based parser on the accuracy measure which the grammarian was trying to maximize, achieving an accuracy of 78% compared to the grammar-based parser's 69%."
      },
      "date": 1684210972264
    },
    {
      "item": {
        "type": "factory",
        "id": "2a97c6fd35f3aa80"
      },
      "id": "2a97c6fd35f3aa80",
      "type": "add",
      "after": "38851df7c9ae4f4f",
      "date": 1684211269642
    },
    {
      "type": "edit",
      "id": "2a97c6fd35f3aa80",
      "item": {
        "type": "paragraph",
        "id": "2a97c6fd35f3aa80",
        "text": "â‡’ [[Decision Tree Parser]]"
      },
      "date": 1684211285101
    },
    {
      "type": "add",
      "id": "5aba2f4567469bda",
      "item": {
        "type": "paragraph",
        "id": "5aba2f4567469bda",
        "text": "PEGs, Packrats and Parser Combinators"
      },
      "after": "2a97c6fd35f3aa80",
      "date": 1684215459491
    },
    {
      "type": "edit",
      "id": "5aba2f4567469bda",
      "item": {
        "type": "paragraph",
        "id": "5aba2f4567469bda",
        "text": "PEGs, Packrats and Parser Combinators [https://www.oscar.nierstrasz.org/teaching/2023-04-06-PEGs pae]"
      },
      "date": 1684216956233
    },
    {
      "type": "edit",
      "id": "5aba2f4567469bda",
      "item": {
        "type": "paragraph",
        "id": "5aba2f4567469bda",
        "text": "PEGs, Packrats and Parser Combinators [https://www.oscar.nierstrasz.org/teaching/2023-04-06-PEGs page]"
      },
      "date": 1684217154776
    },
    {
      "type": "add",
      "id": "838cc5d781dbb921",
      "item": {
        "type": "paragraph",
        "id": "838cc5d781dbb921",
        "text": "\nNIERSTRASZ, Oscar, 2023. PEGs, Packrats and Parser Combinators. Oscar Nierstrasz. Online. 6 April 2023. [AccessedÂ 28Â AprilÂ 2023]. Available from: https://www.oscar.nierstrasz.org/teaching/2023-04-06-PEGsThis was a guest lecture held on Thursday April 6 for the Masters course on Compiler Construction offered by Timo Kehrer at the University of Bern.The lecture provides an introduction to Parsing Expression Grammars, as a well as a live demo using the PetitParser framework to build an interpreter for a toy programming language.\n"
      },
      "after": "5aba2f4567469bda",
      "date": 1684217156406
    },
    {
      "type": "edit",
      "id": "838cc5d781dbb921",
      "item": {
        "type": "paragraph",
        "id": "838cc5d781dbb921",
        "text": "NIERSTRASZ, Oscar, 2023. PEGs, Packrats and Parser Combinators. Oscar Nierstrasz. Online. 6 April 2023. [AccessedÂ 28Â AprilÂ 2023]. Available from: https://www.oscar.nierstrasz.org/teaching/2023-04-06-PEGs This was a guest lecture held on Thursday April 6 for the Masters course on Compiler Construction offered by [[Timo Kehrer]] at the University of Bern.The lecture provides an introduction to Parsing Expression Grammars, as a well as a live demo using the PetitParser framework to build an interpreter for a toy programming language.\n"
      },
      "date": 1684217178807
    },
    {
      "type": "edit",
      "id": "838cc5d781dbb921",
      "item": {
        "type": "paragraph",
        "id": "838cc5d781dbb921",
        "text": "NIERSTRASZ, Oscar, 2023. PEGs, Packrats and Parser Combinators. [[Oscar Nierstrasz]]. Online. 6 April 2023. [AccessedÂ 28Â AprilÂ 2023]. Available from: https://www.oscar.nierstrasz.org/teaching/2023-04-06-PEGs This was a guest lecture held on Thursday April 6 for the Masters course on Compiler Construction offered by [[Timo Kehrer]] at the University of Bern.The lecture provides an introduction to Parsing Expression Grammars, as a well as a live demo using the PetitParser framework to build an interpreter for a toy programming language.\n"
      },
      "date": 1684217254710
    },
    {
      "item": {
        "type": "factory",
        "id": "f6af47a52ab1e1f4"
      },
      "id": "f6af47a52ab1e1f4",
      "type": "add",
      "after": "838cc5d781dbb921",
      "date": 1684217567358
    },
    {
      "type": "edit",
      "id": "f6af47a52ab1e1f4",
      "item": {
        "type": "video",
        "id": "f6af47a52ab1e1f4",
        "text": "YOUTUBE MbzE_PonAfQ"
      },
      "date": 1684217581742
    },
    {
      "type": "edit",
      "id": "f6af47a52ab1e1f4",
      "item": {
        "type": "video",
        "id": "f6af47a52ab1e1f4",
        "text": "YOUTUBE MbzE_PonAfQ\nPEGs, Packrats and Parser Combinators â€” Part 1: An Introduction to PEGs and PetitParser "
      },
      "date": 1684217611628
    },
    {
      "item": {
        "type": "factory",
        "id": "6e35bd93633fceff"
      },
      "id": "6e35bd93633fceff",
      "type": "add",
      "after": "f6af47a52ab1e1f4",
      "date": 1684218393080
    },
    {
      "type": "edit",
      "id": "6e35bd93633fceff",
      "item": {
        "type": "pagefold",
        "id": "6e35bd93633fceff",
        "text": "~"
      },
      "date": 1684218397667
    },
    {
      "item": {
        "type": "factory",
        "id": "0ab3a3f3c43754a7"
      },
      "id": "0ab3a3f3c43754a7",
      "type": "add",
      "after": "6e35bd93633fceff",
      "date": 1684218400284
    },
    {
      "type": "edit",
      "id": "0ab3a3f3c43754a7",
      "item": {
        "type": "paragraph",
        "id": "0ab3a3f3c43754a7",
        "text": "gt: clone and install the latest code"
      },
      "date": 1684218411079
    },
    {
      "type": "edit",
      "id": "0ab3a3f3c43754a7",
      "item": {
        "type": "paragraph",
        "id": "0ab3a3f3c43754a7",
        "text": "gt: clone and install the latest code [https://gtoolkit.com/download/ page]"
      },
      "date": 1684218424490
    },
    {
      "item": {
        "type": "factory",
        "id": "c4f06fb9584c21a0"
      },
      "id": "c4f06fb9584c21a0",
      "type": "add",
      "after": "0ab3a3f3c43754a7",
      "date": 1684218434243
    },
    {
      "type": "edit",
      "id": "c4f06fb9584c21a0",
      "item": {
        "type": "code",
        "id": "c4f06fb9584c21a0",
        "text": "curl https://dl.feenk.com/scripts/mac.sh | bash"
      },
      "date": 1684218437385
    },
    {
      "item": {
        "type": "factory",
        "id": "a8cf640f41ebee56"
      },
      "id": "a8cf640f41ebee56",
      "type": "add",
      "after": "c4f06fb9584c21a0",
      "date": 1684218448610
    },
    {
      "type": "edit",
      "id": "a8cf640f41ebee56",
      "item": {
        "type": "code",
        "id": "a8cf640f41ebee56",
        "text": "[â€¦]\nðŸ”¨ Building Glamorous Toolkit...\nError: Command \"/Users/rgb/gt/glamoroustoolkit/GlamorousToolkit.app/Contents/MacOS/GlamorousToolkit-cli\" \"/Users/rgb/gt/glamoroustoolkit/GlamorousToolkit.image\" \"st\" \"--quit\" \"--save\" \"\" \"load-gt-main.st\" failed. See install.log or install-errors.log for more info"
      },
      "date": 1684218455142
    },
    {
      "item": {
        "type": "factory",
        "id": "bfdfefc9e6d1595d"
      },
      "id": "bfdfefc9e6d1595d",
      "type": "add",
      "after": "a8cf640f41ebee56",
      "date": 1684219064508
    },
    {
      "type": "edit",
      "id": "bfdfefc9e6d1595d",
      "item": {
        "type": "paragraph",
        "id": "bfdfefc9e6d1595d",
        "text": "Note: "
      },
      "date": 1684219070073
    },
    {
      "item": {
        "type": "factory",
        "id": "fb9cf45f5ffeeaa6"
      },
      "id": "fb9cf45f5ffeeaa6",
      "type": "add",
      "after": "bfdfefc9e6d1595d",
      "date": 1684219075446
    },
    {
      "type": "edit",
      "id": "fb9cf45f5ffeeaa6",
      "item": {
        "type": "code",
        "id": "fb9cf45f5ffeeaa6",
        "text": "| credentials |\ncredentials := IceSshCredentials new\n    host:  #'*';\n    username: 'git';\n    publicKey: '/Users/rgb/.ssh/id_ecdsa.pub';\n    privateKey: '/Users/rgb/.ssh/id_ecdsa';\n    yourself.\nIceCredentialStore current\n    storeSshCredential: credentials\n    forHostname: credentials host.\nIceCredentialsProvider useCustomSsh: true.\n"
      },
      "date": 1684219078099
    },
    {
      "type": "edit",
      "id": "bfdfefc9e6d1595d",
      "item": {
        "type": "paragraph",
        "id": "bfdfefc9e6d1595d",
        "text": "Note: ssh-credentials.st needs to be available in "
      },
      "date": 1684219130824
    },
    {
      "type": "edit",
      "id": "bfdfefc9e6d1595d",
      "item": {
        "type": "paragraph",
        "id": "bfdfefc9e6d1595d",
        "text": "Note: ssh-credentials.st needs to be available in ~/Library/Preferences/pharo:"
      },
      "date": 1684219157452
    },
    {
      "item": {
        "type": "factory",
        "id": "5dc06dcfb0ae6d9b"
      },
      "id": "5dc06dcfb0ae6d9b",
      "type": "add",
      "after": "fb9cf45f5ffeeaa6",
      "date": 1684219205647
    },
    {
      "type": "edit",
      "id": "5dc06dcfb0ae6d9b",
      "item": {
        "type": "paragraph",
        "id": "5dc06dcfb0ae6d9b",
        "text": "[[IceSshCredentials]]"
      },
      "date": 1684219210602
    },
    {
      "type": "edit",
      "id": "0ab3a3f3c43754a7",
      "item": {
        "type": "paragraph",
        "id": "0ab3a3f3c43754a7",
        "text": "â‡’ [[gt]]: clone and install the latest code [https://gtoolkit.com/download/ page]"
      },
      "date": 1684225604220
    },
    {
      "type": "edit",
      "id": "5dc06dcfb0ae6d9b",
      "item": {
        "type": "paragraph",
        "id": "5dc06dcfb0ae6d9b",
        "text": "â‡’ [[IceSshCredentials]]"
      },
      "date": 1684225668346
    },
    {
      "type": "edit",
      "id": "5dc06dcfb0ae6d9b",
      "item": {
        "type": "paragraph",
        "id": "5dc06dcfb0ae6d9b",
        "text": "â‡’ [[IceSshCredentials]]: [[connect]] to a git repository via ssh/scp."
      },
      "date": 1684225786402
    },
    {
      "type": "edit",
      "id": "0ab3a3f3c43754a7",
      "item": {
        "type": "paragraph",
        "id": "0ab3a3f3c43754a7",
        "text": "https://youtu.be/MbzE_PonAfQ?t=2445"
      },
      "date": 1684226164787
    },
    {
      "type": "add",
      "id": "f64a8eda39a6e54a",
      "item": {
        "type": "paragraph",
        "id": "f64a8eda39a6e54a",
        "text": "â‡’ [[gt]]: clone and install the latest code [https://gtoolkit.com/download/ page]"
      },
      "after": "0ab3a3f3c43754a7",
      "date": 1684226170945
    },
    {
      "type": "edit",
      "id": "0ab3a3f3c43754a7",
      "item": {
        "type": "paragraph",
        "id": "0ab3a3f3c43754a7",
        "text": "[https://youtu.be/MbzE_PonAfQ?t=2445 video] â€“ [â€¦] a Symbol as Parser"
      },
      "date": 1684226198469
    },
    {
      "type": "edit",
      "id": "0ab3a3f3c43754a7",
      "item": {
        "type": "paragraph",
        "id": "0ab3a3f3c43754a7",
        "text": "[https://youtu.be/MbzE_PonAfQ?t=2445 video] â€“ [â€¦] a Symbol as a Parser"
      },
      "date": 1684226208941
    },
    {
      "type": "edit",
      "id": "0ab3a3f3c43754a7",
      "item": {
        "type": "paragraph",
        "id": "0ab3a3f3c43754a7",
        "text": "[https://youtu.be/MbzE_PonAfQ?t=2445 video] â€“ [â€¦] a Symbol as a Parser (Composing PetitParser parsers in a script)"
      },
      "date": 1684245152698
    },
    {
      "type": "edit",
      "id": "0ab3a3f3c43754a7",
      "item": {
        "type": "paragraph",
        "id": "0ab3a3f3c43754a7",
        "text": "[https://youtu.be/MbzE_PonAfQ?t=2445 video] â€“ Composing PetitParser parsers in a script [â€¦] a Symbol as a Parser"
      },
      "date": 1684245176468
    },
    {
      "type": "fork",
      "site": "wiki.ralfbarkow.ch",
      "date": 1684246298668
    },
    {
      "item": {
        "type": "factory",
        "id": "586fc78f1989c74c"
      },
      "id": "586fc78f1989c74c",
      "type": "add",
      "after": "5dc06dcfb0ae6d9b",
      "date": 1684246322407
    },
    {
      "type": "edit",
      "id": "586fc78f1989c74c",
      "item": {
        "type": "pagefold",
        "id": "586fc78f1989c74c",
        "text": "~"
      },
      "date": 1684246326742
    },
    {
      "item": {
        "type": "factory",
        "id": "2d84301ff24112e8"
      },
      "id": "2d84301ff24112e8",
      "type": "add",
      "after": "586fc78f1989c74c",
      "date": 1684246340497
    },
    {
      "type": "edit",
      "id": "2d84301ff24112e8",
      "item": {
        "type": "reference",
        "id": "2d84301ff24112e8",
        "site": "ward.dojo.fed.wiki",
        "slug": "remote-database-schema-migration",
        "title": "Remote Database Schema Migration",
        "text": "I was sure that we could not get the schema for [[WyCash Plus]] right on the first try. I was familiar with Smaltalk-80's object migration mechanisms. I designed a version that could serve us in a commercial software distribution environment."
      },
      "date": 1684246343251
    },
    {
      "id": "bdbf25def81a6acc",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "bdbf25def81a6acc",
        "text": "Alan Darlington became most skillful of our group managing these resources. We would change what ever we wanted in development and then design the migrations to be delivered, consulting Alan if necessary."
      },
      "after": "2d84301ff24112e8",
      "attribution": {
        "page": "Remote Database Schema Migration",
        "site": "ward.dojo.fed.wiki"
      },
      "date": 1684246353271
    },
    {
      "id": "bdbf25def81a6acc",
      "type": "remove",
      "removedTo": {
        "page": "Remote Database Schema Migration"
      },
      "date": 1684246681406
    },
    {
      "type": "fork",
      "site": "hive.dreyeck.ch",
      "date": 1684247973666
    },
    {
      "item": {
        "type": "factory",
        "id": "83f2662f938b4a65"
      },
      "id": "83f2662f938b4a65",
      "type": "add",
      "after": "2d84301ff24112e8",
      "date": 1684248056762
    },
    {
      "type": "edit",
      "id": "83f2662f938b4a65",
      "item": {
        "type": "reference",
        "id": "83f2662f938b4a65",
        "site": "code.fed.wiki.org",
        "slug": "remote-database-schema-migration",
        "title": "Remote Database Schema Migration",
        "text": "I was sure that we could not get the schema for [[WyCash Plus]] right on the first try. I was familiar with Smaltalk-80's object migration mechanisms. I designed a version that could serve us in a commercial software distribution environment."
      },
      "date": 1684248059102
    },
    {
      "type": "remove",
      "id": "2d84301ff24112e8",
      "date": 1684248061346
    },
    {
      "type": "edit",
      "id": "83f2662f938b4a65",
      "item": {
        "type": "reference",
        "id": "83f2662f938b4a65",
        "site": "code.fed.wiki.org",
        "slug": "remote-database-schema-migration",
        "title": "Remote Database Schema Migration",
        "text": "Ward was sure that they would not get the schema for [[WyCash Plus]] right on the first try. He was familiar with the object migration mechanisms of Smaltalk-80. He designed a version that could serve them in a commercial software distribution environment."
      },
      "date": 1684248072508
    },
    {
      "item": {
        "type": "factory",
        "id": "7043172fc12e8bdc"
      },
      "id": "7043172fc12e8bdc",
      "type": "add",
      "after": "83f2662f938b4a65",
      "date": 1684248412559
    },
    {
      "type": "edit",
      "id": "7043172fc12e8bdc",
      "item": {
        "type": "paragraph",
        "id": "7043172fc12e8bdc",
        "text": "[[record]] mutation vectors for each version to the present."
      },
      "date": 1684248427982
    },
    {
      "type": "edit",
      "id": "7043172fc12e8bdc",
      "item": {
        "type": "paragraph",
        "id": "7043172fc12e8bdc",
        "text": "â‡’ [[record]] mutation vectors for each version to the present."
      },
      "date": 1684248435987
    },
    {
      "type": "add",
      "id": "dd73dd5fe59228ff",
      "item": {
        "type": "paragraph",
        "id": "dd73dd5fe59228ff",
        "text": "How to record mutation vectors for object migration in object-oriented programming languages like Smalltalk?"
      },
      "after": "7043172fc12e8bdc",
      "date": 1684248609719
    },
    {
      "item": {
        "type": "factory",
        "id": "a1bd5f4297606ec5"
      },
      "id": "a1bd5f4297606ec5",
      "type": "add",
      "after": "fec769a83768515c",
      "date": 1684248638987
    },
    {
      "type": "edit",
      "id": "a1bd5f4297606ec5",
      "item": {
        "type": "mathjax",
        "id": "a1bd5f4297606ec5",
        "text": "chat.openai.com"
      },
      "date": 1684248641996
    },
    {
      "item": {
        "type": "factory",
        "id": "fa4916f4d37b4eb4"
      },
      "id": "fa4916f4d37b4eb4",
      "type": "add",
      "after": "a1bd5f4297606ec5",
      "date": 1684248643813
    },
    {
      "type": "edit",
      "id": "fa4916f4d37b4eb4",
      "item": {
        "type": "pagefold",
        "id": "fa4916f4d37b4eb4",
        "text": "chat.openai.com"
      },
      "date": 1684248645898
    },
    {
      "id": "a1bd5f4297606ec5",
      "type": "move",
      "order": [
        "e5eae3a078ccc07a",
        "cb415f7a52c5f70d",
        "38851df7c9ae4f4f",
        "2a97c6fd35f3aa80",
        "5aba2f4567469bda",
        "838cc5d781dbb921",
        "f6af47a52ab1e1f4",
        "6e35bd93633fceff",
        "0ab3a3f3c43754a7",
        "f64a8eda39a6e54a",
        "c4f06fb9584c21a0",
        "a8cf640f41ebee56",
        "bfdfefc9e6d1595d",
        "fb9cf45f5ffeeaa6",
        "5dc06dcfb0ae6d9b",
        "586fc78f1989c74c",
        "83f2662f938b4a65",
        "7043172fc12e8bdc",
        "dd73dd5fe59228ff",
        "fa4916f4d37b4eb4",
        "a1bd5f4297606ec5"
      ],
      "date": 1684248648418
    },
    {
      "type": "edit",
      "id": "a1bd5f4297606ec5",
      "item": {
        "type": "mathjax",
        "id": "a1bd5f4297606ec5",
        "text": "n Smalltalk, you can record mutation vectors for object migration using the concept of \"change sets.\" Change sets are a mechanism in Smalltalk that allows you to track and manage changes to the code and the state of objects. They can be used to capture mutations made to objects, including their data and behavior, and apply those changes to another Smalltalk environment.\n\nHere's a general approach to recording mutation vectors for object migration in Smalltalk using change sets:\n\nCreate a new change set: In your Smalltalk development environment, create a new change set dedicated to tracking the mutations for the object migration. Change sets are typically represented as collections of code changes.\nIdentify the objects to be migrated: Determine which objects you want to migrate from one Smalltalk environment to another. These objects should be self-contained, with all the necessary data and behavior encapsulated within them.\nTrack mutations in the change set: As you make changes to the objects, such as modifying instance variables or adding/removing methods, ensure that these changes are recorded in the dedicated change set. This can be done by adding the code snippets representing these changes to the change set.\nCapture object state: To record the complete state of an object, including its instance variables, you can define methods on the object that return its state as a dictionary or any suitable data structure. You can then invoke these methods and store the resulting state in the change set.\nSerialize the change set: Once you have recorded all the mutations related to the object migration, you can serialize the change set. This step involves converting the change set into a format that can be easily transferred to another Smalltalk environment. Smalltalk provides built-in mechanisms for serialization, such as saving the change set as a file.\nMigrate the change set: Transfer the serialized change set to the target Smalltalk environment where you want to apply the recorded mutations.\nApply the change set: Load the change set into the target Smalltalk environment and apply the recorded mutations to the appropriate objects. The specific steps for applying the change set may vary depending on the Smalltalk implementation you're using.\nBy following these steps, you can record mutation vectors for object migration in Smalltalk using change sets. Change sets provide a convenient way to track and manage changes, making it easier to migrate objects between Smalltalk environments while preserving their state and behavior."
      },
      "date": 1684248665238
    },
    {
      "type": "edit",
      "id": "a1bd5f4297606ec5",
      "item": {
        "type": "mathjax",
        "id": "a1bd5f4297606ec5",
        "text": "In Smalltalk, you can record mutation vectors for object migration using the concept of \"change sets.\" Change sets are a mechanism in Smalltalk that allows you to track and manage changes to the code and the state of objects. They can be used to capture mutations made to objects, including their data and behavior, and apply those changes to another Smalltalk environment.\n\nHere's a general approach to recording mutation vectors for object migration in Smalltalk using change sets:\n\nCreate a new change set: In your Smalltalk development environment, create a new change set dedicated to tracking the mutations for the object migration. Change sets are typically represented as collections of code changes.\nIdentify the objects to be migrated: Determine which objects you want to migrate from one Smalltalk environment to another. These objects should be self-contained, with all the necessary data and behavior encapsulated within them.\nTrack mutations in the change set: As you make changes to the objects, such as modifying instance variables or adding/removing methods, ensure that these changes are recorded in the dedicated change set. This can be done by adding the code snippets representing these changes to the change set.\nCapture object state: To record the complete state of an object, including its instance variables, you can define methods on the object that return its state as a dictionary or any suitable data structure. You can then invoke these methods and store the resulting state in the change set.\nSerialize the change set: Once you have recorded all the mutations related to the object migration, you can serialize the change set. This step involves converting the change set into a format that can be easily transferred to another Smalltalk environment. Smalltalk provides built-in mechanisms for serialization, such as saving the change set as a file.\nMigrate the change set: Transfer the serialized change set to the target Smalltalk environment where you want to apply the recorded mutations.\nApply the change set: Load the change set into the target Smalltalk environment and apply the recorded mutations to the appropriate objects. The specific steps for applying the change set may vary depending on the Smalltalk implementation you're using.\nBy following these steps, you can record mutation vectors for object migration in Smalltalk using change sets. Change sets provide a convenient way to track and manage changes, making it easier to migrate objects between Smalltalk environments while preserving their state and behavior."
      },
      "date": 1684248689722
    },
    {
      "type": "edit",
      "id": "a1bd5f4297606ec5",
      "item": {
        "type": "mathjax",
        "id": "a1bd5f4297606ec5",
        "text": "In Smalltalk, you can record mutation vectors for object migration using the concept of \"change sets.\" Change sets are a mechanism in Smalltalk that allows you to track and manage changes to the code and the state of objects. They can be used to capture mutations made to objects, including their data and behavior, and apply those changes to another Smalltalk environment.\n"
      },
      "date": 1684248709246
    },
    {
      "item": {
        "type": "factory",
        "id": "0f1790180e923521"
      },
      "id": "0f1790180e923521",
      "type": "add",
      "after": "a1bd5f4297606ec5",
      "date": 1684248710671
    },
    {
      "type": "edit",
      "id": "0f1790180e923521",
      "item": {
        "type": "paragraph",
        "id": "0f1790180e923521",
        "text": "Here's a general approach to recording mutation vectors for object migration in Smalltalk using change sets:\n\n"
      },
      "date": 1684248715782
    },
    {
      "type": "add",
      "id": "5acf9183f9671374",
      "item": {
        "type": "paragraph",
        "id": "5acf9183f9671374",
        "text": "1. Create a new change set: In your Smalltalk development environment, create a new change set dedicated to tracking the mutations for the object migration. Change sets are typically represented as collections of code changes.\n"
      },
      "after": "0f1790180e923521",
      "date": 1684248727348
    },
    {
      "type": "add",
      "id": "9c4cd0f7313c9285",
      "item": {
        "type": "paragraph",
        "id": "9c4cd0f7313c9285",
        "text": "2. Identify the objects to be migrated: Determine which objects you want to migrate from one Smalltalk environment to another. These objects should be self-contained, with all the necessary data and behavior encapsulated within them.\nTrack mutations in the change set: As you make changes to the objects, such as modifying instance variables or adding/removing methods, ensure that these changes are recorded in the dedicated change set. This can be done by adding the code snippets representing these changes to the change set.\nCapture object state: To record the complete state of an object, including its instance variables, you can define methods on the object that return its state as a dictionary or any suitable data structure. You can then invoke these methods and store the resulting state in the change set.\nSerialize the change set: Once you have recorded all the mutations related to the object migration, you can serialize the change set. This step involves converting the change set into a format that can be easily transferred to another Smalltalk environment. Smalltalk provides built-in mechanisms for serialization, such as saving the change set as a file.\nMigrate the change set: Transfer the serialized change set to the target Smalltalk environment where you want to apply the recorded mutations.\nApply the change set: Load the change set into the target Smalltalk environment and apply the recorded mutations to the appropriate objects. The specific steps for applying the change set may vary depending on the Smalltalk implementation you're using.\nBy following these steps, you can record mutation vectors for object migration in Smalltalk using change sets. Change sets provide a convenient way to track and manage changes, making it easier to migrate objects between Smalltalk environments while preserving their state and behavior."
      },
      "after": "5acf9183f9671374",
      "date": 1684248728135
    },
    {
      "type": "edit",
      "id": "9c4cd0f7313c9285",
      "item": {
        "type": "paragraph",
        "id": "9c4cd0f7313c9285",
        "text": "2. Identify the objects to be migrated: Determine which objects you want to migrate from one Smalltalk environment to another. These objects should be self-contained, with all the necessary data and behavior encapsulated within them.\n"
      },
      "date": 1684248784178
    },
    {
      "type": "add",
      "id": "0085d9e96dd7fb17",
      "item": {
        "type": "paragraph",
        "id": "0085d9e96dd7fb17",
        "text": "3. Track mutations in the change set: As you make changes to the objects, such as modifying instance variables or adding/removing methods, ensure that these changes are recorded in the dedicated change set. This can be done by adding the code snippets representing these changes to the change set.\nCapture object state: To record the complete state of an object, including its instance variables, you can define methods on the object that return its state as a dictionary or any suitable data structure. You can then invoke these methods and store the resulting state in the change set.\nSerialize the change set: Once you have recorded all the mutations related to the object migration, you can serialize the change set. This step involves converting the change set into a format that can be easily transferred to another Smalltalk environment. Smalltalk provides built-in mechanisms for serialization, such as saving the change set as a file.\nMigrate the change set: Transfer the serialized change set to the target Smalltalk environment where you want to apply the recorded mutations.\nApply the change set: Load the change set into the target Smalltalk environment and apply the recorded mutations to the appropriate objects. The specific steps for applying the change set may vary depending on the Smalltalk implementation you're using.\nBy following these steps, you can record mutation vectors for object migration in Smalltalk using change sets. Change sets provide a convenient way to track and manage changes, making it easier to migrate objects between Smalltalk environments while preserving their state and behavior."
      },
      "after": "9c4cd0f7313c9285",
      "date": 1684248785565
    },
    {
      "type": "edit",
      "id": "0085d9e96dd7fb17",
      "item": {
        "type": "paragraph",
        "id": "0085d9e96dd7fb17",
        "text": "3. Track mutations in the change set: As you make changes to the objects, such as modifying instance variables or adding/removing methods, ensure that these changes are recorded in the dedicated change set. This can be done by adding the code snippets representing these changes to the change set.\n"
      },
      "date": 1684248804394
    },
    {
      "type": "add",
      "id": "de3f9fb9c8718599",
      "item": {
        "type": "paragraph",
        "id": "de3f9fb9c8718599",
        "text": "4. Capture object state: To record the complete state of an object, including its instance variables, you can define methods on the object that return its state as a dictionary or any suitable data structure. You can then invoke these methods and store the resulting state in the change set.\n"
      },
      "after": "0085d9e96dd7fb17",
      "date": 1684248810001
    },
    {
      "type": "add",
      "id": "f90a873680ac27a9",
      "item": {
        "type": "paragraph",
        "id": "f90a873680ac27a9",
        "text": "5. Serialize the change set: Once you have recorded all the mutations related to the object migration, you can serialize the change set. This step involves converting the change set into a format that can be easily transferred to another Smalltalk environment. Smalltalk provides built-in mechanisms for serialization, such as saving the change set as a file.\nMigrate the change set: Transfer the serialized change set to the target Smalltalk environment where you want to apply the recorded mutations.\nApply the change set: Load the change set into the target Smalltalk environment and apply the recorded mutations to the appropriate objects. The specific steps for applying the change set may vary depending on the Smalltalk implementation you're using.\nBy following these steps, you can record mutation vectors for object migration in Smalltalk using change sets. Change sets provide a convenient way to track and manage changes, making it easier to migrate objects between Smalltalk environments while preserving their state and behavior."
      },
      "after": "de3f9fb9c8718599",
      "date": 1684248810717
    },
    {
      "type": "edit",
      "id": "f90a873680ac27a9",
      "item": {
        "type": "paragraph",
        "id": "f90a873680ac27a9",
        "text": "5. Serialize the change set: Once you have recorded all the mutations related to the object migration, you can serialize the change set. This step involves converting the change set into a format that can be easily transferred to another Smalltalk environment. Smalltalk provides built-in mechanisms for serialization, such as saving the change set as a file.\n"
      },
      "date": 1684248839483
    },
    {
      "type": "add",
      "id": "4f423c4246b1775d",
      "item": {
        "type": "paragraph",
        "id": "4f423c4246b1775d",
        "text": "6. Migrate the change set: Transfer the serialized change set to the target Smalltalk environment where you want to apply the recorded mutations.\nApply the change set: Load the change set into the target Smalltalk environment and apply the recorded mutations to the appropriate objects. The specific steps for applying the change set may vary depending on the Smalltalk implementation you're using.\n"
      },
      "after": "f90a873680ac27a9",
      "date": 1684248843020
    },
    {
      "type": "add",
      "id": "a2949fa5d77f314a",
      "item": {
        "type": "paragraph",
        "id": "a2949fa5d77f314a",
        "text": "By following these steps, you can record mutation vectors for object migration in Smalltalk using change sets. Change sets provide a convenient way to track and manage changes, making it easier to migrate objects between Smalltalk environments while preserving their state and behavior."
      },
      "after": "4f423c4246b1775d",
      "date": 1684248843597
    },
    {
      "type": "edit",
      "id": "4f423c4246b1775d",
      "item": {
        "type": "paragraph",
        "id": "4f423c4246b1775d",
        "text": "6. Migrate the change set: Transfer the serialized change set to the target Smalltalk environment where you want to apply the recorded mutations.\n"
      },
      "date": 1684248857949
    },
    {
      "type": "add",
      "id": "03d76d54be1c3b44",
      "item": {
        "type": "paragraph",
        "id": "03d76d54be1c3b44",
        "text": "7. Apply the change set: Load the change set into the target Smalltalk environment and apply the recorded mutations to the appropriate objects. The specific steps for applying the change set may vary depending on the Smalltalk implementation you're using.\n"
      },
      "after": "4f423c4246b1775d",
      "date": 1684248858461
    },
    {
      "item": {
        "type": "factory",
        "id": "eb6b36e8a49a46af"
      },
      "id": "eb6b36e8a49a46af",
      "type": "add",
      "after": "a2949fa5d77f314a",
      "date": 1684248874807
    },
    {
      "type": "edit",
      "id": "eb6b36e8a49a46af",
      "item": {
        "type": "pagefold",
        "id": "eb6b36e8a49a46af",
        "text": "End of chat"
      },
      "date": 1684248882703
    },
    {
      "type": "edit",
      "id": "eb6b36e8a49a46af",
      "item": {
        "type": "pagefold",
        "id": "eb6b36e8a49a46af",
        "text": "End of chat.openai"
      },
      "date": 1684248899914
    },
    {
      "type": "edit",
      "id": "fa4916f4d37b4eb4",
      "item": {
        "type": "pagefold",
        "id": "fa4916f4d37b4eb4",
        "text": "chat.openai"
      },
      "date": 1684248906635
    }
  ]
}