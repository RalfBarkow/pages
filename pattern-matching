{
  "title": "Pattern Matching",
  "story": [
    {
      "type": "reference",
      "id": "1e407b2471037e78",
      "site": "wiki.ralfbarkow.ch",
      "slug": "functional-programming",
      "title": "Functional Programming",
      "text": "[[Functional Programming]] is when functions, not objects or procedures, are used as the fundamental building blocks of a program. Functions in this sense, not to be confused with [[Cee Language]] functions which are just procedures, are analogous to mathematical equations: they declare a [[relationship]] between two or more entities."
    },
    {
      "type": "pagefold",
      "id": "f913c6a36a076950",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "1ad75de525a73187",
      "text": "William Bricken Ph.D, Iconic Arithmetic Volume I: The Design of Mathematics for Human Understanding (Unary press, 2019)."
    },
    {
      "type": "paragraph",
      "id": "0e15254b9b23d05b",
      "text": "⇒ [[Substitution]]"
    },
    {
      "type": "paragraph",
      "id": "672b7cca6cb9c9fb",
      "text": "p. 66 […] unit-ensembles separate theory, structure and algorithm by using the generic tools of pattern-matching to [[enact]] transformations."
    },
    {
      "type": "paragraph",
      "id": "71e22afa1d1712e9",
      "text": "p. 74 [[Parens Arithmetic]], [[add]] and [[multiply]]"
    },
    {
      "type": "paragraph",
      "id": "ced00546e52f35b8",
      "text": "p. 141 The most important characteristic of these axioms is that two of them specify how to [[delete]] structure. Both implicate only one form (labeled A), so that they both require only simple pattern-matching. Remarkably, this leaves all of the complexity of numeric algebra isolated in one [[pattern transformation]]."
    },
    {
      "type": "paragraph",
      "id": "85ed8a9033ad8887",
      "text": "p. 211: A final difference between sets and bounded tallies is that set theory is thoroughly dependent upon first-order logic for its definitions and its axioms, whereas boundary forms instead depend upon pattern matching."
    },
    {
      "type": "markdown",
      "id": "11796a9d05e042fb",
      "text": "# Proof by [[Pattern-Matching]] and [[Substitution]]"
    },
    {
      "type": "markdown",
      "id": "ab7c66f7c52968ad",
      "text": "Axioms *statically* define patterns that are equivalent, and *dynamically* permit transformation between patterns. Structural axioms are implemented by matching a given structure to a permitted pattern and then replacing it by a certified equivalent structure. Two axioms identify void-equivalent forms, permitting deletion of structure. The third permits rearrangement. This makes computation and [[verification]] short and elegant. (p. 152)"
    },
    {
      "type": "paragraph",
      "id": "fe38d0238ddabb7f",
      "text": "p. 361 [[Models of Multiplication]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Pattern Matching",
        "story": []
      },
      "date": 1639081543785
    },
    {
      "item": {
        "type": "factory",
        "id": "1e407b2471037e78"
      },
      "id": "1e407b2471037e78",
      "type": "add",
      "date": 1639081550801
    },
    {
      "type": "edit",
      "id": "1e407b2471037e78",
      "item": {
        "type": "reference",
        "id": "1e407b2471037e78",
        "site": "wiki.ralfbarkow.ch",
        "slug": "functional-programming",
        "title": "Functional Programming",
        "text": "[[Functional Programming]] is when functions, not objects or procedures, are used as the fundamental building blocks of a program. Functions in this sense, not to be confused with [[Cee Language]] functions which are just procedures, are analogous to mathematical equations: they declare a relationship between two or more entities."
      },
      "date": 1639081552938
    },
    {
      "type": "edit",
      "id": "1e407b2471037e78",
      "item": {
        "type": "reference",
        "id": "1e407b2471037e78",
        "site": "wiki.ralfbarkow.ch",
        "slug": "functional-programming",
        "title": "Functional Programming",
        "text": "[[Functional Programming]] is when functions, not objects or procedures, are used as the fundamental building blocks of a program. Functions in this sense, not to be confused with [[Cee Language]] functions which are just procedures, are analogous to mathematical equations: they declare a [[relationship]] between two or more entities."
      },
      "date": 1639081588668
    },
    {
      "item": {
        "type": "factory",
        "id": "85ed8a9033ad8887"
      },
      "id": "85ed8a9033ad8887",
      "type": "add",
      "after": "1e407b2471037e78",
      "date": 1659785237858
    },
    {
      "type": "edit",
      "id": "85ed8a9033ad8887",
      "item": {
        "type": "paragraph",
        "id": "85ed8a9033ad8887",
        "text": "A final difference between sets and bounded tallies is that set theory is thoroughly dependent upon first-order logic for its definitions and its axioms, whereas boundary forms instead depend upon pattern matching."
      },
      "date": 1659785240285
    },
    {
      "item": {
        "type": "factory",
        "id": "f913c6a36a076950"
      },
      "id": "f913c6a36a076950",
      "type": "add",
      "after": "85ed8a9033ad8887",
      "date": 1659785248296
    },
    {
      "id": "f913c6a36a076950",
      "type": "move",
      "order": [
        "1e407b2471037e78",
        "f913c6a36a076950",
        "85ed8a9033ad8887"
      ],
      "date": 1659785249762
    },
    {
      "type": "edit",
      "id": "f913c6a36a076950",
      "item": {
        "type": "pagefold",
        "id": "f913c6a36a076950",
        "text": "~"
      },
      "date": 1659785252961
    },
    {
      "item": {
        "type": "factory",
        "id": "1ad75de525a73187"
      },
      "id": "1ad75de525a73187",
      "type": "add",
      "after": "85ed8a9033ad8887",
      "date": 1659785254479
    },
    {
      "id": "1ad75de525a73187",
      "type": "move",
      "order": [
        "1e407b2471037e78",
        "f913c6a36a076950",
        "1ad75de525a73187",
        "85ed8a9033ad8887"
      ],
      "date": 1659785255812
    },
    {
      "type": "edit",
      "id": "1ad75de525a73187",
      "item": {
        "type": "paragraph",
        "id": "1ad75de525a73187",
        "text": "William Bricken Ph.D, Iconic Arithmetic Volume I: The Design of Mathematics for Human Understanding (Unary press, 2019)."
      },
      "date": 1659785259508
    },
    {
      "type": "edit",
      "id": "85ed8a9033ad8887",
      "item": {
        "type": "paragraph",
        "id": "85ed8a9033ad8887",
        "text": "p. 211: A final difference between sets and bounded tallies is that set theory is thoroughly dependent upon first-order logic for its definitions and its axioms, whereas boundary forms instead depend upon pattern matching."
      },
      "date": 1659785272866
    },
    {
      "item": {
        "type": "factory",
        "id": "11796a9d05e042fb"
      },
      "id": "11796a9d05e042fb",
      "type": "add",
      "after": "85ed8a9033ad8887",
      "date": 1659785314505
    },
    {
      "type": "edit",
      "id": "11796a9d05e042fb",
      "item": {
        "type": "paragraph",
        "id": "11796a9d05e042fb",
        "text": "# Proof by pattern-matching and substitution"
      },
      "date": 1659785321413
    },
    {
      "type": "edit",
      "id": "11796a9d05e042fb",
      "item": {
        "type": "markdown",
        "id": "11796a9d05e042fb",
        "text": "# Proof by pattern-matching and substitution"
      },
      "date": 1659785322535
    },
    {
      "item": {
        "type": "factory",
        "id": "ab7c66f7c52968ad"
      },
      "id": "ab7c66f7c52968ad",
      "type": "add",
      "after": "11796a9d05e042fb",
      "date": 1659785331732
    },
    {
      "type": "edit",
      "id": "ab7c66f7c52968ad",
      "item": {
        "type": "paragraph",
        "id": "ab7c66f7c52968ad",
        "text": "Axioms statically define patterns that are equivalent, and dynamically permit transformation between patterns. Structural axioms are implemented by matching a given structure to a permitted pattern and then replacing it by a certified equivalent structure. Two axioms identify void-equivalent forms, permitting deletion of structure. The third permits rearrangement. This makes computation and verification short and elegant."
      },
      "date": 1659785333723
    },
    {
      "type": "edit",
      "id": "ab7c66f7c52968ad",
      "item": {
        "type": "paragraph",
        "id": "ab7c66f7c52968ad",
        "text": "Axioms statically define patterns that are equivalent, and dynamically permit transformation between patterns. Structural axioms are implemented by matching a given structure to a permitted pattern and then replacing it by a certified equivalent structure. Two axioms identify void-equivalent forms, permitting deletion of structure. The third permits rearrangement. This makes computation and verification short and elegant. (p. 152)"
      },
      "date": 1659785347381
    },
    {
      "type": "edit",
      "id": "ab7c66f7c52968ad",
      "item": {
        "type": "paragraph",
        "id": "ab7c66f7c52968ad",
        "text": "Axioms *statically* define patterns that are equivalent, and dynamically permit transformation between patterns. Structural axioms are implemented by matching a given structure to a permitted pattern and then replacing it by a certified equivalent structure. Two axioms identify void-equivalent forms, permitting deletion of structure. The third permits rearrangement. This makes computation and verification short and elegant. (p. 152)"
      },
      "date": 1659785359275
    },
    {
      "type": "edit",
      "id": "ab7c66f7c52968ad",
      "item": {
        "type": "markdown",
        "id": "ab7c66f7c52968ad",
        "text": "Axioms *statically* define patterns that are equivalent, and dynamically permit transformation between patterns. Structural axioms are implemented by matching a given structure to a permitted pattern and then replacing it by a certified equivalent structure. Two axioms identify void-equivalent forms, permitting deletion of structure. The third permits rearrangement. This makes computation and verification short and elegant. (p. 152)"
      },
      "date": 1659785360429
    },
    {
      "type": "edit",
      "id": "ab7c66f7c52968ad",
      "item": {
        "type": "markdown",
        "id": "ab7c66f7c52968ad",
        "text": "Axioms *statically* define patterns that are equivalent, and *dynamically* permit transformation between patterns. Structural axioms are implemented by matching a given structure to a permitted pattern and then replacing it by a certified equivalent structure. Two axioms identify void-equivalent forms, permitting deletion of structure. The third permits rearrangement. This makes computation and verification short and elegant. (p. 152)"
      },
      "date": 1659785373872
    },
    {
      "type": "edit",
      "id": "ab7c66f7c52968ad",
      "item": {
        "type": "markdown",
        "id": "ab7c66f7c52968ad",
        "text": "Axioms *statically* define patterns that are equivalent, and *dynamically* permit transformation between patterns. Structural axioms are implemented by matching a given structure to a permitted pattern and then replacing it by a certified equivalent structure. Two axioms identify void-equivalent forms, permitting deletion of structure. The third permits rearrangement. This makes computation and [[verification]] short and elegant. (p. 152)"
      },
      "date": 1659785419430
    },
    {
      "type": "edit",
      "id": "11796a9d05e042fb",
      "item": {
        "type": "markdown",
        "id": "11796a9d05e042fb",
        "text": "# Proof by Pattern-Matching and Substitution"
      },
      "date": 1659786196042
    },
    {
      "type": "add",
      "id": "f26eb4298b64d966",
      "item": {
        "type": "paragraph",
        "id": "f26eb4298b64d966",
        "text": "p. "
      },
      "after": "1ad75de525a73187",
      "date": 1659786274068
    },
    {
      "type": "edit",
      "id": "f26eb4298b64d966",
      "item": {
        "type": "paragraph",
        "id": "f26eb4298b64d966",
        "text": "p. 47: Substitution is the primary mechanism for computation and for proof in algebraic systems.17 In general, Wolfram’s Mathematica program demonstrates that practically all calculation, computation and symbolic demonstration can be achieved with pattern-matching and substitution over strings of symbols. Furthermore, when a mathematical system can be encoded in symbolic form, computation and demonstration in that system can be fully automated."
      },
      "date": 1659786278709
    },
    {
      "type": "edit",
      "id": "f26eb4298b64d966",
      "item": {
        "type": "paragraph",
        "id": "f26eb4298b64d966",
        "text": "p. 47: Substitution is the primary mechanism for computation and for proof in algebraic systems. In general, Wolfram’s *Mathematica* program demonstrates that practically all calculation, computation and symbolic demonstration can be achieved with pattern-matching and substitution over strings of symbols. Furthermore, when a mathematical system can be encoded in symbolic form, computation and demonstration in that system can be fully automated."
      },
      "date": 1659786302945
    },
    {
      "type": "edit",
      "id": "f26eb4298b64d966",
      "item": {
        "type": "markdown",
        "id": "f26eb4298b64d966",
        "text": "p. 47: Substitution is the primary mechanism for computation and for proof in algebraic systems. In general, Wolfram’s *Mathematica* program demonstrates that practically all calculation, computation and symbolic demonstration can be achieved with pattern-matching and substitution over strings of symbols. Furthermore, when a mathematical system can be encoded in symbolic form, computation and demonstration in that system can be fully automated."
      },
      "date": 1659786305362
    },
    {
      "id": "f26eb4298b64d966",
      "type": "remove",
      "date": 1659786971991
    },
    {
      "type": "add",
      "id": "0e15254b9b23d05b",
      "item": {
        "type": "paragraph",
        "id": "0e15254b9b23d05b",
        "text": "[[Substitution]]"
      },
      "after": "1ad75de525a73187",
      "date": 1659862897836
    },
    {
      "type": "edit",
      "id": "0e15254b9b23d05b",
      "item": {
        "type": "paragraph",
        "id": "0e15254b9b23d05b",
        "text": "⇒ [[Substitution]]"
      },
      "date": 1659862911468
    },
    {
      "type": "fork",
      "date": 1659862949542
    },
    {
      "type": "edit",
      "id": "11796a9d05e042fb",
      "item": {
        "type": "markdown",
        "id": "11796a9d05e042fb",
        "text": "# Proof by [[Pattern-Matching]] and [[Substitution]]"
      },
      "date": 1659863027254
    },
    {
      "type": "add",
      "id": "672b7cca6cb9c9fb",
      "item": {
        "type": "paragraph",
        "id": "672b7cca6cb9c9fb",
        "text": "p. 66 […] unit-ensembles separate theory, structure and algorithm by using the generic tools of pattern-matching to enact transformations."
      },
      "after": "0e15254b9b23d05b",
      "date": 1659863131084
    },
    {
      "type": "edit",
      "id": "672b7cca6cb9c9fb",
      "item": {
        "type": "paragraph",
        "id": "672b7cca6cb9c9fb",
        "text": "p. 66 […] unit-ensembles separate theory, structure and algorithm by using the generic tools of pattern-matching to [[enact]] transformations."
      },
      "date": 1659863169449
    },
    {
      "type": "add",
      "id": "71e22afa1d1712e9",
      "item": {
        "type": "paragraph",
        "id": "71e22afa1d1712e9",
        "text": "p. 74 [[Parens Arithmetic]]"
      },
      "after": "672b7cca6cb9c9fb",
      "date": 1659863309044
    },
    {
      "type": "edit",
      "id": "71e22afa1d1712e9",
      "item": {
        "type": "paragraph",
        "id": "71e22afa1d1712e9",
        "text": "p. 74 [[Parens Arithmetic]], [[add]]"
      },
      "date": 1659863341165
    },
    {
      "type": "edit",
      "id": "71e22afa1d1712e9",
      "item": {
        "type": "paragraph",
        "id": "71e22afa1d1712e9",
        "text": "p. 74 [[Parens Arithmetic]], [[add]] and [[multiply]]"
      },
      "date": 1659863515280
    },
    {
      "type": "add",
      "id": "ced00546e52f35b8",
      "item": {
        "type": "paragraph",
        "id": "ced00546e52f35b8",
        "text": "p. 141 "
      },
      "after": "71e22afa1d1712e9",
      "date": 1659864331171
    },
    {
      "type": "edit",
      "id": "ced00546e52f35b8",
      "item": {
        "type": "paragraph",
        "id": "ced00546e52f35b8",
        "text": "p. 141 The most important characteristic of these axioms is that two of them specify how to delete structure. Both implicate only one form (labeled A), so that they both require only simple pattern-matching. Remarkably, this leaves all of the complexity of numeric algebra isolated in one [[pattern transformation]]."
      },
      "date": 1659864383482
    },
    {
      "type": "edit",
      "id": "ced00546e52f35b8",
      "item": {
        "type": "paragraph",
        "id": "ced00546e52f35b8",
        "text": "p. 141 The most important characteristic of these axioms is that two of them specify how to [[[delete]] structure. Both implicate only one form (labeled A), so that they both require only simple pattern-matching. Remarkably, this leaves all of the complexity of numeric algebra isolated in one [[pattern transformation]]."
      },
      "date": 1659864483864
    },
    {
      "type": "edit",
      "id": "ced00546e52f35b8",
      "item": {
        "type": "paragraph",
        "id": "ced00546e52f35b8",
        "text": "p. 141 The most important characteristic of these axioms is that two of them specify how to [[delete]] structure. Both implicate only one form (labeled A), so that they both require only simple pattern-matching. Remarkably, this leaves all of the complexity of numeric algebra isolated in one [[pattern transformation]]."
      },
      "date": 1659864488961
    },
    {
      "item": {
        "type": "factory",
        "id": "fe38d0238ddabb7f"
      },
      "id": "fe38d0238ddabb7f",
      "type": "add",
      "after": "ab7c66f7c52968ad",
      "date": 1659864597832
    },
    {
      "type": "edit",
      "id": "fe38d0238ddabb7f",
      "item": {
        "type": "paragraph",
        "id": "fe38d0238ddabb7f",
        "text": "p. 361 [[Models of Multiplication]]"
      },
      "date": 1659864605145
    }
  ]
}