{
  "title": "Sign",
  "story": [
    {
      "type": "paragraph",
      "id": "03dc2e4b02fbf71f",
      "text": "The predicate \"sign\" does not denote an inherent feature of an [[Object]], but rather a specific way of treating it. In fact, almost anything can be used as a sign by someone. Clouds can be taken as a sign of rain, smoke as a sign of fire, footprints as a sign of a human, clothes as a sign of life-style. However, it is a fact that some objects are particularly popular as signs and obtain value solely from this function. This is true of letters, vocal sounds and pictures whose primary reason for being is to function as signs. It is not true of clouds and footprints that occur independently of whether someone uses them as signs or not. Still other objects are not primarily used as signs, but regularly participate in secondary semiotic processes. This is true of many artefacts; although the primary purpose of cars is transportation, the meaning of the design is important to the buyer since it signifies social status and life-style. However, even the most dashing design cannot sell a car that cannot run. >> sign object"
    },
    {
      "type": "paragraph",
      "id": "3bdff281d14fb531",
      "text": "Computer systems resemble letters more than clouds and cars because their primary function is to enter into semiosis. A payroll system stands for employees and wages, a flight reservation system for planes, seats, and flights, a geographic information system for buildings and streets, an economic model for incomes, expenditures and taxes, and an action game for soldiers, guns and combat. If such systems cannot participate in semiosis and their data cannot be interpreted as employees, wages, planes, seats, houses, streets, etc., they are normally considered faulty. >> semiosis data"
    },
    {
      "type": "paragraph",
      "id": "2e248036e175e29a",
      "text": "Note that we do not as yet require the systems to stand for true properties of their domain. This requirement is only sensible for some kinds of systems but not for others. For example, the employee can rightfully expect that the payroll system correctly accumulates the amount of money he has received up till now, and the geographical information systems should not place a house on a location where the real town has a road. But in other cases, truth is not relevant: you cannot get your money back because […] your action game does not assert true facts about reality. >> truth fact"
    },
    {
      "type": "paragraph",
      "id": "1309d6d2ff261ce5",
      "text": "In still other cases, a system may contain data that creates the state of affairs they stand for and for this reason cannot be true of false. This is e.g. true of the booking data of flight reservation systems: booking a seat on a flight does not reflect a pre-existing state of affairs, but creates a social obligation involving passenger and company: the company promises to let the passenger occupy the seat and transport him to the agreed destination, whereas the passenger promises payment in return. However, the system will also contain data that is intended to be taken as true statements about the present or the future: for example the number of seats of a plane or its destination. >> social obligation"
    },
    {
      "type": "pagefold",
      "id": "a4f8c869a332dd49",
      "text": "Sign-Vehicle"
    },
    {
      "type": "paragraph",
      "id": "e13957bfea792609",
      "text": "Thus, the main motivation for creating a discipline of computer semiotics is that the primary function of computer systems is to work as sign-vehicles. The reason why [[Peter Bøgh Andersen]] is not proposing a discipline of aeroplane-semiotics is that the main purpose of aeroplanes is transportation and not semiosis. For this reason semiotics can be expected to reveal basic and important properties of computer systems but not of aeroplanes."
    },
    {
      "type": "paragraph",
      "id": "e807034613e77dab",
      "text": "Our discussion has also exemplified how semiotics can be useful for designing and understanding computer systems, namely by offering more precise concepts for understanding semiosis. If it is true that computer systems are primarily used as sign-vehicles, then non-semiotic approaches will have to deal with the same phenomena as semiotics do. We will expect to find semiotic concepts in other approaches, although used in a more naive and less systematic way, and this is indeed true."
    },
    {
      "type": "paragraph",
      "id": "a31432915a8ca805",
      "text": "One example is object-oriented design and programming. The method distinguishes between a computer model and a domain of the model, the computer model being similar to aspects of its domain. The classes of the model are said to correspond to collections of objects in the domain, the instances of the classes to objects of the domain, methods of the classes to actions and events in the domain, and variables of the classes to properties of the domain objects."
    },
    {
      "type": "paragraph",
      "id": "37c06e8da7cc3f79",
      "text": "⇒ [[Model]] (p. 3–4)"
    },
    {
      "type": "paragraph",
      "id": "d87ddf1c520e4828",
      "text": "In the notion of \"model\" there is a clear invitation to see a computer system as a collection of true statements about the domain, but a systematic semiotic analysis of real computer based signs reveal a more complex picture. Let us start by classifying the computer model as a signifier and the domain as the signified, assuming that the model is taken by designer or user to stand for some aspects of its domain. But since we know there are many kinds of relationships between signifier and signified, we will not stop here but insist on a careful analysis of the relationship between signifier and signified. In some cases we will classify data as statements about the domain and relate them to the class of representative signs; but in other cases we will see them as forces that change the domain (directive or commissive signs) or discover that they stand for fictive phenomena. In short, we replace the simple idea of \"modelling\" by a more detailed description of signifier-signified relations. >> model"
    },
    {
      "type": "paragraph",
      "id": "60db0c19120f1526",
      "text": "A closer look at semiosis will have the same effect. The computer model is assumed to stand for the domain, but to whom? The model itself, in the shape of source code and diagrams, is normally only perceived by systems developers, and thus can only be said to stand for the domain to this group of people. Users have no contact with the global model in their daily work, but only interact with small pieces of model executions. The semiosis taking place here is very different from the one system developers experience, and there is absolutely no reason to expect that the meanings created during systems development automatically migrate to the use situation. >> computer model domain"
    },
    {
      "type": "paragraph",
      "id": "d1a53605f29851f5",
      "text": "Putting systems development under the semiotic microscope reveals new interesting sign-types. We quickly discover that it is only a half-truth that the source code stands for the domain. Many lines of source code turn out to stand for the computer hardware or software. As an illustration to this, suppose we have an object such as employee:"
    },
    {
      "type": "code",
      "id": "a7149205240a01ff",
      "text": "class Employee { \n  string Name, Address; \n  int WageType, TaxDeduction ; \n  int Accumulatedlncome; \n  virtual void Payment(int Amount){....} \n}"
    },
    {
      "type": "paragraph",
      "id": "1cc4e6f35905c94d",
      "text": "The variables and methods of this object can easily be taken to stand for domain features: an employee has a name, lives at an address, pays so much tax, has earned a certain sum and can receive a payment. But the object must also contain a method for displaying itself on a screen, say Display(), and this method will contain code specifying where to place the variables on the screen, say Print(Name, 10, 20) that prints the name on line 10 starting in position 20. Now, \"10, 20\" does not stand for the domain, but for a location on the hardware."
    },
    {
      "type": "paragraph",
      "id": "c259f1fdedda77bc",
      "text": "Besides references to hardware, the code contains many references to other pieces of code, i.e. references to itself. Consider a definition of Display():"
    },
    {
      "type": "code",
      "id": "c0692baeb61c96da",
      "text": "virtual void Display(){ \n  Print(Name, 10, 20); \n  Print(Address, 11, 20); \n  Print(Accumulatedlncome, 12, 20);\n}"
    },
    {
      "type": "paragraph",
      "id": "ce08eeb4eb7b4f6b",
      "text": "The definition says that performing \"Display\" is the same as performing the \"Print\"-method three times, where \"Print\" refers to the definition of \"Print\" somewhere else in the code. Thus, calling the \"Print\" method implies a reference to its declaration. In general, most uses of concepts in programs involves a reference to another location in the program where the concept is defined; and the definition normally uses new concepts for which the same is true. The unravelling of such references to references is routinely performed by any compiler (where the process is called \"linking\") ."
    },
    {
      "type": "paragraph",
      "id": "812041efeeb7fce4",
      "text": "Instead of having one sign-type standing for the domain, we find ourselves with at least three sign types distinguished by their reference: domain, hardware or software, and real programs reveal even more layers than three."
    },
    {
      "type": "paragraph",
      "id": "1a343cb9dea5eec7",
      "text": "We can also begin wondering which forces maintain the relation between signifier and signified. What guarantees, for example, that instance #0099 of class employee in fact represents me? It probably turns out that the relation between #0099 and myself is guaranteed by a conventional rule: I just happen to have the name Name and live at the street named Address, but I and my street could easily have had other names. Signs that are based on conventional relations between signifier and signified are called symbols (this class includes the natural languages), but botanizing a bit more reveals another type of signs that is not based on a convention but rather on a cause-effect relation. We only have to visit the local power plant to discover signs that are not entered into the computer by a human following a set of conventions, but are produced mechanically by a gauge measuring pressure and temperature in boilers. This sign type is called indexes and includes the clouds, smoke and footprints mentioned before. >> symbol cause effect relation index"
    },
    {
      "type": "paragraph",
      "id": "6d7e73659006bb38",
      "text": "Thus, semiotics furnishes a more precise vocabulary and enables us to discover differences we might otherwise not have noticed. In addition, it helps us comparing computer systems to other kinds of sign-systems. >> compare computer sign system"
    },
    {
      "type": "pagefold",
      "id": "c3d6e1ba58b67782",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "ce2abdd8757da83c",
      "text": "ANDERSEN, P. B., 1997. A theory of computer semiotics: semiotic approaches to construction and assessment of computer systems. Updated ed. Cambridge ; New York, NY, USA: Cambridge University Press. Cambridge series on human-computer interaction, 3. ISBN 978-0-521-44868-0, p. 2–3; ⇒ [[Model]] p. 3–4; p. 4–5"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Sign",
        "story": []
      },
      "date": 1679590464702
    },
    {
      "item": {
        "type": "factory",
        "id": "03dc2e4b02fbf71f"
      },
      "id": "03dc2e4b02fbf71f",
      "type": "add",
      "date": 1679590472972
    },
    {
      "type": "edit",
      "id": "03dc2e4b02fbf71f",
      "item": {
        "type": "paragraph",
        "id": "03dc2e4b02fbf71f",
        "text": "The predicate \"sign\" does not denote an inherent feature of an object, but rather a specific way of treating it. In fact, almost anything can be used as a sign by someone. Clouds can be taken as a sign of rain, smoke as a sign of fire, footprints as a sign of a human, clothes as a sign of life-style. However, it is a fact that some objects are particularly popular as signs and obtain value solely from this function. This is true of letters, vocal sounds and pictures whose primary reason for being is to function as signs. It is not true of clouds and footprints that occur independently of whether someone uses them as signs or not. Still other objects are not primarily used as signs, but regularly participate in secondary semiotic processes. This is true of many artefacts; although the primary purpose of cars is transportation, the meaning of the design is important to the buyer since it signifies social status and life-style. However, even the most dashing design cannot sell a car that cannot run."
      },
      "date": 1679590474930
    },
    {
      "id": "c3d6e1ba58b67782",
      "type": "add",
      "item": {
        "type": "pagefold",
        "id": "c3d6e1ba58b67782",
        "text": "~"
      },
      "after": "03dc2e4b02fbf71f",
      "attribution": {
        "page": "Semiotics"
      },
      "date": 1679590481794
    },
    {
      "id": "ce2abdd8757da83c",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "ce2abdd8757da83c",
        "text": "ANDERSEN, P. B., 1997. A theory of computer semiotics: semiotic approaches to construction and assessment of computer systems. Updated ed. Cambridge ; New York, NY, USA: Cambridge University Press. Cambridge series on human-computer interaction, 3. ISBN 978-0-521-44868-0. "
      },
      "after": "03dc2e4b02fbf71f",
      "attribution": {
        "page": "Semiotics"
      },
      "date": 1679590488409
    },
    {
      "id": "c3d6e1ba58b67782",
      "type": "move",
      "order": [
        "03dc2e4b02fbf71f",
        "c3d6e1ba58b67782",
        "ce2abdd8757da83c"
      ],
      "date": 1679590490209
    },
    {
      "type": "edit",
      "id": "ce2abdd8757da83c",
      "item": {
        "type": "paragraph",
        "id": "ce2abdd8757da83c",
        "text": "ANDERSEN, P. B., 1997. A theory of computer semiotics: semiotic approaches to construction and assessment of computer systems. Updated ed. Cambridge ; New York, NY, USA: Cambridge University Press. Cambridge series on human-computer interaction, 3. ISBN 978-0-521-44868-0, p. 2. "
      },
      "date": 1679590500516
    },
    {
      "type": "edit",
      "id": "03dc2e4b02fbf71f",
      "item": {
        "type": "paragraph",
        "id": "03dc2e4b02fbf71f",
        "text": "The predicate \"sign\" does not denote an inherent feature of an [[Object]], but rather a specific way of treating it. In fact, almost anything can be used as a sign by someone. Clouds can be taken as a sign of rain, smoke as a sign of fire, footprints as a sign of a human, clothes as a sign of life-style. However, it is a fact that some objects are particularly popular as signs and obtain value solely from this function. This is true of letters, vocal sounds and pictures whose primary reason for being is to function as signs. It is not true of clouds and footprints that occur independently of whether someone uses them as signs or not. Still other objects are not primarily used as signs, but regularly participate in secondary semiotic processes. This is true of many artefacts; although the primary purpose of cars is transportation, the meaning of the design is important to the buyer since it signifies social status and life-style. However, even the most dashing design cannot sell a car that cannot run. >> sign object"
      },
      "date": 1679590570204
    },
    {
      "type": "add",
      "id": "3bdff281d14fb531",
      "item": {
        "type": "paragraph",
        "id": "3bdff281d14fb531",
        "text": "Computer systems resemble letters more than clouds and cars because their primary function is to enter into semiosis. A payroll system stands for employees and wages, a flight reservation system for planes, seats, and flights, a geographic information system for buildings and streets, an economic model for incomes, expenditures and taxes, and an action game for soldiers, guns and combat. If such systems cannot participate in semiosis and their data cannot be interpreted as employees, wages, planes, seats, houses, streets, etc., they are normally considered faulty."
      },
      "after": "03dc2e4b02fbf71f",
      "date": 1679590644266
    },
    {
      "type": "edit",
      "id": "3bdff281d14fb531",
      "item": {
        "type": "paragraph",
        "id": "3bdff281d14fb531",
        "text": "Computer systems resemble letters more than clouds and cars because their primary function is to enter into semiosis. A payroll system stands for employees and wages, a flight reservation system for planes, seats, and flights, a geographic information system for buildings and streets, an economic model for incomes, expenditures and taxes, and an action game for soldiers, guns and combat. If such systems cannot participate in semiosis and their data cannot be interpreted as employees, wages, planes, seats, houses, streets, etc., they are normally considered faulty. >> semiosis"
      },
      "date": 1679590665518
    },
    {
      "type": "edit",
      "id": "3bdff281d14fb531",
      "item": {
        "type": "paragraph",
        "id": "3bdff281d14fb531",
        "text": "Computer systems resemble letters more than clouds and cars because their primary function is to enter into semiosis. A payroll system stands for employees and wages, a flight reservation system for planes, seats, and flights, a geographic information system for buildings and streets, an economic model for incomes, expenditures and taxes, and an action game for soldiers, guns and combat. If such systems cannot participate in semiosis and their data cannot be interpreted as employees, wages, planes, seats, houses, streets, etc., they are normally considered faulty. >> semiosis data"
      },
      "date": 1679590690018
    },
    {
      "type": "add",
      "id": "2e248036e175e29a",
      "item": {
        "type": "paragraph",
        "id": "2e248036e175e29a",
        "text": "Note that we do not as yet require the systems to stand for true properties of their domain. This requirement is only sensible for some kinds of systems but not for others. For example, the employee can rightfully expect that the payroll system correctly accumulates the amount of money he has received up till now, and the geographical information systems should not place a house on a location where the real town has a road."
      },
      "after": "3bdff281d14fb531",
      "date": 1679590719288
    },
    {
      "type": "edit",
      "id": "ce2abdd8757da83c",
      "item": {
        "type": "paragraph",
        "id": "ce2abdd8757da83c",
        "text": "ANDERSEN, P. B., 1997. A theory of computer semiotics: semiotic approaches to construction and assessment of computer systems. Updated ed. Cambridge ; New York, NY, USA: Cambridge University Press. Cambridge series on human-computer interaction, 3. ISBN 978-0-521-44868-0, p. 2–3. "
      },
      "date": 1679590748842
    },
    {
      "type": "edit",
      "id": "2e248036e175e29a",
      "item": {
        "type": "paragraph",
        "id": "2e248036e175e29a",
        "text": "Note that we do not as yet require the systems to stand for true properties of their domain. This requirement is only sensible for some kinds of systems but not for others. For example, the employee can rightfully expect that the payroll system correctly accumulates the amount of money he has received up till now, and the geographical information systems should not place a house on a location where the real town has a road. But in other cases, truth"
      },
      "date": 1679590758256
    },
    {
      "type": "edit",
      "id": "2e248036e175e29a",
      "item": {
        "type": "paragraph",
        "id": "2e248036e175e29a",
        "text": "Note that we do not as yet require the systems to stand for true properties of their domain. This requirement is only sensible for some kinds of systems but not for others. For example, the employee can rightfully expect that the payroll system correctly accumulates the amount of money he has received up till now, and the geographical information systems should not place a house on a location where the real town has a road. But in other cases, truth is not relevant: you cannot get your money back because the your action game does not assert true facts about reality. >> truth"
      },
      "date": 1679590771387
    },
    {
      "type": "edit",
      "id": "2e248036e175e29a",
      "item": {
        "type": "paragraph",
        "id": "2e248036e175e29a",
        "text": "Note that we do not as yet require the systems to stand for true properties of their domain. This requirement is only sensible for some kinds of systems but not for others. For example, the employee can rightfully expect that the payroll system correctly accumulates the amount of money he has received up till now, and the geographical information systems should not place a house on a location where the real town has a road. But in other cases, truth is not relevant: you cannot get your money back because […] your action game does not assert true facts about reality. >> truth"
      },
      "date": 1679590841299
    },
    {
      "type": "edit",
      "id": "2e248036e175e29a",
      "item": {
        "type": "paragraph",
        "id": "2e248036e175e29a",
        "text": "Note that we do not as yet require the systems to stand for true properties of their domain. This requirement is only sensible for some kinds of systems but not for others. For example, the employee can rightfully expect that the payroll system correctly accumulates the amount of money he has received up till now, and the geographical information systems should not place a house on a location where the real town has a road. But in other cases, truth is not relevant: you cannot get your money back because […] your action game does not assert true facts about reality. >> truth fact"
      },
      "date": 1679590878327
    },
    {
      "item": {
        "type": "factory",
        "id": "1309d6d2ff261ce5"
      },
      "id": "1309d6d2ff261ce5",
      "type": "add",
      "after": "ce2abdd8757da83c",
      "date": 1679590931661
    },
    {
      "id": "1309d6d2ff261ce5",
      "type": "move",
      "order": [
        "03dc2e4b02fbf71f",
        "3bdff281d14fb531",
        "2e248036e175e29a",
        "1309d6d2ff261ce5",
        "c3d6e1ba58b67782",
        "ce2abdd8757da83c"
      ],
      "date": 1679590933548
    },
    {
      "type": "edit",
      "id": "1309d6d2ff261ce5",
      "item": {
        "type": "paragraph",
        "id": "1309d6d2ff261ce5",
        "text": "In still other cases, a system may contain data that creates the state of affairs they stand for and for this reason cannot be true of false. This is e.g. true of the booking data of flight reservation systems: booking a seat on a flight does not reflect a pre-existing state of affairs, but creates a social obligation involving passenger and company: the company promises to let the passenger occupy the seat and transport him to the agreed destination, whereas the passenger promises payment in return. However, the system will also contain data that is intended to be taken as true statements about the present or the future: for example the number of seats of a plane or its destination."
      },
      "date": 1679590934865
    },
    {
      "type": "edit",
      "id": "1309d6d2ff261ce5",
      "item": {
        "type": "paragraph",
        "id": "1309d6d2ff261ce5",
        "text": "In still other cases, a system may contain data that creates the state of affairs they stand for and for this reason cannot be true of false. This is e.g. true of the booking data of flight reservation systems: booking a seat on a flight does not reflect a pre-existing state of affairs, but creates a social obligation involving passenger and company: the company promises to let the passenger occupy the seat and transport him to the agreed destination, whereas the passenger promises payment in return. However, the system will also contain data that is intended to be taken as true statements about the present or the future: for example the number of seats of a plane or its destination. >> social obligation"
      },
      "date": 1679590968346
    },
    {
      "type": "add",
      "id": "e13957bfea792609",
      "item": {
        "type": "paragraph",
        "id": "e13957bfea792609",
        "text": "Thus, the main motivation for creating a discipline of computer semiotics is that the primary function of computer systems is to work as sign-vehicles. The reason why I am not proposing a discipline of aeroplane-semiotics is that the main purpose of aeroplanes is transportation and not semiosis. For this reason semiotics can be expected to reveal basic and important properties of computer systems but not of aeroplanes."
      },
      "after": "1309d6d2ff261ce5",
      "date": 1679591017215
    },
    {
      "type": "add",
      "id": "e807034613e77dab",
      "item": {
        "type": "paragraph",
        "id": "e807034613e77dab",
        "text": "Our discussion has also exemplified how semiotics can be useful for designing and understanding computer systems, namely by offering more precise concepts for understanding semiosis. If it is true that computer systems are primarily used as sign-vehicles, then non-semiotic approaches will have to deal with the same phenomena as semiotics do. We will expect to find semiotic concepts in other approaches, although used in a more naive and less systematic way, and this is indeed true."
      },
      "after": "e13957bfea792609",
      "date": 1679591060476
    },
    {
      "item": {
        "type": "factory",
        "id": "a4f8c869a332dd49"
      },
      "id": "a4f8c869a332dd49",
      "type": "add",
      "after": "ce2abdd8757da83c",
      "date": 1679591077864
    },
    {
      "type": "edit",
      "id": "a4f8c869a332dd49",
      "item": {
        "type": "pagefold",
        "id": "a4f8c869a332dd49",
        "text": "Sign-Vehicle"
      },
      "date": 1679591080057
    },
    {
      "id": "a4f8c869a332dd49",
      "type": "move",
      "order": [
        "03dc2e4b02fbf71f",
        "3bdff281d14fb531",
        "2e248036e175e29a",
        "1309d6d2ff261ce5",
        "a4f8c869a332dd49",
        "e13957bfea792609",
        "e807034613e77dab",
        "c3d6e1ba58b67782",
        "ce2abdd8757da83c"
      ],
      "date": 1679591084526
    },
    {
      "type": "add",
      "id": "a31432915a8ca805",
      "item": {
        "type": "paragraph",
        "id": "a31432915a8ca805",
        "text": "One example is object-oriented design and programming. The method distinguishes between a computer model and a domain of the model, the computer model being similar to aspects of its domain. The classes of the model are said to correspond to collections of objects in the domain, the instances of the classes to objects of the domain, methods of the classes to actions and events in the domain, and variables of the classes to properties of the domain objects."
      },
      "after": "e807034613e77dab",
      "date": 1679591146325
    },
    {
      "type": "add",
      "id": "37c06e8da7cc3f79",
      "item": {
        "type": "paragraph",
        "id": "37c06e8da7cc3f79",
        "text": "[[Model]]"
      },
      "after": "a31432915a8ca805",
      "date": 1679591191573
    },
    {
      "type": "edit",
      "id": "37c06e8da7cc3f79",
      "item": {
        "type": "paragraph",
        "id": "37c06e8da7cc3f79",
        "text": "⇒ [[Model]]"
      },
      "date": 1679591200882
    },
    {
      "type": "add",
      "id": "d87ddf1c520e4828",
      "item": {
        "type": "paragraph",
        "id": "d87ddf1c520e4828",
        "text": "In the notion of \"model\" there is a clear invitation to see a computer system as a collection of true statements about the domain, but a systematic semiotic analysis of real computer based signs reveal a more complex picture. Let us start by classifying the computer model as a signifier and the domain as the signified, assuming that the model is taken by designer or user to stand for some aspects of its domain. But since we know there are many kinds of relationships between signifier and signified, we will not stop here but insist on a careful analysis of the relationship between signifier and signified. In some cases we will classify data as statements about the domain and relate them to the class of representative signs; but in other cases we will see them"
      },
      "after": "37c06e8da7cc3f79",
      "date": 1679591234883
    },
    {
      "type": "edit",
      "id": "d87ddf1c520e4828",
      "item": {
        "type": "paragraph",
        "id": "d87ddf1c520e4828",
        "text": "In the notion of \"model\" there is a clear invitation to see a computer system as a collection of true statements about the domain, but a systematic semiotic analysis of real computer based signs reveal a more complex picture. Let us start by classifying the computer model as a signifier and the domain as the signified, assuming that the model is taken by designer or user to stand for some aspects of its domain. But since we know there are many kinds of relationships between signifier and signified, we will not stop here but insist on a careful analysis of the relationship between signifier and signified. In some cases we will classify data as statements about the domain and relate them to the class of representative signs; but in other cases we will see them as forces that change the domain (directive or commissive signs) or discover that they stand for fictive phenomena. In short, we replace the simple idea of \"modelling\" by a more detailed description of signifier-signified relations."
      },
      "date": 1679591262166
    },
    {
      "type": "edit",
      "id": "37c06e8da7cc3f79",
      "item": {
        "type": "paragraph",
        "id": "37c06e8da7cc3f79",
        "text": "⇒ [[Model]] (p. 3–4)"
      },
      "date": 1679591267781
    },
    {
      "type": "edit",
      "id": "ce2abdd8757da83c",
      "item": {
        "type": "paragraph",
        "id": "ce2abdd8757da83c",
        "text": "ANDERSEN, P. B., 1997. A theory of computer semiotics: semiotic approaches to construction and assessment of computer systems. Updated ed. Cambridge ; New York, NY, USA: Cambridge University Press. Cambridge series on human-computer interaction, 3. ISBN 978-0-521-44868-0, p. 2–3; ⇒ [[Model]] p. 3–4"
      },
      "date": 1679591303614
    },
    {
      "type": "edit",
      "id": "d87ddf1c520e4828",
      "item": {
        "type": "paragraph",
        "id": "d87ddf1c520e4828",
        "text": "In the notion of \"model\" there is a clear invitation to see a computer system as a collection of true statements about the domain, but a systematic semiotic analysis of real computer based signs reveal a more complex picture. Let us start by classifying the computer model as a signifier and the domain as the signified, assuming that the model is taken by designer or user to stand for some aspects of its domain. But since we know there are many kinds of relationships between signifier and signified, we will not stop here but insist on a careful analysis of the relationship between signifier and signified. In some cases we will classify data as statements about the domain and relate them to the class of representative signs; but in other cases we will see them as forces that change the domain (directive or commissive signs) or discover that they stand for fictive phenomena. In short, we replace the simple idea of \"modelling\" by a more detailed description of signifier-signified relations. >> model"
      },
      "date": 1679591340017
    },
    {
      "type": "add",
      "id": "60db0c19120f1526",
      "item": {
        "type": "paragraph",
        "id": "60db0c19120f1526",
        "text": "A closer look at semiosis will have the same effect. The computer model is assumed to stand for the domain, but to whom? The model itself, in the shape of source code and diagrams, is normally only perceived by systems developers, and thus can only be said to stand for the domain to this group of people. Users have no contact with the global model in their daily work, but only interact with small pieces of model executions. The semiosis taking place here is very different from the one system developers experience, and there is absolutely no reason to expect that the meanings created during systems development automatically migrate to the use situation."
      },
      "after": "d87ddf1c520e4828",
      "date": 1679591368242
    },
    {
      "type": "add",
      "id": "d1a53605f29851f5",
      "item": {
        "type": "paragraph",
        "id": "d1a53605f29851f5",
        "text": "Putting systems development under the semiotic microscope reveals new interesting sign-types. We quickly discover that it is only a half-truth that the source code stands for the domain. Many lines of source code turn out to stand for the computer hardware or software. As an illustration to this, suppose we have an object such as employee:"
      },
      "after": "60db0c19120f1526",
      "date": 1679591409532
    },
    {
      "item": {
        "type": "factory",
        "id": "a7149205240a01ff"
      },
      "id": "a7149205240a01ff",
      "type": "add",
      "after": "ce2abdd8757da83c",
      "date": 1679591419026
    },
    {
      "id": "a7149205240a01ff",
      "type": "move",
      "order": [
        "03dc2e4b02fbf71f",
        "3bdff281d14fb531",
        "2e248036e175e29a",
        "1309d6d2ff261ce5",
        "a4f8c869a332dd49",
        "e13957bfea792609",
        "e807034613e77dab",
        "a31432915a8ca805",
        "37c06e8da7cc3f79",
        "d87ddf1c520e4828",
        "60db0c19120f1526",
        "d1a53605f29851f5",
        "a7149205240a01ff",
        "c3d6e1ba58b67782",
        "ce2abdd8757da83c"
      ],
      "date": 1679591420782
    },
    {
      "type": "edit",
      "id": "a7149205240a01ff",
      "item": {
        "type": "code",
        "id": "a7149205240a01ff",
        "text": "class Employee { string Name, Address; int WageType, TaxDeduction ; int Accumulatedlncome; virtual void Payment(int Amount){....} }"
      },
      "date": 1679591422523
    },
    {
      "type": "edit",
      "id": "a7149205240a01ff",
      "item": {
        "type": "code",
        "id": "a7149205240a01ff",
        "text": "class Employee { \nstring Name, Address; int WageType, TaxDeduction ; int Accumulatedlncome; virtual void Payment(int Amount){....} }"
      },
      "date": 1679591431871
    },
    {
      "type": "edit",
      "id": "a7149205240a01ff",
      "item": {
        "type": "code",
        "id": "a7149205240a01ff",
        "text": "class Employee { \n  string Name, Address; \n  int WageType, TaxDeduction ; \n  int Accumulatedlncome; \n  virtual void Payment(int Amount){....} }"
      },
      "date": 1679591449583
    },
    {
      "type": "edit",
      "id": "a7149205240a01ff",
      "item": {
        "type": "code",
        "id": "a7149205240a01ff",
        "text": "class Employee { \n  string Name, Address; \n  int WageType, TaxDeduction ; \n  int Accumulatedlncome; \n  virtual void Payment(int Amount){....} \n}"
      },
      "date": 1679591461453
    },
    {
      "item": {
        "type": "factory",
        "id": "1cc4e6f35905c94d"
      },
      "id": "1cc4e6f35905c94d",
      "type": "add",
      "after": "ce2abdd8757da83c",
      "date": 1679591479102
    },
    {
      "id": "1cc4e6f35905c94d",
      "type": "move",
      "order": [
        "03dc2e4b02fbf71f",
        "3bdff281d14fb531",
        "2e248036e175e29a",
        "1309d6d2ff261ce5",
        "a4f8c869a332dd49",
        "e13957bfea792609",
        "e807034613e77dab",
        "a31432915a8ca805",
        "37c06e8da7cc3f79",
        "d87ddf1c520e4828",
        "60db0c19120f1526",
        "d1a53605f29851f5",
        "a7149205240a01ff",
        "1cc4e6f35905c94d",
        "c3d6e1ba58b67782",
        "ce2abdd8757da83c"
      ],
      "date": 1679591481114
    },
    {
      "type": "edit",
      "id": "1cc4e6f35905c94d",
      "item": {
        "type": "paragraph",
        "id": "1cc4e6f35905c94d",
        "text": "The variables and methods of this object can easily be taken to stand for domain features: an employee has a name, lives at an address, pays so much tax, has earned a certain sum and can receive a payment. But the object must also contain a method for displaying itself on a screen, say Display(), and this method will contain code specifying where to place the variables on the screen, say Print(Name, 10, 20) that prints the name on line 10 starting in position 20. Now, \"10, 20\" does not stand for the domain, but for a location on the hardware."
      },
      "date": 1679591482344
    },
    {
      "type": "add",
      "id": "c259f1fdedda77bc",
      "item": {
        "type": "paragraph",
        "id": "c259f1fdedda77bc",
        "text": "Besides references to hardware, the code contains many references to other pieces of code, i.e. references to itself. Consider a definition of Display():"
      },
      "after": "1cc4e6f35905c94d",
      "date": 1679591499424
    },
    {
      "item": {
        "type": "factory",
        "id": "c0692baeb61c96da"
      },
      "id": "c0692baeb61c96da",
      "type": "add",
      "after": "ce2abdd8757da83c",
      "date": 1679591511471
    },
    {
      "id": "c0692baeb61c96da",
      "type": "move",
      "order": [
        "03dc2e4b02fbf71f",
        "3bdff281d14fb531",
        "2e248036e175e29a",
        "1309d6d2ff261ce5",
        "a4f8c869a332dd49",
        "e13957bfea792609",
        "e807034613e77dab",
        "a31432915a8ca805",
        "37c06e8da7cc3f79",
        "d87ddf1c520e4828",
        "60db0c19120f1526",
        "d1a53605f29851f5",
        "a7149205240a01ff",
        "1cc4e6f35905c94d",
        "c259f1fdedda77bc",
        "c0692baeb61c96da",
        "c3d6e1ba58b67782",
        "ce2abdd8757da83c"
      ],
      "date": 1679591514668
    },
    {
      "type": "edit",
      "id": "c0692baeb61c96da",
      "item": {
        "type": "code",
        "id": "c0692baeb61c96da",
        "text": "virtual void Display(){ \n  Print(Name, 10, 20); \n  Print(Address, 11, 20); \n  Print(Accumulatedlncome, 12, 20);\n}"
      },
      "date": 1679591531895
    },
    {
      "item": {
        "type": "factory",
        "id": "ce08eeb4eb7b4f6b"
      },
      "id": "ce08eeb4eb7b4f6b",
      "type": "add",
      "after": "ce2abdd8757da83c",
      "date": 1679591555515
    },
    {
      "id": "ce08eeb4eb7b4f6b",
      "type": "move",
      "order": [
        "03dc2e4b02fbf71f",
        "3bdff281d14fb531",
        "2e248036e175e29a",
        "1309d6d2ff261ce5",
        "a4f8c869a332dd49",
        "e13957bfea792609",
        "e807034613e77dab",
        "a31432915a8ca805",
        "37c06e8da7cc3f79",
        "d87ddf1c520e4828",
        "60db0c19120f1526",
        "d1a53605f29851f5",
        "a7149205240a01ff",
        "1cc4e6f35905c94d",
        "c259f1fdedda77bc",
        "c0692baeb61c96da",
        "ce08eeb4eb7b4f6b",
        "c3d6e1ba58b67782",
        "ce2abdd8757da83c"
      ],
      "date": 1679591561084
    },
    {
      "type": "edit",
      "id": "ce08eeb4eb7b4f6b",
      "item": {
        "type": "paragraph",
        "id": "ce08eeb4eb7b4f6b",
        "text": "[…]"
      },
      "date": 1679591567101
    },
    {
      "type": "edit",
      "id": "60db0c19120f1526",
      "item": {
        "type": "paragraph",
        "id": "60db0c19120f1526",
        "text": "A closer look at semiosis will have the same effect. The computer model is assumed to stand for the domain, but to whom? The model itself, in the shape of source code and diagrams, is normally only perceived by systems developers, and thus can only be said to stand for the domain to this group of people. Users have no contact with the global model in their daily work, but only interact with small pieces of model executions. The semiosis taking place here is very different from the one system developers experience, and there is absolutely no reason to expect that the meanings created during systems development automatically migrate to the use situation. >> computer model domain"
      },
      "date": 1679591598396
    },
    {
      "type": "edit",
      "id": "ce08eeb4eb7b4f6b",
      "item": {
        "type": "paragraph",
        "id": "ce08eeb4eb7b4f6b",
        "text": "The definition says that performing \"Display\" is the same as performing the \"Print\"-method three times, where \"Print\" refers to the definition of \"Print\" somewhere else in the code. Thus, calling the \"Print\" method implies a reference to its declaration. In general, most uses of concepts in programs involves a reference to another location in the program where the concept is defined; and the definition normally uses new concepts for which the same is true. The unravelling of such references to references is routinely performed by any compiler (where the process is called \"linking\") ."
      },
      "date": 1679591737221
    },
    {
      "type": "add",
      "id": "812041efeeb7fce4",
      "item": {
        "type": "paragraph",
        "id": "812041efeeb7fce4",
        "text": "[…]"
      },
      "after": "ce08eeb4eb7b4f6b",
      "date": 1679591737729
    },
    {
      "type": "edit",
      "id": "812041efeeb7fce4",
      "item": {
        "type": "paragraph",
        "id": "812041efeeb7fce4",
        "text": "Instead of having one sign-type standing for the domain, we find ourselves with at least three sign types distinguished by their reference: domain, hardware or software, and real programs reveal even more layers than three."
      },
      "date": 1679591761482
    },
    {
      "type": "add",
      "id": "6d7e73659006bb38",
      "item": {
        "type": "paragraph",
        "id": "6d7e73659006bb38",
        "text": "[…]"
      },
      "after": "812041efeeb7fce4",
      "date": 1679591761964
    },
    {
      "type": "add",
      "id": "1a343cb9dea5eec7",
      "item": {
        "type": "paragraph",
        "id": "1a343cb9dea5eec7",
        "text": "We can also begin wondering which forces maintain the relation between signifier and signified. What guarantees, for example, that instance #0099 of class employee in fact represents me? It probably turns out that the relation between #0099 and myself is guaranteed by a conventional rule: I just happen to have the name Name and live at the street named Address, but I and my street could easily have had other names. Signs that are based on conventional relations between signifier and signified are called symbols (this class includes the natural languages), but botanizing a bit more reveals another type of signs that is not based on a convention but rather on a causeeffect relation. We only have to visit the local power plant to discover signs that are not entered into the computer by a human following a set of conventions, but are produced mechanically by a gauge measuring pressure and temperature in boilers. This sign type is called indexes and includes the clouds, smoke and footprints mentioned before."
      },
      "after": "812041efeeb7fce4",
      "date": 1679591799535
    },
    {
      "type": "edit",
      "id": "1a343cb9dea5eec7",
      "item": {
        "type": "paragraph",
        "id": "1a343cb9dea5eec7",
        "text": "We can also begin wondering which forces maintain the relation between signifier and signified. What guarantees, for example, that instance #0099 of class employee in fact represents me? It probably turns out that the relation between #0099 and myself is guaranteed by a conventional rule: I just happen to have the name Name and live at the street named Address, but I and my street could easily have had other names. Signs that are based on conventional relations between signifier and signified are called symbols (this class includes the natural languages), but botanizing a bit more reveals another type of signs that is not based on a convention but rather on a causeeffect relation. We only have to visit the local power plant to discover signs that are not entered into the computer by a human following a set of conventions, but are produced mechanically by a gauge measuring pressure and temperature in boilers. This sign type is called indexes and includes the clouds, smoke and footprints mentioned before. >> symbol"
      },
      "date": 1679591833325
    },
    {
      "type": "edit",
      "id": "1a343cb9dea5eec7",
      "item": {
        "type": "paragraph",
        "id": "1a343cb9dea5eec7",
        "text": "We can also begin wondering which forces maintain the relation between signifier and signified. What guarantees, for example, that instance #0099 of class employee in fact represents me? It probably turns out that the relation between #0099 and myself is guaranteed by a conventional rule: I just happen to have the name Name and live at the street named Address, but I and my street could easily have had other names. Signs that are based on conventional relations between signifier and signified are called symbols (this class includes the natural languages), but botanizing a bit more reveals another type of signs that is not based on a convention but rather on a cause-effect relation. We only have to visit the local power plant to discover signs that are not entered into the computer by a human following a set of conventions, but are produced mechanically by a gauge measuring pressure and temperature in boilers. This sign type is called indexes and includes the clouds, smoke and footprints mentioned before. >> symbol cause effect relation"
      },
      "date": 1679591865820
    },
    {
      "type": "edit",
      "id": "1a343cb9dea5eec7",
      "item": {
        "type": "paragraph",
        "id": "1a343cb9dea5eec7",
        "text": "We can also begin wondering which forces maintain the relation between signifier and signified. What guarantees, for example, that instance #0099 of class employee in fact represents me? It probably turns out that the relation between #0099 and myself is guaranteed by a conventional rule: I just happen to have the name Name and live at the street named Address, but I and my street could easily have had other names. Signs that are based on conventional relations between signifier and signified are called symbols (this class includes the natural languages), but botanizing a bit more reveals another type of signs that is not based on a convention but rather on a cause-effect relation. We only have to visit the local power plant to discover signs that are not entered into the computer by a human following a set of conventions, but are produced mechanically by a gauge measuring pressure and temperature in boilers. This sign type is called indexes and includes the clouds, smoke and footprints mentioned before. >> symbol cause effect relation index"
      },
      "date": 1679591903274
    },
    {
      "type": "edit",
      "id": "ce2abdd8757da83c",
      "item": {
        "type": "paragraph",
        "id": "ce2abdd8757da83c",
        "text": "ANDERSEN, P. B., 1997. A theory of computer semiotics: semiotic approaches to construction and assessment of computer systems. Updated ed. Cambridge ; New York, NY, USA: Cambridge University Press. Cambridge series on human-computer interaction, 3. ISBN 978-0-521-44868-0, p. 2–3; ⇒ [[Model]] p. 3–4; p. 4–5"
      },
      "date": 1679591933013
    },
    {
      "type": "edit",
      "id": "6d7e73659006bb38",
      "item": {
        "type": "paragraph",
        "id": "6d7e73659006bb38",
        "text": "Thus, semiotics furnishes a more precise vocabulary and enables us to discover differences we might otherwise not have noticed. In addition, it helps us comparing computer systems to other kinds of sign-systems."
      },
      "date": 1679591964273
    },
    {
      "type": "edit",
      "id": "6d7e73659006bb38",
      "item": {
        "type": "paragraph",
        "id": "6d7e73659006bb38",
        "text": "Thus, semiotics furnishes a more precise vocabulary and enables us to discover differences we might otherwise not have noticed. In addition, it helps us comparing computer systems to other kinds of sign-systems. >> sign system"
      },
      "date": 1679591983893
    },
    {
      "type": "edit",
      "id": "6d7e73659006bb38",
      "item": {
        "type": "paragraph",
        "id": "6d7e73659006bb38",
        "text": "Thus, semiotics furnishes a more precise vocabulary and enables us to discover differences we might otherwise not have noticed. In addition, it helps us comparing computer systems to other kinds of sign-systems. >> compare computer system sign system"
      },
      "date": 1679592147311
    },
    {
      "type": "edit",
      "id": "6d7e73659006bb38",
      "item": {
        "type": "paragraph",
        "id": "6d7e73659006bb38",
        "text": "Thus, semiotics furnishes a more precise vocabulary and enables us to discover differences we might otherwise not have noticed. In addition, it helps us comparing computer systems to other kinds of sign-systems. >> compare computer sign system"
      },
      "date": 1679592249404
    },
    {
      "type": "fork",
      "site": "books.dreyeck.ch",
      "date": 1679640966458
    },
    {
      "type": "edit",
      "id": "e13957bfea792609",
      "item": {
        "type": "paragraph",
        "id": "e13957bfea792609",
        "text": "Thus, the main motivation for creating a discipline of computer semiotics is that the primary function of computer systems is to work as sign-vehicles. The reason why [[Peter Bøgh Andersen]] is not proposing a discipline of aeroplane-semiotics is that the main purpose of aeroplanes is transportation and not semiosis. For this reason semiotics can be expected to reveal basic and important properties of computer systems but not of aeroplanes."
      },
      "date": 1679894166333
    }
  ]
}