{
  "title": "Coupling And Cohesion",
  "story": [
    {
      "type": "html",
      "text": "Given two lines of code, A and B, they are <b>coupled</b> when B must change behavior only because A changed.",
      "id": "8d5b8de534b5aa66d96a0fc603aeb208"
    },
    {
      "type": "html",
      "text": "\nThey are <b>cohesive</b> when a change to A allows B to change so that both add new value.",
      "id": "a56853f63cd23951c3ad26fdc1897ee7"
    },
    {
      "type": "html",
      "text": "\nThe difference between [[Coupling And Cohesion]] is a distinction on a process of change, not a static analysis of code's quality. But there are plenty of indicators and [[Best Practice]]s...",
      "id": "760c7b81cf446e734cc309829896c08e"
    },
    {
      "type": "html",
      "text": " Does \"must change behavior\" refer to source code changes, or run-time results?",
      "id": "0629bda2eb2447355229923b4d15081f"
    },
    {
      "type": "html",
      "text": " <i>It refers to explicit modification of behavior - i.e. the source code.  Automatically adapting run-time results in a value-added way more closely matches the concept of <b>cohesion</b>, below.  'Coupling' is more readily identified by the way things break. Consider: the only reason your B \"must\" change behavior as cause of A changing is that the change to A broke the behavior of B.</i>",
      "id": "6d0a342b3c82ecdd0bd88d2716cb1ef5"
    },
    {
      "type": "html",
      "text": "<i>It's my summary judgement that \"change\" is too open-ended to make this a rigorous concept, a discussed below. There's an effectively infinite way any given module can \"change\". One has to first \"tame\" and classify \"change\" as a prerequisite to rigor-tizing C-and-C if it's tied to the term \"change\". --top</i>",
      "id": "388f127eddb10fd27c803583249aac3a"
    },
    {
      "type": "html",
      "text": "\nThe rubric is chosen to give the term the most value in an [[Agile Software Development]] context; hardening code against bugs by pushing C1 down & C2 up.",
      "id": "e7915163861b4cb4a4eb0e220c9f8cf7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nIt would be difficult to escape the notion of <b>probability</b> here. There are often myriad potential changes and related cross-influences, but each change path is rarely equal. In practice, we are often weighing probabilities of different kinds of changes, sort of a cost/benefit/probability analysis of each potential change. Most authors who talk about C&C seem to bypass the issue of probability, making questionable or untested assumptions in the process as a substitute. Related: [[Change Pattern]]. --top",
      "id": "e141097da5567f9acb32204d76355b46"
    },
    {
      "type": "html",
      "text": "<i>Probability of change is a non-issue for [[Coupling And Cohesion]], but is important for [[Change Pattern]]s. Consider: two units may be tightly coupled even if the probability of change (and consequential breakage) is very low. Because of this, you must distinguish between the coupling and the probability of change.</i>",
      "id": "8910ea2718216c946bfe080664d3eed9"
    },
    {
      "type": "html",
      "text": "\nAlmost everything is \"coupled\" at least by the fact that the names must match.",
      "id": "2bbec94691bdf62d181e9c20363dc16a"
    },
    {
      "type": "html",
      "text": "<i>Uh... unless you mean to say \"Almost everything that is 'coupled' via a shared name dependency is 'coupled' by the fact that the names must match\" (which is trivially true) you are very much incorrect. For example, the code I'm (supposed to be) working on right now certainly isn't coupled to the code you're working on, and there is no need at all for names to match.</i>",
      "id": "3e7070c78d0371d4ce1a9ece61b1dd2a"
    },
    {
      "type": "html",
      "text": "\nThus, \"coupling\" is a matter of degree.",
      "id": "f7fe25840d420dc5ba14c7031bc298a9"
    },
    {
      "type": "html",
      "text": "''While it is true that coupling is a matter of degree. I can make no sense at all of the main statement just above. Does any one have any idea what it might mean?'\nI am thinking that it might be equivalent to the claim that programs that have no dependency at all  are not coupled-- have zero coupling, but I can not figure out how that leads to  \"coupling is a matter of degree\" unless 0 is a degree, but then I am not sure what the point was. HELP wanted here I think others may also be confused. - ANNON",
      "id": "4060f8032f27be8f97277b6b684cded8"
    },
    {
      "type": "html",
      "text": "<i>While your logic leading to it is baffling, I agree with this conclusion. That is why we discuss the desire for \"low\" external coupling and \"high\" internal cohesion.</i>",
      "id": "323454e8d5bc29bcd8bdfdf65667e4c7"
    },
    {
      "type": "html",
      "text": "\nAnd to calculate a \"coupling\" score, it would make sense to consider probability of change rather than just the existence of a potential breakage due to change.",
      "id": "3a0927067dccac36b1b38fb1e1f5d911"
    },
    {
      "type": "html",
      "text": "<i>Incorrect. It would not make sense to consider the <b>probability of change</b>.  But it wouldn't be a bad idea to consider the <b>probability of breakage given a change</b>.  Mathematically, that is <b>P(BREAK|CHANGE)</b> = <b>P(BREAK AND CHANGE) / P(CHANGE)</b>.  In layman terms, this (loosely) is the probability that code unit 'B' will 'break' after an unknown change to code unit 'A'. The closer this probability is to 100%, the higher the coupling from 'B' to 'A'.</i>",
      "id": "93434504739baced1c7774590ff11b5e"
    },
    {
      "type": "html",
      "text": " Perhaps we should make a distinction between calculating coupling and calculating the actual effects of coupling.",
      "id": "e55b164cf1cc2c06b2ae931d934c54f1"
    },
    {
      "type": "html",
      "text": " <i>Indeed. The above wouldn't truly aim to calculate coupling, but rather to measure it.  All 'measurements' are performed through 'effects'. Even distance measurements are based on the effect of distances on, say, reflected light or sound, or on diminishing covering arcs for objects of known height or width, etc. In this case, observing or scoring coupling based on its effects - how it is associated with breakage between modules - is, indeed, a measurement rather than a calculation. Good catch.</i>",
      "id": "4dbf31a0c9fb666ef2dddda86709aea3"
    },
    {
      "type": "html",
      "text": "\nWe may find that things A and B have coupling points C,D,E; and things J and K have coupling points L,M,N. If we merely count the quantity of coupling points, then the coupling between A-B and J-K would be considered the same. However, in practice, changes to L,M,N may be much less likely than C,D,E.  Thus, the utility of measuring coupling is greatly enhanced by considering probability of occurrence. Otherwise, we'd optimize our code for what could be very infrequent events over frequent ones. --top",
      "id": "d14e3db46722de023ef6c98a8f63a186"
    },
    {
      "type": "html",
      "text": "<i>We should optimize our code for [[Change Pattern]]s that have been anticipated based on past experience. But coupling is not the same thing as change patterns. Distinguishing between them is useful for providing or understanding advice such as: \"Reduce coupling to details or features that are subject to frequent change.\"  Indeed, the utility of 'measuring coupling' is enhanced by such distinction. If we don't distinguish between 'coupling' and 'frequency of change', then there is little purpose in having both phrases.</i>",
      "id": "5c71ed24231f2ed0652a59dda21c3e20"
    },
    {
      "type": "html",
      "text": "\nThe distinction between practical couplings and theoretically couplings can make a huge practical difference. For example, a medical application may be coupled to the assumption that a typical human has two arms because it asks the doc to inspect both arms of patient. In theory if an alien race with 3+ arms immigrated to Earth, the application could break or become useless. But in practice you'd be labeled silly to dwell on such. However, there are plenty of \"anal\" or [[Gold Plating]] developers out there who take some advice too literally and may build a convoluted indirection layer to reduce the impact of more arms. To avoid getting tangled in our own underwear, we have to know where the draw the line, and change probability is a key tool for that.",
      "id": "98442e59e8073951487cb95faceb4824"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nThese are some of the better-defined qualities that separate good software from bad software. Although they were formalized during the invention of [[Structured Programming]], they apply exactly as well to [[Object Oriented Programming]] as to any other kind.",
      "id": "12426d46cf724d17c02dae9e60d34d24"
    },
    {
      "type": "html",
      "text": "<b>Cohesion</b> of a single module/component is the degree to which its responsibilities form a meaningful unit; higher cohesion is better.",
      "id": "b1a5f462ac3c480ee236242fa1a0d842"
    },
    {
      "type": "html",
      "text": " Someone had vague reference to decomposability here.  Clarification?",
      "id": "1a4434282d806632d28b29b199be60f1"
    },
    {
      "type": "html",
      "text": " How about: 'Cohesion is inversely proportional to the number of responsibilities a module/component has.'",
      "id": "fe309debba24e7bbac3fec52b98d1f9a"
    },
    {
      "type": "html",
      "text": "<b>Coupling</b> between modules/components is their degree of mutual interdependence; lower coupling is better.",
      "id": "51a3f12442a3d4719e4723b760472dfe"
    },
    {
      "type": "html",
      "text": " size: number of connections between routines",
      "id": "8b9e32929006d64e83eec37bf600e6b9"
    },
    {
      "type": "html",
      "text": " intimacy: the directness of the connection between routines",
      "id": "18257ec3759d33aadacf1ad404b7b11c"
    },
    {
      "type": "html",
      "text": " visibility: the prominence of the connection between routines",
      "id": "2513c56e700c4afa95b63e1901cac06d"
    },
    {
      "type": "html",
      "text": " flexibility: the ease of changing the connections between routines",
      "id": "9d8838b64eeb711c377dc1d4a2278f80"
    },
    {
      "type": "html",
      "text": "\nA first-order principle of software architecture is to increase cohesion and reduce coupling.",
      "id": "0c4e631bed537d57dd1719d95c83c0a4"
    },
    {
      "type": "html",
      "text": "\nCohesion (interdependency within module) strength/level names : (from worse to better, high cohesion is good)",
      "id": "590a131c7d1cda8dab0bfb9cfd2123c3"
    },
    {
      "type": "html",
      "text": " Coincidental Cohesion : (Worst) Module elements are unrelated",
      "id": "1bbc1e8ea4d3651b0c0eb42c9079f950"
    },
    {
      "type": "html",
      "text": " Logical Cohesion : Elements perform similar activities as selected from outside module, i.e. by a flag that selects operation to perform (see also [[Command Object]]).",
      "id": "8b80dc3febb7064f9524e44dc0ce98aa"
    },
    {
      "type": "html",
      "text": " i.e. body of function is one huge if-else/switch on operation flag",
      "id": "eec369f87bffc6068cc6dc0c592b3c82"
    },
    {
      "type": "html",
      "text": " Temporal Cohesion : operations related only by general time performed (i.e. initialization() or [[Fatal Error Shutdown]]())",
      "id": "3a6972657a14ba1090bf7bdf24b29a16"
    },
    {
      "type": "html",
      "text": " Procedural Cohesion : Elements involved in different but sequential activities, each on different data (usually could be trivially split into multiple modules along linear sequence boundaries)",
      "id": "f0b0d85d95614aac8d638ff4c8a16e87"
    },
    {
      "type": "html",
      "text": " Communicational Cohesion : unrelated operations except need same data or input",
      "id": "780f13e00a5de734c21f64d9f254554b"
    },
    {
      "type": "html",
      "text": " Sequential Cohesion : operations on same data in significant order; output from one function is input to next (pipeline)",
      "id": "304b844cfeb5a72f9bc95f81369f8694"
    },
    {
      "type": "html",
      "text": " Informational Cohesion: a module performs a number of actions, each with its own entry point, with independent code for each action, all performed on the same data structure. Essentially an implementation of an abstract data type.",
      "id": "385f1cb7be16104fb66c696e3c8633df"
    },
    {
      "type": "html",
      "text": " i.e. define structure of sales_region_table and its operators: init_table(), update_table(), print_table()",
      "id": "ac170b9995037bf89adf0b2f33f343fa"
    },
    {
      "type": "html",
      "text": " Functional Cohesion : all elements contribute to a single, well-defined task, i.e. a function that performs exactly one operation",
      "id": "77e54146cd453b2fa11e309fe3e44602"
    },
    {
      "type": "html",
      "text": " get_engine_temperature(), add_sales_tax()",
      "id": "8ed4396c70b4ae1bf89dbe38a9859c06"
    },
    {
      "type": "html",
      "text": "\nCoupling (interdependence between modules) level names: (from worse to better, high coupling is bad)",
      "id": "76c55d5224c1f7ae33567187798c9393"
    },
    {
      "type": "html",
      "text": " Content/Pathological Coupling : (worst) When a module uses/alters data in another",
      "id": "c19442fb7c2be4c062f7613d76b21539"
    },
    {
      "type": "html",
      "text": " Control Coupling : 2 modules communicating with a control flag (first tells second what to do via flag)",
      "id": "41e416f05c3b08255b4612efe4296b5c"
    },
    {
      "type": "html",
      "text": " Common/Global-data Coupling : 2 modules communicating via <b>global</b> data",
      "id": "03d864838bb824eb6cf62f6d398a77d1"
    },
    {
      "type": "html",
      "text": " Stamp/Data-structure Coupling : Communicating via a data structure <b>passed</b> as a parameter. The data structure holds <b>more</b> information than the recipient needs.",
      "id": "9ce5b7b53dc45453ec19c9bc6dde4695"
    },
    {
      "type": "html",
      "text": " Data Coupling : (best) Communicating via parameter passing. The parameters passed are only those that the recipient needs.",
      "id": "331c00d9bb16ed047edc5287b5fc91e4"
    },
    {
      "type": "html",
      "text": " No data coupling : independent modules.",
      "id": "221b0867e593f7dedf0d0121aa2aab7e"
    },
    {
      "type": "html",
      "text": "\nAs usual with software source code metrics, these qualities are difficult (but not necessarily impossible) to reduce to quantitative data that can be meaningfully compared across different projects or organizations, despite their value as qualitative measures.",
      "id": "bc49597eb2023bd4db5f04bb35d3c8ad"
    },
    {
      "type": "html",
      "text": "\nThese measures of quality arose in the context of structured procedural programming, but also apply to other paradigms, including OO; the best OO practices can be seen in these same principles. This should not be surprising; OO did not evolve in a vacuum.",
      "id": "cefb376fb3a5625507b7aeb67bb21d0a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "<i>Can coupling be summed up as  as answering to three questions \"yes\" or \"no\"? Thus having 8 possible outcomes. Questions are \"share meaning (are related)?\", \"share (similar) algorithm?\" X \"share data?\" </i> - Mila",
      "id": "806d1d6f1a1480f01ae70a8aaf64fdfa"
    },
    {
      "type": "html",
      "text": "\nNo, coupling cannot be summed up as answering those three questions. Sharing data is, however, one form of coupling.",
      "id": "e4a304e79f49f01b737084c37f06dbcf"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "Quoted from \"[[Boulder Patterns Group Minutes Old]]\" (not otherwise a page to inspire browsing):",
      "id": "418e6863311f1591fcc8b4ea7824fae0"
    },
    {
      "type": "html",
      "text": "<i>the correct terminology is \"tight internal cohesion\" and \"loose external coupling\". This basically means that each method in a class should have one task and the class as a whole should have one major responsibility (tight internal cohesion) and that other classes should not depend on the inner workings of this class but should be designed to the \"interface\" of the class (loose external coupling). See a recent post by [[Alan Shalloway]] on this: [http://groups.yahoo.com/group/dpexplained/message/108 groups.yahoo.com]</i>",
      "id": "ed72c05a61759dbc4ea9f71d7030e344"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "<i>[The following question in [[Decoupling Objects]] inspired the creation of this page.]</i>",
      "id": "757f2ed6f2a2be86753fc478f6c6b7ce"
    },
    {
      "type": "html",
      "text": "\nI am somewhat surprised to find little in-depth discussion of [[Coupling And Cohesion]] on the Wiki - that is, to be honest, nothing I can readily identify as in-depth discussion of the two measures <i>per se</i> as opposed to second-order principles of design that are asserted to be beneficial \"because they reduce coupling\" or \"because they promote cohesion\". I have an \"intuitive\" understanding of the notions, gained mainly by osmosis and reading texts which refer to them, but I have a feeling that my knowledge might be incomplete. Or are the concepts so straightforward that no such discussion is warranted? Or did I miss some obvious pointers? -- [[Laurent Bossavit]]",
      "id": "35a6e530591614ff45e8b9ea7e21316f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nSomeone in [[The Structure Of Scientific Revolutions]] claimed that knowledge of these concepts has largely been forgotten in OOP. That is most unfortunate, if true.",
      "id": "f7a3e3a20a848cc4e2ea74132e3c9d54"
    },
    {
      "type": "html",
      "text": "\nAs an experienced programmer facile with OO and structured methods, I think that concepts of cohesion and coupling absolutely have their place in OOP/OOD. There are many chunks of OO and/or XP wisdom that fundamentally boil down to those two concepts, appropriately framed.",
      "id": "de00128096015ac8aae9f9d72f51dca8"
    },
    {
      "type": "html",
      "text": "\nA class is a coupled blob. The methods and properties must agree with each other on how the class is put together, or else there's little purpose in your class. That is, the internal interface of the class is what couples the implementation to it.",
      "id": "10d3a64e074fd67e48e848680704990c"
    },
    {
      "type": "html",
      "text": "\nA wise OO practitioner wants that internal interface to be as small as reasonable. When a class gets large or complex, it's a center of coupling and begs to be refactored.",
      "id": "7dfe10c4193eb46e6204c3dc5c1785bc"
    },
    {
      "type": "html",
      "text": "\nCohesion represents unity of purpose. We have long ago learned that the most internally unified unit of work is to formally accept inputs and compute outputs. This is the practice espoused by [[Functional Programming]], which takes [[Functional Cohesion]] to the limits of reasonability - and beyond!",
      "id": "e3e7a07bca0f9e3520779d42ae7f735d"
    },
    {
      "type": "html",
      "text": "\nWe also know that internal unity is not the same goal as global unity. We object-users (Classists?) want to express unity on as many levels as possible. Zillions of disorganized but simple functions do not express that unity. A well-designed OO program expresses the unity of purpose for groups of related methods by stuffing them in a class together. That cohesion is not about behavior in the atomic sense. It does apply to the boundaries of the interface which the class implements. Large classes or hierarchies can endanger that quality at their respective levels of abstraction.",
      "id": "25da95f5179ab8821cf9f2e90059dcc5"
    },
    {
      "type": "html",
      "text": "\nPerhaps the great thing about OO technology is that it makes design problems so clear. Still we must learn to read the writing on the wall. When you have a solid grounding in phonics, you can learn to read English with far less trouble than without, and you can do so on your own from reading books. [[Coupling And Cohesion]] are like the phonics of [[Code Smell]]s. By analogy, perhaps books on OO Design focus on the shape of whole words without teaching the letters first. This yields learning if and only if the prerequisites are met.",
      "id": "073ebc2ef638cc43185ead64ca908f30"
    },
    {
      "type": "html",
      "text": "-- [[Ian Kjos]]",
      "id": "d609b43541ff91cdcecec54c91c2a193"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nIn modular and functional programming coupling is the level of \"dependency\" between functions. And cohesion is a measure of how closely lines or groups of lines within a given function relate to each other: are they all \"doing the same thing\" or \"contributing to a single goal?\" One generally frowns upon global variables and parameters which are flags or codes.",
      "id": "b0d658990a58da47bcde4b1742ef990b"
    },
    {
      "type": "html",
      "text": "\nIn OO programming, I think we've created hierarchy of encapsulation, each level of which can be subjected to [[Coupling And Cohesion]] measures:",
      "id": "4b45b86fd383633e7fe5d31dde5f07e7"
    },
    {
      "type": "html",
      "text": " Each individual method should have high cohesion and low coupling with other methods.",
      "id": "c6d8a8236cacd954b0673ad239f9115c"
    },
    {
      "type": "html",
      "text": " Each individual class should have high cohesion within the class and low coupling with other classes.",
      "id": "479515268ed8329ce64e3f391b3a69c8"
    },
    {
      "type": "html",
      "text": "<i>I recall, as a modular programmer learning OO, that I was very impressed that practically every Smalltalk article I saw had discussions of how they improved methods in classes - in ways that improved cohesion within the resulting methods and reduced coupling between methods. Smalltalk culture clearly promoted appropriate [[Coupling And Cohesion]], far more than even the most ardent modular programming texts, and the OO developers didn't even talk about it; it was just \"the way things are done.\" -- [[Jeff Grigg]]</i>",
      "id": "0d63f9760c8fed9d15eeecf0c0c2db34"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nI am finding in my current project that there is a tendency if one is not careful to swing the pendulum too much one way or the other. When they are too <b>coupled</b>, logic and functionality may be dispersed across several components. Both of these lead to a proto [[Anti Pattern]]: how does [[Pendulum Of Coupling And Cohesion]] sound?",
      "id": "4934d5b8e466bb76345eb13bd69fff92"
    },
    {
      "type": "html",
      "text": "\nI think that the main issue is that what is \"intuitive\" to one person is not the same as what is to another. Also, it is difficult to correctly break up the functionalities of a system without error. This is why we [[Refactor Mercilessly]] right? I sometimes find myself feeling dirty when I'm coding. To me this is a clear indication that this [[Code Smell]]s. I am not enamoured of using scents to describe code but my colleagues understood immediately what I was saying when I told them \"I feel dirty.\"",
      "id": "a9445cc6f16987931606a80726e5b5da"
    },
    {
      "type": "html",
      "text": "\nDoes this make sense or am I just rambling? -- [[Iain Lowe]]",
      "id": "73addaad9f1f7b47dd1825e8934494fd"
    },
    {
      "type": "html",
      "text": "<i>What I find interesting is that I don't see coupling and cohesion as opposite quantities, such that decreasing the one automatically increases the other. What kind of coding tactics do you find yourself switching between as \"the pendulum swings\", as you put it?</i>",
      "id": "2bdf46d7a00b827f5e626783f65d7d76"
    },
    {
      "type": "html",
      "text": "\nI think I was a bit [[Dazed And Confused]] when I spoke about <b>cohesion</b> up there. There <i>is</i> a relationship between the two, though: when modules are very de-coupled it stands to reason that they are cohesive. If they were not cohesive, they would require greater insight into the inner workings of the other modules in the system. So there is a pendulum effect but probably something more like [[Half Pendulum Of Coupling And Cohesion]] since you are correct in stating that cohesion will reach a \"sweet-spot\" beyond which you cannot make a module more cohesive. I need to think about this a bit more... I still haven't pin-pointed the tactic-switching you mention above. -- [[Iain Lowe]]",
      "id": "ad1e8f2ac67dd03415fa71d2dff062d1"
    },
    {
      "type": "html",
      "text": "\nIt seems to me that the case is that a module which is cohesive is necessarily de-coupled. It cannot have unity of purpose if other classes accomplish half of that purpose. That is, while the module may be focused on one task it would not cover all of that task. However, being de-coupled does not imply cohesion. One module which manages three entirely distinct tasks can still be de-coupled from all others. -- James Ferguson",
      "id": "99a6b263ea0cced79cd79797d54eac79"
    },
    {
      "type": "html",
      "text": "\nLook at it from a different perspective: Increasing coupling increases dependence (thus increasing future instability) and Increasing cohesion increases stability. <i>The Holy Grail of [[Coupling And Cohesion]] is the [[Black Box]] which offers <b>The minimum dependence for the maximum stability</b> for its user.</i>",
      "id": "bbae1a849e1849ea682e559d9bab7cff"
    },
    {
      "type": "html",
      "text": " This dictates against [[Premature Generalization]]. After all, [[Premature Generalization]] increases an object's dependencies needlessly.",
      "id": "741987a29aa50bf8a98bd43a8ff5ae3b"
    },
    {
      "type": "html",
      "text": " This supports [[Dont Repeat Yourself]]. If I am too interdependent, I've probably repeated myself needlessly and should [[Refactor Mercilessly]].",
      "id": "be42069c75a48da16c7ba8c768879b4a"
    },
    {
      "type": "html",
      "text": " This supports [[Once And Only Once]]. [[Dont Repeat Yourself]] recommends OAOO whenever possible.",
      "id": "57fff7d4b4497dadd10e780aac1d9437"
    },
    {
      "type": "html",
      "text": " This wants to support YAGNI. After all, if [[You Arent Gonna Need It]], why head toward more instability?",
      "id": "55f14793d92642db6c222572a4c04a3d"
    },
    {
      "type": "html",
      "text": "-- [[Wyatt Matthews]]",
      "id": "24edda1ce5d2053a49a3f9f977e1ecd9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "<i>I smell a false dichotomy. Maybe. Coupling is connection crossing a boundary. Cohesion is connection which doesn't cross a boundary. This suggests that the ideal system is a single global space, and the worst is a highly modular space. Then there's geometric complexity which is a measure of dependency range (How many elements are involved in any one transaction). It is all rather more complicated than a single 'rule of thumb'. I suspect we are applying aesthetic judgement as much as any analytical principle. -- [[Richard Henderson]]</i>",
      "id": "87468e42a064e712ea09b4804eb9a7d8"
    },
    {
      "type": "html",
      "text": "\nMy comment was not intended to imply a single global space as the ideal, but to imply individual spaces should have a minimum of dependence upon another individual space that it was not derived from. Patterns such as [[Abstract Interactions]] increase coupling at one level (the interactions are now required maintenance for the dependent class), but expose less dependence upon other spaces because they deliberately allow the substitution of the object previously required for its execution.",
      "id": "e3ffff9384ed9ee38a2ba9711f3eb30c"
    },
    {
      "type": "html",
      "text": "<i>I know . The global thing is the implication of the definitions of coupling and cohesion with a rule to maximize one and minimize the other. I'm not trying to contradict the thesis of the page. I am a great believer in the basic principle. I just think that there is a whole load of expert intuition involved in applying this [[Heuristic Rule]], suggesting additional factors are involved.</i>",
      "id": "67e939f48b5f7c64e035c369e0679388"
    },
    {
      "type": "html",
      "text": "\nPerhaps we can identify these forces more appropriately. For example, I would think that Coupling is necessary between parent and child classes, but only cohesion is necessary for siblings.",
      "id": "99e8be74eff6e7c82143990948be3ab0"
    },
    {
      "type": "html",
      "text": " To me coupling implies direct maintenance costs and makes me think of welding. Breaking the coupling could result in the loss of established quality (short term) or function.",
      "id": "9c52cff1980893b1022431cdf95142d1"
    },
    {
      "type": "html",
      "text": " Good coupling is seen in a well constructed inheritance tree. I'll term this Deep<b></b>Coupling because the child classes are exposed to the majority of the parent class (your welding the entire surface area where the parts join).",
      "id": "e0fe1b5e7d5e7be14cfe2db07a1018ea"
    },
    {
      "type": "html",
      "text": " Bad coupling requires a specific implementation of Class B to run Class A with no inheritance. This situation BEGS for refactoring or an ORB-style implementation. I'll term this as Shallow<b></b>Coupling because it is done through \"Concrete<b></b>Interactions\".",
      "id": "59d47f7e09a09054d77fce426d74517a"
    },
    {
      "type": "html",
      "text": " Good coupling is also seen in some ORB? contexts ([[Abstract Interactions]] are used). I'll term this as Surface<b></b>Coupling because this coupling is like welding only the outsides of a joint together.",
      "id": "073241c5af5f9ec5df0fb8d817c8ba3b"
    },
    {
      "type": "html",
      "text": " Similarly, cohesion implies the ability to exchange objects with similar interfaces. This concept makes me think of N<b></b>utsAndBolts or H<b></b>ooksAndSlots.",
      "id": "53ba51ecd240b3aa45cbbee8c4a5d920"
    },
    {
      "type": "html",
      "text": " Deep<b></b>Cohesion uses [[Abstract Interactions]].",
      "id": "12a96c82fb60bb4bd722f3c4798e59d5"
    },
    {
      "type": "html",
      "text": " Shallow<b></b>Cohesion uses \"Concrete<b></b>Iterations\".",
      "id": "fa034fc54ec3cd082866938fa9325d0b"
    },
    {
      "type": "html",
      "text": " Surface<b></b>Cohesion implies nearly impossible communications between the participants.",
      "id": "37f21ca2dffb62f376f4c1d21ba19fe1"
    },
    {
      "type": "html",
      "text": "\nAny thoughts on my breakdown of these two forces?",
      "id": "bd022d14cbcd45d4b181135be57235c1"
    },
    {
      "type": "html",
      "text": "-- [[Wyatt Matthews]]",
      "id": "24edda1ce5d2053a49a3f9f977e1ecd9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nIt took me a long time to make sense of this word <b>cohesion</b> which I kept hearing. There seem to be many people who use this word without being able to tell me what it means, or show me code examples of <i>cohesion</i>. I have finally come to some level of understanding. First, if a class has a lot of different behaviour which doesn't naturally go together, it lacks a sense of <i>cohesion</i>. Similarly, if in order to alter some behaviour, one must go fiddle with many different classes, this might be a hint that the behaviour is spread out, rather than being in one <i>cohesive</i> unit. Second, if you look at a class, and everything you need to know about some behaviour is right there, and there isn't any thing else there to clutter up what that class does, then that class has a high sense of <i>cohesion</i>.",
      "id": "77e144b6d914f66cefc7bcc8edb53025"
    },
    {
      "type": "html",
      "text": "<i>Not just <b>cohesion</b> means, but also <b>coupling</b>. At the top, it says: </i>Coupling applies to any relationship between software components.<i> Perhaps it should say: </i>Coupling is the amount of relationship between software components.<i>? (Improvements welcome.) -- [[Chris Dailey]]</i>",
      "id": "920ecbf2f8e801af241f4222703a3b93"
    },
    {
      "type": "html",
      "text": "\nOh. How about from [http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=coupling&action=Search foldoc.doc.ic.ac.uk] - \"The degree to which components depend on one another.\" -- [[Chris Dailey]]",
      "id": "a01bd0ee9d2163029ee717e57e9a720e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nRelationships are what makes software powerful. \"Coupling\" is not something to get rid of, but to manage. Encapsulation is a form of coupling, for example. If two things have NO relationship at the time of writing, then yes, perhaps they don't belong together nor connected (at the time).",
      "id": "03720a3a9d23790d95b46019c924a18b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "<b>Some references:</b>",
      "id": "c2a495a75b0de45c9b1a5f8d7107b311"
    },
    {
      "type": "html",
      "text": "<i>[Kudos for [[Jeff Grigg]] for collecting a significant amount of relevant pointers.]</i>",
      "id": "f43e4f62dbeb1dc67fd0de5c3cabf617"
    },
    {
      "type": "html",
      "text": " \"Coupling and Cohesion\" slide in a presentation (the bullets above are mainly a restatement from that slide) -- [http://www.cc.gatech.edu/computing/classes/cs2390_97_summer/lectures/rdd/slide7.html www.cc.gatech.edu]",
      "id": "843b8ae7856cc484cc626bbba69dcc08"
    },
    {
      "type": "html",
      "text": " [ISBN:<br>0136907695] \"Practical Guide to Structured Systems Design\" (Yourdon Press Computing Series)",
      "id": "2d0328adab05c635146065880bb46cb1"
    },
    {
      "type": "html",
      "text": "by Meilir Page-Jones",
      "id": "24e009cbe354ccd5e9bbef0e1717f129"
    },
    {
      "type": "html",
      "text": " \"Measuring Coupling and Cohesion:<br>An Information-Theory Approach\" - a paper from the November 1999 IEEE International Symposium on Software Metrics, by Edward B. Allen and Taghi M. Khoshgoftaar -- [http://csdl.computer.org/comp/proceedings/metrics/1999/0403/00/04030119abs.htm csdl.computer.org] (payment required for access)",
      "id": "6bfa122ff92fa803b191109ead284947"
    },
    {
      "type": "html",
      "text": " \"Coupling and cohesion in object-oriented design and coding\" at ACM Annual Computer Science Conference, by Joel Henry and Donald Gotterbarn -- [http://dev.acm.org/pubs/citations/proceedings/csc/228329/p149-henry/ dev.acm.org] (?)",
      "id": "fa2caf9b4dc7b6eb439921565e385d52"
    },
    {
      "type": "html",
      "text": " calculator -- [http://141.215.8.244/ccc/coupling.asp 141.215.8.244] (gone since at least 2003-06-22)",
      "id": "109d3279ca30af52cb0d4d0acbd1c1e8"
    },
    {
      "type": "html",
      "text": " [http://www.sfcc.spokane.cc.wa.us/bladek/Bladek/CS2w01/COUP_COH.HTM www.sfcc.spokane.cc.wa.us] (gone since at least 2003-06-22)",
      "id": "31e3f407e7ded519f14f6497460a67f1"
    },
    {
      "type": "html",
      "text": " [http://www2.umassd.edu/CoursePages/SoftwareEngineering/lectureMat/couplingcohesion.html#cnc www2.umassd.edu] (gone since at least 2003-06-22)",
      "id": "d55e1c7a015fe4eaa204bc0036ec0943"
    },
    {
      "type": "html",
      "text": " (Apparently was part of \"CIS 311 - Software Engineering\" course -- [http://www2.umassd.edu/CoursePages/SoftwareEngineering/ www2.umassd.edu] (gone since at least 2003-06-22) but may not be part of lecture notes any more. ;-)",
      "id": "e183184bd472515c87d6d3e3243bd515"
    },
    {
      "type": "html",
      "text": " [http://www.cpsc.ucalgary.ca/~jonesb/seng/613/groupwork/sasd/report.html www.cpsc.ucalgary.ca] (gone since at least 2003-06-22)",
      "id": "45ea56917d14ed82dc2d791dffefb372"
    },
    {
      "type": "html",
      "text": "\nLarry L. Constantine and Ed Yourdon. Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design. 1978.",
      "id": "a53ed7442251ab624e6c34e11077a9d2"
    },
    {
      "type": "html",
      "text": "Pre-OO. Essentially the origin of the those terms in software design, devoting a chapter to each.",
      "id": "bad4da76ed2ac2edc659d92a074952eb"
    },
    {
      "type": "html",
      "text": " Nope! I have a 1975 book that covers all of this! \"Reliable Software Through Composite Design\", Glenford J. Myers. This might be the earliest book appearance. But it cites an earlier article, \"Structured Design\", L.L. Constantine, G.J. Myers, W.P. Stevens, IBM Systems Journal, Vol. 13, No. 2, 115-139 (May 1974)....Note that the article is coauthored by the book author, Myers, and the article is also coauthored by Constantine, who coauthored the later 1978 book mentioned above.",
      "id": "98c55c8b0814641f1122918ab27e0abc"
    },
    {
      "type": "html",
      "text": " And things had been percolating unpublished for several years prior, it also cites as origin of some of the coupling/cohesion terms the unpublished manuscript from 1971, \"Fundamentals of Program System Design\", L.L. Constantine again.",
      "id": "c20aef147e7751f47888a96266d1bec1"
    },
    {
      "type": "html",
      "text": " So if anyone is looking to give credit, it looks like the lion's share goes to Constantine, and the rest to Myers and Stevens.",
      "id": "6d66221ec9a2d1af64ae8a6ad0f04f6c"
    },
    {
      "type": "html",
      "text": "[Yes, I did invent the concepts and the original metrics of coupling and cohesion, with first publication in 1968 (\"Segmentation and Design Strategies for Modular Programming.\" In T. O. Barnett and L. L. Constantine,eds., Modular Programming: Proceedings of a National Symposium. Cambridge, Mass.: Information & Systems Press, 1968.) Glen Myers and Wayne Stevens were students and colleagues of mine at IBM's Systems Research Institute where I was on the faculty from 1968-1974. --Larry Constantine]",
      "id": "0c13465c7edbf223c98eecd62f6058da"
    },
    {
      "type": "html",
      "text": "\nLinks from Chris:",
      "id": "89140242b714349fc1410bb135a041c7"
    },
    {
      "type": "html",
      "text": " \"Reducing Coupling\" by Martin Fowler [http://martinfowler.com/ieeeSoftware/coupling.pdf martinfowler.com]",
      "id": "f0a95539efec42e7c6703acd7fa75408"
    },
    {
      "type": "html",
      "text": " \"Dynamic Coupling And Cohesion Metrics For Java Programs\" by Aine Mitchell [http://www.cs.may.ie/~ainem/contents.html www.cs.may.ie]",
      "id": "73a9c02caac339125de6a6b9a2707173"
    },
    {
      "type": "html",
      "text": " Unfortunately, it's difficult to find links to papers by David Lorge Parnas. [http://www.cas.mcmaster.ca/sqrl/parnas.homepg.html www.cas.mcmaster.ca]",
      "id": "d2d3087bc95a9e2f058eecb543c7584b"
    },
    {
      "type": "html",
      "text": " Here is one of the best : If you have not read it you should [http://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf www.cs.umd.edu] -[[Marc Grundfest]]",
      "id": "409725a8e609d5c72e5133043f767a89"
    },
    {
      "type": "html",
      "text": " <i>See [[On Decomposing Systems]]</i>",
      "id": "445270edc1b3ebf086c7a40a25190f55"
    },
    {
      "type": "html",
      "text": " UNC Comp145:<br>[http://www.cs.unc.edu/~stotts/COMP145/modules.html www.cs.unc.edu]",
      "id": "ccd226d3d7053bad05be0eb554dec516"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nMost examples of [[Coupling And Cohesion]] seem to be device-driver-like examples. If one does not deal with device drivers, then those examples are not very good sales material. Some also depend on a pro-subtype viewpoint. Those of us who think [[There Are No Types]] would like to see something else. If the concept depends on subtyping-based [[Change Perception]], that is fine by me. I just want to clarify if this is the case. -- top",
      "id": "2dfd16dc3e2b7ef8e8f2e2441568cc93"
    },
    {
      "type": "html",
      "text": "<i>Types in OO land aren't really all that much different from \"domains\" in relational-land. If you don't understand that, you need to go re-read [[Chris Date]].</i>",
      "id": "1158192b9faf82d4930c978b9b78b6eb"
    },
    {
      "type": "html",
      "text": "\nTypes maybe. But it is <i>subtypes</i> that are the issue.",
      "id": "c756efd77eb3ccaff3ab23e43c8248e2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "A few of the places coupling and cohesion is discussed:\n[[Nature Of Order Discussion]]\n[[Extract Method]]\n[[Code Normalization]]\n[[Benefits Of Oo]]\n[[Software Metrics]]\n[[Maintain Ability]]\n[[Good Code]]\n[[Large Extreme Programming]]\n[[Refactoring And Rewriting]]\n[[Grady Booch]]\n[[Fundamental Flaws In Procedural Designs]]\n[[Dont Refine Exceptions]]\n[[Cpp Utx Overview]] (in regard to testing)",
      "id": "51b3da5b5902efc35cedee0a0b2ce6be"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nThe <i>basic idea</i> is that stuff that <i>works together,</i> should <i>be</i> together.",
      "id": "22588988c4d29e93bcc5df5af9b781ce"
    },
    {
      "type": "html",
      "text": " Put things that fit really well together right next to each other, in one module - seek strong cohesion.",
      "id": "5211a429b98a380c82d79ff6f0829d7d"
    },
    {
      "type": "html",
      "text": " Between modules, don't let them fiddle around with each other's private parts too much - seek low coupling.",
      "id": "d37f63a6b864f6a0f5e273e0bc464e07"
    },
    {
      "type": "html",
      "text": "\nIt's all about <i>how you cut up your program,</i> into pieces called <i>modules.</i>",
      "id": "313ba0161b7462c3934dd1323d6fa57a"
    },
    {
      "type": "html",
      "text": "\nTo think that you can win the game by putting everything into one module is just as silly as saying, \"What, Global Variables are bad? Okay! I'll just put everything into one gigantic structure then, and pass it around. Yay me!\" You have missed the point.",
      "id": "698a56d2c1676a75df81e6d068f802ab"
    },
    {
      "type": "html",
      "text": " Yep! And that \"yay me!\" solution is the one called \"Stamp Coupling\". It has enjoyed a resurgence in popularity in [[Functional Programming]], where it is represented as a Monad, as far as I can tell, but outside of [[Functional Programming]], it's not a good idea.",
      "id": "50fd3f2cab6c3758acceda855d6790c3"
    },
    {
      "type": "html",
      "text": "\nIn [[Object Oriented Programming]], the main vehicle of Coupling is Polymorphism, and the main vehicle of Cohesion is Encapsulation.",
      "id": "816cec1b4306e30d91524ddef04cb837"
    },
    {
      "type": "html",
      "text": " <i>Eh? I see <b>lots</b> of coupling in [[Object Oriented Programming]] implemented by direct instantiation of one class by another.  Often these are chained until virtually the entire system is coupled together.</i>",
      "id": "f61f2e07575cd8a16f98678df10ab77c"
    },
    {
      "type": "html",
      "text": " I concur. [[Abstract Constructor]] or [[Abstract Factory]] patterns could reduce this coupling, but are often painful to use ([[Language Smell]]). [[Gilad Bracha]]'s [[Newspeak Language]] has a restrictive module system to help with this problem.",
      "id": "a7931b3807c586f33318daf7e34b35c0"
    },
    {
      "type": "html",
      "text": "<i>Besides \"stuff that works together\" as a way to cut the pie might be \"stuff that changes together\" per the [[Single Responsibility Principle]]. Is that a useful way to find or measure cohesion? JLS</i>",
      "id": "146bf12bed374237623f523408d59bf8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nBecause so much of programming now is basically drawing pipes between modules, it seems to me that [[Stamp Coupling]] has become more common and accepted. (...since, if you do [[Stamp Coupling]], you don't have to draw in new pipes when you need something- it's just automatically available to you.)",
      "id": "b43908b74b336774a0832f9ecf0f5416"
    },
    {
      "type": "html",
      "text": " I don't see what pipes have to do with it. Pipes are Sequential Cohesion, and needn't have anything to do with Stamp Coupling. When the total environment is shoved into a data structure, it's common to pass around a pointer to it, but I've never seen it passed around as a gigantic chunk in a pipeline. And that would only work on the read-only part of the data, at that, since pipes pass copies.",
      "id": "4b650924001726ebc5c8602f3e34df21"
    },
    {
      "type": "html",
      "text": "\nIf you do only [[Data Coupling]], then every time you need to get a new wire from module A to module D, then you need to massage A->B, B->C, and C->D. But if you're stamping it, you need far less massaging. You just pull what you need from the wire, no need to change a bunch of code.",
      "id": "7141319c129251f9883a890523085028"
    },
    {
      "type": "html",
      "text": "\nPrograms written in the \"loose\" languages, like Python and what not, seem to promote this sort of [[Stamp Coupling]]. Then, as things become formalized, efficient, rigid, and secure, a piece of software moves towards [[Data Coupling]], and is implemented in stricter languages.",
      "id": "97a6c9b87a02e87564ce66d5b2460d2c"
    },
    {
      "type": "html",
      "text": " Perhaps you could give an example, since your train of thought isn't obvious yet.",
      "id": "fcf25a435cf0ef6cea95f7c237d8fe7c"
    },
    {
      "type": "html",
      "text": "\nOkay, so, I think the confusion rests in different understandings of the phrase \"Stamp Coupling.\"",
      "id": "35c6634edd749fee6395c0d6b9ef9d29"
    },
    {
      "type": "html",
      "text": "\nAs such, it's probably best continued on that page: [[Stamp Coupling]].",
      "id": "f88879d66bf57598067c63b99bf54f8b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nRe: \"The <i>basic idea</i> is that stuff that <i>works together,</i> should <i>be</i> together.\"",
      "id": "8d976fcbd59230da4eeac94445cac88c"
    },
    {
      "type": "html",
      "text": "\nThis is often impossible. Factors often interweave such that there is no one perfect grouping. The real world is multi-dimensional but textual code is limited to 1 or 2 dimensions (2D on small scale). The best we can do is find the best compromise, and which is the best compromise is often a source of [[Holy War]]s (for example, grouping by nouns versus grouping by verbs). See [[Group Related Information]].",
      "id": "05543625d07eca4dead29871c678de63"
    },
    {
      "type": "html",
      "text": "<i>True, but unhelpful. You're talking about problems that can arise even when some version of best practice is followed. [[Coupling And Cohesion]] primarily addresses problems that arise when best practice is <b>not</b> followed.</i>",
      "id": "19f9e339afaddb3d31628a970c0481f7"
    },
    {
      "type": "html",
      "text": "<i>It's better for an attempt to have been made to group code based on it working together, than not to do so, even in cases where there is no single perfect answer to grouping.</i>",
      "id": "eebf65d20050d31093a24dbd5888af28"
    },
    {
      "type": "html",
      "text": "\nExcept maybe for newbies, almost everyone uses some kind of grouping approach beyond random.",
      "id": "038ee0c3a769642b9428ede3965b1f05"
    },
    {
      "type": "html",
      "text": " Yes, but it's not a binary issue, because it's <b>not</b> the case that almost everyone follows <b>best</b> practice, even if they don't follow <b>worst</b> practice. For instance, [[Logical Cohesion]] is second-worst on the list, and is not at all uncommon.",
      "id": "5cd874ad237b1a1561fbc9f9a5315038"
    },
    {
      "type": "html",
      "text": "<i>Newer methodologies that attempt to address difficulties in grouping, such as [[Generic Programming]], [[Aspect Oriented Programming]], and perhaps [[Intentional Programming]], do not in any way contradict the principles of [[Coupling And Cohesion]], so far as I am aware.</i>",
      "id": "e28c83c1d9d58b76a9d4ed9a1d04af6a"
    },
    {
      "type": "html",
      "text": "<i>[[Holy War]]s over i.e. OO versus [[Generic Programming]], although the two methodologies can contradict each other, each individually are in alignment with [[Coupling And Cohesion]].</i>",
      "id": "aab92b68cc67fea20a99d78995eab4d9"
    },
    {
      "type": "html",
      "text": "[I agree with the person who said, \"This is often impossible.\" However, just because some \"theoretical purity\" is unknowable or unattainable, doesn't mean that the theory's a bunch of bunk. The purpose of this idea isn't to give you a perfect algorithm to show you the one right way to do something. The purpose of the idea is to help you recognize patterns, and help you think about things. Breaking a problem down into smaller interconnected pieces is pretty universal.]",
      "id": "9c07cb346387706d321ca056a89a66a7"
    },
    {
      "type": "html",
      "text": "\nBecause we have to as humans, not because it necessarily fits actual reality. Grouping stuff is an attempt to find the most [[Useful Lie]]. One often groups by their perceived probabilities of future changes, but it is often hard to agree on the most likely change patterns.",
      "id": "a0f7454ff0dd25774515a6f03985fcd0"
    },
    {
      "type": "html",
      "text": "<i>True, but it pays to keep trying to do better, and gradually over time computer science is learning more about what does and doesn't work well. [[Coupling And Cohesion]] is an example of something that was first invented a long time ago, back in the 1970s, but tends to be neglected, when it should be one of the tools in everyone's arsenal.</i>",
      "id": "870ab5a16f01ff7753b4e5edd86dc3f4"
    },
    {
      "type": "html",
      "text": "<i>[[Coupling And Cohesion]] has been implemented as actual objective automated metrics quite a few times, but such things tend to suffer from problems of insufficiently powerful automated software analysis state of the art in general. Still, I expect this state of the art to continue to improve, and perhaps eventually the whole topic will become significantly less subjective.</i>",
      "id": "060eb836982514cad738c44ccfefeeed"
    },
    {
      "type": "html",
      "text": " Where are these \"automated metrics\"? And we have to be careful to make sure the metrics translate into real benefits and that there are not counter-metrics that are being skipped. For example, small \"code size\" is good, but if it's the only metric we judge on, then really compressed code that might score high on compactness may be difficult to read in practice.",
      "id": "757a6663ae4053ac478aee61ea401fc7"
    },
    {
      "type": "html",
      "text": "<i>Until then, one does the best one can.</i>",
      "id": "12df200b062a51eeed377601e1f63cc8"
    },
    {
      "type": "html",
      "text": "\nI believe that [[Software Development Is Gambling]]. One evaluates the horses relative to each other and then picks the best guesses. There is not always one right answer for every circumstance. Saying \"X is always bad\" is always bad :-)",
      "id": "f77c33a2973c3edb045776f933c95579"
    },
    {
      "type": "html",
      "text": "<i>It's one thing to say that there isn't always one <b>concrete</b> correct answer, it's' another thing to claim that there isn't any objective means possible to measure the degree of correctness of answers in the <b>abstract</b>.</i>",
      "id": "b5ec0abeb70eefbb0f0293cf6fcf34c9"
    },
    {
      "type": "html",
      "text": "<i>The latter would mean that software is of necessity doomed to forever be an art, not a branch of engineering and science. Some would agree, but this seems a risky proposition in an age where we are beginning to understand even the rules of aesthetics (via evolutionary psychology and via tentative systems like Alexander's).</i>",
      "id": "072bc6ffb79280ba32bf7053300bf302"
    },
    {
      "type": "html",
      "text": " One does not know if they made the right choice until and when things do change. That is how we test our change-handling concepts in the end. However, this does not provide any formalism. Further, as I have learned after many heated debates with OO proponents, people perceive (likelihoods of) change differently from one another. Since we cannot produce the actual real world changes during the discussion to see whose design is the most change-friendly, we can only base our designs on how we *expect* the future will change, and this is where the differences in change pattern perceptions make the process very messy. However, a consolation prize would be to better document one's assumptions and describe why alternative change scenarios were ranked lower. But, most software engineers don't seem to have this intraspection skill yet. People don't really know how to properly question their own model of reality, but such is needed to document change-related assumptions properly. -t",
      "id": "2981c24681a532bd6fc18ba39764412b"
    },
    {
      "type": "html",
      "text": " I do know I made the right choice. I deny your right to claim the general case. I prove it every time the change does not force me to rewrite the system. So do others. The fact that what I do is not possible suggests that I am undercharging :)  -[[Anonymous Donor]]",
      "id": "f2d8fbc2d3b64efc5edd21d76cea3752"
    },
    {
      "type": "html",
      "text": " You predicted the nature of future domain changes? That may be a different issue. If we know the future, then our design choices are of course going to be a lot easier. I find the domain future difficult to predict, even after years of experience. New markets, new fads, new management personalities, new presentation technologies, etc. just require too powerful a crystal ball. -t",
      "id": "56e5634fd464ce816bb315ee6bd2b868"
    },
    {
      "type": "html",
      "text": "<i>It would also mean that these characteristics of software inherently cannot be correctly embedded in a mathematical metric space, even in principle, which seems exceedingly rash.</i>",
      "id": "03caf1b41a62a14788753c73cab43f6d"
    },
    {
      "type": "html",
      "text": "<i>Back to brass tacks: name a situation where [[Coupling And Cohesion]] gives an incorrect answer to whether something is good or bad. (The issue of objectively measuring such was already addressed above your comments, not by your comments, so that's a different issue.) -- [[Doug Merritt]]</i>",
      "id": "7334ce88faede0467ad96a05c7a1550e"
    },
    {
      "type": "html",
      "text": "\nExample? Indirection. Indirection reduces coupling, but can also complicate a given design. Having a complex design may make it harder to change because there is more code to read and more code to change. Also, how \"bad\" each form of coupling is, is subject to subjective rankings.",
      "id": "e3e9fc8ce1240f3489feb3d5d7961856"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nAnalysis by <i>reductio ad absurdum</i>.",
      "id": "9d3096fe11b4f3e902da824683506ae1"
    },
    {
      "type": "html",
      "text": "\nCoupling",
      "id": "38fd6deba06b37f0926036d0f8a5b56b"
    },
    {
      "type": "html",
      "text": "\nIt is my understanding that coupling can only be reduced,\nnot eliminated. A program with zero coupling could have\nat most one machine instruction (not source statement).\nAny more than that and there would be dependencies between\nthe action of one instruction and the action of the next.",
      "id": "21c1d712cde8d7f79c02fbcf5c6b04a2"
    },
    {
      "type": "html",
      "text": " Not necessarily. The system isn't inherently mapped to a metric space, but if it were, there are workable definitions of a zero in non-trivial programs.",
      "id": "d235308eda9b2ab5e324f41669bf702d"
    },
    {
      "type": "html",
      "text": "\nSo, by inference, coupling is indicated by the degree of dependency between the various components of a system. Of course, by their very nature, modules depend on one another to perform their respective functions properly, but we are concerned with how much one module depends on the <i>implementation</i> of another module. The ideal is not at all, and we can come very close, but never arrive.",
      "id": "7bab800ec52f6e57bc73b8125f78bd88"
    },
    {
      "type": "html",
      "text": "\nCohesion",
      "id": "282ac97f3ae0aa1292088ef5513d4afa"
    },
    {
      "type": "html",
      "text": "\nBy the same argument used above to show that coupling cannot be eliminated, a certain level of cohesion is also inherent in the sequential nature of electronic computer instructions. (All bets are off on quantum computing.) The goal is to maximize it.",
      "id": "779ce3ae07c3baef17674aa26b4198d0"
    },
    {
      "type": "html",
      "text": " Not necessarily, as above.",
      "id": "c849d128b784a19a0e367ab3d6308fda"
    },
    {
      "type": "html",
      "text": "\nI won't bother pontificating on this because an item above covered it very well:",
      "id": "257fbc92a1edc56a0031fc2bde1c951d"
    },
    {
      "type": "html",
      "text": "<i>Coupling is connection crossing a boundary.</i>",
      "id": "ba082b94700f17a6ee84c273a62cf48e"
    },
    {
      "type": "html",
      "text": "<i>Cohesion is connection which doesn't cross a boundary.</i>",
      "id": "73e57c63a5d1f7e8492b10806892e69f"
    },
    {
      "type": "html",
      "text": " That only applies in G. Spencer-Brown's first order system. And he didn't explain his higher order system. And his followers who did take stabs at it came up with systems where the above doesn't really apply, just as binary logic of one bit leads to limitations that are not true of systems with a large number of binary bits.",
      "id": "0d068258926bf82932151a2a8f3652d5"
    },
    {
      "type": "html",
      "text": "\nThe only addition I would make is to emphasize that the connection need not be explicit, it can be implicit. It could be knowledge as innocent as knowing that certain values passed are 'bit flags'.",
      "id": "5886d0d10387a30fe3b0ba91c0817b1c"
    },
    {
      "type": "html",
      "text": "\nWell I'm out of time. So long.",
      "id": "ba2d788239ec010ad3dcbf6b57f19f40"
    },
    {
      "type": "html",
      "text": "-- [[Bob Bockholt]]",
      "id": "158837a3a7826fc34f3d579846b9265c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nSome examples would be nice. English is insufficient it seems. For example, \"contributing toward the same goal\" can get into some sticky philosophical discussions. It just seems another case where people end up modeling their own internal view of the world and thus nobody agrees. [[Fuzz Flag]]?",
      "id": "a8e5a7e41f1e1fe1a10fc3520a745977"
    },
    {
      "type": "html",
      "text": "<i>This stuff was invented in 1974, but it's been partially forgotten, and seems to be taught at only, I dunno, 20% of colleges and universities these days, even though it is not obsolete; it's still quite important.</i>",
      "id": "9412a7c0966f5aa675f3e2eb41ec4c4f"
    },
    {
      "type": "html",
      "text": "<i>I took the trouble to add definitions for every single level of coupling and cohesion recently, which had never been on this page before, and I did this by doing a bunch of web searching and trying to pick out the pages that seemed to have more coherent definitions. Then I dug up the actual origin of the terms, since that was misquoted here.</i>",
      "id": "e808fda2f737b85a260b6f690470bd4d"
    },
    {
      "type": "html",
      "text": "<i>I understand why you would say that the result is <b>still</b> insufficient, but you know what, I'm kind of tired...how about if now <b>you</b> do some similar searching and find some nice examples and add them to this page? Google is your friend, too, not just mine. :-)</i>",
      "id": "dfec5d65e7077db8e266dbbcb35255c3"
    },
    {
      "type": "html",
      "text": "\nI did not mean to have you carry the entire load.",
      "id": "48364d3cac52f02006dd8a73ebe84f13"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nI think there are (at least) two things to look at when investigating \"links\" between things:",
      "id": "3dee1ed4e60a12ce69824fc9f0e5df2a"
    },
    {
      "type": "html",
      "text": " Does a link reflect an actual domain link (real-life association), or is it a software artifact? If the second, then it should perhaps be a higher alert level. It makes sense that if we are modeling two things that are linked as a domain requirement, then our software/database is also going to contain a link of some kind to reflect that.",
      "id": "4d920544b616ed3c215391e5606d6c9d"
    },
    {
      "type": "html",
      "text": " Related is that the strength level of the domain link should also be reflected in the software/database. If the link is tenuous, then it should be easier to remove from the software also. Of course this may take some estimating skills to apply appropriately.",
      "id": "d49e112345c1826f017e6493f10ea288"
    },
    {
      "type": "html",
      "text": " How expensive is it to add or remove links? What kind of [[Discontinuity Spike]] do such create? For example, I often fuss about the expense of converting is-a relationships to has-a relationships.",
      "id": "8b2eeecdf2751a68fe3fb63fca661e53"
    },
    {
      "type": "html",
      "text": "-- top",
      "id": "4921c41b69ea2112e8368dfcbd5b0242"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nHow [[Responsibility Driven Design]] could help with [[Cohesion And Coupling]] ?",
      "id": "0e9362af10bd740feb662430b2604316"
    },
    {
      "type": "html",
      "text": "\n[[Use Cases]] protect and give answers to the concerns and interests of all stakeholders of a given system.",
      "id": "fb86ab9f7d410313f556b9db2211ef12"
    },
    {
      "type": "html",
      "text": "\nAll stakeholders of a given system are represented through the Actors in the interactions with a such system.",
      "id": "8329a37dc9873c4a2fd3d3fc672c8f60"
    },
    {
      "type": "html",
      "text": "\nFor every goal that a given Actor has with a given system, this system must answer every such goal through its responsibilities.",
      "id": "8965503daf9e1ee14d06d3d21ea168b3"
    },
    {
      "type": "html",
      "text": "\nThis system should become a catalyst for such business, because its purpose is to open new roads to facilitate this business. This catalyst metaphor fits perfectly with [[The Simplest Thing That Could Possibly Work]].",
      "id": "5652482329a94538204b34cfeca533c8"
    },
    {
      "type": "html",
      "text": "\nTo design such a system, we must understand the business this system must service, with this catalyst idea in mind.",
      "id": "3ec45f90aa2bb056aeef220cc560c20f"
    },
    {
      "type": "html",
      "text": "\nTo start with, we look at the business terms or entities that are involved in the business. We are looking into the problem domain of the business. In this domain, all business entities involved are classes.",
      "id": "b593e036fbbe669b4eead32817058070"
    },
    {
      "type": "html",
      "text": "\nOnly a group of all of the problem domain classes will show up in our system. That will depend on the scope of our system.",
      "id": "c006d0dd1ab086f87370ff598d8c6ebc"
    },
    {
      "type": "html",
      "text": "\nBesides, for the group of problem domain classes that will show up in our system, some of the business entities will turn into system classes, while others will become just properties of these classes. Whether a problem domain class becomes a system class or a property of another system class will also depend on the scope of our system.",
      "id": "4a253a7ce01c5a6ca0a39e68c941c42e"
    },
    {
      "type": "html",
      "text": "\nFor instance, let's take a look at the [[Zip Code]] business entity (problem domain class). If we are designing a typical [[Sales Order Processing]] system, in most cases the [[Zip Code]] will become a property of some system class(es).",
      "id": "b2c8ec8e5cb7b5cd51c07233958fbc4a"
    },
    {
      "type": "html",
      "text": "\nBut what if we are designing a system for [[Fed Ex]] or UPS?. In such a case, the problem domain [[Zip Code]] class might become a system class.",
      "id": "2df31e5a22fff70a2f348423abef2e8d"
    },
    {
      "type": "html",
      "text": "(YAGNI and NIAGNI help us define partial, temporal projections into the scope of a given system. We may start with a very narrow scope in the first iteration, like a [[Walking Skeleton]] of a system, and gradually evolve into a wider scope, all the way down to the final scope of such a system).",
      "id": "be09a6e0bcbce44f0667079dd315720e"
    },
    {
      "type": "html",
      "text": "\nSo, for every problem domain class we must fully understand what it has to know and what it has to do in order for it to answer to all its responsibilities (the word responsibility comes from Latin and it means \"to give answer to\").",
      "id": "b2d58860a75312f2585f7dfa87728550"
    },
    {
      "type": "html",
      "text": "\nHow do we do that? Simply by asking for the [[Business Rules]] involved in the problem domain.",
      "id": "a43553575e854005479e05c50040bc19"
    },
    {
      "type": "html",
      "text": "\nThis is the real initial point in our problem domain exploration: [[Business Rules]] will help us identify all business entities (problem domain classes), and also everything that a given class must know and must do.",
      "id": "2f74c832550659909dadbaab982e9f67"
    },
    {
      "type": "html",
      "text": "\n[[Business Rules]] are atomic and elementary always, if we state them in the proper way.",
      "id": "e44eadbeefee2f12b8a64727a6242ca7"
    },
    {
      "type": "html",
      "text": "\n[[Business Rules]] will also tell us how classes interact (collaborate) among themselves.",
      "id": "7b37970e38c23fe9f63290ec7917bcce"
    },
    {
      "type": "html",
      "text": "\nThrough these collaborations among classes to fulfill business goals ([[Use Case]] goals), we could discover how to aggregate knowledge and behavior of every problem domain class to identify its responsibilities.",
      "id": "a71be814aceb9a104f4d6d8bf0f95daa"
    },
    {
      "type": "html",
      "text": "\nIn such a manner, we can get highly cohesive problem domain classes. Cohesion is the middle ground between atomic [[Business Rules]] and lumpier [[Use Case]] goals.",
      "id": "8c69ccb6259b473f713d6d8c58e27e5e"
    },
    {
      "type": "html",
      "text": "\nIf we build a cross-collaboration matrix among all problem domain classes, we will find lumps or clusters of classes with stronger collaboration ties.",
      "id": "82232fa1e17917dfb1d2d8d66a3accc6"
    },
    {
      "type": "html",
      "text": "\nThese clusters tell us what classes belong to a given logical (problem domain) package or component.",
      "id": "80369af2b90df05ba9cf952341dca894"
    },
    {
      "type": "html",
      "text": "\nIf we apply this very same grouping to our software components, we could have loosely coupled components.",
      "id": "f0e3f3636c09e1ba7b54f5c081d27ae6"
    },
    {
      "type": "html",
      "text": "\nProblem Domain Analysis helps us determine the classes involved in it, as well as the public interface of theses classes.",
      "id": "03172c92d17e020472ae002a9cbb82bc"
    },
    {
      "type": "html",
      "text": "\nSince we are dealing with the what of a business and not the how of that business, this analysis helps us design for the public interface of classes, an not for any particular implementation (\"Responsibilities = Public Interface\").",
      "id": "a25525647993d00bc2c33f5810230cc1"
    },
    {
      "type": "html",
      "text": "\nThis is consistent with the first principle of object-oriented design stated in the [[Design Patterns Book]] (page 18):",
      "id": "2677432a1f8d93b11ed3aede6503c236"
    },
    {
      "type": "html",
      "text": "\"Program to an interface, not an implementation\".",
      "id": "6d01ff545ed54e815f02146691f123e8"
    },
    {
      "type": "html",
      "text": "-- [[Gaston Nusimovich]]",
      "id": "3606ddf1499361100219e37f21e9549c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "<b>\"Fuzzy Metric\" Complaint</b>",
      "id": "de6fda4bea3077bc43354ed506eadea4"
    },
    {
      "type": "html",
      "text": "\nIn a usenet debate, [[Robert Martin]] suggested that separate case-statement lists are \"coupled\" because they are allegedly likely to change together.",
      "id": "e5cfbcdc7198c842688c9e9b98467458"
    },
    {
      "type": "code",
      "text": "   functionA(...) {\n     ...\n     select on x\n     case 'aa': {asd()}\n     case 'bb': {jgusss(...)}\n     case 'cc': {j7()}\n     otherwise...\n   }\n   functionB(...) {\n     ...\n     select on x\n     case 'aa': {balasdf()}\n     case 'bb': {nib()}\n     case 'cc': {zork(...)}\n     otherwise...\n   }",
      "id": "7315c06afbdb13e93c0c3b88a0003b16"
    },
    {
      "type": "html",
      "text": "Robert implies there is some kind of what comes across as existential coupling between these two lists because they may be affected by some changes, such as adding a new item to each list. It is not a \"hard\" coupling, because there are no existing references between the two lists (other than \"x\", which does not change in the scenarios usually used).",
      "id": "a1ceae82e0ebecdc0b97849b41acdc5d"
    },
    {
      "type": "html",
      "text": "\nBut the case lists might also drift apart. We may add a \"dd\" to one, but don't want it for the other, for example. There is no guarantee they will change in lock-step. Even if you feel they are likely to change together, the \"coupling\" still depends on probability. There are change probabilities that require polymorphic classes to change in lock-step also, the classic being adding a new method to every shape sub-class. (See [[Switch Statements Smell]] for discussion on change impact and case statements.)",
      "id": "b567366e7e6ea571db477ef2289801f0"
    },
    {
      "type": "html",
      "text": "\nThus, \"coupling\" is drifting from what may have been a clear-cut metric to something that depends on probability estimates and personal judgment. It is not the \"magic metric\" that some paint it as.",
      "id": "cce049476714bf90abdbb91f86c2a67e"
    },
    {
      "type": "html",
      "text": "\nAn example of objective coupling is a method in a class:",
      "id": "ceae762730c1418b7c908389982085fb"
    },
    {
      "type": "code",
      "text": "  class foo {\n    method bar{....}  // location A\n    ...\n  }\n  .....\n  x = new foo(...);\n  x.bar(...)  // location B",
      "id": "94a344465cb7f8099cbbcb2c26cba355"
    },
    {
      "type": "html",
      "text": "\nHere, the method call in location B is \"coupled\" to location A because if we remove method \"bar\" at location A, then the method call at location B is no longer valid. (Changing parameter signatures can be a similar issue.) This kind of thing is where such a metric is useful. However, the link between two CASE lists that may or may not change in lock-stop is subjective, or at least dependent on [[Perception Of Change]] and [[Software Development Is Gambling]].",
      "id": "4f56e797d9afe19d06e1ae5dc0e5b047"
    },
    {
      "type": "html",
      "text": "\nThe \"bar\" example does not assume any external knowledge or experience. One can look at the code and only the code. In fact, an algorithm could probably be written to draw lines between coupled portions of code. The two CASE list issue could not be done this way unless we make up-front assumptions about the likelyhood of change, but people (like me) can question such assumption, wanting more evidence beyond someone else's anecdotes.",
      "id": "ab26d792e8d48fe5d63679c0670eb974"
    },
    {
      "type": "html",
      "text": "-- top",
      "id": "4921c41b69ea2112e8368dfcbd5b0242"
    },
    {
      "type": "html",
      "text": "\nThat's true, but there is no truly magic metric, and IMHO, [[Coupling And Cohesion]] does better in that department that most suggested measures.",
      "id": "3d4fe38dadcafbfc1461ae5e9ad5f963"
    },
    {
      "type": "html",
      "text": " How can it when it is not measuring any \"hard links\"? It is purely a human perception thing, and we know where relying on that leads as far as reaching agreement or defining good design rules. And the few clearer ones risk [[Soviet Shoe Factory Principle]].",
      "id": "5a6aa4c884c3b32d50a7da5f54a3dcbd"
    },
    {
      "type": "html",
      "text": "\nSimilarly with the rest of your comments: perhaps true in the absolute, but replacing switch statements with class-based method dispatch <b>typically</b> produces real, tangible benefits.",
      "id": "9454da7716b113877eab38ccca919513"
    },
    {
      "type": "html",
      "text": "\nThe most common exception is probably your fond example of tables where neither rows nor columns have natural precedence over each other, so that neither is appropriate as the relative root. In pure OO realms people work around this with [[Double Dispatch]], which is often good enough if not perfect, and in impure realms, multi-methods/generic functions which choose a method based on multiple parameter types/classes simultaneously solves this very nicely.",
      "id": "8162d2a40fe507d46a81af8697a655ba"
    },
    {
      "type": "html",
      "text": "\nOn the other hand, I won't dispute that it can also be solved nicely without OO and without multimethods, using good old-fashioned data-driven programming, which pre-dates OO but has philosophical similarities with it. In this case, one might have e.g. a 2-D table indexed by appropriate manifest constants, retrieving the appropriate function pointer to use. This amounts to implementing multi-methods by hand.",
      "id": "0f2b3dc258dc5fd672639a956eb1f019"
    },
    {
      "type": "html",
      "text": " I am not sure what you mean \"by hand\". A good table-oriented language makes it a snap, perhaps easier than code-based approaches because you can key it into a nice grid ([[Table Browser]]) rather than fiddle with hard-to-read syntax. Perhaps in C it is a pain, but [[Cee Is Not The Pinnacle Of Procedural]].",
      "id": "318a5ffe9f10da620ce6bc27761f2010"
    },
    {
      "type": "html",
      "text": " [It's \"by hand\" because a table ([[Vee Table]] for example) of function pointers is what OO-supporting languages use to implement dispatch (efficiently); when you build your own table of function pointers for the purposes of single or [[Multiple Dispatch]], you are reimplementing a feature of other OO languages by hand in your own code. Implementing the table \"by hand\" is intrinsically going to be more work than not implementing the table at all, which is an option if your language of choice already implements multimethods (or simply <i>methods</i>, if you don't need [[Multiple Dispatch]]). It may be fairly <i>straightforward</i> work, especially if you're familiar with working in tables, but it's clearly not less work than not implementing a dispatch table at all. -[[David Mc Lean]]]",
      "id": "c8fa90a4746f3bc89662b2586621c3f0"
    },
    {
      "type": "html",
      "text": " Perhaps for simple stuff, but not if you wanted to do query-like dispatch, such as run all processes for cities that have a population between 1 mil and 3 mil with an average humidity below 40%. And tables are easier to read or can be re-projected to be easier to read than OOP code attributes all jammed up in unnatural ways.",
      "id": "90a6f1225a824eba6b17e1049ac0f61f"
    },
    {
      "type": "html",
      "text": " [Querying in order to \"run all processes for cities that have a population between 1 mil and 3 mil with an average humidity below 40%\" is not an example of dispatch. Dispatch is fundamentally a system whereby the caller of some area of code does not determine the specific behaviour invoked, but one or more callees (arguments). Querying for a particular dataset and then running \"all processes\" on it implies either that the \"all processes\" will be exactly the same for every row of the dataset, or that the \"all processes\" are polymorphic in some way---but in that case the dispatch occurs in the \"all processes\", not in the query to collect data for them. As for tables being easier to read than \"OOP code attributes\", the relevant properties of code when it comes to dispatch are the signatures of methods, which in most languages are quite easy to read excepting pathological cases (methods with tens of arguments). A single [[Double Dispatch]] method in a multimethod-supporting language gives you just a list of method signatures, listing off the objects the method'll work on; a single triple-dispatch method in a multimethod-supporting language takes exactly the same form. Each [[Double Dispatch]] method implemented by hand with relational tools must have its own table, with rows corresponding to the first argument and columns to the second (or vice versa); a triple-dispatch method implemented in relational requires three dimensions, which tables do not afford. (In addition, the multimethod version does not require you to create a bunch of extra named functions. With a relational table, you need to store a name or some other identifier in the table for each possible method implementation.) The point is, a (non-pathological) implementation of multimethods as part of language core will be able to solve dispatch-class problems with much less work from the programmer than <i>any</i> implementation of the same functionality by the programmer, whether it's in relational tables or some other form. -[[David Mc Lean]]]",
      "id": "2ba7a09e5b7024f785c05a200a9d48dc"
    },
    {
      "type": "html",
      "text": " I mean a table something like this [[Control Table]]:",
      "id": "66e794b9d2a66d4c8b83d21f9535ffbb"
    },
    {
      "type": "code",
      "text": "       city.....pop_m..avg_humid...function or expr.\n       ---------------------------------------------\n       ST. LUIS...4.2.......50.....foo()\n       SALK LAKE..3.1.......42.....bar()\n       MAUI.......2.6.......65.....zaz() + foo()\n       //Etc. (Simplified for illustration purposes. Joins may be used in practice to get average, etc.)",
      "id": "54e178d7160611e944de1601c4e4ec3b"
    },
    {
      "type": "html",
      "text": " That same info, including attribute values, as OOP sub-classes is harder to read in my opinion. And generally requires programmers to change instead of merely power users. But maybe we are wondering off topic.",
      "id": "9a4fc442064fe0eb4cb9f8b22e72c294"
    },
    {
      "type": "html",
      "text": " [Disregarding for a moment that calculating any information about a specific city by calling some global function foo() isn't particularly logical, what properties would you calculate in that way, and can not the expressions for deriving such properties be derived from the existing established properties of the cities themselves? Defining a varying expression for calculating \"something\" on a per-row basis genuinely is best done by providing the expression in the row directly, but is defining an expression on a per-row basis really the best way to calculate that something in the first place? (Using code that will be directly evaluated in the row, as opposed to some \"safe\" representation like a domain-specific language that will be evaluated in a sandbox, naturally raises concerns of security in the application, but that's neither here nor there.) -[[David Mc Lean]]]",
      "id": "7f5101fd42b8edb895e4935bdab31cc7"
    },
    {
      "type": "html",
      "text": " Not sure what you mean by not being logical. Similar factoring questions often arise from long, repetitious CASE lists also, but it's often heavily dependent on the domain. As far as \"security\", that would be an issue with just about any dynamic tool, and is to be evaluated on a situational basis. But that's the main point: <b>domain issues and domain changes shape the tradeoffs</b> such that saying \"always use code pattern X\" is silly.",
      "id": "0d63d5419a1e0607a4ca0c4470e1afe1"
    },
    {
      "type": "html",
      "text": " [I claim it's not logical to calculate a property of a <i>specific</i> city (say, the tax rate in Townsville) by calling a <i>global</i> function like foo(), since that global function has no way of knowing what it's supposed to be doing in this specific situation. Security is not necessarily an issue with all dynamic tools, since even when using a dynamic tool one is not required to evaluate arbitrary language expressions received as input; as noted, one could devise a safe [[Domain Specific Language]] (one with no side-effects for example) and use [[Interpreter Pattern]] to evaluate its expressions with no security risk, or alternatively use some form of sandboxing in conjunction with a \"normal\" language. As for the major claim, if the problem necessitates that arbitrary expressions be evaluated at runtime then naturally evaluating arbitrary expressions at runtime is the only real solution. Why would it, though? If the objective is to allow power-users to modify functionality, asking them to write actual expressions in your programming language is asking them to be programmers; what other use case involves modification of functionality that couldn't be done just as easily in the code? -[[David Mc Lean]]]",
      "id": "12908a8212c5d849219c02b0e781e6c0"
    },
    {
      "type": "html",
      "text": " Typically the function(s) would have access to its row's attributes. Perhaps I should have shown \"foo(thisRow)\" or something. (I sometimes make the current row array a global or outer variable to the called functions' scope to simplify the expression syntax.) And power-users are often comfortable with spreadsheet-like formulas, but may not be programmer material. It's not unrealistic to have a tool that's half spreadsheet and half application. Some spreadsheets outgrow Excel and need SOME database-like parts. These are usually internal department-only apps with a small set of users and power-users.",
      "id": "9b6b269f749cae90e4690fd389e9f00e"
    },
    {
      "type": "html",
      "text": " [I'd argue that if you plan to treat the fields like Excel formul rather than like full arbitrary language expressions, you should be interpreting the content of those fields using [[Interpreter Pattern]] on a formula-specific DSL, rather than technically accepting any arbitrary language expression. Nonetheless, you make a reasonable point regarding spreadsheets as a whole. -[[David Mc Lean]]]",
      "id": "7dfd8789638fb117edb43031174480b9"
    },
    {
      "type": "html",
      "text": " When you add libraries to the application, you create a dependency between the library and the code-base that may complicate future maintenance. For example, when the language is upgraded, something in the interpreter library or add-on might break. And it creates another library for the maintenance programmer to learn. Using built-in EVAL-like functionality generally avoids this problem, being the most KISS. For many environments, what you describe is [[Safety Gold Plating]].",
      "id": "079b4eb80fa7de16b608fd2b41e74b43"
    },
    {
      "type": "html",
      "text": " [Sorry, when did I suggest adding libraries to the application? I don't recall arguing that additional external libraries should be added, although I hardly think avoiding external dependencies simply because they are external dependencies is wise. -[[David Mc Lean]]]",
      "id": "b099185984ab5626ca18c84550cb0bfb"
    },
    {
      "type": "html",
      "text": " [[Interpreter Pattern]]. A decent interpreter would be library-sized, and be reinventing what Eval() does out of the box. Anyhow, it's a shop's tradeoff design decision. [[Let The Reader Decide]].",
      "id": "0f61be3ea325262f2d1dad2b547b3597"
    },
    {
      "type": "html",
      "text": " [A decent interpreter for a specialised DSL intended to allow entry of particular mathematical formul and nothing else will not be library-sized. Nor will it be a reinvention of what eval() does, especially if the application language used does not feature the same expression syntax as is desired for formul (for instance, if it's Lisp). Implementing a complete sophisticated sublanguage would approach library size, but we don't <i>want</i> a complete sophisticated sublanguage. -[[David Mc Lean]]]",
      "id": "3dc73dba9829d43a62a9900ac0b0339e"
    },
    {
      "type": "html",
      "text": " <i>A simple recursive-descent parser for canonical formul is tiny, often consisting of a single class and one method per terminal or non-terminal in the grammar.</i>",
      "id": "eaec005064d3139d581543e951eeed25"
    },
    {
      "type": "html",
      "text": "\nEven the latter is typically superior to just using switch statements, though. An example that I've frequently run across in my own work is in interpreters and compilers full of switch statements on the types of objects being manipulated. Some of them do a type-specific print of a value, some do type-specific code generation, etc, and <b>in practice</b>, not theory, these switch statements suck and suffer bit rot and get out of sync with changes, etc, and replacing them with any of the above approaches - including table-oriented methods - has always resulted in sharply better, more maintainable, more readable code.",
      "id": "2dacd53bf5836de495b787f115a41852"
    },
    {
      "type": "html",
      "text": " I agree that systems software may be able to make better use of \"subtypes\". (See [[Oop Biz Domain Gap]]). In your compiler example, \"types\" are hard-wired into the language definition, and thus are relatively immutable. (It may be a case of modeling types with types, which is kind of a self-fullfilling prophecy.) However, I have yet to find too many immutable counter-parts in the biz domain, where hierarchical taxonomies or mutually-exclusive lists are simply a poor model of real change patterns. Show me actual specimens of biz case lists that go awry and I may change my mind. Also in practice I rarely find something that fits a double-dispatch version. A clean one-to-one matrix of factors-to-behavior is too regular to fit the messy biz world. The only practical examples seem to be things such as modem drivers (yet more [[Systems Software]]). -- top",
      "id": "ec1a682f78be98f626890e00c66c454e"
    },
    {
      "type": "html",
      "text": "\nI don't agree with everything [[Robert Martin]] says, but in this case, I believe he is right on target. Most of the time, switch statements have worse [[Coupling And Cohesion]] than OO/generic/data-driven approaches, and one aspect of this is not fuzzy: the switch statements are scattered all over the code, whereas the other approaches centralize things in such a way that lack of synchronized changes becomes less likely, and in fact the language can to some extent actually assist. -- [[Doug Merritt]]",
      "id": "a3660ff0535c40b59e800699e508317d"
    },
    {
      "type": "html",
      "text": "<i>The issue at hand is whether similar case statements are \"coupling\", not whether they are \"good\". The goodness issue is taken up in [[Switch Statements Smell]]. Note that Polymorphism scatters the \"method list\" all over the place in a similar fashion. It is not a free lunch. It generally seems to boil down to a probability estimate, and OO fans see different change probability distributions than I do ([[Perception Of Change]]). It may be a domain-specific thing, or a personality thing. I have asked for an example of a biz domain case list that changes in lock-stop as claimed and have yet to receive one (other than something that should be a table instead). Thus, I have good reason to remain skeptical. I also find IF statements easier to adjust the [[Granularity Of Variation]] on than polymorphism. For example, it's not uncommon in the biz domain for the change request to ask for both features instead of an either/or choice. It's usually less re-coding to change a CASE block into an IF block than it is to de-mutually-exclusivize polymorphism.</i>",
      "id": "747c302acb92734f68f4551f7eacb127"
    },
    {
      "type": "html",
      "text": " {[[Payroll Example Two]] benefits from polymorphism.  It would be quite dire with CASE blocks or IF statements.}",
      "id": "e4c55bdd464f6ff56a38df2c4b9a72d6"
    },
    {
      "type": "html",
      "text": " <i>[[It Depends]] on what the future change patterns actually are. See [[Payroll Example Two Discussion]] for my comments on it.</i>",
      "id": "f2ed09c92fc6cde6d49ac856e5cafcae"
    },
    {
      "type": "html",
      "text": " {Yes, I recall those.  The polymorphic version was clearly superior to the CASE-based equivalent in every respect.}",
      "id": "a32a7447ca9cb0f361f8f03cd37ba741"
    },
    {
      "type": "html",
      "text": " <i>Clear? Really? It didn't show objective metrics, only unverifiable claims that may not necessarily apply to all domains. One participant on the other \"side\" stated, \"I suppose the only way to fairly and objectively resolve this debate would be to experimentally test a series of maintenance actions against the OO version and an equivalent CASE-based procedural version, and measure error rates, implementation time, and developer perception.\"</i>",
      "id": "a9abc5ea4d04e7787e92395db5d53ebe"
    },
    {
      "type": "html",
      "text": " <i>\"Clear\" to me would be </i>counting<i> errors made, number of key-strokes needed, number of eye-movements needed, minutes needed to make a given change, etc. However, in practice we won't get such info. But, we can use proxies for such, such as a hypothetical \"mind dump\" of the steps a typical maintainer will take to find and fix stuff along the lines of \"He/she sees that the URL has \"foo.prog\" in it so looks for the file called \"foo.prog\" in the code folder, then opens the file in the editor and looks for the string \"glob date\" because the form called the field \"glob date\"...\".</i>",
      "id": "49b1a2040583a58ace7602c5e64a124e"
    },
    {
      "type": "html",
      "text": "\nDoug, would you agree that a switch statement in a class may be acceptable if all other dispatch systems were ruled out for some reason provided they did not exit that class?",
      "id": "708218b1a6ef6a59fe3f31fd89dc5c3e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nSticky problems in [[Coupling And Cohesion]]:  [[Coupling And Cohesion]], much like layers of abstraction, tends to be excellent for making the programming easier... and awful for optimizations.  Many of the most powerful optimizations are those that cross boundaries that very clearly constitute 'unnecessary coupling' and might even be called 'utterly evil coupling'.  Furthermore, many of these optimizations cannot be performed by modern optimizers (or even next-generation optimizers...).  And these include real, algorithmic optimizations... not just coefficient cost reduction (though you get that, too).",
      "id": "8696eedd668af658182fd831c3e65847"
    },
    {
      "type": "html",
      "text": "\nI suggest that future research should consider the possibility of aspected-oriented coupling for optimization purposes.  Until we have something that can cross boundaries for us, we'll be doing it by hand, [[Best Practice]]s be damned.",
      "id": "60052f134aaeb98785326f8da9a7b1b0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "\nExample of subjectivity in metrics:",
      "id": "2eb8252cfe930f174b3ae26ce2c32d77"
    },
    {
      "type": "code",
      "text": " routineA(...) {\n    x = routineB(a, b);\n }",
      "id": "68b5158a7e0bdba60fb3bcadcd8370c1"
    },
    {
      "type": "code",
      "text": " routineB(x, y) {\n    [...]\n }",
      "id": "e7ea9a684440bcd512f6c60da03e4126"
    },
    {
      "type": "html",
      "text": "\nIs routineA coupled to routineB and visa versa?",
      "id": "96666758510a987b13e7f659b8482a2c"
    },
    {
      "type": "html",
      "text": "\nNote that if we change routineB to this:",
      "id": "bb0c40a0f5db47730ab419d0c77c69f1"
    },
    {
      "type": "code",
      "text": " routineB(x, y, z) {  // add a new parameter\n    [...]\n }",
      "id": "3c67374e5befeabe7df9ebb7921adabf"
    },
    {
      "type": "html",
      "text": "\nin many languages this would \"break A\" because A calls B with insufficient parameters now. In languages where different parameter counts are allowed such that \"z\" would return blank or Null, the affects are harder to determine. We'd have to dig around in the algorithm details.",
      "id": "9c8c26d16e2a8abaca7e859649014e4a"
    },
    {
      "type": "html",
      "text": "\nWhat counts and what doesn't as \"coupling\", and if all instances are weighed equally is usually a subjective thing. Some situations are even non-deterministic, or at least very expensive to discern because all possible calculation paths can fan out approaching infinity.",
      "id": "a94abeaf580c1eea1c29bbcf865cf885"
    },
    {
      "type": "html",
      "text": "\nIt is possible to make it clean by ignoring certain relationships, but this gets back to objective metrics versus useful objective metrics ([[Soviet Shoe Factory Principle]]).  If we don't count stuff just because some of the metric calculations are too expensive, we may make a nearly useless metric, or at least diminish its practical utility.",
      "id": "ac855d9f858e45cf30b328cd21838e4a"
    },
    {
      "type": "html",
      "text": "--top",
      "id": "13217630cdfbc5ae5992aa878fdb8672"
    },
    {
      "type": "html",
      "text": "\nYou could also break routineA by deleting routineB, or by making routineB return semantic garbage, or by making routineB return some type-unsafe value for routineA, et cetera.  You'll just confuse yourself if you get hung up on petty details like whether the new 'z' parameter can possess a default.  It is quite clear that there is a very 'hard' (measurable, provable, graphable) dependency from routineA to routineB, but it is not at all clear what your claim of 'subjectivity' happens to be in this example (are you making this another vector for your [[Objectivity Is An Illusion]] mantra?).  As to the 'vice versa'?  Dependencies aren't necessarily bi-directional.  And coupling is about <i>mutual</i> interdependence - i.e. you need to demonstrate the 'vice versa' before you can show there is any coupling at all.  Doing so would be impossible with the little information you've provided above.",
      "id": "e6143f3cb50a5e0c5d17ae7658625d82"
    },
    {
      "type": "html",
      "text": "\nFocusing on the motivation for your spiel:",
      "id": "d2d4c301afce62bcdbb59993e3fae594"
    },
    {
      "type": "html",
      "text": "\nThere may be some sort of 'soft' coupling if routineB is being continuously modified to meet the needs of routineA, in much the same way that helper-routines are coupled to the procedures that need the help.  This coupling wouldn't necessarily show up in a dependency graph of function calls; rather, it would show up in the commit history for the project.  This is something you might call 'existential' coupling.  It would be unreasonable to claim it doesn't exist (people can obviously point at examples of it, therefore it must exist).  But one might question its ultimate relevance.  Hard coupling causes hard problems like [[Dll Hell]].  This 'soft' or existential coupling does not.  Thus, whether 'high existential coupling' is even a problem should be evaluated independently.  I do not believe it would be a problem.  Heck, you might as well claim that all domain-based classes and routines in a project are 'existentially coupled' in the form of [[Robert Martin]]'s example - after all, they are all part of the same project, thus if the requirements of the project change they tend to change also.  But it doesn't cause problems (or provide benefits), and therefore it isn't relevant.  And, completely independent of whether they are easy or difficult to measure, irrelevant things simply don't need to be measured.",
      "id": "3f81d2a6a4360845c11e8974b91c398b"
    },
    {
      "type": "html",
      "text": "<i>Is our goal to solve and prevent problems, or merely measure something? If the first, then why would \"soft\" and \"existential\" coupling be omitted? You seem to half-agree that soft/ext. coupling can cause problems.</i> (Only insofar as need for change ever causes problems.) <i>And Martin makes an issue of it. The opening definition seems to include soft coupling. Perhaps we just need a better classification system for \"coupling\" (or at least \"dependency\"). Here's a rough draft:</i>",
      "id": "26897cb39a40379a25f6bf5f0cd4ac73"
    },
    {
      "type": "html",
      "text": " References or associations that can be determined by <b>inspecting the code</b> without studying the algorithms involved. For example, subroutine calls may be coupled by their parameter signatures:",
      "id": "a8df11debec72e2611f7fcc652f58358"
    },
    {
      "type": "code",
      "text": "           foo(1, 2, 3);\n           ....\n           function foo(a, b, c) {.....}\n           // We can see that the def of foo requires 3 parameters\n           // (Assuming the target language does not auto-nil missing ones).",
      "id": "a8902ae9a9e5619945f5f46a3d535cac"
    },
    {
      "type": "html",
      "text": " References or associations that depend on <b>run-time behavior</b> (or at least behavior too complex to be detected by automated basic code analysis).",
      "id": "aaa02a02c55340d4e47aad50c10222b7"
    },
    {
      "type": "code",
      "text": "          function X() {\n            fileName = \"myfile.txt\";\n            a = foo(fileName, currentDateTime());\n            if (a.length > 0) {\n               fileName = alternativeName(a);\n            }\n            contents = readFileContents(fileName, settings);\n            // Function X is coupled to existence of \"myfile.txt\" if \"a\" not blank.\n            // (let's assume readFileContents() requires file existence.)\n          }",
      "id": "cb8a4b4df01bc3acd68104aad32e8535"
    },
    {
      "type": "html",
      "text": " References or associations that depend on some <b>possible future change</b> or requirement.",
      "id": "0137afa4d33ece3dcfe9b417215872e1"
    },
    {
      "type": "html",
      "text": " Example: The potential case-list item addition example given above near the \"fuzzy metrics\" title above.",
      "id": "f96d6907c4acc59c1b0b462e9fccfa96"
    },
    {
      "type": "html",
      "text": "\nDidactic examples would be welcome, top.",
      "id": "2aea106cf07b72cebe0c6f4387f22771"
    },
    {
      "type": "html",
      "text": "<i>Added. See above examples. --top</i>",
      "id": "19ac606d82a9cf4db76cb35ffd6519b9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "External Links:",
      "id": "563e251f1ccfe7cdfcfeca8c8127bad2"
    },
    {
      "type": "html",
      "text": "\n[http://www.computing.dcu.ie/~renaat/ca421/LCOM.html www.computing.dcu.ie]",
      "id": "aba0898b6137afabac419d70d8e5d0c2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "See also: [[Decision Math And Yagni]] [[Decoupling Of Object Oriented Systems]] [[Directed Refactoring]]",
      "id": "87c3c0dfd36c2a524d516ed17bad37fa"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "85ecbeca22e576fe55d91512e49017eb"
    },
    {
      "type": "html",
      "text": "[[Category Info Packaging]], [[Category Modeling Laws And Principles]]",
      "id": "86bf377cfd01cb04d08b946e51443d72"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?CouplingAndCohesion c2.com]",
      "id": "938bf1de64692233a9050c3ef1ea60eb"
    }
  ],
  "journal": [
    {
      "date": 1417271846000,
      "id": "376ec2a7ee92be0fcaee6e37d5c4fb1d",
      "type": "create",
      "item": {
        "title": "Coupling And Cohesion",
        "story": [
          {
            "type": "html",
            "text": "Given two lines of code, A and B, they are <b>coupled</b> when B must change behavior only because A changed.",
            "id": "8d5b8de534b5aa66d96a0fc603aeb208"
          },
          {
            "type": "html",
            "text": "\nThey are <b>cohesive</b> when a change to A allows B to change so that both add new value.",
            "id": "a56853f63cd23951c3ad26fdc1897ee7"
          },
          {
            "type": "html",
            "text": "\nThe difference between [[Coupling And Cohesion]] is a distinction on a process of change, not a static analysis of code's quality. But there are plenty of indicators and [[Best Practice]]s...",
            "id": "760c7b81cf446e734cc309829896c08e"
          },
          {
            "type": "html",
            "text": " Does \"must change behavior\" refer to source code changes, or run-time results?",
            "id": "0629bda2eb2447355229923b4d15081f"
          },
          {
            "type": "html",
            "text": " <i>It refers to explicit modification of behavior - i.e. the source code.  Automatically adapting run-time results in a value-added way more closely matches the concept of <b>cohesion</b>, below.  'Coupling' is more readily identified by the way things break. Consider: the only reason your B \"must\" change behavior as cause of A changing is that the change to A broke the behavior of B.</i>",
            "id": "6d0a342b3c82ecdd0bd88d2716cb1ef5"
          },
          {
            "type": "html",
            "text": "<i>It's my summary judgement that \"change\" is too open-ended to make this a rigorous concept, a discussed below. There's an effectively infinite way any given module can \"change\". One has to first \"tame\" and classify \"change\" as a prerequisite to rigor-tizing C-and-C if it's tied to the term \"change\". --top</i>",
            "id": "388f127eddb10fd27c803583249aac3a"
          },
          {
            "type": "html",
            "text": "\nThe rubric is chosen to give the term the most value in an [[Agile Software Development]] context; hardening code against bugs by pushing C1 down & C2 up.",
            "id": "e7915163861b4cb4a4eb0e220c9f8cf7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nIt would be difficult to escape the notion of <b>probability</b> here. There are often myriad potential changes and related cross-influences, but each change path is rarely equal. In practice, we are often weighing probabilities of different kinds of changes, sort of a cost/benefit/probability analysis of each potential change. Most authors who talk about C&C seem to bypass the issue of probability, making questionable or untested assumptions in the process as a substitute. Related: [[Change Pattern]]. --top",
            "id": "e141097da5567f9acb32204d76355b46"
          },
          {
            "type": "html",
            "text": "<i>Probability of change is a non-issue for [[Coupling And Cohesion]], but is important for [[Change Pattern]]s. Consider: two units may be tightly coupled even if the probability of change (and consequential breakage) is very low. Because of this, you must distinguish between the coupling and the probability of change.</i>",
            "id": "8910ea2718216c946bfe080664d3eed9"
          },
          {
            "type": "html",
            "text": "\nAlmost everything is \"coupled\" at least by the fact that the names must match.",
            "id": "2bbec94691bdf62d181e9c20363dc16a"
          },
          {
            "type": "html",
            "text": "<i>Uh... unless you mean to say \"Almost everything that is 'coupled' via a shared name dependency is 'coupled' by the fact that the names must match\" (which is trivially true) you are very much incorrect. For example, the code I'm (supposed to be) working on right now certainly isn't coupled to the code you're working on, and there is no need at all for names to match.</i>",
            "id": "3e7070c78d0371d4ce1a9ece61b1dd2a"
          },
          {
            "type": "html",
            "text": "\nThus, \"coupling\" is a matter of degree.",
            "id": "f7fe25840d420dc5ba14c7031bc298a9"
          },
          {
            "type": "html",
            "text": "''While it is true that coupling is a matter of degree. I can make no sense at all of the main statement just above. Does any one have any idea what it might mean?'\nI am thinking that it might be equivalent to the claim that programs that have no dependency at all  are not coupled-- have zero coupling, but I can not figure out how that leads to  \"coupling is a matter of degree\" unless 0 is a degree, but then I am not sure what the point was. HELP wanted here I think others may also be confused. - ANNON",
            "id": "4060f8032f27be8f97277b6b684cded8"
          },
          {
            "type": "html",
            "text": "<i>While your logic leading to it is baffling, I agree with this conclusion. That is why we discuss the desire for \"low\" external coupling and \"high\" internal cohesion.</i>",
            "id": "323454e8d5bc29bcd8bdfdf65667e4c7"
          },
          {
            "type": "html",
            "text": "\nAnd to calculate a \"coupling\" score, it would make sense to consider probability of change rather than just the existence of a potential breakage due to change.",
            "id": "3a0927067dccac36b1b38fb1e1f5d911"
          },
          {
            "type": "html",
            "text": "<i>Incorrect. It would not make sense to consider the <b>probability of change</b>.  But it wouldn't be a bad idea to consider the <b>probability of breakage given a change</b>.  Mathematically, that is <b>P(BREAK|CHANGE)</b> = <b>P(BREAK AND CHANGE) / P(CHANGE)</b>.  In layman terms, this (loosely) is the probability that code unit 'B' will 'break' after an unknown change to code unit 'A'. The closer this probability is to 100%, the higher the coupling from 'B' to 'A'.</i>",
            "id": "93434504739baced1c7774590ff11b5e"
          },
          {
            "type": "html",
            "text": " Perhaps we should make a distinction between calculating coupling and calculating the actual effects of coupling.",
            "id": "e55b164cf1cc2c06b2ae931d934c54f1"
          },
          {
            "type": "html",
            "text": " <i>Indeed. The above wouldn't truly aim to calculate coupling, but rather to measure it.  All 'measurements' are performed through 'effects'. Even distance measurements are based on the effect of distances on, say, reflected light or sound, or on diminishing covering arcs for objects of known height or width, etc. In this case, observing or scoring coupling based on its effects - how it is associated with breakage between modules - is, indeed, a measurement rather than a calculation. Good catch.</i>",
            "id": "4dbf31a0c9fb666ef2dddda86709aea3"
          },
          {
            "type": "html",
            "text": "\nWe may find that things A and B have coupling points C,D,E; and things J and K have coupling points L,M,N. If we merely count the quantity of coupling points, then the coupling between A-B and J-K would be considered the same. However, in practice, changes to L,M,N may be much less likely than C,D,E.  Thus, the utility of measuring coupling is greatly enhanced by considering probability of occurrence. Otherwise, we'd optimize our code for what could be very infrequent events over frequent ones. --top",
            "id": "d14e3db46722de023ef6c98a8f63a186"
          },
          {
            "type": "html",
            "text": "<i>We should optimize our code for [[Change Pattern]]s that have been anticipated based on past experience. But coupling is not the same thing as change patterns. Distinguishing between them is useful for providing or understanding advice such as: \"Reduce coupling to details or features that are subject to frequent change.\"  Indeed, the utility of 'measuring coupling' is enhanced by such distinction. If we don't distinguish between 'coupling' and 'frequency of change', then there is little purpose in having both phrases.</i>",
            "id": "5c71ed24231f2ed0652a59dda21c3e20"
          },
          {
            "type": "html",
            "text": "\nThe distinction between practical couplings and theoretically couplings can make a huge practical difference. For example, a medical application may be coupled to the assumption that a typical human has two arms because it asks the doc to inspect both arms of patient. In theory if an alien race with 3+ arms immigrated to Earth, the application could break or become useless. But in practice you'd be labeled silly to dwell on such. However, there are plenty of \"anal\" or [[Gold Plating]] developers out there who take some advice too literally and may build a convoluted indirection layer to reduce the impact of more arms. To avoid getting tangled in our own underwear, we have to know where the draw the line, and change probability is a key tool for that.",
            "id": "98442e59e8073951487cb95faceb4824"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nThese are some of the better-defined qualities that separate good software from bad software. Although they were formalized during the invention of [[Structured Programming]], they apply exactly as well to [[Object Oriented Programming]] as to any other kind.",
            "id": "12426d46cf724d17c02dae9e60d34d24"
          },
          {
            "type": "html",
            "text": "<b>Cohesion</b> of a single module/component is the degree to which its responsibilities form a meaningful unit; higher cohesion is better.",
            "id": "b1a5f462ac3c480ee236242fa1a0d842"
          },
          {
            "type": "html",
            "text": " Someone had vague reference to decomposability here.  Clarification?",
            "id": "1a4434282d806632d28b29b199be60f1"
          },
          {
            "type": "html",
            "text": " How about: 'Cohesion is inversely proportional to the number of responsibilities a module/component has.'",
            "id": "fe309debba24e7bbac3fec52b98d1f9a"
          },
          {
            "type": "html",
            "text": "<b>Coupling</b> between modules/components is their degree of mutual interdependence; lower coupling is better.",
            "id": "51a3f12442a3d4719e4723b760472dfe"
          },
          {
            "type": "html",
            "text": " size: number of connections between routines",
            "id": "8b9e32929006d64e83eec37bf600e6b9"
          },
          {
            "type": "html",
            "text": " intimacy: the directness of the connection between routines",
            "id": "18257ec3759d33aadacf1ad404b7b11c"
          },
          {
            "type": "html",
            "text": " visibility: the prominence of the connection between routines",
            "id": "2513c56e700c4afa95b63e1901cac06d"
          },
          {
            "type": "html",
            "text": " flexibility: the ease of changing the connections between routines",
            "id": "9d8838b64eeb711c377dc1d4a2278f80"
          },
          {
            "type": "html",
            "text": "\nA first-order principle of software architecture is to increase cohesion and reduce coupling.",
            "id": "0c4e631bed537d57dd1719d95c83c0a4"
          },
          {
            "type": "html",
            "text": "\nCohesion (interdependency within module) strength/level names : (from worse to better, high cohesion is good)",
            "id": "590a131c7d1cda8dab0bfb9cfd2123c3"
          },
          {
            "type": "html",
            "text": " Coincidental Cohesion : (Worst) Module elements are unrelated",
            "id": "1bbc1e8ea4d3651b0c0eb42c9079f950"
          },
          {
            "type": "html",
            "text": " Logical Cohesion : Elements perform similar activities as selected from outside module, i.e. by a flag that selects operation to perform (see also [[Command Object]]).",
            "id": "8b80dc3febb7064f9524e44dc0ce98aa"
          },
          {
            "type": "html",
            "text": " i.e. body of function is one huge if-else/switch on operation flag",
            "id": "eec369f87bffc6068cc6dc0c592b3c82"
          },
          {
            "type": "html",
            "text": " Temporal Cohesion : operations related only by general time performed (i.e. initialization() or [[Fatal Error Shutdown]]())",
            "id": "3a6972657a14ba1090bf7bdf24b29a16"
          },
          {
            "type": "html",
            "text": " Procedural Cohesion : Elements involved in different but sequential activities, each on different data (usually could be trivially split into multiple modules along linear sequence boundaries)",
            "id": "f0b0d85d95614aac8d638ff4c8a16e87"
          },
          {
            "type": "html",
            "text": " Communicational Cohesion : unrelated operations except need same data or input",
            "id": "780f13e00a5de734c21f64d9f254554b"
          },
          {
            "type": "html",
            "text": " Sequential Cohesion : operations on same data in significant order; output from one function is input to next (pipeline)",
            "id": "304b844cfeb5a72f9bc95f81369f8694"
          },
          {
            "type": "html",
            "text": " Informational Cohesion: a module performs a number of actions, each with its own entry point, with independent code for each action, all performed on the same data structure. Essentially an implementation of an abstract data type.",
            "id": "385f1cb7be16104fb66c696e3c8633df"
          },
          {
            "type": "html",
            "text": " i.e. define structure of sales_region_table and its operators: init_table(), update_table(), print_table()",
            "id": "ac170b9995037bf89adf0b2f33f343fa"
          },
          {
            "type": "html",
            "text": " Functional Cohesion : all elements contribute to a single, well-defined task, i.e. a function that performs exactly one operation",
            "id": "77e54146cd453b2fa11e309fe3e44602"
          },
          {
            "type": "html",
            "text": " get_engine_temperature(), add_sales_tax()",
            "id": "8ed4396c70b4ae1bf89dbe38a9859c06"
          },
          {
            "type": "html",
            "text": "\nCoupling (interdependence between modules) level names: (from worse to better, high coupling is bad)",
            "id": "76c55d5224c1f7ae33567187798c9393"
          },
          {
            "type": "html",
            "text": " Content/Pathological Coupling : (worst) When a module uses/alters data in another",
            "id": "c19442fb7c2be4c062f7613d76b21539"
          },
          {
            "type": "html",
            "text": " Control Coupling : 2 modules communicating with a control flag (first tells second what to do via flag)",
            "id": "41e416f05c3b08255b4612efe4296b5c"
          },
          {
            "type": "html",
            "text": " Common/Global-data Coupling : 2 modules communicating via <b>global</b> data",
            "id": "03d864838bb824eb6cf62f6d398a77d1"
          },
          {
            "type": "html",
            "text": " Stamp/Data-structure Coupling : Communicating via a data structure <b>passed</b> as a parameter. The data structure holds <b>more</b> information than the recipient needs.",
            "id": "9ce5b7b53dc45453ec19c9bc6dde4695"
          },
          {
            "type": "html",
            "text": " Data Coupling : (best) Communicating via parameter passing. The parameters passed are only those that the recipient needs.",
            "id": "331c00d9bb16ed047edc5287b5fc91e4"
          },
          {
            "type": "html",
            "text": " No data coupling : independent modules.",
            "id": "221b0867e593f7dedf0d0121aa2aab7e"
          },
          {
            "type": "html",
            "text": "\nAs usual with software source code metrics, these qualities are difficult (but not necessarily impossible) to reduce to quantitative data that can be meaningfully compared across different projects or organizations, despite their value as qualitative measures.",
            "id": "bc49597eb2023bd4db5f04bb35d3c8ad"
          },
          {
            "type": "html",
            "text": "\nThese measures of quality arose in the context of structured procedural programming, but also apply to other paradigms, including OO; the best OO practices can be seen in these same principles. This should not be surprising; OO did not evolve in a vacuum.",
            "id": "cefb376fb3a5625507b7aeb67bb21d0a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "<i>Can coupling be summed up as  as answering to three questions \"yes\" or \"no\"? Thus having 8 possible outcomes. Questions are \"share meaning (are related)?\", \"share (similar) algorithm?\" X \"share data?\" </i> - Mila",
            "id": "806d1d6f1a1480f01ae70a8aaf64fdfa"
          },
          {
            "type": "html",
            "text": "\nNo, coupling cannot be summed up as answering those three questions. Sharing data is, however, one form of coupling.",
            "id": "e4a304e79f49f01b737084c37f06dbcf"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "Quoted from \"[[Boulder Patterns Group Minutes Old]]\" (not otherwise a page to inspire browsing):",
            "id": "418e6863311f1591fcc8b4ea7824fae0"
          },
          {
            "type": "html",
            "text": "<i>the correct terminology is \"tight internal cohesion\" and \"loose external coupling\". This basically means that each method in a class should have one task and the class as a whole should have one major responsibility (tight internal cohesion) and that other classes should not depend on the inner workings of this class but should be designed to the \"interface\" of the class (loose external coupling). See a recent post by [[Alan Shalloway]] on this: [http://groups.yahoo.com/group/dpexplained/message/108 groups.yahoo.com]</i>",
            "id": "ed72c05a61759dbc4ea9f71d7030e344"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "<i>[The following question in [[Decoupling Objects]] inspired the creation of this page.]</i>",
            "id": "757f2ed6f2a2be86753fc478f6c6b7ce"
          },
          {
            "type": "html",
            "text": "\nI am somewhat surprised to find little in-depth discussion of [[Coupling And Cohesion]] on the Wiki - that is, to be honest, nothing I can readily identify as in-depth discussion of the two measures <i>per se</i> as opposed to second-order principles of design that are asserted to be beneficial \"because they reduce coupling\" or \"because they promote cohesion\". I have an \"intuitive\" understanding of the notions, gained mainly by osmosis and reading texts which refer to them, but I have a feeling that my knowledge might be incomplete. Or are the concepts so straightforward that no such discussion is warranted? Or did I miss some obvious pointers? -- [[Laurent Bossavit]]",
            "id": "35a6e530591614ff45e8b9ea7e21316f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nSomeone in [[The Structure Of Scientific Revolutions]] claimed that knowledge of these concepts has largely been forgotten in OOP. That is most unfortunate, if true.",
            "id": "f7a3e3a20a848cc4e2ea74132e3c9d54"
          },
          {
            "type": "html",
            "text": "\nAs an experienced programmer facile with OO and structured methods, I think that concepts of cohesion and coupling absolutely have their place in OOP/OOD. There are many chunks of OO and/or XP wisdom that fundamentally boil down to those two concepts, appropriately framed.",
            "id": "de00128096015ac8aae9f9d72f51dca8"
          },
          {
            "type": "html",
            "text": "\nA class is a coupled blob. The methods and properties must agree with each other on how the class is put together, or else there's little purpose in your class. That is, the internal interface of the class is what couples the implementation to it.",
            "id": "10d3a64e074fd67e48e848680704990c"
          },
          {
            "type": "html",
            "text": "\nA wise OO practitioner wants that internal interface to be as small as reasonable. When a class gets large or complex, it's a center of coupling and begs to be refactored.",
            "id": "7dfe10c4193eb46e6204c3dc5c1785bc"
          },
          {
            "type": "html",
            "text": "\nCohesion represents unity of purpose. We have long ago learned that the most internally unified unit of work is to formally accept inputs and compute outputs. This is the practice espoused by [[Functional Programming]], which takes [[Functional Cohesion]] to the limits of reasonability - and beyond!",
            "id": "e3e7a07bca0f9e3520779d42ae7f735d"
          },
          {
            "type": "html",
            "text": "\nWe also know that internal unity is not the same goal as global unity. We object-users (Classists?) want to express unity on as many levels as possible. Zillions of disorganized but simple functions do not express that unity. A well-designed OO program expresses the unity of purpose for groups of related methods by stuffing them in a class together. That cohesion is not about behavior in the atomic sense. It does apply to the boundaries of the interface which the class implements. Large classes or hierarchies can endanger that quality at their respective levels of abstraction.",
            "id": "25da95f5179ab8821cf9f2e90059dcc5"
          },
          {
            "type": "html",
            "text": "\nPerhaps the great thing about OO technology is that it makes design problems so clear. Still we must learn to read the writing on the wall. When you have a solid grounding in phonics, you can learn to read English with far less trouble than without, and you can do so on your own from reading books. [[Coupling And Cohesion]] are like the phonics of [[Code Smell]]s. By analogy, perhaps books on OO Design focus on the shape of whole words without teaching the letters first. This yields learning if and only if the prerequisites are met.",
            "id": "073ebc2ef638cc43185ead64ca908f30"
          },
          {
            "type": "html",
            "text": "-- [[Ian Kjos]]",
            "id": "d609b43541ff91cdcecec54c91c2a193"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nIn modular and functional programming coupling is the level of \"dependency\" between functions. And cohesion is a measure of how closely lines or groups of lines within a given function relate to each other: are they all \"doing the same thing\" or \"contributing to a single goal?\" One generally frowns upon global variables and parameters which are flags or codes.",
            "id": "b0d658990a58da47bcde4b1742ef990b"
          },
          {
            "type": "html",
            "text": "\nIn OO programming, I think we've created hierarchy of encapsulation, each level of which can be subjected to [[Coupling And Cohesion]] measures:",
            "id": "4b45b86fd383633e7fe5d31dde5f07e7"
          },
          {
            "type": "html",
            "text": " Each individual method should have high cohesion and low coupling with other methods.",
            "id": "c6d8a8236cacd954b0673ad239f9115c"
          },
          {
            "type": "html",
            "text": " Each individual class should have high cohesion within the class and low coupling with other classes.",
            "id": "479515268ed8329ce64e3f391b3a69c8"
          },
          {
            "type": "html",
            "text": "<i>I recall, as a modular programmer learning OO, that I was very impressed that practically every Smalltalk article I saw had discussions of how they improved methods in classes - in ways that improved cohesion within the resulting methods and reduced coupling between methods. Smalltalk culture clearly promoted appropriate [[Coupling And Cohesion]], far more than even the most ardent modular programming texts, and the OO developers didn't even talk about it; it was just \"the way things are done.\" -- [[Jeff Grigg]]</i>",
            "id": "0d63f9760c8fed9d15eeecf0c0c2db34"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nI am finding in my current project that there is a tendency if one is not careful to swing the pendulum too much one way or the other. When they are too <b>coupled</b>, logic and functionality may be dispersed across several components. Both of these lead to a proto [[Anti Pattern]]: how does [[Pendulum Of Coupling And Cohesion]] sound?",
            "id": "4934d5b8e466bb76345eb13bd69fff92"
          },
          {
            "type": "html",
            "text": "\nI think that the main issue is that what is \"intuitive\" to one person is not the same as what is to another. Also, it is difficult to correctly break up the functionalities of a system without error. This is why we [[Refactor Mercilessly]] right? I sometimes find myself feeling dirty when I'm coding. To me this is a clear indication that this [[Code Smell]]s. I am not enamoured of using scents to describe code but my colleagues understood immediately what I was saying when I told them \"I feel dirty.\"",
            "id": "a9445cc6f16987931606a80726e5b5da"
          },
          {
            "type": "html",
            "text": "\nDoes this make sense or am I just rambling? -- [[Iain Lowe]]",
            "id": "73addaad9f1f7b47dd1825e8934494fd"
          },
          {
            "type": "html",
            "text": "<i>What I find interesting is that I don't see coupling and cohesion as opposite quantities, such that decreasing the one automatically increases the other. What kind of coding tactics do you find yourself switching between as \"the pendulum swings\", as you put it?</i>",
            "id": "2bdf46d7a00b827f5e626783f65d7d76"
          },
          {
            "type": "html",
            "text": "\nI think I was a bit [[Dazed And Confused]] when I spoke about <b>cohesion</b> up there. There <i>is</i> a relationship between the two, though: when modules are very de-coupled it stands to reason that they are cohesive. If they were not cohesive, they would require greater insight into the inner workings of the other modules in the system. So there is a pendulum effect but probably something more like [[Half Pendulum Of Coupling And Cohesion]] since you are correct in stating that cohesion will reach a \"sweet-spot\" beyond which you cannot make a module more cohesive. I need to think about this a bit more... I still haven't pin-pointed the tactic-switching you mention above. -- [[Iain Lowe]]",
            "id": "ad1e8f2ac67dd03415fa71d2dff062d1"
          },
          {
            "type": "html",
            "text": "\nIt seems to me that the case is that a module which is cohesive is necessarily de-coupled. It cannot have unity of purpose if other classes accomplish half of that purpose. That is, while the module may be focused on one task it would not cover all of that task. However, being de-coupled does not imply cohesion. One module which manages three entirely distinct tasks can still be de-coupled from all others. -- James Ferguson",
            "id": "99a6b263ea0cced79cd79797d54eac79"
          },
          {
            "type": "html",
            "text": "\nLook at it from a different perspective: Increasing coupling increases dependence (thus increasing future instability) and Increasing cohesion increases stability. <i>The Holy Grail of [[Coupling And Cohesion]] is the [[Black Box]] which offers <b>The minimum dependence for the maximum stability</b> for its user.</i>",
            "id": "bbae1a849e1849ea682e559d9bab7cff"
          },
          {
            "type": "html",
            "text": " This dictates against [[Premature Generalization]]. After all, [[Premature Generalization]] increases an object's dependencies needlessly.",
            "id": "741987a29aa50bf8a98bd43a8ff5ae3b"
          },
          {
            "type": "html",
            "text": " This supports [[Dont Repeat Yourself]]. If I am too interdependent, I've probably repeated myself needlessly and should [[Refactor Mercilessly]].",
            "id": "be42069c75a48da16c7ba8c768879b4a"
          },
          {
            "type": "html",
            "text": " This supports [[Once And Only Once]]. [[Dont Repeat Yourself]] recommends OAOO whenever possible.",
            "id": "57fff7d4b4497dadd10e780aac1d9437"
          },
          {
            "type": "html",
            "text": " This wants to support YAGNI. After all, if [[You Arent Gonna Need It]], why head toward more instability?",
            "id": "55f14793d92642db6c222572a4c04a3d"
          },
          {
            "type": "html",
            "text": "-- [[Wyatt Matthews]]",
            "id": "24edda1ce5d2053a49a3f9f977e1ecd9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "<i>I smell a false dichotomy. Maybe. Coupling is connection crossing a boundary. Cohesion is connection which doesn't cross a boundary. This suggests that the ideal system is a single global space, and the worst is a highly modular space. Then there's geometric complexity which is a measure of dependency range (How many elements are involved in any one transaction). It is all rather more complicated than a single 'rule of thumb'. I suspect we are applying aesthetic judgement as much as any analytical principle. -- [[Richard Henderson]]</i>",
            "id": "87468e42a064e712ea09b4804eb9a7d8"
          },
          {
            "type": "html",
            "text": "\nMy comment was not intended to imply a single global space as the ideal, but to imply individual spaces should have a minimum of dependence upon another individual space that it was not derived from. Patterns such as [[Abstract Interactions]] increase coupling at one level (the interactions are now required maintenance for the dependent class), but expose less dependence upon other spaces because they deliberately allow the substitution of the object previously required for its execution.",
            "id": "e3ffff9384ed9ee38a2ba9711f3eb30c"
          },
          {
            "type": "html",
            "text": "<i>I know . The global thing is the implication of the definitions of coupling and cohesion with a rule to maximize one and minimize the other. I'm not trying to contradict the thesis of the page. I am a great believer in the basic principle. I just think that there is a whole load of expert intuition involved in applying this [[Heuristic Rule]], suggesting additional factors are involved.</i>",
            "id": "67e939f48b5f7c64e035c369e0679388"
          },
          {
            "type": "html",
            "text": "\nPerhaps we can identify these forces more appropriately. For example, I would think that Coupling is necessary between parent and child classes, but only cohesion is necessary for siblings.",
            "id": "99e8be74eff6e7c82143990948be3ab0"
          },
          {
            "type": "html",
            "text": " To me coupling implies direct maintenance costs and makes me think of welding. Breaking the coupling could result in the loss of established quality (short term) or function.",
            "id": "9c52cff1980893b1022431cdf95142d1"
          },
          {
            "type": "html",
            "text": " Good coupling is seen in a well constructed inheritance tree. I'll term this Deep<b></b>Coupling because the child classes are exposed to the majority of the parent class (your welding the entire surface area where the parts join).",
            "id": "e0fe1b5e7d5e7be14cfe2db07a1018ea"
          },
          {
            "type": "html",
            "text": " Bad coupling requires a specific implementation of Class B to run Class A with no inheritance. This situation BEGS for refactoring or an ORB-style implementation. I'll term this as Shallow<b></b>Coupling because it is done through \"Concrete<b></b>Interactions\".",
            "id": "59d47f7e09a09054d77fce426d74517a"
          },
          {
            "type": "html",
            "text": " Good coupling is also seen in some ORB? contexts ([[Abstract Interactions]] are used). I'll term this as Surface<b></b>Coupling because this coupling is like welding only the outsides of a joint together.",
            "id": "073241c5af5f9ec5df0fb8d817c8ba3b"
          },
          {
            "type": "html",
            "text": " Similarly, cohesion implies the ability to exchange objects with similar interfaces. This concept makes me think of N<b></b>utsAndBolts or H<b></b>ooksAndSlots.",
            "id": "53ba51ecd240b3aa45cbbee8c4a5d920"
          },
          {
            "type": "html",
            "text": " Deep<b></b>Cohesion uses [[Abstract Interactions]].",
            "id": "12a96c82fb60bb4bd722f3c4798e59d5"
          },
          {
            "type": "html",
            "text": " Shallow<b></b>Cohesion uses \"Concrete<b></b>Iterations\".",
            "id": "fa034fc54ec3cd082866938fa9325d0b"
          },
          {
            "type": "html",
            "text": " Surface<b></b>Cohesion implies nearly impossible communications between the participants.",
            "id": "37f21ca2dffb62f376f4c1d21ba19fe1"
          },
          {
            "type": "html",
            "text": "\nAny thoughts on my breakdown of these two forces?",
            "id": "bd022d14cbcd45d4b181135be57235c1"
          },
          {
            "type": "html",
            "text": "-- [[Wyatt Matthews]]",
            "id": "24edda1ce5d2053a49a3f9f977e1ecd9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nIt took me a long time to make sense of this word <b>cohesion</b> which I kept hearing. There seem to be many people who use this word without being able to tell me what it means, or show me code examples of <i>cohesion</i>. I have finally come to some level of understanding. First, if a class has a lot of different behaviour which doesn't naturally go together, it lacks a sense of <i>cohesion</i>. Similarly, if in order to alter some behaviour, one must go fiddle with many different classes, this might be a hint that the behaviour is spread out, rather than being in one <i>cohesive</i> unit. Second, if you look at a class, and everything you need to know about some behaviour is right there, and there isn't any thing else there to clutter up what that class does, then that class has a high sense of <i>cohesion</i>.",
            "id": "77e144b6d914f66cefc7bcc8edb53025"
          },
          {
            "type": "html",
            "text": "<i>Not just <b>cohesion</b> means, but also <b>coupling</b>. At the top, it says: </i>Coupling applies to any relationship between software components.<i> Perhaps it should say: </i>Coupling is the amount of relationship between software components.<i>? (Improvements welcome.) -- [[Chris Dailey]]</i>",
            "id": "920ecbf2f8e801af241f4222703a3b93"
          },
          {
            "type": "html",
            "text": "\nOh. How about from [http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=coupling&action=Search foldoc.doc.ic.ac.uk] - \"The degree to which components depend on one another.\" -- [[Chris Dailey]]",
            "id": "a01bd0ee9d2163029ee717e57e9a720e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nRelationships are what makes software powerful. \"Coupling\" is not something to get rid of, but to manage. Encapsulation is a form of coupling, for example. If two things have NO relationship at the time of writing, then yes, perhaps they don't belong together nor connected (at the time).",
            "id": "03720a3a9d23790d95b46019c924a18b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "<b>Some references:</b>",
            "id": "c2a495a75b0de45c9b1a5f8d7107b311"
          },
          {
            "type": "html",
            "text": "<i>[Kudos for [[Jeff Grigg]] for collecting a significant amount of relevant pointers.]</i>",
            "id": "f43e4f62dbeb1dc67fd0de5c3cabf617"
          },
          {
            "type": "html",
            "text": " \"Coupling and Cohesion\" slide in a presentation (the bullets above are mainly a restatement from that slide) -- [http://www.cc.gatech.edu/computing/classes/cs2390_97_summer/lectures/rdd/slide7.html www.cc.gatech.edu]",
            "id": "843b8ae7856cc484cc626bbba69dcc08"
          },
          {
            "type": "html",
            "text": " [ISBN:<br>0136907695] \"Practical Guide to Structured Systems Design\" (Yourdon Press Computing Series)",
            "id": "2d0328adab05c635146065880bb46cb1"
          },
          {
            "type": "html",
            "text": "by Meilir Page-Jones",
            "id": "24e009cbe354ccd5e9bbef0e1717f129"
          },
          {
            "type": "html",
            "text": " \"Measuring Coupling and Cohesion:<br>An Information-Theory Approach\" - a paper from the November 1999 IEEE International Symposium on Software Metrics, by Edward B. Allen and Taghi M. Khoshgoftaar -- [http://csdl.computer.org/comp/proceedings/metrics/1999/0403/00/04030119abs.htm csdl.computer.org] (payment required for access)",
            "id": "6bfa122ff92fa803b191109ead284947"
          },
          {
            "type": "html",
            "text": " \"Coupling and cohesion in object-oriented design and coding\" at ACM Annual Computer Science Conference, by Joel Henry and Donald Gotterbarn -- [http://dev.acm.org/pubs/citations/proceedings/csc/228329/p149-henry/ dev.acm.org] (?)",
            "id": "fa2caf9b4dc7b6eb439921565e385d52"
          },
          {
            "type": "html",
            "text": " calculator -- [http://141.215.8.244/ccc/coupling.asp 141.215.8.244] (gone since at least 2003-06-22)",
            "id": "109d3279ca30af52cb0d4d0acbd1c1e8"
          },
          {
            "type": "html",
            "text": " [http://www.sfcc.spokane.cc.wa.us/bladek/Bladek/CS2w01/COUP_COH.HTM www.sfcc.spokane.cc.wa.us] (gone since at least 2003-06-22)",
            "id": "31e3f407e7ded519f14f6497460a67f1"
          },
          {
            "type": "html",
            "text": " [http://www2.umassd.edu/CoursePages/SoftwareEngineering/lectureMat/couplingcohesion.html#cnc www2.umassd.edu] (gone since at least 2003-06-22)",
            "id": "d55e1c7a015fe4eaa204bc0036ec0943"
          },
          {
            "type": "html",
            "text": " (Apparently was part of \"CIS 311 - Software Engineering\" course -- [http://www2.umassd.edu/CoursePages/SoftwareEngineering/ www2.umassd.edu] (gone since at least 2003-06-22) but may not be part of lecture notes any more. ;-)",
            "id": "e183184bd472515c87d6d3e3243bd515"
          },
          {
            "type": "html",
            "text": " [http://www.cpsc.ucalgary.ca/~jonesb/seng/613/groupwork/sasd/report.html www.cpsc.ucalgary.ca] (gone since at least 2003-06-22)",
            "id": "45ea56917d14ed82dc2d791dffefb372"
          },
          {
            "type": "html",
            "text": "\nLarry L. Constantine and Ed Yourdon. Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design. 1978.",
            "id": "a53ed7442251ab624e6c34e11077a9d2"
          },
          {
            "type": "html",
            "text": "Pre-OO. Essentially the origin of the those terms in software design, devoting a chapter to each.",
            "id": "bad4da76ed2ac2edc659d92a074952eb"
          },
          {
            "type": "html",
            "text": " Nope! I have a 1975 book that covers all of this! \"Reliable Software Through Composite Design\", Glenford J. Myers. This might be the earliest book appearance. But it cites an earlier article, \"Structured Design\", L.L. Constantine, G.J. Myers, W.P. Stevens, IBM Systems Journal, Vol. 13, No. 2, 115-139 (May 1974)....Note that the article is coauthored by the book author, Myers, and the article is also coauthored by Constantine, who coauthored the later 1978 book mentioned above.",
            "id": "98c55c8b0814641f1122918ab27e0abc"
          },
          {
            "type": "html",
            "text": " And things had been percolating unpublished for several years prior, it also cites as origin of some of the coupling/cohesion terms the unpublished manuscript from 1971, \"Fundamentals of Program System Design\", L.L. Constantine again.",
            "id": "c20aef147e7751f47888a96266d1bec1"
          },
          {
            "type": "html",
            "text": " So if anyone is looking to give credit, it looks like the lion's share goes to Constantine, and the rest to Myers and Stevens.",
            "id": "6d66221ec9a2d1af64ae8a6ad0f04f6c"
          },
          {
            "type": "html",
            "text": "[Yes, I did invent the concepts and the original metrics of coupling and cohesion, with first publication in 1968 (\"Segmentation and Design Strategies for Modular Programming.\" In T. O. Barnett and L. L. Constantine,eds., Modular Programming: Proceedings of a National Symposium. Cambridge, Mass.: Information & Systems Press, 1968.) Glen Myers and Wayne Stevens were students and colleagues of mine at IBM's Systems Research Institute where I was on the faculty from 1968-1974. --Larry Constantine]",
            "id": "0c13465c7edbf223c98eecd62f6058da"
          },
          {
            "type": "html",
            "text": "\nLinks from Chris:",
            "id": "89140242b714349fc1410bb135a041c7"
          },
          {
            "type": "html",
            "text": " \"Reducing Coupling\" by Martin Fowler [http://martinfowler.com/ieeeSoftware/coupling.pdf martinfowler.com]",
            "id": "f0a95539efec42e7c6703acd7fa75408"
          },
          {
            "type": "html",
            "text": " \"Dynamic Coupling And Cohesion Metrics For Java Programs\" by Aine Mitchell [http://www.cs.may.ie/~ainem/contents.html www.cs.may.ie]",
            "id": "73a9c02caac339125de6a6b9a2707173"
          },
          {
            "type": "html",
            "text": " Unfortunately, it's difficult to find links to papers by David Lorge Parnas. [http://www.cas.mcmaster.ca/sqrl/parnas.homepg.html www.cas.mcmaster.ca]",
            "id": "d2d3087bc95a9e2f058eecb543c7584b"
          },
          {
            "type": "html",
            "text": " Here is one of the best : If you have not read it you should [http://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf www.cs.umd.edu] -[[Marc Grundfest]]",
            "id": "409725a8e609d5c72e5133043f767a89"
          },
          {
            "type": "html",
            "text": " <i>See [[On Decomposing Systems]]</i>",
            "id": "445270edc1b3ebf086c7a40a25190f55"
          },
          {
            "type": "html",
            "text": " UNC Comp145:<br>[http://www.cs.unc.edu/~stotts/COMP145/modules.html www.cs.unc.edu]",
            "id": "ccd226d3d7053bad05be0eb554dec516"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nMost examples of [[Coupling And Cohesion]] seem to be device-driver-like examples. If one does not deal with device drivers, then those examples are not very good sales material. Some also depend on a pro-subtype viewpoint. Those of us who think [[There Are No Types]] would like to see something else. If the concept depends on subtyping-based [[Change Perception]], that is fine by me. I just want to clarify if this is the case. -- top",
            "id": "2dfd16dc3e2b7ef8e8f2e2441568cc93"
          },
          {
            "type": "html",
            "text": "<i>Types in OO land aren't really all that much different from \"domains\" in relational-land. If you don't understand that, you need to go re-read [[Chris Date]].</i>",
            "id": "1158192b9faf82d4930c978b9b78b6eb"
          },
          {
            "type": "html",
            "text": "\nTypes maybe. But it is <i>subtypes</i> that are the issue.",
            "id": "c756efd77eb3ccaff3ab23e43c8248e2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "A few of the places coupling and cohesion is discussed:\n[[Nature Of Order Discussion]]\n[[Extract Method]]\n[[Code Normalization]]\n[[Benefits Of Oo]]\n[[Software Metrics]]\n[[Maintain Ability]]\n[[Good Code]]\n[[Large Extreme Programming]]\n[[Refactoring And Rewriting]]\n[[Grady Booch]]\n[[Fundamental Flaws In Procedural Designs]]\n[[Dont Refine Exceptions]]\n[[Cpp Utx Overview]] (in regard to testing)",
            "id": "51b3da5b5902efc35cedee0a0b2ce6be"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nThe <i>basic idea</i> is that stuff that <i>works together,</i> should <i>be</i> together.",
            "id": "22588988c4d29e93bcc5df5af9b781ce"
          },
          {
            "type": "html",
            "text": " Put things that fit really well together right next to each other, in one module - seek strong cohesion.",
            "id": "5211a429b98a380c82d79ff6f0829d7d"
          },
          {
            "type": "html",
            "text": " Between modules, don't let them fiddle around with each other's private parts too much - seek low coupling.",
            "id": "d37f63a6b864f6a0f5e273e0bc464e07"
          },
          {
            "type": "html",
            "text": "\nIt's all about <i>how you cut up your program,</i> into pieces called <i>modules.</i>",
            "id": "313ba0161b7462c3934dd1323d6fa57a"
          },
          {
            "type": "html",
            "text": "\nTo think that you can win the game by putting everything into one module is just as silly as saying, \"What, Global Variables are bad? Okay! I'll just put everything into one gigantic structure then, and pass it around. Yay me!\" You have missed the point.",
            "id": "698a56d2c1676a75df81e6d068f802ab"
          },
          {
            "type": "html",
            "text": " Yep! And that \"yay me!\" solution is the one called \"Stamp Coupling\". It has enjoyed a resurgence in popularity in [[Functional Programming]], where it is represented as a Monad, as far as I can tell, but outside of [[Functional Programming]], it's not a good idea.",
            "id": "50fd3f2cab6c3758acceda855d6790c3"
          },
          {
            "type": "html",
            "text": "\nIn [[Object Oriented Programming]], the main vehicle of Coupling is Polymorphism, and the main vehicle of Cohesion is Encapsulation.",
            "id": "816cec1b4306e30d91524ddef04cb837"
          },
          {
            "type": "html",
            "text": " <i>Eh? I see <b>lots</b> of coupling in [[Object Oriented Programming]] implemented by direct instantiation of one class by another.  Often these are chained until virtually the entire system is coupled together.</i>",
            "id": "f61f2e07575cd8a16f98678df10ab77c"
          },
          {
            "type": "html",
            "text": " I concur. [[Abstract Constructor]] or [[Abstract Factory]] patterns could reduce this coupling, but are often painful to use ([[Language Smell]]). [[Gilad Bracha]]'s [[Newspeak Language]] has a restrictive module system to help with this problem.",
            "id": "a7931b3807c586f33318daf7e34b35c0"
          },
          {
            "type": "html",
            "text": "<i>Besides \"stuff that works together\" as a way to cut the pie might be \"stuff that changes together\" per the [[Single Responsibility Principle]]. Is that a useful way to find or measure cohesion? JLS</i>",
            "id": "146bf12bed374237623f523408d59bf8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nBecause so much of programming now is basically drawing pipes between modules, it seems to me that [[Stamp Coupling]] has become more common and accepted. (...since, if you do [[Stamp Coupling]], you don't have to draw in new pipes when you need something- it's just automatically available to you.)",
            "id": "b43908b74b336774a0832f9ecf0f5416"
          },
          {
            "type": "html",
            "text": " I don't see what pipes have to do with it. Pipes are Sequential Cohesion, and needn't have anything to do with Stamp Coupling. When the total environment is shoved into a data structure, it's common to pass around a pointer to it, but I've never seen it passed around as a gigantic chunk in a pipeline. And that would only work on the read-only part of the data, at that, since pipes pass copies.",
            "id": "4b650924001726ebc5c8602f3e34df21"
          },
          {
            "type": "html",
            "text": "\nIf you do only [[Data Coupling]], then every time you need to get a new wire from module A to module D, then you need to massage A->B, B->C, and C->D. But if you're stamping it, you need far less massaging. You just pull what you need from the wire, no need to change a bunch of code.",
            "id": "7141319c129251f9883a890523085028"
          },
          {
            "type": "html",
            "text": "\nPrograms written in the \"loose\" languages, like Python and what not, seem to promote this sort of [[Stamp Coupling]]. Then, as things become formalized, efficient, rigid, and secure, a piece of software moves towards [[Data Coupling]], and is implemented in stricter languages.",
            "id": "97a6c9b87a02e87564ce66d5b2460d2c"
          },
          {
            "type": "html",
            "text": " Perhaps you could give an example, since your train of thought isn't obvious yet.",
            "id": "fcf25a435cf0ef6cea95f7c237d8fe7c"
          },
          {
            "type": "html",
            "text": "\nOkay, so, I think the confusion rests in different understandings of the phrase \"Stamp Coupling.\"",
            "id": "35c6634edd749fee6395c0d6b9ef9d29"
          },
          {
            "type": "html",
            "text": "\nAs such, it's probably best continued on that page: [[Stamp Coupling]].",
            "id": "f88879d66bf57598067c63b99bf54f8b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nRe: \"The <i>basic idea</i> is that stuff that <i>works together,</i> should <i>be</i> together.\"",
            "id": "8d976fcbd59230da4eeac94445cac88c"
          },
          {
            "type": "html",
            "text": "\nThis is often impossible. Factors often interweave such that there is no one perfect grouping. The real world is multi-dimensional but textual code is limited to 1 or 2 dimensions (2D on small scale). The best we can do is find the best compromise, and which is the best compromise is often a source of [[Holy War]]s (for example, grouping by nouns versus grouping by verbs). See [[Group Related Information]].",
            "id": "05543625d07eca4dead29871c678de63"
          },
          {
            "type": "html",
            "text": "<i>True, but unhelpful. You're talking about problems that can arise even when some version of best practice is followed. [[Coupling And Cohesion]] primarily addresses problems that arise when best practice is <b>not</b> followed.</i>",
            "id": "19f9e339afaddb3d31628a970c0481f7"
          },
          {
            "type": "html",
            "text": "<i>It's better for an attempt to have been made to group code based on it working together, than not to do so, even in cases where there is no single perfect answer to grouping.</i>",
            "id": "eebf65d20050d31093a24dbd5888af28"
          },
          {
            "type": "html",
            "text": "\nExcept maybe for newbies, almost everyone uses some kind of grouping approach beyond random.",
            "id": "038ee0c3a769642b9428ede3965b1f05"
          },
          {
            "type": "html",
            "text": " Yes, but it's not a binary issue, because it's <b>not</b> the case that almost everyone follows <b>best</b> practice, even if they don't follow <b>worst</b> practice. For instance, [[Logical Cohesion]] is second-worst on the list, and is not at all uncommon.",
            "id": "5cd874ad237b1a1561fbc9f9a5315038"
          },
          {
            "type": "html",
            "text": "<i>Newer methodologies that attempt to address difficulties in grouping, such as [[Generic Programming]], [[Aspect Oriented Programming]], and perhaps [[Intentional Programming]], do not in any way contradict the principles of [[Coupling And Cohesion]], so far as I am aware.</i>",
            "id": "e28c83c1d9d58b76a9d4ed9a1d04af6a"
          },
          {
            "type": "html",
            "text": "<i>[[Holy War]]s over i.e. OO versus [[Generic Programming]], although the two methodologies can contradict each other, each individually are in alignment with [[Coupling And Cohesion]].</i>",
            "id": "aab92b68cc67fea20a99d78995eab4d9"
          },
          {
            "type": "html",
            "text": "[I agree with the person who said, \"This is often impossible.\" However, just because some \"theoretical purity\" is unknowable or unattainable, doesn't mean that the theory's a bunch of bunk. The purpose of this idea isn't to give you a perfect algorithm to show you the one right way to do something. The purpose of the idea is to help you recognize patterns, and help you think about things. Breaking a problem down into smaller interconnected pieces is pretty universal.]",
            "id": "9c07cb346387706d321ca056a89a66a7"
          },
          {
            "type": "html",
            "text": "\nBecause we have to as humans, not because it necessarily fits actual reality. Grouping stuff is an attempt to find the most [[Useful Lie]]. One often groups by their perceived probabilities of future changes, but it is often hard to agree on the most likely change patterns.",
            "id": "a0f7454ff0dd25774515a6f03985fcd0"
          },
          {
            "type": "html",
            "text": "<i>True, but it pays to keep trying to do better, and gradually over time computer science is learning more about what does and doesn't work well. [[Coupling And Cohesion]] is an example of something that was first invented a long time ago, back in the 1970s, but tends to be neglected, when it should be one of the tools in everyone's arsenal.</i>",
            "id": "870ab5a16f01ff7753b4e5edd86dc3f4"
          },
          {
            "type": "html",
            "text": "<i>[[Coupling And Cohesion]] has been implemented as actual objective automated metrics quite a few times, but such things tend to suffer from problems of insufficiently powerful automated software analysis state of the art in general. Still, I expect this state of the art to continue to improve, and perhaps eventually the whole topic will become significantly less subjective.</i>",
            "id": "060eb836982514cad738c44ccfefeeed"
          },
          {
            "type": "html",
            "text": " Where are these \"automated metrics\"? And we have to be careful to make sure the metrics translate into real benefits and that there are not counter-metrics that are being skipped. For example, small \"code size\" is good, but if it's the only metric we judge on, then really compressed code that might score high on compactness may be difficult to read in practice.",
            "id": "757a6663ae4053ac478aee61ea401fc7"
          },
          {
            "type": "html",
            "text": "<i>Until then, one does the best one can.</i>",
            "id": "12df200b062a51eeed377601e1f63cc8"
          },
          {
            "type": "html",
            "text": "\nI believe that [[Software Development Is Gambling]]. One evaluates the horses relative to each other and then picks the best guesses. There is not always one right answer for every circumstance. Saying \"X is always bad\" is always bad :-)",
            "id": "f77c33a2973c3edb045776f933c95579"
          },
          {
            "type": "html",
            "text": "<i>It's one thing to say that there isn't always one <b>concrete</b> correct answer, it's' another thing to claim that there isn't any objective means possible to measure the degree of correctness of answers in the <b>abstract</b>.</i>",
            "id": "b5ec0abeb70eefbb0f0293cf6fcf34c9"
          },
          {
            "type": "html",
            "text": "<i>The latter would mean that software is of necessity doomed to forever be an art, not a branch of engineering and science. Some would agree, but this seems a risky proposition in an age where we are beginning to understand even the rules of aesthetics (via evolutionary psychology and via tentative systems like Alexander's).</i>",
            "id": "072bc6ffb79280ba32bf7053300bf302"
          },
          {
            "type": "html",
            "text": " One does not know if they made the right choice until and when things do change. That is how we test our change-handling concepts in the end. However, this does not provide any formalism. Further, as I have learned after many heated debates with OO proponents, people perceive (likelihoods of) change differently from one another. Since we cannot produce the actual real world changes during the discussion to see whose design is the most change-friendly, we can only base our designs on how we *expect* the future will change, and this is where the differences in change pattern perceptions make the process very messy. However, a consolation prize would be to better document one's assumptions and describe why alternative change scenarios were ranked lower. But, most software engineers don't seem to have this intraspection skill yet. People don't really know how to properly question their own model of reality, but such is needed to document change-related assumptions properly. -t",
            "id": "2981c24681a532bd6fc18ba39764412b"
          },
          {
            "type": "html",
            "text": " I do know I made the right choice. I deny your right to claim the general case. I prove it every time the change does not force me to rewrite the system. So do others. The fact that what I do is not possible suggests that I am undercharging :)  -[[Anonymous Donor]]",
            "id": "f2d8fbc2d3b64efc5edd21d76cea3752"
          },
          {
            "type": "html",
            "text": " You predicted the nature of future domain changes? That may be a different issue. If we know the future, then our design choices are of course going to be a lot easier. I find the domain future difficult to predict, even after years of experience. New markets, new fads, new management personalities, new presentation technologies, etc. just require too powerful a crystal ball. -t",
            "id": "56e5634fd464ce816bb315ee6bd2b868"
          },
          {
            "type": "html",
            "text": "<i>It would also mean that these characteristics of software inherently cannot be correctly embedded in a mathematical metric space, even in principle, which seems exceedingly rash.</i>",
            "id": "03caf1b41a62a14788753c73cab43f6d"
          },
          {
            "type": "html",
            "text": "<i>Back to brass tacks: name a situation where [[Coupling And Cohesion]] gives an incorrect answer to whether something is good or bad. (The issue of objectively measuring such was already addressed above your comments, not by your comments, so that's a different issue.) -- [[Doug Merritt]]</i>",
            "id": "7334ce88faede0467ad96a05c7a1550e"
          },
          {
            "type": "html",
            "text": "\nExample? Indirection. Indirection reduces coupling, but can also complicate a given design. Having a complex design may make it harder to change because there is more code to read and more code to change. Also, how \"bad\" each form of coupling is, is subject to subjective rankings.",
            "id": "e3e9fc8ce1240f3489feb3d5d7961856"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nAnalysis by <i>reductio ad absurdum</i>.",
            "id": "9d3096fe11b4f3e902da824683506ae1"
          },
          {
            "type": "html",
            "text": "\nCoupling",
            "id": "38fd6deba06b37f0926036d0f8a5b56b"
          },
          {
            "type": "html",
            "text": "\nIt is my understanding that coupling can only be reduced,\nnot eliminated. A program with zero coupling could have\nat most one machine instruction (not source statement).\nAny more than that and there would be dependencies between\nthe action of one instruction and the action of the next.",
            "id": "21c1d712cde8d7f79c02fbcf5c6b04a2"
          },
          {
            "type": "html",
            "text": " Not necessarily. The system isn't inherently mapped to a metric space, but if it were, there are workable definitions of a zero in non-trivial programs.",
            "id": "d235308eda9b2ab5e324f41669bf702d"
          },
          {
            "type": "html",
            "text": "\nSo, by inference, coupling is indicated by the degree of dependency between the various components of a system. Of course, by their very nature, modules depend on one another to perform their respective functions properly, but we are concerned with how much one module depends on the <i>implementation</i> of another module. The ideal is not at all, and we can come very close, but never arrive.",
            "id": "7bab800ec52f6e57bc73b8125f78bd88"
          },
          {
            "type": "html",
            "text": "\nCohesion",
            "id": "282ac97f3ae0aa1292088ef5513d4afa"
          },
          {
            "type": "html",
            "text": "\nBy the same argument used above to show that coupling cannot be eliminated, a certain level of cohesion is also inherent in the sequential nature of electronic computer instructions. (All bets are off on quantum computing.) The goal is to maximize it.",
            "id": "779ce3ae07c3baef17674aa26b4198d0"
          },
          {
            "type": "html",
            "text": " Not necessarily, as above.",
            "id": "c849d128b784a19a0e367ab3d6308fda"
          },
          {
            "type": "html",
            "text": "\nI won't bother pontificating on this because an item above covered it very well:",
            "id": "257fbc92a1edc56a0031fc2bde1c951d"
          },
          {
            "type": "html",
            "text": "<i>Coupling is connection crossing a boundary.</i>",
            "id": "ba082b94700f17a6ee84c273a62cf48e"
          },
          {
            "type": "html",
            "text": "<i>Cohesion is connection which doesn't cross a boundary.</i>",
            "id": "73e57c63a5d1f7e8492b10806892e69f"
          },
          {
            "type": "html",
            "text": " That only applies in G. Spencer-Brown's first order system. And he didn't explain his higher order system. And his followers who did take stabs at it came up with systems where the above doesn't really apply, just as binary logic of one bit leads to limitations that are not true of systems with a large number of binary bits.",
            "id": "0d068258926bf82932151a2a8f3652d5"
          },
          {
            "type": "html",
            "text": "\nThe only addition I would make is to emphasize that the connection need not be explicit, it can be implicit. It could be knowledge as innocent as knowing that certain values passed are 'bit flags'.",
            "id": "5886d0d10387a30fe3b0ba91c0817b1c"
          },
          {
            "type": "html",
            "text": "\nWell I'm out of time. So long.",
            "id": "ba2d788239ec010ad3dcbf6b57f19f40"
          },
          {
            "type": "html",
            "text": "-- [[Bob Bockholt]]",
            "id": "158837a3a7826fc34f3d579846b9265c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nSome examples would be nice. English is insufficient it seems. For example, \"contributing toward the same goal\" can get into some sticky philosophical discussions. It just seems another case where people end up modeling their own internal view of the world and thus nobody agrees. [[Fuzz Flag]]?",
            "id": "a8e5a7e41f1e1fe1a10fc3520a745977"
          },
          {
            "type": "html",
            "text": "<i>This stuff was invented in 1974, but it's been partially forgotten, and seems to be taught at only, I dunno, 20% of colleges and universities these days, even though it is not obsolete; it's still quite important.</i>",
            "id": "9412a7c0966f5aa675f3e2eb41ec4c4f"
          },
          {
            "type": "html",
            "text": "<i>I took the trouble to add definitions for every single level of coupling and cohesion recently, which had never been on this page before, and I did this by doing a bunch of web searching and trying to pick out the pages that seemed to have more coherent definitions. Then I dug up the actual origin of the terms, since that was misquoted here.</i>",
            "id": "e808fda2f737b85a260b6f690470bd4d"
          },
          {
            "type": "html",
            "text": "<i>I understand why you would say that the result is <b>still</b> insufficient, but you know what, I'm kind of tired...how about if now <b>you</b> do some similar searching and find some nice examples and add them to this page? Google is your friend, too, not just mine. :-)</i>",
            "id": "dfec5d65e7077db8e266dbbcb35255c3"
          },
          {
            "type": "html",
            "text": "\nI did not mean to have you carry the entire load.",
            "id": "48364d3cac52f02006dd8a73ebe84f13"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nI think there are (at least) two things to look at when investigating \"links\" between things:",
            "id": "3dee1ed4e60a12ce69824fc9f0e5df2a"
          },
          {
            "type": "html",
            "text": " Does a link reflect an actual domain link (real-life association), or is it a software artifact? If the second, then it should perhaps be a higher alert level. It makes sense that if we are modeling two things that are linked as a domain requirement, then our software/database is also going to contain a link of some kind to reflect that.",
            "id": "4d920544b616ed3c215391e5606d6c9d"
          },
          {
            "type": "html",
            "text": " Related is that the strength level of the domain link should also be reflected in the software/database. If the link is tenuous, then it should be easier to remove from the software also. Of course this may take some estimating skills to apply appropriately.",
            "id": "d49e112345c1826f017e6493f10ea288"
          },
          {
            "type": "html",
            "text": " How expensive is it to add or remove links? What kind of [[Discontinuity Spike]] do such create? For example, I often fuss about the expense of converting is-a relationships to has-a relationships.",
            "id": "8b2eeecdf2751a68fe3fb63fca661e53"
          },
          {
            "type": "html",
            "text": "-- top",
            "id": "4921c41b69ea2112e8368dfcbd5b0242"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nHow [[Responsibility Driven Design]] could help with [[Cohesion And Coupling]] ?",
            "id": "0e9362af10bd740feb662430b2604316"
          },
          {
            "type": "html",
            "text": "\n[[Use Cases]] protect and give answers to the concerns and interests of all stakeholders of a given system.",
            "id": "fb86ab9f7d410313f556b9db2211ef12"
          },
          {
            "type": "html",
            "text": "\nAll stakeholders of a given system are represented through the Actors in the interactions with a such system.",
            "id": "8329a37dc9873c4a2fd3d3fc672c8f60"
          },
          {
            "type": "html",
            "text": "\nFor every goal that a given Actor has with a given system, this system must answer every such goal through its responsibilities.",
            "id": "8965503daf9e1ee14d06d3d21ea168b3"
          },
          {
            "type": "html",
            "text": "\nThis system should become a catalyst for such business, because its purpose is to open new roads to facilitate this business. This catalyst metaphor fits perfectly with [[The Simplest Thing That Could Possibly Work]].",
            "id": "5652482329a94538204b34cfeca533c8"
          },
          {
            "type": "html",
            "text": "\nTo design such a system, we must understand the business this system must service, with this catalyst idea in mind.",
            "id": "3ec45f90aa2bb056aeef220cc560c20f"
          },
          {
            "type": "html",
            "text": "\nTo start with, we look at the business terms or entities that are involved in the business. We are looking into the problem domain of the business. In this domain, all business entities involved are classes.",
            "id": "b593e036fbbe669b4eead32817058070"
          },
          {
            "type": "html",
            "text": "\nOnly a group of all of the problem domain classes will show up in our system. That will depend on the scope of our system.",
            "id": "c006d0dd1ab086f87370ff598d8c6ebc"
          },
          {
            "type": "html",
            "text": "\nBesides, for the group of problem domain classes that will show up in our system, some of the business entities will turn into system classes, while others will become just properties of these classes. Whether a problem domain class becomes a system class or a property of another system class will also depend on the scope of our system.",
            "id": "4a253a7ce01c5a6ca0a39e68c941c42e"
          },
          {
            "type": "html",
            "text": "\nFor instance, let's take a look at the [[Zip Code]] business entity (problem domain class). If we are designing a typical [[Sales Order Processing]] system, in most cases the [[Zip Code]] will become a property of some system class(es).",
            "id": "b2c8ec8e5cb7b5cd51c07233958fbc4a"
          },
          {
            "type": "html",
            "text": "\nBut what if we are designing a system for [[Fed Ex]] or UPS?. In such a case, the problem domain [[Zip Code]] class might become a system class.",
            "id": "2df31e5a22fff70a2f348423abef2e8d"
          },
          {
            "type": "html",
            "text": "(YAGNI and NIAGNI help us define partial, temporal projections into the scope of a given system. We may start with a very narrow scope in the first iteration, like a [[Walking Skeleton]] of a system, and gradually evolve into a wider scope, all the way down to the final scope of such a system).",
            "id": "be09a6e0bcbce44f0667079dd315720e"
          },
          {
            "type": "html",
            "text": "\nSo, for every problem domain class we must fully understand what it has to know and what it has to do in order for it to answer to all its responsibilities (the word responsibility comes from Latin and it means \"to give answer to\").",
            "id": "b2d58860a75312f2585f7dfa87728550"
          },
          {
            "type": "html",
            "text": "\nHow do we do that? Simply by asking for the [[Business Rules]] involved in the problem domain.",
            "id": "a43553575e854005479e05c50040bc19"
          },
          {
            "type": "html",
            "text": "\nThis is the real initial point in our problem domain exploration: [[Business Rules]] will help us identify all business entities (problem domain classes), and also everything that a given class must know and must do.",
            "id": "2f74c832550659909dadbaab982e9f67"
          },
          {
            "type": "html",
            "text": "\n[[Business Rules]] are atomic and elementary always, if we state them in the proper way.",
            "id": "e44eadbeefee2f12b8a64727a6242ca7"
          },
          {
            "type": "html",
            "text": "\n[[Business Rules]] will also tell us how classes interact (collaborate) among themselves.",
            "id": "7b37970e38c23fe9f63290ec7917bcce"
          },
          {
            "type": "html",
            "text": "\nThrough these collaborations among classes to fulfill business goals ([[Use Case]] goals), we could discover how to aggregate knowledge and behavior of every problem domain class to identify its responsibilities.",
            "id": "a71be814aceb9a104f4d6d8bf0f95daa"
          },
          {
            "type": "html",
            "text": "\nIn such a manner, we can get highly cohesive problem domain classes. Cohesion is the middle ground between atomic [[Business Rules]] and lumpier [[Use Case]] goals.",
            "id": "8c69ccb6259b473f713d6d8c58e27e5e"
          },
          {
            "type": "html",
            "text": "\nIf we build a cross-collaboration matrix among all problem domain classes, we will find lumps or clusters of classes with stronger collaboration ties.",
            "id": "82232fa1e17917dfb1d2d8d66a3accc6"
          },
          {
            "type": "html",
            "text": "\nThese clusters tell us what classes belong to a given logical (problem domain) package or component.",
            "id": "80369af2b90df05ba9cf952341dca894"
          },
          {
            "type": "html",
            "text": "\nIf we apply this very same grouping to our software components, we could have loosely coupled components.",
            "id": "f0e3f3636c09e1ba7b54f5c081d27ae6"
          },
          {
            "type": "html",
            "text": "\nProblem Domain Analysis helps us determine the classes involved in it, as well as the public interface of theses classes.",
            "id": "03172c92d17e020472ae002a9cbb82bc"
          },
          {
            "type": "html",
            "text": "\nSince we are dealing with the what of a business and not the how of that business, this analysis helps us design for the public interface of classes, an not for any particular implementation (\"Responsibilities = Public Interface\").",
            "id": "a25525647993d00bc2c33f5810230cc1"
          },
          {
            "type": "html",
            "text": "\nThis is consistent with the first principle of object-oriented design stated in the [[Design Patterns Book]] (page 18):",
            "id": "2677432a1f8d93b11ed3aede6503c236"
          },
          {
            "type": "html",
            "text": "\"Program to an interface, not an implementation\".",
            "id": "6d01ff545ed54e815f02146691f123e8"
          },
          {
            "type": "html",
            "text": "-- [[Gaston Nusimovich]]",
            "id": "3606ddf1499361100219e37f21e9549c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "<b>\"Fuzzy Metric\" Complaint</b>",
            "id": "de6fda4bea3077bc43354ed506eadea4"
          },
          {
            "type": "html",
            "text": "\nIn a usenet debate, [[Robert Martin]] suggested that separate case-statement lists are \"coupled\" because they are allegedly likely to change together.",
            "id": "e5cfbcdc7198c842688c9e9b98467458"
          },
          {
            "type": "code",
            "text": "   functionA(...) {\n     ...\n     select on x\n     case 'aa': {asd()}\n     case 'bb': {jgusss(...)}\n     case 'cc': {j7()}\n     otherwise...\n   }\n   functionB(...) {\n     ...\n     select on x\n     case 'aa': {balasdf()}\n     case 'bb': {nib()}\n     case 'cc': {zork(...)}\n     otherwise...\n   }",
            "id": "7315c06afbdb13e93c0c3b88a0003b16"
          },
          {
            "type": "html",
            "text": "Robert implies there is some kind of what comes across as existential coupling between these two lists because they may be affected by some changes, such as adding a new item to each list. It is not a \"hard\" coupling, because there are no existing references between the two lists (other than \"x\", which does not change in the scenarios usually used).",
            "id": "a1ceae82e0ebecdc0b97849b41acdc5d"
          },
          {
            "type": "html",
            "text": "\nBut the case lists might also drift apart. We may add a \"dd\" to one, but don't want it for the other, for example. There is no guarantee they will change in lock-step. Even if you feel they are likely to change together, the \"coupling\" still depends on probability. There are change probabilities that require polymorphic classes to change in lock-step also, the classic being adding a new method to every shape sub-class. (See [[Switch Statements Smell]] for discussion on change impact and case statements.)",
            "id": "b567366e7e6ea571db477ef2289801f0"
          },
          {
            "type": "html",
            "text": "\nThus, \"coupling\" is drifting from what may have been a clear-cut metric to something that depends on probability estimates and personal judgment. It is not the \"magic metric\" that some paint it as.",
            "id": "cce049476714bf90abdbb91f86c2a67e"
          },
          {
            "type": "html",
            "text": "\nAn example of objective coupling is a method in a class:",
            "id": "ceae762730c1418b7c908389982085fb"
          },
          {
            "type": "code",
            "text": "  class foo {\n    method bar{....}  // location A\n    ...\n  }\n  .....\n  x = new foo(...);\n  x.bar(...)  // location B",
            "id": "94a344465cb7f8099cbbcb2c26cba355"
          },
          {
            "type": "html",
            "text": "\nHere, the method call in location B is \"coupled\" to location A because if we remove method \"bar\" at location A, then the method call at location B is no longer valid. (Changing parameter signatures can be a similar issue.) This kind of thing is where such a metric is useful. However, the link between two CASE lists that may or may not change in lock-stop is subjective, or at least dependent on [[Perception Of Change]] and [[Software Development Is Gambling]].",
            "id": "4f56e797d9afe19d06e1ae5dc0e5b047"
          },
          {
            "type": "html",
            "text": "\nThe \"bar\" example does not assume any external knowledge or experience. One can look at the code and only the code. In fact, an algorithm could probably be written to draw lines between coupled portions of code. The two CASE list issue could not be done this way unless we make up-front assumptions about the likelyhood of change, but people (like me) can question such assumption, wanting more evidence beyond someone else's anecdotes.",
            "id": "ab26d792e8d48fe5d63679c0670eb974"
          },
          {
            "type": "html",
            "text": "-- top",
            "id": "4921c41b69ea2112e8368dfcbd5b0242"
          },
          {
            "type": "html",
            "text": "\nThat's true, but there is no truly magic metric, and IMHO, [[Coupling And Cohesion]] does better in that department that most suggested measures.",
            "id": "3d4fe38dadcafbfc1461ae5e9ad5f963"
          },
          {
            "type": "html",
            "text": " How can it when it is not measuring any \"hard links\"? It is purely a human perception thing, and we know where relying on that leads as far as reaching agreement or defining good design rules. And the few clearer ones risk [[Soviet Shoe Factory Principle]].",
            "id": "5a6aa4c884c3b32d50a7da5f54a3dcbd"
          },
          {
            "type": "html",
            "text": "\nSimilarly with the rest of your comments: perhaps true in the absolute, but replacing switch statements with class-based method dispatch <b>typically</b> produces real, tangible benefits.",
            "id": "9454da7716b113877eab38ccca919513"
          },
          {
            "type": "html",
            "text": "\nThe most common exception is probably your fond example of tables where neither rows nor columns have natural precedence over each other, so that neither is appropriate as the relative root. In pure OO realms people work around this with [[Double Dispatch]], which is often good enough if not perfect, and in impure realms, multi-methods/generic functions which choose a method based on multiple parameter types/classes simultaneously solves this very nicely.",
            "id": "8162d2a40fe507d46a81af8697a655ba"
          },
          {
            "type": "html",
            "text": "\nOn the other hand, I won't dispute that it can also be solved nicely without OO and without multimethods, using good old-fashioned data-driven programming, which pre-dates OO but has philosophical similarities with it. In this case, one might have e.g. a 2-D table indexed by appropriate manifest constants, retrieving the appropriate function pointer to use. This amounts to implementing multi-methods by hand.",
            "id": "0f2b3dc258dc5fd672639a956eb1f019"
          },
          {
            "type": "html",
            "text": " I am not sure what you mean \"by hand\". A good table-oriented language makes it a snap, perhaps easier than code-based approaches because you can key it into a nice grid ([[Table Browser]]) rather than fiddle with hard-to-read syntax. Perhaps in C it is a pain, but [[Cee Is Not The Pinnacle Of Procedural]].",
            "id": "318a5ffe9f10da620ce6bc27761f2010"
          },
          {
            "type": "html",
            "text": " [It's \"by hand\" because a table ([[Vee Table]] for example) of function pointers is what OO-supporting languages use to implement dispatch (efficiently); when you build your own table of function pointers for the purposes of single or [[Multiple Dispatch]], you are reimplementing a feature of other OO languages by hand in your own code. Implementing the table \"by hand\" is intrinsically going to be more work than not implementing the table at all, which is an option if your language of choice already implements multimethods (or simply <i>methods</i>, if you don't need [[Multiple Dispatch]]). It may be fairly <i>straightforward</i> work, especially if you're familiar with working in tables, but it's clearly not less work than not implementing a dispatch table at all. -[[David Mc Lean]]]",
            "id": "c8fa90a4746f3bc89662b2586621c3f0"
          },
          {
            "type": "html",
            "text": " Perhaps for simple stuff, but not if you wanted to do query-like dispatch, such as run all processes for cities that have a population between 1 mil and 3 mil with an average humidity below 40%. And tables are easier to read or can be re-projected to be easier to read than OOP code attributes all jammed up in unnatural ways.",
            "id": "90a6f1225a824eba6b17e1049ac0f61f"
          },
          {
            "type": "html",
            "text": " [Querying in order to \"run all processes for cities that have a population between 1 mil and 3 mil with an average humidity below 40%\" is not an example of dispatch. Dispatch is fundamentally a system whereby the caller of some area of code does not determine the specific behaviour invoked, but one or more callees (arguments). Querying for a particular dataset and then running \"all processes\" on it implies either that the \"all processes\" will be exactly the same for every row of the dataset, or that the \"all processes\" are polymorphic in some way---but in that case the dispatch occurs in the \"all processes\", not in the query to collect data for them. As for tables being easier to read than \"OOP code attributes\", the relevant properties of code when it comes to dispatch are the signatures of methods, which in most languages are quite easy to read excepting pathological cases (methods with tens of arguments). A single [[Double Dispatch]] method in a multimethod-supporting language gives you just a list of method signatures, listing off the objects the method'll work on; a single triple-dispatch method in a multimethod-supporting language takes exactly the same form. Each [[Double Dispatch]] method implemented by hand with relational tools must have its own table, with rows corresponding to the first argument and columns to the second (or vice versa); a triple-dispatch method implemented in relational requires three dimensions, which tables do not afford. (In addition, the multimethod version does not require you to create a bunch of extra named functions. With a relational table, you need to store a name or some other identifier in the table for each possible method implementation.) The point is, a (non-pathological) implementation of multimethods as part of language core will be able to solve dispatch-class problems with much less work from the programmer than <i>any</i> implementation of the same functionality by the programmer, whether it's in relational tables or some other form. -[[David Mc Lean]]]",
            "id": "2ba7a09e5b7024f785c05a200a9d48dc"
          },
          {
            "type": "html",
            "text": " I mean a table something like this [[Control Table]]:",
            "id": "66e794b9d2a66d4c8b83d21f9535ffbb"
          },
          {
            "type": "code",
            "text": "       city.....pop_m..avg_humid...function or expr.\n       ---------------------------------------------\n       ST. LUIS...4.2.......50.....foo()\n       SALK LAKE..3.1.......42.....bar()\n       MAUI.......2.6.......65.....zaz() + foo()\n       //Etc. (Simplified for illustration purposes. Joins may be used in practice to get average, etc.)",
            "id": "54e178d7160611e944de1601c4e4ec3b"
          },
          {
            "type": "html",
            "text": " That same info, including attribute values, as OOP sub-classes is harder to read in my opinion. And generally requires programmers to change instead of merely power users. But maybe we are wondering off topic.",
            "id": "9a4fc442064fe0eb4cb9f8b22e72c294"
          },
          {
            "type": "html",
            "text": " [Disregarding for a moment that calculating any information about a specific city by calling some global function foo() isn't particularly logical, what properties would you calculate in that way, and can not the expressions for deriving such properties be derived from the existing established properties of the cities themselves? Defining a varying expression for calculating \"something\" on a per-row basis genuinely is best done by providing the expression in the row directly, but is defining an expression on a per-row basis really the best way to calculate that something in the first place? (Using code that will be directly evaluated in the row, as opposed to some \"safe\" representation like a domain-specific language that will be evaluated in a sandbox, naturally raises concerns of security in the application, but that's neither here nor there.) -[[David Mc Lean]]]",
            "id": "7f5101fd42b8edb895e4935bdab31cc7"
          },
          {
            "type": "html",
            "text": " Not sure what you mean by not being logical. Similar factoring questions often arise from long, repetitious CASE lists also, but it's often heavily dependent on the domain. As far as \"security\", that would be an issue with just about any dynamic tool, and is to be evaluated on a situational basis. But that's the main point: <b>domain issues and domain changes shape the tradeoffs</b> such that saying \"always use code pattern X\" is silly.",
            "id": "0d63d5419a1e0607a4ca0c4470e1afe1"
          },
          {
            "type": "html",
            "text": " [I claim it's not logical to calculate a property of a <i>specific</i> city (say, the tax rate in Townsville) by calling a <i>global</i> function like foo(), since that global function has no way of knowing what it's supposed to be doing in this specific situation. Security is not necessarily an issue with all dynamic tools, since even when using a dynamic tool one is not required to evaluate arbitrary language expressions received as input; as noted, one could devise a safe [[Domain Specific Language]] (one with no side-effects for example) and use [[Interpreter Pattern]] to evaluate its expressions with no security risk, or alternatively use some form of sandboxing in conjunction with a \"normal\" language. As for the major claim, if the problem necessitates that arbitrary expressions be evaluated at runtime then naturally evaluating arbitrary expressions at runtime is the only real solution. Why would it, though? If the objective is to allow power-users to modify functionality, asking them to write actual expressions in your programming language is asking them to be programmers; what other use case involves modification of functionality that couldn't be done just as easily in the code? -[[David Mc Lean]]]",
            "id": "12908a8212c5d849219c02b0e781e6c0"
          },
          {
            "type": "html",
            "text": " Typically the function(s) would have access to its row's attributes. Perhaps I should have shown \"foo(thisRow)\" or something. (I sometimes make the current row array a global or outer variable to the called functions' scope to simplify the expression syntax.) And power-users are often comfortable with spreadsheet-like formulas, but may not be programmer material. It's not unrealistic to have a tool that's half spreadsheet and half application. Some spreadsheets outgrow Excel and need SOME database-like parts. These are usually internal department-only apps with a small set of users and power-users.",
            "id": "9b6b269f749cae90e4690fd389e9f00e"
          },
          {
            "type": "html",
            "text": " [I'd argue that if you plan to treat the fields like Excel formul rather than like full arbitrary language expressions, you should be interpreting the content of those fields using [[Interpreter Pattern]] on a formula-specific DSL, rather than technically accepting any arbitrary language expression. Nonetheless, you make a reasonable point regarding spreadsheets as a whole. -[[David Mc Lean]]]",
            "id": "7dfd8789638fb117edb43031174480b9"
          },
          {
            "type": "html",
            "text": " When you add libraries to the application, you create a dependency between the library and the code-base that may complicate future maintenance. For example, when the language is upgraded, something in the interpreter library or add-on might break. And it creates another library for the maintenance programmer to learn. Using built-in EVAL-like functionality generally avoids this problem, being the most KISS. For many environments, what you describe is [[Safety Gold Plating]].",
            "id": "079b4eb80fa7de16b608fd2b41e74b43"
          },
          {
            "type": "html",
            "text": " [Sorry, when did I suggest adding libraries to the application? I don't recall arguing that additional external libraries should be added, although I hardly think avoiding external dependencies simply because they are external dependencies is wise. -[[David Mc Lean]]]",
            "id": "b099185984ab5626ca18c84550cb0bfb"
          },
          {
            "type": "html",
            "text": " [[Interpreter Pattern]]. A decent interpreter would be library-sized, and be reinventing what Eval() does out of the box. Anyhow, it's a shop's tradeoff design decision. [[Let The Reader Decide]].",
            "id": "0f61be3ea325262f2d1dad2b547b3597"
          },
          {
            "type": "html",
            "text": " [A decent interpreter for a specialised DSL intended to allow entry of particular mathematical formul and nothing else will not be library-sized. Nor will it be a reinvention of what eval() does, especially if the application language used does not feature the same expression syntax as is desired for formul (for instance, if it's Lisp). Implementing a complete sophisticated sublanguage would approach library size, but we don't <i>want</i> a complete sophisticated sublanguage. -[[David Mc Lean]]]",
            "id": "3dc73dba9829d43a62a9900ac0b0339e"
          },
          {
            "type": "html",
            "text": " <i>A simple recursive-descent parser for canonical formul is tiny, often consisting of a single class and one method per terminal or non-terminal in the grammar.</i>",
            "id": "eaec005064d3139d581543e951eeed25"
          },
          {
            "type": "html",
            "text": "\nEven the latter is typically superior to just using switch statements, though. An example that I've frequently run across in my own work is in interpreters and compilers full of switch statements on the types of objects being manipulated. Some of them do a type-specific print of a value, some do type-specific code generation, etc, and <b>in practice</b>, not theory, these switch statements suck and suffer bit rot and get out of sync with changes, etc, and replacing them with any of the above approaches - including table-oriented methods - has always resulted in sharply better, more maintainable, more readable code.",
            "id": "2dacd53bf5836de495b787f115a41852"
          },
          {
            "type": "html",
            "text": " I agree that systems software may be able to make better use of \"subtypes\". (See [[Oop Biz Domain Gap]]). In your compiler example, \"types\" are hard-wired into the language definition, and thus are relatively immutable. (It may be a case of modeling types with types, which is kind of a self-fullfilling prophecy.) However, I have yet to find too many immutable counter-parts in the biz domain, where hierarchical taxonomies or mutually-exclusive lists are simply a poor model of real change patterns. Show me actual specimens of biz case lists that go awry and I may change my mind. Also in practice I rarely find something that fits a double-dispatch version. A clean one-to-one matrix of factors-to-behavior is too regular to fit the messy biz world. The only practical examples seem to be things such as modem drivers (yet more [[Systems Software]]). -- top",
            "id": "ec1a682f78be98f626890e00c66c454e"
          },
          {
            "type": "html",
            "text": "\nI don't agree with everything [[Robert Martin]] says, but in this case, I believe he is right on target. Most of the time, switch statements have worse [[Coupling And Cohesion]] than OO/generic/data-driven approaches, and one aspect of this is not fuzzy: the switch statements are scattered all over the code, whereas the other approaches centralize things in such a way that lack of synchronized changes becomes less likely, and in fact the language can to some extent actually assist. -- [[Doug Merritt]]",
            "id": "a3660ff0535c40b59e800699e508317d"
          },
          {
            "type": "html",
            "text": "<i>The issue at hand is whether similar case statements are \"coupling\", not whether they are \"good\". The goodness issue is taken up in [[Switch Statements Smell]]. Note that Polymorphism scatters the \"method list\" all over the place in a similar fashion. It is not a free lunch. It generally seems to boil down to a probability estimate, and OO fans see different change probability distributions than I do ([[Perception Of Change]]). It may be a domain-specific thing, or a personality thing. I have asked for an example of a biz domain case list that changes in lock-stop as claimed and have yet to receive one (other than something that should be a table instead). Thus, I have good reason to remain skeptical. I also find IF statements easier to adjust the [[Granularity Of Variation]] on than polymorphism. For example, it's not uncommon in the biz domain for the change request to ask for both features instead of an either/or choice. It's usually less re-coding to change a CASE block into an IF block than it is to de-mutually-exclusivize polymorphism.</i>",
            "id": "747c302acb92734f68f4551f7eacb127"
          },
          {
            "type": "html",
            "text": " {[[Payroll Example Two]] benefits from polymorphism.  It would be quite dire with CASE blocks or IF statements.}",
            "id": "e4c55bdd464f6ff56a38df2c4b9a72d6"
          },
          {
            "type": "html",
            "text": " <i>[[It Depends]] on what the future change patterns actually are. See [[Payroll Example Two Discussion]] for my comments on it.</i>",
            "id": "f2ed09c92fc6cde6d49ac856e5cafcae"
          },
          {
            "type": "html",
            "text": " {Yes, I recall those.  The polymorphic version was clearly superior to the CASE-based equivalent in every respect.}",
            "id": "a32a7447ca9cb0f361f8f03cd37ba741"
          },
          {
            "type": "html",
            "text": " <i>Clear? Really? It didn't show objective metrics, only unverifiable claims that may not necessarily apply to all domains. One participant on the other \"side\" stated, \"I suppose the only way to fairly and objectively resolve this debate would be to experimentally test a series of maintenance actions against the OO version and an equivalent CASE-based procedural version, and measure error rates, implementation time, and developer perception.\"</i>",
            "id": "a9abc5ea4d04e7787e92395db5d53ebe"
          },
          {
            "type": "html",
            "text": " <i>\"Clear\" to me would be </i>counting<i> errors made, number of key-strokes needed, number of eye-movements needed, minutes needed to make a given change, etc. However, in practice we won't get such info. But, we can use proxies for such, such as a hypothetical \"mind dump\" of the steps a typical maintainer will take to find and fix stuff along the lines of \"He/she sees that the URL has \"foo.prog\" in it so looks for the file called \"foo.prog\" in the code folder, then opens the file in the editor and looks for the string \"glob date\" because the form called the field \"glob date\"...\".</i>",
            "id": "49b1a2040583a58ace7602c5e64a124e"
          },
          {
            "type": "html",
            "text": "\nDoug, would you agree that a switch statement in a class may be acceptable if all other dispatch systems were ruled out for some reason provided they did not exit that class?",
            "id": "708218b1a6ef6a59fe3f31fd89dc5c3e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nSticky problems in [[Coupling And Cohesion]]:  [[Coupling And Cohesion]], much like layers of abstraction, tends to be excellent for making the programming easier... and awful for optimizations.  Many of the most powerful optimizations are those that cross boundaries that very clearly constitute 'unnecessary coupling' and might even be called 'utterly evil coupling'.  Furthermore, many of these optimizations cannot be performed by modern optimizers (or even next-generation optimizers...).  And these include real, algorithmic optimizations... not just coefficient cost reduction (though you get that, too).",
            "id": "8696eedd668af658182fd831c3e65847"
          },
          {
            "type": "html",
            "text": "\nI suggest that future research should consider the possibility of aspected-oriented coupling for optimization purposes.  Until we have something that can cross boundaries for us, we'll be doing it by hand, [[Best Practice]]s be damned.",
            "id": "60052f134aaeb98785326f8da9a7b1b0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "\nExample of subjectivity in metrics:",
            "id": "2eb8252cfe930f174b3ae26ce2c32d77"
          },
          {
            "type": "code",
            "text": " routineA(...) {\n    x = routineB(a, b);\n }",
            "id": "68b5158a7e0bdba60fb3bcadcd8370c1"
          },
          {
            "type": "code",
            "text": " routineB(x, y) {\n    [...]\n }",
            "id": "e7ea9a684440bcd512f6c60da03e4126"
          },
          {
            "type": "html",
            "text": "\nIs routineA coupled to routineB and visa versa?",
            "id": "96666758510a987b13e7f659b8482a2c"
          },
          {
            "type": "html",
            "text": "\nNote that if we change routineB to this:",
            "id": "bb0c40a0f5db47730ab419d0c77c69f1"
          },
          {
            "type": "code",
            "text": " routineB(x, y, z) {  // add a new parameter\n    [...]\n }",
            "id": "3c67374e5befeabe7df9ebb7921adabf"
          },
          {
            "type": "html",
            "text": "\nin many languages this would \"break A\" because A calls B with insufficient parameters now. In languages where different parameter counts are allowed such that \"z\" would return blank or Null, the affects are harder to determine. We'd have to dig around in the algorithm details.",
            "id": "9c8c26d16e2a8abaca7e859649014e4a"
          },
          {
            "type": "html",
            "text": "\nWhat counts and what doesn't as \"coupling\", and if all instances are weighed equally is usually a subjective thing. Some situations are even non-deterministic, or at least very expensive to discern because all possible calculation paths can fan out approaching infinity.",
            "id": "a94abeaf580c1eea1c29bbcf865cf885"
          },
          {
            "type": "html",
            "text": "\nIt is possible to make it clean by ignoring certain relationships, but this gets back to objective metrics versus useful objective metrics ([[Soviet Shoe Factory Principle]]).  If we don't count stuff just because some of the metric calculations are too expensive, we may make a nearly useless metric, or at least diminish its practical utility.",
            "id": "ac855d9f858e45cf30b328cd21838e4a"
          },
          {
            "type": "html",
            "text": "--top",
            "id": "13217630cdfbc5ae5992aa878fdb8672"
          },
          {
            "type": "html",
            "text": "\nYou could also break routineA by deleting routineB, or by making routineB return semantic garbage, or by making routineB return some type-unsafe value for routineA, et cetera.  You'll just confuse yourself if you get hung up on petty details like whether the new 'z' parameter can possess a default.  It is quite clear that there is a very 'hard' (measurable, provable, graphable) dependency from routineA to routineB, but it is not at all clear what your claim of 'subjectivity' happens to be in this example (are you making this another vector for your [[Objectivity Is An Illusion]] mantra?).  As to the 'vice versa'?  Dependencies aren't necessarily bi-directional.  And coupling is about <i>mutual</i> interdependence - i.e. you need to demonstrate the 'vice versa' before you can show there is any coupling at all.  Doing so would be impossible with the little information you've provided above.",
            "id": "e6143f3cb50a5e0c5d17ae7658625d82"
          },
          {
            "type": "html",
            "text": "\nFocusing on the motivation for your spiel:",
            "id": "d2d4c301afce62bcdbb59993e3fae594"
          },
          {
            "type": "html",
            "text": "\nThere may be some sort of 'soft' coupling if routineB is being continuously modified to meet the needs of routineA, in much the same way that helper-routines are coupled to the procedures that need the help.  This coupling wouldn't necessarily show up in a dependency graph of function calls; rather, it would show up in the commit history for the project.  This is something you might call 'existential' coupling.  It would be unreasonable to claim it doesn't exist (people can obviously point at examples of it, therefore it must exist).  But one might question its ultimate relevance.  Hard coupling causes hard problems like [[Dll Hell]].  This 'soft' or existential coupling does not.  Thus, whether 'high existential coupling' is even a problem should be evaluated independently.  I do not believe it would be a problem.  Heck, you might as well claim that all domain-based classes and routines in a project are 'existentially coupled' in the form of [[Robert Martin]]'s example - after all, they are all part of the same project, thus if the requirements of the project change they tend to change also.  But it doesn't cause problems (or provide benefits), and therefore it isn't relevant.  And, completely independent of whether they are easy or difficult to measure, irrelevant things simply don't need to be measured.",
            "id": "3f81d2a6a4360845c11e8974b91c398b"
          },
          {
            "type": "html",
            "text": "<i>Is our goal to solve and prevent problems, or merely measure something? If the first, then why would \"soft\" and \"existential\" coupling be omitted? You seem to half-agree that soft/ext. coupling can cause problems.</i> (Only insofar as need for change ever causes problems.) <i>And Martin makes an issue of it. The opening definition seems to include soft coupling. Perhaps we just need a better classification system for \"coupling\" (or at least \"dependency\"). Here's a rough draft:</i>",
            "id": "26897cb39a40379a25f6bf5f0cd4ac73"
          },
          {
            "type": "html",
            "text": " References or associations that can be determined by <b>inspecting the code</b> without studying the algorithms involved. For example, subroutine calls may be coupled by their parameter signatures:",
            "id": "a8df11debec72e2611f7fcc652f58358"
          },
          {
            "type": "code",
            "text": "           foo(1, 2, 3);\n           ....\n           function foo(a, b, c) {.....}\n           // We can see that the def of foo requires 3 parameters\n           // (Assuming the target language does not auto-nil missing ones).",
            "id": "a8902ae9a9e5619945f5f46a3d535cac"
          },
          {
            "type": "html",
            "text": " References or associations that depend on <b>run-time behavior</b> (or at least behavior too complex to be detected by automated basic code analysis).",
            "id": "aaa02a02c55340d4e47aad50c10222b7"
          },
          {
            "type": "code",
            "text": "          function X() {\n            fileName = \"myfile.txt\";\n            a = foo(fileName, currentDateTime());\n            if (a.length > 0) {\n               fileName = alternativeName(a);\n            }\n            contents = readFileContents(fileName, settings);\n            // Function X is coupled to existence of \"myfile.txt\" if \"a\" not blank.\n            // (let's assume readFileContents() requires file existence.)\n          }",
            "id": "cb8a4b4df01bc3acd68104aad32e8535"
          },
          {
            "type": "html",
            "text": " References or associations that depend on some <b>possible future change</b> or requirement.",
            "id": "0137afa4d33ece3dcfe9b417215872e1"
          },
          {
            "type": "html",
            "text": " Example: The potential case-list item addition example given above near the \"fuzzy metrics\" title above.",
            "id": "f96d6907c4acc59c1b0b462e9fccfa96"
          },
          {
            "type": "html",
            "text": "\nDidactic examples would be welcome, top.",
            "id": "2aea106cf07b72cebe0c6f4387f22771"
          },
          {
            "type": "html",
            "text": "<i>Added. See above examples. --top</i>",
            "id": "19ac606d82a9cf4db76cb35ffd6519b9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "External Links:",
            "id": "563e251f1ccfe7cdfcfeca8c8127bad2"
          },
          {
            "type": "html",
            "text": "\n[http://www.computing.dcu.ie/~renaat/ca421/LCOM.html www.computing.dcu.ie]",
            "id": "aba0898b6137afabac419d70d8e5d0c2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "See also: [[Decision Math And Yagni]] [[Decoupling Of Object Oriented Systems]] [[Directed Refactoring]]",
            "id": "87c3c0dfd36c2a524d516ed17bad37fa"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "85ecbeca22e576fe55d91512e49017eb"
          },
          {
            "type": "html",
            "text": "[[Category Info Packaging]], [[Category Modeling Laws And Principles]]",
            "id": "86bf377cfd01cb04d08b946e51443d72"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?CouplingAndCohesion c2.com]",
            "id": "938bf1de64692233a9050c3ef1ea60eb"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1627476756537
    }
  ]
}