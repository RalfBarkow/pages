{
  "title": "Characterization of the Parts",
  "story": [
    {
      "type": "paragraph",
      "id": "e50a2dc593a06139",
      "text": "The [[pattern of perception]] consists of a [[player]] that has an interface with an incoming and outbound pipe, a set of eyes, a [[strategy]] which produces objectives, and a set of hands. Apparently, there is not a lot to abstract here because each of these objects has a distinct, well defined responsibility."
    },
    {
      "type": "paragraph",
      "id": "caeb428020db1a24",
      "text": "[…]"
    },
    {
      "type": "markdown",
      "id": "20943d62ec6ada55",
      "text": "Also, did you notice the distinction we just made? We said that *standalone* behavior processes will evaluate to something. But what would happen if the behavior process is not standalone, meaning that it does not correspond to a Smalltalk process? What does that mean to begin with? Well, one interpretation could be that the player queries its behavior processes because its design goals ask for a specific composite behavior which is best induced by controlling the sequence in which each of the behavior processes behave more tightly. This means that our design has to accomodate multithreaded and singlethreaded players. \n"
    },
    {
      "type": "markdown",
      "id": "99ce0cd288c7473f",
      "text": "At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have.\n"
    },
    {
      "type": "markdown",
      "id": "7396d9e868d94a54",
      "text": "Nevertheless, it may feel as if it will cause lots of code to appear. And yet, that just does not need to be the case. A forked Smalltalk process running in the behavior process could simply reuse the code that allows the player itself to query the behavior process in the first place, so this should not be hard to do.\n"
    },
    {
      "type": "markdown",
      "id": "975e8fcd7f892cba",
      "text": "What are we going to do with the information space in which the behavior process moves? We said we do not want to explicitly show that we are thinking about information spaces because that would allow too much of an arbitrary abstraction to shine through. So now we need to hide that a bit without lying too much. How are we going to tackle this? Well, we could talk in terms we can expect others to be very familiar with. For example, what Smalltalk construct is similar to what we want to do? Where in Smalltalk does it happen that there is a map between some input objects and some output objects? The point of a behavior process is to implement behavior, right? So what is the Smalltalk construct that allows behavior to occur?…\n"
    },
    {
      "type": "markdown",
      "id": "8b572df750c59e63",
      "text": "Of course! In Smalltalk, *the only thing we can do is to send messages!*\n"
    },
    {
      "type": "markdown",
      "id": "9a5054568bc672dd",
      "text": "Therefore, we will use the word `sender` to implicitly talk about the source of position vectors, and the word `receiver` to talk about whoever receives the displacement vector from the behavior process.\n"
    },
    {
      "type": "markdown",
      "id": "bfe9c6826cf3e864",
      "text": "This looks almost too easy. But consider the many pages and the amount of effort we had to go through to reach this place! It just seems simple now because it is becoming obvious that the amount of code we will have to write is very small — which is exactly the point of not writing code right away.\n"
    },
    {
      "type": "markdown",
      "id": "f3d14870d8b77c56",
      "text": "What other names will behavior processes have to know? Well, in order to make housekeeping easier, there should be an instance name for any embedded process running inside a behavior process. Borrowing from the circuit analogy we discussed earlier in the book, we will call this process the `signal`. To be able to stop a signal gracefully, we will also let behavior processes know whether their `signalShouldEvaluate`."
    },
    {
      "type": "paragraph",
      "id": "dde53beac36042fe",
      "text": "[…]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Characterization of the Parts",
        "story": []
      },
      "date": 1660814726339
    },
    {
      "item": {
        "type": "factory",
        "id": "e50a2dc593a06139"
      },
      "id": "e50a2dc593a06139",
      "type": "add",
      "date": 1660814733852
    },
    {
      "type": "edit",
      "id": "e50a2dc593a06139",
      "item": {
        "type": "paragraph",
        "id": "e50a2dc593a06139",
        "text": "The pattern of perception consists of a player that has an interface with an incoming and outbound pipe, a set of eyes, a strategy which produces objectives, and a set of hands. Apparently, there is not a lot to abstract here because each of these objects has a distinct, well defined responsibility."
      },
      "date": 1660814735881
    },
    {
      "type": "add",
      "id": "caeb428020db1a24",
      "item": {
        "type": "paragraph",
        "id": "caeb428020db1a24",
        "text": "[…]"
      },
      "after": "e50a2dc593a06139",
      "date": 1660814740081
    },
    {
      "type": "edit",
      "id": "e50a2dc593a06139",
      "item": {
        "type": "paragraph",
        "id": "e50a2dc593a06139",
        "text": "The [[pattern of perception]] consists of a [[player]] that has an interface with an incoming and outbound pipe, a set of eyes, a strategy which produces objectives, and a set of hands. Apparently, there is not a lot to abstract here because each of these objects has a distinct, well defined responsibility."
      },
      "date": 1660814758063
    },
    {
      "type": "add",
      "id": "20943d62ec6ada55",
      "item": {
        "type": "paragraph",
        "id": "20943d62ec6ada55",
        "text": "Also, did you notice the distinction we just made? We said that standalone behavior processes will evaluate to something. But what would happen if the behavior process is not standalone, meaning that it does not correspond to a Smalltalk process? What does that mean to begin with? Well, one interpretation could be that the player queries its behavior processes because its design goals ask for a specific composite behavior which is best induced by controlling the sequence in which each of the behavior processes behave more tightly. This means that our design has to accomodate multithreaded and singlethreaded players. At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have."
      },
      "after": "caeb428020db1a24",
      "date": 1660814799205
    },
    {
      "type": "add",
      "id": "dde53beac36042fe",
      "item": {
        "type": "paragraph",
        "id": "dde53beac36042fe",
        "text": "[…]"
      },
      "after": "20943d62ec6ada55",
      "date": 1660814801050
    },
    {
      "type": "edit",
      "id": "20943d62ec6ada55",
      "item": {
        "type": "paragraph",
        "id": "20943d62ec6ada55",
        "text": "Also, did you notice the distinction we just made? We said that *standalone* behavior processes will evaluate to something. But what would happen if the behavior process is not standalone, meaning that it does not correspond to a Smalltalk process? What does that mean to begin with? Well, one interpretation could be that the player queries its behavior processes because its design goals ask for a specific composite behavior which is best induced by controlling the sequence in which each of the behavior processes behave more tightly. This means that our design has to accomodate multithreaded and singlethreaded players. At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have."
      },
      "date": 1660814820332
    },
    {
      "type": "edit",
      "id": "20943d62ec6ada55",
      "item": {
        "type": "markdown",
        "id": "20943d62ec6ada55",
        "text": "Also, did you notice the distinction we just made? We said that *standalone* behavior processes will evaluate to something. But what would happen if the behavior process is not standalone, meaning that it does not correspond to a Smalltalk process? What does that mean to begin with? Well, one interpretation could be that the player queries its behavior processes because its design goals ask for a specific composite behavior which is best induced by controlling the sequence in which each of the behavior processes behave more tightly. This means that our design has to accomodate multithreaded and singlethreaded players. At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have."
      },
      "date": 1660814821360
    },
    {
      "type": "edit",
      "id": "20943d62ec6ada55",
      "item": {
        "type": "markdown",
        "id": "20943d62ec6ada55",
        "text": "Also, did you notice the distinction we just made? We said that *standalone* behavior processes will evaluate to something. But what would happen if the behavior process is not standalone, meaning that it does not correspond to a Smalltalk process? What does that mean to begin with? Well, one interpretation could be that the player queries its behavior processes because its design goals ask for a specific composite behavior which is best induced by controlling the sequence in which each of the behavior processes behave more tightly. This means that our design has to accomodate multithreaded and singlethreaded players. \n"
      },
      "date": 1660814904923
    },
    {
      "type": "add",
      "id": "99ce0cd288c7473f",
      "item": {
        "type": "markdown",
        "id": "99ce0cd288c7473f",
        "text": "At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have."
      },
      "after": "20943d62ec6ada55",
      "date": 1660814905225
    },
    {
      "type": "edit",
      "id": "99ce0cd288c7473f",
      "item": {
        "type": "markdown",
        "id": "99ce0cd288c7473f",
        "text": "At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have.\n"
      },
      "date": 1660814923835
    },
    {
      "type": "add",
      "id": "7396d9e868d94a54",
      "item": {
        "type": "markdown",
        "id": "7396d9e868d94a54",
        "text": "Nevertheless, it may feel as if it will cause lots of code to appear. And yet, that just does not need to be the case. A forked Smalltalk process running in the behavior process could simply reuse the code that allows the player itself to query the behavior process in the first place, so this should not be hard to do."
      },
      "after": "99ce0cd288c7473f",
      "date": 1660814924661
    },
    {
      "type": "edit",
      "id": "7396d9e868d94a54",
      "item": {
        "type": "markdown",
        "id": "7396d9e868d94a54",
        "text": "Nevertheless, it may feel as if it will cause lots of code to appear. And yet, that just does not need to be the case. A forked Smalltalk process running in the behavior process could simply reuse the code that allows the player itself to query the behavior process in the first place, so this should not be hard to do.\n"
      },
      "date": 1660814971981
    },
    {
      "type": "add",
      "id": "975e8fcd7f892cba",
      "item": {
        "type": "markdown",
        "id": "975e8fcd7f892cba",
        "text": "What are we going to do with the information space in which the behavior"
      },
      "after": "7396d9e868d94a54",
      "date": 1660814972914
    },
    {
      "type": "edit",
      "id": "975e8fcd7f892cba",
      "item": {
        "type": "markdown",
        "id": "975e8fcd7f892cba",
        "text": "What are we going to do with the information space in which the behavior rocess moves? We said we do not want to explicitly show that we are thinking about information spaces because that would allow too much of an arbitrary abstraction to shine through. So now we need to hide that a bit without lying too much. How are we going to tackle this? Well, we could talk in terms we can expect others to be very familiar with. For example, what Smalltalk construct is similar to what we want to do? Where in Smalltalk does it happen that there is a map between some input objects and some output objects? The point of a behavior process is to implement behavior, right? So what is the Smalltalk construct that allows behavior to occur?. . ."
      },
      "date": 1660814990303
    },
    {
      "type": "edit",
      "id": "975e8fcd7f892cba",
      "item": {
        "type": "markdown",
        "id": "975e8fcd7f892cba",
        "text": "What are we going to do with the information space in which the behavior process moves? We said we do not want to explicitly show that we are thinking about information spaces because that would allow too much of an arbitrary abstraction to shine through. So now we need to hide that a bit without lying too much. How are we going to tackle this? Well, we could talk in terms we can expect others to be very familiar with. For example, what Smalltalk construct is similar to what we want to do? Where in Smalltalk does it happen that there is a map between some input objects and some output objects? The point of a behavior process is to implement behavior, right? So what is the Smalltalk construct that allows behavior to occur?. . ."
      },
      "date": 1660815003731
    },
    {
      "type": "edit",
      "id": "975e8fcd7f892cba",
      "item": {
        "type": "markdown",
        "id": "975e8fcd7f892cba",
        "text": "What are we going to do with the information space in which the behavior process moves? We said we do not want to explicitly show that we are thinking about information spaces because that would allow too much of an arbitrary abstraction to shine through. So now we need to hide that a bit without lying too much. How are we going to tackle this? Well, we could talk in terms we can expect others to be very familiar with. For example, what Smalltalk construct is similar to what we want to do? Where in Smalltalk does it happen that there is a map between some input objects and some output objects? The point of a behavior process is to implement behavior, right? So what is the Smalltalk construct that allows behavior to occur?…"
      },
      "date": 1660815047106
    },
    {
      "type": "edit",
      "id": "975e8fcd7f892cba",
      "item": {
        "type": "markdown",
        "id": "975e8fcd7f892cba",
        "text": "What are we going to do with the information space in which the behavior process moves? We said we do not want to explicitly show that we are thinking about information spaces because that would allow too much of an arbitrary abstraction to shine through. So now we need to hide that a bit without lying too much. How are we going to tackle this? Well, we could talk in terms we can expect others to be very familiar with. For example, what Smalltalk construct is similar to what we want to do? Where in Smalltalk does it happen that there is a map between some input objects and some output objects? The point of a behavior process is to implement behavior, right? So what is the Smalltalk construct that allows behavior to occur?…\n"
      },
      "date": 1660815060911
    },
    {
      "type": "add",
      "id": "8b572df750c59e63",
      "item": {
        "type": "markdown",
        "id": "8b572df750c59e63",
        "text": "Of course! In Smalltalk, the only thing we can do is to send messages!"
      },
      "after": "975e8fcd7f892cba",
      "date": 1660815062384
    },
    {
      "type": "edit",
      "id": "8b572df750c59e63",
      "item": {
        "type": "markdown",
        "id": "8b572df750c59e63",
        "text": "Of course! In Smalltalk, *the only thing we can do is to send messages!*"
      },
      "date": 1660815075047
    },
    {
      "type": "edit",
      "id": "8b572df750c59e63",
      "item": {
        "type": "markdown",
        "id": "8b572df750c59e63",
        "text": "Of course! In Smalltalk, *the only thing we can do is to send messages!*\n"
      },
      "date": 1660815093660
    },
    {
      "type": "add",
      "id": "9a5054568bc672dd",
      "item": {
        "type": "markdown",
        "id": "9a5054568bc672dd",
        "text": "Therefore, we will use the word sender to implicitly talk about the source of position vectors, and the word receiver to talk about whoever receives the displacement vector from the behavior process16."
      },
      "after": "8b572df750c59e63",
      "date": 1660815094834
    },
    {
      "type": "edit",
      "id": "9a5054568bc672dd",
      "item": {
        "type": "markdown",
        "id": "9a5054568bc672dd",
        "text": "Therefore, we will use the word sender to implicitly talk about the source of position vectors, and the word receiver to talk about whoever receives the displacement vector from the behavior process.\n"
      },
      "date": 1660815113006
    },
    {
      "type": "add",
      "id": "bfe9c6826cf3e864",
      "item": {
        "type": "markdown",
        "id": "bfe9c6826cf3e864",
        "text": "This looks almost too easy. But consider the many pages and the amount of effort we had to go through to reach this place! It just seems simple now because it is becoming obvious that the amount of code we will have to write is very small — which is exactly the point of not writing code right away."
      },
      "after": "9a5054568bc672dd",
      "date": 1660815113681
    },
    {
      "type": "edit",
      "id": "bfe9c6826cf3e864",
      "item": {
        "type": "markdown",
        "id": "bfe9c6826cf3e864",
        "text": "This looks almost too easy. But consider the many pages and the amount of effort we had to go through to reach this place! It just seems simple now because it is becoming obvious that the amount of code we will have to write is very small — which is exactly the point of not writing code right away.\n"
      },
      "date": 1660815167502
    },
    {
      "type": "add",
      "id": "f3d14870d8b77c56",
      "item": {
        "type": "markdown",
        "id": "f3d14870d8b77c56",
        "text": "What other names will behavior processes have to know? Well, in order to make housekeeping easier, there should be an instance name for any embedded process running inside a behavior process. Borrowing from the circuit analogy we discussed earlier in the book, we will call this process the signal. To be able to stop a signal gracefully, we will also let behavior processes know whether their signalShouldEvaluate."
      },
      "after": "bfe9c6826cf3e864",
      "date": 1660815168302
    },
    {
      "type": "edit",
      "id": "9a5054568bc672dd",
      "item": {
        "type": "markdown",
        "id": "9a5054568bc672dd",
        "text": "Therefore, we will use the word `sender` to implicitly talk about the source of position vectors, and the word receiver to talk about whoever receives the displacement vector from the behavior process.\n"
      },
      "date": 1660815219037
    },
    {
      "type": "edit",
      "id": "9a5054568bc672dd",
      "item": {
        "type": "markdown",
        "id": "9a5054568bc672dd",
        "text": "Therefore, we will use the word `sender` to implicitly talk about the source of position vectors, and the word `receiver` to talk about whoever receives the displacement vector from the behavior process.\n"
      },
      "date": 1660815243003
    },
    {
      "type": "edit",
      "id": "f3d14870d8b77c56",
      "item": {
        "type": "markdown",
        "id": "f3d14870d8b77c56",
        "text": "What other names will behavior processes have to know? Well, in order to make housekeeping easier, there should be an instance name for any embedded process running inside a behavior process. Borrowing from the circuit analogy we discussed earlier in the book, we will call this process the `signal`. To be able to stop a signal gracefully, we will also let behavior processes know whether their `signalShouldEvaluate`."
      },
      "date": 1660815281557
    },
    {
      "type": "edit",
      "id": "e50a2dc593a06139",
      "item": {
        "type": "paragraph",
        "id": "e50a2dc593a06139",
        "text": "The [[pattern of perception]] consists of a [[player]] that has an interface with an incoming and outbound pipe, a set of eyes, a [[strategy]] which produces objectives, and a set of hands. Apparently, there is not a lot to abstract here because each of these objects has a distinct, well defined responsibility."
      },
      "date": 1660815557600
    }
  ]
}