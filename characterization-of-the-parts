{
  "title": "Characterization of the Parts",
  "story": [
    {
      "type": "paragraph",
      "id": "e50a2dc593a06139",
      "text": "The [[pattern of perception]] consists of a [[player]] that has an interface with an incoming and outbound pipe, a set of eyes, a [[strategy]] which produces objectives, and a set of hands. Apparently, there is not a lot to abstract here because each of these objects has a distinct, well defined responsibility."
    },
    {
      "type": "paragraph",
      "id": "706366d8c96ac55c",
      "text": "Or is there something under the surface? Because let’s see here, the eyes for example take information from one space and produce information in another space. The strategy takes the output of the eyes and produces information in the space containing the objectives. The hands do something similar. Both pipes of the interface do the same. So actually, these objects have a lot in common. And what is more, we have already made an abstraction that applies to all of them, remember?. . ."
    },
    {
      "type": "markdown",
      "id": "9e8070932e7260c7",
      "text": "*Every single object we have been talking about is a behavior process!*\n"
    },
    {
      "type": "markdown",
      "id": "743857cf92942196",
      "text": "Ah, but then what we should do now is to model behavior processes. Once we have them stabilized in our minds and then in code, implementing the rest of the parts should be more straightforward.\n"
    },
    {
      "type": "markdown",
      "id": "df1523b5fa1e83bc",
      "text": "> This onion is full of layers!\n"
    },
    {
      "type": "markdown",
      "id": "65173c3e45b93037",
      "text": "Note here how the principle of not writing code right away is at work.\n"
    },
    {
      "type": "markdown",
      "id": "5cf2cacaa3636e72",
      "text": "As we saw before, a behavior process is a function embedded in an [[information space]]. The function takes a position vector from the space it is embedded in, chooses a direction in which to move, and produces a vector which represents how much it wants to move.\n"
    },
    {
      "type": "markdown",
      "id": "e97e0235a6923132",
      "text": "Should we explicitly model an information space and position vectors? For now, the answer is no. Doing so could cause us to translate the language of our domain into an abstraction capable of holding anything we throw at it, and as a consequence we run the risk of losing some of the ability to concretely describe our problem. Thus, while we will not create classes such as `InformationSpace` at this time, we will however model everything else to be a good reflection of them.\n"
    },
    {
      "type": "markdown",
      "id": "f5ec2d278997fd32",
      "text": "Do you remember the discussion, a few chapters earlier in the book, about whether behavior processes travelling in an information space end their existence because they finally evaluate or because of an unhandled exception? That is one of the details we have to consider now. Fortunately, it is not as thorny as it seems. In Smalltalk, an unhandled exception is a problem, and as such it should not happen. Because the context in which we have to make this design decision, we have no choice other than to assume a model in which standalone behavior processes *do evaluate*.\n"
    },
    {
      "type": "markdown",
      "id": "5dfe33d3577bb977",
      "text": "> See how easy that was? Scary, huh?"
    },
    {
      "type": "markdown",
      "id": "20943d62ec6ada55",
      "text": "Also, did you notice the distinction we just made? We said that *standalone* behavior processes will evaluate to something. But what would happen if the behavior process is not standalone, meaning that it does not correspond to a Smalltalk process? What does that mean to begin with? Well, one interpretation could be that **the player queries its behavior processes because its design goals ask for a specific composite behavior which is best induced by controlling the sequence in which each of the behavior processes behave more tightly**. This means that our design has to accomodate multithreaded and singlethreaded players. \n"
    },
    {
      "type": "markdown",
      "id": "99ce0cd288c7473f",
      "text": "At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have.\n"
    },
    {
      "type": "markdown",
      "id": "7396d9e868d94a54",
      "text": "Nevertheless, it may feel as if it will cause lots of code to appear. And yet, that just does not need to be the case. A forked Smalltalk process running in the behavior process could simply reuse the code that allows the player itself to query the behavior process in the first place, so this should not be hard to do.\n"
    },
    {
      "type": "markdown",
      "id": "975e8fcd7f892cba",
      "text": "What are we going to do with the information space in which the behavior process moves? We said we do not want to explicitly show that we are thinking about information spaces because that would allow too much of an arbitrary abstraction to shine through. So now we need to hide that a bit without lying too much. How are we going to tackle this? Well, we could talk in terms we can expect others to be very familiar with. For example, what Smalltalk construct is similar to what we want to do? Where in Smalltalk does it happen that there is a map between some input objects and some output objects? The point of a behavior process is to implement behavior, right? So what is the Smalltalk construct that allows behavior to occur?…\n"
    },
    {
      "type": "markdown",
      "id": "8b572df750c59e63",
      "text": "Of course! In Smalltalk, *the only thing we can do is to send messages!*\n"
    },
    {
      "type": "markdown",
      "id": "9a5054568bc672dd",
      "text": "Therefore, we will use the word `sender` to implicitly talk about the source of position vectors, and the word `receiver` to talk about whoever receives the displacement vector from the behavior process.\n"
    },
    {
      "type": "markdown",
      "id": "bfe9c6826cf3e864",
      "text": "This looks almost too easy. But consider the many pages and the amount of effort we had to go through to reach this place! It just seems simple now because it is becoming obvious that the amount of code we will have to write is very small — which is exactly the point of not writing code right away.\n"
    },
    {
      "type": "markdown",
      "id": "f3d14870d8b77c56",
      "text": "What other names will behavior processes have to know? Well, in order to make housekeeping easier, there should be an instance name for any embedded process running inside a behavior process. Borrowing from the circuit analogy we discussed earlier in the book, we will call this process the `signal`. To be able to stop a signal gracefully, we will also let behavior processes know whether their `signalShouldEvaluate`."
    },
    {
      "type": "paragraph",
      "id": "dde53beac36042fe",
      "text": "[…]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Characterization of the Parts",
        "story": []
      },
      "date": 1660814726339
    },
    {
      "item": {
        "type": "factory",
        "id": "e50a2dc593a06139"
      },
      "id": "e50a2dc593a06139",
      "type": "add",
      "date": 1660814733852
    },
    {
      "type": "edit",
      "id": "e50a2dc593a06139",
      "item": {
        "type": "paragraph",
        "id": "e50a2dc593a06139",
        "text": "The pattern of perception consists of a player that has an interface with an incoming and outbound pipe, a set of eyes, a strategy which produces objectives, and a set of hands. Apparently, there is not a lot to abstract here because each of these objects has a distinct, well defined responsibility."
      },
      "date": 1660814735881
    },
    {
      "type": "add",
      "id": "caeb428020db1a24",
      "item": {
        "type": "paragraph",
        "id": "caeb428020db1a24",
        "text": "[…]"
      },
      "after": "e50a2dc593a06139",
      "date": 1660814740081
    },
    {
      "type": "edit",
      "id": "e50a2dc593a06139",
      "item": {
        "type": "paragraph",
        "id": "e50a2dc593a06139",
        "text": "The [[pattern of perception]] consists of a [[player]] that has an interface with an incoming and outbound pipe, a set of eyes, a strategy which produces objectives, and a set of hands. Apparently, there is not a lot to abstract here because each of these objects has a distinct, well defined responsibility."
      },
      "date": 1660814758063
    },
    {
      "type": "add",
      "id": "20943d62ec6ada55",
      "item": {
        "type": "paragraph",
        "id": "20943d62ec6ada55",
        "text": "Also, did you notice the distinction we just made? We said that standalone behavior processes will evaluate to something. But what would happen if the behavior process is not standalone, meaning that it does not correspond to a Smalltalk process? What does that mean to begin with? Well, one interpretation could be that the player queries its behavior processes because its design goals ask for a specific composite behavior which is best induced by controlling the sequence in which each of the behavior processes behave more tightly. This means that our design has to accomodate multithreaded and singlethreaded players. At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have."
      },
      "after": "caeb428020db1a24",
      "date": 1660814799205
    },
    {
      "type": "add",
      "id": "dde53beac36042fe",
      "item": {
        "type": "paragraph",
        "id": "dde53beac36042fe",
        "text": "[…]"
      },
      "after": "20943d62ec6ada55",
      "date": 1660814801050
    },
    {
      "type": "edit",
      "id": "20943d62ec6ada55",
      "item": {
        "type": "paragraph",
        "id": "20943d62ec6ada55",
        "text": "Also, did you notice the distinction we just made? We said that *standalone* behavior processes will evaluate to something. But what would happen if the behavior process is not standalone, meaning that it does not correspond to a Smalltalk process? What does that mean to begin with? Well, one interpretation could be that the player queries its behavior processes because its design goals ask for a specific composite behavior which is best induced by controlling the sequence in which each of the behavior processes behave more tightly. This means that our design has to accomodate multithreaded and singlethreaded players. At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have."
      },
      "date": 1660814820332
    },
    {
      "type": "edit",
      "id": "20943d62ec6ada55",
      "item": {
        "type": "markdown",
        "id": "20943d62ec6ada55",
        "text": "Also, did you notice the distinction we just made? We said that *standalone* behavior processes will evaluate to something. But what would happen if the behavior process is not standalone, meaning that it does not correspond to a Smalltalk process? What does that mean to begin with? Well, one interpretation could be that the player queries its behavior processes because its design goals ask for a specific composite behavior which is best induced by controlling the sequence in which each of the behavior processes behave more tightly. This means that our design has to accomodate multithreaded and singlethreaded players. At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have."
      },
      "date": 1660814821360
    },
    {
      "type": "edit",
      "id": "20943d62ec6ada55",
      "item": {
        "type": "markdown",
        "id": "20943d62ec6ada55",
        "text": "Also, did you notice the distinction we just made? We said that *standalone* behavior processes will evaluate to something. But what would happen if the behavior process is not standalone, meaning that it does not correspond to a Smalltalk process? What does that mean to begin with? Well, one interpretation could be that the player queries its behavior processes because its design goals ask for a specific composite behavior which is best induced by controlling the sequence in which each of the behavior processes behave more tightly. This means that our design has to accomodate multithreaded and singlethreaded players. \n"
      },
      "date": 1660814904923
    },
    {
      "type": "add",
      "id": "99ce0cd288c7473f",
      "item": {
        "type": "markdown",
        "id": "99ce0cd288c7473f",
        "text": "At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have."
      },
      "after": "20943d62ec6ada55",
      "date": 1660814905225
    },
    {
      "type": "edit",
      "id": "99ce0cd288c7473f",
      "item": {
        "type": "markdown",
        "id": "99ce0cd288c7473f",
        "text": "At first this may seem like an overblown requirement, but I am sure you will be able to think of instances in which you behave one way or the other. As the point of the pattern of perception is to allow us to model our own behavior, then this level of flexibility is truly a desirable feature to have.\n"
      },
      "date": 1660814923835
    },
    {
      "type": "add",
      "id": "7396d9e868d94a54",
      "item": {
        "type": "markdown",
        "id": "7396d9e868d94a54",
        "text": "Nevertheless, it may feel as if it will cause lots of code to appear. And yet, that just does not need to be the case. A forked Smalltalk process running in the behavior process could simply reuse the code that allows the player itself to query the behavior process in the first place, so this should not be hard to do."
      },
      "after": "99ce0cd288c7473f",
      "date": 1660814924661
    },
    {
      "type": "edit",
      "id": "7396d9e868d94a54",
      "item": {
        "type": "markdown",
        "id": "7396d9e868d94a54",
        "text": "Nevertheless, it may feel as if it will cause lots of code to appear. And yet, that just does not need to be the case. A forked Smalltalk process running in the behavior process could simply reuse the code that allows the player itself to query the behavior process in the first place, so this should not be hard to do.\n"
      },
      "date": 1660814971981
    },
    {
      "type": "add",
      "id": "975e8fcd7f892cba",
      "item": {
        "type": "markdown",
        "id": "975e8fcd7f892cba",
        "text": "What are we going to do with the information space in which the behavior"
      },
      "after": "7396d9e868d94a54",
      "date": 1660814972914
    },
    {
      "type": "edit",
      "id": "975e8fcd7f892cba",
      "item": {
        "type": "markdown",
        "id": "975e8fcd7f892cba",
        "text": "What are we going to do with the information space in which the behavior rocess moves? We said we do not want to explicitly show that we are thinking about information spaces because that would allow too much of an arbitrary abstraction to shine through. So now we need to hide that a bit without lying too much. How are we going to tackle this? Well, we could talk in terms we can expect others to be very familiar with. For example, what Smalltalk construct is similar to what we want to do? Where in Smalltalk does it happen that there is a map between some input objects and some output objects? The point of a behavior process is to implement behavior, right? So what is the Smalltalk construct that allows behavior to occur?. . ."
      },
      "date": 1660814990303
    },
    {
      "type": "edit",
      "id": "975e8fcd7f892cba",
      "item": {
        "type": "markdown",
        "id": "975e8fcd7f892cba",
        "text": "What are we going to do with the information space in which the behavior process moves? We said we do not want to explicitly show that we are thinking about information spaces because that would allow too much of an arbitrary abstraction to shine through. So now we need to hide that a bit without lying too much. How are we going to tackle this? Well, we could talk in terms we can expect others to be very familiar with. For example, what Smalltalk construct is similar to what we want to do? Where in Smalltalk does it happen that there is a map between some input objects and some output objects? The point of a behavior process is to implement behavior, right? So what is the Smalltalk construct that allows behavior to occur?. . ."
      },
      "date": 1660815003731
    },
    {
      "type": "edit",
      "id": "975e8fcd7f892cba",
      "item": {
        "type": "markdown",
        "id": "975e8fcd7f892cba",
        "text": "What are we going to do with the information space in which the behavior process moves? We said we do not want to explicitly show that we are thinking about information spaces because that would allow too much of an arbitrary abstraction to shine through. So now we need to hide that a bit without lying too much. How are we going to tackle this? Well, we could talk in terms we can expect others to be very familiar with. For example, what Smalltalk construct is similar to what we want to do? Where in Smalltalk does it happen that there is a map between some input objects and some output objects? The point of a behavior process is to implement behavior, right? So what is the Smalltalk construct that allows behavior to occur?…"
      },
      "date": 1660815047106
    },
    {
      "type": "edit",
      "id": "975e8fcd7f892cba",
      "item": {
        "type": "markdown",
        "id": "975e8fcd7f892cba",
        "text": "What are we going to do with the information space in which the behavior process moves? We said we do not want to explicitly show that we are thinking about information spaces because that would allow too much of an arbitrary abstraction to shine through. So now we need to hide that a bit without lying too much. How are we going to tackle this? Well, we could talk in terms we can expect others to be very familiar with. For example, what Smalltalk construct is similar to what we want to do? Where in Smalltalk does it happen that there is a map between some input objects and some output objects? The point of a behavior process is to implement behavior, right? So what is the Smalltalk construct that allows behavior to occur?…\n"
      },
      "date": 1660815060911
    },
    {
      "type": "add",
      "id": "8b572df750c59e63",
      "item": {
        "type": "markdown",
        "id": "8b572df750c59e63",
        "text": "Of course! In Smalltalk, the only thing we can do is to send messages!"
      },
      "after": "975e8fcd7f892cba",
      "date": 1660815062384
    },
    {
      "type": "edit",
      "id": "8b572df750c59e63",
      "item": {
        "type": "markdown",
        "id": "8b572df750c59e63",
        "text": "Of course! In Smalltalk, *the only thing we can do is to send messages!*"
      },
      "date": 1660815075047
    },
    {
      "type": "edit",
      "id": "8b572df750c59e63",
      "item": {
        "type": "markdown",
        "id": "8b572df750c59e63",
        "text": "Of course! In Smalltalk, *the only thing we can do is to send messages!*\n"
      },
      "date": 1660815093660
    },
    {
      "type": "add",
      "id": "9a5054568bc672dd",
      "item": {
        "type": "markdown",
        "id": "9a5054568bc672dd",
        "text": "Therefore, we will use the word sender to implicitly talk about the source of position vectors, and the word receiver to talk about whoever receives the displacement vector from the behavior process16."
      },
      "after": "8b572df750c59e63",
      "date": 1660815094834
    },
    {
      "type": "edit",
      "id": "9a5054568bc672dd",
      "item": {
        "type": "markdown",
        "id": "9a5054568bc672dd",
        "text": "Therefore, we will use the word sender to implicitly talk about the source of position vectors, and the word receiver to talk about whoever receives the displacement vector from the behavior process.\n"
      },
      "date": 1660815113006
    },
    {
      "type": "add",
      "id": "bfe9c6826cf3e864",
      "item": {
        "type": "markdown",
        "id": "bfe9c6826cf3e864",
        "text": "This looks almost too easy. But consider the many pages and the amount of effort we had to go through to reach this place! It just seems simple now because it is becoming obvious that the amount of code we will have to write is very small — which is exactly the point of not writing code right away."
      },
      "after": "9a5054568bc672dd",
      "date": 1660815113681
    },
    {
      "type": "edit",
      "id": "bfe9c6826cf3e864",
      "item": {
        "type": "markdown",
        "id": "bfe9c6826cf3e864",
        "text": "This looks almost too easy. But consider the many pages and the amount of effort we had to go through to reach this place! It just seems simple now because it is becoming obvious that the amount of code we will have to write is very small — which is exactly the point of not writing code right away.\n"
      },
      "date": 1660815167502
    },
    {
      "type": "add",
      "id": "f3d14870d8b77c56",
      "item": {
        "type": "markdown",
        "id": "f3d14870d8b77c56",
        "text": "What other names will behavior processes have to know? Well, in order to make housekeeping easier, there should be an instance name for any embedded process running inside a behavior process. Borrowing from the circuit analogy we discussed earlier in the book, we will call this process the signal. To be able to stop a signal gracefully, we will also let behavior processes know whether their signalShouldEvaluate."
      },
      "after": "bfe9c6826cf3e864",
      "date": 1660815168302
    },
    {
      "type": "edit",
      "id": "9a5054568bc672dd",
      "item": {
        "type": "markdown",
        "id": "9a5054568bc672dd",
        "text": "Therefore, we will use the word `sender` to implicitly talk about the source of position vectors, and the word receiver to talk about whoever receives the displacement vector from the behavior process.\n"
      },
      "date": 1660815219037
    },
    {
      "type": "edit",
      "id": "9a5054568bc672dd",
      "item": {
        "type": "markdown",
        "id": "9a5054568bc672dd",
        "text": "Therefore, we will use the word `sender` to implicitly talk about the source of position vectors, and the word `receiver` to talk about whoever receives the displacement vector from the behavior process.\n"
      },
      "date": 1660815243003
    },
    {
      "type": "edit",
      "id": "f3d14870d8b77c56",
      "item": {
        "type": "markdown",
        "id": "f3d14870d8b77c56",
        "text": "What other names will behavior processes have to know? Well, in order to make housekeeping easier, there should be an instance name for any embedded process running inside a behavior process. Borrowing from the circuit analogy we discussed earlier in the book, we will call this process the `signal`. To be able to stop a signal gracefully, we will also let behavior processes know whether their `signalShouldEvaluate`."
      },
      "date": 1660815281557
    },
    {
      "type": "edit",
      "id": "e50a2dc593a06139",
      "item": {
        "type": "paragraph",
        "id": "e50a2dc593a06139",
        "text": "The [[pattern of perception]] consists of a [[player]] that has an interface with an incoming and outbound pipe, a set of eyes, a [[strategy]] which produces objectives, and a set of hands. Apparently, there is not a lot to abstract here because each of these objects has a distinct, well defined responsibility."
      },
      "date": 1660815557600
    },
    {
      "type": "add",
      "id": "706366d8c96ac55c",
      "item": {
        "type": "paragraph",
        "id": "706366d8c96ac55c",
        "text": "Or is there something under the surface? Because let’s see here, the eyes for example take information from one space and produce information in another space. The strategy takes the output of the eyes and produces information in the space containing the objectives. The hands do something similar. Both pipes of the interface do the same. So actually, these objects have a lot in common. And what is more, we have already made an abstraction that applies to all of them, remember?. . ."
      },
      "after": "e50a2dc593a06139",
      "date": 1660925770979
    },
    {
      "type": "add",
      "id": "9e8070932e7260c7",
      "item": {
        "type": "paragraph",
        "id": "9e8070932e7260c7",
        "text": "*Every single object we have been talking about is a behavior process!*"
      },
      "after": "706366d8c96ac55c",
      "date": 1660925818776
    },
    {
      "type": "edit",
      "id": "9e8070932e7260c7",
      "item": {
        "type": "markdown",
        "id": "9e8070932e7260c7",
        "text": "*Every single object we have been talking about is a behavior process!*"
      },
      "date": 1660925820306
    },
    {
      "type": "edit",
      "id": "9e8070932e7260c7",
      "item": {
        "type": "markdown",
        "id": "9e8070932e7260c7",
        "text": "*Every single object we have been talking about is a behavior process!*\n"
      },
      "date": 1660925835949
    },
    {
      "type": "add",
      "id": "743857cf92942196",
      "item": {
        "type": "markdown",
        "id": "743857cf92942196",
        "text": "Ah, but then what we should do now is to model behavior processes. Once we have them stabilized in our minds and then in code, implementing the rest of"
      },
      "after": "9e8070932e7260c7",
      "date": 1660925836622
    },
    {
      "type": "edit",
      "id": "743857cf92942196",
      "item": {
        "type": "markdown",
        "id": "743857cf92942196",
        "text": "Ah, but then what we should do now is to model behavior processes. Once we have them stabilized in our minds and then in code, implementing the rest of the parts should be more straightforward"
      },
      "date": 1660925862166
    },
    {
      "type": "edit",
      "id": "743857cf92942196",
      "item": {
        "type": "markdown",
        "id": "743857cf92942196",
        "text": "Ah, but then what we should do now is to model behavior processes. Once we have them stabilized in our minds and then in code, implementing the rest of the parts should be more straightforward."
      },
      "date": 1660925868231
    },
    {
      "type": "edit",
      "id": "743857cf92942196",
      "item": {
        "type": "markdown",
        "id": "743857cf92942196",
        "text": "Ah, but then what we should do now is to model behavior processes. Once we have them stabilized in our minds and then in code, implementing the rest of the parts should be more straightforward.\n"
      },
      "date": 1660925877198
    },
    {
      "type": "add",
      "id": "df1523b5fa1e83bc",
      "item": {
        "type": "markdown",
        "id": "df1523b5fa1e83bc",
        "text": "> This onion is full of layers!"
      },
      "after": "743857cf92942196",
      "date": 1660925878375
    },
    {
      "type": "edit",
      "id": "df1523b5fa1e83bc",
      "item": {
        "type": "markdown",
        "id": "df1523b5fa1e83bc",
        "text": "> This onion is full of layers!\n"
      },
      "date": 1660925900825
    },
    {
      "type": "add",
      "id": "65173c3e45b93037",
      "item": {
        "type": "markdown",
        "id": "65173c3e45b93037",
        "text": "Note here how the principle of not writing code right away is at work."
      },
      "after": "df1523b5fa1e83bc",
      "date": 1660925901612
    },
    {
      "type": "edit",
      "id": "65173c3e45b93037",
      "item": {
        "type": "markdown",
        "id": "65173c3e45b93037",
        "text": "Note here how the principle of not writing code right away is at work.\n"
      },
      "date": 1660925934104
    },
    {
      "type": "add",
      "id": "5cf2cacaa3636e72",
      "item": {
        "type": "markdown",
        "id": "5cf2cacaa3636e72",
        "text": "As we saw before, a behavior process is a function embedded in an information space. The function takes a position vector from the space it is embedded in, chooses a direction in which to move, and produces a vector which represents how much it wants to move."
      },
      "after": "65173c3e45b93037",
      "date": 1660925934720
    },
    {
      "type": "edit",
      "id": "5cf2cacaa3636e72",
      "item": {
        "type": "markdown",
        "id": "5cf2cacaa3636e72",
        "text": "As we saw before, a behavior process is a function embedded in an [[information space]]. The function takes a position vector from the space it is embedded in, chooses a direction in which to move, and produces a vector which represents how much it wants to move."
      },
      "date": 1660925952995
    },
    {
      "type": "edit",
      "id": "5cf2cacaa3636e72",
      "item": {
        "type": "markdown",
        "id": "5cf2cacaa3636e72",
        "text": "As we saw before, a behavior process is a function embedded in an [[information space]]. The function takes a position vector from the space it is embedded in, chooses a direction in which to move, and produces a vector which represents how much it wants to move.\n"
      },
      "date": 1660926160679
    },
    {
      "type": "add",
      "id": "e97e0235a6923132",
      "item": {
        "type": "markdown",
        "id": "e97e0235a6923132",
        "text": "Should we explicitly model an information space and position vectors? For now, the answer is no. Doing so could cause us to translate the language of our domain into an abstraction capable of holding anything we throw at it, and as a consequence we run the risk of losing some of the ability to concretely describe our problem. Thus, while we will not create classes such as InformationSpace at this time, we will however model everything else to be a good reflection of them."
      },
      "after": "5cf2cacaa3636e72",
      "date": 1660926161327
    },
    {
      "type": "edit",
      "id": "e97e0235a6923132",
      "item": {
        "type": "markdown",
        "id": "e97e0235a6923132",
        "text": "Should we explicitly model an information space and position vectors? For now, the answer is no. Doing so could cause us to translate the language of our domain into an abstraction capable of holding anything we throw at it, and as a consequence we run the risk of losing some of the ability to concretely describe our problem. Thus, while we will not create classes such as `InformationSpace£` at this time, we will however model everything else to be a good reflection of them."
      },
      "date": 1660926188977
    },
    {
      "type": "edit",
      "id": "e97e0235a6923132",
      "item": {
        "type": "markdown",
        "id": "e97e0235a6923132",
        "text": "Should we explicitly model an information space and position vectors? For now, the answer is no. Doing so could cause us to translate the language of our domain into an abstraction capable of holding anything we throw at it, and as a consequence we run the risk of losing some of the ability to concretely describe our problem. Thus, while we will not create classes such as `InformationSpace` at this time, we will however model everything else to be a good reflection of them."
      },
      "date": 1660926194308
    },
    {
      "type": "edit",
      "id": "e97e0235a6923132",
      "item": {
        "type": "markdown",
        "id": "e97e0235a6923132",
        "text": "Should we explicitly model an information space and position vectors? For now, the answer is no. Doing so could cause us to translate the language of our domain into an abstraction capable of holding anything we throw at it, and as a consequence we run the risk of losing some of the ability to concretely describe our problem. Thus, while we will not create classes such as `InformationSpace` at this time, we will however model everything else to be a good reflection of them.\n"
      },
      "date": 1660926208072
    },
    {
      "type": "add",
      "id": "f5ec2d278997fd32",
      "item": {
        "type": "markdown",
        "id": "f5ec2d278997fd32",
        "text": "Do you remember the discussion, a few chapters earlier in the book, about whether behavior processes travelling in an information space end their existence because they finally evaluate or because of an unhandled exception? That is one of the details we have to consider now. Fortunately, it is not as thorny as it seems. In Smalltalk, an unhandled exception is a problem, and as such it should not happen. Because the context in which we have to make this design decision, we have no choice other than to assume a model in which standalone behavior processes do evaluate."
      },
      "after": "e97e0235a6923132",
      "date": 1660926208966
    },
    {
      "type": "edit",
      "id": "f5ec2d278997fd32",
      "item": {
        "type": "markdown",
        "id": "f5ec2d278997fd32",
        "text": "Do you remember the discussion, a few chapters earlier in the book, about whether behavior processes travelling in an information space end their existence because they finally evaluate or because of an unhandled exception? That is one of the details we have to consider now. Fortunately, it is not as thorny as it seems. In Smalltalk, an unhandled exception is a problem, and as such it should not happen. Because the context in which we have to make this design decision, we have no choice other than to assume a model in which standalone behavior processes *do evaluate*."
      },
      "date": 1660926247103
    },
    {
      "type": "edit",
      "id": "f5ec2d278997fd32",
      "item": {
        "type": "markdown",
        "id": "f5ec2d278997fd32",
        "text": "Do you remember the discussion, a few chapters earlier in the book, about whether behavior processes travelling in an information space end their existence because they finally evaluate or because of an unhandled exception? That is one of the details we have to consider now. Fortunately, it is not as thorny as it seems. In Smalltalk, an unhandled exception is a problem, and as such it should not happen. Because the context in which we have to make this design decision, we have no choice other than to assume a model in which standalone behavior processes *do evaluate*.\n"
      },
      "date": 1660926263670
    },
    {
      "type": "add",
      "id": "5dfe33d3577bb977",
      "item": {
        "type": "markdown",
        "id": "5dfe33d3577bb977",
        "text": "> See how easy that was? Scary, huh?"
      },
      "after": "f5ec2d278997fd32",
      "date": 1660926265391
    },
    {
      "type": "remove",
      "id": "caeb428020db1a24",
      "date": 1660926275449
    },
    {
      "type": "edit",
      "id": "20943d62ec6ada55",
      "item": {
        "type": "markdown",
        "id": "20943d62ec6ada55",
        "text": "Also, did you notice the distinction we just made? We said that *standalone* behavior processes will evaluate to something. But what would happen if the behavior process is not standalone, meaning that it does not correspond to a Smalltalk process? What does that mean to begin with? Well, one interpretation could be that **the player queries its behavior processes because its design goals ask for a specific composite behavior which is best induced by controlling the sequence in which each of the behavior processes behave more tightly**. This means that our design has to accomodate multithreaded and singlethreaded players. \n"
      },
      "date": 1669163553388
    }
  ]
}