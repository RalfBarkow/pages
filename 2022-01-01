{
  "title": "2022-01-01",
  "story": [
    {
      "type": "paragraph",
      "id": "a2d9ae07f8a68862",
      "text": "[[Projectify]]"
    },
    {
      "type": "paragraph",
      "id": "3228f24fd4d6d172",
      "text": "We use project based learning using @nicolaspetton http://projectify.wiki. [https://twitter.com/offrayLC/status/1458255902096699392 tweet]"
    },
    {
      "type": "paragraph",
      "id": "36763a347b105585",
      "text": "[[Fossil]]"
    },
    {
      "type": "paragraph",
      "id": "117c17c82f4bd26d",
      "text": "https://pkgs.on-nix.com/nixpkgs/fossil/"
    },
    {
      "type": "reference",
      "id": "adebc097c7e60350",
      "site": "code.fed.wiki.org",
      "slug": "biota-flagellum",
      "title": "Biota Flagellum",
      "text": "The Flagellum was our best [[Biota]] program ever. Here we have slimmed down Ian Osgood's javascript implementation to show this one program running."
    },
    {
      "type": "paragraph",
      "id": "9d1e7d5f6eff5c2d",
      "text": "// Biota interpreter (original in Smalltalk by Ward Cunningham)\n// Copyright 2005 Ian Osgood"
    },
    {
      "type": "paragraph",
      "id": "37038aab0458668f",
      "text": "[[Ward]] via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1640983321963211dmhAJ:matrix.org?via=matrix.org&via=dreyeck.freedombox.rocks&via=matrix.goatpen.co matrix]"
    },
    {
      "type": "markdown",
      "id": "ef14b98a54019e37",
      "text": "> Biota is a two dimensional programming language where loops actually look like loops. I created it a long time ago. Twitter found it among other esoteric languages. I replied with some pointers but couldn't stop there. Now I have simplified Ian Osgood's javascript implementation so that it fits nicely on a wiki page. http://code.fed.wiki.org/biota-flagellum.html"
    },
    {
      "type": "paragraph",
      "id": "bcf21613fc98a49b",
      "text": "[[The Biota Computer]]\nby Ward Cunningham"
    },
    {
      "type": "paragraph",
      "id": "ef59bcc8fd490d58",
      "text": "[[Dispatch Table]]"
    },
    {
      "type": "paragraph",
      "id": "4ab1178117429a93",
      "text": "[[Biota Language]]"
    },
    {
      "type": "paragraph",
      "id": "c93804ed49a3f763",
      "text": "The Chemical Architecture of the Human Mind [https://web.archive.org/web/20040212181752/http://www.isd.atr.co.jp/~ray/pubs/pharm/ wayback]"
    },
    {
      "type": "paragraph",
      "id": "2103ff5301dcce99",
      "text": "Understanding Pharo’s global state to move programs through time and space [https://hal.archives-ouvertes.fr/hal-01070964/document pdf]"
    },
    {
      "type": "markdown",
      "id": "4f4e52d4626a12e1",
      "text": "> **Abstract**. Code mobility is a mechanism that allows the migration of running programs between different environments. Such migration includes amongst others the migration of application data and resources. Application’s data is is usually composed by elements of different nature: from printers and files, to framework and domain objects. This application data will be transported along with the code of its program in space (when serialized and deployed in another environment) or time (when a new session is started in a different point of time). The main problem when moving around\ncode resides, in our understanding, to global state. While unreferenced leaf objects are garbage collected, those referenced (transitively) by some global object will remain alive. In order to support code mobility in time and space, we need to understand how global application data is used. With this purpose, we study and classify Pharo’s global state. This classification uncovers some common patterns and provides a first insight on how global state should be managed, specially in code mobility scenarios. As a minor contribution, we also discuss solutions to each of the found categories."
    },
    {
      "type": "pagefold",
      "id": "93470397aed7384e",
      "text": "Cuis"
    },
    {
      "type": "paragraph",
      "id": "490c2c965f54ca79",
      "text": "Jacob via Cuis-dev mailing list\n\n"
    },
    {
      "type": "paragraph",
      "id": "30e001798722e2f6",
      "text": "I'm a heavy user of Emacs, a dabbler in Smalltalk and slightly less of\na dabbler in Lisp generally. I don't have the extension development\nexperience of Mariano, but I wanted to submit my own opinions for what\nthey're worth. I find this intersection intensely interesting.\n\nLisp, Smalltalk, and Forth have appealed to me on aesthetic grounds\nfor several. Recently, I added APL to that list. Each language\nemphasizes a certain material which almost everything is built upon.\nIn the Forth case, it's the stack; in APL, matrices; in, Smalltalk,\nobjects and messages; in Lisp I'm not sure precisely what. \"Lists\" is\none answer, but I think that's too specific. Rather, my experience of\nLisp is working with symbols. \"Code-is-data\" is a cliche when it comes\nto Lisp, but it's true. Lisp and Smalltalk feel particularly similar\nas they are both image-oriented. Emacs, in fact, loads an image every\ntime it starts; The C core is very small and loading the necessary\nLisp code from text would be prohibitively expensive.\n\n> In a way, I consider Lisps to be \"object oriented\"\n\nI don't disagree, but there's a distinct difference between the\nSmalltalk and Lisp worlds. You can give a Lisp an object system easily\nenough, but the rest of the environment seems much more symbolic. In\nEmacs's case, you get a built-in UI, and are closer to the Smalltalk\nmodel of a running image than you are in a REPL. But Emacs buffers are\nnot very similar to Smalltalk objects. Again, my experience in these\nsystems is less, and perhaps it would converge if I spent more time in\neach.\n\nMy thoughts on this are heavily colored by my quest to find or make\nthe perfect literate programming environment. On said quest, I\ndiscovered Leo (http://leoeditor.com/), which (at least in default\nconfiguration) feels more like a Smalltalk than Emacs does, albeit\nwith a much less uniform programming language. I've also had the\nGlamorous Toolkit (https://gtoolkit.com/) bookmarked in various forms\nforever. Its approach seems somewhat unique to Smalltalk; I can't\nimagine it working very well in Emacs.\n\n"
    },
    {
      "type": "paragraph",
      "id": "182952c23dfbabc0",
      "text": "https://leoeditor.com/"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2022-01-01",
        "story": []
      },
      "date": 1641025072799
    },
    {
      "item": {
        "type": "factory",
        "id": "a2d9ae07f8a68862"
      },
      "id": "a2d9ae07f8a68862",
      "type": "add",
      "date": 1641025344119
    },
    {
      "type": "edit",
      "id": "a2d9ae07f8a68862",
      "item": {
        "type": "paragraph",
        "id": "a2d9ae07f8a68862",
        "text": "[[Projectify]]"
      },
      "date": 1641025352478
    },
    {
      "item": {
        "type": "factory",
        "id": "3228f24fd4d6d172"
      },
      "id": "3228f24fd4d6d172",
      "type": "add",
      "after": "a2d9ae07f8a68862",
      "date": 1641025386513
    },
    {
      "type": "edit",
      "id": "3228f24fd4d6d172",
      "item": {
        "type": "paragraph",
        "id": "3228f24fd4d6d172",
        "text": "We use project based learning using @nicolaspetton http://projectify.wiki."
      },
      "date": 1641025389180
    },
    {
      "type": "edit",
      "id": "3228f24fd4d6d172",
      "item": {
        "type": "paragraph",
        "id": "3228f24fd4d6d172",
        "text": "We use project based learning using @nicolaspetton http://projectify.wiki. [https://twitter.com/offrayLC/status/1458255902096699392 tweet]"
      },
      "date": 1641025399040
    },
    {
      "item": {
        "type": "factory",
        "id": "36763a347b105585"
      },
      "id": "36763a347b105585",
      "type": "add",
      "after": "3228f24fd4d6d172",
      "date": 1641025456500
    },
    {
      "type": "edit",
      "id": "36763a347b105585",
      "item": {
        "type": "paragraph",
        "id": "36763a347b105585",
        "text": "[[Fossil]]"
      },
      "date": 1641025462035
    },
    {
      "item": {
        "type": "factory",
        "id": "117c17c82f4bd26d"
      },
      "id": "117c17c82f4bd26d",
      "type": "add",
      "after": "36763a347b105585",
      "date": 1641027384772
    },
    {
      "type": "edit",
      "id": "117c17c82f4bd26d",
      "item": {
        "type": "paragraph",
        "id": "117c17c82f4bd26d",
        "text": "https://pkgs.on-nix.com/nixpkgs/fossil/"
      },
      "date": 1641027389546
    },
    {
      "item": {
        "type": "factory",
        "id": "adebc097c7e60350"
      },
      "id": "adebc097c7e60350",
      "type": "add",
      "after": "117c17c82f4bd26d",
      "date": 1641031511913
    },
    {
      "type": "edit",
      "id": "adebc097c7e60350",
      "item": {
        "type": "reference",
        "id": "adebc097c7e60350",
        "site": "code.fed.wiki.org",
        "slug": "biota-flagellum",
        "title": "Biota Flagellum",
        "text": "The Flagellum was our best [[Biota]] program ever. Here we have slimmed down Ian Osgood's javascript implementation to show this one program running."
      },
      "date": 1641031516447
    },
    {
      "item": {
        "type": "factory",
        "id": "9d1e7d5f6eff5c2d"
      },
      "id": "9d1e7d5f6eff5c2d",
      "type": "add",
      "after": "adebc097c7e60350",
      "date": 1641031626625
    },
    {
      "type": "edit",
      "id": "9d1e7d5f6eff5c2d",
      "item": {
        "type": "paragraph",
        "id": "9d1e7d5f6eff5c2d",
        "text": "// Biota interpreter (original in Smalltalk by Ward Cunningham)\n// Copyright 2005 Ian Osgood"
      },
      "date": 1641031629325
    },
    {
      "type": "add",
      "id": "37038aab0458668f",
      "item": {
        "type": "paragraph",
        "id": "37038aab0458668f",
        "text": "[[Ward]] via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1640983321963211dmhAJ:matrix.org?via=matrix.org&via=dreyeck.freedombox.rocks&via=matrix.goatpen.co matrix]"
      },
      "after": "9d1e7d5f6eff5c2d",
      "date": 1641031677807
    },
    {
      "item": {
        "type": "factory",
        "id": "ef14b98a54019e37"
      },
      "id": "ef14b98a54019e37",
      "type": "add",
      "after": "37038aab0458668f",
      "date": 1641031686177
    },
    {
      "type": "edit",
      "id": "ef14b98a54019e37",
      "item": {
        "type": "paragraph",
        "id": "ef14b98a54019e37",
        "text": "Biota is a two dimensional programming language where loops actually look like loops. I created it a long time ago. Twitter found it among other esoteric languages. I replied with some pointers but couldn't stop there. Now I have simplified Ian Osgood's javascript implementation so that it fits nicely on a wiki page. http://code.fed.wiki.org/biota-flagellum.html"
      },
      "date": 1641031687922
    },
    {
      "type": "edit",
      "id": "ef14b98a54019e37",
      "item": {
        "type": "paragraph",
        "id": "ef14b98a54019e37",
        "text": "> Biota is a two dimensional programming language where loops actually look like loops. I created it a long time ago. Twitter found it among other esoteric languages. I replied with some pointers but couldn't stop there. Now I have simplified Ian Osgood's javascript implementation so that it fits nicely on a wiki page. http://code.fed.wiki.org/biota-flagellum.html"
      },
      "date": 1641031697693
    },
    {
      "type": "edit",
      "id": "ef14b98a54019e37",
      "item": {
        "type": "markdown",
        "id": "ef14b98a54019e37",
        "text": "> Biota is a two dimensional programming language where loops actually look like loops. I created it a long time ago. Twitter found it among other esoteric languages. I replied with some pointers but couldn't stop there. Now I have simplified Ian Osgood's javascript implementation so that it fits nicely on a wiki page. http://code.fed.wiki.org/biota-flagellum.html"
      },
      "date": 1641031698705
    },
    {
      "item": {
        "type": "factory",
        "id": "bcf21613fc98a49b"
      },
      "id": "bcf21613fc98a49b",
      "type": "add",
      "after": "ef14b98a54019e37",
      "date": 1641032154819
    },
    {
      "type": "edit",
      "id": "bcf21613fc98a49b",
      "item": {
        "type": "paragraph",
        "id": "bcf21613fc98a49b",
        "text": "[[Biota is a two dimensional programming language where loops actually look like loops. I created it a long time ago. Twitter found it among other esoteric languages. I replied with some pointers but couldn't stop there. Now I have simplified Ian Osgood's javascript implementation so that it fits nicely on a wiki page. http://code.fed.wiki.org/biota-flagellum.html"
      },
      "date": 1641032166138
    },
    {
      "type": "edit",
      "id": "bcf21613fc98a49b",
      "item": {
        "type": "paragraph",
        "id": "bcf21613fc98a49b",
        "text": "[[The Biota Computer]]\nby Ward Cunningham"
      },
      "date": 1641032177793
    },
    {
      "item": {
        "type": "factory",
        "id": "182952c23dfbabc0"
      },
      "id": "182952c23dfbabc0",
      "type": "add",
      "after": "bcf21613fc98a49b",
      "date": 1641035148919
    },
    {
      "type": "edit",
      "id": "182952c23dfbabc0",
      "item": {
        "type": "paragraph",
        "id": "182952c23dfbabc0",
        "text": "https://leoeditor.com/"
      },
      "date": 1641035154510
    },
    {
      "item": {
        "type": "factory",
        "id": "30e001798722e2f6"
      },
      "id": "30e001798722e2f6",
      "type": "add",
      "after": "182952c23dfbabc0",
      "date": 1641035161726
    },
    {
      "type": "edit",
      "id": "30e001798722e2f6",
      "item": {
        "type": "paragraph",
        "id": "30e001798722e2f6",
        "text": "I'm a heavy user of Emacs, a dabbler in Smalltalk and slightly less of\na dabbler in Lisp generally. I don't have the extension development\nexperience of Mariano, but I wanted to submit my own opinions for what\nthey're worth. I find this intersection intensely interesting.\n\nLisp, Smalltalk, and Forth have appealed to me on aesthetic grounds\nfor several. Recently, I added APL to that list. Each language\nemphasizes a certain material which almost everything is built upon.\nIn the Forth case, it's the stack; in APL, matrices; in, Smalltalk,\nobjects and messages; in Lisp I'm not sure precisely what. \"Lists\" is\none answer, but I think that's too specific. Rather, my experience of\nLisp is working with symbols. \"Code-is-data\" is a cliche when it comes\nto Lisp, but it's true. Lisp and Smalltalk feel particularly similar\nas they are both image-oriented. Emacs, in fact, loads an image every\ntime it starts; The C core is very small and loading the necessary\nLisp code from text would be prohibitively expensive.\n\n> In a way, I consider Lisps to be \"object oriented\"\n\nI don't disagree, but there's a distinct difference between the\nSmalltalk and Lisp worlds. You can give a Lisp an object system easily\nenough, but the rest of the environment seems much more symbolic. In\nEmacs's case, you get a built-in UI, and are closer to the Smalltalk\nmodel of a running image than you are in a REPL. But Emacs buffers are\nnot very similar to Smalltalk objects. Again, my experience in these\nsystems is less, and perhaps it would converge if I spent more time in\neach.\n\nMy thoughts on this are heavily colored by my quest to find or make\nthe perfect literate programming environment. On said quest, I\ndiscovered Leo (http://leoeditor.com/), which (at least in default\nconfiguration) feels more like a Smalltalk than Emacs does, albeit\nwith a much less uniform programming language. I've also had the\nGlamorous Toolkit (https://gtoolkit.com/) bookmarked in various forms\nforever. Its approach seems somewhat unique to Smalltalk; I can't\nimagine it working very well in Emacs.\n\n"
      },
      "date": 1641035173306
    },
    {
      "type": "add",
      "id": "490c2c965f54ca79",
      "item": {
        "type": "paragraph",
        "id": "490c2c965f54ca79",
        "text": "Jacob via Cuis-dev mailing list\n\n"
      },
      "after": "30e001798722e2f6",
      "date": 1641035180811
    },
    {
      "id": "490c2c965f54ca79",
      "type": "move",
      "order": [
        "a2d9ae07f8a68862",
        "3228f24fd4d6d172",
        "36763a347b105585",
        "117c17c82f4bd26d",
        "adebc097c7e60350",
        "9d1e7d5f6eff5c2d",
        "37038aab0458668f",
        "ef14b98a54019e37",
        "bcf21613fc98a49b",
        "490c2c965f54ca79",
        "182952c23dfbabc0",
        "30e001798722e2f6"
      ],
      "date": 1641035185673
    },
    {
      "item": {
        "type": "factory",
        "id": "93470397aed7384e"
      },
      "id": "93470397aed7384e",
      "type": "add",
      "after": "30e001798722e2f6",
      "date": 1641035194750
    },
    {
      "type": "edit",
      "id": "93470397aed7384e",
      "item": {
        "type": "pagefold",
        "id": "93470397aed7384e",
        "text": "Cuis"
      },
      "date": 1641035197992
    },
    {
      "id": "93470397aed7384e",
      "type": "move",
      "order": [
        "a2d9ae07f8a68862",
        "3228f24fd4d6d172",
        "36763a347b105585",
        "117c17c82f4bd26d",
        "adebc097c7e60350",
        "9d1e7d5f6eff5c2d",
        "37038aab0458668f",
        "ef14b98a54019e37",
        "bcf21613fc98a49b",
        "93470397aed7384e",
        "490c2c965f54ca79",
        "182952c23dfbabc0",
        "30e001798722e2f6"
      ],
      "date": 1641035203881
    },
    {
      "id": "182952c23dfbabc0",
      "type": "move",
      "order": [
        "a2d9ae07f8a68862",
        "3228f24fd4d6d172",
        "36763a347b105585",
        "117c17c82f4bd26d",
        "adebc097c7e60350",
        "9d1e7d5f6eff5c2d",
        "37038aab0458668f",
        "ef14b98a54019e37",
        "bcf21613fc98a49b",
        "93470397aed7384e",
        "490c2c965f54ca79",
        "30e001798722e2f6",
        "182952c23dfbabc0"
      ],
      "date": 1641035213409
    },
    {
      "type": "add",
      "id": "ef59bcc8fd490d58",
      "item": {
        "type": "paragraph",
        "id": "ef59bcc8fd490d58",
        "text": "[[Dispatch Table]]"
      },
      "after": "bcf21613fc98a49b",
      "date": 1641047396976
    },
    {
      "type": "add",
      "id": "4ab1178117429a93",
      "item": {
        "type": "paragraph",
        "id": "4ab1178117429a93",
        "text": "[[Biota Language]]"
      },
      "after": "ef59bcc8fd490d58",
      "date": 1641047500229
    },
    {
      "type": "add",
      "id": "c93804ed49a3f763",
      "item": {
        "type": "paragraph",
        "id": "c93804ed49a3f763",
        "text": "The Chemical Architecture of the Human Mind "
      },
      "after": "4ab1178117429a93",
      "date": 1641047973462
    },
    {
      "type": "edit",
      "id": "c93804ed49a3f763",
      "item": {
        "type": "paragraph",
        "id": "c93804ed49a3f763",
        "text": "The Chemical Architecture of the Human Mind [https://web.archive.org/web/20040212181752/http://www.isd.atr.co.jp/~ray/pubs/pharm/ wayback]"
      },
      "date": 1641047986170
    },
    {
      "type": "add",
      "id": "2103ff5301dcce99",
      "item": {
        "type": "paragraph",
        "id": "2103ff5301dcce99",
        "text": "Understanding Pharo’s global state to move programs through time and space"
      },
      "after": "c93804ed49a3f763",
      "date": 1641048084901
    },
    {
      "type": "edit",
      "id": "2103ff5301dcce99",
      "item": {
        "type": "paragraph",
        "id": "2103ff5301dcce99",
        "text": "Understanding Pharo’s global state to move programs through time and space [https://hal.archives-ouvertes.fr/hal-01070964/document pdf]"
      },
      "date": 1641048095078
    },
    {
      "type": "add",
      "id": "4f4e52d4626a12e1",
      "item": {
        "type": "paragraph",
        "id": "4f4e52d4626a12e1",
        "text": "> **Abstract**. Code mobility is a mechanism that allows the migration of running programs between different environments. Such\nmigration includes amongst others the migration of application data and resources. Application’s data is is usually\ncomposed by elements of different nature: from printers and\nfiles, to framework and domain objects. This application\ndata will be transported along with the code of its program\nin space (when serialized and deployed in another environ-\nment) or time (when a new session is started in a differ-\nent point of time). The main problem when moving around\ncode resides, in our understanding, to global state. While\nunreferenced leaf objects are garbage collected, those refer-\nenced (transitively) by some global object will remain alive.\nIn order to support code mobility in time and space, we\nneed to understand how global application data is used.\nWith this purpose, we study and classify Pharo’s global\nstate. This classification uncovers some common patterns\nand provides a first insight on how global state should be\nmanaged, specially in code mobility scenarios. As a minor\ncontribution, we also discuss solutions to each of the found\ncategories."
      },
      "after": "2103ff5301dcce99",
      "date": 1641048135018
    },
    {
      "type": "edit",
      "id": "4f4e52d4626a12e1",
      "item": {
        "type": "markdown",
        "id": "4f4e52d4626a12e1",
        "text": "> **Abstract**. Code mobility is a mechanism that allows the migration of running programs between different environments. Such\nmigration includes amongst others the migration of application data and resources. Application’s data is is usually\ncomposed by elements of different nature: from printers and\nfiles, to framework and domain objects. This application\ndata will be transported along with the code of its program\nin space (when serialized and deployed in another environ-\nment) or time (when a new session is started in a differ-\nent point of time). The main problem when moving around\ncode resides, in our understanding, to global state. While\nunreferenced leaf objects are garbage collected, those refer-\nenced (transitively) by some global object will remain alive.\nIn order to support code mobility in time and space, we\nneed to understand how global application data is used.\nWith this purpose, we study and classify Pharo’s global\nstate. This classification uncovers some common patterns\nand provides a first insight on how global state should be\nmanaged, specially in code mobility scenarios. As a minor\ncontribution, we also discuss solutions to each of the found\ncategories."
      },
      "date": 1641048136671
    },
    {
      "type": "edit",
      "id": "4f4e52d4626a12e1",
      "item": {
        "type": "markdown",
        "id": "4f4e52d4626a12e1",
        "text": "> **Abstract**. Code mobility is a mechanism that allows the migration of running programs between different environments. Such migration includes amongst others the migration of application data and resources. Application’s data is is usually\ncomposed by elements of different nature: from printers and files, to framework and domain objects. This application data will be transported along with the code of its program in space (when serialized and deployed in another environment) or time (when a new session is started in a different point of time). The main problem when moving around\ncode resides, in our understanding, to global state. While unreferenced leaf objects are garbage collected, those referenced (transitively) by some global object will remain alive. In order to support code mobility in time and space, we need to understand how global application data is used. With this purpose, we study and classify Pharo’s global state. This classification uncovers some common patterns and provides a first insight on how global state should be managed, specially in code mobility scenarios. As a minor contribution, we also discuss solutions to each of the found\ncategories."
      },
      "date": 1641055824815
    },
    {
      "type": "edit",
      "id": "4f4e52d4626a12e1",
      "item": {
        "type": "markdown",
        "id": "4f4e52d4626a12e1",
        "text": "> **Abstract**. Code mobility is a mechanism that allows the migration of running programs between different environments. Such migration includes amongst others the migration of application data and resources. Application’s data is is usually composed by elements of different nature: from printers and files, to framework and domain objects. This application data will be transported along with the code of its program in space (when serialized and deployed in another environment) or time (when a new session is started in a different point of time). The main problem when moving around\ncode resides, in our understanding, to global state. While unreferenced leaf objects are garbage collected, those referenced (transitively) by some global object will remain alive. In order to support code mobility in time and space, we need to understand how global application data is used. With this purpose, we study and classify Pharo’s global state. This classification uncovers some common patterns and provides a first insight on how global state should be managed, specially in code mobility scenarios. As a minor contribution, we also discuss solutions to each of the found\ncategories."
      },
      "date": 1641055854520
    },
    {
      "type": "edit",
      "id": "4f4e52d4626a12e1",
      "item": {
        "type": "markdown",
        "id": "4f4e52d4626a12e1",
        "text": "> **Abstract**. Code mobility is a mechanism that allows the migration of running programs between different environments. Such migration includes amongst others the migration of application data and resources. Application’s data is is usually composed by elements of different nature: from printers and files, to framework and domain objects. This application data will be transported along with the code of its program in space (when serialized and deployed in another environment) or time (when a new session is started in a different point of time). The main problem when moving around\ncode resides, in our understanding, to global state. While unreferenced leaf objects are garbage collected, those referenced (transitively) by some global object will remain alive. In order to support code mobility in time and space, we need to understand how global application data is used. With this purpose, we study and classify Pharo’s global state. This classification uncovers some common patterns and provides a first insight on how global state should be managed, specially in code mobility scenarios. As a minor contribution, we also discuss solutions to each of the found categories."
      },
      "date": 1641055872871
    }
  ]
}