{
  "title": "Object Finalization",
  "story": [
    {
      "type": "paragraph",
      "id": "cea5f7606a366343",
      "text": "Obviously, the Pharo object must be retained as long as there is a reference on the Javascript side, but no longer. There is a complication here, since there is no support for [[object finalization]] in Javascript. So, we have introduced a reference counting solution to deal with Pharo objects referenced by Javascript ones. Whenever a Pharo objet is passed to the Javascript world, it is stored in a dictionary at the Pharo side. So, it survives Pharo garbage collection thanks to this strong reference. On the Javascript side, a reverse proxy that references the Pharo object is created and its references are counted. When the count goes to zero, the Javascript reverse proxy sends a callback to remove the Pharo object from the dictionary, which allows for it to be garbage collected. (p. 15)"
    },
    {
      "type": "pagefold",
      "id": "4107d4d2b93b0065",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "e5e555326296477a",
      "text": "N. Bouraqadi, D. Mason, [[Test-Driven Development for Generated Portable Javascript Apps]], Sci. Comput. Program. (2018), https://doi.org/10.1016/j.scico.2018.02.003"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Object Finalization",
        "story": []
      },
      "date": 1649784997440
    },
    {
      "item": {
        "type": "factory",
        "id": "cea5f7606a366343"
      },
      "id": "cea5f7606a366343",
      "type": "add",
      "date": 1649785023773
    },
    {
      "type": "edit",
      "id": "cea5f7606a366343",
      "item": {
        "type": "paragraph",
        "id": "cea5f7606a366343",
        "text": "Obviously, the Pharo object must be retained as long as there is a reference on the Javascript side, but no longer. There is a complication here, since there is no support for object finalization in Javascript. So, we have introduced a reference counting solution to deal with Pharo objects referenced by Javascript ones. Whenever a Pharo objet is passed to the Javascript world, it is stored in a dictionary at the Pharo side. So, it survives Pharo garbage collection thanks to this strong reference. On the Javascript side, a reverse proxy that references the Pharo object is created and its references are counted. When the count goes to zero, the Javascript reverse proxy sends a callback to remove the Pharo object from the dictionary, which allows for it to be garbage collected."
      },
      "date": 1649785025028
    },
    {
      "id": "4107d4d2b93b0065",
      "type": "add",
      "item": {
        "type": "pagefold",
        "id": "4107d4d2b93b0065",
        "text": "~"
      },
      "after": "cea5f7606a366343",
      "date": 1649785044993
    },
    {
      "id": "e5e555326296477a",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "e5e555326296477a",
        "text": "N. Bouraqadi, D. Mason, [[Test-Driven Development for Generated Portable Javascript Apps]], Sci. Comput. Program. (2018), https://doi.org/10.1016/j.scico.2018.02.003"
      },
      "after": "4107d4d2b93b0065",
      "date": 1649785048229
    },
    {
      "type": "edit",
      "id": "cea5f7606a366343",
      "item": {
        "type": "paragraph",
        "id": "cea5f7606a366343",
        "text": "Obviously, the Pharo object must be retained as long as there is a reference on the Javascript side, but no longer. There is a complication here, since there is no support for object finalization in Javascript. So, we have introduced a reference counting solution to deal with Pharo objects referenced by Javascript ones. Whenever a Pharo objet is passed to the Javascript world, it is stored in a dictionary at the Pharo side. So, it survives Pharo garbage collection thanks to this strong reference. On the Javascript side, a reverse proxy that references the Pharo object is created and its references are counted. When the count goes to zero, the Javascript reverse proxy sends a callback to remove the Pharo object from the dictionary, which allows for it to be garbage collected. (p. 15)"
      },
      "date": 1649785062335
    },
    {
      "type": "edit",
      "id": "cea5f7606a366343",
      "item": {
        "type": "paragraph",
        "id": "cea5f7606a366343",
        "text": "Obviously, the Pharo object must be retained as long as there is a reference on the Javascript side, but no longer. There is a complication here, since there is no support for [[object finalization]] in Javascript. So, we have introduced a reference counting solution to deal with Pharo objects referenced by Javascript ones. Whenever a Pharo objet is passed to the Javascript world, it is stored in a dictionary at the Pharo side. So, it survives Pharo garbage collection thanks to this strong reference. On the Javascript side, a reverse proxy that references the Pharo object is created and its references are counted. When the count goes to zero, the Javascript reverse proxy sends a callback to remove the Pharo object from the dictionary, which allows for it to be garbage collected. (p. 15)"
      },
      "date": 1649785090204
    }
  ]
}