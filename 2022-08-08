{
  "title": "2022-08-08",
  "story": [
    {
      "type": "paragraph",
      "id": "71d7e497aeb8db38",
      "text": "\"[[Proof]]\": \nSpencer Brown uses demonstration. \nProof is when you step outside of your computational system and we didn't do that \nso proof isn't an appropriate word \nbut you know Dirk mentioned that the mark is a combination of both thinking about implication and negation \nwe tried to eliminate thinking about all those concepts and just looked at structural patterning \nthat was a demonstration that the structural pattern you can make go away\n"
    },
    {
      "type": "pagefold",
      "id": "cbd2118f03811ef7",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "aa13aae3ea1ef914",
      "text": "\"pathological\" ⇒ [[Halting Problem]], [https://en.wikipedia.org/wiki/Halting_problem wikipedia]"
    },
    {
      "type": "graphviz",
      "id": "05568c6c597d59ae",
      "text": "DOT FROM lambda-browsing"
    },
    {
      "type": "markdown",
      "id": "9c373875fea8e26e",
      "text": "# [[Programmable Logic Controllers]]"
    },
    {
      "type": "paragraph",
      "id": "b5453a32efbc0cc5",
      "text": "The classic PLC programming languages used so far, such as [[instruction list]], [[Ladder Diagram]] or [[function block diagram]], are reaching their limits. Users demand uniform, manufacturer-independent language concepts, higher programming languages and development tools, as they have been common in the PC world for a long time."
    },
    {
      "type": "markdown",
      "id": "be214c74e406d97e",
      "text": "Karl-Heinz John und Michael Tiegelkamp, „Die Programmiersprachen der IEC 61131-3“, in SPS-Programmierung mit IEC 61131-3: Konzepte und Programmiersprachen, Anforderungen an Programmiersysteme, Entscheidungshilfen, hg. von Michael Tiegelkamp und Karl Heinz John, VDI-Buch (Berlin, Heidelberg: Springer, 2009), 103–211, [https://doi.org/10.1007/978-3-642-00269-4_4 doi]."
    },
    {
      "type": "paragraph",
      "id": "677702161df6125c",
      "text": "This book aims to provide an understandable introduction to the concepts and languages of the IEC 61131 standard. Simple examples are used to explain the ideas and application of the new PLC programming languages. A larger example program summarizes the results of each section again. The book is intended as an introduction and explanatory aid for people in training and practice who want to learn about and use the possibilities of the new standard. The book describes the methodology of the standard from a manufacturer-independent point of view. Special characteristics and variants of individual programming systems should be reserved for the respective manuals. "
    },
    {
      "type": "paragraph",
      "id": "7c27bf5868c45243",
      "text": "It assumes little knowledge of personal computers and basic knowledge of PLC technology (see [Berger-03] or [Berger-06]). Even experienced PLC programmers will find information here that will make their work with these programming systems easier. The book emphasizes describing the standard itself rather than the corresponding variants of programming systems on the market. Vocational students and students are provided with a reference book that systematically facilitates their learning of the new programming standard. With the help of the \"Purchasing Advisor\", the reader can additionally evaluate PLC programming systems himself and individually, see the enclosed CD."
    },
    {
      "type": "pagefold",
      "id": "1ba1689683992bc4",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "1fb0a4b9455d6bfd",
      "text": "[Berger-03] Hans Berger „Automatisieren mit STEP 7 in KOP und FUP“ Speicherprogrammierbare Steuerungen SIMATIC S7-300/400 Hrsg.: Siemens-Aktiengesellschaft, Berlin München, Publicis-MCD-Verlag Erlangen 2003, ISBN 978-3895782190 "
    },
    {
      "type": "paragraph",
      "id": "b55a927d7cced091",
      "text": "[Berger-06] Hans Berger „Automatisieren mit STEP 7 in AWL und SCL“ Speicherprogrammierbare Steuerungen SIMATIC S7-300/400 Hrsg.: Siemens-Aktiengesellschaft, Berlin München, Publicis-MCD-Verlag Erlangen 2003, ISBN 978-3895782800"
    },
    {
      "type": "markdown",
      "id": "d2635aa820dc243b",
      "text": "Prof. Dr. Wolfgang Bock (2017), Grundlagen der SPS-Programmierung /Prozessinformatik. [https://www.oth-aw.de/files/oth-aw/Forschung/Forschungsprojekte/OTH_mind/Skript_PI.pdf pdf] (Stand: 9. Januar 2018)"
    },
    {
      "type": "pagefold",
      "id": "a70b186fd7222e62",
      "text": "."
    },
    {
      "type": "paragraph",
      "id": "ac89530f427927d0",
      "text": "[[Wilhelm Ackermann]]"
    },
    {
      "type": "markdown",
      "id": "6a2518641487950b",
      "text": "W. ACKERMANN. Solvable cases of the decision problem. Studies in logic and the foundations of mathematics. North-Holland Publishing Company, Amsterdam 1954, VIII + 114 pp. [https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/abs/ackermann-w-solvable-cases-of-the-decision-problem-studies-in-logic-and-the-foundations-of-mathematics-northholland-publishing-company-amsterdam1954-viii-114-pp/EA7768F069801A1A1201637671117DE0 page]"
    },
    {
      "type": "html",
      "id": "8d3b7bb5592b011c",
      "text": "<img\n  width=\"100%\"\n  src=\"https://images-na.ssl-images-amazon.com/images/I/81KQgK4uqQL.jpg\"\n>"
    },
    {
      "type": "markdown",
      "id": "df06894f45f6808e",
      "text": "BADBAN, Bahareh, 2009. A Term Rewriting Technique for Decision Graphs. Electronic Notes in Theoretical Computer Science. Online. 6 November 2009. Vol. 253, no. 4, p. 39–54. [https://www.sciencedirect.com/science/article/pii/S1571066109004368 doi]"
    },
    {
      "type": "markdown",
      "id": "873ae88f9d38dd96",
      "text": "> We provide an automatic verification for a fragment of FOL quantifier-free logic with zero, successor and equality. We use BDD representation of such formulas and to verify them, we first introduce a (complete) term rewrite system to generate an equivalent Ordered (0,S,=)-BDD from any given (0,S,=)-BDD. Having the ordered representation of the BDDs, one can verify the original formula in constant time. Then, to have this transformation automatically, we provide an algorithm which will do the whole process.\n"
    },
    {
      "type": "markdown",
      "id": "b1e8379ff3a26182",
      "text": "In order to solve the satisfiability or tautology problem, each path in the OBDD has to be checked for consistency, with respect to the underlying equational theory. A path represents a conjunction of (negated) equations, on which the aforementioned decision procedures can be applied. All inconsistent paths can be removed, resulting in an OBDD with only consistent paths. However, due to sharing subterms, an OBDD can have exponentially many paths, so still there is a computational bottleneck. In the Encoding method these steps are reversed. First the formula is transformed to a purely propositional formula. In this translation, facts from the equational theory (e.g. congruence of functions, transitivity of equality and orderings) are encoded into the formula. Then a finite model property is used to obtain a finite upperbound on the cardinality of the model. Finally, variables that range over a set of size n are encoded by log(n) propositional variables. The resulting formula can be checked for satisfiability with any existing SAT-technique, for instance based on resolution [7] or on BDDs [5]. An early example is Ackermann’s reduction [1], by which second order variables can be eliminated. More optimal versions are in [10,17,6]."
    },
    {
      "type": "pagefold",
      "id": "f99bda8b39b67c17",
      "text": "Komplexität"
    },
    {
      "type": "paragraph",
      "id": "2880bb90b217eaa0",
      "text": "I would like to add a few thoughts that go beyond the scope of this discussion and at the same time try to explain why we talk less about [[complexity]] today than we did in the 1950s and 1960s. Perhaps this is simply because the hopes of finding a conceptual management of complexity, that is, of making complexity analytically manipulable, have not been realized. When one proceeds statistically, one must be careful about the preconditions of statistical analysis. When one combines variables, one can go very high with the number today, but also not arbitrarily high, and usually one assumes that so many variables are needed to fully describe systems that a theory cannot cope with them. There hasn't been a lot of success at this level, although I recently talked to someone at Prognos AG in Basel who said there has been tremendous progress in variable management of predictive models over the last decade. I can't judge that, but that's also just one line of development. Another question is whether, at least as a sociologist, independent of the question of whether one can calculate with measurement precision how complexity is dealt with, one can study facilities of the step function or of generalization with respect to the problem of complexity reduction."
    },
    {
      "type": "paragraph",
      "id": "6df4847e014d9c30",
      "text": "Luhmann, Niklas. Einführung in die Systemtheorie. Herausgegeben von Dirk Baecker. 2. Aufl. Sozialwissenschaften. Heidelberg: Carl-Auer-Verl, 2004, p. 178–179.\n"
    },
    {
      "type": "pagefold",
      "id": "1a120aea2a548443",
      "text": "."
    },
    {
      "type": "markdown",
      "id": "23511c1cc0a9e93e",
      "text": "– https://link.springer.com/chapter/10.1007/978-3-662-09992-6_7"
    },
    {
      "type": "markdown",
      "id": "ca2cbca3bf450c02",
      "text": "– https://d1wqtxts1xzle7.cloudfront.net/45267045/A_History-based_Verification_of_Distribu20160502-15955-16zkt8c-with-cover-page-v2.pdf?Expires=1659961656&Signature=d-~spbfUjoGRsEvk~3Q910NlwiC4uTd900krhMft-zNrMErfQzDWv-G7ry0Hf8EkOeqBEpiHMfH3yu35jiFe7vRhRntpMgigcogJPi5M75FC1s4XKZhxEB07Mzbe2n6JvvHCoTCnPRLNoGxHpWJuycPGbcbXKKIZamrB0uHxycRyyvshl-3y6fxYEz4297KM3qLEksTckZLaLayIvYNTygC1nbGVZzdWa0SwY60UW4tz3wdVwQlFL4hvSgPJEiP72evQQl5WNBipTCOpUQoyUIs627voSIq38iH~KoxJw5PHO7ug-u~NnUTOJ4sHu-baLyVRzGcuXAbsZk6nS7zDWQ__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA#page=160"
    },
    {
      "type": "markdown",
      "id": "a12afec60f5e5676",
      "text": "– https://link.springer.com/article/10.1007/s00502-021-00917-x"
    },
    {
      "type": "paragraph",
      "id": "f75eb5818ad9ca3d",
      "text": "CODESYS Static Analysis [https://store.codesys.com/de/codesys-static-analysis.html page]\n"
    },
    {
      "type": "markdown",
      "id": "65dfe7e5b39ef87c",
      "text": "– https://www.scch.at/software-science/projekte/detail/ak-graph"
    },
    {
      "type": "pagefold",
      "id": "d517671bbcf5ce13",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "cdc9ca21f1a4b20c",
      "text": "– https://dl.acm.org/doi/abs/10.1145/3139903.3139905"
    },
    {
      "type": "markdown",
      "id": "70f38b16e99b8063",
      "text": "– http://shingarov.com/athens/vmil.pdf"
    },
    {
      "type": "paragraph",
      "id": "57e439d6d18a6ed6",
      "text": "Boris"
    },
    {
      "type": "markdown",
      "id": "f7310b2d76000293",
      "text": "The gem5 Simulator: Version 20.0+ [https://arxiv.org/abs/2007.03152 arxiv]\n"
    },
    {
      "type": "markdown",
      "id": "9f487b968cb73bb9",
      "text": "# MachineArithmetic.image"
    },
    {
      "type": "paragraph",
      "id": "0b82cadc1ac55a94",
      "text": "[[Z3 Interface for Smalltalk]]"
    },
    {
      "type": "code",
      "id": "cd7205f47a99635f",
      "text": "proveValid: f\n\t\"Prove that the constraints already asserted into the logical\n   context implies the given formula f, by showing that (not f) is unsatisfiable.\n\n   The receiver context is not modified by this function.\n\n\tRaise an NotValid exception if f is not valid, i.e. if a counterexample was found;\n\tthe counterexample is wrapped in the exception.\"\n\n\t| counterexample |\n\tcounterexample := self findCounterexample: f.\n\tcounterexample isNil ifFalse: [ NotValid signalWithCounterexample: counterexample ]"
    },
    {
      "type": "paragraph",
      "id": "05eb0e1485385334",
      "text": "RefinementParser"
    },
    {
      "type": "code",
      "id": "d5ae045c19f5eb40",
      "text": "PPCompositeParser subclass: #RefinementParser\n\tinstanceVariableNames: 'matchedParen funArg reftB tbase refTop rtype0 rbase rtype rfun'\n\tclassVariableNames: ''\n\tpackage: 'SpriteLang'"
    },
    {
      "type": "paragraph",
      "id": "8b34e1a22461086c",
      "text": "a Test"
    },
    {
      "type": "code",
      "id": "0159fbc8c6835be9",
      "text": "test_abs01\n\tself processString: '\n⟦val cassert : bool[b|b] => int⟧\nlet cassert = (b) => { 0 };\n\n⟦val abs : x:int => int[?]⟧\nlet abs = (x) => {\n  let pos = x >= 0;\n  if (pos) {\n    x\n  } else {\n    0 - x\n  }\n};\n\n⟦val main : int => int⟧\nlet main = (y) => {\n  let fails = 0 <= y;\n  cassert(fails)\n};\n'"
    },
    {
      "type": "paragraph",
      "id": "d8654b352a8e6f33",
      "text": "SMT solvers ⇒ [[Satisfiability Modulo Theories]], [https://en.wikipedia.org/wiki/Satisfiability_modulo_theories wikipedia]"
    },
    {
      "type": "markdown",
      "id": "bb584238191a3871",
      "text": "> SMT can be thought of as a constraint satisfaction problem and thus a certain formalized approach to constraint programming. \n"
    },
    {
      "type": "markdown",
      "id": "886a982f9fedc931",
      "text": "Horn Clause Solvers for [[Program Verification]]. [https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/nbjorner-yurifest.pdf pdf]\n"
    },
    {
      "type": "markdown",
      "id": "53d6dfa1fc746e44",
      "text": "> Automatic program verification and symbolic model checking tools interface with theorem proving technologies that check [[satisfiability]] of formulas. A theme pursued in the past years by the authors of this paper has been to encode symbolic model problems directly as Horn clauses and develop dedicated solvers for Horn clauses. Our solvers are called Duality, HSF, SeaHorn, and μZ and we have devoted considerable attention in recent papers to algorithms for solving Horn clauses. This paper complements these strides as we summarize main useful properties of Horn clauses, illustrate encodings of procedural program verification into Horn clauses and then highlight a number of useful simplification strategies at the level of Horn clauses. Solving Horn clauses amounts to establishing Existential positive Fixed-point Logic formulas, a perspec- tive that was promoted by Blass and Gurevich."
    },
    {
      "type": "pagefold",
      "id": "931891c8ba3efca0",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "c0377602f33f86d0",
      "text": "How does find by example work in the Pharo Finder. [https://chicoary.wordpress.com/2020/05/23/how-does-find-by-example-work-in-the-pharo-finder-englished/ page], [https://news.ycombinator.com/item?id=31465945 hn]"
    },
    {
      "type": "markdown",
      "id": "41347088fa976351",
      "text": "> \t\n\t\nmncharity 77 days ago | root | parent | next [–]\n\n> the philosophical break between the two paradigms and one which I spend a lot of time on [...] I wonder if it’s more about balancing the two modes.\n\nI don't see the break? \"Clay\" tooling exists for \"industrial\" code, but as secret sauce, and jig kludgery, and various other \"making this more broadly available is not in/of our interest\". \"Clay\"'s rejection of \"industrial\" has seemed more resource-starved exploit-not-explore group-think. Smalltalk/forth/etc audacious-scope rewrite-the-world efforts have seemed more \"remake the world\" than \"to force us to remake ourselves\". Try imaging a forth implementation effort that said \"ok, we have bootstrap... so now the next obvious steps are supporting PICs and multiple dispatch and template jit, WAM and BEAM vms, linking Z3 solver, DHM type inference, ...\". So perhaps rather than an inherent break between modes, and balancing to be done, there's a lack of available power, and of interests/resources aligned with ramping it.\n\nBut then, I'd like a programming environment which provides an powerful environment for making engineering tradeoffs, rather than ones which hardwire in very dramatic ones. I expect such an environment, when it finally exists, won't be hard to recognize. As, for example, basic reimplementation of existing modern languages, with their big test suites, libraries, community repos, specs sometimes transliteratable directly into code, code-as-documentation and highly-investment-in optimization, is a natural forcing-factor exercise for such an environment. So when you see a small team spewing new language implementations... maybe we've at long last hit phase transition. And if one can't easily manage that, in bulk, even with all that leverage... then it's not a very powerful environment, is it? "
    },
    {
      "type": "pagefold",
      "id": "47fcade622d9169c",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "793fe4401d70365d",
      "text": "Re: Slang for Cuis (WIP, experimental). [http://forum.world.st/Squeak-Pharo-VM-fork-history-was-RE-Pharo-dev-Squeak-and-Pharo-speed-differences-td5116740i20.html#a5116887 page]"
    },
    {
      "type": "paragraph",
      "id": "60eb60e46d297f3c",
      "text": "[[Smalltalk]]"
    },
    {
      "type": "paragraph",
      "id": "a426a1b8bed91b12",
      "text": "[[Magic Phone]]"
    },
    {
      "type": "paragraph",
      "id": "046c28ad8aaab153",
      "text": "Pharo Zeroconf Script. [https://get.pharo.org site]\n\n"
    },
    {
      "type": "markdown",
      "id": "3f8d359e0daa6204",
      "text": "# Z3AST"
    },
    {
      "type": "paragraph",
      "id": "46396d11ea9bc169",
      "text": "In Z3, expressions, sorts and declarations are called ASTs. ASTs are directed acyclic graphs. Every expression has a sort. Send #sort to get the sort of an expression.\n\nWhen we get an AST handle from Z3, we look at the sort, and create an instance of the concrete subclass (BitVector, Bool etc) appropriate for the sort.\n\nIn addition to sorts, ASTs also have kinds: VAR, NUMERAL, APP etc.  This becomes tricky because in Smalltalk this would correspond to something like a two-dimensional class membership, which we don't have.  So to send messages understood by AST of particular kinds (e.g. arity is a concept specific to function applications), we can downcast an AST to its kind by sending #asKind, and back by sending #asAST."
    },
    {
      "type": "pagefold",
      "id": "49ce7cd6bc42a417",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "a06e73733088436b",
      "text": "– https://www.scch.at/scch/presse-medien/detail/software-analyse-habt-in-programmen-verstecktes-wissen"
    },
    {
      "type": "markdown",
      "id": "299c7fcdccc139cc",
      "text": "– https://d-nb.info/968052150/34"
    },
    {
      "type": "markdown",
      "id": "9de2f56ed523e003",
      "text": "– https://d-nb.info/1044451912/34"
    },
    {
      "type": "paragraph",
      "id": "0599a31d2670ecee",
      "text": "GRAphe Fonctionnel de Commande Etape et Transitions (GRAFCET)"
    },
    {
      "type": "markdown",
      "id": "fff722d44a954941",
      "text": "– https://www.sps-forum.de/threads/suche-etwas-seltsame-sps.13382/"
    },
    {
      "type": "markdown",
      "id": "61551793910c8c4c",
      "text": "PLC Checker from Itris Automation. [https://www.automation.com/en-us/products/product03/itris-automation-announces-plc-checker-now-with-pl page]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2022-08-08",
        "story": []
      },
      "date": 1659942961371
    },
    {
      "item": {
        "type": "factory",
        "id": "71d7e497aeb8db38"
      },
      "id": "71d7e497aeb8db38",
      "type": "add",
      "date": 1659942962935
    },
    {
      "type": "edit",
      "id": "71d7e497aeb8db38",
      "item": {
        "type": "paragraph",
        "id": "71d7e497aeb8db38",
        "text": " \"proof\"\nSpencer Brown uses demonstration \nProof is when you step outside of your computational system and we didn't do that \nso proof isn't an appropriate word \nbut you know Dirk mentioned that the mark is a combination of both thinking about implication and negation \nwe tried to eliminate thinking about all those concepts and just looked at structural patterning \nthat was a demonstration that the structural pattern you can make go away\n"
      },
      "date": 1659942965887
    },
    {
      "type": "edit",
      "id": "71d7e497aeb8db38",
      "item": {
        "type": "paragraph",
        "id": "71d7e497aeb8db38",
        "text": "\"[[Proof]]\"\nSpencer Brown uses demonstration \nProof is when you step outside of your computational system and we didn't do that \nso proof isn't an appropriate word \nbut you know Dirk mentioned that the mark is a combination of both thinking about implication and negation \nwe tried to eliminate thinking about all those concepts and just looked at structural patterning \nthat was a demonstration that the structural pattern you can make go away\n"
      },
      "date": 1659947258311
    },
    {
      "type": "fork",
      "date": 1659947323101
    },
    {
      "item": {
        "type": "factory",
        "id": "cbd2118f03811ef7"
      },
      "id": "cbd2118f03811ef7",
      "type": "add",
      "after": "71d7e497aeb8db38",
      "date": 1659947620715
    },
    {
      "type": "edit",
      "id": "cbd2118f03811ef7",
      "item": {
        "type": "pagefold",
        "id": "cbd2118f03811ef7",
        "text": "~"
      },
      "date": 1659947624813
    },
    {
      "item": {
        "type": "factory",
        "id": "aa13aae3ea1ef914"
      },
      "id": "aa13aae3ea1ef914",
      "type": "add",
      "after": "cbd2118f03811ef7",
      "date": 1659947626435
    },
    {
      "type": "edit",
      "id": "aa13aae3ea1ef914",
      "item": {
        "type": "paragraph",
        "id": "aa13aae3ea1ef914",
        "text": "\"pathological\" "
      },
      "date": 1659947630837
    },
    {
      "type": "edit",
      "id": "aa13aae3ea1ef914",
      "item": {
        "type": "paragraph",
        "id": "aa13aae3ea1ef914",
        "text": "\"pathological\" Halting problem"
      },
      "date": 1659947644308
    },
    {
      "type": "edit",
      "id": "aa13aae3ea1ef914",
      "item": {
        "type": "paragraph",
        "id": "aa13aae3ea1ef914",
        "text": "\"pathological\" ⇒ [[Halting Problem]]"
      },
      "date": 1659947666015
    },
    {
      "type": "edit",
      "id": "aa13aae3ea1ef914",
      "item": {
        "type": "paragraph",
        "id": "aa13aae3ea1ef914",
        "text": "\"pathological\" ⇒ [[Halting Problem]] [https://en.wikipedia.org/wiki/Halting_problem wikipedia]"
      },
      "date": 1659947767185
    },
    {
      "item": {
        "type": "factory",
        "id": "05568c6c597d59ae"
      },
      "id": "05568c6c597d59ae",
      "type": "add",
      "after": "aa13aae3ea1ef914",
      "date": 1659947771847
    },
    {
      "type": "edit",
      "id": "05568c6c597d59ae",
      "item": {
        "type": "graphviz",
        "id": "05568c6c597d59ae",
        "text": "DOT FROM lambda-browsing"
      },
      "date": 1659947783828
    },
    {
      "type": "edit",
      "id": "aa13aae3ea1ef914",
      "item": {
        "type": "paragraph",
        "id": "aa13aae3ea1ef914",
        "text": "\"pathological\" ⇒ [[Halting Problem]], [https://en.wikipedia.org/wiki/Halting_problem wikipedia]"
      },
      "date": 1659947798468
    },
    {
      "item": {
        "type": "factory",
        "id": "01c83461dd48c985"
      },
      "id": "01c83461dd48c985",
      "type": "add",
      "after": "05568c6c597d59ae",
      "date": 1659947939110
    },
    {
      "type": "remove",
      "id": "01c83461dd48c985",
      "date": 1659947945493
    },
    {
      "item": {
        "type": "factory",
        "id": "b5453a32efbc0cc5"
      },
      "id": "b5453a32efbc0cc5",
      "type": "add",
      "after": "05568c6c597d59ae",
      "date": 1659947947403
    },
    {
      "type": "edit",
      "id": "b5453a32efbc0cc5",
      "item": {
        "type": "paragraph",
        "id": "b5453a32efbc0cc5",
        "text": "The classic PLC programming languages used so far, such as instruction list, ladder diagram or function block diagram, are reaching their limits. Users demand uniform, manufacturer-independent language concepts, higher programming languages and development tools, as they have been common in the PC world for a long time."
      },
      "date": 1659947949437
    },
    {
      "type": "edit",
      "id": "b5453a32efbc0cc5",
      "item": {
        "type": "paragraph",
        "id": "b5453a32efbc0cc5",
        "text": "The classic PLC programming languages used so far, such as [[instruction list]], [[ladder diagram]] or [[function block diagram]], are reaching their limits. Users demand uniform, manufacturer-independent language concepts, higher programming languages and development tools, as they have been common in the PC world for a long time."
      },
      "date": 1659947989044
    },
    {
      "type": "edit",
      "id": "b5453a32efbc0cc5",
      "item": {
        "type": "paragraph",
        "id": "b5453a32efbc0cc5",
        "text": "The classic PLC programming languages used so far, such as [[instruction list]], [[Ladder Diagram]] or [[function block diagram]], are reaching their limits. Users demand uniform, manufacturer-independent language concepts, higher programming languages and development tools, as they have been common in the PC world for a long time."
      },
      "date": 1659948018795
    },
    {
      "item": {
        "type": "factory",
        "id": "9c373875fea8e26e"
      },
      "id": "9c373875fea8e26e",
      "type": "add",
      "after": "b5453a32efbc0cc5",
      "date": 1659948488924
    },
    {
      "type": "edit",
      "id": "9c373875fea8e26e",
      "item": {
        "type": "markdown",
        "id": "9c373875fea8e26e",
        "text": "# [[Programmable Logic Controllers]]"
      },
      "date": 1659948497601
    },
    {
      "id": "9c373875fea8e26e",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5"
      ],
      "date": 1659948499970
    },
    {
      "item": {
        "type": "factory",
        "id": "be214c74e406d97e"
      },
      "id": "be214c74e406d97e",
      "type": "add",
      "after": "b5453a32efbc0cc5",
      "date": 1659948893107
    },
    {
      "type": "edit",
      "id": "be214c74e406d97e",
      "item": {
        "type": "paragraph",
        "id": "be214c74e406d97e",
        "text": "Karl-Heinz John und Michael Tiegelkamp, „Die Programmiersprachen der IEC 61131-3“, in SPS-Programmierung mit IEC 61131-3: Konzepte und Programmiersprachen, Anforderungen an Programmiersysteme, Entscheidungshilfen, hg. von Michael Tiegelkamp und Karl Heinz John, VDI-Buch (Berlin, Heidelberg: Springer, 2009), 103–211, https://doi.org/10.1007/978-3-642-00269-4_4."
      },
      "date": 1659948898758
    },
    {
      "item": {
        "type": "factory",
        "id": "677702161df6125c"
      },
      "id": "677702161df6125c",
      "type": "add",
      "after": "be214c74e406d97e",
      "date": 1659948908590
    },
    {
      "type": "edit",
      "id": "677702161df6125c",
      "item": {
        "type": "paragraph",
        "id": "677702161df6125c",
        "text": "This book aims to provide an understandable introduction to the concepts and languages of the IEC 61131 standard. Simple examples are used to explain the ideas and application of the new PLC programming languages. A larger example program summarizes the results of each section again. The book is intended as an introduction and explanatory aid for people in training and practice who want to learn about and use the possibilities of the new standard. The book describes the methodology of the standard from a manufacturer-independent point of view. Special characteristics and variants of individual programming systems should be reserved for the respective manuals. It assumes little knowledge of personal computers and basic knowledge of PLC technology (see [Berger-03] or [Berger-06]). Even experienced PLC programmers will find information here that will make their work with these programming systems easier. The book emphasizes describing the standard itself rather than the corresponding variants of programming systems on the market. Vocational students and students are provided with a reference book that systematically facilitates their learning of the new programming standard. With the help of the \"Purchasing Advisor\", the reader can additionally evaluate PLC programming systems himself and individually, see the enclosed CD."
      },
      "date": 1659948910574
    },
    {
      "item": {
        "type": "factory",
        "id": "1ba1689683992bc4"
      },
      "id": "1ba1689683992bc4",
      "type": "add",
      "after": "677702161df6125c",
      "date": 1659948985375
    },
    {
      "type": "edit",
      "id": "1ba1689683992bc4",
      "item": {
        "type": "pagefold",
        "id": "1ba1689683992bc4",
        "text": "~"
      },
      "date": 1659948988087
    },
    {
      "item": {
        "type": "factory",
        "id": "1fb0a4b9455d6bfd"
      },
      "id": "1fb0a4b9455d6bfd",
      "type": "add",
      "after": "1ba1689683992bc4",
      "date": 1659948989708
    },
    {
      "type": "edit",
      "id": "1fb0a4b9455d6bfd",
      "item": {
        "type": "paragraph",
        "id": "1fb0a4b9455d6bfd",
        "text": "[Berger-03] Hans Berger „Automatisieren mit STEP 7 in KOP und FUP“ Speicherprogrammierbare Steuerungen SIMATIC S7-300/400 Hrsg.: Siemens-Aktiengesellschaft, Berlin München, Publicis-MCD-Verlag Erlangen 2003, ISBN 978-3895782190 [Berger-06] Hans Berger „Automatisieren mit STEP 7 in AWL und SCL“ Speicherprogrammierbare Steuerungen SIMATIC S7-300/400 Hrsg.: Siemens-Aktiengesellschaft, Berlin München, Publicis-MCD-Verlag Erlangen 2003, ISBN 978-3895782800"
      },
      "date": 1659948992860
    },
    {
      "type": "edit",
      "id": "1fb0a4b9455d6bfd",
      "item": {
        "type": "paragraph",
        "id": "1fb0a4b9455d6bfd",
        "text": "[Berger-03] Hans Berger „Automatisieren mit STEP 7 in KOP und FUP“ Speicherprogrammierbare Steuerungen SIMATIC S7-300/400 Hrsg.: Siemens-Aktiengesellschaft, Berlin München, Publicis-MCD-Verlag Erlangen 2003, ISBN 978-3895782190 "
      },
      "date": 1659948997512
    },
    {
      "type": "add",
      "id": "b55a927d7cced091",
      "item": {
        "type": "paragraph",
        "id": "b55a927d7cced091",
        "text": "[Berger-06] Hans Berger „Automatisieren mit STEP 7 in AWL und SCL“ Speicherprogrammierbare Steuerungen SIMATIC S7-300/400 Hrsg.: Siemens-Aktiengesellschaft, Berlin München, Publicis-MCD-Verlag Erlangen 2003, ISBN 978-3895782800"
      },
      "after": "1fb0a4b9455d6bfd",
      "date": 1659948998326
    },
    {
      "type": "edit",
      "id": "677702161df6125c",
      "item": {
        "type": "paragraph",
        "id": "677702161df6125c",
        "text": "This book aims to provide an understandable introduction to the concepts and languages of the IEC 61131 standard. Simple examples are used to explain the ideas and application of the new PLC programming languages. A larger example program summarizes the results of each section again. The book is intended as an introduction and explanatory aid for people in training and practice who want to learn about and use the possibilities of the new standard. The book describes the methodology of the standard from a manufacturer-independent point of view. Special characteristics and variants of individual programming systems should be reserved for the respective manuals. "
      },
      "date": 1659949146168
    },
    {
      "type": "add",
      "id": "7c27bf5868c45243",
      "item": {
        "type": "paragraph",
        "id": "7c27bf5868c45243",
        "text": "It assumes little knowledge of personal computers and basic knowledge of PLC technology (see [Berger-03] or [Berger-06]). Even experienced PLC programmers will find information here that will make their work with these programming systems easier. The book emphasizes describing the standard itself rather than the corresponding variants of programming systems on the market. Vocational students and students are provided with a reference book that systematically facilitates their learning of the new programming standard. With the help of the \"Purchasing Advisor\", the reader can additionally evaluate PLC programming systems himself and individually, see the enclosed CD."
      },
      "after": "677702161df6125c",
      "date": 1659949147208
    },
    {
      "item": {
        "type": "factory",
        "id": "d2635aa820dc243b"
      },
      "id": "d2635aa820dc243b",
      "type": "add",
      "after": "b55a927d7cced091",
      "date": 1659949266490
    },
    {
      "type": "edit",
      "id": "d2635aa820dc243b",
      "item": {
        "type": "paragraph",
        "id": "d2635aa820dc243b",
        "text": "https://www.oth-aw.de/files/oth-aw/Forschung/Forschungsprojekte/OTH_mind/Skript_PI.pdf"
      },
      "date": 1659949269130
    },
    {
      "type": "edit",
      "id": "d2635aa820dc243b",
      "item": {
        "type": "markdown",
        "id": "d2635aa820dc243b",
        "text": "https://www.oth-aw.de/files/oth-aw/Forschung/Forschungsprojekte/OTH_mind/Skript_PI.pdf"
      },
      "date": 1659949270137
    },
    {
      "type": "edit",
      "id": "d2635aa820dc243b",
      "item": {
        "type": "markdown",
        "id": "d2635aa820dc243b",
        "text": "Prof. Dr. Wolfgang Bock [https://www.oth-aw.de/files/oth-aw/Forschung/Forschungsprojekte/OTH_mind/Skript_PI.pdf pdf]"
      },
      "date": 1659949296288
    },
    {
      "type": "edit",
      "id": "d2635aa820dc243b",
      "item": {
        "type": "markdown",
        "id": "d2635aa820dc243b",
        "text": "Prof. Dr. Wolfgang Bock, Grundlagen der SPS-Programmierung /Prozessinformatik. [https://www.oth-aw.de/files/oth-aw/Forschung/Forschungsprojekte/OTH_mind/Skript_PI.pdf pdf]"
      },
      "date": 1659949343726
    },
    {
      "type": "edit",
      "id": "d2635aa820dc243b",
      "item": {
        "type": "markdown",
        "id": "d2635aa820dc243b",
        "text": "Prof. Dr. Wolfgang Bock (2017), Grundlagen der SPS-Programmierung /Prozessinformatik. [https://www.oth-aw.de/files/oth-aw/Forschung/Forschungsprojekte/OTH_mind/Skript_PI.pdf pdf]"
      },
      "date": 1659949352638
    },
    {
      "type": "edit",
      "id": "d2635aa820dc243b",
      "item": {
        "type": "markdown",
        "id": "d2635aa820dc243b",
        "text": "Prof. Dr. Wolfgang Bock (2017), Grundlagen der SPS-Programmierung /Prozessinformatik. [https://www.oth-aw.de/files/oth-aw/Forschung/Forschungsprojekte/OTH_mind/Skript_PI.pdf pdf] (STAND: 9. JANUAR 2018)"
      },
      "date": 1659949384820
    },
    {
      "type": "edit",
      "id": "d2635aa820dc243b",
      "item": {
        "type": "markdown",
        "id": "d2635aa820dc243b",
        "text": "Prof. Dr. Wolfgang Bock (2017), Grundlagen der SPS-Programmierung /Prozessinformatik. [https://www.oth-aw.de/files/oth-aw/Forschung/Forschungsprojekte/OTH_mind/Skript_PI.pdf pdf] (Stand: 9. Januar 2018\n)"
      },
      "date": 1659949396304
    },
    {
      "type": "edit",
      "id": "d2635aa820dc243b",
      "item": {
        "type": "markdown",
        "id": "d2635aa820dc243b",
        "text": "Prof. Dr. Wolfgang Bock (2017), Grundlagen der SPS-Programmierung /Prozessinformatik. [https://www.oth-aw.de/files/oth-aw/Forschung/Forschungsprojekte/OTH_mind/Skript_PI.pdf pdf] (Stand: 9. Januar 2018)"
      },
      "date": 1659949400918
    },
    {
      "item": {
        "type": "factory",
        "id": "a70b186fd7222e62"
      },
      "id": "a70b186fd7222e62",
      "type": "add",
      "after": "d2635aa820dc243b",
      "date": 1659949779511
    },
    {
      "type": "edit",
      "id": "a70b186fd7222e62",
      "item": {
        "type": "pagefold",
        "id": "a70b186fd7222e62",
        "text": "."
      },
      "date": 1659949784256
    },
    {
      "item": {
        "type": "factory",
        "id": "6a2518641487950b"
      },
      "id": "6a2518641487950b",
      "type": "add",
      "after": "a70b186fd7222e62",
      "date": 1659949787306
    },
    {
      "type": "edit",
      "id": "6a2518641487950b",
      "item": {
        "type": "paragraph",
        "id": "6a2518641487950b",
        "text": "https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/abs/ackermann-w-solvable-cases-of-the-decision-problem-studies-in-logic-and-the-foundations-of-mathematics-northholland-publishing-company-amsterdam1954-viii-114-pp/EA7768F069801A1A1201637671117DE0"
      },
      "date": 1659949790198
    },
    {
      "type": "edit",
      "id": "6a2518641487950b",
      "item": {
        "type": "markdown",
        "id": "6a2518641487950b",
        "text": "https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/abs/ackermann-w-solvable-cases-of-the-decision-problem-studies-in-logic-and-the-foundations-of-mathematics-northholland-publishing-company-amsterdam1954-viii-114-pp/EA7768F069801A1A1201637671117DE0"
      },
      "date": 1659949791200
    },
    {
      "type": "edit",
      "id": "6a2518641487950b",
      "item": {
        "type": "markdown",
        "id": "6a2518641487950b",
        "text": "W. ACKERMANN. Solvable cases of the decision problem. Studies in logic and the foundations of mathematics. North-Holland Publishing Company, Amsterdam 1954, VIII + 114 pp. [https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/abs/ackermann-w-solvable-cases-of-the-decision-problem-studies-in-logic-and-the-foundations-of-mathematics-northholland-publishing-company-amsterdam1954-viii-114-pp/EA7768F069801A1A1201637671117DE0 page]"
      },
      "date": 1659949918745
    },
    {
      "type": "edit",
      "id": "be214c74e406d97e",
      "item": {
        "type": "markdown",
        "id": "be214c74e406d97e",
        "text": "Karl-Heinz John und Michael Tiegelkamp, „Die Programmiersprachen der IEC 61131-3“, in SPS-Programmierung mit IEC 61131-3: Konzepte und Programmiersprachen, Anforderungen an Programmiersysteme, Entscheidungshilfen, hg. von Michael Tiegelkamp und Karl Heinz John, VDI-Buch (Berlin, Heidelberg: Springer, 2009), 103–211, https://doi.org/10.1007/978-3-642-00269-4_4."
      },
      "date": 1659951761375
    },
    {
      "type": "edit",
      "id": "be214c74e406d97e",
      "item": {
        "type": "markdown",
        "id": "be214c74e406d97e",
        "text": "Karl-Heinz John und Michael Tiegelkamp, „Die Programmiersprachen der IEC 61131-3“, in SPS-Programmierung mit IEC 61131-3: Konzepte und Programmiersprachen, Anforderungen an Programmiersysteme, Entscheidungshilfen, hg. von Michael Tiegelkamp und Karl Heinz John, VDI-Buch (Berlin, Heidelberg: Springer, 2009), 103–211, https://doi.org/10.1007/978-3-642-00269-4_4 doi]."
      },
      "date": 1659951772815
    },
    {
      "type": "edit",
      "id": "be214c74e406d97e",
      "item": {
        "type": "markdown",
        "id": "be214c74e406d97e",
        "text": "Karl-Heinz John und Michael Tiegelkamp, „Die Programmiersprachen der IEC 61131-3“, in SPS-Programmierung mit IEC 61131-3: Konzepte und Programmiersprachen, Anforderungen an Programmiersysteme, Entscheidungshilfen, hg. von Michael Tiegelkamp und Karl Heinz John, VDI-Buch (Berlin, Heidelberg: Springer, 2009), 103–211, [https://doi.org/10.1007/978-3-642-00269-4_4 doi]."
      },
      "date": 1659951779104
    },
    {
      "item": {
        "type": "factory",
        "id": "df06894f45f6808e"
      },
      "id": "df06894f45f6808e",
      "type": "add",
      "after": "6a2518641487950b",
      "date": 1659953199176
    },
    {
      "type": "edit",
      "id": "df06894f45f6808e",
      "item": {
        "type": "paragraph",
        "id": "df06894f45f6808e",
        "text": "– https://www.sciencedirect.com/science/article/pii/S1571066109004368"
      },
      "date": 1659953201786
    },
    {
      "type": "edit",
      "id": "df06894f45f6808e",
      "item": {
        "type": "markdown",
        "id": "df06894f45f6808e",
        "text": "– https://www.sciencedirect.com/science/article/pii/S1571066109004368"
      },
      "date": 1659953203041
    },
    {
      "item": {
        "type": "factory",
        "id": "8d3b7bb5592b011c"
      },
      "id": "8d3b7bb5592b011c",
      "type": "add",
      "after": "df06894f45f6808e",
      "date": 1659954035146
    },
    {
      "type": "edit",
      "id": "8d3b7bb5592b011c",
      "item": {
        "type": "html",
        "id": "8d3b7bb5592b011c",
        "text": "<img\n  width=\"100%\"\n  src=\"https://images-na.ssl-images-amazon.com/images/I/81KQgK4uqQL.jpg\"\n>"
      },
      "date": 1659954054256
    },
    {
      "id": "8d3b7bb5592b011c",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5",
        "be214c74e406d97e",
        "677702161df6125c",
        "7c27bf5868c45243",
        "1ba1689683992bc4",
        "1fb0a4b9455d6bfd",
        "b55a927d7cced091",
        "d2635aa820dc243b",
        "a70b186fd7222e62",
        "6a2518641487950b",
        "8d3b7bb5592b011c",
        "df06894f45f6808e"
      ],
      "date": 1659954057104
    },
    {
      "item": {
        "type": "factory",
        "id": "b1e8379ff3a26182"
      },
      "id": "b1e8379ff3a26182",
      "type": "add",
      "after": "df06894f45f6808e",
      "date": 1659954119982
    },
    {
      "type": "edit",
      "id": "b1e8379ff3a26182",
      "item": {
        "type": "markdown",
        "id": "b1e8379ff3a26182",
        "text": "> In order to solve the satisfiability or tautology problem, each path in the OBDD has to be checked for consistency, with respect to the underlying equational theory. A path represents a conjunction of (negated) equations, on which the aforementioned decision procedures can be applied. All inconsistent paths can be removed, resulting in an OBDD with only consistent paths. However, due to sharing subterms, an OBDD can have exponentially many paths, so still there is a computational bottleneck. In the Encoding method these steps are reversed. First the formula is transformed to a purely propositional formula. In this translation, facts from the equational theory (e.g. congruence of functions, transitivity of equality and orderings) are encoded into the formula. Then a finite model property is used to obtain a finite upperbound on the cardinality of the model. Finally, variables that range over a set of size n are encoded by log(n) propositional variables. The resulting formula can be checked for satisfiability with any existing SAT-technique, for instance based on resolution [7] or on BDDs [5]. An early example is Ackermann’s reduction [1], by which second order variables can be eliminated. More optimal versions are in [10,17,6]."
      },
      "date": 1659954124076
    },
    {
      "type": "edit",
      "id": "df06894f45f6808e",
      "item": {
        "type": "markdown",
        "id": "df06894f45f6808e",
        "text": "\nBADBAN, Bahareh, 2009. A Term Rewriting Technique for Decision Graphs. Electronic Notes in Theoretical Computer Science. Online. 6 November 2009. Vol. 253, no. 4, p. 39–54. [Accessed 8 August 2022]. DOI 10.1016/j.entcs.2009.10.016. We provide an automatic verification for a fragment of FOL quantifier-free logic with zero, successor and equality. \n"
      },
      "date": 1659954156085
    },
    {
      "type": "add",
      "id": "873ae88f9d38dd96",
      "item": {
        "type": "markdown",
        "id": "873ae88f9d38dd96",
        "text": "> We use BDD representation of such formulas and to verify them, we first introduce a (complete) term rewrite system to generate an equivalent Ordered (0,S,=)-BDD from any given (0,S,=)-BDD. Having the ordered representation of the BDDs, one can verify the original formula in constant time. Then, to have this transformation automatically, we provide an algorithm which will do the whole process.\n– https://www.sciencedirect.com/science/article/pii/S1571066109004368"
      },
      "after": "df06894f45f6808e",
      "date": 1659954156618
    },
    {
      "type": "edit",
      "id": "b1e8379ff3a26182",
      "item": {
        "type": "markdown",
        "id": "b1e8379ff3a26182",
        "text": "In order to solve the satisfiability or tautology problem, each path in the OBDD has to be checked for consistency, with respect to the underlying equational theory. A path represents a conjunction of (negated) equations, on which the aforementioned decision procedures can be applied. All inconsistent paths can be removed, resulting in an OBDD with only consistent paths. However, due to sharing subterms, an OBDD can have exponentially many paths, so still there is a computational bottleneck. In the Encoding method these steps are reversed. First the formula is transformed to a purely propositional formula. In this translation, facts from the equational theory (e.g. congruence of functions, transitivity of equality and orderings) are encoded into the formula. Then a finite model property is used to obtain a finite upperbound on the cardinality of the model. Finally, variables that range over a set of size n are encoded by log(n) propositional variables. The resulting formula can be checked for satisfiability with any existing SAT-technique, for instance based on resolution [7] or on BDDs [5]. An early example is Ackermann’s reduction [1], by which second order variables can be eliminated. More optimal versions are in [10,17,6]."
      },
      "date": 1659954164573
    },
    {
      "type": "edit",
      "id": "873ae88f9d38dd96",
      "item": {
        "type": "markdown",
        "id": "873ae88f9d38dd96",
        "text": "> We use BDD representation of such formulas and to verify them, we first introduce a (complete) term rewrite system to generate an equivalent Ordered (0,S,=)-BDD from any given (0,S,=)-BDD. Having the ordered representation of the BDDs, one can verify the original formula in constant time. Then, to have this transformation automatically, we provide an algorithm which will do the whole process.\n"
      },
      "date": 1659954173203
    },
    {
      "type": "edit",
      "id": "df06894f45f6808e",
      "item": {
        "type": "markdown",
        "id": "df06894f45f6808e",
        "text": "BADBAN, Bahareh, 2009. A Term Rewriting Technique for Decision Graphs. Electronic Notes in Theoretical Computer Science. Online. 6 November 2009. Vol. 253, no. 4, p. 39–54. [Accessed 8 August 2022]. DOI 10.1016/j.entcs.2009.10.016. [https://www.sciencedirect.com/science/article/pii/S1571066109004368 page] We provide an automatic verification for a fragment of FOL quantifier-free logic with zero, successor and equality. \n"
      },
      "date": 1659954183056
    },
    {
      "type": "edit",
      "id": "df06894f45f6808e",
      "item": {
        "type": "markdown",
        "id": "df06894f45f6808e",
        "text": "BADBAN, Bahareh, 2009. A Term Rewriting Technique for Decision Graphs. Electronic Notes in Theoretical Computer Science. Online. 6 November 2009. Vol. 253, no. 4, p. 39–54. [Accessed 8 August 2022]. DOI 10.1016/j.entcs.2009.10.016. [https://www.sciencedirect.com/science/article/pii/S1571066109004368 page] "
      },
      "date": 1659954189504
    },
    {
      "type": "edit",
      "id": "873ae88f9d38dd96",
      "item": {
        "type": "markdown",
        "id": "873ae88f9d38dd96",
        "text": "> We provide an automatic verification for a fragment of FOL quantifier-free logic with zero, successor and equality. We use BDD representation of such formulas and to verify them, we first introduce a (complete) term rewrite system to generate an equivalent Ordered (0,S,=)-BDD from any given (0,S,=)-BDD. Having the ordered representation of the BDDs, one can verify the original formula in constant time. Then, to have this transformation automatically, we provide an algorithm which will do the whole process.\n"
      },
      "date": 1659954194741
    },
    {
      "type": "edit",
      "id": "df06894f45f6808e",
      "item": {
        "type": "markdown",
        "id": "df06894f45f6808e",
        "text": "BADBAN, Bahareh, 2009. A Term Rewriting Technique for Decision Graphs. Electronic Notes in Theoretical Computer Science. Online. 6 November 2009. Vol. 253, no. 4, p. 39–54. [https://www.sciencedirect.com/science/article/pii/S1571066109004368?via%3Dihub doi]"
      },
      "date": 1659954225887
    },
    {
      "type": "edit",
      "id": "df06894f45f6808e",
      "item": {
        "type": "markdown",
        "id": "df06894f45f6808e",
        "text": "BADBAN, Bahareh, 2009. A Term Rewriting Technique for Decision Graphs. Electronic Notes in Theoretical Computer Science. Online. 6 November 2009. Vol. 253, no. 4, p. 39–54. [https://www.sciencedirect.com/science/article/pii/S1571066109004368 doi]"
      },
      "date": 1659954245769
    },
    {
      "item": {
        "type": "factory",
        "id": "ac89530f427927d0"
      },
      "id": "ac89530f427927d0",
      "type": "add",
      "after": "b1e8379ff3a26182",
      "date": 1659954436365
    },
    {
      "type": "edit",
      "id": "ac89530f427927d0",
      "item": {
        "type": "paragraph",
        "id": "ac89530f427927d0",
        "text": "[[Wilhelm Ackermann]]"
      },
      "date": 1659954442750
    },
    {
      "id": "ac89530f427927d0",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5",
        "be214c74e406d97e",
        "677702161df6125c",
        "7c27bf5868c45243",
        "1ba1689683992bc4",
        "1fb0a4b9455d6bfd",
        "b55a927d7cced091",
        "d2635aa820dc243b",
        "a70b186fd7222e62",
        "ac89530f427927d0",
        "6a2518641487950b",
        "8d3b7bb5592b011c",
        "df06894f45f6808e",
        "873ae88f9d38dd96",
        "b1e8379ff3a26182"
      ],
      "date": 1659954881350
    },
    {
      "item": {
        "type": "factory",
        "id": "f99bda8b39b67c17"
      },
      "id": "f99bda8b39b67c17",
      "type": "add",
      "after": "b1e8379ff3a26182",
      "date": 1659955092423
    },
    {
      "type": "edit",
      "id": "f99bda8b39b67c17",
      "item": {
        "type": "pagefold",
        "id": "f99bda8b39b67c17",
        "text": "Komplexität"
      },
      "date": 1659955104170
    },
    {
      "item": {
        "type": "factory",
        "id": "2880bb90b217eaa0"
      },
      "id": "2880bb90b217eaa0",
      "type": "add",
      "after": "f99bda8b39b67c17",
      "date": 1659955141489
    },
    {
      "type": "edit",
      "id": "2880bb90b217eaa0",
      "item": {
        "type": "paragraph",
        "id": "2880bb90b217eaa0",
        "text": "which is why we talk less about complexity today than we did in the 1950s and 1960s. Perhaps this is simply because the hopes of finding a conceptual management of complexity, that is, of making complexity analytically manipulable, have not been realized. When one proceeds statistically, one must be careful about the preconditions of statistical analysis. When one combines variables, one can go very high with the number today, but also not arbitrarily high, and usually one assumes that so many variables are needed to fully describe systems that a theory cannot cope with them. There hasn't been a lot of success at this level, although I recently talked to someone at Prognos AG in Basel who said there has been tremendous progress in variable management of predictive models over the last decade. I can't judge that, but that's also just one line of development. Another question is whether, at least as a sociologist, independent of the question of whether one can calculate with measurement precision how complexity is dealt with, one can study facilities of the step function or of generalization with respect to the problem of complexity reduction."
      },
      "date": 1659955143358
    },
    {
      "type": "edit",
      "id": "2880bb90b217eaa0",
      "item": {
        "type": "paragraph",
        "id": "2880bb90b217eaa0",
        "text": "I would like to add a few thoughts that go beyond the scope of this discussion and at the same time try to explain why we talk less about complexity today than we did in the 1950s and 1960s. Perhaps this is simply because the hopes of finding a conceptual management of complexity, that is, of making complexity analytically manipulable, have not been realized. When one proceeds statistically, one must be careful about the preconditions of statistical analysis. When one combines variables, one can go very high with the number today, but also not arbitrarily high, and usually one assumes that so many variables are needed to fully describe systems that a theory cannot cope with them. There hasn't been a lot of success at this level, although I recently talked to someone at Prognos AG in Basel who said there has been tremendous progress in variable management of predictive models over the last decade. I can't judge that, but that's also just one line of development. Another question is whether, at least as a sociologist, independent of the question of whether one can calculate with measurement precision how complexity is dealt with, one can study facilities of the step function or of generalization with respect to the problem of complexity reduction."
      },
      "date": 1659955187441
    },
    {
      "item": {
        "type": "factory",
        "id": "6df4847e014d9c30"
      },
      "id": "6df4847e014d9c30",
      "type": "add",
      "after": "2880bb90b217eaa0",
      "date": 1659955199933
    },
    {
      "type": "edit",
      "id": "6df4847e014d9c30",
      "item": {
        "type": "paragraph",
        "id": "6df4847e014d9c30",
        "text": "Luhmann, Niklas. Einführung in die Systemtheorie. Herausgegeben von Dirk Baecker. 2. Aufl. Sozialwissenschaften. Heidelberg: Carl-Auer-Verl, 2004.\n"
      },
      "date": 1659955201982
    },
    {
      "type": "edit",
      "id": "6df4847e014d9c30",
      "item": {
        "type": "paragraph",
        "id": "6df4847e014d9c30",
        "text": "Luhmann, Niklas. Einführung in die Systemtheorie. Herausgegeben von Dirk Baecker. 2. Aufl. Sozialwissenschaften. Heidelberg: Carl-Auer-Verl, 2004, p. 178–179.\n"
      },
      "date": 1659955212216
    },
    {
      "type": "edit",
      "id": "2880bb90b217eaa0",
      "item": {
        "type": "paragraph",
        "id": "2880bb90b217eaa0",
        "text": "I would like to add a few thoughts that go beyond the scope of this discussion and at the same time try to explain why we talk less about [[complexity]] today than we did in the 1950s and 1960s. Perhaps this is simply because the hopes of finding a conceptual management of complexity, that is, of making complexity analytically manipulable, have not been realized. When one proceeds statistically, one must be careful about the preconditions of statistical analysis. When one combines variables, one can go very high with the number today, but also not arbitrarily high, and usually one assumes that so many variables are needed to fully describe systems that a theory cannot cope with them. There hasn't been a lot of success at this level, although I recently talked to someone at Prognos AG in Basel who said there has been tremendous progress in variable management of predictive models over the last decade. I can't judge that, but that's also just one line of development. Another question is whether, at least as a sociologist, independent of the question of whether one can calculate with measurement precision how complexity is dealt with, one can study facilities of the step function or of generalization with respect to the problem of complexity reduction."
      },
      "date": 1659955236044
    },
    {
      "item": {
        "type": "factory",
        "id": "1a120aea2a548443"
      },
      "id": "1a120aea2a548443",
      "type": "add",
      "after": "6df4847e014d9c30",
      "date": 1659957648058
    },
    {
      "type": "edit",
      "id": "1a120aea2a548443",
      "item": {
        "type": "pagefold",
        "id": "1a120aea2a548443",
        "text": "."
      },
      "date": 1659957651880
    },
    {
      "item": {
        "type": "factory",
        "id": "23511c1cc0a9e93e"
      },
      "id": "23511c1cc0a9e93e",
      "type": "add",
      "after": "1a120aea2a548443",
      "date": 1659957654316
    },
    {
      "type": "edit",
      "id": "23511c1cc0a9e93e",
      "item": {
        "type": "paragraph",
        "id": "23511c1cc0a9e93e",
        "text": "– https://link.springer.com/chapter/10.1007/978-3-662-09992-6_7"
      },
      "date": 1659957657242
    },
    {
      "type": "edit",
      "id": "23511c1cc0a9e93e",
      "item": {
        "type": "markdown",
        "id": "23511c1cc0a9e93e",
        "text": "– https://link.springer.com/chapter/10.1007/978-3-662-09992-6_7"
      },
      "date": 1659957658436
    },
    {
      "item": {
        "type": "factory",
        "id": "ca2cbca3bf450c02"
      },
      "id": "ca2cbca3bf450c02",
      "type": "add",
      "after": "23511c1cc0a9e93e",
      "date": 1659958093401
    },
    {
      "type": "edit",
      "id": "ca2cbca3bf450c02",
      "item": {
        "type": "paragraph",
        "id": "ca2cbca3bf450c02",
        "text": "– https://d1wqtxts1xzle7.cloudfront.net/45267045/A_History-based_Verification_of_Distribu20160502-15955-16zkt8c-with-cover-page-v2.pdf?Expires=1659961656&Signature=d-~spbfUjoGRsEvk~3Q910NlwiC4uTd900krhMft-zNrMErfQzDWv-G7ry0Hf8EkOeqBEpiHMfH3yu35jiFe7vRhRntpMgigcogJPi5M75FC1s4XKZhxEB07Mzbe2n6JvvHCoTCnPRLNoGxHpWJuycPGbcbXKKIZamrB0uHxycRyyvshl-3y6fxYEz4297KM3qLEksTckZLaLayIvYNTygC1nbGVZzdWa0SwY60UW4tz3wdVwQlFL4hvSgPJEiP72evQQl5WNBipTCOpUQoyUIs627voSIq38iH~KoxJw5PHO7ug-u~NnUTOJ4sHu-baLyVRzGcuXAbsZk6nS7zDWQ__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA#page=160"
      },
      "date": 1659958096293
    },
    {
      "type": "edit",
      "id": "ca2cbca3bf450c02",
      "item": {
        "type": "markdown",
        "id": "ca2cbca3bf450c02",
        "text": "– https://d1wqtxts1xzle7.cloudfront.net/45267045/A_History-based_Verification_of_Distribu20160502-15955-16zkt8c-with-cover-page-v2.pdf?Expires=1659961656&Signature=d-~spbfUjoGRsEvk~3Q910NlwiC4uTd900krhMft-zNrMErfQzDWv-G7ry0Hf8EkOeqBEpiHMfH3yu35jiFe7vRhRntpMgigcogJPi5M75FC1s4XKZhxEB07Mzbe2n6JvvHCoTCnPRLNoGxHpWJuycPGbcbXKKIZamrB0uHxycRyyvshl-3y6fxYEz4297KM3qLEksTckZLaLayIvYNTygC1nbGVZzdWa0SwY60UW4tz3wdVwQlFL4hvSgPJEiP72evQQl5WNBipTCOpUQoyUIs627voSIq38iH~KoxJw5PHO7ug-u~NnUTOJ4sHu-baLyVRzGcuXAbsZk6nS7zDWQ__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA#page=160"
      },
      "date": 1659958097429
    },
    {
      "item": {
        "type": "factory",
        "id": "a12afec60f5e5676"
      },
      "id": "a12afec60f5e5676",
      "type": "add",
      "after": "ca2cbca3bf450c02",
      "date": 1659958447031
    },
    {
      "type": "edit",
      "id": "a12afec60f5e5676",
      "item": {
        "type": "paragraph",
        "id": "a12afec60f5e5676",
        "text": "– https://link.springer.com/article/10.1007/s00502-021-00917-x"
      },
      "date": 1659958449909
    },
    {
      "type": "edit",
      "id": "a12afec60f5e5676",
      "item": {
        "type": "markdown",
        "id": "a12afec60f5e5676",
        "text": "– https://link.springer.com/article/10.1007/s00502-021-00917-x"
      },
      "date": 1659958451229
    },
    {
      "item": {
        "type": "factory",
        "id": "f75eb5818ad9ca3d"
      },
      "id": "f75eb5818ad9ca3d",
      "type": "add",
      "after": "a12afec60f5e5676",
      "date": 1659958706497
    },
    {
      "type": "edit",
      "id": "f75eb5818ad9ca3d",
      "item": {
        "type": "paragraph",
        "id": "f75eb5818ad9ca3d",
        "text": "\nCODESYS Static Analysis\n"
      },
      "date": 1659958710843
    },
    {
      "type": "edit",
      "id": "f75eb5818ad9ca3d",
      "item": {
        "type": "paragraph",
        "id": "f75eb5818ad9ca3d",
        "text": "CODESYS Static Analysis [https://store.codesys.com/de/codesys-static-analysis.html page]\n"
      },
      "date": 1659958722244
    },
    {
      "item": {
        "type": "factory",
        "id": "65dfe7e5b39ef87c"
      },
      "id": "65dfe7e5b39ef87c",
      "type": "add",
      "after": "f75eb5818ad9ca3d",
      "date": 1659960250465
    },
    {
      "type": "edit",
      "id": "65dfe7e5b39ef87c",
      "item": {
        "type": "paragraph",
        "id": "65dfe7e5b39ef87c",
        "text": "– https://www.scch.at/software-science/projekte/detail/ak-graph"
      },
      "date": 1659960252751
    },
    {
      "type": "edit",
      "id": "65dfe7e5b39ef87c",
      "item": {
        "type": "markdown",
        "id": "65dfe7e5b39ef87c",
        "text": "– https://www.scch.at/software-science/projekte/detail/ak-graph"
      },
      "date": 1659960253802
    },
    {
      "item": {
        "type": "factory",
        "id": "d517671bbcf5ce13"
      },
      "id": "d517671bbcf5ce13",
      "type": "add",
      "after": "65dfe7e5b39ef87c",
      "date": 1659961676900
    },
    {
      "type": "edit",
      "id": "d517671bbcf5ce13",
      "item": {
        "type": "pagefold",
        "id": "d517671bbcf5ce13",
        "text": "~"
      },
      "date": 1659961681171
    },
    {
      "item": {
        "type": "factory",
        "id": "cdc9ca21f1a4b20c"
      },
      "id": "cdc9ca21f1a4b20c",
      "type": "add",
      "after": "d517671bbcf5ce13",
      "date": 1659961683680
    },
    {
      "type": "edit",
      "id": "cdc9ca21f1a4b20c",
      "item": {
        "type": "paragraph",
        "id": "cdc9ca21f1a4b20c",
        "text": "– https://dl.acm.org/doi/abs/10.1145/3139903.3139905"
      },
      "date": 1659961687027
    },
    {
      "type": "edit",
      "id": "cdc9ca21f1a4b20c",
      "item": {
        "type": "markdown",
        "id": "cdc9ca21f1a4b20c",
        "text": "– https://dl.acm.org/doi/abs/10.1145/3139903.3139905"
      },
      "date": 1659961688705
    },
    {
      "item": {
        "type": "factory",
        "id": "70f38b16e99b8063"
      },
      "id": "70f38b16e99b8063",
      "type": "add",
      "after": "cdc9ca21f1a4b20c",
      "date": 1659961746089
    },
    {
      "type": "edit",
      "id": "70f38b16e99b8063",
      "item": {
        "type": "paragraph",
        "id": "70f38b16e99b8063",
        "text": "– http://shingarov.com/athens/vmil.pdf"
      },
      "date": 1659961749294
    },
    {
      "type": "edit",
      "id": "70f38b16e99b8063",
      "item": {
        "type": "markdown",
        "id": "70f38b16e99b8063",
        "text": "– http://shingarov.com/athens/vmil.pdf"
      },
      "date": 1659961750735
    },
    {
      "item": {
        "type": "factory",
        "id": "57e439d6d18a6ed6"
      },
      "id": "57e439d6d18a6ed6",
      "type": "add",
      "after": "70f38b16e99b8063",
      "date": 1659962680626
    },
    {
      "type": "edit",
      "id": "57e439d6d18a6ed6",
      "item": {
        "type": "paragraph",
        "id": "57e439d6d18a6ed6",
        "text": "Boris"
      },
      "date": 1659962685297
    },
    {
      "type": "add",
      "id": "f7310b2d76000293",
      "item": {
        "type": "paragraph",
        "id": "f7310b2d76000293",
        "text": "– ["
      },
      "after": "57e439d6d18a6ed6",
      "date": 1659962689552
    },
    {
      "type": "edit",
      "id": "f7310b2d76000293",
      "item": {
        "type": "paragraph",
        "id": "f7310b2d76000293",
        "text": "– https://arxiv.org/abs/2007.03152"
      },
      "date": 1659962702997
    },
    {
      "type": "edit",
      "id": "f7310b2d76000293",
      "item": {
        "type": "markdown",
        "id": "f7310b2d76000293",
        "text": "– https://arxiv.org/abs/2007.03152"
      },
      "date": 1659962704983
    },
    {
      "type": "edit",
      "id": "f7310b2d76000293",
      "item": {
        "type": "markdown",
        "id": "f7310b2d76000293",
        "text": "The gem5 Simulator: Version 20.0+ [https://arxiv.org/abs/2007.03152 arxiv]"
      },
      "date": 1659962759004
    },
    {
      "item": {
        "type": "factory",
        "id": "0b82cadc1ac55a94"
      },
      "id": "0b82cadc1ac55a94",
      "type": "add",
      "after": "f7310b2d76000293",
      "date": 1659963903850
    },
    {
      "type": "edit",
      "id": "0b82cadc1ac55a94",
      "item": {
        "type": "paragraph",
        "id": "0b82cadc1ac55a94",
        "text": "[[Z3 Interface for Smalltalk]]"
      },
      "date": 1659963911952
    },
    {
      "item": {
        "type": "factory",
        "id": "cd7205f47a99635f"
      },
      "id": "cd7205f47a99635f",
      "type": "add",
      "after": "0b82cadc1ac55a94",
      "date": 1659964213586
    },
    {
      "type": "edit",
      "id": "cd7205f47a99635f",
      "item": {
        "type": "code",
        "id": "cd7205f47a99635f",
        "text": "proveValid: f\n\t\"Prove that the constraints already asserted into the logical\n   context implies the given formula f, by showing that (not f) is unsatisfiable.\n\n   The receiver context is not modified by this function.\n\n\tRaise an NotValid exception if f is not valid, i.e. if a counterexample was found;\n\tthe counterexample is wrapped in the exception.\"\n\n\t| counterexample |\n\tcounterexample := self findCounterexample: f.\n\tcounterexample isNil ifFalse: [ NotValid signalWithCounterexample: counterexample ]"
      },
      "date": 1659964216963
    },
    {
      "item": {
        "type": "factory",
        "id": "c0377602f33f86d0"
      },
      "id": "c0377602f33f86d0",
      "type": "add",
      "after": "cd7205f47a99635f",
      "date": 1659964375525
    },
    {
      "type": "edit",
      "id": "c0377602f33f86d0",
      "item": {
        "type": "paragraph",
        "id": "c0377602f33f86d0",
        "text": "– https://chicoary.wordpress.com/2020/05/23/how-does-find-by-example-work-in-the-pharo-finder-englished/"
      },
      "date": 1659964379090
    },
    {
      "type": "edit",
      "id": "c0377602f33f86d0",
      "item": {
        "type": "markdown",
        "id": "c0377602f33f86d0",
        "text": "– https://chicoary.wordpress.com/2020/05/23/how-does-find-by-example-work-in-the-pharo-finder-englished/"
      },
      "date": 1659964383055
    },
    {
      "type": "edit",
      "id": "c0377602f33f86d0",
      "item": {
        "type": "markdown",
        "id": "c0377602f33f86d0",
        "text": "How does find by example work in the Pharo Finder. [https://chicoary.wordpress.com/2020/05/23/how-does-find-by-example-work-in-the-pharo-finder-englished/ page], "
      },
      "date": 1659964408582
    },
    {
      "type": "edit",
      "id": "c0377602f33f86d0",
      "item": {
        "type": "markdown",
        "id": "c0377602f33f86d0",
        "text": "How does find by example work in the Pharo Finder. [https://chicoary.wordpress.com/2020/05/23/how-does-find-by-example-work-in-the-pharo-finder-englished/ page], [https://news.ycombinator.com/item?id=31465945 hn]"
      },
      "date": 1659964422925
    },
    {
      "item": {
        "type": "factory",
        "id": "41347088fa976351"
      },
      "id": "41347088fa976351",
      "type": "add",
      "after": "c0377602f33f86d0",
      "date": 1659964582772
    },
    {
      "type": "edit",
      "id": "41347088fa976351",
      "item": {
        "type": "markdown",
        "id": "41347088fa976351",
        "text": "> \t\n\t\nmncharity 77 days ago | root | parent | next [–]\n\n> the philosophical break between the two paradigms and one which I spend a lot of time on [...] I wonder if it’s more about balancing the two modes.\n\nI don't see the break? \"Clay\" tooling exists for \"industrial\" code, but as secret sauce, and jig kludgery, and various other \"making this more broadly available is not in/of our interest\". \"Clay\"'s rejection of \"industrial\" has seemed more resource-starved exploit-not-explore group-think. Smalltalk/forth/etc audacious-scope rewrite-the-world efforts have seemed more \"remake the world\" than \"to force us to remake ourselves\". Try imaging a forth implementation effort that said \"ok, we have bootstrap... so now the next obvious steps are supporting PICs and multiple dispatch and template jit, WAM and BEAM vms, linking Z3 solver, DHM type inference, ...\". So perhaps rather than an inherent break between modes, and balancing to be done, there's a lack of available power, and of interests/resources aligned with ramping it.\n\nBut then, I'd like a programming environment which provides an powerful environment for making engineering tradeoffs, rather than ones which hardwire in very dramatic ones. I expect such an environment, when it finally exists, won't be hard to recognize. As, for example, basic reimplementation of existing modern languages, with their big test suites, libraries, community repos, specs sometimes transliteratable directly into code, code-as-documentation and highly-investment-in optimization, is a natural forcing-factor exercise for such an environment. So when you see a small team spewing new language implementations... maybe we've at long last hit phase transition. And if one can't easily manage that, in bulk, even with all that leverage... then it's not a very powerful environment, is it? "
      },
      "date": 1659964587792
    },
    {
      "item": {
        "type": "factory",
        "id": "931891c8ba3efca0"
      },
      "id": "931891c8ba3efca0",
      "type": "add",
      "after": "41347088fa976351",
      "date": 1659965120521
    },
    {
      "id": "931891c8ba3efca0",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5",
        "be214c74e406d97e",
        "677702161df6125c",
        "7c27bf5868c45243",
        "1ba1689683992bc4",
        "1fb0a4b9455d6bfd",
        "b55a927d7cced091",
        "d2635aa820dc243b",
        "a70b186fd7222e62",
        "ac89530f427927d0",
        "6a2518641487950b",
        "8d3b7bb5592b011c",
        "df06894f45f6808e",
        "873ae88f9d38dd96",
        "b1e8379ff3a26182",
        "f99bda8b39b67c17",
        "2880bb90b217eaa0",
        "6df4847e014d9c30",
        "1a120aea2a548443",
        "23511c1cc0a9e93e",
        "ca2cbca3bf450c02",
        "a12afec60f5e5676",
        "f75eb5818ad9ca3d",
        "65dfe7e5b39ef87c",
        "d517671bbcf5ce13",
        "cdc9ca21f1a4b20c",
        "70f38b16e99b8063",
        "57e439d6d18a6ed6",
        "f7310b2d76000293",
        "0b82cadc1ac55a94",
        "cd7205f47a99635f",
        "931891c8ba3efca0",
        "c0377602f33f86d0",
        "41347088fa976351"
      ],
      "date": 1659965125705
    },
    {
      "type": "edit",
      "id": "931891c8ba3efca0",
      "item": {
        "type": "pagefold",
        "id": "931891c8ba3efca0",
        "text": "~"
      },
      "date": 1659965128637
    },
    {
      "item": {
        "type": "factory",
        "id": "d5ae045c19f5eb40"
      },
      "id": "d5ae045c19f5eb40",
      "type": "add",
      "after": "41347088fa976351",
      "date": 1659965131914
    },
    {
      "id": "d5ae045c19f5eb40",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5",
        "be214c74e406d97e",
        "677702161df6125c",
        "7c27bf5868c45243",
        "1ba1689683992bc4",
        "1fb0a4b9455d6bfd",
        "b55a927d7cced091",
        "d2635aa820dc243b",
        "a70b186fd7222e62",
        "ac89530f427927d0",
        "6a2518641487950b",
        "8d3b7bb5592b011c",
        "df06894f45f6808e",
        "873ae88f9d38dd96",
        "b1e8379ff3a26182",
        "f99bda8b39b67c17",
        "2880bb90b217eaa0",
        "6df4847e014d9c30",
        "1a120aea2a548443",
        "23511c1cc0a9e93e",
        "ca2cbca3bf450c02",
        "a12afec60f5e5676",
        "f75eb5818ad9ca3d",
        "65dfe7e5b39ef87c",
        "d517671bbcf5ce13",
        "cdc9ca21f1a4b20c",
        "70f38b16e99b8063",
        "57e439d6d18a6ed6",
        "f7310b2d76000293",
        "0b82cadc1ac55a94",
        "cd7205f47a99635f",
        "d5ae045c19f5eb40",
        "931891c8ba3efca0",
        "c0377602f33f86d0",
        "41347088fa976351"
      ],
      "date": 1659965136564
    },
    {
      "type": "edit",
      "id": "d5ae045c19f5eb40",
      "item": {
        "type": "code",
        "id": "d5ae045c19f5eb40",
        "text": "PPCompositeParser subclass: #RefinementParser\n\tinstanceVariableNames: 'matchedParen funArg reftB tbase refTop rtype0 rbase rtype rfun'\n\tclassVariableNames: ''\n\tpackage: 'SpriteLang'"
      },
      "date": 1659965139527
    },
    {
      "item": {
        "type": "factory",
        "id": "05eb0e1485385334"
      },
      "id": "05eb0e1485385334",
      "type": "add",
      "after": "41347088fa976351",
      "date": 1659965161566
    },
    {
      "id": "05eb0e1485385334",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5",
        "be214c74e406d97e",
        "677702161df6125c",
        "7c27bf5868c45243",
        "1ba1689683992bc4",
        "1fb0a4b9455d6bfd",
        "b55a927d7cced091",
        "d2635aa820dc243b",
        "a70b186fd7222e62",
        "ac89530f427927d0",
        "6a2518641487950b",
        "8d3b7bb5592b011c",
        "df06894f45f6808e",
        "873ae88f9d38dd96",
        "b1e8379ff3a26182",
        "f99bda8b39b67c17",
        "2880bb90b217eaa0",
        "6df4847e014d9c30",
        "1a120aea2a548443",
        "23511c1cc0a9e93e",
        "ca2cbca3bf450c02",
        "a12afec60f5e5676",
        "f75eb5818ad9ca3d",
        "65dfe7e5b39ef87c",
        "d517671bbcf5ce13",
        "cdc9ca21f1a4b20c",
        "70f38b16e99b8063",
        "57e439d6d18a6ed6",
        "f7310b2d76000293",
        "0b82cadc1ac55a94",
        "cd7205f47a99635f",
        "05eb0e1485385334",
        "d5ae045c19f5eb40",
        "931891c8ba3efca0",
        "c0377602f33f86d0",
        "41347088fa976351"
      ],
      "date": 1659965167772
    },
    {
      "type": "edit",
      "id": "05eb0e1485385334",
      "item": {
        "type": "paragraph",
        "id": "05eb0e1485385334",
        "text": "RefinementParser"
      },
      "date": 1659965171579
    },
    {
      "item": {
        "type": "factory",
        "id": "8b34e1a22461086c"
      },
      "id": "8b34e1a22461086c",
      "type": "add",
      "after": "41347088fa976351",
      "date": 1659965272931
    },
    {
      "id": "8b34e1a22461086c",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5",
        "be214c74e406d97e",
        "677702161df6125c",
        "7c27bf5868c45243",
        "1ba1689683992bc4",
        "1fb0a4b9455d6bfd",
        "b55a927d7cced091",
        "d2635aa820dc243b",
        "a70b186fd7222e62",
        "ac89530f427927d0",
        "6a2518641487950b",
        "8d3b7bb5592b011c",
        "df06894f45f6808e",
        "873ae88f9d38dd96",
        "b1e8379ff3a26182",
        "f99bda8b39b67c17",
        "2880bb90b217eaa0",
        "6df4847e014d9c30",
        "1a120aea2a548443",
        "23511c1cc0a9e93e",
        "ca2cbca3bf450c02",
        "a12afec60f5e5676",
        "f75eb5818ad9ca3d",
        "65dfe7e5b39ef87c",
        "d517671bbcf5ce13",
        "cdc9ca21f1a4b20c",
        "70f38b16e99b8063",
        "57e439d6d18a6ed6",
        "f7310b2d76000293",
        "0b82cadc1ac55a94",
        "cd7205f47a99635f",
        "05eb0e1485385334",
        "d5ae045c19f5eb40",
        "8b34e1a22461086c",
        "931891c8ba3efca0",
        "c0377602f33f86d0",
        "41347088fa976351"
      ],
      "date": 1659965281271
    },
    {
      "item": {
        "type": "factory",
        "id": "0159fbc8c6835be9"
      },
      "id": "0159fbc8c6835be9",
      "type": "add",
      "after": "41347088fa976351",
      "date": 1659965292487
    },
    {
      "id": "0159fbc8c6835be9",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5",
        "be214c74e406d97e",
        "677702161df6125c",
        "7c27bf5868c45243",
        "1ba1689683992bc4",
        "1fb0a4b9455d6bfd",
        "b55a927d7cced091",
        "d2635aa820dc243b",
        "a70b186fd7222e62",
        "ac89530f427927d0",
        "6a2518641487950b",
        "8d3b7bb5592b011c",
        "df06894f45f6808e",
        "873ae88f9d38dd96",
        "b1e8379ff3a26182",
        "f99bda8b39b67c17",
        "2880bb90b217eaa0",
        "6df4847e014d9c30",
        "1a120aea2a548443",
        "23511c1cc0a9e93e",
        "ca2cbca3bf450c02",
        "a12afec60f5e5676",
        "f75eb5818ad9ca3d",
        "65dfe7e5b39ef87c",
        "d517671bbcf5ce13",
        "cdc9ca21f1a4b20c",
        "70f38b16e99b8063",
        "57e439d6d18a6ed6",
        "f7310b2d76000293",
        "0b82cadc1ac55a94",
        "cd7205f47a99635f",
        "05eb0e1485385334",
        "d5ae045c19f5eb40",
        "8b34e1a22461086c",
        "0159fbc8c6835be9",
        "931891c8ba3efca0",
        "c0377602f33f86d0",
        "41347088fa976351"
      ],
      "date": 1659965296968
    },
    {
      "type": "edit",
      "id": "8b34e1a22461086c",
      "item": {
        "type": "paragraph",
        "id": "8b34e1a22461086c",
        "text": "a Test"
      },
      "date": 1659965297921
    },
    {
      "type": "edit",
      "id": "0159fbc8c6835be9",
      "item": {
        "type": "code",
        "id": "0159fbc8c6835be9",
        "text": "test_abs01\n\tself processString: '\n⟦val cassert : bool[b|b] => int⟧\nlet cassert = (b) => { 0 };\n\n⟦val abs : x:int => int[?]⟧\nlet abs = (x) => {\n  let pos = x >= 0;\n  if (pos) {\n    x\n  } else {\n    0 - x\n  }\n};\n\n⟦val main : int => int⟧\nlet main = (y) => {\n  let fails = 0 <= y;\n  cassert(fails)\n};\n'"
      },
      "date": 1659965298828
    },
    {
      "item": {
        "type": "factory",
        "id": "d8654b352a8e6f33"
      },
      "id": "d8654b352a8e6f33",
      "type": "add",
      "after": "41347088fa976351",
      "date": 1659965406489
    },
    {
      "id": "d8654b352a8e6f33",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5",
        "be214c74e406d97e",
        "677702161df6125c",
        "7c27bf5868c45243",
        "1ba1689683992bc4",
        "1fb0a4b9455d6bfd",
        "b55a927d7cced091",
        "d2635aa820dc243b",
        "a70b186fd7222e62",
        "ac89530f427927d0",
        "6a2518641487950b",
        "8d3b7bb5592b011c",
        "df06894f45f6808e",
        "873ae88f9d38dd96",
        "b1e8379ff3a26182",
        "f99bda8b39b67c17",
        "2880bb90b217eaa0",
        "6df4847e014d9c30",
        "1a120aea2a548443",
        "23511c1cc0a9e93e",
        "ca2cbca3bf450c02",
        "a12afec60f5e5676",
        "f75eb5818ad9ca3d",
        "65dfe7e5b39ef87c",
        "d517671bbcf5ce13",
        "cdc9ca21f1a4b20c",
        "70f38b16e99b8063",
        "57e439d6d18a6ed6",
        "f7310b2d76000293",
        "0b82cadc1ac55a94",
        "cd7205f47a99635f",
        "05eb0e1485385334",
        "d5ae045c19f5eb40",
        "8b34e1a22461086c",
        "0159fbc8c6835be9",
        "d8654b352a8e6f33",
        "931891c8ba3efca0",
        "c0377602f33f86d0",
        "41347088fa976351"
      ],
      "date": 1659965412256
    },
    {
      "type": "edit",
      "id": "d8654b352a8e6f33",
      "item": {
        "type": "paragraph",
        "id": "d8654b352a8e6f33",
        "text": "SMT solvers [[Satisfiability Modulo Theories]]"
      },
      "date": 1659965427786
    },
    {
      "type": "edit",
      "id": "d8654b352a8e6f33",
      "item": {
        "type": "paragraph",
        "id": "d8654b352a8e6f33",
        "text": "SMT solvers ⇒ [[Satisfiability Modulo Theories]]"
      },
      "date": 1659965441314
    },
    {
      "type": "edit",
      "id": "d8654b352a8e6f33",
      "item": {
        "type": "paragraph",
        "id": "d8654b352a8e6f33",
        "text": "SMT solvers ⇒ [[Satisfiability Modulo Theories]], [https://en.wikipedia.org/wiki/Satisfiability_modulo_theories wikipedia]"
      },
      "date": 1659965455388
    },
    {
      "item": {
        "type": "factory",
        "id": "bb584238191a3871"
      },
      "id": "bb584238191a3871",
      "type": "add",
      "after": "41347088fa976351",
      "date": 1659965527357
    },
    {
      "id": "bb584238191a3871",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5",
        "be214c74e406d97e",
        "677702161df6125c",
        "7c27bf5868c45243",
        "1ba1689683992bc4",
        "1fb0a4b9455d6bfd",
        "b55a927d7cced091",
        "d2635aa820dc243b",
        "a70b186fd7222e62",
        "ac89530f427927d0",
        "6a2518641487950b",
        "8d3b7bb5592b011c",
        "df06894f45f6808e",
        "873ae88f9d38dd96",
        "b1e8379ff3a26182",
        "f99bda8b39b67c17",
        "2880bb90b217eaa0",
        "6df4847e014d9c30",
        "1a120aea2a548443",
        "23511c1cc0a9e93e",
        "ca2cbca3bf450c02",
        "a12afec60f5e5676",
        "f75eb5818ad9ca3d",
        "65dfe7e5b39ef87c",
        "d517671bbcf5ce13",
        "cdc9ca21f1a4b20c",
        "70f38b16e99b8063",
        "57e439d6d18a6ed6",
        "f7310b2d76000293",
        "0b82cadc1ac55a94",
        "cd7205f47a99635f",
        "05eb0e1485385334",
        "d5ae045c19f5eb40",
        "8b34e1a22461086c",
        "0159fbc8c6835be9",
        "bb584238191a3871",
        "d8654b352a8e6f33",
        "931891c8ba3efca0",
        "c0377602f33f86d0",
        "41347088fa976351"
      ],
      "date": 1659965533078
    },
    {
      "id": "d8654b352a8e6f33",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5",
        "be214c74e406d97e",
        "677702161df6125c",
        "7c27bf5868c45243",
        "1ba1689683992bc4",
        "1fb0a4b9455d6bfd",
        "b55a927d7cced091",
        "d2635aa820dc243b",
        "a70b186fd7222e62",
        "ac89530f427927d0",
        "6a2518641487950b",
        "8d3b7bb5592b011c",
        "df06894f45f6808e",
        "873ae88f9d38dd96",
        "b1e8379ff3a26182",
        "f99bda8b39b67c17",
        "2880bb90b217eaa0",
        "6df4847e014d9c30",
        "1a120aea2a548443",
        "23511c1cc0a9e93e",
        "ca2cbca3bf450c02",
        "a12afec60f5e5676",
        "f75eb5818ad9ca3d",
        "65dfe7e5b39ef87c",
        "d517671bbcf5ce13",
        "cdc9ca21f1a4b20c",
        "70f38b16e99b8063",
        "57e439d6d18a6ed6",
        "f7310b2d76000293",
        "0b82cadc1ac55a94",
        "cd7205f47a99635f",
        "05eb0e1485385334",
        "d5ae045c19f5eb40",
        "8b34e1a22461086c",
        "0159fbc8c6835be9",
        "d8654b352a8e6f33",
        "bb584238191a3871",
        "931891c8ba3efca0",
        "c0377602f33f86d0",
        "41347088fa976351"
      ],
      "date": 1659965536889
    },
    {
      "type": "edit",
      "id": "bb584238191a3871",
      "item": {
        "type": "markdown",
        "id": "bb584238191a3871",
        "text": "> SMT can be thought of as a constraint satisfaction problem and thus a certain formalized approach to constraint programming. "
      },
      "date": 1659965539870
    },
    {
      "type": "edit",
      "id": "f7310b2d76000293",
      "item": {
        "type": "markdown",
        "id": "f7310b2d76000293",
        "text": "The gem5 Simulator: Version 20.0+ [https://arxiv.org/abs/2007.03152 arxiv]\n"
      },
      "date": 1659965623467
    },
    {
      "type": "add",
      "id": "9f487b968cb73bb9",
      "item": {
        "type": "markdown",
        "id": "9f487b968cb73bb9",
        "text": "MachineArithmetic.image"
      },
      "after": "f7310b2d76000293",
      "date": 1659965625227
    },
    {
      "type": "edit",
      "id": "9f487b968cb73bb9",
      "item": {
        "type": "markdown",
        "id": "9f487b968cb73bb9",
        "text": "# MachineArithmetic.image"
      },
      "date": 1659965630049
    },
    {
      "type": "edit",
      "id": "bb584238191a3871",
      "item": {
        "type": "markdown",
        "id": "bb584238191a3871",
        "text": "> SMT can be thought of as a constraint satisfaction problem and thus a certain formalized approach to constraint programming. \n"
      },
      "date": 1659965686604
    },
    {
      "type": "add",
      "id": "886a982f9fedc931",
      "item": {
        "type": "markdown",
        "id": "886a982f9fedc931",
        "text": "Horn Clause Solvers for Program Verification. "
      },
      "after": "bb584238191a3871",
      "date": 1659965690047
    },
    {
      "type": "edit",
      "id": "886a982f9fedc931",
      "item": {
        "type": "markdown",
        "id": "886a982f9fedc931",
        "text": "Horn Clause Solvers for Program Verification. [https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/nbjorner-yurifest.pdf pdf]"
      },
      "date": 1659965707243
    },
    {
      "type": "edit",
      "id": "886a982f9fedc931",
      "item": {
        "type": "markdown",
        "id": "886a982f9fedc931",
        "text": "Horn Clause Solvers for [[Program Verification]]. [https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/nbjorner-yurifest.pdf pdf]"
      },
      "date": 1659965720778
    },
    {
      "type": "edit",
      "id": "886a982f9fedc931",
      "item": {
        "type": "markdown",
        "id": "886a982f9fedc931",
        "text": "Horn Clause Solvers for [[Program Verification]]. [https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/nbjorner-yurifest.pdf pdf]\n"
      },
      "date": 1659965801605
    },
    {
      "type": "add",
      "id": "53d6dfa1fc746e44",
      "item": {
        "type": "markdown",
        "id": "53d6dfa1fc746e44",
        "text": "> Automatic program verification and symbolic model checking tools interface with theorem proving technologies that check satisfiability of formulas. A theme pursued in the past years by the authors of this paper has been to encode symbolic model problems directly as Horn clauses and develop dedicated solvers for Horn clauses. Our solvers are called Duality, HSF, SeaHorn, and μZ and we have devoted considerable attention in recent papers to algorithms for solving Horn clauses. This paper complements these strides as we summarize main useful properties of Horn clauses, illustrate encodings of procedural program verification into Horn clauses and then highlight a number of useful simplification strategies at the level of Horn clauses. Solving Horn clauses amounts to establishing Existential positive Fixed-point Logic formulas, a perspec- tive that was promoted by Blass and Gurevich."
      },
      "after": "886a982f9fedc931",
      "date": 1659965803349
    },
    {
      "type": "edit",
      "id": "53d6dfa1fc746e44",
      "item": {
        "type": "markdown",
        "id": "53d6dfa1fc746e44",
        "text": "> Automatic program verification and symbolic model checking tools interface with theorem proving technologies that check [[satisfiability]] of formulas. A theme pursued in the past years by the authors of this paper has been to encode symbolic model problems directly as Horn clauses and develop dedicated solvers for Horn clauses. Our solvers are called Duality, HSF, SeaHorn, and μZ and we have devoted considerable attention in recent papers to algorithms for solving Horn clauses. This paper complements these strides as we summarize main useful properties of Horn clauses, illustrate encodings of procedural program verification into Horn clauses and then highlight a number of useful simplification strategies at the level of Horn clauses. Solving Horn clauses amounts to establishing Existential positive Fixed-point Logic formulas, a perspec- tive that was promoted by Blass and Gurevich."
      },
      "date": 1659965819740
    },
    {
      "item": {
        "type": "factory",
        "id": "47fcade622d9169c"
      },
      "id": "47fcade622d9169c",
      "type": "add",
      "after": "41347088fa976351",
      "date": 1659966345320
    },
    {
      "type": "edit",
      "id": "47fcade622d9169c",
      "item": {
        "type": "pagefold",
        "id": "47fcade622d9169c",
        "text": "~"
      },
      "date": 1659966348353
    },
    {
      "item": {
        "type": "factory",
        "id": "793fe4401d70365d"
      },
      "id": "793fe4401d70365d",
      "type": "add",
      "after": "47fcade622d9169c",
      "date": 1659966350011
    },
    {
      "type": "edit",
      "id": "793fe4401d70365d",
      "item": {
        "type": "paragraph",
        "id": "793fe4401d70365d",
        "text": "http://forum.world.st/Squeak-Pharo-VM-fork-history-was-RE-Pharo-dev-Squeak-and-Pharo-speed-differences-td5116740i20.html#a5116887"
      },
      "date": 1659966355990
    },
    {
      "type": "edit",
      "id": "793fe4401d70365d",
      "item": {
        "type": "paragraph",
        "id": "793fe4401d70365d",
        "text": "Re: Slang for Cuis (WIP, experimental) [http://forum.world.st/Squeak-Pharo-VM-fork-history-was-RE-Pharo-dev-Squeak-and-Pharo-speed-differences-td5116740i20.html#a5116887 page]"
      },
      "date": 1659966382230
    },
    {
      "type": "edit",
      "id": "793fe4401d70365d",
      "item": {
        "type": "paragraph",
        "id": "793fe4401d70365d",
        "text": "Re: Slang for Cuis (WIP, experimental). [http://forum.world.st/Squeak-Pharo-VM-fork-history-was-RE-Pharo-dev-Squeak-and-Pharo-speed-differences-td5116740i20.html#a5116887 page]"
      },
      "date": 1659966387403
    },
    {
      "item": {
        "type": "factory",
        "id": "60eb60e46d297f3c"
      },
      "id": "60eb60e46d297f3c",
      "type": "add",
      "after": "793fe4401d70365d",
      "date": 1659967023396
    },
    {
      "type": "edit",
      "id": "60eb60e46d297f3c",
      "item": {
        "type": "paragraph",
        "id": "60eb60e46d297f3c",
        "text": "[[Smalltalk]]"
      },
      "date": 1659967027655
    },
    {
      "item": {
        "type": "factory",
        "id": "a426a1b8bed91b12"
      },
      "id": "a426a1b8bed91b12",
      "type": "add",
      "after": "65dfe7e5b39ef87c",
      "date": 1659970987839
    },
    {
      "type": "edit",
      "id": "a426a1b8bed91b12",
      "item": {
        "type": "paragraph",
        "id": "a426a1b8bed91b12",
        "text": "[[Magic Phone]]"
      },
      "date": 1659970992876
    },
    {
      "id": "a426a1b8bed91b12",
      "type": "move",
      "order": [
        "71d7e497aeb8db38",
        "cbd2118f03811ef7",
        "aa13aae3ea1ef914",
        "05568c6c597d59ae",
        "9c373875fea8e26e",
        "b5453a32efbc0cc5",
        "be214c74e406d97e",
        "677702161df6125c",
        "7c27bf5868c45243",
        "1ba1689683992bc4",
        "1fb0a4b9455d6bfd",
        "b55a927d7cced091",
        "d2635aa820dc243b",
        "a70b186fd7222e62",
        "ac89530f427927d0",
        "6a2518641487950b",
        "8d3b7bb5592b011c",
        "df06894f45f6808e",
        "873ae88f9d38dd96",
        "b1e8379ff3a26182",
        "f99bda8b39b67c17",
        "2880bb90b217eaa0",
        "6df4847e014d9c30",
        "1a120aea2a548443",
        "23511c1cc0a9e93e",
        "ca2cbca3bf450c02",
        "a12afec60f5e5676",
        "f75eb5818ad9ca3d",
        "65dfe7e5b39ef87c",
        "d517671bbcf5ce13",
        "cdc9ca21f1a4b20c",
        "70f38b16e99b8063",
        "57e439d6d18a6ed6",
        "f7310b2d76000293",
        "9f487b968cb73bb9",
        "0b82cadc1ac55a94",
        "cd7205f47a99635f",
        "05eb0e1485385334",
        "d5ae045c19f5eb40",
        "8b34e1a22461086c",
        "0159fbc8c6835be9",
        "d8654b352a8e6f33",
        "bb584238191a3871",
        "886a982f9fedc931",
        "53d6dfa1fc746e44",
        "931891c8ba3efca0",
        "c0377602f33f86d0",
        "41347088fa976351",
        "47fcade622d9169c",
        "793fe4401d70365d",
        "60eb60e46d297f3c",
        "a426a1b8bed91b12"
      ],
      "date": 1659971038568
    },
    {
      "item": {
        "type": "factory",
        "id": "046c28ad8aaab153"
      },
      "id": "046c28ad8aaab153",
      "type": "add",
      "after": "a426a1b8bed91b12",
      "date": 1659972245370
    },
    {
      "type": "edit",
      "id": "046c28ad8aaab153",
      "item": {
        "type": "paragraph",
        "id": "046c28ad8aaab153",
        "text": "Pharo Zeroconf Script\n\n"
      },
      "date": 1659972249439
    },
    {
      "type": "edit",
      "id": "046c28ad8aaab153",
      "item": {
        "type": "paragraph",
        "id": "046c28ad8aaab153",
        "text": "Pharo Zeroconf Script. [https://get.pharo.org site]\n\n"
      },
      "date": 1659972263065
    },
    {
      "item": {
        "type": "factory",
        "id": "3f8d359e0daa6204"
      },
      "id": "3f8d359e0daa6204",
      "type": "add",
      "after": "046c28ad8aaab153",
      "date": 1659972687894
    },
    {
      "type": "edit",
      "id": "3f8d359e0daa6204",
      "item": {
        "type": "paragraph",
        "id": "3f8d359e0daa6204",
        "text": "# Z3AST"
      },
      "date": 1659972691129
    },
    {
      "type": "edit",
      "id": "3f8d359e0daa6204",
      "item": {
        "type": "markdown",
        "id": "3f8d359e0daa6204",
        "text": "# Z3AST"
      },
      "date": 1659972693837
    },
    {
      "item": {
        "type": "factory",
        "id": "46396d11ea9bc169"
      },
      "id": "46396d11ea9bc169",
      "type": "add",
      "after": "3f8d359e0daa6204",
      "date": 1659972699233
    },
    {
      "type": "edit",
      "id": "46396d11ea9bc169",
      "item": {
        "type": "paragraph",
        "id": "46396d11ea9bc169",
        "text": "In Z3, expressions, sorts and declarations are called ASTs. ASTs are directed acyclic graphs. Every expression has a sort. Send #sort to get the sort of an expression.\n\nWhen we get an AST handle from Z3, we look at the sort, and create an instance of the concrete subclass (BitVector, Bool etc) appropriate for the sort.\n\nIn addition to sorts, ASTs also have kinds: VAR, NUMERAL, APP etc.  This becomes tricky because in Smalltalk this would correspond to something like a two-dimensional class membership, which we don't have.  So to send messages understood by AST of particular kinds (e.g. arity is a concept specific to function applications), we can downcast an AST to its kind by sending #asKind, and back by sending #asAST."
      },
      "date": 1659972701420
    },
    {
      "item": {
        "type": "factory",
        "id": "49ce7cd6bc42a417"
      },
      "id": "49ce7cd6bc42a417",
      "type": "add",
      "after": "46396d11ea9bc169",
      "date": 1659992281676
    },
    {
      "type": "edit",
      "id": "49ce7cd6bc42a417",
      "item": {
        "type": "pagefold",
        "id": "49ce7cd6bc42a417",
        "text": "~"
      },
      "date": 1659992286605
    },
    {
      "item": {
        "type": "factory",
        "id": "a06e73733088436b"
      },
      "id": "a06e73733088436b",
      "type": "add",
      "after": "49ce7cd6bc42a417",
      "date": 1659992289237
    },
    {
      "type": "edit",
      "id": "a06e73733088436b",
      "item": {
        "type": "paragraph",
        "id": "a06e73733088436b",
        "text": "– https://www.scch.at/scch/presse-medien/detail/software-analyse-habt-in-programmen-verstecktes-wissen"
      },
      "date": 1659992295909
    },
    {
      "type": "edit",
      "id": "a06e73733088436b",
      "item": {
        "type": "markdown",
        "id": "a06e73733088436b",
        "text": "– https://www.scch.at/scch/presse-medien/detail/software-analyse-habt-in-programmen-verstecktes-wissen"
      },
      "date": 1659992297187
    },
    {
      "item": {
        "type": "factory",
        "id": "299c7fcdccc139cc"
      },
      "id": "299c7fcdccc139cc",
      "type": "add",
      "after": "a06e73733088436b",
      "date": 1659992396554
    },
    {
      "type": "edit",
      "id": "299c7fcdccc139cc",
      "item": {
        "type": "paragraph",
        "id": "299c7fcdccc139cc",
        "text": "– https://d-nb.info/968052150/34"
      },
      "date": 1659992400562
    },
    {
      "type": "edit",
      "id": "299c7fcdccc139cc",
      "item": {
        "type": "markdown",
        "id": "299c7fcdccc139cc",
        "text": "– https://d-nb.info/968052150/34"
      },
      "date": 1659992401767
    },
    {
      "item": {
        "type": "factory",
        "id": "9de2f56ed523e003"
      },
      "id": "9de2f56ed523e003",
      "type": "add",
      "after": "299c7fcdccc139cc",
      "date": 1659992451874
    },
    {
      "type": "edit",
      "id": "9de2f56ed523e003",
      "item": {
        "type": "paragraph",
        "id": "9de2f56ed523e003",
        "text": "– https://d-nb.info/1044451912/34"
      },
      "date": 1659992455395
    },
    {
      "type": "edit",
      "id": "9de2f56ed523e003",
      "item": {
        "type": "markdown",
        "id": "9de2f56ed523e003",
        "text": "– https://d-nb.info/1044451912/34"
      },
      "date": 1659992456705
    },
    {
      "item": {
        "type": "factory",
        "id": "0599a31d2670ecee"
      },
      "id": "0599a31d2670ecee",
      "type": "add",
      "after": "9de2f56ed523e003",
      "date": 1659992541546
    },
    {
      "type": "edit",
      "id": "0599a31d2670ecee",
      "item": {
        "type": "paragraph",
        "id": "0599a31d2670ecee",
        "text": "GRAphe Fonctionnel de Commande Etape et Transitions (GRAFCET)"
      },
      "date": 1659992544907
    },
    {
      "item": {
        "type": "factory",
        "id": "fff722d44a954941"
      },
      "id": "fff722d44a954941",
      "type": "add",
      "after": "0599a31d2670ecee",
      "date": 1659992765512
    },
    {
      "type": "edit",
      "id": "fff722d44a954941",
      "item": {
        "type": "paragraph",
        "id": "fff722d44a954941",
        "text": "– https://www.sps-forum.de/threads/suche-etwas-seltsame-sps.13382/"
      },
      "date": 1659992769954
    },
    {
      "type": "edit",
      "id": "fff722d44a954941",
      "item": {
        "type": "markdown",
        "id": "fff722d44a954941",
        "text": "– https://www.sps-forum.de/threads/suche-etwas-seltsame-sps.13382/"
      },
      "date": 1659992771130
    },
    {
      "item": {
        "type": "factory",
        "id": "61551793910c8c4c"
      },
      "id": "61551793910c8c4c",
      "type": "add",
      "after": "fff722d44a954941",
      "date": 1659992929538
    },
    {
      "type": "edit",
      "id": "61551793910c8c4c",
      "item": {
        "type": "paragraph",
        "id": "61551793910c8c4c",
        "text": "– https://www.automation.com/en-us/products/product03/itris-automation-announces-plc-checker-now-with-pl"
      },
      "date": 1659992932786
    },
    {
      "type": "edit",
      "id": "61551793910c8c4c",
      "item": {
        "type": "markdown",
        "id": "61551793910c8c4c",
        "text": "– https://www.automation.com/en-us/products/product03/itris-automation-announces-plc-checker-now-with-pl"
      },
      "date": 1659992933933
    },
    {
      "type": "edit",
      "id": "61551793910c8c4c",
      "item": {
        "type": "markdown",
        "id": "61551793910c8c4c",
        "text": "PLC Checker from Itris Automation. [https://www.automation.com/en-us/products/product03/itris-automation-announces-plc-checker-now-with-pl pge]"
      },
      "date": 1659992961100
    },
    {
      "type": "edit",
      "id": "61551793910c8c4c",
      "item": {
        "type": "markdown",
        "id": "61551793910c8c4c",
        "text": "PLC Checker from Itris Automation. [https://www.automation.com/en-us/products/product03/itris-automation-announces-plc-checker-now-with-pl page]"
      },
      "date": 1659992974802
    },
    {
      "type": "edit",
      "id": "71d7e497aeb8db38",
      "item": {
        "type": "paragraph",
        "id": "71d7e497aeb8db38",
        "text": "\"[[Proof]]\": \nSpencer Brown uses demonstration. \nProof is when you step outside of your computational system and we didn't do that \nso proof isn't an appropriate word \nbut you know Dirk mentioned that the mark is a combination of both thinking about implication and negation \nwe tried to eliminate thinking about all those concepts and just looked at structural patterning \nthat was a demonstration that the structural pattern you can make go away\n"
      },
      "date": 1660028576815
    }
  ]
}