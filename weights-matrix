{
  "title": "Weights Matrix",
  "story": [
    {
      "type": "paragraph",
      "id": "b30730839d0a0368",
      "text": "We prefer to improve [[SOM]] type networks so the weighting problem wouldn’t often happen as matrixes are updated during runs and not as predefined list of [[Vector]]s of numbers. In this case creativity of SOM is considered more than static fixed weighting matrix based ANNs. […]"
    },
    {
      "type": "pagefold",
      "id": "d0022cabc69767d1",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "3d3db7f0b9c1ec56",
      "text": "Abstract— the artificial neural networks have an important role in current life with higher expectations. The art of using these ANNs give us a good insight for problem solving. For example the applications in pattern recognition and regression are two areas in which ANNs are working well. Signal processing itself investigates broad ranges of ANNs. The purpose of this paper is, scanning connection routes of one and two layer networks that may be used as default structure in data replacing and signal analyzing. When a signal is considered as a variable by a problem solver, the problem solver chooses the best possible ANNs to solve it. But the way we ensure the high possibilities of reliability for these types of networks, while the compatibility is still needed is important. We present several factors to measure the capability of a specific network, for a specific problem the one like E-machine learning. Formal proofs for claim are provided as well. Finally we try to optimize Kohonen SOM using factor C’."
    },
    {
      "type": "pagefold",
      "id": "f22e2b58f31ba8bc",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "39d3862832fc9ca6",
      "text": "\nRAHMATI, Vahid, YAR, Morteza Husainy and MALEKIJAVAN, Ali Reza, 2014. Neural Networks New Capacity Factor Measurement for Improvement of SOM. . 2014. Vol. 3, no. 12. \n"
    },
    {
      "type": "paragraph",
      "id": "6990bf7db33fbfb4",
      "text": "Application of C’ for SOM Optimization"
    },
    {
      "type": "paragraph",
      "id": "ad92f0b7aa2a53a6",
      "text": "The main goal for calculating C’ is to optimize the weights matrix. Here we don’t define any initializing values but we can improve it in running time. The optimization is equal to making r equal to 1. It is very clear that for the first round the C’ is absolutely non-one[10]. So the set of problems in Gpm defines the accuracy of capacity factor. For example if Gp5 is used 5 problems are equal to 5 rounds in this algorithm and r is calculated separately and C’ is the average value. "
    },
    {
      "type": "paragraph",
      "id": "24710acfb67df370",
      "text": "When the algorithm is initialized by user weight matrix the first few rounds show the reliability, and we easily measure C’, if C’ is near zero we modify weighting formula, if it’s near 1 we don’t modify formula. Each modification depends on m or index of problem group. "
    },
    {
      "type": "paragraph",
      "id": "839a062e3f65d6b2",
      "text": "By this trick we alter weight matrix to converge as fast as possible. C’ is in fact a dynamic factor that is modified over rounds. This inline C’ calculation makes the algorithm faster. The memory consumption for calculating C’ is not too much and can be ignored."
    },
    {
      "type": "paragraph",
      "id": "3fc22d90c85db1e8",
      "text": "Here we provide modified version of Kohonen SOM algorithm. By this C’ we can alter wij to help the algorithm converge faster[12]. Here we modify Kohonen SOM algorithm and make it a bit faster by improving weighting process. This happens while the algorithm is running. Algorithm:"
    },
    {
      "type": "paragraph",
      "id": "ba27b2dfcfcb10b5",
      "text": "0. Define wij weights and learning rate. "
    },
    {
      "type": "paragraph",
      "id": "6ea387822fc38340",
      "text": "1. While not stopped loop for 2 to 8. "
    },
    {
      "type": "paragraph",
      "id": "c26a319de71d7776",
      "text": "2. For each [[Vector]] x repeat 3 to 5. If new vector then reset pc and pw. "
    },
    {
      "type": "paragraph",
      "id": "764bd0041bb38685",
      "text": "3. Find D (j) by (8). "
    },
    {
      "type": "paragraph",
      "id": "96a8561d31168168",
      "text": "4. Make D (j) minimum for specific j. "
    },
    {
      "type": "paragraph",
      "id": "29bc3304eacf4224",
      "text": "5. Calculate pc and pw for number of loops from 2 to 8. "
    },
    {
      "type": "paragraph",
      "id": "9e57cde7894c4989",
      "text": "6. Calculate C’ in Gpm where m is the number of input vectors. "
    },
    {
      "type": "paragraph",
      "id": "5c5dc3f786a393bb",
      "text": "7. If d= wij (new)-wij (old) < 10-3 and 1-C’<10-3 go to 12 "
    },
    {
      "type": "paragraph",
      "id": "b331533f2a128886",
      "text": "8. wij (new) = wij (old)+ 0.5α (xi-wij(old)). "
    },
    {
      "type": "paragraph",
      "id": "46b73cf4e6d0c144",
      "text": "9. If d= wij (new)-wij (old) < 10-3 go to 12 "
    },
    {
      "type": "paragraph",
      "id": "74f85164dc33f894",
      "text": "10. wij (new) = wij (old)+ α (xi-wij(old)) "
    },
    {
      "type": "paragraph",
      "id": "b15248a30f9a4665",
      "text": "11. Go to 2 "
    },
    {
      "type": "paragraph",
      "id": "8ecc561acdff01b1",
      "text": "12. Stop."
    },
    {
      "type": "paragraph",
      "id": "294a8f57b94d9644",
      "text": "In this algorithm the weighting matrix is modified according to convergent speed the step 8 can use an alternative form, but the convergence criteria must be considered as well."
    },
    {
      "type": "paragraph",
      "id": "2510b85da685a865",
      "text": "Conclusions"
    },
    {
      "type": "paragraph",
      "id": "91005a227856e813",
      "text": "We measured a factor called C’ to increase speed of a chosen SOM. This lets us to make better algorithms. In this paper we used C’ as a new factor. But this capacity factor does not ensure convergence. The only important factor for convergence is the weighting matrix itself. We brought an example of modified Kohonen SOM. It makes the algorithm faster. We calculated this for 10 vectors of different length by using C’. […]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Weights Matrix",
        "story": []
      },
      "date": 1674573102383
    },
    {
      "id": "39d3862832fc9ca6",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "39d3862832fc9ca6",
        "text": "\nRAHMATI, Vahid, YAR, Morteza Husainy and MALEKIJAVAN, Ali Reza, 2014. Neural Networks New Capacity Factor Measurement for Improvement of SOM. . 2014. Vol. 3, no. 12. \n"
      },
      "date": 1674573105517
    },
    {
      "item": {
        "type": "factory",
        "id": "3d3db7f0b9c1ec56"
      },
      "id": "3d3db7f0b9c1ec56",
      "type": "add",
      "after": "39d3862832fc9ca6",
      "date": 1674573131638
    },
    {
      "type": "edit",
      "id": "3d3db7f0b9c1ec56",
      "item": {
        "type": "paragraph",
        "id": "3d3db7f0b9c1ec56",
        "text": "Abstract— the artificial neural networks have an important role in current life with higher expectations. The art of using these ANNs give us a good insight for problem solving. For example the applications in pattern recognition and regression are two areas in which ANNs are working well. Signal processing itself investigates broad ranges of ANNs. The purpose of this paper is, scanning connection routes of one and two layer networks that may be used as default structure in data replacing and signal analyzing. When a signal is considered as a variable by a problem solver, the problem solver chooses the best possible ANNs to solve it. But the way we ensure the high possibilities of reliability for these types of networks, while the compatibility is still needed is important. We present several factors to measure the capability of a specific network, for a specific problem the one like E-machine learning. Formal proofs for claim are provided as well. Finally we try to optimize Kohonen SOM using factor C’."
      },
      "date": 1674573133561
    },
    {
      "id": "3d3db7f0b9c1ec56",
      "type": "move",
      "order": [
        "3d3db7f0b9c1ec56",
        "39d3862832fc9ca6"
      ],
      "date": 1674573135070
    },
    {
      "item": {
        "type": "factory",
        "id": "f22e2b58f31ba8bc"
      },
      "id": "f22e2b58f31ba8bc",
      "type": "add",
      "after": "39d3862832fc9ca6",
      "date": 1674573136840
    },
    {
      "type": "edit",
      "id": "f22e2b58f31ba8bc",
      "item": {
        "type": "pagefold",
        "id": "f22e2b58f31ba8bc",
        "text": "~"
      },
      "date": 1674573139758
    },
    {
      "id": "f22e2b58f31ba8bc",
      "type": "move",
      "order": [
        "3d3db7f0b9c1ec56",
        "f22e2b58f31ba8bc",
        "39d3862832fc9ca6"
      ],
      "date": 1674573142032
    },
    {
      "item": {
        "type": "factory",
        "id": "d0022cabc69767d1"
      },
      "id": "d0022cabc69767d1",
      "type": "add",
      "after": "39d3862832fc9ca6",
      "date": 1674573144987
    },
    {
      "type": "edit",
      "id": "d0022cabc69767d1",
      "item": {
        "type": "pagefold",
        "id": "d0022cabc69767d1",
        "text": "~"
      },
      "date": 1674573148740
    },
    {
      "id": "d0022cabc69767d1",
      "type": "move",
      "order": [
        "d0022cabc69767d1",
        "3d3db7f0b9c1ec56",
        "f22e2b58f31ba8bc",
        "39d3862832fc9ca6"
      ],
      "date": 1674573150756
    },
    {
      "item": {
        "type": "factory",
        "id": "b30730839d0a0368"
      },
      "id": "b30730839d0a0368",
      "type": "add",
      "after": "39d3862832fc9ca6",
      "date": 1674573155507
    },
    {
      "id": "b30730839d0a0368",
      "type": "move",
      "order": [
        "b30730839d0a0368",
        "d0022cabc69767d1",
        "3d3db7f0b9c1ec56",
        "f22e2b58f31ba8bc",
        "39d3862832fc9ca6"
      ],
      "date": 1674573158472
    },
    {
      "type": "edit",
      "id": "b30730839d0a0368",
      "item": {
        "type": "paragraph",
        "id": "b30730839d0a0368",
        "text": "Here in a table we list several factors of measures that is used for optimizing a chosen ANN, We prefer to improve SOM type networks so the weighting problem wouldn’t often happen as matrixes are updated during runs and not as predefined list of vectors of numbers. In this case creativity of SOM is considered more than static fixed weighting matrix based ANNs."
      },
      "date": 1674573160693
    },
    {
      "type": "edit",
      "id": "b30730839d0a0368",
      "item": {
        "type": "paragraph",
        "id": "b30730839d0a0368",
        "text": "Here we list several factors of measures that is used for optimizing a chosen ANN, We prefer to improve SOM type networks so the weighting problem wouldn’t often happen as matrixes are updated during runs and not as predefined list of vectors of numbers. In this case creativity of SOM is considered more than static fixed weighting matrix based ANNs."
      },
      "date": 1674573192277
    },
    {
      "type": "edit",
      "id": "b30730839d0a0368",
      "item": {
        "type": "paragraph",
        "id": "b30730839d0a0368",
        "text": "Here we list several factors of measures that is used for optimizing a chosen ANN, We prefer to improve SOM type networks so the weighting problem wouldn’t often happen as matrixes are updated during runs and not as predefined list of vectors of numbers. In this case creativity of SOM is considered more than static fixed weighting matrix based ANNs. […]"
      },
      "date": 1674573197338
    },
    {
      "type": "edit",
      "id": "b30730839d0a0368",
      "item": {
        "type": "paragraph",
        "id": "b30730839d0a0368",
        "text": "We prefer to improve SOM type networks so the weighting problem wouldn’t often happen as matrixes are updated during runs and not as predefined list of vectors of numbers. In this case creativity of SOM is considered more than static fixed weighting matrix based ANNs. […]"
      },
      "date": 1674573234623
    },
    {
      "type": "edit",
      "id": "b30730839d0a0368",
      "item": {
        "type": "paragraph",
        "id": "b30730839d0a0368",
        "text": "We prefer to improve [[SOM]] type networks so the weighting problem wouldn’t often happen as matrixes are updated during runs and not as predefined list of vectors of numbers. In this case creativity of SOM is considered more than static fixed weighting matrix based ANNs. […]"
      },
      "date": 1674573244381
    },
    {
      "item": {
        "type": "factory",
        "id": "6990bf7db33fbfb4"
      },
      "id": "6990bf7db33fbfb4",
      "type": "add",
      "after": "39d3862832fc9ca6",
      "date": 1674573320386
    },
    {
      "type": "edit",
      "id": "6990bf7db33fbfb4",
      "item": {
        "type": "paragraph",
        "id": "6990bf7db33fbfb4",
        "text": "Application of C’ for SOM Optimization"
      },
      "date": 1674573332460
    },
    {
      "item": {
        "type": "factory",
        "id": "ad92f0b7aa2a53a6"
      },
      "id": "ad92f0b7aa2a53a6",
      "type": "add",
      "after": "6990bf7db33fbfb4",
      "date": 1674573353427
    },
    {
      "type": "edit",
      "id": "ad92f0b7aa2a53a6",
      "item": {
        "type": "paragraph",
        "id": "ad92f0b7aa2a53a6",
        "text": "The main goal for calculating C’ is to optimize the weights matrix. Here we don’t define any initializing values but we can improve it in running time. The optimization is equal to making r equal to 1. It is very clear that for the first round the C’ is absolutely non-one[10]. So the set of problems in Gpm defines the accuracy of capacity factor. For example if Gp5 is used 5 problems are equal to 5 rounds in this algorithm and r is calculated separately and C’ is the average value. When the algorithm is initialized by user weight matrix the first few rounds show the reliability, and we easily measure C’, if C’ is near zero we modify weighting formula, if it’s near 1 we don’t modify formula. Each modification depends on m or index of problem group. By this trick we alter weight matrix to converge as fast as possible. C’ is in fact a dynamic factor that is modified over rounds. This inline C’ calculation makes the algorithm faster. The memory consumption for calculating C’ is not too much and can be ignored."
      },
      "date": 1674573356987
    },
    {
      "type": "edit",
      "id": "ad92f0b7aa2a53a6",
      "item": {
        "type": "paragraph",
        "id": "ad92f0b7aa2a53a6",
        "text": "The main goal for calculating C’ is to optimize the weights matrix. Here we don’t define any initializing values but we can improve it in running time. The optimization is equal to making r equal to 1. It is very clear that for the first round the C’ is absolutely non-one[10]. So the set of problems in Gpm defines the accuracy of capacity factor. For example if Gp5 is used 5 problems are equal to 5 rounds in this algorithm and r is calculated separately and C’ is the average value. "
      },
      "date": 1674573390390
    },
    {
      "type": "add",
      "id": "24710acfb67df370",
      "item": {
        "type": "paragraph",
        "id": "24710acfb67df370",
        "text": "When the algorithm is initialized by user weight matrix the first few rounds show the reliability, and we easily measure C’, if C’ is near zero we modify weighting formula, if it’s near 1 we don’t modify formula. Each modification depends on m or index of problem group. By this trick we alter weight matrix to converge as fast as possible. C’ is in fact a dynamic factor that is modified over rounds. This inline C’ calculation makes the algorithm faster. The memory consumption for calculating C’ is not too much and can be ignored."
      },
      "after": "ad92f0b7aa2a53a6",
      "date": 1674573391159
    },
    {
      "type": "edit",
      "id": "24710acfb67df370",
      "item": {
        "type": "paragraph",
        "id": "24710acfb67df370",
        "text": "When the algorithm is initialized by user weight matrix the first few rounds show the reliability, and we easily measure C’, if C’ is near zero we modify weighting formula, if it’s near 1 we don’t modify formula. Each modification depends on m or index of problem group. "
      },
      "date": 1674573423633
    },
    {
      "type": "add",
      "id": "839a062e3f65d6b2",
      "item": {
        "type": "paragraph",
        "id": "839a062e3f65d6b2",
        "text": "By this trick we alter weight matrix to converge as fast as possible. C’ is in fact a dynamic factor that is modified over rounds. This inline C’ calculation makes the algorithm faster. The memory consumption for calculating C’ is not too much and can be ignored."
      },
      "after": "24710acfb67df370",
      "date": 1674573424067
    },
    {
      "item": {
        "type": "factory",
        "id": "3fc22d90c85db1e8"
      },
      "id": "3fc22d90c85db1e8",
      "type": "add",
      "after": "839a062e3f65d6b2",
      "date": 1674573450487
    },
    {
      "type": "edit",
      "id": "3fc22d90c85db1e8",
      "item": {
        "type": "paragraph",
        "id": "3fc22d90c85db1e8",
        "text": "Here we provide modified version of Kohonen SOM algorithm. By this C’ we can alter wij to help the algorithm"
      },
      "date": 1674573453302
    },
    {
      "type": "edit",
      "id": "3fc22d90c85db1e8",
      "item": {
        "type": "paragraph",
        "id": "3fc22d90c85db1e8",
        "text": "Here we provide modified version of Kohonen SOM algorithm. By this C’ we can alter wij to help the algorithm converge faster[12]. Here we modify Kohonen SOM algorithm and make it a bit faster by improving weighting process. This happens while the algorithm is running. Algorithm:"
      },
      "date": 1674573463841
    },
    {
      "item": {
        "type": "factory",
        "id": "ba27b2dfcfcb10b5"
      },
      "id": "ba27b2dfcfcb10b5",
      "type": "add",
      "after": "3fc22d90c85db1e8",
      "date": 1674573472220
    },
    {
      "type": "edit",
      "id": "ba27b2dfcfcb10b5",
      "item": {
        "type": "paragraph",
        "id": "ba27b2dfcfcb10b5",
        "text": "0. Define wij weights and learning rate. "
      },
      "date": 1674573476259
    },
    {
      "type": "add",
      "id": "6ea387822fc38340",
      "item": {
        "type": "paragraph",
        "id": "6ea387822fc38340",
        "text": "1. While not stopped loop for 2 to 8. "
      },
      "after": "ba27b2dfcfcb10b5",
      "date": 1674573479577
    },
    {
      "type": "add",
      "id": "c26a319de71d7776",
      "item": {
        "type": "paragraph",
        "id": "c26a319de71d7776",
        "text": "2. For each vector x repeat 3 to 5. If new vector then reset pc and pw. "
      },
      "after": "6ea387822fc38340",
      "date": 1674573482707
    },
    {
      "type": "add",
      "id": "764bd0041bb38685",
      "item": {
        "type": "paragraph",
        "id": "764bd0041bb38685",
        "text": "3. Find D (j) by (8). "
      },
      "after": "c26a319de71d7776",
      "date": 1674573484935
    },
    {
      "type": "add",
      "id": "96a8561d31168168",
      "item": {
        "type": "paragraph",
        "id": "96a8561d31168168",
        "text": "4. Make D (j) minimum for specific j. "
      },
      "after": "764bd0041bb38685",
      "date": 1674573488278
    },
    {
      "type": "add",
      "id": "29bc3304eacf4224",
      "item": {
        "type": "paragraph",
        "id": "29bc3304eacf4224",
        "text": "5. Calculate pc and pw for number of loops from 2 to 8. "
      },
      "after": "96a8561d31168168",
      "date": 1674573492800
    },
    {
      "type": "add",
      "id": "9e57cde7894c4989",
      "item": {
        "type": "paragraph",
        "id": "9e57cde7894c4989",
        "text": "6. Calculate C’ in Gpm where m is the number of input vectors. "
      },
      "after": "29bc3304eacf4224",
      "date": 1674573497895
    },
    {
      "type": "add",
      "id": "5c5dc3f786a393bb",
      "item": {
        "type": "paragraph",
        "id": "5c5dc3f786a393bb",
        "text": "7. If d= wij (new)-wij (old) < 10-3 and 1-C’<10-3 go to 12 "
      },
      "after": "9e57cde7894c4989",
      "date": 1674573502583
    },
    {
      "type": "add",
      "id": "b331533f2a128886",
      "item": {
        "type": "paragraph",
        "id": "b331533f2a128886",
        "text": "8. wij (new) = wij (old)+ 0.5α (xi-wij(old)). "
      },
      "after": "5c5dc3f786a393bb",
      "date": 1674573505509
    },
    {
      "type": "add",
      "id": "46b73cf4e6d0c144",
      "item": {
        "type": "paragraph",
        "id": "46b73cf4e6d0c144",
        "text": "9. If d= wij (new)-wij (old) < 10-3 go to 12 "
      },
      "after": "b331533f2a128886",
      "date": 1674573508211
    },
    {
      "type": "add",
      "id": "74f85164dc33f894",
      "item": {
        "type": "paragraph",
        "id": "74f85164dc33f894",
        "text": "10. wij (new) = wij (old)+ α (xi-wij(old)) "
      },
      "after": "46b73cf4e6d0c144",
      "date": 1674573510552
    },
    {
      "type": "add",
      "id": "b15248a30f9a4665",
      "item": {
        "type": "paragraph",
        "id": "b15248a30f9a4665",
        "text": "11. Go to 2 "
      },
      "after": "74f85164dc33f894",
      "date": 1674573513177
    },
    {
      "type": "add",
      "id": "8ecc561acdff01b1",
      "item": {
        "type": "paragraph",
        "id": "8ecc561acdff01b1",
        "text": "12. Stop."
      },
      "after": "b15248a30f9a4665",
      "date": 1674573514502
    },
    {
      "item": {
        "type": "factory",
        "id": "294a8f57b94d9644"
      },
      "id": "294a8f57b94d9644",
      "type": "add",
      "after": "8ecc561acdff01b1",
      "date": 1674573522873
    },
    {
      "type": "edit",
      "id": "294a8f57b94d9644",
      "item": {
        "type": "paragraph",
        "id": "294a8f57b94d9644",
        "text": "n this algorithm the weighting matrix is modified according to convergent speed the step 8 can use an alternative form, but the convergence criteria must be considered as well."
      },
      "date": 1674573524562
    },
    {
      "type": "edit",
      "id": "294a8f57b94d9644",
      "item": {
        "type": "paragraph",
        "id": "294a8f57b94d9644",
        "text": "In this algorithm the weighting matrix is modified according to convergent speed the step 8 can use an alternative form, but the convergence criteria must be considered as well."
      },
      "date": 1674573527704
    },
    {
      "item": {
        "type": "factory",
        "id": "2510b85da685a865"
      },
      "id": "2510b85da685a865",
      "type": "add",
      "after": "294a8f57b94d9644",
      "date": 1674573595689
    },
    {
      "type": "edit",
      "id": "2510b85da685a865",
      "item": {
        "type": "paragraph",
        "id": "2510b85da685a865",
        "text": "Conclusions"
      },
      "date": 1674573599130
    },
    {
      "item": {
        "type": "factory",
        "id": "91005a227856e813"
      },
      "id": "91005a227856e813",
      "type": "add",
      "after": "2510b85da685a865",
      "date": 1674573610913
    },
    {
      "type": "edit",
      "id": "91005a227856e813",
      "item": {
        "type": "paragraph",
        "id": "91005a227856e813",
        "text": "We measured a factor called C’ to increase speed of a chosen SOM. This lets us to make better algorithms. In this paper we used C’ as a new factor. But this capacity factor does not ensure convergence. The only important factor for convergence is the weighting matrix itself. We brought an example of modified Kohonen SOM. It makes the algorithm faster. We calculated this for 10 vectors of different length by using C’. […]"
      },
      "date": 1674573616672
    },
    {
      "type": "edit",
      "id": "b30730839d0a0368",
      "item": {
        "type": "paragraph",
        "id": "b30730839d0a0368",
        "text": "We prefer to improve [[SOM]] type networks so the weighting problem wouldn’t often happen as matrixes are updated during runs and not as predefined list of [[Vector]]s of numbers. In this case creativity of SOM is considered more than static fixed weighting matrix based ANNs. […]"
      },
      "date": 1674573888466
    },
    {
      "type": "edit",
      "id": "c26a319de71d7776",
      "item": {
        "type": "paragraph",
        "id": "c26a319de71d7776",
        "text": "2. For each [[Vector]] x repeat 3 to 5. If new vector then reset pc and pw. "
      },
      "date": 1674573984568
    }
  ]
}