{
  "title": "2024-03-03",
  "story": [
    {
      "type": "paragraph",
      "id": "c09be728375de48e",
      "text": "[[~/place/0]]"
    },
    {
      "type": "paragraph",
      "id": "cc39abd9f3f076e9",
      "text": "[[Antwort]]"
    },
    {
      "type": "paragraph",
      "id": "5a4aad493a81ca3c",
      "text": "[[How to Go From a Problem to a Bad Solution]]"
    },
    {
      "type": "paragraph",
      "id": "d7eed4326ddc2cba",
      "text": "[[Two Sheets of Paper]]"
    },
    {
      "type": "paragraph",
      "id": "ad1f7f1fc166e54c",
      "text": "[[Window Place]]"
    },
    {
      "type": "pagefold",
      "id": "c5eff04b7820cf10",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "cb6f4641675cb7c4",
      "text": "Javascript programming challenge: [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170943449574946OjiXF:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]\nI (Ward) have a program that identifies places by paths where a path would be an ordered collection of words (short strings). I am trying to write a program where I count how many times one [[Path]] leads to another. I'd like to represent this as two paths, p1 and p2, in an ordered array, a tuple [p1,p2]. how would I write a function, count, where I would say count([p1,p2]) and after a long run, get a list of tuples and how many times it occurred. I'm thinking this should be easily coded with ES6 collection types but just don't see how in the moment.\n\nI'm thinking that if a Bag were like a Set but were duplicates were counted, and if arrays defined equality as the recursive equality of its members, then my solution would be to just put all of my [p1,p2] in a bag and be done with it."
    },
    {
      "type": "paragraph",
      "id": "9c931a7eb084ca5e",
      "text": "Brian via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170943766775019tDpuo:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix] I'm a bit unclear in the problem description.  In graph theory, a path is a sequence of unique edges. (https://en.wikipedia.org/wiki/Path_(graph_theory) ).  Is this usage of path consistent or is it meant to mean something else?  If one path leads to another, does that mean that the first and last vertices of the path are common, or is it something about how the paths might intersect?"
    },
    {
      "type": "paragraph",
      "id": "c944defdf9de8f2c",
      "text": "Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170943818275033YdpPn:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix] In this case the path is a route from root to leaf of a parse tree. The elements are non-terminal names leading ultimately a terminal like \"keyword\" or \"number\"."
    },
    {
      "type": "paragraph",
      "id": "708280578c5078c1",
      "text": "The p1 and p2 will usually share a prefix but I'd like to handle cases where they don't."
    },
    {
      "type": "paragraph",
      "id": "2ff9d973b78ab3df",
      "text": "Brian via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170943852475045Qdtpq:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix] In the jargon of grammars, are you asking for counting the number of productions of a nonterminal?  Or are you asking for how many sequences can lead to a particular terminal, or am I still not following quite right yet (most likely)."
    },
    {
      "type": "paragraph",
      "id": "d536e3e202dc2125",
      "text": "Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170944105975139rnKRs:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix] Eric revised my interest in exploratory parsing showing that wiki might be ready to host it. My application is producing a tally of reductions processed while parsing a large corpus like a wikipedia dump.\nhttp://ward.dojo.fed.wiki/exploratory-parsing-in-frames.html"
    },
    {
      "type": "reference",
      "id": "37fb2d74db6289bb",
      "site": "wiki.dbbs.co",
      "slug": "exploratory-parsing-in-frames",
      "title": "Exploratory Parsing in Frames",
      "text": "A brief charter. We explore Ward's technique of Exploratory Parsing with 1 hour and a local wiki with the Frame Plugin and our esm.html script."
    },
    {
      "type": "pagefold",
      "id": "26f39e130f42a2d0",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "fc677c7ae0b90523",
      "text": "⇒ [[Recurring Problem]]"
    },
    {
      "type": "paragraph",
      "id": "45503966dace2ddf",
      "text": "I am interested in paths in the context of anti-patterns.\nAn anti-pattern is a pattern that describes how to get from a problem to a bad solution. (As opposed to an amelioration pattern, which describes the path from a bad solution to a good solution).\n\nI operationalize a problem in the form of a patlet, i.e. Start With a (first) Paragraph of a wiki page. This paragraph describes a recurring problem that is rooted in human nature, and the second paragraph describes something specific that could be done to \"solve\" the forces mentioned in the first paragraph.\n\nTherefore,\n\nHow to Go From a Problem to a (Bad) Solution and then describe the path from a bad solution to a good solution.\n\nThis makes the From Where relevant. This means the question of the starting point of our path. I therefore change the node shape of the starting point of the next speed bot journey. [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$17094678210tmDWp:dreyeck.freedombox.rocks?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2024-03-03",
        "story": []
      },
      "date": 1709458567841
    },
    {
      "item": {
        "type": "factory",
        "id": "359b344fff2cb583"
      },
      "id": "359b344fff2cb583",
      "type": "add",
      "date": 1709458569742
    },
    {
      "type": "edit",
      "id": "359b344fff2cb583",
      "item": {
        "type": "image",
        "id": "359b344fff2cb583",
        "text": "Ort im Netz der Nachrichtenpfade",
        "size": "wide",
        "width": 419,
        "height": 305,
        "url": "/assets/plugins/image/00eef7b7d26b938f1ad60090fec3d956.jpg"
      },
      "date": 1709458594614
    },
    {
      "item": {
        "type": "factory",
        "id": "14000399e49b22cd"
      },
      "id": "14000399e49b22cd",
      "type": "add",
      "after": "359b344fff2cb583",
      "date": 1709458922872
    },
    {
      "type": "edit",
      "id": "14000399e49b22cd",
      "item": {
        "type": "image",
        "id": "14000399e49b22cd",
        "text": "Fragen nach der Relation zwischen Problem und Lösung",
        "size": "wide",
        "width": 418,
        "height": 297,
        "url": "/assets/plugins/image/72424e8b1b3f7be9694a88049d9c0309.jpg"
      },
      "date": 1709458948550
    },
    {
      "item": {
        "type": "factory",
        "id": "c09be728375de48e"
      },
      "id": "c09be728375de48e",
      "type": "add",
      "after": "14000399e49b22cd",
      "date": 1709458958107
    },
    {
      "type": "edit",
      "id": "c09be728375de48e",
      "item": {
        "type": "paragraph",
        "id": "c09be728375de48e",
        "text": "[[~/place/0]]"
      },
      "date": 1709458971611
    },
    {
      "id": "14000399e49b22cd",
      "type": "remove",
      "removedTo": {
        "page": "~/place/0"
      },
      "date": 1709458997683
    },
    {
      "item": {
        "type": "factory",
        "id": "5a4aad493a81ca3c"
      },
      "id": "5a4aad493a81ca3c",
      "type": "add",
      "after": "c09be728375de48e",
      "date": 1709459428421
    },
    {
      "type": "edit",
      "id": "5a4aad493a81ca3c",
      "item": {
        "type": "paragraph",
        "id": "5a4aad493a81ca3c",
        "text": "[[How to Go From a Problem to a Bad Solution]]"
      },
      "date": 1709459444294
    },
    {
      "item": {
        "type": "factory",
        "id": "5178da314667ff16"
      },
      "id": "5178da314667ff16",
      "type": "add",
      "after": "5a4aad493a81ca3c",
      "date": 1709461229167
    },
    {
      "type": "edit",
      "id": "5178da314667ff16",
      "item": {
        "type": "image",
        "id": "5178da314667ff16",
        "text": "two-sheets-of-paper",
        "size": "wide",
        "width": 418,
        "height": 307,
        "url": "/assets/plugins/image/cc7bbf664599a61e496d7fcbe85eccca.jpg"
      },
      "date": 1709461246283
    },
    {
      "type": "edit",
      "id": "5178da314667ff16",
      "item": {
        "type": "image",
        "id": "5178da314667ff16",
        "text": "Two sheets of paper",
        "size": "wide",
        "width": 418,
        "height": 307,
        "url": "/assets/plugins/image/cc7bbf664599a61e496d7fcbe85eccca.jpg"
      },
      "date": 1709461281210
    },
    {
      "item": {
        "type": "factory",
        "id": "d7eed4326ddc2cba"
      },
      "id": "d7eed4326ddc2cba",
      "type": "add",
      "after": "5178da314667ff16",
      "date": 1709461288119
    },
    {
      "type": "edit",
      "id": "d7eed4326ddc2cba",
      "item": {
        "type": "paragraph",
        "id": "d7eed4326ddc2cba",
        "text": "[[Two Sheets of Paper]]"
      },
      "date": 1709461292650
    },
    {
      "id": "c09be728375de48e",
      "type": "move",
      "order": [
        "c09be728375de48e",
        "359b344fff2cb583",
        "5a4aad493a81ca3c",
        "5178da314667ff16",
        "d7eed4326ddc2cba"
      ],
      "date": 1709462282939
    },
    {
      "type": "add",
      "id": "cc39abd9f3f076e9",
      "item": {
        "type": "paragraph",
        "id": "cc39abd9f3f076e9",
        "text": "[[Antwort]]"
      },
      "after": "c09be728375de48e",
      "date": 1709462321688
    },
    {
      "id": "359b344fff2cb583",
      "type": "remove",
      "removedTo": {
        "page": "Antwort"
      },
      "date": 1709462344037
    },
    {
      "type": "remove",
      "id": "5178da314667ff16",
      "date": 1709462385749
    },
    {
      "item": {
        "type": "factory",
        "id": "cb6f4641675cb7c4"
      },
      "id": "cb6f4641675cb7c4",
      "type": "add",
      "after": "d7eed4326ddc2cba",
      "date": 1709463540300
    },
    {
      "type": "edit",
      "id": "cb6f4641675cb7c4",
      "item": {
        "type": "paragraph",
        "id": "cb6f4641675cb7c4",
        "text": "Javascript programming challenge:\nI have a program that identifies places by paths where a path would be an ordered collection of words (short strings). I am trying to write a program where I count how many times one path leads to another. I'd like to represent this as two paths, p1 and p2, in an ordered array, a tuple [p1,p2]. how would I write a function, count, where I would say count([p1,p2]) and after a long run, get a list of tuples and how many times it occurred. I'm thinking this should be easily coded with ES6 collection types but just don't see how in the moment.\n\nI'm thinking that if a Bag were like a Set but were duplicates were counted, and if arrays defined equality as the recursive equality of its members, then my solution would be to just put all of my [p1,p2] in a bag and be done with it."
      },
      "date": 1709463542349
    },
    {
      "type": "edit",
      "id": "cb6f4641675cb7c4",
      "item": {
        "type": "paragraph",
        "id": "cb6f4641675cb7c4",
        "text": "Javascript programming challenge: [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170943449574946OjiXF:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]\nI (Ward) have a program that identifies places by paths where a path would be an ordered collection of words (short strings). I am trying to write a program where I count how many times one path leads to another. I'd like to represent this as two paths, p1 and p2, in an ordered array, a tuple [p1,p2]. how would I write a function, count, where I would say count([p1,p2]) and after a long run, get a list of tuples and how many times it occurred. I'm thinking this should be easily coded with ES6 collection types but just don't see how in the moment.\n\nI'm thinking that if a Bag were like a Set but were duplicates were counted, and if arrays defined equality as the recursive equality of its members, then my solution would be to just put all of my [p1,p2] in a bag and be done with it."
      },
      "date": 1709463599802
    },
    {
      "item": {
        "type": "factory",
        "id": "c5eff04b7820cf10"
      },
      "id": "c5eff04b7820cf10",
      "type": "add",
      "after": "cb6f4641675cb7c4",
      "date": 1709463607054
    },
    {
      "type": "edit",
      "id": "c5eff04b7820cf10",
      "item": {
        "type": "pagefold",
        "id": "c5eff04b7820cf10",
        "text": "~"
      },
      "date": 1709463611600
    },
    {
      "id": "c5eff04b7820cf10",
      "type": "move",
      "order": [
        "c09be728375de48e",
        "cc39abd9f3f076e9",
        "5a4aad493a81ca3c",
        "d7eed4326ddc2cba",
        "c5eff04b7820cf10",
        "cb6f4641675cb7c4"
      ],
      "date": 1709463619761
    },
    {
      "item": {
        "type": "factory",
        "id": "9c931a7eb084ca5e"
      },
      "id": "9c931a7eb084ca5e",
      "type": "add",
      "after": "cb6f4641675cb7c4",
      "date": 1709463653057
    },
    {
      "type": "edit",
      "id": "9c931a7eb084ca5e",
      "item": {
        "type": "paragraph",
        "id": "9c931a7eb084ca5e",
        "text": "Brian via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170943766775019tDpuo:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]"
      },
      "date": 1709463663168
    },
    {
      "type": "edit",
      "id": "9c931a7eb084ca5e",
      "item": {
        "type": "paragraph",
        "id": "9c931a7eb084ca5e",
        "text": "Brian via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170943766775019tDpuo:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix] I'm a bit unclear in the problem description.  In graph theory, a path is a sequence of unique edges. (https://en.wikipedia.org/wiki/Path_(graph_theory) ).  Is this usage of path consistent or is it meant to mean something else?  If one path leads to another, does that mean that the first and last vertices of the path are common, or is it something about how the paths might intersect?"
      },
      "date": 1709463674699
    },
    {
      "type": "add",
      "id": "c944defdf9de8f2c",
      "item": {
        "type": "paragraph",
        "id": "c944defdf9de8f2c",
        "text": "Ward via [matrix] In this case the path is a route from root to leaf of a parse tree. The elements are non-terminal names leading ultimately a terminal like \"keyword\" or \"number\"."
      },
      "after": "9c931a7eb084ca5e",
      "date": 1709463717983
    },
    {
      "type": "edit",
      "id": "c944defdf9de8f2c",
      "item": {
        "type": "paragraph",
        "id": "c944defdf9de8f2c",
        "text": "Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170943818275033YdpPn:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix] In this case the path is a route from root to leaf of a parse tree. The elements are non-terminal names leading ultimately a terminal like \"keyword\" or \"number\"."
      },
      "date": 1709463729914
    },
    {
      "type": "add",
      "id": "708280578c5078c1",
      "item": {
        "type": "paragraph",
        "id": "708280578c5078c1",
        "text": "The p1 and p2 will usually share a prefix but I'd like to handle cases where they don't."
      },
      "after": "c944defdf9de8f2c",
      "date": 1709463772123
    },
    {
      "item": {
        "type": "factory",
        "id": "2ff9d973b78ab3df"
      },
      "id": "2ff9d973b78ab3df",
      "type": "add",
      "after": "708280578c5078c1",
      "date": 1709463790179
    },
    {
      "type": "edit",
      "id": "2ff9d973b78ab3df",
      "item": {
        "type": "paragraph",
        "id": "2ff9d973b78ab3df",
        "text": "Brian via [matrix]"
      },
      "date": 1709463799959
    },
    {
      "type": "edit",
      "id": "2ff9d973b78ab3df",
      "item": {
        "type": "paragraph",
        "id": "2ff9d973b78ab3df",
        "text": "Brian via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170943852475045Qdtpq:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]"
      },
      "date": 1709463808542
    },
    {
      "item": {
        "type": "factory",
        "id": "d536e3e202dc2125"
      },
      "id": "d536e3e202dc2125",
      "type": "add",
      "after": "2ff9d973b78ab3df",
      "date": 1709463837362
    },
    {
      "type": "edit",
      "id": "d536e3e202dc2125",
      "item": {
        "type": "paragraph",
        "id": "d536e3e202dc2125",
        "text": "Ward via [matrix] Eric revised my interest in exploratory parsing showing that wiki might be ready to host it. My application is producing a tally of reductions processed while parsing a large corpus like a wikipedia dump.\nhttp://ward.dojo.fed.wiki/exploratory-parsing-in-frames.html"
      },
      "date": 1709463849703
    },
    {
      "item": {
        "type": "factory",
        "id": "37fb2d74db6289bb"
      },
      "id": "37fb2d74db6289bb",
      "type": "add",
      "after": "d536e3e202dc2125",
      "date": 1709463851696
    },
    {
      "type": "edit",
      "id": "37fb2d74db6289bb",
      "item": {
        "type": "reference",
        "id": "37fb2d74db6289bb",
        "site": "wiki.dbbs.co",
        "slug": "exploratory-parsing-in-frames",
        "title": "Exploratory Parsing in Frames",
        "text": "A brief charter. We explore Ward's technique of Exploratory Parsing with 1 hour and a local wiki with the Frame Plugin and our esm.html script."
      },
      "date": 1709463855383
    },
    {
      "type": "edit",
      "id": "d536e3e202dc2125",
      "item": {
        "type": "paragraph",
        "id": "d536e3e202dc2125",
        "text": "Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170944105975139rnKRs:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix] Eric revised my interest in exploratory parsing showing that wiki might be ready to host it. My application is producing a tally of reductions processed while parsing a large corpus like a wikipedia dump.\nhttp://ward.dojo.fed.wiki/exploratory-parsing-in-frames.html"
      },
      "date": 1709463981540
    },
    {
      "type": "edit",
      "id": "2ff9d973b78ab3df",
      "item": {
        "type": "paragraph",
        "id": "2ff9d973b78ab3df",
        "text": "Brian via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170943852475045Qdtpq:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix] In the jargon of grammars, are you asking for counting the number of productions of a nonterminal?  Or are you asking for how many sequences can lead to a particular terminal, or am I still not following quite right yet (most likely)."
      },
      "date": 1709463998754
    },
    {
      "type": "add",
      "id": "ad1f7f1fc166e54c",
      "item": {
        "type": "paragraph",
        "id": "ad1f7f1fc166e54c",
        "text": "[[Window Place]]"
      },
      "after": "d7eed4326ddc2cba",
      "date": 1709464285195
    },
    {
      "id": "c5e84ce6b92a6d8c",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "c5e84ce6b92a6d8c",
        "text": "Consider one simple problem that can appear in the architecture. Let us assume that a person wants be comfortable in a room, implying that the person needs to to sit down to really feel comfortable. Additionally, the sunlight is an issue, since the person is most likely to prefer to sit near the light. Thus, forces in this example are: (i) the desire to sit down, and (ii) the desire to be near light. The solution to this problem could be that in every room the architect should make one window into a window place."
      },
      "after": "c5eff04b7820cf10",
      "attribution": {
        "page": "What Is a Pattern?"
      },
      "date": 1709464354969
    },
    {
      "id": "c5e84ce6b92a6d8c",
      "type": "remove",
      "removedTo": {
        "page": "Window Place"
      },
      "date": 1709464370652
    },
    {
      "type": "edit",
      "id": "cb6f4641675cb7c4",
      "item": {
        "type": "paragraph",
        "id": "cb6f4641675cb7c4",
        "text": "Javascript programming challenge: [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$170943449574946OjiXF:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]\nI (Ward) have a program that identifies places by paths where a path would be an ordered collection of words (short strings). I am trying to write a program where I count how many times one [[Path]] leads to another. I'd like to represent this as two paths, p1 and p2, in an ordered array, a tuple [p1,p2]. how would I write a function, count, where I would say count([p1,p2]) and after a long run, get a list of tuples and how many times it occurred. I'm thinking this should be easily coded with ES6 collection types but just don't see how in the moment.\n\nI'm thinking that if a Bag were like a Set but were duplicates were counted, and if arrays defined equality as the recursive equality of its members, then my solution would be to just put all of my [p1,p2] in a bag and be done with it."
      },
      "date": 1709466603112
    },
    {
      "item": {
        "type": "factory",
        "id": "26f39e130f42a2d0"
      },
      "id": "26f39e130f42a2d0",
      "type": "add",
      "after": "37fb2d74db6289bb",
      "date": 1709467988175
    },
    {
      "type": "edit",
      "id": "26f39e130f42a2d0",
      "item": {
        "type": "pagefold",
        "id": "26f39e130f42a2d0",
        "text": "~"
      },
      "date": 1709467995356
    },
    {
      "item": {
        "type": "factory",
        "id": "fc677c7ae0b90523"
      },
      "id": "fc677c7ae0b90523",
      "type": "add",
      "after": "26f39e130f42a2d0",
      "date": 1709467996811
    },
    {
      "type": "edit",
      "id": "fc677c7ae0b90523",
      "item": {
        "type": "paragraph",
        "id": "fc677c7ae0b90523",
        "text": "I am interested in paths in the context of anti-patterns.\nAn anti-pattern is a pattern that describes how to get from a problem to a bad solution. (As opposed to an amelioration pattern, which describes the path from a bad solution to a good solution).\n\nI operationalize a problem in the form of a patlet, i.e. Start With a (first) Paragraph of a wiki page. This paragraph describes a recurring problem that is rooted in human nature, and the second paragraph describes something specific that could be done to \"solve\" the forces mentioned in the first paragraph.\n\nTherefore,\n\nHow to Go From a Problem to a (Bad) Solution and then describe the path from a bad solution to a good solution.\n\nThis makes the From Where relevant. This means the question of the starting point of our path. I therefore change the node shape of the starting point of the next speed bot journey."
      },
      "date": 1709468000104
    },
    {
      "type": "edit",
      "id": "fc677c7ae0b90523",
      "item": {
        "type": "paragraph",
        "id": "fc677c7ae0b90523",
        "text": "I am interested in paths in the context of anti-patterns.\nAn anti-pattern is a pattern that describes how to get from a problem to a bad solution. (As opposed to an amelioration pattern, which describes the path from a bad solution to a good solution).\n\nI operationalize a problem in the form of a patlet, i.e. Start With a (first) Paragraph of a wiki page. This paragraph describes a recurring problem that is rooted in human nature, and the second paragraph describes something specific that could be done to \"solve\" the forces mentioned in the first paragraph.\n\nTherefore,\n\nHow to Go From a Problem to a (Bad) Solution and then describe the path from a bad solution to a good solution.\n\nThis makes the From Where relevant. This means the question of the starting point of our path. I therefore change the node shape of the starting point of the next speed bot journey. [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$17094678210tmDWp:dreyeck.freedombox.rocks?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]"
      },
      "date": 1709468022836
    },
    {
      "type": "edit",
      "id": "fc677c7ae0b90523",
      "item": {
        "type": "paragraph",
        "id": "fc677c7ae0b90523",
        "text": "⇒ [[Recurring Problem]]"
      },
      "date": 1709468049813
    },
    {
      "type": "add",
      "id": "45503966dace2ddf",
      "item": {
        "type": "paragraph",
        "id": "45503966dace2ddf",
        "text": "I am interested in paths in the context of anti-patterns.\nAn anti-pattern is a pattern that describes how to get from a problem to a bad solution. (As opposed to an amelioration pattern, which describes the path from a bad solution to a good solution).\n\nI operationalize a problem in the form of a patlet, i.e. Start With a (first) Paragraph of a wiki page. This paragraph describes a recurring problem that is rooted in human nature, and the second paragraph describes something specific that could be done to \"solve\" the forces mentioned in the first paragraph.\n\nTherefore,\n\nHow to Go From a Problem to a (Bad) Solution and then describe the path from a bad solution to a good solution.\n\nThis makes the From Where relevant. This means the question of the starting point of our path. I therefore change the node shape of the starting point of the next speed bot journey. [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$17094678210tmDWp:dreyeck.freedombox.rocks?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]"
      },
      "after": "fc677c7ae0b90523",
      "date": 1709468050311
    }
  ]
}