{
  "title": "Arrow Functions",
  "story": [
    {
      "type": "paragraph",
      "id": "cb02def52b249739",
      "text": "[[ES6 Arrow Functions]] ⇒ [[Lambdas with Arrow Functions]]"
    },
    {
      "type": "markdown",
      "id": "d112e25f29ffaa67",
      "text": "> We write rules as ES6 arrow functions which we collect in an object initalised as const r = {}. We will see r (or it's shadow, x) strewn throught or javascript parsing code. [https://github.com/WardCunningham/graph/blob/main/cypher/ReadMe.md github]"
    },
    {
      "type": "pagefold",
      "id": "f746c764ba7533c7",
      "text": "."
    },
    {
      "type": "paragraph",
      "id": "d25b987d0ba4290f",
      "text": "[[Arrow Functions]] eliminate a lot of the verbosity that function expressions present. Let us whet our appetite with a simple example: "
    },
    {
      "type": "code",
      "id": "02da3a08f1d99997",
      "text": "const doubleIt = n => n * 2; \n\n// invoke it \nconsole.assert(doubleIt(8) === 16); "
    },
    {
      "type": "markdown",
      "id": "a96d4d21df04b144",
      "text": "Let us feast our eyes on the elegance of arrow functions prior to delving into the weeds. Gone is the function keyword, the parentheses, the curly brackets, and the return keyword. (The last true are not entirely true, as we will see in the following discussion.) All that remains is the **true** intent of the function. "
    },
    {
      "type": "markdown",
      "id": "85e375ec519baa7a",
      "text": "As we can see, much like function expressions, we do not provide a name for the function itself. Rather we assign the result of *evaluating* the expression to a variable so that we can reference it later. \n\n"
    },
    {
      "type": "markdown",
      "id": "6ed762bae2895e5a",
      "text": "While arrow functions have a passing resemblance to their expression and statement cousins, their role in the new world of JavaScript remains undisputed. They enable us to leverage JavaScripts inherent functional nature, making code more concise, and readable, and unlike regular functions rein in any attempts to make them stateful. \n"
    },
    {
      "type": "markdown",
      "id": "552829a67db07598",
      "text": "In this chapter we explored the new syntax for fat-arrow functions. We saw how their semantics differ from that of regular functions, and learned the appropriate use-cases where fat-arrow functions best serve us. As long as we remain mindful of the differences in their behavior, arrow functions will serve us well. \n"
    },
    {
      "type": "markdown",
      "id": "50546c88b821d22f",
      "text": "In the next chapter we will explore a new mechanism to define function signatures that allow our code to be more expressive, while reducing the amount of error checking that we are so accustomed to doing within our functions."
    },
    {
      "type": "pagefold",
      "id": "1b76231a78561095",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "87ea956b4ff46d0c",
      "text": "GANDHI, Raju, 2019. [[Lambdas with Arrow Functions]]. In: GANDHI, Raju (ed.), JavaScript Next: Your Complete Guide to the New Features Introduced in JavaScript, Starting from ES6 to ES9. Online. Berkeley, CA: Apress. p. 13–26. [Accessed 10 May 2022]. ISBN 978-1-4842-5394-6, p. 17"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Arrow Functions",
        "story": []
      },
      "date": 1652166813143
    },
    {
      "id": "cb02def52b249739",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "cb02def52b249739",
        "text": "[[ES6 Arrow Functions]] "
      },
      "date": 1652166824919
    },
    {
      "id": "d112e25f29ffaa67",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "d112e25f29ffaa67",
        "text": "> We write rules as ES6 arrow functions which we collect in an object initalised as const r = {}. We will see r (or it's shadow, x) strewn throught or javascript parsing code."
      },
      "after": "cb02def52b249739",
      "date": 1652166889171
    },
    {
      "type": "edit",
      "id": "d112e25f29ffaa67",
      "item": {
        "type": "markdown",
        "id": "d112e25f29ffaa67",
        "text": "> We write rules as ES6 arrow functions which we collect in an object initalised as const r = {}. We will see r (or it's shadow, x) strewn throught or javascript parsing code. [https://github.com/WardCunningham/graph/blob/main/cypher/ReadMe.md github]"
      },
      "date": 1652166955731
    },
    {
      "type": "fork",
      "date": 1652166970586
    },
    {
      "type": "fork",
      "date": 1652167015653
    },
    {
      "item": {
        "type": "paragraph",
        "id": "fd93323f95b6d124",
        "text": "[[Lambdas with Arrow Functions]]"
      },
      "id": "fd93323f95b6d124",
      "type": "add",
      "after": "d112e25f29ffaa67",
      "date": 1652167318494
    },
    {
      "type": "edit",
      "id": "fd93323f95b6d124",
      "item": {
        "type": "paragraph",
        "id": "fd93323f95b6d124",
        "text": "[[Lambdas with Arrow Functions]]"
      },
      "date": 1652167325031,
      "error": {
        "type": "error",
        "msg": ""
      }
    },
    {
      "type": "fork",
      "date": 1652167330784
    },
    {
      "type": "edit",
      "id": "cb02def52b249739",
      "item": {
        "type": "paragraph",
        "id": "cb02def52b249739",
        "text": "[[ES6 Arrow Functions]] ⇒"
      },
      "date": 1652167801518
    },
    {
      "type": "remove",
      "id": "fd93323f95b6d124",
      "date": 1652167802901
    },
    {
      "type": "edit",
      "id": "cb02def52b249739",
      "item": {
        "type": "paragraph",
        "id": "cb02def52b249739",
        "text": "[[ES6 Arrow Functions]] ⇒ [[Lambdas with Arrow Functions]]"
      },
      "date": 1652167805297
    },
    {
      "item": {
        "type": "factory",
        "id": "d25b987d0ba4290f"
      },
      "id": "d25b987d0ba4290f",
      "type": "add",
      "after": "d112e25f29ffaa67",
      "date": 1652169411930
    },
    {
      "type": "edit",
      "id": "d25b987d0ba4290f",
      "item": {
        "type": "paragraph",
        "id": "d25b987d0ba4290f",
        "text": "Arrow functions eliminate a lot of the verbosity that function expressions present. Let us whet our appetite with a simple example: const doubleIt = n => n * 2; // invoke it console.assert(doubleIt(8) === 16); Let us feast our eyes on the elegance of arrow functions prior to delving into the weeds. Gone is the function keyword, the parentheses, the curly brackets, and the return keyword. (The last true are not entirely true, as we will see in the following discussion.) All that remains is the true intent of the function. As we can see, much like function expressions, we do not provide a name for the function itself. Rather we assign the result of evaluating the expression to a variable so that we can reference it later. Now that we have had a taste of arrow functions, let us discuss some syntactical details."
      },
      "date": 1652169414375
    },
    {
      "type": "edit",
      "id": "d25b987d0ba4290f",
      "item": {
        "type": "paragraph",
        "id": "d25b987d0ba4290f",
        "text": "Arrow functions eliminate a lot of the verbosity that function expressions present. Let us whet our appetite with a simple example: "
      },
      "date": 1652169425297
    },
    {
      "type": "add",
      "id": "1af804eb39d71f0e",
      "item": {
        "type": "paragraph",
        "id": "1af804eb39d71f0e",
        "text": "const doubleIt = n => n * 2; // invoke it console.assert(doubleIt(8) === 16); "
      },
      "after": "d25b987d0ba4290f",
      "date": 1652169430647
    },
    {
      "item": {
        "type": "factory",
        "id": "02da3a08f1d99997"
      },
      "id": "02da3a08f1d99997",
      "type": "add",
      "after": "a96d4d21df04b144",
      "date": 1652169434252
    },
    {
      "type": "add",
      "id": "a96d4d21df04b144",
      "item": {
        "type": "paragraph",
        "id": "a96d4d21df04b144",
        "text": "Let us feast our eyes on the elegance of arrow functions prior to delving into the weeds. Gone is the function keyword, the parentheses, the curly brackets, and the return keyword. (The last true are not entirely true, as we will see in the following discussion.) All that remains is the true intent of the function. As we can see, much like function expressions, we do not provide a name for the function itself. Rather we assign the result of evaluating the expression to a variable so that we can reference it later. Now that we have had a taste of arrow functions, let us discuss some syntactical details."
      },
      "after": "1af804eb39d71f0e",
      "date": 1652169436458
    },
    {
      "type": "edit",
      "id": "02da3a08f1d99997",
      "item": {
        "type": "code",
        "id": "02da3a08f1d99997",
        "text": "const"
      },
      "date": 1652169441282
    },
    {
      "id": "02da3a08f1d99997",
      "type": "move",
      "order": [
        "cb02def52b249739",
        "d112e25f29ffaa67",
        "d25b987d0ba4290f",
        "1af804eb39d71f0e",
        "02da3a08f1d99997",
        "a96d4d21df04b144"
      ],
      "date": 1652169445995
    },
    {
      "type": "remove",
      "id": "1af804eb39d71f0e",
      "date": 1652169450592
    },
    {
      "type": "edit",
      "id": "02da3a08f1d99997",
      "item": {
        "type": "code",
        "id": "02da3a08f1d99997",
        "text": "const doubleIt = n => n * 2; // invoke it console.assert(doubleIt(8) === 16); "
      },
      "date": 1652169452041
    },
    {
      "type": "edit",
      "id": "02da3a08f1d99997",
      "item": {
        "type": "code",
        "id": "02da3a08f1d99997",
        "text": "const doubleIt = n => n * 2; \n\n// invoke it \nconsole.assert(doubleIt(8) === 16); "
      },
      "date": 1652169465575
    },
    {
      "item": {
        "type": "factory",
        "id": "1b76231a78561095"
      },
      "id": "1b76231a78561095",
      "type": "add",
      "after": "a96d4d21df04b144",
      "date": 1652169497042
    },
    {
      "type": "edit",
      "id": "1b76231a78561095",
      "item": {
        "type": "pagefold",
        "id": "1b76231a78561095",
        "text": "~"
      },
      "date": 1652169501456
    },
    {
      "item": {
        "type": "factory",
        "id": "87ea956b4ff46d0c"
      },
      "id": "87ea956b4ff46d0c",
      "type": "add",
      "after": "1b76231a78561095",
      "date": 1652169505474
    },
    {
      "type": "edit",
      "id": "87ea956b4ff46d0c",
      "item": {
        "type": "paragraph",
        "id": "87ea956b4ff46d0c",
        "text": "p. 17"
      },
      "date": 1652169509607
    },
    {
      "type": "edit",
      "id": "87ea956b4ff46d0c",
      "item": {
        "type": "paragraph",
        "id": "87ea956b4ff46d0c",
        "text": "\nGANDHI, Raju, 2019. Lambdas with Arrow Functions. In: GANDHI, Raju (ed.), JavaScript Next: Your Complete Guide to the New Features Introduced in JavaScript, Starting from ES6 to ES9. Online. Berkeley, CA: Apress. p. 13–26. [Accessed 10 May 2022]. ISBN 978-1-4842-5394-6, p. 17"
      },
      "date": 1652169539483
    },
    {
      "item": {
        "type": "factory",
        "id": "f746c764ba7533c7"
      },
      "id": "f746c764ba7533c7",
      "type": "add",
      "after": "87ea956b4ff46d0c",
      "date": 1652169557228
    },
    {
      "type": "edit",
      "id": "f746c764ba7533c7",
      "item": {
        "type": "pagefold",
        "id": "f746c764ba7533c7",
        "text": "."
      },
      "date": 1652169560156
    },
    {
      "id": "f746c764ba7533c7",
      "type": "move",
      "order": [
        "cb02def52b249739",
        "d112e25f29ffaa67",
        "f746c764ba7533c7",
        "d25b987d0ba4290f",
        "02da3a08f1d99997",
        "a96d4d21df04b144",
        "1b76231a78561095",
        "87ea956b4ff46d0c"
      ],
      "date": 1652169567981
    },
    {
      "type": "edit",
      "id": "d25b987d0ba4290f",
      "item": {
        "type": "paragraph",
        "id": "d25b987d0ba4290f",
        "text": "[[Arrow functions]] eliminate a lot of the verbosity that function expressions present. Let us whet our appetite with a simple example: "
      },
      "date": 1652169585277
    },
    {
      "type": "edit",
      "id": "a96d4d21df04b144",
      "item": {
        "type": "paragraph",
        "id": "a96d4d21df04b144",
        "text": "Let us feast our eyes on the elegance of arrow functions prior to delving into the weeds. Gone is the function keyword, the parentheses, the curly brackets, and the return keyword. (The last true are not entirely true, as we will see in the following discussion.) All that remains is the true intent of the function. "
      },
      "date": 1652169621398
    },
    {
      "type": "add",
      "id": "85e375ec519baa7a",
      "item": {
        "type": "paragraph",
        "id": "85e375ec519baa7a",
        "text": "As we can see, much like function expressions, we do not provide a name for the function itself. Rather we assign the result of evaluating the expression to a variable so that we can reference it later. Now that we have had a taste of arrow functions, let us discuss some syntactical details."
      },
      "after": "a96d4d21df04b144",
      "date": 1652169623242
    },
    {
      "type": "edit",
      "id": "a96d4d21df04b144",
      "item": {
        "type": "paragraph",
        "id": "a96d4d21df04b144",
        "text": "Let us feast our eyes on the elegance of arrow functions prior to delving into the weeds. Gone is the function keyword, the parentheses, the curly brackets, and the return keyword. (The last true are not entirely true, as we will see in the following discussion.) All that remains is the **true** intent of the function. "
      },
      "date": 1652169628534
    },
    {
      "type": "edit",
      "id": "a96d4d21df04b144",
      "item": {
        "type": "markdown",
        "id": "a96d4d21df04b144",
        "text": "Let us feast our eyes on the elegance of arrow functions prior to delving into the weeds. Gone is the function keyword, the parentheses, the curly brackets, and the return keyword. (The last true are not entirely true, as we will see in the following discussion.) All that remains is the **true** intent of the function. "
      },
      "date": 1652169629823
    },
    {
      "type": "edit",
      "id": "85e375ec519baa7a",
      "item": {
        "type": "paragraph",
        "id": "85e375ec519baa7a",
        "text": "As we can see, much like function expressions, we do not provide a name for the function itself. Rather we assign the result of *evaluating* the expression to a variable so that we can reference it later. Now that we have had a taste of arrow functions, let us discuss some syntactical details."
      },
      "date": 1652169666725
    },
    {
      "type": "edit",
      "id": "85e375ec519baa7a",
      "item": {
        "type": "markdown",
        "id": "85e375ec519baa7a",
        "text": "As we can see, much like function expressions, we do not provide a name for the function itself. Rather we assign the result of *evaluating* the expression to a variable so that we can reference it later. Now that we have had a taste of arrow functions, let us discuss some syntactical details."
      },
      "date": 1652169667970
    },
    {
      "type": "edit",
      "id": "85e375ec519baa7a",
      "item": {
        "type": "markdown",
        "id": "85e375ec519baa7a",
        "text": "As we can see, much like function expressions, we do not provide a name for the function itself. Rather we assign the result of *evaluating* the expression to a variable so that we can reference it later. \n"
      },
      "date": 1652169683162
    },
    {
      "type": "add",
      "id": "0dc48cbc831663fa",
      "item": {
        "type": "markdown",
        "id": "0dc48cbc831663fa",
        "text": "Now that we have had a taste of arrow functions, let us discuss some syntactical details."
      },
      "after": "85e375ec519baa7a",
      "date": 1652169683616
    },
    {
      "type": "remove",
      "id": "0dc48cbc831663fa",
      "date": 1652169687095
    },
    {
      "type": "edit",
      "id": "85e375ec519baa7a",
      "item": {
        "type": "markdown",
        "id": "85e375ec519baa7a",
        "text": "As we can see, much like function expressions, we do not provide a name for the function itself. Rather we assign the result of *evaluating* the expression to a variable so that we can reference it later. \n\n"
      },
      "date": 1652169840952
    },
    {
      "type": "add",
      "id": "6ed762bae2895e5a",
      "item": {
        "type": "markdown",
        "id": "6ed762bae2895e5a",
        "text": "While arrow functions have a passing resemblance to their expression and statement cousins, their role in the new world of JavaScript remains undisputed. They enable us to leverage JavaScripts inherent functional nature, making code more concise, and readable, and unlike regular functions rein in any attempts to make them stateful. In this chapter we explored the new syntax for fat-arrow functions. We saw how their semantics differ from that of regular functions, and learned the appropriate use-cases where fat-arrow functions best serve us. As long as we remain mindful of the differences in their behavior, arrow functions will serve us well. In the next chapter we will explore a new mechanism to define function signatures that allow our code to be more expressive, while reducing the amount of error checking that we are so accustomed to doing within our functions."
      },
      "after": "85e375ec519baa7a",
      "date": 1652169843793
    },
    {
      "type": "edit",
      "id": "6ed762bae2895e5a",
      "item": {
        "type": "markdown",
        "id": "6ed762bae2895e5a",
        "text": "While arrow functions have a passing resemblance to their expression and statement cousins, their role in the new world of JavaScript remains undisputed. They enable us to leverage JavaScripts inherent functional nature, making code more concise, and readable, and unlike regular functions rein in any attempts to make them stateful. \n"
      },
      "date": 1652169897480
    },
    {
      "type": "add",
      "id": "552829a67db07598",
      "item": {
        "type": "markdown",
        "id": "552829a67db07598",
        "text": "In this chapter we explored the new syntax for fat-arrow functions. We saw how their semantics differ from that of regular functions, and learned the appropriate use-cases where fat-arrow functions best serve us. As long as we remain mindful of the differences in their behavior, arrow functions will serve us well. \n"
      },
      "after": "6ed762bae2895e5a",
      "date": 1652169903551
    },
    {
      "type": "add",
      "id": "50546c88b821d22f",
      "item": {
        "type": "markdown",
        "id": "50546c88b821d22f",
        "text": "In the next chapter we will explore a new mechanism to define function signatures that allow our code to be more expressive, while reducing the amount of error checking that we are so accustomed to doing within our functions."
      },
      "after": "552829a67db07598",
      "date": 1652169904219
    },
    {
      "type": "edit",
      "id": "87ea956b4ff46d0c",
      "item": {
        "type": "paragraph",
        "id": "87ea956b4ff46d0c",
        "text": "GANDHI, Raju, 2019. [[Lambdas with Arrow Functions]]. In: GANDHI, Raju (ed.), JavaScript Next: Your Complete Guide to the New Features Introduced in JavaScript, Starting from ES6 to ES9. Online. Berkeley, CA: Apress. p. 13–26. [Accessed 10 May 2022]. ISBN 978-1-4842-5394-6, p. 17"
      },
      "date": 1652169960977
    },
    {
      "type": "edit",
      "id": "d25b987d0ba4290f",
      "item": {
        "type": "paragraph",
        "id": "d25b987d0ba4290f",
        "text": "[[Arrow Functions]] eliminate a lot of the verbosity that function expressions present. Let us whet our appetite with a simple example: "
      },
      "date": 1652175098527
    }
  ]
}