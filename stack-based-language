{
  "title": "Stack Based Language",
  "story": [
    {
      "type": "html",
      "text": "See also: [[Stack Computers]]",
      "id": "9cfef8cb30c6b847899e905f1d39359b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c788b13cb61f70e2998d2d11127a6a7f"
    },
    {
      "type": "html",
      "text": "A stack-based language is one in which a stack, implicitly accessed by most operations, is a fundamental part of the programming model.  Examples include [[Forth Language]], [[Factor Language]], [[Joy Language]], [[Post Script]], and the [[Java Virtual Machine]] (which, since one can write in assembly for it, should be considered a language albeit a low-level one).",
      "id": "6230944a41905c6616b68b2f117fac63"
    },
    {
      "type": "html",
      "text": "\nLanguages which maintain a program stack (\"[[The Stack]]\") for storing of [[Activation Record]]s and/or parameter passing as an implementation detail, but keep the programmer from manipulating [[The Stack]] directly, don't count.  This includes most imperative programming languages ([[Cee Language]], [[Cee Plus Plus]], [[Java Language]])--in each of these, the program stack could be replaced with an alternative data structure (for example, heap-allocated activation records, like [[Smalltalk Language]] has).",
      "id": "13e4bd550dedcc3a0051e4b51f70d01e"
    },
    {
      "type": "html",
      "text": "\nLikewise, providing a stack data structure in the library also doesn't count.",
      "id": "bdc03f4f605531f9567db9f00ee40aec"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c788b13cb61f70e2998d2d11127a6a7f"
    },
    {
      "type": "html",
      "text": "Actually, the [[Forth Language]] uses two separate stacks: the data stack for parameter and result passing and the return stack for storing activation records. This separation makes it easy and natural for a Forth word to return multiple values. (It is possible and sometimes useful to temporarily push data on to the return stack to reduce stack juggling.)",
      "id": "df49d165b5d577265d2229fc10946931"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c788b13cb61f70e2998d2d11127a6a7f"
    },
    {
      "type": "html",
      "text": "\nAnother common feature of stack-based languages is [[Postfix Notation]], also called [[Reverse Polish Notation]].  Rather than writing an expression such as ",
      "id": "60201eba5088da3f2c22497eecf74b96"
    },
    {
      "type": "html",
      "text": " + 4",
      "id": "b4164befecfbe91b67e03be49a3b8ba3"
    },
    {
      "type": "html",
      "text": "\nin many [[Stack Based Languages]] you write",
      "id": "78639ed6ab8e145abe50b9efaab4d194"
    },
    {
      "type": "html",
      "text": " 4 +",
      "id": "996165c606dfa72f5075e1e03f48546c"
    },
    {
      "type": "html",
      "text": "\nA bit unusual, until you get used to it.  Postfix notation has the nice property that it doesn't require parentheses for associativity.  The following expression is ambiguous:",
      "id": "4639c2313ba0190d0ced652d5002419f"
    },
    {
      "type": "html",
      "text": " + 4 * 5",
      "id": "2d761e93013ad2b2dc23b7dcfedd6b13"
    },
    {
      "type": "html",
      "text": "\nIs it (3+4) * 5 = 35, or 3+(4*5) = 23?  The rules of mathematics and most programming languages say the latter; [[Smalltalk Language]] says the former.  To override these defaults, parentheses must be added.  In postfix notation, that's not necessary--you would write either",
      "id": "074e0ef5dc835daf546bdff6718766f6"
    },
    {
      "type": "html",
      "text": " 4 + 5 *",
      "id": "c9b2ab385eacecae1ed50f47801e3fbb"
    },
    {
      "type": "html",
      "text": "\nif you mean the first, or",
      "id": "633d9d079b58f538f6c1a482b7e67e6f"
    },
    {
      "type": "html",
      "text": " 4 5 * +",
      "id": "db215e24a980c87973883968a7b2cc92"
    },
    {
      "type": "html",
      "text": "\nif you mean the second.",
      "id": "7fc40fe4ebbbd15e2badb7e6cb63778c"
    },
    {
      "type": "html",
      "text": "\nOne drawback with postfix notation is that operators must either be unary or binary, not both.  If you want negation, you cannot overload - to be a unary operator; you either have to provide a new operator (say neg) or use subtraction from zero.",
      "id": "22335c1a3f1178a2f68fb1d0bc82a4d6"
    },
    {
      "type": "html",
      "text": " 5 - +",
      "id": "8740543b57f2ca0e9fa1ab62a6692e05"
    },
    {
      "type": "html",
      "text": "\nis an error.",
      "id": "5f8690761f81b7917a4eee208cdc8bd4"
    },
    {
      "type": "html",
      "text": " 5 neg +",
      "id": "a3d00274a5005773bb766d8a63174433"
    },
    {
      "type": "html",
      "text": "\nor",
      "id": "42ec25c34c59435771ad80c4170405dc"
    },
    {
      "type": "html",
      "text": " 0 5 - +",
      "id": "9c65b841302e2389e84170b553c40239"
    },
    {
      "type": "html",
      "text": "\nboth produce -2.",
      "id": "819ddfbcb479f73189d11d686a302b5c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c788b13cb61f70e2998d2d11127a6a7f"
    },
    {
      "type": "html",
      "text": "\nI generally consider stack-based languages to be better suited for [[Intermediate Form]]s or [[Virtual Machine]]s (the [[Java Virtual Machine]] is a fine example) then they are for source languages.  Elimination of variables/[[Let Binding]]s is theoretically interesting, and certainly elimination of variables which are only used as temporaries is nice; however, stack-based languages can increase the chance of programmer error.  Stack-based languages frequently require the programmer to keep track of bookkeeping details that a compiler should handle instead (\"Where on the stack is the result of evaluating the foo function?\").  Variable names are also a key part of a program's documentation (well-chosen ones, anyway); eliminating them tends to obfuscate code.  In my opinion, at least.",
      "id": "9d5aac30547b34133f7db1d9a881366b"
    },
    {
      "type": "html",
      "text": "\nA program stack (visible to the programmer, rather than just a convenient way to deal with [[Activation Record]]s) can be a useful thing; especially when it augments rather than replaces other things.",
      "id": "f7171af6ac46db5970d3c8e462c547bf"
    },
    {
      "type": "html",
      "text": "-- [[Scott Johnson]]",
      "id": "3d93ba1cc0ae61c08f44ab676fd3292a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c788b13cb61f70e2998d2d11127a6a7f"
    },
    {
      "type": "html",
      "text": "\nI agree; [[Forth Language]] novices are apt to make many stack-balancing errors when programming in their accustomed style (big functions, lots of conditionals, lots of intermediate values on the stack).  The lesson learned is to [[Refactor Mercilessly]] and [[Simplify Vigorously]].  The ideal Forth word definition is seven words long.  Easy to understand, easy to [[Unit Test]] interactively and exhaustively.  Proverb: \"Refactor until there is no place left for the bug to hide.\"",
      "id": "13eef46c70a6f501ab6dbea1759b05e0"
    },
    {
      "type": "html",
      "text": "\nThe more words you factor your code into, the more the words themselves become the built-in documentation.  In the few cases where persistent stack intermediates are unavoidable, one can insert a stack comment: ( foo bar -- ), or use a local variable language extension to define symbolic names for those intermediates.",
      "id": "b2038df1d07dff4041ff146191835a7e"
    },
    {
      "type": "html",
      "text": "\nAs with [[Assembly Language]] programming, you can get around the lack of a safety net in Forth (which has been described as a macro assembler for a virtual stack machine) by using good programming practices.",
      "id": "8a245ca2ea1e87633dda837a041b4241"
    },
    {
      "type": "html",
      "text": "-- [[Ian Osgood]]",
      "id": "3f8c8132473d3e14cbb78a0d33a4766c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c788b13cb61f70e2998d2d11127a6a7f"
    },
    {
      "type": "html",
      "text": "\nIf you are asking <i>Where on the stack is the result of evaluating the foo function?</i>, you probably need to refactor in simpler terms. Unavoidably, that happens all the time.",
      "id": "df448247c490621028f66a97392f993b"
    },
    {
      "type": "html",
      "text": "-- iru",
      "id": "095ac3eedec61d5b402716fced389ab9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c788b13cb61f70e2998d2d11127a6a7f"
    },
    {
      "type": "html",
      "text": "\nThe built-in language in HP 48 series graphic calculators (and other HP RPN calculators) is also stack-oriented.",
      "id": "319b2b62ffb95432a4b6fe99d24c65e6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c788b13cb61f70e2998d2d11127a6a7f"
    },
    {
      "type": "html",
      "text": "\nThe Concatenative Languages Wiki located at [http://factor.sourceforge.net/wiki/ factor.sourceforge.net] provides a wealth of information about (stack-based) [[Concatenative Language]]s.  -- Slava Pestov",
      "id": "ab403e25ce5d789de7d31134a6447b52"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c788b13cb61f70e2998d2d11127a6a7f"
    },
    {
      "type": "html",
      "text": "[[Category Programming Language]]",
      "id": "f0a97a5f9006afa2e1e6a18457943b62"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?StackBasedLanguage c2.com]",
      "id": "86ae5860c6e3494d03ccc60aa033e3c6"
    }
  ],
  "journal": [
    {
      "date": 1320168226000,
      "id": "931f0616470406310ff017d62bdf5f45",
      "type": "create",
      "item": {
        "title": "Stack Based Language",
        "story": [
          {
            "type": "html",
            "text": "See also: [[Stack Computers]]",
            "id": "9cfef8cb30c6b847899e905f1d39359b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c788b13cb61f70e2998d2d11127a6a7f"
          },
          {
            "type": "html",
            "text": "A stack-based language is one in which a stack, implicitly accessed by most operations, is a fundamental part of the programming model.  Examples include [[Forth Language]], [[Factor Language]], [[Joy Language]], [[Post Script]], and the [[Java Virtual Machine]] (which, since one can write in assembly for it, should be considered a language albeit a low-level one).",
            "id": "6230944a41905c6616b68b2f117fac63"
          },
          {
            "type": "html",
            "text": "\nLanguages which maintain a program stack (\"[[The Stack]]\") for storing of [[Activation Record]]s and/or parameter passing as an implementation detail, but keep the programmer from manipulating [[The Stack]] directly, don't count.  This includes most imperative programming languages ([[Cee Language]], [[Cee Plus Plus]], [[Java Language]])--in each of these, the program stack could be replaced with an alternative data structure (for example, heap-allocated activation records, like [[Smalltalk Language]] has).",
            "id": "13e4bd550dedcc3a0051e4b51f70d01e"
          },
          {
            "type": "html",
            "text": "\nLikewise, providing a stack data structure in the library also doesn't count.",
            "id": "bdc03f4f605531f9567db9f00ee40aec"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c788b13cb61f70e2998d2d11127a6a7f"
          },
          {
            "type": "html",
            "text": "Actually, the [[Forth Language]] uses two separate stacks: the data stack for parameter and result passing and the return stack for storing activation records. This separation makes it easy and natural for a Forth word to return multiple values. (It is possible and sometimes useful to temporarily push data on to the return stack to reduce stack juggling.)",
            "id": "df49d165b5d577265d2229fc10946931"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c788b13cb61f70e2998d2d11127a6a7f"
          },
          {
            "type": "html",
            "text": "\nAnother common feature of stack-based languages is [[Postfix Notation]], also called [[Reverse Polish Notation]].  Rather than writing an expression such as ",
            "id": "60201eba5088da3f2c22497eecf74b96"
          },
          {
            "type": "html",
            "text": " + 4",
            "id": "b4164befecfbe91b67e03be49a3b8ba3"
          },
          {
            "type": "html",
            "text": "\nin many [[Stack Based Languages]] you write",
            "id": "78639ed6ab8e145abe50b9efaab4d194"
          },
          {
            "type": "html",
            "text": " 4 +",
            "id": "996165c606dfa72f5075e1e03f48546c"
          },
          {
            "type": "html",
            "text": "\nA bit unusual, until you get used to it.  Postfix notation has the nice property that it doesn't require parentheses for associativity.  The following expression is ambiguous:",
            "id": "4639c2313ba0190d0ced652d5002419f"
          },
          {
            "type": "html",
            "text": " + 4 * 5",
            "id": "2d761e93013ad2b2dc23b7dcfedd6b13"
          },
          {
            "type": "html",
            "text": "\nIs it (3+4) * 5 = 35, or 3+(4*5) = 23?  The rules of mathematics and most programming languages say the latter; [[Smalltalk Language]] says the former.  To override these defaults, parentheses must be added.  In postfix notation, that's not necessary--you would write either",
            "id": "074e0ef5dc835daf546bdff6718766f6"
          },
          {
            "type": "html",
            "text": " 4 + 5 *",
            "id": "c9b2ab385eacecae1ed50f47801e3fbb"
          },
          {
            "type": "html",
            "text": "\nif you mean the first, or",
            "id": "633d9d079b58f538f6c1a482b7e67e6f"
          },
          {
            "type": "html",
            "text": " 4 5 * +",
            "id": "db215e24a980c87973883968a7b2cc92"
          },
          {
            "type": "html",
            "text": "\nif you mean the second.",
            "id": "7fc40fe4ebbbd15e2badb7e6cb63778c"
          },
          {
            "type": "html",
            "text": "\nOne drawback with postfix notation is that operators must either be unary or binary, not both.  If you want negation, you cannot overload - to be a unary operator; you either have to provide a new operator (say neg) or use subtraction from zero.",
            "id": "22335c1a3f1178a2f68fb1d0bc82a4d6"
          },
          {
            "type": "html",
            "text": " 5 - +",
            "id": "8740543b57f2ca0e9fa1ab62a6692e05"
          },
          {
            "type": "html",
            "text": "\nis an error.",
            "id": "5f8690761f81b7917a4eee208cdc8bd4"
          },
          {
            "type": "html",
            "text": " 5 neg +",
            "id": "a3d00274a5005773bb766d8a63174433"
          },
          {
            "type": "html",
            "text": "\nor",
            "id": "42ec25c34c59435771ad80c4170405dc"
          },
          {
            "type": "html",
            "text": " 0 5 - +",
            "id": "9c65b841302e2389e84170b553c40239"
          },
          {
            "type": "html",
            "text": "\nboth produce -2.",
            "id": "819ddfbcb479f73189d11d686a302b5c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c788b13cb61f70e2998d2d11127a6a7f"
          },
          {
            "type": "html",
            "text": "\nI generally consider stack-based languages to be better suited for [[Intermediate Form]]s or [[Virtual Machine]]s (the [[Java Virtual Machine]] is a fine example) then they are for source languages.  Elimination of variables/[[Let Binding]]s is theoretically interesting, and certainly elimination of variables which are only used as temporaries is nice; however, stack-based languages can increase the chance of programmer error.  Stack-based languages frequently require the programmer to keep track of bookkeeping details that a compiler should handle instead (\"Where on the stack is the result of evaluating the foo function?\").  Variable names are also a key part of a program's documentation (well-chosen ones, anyway); eliminating them tends to obfuscate code.  In my opinion, at least.",
            "id": "9d5aac30547b34133f7db1d9a881366b"
          },
          {
            "type": "html",
            "text": "\nA program stack (visible to the programmer, rather than just a convenient way to deal with [[Activation Record]]s) can be a useful thing; especially when it augments rather than replaces other things.",
            "id": "f7171af6ac46db5970d3c8e462c547bf"
          },
          {
            "type": "html",
            "text": "-- [[Scott Johnson]]",
            "id": "3d93ba1cc0ae61c08f44ab676fd3292a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c788b13cb61f70e2998d2d11127a6a7f"
          },
          {
            "type": "html",
            "text": "\nI agree; [[Forth Language]] novices are apt to make many stack-balancing errors when programming in their accustomed style (big functions, lots of conditionals, lots of intermediate values on the stack).  The lesson learned is to [[Refactor Mercilessly]] and [[Simplify Vigorously]].  The ideal Forth word definition is seven words long.  Easy to understand, easy to [[Unit Test]] interactively and exhaustively.  Proverb: \"Refactor until there is no place left for the bug to hide.\"",
            "id": "13eef46c70a6f501ab6dbea1759b05e0"
          },
          {
            "type": "html",
            "text": "\nThe more words you factor your code into, the more the words themselves become the built-in documentation.  In the few cases where persistent stack intermediates are unavoidable, one can insert a stack comment: ( foo bar -- ), or use a local variable language extension to define symbolic names for those intermediates.",
            "id": "b2038df1d07dff4041ff146191835a7e"
          },
          {
            "type": "html",
            "text": "\nAs with [[Assembly Language]] programming, you can get around the lack of a safety net in Forth (which has been described as a macro assembler for a virtual stack machine) by using good programming practices.",
            "id": "8a245ca2ea1e87633dda837a041b4241"
          },
          {
            "type": "html",
            "text": "-- [[Ian Osgood]]",
            "id": "3f8c8132473d3e14cbb78a0d33a4766c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c788b13cb61f70e2998d2d11127a6a7f"
          },
          {
            "type": "html",
            "text": "\nIf you are asking <i>Where on the stack is the result of evaluating the foo function?</i>, you probably need to refactor in simpler terms. Unavoidably, that happens all the time.",
            "id": "df448247c490621028f66a97392f993b"
          },
          {
            "type": "html",
            "text": "-- iru",
            "id": "095ac3eedec61d5b402716fced389ab9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c788b13cb61f70e2998d2d11127a6a7f"
          },
          {
            "type": "html",
            "text": "\nThe built-in language in HP 48 series graphic calculators (and other HP RPN calculators) is also stack-oriented.",
            "id": "319b2b62ffb95432a4b6fe99d24c65e6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c788b13cb61f70e2998d2d11127a6a7f"
          },
          {
            "type": "html",
            "text": "\nThe Concatenative Languages Wiki located at [http://factor.sourceforge.net/wiki/ factor.sourceforge.net] provides a wealth of information about (stack-based) [[Concatenative Language]]s.  -- Slava Pestov",
            "id": "ab403e25ce5d789de7d31134a6447b52"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c788b13cb61f70e2998d2d11127a6a7f"
          },
          {
            "type": "html",
            "text": "[[Category Programming Language]]",
            "id": "f0a97a5f9006afa2e1e6a18457943b62"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?StackBasedLanguage c2.com]",
            "id": "86ae5860c6e3494d03ccc60aa033e3c6"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1707801237022
    }
  ]
}