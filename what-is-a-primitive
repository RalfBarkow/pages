{
  "title": "What Is a Primitive",
  "story": [
    {
      "type": "paragraph",
      "id": "966bdcc7c676c598",
      "text": "Some [[Messages]] in the system are responded to primitively. A primitive response is performed directly by the interpreter rather than by evaluating expressions in a method. The methods for these messages indicate the presence of a primitive response by including <primitive: xx> or \n<primitive: 79 error: ec>before the first expression in the method."
    },
    {
      "type": "paragraph",
      "id": "1b5ad3efc1ca8a18",
      "text": "In the second case, ec is a special temporary variable that holds an error code. \nIn the VM primitive, failure is indicated by a variable called primFailCode being \nnon-zero. On activating a method with a failing primitive, if the index is in \nbounds of the primitiveFailCodes array in the VMspecialObjectsArray then the \nfailure code substitutes the symbol in the primitiveFailCodes array, otherwise \nit supplies the integer value."
    },
    {
      "type": "paragraph",
      "id": "09db45abf55439bf",
      "text": "Primitives exist for several reasons. Certain basic or 'primitive' operations cannot be performed in any other way. Smalltalk without primitives can move values from one variable to another, but cannot add two SmallIntegers together. Many methods for arithmetic and comparison between numbers are primitives. Some primitives allow Smalltalk to communicate with I/O devices such as the disk, the display, and the keyboard. Some primitives exist only to make the system run faster; each does the same thing as a certain Smalltalk method, and its implementation as a primitive is optional."
    },
    {
      "type": "paragraph",
      "id": "da57c3955bf8dda3",
      "text": "When the Smalltalk interpreter begins to execute a method which specifies a primitive response, it tries to perform the primitive action and to return a result. If the routine in the interpreter for this primitive is successful, it will return a value and the expressions in the method will not be evaluated. If the primitive routine is not successful, the primitive 'fails', and the Smalltalk expressions in the method are executed instead. These expressions are evaluated as though the primitive routine had not been called."
    },
    {
      "type": "paragraph",
      "id": "e97069b03dbc6545",
      "text": "The Smalltalk code that is evaluated when a primitive fails usually anticipates why that primitive might fail. If the primitive is optional, the expressions in the method do exactly what the primitive would have done (See Number @). If the primitive only works on certain classes of arguments, the Smalltalk code tries to coerce the argument or appeals to a superclass to find a more general way of doing the operation (see SmallInteger +). If the primitive is never supposed to fail, the expressions signal an error (see SmallInteger asFloat)."
    },
    {
      "type": "paragraph",
      "id": "c20bc666246a2ea2",
      "text": "Each method that specifies a primitive has a comment in it. If the primitive is optional, the comment will say 'Optional'. An optional primitive that is not implemented always fails, and the Smalltalk expressions do the work instead."
    },
    {
      "type": "paragraph",
      "id": "aae77ea03201792b",
      "text": "If a primitive is not optional, the comment will say, 'Essential'. Some methods will have the comment, 'No Lookup'. See Object howToModifyPrimitives for an explanation of special selectors which are not looked up."
    },
    {
      "type": "paragraph",
      "id": "8043d248e238f345",
      "text": "For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated in Float, the primitive constructs and returns a 16-bit LargePositiveInteger when the result warrants it. Returning 16-bit LargePositiveIntegers from these primitives instead of failing is optional in the same sense that the LargePositiveInteger arithmetic primitives are optional. The comments in the SmallInteger primitives say, 'Fails if result is not a SmallInteger', even though the implementor has the option to construct a LargePositiveInteger. For further information on primitives, see the 'Primitive Methods' part of the chapter on the formal specification of the interpreter in the Smalltalk book."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "What Is a Primitive",
        "story": []
      },
      "date": 1705048689533
    },
    {
      "type": "edit",
      "id": "966bdcc7c676c598",
      "item": {
        "type": "paragraph",
        "id": "966bdcc7c676c598",
        "text": "Some messages in the system are responded to primitively. A primitive response is performed directly by the interpreter rather than by evaluating expressions in a method. The methods for these messages indicate the presence of a primitive response by including <primitive: xx> or \n<primitive: 79 error: ec>before the first expression in the method. \nIn the second case, ec is a special temporary variable that holds an error code. \nIn the VM primitive, failure is indicated by a variable called primFailCode being \nnon-zero. On activating a method with a failing primitive, if the index is in \nbounds of the primitiveFailCodes array in the VMspecialObjectsArray then the \nfailure code substitutes the symbol in the primitiveFailCodes array, otherwise \nit supplies the integer value.\n  \nPrimitives exist for several reasons. Certain basic or 'primitive' \noperations cannot be performed in any other way. Smalltalk without \nprimitives can move values from one variable to another, but cannot add two \nSmallIntegers together. Many methods for arithmetic and comparison \nbetween numbers are primitives. Some primitives allow Smalltalk to \ncommunicate with I/O devices such as the disk, the display, and the keyboard. \nSome primitives exist only to make the system run faster; each does the same \nthing as a certain Smalltalk method, and its implementation as a primitive is \noptional.  \n  \nWhen the Smalltalk interpreter begins to execute a method which specifies a \nprimitive response, it tries to perform the primitive action and to return a \nresult. If the routine in the interpreter for this primitive is successful, \nit will return a value and the expressions in the method will not be evaluated. \nIf the primitive routine is not successful, the primitive 'fails', and the \nSmalltalk expressions in the method are executed instead. These \nexpressions are evaluated as though the primitive routine had not been \ncalled.  \n  \nThe Smalltalk code that is evaluated when a primitive fails usually \nanticipates why that primitive might fail. If the primitive is optional, the \nexpressions in the method do exactly what the primitive would have done (See \nNumber @). If the primitive only works on certain classes of arguments, the \nSmalltalk code tries to coerce the argument or appeals to a superclass to find \na more general way of doing the operation (see SmallInteger +). If the \nprimitive is never supposed to fail, the expressions signal an error (see \nSmallInteger asFloat).  \n  \nEach method that specifies a primitive has a comment in it. If the primitive is \noptional, the comment will say 'Optional'. An optional primitive that is not \nimplemented always fails, and the Smalltalk expressions do the work \ninstead.  \n \nIf a primitive is not optional, the comment will say, 'Essential'. Some \nmethods will have the comment, 'No Lookup'. See Object \nhowToModifyPrimitives for an explanation of special selectors which are \nnot looked up.  \n  \nFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \nin Float, the primitive constructs and returns a 16-bit \nLargePositiveInteger when the result warrants it. Returning 16-bit \nLargePositiveIntegers from these primitives instead of failing is \noptional in the same sense that the LargePositiveInteger arithmetic \nprimitives are optional. The comments in the SmallInteger primitives say, \n'Fails if result is not a SmallInteger', even though the implementor has the \noption to construct a LargePositiveInteger. For further information on \nprimitives, see the 'Primitive Methods' part of the chapter on the formal \nspecification of the interpreter in the Smalltalk book."
      },
      "date": 1705048693501
    },
    {
      "type": "fork",
      "date": 1705048711837
    },
    {
      "type": "edit",
      "id": "966bdcc7c676c598",
      "item": {
        "type": "paragraph",
        "id": "966bdcc7c676c598",
        "text": "Some messages in the system are responded to primitively. A primitive response is performed directly by the interpreter rather than by evaluating expressions in a method. The methods for these messages indicate the presence of a primitive response by including <primitive: xx> or \n<primitive: 79 error: ec>before the first expression in the method."
      },
      "date": 1705048758027
    },
    {
      "type": "add",
      "id": "1b5ad3efc1ca8a18",
      "item": {
        "type": "paragraph",
        "id": "1b5ad3efc1ca8a18",
        "text": "In the second case, ec is a special temporary variable that holds an error code. \nIn the VM primitive, failure is indicated by a variable called primFailCode being \nnon-zero. On activating a method with a failing primitive, if the index is in \nbounds of the primitiveFailCodes array in the VMspecialObjectsArray then the \nfailure code substitutes the symbol in the primitiveFailCodes array, otherwise \nit supplies the integer value.\n  \nPrimitives exist for several reasons. Certain basic or 'primitive' \noperations cannot be performed in any other way. Smalltalk without \nprimitives can move values from one variable to another, but cannot add two \nSmallIntegers together. Many methods for arithmetic and comparison \nbetween numbers are primitives. Some primitives allow Smalltalk to \ncommunicate with I/O devices such as the disk, the display, and the keyboard. \nSome primitives exist only to make the system run faster; each does the same \nthing as a certain Smalltalk method, and its implementation as a primitive is \noptional.  \n  \nWhen the Smalltalk interpreter begins to execute a method which specifies a \nprimitive response, it tries to perform the primitive action and to return a \nresult. If the routine in the interpreter for this primitive is successful, \nit will return a value and the expressions in the method will not be evaluated. \nIf the primitive routine is not successful, the primitive 'fails', and the \nSmalltalk expressions in the method are executed instead. These \nexpressions are evaluated as though the primitive routine had not been \ncalled.  \n  \nThe Smalltalk code that is evaluated when a primitive fails usually \nanticipates why that primitive might fail. If the primitive is optional, the \nexpressions in the method do exactly what the primitive would have done (See \nNumber @). If the primitive only works on certain classes of arguments, the \nSmalltalk code tries to coerce the argument or appeals to a superclass to find \na more general way of doing the operation (see SmallInteger +). If the \nprimitive is never supposed to fail, the expressions signal an error (see \nSmallInteger asFloat).  \n  \nEach method that specifies a primitive has a comment in it. If the primitive is \noptional, the comment will say 'Optional'. An optional primitive that is not \nimplemented always fails, and the Smalltalk expressions do the work \ninstead.  \n \nIf a primitive is not optional, the comment will say, 'Essential'. Some \nmethods will have the comment, 'No Lookup'. See Object \nhowToModifyPrimitives for an explanation of special selectors which are \nnot looked up.  \n  \nFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \nin Float, the primitive constructs and returns a 16-bit \nLargePositiveInteger when the result warrants it. Returning 16-bit \nLargePositiveIntegers from these primitives instead of failing is \noptional in the same sense that the LargePositiveInteger arithmetic \nprimitives are optional. The comments in the SmallInteger primitives say, \n'Fails if result is not a SmallInteger', even though the implementor has the \noption to construct a LargePositiveInteger. For further information on \nprimitives, see the 'Primitive Methods' part of the chapter on the formal \nspecification of the interpreter in the Smalltalk book."
      },
      "after": "966bdcc7c676c598",
      "date": 1705048761269
    },
    {
      "type": "edit",
      "id": "966bdcc7c676c598",
      "item": {
        "type": "paragraph",
        "id": "966bdcc7c676c598",
        "text": "Some [[Messages]] in the system are responded to primitively. A primitive response is performed directly by the interpreter rather than by evaluating expressions in a method. The methods for these messages indicate the presence of a primitive response by including <primitive: xx> or \n<primitive: 79 error: ec>before the first expression in the method."
      },
      "date": 1705048777324
    },
    {
      "type": "edit",
      "id": "1b5ad3efc1ca8a18",
      "item": {
        "type": "paragraph",
        "id": "1b5ad3efc1ca8a18",
        "text": "In the second case, ec is a special temporary variable that holds an error code. \nIn the VM primitive, failure is indicated by a variable called primFailCode being \nnon-zero. On activating a method with a failing primitive, if the index is in \nbounds of the primitiveFailCodes array in the VMspecialObjectsArray then the \nfailure code substitutes the symbol in the primitiveFailCodes array, otherwise \nit supplies the integer value."
      },
      "date": 1705048872252
    },
    {
      "type": "add",
      "id": "09db45abf55439bf",
      "item": {
        "type": "paragraph",
        "id": "09db45abf55439bf",
        "text": "Primitives exist for several reasons. Certain basic or 'primitive' \noperations cannot be performed in any other way. Smalltalk without \nprimitives can move values from one variable to another, but cannot add two \nSmallIntegers together. Many methods for arithmetic and comparison \nbetween numbers are primitives. Some primitives allow Smalltalk to \ncommunicate with I/O devices such as the disk, the display, and the keyboard. \nSome primitives exist only to make the system run faster; each does the same \nthing as a certain Smalltalk method, and its implementation as a primitive is \noptional.  \n  \nWhen the Smalltalk interpreter begins to execute a method which specifies a \nprimitive response, it tries to perform the primitive action and to return a \nresult. If the routine in the interpreter for this primitive is successful, \nit will return a value and the expressions in the method will not be evaluated. \nIf the primitive routine is not successful, the primitive 'fails', and the \nSmalltalk expressions in the method are executed instead. These \nexpressions are evaluated as though the primitive routine had not been \ncalled.  \n  \nThe Smalltalk code that is evaluated when a primitive fails usually \nanticipates why that primitive might fail. If the primitive is optional, the \nexpressions in the method do exactly what the primitive would have done (See \nNumber @). If the primitive only works on certain classes of arguments, the \nSmalltalk code tries to coerce the argument or appeals to a superclass to find \na more general way of doing the operation (see SmallInteger +). If the \nprimitive is never supposed to fail, the expressions signal an error (see \nSmallInteger asFloat).  \n  \nEach method that specifies a primitive has a comment in it. If the primitive is \noptional, the comment will say 'Optional'. An optional primitive that is not \nimplemented always fails, and the Smalltalk expressions do the work \ninstead.  \n \nIf a primitive is not optional, the comment will say, 'Essential'. Some \nmethods will have the comment, 'No Lookup'. See Object \nhowToModifyPrimitives for an explanation of special selectors which are \nnot looked up.  \n  \nFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \nin Float, the primitive constructs and returns a 16-bit \nLargePositiveInteger when the result warrants it. Returning 16-bit \nLargePositiveIntegers from these primitives instead of failing is \noptional in the same sense that the LargePositiveInteger arithmetic \nprimitives are optional. The comments in the SmallInteger primitives say, \n'Fails if result is not a SmallInteger', even though the implementor has the \noption to construct a LargePositiveInteger. For further information on \nprimitives, see the 'Primitive Methods' part of the chapter on the formal \nspecification of the interpreter in the Smalltalk book."
      },
      "after": "1b5ad3efc1ca8a18",
      "date": 1705048873443
    },
    {
      "type": "edit",
      "id": "09db45abf55439bf",
      "item": {
        "type": "paragraph",
        "id": "09db45abf55439bf",
        "text": "Primitives exist for several reasons. Certain basic or 'primitive' \noperations cannot be performed in any other way. Smalltalk without \nprimitives can move values from one variable to another, but cannot add two \nSmallIntegers together. Many methods for arithmetic and comparison \nbetween numbers are primitives. Some primitives allow Smalltalk to \ncommunicate with I/O devices such as the disk, the display, and the keyboard. \nSome primitives exist only to make the system run faster; each does the same \nthing as a certain Smalltalk method, and its implementation as a primitive is \noptional."
      },
      "date": 1705048899947
    },
    {
      "type": "add",
      "id": "da57c3955bf8dda3",
      "item": {
        "type": "paragraph",
        "id": "da57c3955bf8dda3",
        "text": "When the Smalltalk interpreter begins to execute a method which specifies a \nprimitive response, it tries to perform the primitive action and to return a \nresult. If the routine in the interpreter for this primitive is successful, \nit will return a value and the expressions in the method will not be evaluated. \nIf the primitive routine is not successful, the primitive 'fails', and the \nSmalltalk expressions in the method are executed instead. These \nexpressions are evaluated as though the primitive routine had not been \ncalled.  \n  \nThe Smalltalk code that is evaluated when a primitive fails usually \nanticipates why that primitive might fail. If the primitive is optional, the \nexpressions in the method do exactly what the primitive would have done (See \nNumber @). If the primitive only works on certain classes of arguments, the \nSmalltalk code tries to coerce the argument or appeals to a superclass to find \na more general way of doing the operation (see SmallInteger +). If the \nprimitive is never supposed to fail, the expressions signal an error (see \nSmallInteger asFloat).  \n  \nEach method that specifies a primitive has a comment in it. If the primitive is \noptional, the comment will say 'Optional'. An optional primitive that is not \nimplemented always fails, and the Smalltalk expressions do the work \ninstead.  \n \nIf a primitive is not optional, the comment will say, 'Essential'. Some \nmethods will have the comment, 'No Lookup'. See Object \nhowToModifyPrimitives for an explanation of special selectors which are \nnot looked up.  \n  \nFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \nin Float, the primitive constructs and returns a 16-bit \nLargePositiveInteger when the result warrants it. Returning 16-bit \nLargePositiveIntegers from these primitives instead of failing is \noptional in the same sense that the LargePositiveInteger arithmetic \nprimitives are optional. The comments in the SmallInteger primitives say, \n'Fails if result is not a SmallInteger', even though the implementor has the \noption to construct a LargePositiveInteger. For further information on \nprimitives, see the 'Primitive Methods' part of the chapter on the formal \nspecification of the interpreter in the Smalltalk book."
      },
      "after": "09db45abf55439bf",
      "date": 1705048901205
    },
    {
      "type": "edit",
      "id": "09db45abf55439bf",
      "item": {
        "type": "paragraph",
        "id": "09db45abf55439bf",
        "text": "Primitives exist for several reasons. Certain basic or 'primitive' operations cannot be performed in any other way. Smalltalk without primitives can move values from one variable to another, but cannot add two SmallIntegers together. Many methods for arithmetic and comparison between numbers are primitives. Some primitives allow Smalltalk to communicate with I/O devices such as the disk, the display, and the keyboard. Some primitives exist only to make the system run faster; each does the same thing as a certain Smalltalk method, and its implementation as a primitive is optional."
      },
      "date": 1705048922092
    },
    {
      "type": "edit",
      "id": "da57c3955bf8dda3",
      "item": {
        "type": "paragraph",
        "id": "da57c3955bf8dda3",
        "text": "When the Smalltalk interpreter begins to execute a method which specifies a \nprimitive response, it tries to perform the primitive action and to return a \nresult. If the routine in the interpreter for this primitive is successful, \nit will return a value and the expressions in the method will not be evaluated. \nIf the primitive routine is not successful, the primitive 'fails', and the \nSmalltalk expressions in the method are executed instead. These \nexpressions are evaluated as though the primitive routine had not been \ncalled."
      },
      "date": 1705048982835
    },
    {
      "type": "add",
      "id": "e97069b03dbc6545",
      "item": {
        "type": "paragraph",
        "id": "e97069b03dbc6545",
        "text": "The Smalltalk code that is evaluated when a primitive fails usually \nanticipates why that primitive might fail. If the primitive is optional, the \nexpressions in the method do exactly what the primitive would have done (See \nNumber @). If the primitive only works on certain classes of arguments, the \nSmalltalk code tries to coerce the argument or appeals to a superclass to find \na more general way of doing the operation (see SmallInteger +). If the \nprimitive is never supposed to fail, the expressions signal an error (see \nSmallInteger asFloat).  \n  \nEach method that specifies a primitive has a comment in it. If the primitive is \noptional, the comment will say 'Optional'. An optional primitive that is not \nimplemented always fails, and the Smalltalk expressions do the work \ninstead.  \n \nIf a primitive is not optional, the comment will say, 'Essential'. Some \nmethods will have the comment, 'No Lookup'. See Object \nhowToModifyPrimitives for an explanation of special selectors which are \nnot looked up.  \n  \nFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \nin Float, the primitive constructs and returns a 16-bit \nLargePositiveInteger when the result warrants it. Returning 16-bit \nLargePositiveIntegers from these primitives instead of failing is \noptional in the same sense that the LargePositiveInteger arithmetic \nprimitives are optional. The comments in the SmallInteger primitives say, \n'Fails if result is not a SmallInteger', even though the implementor has the \noption to construct a LargePositiveInteger. For further information on \nprimitives, see the 'Primitive Methods' part of the chapter on the formal \nspecification of the interpreter in the Smalltalk book."
      },
      "after": "da57c3955bf8dda3",
      "date": 1705048984524
    },
    {
      "type": "edit",
      "id": "da57c3955bf8dda3",
      "item": {
        "type": "paragraph",
        "id": "da57c3955bf8dda3",
        "text": "When the Smalltalk interpreter begins to execute a method which specifies a primitive response, it tries to perform the primitive action and to return a result. If the routine in the interpreter for this primitive is successful, it will return a value and the expressions in the method will not be evaluated. If the primitive routine is not successful, the primitive 'fails', and the Smalltalk expressions in the method are executed instead. These expressions are evaluated as though the primitive routine had not been called."
      },
      "date": 1705048994768
    },
    {
      "type": "edit",
      "id": "e97069b03dbc6545",
      "item": {
        "type": "paragraph",
        "id": "e97069b03dbc6545",
        "text": "The Smalltalk code that is evaluated when a primitive fails usually \nanticipates why that primitive might fail. If the primitive is optional, the \nexpressions in the method do exactly what the primitive would have done (See \nNumber @). If the primitive only works on certain classes of arguments, the \nSmalltalk code tries to coerce the argument or appeals to a superclass to find \na more general way of doing the operation (see SmallInteger +). If the \nprimitive is never supposed to fail, the expressions signal an error (see \nSmallInteger asFloat)."
      },
      "date": 1705049042672
    },
    {
      "type": "add",
      "id": "c20bc666246a2ea2",
      "item": {
        "type": "paragraph",
        "id": "c20bc666246a2ea2",
        "text": "Each method that specifies a primitive has a comment in it. If the primitive is \noptional, the comment will say 'Optional'. An optional primitive that is not \nimplemented always fails, and the Smalltalk expressions do the work \ninstead.  \n \nIf a primitive is not optional, the comment will say, 'Essential'. Some \nmethods will have the comment, 'No Lookup'. See Object \nhowToModifyPrimitives for an explanation of special selectors which are \nnot looked up.  \n  \nFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \nin Float, the primitive constructs and returns a 16-bit \nLargePositiveInteger when the result warrants it. Returning 16-bit \nLargePositiveIntegers from these primitives instead of failing is \noptional in the same sense that the LargePositiveInteger arithmetic \nprimitives are optional. The comments in the SmallInteger primitives say, \n'Fails if result is not a SmallInteger', even though the implementor has the \noption to construct a LargePositiveInteger. For further information on \nprimitives, see the 'Primitive Methods' part of the chapter on the formal \nspecification of the interpreter in the Smalltalk book."
      },
      "after": "e97069b03dbc6545",
      "date": 1705049043775
    },
    {
      "type": "edit",
      "id": "e97069b03dbc6545",
      "item": {
        "type": "paragraph",
        "id": "e97069b03dbc6545",
        "text": "The Smalltalk code that is evaluated when a primitive fails usually anticipates why that primitive might fail. If the primitive is optional, the expressions in the method do exactly what the primitive would have done (See Number @). If the primitive only works on certain classes of arguments, the Smalltalk code tries to coerce the argument or appeals to a superclass to find a more general way of doing the operation (see SmallInteger +). If the primitive is never supposed to fail, the expressions signal an error (see SmallInteger asFloat)."
      },
      "date": 1705049057902
    },
    {
      "type": "edit",
      "id": "c20bc666246a2ea2",
      "item": {
        "type": "paragraph",
        "id": "c20bc666246a2ea2",
        "text": "Each method that specifies a primitive has a comment in it. If the primitive is \noptional, the comment will say 'Optional'. An optional primitive that is not \nimplemented always fails, and the Smalltalk expressions do the work \ninstead."
      },
      "date": 1705049102443
    },
    {
      "type": "add",
      "id": "aae77ea03201792b",
      "item": {
        "type": "paragraph",
        "id": "aae77ea03201792b",
        "text": "If a primitive is not optional, the comment will say, 'Essential'. Some \nmethods will have the comment, 'No Lookup'. See Object \nhowToModifyPrimitives for an explanation of special selectors which are \nnot looked up.  \n  \nFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \nin Float, the primitive constructs and returns a 16-bit \nLargePositiveInteger when the result warrants it. Returning 16-bit \nLargePositiveIntegers from these primitives instead of failing is \noptional in the same sense that the LargePositiveInteger arithmetic \nprimitives are optional. The comments in the SmallInteger primitives say, \n'Fails if result is not a SmallInteger', even though the implementor has the \noption to construct a LargePositiveInteger. For further information on \nprimitives, see the 'Primitive Methods' part of the chapter on the formal \nspecification of the interpreter in the Smalltalk book."
      },
      "after": "c20bc666246a2ea2",
      "date": 1705049103661
    },
    {
      "type": "edit",
      "id": "c20bc666246a2ea2",
      "item": {
        "type": "paragraph",
        "id": "c20bc666246a2ea2",
        "text": "Each method that specifies a primitive has a comment in it. If the primitive is optional, the comment will say 'Optional'. An optional primitive that is not implemented always fails, and the Smalltalk expressions do the work instead."
      },
      "date": 1705049119603
    },
    {
      "type": "edit",
      "id": "aae77ea03201792b",
      "item": {
        "type": "paragraph",
        "id": "aae77ea03201792b",
        "text": "If a primitive is not optional, the comment will say, 'Essential'. Some \nmethods will have the comment, 'No Lookup'. See Object \nhowToModifyPrimitives for an explanation of special selectors which are \nnot looked up."
      },
      "date": 1705049145588
    },
    {
      "type": "add",
      "id": "8043d248e238f345",
      "item": {
        "type": "paragraph",
        "id": "8043d248e238f345",
        "text": "For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \nin Float, the primitive constructs and returns a 16-bit \nLargePositiveInteger when the result warrants it. Returning 16-bit \nLargePositiveIntegers from these primitives instead of failing is \noptional in the same sense that the LargePositiveInteger arithmetic \nprimitives are optional. The comments in the SmallInteger primitives say, \n'Fails if result is not a SmallInteger', even though the implementor has the \noption to construct a LargePositiveInteger. For further information on \nprimitives, see the 'Primitive Methods' part of the chapter on the formal \nspecification of the interpreter in the Smalltalk book."
      },
      "after": "aae77ea03201792b",
      "date": 1705049146940
    },
    {
      "type": "edit",
      "id": "aae77ea03201792b",
      "item": {
        "type": "paragraph",
        "id": "aae77ea03201792b",
        "text": "If a primitive is not optional, the comment will say, 'Essential'. Some methods will have the comment, 'No Lookup'. See Object howToModifyPrimitives for an explanation of special selectors which are not looked up."
      },
      "date": 1705049162417
    },
    {
      "type": "edit",
      "id": "8043d248e238f345",
      "item": {
        "type": "paragraph",
        "id": "8043d248e238f345",
        "text": "For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated in Float, the primitive constructs and returns a 16-bit LargePositiveInteger when the result warrants it. Returning 16-bit LargePositiveIntegers from these primitives instead of failing is optional in the same sense that the LargePositiveInteger arithmetic primitives are optional. The comments in the SmallInteger primitives say, 'Fails if result is not a SmallInteger', even though the implementor has the option to construct a LargePositiveInteger. For further information on primitives, see the 'Primitive Methods' part of the chapter on the formal specification of the interpreter in the Smalltalk book."
      },
      "date": 1705049206982
    }
  ]
}