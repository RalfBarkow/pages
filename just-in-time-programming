{
  "title": "Just In Time Programming",
  "story": [
    {
      "type": "markdown",
      "id": "5be405ab12de44d0",
      "text": "An iterative approach to development. Focus on developing only what your current requirements call for. [https://c2.com/xp/JustInTimeProgramming.html c2.com]  [[Do The Simplest Thing That Could Possibly Work]].  Assume that [[You Arent Gonna Need It]]."
    },
    {
      "type": "paragraph",
      "id": "37a8826147eb0e1a",
      "text": "[[Just-in-Time Programming]] by [[Richard Potter]], Human Computer Interaction Lab, University of Maryland [http://web.media.mit.edu/~lieber/Teaching/Context/Potter.rtf rtf]"
    },
    {
      "type": "markdown",
      "id": "26fe073b834e8522",
      "text": "## Introduction\nMany of the other chapters have presented advancements in programming by demonstration by presenting PBD systems and their innovations.  In other words, these chapters have presented solutions.  This chapter takes another tact by discussing PBD in the context of a problem.  The problem is to create a programming system that is effective for just-in-time programming.  This chapter defines just-in-time programming, explains how it relates to other forms of programming, and explores how creating effective just-in-time programming systems motivates PBD research.\n"
    },
    {
      "type": "markdown",
      "id": "5745e710a3f02563",
      "text": "Just-in-time programming is the implementing of algorithms during task-time (i.e. the time when the user is actually trying to accomplish the task to be automated) and can be characterized by a situation with the following components:\n* a computer user who could be either a novice user or an experienced programmer,\n* a task that the user is manually accomplishing and completion of which is the user's primary goal,\n* an algorithm that will accomplish a subtask (i.e. part of the task) and that the user envisioned while working on the task,\n* and an attempt by the user to implement the algorithm for the purpose of more effectively completing the task.\n\n"
    },
    {
      "type": "markdown",
      "id": "b67f51d14ea929c3",
      "text": "In short, the goal of just-in-time programming is to allow users to profit from their task-time algorithmic insights by programming.  Instead of automating with software that was carefully designed and implemented much earlier, the user recognizes an algorithm and then creates the software to take advantage of it just before it is needed, hence implementing it just in time.\n\n"
    },
    {
      "type": "markdown",
      "id": "921ea177f259d957",
      "text": "It is worth emphasizing that the user's task could be from any domain (e.g. graphic drawing, scientific visualization, word processing, etc.) and that the algorithm to be implemented originates with the user.  Obviously, a user with more programming experience will be able to envision a more complex algorithm than a novice user.  How the user comes up with the algorithm is not a concern.  Also, no hint of a solution appears in the problem statement.  Any programming system could conceivably be used for just-in-time programming, including C, PASCAL, keyboard macros, scripting languages, or PBD. PBD will probably be an important part of the more successful just-in-time programming systems, but the problem statement leaves open the possibility for other solutions.\n"
    },
    {
      "type": "markdown",
      "id": "60e7739bdc242a3d",
      "text": "Just-in-time programming research shares many of the motivations of other PBD research.  Chief among these is that users often do repetitive or algorithmic subtasks that the computer could be doing.  We call these subtasks *potential computer subtasks* and call these situations *opportunities for new beneficial automation*.  Because automating can increase productivity and user satisfaction and at the same time reduce errors, one would expect the user to delegate potential computer subtasks to the computer.  That users often do not take advantage of these opportunities motivates researching ways to improve the computer.  Just-in-time programming research and PBD research assert that easier to use *programming tools* will allow users to better take advantage of opportunities for new beneficial automation.\n"
    },
    {
      "type": "markdown",
      "id": "52e6e49fce0e18e9",
      "text": "Just-in-time programming research, however, is focused on making programming easier for a specific cross section of situations.  These situations are primarily defined by the user programming during task-time.  In other words, the user is attempting to write a program for a task that is already in progress.  Figure 1 summarizes the relationship between task progress and the user's expenditure of effort.  The expenditure of effort for just-in-time programming is shown separate from the other task related effort.  The difficulty of just-in-time programming results from the spreading of the user's mental resources between two activities.  Another difficulty is that the time spent programming contributes directly to total time between the start and completion of the task.\n"
    },
    {
      "type": "html",
      "id": "43b95e8f5f339163",
      "text": "<center><img width=\"100%\" src=\"data:image/png;base64,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5pGPfGSz/fbbj8qQchyJgcRAHww873nPa+68884+Z/LQuGBgpDQHSH3Qgx7U/Oqv/uq44DfnkRgYSww84AEPGPl5/exnP2ve+MY3Vpry1Kc+tfnyl7/cnHbaac3b3/725uSTTx7K+N/znvc0X//615tzzjlnUn+33357c/rppzfw9PM///PNP//zPzdvfvObm3XXXXdSu6X+YQyHHnpo84hHPGLWW6fPYVYUZYPEQGJgJWLgF37hF5pvf/vbzS677NLsvPPOzetf//rmIQ95SHPIIYfU6fzf//1fJdp+MKD867/+a/383//938a5f/mXf2n+/d//fWLqfveCts9+9rN7DzcY01lnndXcfffdzbbbblvv/Su/8iu1nXOg29+//du/1WPdf44ZU0C3vfHFNT6NI/rVHjP6p3/6p3qpMcQ8DjjggAnGEPPV6L//+7/rePQTMHKaQwxskM+77rqr+exnP1slgu9+97vNj3/84wkk0ED8PexhD2t++Zd/ufFg1lprreZJT3pS/VtvvfWaRz/60YPcZqzbWDg/+clPmic/+clznuc3vvGNKhX94Ac/aH7t136t4nrOnQxwgef6cz/3c815553X/L//9/+ab37zmw3JbL/99muOO+64Zu+9927+/u//vr4Mr3jFK5rPfOYzzW//9m/X5z+IhDTAEEayCYJGGv6N3/iNOY/v7/7u75of/vCHzYMf/OD6DJdbop3zBAa44D//8z+bz3/+883111/fXHfddc2b3vSmZt9992222WabZsMNN2zOPffc5r/+67+aF73oRc13vvOd5uEPf3jzmMc8prGeXfsXf/EXdU2/7W1vq22/9KUvNR/4wAcqPYnbf/zjH2/+4A/+IH5OfP76r/96ZTD8qH/4h39YifxWW21Vx7PXXns1l112WXPkkUc2J554Yj1Ps7FuQ6P5h3/4h+bwww+vzEyb9773vXWs+n3sYx/bfPKTn6zz0oY29JznPKeO+ZhjjmmMd4MNNmi+8IUvNLvttlvzlre8pUHvMEjazJ//+Z9XxrXJJps0559/fnPxxRc3v/M7v9M88YlPrGNCJ8GKYw64pAcEub6zff7Wb/1W86pXvaqao0gG//M//1M5oQf8H//xH5Vp/PSnP62fHvDVV19d7aW4JKL2zGc+s/55QBA0THAP4zAugEN7qTEu5/ymdt7vfver53F4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\"></center>"
    },
    {
      "type": "markdown",
      "id": "ca80aab2b586cd46",
      "text": "Figure 1:  Just-in-time programming intermixes programming effort with other task related effort.\n"
    },
    {
      "type": "html",
      "id": "07398bac659aa1d4",
      "text": "<center>\n  <img\n    width=\"100%\"\n    src=\"http://acypher.com/wwid/Chapters/Chapter271.gif\"\n  >\n</center>"
    },
    {
      "type": "markdown",
      "id": "5d4947e3e1d04306",
      "text": "//FIXME http://acypher.com/wwid/Chapters/Chapter271.gif\nFigure 1. Two scenarios are shown of a user presented with an opportunity suitable for just-in-time programming. The intermixing of programming effort with other task related effort is shown for the second scenario where the user decides to apply just-in-time programming.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "1b55857e3235aa15",
      "text": "## What is not Just-in-time Programming?\nOne might contrast just-in-time programming with, for lack of a better term, task-time independent programming which is summarized in figure 2.  For an example, consider a user who is programming a [[HyperCard]] mock-up of a user interface in preparation for a demonstration the next day.  The subtask of the software is to help an audience visualize a proposed user interface design during the meeting.  This example would be task-time independent programming because the software is created well before the meeting.  As is the case with many distinctions, there are examples that straddle the line between just-in-time programming and task-time independent programming, but the discussions that follow should hold regardless.\nFigure 2:  Task-time independent programming separates programming effort from other task-related effort.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "279618ac11b7b347",
      "text": "Just-in-time programming can be contrasted with other forms of programming by considering implications of the situation characterized in the introduction.  For example, since the algorithm to be implemented is the product of the user's insight, it is typically simple.  Thus one could contrast just-in-time programming with programming-in-the-large.  For an example, developing a full featured word processor would not be just-in-time programming because an algorithm that implements all the features of a word processor is too complex for one person to envision.\n\n"
    },
    {
      "type": "markdown",
      "id": "37122d1b9316951a",
      "text": "Another implication of the situation characterized earlier is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\n\n"
    },
    {
      "type": "markdown",
      "id": "017090bcd890bbe4",
      "text": "How does just-in-time programming relate to the more common PBD application of programming for novice programmers? These two types of programming are basically independent;  programming in a given situation could represent both, one, or neither of these.  \n"
    },
    {
      "type": "markdown",
      "id": "5777e0a76f3a54ae",
      "text": "A novice programmer writing a short program that changes all numbers in a document to a larger font would be an example of both types of programming, assuming the user was about to make the modifications by hand.  A novice programmer writing educational software to be used by students at a later time would be an example of a novice programmer programming, but not just-in-time programming.  I recently modified a postscript file to only print out the even pages of the document and then the odd pages so that it would print on both sides of the paper without requiring me to issue a separate print command for each page.  This would be an example of just-in-time programming that was not programming for the novice.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "5fcfa3af16685de7",
      "text": "A Subtask Suitable for Just-in-Time Programming\nI happened upon an opportunity for just-in-time programming when Think C updated their class library to version 1.1.  Before version 1.1, rectangles were defined with 16-bit coordinates and in version 1.1 rectangles were defined by 32-bit coordinates.  When I first compiled my software project with the new class library, type mismatch errors occurred where my software expected 16-bit values.  Many of these were simple assignment statements.  The new class library included a utility function for converting 32-bit rectangles to 16-bit rectangles, so a typical fix involved changing a line of the form\n"
    },
    {
      "type": "code",
      "id": "e265f8914f538469",
      "text": "*inset=frame;"
    },
    {
      "type": "markdown",
      "id": "408bda90c3142bd6",
      "text": "to the form \n"
    },
    {
      "type": "markdown",
      "id": "8500011ce45ded08",
      "text": "\n"
    },
    {
      "type": "code",
      "id": "a714d3608ae0bfb7",
      "text": "longToQDRect(&frame,inset);"
    },
    {
      "type": "markdown",
      "id": "5528af9204e0b71a",
      "text": ".\n"
    },
    {
      "type": "markdown",
      "id": "7a507bdf0e4f872e",
      "text": "Various other types of errors were found and fixed as well.  The second time an assignment of a 32-bit rectangle to a 16-bit rectangle caused an error, I recalled that there were many such assignments throughout my program and concluded I would, in time, be transforming many lines from assignment statements into function calls. Each would differ only in the names of the variables and whether each variable was a pointer or not (i.e. preceded by a \"*\").  For the rest of this paper, transforming one of these lines will be called the line transformation subtask.\nTo attempt to automate this subtask would have been just-in-time programming because of the situation.  This particular example also contrasts well with the other types of programming discussed above.  It would certainly not be task-time independent programming because I was in the midst of modifying my software project.  The subtask was algorithmically simple so it was not programming-in-the-large.  Automating the subtask was not essential, so it was not essential programming.\n"
    },
    {
      "type": "markdown",
      "id": "2f006e42e4ec3116",
      "text": "So to break this situation down into the components of just-in-time programming:\nThe user: \nmyself\nThe task: \nmodifying a software project to work with an updated class library\nThe subtask: \nchanging certain lines of source code from the form {*}var1 = {*}var2; to the form longToQDRect({&}var2,{&}var1); (i.e. the line transformation subtask)\nThe algorithm: \ninsert leading white space\ninsert \"longToQDRect(\"\nif second variable name is not preceded by \"*\", insert \"&\"\ninsert second variable name\ninsert \",\"\nif first variable name is not preceded by \"*\", insert \"&\"\ninsert first variable name\ninsert \")\"\ninsert rest of line (the \";\" and comments, if any)\ndelete original line.\nThe attempt to automate:  \nActually I did not try to automate the subtask.  The rest of the chapter will explain why.\n\nFive Obstacles\nOne reason to explicitly state a problem is so that it can be broken down into meaningful subproblems.  One way to do this is to analyze current technology, identify common obstacles that prevent the technology from being effective, and let the subproblems be to find ways to eliminate these obstacles.  The following sections discuss five obstacles that often prevent users of current programming systems from profiting from their algorithmic insights.  Each section also discusses PBD's potential role in solving the subproblem represented by each obstacle.\n\t\nFigure 3:  A C algorithm that automates the line transformation subtask assuming the line has been isolated in a character buffer.\n\nEffort of entering the algorithm\nGiven that I understood the algorithmic structure of the line transformation subtask, why not automate it?  Since I was actually using a C programming system, let's first explore the possibility of using it.  Figure 3 shows a program in C that can transform the line as needed, assuming that the line has been loaded into a string (we will deal with this assumption more later).  One obstacle quickly becomes apparent: the effort of entering the algorithm.  Merely the physical effort of typing in the 749 characters of this program would likely undermine the benefits of automating this small part of the task.  But there is also the mental effort required to translate the algorithm into the idioms of the language and to work out the fine details.  For example, after years of programming in C, I still must look up the strcat function in the manual to see if it copies from the first argument to the second or vice versa.\nDiscussion  No matter what type of programming is being done, reducing this effort is desirable.  However, the effort of entering an algorithm is particularly important for just-in-time programming because the subtasks appropriate for just-in-time programming are typically special purpose needs that can not be as widely applied as functionality that is more generic.  The line transformation task is a good example of this because once I finished updating the software project, I had no need for this particular functionality.  When the benefits per programming effort are modest, only minimal effort can be expended towards entering the algorithm before the venture becomes pointless.  If the user's task is creative or involves problem solving, then the user can scarcely afford to expend mental effort for modest gains.  Of course, there are times when the payoffs of just-in-time programming are large enough that the effort to enter the algorithm is not as crucial.  But there are enough opportunities for modest payoffs that finding ways to reduce the effort required to enter the algorithm is an important subproblem to solve.\nSometimes creating new beneficial automation by programming pays off because the user can apply the automation many times in the future.  A script that automatically dials a remote computer and logs the user into their account would be a good example.  Here the distinction between just-in-time programming and task-time independent programming is blurred.  Strictly speaking, the programming effort is expended at a time independent of when the benefits of the automation are received.  However, the user is likely to automate this task at a time when they are about to dial in to the remote computer manually, that is, when the desirability of automating the subtask comes to mind.  So although the user could set aside some time and do task-time independent programming, psychologically the task-time aspects of whatever the user is doing are likely to impact the programming process.  In this sense, much of the special concerns of just-in-time programming still hold.\nReducing this effort is less important for programming-in-the-large because the effort required to manage the complexity of a large software project tends to overshadow the effort required to enter the algorithm.  In fact, programming languages such as Ada even increase the effort of entering the algorithm by requiring extra notation for modularizing the code.  Such notation does not contribute directly to functionality, but is appropriate for programming-in-the-large because complexity is such an overriding concern.\nJust-in-time programming accentuates the mental effort required to enter the algorithm because users must switch their mind-sets from the task domain to the programming domain as illustrated in figure 1.  After the algorithm has been implemented, users must also expend effort to return their mind-sets to the task domain.  Users might expend effort trying not to divert too much attention to the programming effort, sometimes trying to keep more in their short term memory than is reasonable.  For creative tasks, this diversion is especially costly.  In contrast, users who are programming independently of task time can change their mind-set over a longer period of time.\nTherefore when minimizing the effort of entering the algorithm, it is important to minimize distraction from the task.  One of the main sources of effort and distraction is the number of special programming concepts.  For example, writing the C algorithm in figure 3 required remembering how strings are allocated and referenced.  On this point, just-in-time programming and programming for novice programmers share similar goals because a programming system for novice programmers should require the understanding of as few new concepts as possible.  In cases where a just-in-time programming system is being designed specifically for novice programmers, the same would apply.\nThe idea of just-in-time programming, however, is not limited to novice programmers.  For expert programmers, whether a concept is familiar to a nonprogrammer is not the crucial factor.  Instead, the programming system should require the user to understand only concepts that can be ingrained and that the user can apply fluently.  Therefore, part of the research agenda of just-in-time programming should be to identify key skills that, if ingrained, will allow a user to more effectively write programs just in time.  These skills could be anything from something classic like regular expressions to some new esoteric programming paradigm.  It seems clear that, at least for the foreseeable future, users will have to understand the basic concepts of conditionals and iteration.\nSolution directions  Many techniques including code templates, code reuse, domain specific functionality, subroutines, copy/paste, and on-line documentation can help reduce the effort required to enter an algorithm.  PBD helps reduce this effort by allowing users to enter the algorithm using the same interface as they would normally use to work the subtask manually.  This helps reduce both the physical effort and the mental effort because the user is often well practiced at using this interface.  Since the user would use the same user interface to work the subtask manually, the artifacts are already in short term memory and programming with them is likely to be less distracting than with an off-line programming language.  The effort to enter the algorithm is also reduced because user interfaces are usually optimized to the task.\nFigure 4:  This Quickeys macro can partially automate the line transformation subtask.  The number of keystrokes required to enter the macro and the visual state of the editor are shown.\n\nFor a simple example of how PBD can reduce the effort of entering an algorithm, consider one partial solution to the line transformation subtask.  If the user first places the cursor to the left of the first variable in the line to be transformed and neither variable is a pointer, then the Quickeys macro shown in figure 4 will transform the line as required.  The macro also assumes that exactly three characters (\" = \") separate the two variable names.  Only the 33 keypresses shown in figure 4 are required to implement the macro.  The visual feedback of the editor also helps reduce the mental effort by showing intermediate results.\nLimited computational generality\nWhy illustrate the virtues of the keyboard macro by only partially automating the line transformation subtask?  The reason is that the subtask requires conditional logic to decide whether each variable is a pointer or not.  Keyboard macros only record straight-line algorithms and thus are not able to fully automate this subtask.  This illustrates an obstacle that users face when programming just in time:  the programming systems that make it easy to enter their algorithm can often only implement algorithms of limited computational generality.\nDiscussion  It is important for a just-in-time programming system to have full Turing-complete computational generality because there is no way to predict which of the vast array of algorithms the user might envision.  Unfortunately computational generality is not one of PBD's strengths.  Halbert recognized this when implementing SmallStar and concluded that control structures were better created by editing a static representation of the program than by demonstration [Halbert 84].  Others have used inference to generalize straight-line demonstrations into procedures with control structures.  Cypher's Eager and Myers' Peridot used domain knowledge to infer procedures with control structures solely from straight-line demonstrations [EAGER CHAPTER, PERIDOT CHAPTER].  The computational generality of these systems, however, was limited by limited domain knowledge.\nSolution directions  In order for a PBD to be used for just-in-time programming, it will have to be integrated with other techniques to give full computational generality.  Interesting directions include giving separate examples for each path of the algorithm as in Tinker [TINKER CHAPTER], or a combination of multiple demonstrations, inferencing, and special instructions from the user as in Metamouse [METAMOUSE CHAPTER].\nEffort of invoking algorithm\nAs stated previously, the effort to enter an algorithm is less of an obstacle when the benefits of automating are large.  So for the sake of argument, assume that I knew there would be hundreds of lines needing to be transformed and decided to automate the task using C.  Limited computational generality would not be an obstacle with C.  Are there other obstacles?\nWhen the compiler detected an error in my software project, it would load the file containing the error into its text editor and highlight the erroneous line.  To take advantage of the line transformation program, I would first have to judge if it was one of the simple type mismatch errors that could be fixed by the simple line transformation.  If so, I would then invoke the C implementation on the specific line.  But how would I do that?  One possibility would be to mark the line some special way, perhaps by placing a \"*\" at the beginning of the line, and then save the file out to disk.  Then I could run the C program which would then prompt me for the name of the file with the incorrect line.  The C program would then scan through the file for a line that started with a \"*\" and apply the transformation to it.  But this would be silly.  The effort to invoke the algorithm would undermine the benefits and would be yet another obstacle to automating this subtask.\nDiscussion  As in this case, a subtask appropriate for just-in-time programming typically applies to part of a larger document.  Thus, users must be able to implement the algorithm such that they can specify which part of the document should be processed when they invoke the algorithm.  It is important that they be able to do this with ease because the benefits to be obtained by automating can be easily negated by the invocation effort.  Unlike the effort to enter the algorithm, the effort to invoke the algorithm can not be amortized over the life of the new beneficial automation.  The effort must be small in comparison with the benefit received from each invocation of the algorithm.  When the payoffs per invocation are larger this obstacle is not as crucial, but enough opportunities for modest benefits exist that it is important to reduce the effort required to invoke algorithms implemented just in time.\nFor an example of how crucial the ease of invocation can be towards making automation beneficial, consider the feature on many word processors that allows a user to select a word simply by double clicking on it.  The word processor automatically does the tedious subtask of extending the selection out to the word boundaries.  Identifying these word boundaries manually is a simple subtask, so not much benefit is received each time the feature is used.  However, words are selected so commonly that, over time, the feature is very beneficial.  Another invocation strategy could easily undermine this benefit.  For example, even requiring the user to click on the word and then select the feature from a pull down menu could require too much effort.\nAs the previous example implies, this obstacle is not unique to just-in-time programming.  Because the effort to invoke the algorithm can not be amortized, any programming endeavor that produces interactive software needs to pay special attention to this obstacle.  The main difference for just-in-time programming is that the user can not amortize the effort to create the invocation scheme as much.\nSolution directions  How should just-in-time programming make it easy to invoke algorithms?  One clue is strongly implied by the hypothetical consideration of C for automating the line transformation subtask:  users should be able to implement their algorithms such that they can perform the subtask without having to save their documents to disk.  Instead their algorithms should be able to process data in its present form which is usually internal to some application.  Thus just-in-time programming systems should allow users to process data within their applications.  In addition, users should be able to use the application's data selection mechanisms to indicate what part of their document to process.  This would enable users to work manually, apply a newly implemented algorithm to the data, and continue to work manually without the overhead of saving the data to a file. Processing data within applications is central to PBD, so it already goes far to easing the effort to invoke the algorithm.\nBeyond automating within applications, just-in-time programming systems should allow the user to choose among various invocation strategies.  Standard invocations such as menu selections and keypresses should be supported.  The ability to create more refined invocations, like double clicking on a an object to apply some automation to it, would be important for making some highly interactive automation worth creating.  PBD techniques could possibly be used to have the fact that the user has started doing the subtask be what triggers the automation to be invoked.  David Maulsby's Turvy and Metamouse give hints of how this might work [TURVY CHAPTER, METAMOUSE CHAPTER].\nInaccessible data and operators\nSo far we have seen several reasons to want to process data while it resides within an application.  One is to make algorithms easier to enter by allowing the user to demonstration the algorithm through the user interface of the application.  Another is that invocations can be made easier if the data is processed within the application.  The Quickeys solution in figure 4 had these advantages, but it only partially automated the subtask.  No other programming system on my computer (including APL, C, Lisp, Scheme, or HyperTalk) can automate within Think C's editor because of the fourth obstacle, inaccessible data and operators.  In this case, this obstacle undermines the modest benefits of automating the subtask.  If the benefits per invocation were greater, then accessing the data independently of the application by saving the document to a file might have made creating the new automation worthwhile.\nIn other cases, limited data access can take the simplest algorithms and render them impossible to implement.  Consider the example discussed in [TRIGGERS CHAPTER REFERENCE] of automating the wrapping of a text field with a properly sized rounded rectangle.  The algorithm to automate this task is trivial when stated in terms of the text field's and the rounded rectangle's properties of location, length and width.  The central part of the algorithm is to set the rounded rectangle's location a bit above and to the left of the text field's location, and set the rounded rectangle's length and width to be a bit larger.  Automating this task independently of MacDraw II would involve extracting these properties from MacDraw II's coded file format, which would be very difficult.  Also, the user's algorithm may be based on special functionality provided by the application such as, in this case, the ability to create rounded rectangles.  Just-in-time programming systems should therefore be able to access properties from applications and invoke the operators provided by applications.\nSometimes an opportunity for new beneficial automation involves not so much the processing of data, but rather the repetitive manipulation of an application's user interface artifacts.  For example, the user may wish to automate the toggling between two window arrangements.  The only way a programming system can automate this is to access the state of the user interface and manipulate its components.\nDiscussion  Inaccessible data and operators is a particularly common obstacle for just-in-time programming because users must make do with whatever form their data is in when they envision the algorithm.  Usually this data exists within an application.  In contrast, task-time independent programming often allows the user to plan what form the data will be in when the automation is eventually used.  Many programming efforts, like games or educational software, are closed systems where the programmer can choose the format of the data to be whatever makes their programming effort easiest.\nSolution directions  In order for a programming system to access the data and operators of an application, there must be a communication protocol that both the programming system and the application follow.  One way to effect this protocol is to build the programming system into the application.  This strategy, however, limits the data access to the one application, so inaccessible data and operators would still be an obstacle when the user's algorithm involved multiple applications.  Therefore just-in-time programming systems should make use of specially established interapplication protocols like Apple Events [Apple 91].\nSometimes programming systems can overcome the inaccessible data and operators obstacle by using protocols established for reasons other than interapplication communication.  For example, the Quickeys solution uses the computer's keyboard input stream as a protocol to process data in the editor application.  The Triggers chapter discusses an extension to this technique where pixel data from the computer display can be used to gain a significant degree data access from any application.  PBD plays a large role in making this extension possible because the algorithms implemented using these techniques sometimes contain large bitmap constants.  Entering these bitmaps would be unwieldy if they could not be specified by demonstration.\nRisk\nThe fifth obstacle is the risk that the automation will fail, be ineffective, or produce unintended results.  Consider the risks of automating the line transformation subtask.  There are many possible scenarios.  In the best case the algorithm could have been entered almost effortlessly, and as each occurrence of a line needing the simple transformation was flagged by the compiler, I could have easily invoked the algorithm somehow.  To my surprise, perhaps more chances to use the new automation occurred than were anticipated, making the automation pay off more than expected.\nBut there are many other possible scenarios.  The algorithm could have taken a long time to enter, perhaps because some special purpose function had to be looked up in a manual.  A mistake in the implementation might have caused the new (not beneficial) automation to destroy part of the source file, perhaps too quickly to be noticed.  Limited data access could have turned the simple algorithm into one that was impossible to implement.  I was not sure exactly how many more assignments of 32-bit rectangles to 16-bit rectangles were left in my software project, and thus there may have been too few to make the programming effort worthwhile.  Unforeseen special cases may have made the envisioned algorithm simply wrong.\nA user who is considering a just-in-time programming effort has the option of continuing to work manually.  Given the many adverse scenarios, it is not surprising that the user would choose this option.  Thus just-in-time programming systems often fail because the user chooses not to use it.\nRisk was the main reason I chose not to automate the line transformation subtask.  The partial solution using keyboard macros was the only one worth considering because it was the only solution that did not require saving the file to disk.  In the past, my attempts to use keyboard macros have often been thwarted by unforeseen special cases, the difficulty of accommodating special cases into an already existing macro, and the uncontrollable speed of macros that make it difficult to verify that the macro works correctly.  In retrospect, a keyboard macro would have been worthwhile and would have prevented a few recompiles caused by typos in my manual transforming of the lines.  However at the time, the apparent risks convinced me to play it safe and transform the lines manually.\nDiscussion  Certainly all programming involves risk.  The risks of just-in-time programming are notable on two accounts.  One is that the time and effort spent implementing the algorithm relate directly to the success of the venture.  For example, any extra time or frustration involved in automating the line transformation subtask would have quickly eliminated the potential benefits.  In contrast, task-time independent programming efforts often relate only indirectly to success.  For example, say a user is programming an animated demo for a five-minute presentation.  If the demo take two hours longer to implement than expected, the presentation the next day can still be a success.\nBut the main reason risk affects just-in-time programming so strongly is that it is easy for users to choose to continue to work manually and avoid the risk.  In contrast, essential programming requires users to make the best of what their programming systems have to offer.  Users still have to assume whatever risks are present, but the programming system will not fail for lack of use.\nRisk is caused, in part, by the users' uncertainty about how the other four obstacles will affect their attempts to automate.  Thus, one way to reduce the risk is to work towards eliminating these four obstacles.  For example, if entering the algorithm were effortless, there would be no risk in taking that step.  Unfortunately, entirely eliminating these obstacles is very unlikely.  In addition, users will still have to assume the risk that their algorithms might not do as expected.  Thus, it is important to explicitly consider techniques that reduce the risks of just-in-time programming.\nSolution directions  One approach to addressing risk is to make it so that the user can accurately judge the effort required to implement the algorithm and accurately judge the benefits.  Simplicity and visibility are two attributes of a programming system that would contribute to this approach.  When users can confidently judge the benefits will be greater then the efforts, then they can proceed to profit from using the just-in-time programming system and the system will not fail from lack of use.  The limitation of this approach is that merely judging the risks is a risk in itself because the user must expend some mental effort.  Because it is unlikely that this effort can be eliminated entirely, the user will have good reason to simply continue working the task manually without ever giving the opportunity to use just-in-time programming a second thought.  Other techniques need to be considered.\nAnother approach to reducing risk is to enable users to profit from partial implementations of their algorithms.  This would help alleviate the risk that an obstacle might prevent the implementing of part of the algorithm, render the whole algorithm useless, and waste any effort already expended.  Users should be able to implement and profit from parts of their algorithms without requiring the entire algorithm to work flawlessly.\nFor example, assume a user has 20 book chapters saved as a separate MacWrite II files in a folder, and that a colleague requests a pure ASCII copy of each chapter.  To manually convert each chapter to pure ASCII, the user would have to load its file into the MacWrite II, select the Text Only option, and save it back out to disk using a different file name.  Assume files with the word \"backup\" in the file name should not be converted.  The simple algorithm in figure 5 could select all 20 chapters in turn and carry out these repetitive actions.  If the user were able to implement this algorithm, the tedium of keeping track of which files have been converted and the tedium of the repetitive actions would be avoided.\nFigure 5:  An algorithm that will convert a folder full of MacWrite II files to pure ASCII.\n\nIf the entire algorithm could be implemented confidently, easily, and flawlessly, then risk would not be an issue.  Unfortunately, any step in the algorithm could cause potential problems.  What if after putting some effort into the algorithm, the user discovers that only a subset of the nine steps can be implemented?  For example, what if step number 7 could not be implemented because the user's programming system could not invoke the operator that selects the Text Only operator?  The partial implementation can still potentially be beneficial if the user can manually do the steps that prove difficult to implement.  For example, the algorithm could invoke the \"Save As...\" dialog box and pause while the user selects Text Only manually.  The partial implementation would still be beneficial because it would take care of the tedium of keeping track of which files have been converted and a great majority of the other actions.\nFor step number 7, this strategy is easy to imagine because the application's existing user interface can allow the user to carry out the hard to implement action manually.  But what if step number 2 is too difficult to implement because the user's programming system has no built-in test for substrings?  In this case the list is in the programming system's execution environment, not the application.  If the user is to manually accomplish this step, the programming system must have an existing user interface that allows the user to manipulate the execution environment.  Some interactive programming systems and debuggers allow users to modify the execution environment during run-time, but few allow data to be manipulated easily enough for the user to do real work.  Also, the more that control has to pass between the user and their implementation, the more essential it will be that flexible invocation schemes are possible.\nEssentially the user's risk is that the manual method might be more effective than implementing the algorithm.  Therefore, another approach to addressing risk is to allow the user to pursue both alternatives in parallel.  In theory, the risk of attempting to automate the subtask would be eliminated because if unforeseen difficulties make the programming effort ineffective, then the user can fall back on the manual method already underway.\nIn practice, this approach would probably not eliminate risk, but it could reduce risk greatly.  PBD could play a large part in realizing this approach because it allows the user to implement algorithms by demonstrating on their actual task data.  In other words, the user can be programming and manually accomplishing the subtask simultaneously.  For example, recording the keyboard in figure 4 actually transforms one of the lines, so progress towards completing the overall task is hindered minimally.\nThis technique has its greatest potential when mixed with history based techniques.  For example, Allen Cypher's system Eager records the user's actions into an event history [EAGER CHAPTER].  When Eager detects the user doing repetitive actions, it indicates this to the user by highlighting what it expects the user to select next.  For certain classes of algorithms, the user can implement an algorithm at almost no risk because the user takes no special actions.  The decision of whether to invoke the algorithm still involves some risk because the exact behavior of some algorithms is difficult to predict.  Therefore additional techniques such as undo and slow motion execution will have to be extended and refined.\n\nConclusion\nIs creating a programming system that is effective for just-in-time programming an interesting research problem? The previous sections clearly show that it has not been solved already, so it meets this criterion.  A second criterion for interesting research is that there be some indication that solutions are possible.  The previous section touched on several promising research directions, many of which are based on PBD.  A third, important criterion for interesting research is that it lead to tangible benefits.  The benefits of improved just-in-time programming systems would be to allow users to better automate repetitive subtasks that arise from their unique circumstances.  The line transformation subtask was one such example where automation would have led to significant benefit.  There will always be subtasks like this that slip through the prepackaged functionality of applications because they result from the interactions of users with the complexities of the real world.  Task-time is often the only possible time to implement the algorithms that can automate these subtasks.\nBut is it necessary to focus the research problem on such a narrow slice of programming to make automating these subtasks practical?  After all, many of the obstacles facing just-in-time programming also affect other types of programming;  it is possible that researching other types of programming will produce effective just-in-time programming systems as a side effect.  Are there reasons for researching just-in-time programming specifically?\nOne reason is that a user must accomplish all of the following during task-time: assess risk, enter the algorithm, design the invocation scheme, solve data access problems, invoke the algorithm, verify correct program behavior, and resume work on the overlying task.  Thus it is crucial that techniques that support these activities be refined to a degree that other forms of research are unlikely to achieve.  For example, research that concentrates on programming-in-the-large is unlikely to adequately reduce the effort required to input the algorithm when managing program complexity is its overriding concern.  Research that assumes essential programming is unlikely consider techniques that reduce risk by enabling productive use of partially debugged programs.  Research that assumes task-time independent programming is unlikely to recognize that programming may not be the user's primary concern.  Thus it is unlikely to give adequate emphasis to minimizing distractions from the user's primary task.  It is also unlikely to motivate data and operator access that is flexible enough to process the user's data wherever it may be when the opportunity to apply just-in-time programming arises.\nAnother reason is there are solutions that are appropriate for just-in-time programming but are not necessarily appropriate for other types of programming.  For example, the pixel based techniques of Triggers [TRIGGERS CHAPTER] would not be appropriate for software that must run in the background.  The technique of programming and accomplishing the task at the same time discussed in the risk section does not make sense for programmers who are writing software for other people's use.\nBy recognizing the special nature of just-in-time programming and by addressing the limitations of current programming systems head-on, much research progress should result.  The five obstacles provide a set of subproblems that can be used to focus multiple avenues of research.  Researchers should be careful not to accentuate one obstacle in the elimination of another; it only takes one to prevent a just-in-time programming system from being effective.  It is crucial that a just-in-time programming system address risk because it is probably impossible to create a programming system where the user's every attempt at creating new automation will be profitable.  The goal should be to create a programming system where a user can know that in the worse case attempting just-in-time programming will not hinder progress towards completing the task.  Then the user will be able to confidently use the full extent of the programming system to profit from their algorithmic insights.\n\nReferences for Alan\n\n[Apple 91] Apple Computer, Inc., <Inside Macintosh, Volume VI> Addison Wesley, Reading, Massachusetts, 1991.\n\n[Cypher 86] Cypher A., \"The Structure of Users' Activities,\" <User Centered Design>, Lawrence Erlbaum Associates, Hillsdale, New Jersey, 1986.\n\n[Halbert 84] Halbert D., \"Programming by Example,\" Ph.D. Thesis, Department of Computer Science, University of California at Berkeley , 1984.\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Just In Time Programming",
        "story": []
      },
      "date": 1641328808762,
      "error": {
        "type": "error",
        "msg": "Conflict",
        "response": "Page already exists."
      }
    },
    {
      "type": "fork",
      "date": 1641328837636
    },
    {
      "item": {
        "type": "factory",
        "id": "5be405ab12de44d0"
      },
      "id": "5be405ab12de44d0",
      "type": "add",
      "date": 1641328904944
    },
    {
      "type": "edit",
      "id": "5be405ab12de44d0",
      "item": {
        "type": "paragraph",
        "id": "5be405ab12de44d0",
        "text": "Just-in-Time Programming\n\nby \nRichard Potter \nHuman Computer Interaction Lab \nUniversity of Maryland "
      },
      "date": 1641328917891
    },
    {
      "type": "add",
      "id": "3c894e6be1a053b1",
      "item": {
        "type": "paragraph",
        "id": "3c894e6be1a053b1",
        "text": "[http://web.media.mit.edu/~lieber/Teaching/Context/Potter.rtf rtf]"
      },
      "after": "5be405ab12de44d0",
      "date": 1641328944227
    },
    {
      "item": {
        "type": "factory",
        "id": "26fe073b834e8522"
      },
      "id": "26fe073b834e8522",
      "type": "add",
      "after": "3c894e6be1a053b1",
      "date": 1641328963121
    },
    {
      "type": "edit",
      "id": "26fe073b834e8522",
      "item": {
        "type": "paragraph",
        "id": "26fe073b834e8522",
        "text": "Introduction\nMany of the other chapters have presented advancements in programming by demonstration by presenting PBD systems and their innovations.  In other words, these chapters have presented solutions.  This chapter takes another tact by discussing PBD in the context of a problem.  The problem is to create a programming system that is effective for just-in-time programming.  This chapter defines just-in-time programming, explains how it relates to other forms of programming, and explores how creating effective just-in-time programming systems motivates PBD research.\nJust-in-time programming is the implementing of algorithms during task-time (i.e. the time when the user is actually trying to accomplish the task to be automated) and can be characterized by a situation with the following components:\n a computer user who could be either a novice user or an experienced programmer,\n a task that the user is manually accomplishing and completion of which is the user's primary goal,\n an algorithm that will accomplish a subtask (i.e. part of the task) and that the user envisioned while working on the task,\n and an attempt by the user to implement the algorithm for the purpose of more effectively completing the task.\nIn short, the goal of just-in-time programming is to allow users to profit from their task-time algorithmic insights by programming.  Instead of automating with software that was carefully designed and implemented much earlier, the user recognizes an algorithm and then creates the software to take advantage of it just before it is needed, hence implementing it just in time.\nIt is worth emphasizing that the user's task could be from any domain (e.g. graphic drawing, scientific visualization, word processing, etc.) and that the algorithm to be implemented originates with the user.  Obviously, a user with more programming experience will be able to envision a more complex algorithm than a novice user.  How the user comes up with the algorithm is not a concern.  Also, no hint of a solution appears in the problem statement.  Any programming system could conceivably be used for just-in-time programming, including C, PASCAL, keyboard macros, scripting languages, or PBD. PBD will probably be an important part of the more successful just-in-time programming systems, but the problem statement leaves open the possibility for other solutions.\nJust-in-time programming research shares many of the motivations of other PBD research.  Chief among these is that users often do repetitive or algorithmic subtasks that the computer could be doing.  We call these subtasks potential computer subtasks and call these situations opportunities for new beneficial automation.  Because automating can increase productivity and user satisfaction and at the same time reduce errors, one would expect the user to delegate potential computer subtasks to the computer.  That users often do not take advantage of these opportunities motivates researching ways to improve the computer.  Just-in-time programming research and PBD research assert that easier to use programming tools will allow users to better take advantage of opportunities for new beneficial automation.\nJust-in-time programming research, however, is focused on making programming easier for a specific cross section of situations.  These situations are primarily defined by the user programming during task-time.  In other words, the user is attempting to write a program for a task that is already in progress.  Figure 1 summarizes the relationship between task progress and the user's expenditure of effort.  The expenditure of effort for just-in-time programming is shown separate from the other task related effort.  The difficulty of just-in-time programming results from the spreading of the user's mental resources between two activities.  Another difficulty is that the time spent programming contributes directly to total time between the start and completion of the task.\nFigure 1:  Just-in-time programming intermixes programming effort with other task related effort.\n\n\nWhat is not Just-in-time Programming?\nOne might contrast just-in-time programming with, for lack of a better term, task-time independent programming which is summarized in figure 2.  For an example, consider a user who is programming a HyperCard mock-up of a user interface in preparation for a demonstration the next day.  The subtask of the software is to help an audience visualize a proposed user interface design during the meeting.  This example would be task-time independent programming because the software is created well before the meeting.  As is the case with many distinctions, there are examples that straddle the line between just-in-time programming and task-time independent programming, but the discussions that follow should hold regardless.\nFigure 2:  Task-time independent programming separates programming effort from other task-related effort.\n\nJust-in-time programming can be contrasted with other forms of programming by considering implications of the situation characterized in the introduction.  For example, since the algorithm to be implemented is the product of the user's insight, it is typically simple.  Thus one could contrast just-in-time programming with programming-in-the-large.  For an example, developing a full featured word processor would not be just-in-time programming because an algorithm that implements all the features of a word processor is too complex for one person to envision.\nAnother implication of the situation characterized in the introduction is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\nHow does just-in-time programming relate to the more common PBD application of programming for novice programmers? These two types of programming are basically independent;  programming in a given situation could represent both, one, or neither of these.  A novice programmer writing a short program that changes all numbers in a document to a larger font would be an example of both types of programming, assuming the user was about to make the modifications by hand.  A novice programmer writing educational software to be used by students at a later time would be an example of a novice programmer programming, but not just-in-time programming.  I recently modified a postscript file to only print out the even pages of the document and then the odd pages so that it would print on both sides of the paper without requiring me to issue a separate print command for each page.  This would be an example of just-in-time programming that was not programming for the novice.\n\nA Subtask Suitable for Just-in-Time Programming\nI happened upon an opportunity for just-in-time programming when Think C updated their class library to version 1.1.  Before version 1.1, rectangles were defined with 16-bit coordinates and in version 1.1 rectangles were defined by 32-bit coordinates.  When I first compiled my software project with the new class library, type mismatch errors occurred where my software expected 16-bit values.  Many of these were simple assignment statements.  The new class library included a utility function for converting 32-bit rectangles to 16-bit rectangles, so a typical fix involved changing a line of the form *inset=frame; to the form longToQDRect(&frame,inset);. Various other types of errors were found and fixed as well.  The second time an assignment of a 32-bit rectangle to a 16-bit rectangle caused an error, I recalled that there were many such assignments throughout my program and concluded I would, in time, be transforming many lines from assignment statements into function calls. Each would differ only in the names of the variables and whether each variable was a pointer or not (i.e. preceded by a \"*\").  For the rest of this paper, transforming one of these lines will be called the line transformation subtask.\nTo attempt to automate this subtask would have been just-in-time programming because of the situation.  This particular example also contrasts well with the other types of programming discussed above.  It would certainly not be task-time independent programming because I was in the midst of modifying my software project.  The subtask was algorithmically simple so it was not programming-in-the-large.  Automating the subtask was not essential, so it was not essential programming.\nSo to break this situation down into the components of just-in-time programming:\nThe user: \nmyself\nThe task: \nmodifying a software project to work with an updated class library\nThe subtask: \nchanging certain lines of source code from the form {*}var1 = {*}var2; to the form longToQDRect({&}var2,{&}var1); (i.e. the line transformation subtask)\nThe algorithm: \ninsert leading white space\ninsert \"longToQDRect(\"\nif second variable name is not preceded by \"*\", insert \"&\"\ninsert second variable name\ninsert \",\"\nif first variable name is not preceded by \"*\", insert \"&\"\ninsert first variable name\ninsert \")\"\ninsert rest of line (the \";\" and comments, if any)\ndelete original line.\nThe attempt to automate:  \nActually I did not try to automate the subtask.  The rest of the chapter will explain why.\n\nFive Obstacles\nOne reason to explicitly state a problem is so that it can be broken down into meaningful subproblems.  One way to do this is to analyze current technology, identify common obstacles that prevent the technology from being effective, and let the subproblems be to find ways to eliminate these obstacles.  The following sections discuss five obstacles that often prevent users of current programming systems from profiting from their algorithmic insights.  Each section also discusses PBD's potential role in solving the subproblem represented by each obstacle.\n\t\nFigure 3:  A C algorithm that automates the line transformation subtask assuming the line has been isolated in a character buffer.\n\nEffort of entering the algorithm\nGiven that I understood the algorithmic structure of the line transformation subtask, why not automate it?  Since I was actually using a C programming system, let's first explore the possibility of using it.  Figure 3 shows a program in C that can transform the line as needed, assuming that the line has been loaded into a string (we will deal with this assumption more later).  One obstacle quickly becomes apparent: the effort of entering the algorithm.  Merely the physical effort of typing in the 749 characters of this program would likely undermine the benefits of automating this small part of the task.  But there is also the mental effort required to translate the algorithm into the idioms of the language and to work out the fine details.  For example, after years of programming in C, I still must look up the strcat function in the manual to see if it copies from the first argument to the second or vice versa.\nDiscussion  No matter what type of programming is being done, reducing this effort is desirable.  However, the effort of entering an algorithm is particularly important for just-in-time programming because the subtasks appropriate for just-in-time programming are typically special purpose needs that can not be as widely applied as functionality that is more generic.  The line transformation task is a good example of this because once I finished updating the software project, I had no need for this particular functionality.  When the benefits per programming effort are modest, only minimal effort can be expended towards entering the algorithm before the venture becomes pointless.  If the user's task is creative or involves problem solving, then the user can scarcely afford to expend mental effort for modest gains.  Of course, there are times when the payoffs of just-in-time programming are large enough that the effort to enter the algorithm is not as crucial.  But there are enough opportunities for modest payoffs that finding ways to reduce the effort required to enter the algorithm is an important subproblem to solve.\nSometimes creating new beneficial automation by programming pays off because the user can apply the automation many times in the future.  A script that automatically dials a remote computer and logs the user into their account would be a good example.  Here the distinction between just-in-time programming and task-time independent programming is blurred.  Strictly speaking, the programming effort is expended at a time independent of when the benefits of the automation are received.  However, the user is likely to automate this task at a time when they are about to dial in to the remote computer manually, that is, when the desirability of automating the subtask comes to mind.  So although the user could set aside some time and do task-time independent programming, psychologically the task-time aspects of whatever the user is doing are likely to impact the programming process.  In this sense, much of the special concerns of just-in-time programming still hold.\nReducing this effort is less important for programming-in-the-large because the effort required to manage the complexity of a large software project tends to overshadow the effort required to enter the algorithm.  In fact, programming languages such as Ada even increase the effort of entering the algorithm by requiring extra notation for modularizing the code.  Such notation does not contribute directly to functionality, but is appropriate for programming-in-the-large because complexity is such an overriding concern.\nJust-in-time programming accentuates the mental effort required to enter the algorithm because users must switch their mind-sets from the task domain to the programming domain as illustrated in figure 1.  After the algorithm has been implemented, users must also expend effort to return their mind-sets to the task domain.  Users might expend effort trying not to divert too much attention to the programming effort, sometimes trying to keep more in their short term memory than is reasonable.  For creative tasks, this diversion is especially costly.  In contrast, users who are programming independently of task time can change their mind-set over a longer period of time.\nTherefore when minimizing the effort of entering the algorithm, it is important to minimize distraction from the task.  One of the main sources of effort and distraction is the number of special programming concepts.  For example, writing the C algorithm in figure 3 required remembering how strings are allocated and referenced.  On this point, just-in-time programming and programming for novice programmers share similar goals because a programming system for novice programmers should require the understanding of as few new concepts as possible.  In cases where a just-in-time programming system is being designed specifically for novice programmers, the same would apply.\nThe idea of just-in-time programming, however, is not limited to novice programmers.  For expert programmers, whether a concept is familiar to a nonprogrammer is not the crucial factor.  Instead, the programming system should require the user to understand only concepts that can be ingrained and that the user can apply fluently.  Therefore, part of the research agenda of just-in-time programming should be to identify key skills that, if ingrained, will allow a user to more effectively write programs just in time.  These skills could be anything from something classic like regular expressions to some new esoteric programming paradigm.  It seems clear that, at least for the foreseeable future, users will have to understand the basic concepts of conditionals and iteration.\nSolution directions  Many techniques including code templates, code reuse, domain specific functionality, subroutines, copy/paste, and on-line documentation can help reduce the effort required to enter an algorithm.  PBD helps reduce this effort by allowing users to enter the algorithm using the same interface as they would normally use to work the subtask manually.  This helps reduce both the physical effort and the mental effort because the user is often well practiced at using this interface.  Since the user would use the same user interface to work the subtask manually, the artifacts are already in short term memory and programming with them is likely to be less distracting than with an off-line programming language.  The effort to enter the algorithm is also reduced because user interfaces are usually optimized to the task.\nFigure 4:  This Quickeys macro can partially automate the line transformation subtask.  The number of keystrokes required to enter the macro and the visual state of the editor are shown.\n\nFor a simple example of how PBD can reduce the effort of entering an algorithm, consider one partial solution to the line transformation subtask.  If the user first places the cursor to the left of the first variable in the line to be transformed and neither variable is a pointer, then the Quickeys macro shown in figure 4 will transform the line as required.  The macro also assumes that exactly three characters (\" = \") separate the two variable names.  Only the 33 keypresses shown in figure 4 are required to implement the macro.  The visual feedback of the editor also helps reduce the mental effort by showing intermediate results.\nLimited computational generality\nWhy illustrate the virtues of the keyboard macro by only partially automating the line transformation subtask?  The reason is that the subtask requires conditional logic to decide whether each variable is a pointer or not.  Keyboard macros only record straight-line algorithms and thus are not able to fully automate this subtask.  This illustrates an obstacle that users face when programming just in time:  the programming systems that make it easy to enter their algorithm can often only implement algorithms of limited computational generality.\nDiscussion  It is important for a just-in-time programming system to have full Turing-complete computational generality because there is no way to predict which of the vast array of algorithms the user might envision.  Unfortunately computational generality is not one of PBD's strengths.  Halbert recognized this when implementing SmallStar and concluded that control structures were better created by editing a static representation of the program than by demonstration [Halbert 84].  Others have used inference to generalize straight-line demonstrations into procedures with control structures.  Cypher's Eager and Myers' Peridot used domain knowledge to infer procedures with control structures solely from straight-line demonstrations [EAGER CHAPTER, PERIDOT CHAPTER].  The computational generality of these systems, however, was limited by limited domain knowledge.\nSolution directions  In order for a PBD to be used for just-in-time programming, it will have to be integrated with other techniques to give full computational generality.  Interesting directions include giving separate examples for each path of the algorithm as in Tinker [TINKER CHAPTER], or a combination of multiple demonstrations, inferencing, and special instructions from the user as in Metamouse [METAMOUSE CHAPTER].\nEffort of invoking algorithm\nAs stated previously, the effort to enter an algorithm is less of an obstacle when the benefits of automating are large.  So for the sake of argument, assume that I knew there would be hundreds of lines needing to be transformed and decided to automate the task using C.  Limited computational generality would not be an obstacle with C.  Are there other obstacles?\nWhen the compiler detected an error in my software project, it would load the file containing the error into its text editor and highlight the erroneous line.  To take advantage of the line transformation program, I would first have to judge if it was one of the simple type mismatch errors that could be fixed by the simple line transformation.  If so, I would then invoke the C implementation on the specific line.  But how would I do that?  One possibility would be to mark the line some special way, perhaps by placing a \"*\" at the beginning of the line, and then save the file out to disk.  Then I could run the C program which would then prompt me for the name of the file with the incorrect line.  The C program would then scan through the file for a line that started with a \"*\" and apply the transformation to it.  But this would be silly.  The effort to invoke the algorithm would undermine the benefits and would be yet another obstacle to automating this subtask.\nDiscussion  As in this case, a subtask appropriate for just-in-time programming typically applies to part of a larger document.  Thus, users must be able to implement the algorithm such that they can specify which part of the document should be processed when they invoke the algorithm.  It is important that they be able to do this with ease because the benefits to be obtained by automating can be easily negated by the invocation effort.  Unlike the effort to enter the algorithm, the effort to invoke the algorithm can not be amortized over the life of the new beneficial automation.  The effort must be small in comparison with the benefit received from each invocation of the algorithm.  When the payoffs per invocation are larger this obstacle is not as crucial, but enough opportunities for modest benefits exist that it is important to reduce the effort required to invoke algorithms implemented just in time.\nFor an example of how crucial the ease of invocation can be towards making automation beneficial, consider the feature on many word processors that allows a user to select a word simply by double clicking on it.  The word processor automatically does the tedious subtask of extending the selection out to the word boundaries.  Identifying these word boundaries manually is a simple subtask, so not much benefit is received each time the feature is used.  However, words are selected so commonly that, over time, the feature is very beneficial.  Another invocation strategy could easily undermine this benefit.  For example, even requiring the user to click on the word and then select the feature from a pull down menu could require too much effort.\nAs the previous example implies, this obstacle is not unique to just-in-time programming.  Because the effort to invoke the algorithm can not be amortized, any programming endeavor that produces interactive software needs to pay special attention to this obstacle.  The main difference for just-in-time programming is that the user can not amortize the effort to create the invocation scheme as much.\nSolution directions  How should just-in-time programming make it easy to invoke algorithms?  One clue is strongly implied by the hypothetical consideration of C for automating the line transformation subtask:  users should be able to implement their algorithms such that they can perform the subtask without having to save their documents to disk.  Instead their algorithms should be able to process data in its present form which is usually internal to some application.  Thus just-in-time programming systems should allow users to process data within their applications.  In addition, users should be able to use the application's data selection mechanisms to indicate what part of their document to process.  This would enable users to work manually, apply a newly implemented algorithm to the data, and continue to work manually without the overhead of saving the data to a file. Processing data within applications is central to PBD, so it already goes far to easing the effort to invoke the algorithm.\nBeyond automating within applications, just-in-time programming systems should allow the user to choose among various invocation strategies.  Standard invocations such as menu selections and keypresses should be supported.  The ability to create more refined invocations, like double clicking on a an object to apply some automation to it, would be important for making some highly interactive automation worth creating.  PBD techniques could possibly be used to have the fact that the user has started doing the subtask be what triggers the automation to be invoked.  David Maulsby's Turvy and Metamouse give hints of how this might work [TURVY CHAPTER, METAMOUSE CHAPTER].\nInaccessible data and operators\nSo far we have seen several reasons to want to process data while it resides within an application.  One is to make algorithms easier to enter by allowing the user to demonstration the algorithm through the user interface of the application.  Another is that invocations can be made easier if the data is processed within the application.  The Quickeys solution in figure 4 had these advantages, but it only partially automated the subtask.  No other programming system on my computer (including APL, C, Lisp, Scheme, or HyperTalk) can automate within Think C's editor because of the fourth obstacle, inaccessible data and operators.  In this case, this obstacle undermines the modest benefits of automating the subtask.  If the benefits per invocation were greater, then accessing the data independently of the application by saving the document to a file might have made creating the new automation worthwhile.\nIn other cases, limited data access can take the simplest algorithms and render them impossible to implement.  Consider the example discussed in [TRIGGERS CHAPTER REFERENCE] of automating the wrapping of a text field with a properly sized rounded rectangle.  The algorithm to automate this task is trivial when stated in terms of the text field's and the rounded rectangle's properties of location, length and width.  The central part of the algorithm is to set the rounded rectangle's location a bit above and to the left of the text field's location, and set the rounded rectangle's length and width to be a bit larger.  Automating this task independently of MacDraw II would involve extracting these properties from MacDraw II's coded file format, which would be very difficult.  Also, the user's algorithm may be based on special functionality provided by the application such as, in this case, the ability to create rounded rectangles.  Just-in-time programming systems should therefore be able to access properties from applications and invoke the operators provided by applications.\nSometimes an opportunity for new beneficial automation involves not so much the processing of data, but rather the repetitive manipulation of an application's user interface artifacts.  For example, the user may wish to automate the toggling between two window arrangements.  The only way a programming system can automate this is to access the state of the user interface and manipulate its components.\nDiscussion  Inaccessible data and operators is a particularly common obstacle for just-in-time programming because users must make do with whatever form their data is in when they envision the algorithm.  Usually this data exists within an application.  In contrast, task-time independent programming often allows the user to plan what form the data will be in when the automation is eventually used.  Many programming efforts, like games or educational software, are closed systems where the programmer can choose the format of the data to be whatever makes their programming effort easiest.\nSolution directions  In order for a programming system to access the data and operators of an application, there must be a communication protocol that both the programming system and the application follow.  One way to effect this protocol is to build the programming system into the application.  This strategy, however, limits the data access to the one application, so inaccessible data and operators would still be an obstacle when the user's algorithm involved multiple applications.  Therefore just-in-time programming systems should make use of specially established interapplication protocols like Apple Events [Apple 91].\nSometimes programming systems can overcome the inaccessible data and operators obstacle by using protocols established for reasons other than interapplication communication.  For example, the Quickeys solution uses the computer's keyboard input stream as a protocol to process data in the editor application.  The Triggers chapter discusses an extension to this technique where pixel data from the computer display can be used to gain a significant degree data access from any application.  PBD plays a large role in making this extension possible because the algorithms implemented using these techniques sometimes contain large bitmap constants.  Entering these bitmaps would be unwieldy if they could not be specified by demonstration.\nRisk\nThe fifth obstacle is the risk that the automation will fail, be ineffective, or produce unintended results.  Consider the risks of automating the line transformation subtask.  There are many possible scenarios.  In the best case the algorithm could have been entered almost effortlessly, and as each occurrence of a line needing the simple transformation was flagged by the compiler, I could have easily invoked the algorithm somehow.  To my surprise, perhaps more chances to use the new automation occurred than were anticipated, making the automation pay off more than expected.\nBut there are many other possible scenarios.  The algorithm could have taken a long time to enter, perhaps because some special purpose function had to be looked up in a manual.  A mistake in the implementation might have caused the new (not beneficial) automation to destroy part of the source file, perhaps too quickly to be noticed.  Limited data access could have turned the simple algorithm into one that was impossible to implement.  I was not sure exactly how many more assignments of 32-bit rectangles to 16-bit rectangles were left in my software project, and thus there may have been too few to make the programming effort worthwhile.  Unforeseen special cases may have made the envisioned algorithm simply wrong.\nA user who is considering a just-in-time programming effort has the option of continuing to work manually.  Given the many adverse scenarios, it is not surprising that the user would choose this option.  Thus just-in-time programming systems often fail because the user chooses not to use it.\nRisk was the main reason I chose not to automate the line transformation subtask.  The partial solution using keyboard macros was the only one worth considering because it was the only solution that did not require saving the file to disk.  In the past, my attempts to use keyboard macros have often been thwarted by unforeseen special cases, the difficulty of accommodating special cases into an already existing macro, and the uncontrollable speed of macros that make it difficult to verify that the macro works correctly.  In retrospect, a keyboard macro would have been worthwhile and would have prevented a few recompiles caused by typos in my manual transforming of the lines.  However at the time, the apparent risks convinced me to play it safe and transform the lines manually.\nDiscussion  Certainly all programming involves risk.  The risks of just-in-time programming are notable on two accounts.  One is that the time and effort spent implementing the algorithm relate directly to the success of the venture.  For example, any extra time or frustration involved in automating the line transformation subtask would have quickly eliminated the potential benefits.  In contrast, task-time independent programming efforts often relate only indirectly to success.  For example, say a user is programming an animated demo for a five-minute presentation.  If the demo take two hours longer to implement than expected, the presentation the next day can still be a success.\nBut the main reason risk affects just-in-time programming so strongly is that it is easy for users to choose to continue to work manually and avoid the risk.  In contrast, essential programming requires users to make the best of what their programming systems have to offer.  Users still have to assume whatever risks are present, but the programming system will not fail for lack of use.\nRisk is caused, in part, by the users' uncertainty about how the other four obstacles will affect their attempts to automate.  Thus, one way to reduce the risk is to work towards eliminating these four obstacles.  For example, if entering the algorithm were effortless, there would be no risk in taking that step.  Unfortunately, entirely eliminating these obstacles is very unlikely.  In addition, users will still have to assume the risk that their algorithms might not do as expected.  Thus, it is important to explicitly consider techniques that reduce the risks of just-in-time programming.\nSolution directions  One approach to addressing risk is to make it so that the user can accurately judge the effort required to implement the algorithm and accurately judge the benefits.  Simplicity and visibility are two attributes of a programming system that would contribute to this approach.  When users can confidently judge the benefits will be greater then the efforts, then they can proceed to profit from using the just-in-time programming system and the system will not fail from lack of use.  The limitation of this approach is that merely judging the risks is a risk in itself because the user must expend some mental effort.  Because it is unlikely that this effort can be eliminated entirely, the user will have good reason to simply continue working the task manually without ever giving the opportunity to use just-in-time programming a second thought.  Other techniques need to be considered.\nAnother approach to reducing risk is to enable users to profit from partial implementations of their algorithms.  This would help alleviate the risk that an obstacle might prevent the implementing of part of the algorithm, render the whole algorithm useless, and waste any effort already expended.  Users should be able to implement and profit from parts of their algorithms without requiring the entire algorithm to work flawlessly.\nFor example, assume a user has 20 book chapters saved as a separate MacWrite II files in a folder, and that a colleague requests a pure ASCII copy of each chapter.  To manually convert each chapter to pure ASCII, the user would have to load its file into the MacWrite II, select the Text Only option, and save it back out to disk using a different file name.  Assume files with the word \"backup\" in the file name should not be converted.  The simple algorithm in figure 5 could select all 20 chapters in turn and carry out these repetitive actions.  If the user were able to implement this algorithm, the tedium of keeping track of which files have been converted and the tedium of the repetitive actions would be avoided.\nFigure 5:  An algorithm that will convert a folder full of MacWrite II files to pure ASCII.\n\nIf the entire algorithm could be implemented confidently, easily, and flawlessly, then risk would not be an issue.  Unfortunately, any step in the algorithm could cause potential problems.  What if after putting some effort into the algorithm, the user discovers that only a subset of the nine steps can be implemented?  For example, what if step number 7 could not be implemented because the user's programming system could not invoke the operator that selects the Text Only operator?  The partial implementation can still potentially be beneficial if the user can manually do the steps that prove difficult to implement.  For example, the algorithm could invoke the \"Save As...\" dialog box and pause while the user selects Text Only manually.  The partial implementation would still be beneficial because it would take care of the tedium of keeping track of which files have been converted and a great majority of the other actions.\nFor step number 7, this strategy is easy to imagine because the application's existing user interface can allow the user to carry out the hard to implement action manually.  But what if step number 2 is too difficult to implement because the user's programming system has no built-in test for substrings?  In this case the list is in the programming system's execution environment, not the application.  If the user is to manually accomplish this step, the programming system must have an existing user interface that allows the user to manipulate the execution environment.  Some interactive programming systems and debuggers allow users to modify the execution environment during run-time, but few allow data to be manipulated easily enough for the user to do real work.  Also, the more that control has to pass between the user and their implementation, the more essential it will be that flexible invocation schemes are possible.\nEssentially the user's risk is that the manual method might be more effective than implementing the algorithm.  Therefore, another approach to addressing risk is to allow the user to pursue both alternatives in parallel.  In theory, the risk of attempting to automate the subtask would be eliminated because if unforeseen difficulties make the programming effort ineffective, then the user can fall back on the manual method already underway.\nIn practice, this approach would probably not eliminate risk, but it could reduce risk greatly.  PBD could play a large part in realizing this approach because it allows the user to implement algorithms by demonstrating on their actual task data.  In other words, the user can be programming and manually accomplishing the subtask simultaneously.  For example, recording the keyboard in figure 4 actually transforms one of the lines, so progress towards completing the overall task is hindered minimally.\nThis technique has its greatest potential when mixed with history based techniques.  For example, Allen Cypher's system Eager records the user's actions into an event history [EAGER CHAPTER].  When Eager detects the user doing repetitive actions, it indicates this to the user by highlighting what it expects the user to select next.  For certain classes of algorithms, the user can implement an algorithm at almost no risk because the user takes no special actions.  The decision of whether to invoke the algorithm still involves some risk because the exact behavior of some algorithms is difficult to predict.  Therefore additional techniques such as undo and slow motion execution will have to be extended and refined.\n\nConclusion\nIs creating a programming system that is effective for just-in-time programming an interesting research problem? The previous sections clearly show that it has not been solved already, so it meets this criterion.  A second criterion for interesting research is that there be some indication that solutions are possible.  The previous section touched on several promising research directions, many of which are based on PBD.  A third, important criterion for interesting research is that it lead to tangible benefits.  The benefits of improved just-in-time programming systems would be to allow users to better automate repetitive subtasks that arise from their unique circumstances.  The line transformation subtask was one such example where automation would have led to significant benefit.  There will always be subtasks like this that slip through the prepackaged functionality of applications because they result from the interactions of users with the complexities of the real world.  Task-time is often the only possible time to implement the algorithms that can automate these subtasks.\nBut is it necessary to focus the research problem on such a narrow slice of programming to make automating these subtasks practical?  After all, many of the obstacles facing just-in-time programming also affect other types of programming;  it is possible that researching other types of programming will produce effective just-in-time programming systems as a side effect.  Are there reasons for researching just-in-time programming specifically?\nOne reason is that a user must accomplish all of the following during task-time: assess risk, enter the algorithm, design the invocation scheme, solve data access problems, invoke the algorithm, verify correct program behavior, and resume work on the overlying task.  Thus it is crucial that techniques that support these activities be refined to a degree that other forms of research are unlikely to achieve.  For example, research that concentrates on programming-in-the-large is unlikely to adequately reduce the effort required to input the algorithm when managing program complexity is its overriding concern.  Research that assumes essential programming is unlikely consider techniques that reduce risk by enabling productive use of partially debugged programs.  Research that assumes task-time independent programming is unlikely to recognize that programming may not be the user's primary concern.  Thus it is unlikely to give adequate emphasis to minimizing distractions from the user's primary task.  It is also unlikely to motivate data and operator access that is flexible enough to process the user's data wherever it may be when the opportunity to apply just-in-time programming arises.\nAnother reason is there are solutions that are appropriate for just-in-time programming but are not necessarily appropriate for other types of programming.  For example, the pixel based techniques of Triggers [TRIGGERS CHAPTER] would not be appropriate for software that must run in the background.  The technique of programming and accomplishing the task at the same time discussed in the risk section does not make sense for programmers who are writing software for other people's use.\nBy recognizing the special nature of just-in-time programming and by addressing the limitations of current programming systems head-on, much research progress should result.  The five obstacles provide a set of subproblems that can be used to focus multiple avenues of research.  Researchers should be careful not to accentuate one obstacle in the elimination of another; it only takes one to prevent a just-in-time programming system from being effective.  It is crucial that a just-in-time programming system address risk because it is probably impossible to create a programming system where the user's every attempt at creating new automation will be profitable.  The goal should be to create a programming system where a user can know that in the worse case attempting just-in-time programming will not hinder progress towards completing the task.  Then the user will be able to confidently use the full extent of the programming system to profit from their algorithmic insights.\n\nReferences for Alan\n\n[Apple 91] Apple Computer, Inc., <Inside Macintosh, Volume VI> Addison Wesley, Reading, Massachusetts, 1991.\n\n[Cypher 86] Cypher A., \"The Structure of Users' Activities,\" <User Centered Design>, Lawrence Erlbaum Associates, Hillsdale, New Jersey, 1986.\n\n[Halbert 84] Halbert D., \"Programming by Example,\" Ph.D. Thesis, Department of Computer Science, University of California at Berkeley , 1984.\n"
      },
      "date": 1641328965053
    },
    {
      "type": "edit",
      "id": "26fe073b834e8522",
      "item": {
        "type": "markdown",
        "id": "26fe073b834e8522",
        "text": "Introduction\nMany of the other chapters have presented advancements in programming by demonstration by presenting PBD systems and their innovations.  In other words, these chapters have presented solutions.  This chapter takes another tact by discussing PBD in the context of a problem.  The problem is to create a programming system that is effective for just-in-time programming.  This chapter defines just-in-time programming, explains how it relates to other forms of programming, and explores how creating effective just-in-time programming systems motivates PBD research.\nJust-in-time programming is the implementing of algorithms during task-time (i.e. the time when the user is actually trying to accomplish the task to be automated) and can be characterized by a situation with the following components:\n a computer user who could be either a novice user or an experienced programmer,\n a task that the user is manually accomplishing and completion of which is the user's primary goal,\n an algorithm that will accomplish a subtask (i.e. part of the task) and that the user envisioned while working on the task,\n and an attempt by the user to implement the algorithm for the purpose of more effectively completing the task.\nIn short, the goal of just-in-time programming is to allow users to profit from their task-time algorithmic insights by programming.  Instead of automating with software that was carefully designed and implemented much earlier, the user recognizes an algorithm and then creates the software to take advantage of it just before it is needed, hence implementing it just in time.\nIt is worth emphasizing that the user's task could be from any domain (e.g. graphic drawing, scientific visualization, word processing, etc.) and that the algorithm to be implemented originates with the user.  Obviously, a user with more programming experience will be able to envision a more complex algorithm than a novice user.  How the user comes up with the algorithm is not a concern.  Also, no hint of a solution appears in the problem statement.  Any programming system could conceivably be used for just-in-time programming, including C, PASCAL, keyboard macros, scripting languages, or PBD. PBD will probably be an important part of the more successful just-in-time programming systems, but the problem statement leaves open the possibility for other solutions.\nJust-in-time programming research shares many of the motivations of other PBD research.  Chief among these is that users often do repetitive or algorithmic subtasks that the computer could be doing.  We call these subtasks potential computer subtasks and call these situations opportunities for new beneficial automation.  Because automating can increase productivity and user satisfaction and at the same time reduce errors, one would expect the user to delegate potential computer subtasks to the computer.  That users often do not take advantage of these opportunities motivates researching ways to improve the computer.  Just-in-time programming research and PBD research assert that easier to use programming tools will allow users to better take advantage of opportunities for new beneficial automation.\nJust-in-time programming research, however, is focused on making programming easier for a specific cross section of situations.  These situations are primarily defined by the user programming during task-time.  In other words, the user is attempting to write a program for a task that is already in progress.  Figure 1 summarizes the relationship between task progress and the user's expenditure of effort.  The expenditure of effort for just-in-time programming is shown separate from the other task related effort.  The difficulty of just-in-time programming results from the spreading of the user's mental resources between two activities.  Another difficulty is that the time spent programming contributes directly to total time between the start and completion of the task.\nFigure 1:  Just-in-time programming intermixes programming effort with other task related effort.\n\n\nWhat is not Just-in-time Programming?\nOne might contrast just-in-time programming with, for lack of a better term, task-time independent programming which is summarized in figure 2.  For an example, consider a user who is programming a HyperCard mock-up of a user interface in preparation for a demonstration the next day.  The subtask of the software is to help an audience visualize a proposed user interface design during the meeting.  This example would be task-time independent programming because the software is created well before the meeting.  As is the case with many distinctions, there are examples that straddle the line between just-in-time programming and task-time independent programming, but the discussions that follow should hold regardless.\nFigure 2:  Task-time independent programming separates programming effort from other task-related effort.\n\nJust-in-time programming can be contrasted with other forms of programming by considering implications of the situation characterized in the introduction.  For example, since the algorithm to be implemented is the product of the user's insight, it is typically simple.  Thus one could contrast just-in-time programming with programming-in-the-large.  For an example, developing a full featured word processor would not be just-in-time programming because an algorithm that implements all the features of a word processor is too complex for one person to envision.\nAnother implication of the situation characterized in the introduction is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\nHow does just-in-time programming relate to the more common PBD application of programming for novice programmers? These two types of programming are basically independent;  programming in a given situation could represent both, one, or neither of these.  A novice programmer writing a short program that changes all numbers in a document to a larger font would be an example of both types of programming, assuming the user was about to make the modifications by hand.  A novice programmer writing educational software to be used by students at a later time would be an example of a novice programmer programming, but not just-in-time programming.  I recently modified a postscript file to only print out the even pages of the document and then the odd pages so that it would print on both sides of the paper without requiring me to issue a separate print command for each page.  This would be an example of just-in-time programming that was not programming for the novice.\n\nA Subtask Suitable for Just-in-Time Programming\nI happened upon an opportunity for just-in-time programming when Think C updated their class library to version 1.1.  Before version 1.1, rectangles were defined with 16-bit coordinates and in version 1.1 rectangles were defined by 32-bit coordinates.  When I first compiled my software project with the new class library, type mismatch errors occurred where my software expected 16-bit values.  Many of these were simple assignment statements.  The new class library included a utility function for converting 32-bit rectangles to 16-bit rectangles, so a typical fix involved changing a line of the form *inset=frame; to the form longToQDRect(&frame,inset);. Various other types of errors were found and fixed as well.  The second time an assignment of a 32-bit rectangle to a 16-bit rectangle caused an error, I recalled that there were many such assignments throughout my program and concluded I would, in time, be transforming many lines from assignment statements into function calls. Each would differ only in the names of the variables and whether each variable was a pointer or not (i.e. preceded by a \"*\").  For the rest of this paper, transforming one of these lines will be called the line transformation subtask.\nTo attempt to automate this subtask would have been just-in-time programming because of the situation.  This particular example also contrasts well with the other types of programming discussed above.  It would certainly not be task-time independent programming because I was in the midst of modifying my software project.  The subtask was algorithmically simple so it was not programming-in-the-large.  Automating the subtask was not essential, so it was not essential programming.\nSo to break this situation down into the components of just-in-time programming:\nThe user: \nmyself\nThe task: \nmodifying a software project to work with an updated class library\nThe subtask: \nchanging certain lines of source code from the form {*}var1 = {*}var2; to the form longToQDRect({&}var2,{&}var1); (i.e. the line transformation subtask)\nThe algorithm: \ninsert leading white space\ninsert \"longToQDRect(\"\nif second variable name is not preceded by \"*\", insert \"&\"\ninsert second variable name\ninsert \",\"\nif first variable name is not preceded by \"*\", insert \"&\"\ninsert first variable name\ninsert \")\"\ninsert rest of line (the \";\" and comments, if any)\ndelete original line.\nThe attempt to automate:  \nActually I did not try to automate the subtask.  The rest of the chapter will explain why.\n\nFive Obstacles\nOne reason to explicitly state a problem is so that it can be broken down into meaningful subproblems.  One way to do this is to analyze current technology, identify common obstacles that prevent the technology from being effective, and let the subproblems be to find ways to eliminate these obstacles.  The following sections discuss five obstacles that often prevent users of current programming systems from profiting from their algorithmic insights.  Each section also discusses PBD's potential role in solving the subproblem represented by each obstacle.\n\t\nFigure 3:  A C algorithm that automates the line transformation subtask assuming the line has been isolated in a character buffer.\n\nEffort of entering the algorithm\nGiven that I understood the algorithmic structure of the line transformation subtask, why not automate it?  Since I was actually using a C programming system, let's first explore the possibility of using it.  Figure 3 shows a program in C that can transform the line as needed, assuming that the line has been loaded into a string (we will deal with this assumption more later).  One obstacle quickly becomes apparent: the effort of entering the algorithm.  Merely the physical effort of typing in the 749 characters of this program would likely undermine the benefits of automating this small part of the task.  But there is also the mental effort required to translate the algorithm into the idioms of the language and to work out the fine details.  For example, after years of programming in C, I still must look up the strcat function in the manual to see if it copies from the first argument to the second or vice versa.\nDiscussion  No matter what type of programming is being done, reducing this effort is desirable.  However, the effort of entering an algorithm is particularly important for just-in-time programming because the subtasks appropriate for just-in-time programming are typically special purpose needs that can not be as widely applied as functionality that is more generic.  The line transformation task is a good example of this because once I finished updating the software project, I had no need for this particular functionality.  When the benefits per programming effort are modest, only minimal effort can be expended towards entering the algorithm before the venture becomes pointless.  If the user's task is creative or involves problem solving, then the user can scarcely afford to expend mental effort for modest gains.  Of course, there are times when the payoffs of just-in-time programming are large enough that the effort to enter the algorithm is not as crucial.  But there are enough opportunities for modest payoffs that finding ways to reduce the effort required to enter the algorithm is an important subproblem to solve.\nSometimes creating new beneficial automation by programming pays off because the user can apply the automation many times in the future.  A script that automatically dials a remote computer and logs the user into their account would be a good example.  Here the distinction between just-in-time programming and task-time independent programming is blurred.  Strictly speaking, the programming effort is expended at a time independent of when the benefits of the automation are received.  However, the user is likely to automate this task at a time when they are about to dial in to the remote computer manually, that is, when the desirability of automating the subtask comes to mind.  So although the user could set aside some time and do task-time independent programming, psychologically the task-time aspects of whatever the user is doing are likely to impact the programming process.  In this sense, much of the special concerns of just-in-time programming still hold.\nReducing this effort is less important for programming-in-the-large because the effort required to manage the complexity of a large software project tends to overshadow the effort required to enter the algorithm.  In fact, programming languages such as Ada even increase the effort of entering the algorithm by requiring extra notation for modularizing the code.  Such notation does not contribute directly to functionality, but is appropriate for programming-in-the-large because complexity is such an overriding concern.\nJust-in-time programming accentuates the mental effort required to enter the algorithm because users must switch their mind-sets from the task domain to the programming domain as illustrated in figure 1.  After the algorithm has been implemented, users must also expend effort to return their mind-sets to the task domain.  Users might expend effort trying not to divert too much attention to the programming effort, sometimes trying to keep more in their short term memory than is reasonable.  For creative tasks, this diversion is especially costly.  In contrast, users who are programming independently of task time can change their mind-set over a longer period of time.\nTherefore when minimizing the effort of entering the algorithm, it is important to minimize distraction from the task.  One of the main sources of effort and distraction is the number of special programming concepts.  For example, writing the C algorithm in figure 3 required remembering how strings are allocated and referenced.  On this point, just-in-time programming and programming for novice programmers share similar goals because a programming system for novice programmers should require the understanding of as few new concepts as possible.  In cases where a just-in-time programming system is being designed specifically for novice programmers, the same would apply.\nThe idea of just-in-time programming, however, is not limited to novice programmers.  For expert programmers, whether a concept is familiar to a nonprogrammer is not the crucial factor.  Instead, the programming system should require the user to understand only concepts that can be ingrained and that the user can apply fluently.  Therefore, part of the research agenda of just-in-time programming should be to identify key skills that, if ingrained, will allow a user to more effectively write programs just in time.  These skills could be anything from something classic like regular expressions to some new esoteric programming paradigm.  It seems clear that, at least for the foreseeable future, users will have to understand the basic concepts of conditionals and iteration.\nSolution directions  Many techniques including code templates, code reuse, domain specific functionality, subroutines, copy/paste, and on-line documentation can help reduce the effort required to enter an algorithm.  PBD helps reduce this effort by allowing users to enter the algorithm using the same interface as they would normally use to work the subtask manually.  This helps reduce both the physical effort and the mental effort because the user is often well practiced at using this interface.  Since the user would use the same user interface to work the subtask manually, the artifacts are already in short term memory and programming with them is likely to be less distracting than with an off-line programming language.  The effort to enter the algorithm is also reduced because user interfaces are usually optimized to the task.\nFigure 4:  This Quickeys macro can partially automate the line transformation subtask.  The number of keystrokes required to enter the macro and the visual state of the editor are shown.\n\nFor a simple example of how PBD can reduce the effort of entering an algorithm, consider one partial solution to the line transformation subtask.  If the user first places the cursor to the left of the first variable in the line to be transformed and neither variable is a pointer, then the Quickeys macro shown in figure 4 will transform the line as required.  The macro also assumes that exactly three characters (\" = \") separate the two variable names.  Only the 33 keypresses shown in figure 4 are required to implement the macro.  The visual feedback of the editor also helps reduce the mental effort by showing intermediate results.\nLimited computational generality\nWhy illustrate the virtues of the keyboard macro by only partially automating the line transformation subtask?  The reason is that the subtask requires conditional logic to decide whether each variable is a pointer or not.  Keyboard macros only record straight-line algorithms and thus are not able to fully automate this subtask.  This illustrates an obstacle that users face when programming just in time:  the programming systems that make it easy to enter their algorithm can often only implement algorithms of limited computational generality.\nDiscussion  It is important for a just-in-time programming system to have full Turing-complete computational generality because there is no way to predict which of the vast array of algorithms the user might envision.  Unfortunately computational generality is not one of PBD's strengths.  Halbert recognized this when implementing SmallStar and concluded that control structures were better created by editing a static representation of the program than by demonstration [Halbert 84].  Others have used inference to generalize straight-line demonstrations into procedures with control structures.  Cypher's Eager and Myers' Peridot used domain knowledge to infer procedures with control structures solely from straight-line demonstrations [EAGER CHAPTER, PERIDOT CHAPTER].  The computational generality of these systems, however, was limited by limited domain knowledge.\nSolution directions  In order for a PBD to be used for just-in-time programming, it will have to be integrated with other techniques to give full computational generality.  Interesting directions include giving separate examples for each path of the algorithm as in Tinker [TINKER CHAPTER], or a combination of multiple demonstrations, inferencing, and special instructions from the user as in Metamouse [METAMOUSE CHAPTER].\nEffort of invoking algorithm\nAs stated previously, the effort to enter an algorithm is less of an obstacle when the benefits of automating are large.  So for the sake of argument, assume that I knew there would be hundreds of lines needing to be transformed and decided to automate the task using C.  Limited computational generality would not be an obstacle with C.  Are there other obstacles?\nWhen the compiler detected an error in my software project, it would load the file containing the error into its text editor and highlight the erroneous line.  To take advantage of the line transformation program, I would first have to judge if it was one of the simple type mismatch errors that could be fixed by the simple line transformation.  If so, I would then invoke the C implementation on the specific line.  But how would I do that?  One possibility would be to mark the line some special way, perhaps by placing a \"*\" at the beginning of the line, and then save the file out to disk.  Then I could run the C program which would then prompt me for the name of the file with the incorrect line.  The C program would then scan through the file for a line that started with a \"*\" and apply the transformation to it.  But this would be silly.  The effort to invoke the algorithm would undermine the benefits and would be yet another obstacle to automating this subtask.\nDiscussion  As in this case, a subtask appropriate for just-in-time programming typically applies to part of a larger document.  Thus, users must be able to implement the algorithm such that they can specify which part of the document should be processed when they invoke the algorithm.  It is important that they be able to do this with ease because the benefits to be obtained by automating can be easily negated by the invocation effort.  Unlike the effort to enter the algorithm, the effort to invoke the algorithm can not be amortized over the life of the new beneficial automation.  The effort must be small in comparison with the benefit received from each invocation of the algorithm.  When the payoffs per invocation are larger this obstacle is not as crucial, but enough opportunities for modest benefits exist that it is important to reduce the effort required to invoke algorithms implemented just in time.\nFor an example of how crucial the ease of invocation can be towards making automation beneficial, consider the feature on many word processors that allows a user to select a word simply by double clicking on it.  The word processor automatically does the tedious subtask of extending the selection out to the word boundaries.  Identifying these word boundaries manually is a simple subtask, so not much benefit is received each time the feature is used.  However, words are selected so commonly that, over time, the feature is very beneficial.  Another invocation strategy could easily undermine this benefit.  For example, even requiring the user to click on the word and then select the feature from a pull down menu could require too much effort.\nAs the previous example implies, this obstacle is not unique to just-in-time programming.  Because the effort to invoke the algorithm can not be amortized, any programming endeavor that produces interactive software needs to pay special attention to this obstacle.  The main difference for just-in-time programming is that the user can not amortize the effort to create the invocation scheme as much.\nSolution directions  How should just-in-time programming make it easy to invoke algorithms?  One clue is strongly implied by the hypothetical consideration of C for automating the line transformation subtask:  users should be able to implement their algorithms such that they can perform the subtask without having to save their documents to disk.  Instead their algorithms should be able to process data in its present form which is usually internal to some application.  Thus just-in-time programming systems should allow users to process data within their applications.  In addition, users should be able to use the application's data selection mechanisms to indicate what part of their document to process.  This would enable users to work manually, apply a newly implemented algorithm to the data, and continue to work manually without the overhead of saving the data to a file. Processing data within applications is central to PBD, so it already goes far to easing the effort to invoke the algorithm.\nBeyond automating within applications, just-in-time programming systems should allow the user to choose among various invocation strategies.  Standard invocations such as menu selections and keypresses should be supported.  The ability to create more refined invocations, like double clicking on a an object to apply some automation to it, would be important for making some highly interactive automation worth creating.  PBD techniques could possibly be used to have the fact that the user has started doing the subtask be what triggers the automation to be invoked.  David Maulsby's Turvy and Metamouse give hints of how this might work [TURVY CHAPTER, METAMOUSE CHAPTER].\nInaccessible data and operators\nSo far we have seen several reasons to want to process data while it resides within an application.  One is to make algorithms easier to enter by allowing the user to demonstration the algorithm through the user interface of the application.  Another is that invocations can be made easier if the data is processed within the application.  The Quickeys solution in figure 4 had these advantages, but it only partially automated the subtask.  No other programming system on my computer (including APL, C, Lisp, Scheme, or HyperTalk) can automate within Think C's editor because of the fourth obstacle, inaccessible data and operators.  In this case, this obstacle undermines the modest benefits of automating the subtask.  If the benefits per invocation were greater, then accessing the data independently of the application by saving the document to a file might have made creating the new automation worthwhile.\nIn other cases, limited data access can take the simplest algorithms and render them impossible to implement.  Consider the example discussed in [TRIGGERS CHAPTER REFERENCE] of automating the wrapping of a text field with a properly sized rounded rectangle.  The algorithm to automate this task is trivial when stated in terms of the text field's and the rounded rectangle's properties of location, length and width.  The central part of the algorithm is to set the rounded rectangle's location a bit above and to the left of the text field's location, and set the rounded rectangle's length and width to be a bit larger.  Automating this task independently of MacDraw II would involve extracting these properties from MacDraw II's coded file format, which would be very difficult.  Also, the user's algorithm may be based on special functionality provided by the application such as, in this case, the ability to create rounded rectangles.  Just-in-time programming systems should therefore be able to access properties from applications and invoke the operators provided by applications.\nSometimes an opportunity for new beneficial automation involves not so much the processing of data, but rather the repetitive manipulation of an application's user interface artifacts.  For example, the user may wish to automate the toggling between two window arrangements.  The only way a programming system can automate this is to access the state of the user interface and manipulate its components.\nDiscussion  Inaccessible data and operators is a particularly common obstacle for just-in-time programming because users must make do with whatever form their data is in when they envision the algorithm.  Usually this data exists within an application.  In contrast, task-time independent programming often allows the user to plan what form the data will be in when the automation is eventually used.  Many programming efforts, like games or educational software, are closed systems where the programmer can choose the format of the data to be whatever makes their programming effort easiest.\nSolution directions  In order for a programming system to access the data and operators of an application, there must be a communication protocol that both the programming system and the application follow.  One way to effect this protocol is to build the programming system into the application.  This strategy, however, limits the data access to the one application, so inaccessible data and operators would still be an obstacle when the user's algorithm involved multiple applications.  Therefore just-in-time programming systems should make use of specially established interapplication protocols like Apple Events [Apple 91].\nSometimes programming systems can overcome the inaccessible data and operators obstacle by using protocols established for reasons other than interapplication communication.  For example, the Quickeys solution uses the computer's keyboard input stream as a protocol to process data in the editor application.  The Triggers chapter discusses an extension to this technique where pixel data from the computer display can be used to gain a significant degree data access from any application.  PBD plays a large role in making this extension possible because the algorithms implemented using these techniques sometimes contain large bitmap constants.  Entering these bitmaps would be unwieldy if they could not be specified by demonstration.\nRisk\nThe fifth obstacle is the risk that the automation will fail, be ineffective, or produce unintended results.  Consider the risks of automating the line transformation subtask.  There are many possible scenarios.  In the best case the algorithm could have been entered almost effortlessly, and as each occurrence of a line needing the simple transformation was flagged by the compiler, I could have easily invoked the algorithm somehow.  To my surprise, perhaps more chances to use the new automation occurred than were anticipated, making the automation pay off more than expected.\nBut there are many other possible scenarios.  The algorithm could have taken a long time to enter, perhaps because some special purpose function had to be looked up in a manual.  A mistake in the implementation might have caused the new (not beneficial) automation to destroy part of the source file, perhaps too quickly to be noticed.  Limited data access could have turned the simple algorithm into one that was impossible to implement.  I was not sure exactly how many more assignments of 32-bit rectangles to 16-bit rectangles were left in my software project, and thus there may have been too few to make the programming effort worthwhile.  Unforeseen special cases may have made the envisioned algorithm simply wrong.\nA user who is considering a just-in-time programming effort has the option of continuing to work manually.  Given the many adverse scenarios, it is not surprising that the user would choose this option.  Thus just-in-time programming systems often fail because the user chooses not to use it.\nRisk was the main reason I chose not to automate the line transformation subtask.  The partial solution using keyboard macros was the only one worth considering because it was the only solution that did not require saving the file to disk.  In the past, my attempts to use keyboard macros have often been thwarted by unforeseen special cases, the difficulty of accommodating special cases into an already existing macro, and the uncontrollable speed of macros that make it difficult to verify that the macro works correctly.  In retrospect, a keyboard macro would have been worthwhile and would have prevented a few recompiles caused by typos in my manual transforming of the lines.  However at the time, the apparent risks convinced me to play it safe and transform the lines manually.\nDiscussion  Certainly all programming involves risk.  The risks of just-in-time programming are notable on two accounts.  One is that the time and effort spent implementing the algorithm relate directly to the success of the venture.  For example, any extra time or frustration involved in automating the line transformation subtask would have quickly eliminated the potential benefits.  In contrast, task-time independent programming efforts often relate only indirectly to success.  For example, say a user is programming an animated demo for a five-minute presentation.  If the demo take two hours longer to implement than expected, the presentation the next day can still be a success.\nBut the main reason risk affects just-in-time programming so strongly is that it is easy for users to choose to continue to work manually and avoid the risk.  In contrast, essential programming requires users to make the best of what their programming systems have to offer.  Users still have to assume whatever risks are present, but the programming system will not fail for lack of use.\nRisk is caused, in part, by the users' uncertainty about how the other four obstacles will affect their attempts to automate.  Thus, one way to reduce the risk is to work towards eliminating these four obstacles.  For example, if entering the algorithm were effortless, there would be no risk in taking that step.  Unfortunately, entirely eliminating these obstacles is very unlikely.  In addition, users will still have to assume the risk that their algorithms might not do as expected.  Thus, it is important to explicitly consider techniques that reduce the risks of just-in-time programming.\nSolution directions  One approach to addressing risk is to make it so that the user can accurately judge the effort required to implement the algorithm and accurately judge the benefits.  Simplicity and visibility are two attributes of a programming system that would contribute to this approach.  When users can confidently judge the benefits will be greater then the efforts, then they can proceed to profit from using the just-in-time programming system and the system will not fail from lack of use.  The limitation of this approach is that merely judging the risks is a risk in itself because the user must expend some mental effort.  Because it is unlikely that this effort can be eliminated entirely, the user will have good reason to simply continue working the task manually without ever giving the opportunity to use just-in-time programming a second thought.  Other techniques need to be considered.\nAnother approach to reducing risk is to enable users to profit from partial implementations of their algorithms.  This would help alleviate the risk that an obstacle might prevent the implementing of part of the algorithm, render the whole algorithm useless, and waste any effort already expended.  Users should be able to implement and profit from parts of their algorithms without requiring the entire algorithm to work flawlessly.\nFor example, assume a user has 20 book chapters saved as a separate MacWrite II files in a folder, and that a colleague requests a pure ASCII copy of each chapter.  To manually convert each chapter to pure ASCII, the user would have to load its file into the MacWrite II, select the Text Only option, and save it back out to disk using a different file name.  Assume files with the word \"backup\" in the file name should not be converted.  The simple algorithm in figure 5 could select all 20 chapters in turn and carry out these repetitive actions.  If the user were able to implement this algorithm, the tedium of keeping track of which files have been converted and the tedium of the repetitive actions would be avoided.\nFigure 5:  An algorithm that will convert a folder full of MacWrite II files to pure ASCII.\n\nIf the entire algorithm could be implemented confidently, easily, and flawlessly, then risk would not be an issue.  Unfortunately, any step in the algorithm could cause potential problems.  What if after putting some effort into the algorithm, the user discovers that only a subset of the nine steps can be implemented?  For example, what if step number 7 could not be implemented because the user's programming system could not invoke the operator that selects the Text Only operator?  The partial implementation can still potentially be beneficial if the user can manually do the steps that prove difficult to implement.  For example, the algorithm could invoke the \"Save As...\" dialog box and pause while the user selects Text Only manually.  The partial implementation would still be beneficial because it would take care of the tedium of keeping track of which files have been converted and a great majority of the other actions.\nFor step number 7, this strategy is easy to imagine because the application's existing user interface can allow the user to carry out the hard to implement action manually.  But what if step number 2 is too difficult to implement because the user's programming system has no built-in test for substrings?  In this case the list is in the programming system's execution environment, not the application.  If the user is to manually accomplish this step, the programming system must have an existing user interface that allows the user to manipulate the execution environment.  Some interactive programming systems and debuggers allow users to modify the execution environment during run-time, but few allow data to be manipulated easily enough for the user to do real work.  Also, the more that control has to pass between the user and their implementation, the more essential it will be that flexible invocation schemes are possible.\nEssentially the user's risk is that the manual method might be more effective than implementing the algorithm.  Therefore, another approach to addressing risk is to allow the user to pursue both alternatives in parallel.  In theory, the risk of attempting to automate the subtask would be eliminated because if unforeseen difficulties make the programming effort ineffective, then the user can fall back on the manual method already underway.\nIn practice, this approach would probably not eliminate risk, but it could reduce risk greatly.  PBD could play a large part in realizing this approach because it allows the user to implement algorithms by demonstrating on their actual task data.  In other words, the user can be programming and manually accomplishing the subtask simultaneously.  For example, recording the keyboard in figure 4 actually transforms one of the lines, so progress towards completing the overall task is hindered minimally.\nThis technique has its greatest potential when mixed with history based techniques.  For example, Allen Cypher's system Eager records the user's actions into an event history [EAGER CHAPTER].  When Eager detects the user doing repetitive actions, it indicates this to the user by highlighting what it expects the user to select next.  For certain classes of algorithms, the user can implement an algorithm at almost no risk because the user takes no special actions.  The decision of whether to invoke the algorithm still involves some risk because the exact behavior of some algorithms is difficult to predict.  Therefore additional techniques such as undo and slow motion execution will have to be extended and refined.\n\nConclusion\nIs creating a programming system that is effective for just-in-time programming an interesting research problem? The previous sections clearly show that it has not been solved already, so it meets this criterion.  A second criterion for interesting research is that there be some indication that solutions are possible.  The previous section touched on several promising research directions, many of which are based on PBD.  A third, important criterion for interesting research is that it lead to tangible benefits.  The benefits of improved just-in-time programming systems would be to allow users to better automate repetitive subtasks that arise from their unique circumstances.  The line transformation subtask was one such example where automation would have led to significant benefit.  There will always be subtasks like this that slip through the prepackaged functionality of applications because they result from the interactions of users with the complexities of the real world.  Task-time is often the only possible time to implement the algorithms that can automate these subtasks.\nBut is it necessary to focus the research problem on such a narrow slice of programming to make automating these subtasks practical?  After all, many of the obstacles facing just-in-time programming also affect other types of programming;  it is possible that researching other types of programming will produce effective just-in-time programming systems as a side effect.  Are there reasons for researching just-in-time programming specifically?\nOne reason is that a user must accomplish all of the following during task-time: assess risk, enter the algorithm, design the invocation scheme, solve data access problems, invoke the algorithm, verify correct program behavior, and resume work on the overlying task.  Thus it is crucial that techniques that support these activities be refined to a degree that other forms of research are unlikely to achieve.  For example, research that concentrates on programming-in-the-large is unlikely to adequately reduce the effort required to input the algorithm when managing program complexity is its overriding concern.  Research that assumes essential programming is unlikely consider techniques that reduce risk by enabling productive use of partially debugged programs.  Research that assumes task-time independent programming is unlikely to recognize that programming may not be the user's primary concern.  Thus it is unlikely to give adequate emphasis to minimizing distractions from the user's primary task.  It is also unlikely to motivate data and operator access that is flexible enough to process the user's data wherever it may be when the opportunity to apply just-in-time programming arises.\nAnother reason is there are solutions that are appropriate for just-in-time programming but are not necessarily appropriate for other types of programming.  For example, the pixel based techniques of Triggers [TRIGGERS CHAPTER] would not be appropriate for software that must run in the background.  The technique of programming and accomplishing the task at the same time discussed in the risk section does not make sense for programmers who are writing software for other people's use.\nBy recognizing the special nature of just-in-time programming and by addressing the limitations of current programming systems head-on, much research progress should result.  The five obstacles provide a set of subproblems that can be used to focus multiple avenues of research.  Researchers should be careful not to accentuate one obstacle in the elimination of another; it only takes one to prevent a just-in-time programming system from being effective.  It is crucial that a just-in-time programming system address risk because it is probably impossible to create a programming system where the user's every attempt at creating new automation will be profitable.  The goal should be to create a programming system where a user can know that in the worse case attempting just-in-time programming will not hinder progress towards completing the task.  Then the user will be able to confidently use the full extent of the programming system to profit from their algorithmic insights.\n\nReferences for Alan\n\n[Apple 91] Apple Computer, Inc., <Inside Macintosh, Volume VI> Addison Wesley, Reading, Massachusetts, 1991.\n\n[Cypher 86] Cypher A., \"The Structure of Users' Activities,\" <User Centered Design>, Lawrence Erlbaum Associates, Hillsdale, New Jersey, 1986.\n\n[Halbert 84] Halbert D., \"Programming by Example,\" Ph.D. Thesis, Department of Computer Science, University of California at Berkeley , 1984.\n"
      },
      "date": 1641328970671
    },
    {
      "type": "edit",
      "id": "26fe073b834e8522",
      "item": {
        "type": "markdown",
        "id": "26fe073b834e8522",
        "text": "## Introduction\nMany of the other chapters have presented advancements in programming by demonstration by presenting PBD systems and their innovations.  In other words, these chapters have presented solutions.  This chapter takes another tact by discussing PBD in the context of a problem.  The problem is to create a programming system that is effective for just-in-time programming.  This chapter defines just-in-time programming, explains how it relates to other forms of programming, and explores how creating effective just-in-time programming systems motivates PBD research.\nJust-in-time programming is the implementing of algorithms during task-time (i.e. the time when the user is actually trying to accomplish the task to be automated) and can be characterized by a situation with the following components:\n a computer user who could be either a novice user or an experienced programmer,\n a task that the user is manually accomplishing and completion of which is the user's primary goal,\n an algorithm that will accomplish a subtask (i.e. part of the task) and that the user envisioned while working on the task,\n and an attempt by the user to implement the algorithm for the purpose of more effectively completing the task.\nIn short, the goal of just-in-time programming is to allow users to profit from their task-time algorithmic insights by programming.  Instead of automating with software that was carefully designed and implemented much earlier, the user recognizes an algorithm and then creates the software to take advantage of it just before it is needed, hence implementing it just in time.\nIt is worth emphasizing that the user's task could be from any domain (e.g. graphic drawing, scientific visualization, word processing, etc.) and that the algorithm to be implemented originates with the user.  Obviously, a user with more programming experience will be able to envision a more complex algorithm than a novice user.  How the user comes up with the algorithm is not a concern.  Also, no hint of a solution appears in the problem statement.  Any programming system could conceivably be used for just-in-time programming, including C, PASCAL, keyboard macros, scripting languages, or PBD. PBD will probably be an important part of the more successful just-in-time programming systems, but the problem statement leaves open the possibility for other solutions.\nJust-in-time programming research shares many of the motivations of other PBD research.  Chief among these is that users often do repetitive or algorithmic subtasks that the computer could be doing.  We call these subtasks potential computer subtasks and call these situations opportunities for new beneficial automation.  Because automating can increase productivity and user satisfaction and at the same time reduce errors, one would expect the user to delegate potential computer subtasks to the computer.  That users often do not take advantage of these opportunities motivates researching ways to improve the computer.  Just-in-time programming research and PBD research assert that easier to use programming tools will allow users to better take advantage of opportunities for new beneficial automation.\nJust-in-time programming research, however, is focused on making programming easier for a specific cross section of situations.  These situations are primarily defined by the user programming during task-time.  In other words, the user is attempting to write a program for a task that is already in progress.  Figure 1 summarizes the relationship between task progress and the user's expenditure of effort.  The expenditure of effort for just-in-time programming is shown separate from the other task related effort.  The difficulty of just-in-time programming results from the spreading of the user's mental resources between two activities.  Another difficulty is that the time spent programming contributes directly to total time between the start and completion of the task.\nFigure 1:  Just-in-time programming intermixes programming effort with other task related effort.\n\n\nWhat is not Just-in-time Programming?\nOne might contrast just-in-time programming with, for lack of a better term, task-time independent programming which is summarized in figure 2.  For an example, consider a user who is programming a HyperCard mock-up of a user interface in preparation for a demonstration the next day.  The subtask of the software is to help an audience visualize a proposed user interface design during the meeting.  This example would be task-time independent programming because the software is created well before the meeting.  As is the case with many distinctions, there are examples that straddle the line between just-in-time programming and task-time independent programming, but the discussions that follow should hold regardless.\nFigure 2:  Task-time independent programming separates programming effort from other task-related effort.\n\nJust-in-time programming can be contrasted with other forms of programming by considering implications of the situation characterized in the introduction.  For example, since the algorithm to be implemented is the product of the user's insight, it is typically simple.  Thus one could contrast just-in-time programming with programming-in-the-large.  For an example, developing a full featured word processor would not be just-in-time programming because an algorithm that implements all the features of a word processor is too complex for one person to envision.\nAnother implication of the situation characterized in the introduction is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\nHow does just-in-time programming relate to the more common PBD application of programming for novice programmers? These two types of programming are basically independent;  programming in a given situation could represent both, one, or neither of these.  A novice programmer writing a short program that changes all numbers in a document to a larger font would be an example of both types of programming, assuming the user was about to make the modifications by hand.  A novice programmer writing educational software to be used by students at a later time would be an example of a novice programmer programming, but not just-in-time programming.  I recently modified a postscript file to only print out the even pages of the document and then the odd pages so that it would print on both sides of the paper without requiring me to issue a separate print command for each page.  This would be an example of just-in-time programming that was not programming for the novice.\n\nA Subtask Suitable for Just-in-Time Programming\nI happened upon an opportunity for just-in-time programming when Think C updated their class library to version 1.1.  Before version 1.1, rectangles were defined with 16-bit coordinates and in version 1.1 rectangles were defined by 32-bit coordinates.  When I first compiled my software project with the new class library, type mismatch errors occurred where my software expected 16-bit values.  Many of these were simple assignment statements.  The new class library included a utility function for converting 32-bit rectangles to 16-bit rectangles, so a typical fix involved changing a line of the form *inset=frame; to the form longToQDRect(&frame,inset);. Various other types of errors were found and fixed as well.  The second time an assignment of a 32-bit rectangle to a 16-bit rectangle caused an error, I recalled that there were many such assignments throughout my program and concluded I would, in time, be transforming many lines from assignment statements into function calls. Each would differ only in the names of the variables and whether each variable was a pointer or not (i.e. preceded by a \"*\").  For the rest of this paper, transforming one of these lines will be called the line transformation subtask.\nTo attempt to automate this subtask would have been just-in-time programming because of the situation.  This particular example also contrasts well with the other types of programming discussed above.  It would certainly not be task-time independent programming because I was in the midst of modifying my software project.  The subtask was algorithmically simple so it was not programming-in-the-large.  Automating the subtask was not essential, so it was not essential programming.\nSo to break this situation down into the components of just-in-time programming:\nThe user: \nmyself\nThe task: \nmodifying a software project to work with an updated class library\nThe subtask: \nchanging certain lines of source code from the form {*}var1 = {*}var2; to the form longToQDRect({&}var2,{&}var1); (i.e. the line transformation subtask)\nThe algorithm: \ninsert leading white space\ninsert \"longToQDRect(\"\nif second variable name is not preceded by \"*\", insert \"&\"\ninsert second variable name\ninsert \",\"\nif first variable name is not preceded by \"*\", insert \"&\"\ninsert first variable name\ninsert \")\"\ninsert rest of line (the \";\" and comments, if any)\ndelete original line.\nThe attempt to automate:  \nActually I did not try to automate the subtask.  The rest of the chapter will explain why.\n\nFive Obstacles\nOne reason to explicitly state a problem is so that it can be broken down into meaningful subproblems.  One way to do this is to analyze current technology, identify common obstacles that prevent the technology from being effective, and let the subproblems be to find ways to eliminate these obstacles.  The following sections discuss five obstacles that often prevent users of current programming systems from profiting from their algorithmic insights.  Each section also discusses PBD's potential role in solving the subproblem represented by each obstacle.\n\t\nFigure 3:  A C algorithm that automates the line transformation subtask assuming the line has been isolated in a character buffer.\n\nEffort of entering the algorithm\nGiven that I understood the algorithmic structure of the line transformation subtask, why not automate it?  Since I was actually using a C programming system, let's first explore the possibility of using it.  Figure 3 shows a program in C that can transform the line as needed, assuming that the line has been loaded into a string (we will deal with this assumption more later).  One obstacle quickly becomes apparent: the effort of entering the algorithm.  Merely the physical effort of typing in the 749 characters of this program would likely undermine the benefits of automating this small part of the task.  But there is also the mental effort required to translate the algorithm into the idioms of the language and to work out the fine details.  For example, after years of programming in C, I still must look up the strcat function in the manual to see if it copies from the first argument to the second or vice versa.\nDiscussion  No matter what type of programming is being done, reducing this effort is desirable.  However, the effort of entering an algorithm is particularly important for just-in-time programming because the subtasks appropriate for just-in-time programming are typically special purpose needs that can not be as widely applied as functionality that is more generic.  The line transformation task is a good example of this because once I finished updating the software project, I had no need for this particular functionality.  When the benefits per programming effort are modest, only minimal effort can be expended towards entering the algorithm before the venture becomes pointless.  If the user's task is creative or involves problem solving, then the user can scarcely afford to expend mental effort for modest gains.  Of course, there are times when the payoffs of just-in-time programming are large enough that the effort to enter the algorithm is not as crucial.  But there are enough opportunities for modest payoffs that finding ways to reduce the effort required to enter the algorithm is an important subproblem to solve.\nSometimes creating new beneficial automation by programming pays off because the user can apply the automation many times in the future.  A script that automatically dials a remote computer and logs the user into their account would be a good example.  Here the distinction between just-in-time programming and task-time independent programming is blurred.  Strictly speaking, the programming effort is expended at a time independent of when the benefits of the automation are received.  However, the user is likely to automate this task at a time when they are about to dial in to the remote computer manually, that is, when the desirability of automating the subtask comes to mind.  So although the user could set aside some time and do task-time independent programming, psychologically the task-time aspects of whatever the user is doing are likely to impact the programming process.  In this sense, much of the special concerns of just-in-time programming still hold.\nReducing this effort is less important for programming-in-the-large because the effort required to manage the complexity of a large software project tends to overshadow the effort required to enter the algorithm.  In fact, programming languages such as Ada even increase the effort of entering the algorithm by requiring extra notation for modularizing the code.  Such notation does not contribute directly to functionality, but is appropriate for programming-in-the-large because complexity is such an overriding concern.\nJust-in-time programming accentuates the mental effort required to enter the algorithm because users must switch their mind-sets from the task domain to the programming domain as illustrated in figure 1.  After the algorithm has been implemented, users must also expend effort to return their mind-sets to the task domain.  Users might expend effort trying not to divert too much attention to the programming effort, sometimes trying to keep more in their short term memory than is reasonable.  For creative tasks, this diversion is especially costly.  In contrast, users who are programming independently of task time can change their mind-set over a longer period of time.\nTherefore when minimizing the effort of entering the algorithm, it is important to minimize distraction from the task.  One of the main sources of effort and distraction is the number of special programming concepts.  For example, writing the C algorithm in figure 3 required remembering how strings are allocated and referenced.  On this point, just-in-time programming and programming for novice programmers share similar goals because a programming system for novice programmers should require the understanding of as few new concepts as possible.  In cases where a just-in-time programming system is being designed specifically for novice programmers, the same would apply.\nThe idea of just-in-time programming, however, is not limited to novice programmers.  For expert programmers, whether a concept is familiar to a nonprogrammer is not the crucial factor.  Instead, the programming system should require the user to understand only concepts that can be ingrained and that the user can apply fluently.  Therefore, part of the research agenda of just-in-time programming should be to identify key skills that, if ingrained, will allow a user to more effectively write programs just in time.  These skills could be anything from something classic like regular expressions to some new esoteric programming paradigm.  It seems clear that, at least for the foreseeable future, users will have to understand the basic concepts of conditionals and iteration.\nSolution directions  Many techniques including code templates, code reuse, domain specific functionality, subroutines, copy/paste, and on-line documentation can help reduce the effort required to enter an algorithm.  PBD helps reduce this effort by allowing users to enter the algorithm using the same interface as they would normally use to work the subtask manually.  This helps reduce both the physical effort and the mental effort because the user is often well practiced at using this interface.  Since the user would use the same user interface to work the subtask manually, the artifacts are already in short term memory and programming with them is likely to be less distracting than with an off-line programming language.  The effort to enter the algorithm is also reduced because user interfaces are usually optimized to the task.\nFigure 4:  This Quickeys macro can partially automate the line transformation subtask.  The number of keystrokes required to enter the macro and the visual state of the editor are shown.\n\nFor a simple example of how PBD can reduce the effort of entering an algorithm, consider one partial solution to the line transformation subtask.  If the user first places the cursor to the left of the first variable in the line to be transformed and neither variable is a pointer, then the Quickeys macro shown in figure 4 will transform the line as required.  The macro also assumes that exactly three characters (\" = \") separate the two variable names.  Only the 33 keypresses shown in figure 4 are required to implement the macro.  The visual feedback of the editor also helps reduce the mental effort by showing intermediate results.\nLimited computational generality\nWhy illustrate the virtues of the keyboard macro by only partially automating the line transformation subtask?  The reason is that the subtask requires conditional logic to decide whether each variable is a pointer or not.  Keyboard macros only record straight-line algorithms and thus are not able to fully automate this subtask.  This illustrates an obstacle that users face when programming just in time:  the programming systems that make it easy to enter their algorithm can often only implement algorithms of limited computational generality.\nDiscussion  It is important for a just-in-time programming system to have full Turing-complete computational generality because there is no way to predict which of the vast array of algorithms the user might envision.  Unfortunately computational generality is not one of PBD's strengths.  Halbert recognized this when implementing SmallStar and concluded that control structures were better created by editing a static representation of the program than by demonstration [Halbert 84].  Others have used inference to generalize straight-line demonstrations into procedures with control structures.  Cypher's Eager and Myers' Peridot used domain knowledge to infer procedures with control structures solely from straight-line demonstrations [EAGER CHAPTER, PERIDOT CHAPTER].  The computational generality of these systems, however, was limited by limited domain knowledge.\nSolution directions  In order for a PBD to be used for just-in-time programming, it will have to be integrated with other techniques to give full computational generality.  Interesting directions include giving separate examples for each path of the algorithm as in Tinker [TINKER CHAPTER], or a combination of multiple demonstrations, inferencing, and special instructions from the user as in Metamouse [METAMOUSE CHAPTER].\nEffort of invoking algorithm\nAs stated previously, the effort to enter an algorithm is less of an obstacle when the benefits of automating are large.  So for the sake of argument, assume that I knew there would be hundreds of lines needing to be transformed and decided to automate the task using C.  Limited computational generality would not be an obstacle with C.  Are there other obstacles?\nWhen the compiler detected an error in my software project, it would load the file containing the error into its text editor and highlight the erroneous line.  To take advantage of the line transformation program, I would first have to judge if it was one of the simple type mismatch errors that could be fixed by the simple line transformation.  If so, I would then invoke the C implementation on the specific line.  But how would I do that?  One possibility would be to mark the line some special way, perhaps by placing a \"*\" at the beginning of the line, and then save the file out to disk.  Then I could run the C program which would then prompt me for the name of the file with the incorrect line.  The C program would then scan through the file for a line that started with a \"*\" and apply the transformation to it.  But this would be silly.  The effort to invoke the algorithm would undermine the benefits and would be yet another obstacle to automating this subtask.\nDiscussion  As in this case, a subtask appropriate for just-in-time programming typically applies to part of a larger document.  Thus, users must be able to implement the algorithm such that they can specify which part of the document should be processed when they invoke the algorithm.  It is important that they be able to do this with ease because the benefits to be obtained by automating can be easily negated by the invocation effort.  Unlike the effort to enter the algorithm, the effort to invoke the algorithm can not be amortized over the life of the new beneficial automation.  The effort must be small in comparison with the benefit received from each invocation of the algorithm.  When the payoffs per invocation are larger this obstacle is not as crucial, but enough opportunities for modest benefits exist that it is important to reduce the effort required to invoke algorithms implemented just in time.\nFor an example of how crucial the ease of invocation can be towards making automation beneficial, consider the feature on many word processors that allows a user to select a word simply by double clicking on it.  The word processor automatically does the tedious subtask of extending the selection out to the word boundaries.  Identifying these word boundaries manually is a simple subtask, so not much benefit is received each time the feature is used.  However, words are selected so commonly that, over time, the feature is very beneficial.  Another invocation strategy could easily undermine this benefit.  For example, even requiring the user to click on the word and then select the feature from a pull down menu could require too much effort.\nAs the previous example implies, this obstacle is not unique to just-in-time programming.  Because the effort to invoke the algorithm can not be amortized, any programming endeavor that produces interactive software needs to pay special attention to this obstacle.  The main difference for just-in-time programming is that the user can not amortize the effort to create the invocation scheme as much.\nSolution directions  How should just-in-time programming make it easy to invoke algorithms?  One clue is strongly implied by the hypothetical consideration of C for automating the line transformation subtask:  users should be able to implement their algorithms such that they can perform the subtask without having to save their documents to disk.  Instead their algorithms should be able to process data in its present form which is usually internal to some application.  Thus just-in-time programming systems should allow users to process data within their applications.  In addition, users should be able to use the application's data selection mechanisms to indicate what part of their document to process.  This would enable users to work manually, apply a newly implemented algorithm to the data, and continue to work manually without the overhead of saving the data to a file. Processing data within applications is central to PBD, so it already goes far to easing the effort to invoke the algorithm.\nBeyond automating within applications, just-in-time programming systems should allow the user to choose among various invocation strategies.  Standard invocations such as menu selections and keypresses should be supported.  The ability to create more refined invocations, like double clicking on a an object to apply some automation to it, would be important for making some highly interactive automation worth creating.  PBD techniques could possibly be used to have the fact that the user has started doing the subtask be what triggers the automation to be invoked.  David Maulsby's Turvy and Metamouse give hints of how this might work [TURVY CHAPTER, METAMOUSE CHAPTER].\nInaccessible data and operators\nSo far we have seen several reasons to want to process data while it resides within an application.  One is to make algorithms easier to enter by allowing the user to demonstration the algorithm through the user interface of the application.  Another is that invocations can be made easier if the data is processed within the application.  The Quickeys solution in figure 4 had these advantages, but it only partially automated the subtask.  No other programming system on my computer (including APL, C, Lisp, Scheme, or HyperTalk) can automate within Think C's editor because of the fourth obstacle, inaccessible data and operators.  In this case, this obstacle undermines the modest benefits of automating the subtask.  If the benefits per invocation were greater, then accessing the data independently of the application by saving the document to a file might have made creating the new automation worthwhile.\nIn other cases, limited data access can take the simplest algorithms and render them impossible to implement.  Consider the example discussed in [TRIGGERS CHAPTER REFERENCE] of automating the wrapping of a text field with a properly sized rounded rectangle.  The algorithm to automate this task is trivial when stated in terms of the text field's and the rounded rectangle's properties of location, length and width.  The central part of the algorithm is to set the rounded rectangle's location a bit above and to the left of the text field's location, and set the rounded rectangle's length and width to be a bit larger.  Automating this task independently of MacDraw II would involve extracting these properties from MacDraw II's coded file format, which would be very difficult.  Also, the user's algorithm may be based on special functionality provided by the application such as, in this case, the ability to create rounded rectangles.  Just-in-time programming systems should therefore be able to access properties from applications and invoke the operators provided by applications.\nSometimes an opportunity for new beneficial automation involves not so much the processing of data, but rather the repetitive manipulation of an application's user interface artifacts.  For example, the user may wish to automate the toggling between two window arrangements.  The only way a programming system can automate this is to access the state of the user interface and manipulate its components.\nDiscussion  Inaccessible data and operators is a particularly common obstacle for just-in-time programming because users must make do with whatever form their data is in when they envision the algorithm.  Usually this data exists within an application.  In contrast, task-time independent programming often allows the user to plan what form the data will be in when the automation is eventually used.  Many programming efforts, like games or educational software, are closed systems where the programmer can choose the format of the data to be whatever makes their programming effort easiest.\nSolution directions  In order for a programming system to access the data and operators of an application, there must be a communication protocol that both the programming system and the application follow.  One way to effect this protocol is to build the programming system into the application.  This strategy, however, limits the data access to the one application, so inaccessible data and operators would still be an obstacle when the user's algorithm involved multiple applications.  Therefore just-in-time programming systems should make use of specially established interapplication protocols like Apple Events [Apple 91].\nSometimes programming systems can overcome the inaccessible data and operators obstacle by using protocols established for reasons other than interapplication communication.  For example, the Quickeys solution uses the computer's keyboard input stream as a protocol to process data in the editor application.  The Triggers chapter discusses an extension to this technique where pixel data from the computer display can be used to gain a significant degree data access from any application.  PBD plays a large role in making this extension possible because the algorithms implemented using these techniques sometimes contain large bitmap constants.  Entering these bitmaps would be unwieldy if they could not be specified by demonstration.\nRisk\nThe fifth obstacle is the risk that the automation will fail, be ineffective, or produce unintended results.  Consider the risks of automating the line transformation subtask.  There are many possible scenarios.  In the best case the algorithm could have been entered almost effortlessly, and as each occurrence of a line needing the simple transformation was flagged by the compiler, I could have easily invoked the algorithm somehow.  To my surprise, perhaps more chances to use the new automation occurred than were anticipated, making the automation pay off more than expected.\nBut there are many other possible scenarios.  The algorithm could have taken a long time to enter, perhaps because some special purpose function had to be looked up in a manual.  A mistake in the implementation might have caused the new (not beneficial) automation to destroy part of the source file, perhaps too quickly to be noticed.  Limited data access could have turned the simple algorithm into one that was impossible to implement.  I was not sure exactly how many more assignments of 32-bit rectangles to 16-bit rectangles were left in my software project, and thus there may have been too few to make the programming effort worthwhile.  Unforeseen special cases may have made the envisioned algorithm simply wrong.\nA user who is considering a just-in-time programming effort has the option of continuing to work manually.  Given the many adverse scenarios, it is not surprising that the user would choose this option.  Thus just-in-time programming systems often fail because the user chooses not to use it.\nRisk was the main reason I chose not to automate the line transformation subtask.  The partial solution using keyboard macros was the only one worth considering because it was the only solution that did not require saving the file to disk.  In the past, my attempts to use keyboard macros have often been thwarted by unforeseen special cases, the difficulty of accommodating special cases into an already existing macro, and the uncontrollable speed of macros that make it difficult to verify that the macro works correctly.  In retrospect, a keyboard macro would have been worthwhile and would have prevented a few recompiles caused by typos in my manual transforming of the lines.  However at the time, the apparent risks convinced me to play it safe and transform the lines manually.\nDiscussion  Certainly all programming involves risk.  The risks of just-in-time programming are notable on two accounts.  One is that the time and effort spent implementing the algorithm relate directly to the success of the venture.  For example, any extra time or frustration involved in automating the line transformation subtask would have quickly eliminated the potential benefits.  In contrast, task-time independent programming efforts often relate only indirectly to success.  For example, say a user is programming an animated demo for a five-minute presentation.  If the demo take two hours longer to implement than expected, the presentation the next day can still be a success.\nBut the main reason risk affects just-in-time programming so strongly is that it is easy for users to choose to continue to work manually and avoid the risk.  In contrast, essential programming requires users to make the best of what their programming systems have to offer.  Users still have to assume whatever risks are present, but the programming system will not fail for lack of use.\nRisk is caused, in part, by the users' uncertainty about how the other four obstacles will affect their attempts to automate.  Thus, one way to reduce the risk is to work towards eliminating these four obstacles.  For example, if entering the algorithm were effortless, there would be no risk in taking that step.  Unfortunately, entirely eliminating these obstacles is very unlikely.  In addition, users will still have to assume the risk that their algorithms might not do as expected.  Thus, it is important to explicitly consider techniques that reduce the risks of just-in-time programming.\nSolution directions  One approach to addressing risk is to make it so that the user can accurately judge the effort required to implement the algorithm and accurately judge the benefits.  Simplicity and visibility are two attributes of a programming system that would contribute to this approach.  When users can confidently judge the benefits will be greater then the efforts, then they can proceed to profit from using the just-in-time programming system and the system will not fail from lack of use.  The limitation of this approach is that merely judging the risks is a risk in itself because the user must expend some mental effort.  Because it is unlikely that this effort can be eliminated entirely, the user will have good reason to simply continue working the task manually without ever giving the opportunity to use just-in-time programming a second thought.  Other techniques need to be considered.\nAnother approach to reducing risk is to enable users to profit from partial implementations of their algorithms.  This would help alleviate the risk that an obstacle might prevent the implementing of part of the algorithm, render the whole algorithm useless, and waste any effort already expended.  Users should be able to implement and profit from parts of their algorithms without requiring the entire algorithm to work flawlessly.\nFor example, assume a user has 20 book chapters saved as a separate MacWrite II files in a folder, and that a colleague requests a pure ASCII copy of each chapter.  To manually convert each chapter to pure ASCII, the user would have to load its file into the MacWrite II, select the Text Only option, and save it back out to disk using a different file name.  Assume files with the word \"backup\" in the file name should not be converted.  The simple algorithm in figure 5 could select all 20 chapters in turn and carry out these repetitive actions.  If the user were able to implement this algorithm, the tedium of keeping track of which files have been converted and the tedium of the repetitive actions would be avoided.\nFigure 5:  An algorithm that will convert a folder full of MacWrite II files to pure ASCII.\n\nIf the entire algorithm could be implemented confidently, easily, and flawlessly, then risk would not be an issue.  Unfortunately, any step in the algorithm could cause potential problems.  What if after putting some effort into the algorithm, the user discovers that only a subset of the nine steps can be implemented?  For example, what if step number 7 could not be implemented because the user's programming system could not invoke the operator that selects the Text Only operator?  The partial implementation can still potentially be beneficial if the user can manually do the steps that prove difficult to implement.  For example, the algorithm could invoke the \"Save As...\" dialog box and pause while the user selects Text Only manually.  The partial implementation would still be beneficial because it would take care of the tedium of keeping track of which files have been converted and a great majority of the other actions.\nFor step number 7, this strategy is easy to imagine because the application's existing user interface can allow the user to carry out the hard to implement action manually.  But what if step number 2 is too difficult to implement because the user's programming system has no built-in test for substrings?  In this case the list is in the programming system's execution environment, not the application.  If the user is to manually accomplish this step, the programming system must have an existing user interface that allows the user to manipulate the execution environment.  Some interactive programming systems and debuggers allow users to modify the execution environment during run-time, but few allow data to be manipulated easily enough for the user to do real work.  Also, the more that control has to pass between the user and their implementation, the more essential it will be that flexible invocation schemes are possible.\nEssentially the user's risk is that the manual method might be more effective than implementing the algorithm.  Therefore, another approach to addressing risk is to allow the user to pursue both alternatives in parallel.  In theory, the risk of attempting to automate the subtask would be eliminated because if unforeseen difficulties make the programming effort ineffective, then the user can fall back on the manual method already underway.\nIn practice, this approach would probably not eliminate risk, but it could reduce risk greatly.  PBD could play a large part in realizing this approach because it allows the user to implement algorithms by demonstrating on their actual task data.  In other words, the user can be programming and manually accomplishing the subtask simultaneously.  For example, recording the keyboard in figure 4 actually transforms one of the lines, so progress towards completing the overall task is hindered minimally.\nThis technique has its greatest potential when mixed with history based techniques.  For example, Allen Cypher's system Eager records the user's actions into an event history [EAGER CHAPTER].  When Eager detects the user doing repetitive actions, it indicates this to the user by highlighting what it expects the user to select next.  For certain classes of algorithms, the user can implement an algorithm at almost no risk because the user takes no special actions.  The decision of whether to invoke the algorithm still involves some risk because the exact behavior of some algorithms is difficult to predict.  Therefore additional techniques such as undo and slow motion execution will have to be extended and refined.\n\nConclusion\nIs creating a programming system that is effective for just-in-time programming an interesting research problem? The previous sections clearly show that it has not been solved already, so it meets this criterion.  A second criterion for interesting research is that there be some indication that solutions are possible.  The previous section touched on several promising research directions, many of which are based on PBD.  A third, important criterion for interesting research is that it lead to tangible benefits.  The benefits of improved just-in-time programming systems would be to allow users to better automate repetitive subtasks that arise from their unique circumstances.  The line transformation subtask was one such example where automation would have led to significant benefit.  There will always be subtasks like this that slip through the prepackaged functionality of applications because they result from the interactions of users with the complexities of the real world.  Task-time is often the only possible time to implement the algorithms that can automate these subtasks.\nBut is it necessary to focus the research problem on such a narrow slice of programming to make automating these subtasks practical?  After all, many of the obstacles facing just-in-time programming also affect other types of programming;  it is possible that researching other types of programming will produce effective just-in-time programming systems as a side effect.  Are there reasons for researching just-in-time programming specifically?\nOne reason is that a user must accomplish all of the following during task-time: assess risk, enter the algorithm, design the invocation scheme, solve data access problems, invoke the algorithm, verify correct program behavior, and resume work on the overlying task.  Thus it is crucial that techniques that support these activities be refined to a degree that other forms of research are unlikely to achieve.  For example, research that concentrates on programming-in-the-large is unlikely to adequately reduce the effort required to input the algorithm when managing program complexity is its overriding concern.  Research that assumes essential programming is unlikely consider techniques that reduce risk by enabling productive use of partially debugged programs.  Research that assumes task-time independent programming is unlikely to recognize that programming may not be the user's primary concern.  Thus it is unlikely to give adequate emphasis to minimizing distractions from the user's primary task.  It is also unlikely to motivate data and operator access that is flexible enough to process the user's data wherever it may be when the opportunity to apply just-in-time programming arises.\nAnother reason is there are solutions that are appropriate for just-in-time programming but are not necessarily appropriate for other types of programming.  For example, the pixel based techniques of Triggers [TRIGGERS CHAPTER] would not be appropriate for software that must run in the background.  The technique of programming and accomplishing the task at the same time discussed in the risk section does not make sense for programmers who are writing software for other people's use.\nBy recognizing the special nature of just-in-time programming and by addressing the limitations of current programming systems head-on, much research progress should result.  The five obstacles provide a set of subproblems that can be used to focus multiple avenues of research.  Researchers should be careful not to accentuate one obstacle in the elimination of another; it only takes one to prevent a just-in-time programming system from being effective.  It is crucial that a just-in-time programming system address risk because it is probably impossible to create a programming system where the user's every attempt at creating new automation will be profitable.  The goal should be to create a programming system where a user can know that in the worse case attempting just-in-time programming will not hinder progress towards completing the task.  Then the user will be able to confidently use the full extent of the programming system to profit from their algorithmic insights.\n\nReferences for Alan\n\n[Apple 91] Apple Computer, Inc., <Inside Macintosh, Volume VI> Addison Wesley, Reading, Massachusetts, 1991.\n\n[Cypher 86] Cypher A., \"The Structure of Users' Activities,\" <User Centered Design>, Lawrence Erlbaum Associates, Hillsdale, New Jersey, 1986.\n\n[Halbert 84] Halbert D., \"Programming by Example,\" Ph.D. Thesis, Department of Computer Science, University of California at Berkeley , 1984.\n"
      },
      "date": 1641329012058
    },
    {
      "type": "edit",
      "id": "26fe073b834e8522",
      "item": {
        "type": "markdown",
        "id": "26fe073b834e8522",
        "text": "## Introduction\nMany of the other chapters have presented advancements in programming by demonstration by presenting PBD systems and their innovations.  In other words, these chapters have presented solutions.  This chapter takes another tact by discussing PBD in the context of a problem.  The problem is to create a programming system that is effective for just-in-time programming.  This chapter defines just-in-time programming, explains how it relates to other forms of programming, and explores how creating effective just-in-time programming systems motivates PBD research.\n"
      },
      "date": 1641329021938
    },
    {
      "type": "add",
      "id": "5745e710a3f02563",
      "item": {
        "type": "markdown",
        "id": "5745e710a3f02563",
        "text": "Just-in-time programming is the implementing of algorithms during task-time (i.e. the time when the user is actually trying to accomplish the task to be automated) and can be characterized by a situation with the following components:\n a computer user who could be either a novice user or an experienced programmer,\n a task that the user is manually accomplishing and completion of which is the user's primary goal,\n an algorithm that will accomplish a subtask (i.e. part of the task) and that the user envisioned while working on the task,\n and an attempt by the user to implement the algorithm for the purpose of more effectively completing the task.\nIn short, the goal of just-in-time programming is to allow users to profit from their task-time algorithmic insights by programming.  Instead of automating with software that was carefully designed and implemented much earlier, the user recognizes an algorithm and then creates the software to take advantage of it just before it is needed, hence implementing it just in time.\nIt is worth emphasizing that the user's task could be from any domain (e.g. graphic drawing, scientific visualization, word processing, etc.) and that the algorithm to be implemented originates with the user.  Obviously, a user with more programming experience will be able to envision a more complex algorithm than a novice user.  How the user comes up with the algorithm is not a concern.  Also, no hint of a solution appears in the problem statement.  Any programming system could conceivably be used for just-in-time programming, including C, PASCAL, keyboard macros, scripting languages, or PBD. PBD will probably be an important part of the more successful just-in-time programming systems, but the problem statement leaves open the possibility for other solutions.\nJust-in-time programming research shares many of the motivations of other PBD research.  Chief among these is that users often do repetitive or algorithmic subtasks that the computer could be doing.  We call these subtasks potential computer subtasks and call these situations opportunities for new beneficial automation.  Because automating can increase productivity and user satisfaction and at the same time reduce errors, one would expect the user to delegate potential computer subtasks to the computer.  That users often do not take advantage of these opportunities motivates researching ways to improve the computer.  Just-in-time programming research and PBD research assert that easier to use programming tools will allow users to better take advantage of opportunities for new beneficial automation.\nJust-in-time programming research, however, is focused on making programming easier for a specific cross section of situations.  These situations are primarily defined by the user programming during task-time.  In other words, the user is attempting to write a program for a task that is already in progress.  Figure 1 summarizes the relationship between task progress and the user's expenditure of effort.  The expenditure of effort for just-in-time programming is shown separate from the other task related effort.  The difficulty of just-in-time programming results from the spreading of the user's mental resources between two activities.  Another difficulty is that the time spent programming contributes directly to total time between the start and completion of the task.\nFigure 1:  Just-in-time programming intermixes programming effort with other task related effort.\n\n\nWhat is not Just-in-time Programming?\nOne might contrast just-in-time programming with, for lack of a better term, task-time independent programming which is summarized in figure 2.  For an example, consider a user who is programming a HyperCard mock-up of a user interface in preparation for a demonstration the next day.  The subtask of the software is to help an audience visualize a proposed user interface design during the meeting.  This example would be task-time independent programming because the software is created well before the meeting.  As is the case with many distinctions, there are examples that straddle the line between just-in-time programming and task-time independent programming, but the discussions that follow should hold regardless.\nFigure 2:  Task-time independent programming separates programming effort from other task-related effort.\n\nJust-in-time programming can be contrasted with other forms of programming by considering implications of the situation characterized in the introduction.  For example, since the algorithm to be implemented is the product of the user's insight, it is typically simple.  Thus one could contrast just-in-time programming with programming-in-the-large.  For an example, developing a full featured word processor would not be just-in-time programming because an algorithm that implements all the features of a word processor is too complex for one person to envision.\nAnother implication of the situation characterized in the introduction is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\nHow does just-in-time programming relate to the more common PBD application of programming for novice programmers? These two types of programming are basically independent;  programming in a given situation could represent both, one, or neither of these.  A novice programmer writing a short program that changes all numbers in a document to a larger font would be an example of both types of programming, assuming the user was about to make the modifications by hand.  A novice programmer writing educational software to be used by students at a later time would be an example of a novice programmer programming, but not just-in-time programming.  I recently modified a postscript file to only print out the even pages of the document and then the odd pages so that it would print on both sides of the paper without requiring me to issue a separate print command for each page.  This would be an example of just-in-time programming that was not programming for the novice.\n\nA Subtask Suitable for Just-in-Time Programming\nI happened upon an opportunity for just-in-time programming when Think C updated their class library to version 1.1.  Before version 1.1, rectangles were defined with 16-bit coordinates and in version 1.1 rectangles were defined by 32-bit coordinates.  When I first compiled my software project with the new class library, type mismatch errors occurred where my software expected 16-bit values.  Many of these were simple assignment statements.  The new class library included a utility function for converting 32-bit rectangles to 16-bit rectangles, so a typical fix involved changing a line of the form *inset=frame; to the form longToQDRect(&frame,inset);. Various other types of errors were found and fixed as well.  The second time an assignment of a 32-bit rectangle to a 16-bit rectangle caused an error, I recalled that there were many such assignments throughout my program and concluded I would, in time, be transforming many lines from assignment statements into function calls. Each would differ only in the names of the variables and whether each variable was a pointer or not (i.e. preceded by a \"*\").  For the rest of this paper, transforming one of these lines will be called the line transformation subtask.\nTo attempt to automate this subtask would have been just-in-time programming because of the situation.  This particular example also contrasts well with the other types of programming discussed above.  It would certainly not be task-time independent programming because I was in the midst of modifying my software project.  The subtask was algorithmically simple so it was not programming-in-the-large.  Automating the subtask was not essential, so it was not essential programming.\nSo to break this situation down into the components of just-in-time programming:\nThe user: \nmyself\nThe task: \nmodifying a software project to work with an updated class library\nThe subtask: \nchanging certain lines of source code from the form {*}var1 = {*}var2; to the form longToQDRect({&}var2,{&}var1); (i.e. the line transformation subtask)\nThe algorithm: \ninsert leading white space\ninsert \"longToQDRect(\"\nif second variable name is not preceded by \"*\", insert \"&\"\ninsert second variable name\ninsert \",\"\nif first variable name is not preceded by \"*\", insert \"&\"\ninsert first variable name\ninsert \")\"\ninsert rest of line (the \";\" and comments, if any)\ndelete original line.\nThe attempt to automate:  \nActually I did not try to automate the subtask.  The rest of the chapter will explain why.\n\nFive Obstacles\nOne reason to explicitly state a problem is so that it can be broken down into meaningful subproblems.  One way to do this is to analyze current technology, identify common obstacles that prevent the technology from being effective, and let the subproblems be to find ways to eliminate these obstacles.  The following sections discuss five obstacles that often prevent users of current programming systems from profiting from their algorithmic insights.  Each section also discusses PBD's potential role in solving the subproblem represented by each obstacle.\n\t\nFigure 3:  A C algorithm that automates the line transformation subtask assuming the line has been isolated in a character buffer.\n\nEffort of entering the algorithm\nGiven that I understood the algorithmic structure of the line transformation subtask, why not automate it?  Since I was actually using a C programming system, let's first explore the possibility of using it.  Figure 3 shows a program in C that can transform the line as needed, assuming that the line has been loaded into a string (we will deal with this assumption more later).  One obstacle quickly becomes apparent: the effort of entering the algorithm.  Merely the physical effort of typing in the 749 characters of this program would likely undermine the benefits of automating this small part of the task.  But there is also the mental effort required to translate the algorithm into the idioms of the language and to work out the fine details.  For example, after years of programming in C, I still must look up the strcat function in the manual to see if it copies from the first argument to the second or vice versa.\nDiscussion  No matter what type of programming is being done, reducing this effort is desirable.  However, the effort of entering an algorithm is particularly important for just-in-time programming because the subtasks appropriate for just-in-time programming are typically special purpose needs that can not be as widely applied as functionality that is more generic.  The line transformation task is a good example of this because once I finished updating the software project, I had no need for this particular functionality.  When the benefits per programming effort are modest, only minimal effort can be expended towards entering the algorithm before the venture becomes pointless.  If the user's task is creative or involves problem solving, then the user can scarcely afford to expend mental effort for modest gains.  Of course, there are times when the payoffs of just-in-time programming are large enough that the effort to enter the algorithm is not as crucial.  But there are enough opportunities for modest payoffs that finding ways to reduce the effort required to enter the algorithm is an important subproblem to solve.\nSometimes creating new beneficial automation by programming pays off because the user can apply the automation many times in the future.  A script that automatically dials a remote computer and logs the user into their account would be a good example.  Here the distinction between just-in-time programming and task-time independent programming is blurred.  Strictly speaking, the programming effort is expended at a time independent of when the benefits of the automation are received.  However, the user is likely to automate this task at a time when they are about to dial in to the remote computer manually, that is, when the desirability of automating the subtask comes to mind.  So although the user could set aside some time and do task-time independent programming, psychologically the task-time aspects of whatever the user is doing are likely to impact the programming process.  In this sense, much of the special concerns of just-in-time programming still hold.\nReducing this effort is less important for programming-in-the-large because the effort required to manage the complexity of a large software project tends to overshadow the effort required to enter the algorithm.  In fact, programming languages such as Ada even increase the effort of entering the algorithm by requiring extra notation for modularizing the code.  Such notation does not contribute directly to functionality, but is appropriate for programming-in-the-large because complexity is such an overriding concern.\nJust-in-time programming accentuates the mental effort required to enter the algorithm because users must switch their mind-sets from the task domain to the programming domain as illustrated in figure 1.  After the algorithm has been implemented, users must also expend effort to return their mind-sets to the task domain.  Users might expend effort trying not to divert too much attention to the programming effort, sometimes trying to keep more in their short term memory than is reasonable.  For creative tasks, this diversion is especially costly.  In contrast, users who are programming independently of task time can change their mind-set over a longer period of time.\nTherefore when minimizing the effort of entering the algorithm, it is important to minimize distraction from the task.  One of the main sources of effort and distraction is the number of special programming concepts.  For example, writing the C algorithm in figure 3 required remembering how strings are allocated and referenced.  On this point, just-in-time programming and programming for novice programmers share similar goals because a programming system for novice programmers should require the understanding of as few new concepts as possible.  In cases where a just-in-time programming system is being designed specifically for novice programmers, the same would apply.\nThe idea of just-in-time programming, however, is not limited to novice programmers.  For expert programmers, whether a concept is familiar to a nonprogrammer is not the crucial factor.  Instead, the programming system should require the user to understand only concepts that can be ingrained and that the user can apply fluently.  Therefore, part of the research agenda of just-in-time programming should be to identify key skills that, if ingrained, will allow a user to more effectively write programs just in time.  These skills could be anything from something classic like regular expressions to some new esoteric programming paradigm.  It seems clear that, at least for the foreseeable future, users will have to understand the basic concepts of conditionals and iteration.\nSolution directions  Many techniques including code templates, code reuse, domain specific functionality, subroutines, copy/paste, and on-line documentation can help reduce the effort required to enter an algorithm.  PBD helps reduce this effort by allowing users to enter the algorithm using the same interface as they would normally use to work the subtask manually.  This helps reduce both the physical effort and the mental effort because the user is often well practiced at using this interface.  Since the user would use the same user interface to work the subtask manually, the artifacts are already in short term memory and programming with them is likely to be less distracting than with an off-line programming language.  The effort to enter the algorithm is also reduced because user interfaces are usually optimized to the task.\nFigure 4:  This Quickeys macro can partially automate the line transformation subtask.  The number of keystrokes required to enter the macro and the visual state of the editor are shown.\n\nFor a simple example of how PBD can reduce the effort of entering an algorithm, consider one partial solution to the line transformation subtask.  If the user first places the cursor to the left of the first variable in the line to be transformed and neither variable is a pointer, then the Quickeys macro shown in figure 4 will transform the line as required.  The macro also assumes that exactly three characters (\" = \") separate the two variable names.  Only the 33 keypresses shown in figure 4 are required to implement the macro.  The visual feedback of the editor also helps reduce the mental effort by showing intermediate results.\nLimited computational generality\nWhy illustrate the virtues of the keyboard macro by only partially automating the line transformation subtask?  The reason is that the subtask requires conditional logic to decide whether each variable is a pointer or not.  Keyboard macros only record straight-line algorithms and thus are not able to fully automate this subtask.  This illustrates an obstacle that users face when programming just in time:  the programming systems that make it easy to enter their algorithm can often only implement algorithms of limited computational generality.\nDiscussion  It is important for a just-in-time programming system to have full Turing-complete computational generality because there is no way to predict which of the vast array of algorithms the user might envision.  Unfortunately computational generality is not one of PBD's strengths.  Halbert recognized this when implementing SmallStar and concluded that control structures were better created by editing a static representation of the program than by demonstration [Halbert 84].  Others have used inference to generalize straight-line demonstrations into procedures with control structures.  Cypher's Eager and Myers' Peridot used domain knowledge to infer procedures with control structures solely from straight-line demonstrations [EAGER CHAPTER, PERIDOT CHAPTER].  The computational generality of these systems, however, was limited by limited domain knowledge.\nSolution directions  In order for a PBD to be used for just-in-time programming, it will have to be integrated with other techniques to give full computational generality.  Interesting directions include giving separate examples for each path of the algorithm as in Tinker [TINKER CHAPTER], or a combination of multiple demonstrations, inferencing, and special instructions from the user as in Metamouse [METAMOUSE CHAPTER].\nEffort of invoking algorithm\nAs stated previously, the effort to enter an algorithm is less of an obstacle when the benefits of automating are large.  So for the sake of argument, assume that I knew there would be hundreds of lines needing to be transformed and decided to automate the task using C.  Limited computational generality would not be an obstacle with C.  Are there other obstacles?\nWhen the compiler detected an error in my software project, it would load the file containing the error into its text editor and highlight the erroneous line.  To take advantage of the line transformation program, I would first have to judge if it was one of the simple type mismatch errors that could be fixed by the simple line transformation.  If so, I would then invoke the C implementation on the specific line.  But how would I do that?  One possibility would be to mark the line some special way, perhaps by placing a \"*\" at the beginning of the line, and then save the file out to disk.  Then I could run the C program which would then prompt me for the name of the file with the incorrect line.  The C program would then scan through the file for a line that started with a \"*\" and apply the transformation to it.  But this would be silly.  The effort to invoke the algorithm would undermine the benefits and would be yet another obstacle to automating this subtask.\nDiscussion  As in this case, a subtask appropriate for just-in-time programming typically applies to part of a larger document.  Thus, users must be able to implement the algorithm such that they can specify which part of the document should be processed when they invoke the algorithm.  It is important that they be able to do this with ease because the benefits to be obtained by automating can be easily negated by the invocation effort.  Unlike the effort to enter the algorithm, the effort to invoke the algorithm can not be amortized over the life of the new beneficial automation.  The effort must be small in comparison with the benefit received from each invocation of the algorithm.  When the payoffs per invocation are larger this obstacle is not as crucial, but enough opportunities for modest benefits exist that it is important to reduce the effort required to invoke algorithms implemented just in time.\nFor an example of how crucial the ease of invocation can be towards making automation beneficial, consider the feature on many word processors that allows a user to select a word simply by double clicking on it.  The word processor automatically does the tedious subtask of extending the selection out to the word boundaries.  Identifying these word boundaries manually is a simple subtask, so not much benefit is received each time the feature is used.  However, words are selected so commonly that, over time, the feature is very beneficial.  Another invocation strategy could easily undermine this benefit.  For example, even requiring the user to click on the word and then select the feature from a pull down menu could require too much effort.\nAs the previous example implies, this obstacle is not unique to just-in-time programming.  Because the effort to invoke the algorithm can not be amortized, any programming endeavor that produces interactive software needs to pay special attention to this obstacle.  The main difference for just-in-time programming is that the user can not amortize the effort to create the invocation scheme as much.\nSolution directions  How should just-in-time programming make it easy to invoke algorithms?  One clue is strongly implied by the hypothetical consideration of C for automating the line transformation subtask:  users should be able to implement their algorithms such that they can perform the subtask without having to save their documents to disk.  Instead their algorithms should be able to process data in its present form which is usually internal to some application.  Thus just-in-time programming systems should allow users to process data within their applications.  In addition, users should be able to use the application's data selection mechanisms to indicate what part of their document to process.  This would enable users to work manually, apply a newly implemented algorithm to the data, and continue to work manually without the overhead of saving the data to a file. Processing data within applications is central to PBD, so it already goes far to easing the effort to invoke the algorithm.\nBeyond automating within applications, just-in-time programming systems should allow the user to choose among various invocation strategies.  Standard invocations such as menu selections and keypresses should be supported.  The ability to create more refined invocations, like double clicking on a an object to apply some automation to it, would be important for making some highly interactive automation worth creating.  PBD techniques could possibly be used to have the fact that the user has started doing the subtask be what triggers the automation to be invoked.  David Maulsby's Turvy and Metamouse give hints of how this might work [TURVY CHAPTER, METAMOUSE CHAPTER].\nInaccessible data and operators\nSo far we have seen several reasons to want to process data while it resides within an application.  One is to make algorithms easier to enter by allowing the user to demonstration the algorithm through the user interface of the application.  Another is that invocations can be made easier if the data is processed within the application.  The Quickeys solution in figure 4 had these advantages, but it only partially automated the subtask.  No other programming system on my computer (including APL, C, Lisp, Scheme, or HyperTalk) can automate within Think C's editor because of the fourth obstacle, inaccessible data and operators.  In this case, this obstacle undermines the modest benefits of automating the subtask.  If the benefits per invocation were greater, then accessing the data independently of the application by saving the document to a file might have made creating the new automation worthwhile.\nIn other cases, limited data access can take the simplest algorithms and render them impossible to implement.  Consider the example discussed in [TRIGGERS CHAPTER REFERENCE] of automating the wrapping of a text field with a properly sized rounded rectangle.  The algorithm to automate this task is trivial when stated in terms of the text field's and the rounded rectangle's properties of location, length and width.  The central part of the algorithm is to set the rounded rectangle's location a bit above and to the left of the text field's location, and set the rounded rectangle's length and width to be a bit larger.  Automating this task independently of MacDraw II would involve extracting these properties from MacDraw II's coded file format, which would be very difficult.  Also, the user's algorithm may be based on special functionality provided by the application such as, in this case, the ability to create rounded rectangles.  Just-in-time programming systems should therefore be able to access properties from applications and invoke the operators provided by applications.\nSometimes an opportunity for new beneficial automation involves not so much the processing of data, but rather the repetitive manipulation of an application's user interface artifacts.  For example, the user may wish to automate the toggling between two window arrangements.  The only way a programming system can automate this is to access the state of the user interface and manipulate its components.\nDiscussion  Inaccessible data and operators is a particularly common obstacle for just-in-time programming because users must make do with whatever form their data is in when they envision the algorithm.  Usually this data exists within an application.  In contrast, task-time independent programming often allows the user to plan what form the data will be in when the automation is eventually used.  Many programming efforts, like games or educational software, are closed systems where the programmer can choose the format of the data to be whatever makes their programming effort easiest.\nSolution directions  In order for a programming system to access the data and operators of an application, there must be a communication protocol that both the programming system and the application follow.  One way to effect this protocol is to build the programming system into the application.  This strategy, however, limits the data access to the one application, so inaccessible data and operators would still be an obstacle when the user's algorithm involved multiple applications.  Therefore just-in-time programming systems should make use of specially established interapplication protocols like Apple Events [Apple 91].\nSometimes programming systems can overcome the inaccessible data and operators obstacle by using protocols established for reasons other than interapplication communication.  For example, the Quickeys solution uses the computer's keyboard input stream as a protocol to process data in the editor application.  The Triggers chapter discusses an extension to this technique where pixel data from the computer display can be used to gain a significant degree data access from any application.  PBD plays a large role in making this extension possible because the algorithms implemented using these techniques sometimes contain large bitmap constants.  Entering these bitmaps would be unwieldy if they could not be specified by demonstration.\nRisk\nThe fifth obstacle is the risk that the automation will fail, be ineffective, or produce unintended results.  Consider the risks of automating the line transformation subtask.  There are many possible scenarios.  In the best case the algorithm could have been entered almost effortlessly, and as each occurrence of a line needing the simple transformation was flagged by the compiler, I could have easily invoked the algorithm somehow.  To my surprise, perhaps more chances to use the new automation occurred than were anticipated, making the automation pay off more than expected.\nBut there are many other possible scenarios.  The algorithm could have taken a long time to enter, perhaps because some special purpose function had to be looked up in a manual.  A mistake in the implementation might have caused the new (not beneficial) automation to destroy part of the source file, perhaps too quickly to be noticed.  Limited data access could have turned the simple algorithm into one that was impossible to implement.  I was not sure exactly how many more assignments of 32-bit rectangles to 16-bit rectangles were left in my software project, and thus there may have been too few to make the programming effort worthwhile.  Unforeseen special cases may have made the envisioned algorithm simply wrong.\nA user who is considering a just-in-time programming effort has the option of continuing to work manually.  Given the many adverse scenarios, it is not surprising that the user would choose this option.  Thus just-in-time programming systems often fail because the user chooses not to use it.\nRisk was the main reason I chose not to automate the line transformation subtask.  The partial solution using keyboard macros was the only one worth considering because it was the only solution that did not require saving the file to disk.  In the past, my attempts to use keyboard macros have often been thwarted by unforeseen special cases, the difficulty of accommodating special cases into an already existing macro, and the uncontrollable speed of macros that make it difficult to verify that the macro works correctly.  In retrospect, a keyboard macro would have been worthwhile and would have prevented a few recompiles caused by typos in my manual transforming of the lines.  However at the time, the apparent risks convinced me to play it safe and transform the lines manually.\nDiscussion  Certainly all programming involves risk.  The risks of just-in-time programming are notable on two accounts.  One is that the time and effort spent implementing the algorithm relate directly to the success of the venture.  For example, any extra time or frustration involved in automating the line transformation subtask would have quickly eliminated the potential benefits.  In contrast, task-time independent programming efforts often relate only indirectly to success.  For example, say a user is programming an animated demo for a five-minute presentation.  If the demo take two hours longer to implement than expected, the presentation the next day can still be a success.\nBut the main reason risk affects just-in-time programming so strongly is that it is easy for users to choose to continue to work manually and avoid the risk.  In contrast, essential programming requires users to make the best of what their programming systems have to offer.  Users still have to assume whatever risks are present, but the programming system will not fail for lack of use.\nRisk is caused, in part, by the users' uncertainty about how the other four obstacles will affect their attempts to automate.  Thus, one way to reduce the risk is to work towards eliminating these four obstacles.  For example, if entering the algorithm were effortless, there would be no risk in taking that step.  Unfortunately, entirely eliminating these obstacles is very unlikely.  In addition, users will still have to assume the risk that their algorithms might not do as expected.  Thus, it is important to explicitly consider techniques that reduce the risks of just-in-time programming.\nSolution directions  One approach to addressing risk is to make it so that the user can accurately judge the effort required to implement the algorithm and accurately judge the benefits.  Simplicity and visibility are two attributes of a programming system that would contribute to this approach.  When users can confidently judge the benefits will be greater then the efforts, then they can proceed to profit from using the just-in-time programming system and the system will not fail from lack of use.  The limitation of this approach is that merely judging the risks is a risk in itself because the user must expend some mental effort.  Because it is unlikely that this effort can be eliminated entirely, the user will have good reason to simply continue working the task manually without ever giving the opportunity to use just-in-time programming a second thought.  Other techniques need to be considered.\nAnother approach to reducing risk is to enable users to profit from partial implementations of their algorithms.  This would help alleviate the risk that an obstacle might prevent the implementing of part of the algorithm, render the whole algorithm useless, and waste any effort already expended.  Users should be able to implement and profit from parts of their algorithms without requiring the entire algorithm to work flawlessly.\nFor example, assume a user has 20 book chapters saved as a separate MacWrite II files in a folder, and that a colleague requests a pure ASCII copy of each chapter.  To manually convert each chapter to pure ASCII, the user would have to load its file into the MacWrite II, select the Text Only option, and save it back out to disk using a different file name.  Assume files with the word \"backup\" in the file name should not be converted.  The simple algorithm in figure 5 could select all 20 chapters in turn and carry out these repetitive actions.  If the user were able to implement this algorithm, the tedium of keeping track of which files have been converted and the tedium of the repetitive actions would be avoided.\nFigure 5:  An algorithm that will convert a folder full of MacWrite II files to pure ASCII.\n\nIf the entire algorithm could be implemented confidently, easily, and flawlessly, then risk would not be an issue.  Unfortunately, any step in the algorithm could cause potential problems.  What if after putting some effort into the algorithm, the user discovers that only a subset of the nine steps can be implemented?  For example, what if step number 7 could not be implemented because the user's programming system could not invoke the operator that selects the Text Only operator?  The partial implementation can still potentially be beneficial if the user can manually do the steps that prove difficult to implement.  For example, the algorithm could invoke the \"Save As...\" dialog box and pause while the user selects Text Only manually.  The partial implementation would still be beneficial because it would take care of the tedium of keeping track of which files have been converted and a great majority of the other actions.\nFor step number 7, this strategy is easy to imagine because the application's existing user interface can allow the user to carry out the hard to implement action manually.  But what if step number 2 is too difficult to implement because the user's programming system has no built-in test for substrings?  In this case the list is in the programming system's execution environment, not the application.  If the user is to manually accomplish this step, the programming system must have an existing user interface that allows the user to manipulate the execution environment.  Some interactive programming systems and debuggers allow users to modify the execution environment during run-time, but few allow data to be manipulated easily enough for the user to do real work.  Also, the more that control has to pass between the user and their implementation, the more essential it will be that flexible invocation schemes are possible.\nEssentially the user's risk is that the manual method might be more effective than implementing the algorithm.  Therefore, another approach to addressing risk is to allow the user to pursue both alternatives in parallel.  In theory, the risk of attempting to automate the subtask would be eliminated because if unforeseen difficulties make the programming effort ineffective, then the user can fall back on the manual method already underway.\nIn practice, this approach would probably not eliminate risk, but it could reduce risk greatly.  PBD could play a large part in realizing this approach because it allows the user to implement algorithms by demonstrating on their actual task data.  In other words, the user can be programming and manually accomplishing the subtask simultaneously.  For example, recording the keyboard in figure 4 actually transforms one of the lines, so progress towards completing the overall task is hindered minimally.\nThis technique has its greatest potential when mixed with history based techniques.  For example, Allen Cypher's system Eager records the user's actions into an event history [EAGER CHAPTER].  When Eager detects the user doing repetitive actions, it indicates this to the user by highlighting what it expects the user to select next.  For certain classes of algorithms, the user can implement an algorithm at almost no risk because the user takes no special actions.  The decision of whether to invoke the algorithm still involves some risk because the exact behavior of some algorithms is difficult to predict.  Therefore additional techniques such as undo and slow motion execution will have to be extended and refined.\n\nConclusion\nIs creating a programming system that is effective for just-in-time programming an interesting research problem? The previous sections clearly show that it has not been solved already, so it meets this criterion.  A second criterion for interesting research is that there be some indication that solutions are possible.  The previous section touched on several promising research directions, many of which are based on PBD.  A third, important criterion for interesting research is that it lead to tangible benefits.  The benefits of improved just-in-time programming systems would be to allow users to better automate repetitive subtasks that arise from their unique circumstances.  The line transformation subtask was one such example where automation would have led to significant benefit.  There will always be subtasks like this that slip through the prepackaged functionality of applications because they result from the interactions of users with the complexities of the real world.  Task-time is often the only possible time to implement the algorithms that can automate these subtasks.\nBut is it necessary to focus the research problem on such a narrow slice of programming to make automating these subtasks practical?  After all, many of the obstacles facing just-in-time programming also affect other types of programming;  it is possible that researching other types of programming will produce effective just-in-time programming systems as a side effect.  Are there reasons for researching just-in-time programming specifically?\nOne reason is that a user must accomplish all of the following during task-time: assess risk, enter the algorithm, design the invocation scheme, solve data access problems, invoke the algorithm, verify correct program behavior, and resume work on the overlying task.  Thus it is crucial that techniques that support these activities be refined to a degree that other forms of research are unlikely to achieve.  For example, research that concentrates on programming-in-the-large is unlikely to adequately reduce the effort required to input the algorithm when managing program complexity is its overriding concern.  Research that assumes essential programming is unlikely consider techniques that reduce risk by enabling productive use of partially debugged programs.  Research that assumes task-time independent programming is unlikely to recognize that programming may not be the user's primary concern.  Thus it is unlikely to give adequate emphasis to minimizing distractions from the user's primary task.  It is also unlikely to motivate data and operator access that is flexible enough to process the user's data wherever it may be when the opportunity to apply just-in-time programming arises.\nAnother reason is there are solutions that are appropriate for just-in-time programming but are not necessarily appropriate for other types of programming.  For example, the pixel based techniques of Triggers [TRIGGERS CHAPTER] would not be appropriate for software that must run in the background.  The technique of programming and accomplishing the task at the same time discussed in the risk section does not make sense for programmers who are writing software for other people's use.\nBy recognizing the special nature of just-in-time programming and by addressing the limitations of current programming systems head-on, much research progress should result.  The five obstacles provide a set of subproblems that can be used to focus multiple avenues of research.  Researchers should be careful not to accentuate one obstacle in the elimination of another; it only takes one to prevent a just-in-time programming system from being effective.  It is crucial that a just-in-time programming system address risk because it is probably impossible to create a programming system where the user's every attempt at creating new automation will be profitable.  The goal should be to create a programming system where a user can know that in the worse case attempting just-in-time programming will not hinder progress towards completing the task.  Then the user will be able to confidently use the full extent of the programming system to profit from their algorithmic insights.\n\nReferences for Alan\n\n[Apple 91] Apple Computer, Inc., <Inside Macintosh, Volume VI> Addison Wesley, Reading, Massachusetts, 1991.\n\n[Cypher 86] Cypher A., \"The Structure of Users' Activities,\" <User Centered Design>, Lawrence Erlbaum Associates, Hillsdale, New Jersey, 1986.\n\n[Halbert 84] Halbert D., \"Programming by Example,\" Ph.D. Thesis, Department of Computer Science, University of California at Berkeley , 1984.\n"
      },
      "after": "26fe073b834e8522",
      "date": 1641329023361
    },
    {
      "type": "edit",
      "id": "5745e710a3f02563",
      "item": {
        "type": "markdown",
        "id": "5745e710a3f02563",
        "text": "Just-in-time programming is the implementing of algorithms during task-time (i.e. the time when the user is actually trying to accomplish the task to be automated) and can be characterized by a situation with the following components:\n* a computer user who could be either a novice user or an experienced programmer,\n* a task that the user is manually accomplishing and completion of which is the user's primary goal,\n* an algorithm that will accomplish a subtask (i.e. part of the task) and that the user envisioned while working on the task,\n* and an attempt by the user to implement the algorithm for the purpose of more effectively completing the task.\n\n"
      },
      "date": 1641329060728
    },
    {
      "type": "add",
      "id": "b67f51d14ea929c3",
      "item": {
        "type": "markdown",
        "id": "b67f51d14ea929c3",
        "text": "In short, the goal of just-in-time programming is to allow users to profit from their task-time algorithmic insights by programming.  Instead of automating with software that was carefully designed and implemented much earlier, the user recognizes an algorithm and then creates the software to take advantage of it just before it is needed, hence implementing it just in time.\n\n"
      },
      "after": "5745e710a3f02563",
      "date": 1641329091193
    },
    {
      "type": "add",
      "id": "921ea177f259d957",
      "item": {
        "type": "markdown",
        "id": "921ea177f259d957",
        "text": "It is worth emphasizing that the user's task could be from any domain (e.g. graphic drawing, scientific visualization, word processing, etc.) and that the algorithm to be implemented originates with the user.  Obviously, a user with more programming experience will be able to envision a more complex algorithm than a novice user.  How the user comes up with the algorithm is not a concern.  Also, no hint of a solution appears in the problem statement.  Any programming system could conceivably be used for just-in-time programming, including C, PASCAL, keyboard macros, scripting languages, or PBD. PBD will probably be an important part of the more successful just-in-time programming systems, but the problem statement leaves open the possibility for other solutions.\nJust-in-time programming research shares many of the motivations of other PBD research.  Chief among these is that users often do repetitive or algorithmic subtasks that the computer could be doing.  We call these subtasks potential computer subtasks and call these situations opportunities for new beneficial automation.  Because automating can increase productivity and user satisfaction and at the same time reduce errors, one would expect the user to delegate potential computer subtasks to the computer.  That users often do not take advantage of these opportunities motivates researching ways to improve the computer.  Just-in-time programming research and PBD research assert that easier to use programming tools will allow users to better take advantage of opportunities for new beneficial automation.\nJust-in-time programming research, however, is focused on making programming easier for a specific cross section of situations.  These situations are primarily defined by the user programming during task-time.  In other words, the user is attempting to write a program for a task that is already in progress.  Figure 1 summarizes the relationship between task progress and the user's expenditure of effort.  The expenditure of effort for just-in-time programming is shown separate from the other task related effort.  The difficulty of just-in-time programming results from the spreading of the user's mental resources between two activities.  Another difficulty is that the time spent programming contributes directly to total time between the start and completion of the task.\nFigure 1:  Just-in-time programming intermixes programming effort with other task related effort.\n\n\nWhat is not Just-in-time Programming?\nOne might contrast just-in-time programming with, for lack of a better term, task-time independent programming which is summarized in figure 2.  For an example, consider a user who is programming a HyperCard mock-up of a user interface in preparation for a demonstration the next day.  The subtask of the software is to help an audience visualize a proposed user interface design during the meeting.  This example would be task-time independent programming because the software is created well before the meeting.  As is the case with many distinctions, there are examples that straddle the line between just-in-time programming and task-time independent programming, but the discussions that follow should hold regardless.\nFigure 2:  Task-time independent programming separates programming effort from other task-related effort.\n\nJust-in-time programming can be contrasted with other forms of programming by considering implications of the situation characterized in the introduction.  For example, since the algorithm to be implemented is the product of the user's insight, it is typically simple.  Thus one could contrast just-in-time programming with programming-in-the-large.  For an example, developing a full featured word processor would not be just-in-time programming because an algorithm that implements all the features of a word processor is too complex for one person to envision.\nAnother implication of the situation characterized in the introduction is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\nHow does just-in-time programming relate to the more common PBD application of programming for novice programmers? These two types of programming are basically independent;  programming in a given situation could represent both, one, or neither of these.  A novice programmer writing a short program that changes all numbers in a document to a larger font would be an example of both types of programming, assuming the user was about to make the modifications by hand.  A novice programmer writing educational software to be used by students at a later time would be an example of a novice programmer programming, but not just-in-time programming.  I recently modified a postscript file to only print out the even pages of the document and then the odd pages so that it would print on both sides of the paper without requiring me to issue a separate print command for each page.  This would be an example of just-in-time programming that was not programming for the novice.\n\nA Subtask Suitable for Just-in-Time Programming\nI happened upon an opportunity for just-in-time programming when Think C updated their class library to version 1.1.  Before version 1.1, rectangles were defined with 16-bit coordinates and in version 1.1 rectangles were defined by 32-bit coordinates.  When I first compiled my software project with the new class library, type mismatch errors occurred where my software expected 16-bit values.  Many of these were simple assignment statements.  The new class library included a utility function for converting 32-bit rectangles to 16-bit rectangles, so a typical fix involved changing a line of the form *inset=frame; to the form longToQDRect(&frame,inset);. Various other types of errors were found and fixed as well.  The second time an assignment of a 32-bit rectangle to a 16-bit rectangle caused an error, I recalled that there were many such assignments throughout my program and concluded I would, in time, be transforming many lines from assignment statements into function calls. Each would differ only in the names of the variables and whether each variable was a pointer or not (i.e. preceded by a \"*\").  For the rest of this paper, transforming one of these lines will be called the line transformation subtask.\nTo attempt to automate this subtask would have been just-in-time programming because of the situation.  This particular example also contrasts well with the other types of programming discussed above.  It would certainly not be task-time independent programming because I was in the midst of modifying my software project.  The subtask was algorithmically simple so it was not programming-in-the-large.  Automating the subtask was not essential, so it was not essential programming.\nSo to break this situation down into the components of just-in-time programming:\nThe user: \nmyself\nThe task: \nmodifying a software project to work with an updated class library\nThe subtask: \nchanging certain lines of source code from the form {*}var1 = {*}var2; to the form longToQDRect({&}var2,{&}var1); (i.e. the line transformation subtask)\nThe algorithm: \ninsert leading white space\ninsert \"longToQDRect(\"\nif second variable name is not preceded by \"*\", insert \"&\"\ninsert second variable name\ninsert \",\"\nif first variable name is not preceded by \"*\", insert \"&\"\ninsert first variable name\ninsert \")\"\ninsert rest of line (the \";\" and comments, if any)\ndelete original line.\nThe attempt to automate:  \nActually I did not try to automate the subtask.  The rest of the chapter will explain why.\n\nFive Obstacles\nOne reason to explicitly state a problem is so that it can be broken down into meaningful subproblems.  One way to do this is to analyze current technology, identify common obstacles that prevent the technology from being effective, and let the subproblems be to find ways to eliminate these obstacles.  The following sections discuss five obstacles that often prevent users of current programming systems from profiting from their algorithmic insights.  Each section also discusses PBD's potential role in solving the subproblem represented by each obstacle.\n\t\nFigure 3:  A C algorithm that automates the line transformation subtask assuming the line has been isolated in a character buffer.\n\nEffort of entering the algorithm\nGiven that I understood the algorithmic structure of the line transformation subtask, why not automate it?  Since I was actually using a C programming system, let's first explore the possibility of using it.  Figure 3 shows a program in C that can transform the line as needed, assuming that the line has been loaded into a string (we will deal with this assumption more later).  One obstacle quickly becomes apparent: the effort of entering the algorithm.  Merely the physical effort of typing in the 749 characters of this program would likely undermine the benefits of automating this small part of the task.  But there is also the mental effort required to translate the algorithm into the idioms of the language and to work out the fine details.  For example, after years of programming in C, I still must look up the strcat function in the manual to see if it copies from the first argument to the second or vice versa.\nDiscussion  No matter what type of programming is being done, reducing this effort is desirable.  However, the effort of entering an algorithm is particularly important for just-in-time programming because the subtasks appropriate for just-in-time programming are typically special purpose needs that can not be as widely applied as functionality that is more generic.  The line transformation task is a good example of this because once I finished updating the software project, I had no need for this particular functionality.  When the benefits per programming effort are modest, only minimal effort can be expended towards entering the algorithm before the venture becomes pointless.  If the user's task is creative or involves problem solving, then the user can scarcely afford to expend mental effort for modest gains.  Of course, there are times when the payoffs of just-in-time programming are large enough that the effort to enter the algorithm is not as crucial.  But there are enough opportunities for modest payoffs that finding ways to reduce the effort required to enter the algorithm is an important subproblem to solve.\nSometimes creating new beneficial automation by programming pays off because the user can apply the automation many times in the future.  A script that automatically dials a remote computer and logs the user into their account would be a good example.  Here the distinction between just-in-time programming and task-time independent programming is blurred.  Strictly speaking, the programming effort is expended at a time independent of when the benefits of the automation are received.  However, the user is likely to automate this task at a time when they are about to dial in to the remote computer manually, that is, when the desirability of automating the subtask comes to mind.  So although the user could set aside some time and do task-time independent programming, psychologically the task-time aspects of whatever the user is doing are likely to impact the programming process.  In this sense, much of the special concerns of just-in-time programming still hold.\nReducing this effort is less important for programming-in-the-large because the effort required to manage the complexity of a large software project tends to overshadow the effort required to enter the algorithm.  In fact, programming languages such as Ada even increase the effort of entering the algorithm by requiring extra notation for modularizing the code.  Such notation does not contribute directly to functionality, but is appropriate for programming-in-the-large because complexity is such an overriding concern.\nJust-in-time programming accentuates the mental effort required to enter the algorithm because users must switch their mind-sets from the task domain to the programming domain as illustrated in figure 1.  After the algorithm has been implemented, users must also expend effort to return their mind-sets to the task domain.  Users might expend effort trying not to divert too much attention to the programming effort, sometimes trying to keep more in their short term memory than is reasonable.  For creative tasks, this diversion is especially costly.  In contrast, users who are programming independently of task time can change their mind-set over a longer period of time.\nTherefore when minimizing the effort of entering the algorithm, it is important to minimize distraction from the task.  One of the main sources of effort and distraction is the number of special programming concepts.  For example, writing the C algorithm in figure 3 required remembering how strings are allocated and referenced.  On this point, just-in-time programming and programming for novice programmers share similar goals because a programming system for novice programmers should require the understanding of as few new concepts as possible.  In cases where a just-in-time programming system is being designed specifically for novice programmers, the same would apply.\nThe idea of just-in-time programming, however, is not limited to novice programmers.  For expert programmers, whether a concept is familiar to a nonprogrammer is not the crucial factor.  Instead, the programming system should require the user to understand only concepts that can be ingrained and that the user can apply fluently.  Therefore, part of the research agenda of just-in-time programming should be to identify key skills that, if ingrained, will allow a user to more effectively write programs just in time.  These skills could be anything from something classic like regular expressions to some new esoteric programming paradigm.  It seems clear that, at least for the foreseeable future, users will have to understand the basic concepts of conditionals and iteration.\nSolution directions  Many techniques including code templates, code reuse, domain specific functionality, subroutines, copy/paste, and on-line documentation can help reduce the effort required to enter an algorithm.  PBD helps reduce this effort by allowing users to enter the algorithm using the same interface as they would normally use to work the subtask manually.  This helps reduce both the physical effort and the mental effort because the user is often well practiced at using this interface.  Since the user would use the same user interface to work the subtask manually, the artifacts are already in short term memory and programming with them is likely to be less distracting than with an off-line programming language.  The effort to enter the algorithm is also reduced because user interfaces are usually optimized to the task.\nFigure 4:  This Quickeys macro can partially automate the line transformation subtask.  The number of keystrokes required to enter the macro and the visual state of the editor are shown.\n\nFor a simple example of how PBD can reduce the effort of entering an algorithm, consider one partial solution to the line transformation subtask.  If the user first places the cursor to the left of the first variable in the line to be transformed and neither variable is a pointer, then the Quickeys macro shown in figure 4 will transform the line as required.  The macro also assumes that exactly three characters (\" = \") separate the two variable names.  Only the 33 keypresses shown in figure 4 are required to implement the macro.  The visual feedback of the editor also helps reduce the mental effort by showing intermediate results.\nLimited computational generality\nWhy illustrate the virtues of the keyboard macro by only partially automating the line transformation subtask?  The reason is that the subtask requires conditional logic to decide whether each variable is a pointer or not.  Keyboard macros only record straight-line algorithms and thus are not able to fully automate this subtask.  This illustrates an obstacle that users face when programming just in time:  the programming systems that make it easy to enter their algorithm can often only implement algorithms of limited computational generality.\nDiscussion  It is important for a just-in-time programming system to have full Turing-complete computational generality because there is no way to predict which of the vast array of algorithms the user might envision.  Unfortunately computational generality is not one of PBD's strengths.  Halbert recognized this when implementing SmallStar and concluded that control structures were better created by editing a static representation of the program than by demonstration [Halbert 84].  Others have used inference to generalize straight-line demonstrations into procedures with control structures.  Cypher's Eager and Myers' Peridot used domain knowledge to infer procedures with control structures solely from straight-line demonstrations [EAGER CHAPTER, PERIDOT CHAPTER].  The computational generality of these systems, however, was limited by limited domain knowledge.\nSolution directions  In order for a PBD to be used for just-in-time programming, it will have to be integrated with other techniques to give full computational generality.  Interesting directions include giving separate examples for each path of the algorithm as in Tinker [TINKER CHAPTER], or a combination of multiple demonstrations, inferencing, and special instructions from the user as in Metamouse [METAMOUSE CHAPTER].\nEffort of invoking algorithm\nAs stated previously, the effort to enter an algorithm is less of an obstacle when the benefits of automating are large.  So for the sake of argument, assume that I knew there would be hundreds of lines needing to be transformed and decided to automate the task using C.  Limited computational generality would not be an obstacle with C.  Are there other obstacles?\nWhen the compiler detected an error in my software project, it would load the file containing the error into its text editor and highlight the erroneous line.  To take advantage of the line transformation program, I would first have to judge if it was one of the simple type mismatch errors that could be fixed by the simple line transformation.  If so, I would then invoke the C implementation on the specific line.  But how would I do that?  One possibility would be to mark the line some special way, perhaps by placing a \"*\" at the beginning of the line, and then save the file out to disk.  Then I could run the C program which would then prompt me for the name of the file with the incorrect line.  The C program would then scan through the file for a line that started with a \"*\" and apply the transformation to it.  But this would be silly.  The effort to invoke the algorithm would undermine the benefits and would be yet another obstacle to automating this subtask.\nDiscussion  As in this case, a subtask appropriate for just-in-time programming typically applies to part of a larger document.  Thus, users must be able to implement the algorithm such that they can specify which part of the document should be processed when they invoke the algorithm.  It is important that they be able to do this with ease because the benefits to be obtained by automating can be easily negated by the invocation effort.  Unlike the effort to enter the algorithm, the effort to invoke the algorithm can not be amortized over the life of the new beneficial automation.  The effort must be small in comparison with the benefit received from each invocation of the algorithm.  When the payoffs per invocation are larger this obstacle is not as crucial, but enough opportunities for modest benefits exist that it is important to reduce the effort required to invoke algorithms implemented just in time.\nFor an example of how crucial the ease of invocation can be towards making automation beneficial, consider the feature on many word processors that allows a user to select a word simply by double clicking on it.  The word processor automatically does the tedious subtask of extending the selection out to the word boundaries.  Identifying these word boundaries manually is a simple subtask, so not much benefit is received each time the feature is used.  However, words are selected so commonly that, over time, the feature is very beneficial.  Another invocation strategy could easily undermine this benefit.  For example, even requiring the user to click on the word and then select the feature from a pull down menu could require too much effort.\nAs the previous example implies, this obstacle is not unique to just-in-time programming.  Because the effort to invoke the algorithm can not be amortized, any programming endeavor that produces interactive software needs to pay special attention to this obstacle.  The main difference for just-in-time programming is that the user can not amortize the effort to create the invocation scheme as much.\nSolution directions  How should just-in-time programming make it easy to invoke algorithms?  One clue is strongly implied by the hypothetical consideration of C for automating the line transformation subtask:  users should be able to implement their algorithms such that they can perform the subtask without having to save their documents to disk.  Instead their algorithms should be able to process data in its present form which is usually internal to some application.  Thus just-in-time programming systems should allow users to process data within their applications.  In addition, users should be able to use the application's data selection mechanisms to indicate what part of their document to process.  This would enable users to work manually, apply a newly implemented algorithm to the data, and continue to work manually without the overhead of saving the data to a file. Processing data within applications is central to PBD, so it already goes far to easing the effort to invoke the algorithm.\nBeyond automating within applications, just-in-time programming systems should allow the user to choose among various invocation strategies.  Standard invocations such as menu selections and keypresses should be supported.  The ability to create more refined invocations, like double clicking on a an object to apply some automation to it, would be important for making some highly interactive automation worth creating.  PBD techniques could possibly be used to have the fact that the user has started doing the subtask be what triggers the automation to be invoked.  David Maulsby's Turvy and Metamouse give hints of how this might work [TURVY CHAPTER, METAMOUSE CHAPTER].\nInaccessible data and operators\nSo far we have seen several reasons to want to process data while it resides within an application.  One is to make algorithms easier to enter by allowing the user to demonstration the algorithm through the user interface of the application.  Another is that invocations can be made easier if the data is processed within the application.  The Quickeys solution in figure 4 had these advantages, but it only partially automated the subtask.  No other programming system on my computer (including APL, C, Lisp, Scheme, or HyperTalk) can automate within Think C's editor because of the fourth obstacle, inaccessible data and operators.  In this case, this obstacle undermines the modest benefits of automating the subtask.  If the benefits per invocation were greater, then accessing the data independently of the application by saving the document to a file might have made creating the new automation worthwhile.\nIn other cases, limited data access can take the simplest algorithms and render them impossible to implement.  Consider the example discussed in [TRIGGERS CHAPTER REFERENCE] of automating the wrapping of a text field with a properly sized rounded rectangle.  The algorithm to automate this task is trivial when stated in terms of the text field's and the rounded rectangle's properties of location, length and width.  The central part of the algorithm is to set the rounded rectangle's location a bit above and to the left of the text field's location, and set the rounded rectangle's length and width to be a bit larger.  Automating this task independently of MacDraw II would involve extracting these properties from MacDraw II's coded file format, which would be very difficult.  Also, the user's algorithm may be based on special functionality provided by the application such as, in this case, the ability to create rounded rectangles.  Just-in-time programming systems should therefore be able to access properties from applications and invoke the operators provided by applications.\nSometimes an opportunity for new beneficial automation involves not so much the processing of data, but rather the repetitive manipulation of an application's user interface artifacts.  For example, the user may wish to automate the toggling between two window arrangements.  The only way a programming system can automate this is to access the state of the user interface and manipulate its components.\nDiscussion  Inaccessible data and operators is a particularly common obstacle for just-in-time programming because users must make do with whatever form their data is in when they envision the algorithm.  Usually this data exists within an application.  In contrast, task-time independent programming often allows the user to plan what form the data will be in when the automation is eventually used.  Many programming efforts, like games or educational software, are closed systems where the programmer can choose the format of the data to be whatever makes their programming effort easiest.\nSolution directions  In order for a programming system to access the data and operators of an application, there must be a communication protocol that both the programming system and the application follow.  One way to effect this protocol is to build the programming system into the application.  This strategy, however, limits the data access to the one application, so inaccessible data and operators would still be an obstacle when the user's algorithm involved multiple applications.  Therefore just-in-time programming systems should make use of specially established interapplication protocols like Apple Events [Apple 91].\nSometimes programming systems can overcome the inaccessible data and operators obstacle by using protocols established for reasons other than interapplication communication.  For example, the Quickeys solution uses the computer's keyboard input stream as a protocol to process data in the editor application.  The Triggers chapter discusses an extension to this technique where pixel data from the computer display can be used to gain a significant degree data access from any application.  PBD plays a large role in making this extension possible because the algorithms implemented using these techniques sometimes contain large bitmap constants.  Entering these bitmaps would be unwieldy if they could not be specified by demonstration.\nRisk\nThe fifth obstacle is the risk that the automation will fail, be ineffective, or produce unintended results.  Consider the risks of automating the line transformation subtask.  There are many possible scenarios.  In the best case the algorithm could have been entered almost effortlessly, and as each occurrence of a line needing the simple transformation was flagged by the compiler, I could have easily invoked the algorithm somehow.  To my surprise, perhaps more chances to use the new automation occurred than were anticipated, making the automation pay off more than expected.\nBut there are many other possible scenarios.  The algorithm could have taken a long time to enter, perhaps because some special purpose function had to be looked up in a manual.  A mistake in the implementation might have caused the new (not beneficial) automation to destroy part of the source file, perhaps too quickly to be noticed.  Limited data access could have turned the simple algorithm into one that was impossible to implement.  I was not sure exactly how many more assignments of 32-bit rectangles to 16-bit rectangles were left in my software project, and thus there may have been too few to make the programming effort worthwhile.  Unforeseen special cases may have made the envisioned algorithm simply wrong.\nA user who is considering a just-in-time programming effort has the option of continuing to work manually.  Given the many adverse scenarios, it is not surprising that the user would choose this option.  Thus just-in-time programming systems often fail because the user chooses not to use it.\nRisk was the main reason I chose not to automate the line transformation subtask.  The partial solution using keyboard macros was the only one worth considering because it was the only solution that did not require saving the file to disk.  In the past, my attempts to use keyboard macros have often been thwarted by unforeseen special cases, the difficulty of accommodating special cases into an already existing macro, and the uncontrollable speed of macros that make it difficult to verify that the macro works correctly.  In retrospect, a keyboard macro would have been worthwhile and would have prevented a few recompiles caused by typos in my manual transforming of the lines.  However at the time, the apparent risks convinced me to play it safe and transform the lines manually.\nDiscussion  Certainly all programming involves risk.  The risks of just-in-time programming are notable on two accounts.  One is that the time and effort spent implementing the algorithm relate directly to the success of the venture.  For example, any extra time or frustration involved in automating the line transformation subtask would have quickly eliminated the potential benefits.  In contrast, task-time independent programming efforts often relate only indirectly to success.  For example, say a user is programming an animated demo for a five-minute presentation.  If the demo take two hours longer to implement than expected, the presentation the next day can still be a success.\nBut the main reason risk affects just-in-time programming so strongly is that it is easy for users to choose to continue to work manually and avoid the risk.  In contrast, essential programming requires users to make the best of what their programming systems have to offer.  Users still have to assume whatever risks are present, but the programming system will not fail for lack of use.\nRisk is caused, in part, by the users' uncertainty about how the other four obstacles will affect their attempts to automate.  Thus, one way to reduce the risk is to work towards eliminating these four obstacles.  For example, if entering the algorithm were effortless, there would be no risk in taking that step.  Unfortunately, entirely eliminating these obstacles is very unlikely.  In addition, users will still have to assume the risk that their algorithms might not do as expected.  Thus, it is important to explicitly consider techniques that reduce the risks of just-in-time programming.\nSolution directions  One approach to addressing risk is to make it so that the user can accurately judge the effort required to implement the algorithm and accurately judge the benefits.  Simplicity and visibility are two attributes of a programming system that would contribute to this approach.  When users can confidently judge the benefits will be greater then the efforts, then they can proceed to profit from using the just-in-time programming system and the system will not fail from lack of use.  The limitation of this approach is that merely judging the risks is a risk in itself because the user must expend some mental effort.  Because it is unlikely that this effort can be eliminated entirely, the user will have good reason to simply continue working the task manually without ever giving the opportunity to use just-in-time programming a second thought.  Other techniques need to be considered.\nAnother approach to reducing risk is to enable users to profit from partial implementations of their algorithms.  This would help alleviate the risk that an obstacle might prevent the implementing of part of the algorithm, render the whole algorithm useless, and waste any effort already expended.  Users should be able to implement and profit from parts of their algorithms without requiring the entire algorithm to work flawlessly.\nFor example, assume a user has 20 book chapters saved as a separate MacWrite II files in a folder, and that a colleague requests a pure ASCII copy of each chapter.  To manually convert each chapter to pure ASCII, the user would have to load its file into the MacWrite II, select the Text Only option, and save it back out to disk using a different file name.  Assume files with the word \"backup\" in the file name should not be converted.  The simple algorithm in figure 5 could select all 20 chapters in turn and carry out these repetitive actions.  If the user were able to implement this algorithm, the tedium of keeping track of which files have been converted and the tedium of the repetitive actions would be avoided.\nFigure 5:  An algorithm that will convert a folder full of MacWrite II files to pure ASCII.\n\nIf the entire algorithm could be implemented confidently, easily, and flawlessly, then risk would not be an issue.  Unfortunately, any step in the algorithm could cause potential problems.  What if after putting some effort into the algorithm, the user discovers that only a subset of the nine steps can be implemented?  For example, what if step number 7 could not be implemented because the user's programming system could not invoke the operator that selects the Text Only operator?  The partial implementation can still potentially be beneficial if the user can manually do the steps that prove difficult to implement.  For example, the algorithm could invoke the \"Save As...\" dialog box and pause while the user selects Text Only manually.  The partial implementation would still be beneficial because it would take care of the tedium of keeping track of which files have been converted and a great majority of the other actions.\nFor step number 7, this strategy is easy to imagine because the application's existing user interface can allow the user to carry out the hard to implement action manually.  But what if step number 2 is too difficult to implement because the user's programming system has no built-in test for substrings?  In this case the list is in the programming system's execution environment, not the application.  If the user is to manually accomplish this step, the programming system must have an existing user interface that allows the user to manipulate the execution environment.  Some interactive programming systems and debuggers allow users to modify the execution environment during run-time, but few allow data to be manipulated easily enough for the user to do real work.  Also, the more that control has to pass between the user and their implementation, the more essential it will be that flexible invocation schemes are possible.\nEssentially the user's risk is that the manual method might be more effective than implementing the algorithm.  Therefore, another approach to addressing risk is to allow the user to pursue both alternatives in parallel.  In theory, the risk of attempting to automate the subtask would be eliminated because if unforeseen difficulties make the programming effort ineffective, then the user can fall back on the manual method already underway.\nIn practice, this approach would probably not eliminate risk, but it could reduce risk greatly.  PBD could play a large part in realizing this approach because it allows the user to implement algorithms by demonstrating on their actual task data.  In other words, the user can be programming and manually accomplishing the subtask simultaneously.  For example, recording the keyboard in figure 4 actually transforms one of the lines, so progress towards completing the overall task is hindered minimally.\nThis technique has its greatest potential when mixed with history based techniques.  For example, Allen Cypher's system Eager records the user's actions into an event history [EAGER CHAPTER].  When Eager detects the user doing repetitive actions, it indicates this to the user by highlighting what it expects the user to select next.  For certain classes of algorithms, the user can implement an algorithm at almost no risk because the user takes no special actions.  The decision of whether to invoke the algorithm still involves some risk because the exact behavior of some algorithms is difficult to predict.  Therefore additional techniques such as undo and slow motion execution will have to be extended and refined.\n\nConclusion\nIs creating a programming system that is effective for just-in-time programming an interesting research problem? The previous sections clearly show that it has not been solved already, so it meets this criterion.  A second criterion for interesting research is that there be some indication that solutions are possible.  The previous section touched on several promising research directions, many of which are based on PBD.  A third, important criterion for interesting research is that it lead to tangible benefits.  The benefits of improved just-in-time programming systems would be to allow users to better automate repetitive subtasks that arise from their unique circumstances.  The line transformation subtask was one such example where automation would have led to significant benefit.  There will always be subtasks like this that slip through the prepackaged functionality of applications because they result from the interactions of users with the complexities of the real world.  Task-time is often the only possible time to implement the algorithms that can automate these subtasks.\nBut is it necessary to focus the research problem on such a narrow slice of programming to make automating these subtasks practical?  After all, many of the obstacles facing just-in-time programming also affect other types of programming;  it is possible that researching other types of programming will produce effective just-in-time programming systems as a side effect.  Are there reasons for researching just-in-time programming specifically?\nOne reason is that a user must accomplish all of the following during task-time: assess risk, enter the algorithm, design the invocation scheme, solve data access problems, invoke the algorithm, verify correct program behavior, and resume work on the overlying task.  Thus it is crucial that techniques that support these activities be refined to a degree that other forms of research are unlikely to achieve.  For example, research that concentrates on programming-in-the-large is unlikely to adequately reduce the effort required to input the algorithm when managing program complexity is its overriding concern.  Research that assumes essential programming is unlikely consider techniques that reduce risk by enabling productive use of partially debugged programs.  Research that assumes task-time independent programming is unlikely to recognize that programming may not be the user's primary concern.  Thus it is unlikely to give adequate emphasis to minimizing distractions from the user's primary task.  It is also unlikely to motivate data and operator access that is flexible enough to process the user's data wherever it may be when the opportunity to apply just-in-time programming arises.\nAnother reason is there are solutions that are appropriate for just-in-time programming but are not necessarily appropriate for other types of programming.  For example, the pixel based techniques of Triggers [TRIGGERS CHAPTER] would not be appropriate for software that must run in the background.  The technique of programming and accomplishing the task at the same time discussed in the risk section does not make sense for programmers who are writing software for other people's use.\nBy recognizing the special nature of just-in-time programming and by addressing the limitations of current programming systems head-on, much research progress should result.  The five obstacles provide a set of subproblems that can be used to focus multiple avenues of research.  Researchers should be careful not to accentuate one obstacle in the elimination of another; it only takes one to prevent a just-in-time programming system from being effective.  It is crucial that a just-in-time programming system address risk because it is probably impossible to create a programming system where the user's every attempt at creating new automation will be profitable.  The goal should be to create a programming system where a user can know that in the worse case attempting just-in-time programming will not hinder progress towards completing the task.  Then the user will be able to confidently use the full extent of the programming system to profit from their algorithmic insights.\n\nReferences for Alan\n\n[Apple 91] Apple Computer, Inc., <Inside Macintosh, Volume VI> Addison Wesley, Reading, Massachusetts, 1991.\n\n[Cypher 86] Cypher A., \"The Structure of Users' Activities,\" <User Centered Design>, Lawrence Erlbaum Associates, Hillsdale, New Jersey, 1986.\n\n[Halbert 84] Halbert D., \"Programming by Example,\" Ph.D. Thesis, Department of Computer Science, University of California at Berkeley , 1984.\n"
      },
      "after": "b67f51d14ea929c3",
      "date": 1641329098502
    },
    {
      "type": "edit",
      "id": "5be405ab12de44d0",
      "item": {
        "type": "paragraph",
        "id": "5be405ab12de44d0",
        "text": "https://c2.com/xp/JustInTimeProgramming.html"
      },
      "date": 1641329128434
    },
    {
      "type": "edit",
      "id": "5be405ab12de44d0",
      "item": {
        "type": "markdown",
        "id": "5be405ab12de44d0",
        "text": "https://c2.com/xp/JustInTimeProgramming.html"
      },
      "date": 1641329130709
    },
    {
      "type": "add",
      "id": "37a8826147eb0e1a",
      "item": {
        "type": "paragraph",
        "id": "37a8826147eb0e1a",
        "text": "Just-in-Time Programming\n\nby \nRichard Potter \nHuman Computer Interaction Lab \nUniversity of Maryland "
      },
      "after": "5be405ab12de44d0",
      "date": 1641329135583
    },
    {
      "type": "edit",
      "id": "37a8826147eb0e1a",
      "item": {
        "type": "paragraph",
        "id": "37a8826147eb0e1a",
        "text": "[[Just-in-Time Programming]] by [[Richard Potter]], Human Computer Interaction Lab, University of Maryland "
      },
      "date": 1641329159961
    },
    {
      "type": "edit",
      "id": "921ea177f259d957",
      "item": {
        "type": "markdown",
        "id": "921ea177f259d957",
        "text": "It is worth emphasizing that the user's task could be from any domain (e.g. graphic drawing, scientific visualization, word processing, etc.) and that the algorithm to be implemented originates with the user.  Obviously, a user with more programming experience will be able to envision a more complex algorithm than a novice user.  How the user comes up with the algorithm is not a concern.  Also, no hint of a solution appears in the problem statement.  Any programming system could conceivably be used for just-in-time programming, including C, PASCAL, keyboard macros, scripting languages, or PBD. PBD will probably be an important part of the more successful just-in-time programming systems, but the problem statement leaves open the possibility for other solutions.\nJust-in-time programming research shares many of the motivations of other PBD research.  Chief among these is that users often do repetitive or algorithmic subtasks that the computer could be doing.  We call these subtasks potential computer subtasks and call these situations opportunities for new beneficial automation.  Because automating can increase productivity and user satisfaction and at the same time reduce errors, one would expect the user to delegate potential computer subtasks to the computer.  That users often do not take advantage of these opportunities motivates researching ways to improve the computer.  Just-in-time programming research and PBD research assert that easier to use programming tools will allow users to better take advantage of opportunities for new beneficial automation.\nJust-in-time programming research, however, is focused on making programming easier for a specific cross section of situations.  These situations are primarily defined by the user programming during task-time.  In other words, the user is attempting to write a program for a task that is already in progress.  Figure 1 summarizes the relationship between task progress and the user's expenditure of effort.  The expenditure of effort for just-in-time programming is shown separate from the other task related effort.  The difficulty of just-in-time programming results from the spreading of the user's mental resources between two activities.  Another difficulty is that the time spent programming contributes directly to total time between the start and completion of the task.\nFigure 1:  Just-in-time programming intermixes programming effort with other task related effort.\n\n\n\n"
      },
      "date": 1641329311416
    },
    {
      "type": "add",
      "id": "1b55857e3235aa15",
      "item": {
        "type": "markdown",
        "id": "1b55857e3235aa15",
        "text": "## What is not Just-in-time Programming?\nOne might contrast just-in-time programming with, for lack of a better term, task-time independent programming which is summarized in figure 2.  For an example, consider a user who is programming a HyperCard mock-up of a user interface in preparation for a demonstration the next day.  The subtask of the software is to help an audience visualize a proposed user interface design during the meeting.  This example would be task-time independent programming because the software is created well before the meeting.  As is the case with many distinctions, there are examples that straddle the line between just-in-time programming and task-time independent programming, but the discussions that follow should hold regardless.\nFigure 2:  Task-time independent programming separates programming effort from other task-related effort.\n\nJust-in-time programming can be contrasted with other forms of programming by considering implications of the situation characterized in the introduction.  For example, since the algorithm to be implemented is the product of the user's insight, it is typically simple.  Thus one could contrast just-in-time programming with programming-in-the-large.  For an example, developing a full featured word processor would not be just-in-time programming because an algorithm that implements all the features of a word processor is too complex for one person to envision.\nAnother implication of the situation characterized in the introduction is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\nHow does just-in-time programming relate to the more common PBD application of programming for novice programmers? These two types of programming are basically independent;  programming in a given situation could represent both, one, or neither of these.  A novice programmer writing a short program that changes all numbers in a document to a larger font would be an example of both types of programming, assuming the user was about to make the modifications by hand.  A novice programmer writing educational software to be used by students at a later time would be an example of a novice programmer programming, but not just-in-time programming.  I recently modified a postscript file to only print out the even pages of the document and then the odd pages so that it would print on both sides of the paper without requiring me to issue a separate print command for each page.  This would be an example of just-in-time programming that was not programming for the novice.\n\nA Subtask Suitable for Just-in-Time Programming\nI happened upon an opportunity for just-in-time programming when Think C updated their class library to version 1.1.  Before version 1.1, rectangles were defined with 16-bit coordinates and in version 1.1 rectangles were defined by 32-bit coordinates.  When I first compiled my software project with the new class library, type mismatch errors occurred where my software expected 16-bit values.  Many of these were simple assignment statements.  The new class library included a utility function for converting 32-bit rectangles to 16-bit rectangles, so a typical fix involved changing a line of the form *inset=frame; to the form longToQDRect(&frame,inset);. Various other types of errors were found and fixed as well.  The second time an assignment of a 32-bit rectangle to a 16-bit rectangle caused an error, I recalled that there were many such assignments throughout my program and concluded I would, in time, be transforming many lines from assignment statements into function calls. Each would differ only in the names of the variables and whether each variable was a pointer or not (i.e. preceded by a \"*\").  For the rest of this paper, transforming one of these lines will be called the line transformation subtask.\nTo attempt to automate this subtask would have been just-in-time programming because of the situation.  This particular example also contrasts well with the other types of programming discussed above.  It would certainly not be task-time independent programming because I was in the midst of modifying my software project.  The subtask was algorithmically simple so it was not programming-in-the-large.  Automating the subtask was not essential, so it was not essential programming.\nSo to break this situation down into the components of just-in-time programming:\nThe user: \nmyself\nThe task: \nmodifying a software project to work with an updated class library\nThe subtask: \nchanging certain lines of source code from the form {*}var1 = {*}var2; to the form longToQDRect({&}var2,{&}var1); (i.e. the line transformation subtask)\nThe algorithm: \ninsert leading white space\ninsert \"longToQDRect(\"\nif second variable name is not preceded by \"*\", insert \"&\"\ninsert second variable name\ninsert \",\"\nif first variable name is not preceded by \"*\", insert \"&\"\ninsert first variable name\ninsert \")\"\ninsert rest of line (the \";\" and comments, if any)\ndelete original line.\nThe attempt to automate:  \nActually I did not try to automate the subtask.  The rest of the chapter will explain why.\n\nFive Obstacles\nOne reason to explicitly state a problem is so that it can be broken down into meaningful subproblems.  One way to do this is to analyze current technology, identify common obstacles that prevent the technology from being effective, and let the subproblems be to find ways to eliminate these obstacles.  The following sections discuss five obstacles that often prevent users of current programming systems from profiting from their algorithmic insights.  Each section also discusses PBD's potential role in solving the subproblem represented by each obstacle.\n\t\nFigure 3:  A C algorithm that automates the line transformation subtask assuming the line has been isolated in a character buffer.\n\nEffort of entering the algorithm\nGiven that I understood the algorithmic structure of the line transformation subtask, why not automate it?  Since I was actually using a C programming system, let's first explore the possibility of using it.  Figure 3 shows a program in C that can transform the line as needed, assuming that the line has been loaded into a string (we will deal with this assumption more later).  One obstacle quickly becomes apparent: the effort of entering the algorithm.  Merely the physical effort of typing in the 749 characters of this program would likely undermine the benefits of automating this small part of the task.  But there is also the mental effort required to translate the algorithm into the idioms of the language and to work out the fine details.  For example, after years of programming in C, I still must look up the strcat function in the manual to see if it copies from the first argument to the second or vice versa.\nDiscussion  No matter what type of programming is being done, reducing this effort is desirable.  However, the effort of entering an algorithm is particularly important for just-in-time programming because the subtasks appropriate for just-in-time programming are typically special purpose needs that can not be as widely applied as functionality that is more generic.  The line transformation task is a good example of this because once I finished updating the software project, I had no need for this particular functionality.  When the benefits per programming effort are modest, only minimal effort can be expended towards entering the algorithm before the venture becomes pointless.  If the user's task is creative or involves problem solving, then the user can scarcely afford to expend mental effort for modest gains.  Of course, there are times when the payoffs of just-in-time programming are large enough that the effort to enter the algorithm is not as crucial.  But there are enough opportunities for modest payoffs that finding ways to reduce the effort required to enter the algorithm is an important subproblem to solve.\nSometimes creating new beneficial automation by programming pays off because the user can apply the automation many times in the future.  A script that automatically dials a remote computer and logs the user into their account would be a good example.  Here the distinction between just-in-time programming and task-time independent programming is blurred.  Strictly speaking, the programming effort is expended at a time independent of when the benefits of the automation are received.  However, the user is likely to automate this task at a time when they are about to dial in to the remote computer manually, that is, when the desirability of automating the subtask comes to mind.  So although the user could set aside some time and do task-time independent programming, psychologically the task-time aspects of whatever the user is doing are likely to impact the programming process.  In this sense, much of the special concerns of just-in-time programming still hold.\nReducing this effort is less important for programming-in-the-large because the effort required to manage the complexity of a large software project tends to overshadow the effort required to enter the algorithm.  In fact, programming languages such as Ada even increase the effort of entering the algorithm by requiring extra notation for modularizing the code.  Such notation does not contribute directly to functionality, but is appropriate for programming-in-the-large because complexity is such an overriding concern.\nJust-in-time programming accentuates the mental effort required to enter the algorithm because users must switch their mind-sets from the task domain to the programming domain as illustrated in figure 1.  After the algorithm has been implemented, users must also expend effort to return their mind-sets to the task domain.  Users might expend effort trying not to divert too much attention to the programming effort, sometimes trying to keep more in their short term memory than is reasonable.  For creative tasks, this diversion is especially costly.  In contrast, users who are programming independently of task time can change their mind-set over a longer period of time.\nTherefore when minimizing the effort of entering the algorithm, it is important to minimize distraction from the task.  One of the main sources of effort and distraction is the number of special programming concepts.  For example, writing the C algorithm in figure 3 required remembering how strings are allocated and referenced.  On this point, just-in-time programming and programming for novice programmers share similar goals because a programming system for novice programmers should require the understanding of as few new concepts as possible.  In cases where a just-in-time programming system is being designed specifically for novice programmers, the same would apply.\nThe idea of just-in-time programming, however, is not limited to novice programmers.  For expert programmers, whether a concept is familiar to a nonprogrammer is not the crucial factor.  Instead, the programming system should require the user to understand only concepts that can be ingrained and that the user can apply fluently.  Therefore, part of the research agenda of just-in-time programming should be to identify key skills that, if ingrained, will allow a user to more effectively write programs just in time.  These skills could be anything from something classic like regular expressions to some new esoteric programming paradigm.  It seems clear that, at least for the foreseeable future, users will have to understand the basic concepts of conditionals and iteration.\nSolution directions  Many techniques including code templates, code reuse, domain specific functionality, subroutines, copy/paste, and on-line documentation can help reduce the effort required to enter an algorithm.  PBD helps reduce this effort by allowing users to enter the algorithm using the same interface as they would normally use to work the subtask manually.  This helps reduce both the physical effort and the mental effort because the user is often well practiced at using this interface.  Since the user would use the same user interface to work the subtask manually, the artifacts are already in short term memory and programming with them is likely to be less distracting than with an off-line programming language.  The effort to enter the algorithm is also reduced because user interfaces are usually optimized to the task.\nFigure 4:  This Quickeys macro can partially automate the line transformation subtask.  The number of keystrokes required to enter the macro and the visual state of the editor are shown.\n\nFor a simple example of how PBD can reduce the effort of entering an algorithm, consider one partial solution to the line transformation subtask.  If the user first places the cursor to the left of the first variable in the line to be transformed and neither variable is a pointer, then the Quickeys macro shown in figure 4 will transform the line as required.  The macro also assumes that exactly three characters (\" = \") separate the two variable names.  Only the 33 keypresses shown in figure 4 are required to implement the macro.  The visual feedback of the editor also helps reduce the mental effort by showing intermediate results.\nLimited computational generality\nWhy illustrate the virtues of the keyboard macro by only partially automating the line transformation subtask?  The reason is that the subtask requires conditional logic to decide whether each variable is a pointer or not.  Keyboard macros only record straight-line algorithms and thus are not able to fully automate this subtask.  This illustrates an obstacle that users face when programming just in time:  the programming systems that make it easy to enter their algorithm can often only implement algorithms of limited computational generality.\nDiscussion  It is important for a just-in-time programming system to have full Turing-complete computational generality because there is no way to predict which of the vast array of algorithms the user might envision.  Unfortunately computational generality is not one of PBD's strengths.  Halbert recognized this when implementing SmallStar and concluded that control structures were better created by editing a static representation of the program than by demonstration [Halbert 84].  Others have used inference to generalize straight-line demonstrations into procedures with control structures.  Cypher's Eager and Myers' Peridot used domain knowledge to infer procedures with control structures solely from straight-line demonstrations [EAGER CHAPTER, PERIDOT CHAPTER].  The computational generality of these systems, however, was limited by limited domain knowledge.\nSolution directions  In order for a PBD to be used for just-in-time programming, it will have to be integrated with other techniques to give full computational generality.  Interesting directions include giving separate examples for each path of the algorithm as in Tinker [TINKER CHAPTER], or a combination of multiple demonstrations, inferencing, and special instructions from the user as in Metamouse [METAMOUSE CHAPTER].\nEffort of invoking algorithm\nAs stated previously, the effort to enter an algorithm is less of an obstacle when the benefits of automating are large.  So for the sake of argument, assume that I knew there would be hundreds of lines needing to be transformed and decided to automate the task using C.  Limited computational generality would not be an obstacle with C.  Are there other obstacles?\nWhen the compiler detected an error in my software project, it would load the file containing the error into its text editor and highlight the erroneous line.  To take advantage of the line transformation program, I would first have to judge if it was one of the simple type mismatch errors that could be fixed by the simple line transformation.  If so, I would then invoke the C implementation on the specific line.  But how would I do that?  One possibility would be to mark the line some special way, perhaps by placing a \"*\" at the beginning of the line, and then save the file out to disk.  Then I could run the C program which would then prompt me for the name of the file with the incorrect line.  The C program would then scan through the file for a line that started with a \"*\" and apply the transformation to it.  But this would be silly.  The effort to invoke the algorithm would undermine the benefits and would be yet another obstacle to automating this subtask.\nDiscussion  As in this case, a subtask appropriate for just-in-time programming typically applies to part of a larger document.  Thus, users must be able to implement the algorithm such that they can specify which part of the document should be processed when they invoke the algorithm.  It is important that they be able to do this with ease because the benefits to be obtained by automating can be easily negated by the invocation effort.  Unlike the effort to enter the algorithm, the effort to invoke the algorithm can not be amortized over the life of the new beneficial automation.  The effort must be small in comparison with the benefit received from each invocation of the algorithm.  When the payoffs per invocation are larger this obstacle is not as crucial, but enough opportunities for modest benefits exist that it is important to reduce the effort required to invoke algorithms implemented just in time.\nFor an example of how crucial the ease of invocation can be towards making automation beneficial, consider the feature on many word processors that allows a user to select a word simply by double clicking on it.  The word processor automatically does the tedious subtask of extending the selection out to the word boundaries.  Identifying these word boundaries manually is a simple subtask, so not much benefit is received each time the feature is used.  However, words are selected so commonly that, over time, the feature is very beneficial.  Another invocation strategy could easily undermine this benefit.  For example, even requiring the user to click on the word and then select the feature from a pull down menu could require too much effort.\nAs the previous example implies, this obstacle is not unique to just-in-time programming.  Because the effort to invoke the algorithm can not be amortized, any programming endeavor that produces interactive software needs to pay special attention to this obstacle.  The main difference for just-in-time programming is that the user can not amortize the effort to create the invocation scheme as much.\nSolution directions  How should just-in-time programming make it easy to invoke algorithms?  One clue is strongly implied by the hypothetical consideration of C for automating the line transformation subtask:  users should be able to implement their algorithms such that they can perform the subtask without having to save their documents to disk.  Instead their algorithms should be able to process data in its present form which is usually internal to some application.  Thus just-in-time programming systems should allow users to process data within their applications.  In addition, users should be able to use the application's data selection mechanisms to indicate what part of their document to process.  This would enable users to work manually, apply a newly implemented algorithm to the data, and continue to work manually without the overhead of saving the data to a file. Processing data within applications is central to PBD, so it already goes far to easing the effort to invoke the algorithm.\nBeyond automating within applications, just-in-time programming systems should allow the user to choose among various invocation strategies.  Standard invocations such as menu selections and keypresses should be supported.  The ability to create more refined invocations, like double clicking on a an object to apply some automation to it, would be important for making some highly interactive automation worth creating.  PBD techniques could possibly be used to have the fact that the user has started doing the subtask be what triggers the automation to be invoked.  David Maulsby's Turvy and Metamouse give hints of how this might work [TURVY CHAPTER, METAMOUSE CHAPTER].\nInaccessible data and operators\nSo far we have seen several reasons to want to process data while it resides within an application.  One is to make algorithms easier to enter by allowing the user to demonstration the algorithm through the user interface of the application.  Another is that invocations can be made easier if the data is processed within the application.  The Quickeys solution in figure 4 had these advantages, but it only partially automated the subtask.  No other programming system on my computer (including APL, C, Lisp, Scheme, or HyperTalk) can automate within Think C's editor because of the fourth obstacle, inaccessible data and operators.  In this case, this obstacle undermines the modest benefits of automating the subtask.  If the benefits per invocation were greater, then accessing the data independently of the application by saving the document to a file might have made creating the new automation worthwhile.\nIn other cases, limited data access can take the simplest algorithms and render them impossible to implement.  Consider the example discussed in [TRIGGERS CHAPTER REFERENCE] of automating the wrapping of a text field with a properly sized rounded rectangle.  The algorithm to automate this task is trivial when stated in terms of the text field's and the rounded rectangle's properties of location, length and width.  The central part of the algorithm is to set the rounded rectangle's location a bit above and to the left of the text field's location, and set the rounded rectangle's length and width to be a bit larger.  Automating this task independently of MacDraw II would involve extracting these properties from MacDraw II's coded file format, which would be very difficult.  Also, the user's algorithm may be based on special functionality provided by the application such as, in this case, the ability to create rounded rectangles.  Just-in-time programming systems should therefore be able to access properties from applications and invoke the operators provided by applications.\nSometimes an opportunity for new beneficial automation involves not so much the processing of data, but rather the repetitive manipulation of an application's user interface artifacts.  For example, the user may wish to automate the toggling between two window arrangements.  The only way a programming system can automate this is to access the state of the user interface and manipulate its components.\nDiscussion  Inaccessible data and operators is a particularly common obstacle for just-in-time programming because users must make do with whatever form their data is in when they envision the algorithm.  Usually this data exists within an application.  In contrast, task-time independent programming often allows the user to plan what form the data will be in when the automation is eventually used.  Many programming efforts, like games or educational software, are closed systems where the programmer can choose the format of the data to be whatever makes their programming effort easiest.\nSolution directions  In order for a programming system to access the data and operators of an application, there must be a communication protocol that both the programming system and the application follow.  One way to effect this protocol is to build the programming system into the application.  This strategy, however, limits the data access to the one application, so inaccessible data and operators would still be an obstacle when the user's algorithm involved multiple applications.  Therefore just-in-time programming systems should make use of specially established interapplication protocols like Apple Events [Apple 91].\nSometimes programming systems can overcome the inaccessible data and operators obstacle by using protocols established for reasons other than interapplication communication.  For example, the Quickeys solution uses the computer's keyboard input stream as a protocol to process data in the editor application.  The Triggers chapter discusses an extension to this technique where pixel data from the computer display can be used to gain a significant degree data access from any application.  PBD plays a large role in making this extension possible because the algorithms implemented using these techniques sometimes contain large bitmap constants.  Entering these bitmaps would be unwieldy if they could not be specified by demonstration.\nRisk\nThe fifth obstacle is the risk that the automation will fail, be ineffective, or produce unintended results.  Consider the risks of automating the line transformation subtask.  There are many possible scenarios.  In the best case the algorithm could have been entered almost effortlessly, and as each occurrence of a line needing the simple transformation was flagged by the compiler, I could have easily invoked the algorithm somehow.  To my surprise, perhaps more chances to use the new automation occurred than were anticipated, making the automation pay off more than expected.\nBut there are many other possible scenarios.  The algorithm could have taken a long time to enter, perhaps because some special purpose function had to be looked up in a manual.  A mistake in the implementation might have caused the new (not beneficial) automation to destroy part of the source file, perhaps too quickly to be noticed.  Limited data access could have turned the simple algorithm into one that was impossible to implement.  I was not sure exactly how many more assignments of 32-bit rectangles to 16-bit rectangles were left in my software project, and thus there may have been too few to make the programming effort worthwhile.  Unforeseen special cases may have made the envisioned algorithm simply wrong.\nA user who is considering a just-in-time programming effort has the option of continuing to work manually.  Given the many adverse scenarios, it is not surprising that the user would choose this option.  Thus just-in-time programming systems often fail because the user chooses not to use it.\nRisk was the main reason I chose not to automate the line transformation subtask.  The partial solution using keyboard macros was the only one worth considering because it was the only solution that did not require saving the file to disk.  In the past, my attempts to use keyboard macros have often been thwarted by unforeseen special cases, the difficulty of accommodating special cases into an already existing macro, and the uncontrollable speed of macros that make it difficult to verify that the macro works correctly.  In retrospect, a keyboard macro would have been worthwhile and would have prevented a few recompiles caused by typos in my manual transforming of the lines.  However at the time, the apparent risks convinced me to play it safe and transform the lines manually.\nDiscussion  Certainly all programming involves risk.  The risks of just-in-time programming are notable on two accounts.  One is that the time and effort spent implementing the algorithm relate directly to the success of the venture.  For example, any extra time or frustration involved in automating the line transformation subtask would have quickly eliminated the potential benefits.  In contrast, task-time independent programming efforts often relate only indirectly to success.  For example, say a user is programming an animated demo for a five-minute presentation.  If the demo take two hours longer to implement than expected, the presentation the next day can still be a success.\nBut the main reason risk affects just-in-time programming so strongly is that it is easy for users to choose to continue to work manually and avoid the risk.  In contrast, essential programming requires users to make the best of what their programming systems have to offer.  Users still have to assume whatever risks are present, but the programming system will not fail for lack of use.\nRisk is caused, in part, by the users' uncertainty about how the other four obstacles will affect their attempts to automate.  Thus, one way to reduce the risk is to work towards eliminating these four obstacles.  For example, if entering the algorithm were effortless, there would be no risk in taking that step.  Unfortunately, entirely eliminating these obstacles is very unlikely.  In addition, users will still have to assume the risk that their algorithms might not do as expected.  Thus, it is important to explicitly consider techniques that reduce the risks of just-in-time programming.\nSolution directions  One approach to addressing risk is to make it so that the user can accurately judge the effort required to implement the algorithm and accurately judge the benefits.  Simplicity and visibility are two attributes of a programming system that would contribute to this approach.  When users can confidently judge the benefits will be greater then the efforts, then they can proceed to profit from using the just-in-time programming system and the system will not fail from lack of use.  The limitation of this approach is that merely judging the risks is a risk in itself because the user must expend some mental effort.  Because it is unlikely that this effort can be eliminated entirely, the user will have good reason to simply continue working the task manually without ever giving the opportunity to use just-in-time programming a second thought.  Other techniques need to be considered.\nAnother approach to reducing risk is to enable users to profit from partial implementations of their algorithms.  This would help alleviate the risk that an obstacle might prevent the implementing of part of the algorithm, render the whole algorithm useless, and waste any effort already expended.  Users should be able to implement and profit from parts of their algorithms without requiring the entire algorithm to work flawlessly.\nFor example, assume a user has 20 book chapters saved as a separate MacWrite II files in a folder, and that a colleague requests a pure ASCII copy of each chapter.  To manually convert each chapter to pure ASCII, the user would have to load its file into the MacWrite II, select the Text Only option, and save it back out to disk using a different file name.  Assume files with the word \"backup\" in the file name should not be converted.  The simple algorithm in figure 5 could select all 20 chapters in turn and carry out these repetitive actions.  If the user were able to implement this algorithm, the tedium of keeping track of which files have been converted and the tedium of the repetitive actions would be avoided.\nFigure 5:  An algorithm that will convert a folder full of MacWrite II files to pure ASCII.\n\nIf the entire algorithm could be implemented confidently, easily, and flawlessly, then risk would not be an issue.  Unfortunately, any step in the algorithm could cause potential problems.  What if after putting some effort into the algorithm, the user discovers that only a subset of the nine steps can be implemented?  For example, what if step number 7 could not be implemented because the user's programming system could not invoke the operator that selects the Text Only operator?  The partial implementation can still potentially be beneficial if the user can manually do the steps that prove difficult to implement.  For example, the algorithm could invoke the \"Save As...\" dialog box and pause while the user selects Text Only manually.  The partial implementation would still be beneficial because it would take care of the tedium of keeping track of which files have been converted and a great majority of the other actions.\nFor step number 7, this strategy is easy to imagine because the application's existing user interface can allow the user to carry out the hard to implement action manually.  But what if step number 2 is too difficult to implement because the user's programming system has no built-in test for substrings?  In this case the list is in the programming system's execution environment, not the application.  If the user is to manually accomplish this step, the programming system must have an existing user interface that allows the user to manipulate the execution environment.  Some interactive programming systems and debuggers allow users to modify the execution environment during run-time, but few allow data to be manipulated easily enough for the user to do real work.  Also, the more that control has to pass between the user and their implementation, the more essential it will be that flexible invocation schemes are possible.\nEssentially the user's risk is that the manual method might be more effective than implementing the algorithm.  Therefore, another approach to addressing risk is to allow the user to pursue both alternatives in parallel.  In theory, the risk of attempting to automate the subtask would be eliminated because if unforeseen difficulties make the programming effort ineffective, then the user can fall back on the manual method already underway.\nIn practice, this approach would probably not eliminate risk, but it could reduce risk greatly.  PBD could play a large part in realizing this approach because it allows the user to implement algorithms by demonstrating on their actual task data.  In other words, the user can be programming and manually accomplishing the subtask simultaneously.  For example, recording the keyboard in figure 4 actually transforms one of the lines, so progress towards completing the overall task is hindered minimally.\nThis technique has its greatest potential when mixed with history based techniques.  For example, Allen Cypher's system Eager records the user's actions into an event history [EAGER CHAPTER].  When Eager detects the user doing repetitive actions, it indicates this to the user by highlighting what it expects the user to select next.  For certain classes of algorithms, the user can implement an algorithm at almost no risk because the user takes no special actions.  The decision of whether to invoke the algorithm still involves some risk because the exact behavior of some algorithms is difficult to predict.  Therefore additional techniques such as undo and slow motion execution will have to be extended and refined.\n\nConclusion\nIs creating a programming system that is effective for just-in-time programming an interesting research problem? The previous sections clearly show that it has not been solved already, so it meets this criterion.  A second criterion for interesting research is that there be some indication that solutions are possible.  The previous section touched on several promising research directions, many of which are based on PBD.  A third, important criterion for interesting research is that it lead to tangible benefits.  The benefits of improved just-in-time programming systems would be to allow users to better automate repetitive subtasks that arise from their unique circumstances.  The line transformation subtask was one such example where automation would have led to significant benefit.  There will always be subtasks like this that slip through the prepackaged functionality of applications because they result from the interactions of users with the complexities of the real world.  Task-time is often the only possible time to implement the algorithms that can automate these subtasks.\nBut is it necessary to focus the research problem on such a narrow slice of programming to make automating these subtasks practical?  After all, many of the obstacles facing just-in-time programming also affect other types of programming;  it is possible that researching other types of programming will produce effective just-in-time programming systems as a side effect.  Are there reasons for researching just-in-time programming specifically?\nOne reason is that a user must accomplish all of the following during task-time: assess risk, enter the algorithm, design the invocation scheme, solve data access problems, invoke the algorithm, verify correct program behavior, and resume work on the overlying task.  Thus it is crucial that techniques that support these activities be refined to a degree that other forms of research are unlikely to achieve.  For example, research that concentrates on programming-in-the-large is unlikely to adequately reduce the effort required to input the algorithm when managing program complexity is its overriding concern.  Research that assumes essential programming is unlikely consider techniques that reduce risk by enabling productive use of partially debugged programs.  Research that assumes task-time independent programming is unlikely to recognize that programming may not be the user's primary concern.  Thus it is unlikely to give adequate emphasis to minimizing distractions from the user's primary task.  It is also unlikely to motivate data and operator access that is flexible enough to process the user's data wherever it may be when the opportunity to apply just-in-time programming arises.\nAnother reason is there are solutions that are appropriate for just-in-time programming but are not necessarily appropriate for other types of programming.  For example, the pixel based techniques of Triggers [TRIGGERS CHAPTER] would not be appropriate for software that must run in the background.  The technique of programming and accomplishing the task at the same time discussed in the risk section does not make sense for programmers who are writing software for other people's use.\nBy recognizing the special nature of just-in-time programming and by addressing the limitations of current programming systems head-on, much research progress should result.  The five obstacles provide a set of subproblems that can be used to focus multiple avenues of research.  Researchers should be careful not to accentuate one obstacle in the elimination of another; it only takes one to prevent a just-in-time programming system from being effective.  It is crucial that a just-in-time programming system address risk because it is probably impossible to create a programming system where the user's every attempt at creating new automation will be profitable.  The goal should be to create a programming system where a user can know that in the worse case attempting just-in-time programming will not hinder progress towards completing the task.  Then the user will be able to confidently use the full extent of the programming system to profit from their algorithmic insights.\n\nReferences for Alan\n\n[Apple 91] Apple Computer, Inc., <Inside Macintosh, Volume VI> Addison Wesley, Reading, Massachusetts, 1991.\n\n[Cypher 86] Cypher A., \"The Structure of Users' Activities,\" <User Centered Design>, Lawrence Erlbaum Associates, Hillsdale, New Jersey, 1986.\n\n[Halbert 84] Halbert D., \"Programming by Example,\" Ph.D. Thesis, Department of Computer Science, University of California at Berkeley , 1984.\n"
      },
      "after": "921ea177f259d957",
      "date": 1641329313087
    },
    {
      "type": "edit",
      "id": "1b55857e3235aa15",
      "item": {
        "type": "markdown",
        "id": "1b55857e3235aa15",
        "text": "## What is not Just-in-time Programming?\nOne might contrast just-in-time programming with, for lack of a better term, task-time independent programming which is summarized in figure 2.  For an example, consider a user who is programming a [[HyperCard]] mock-up of a user interface in preparation for a demonstration the next day.  The subtask of the software is to help an audience visualize a proposed user interface design during the meeting.  This example would be task-time independent programming because the software is created well before the meeting.  As is the case with many distinctions, there are examples that straddle the line between just-in-time programming and task-time independent programming, but the discussions that follow should hold regardless.\nFigure 2:  Task-time independent programming separates programming effort from other task-related effort.\n\nJust-in-time programming can be contrasted with other forms of programming by considering implications of the situation characterized in the introduction.  For example, since the algorithm to be implemented is the product of the user's insight, it is typically simple.  Thus one could contrast just-in-time programming with programming-in-the-large.  For an example, developing a full featured word processor would not be just-in-time programming because an algorithm that implements all the features of a word processor is too complex for one person to envision.\nAnother implication of the situation characterized in the introduction is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\nHow does just-in-time programming relate to the more common PBD application of programming for novice programmers? These two types of programming are basically independent;  programming in a given situation could represent both, one, or neither of these.  A novice programmer writing a short program that changes all numbers in a document to a larger font would be an example of both types of programming, assuming the user was about to make the modifications by hand.  A novice programmer writing educational software to be used by students at a later time would be an example of a novice programmer programming, but not just-in-time programming.  I recently modified a postscript file to only print out the even pages of the document and then the odd pages so that it would print on both sides of the paper without requiring me to issue a separate print command for each page.  This would be an example of just-in-time programming that was not programming for the novice.\n\nA Subtask Suitable for Just-in-Time Programming\nI happened upon an opportunity for just-in-time programming when Think C updated their class library to version 1.1.  Before version 1.1, rectangles were defined with 16-bit coordinates and in version 1.1 rectangles were defined by 32-bit coordinates.  When I first compiled my software project with the new class library, type mismatch errors occurred where my software expected 16-bit values.  Many of these were simple assignment statements.  The new class library included a utility function for converting 32-bit rectangles to 16-bit rectangles, so a typical fix involved changing a line of the form *inset=frame; to the form longToQDRect(&frame,inset);. Various other types of errors were found and fixed as well.  The second time an assignment of a 32-bit rectangle to a 16-bit rectangle caused an error, I recalled that there were many such assignments throughout my program and concluded I would, in time, be transforming many lines from assignment statements into function calls. Each would differ only in the names of the variables and whether each variable was a pointer or not (i.e. preceded by a \"*\").  For the rest of this paper, transforming one of these lines will be called the line transformation subtask.\nTo attempt to automate this subtask would have been just-in-time programming because of the situation.  This particular example also contrasts well with the other types of programming discussed above.  It would certainly not be task-time independent programming because I was in the midst of modifying my software project.  The subtask was algorithmically simple so it was not programming-in-the-large.  Automating the subtask was not essential, so it was not essential programming.\nSo to break this situation down into the components of just-in-time programming:\nThe user: \nmyself\nThe task: \nmodifying a software project to work with an updated class library\nThe subtask: \nchanging certain lines of source code from the form {*}var1 = {*}var2; to the form longToQDRect({&}var2,{&}var1); (i.e. the line transformation subtask)\nThe algorithm: \ninsert leading white space\ninsert \"longToQDRect(\"\nif second variable name is not preceded by \"*\", insert \"&\"\ninsert second variable name\ninsert \",\"\nif first variable name is not preceded by \"*\", insert \"&\"\ninsert first variable name\ninsert \")\"\ninsert rest of line (the \";\" and comments, if any)\ndelete original line.\nThe attempt to automate:  \nActually I did not try to automate the subtask.  The rest of the chapter will explain why.\n\nFive Obstacles\nOne reason to explicitly state a problem is so that it can be broken down into meaningful subproblems.  One way to do this is to analyze current technology, identify common obstacles that prevent the technology from being effective, and let the subproblems be to find ways to eliminate these obstacles.  The following sections discuss five obstacles that often prevent users of current programming systems from profiting from their algorithmic insights.  Each section also discusses PBD's potential role in solving the subproblem represented by each obstacle.\n\t\nFigure 3:  A C algorithm that automates the line transformation subtask assuming the line has been isolated in a character buffer.\n\nEffort of entering the algorithm\nGiven that I understood the algorithmic structure of the line transformation subtask, why not automate it?  Since I was actually using a C programming system, let's first explore the possibility of using it.  Figure 3 shows a program in C that can transform the line as needed, assuming that the line has been loaded into a string (we will deal with this assumption more later).  One obstacle quickly becomes apparent: the effort of entering the algorithm.  Merely the physical effort of typing in the 749 characters of this program would likely undermine the benefits of automating this small part of the task.  But there is also the mental effort required to translate the algorithm into the idioms of the language and to work out the fine details.  For example, after years of programming in C, I still must look up the strcat function in the manual to see if it copies from the first argument to the second or vice versa.\nDiscussion  No matter what type of programming is being done, reducing this effort is desirable.  However, the effort of entering an algorithm is particularly important for just-in-time programming because the subtasks appropriate for just-in-time programming are typically special purpose needs that can not be as widely applied as functionality that is more generic.  The line transformation task is a good example of this because once I finished updating the software project, I had no need for this particular functionality.  When the benefits per programming effort are modest, only minimal effort can be expended towards entering the algorithm before the venture becomes pointless.  If the user's task is creative or involves problem solving, then the user can scarcely afford to expend mental effort for modest gains.  Of course, there are times when the payoffs of just-in-time programming are large enough that the effort to enter the algorithm is not as crucial.  But there are enough opportunities for modest payoffs that finding ways to reduce the effort required to enter the algorithm is an important subproblem to solve.\nSometimes creating new beneficial automation by programming pays off because the user can apply the automation many times in the future.  A script that automatically dials a remote computer and logs the user into their account would be a good example.  Here the distinction between just-in-time programming and task-time independent programming is blurred.  Strictly speaking, the programming effort is expended at a time independent of when the benefits of the automation are received.  However, the user is likely to automate this task at a time when they are about to dial in to the remote computer manually, that is, when the desirability of automating the subtask comes to mind.  So although the user could set aside some time and do task-time independent programming, psychologically the task-time aspects of whatever the user is doing are likely to impact the programming process.  In this sense, much of the special concerns of just-in-time programming still hold.\nReducing this effort is less important for programming-in-the-large because the effort required to manage the complexity of a large software project tends to overshadow the effort required to enter the algorithm.  In fact, programming languages such as Ada even increase the effort of entering the algorithm by requiring extra notation for modularizing the code.  Such notation does not contribute directly to functionality, but is appropriate for programming-in-the-large because complexity is such an overriding concern.\nJust-in-time programming accentuates the mental effort required to enter the algorithm because users must switch their mind-sets from the task domain to the programming domain as illustrated in figure 1.  After the algorithm has been implemented, users must also expend effort to return their mind-sets to the task domain.  Users might expend effort trying not to divert too much attention to the programming effort, sometimes trying to keep more in their short term memory than is reasonable.  For creative tasks, this diversion is especially costly.  In contrast, users who are programming independently of task time can change their mind-set over a longer period of time.\nTherefore when minimizing the effort of entering the algorithm, it is important to minimize distraction from the task.  One of the main sources of effort and distraction is the number of special programming concepts.  For example, writing the C algorithm in figure 3 required remembering how strings are allocated and referenced.  On this point, just-in-time programming and programming for novice programmers share similar goals because a programming system for novice programmers should require the understanding of as few new concepts as possible.  In cases where a just-in-time programming system is being designed specifically for novice programmers, the same would apply.\nThe idea of just-in-time programming, however, is not limited to novice programmers.  For expert programmers, whether a concept is familiar to a nonprogrammer is not the crucial factor.  Instead, the programming system should require the user to understand only concepts that can be ingrained and that the user can apply fluently.  Therefore, part of the research agenda of just-in-time programming should be to identify key skills that, if ingrained, will allow a user to more effectively write programs just in time.  These skills could be anything from something classic like regular expressions to some new esoteric programming paradigm.  It seems clear that, at least for the foreseeable future, users will have to understand the basic concepts of conditionals and iteration.\nSolution directions  Many techniques including code templates, code reuse, domain specific functionality, subroutines, copy/paste, and on-line documentation can help reduce the effort required to enter an algorithm.  PBD helps reduce this effort by allowing users to enter the algorithm using the same interface as they would normally use to work the subtask manually.  This helps reduce both the physical effort and the mental effort because the user is often well practiced at using this interface.  Since the user would use the same user interface to work the subtask manually, the artifacts are already in short term memory and programming with them is likely to be less distracting than with an off-line programming language.  The effort to enter the algorithm is also reduced because user interfaces are usually optimized to the task.\nFigure 4:  This Quickeys macro can partially automate the line transformation subtask.  The number of keystrokes required to enter the macro and the visual state of the editor are shown.\n\nFor a simple example of how PBD can reduce the effort of entering an algorithm, consider one partial solution to the line transformation subtask.  If the user first places the cursor to the left of the first variable in the line to be transformed and neither variable is a pointer, then the Quickeys macro shown in figure 4 will transform the line as required.  The macro also assumes that exactly three characters (\" = \") separate the two variable names.  Only the 33 keypresses shown in figure 4 are required to implement the macro.  The visual feedback of the editor also helps reduce the mental effort by showing intermediate results.\nLimited computational generality\nWhy illustrate the virtues of the keyboard macro by only partially automating the line transformation subtask?  The reason is that the subtask requires conditional logic to decide whether each variable is a pointer or not.  Keyboard macros only record straight-line algorithms and thus are not able to fully automate this subtask.  This illustrates an obstacle that users face when programming just in time:  the programming systems that make it easy to enter their algorithm can often only implement algorithms of limited computational generality.\nDiscussion  It is important for a just-in-time programming system to have full Turing-complete computational generality because there is no way to predict which of the vast array of algorithms the user might envision.  Unfortunately computational generality is not one of PBD's strengths.  Halbert recognized this when implementing SmallStar and concluded that control structures were better created by editing a static representation of the program than by demonstration [Halbert 84].  Others have used inference to generalize straight-line demonstrations into procedures with control structures.  Cypher's Eager and Myers' Peridot used domain knowledge to infer procedures with control structures solely from straight-line demonstrations [EAGER CHAPTER, PERIDOT CHAPTER].  The computational generality of these systems, however, was limited by limited domain knowledge.\nSolution directions  In order for a PBD to be used for just-in-time programming, it will have to be integrated with other techniques to give full computational generality.  Interesting directions include giving separate examples for each path of the algorithm as in Tinker [TINKER CHAPTER], or a combination of multiple demonstrations, inferencing, and special instructions from the user as in Metamouse [METAMOUSE CHAPTER].\nEffort of invoking algorithm\nAs stated previously, the effort to enter an algorithm is less of an obstacle when the benefits of automating are large.  So for the sake of argument, assume that I knew there would be hundreds of lines needing to be transformed and decided to automate the task using C.  Limited computational generality would not be an obstacle with C.  Are there other obstacles?\nWhen the compiler detected an error in my software project, it would load the file containing the error into its text editor and highlight the erroneous line.  To take advantage of the line transformation program, I would first have to judge if it was one of the simple type mismatch errors that could be fixed by the simple line transformation.  If so, I would then invoke the C implementation on the specific line.  But how would I do that?  One possibility would be to mark the line some special way, perhaps by placing a \"*\" at the beginning of the line, and then save the file out to disk.  Then I could run the C program which would then prompt me for the name of the file with the incorrect line.  The C program would then scan through the file for a line that started with a \"*\" and apply the transformation to it.  But this would be silly.  The effort to invoke the algorithm would undermine the benefits and would be yet another obstacle to automating this subtask.\nDiscussion  As in this case, a subtask appropriate for just-in-time programming typically applies to part of a larger document.  Thus, users must be able to implement the algorithm such that they can specify which part of the document should be processed when they invoke the algorithm.  It is important that they be able to do this with ease because the benefits to be obtained by automating can be easily negated by the invocation effort.  Unlike the effort to enter the algorithm, the effort to invoke the algorithm can not be amortized over the life of the new beneficial automation.  The effort must be small in comparison with the benefit received from each invocation of the algorithm.  When the payoffs per invocation are larger this obstacle is not as crucial, but enough opportunities for modest benefits exist that it is important to reduce the effort required to invoke algorithms implemented just in time.\nFor an example of how crucial the ease of invocation can be towards making automation beneficial, consider the feature on many word processors that allows a user to select a word simply by double clicking on it.  The word processor automatically does the tedious subtask of extending the selection out to the word boundaries.  Identifying these word boundaries manually is a simple subtask, so not much benefit is received each time the feature is used.  However, words are selected so commonly that, over time, the feature is very beneficial.  Another invocation strategy could easily undermine this benefit.  For example, even requiring the user to click on the word and then select the feature from a pull down menu could require too much effort.\nAs the previous example implies, this obstacle is not unique to just-in-time programming.  Because the effort to invoke the algorithm can not be amortized, any programming endeavor that produces interactive software needs to pay special attention to this obstacle.  The main difference for just-in-time programming is that the user can not amortize the effort to create the invocation scheme as much.\nSolution directions  How should just-in-time programming make it easy to invoke algorithms?  One clue is strongly implied by the hypothetical consideration of C for automating the line transformation subtask:  users should be able to implement their algorithms such that they can perform the subtask without having to save their documents to disk.  Instead their algorithms should be able to process data in its present form which is usually internal to some application.  Thus just-in-time programming systems should allow users to process data within their applications.  In addition, users should be able to use the application's data selection mechanisms to indicate what part of their document to process.  This would enable users to work manually, apply a newly implemented algorithm to the data, and continue to work manually without the overhead of saving the data to a file. Processing data within applications is central to PBD, so it already goes far to easing the effort to invoke the algorithm.\nBeyond automating within applications, just-in-time programming systems should allow the user to choose among various invocation strategies.  Standard invocations such as menu selections and keypresses should be supported.  The ability to create more refined invocations, like double clicking on a an object to apply some automation to it, would be important for making some highly interactive automation worth creating.  PBD techniques could possibly be used to have the fact that the user has started doing the subtask be what triggers the automation to be invoked.  David Maulsby's Turvy and Metamouse give hints of how this might work [TURVY CHAPTER, METAMOUSE CHAPTER].\nInaccessible data and operators\nSo far we have seen several reasons to want to process data while it resides within an application.  One is to make algorithms easier to enter by allowing the user to demonstration the algorithm through the user interface of the application.  Another is that invocations can be made easier if the data is processed within the application.  The Quickeys solution in figure 4 had these advantages, but it only partially automated the subtask.  No other programming system on my computer (including APL, C, Lisp, Scheme, or HyperTalk) can automate within Think C's editor because of the fourth obstacle, inaccessible data and operators.  In this case, this obstacle undermines the modest benefits of automating the subtask.  If the benefits per invocation were greater, then accessing the data independently of the application by saving the document to a file might have made creating the new automation worthwhile.\nIn other cases, limited data access can take the simplest algorithms and render them impossible to implement.  Consider the example discussed in [TRIGGERS CHAPTER REFERENCE] of automating the wrapping of a text field with a properly sized rounded rectangle.  The algorithm to automate this task is trivial when stated in terms of the text field's and the rounded rectangle's properties of location, length and width.  The central part of the algorithm is to set the rounded rectangle's location a bit above and to the left of the text field's location, and set the rounded rectangle's length and width to be a bit larger.  Automating this task independently of MacDraw II would involve extracting these properties from MacDraw II's coded file format, which would be very difficult.  Also, the user's algorithm may be based on special functionality provided by the application such as, in this case, the ability to create rounded rectangles.  Just-in-time programming systems should therefore be able to access properties from applications and invoke the operators provided by applications.\nSometimes an opportunity for new beneficial automation involves not so much the processing of data, but rather the repetitive manipulation of an application's user interface artifacts.  For example, the user may wish to automate the toggling between two window arrangements.  The only way a programming system can automate this is to access the state of the user interface and manipulate its components.\nDiscussion  Inaccessible data and operators is a particularly common obstacle for just-in-time programming because users must make do with whatever form their data is in when they envision the algorithm.  Usually this data exists within an application.  In contrast, task-time independent programming often allows the user to plan what form the data will be in when the automation is eventually used.  Many programming efforts, like games or educational software, are closed systems where the programmer can choose the format of the data to be whatever makes their programming effort easiest.\nSolution directions  In order for a programming system to access the data and operators of an application, there must be a communication protocol that both the programming system and the application follow.  One way to effect this protocol is to build the programming system into the application.  This strategy, however, limits the data access to the one application, so inaccessible data and operators would still be an obstacle when the user's algorithm involved multiple applications.  Therefore just-in-time programming systems should make use of specially established interapplication protocols like Apple Events [Apple 91].\nSometimes programming systems can overcome the inaccessible data and operators obstacle by using protocols established for reasons other than interapplication communication.  For example, the Quickeys solution uses the computer's keyboard input stream as a protocol to process data in the editor application.  The Triggers chapter discusses an extension to this technique where pixel data from the computer display can be used to gain a significant degree data access from any application.  PBD plays a large role in making this extension possible because the algorithms implemented using these techniques sometimes contain large bitmap constants.  Entering these bitmaps would be unwieldy if they could not be specified by demonstration.\nRisk\nThe fifth obstacle is the risk that the automation will fail, be ineffective, or produce unintended results.  Consider the risks of automating the line transformation subtask.  There are many possible scenarios.  In the best case the algorithm could have been entered almost effortlessly, and as each occurrence of a line needing the simple transformation was flagged by the compiler, I could have easily invoked the algorithm somehow.  To my surprise, perhaps more chances to use the new automation occurred than were anticipated, making the automation pay off more than expected.\nBut there are many other possible scenarios.  The algorithm could have taken a long time to enter, perhaps because some special purpose function had to be looked up in a manual.  A mistake in the implementation might have caused the new (not beneficial) automation to destroy part of the source file, perhaps too quickly to be noticed.  Limited data access could have turned the simple algorithm into one that was impossible to implement.  I was not sure exactly how many more assignments of 32-bit rectangles to 16-bit rectangles were left in my software project, and thus there may have been too few to make the programming effort worthwhile.  Unforeseen special cases may have made the envisioned algorithm simply wrong.\nA user who is considering a just-in-time programming effort has the option of continuing to work manually.  Given the many adverse scenarios, it is not surprising that the user would choose this option.  Thus just-in-time programming systems often fail because the user chooses not to use it.\nRisk was the main reason I chose not to automate the line transformation subtask.  The partial solution using keyboard macros was the only one worth considering because it was the only solution that did not require saving the file to disk.  In the past, my attempts to use keyboard macros have often been thwarted by unforeseen special cases, the difficulty of accommodating special cases into an already existing macro, and the uncontrollable speed of macros that make it difficult to verify that the macro works correctly.  In retrospect, a keyboard macro would have been worthwhile and would have prevented a few recompiles caused by typos in my manual transforming of the lines.  However at the time, the apparent risks convinced me to play it safe and transform the lines manually.\nDiscussion  Certainly all programming involves risk.  The risks of just-in-time programming are notable on two accounts.  One is that the time and effort spent implementing the algorithm relate directly to the success of the venture.  For example, any extra time or frustration involved in automating the line transformation subtask would have quickly eliminated the potential benefits.  In contrast, task-time independent programming efforts often relate only indirectly to success.  For example, say a user is programming an animated demo for a five-minute presentation.  If the demo take two hours longer to implement than expected, the presentation the next day can still be a success.\nBut the main reason risk affects just-in-time programming so strongly is that it is easy for users to choose to continue to work manually and avoid the risk.  In contrast, essential programming requires users to make the best of what their programming systems have to offer.  Users still have to assume whatever risks are present, but the programming system will not fail for lack of use.\nRisk is caused, in part, by the users' uncertainty about how the other four obstacles will affect their attempts to automate.  Thus, one way to reduce the risk is to work towards eliminating these four obstacles.  For example, if entering the algorithm were effortless, there would be no risk in taking that step.  Unfortunately, entirely eliminating these obstacles is very unlikely.  In addition, users will still have to assume the risk that their algorithms might not do as expected.  Thus, it is important to explicitly consider techniques that reduce the risks of just-in-time programming.\nSolution directions  One approach to addressing risk is to make it so that the user can accurately judge the effort required to implement the algorithm and accurately judge the benefits.  Simplicity and visibility are two attributes of a programming system that would contribute to this approach.  When users can confidently judge the benefits will be greater then the efforts, then they can proceed to profit from using the just-in-time programming system and the system will not fail from lack of use.  The limitation of this approach is that merely judging the risks is a risk in itself because the user must expend some mental effort.  Because it is unlikely that this effort can be eliminated entirely, the user will have good reason to simply continue working the task manually without ever giving the opportunity to use just-in-time programming a second thought.  Other techniques need to be considered.\nAnother approach to reducing risk is to enable users to profit from partial implementations of their algorithms.  This would help alleviate the risk that an obstacle might prevent the implementing of part of the algorithm, render the whole algorithm useless, and waste any effort already expended.  Users should be able to implement and profit from parts of their algorithms without requiring the entire algorithm to work flawlessly.\nFor example, assume a user has 20 book chapters saved as a separate MacWrite II files in a folder, and that a colleague requests a pure ASCII copy of each chapter.  To manually convert each chapter to pure ASCII, the user would have to load its file into the MacWrite II, select the Text Only option, and save it back out to disk using a different file name.  Assume files with the word \"backup\" in the file name should not be converted.  The simple algorithm in figure 5 could select all 20 chapters in turn and carry out these repetitive actions.  If the user were able to implement this algorithm, the tedium of keeping track of which files have been converted and the tedium of the repetitive actions would be avoided.\nFigure 5:  An algorithm that will convert a folder full of MacWrite II files to pure ASCII.\n\nIf the entire algorithm could be implemented confidently, easily, and flawlessly, then risk would not be an issue.  Unfortunately, any step in the algorithm could cause potential problems.  What if after putting some effort into the algorithm, the user discovers that only a subset of the nine steps can be implemented?  For example, what if step number 7 could not be implemented because the user's programming system could not invoke the operator that selects the Text Only operator?  The partial implementation can still potentially be beneficial if the user can manually do the steps that prove difficult to implement.  For example, the algorithm could invoke the \"Save As...\" dialog box and pause while the user selects Text Only manually.  The partial implementation would still be beneficial because it would take care of the tedium of keeping track of which files have been converted and a great majority of the other actions.\nFor step number 7, this strategy is easy to imagine because the application's existing user interface can allow the user to carry out the hard to implement action manually.  But what if step number 2 is too difficult to implement because the user's programming system has no built-in test for substrings?  In this case the list is in the programming system's execution environment, not the application.  If the user is to manually accomplish this step, the programming system must have an existing user interface that allows the user to manipulate the execution environment.  Some interactive programming systems and debuggers allow users to modify the execution environment during run-time, but few allow data to be manipulated easily enough for the user to do real work.  Also, the more that control has to pass between the user and their implementation, the more essential it will be that flexible invocation schemes are possible.\nEssentially the user's risk is that the manual method might be more effective than implementing the algorithm.  Therefore, another approach to addressing risk is to allow the user to pursue both alternatives in parallel.  In theory, the risk of attempting to automate the subtask would be eliminated because if unforeseen difficulties make the programming effort ineffective, then the user can fall back on the manual method already underway.\nIn practice, this approach would probably not eliminate risk, but it could reduce risk greatly.  PBD could play a large part in realizing this approach because it allows the user to implement algorithms by demonstrating on their actual task data.  In other words, the user can be programming and manually accomplishing the subtask simultaneously.  For example, recording the keyboard in figure 4 actually transforms one of the lines, so progress towards completing the overall task is hindered minimally.\nThis technique has its greatest potential when mixed with history based techniques.  For example, Allen Cypher's system Eager records the user's actions into an event history [EAGER CHAPTER].  When Eager detects the user doing repetitive actions, it indicates this to the user by highlighting what it expects the user to select next.  For certain classes of algorithms, the user can implement an algorithm at almost no risk because the user takes no special actions.  The decision of whether to invoke the algorithm still involves some risk because the exact behavior of some algorithms is difficult to predict.  Therefore additional techniques such as undo and slow motion execution will have to be extended and refined.\n\nConclusion\nIs creating a programming system that is effective for just-in-time programming an interesting research problem? The previous sections clearly show that it has not been solved already, so it meets this criterion.  A second criterion for interesting research is that there be some indication that solutions are possible.  The previous section touched on several promising research directions, many of which are based on PBD.  A third, important criterion for interesting research is that it lead to tangible benefits.  The benefits of improved just-in-time programming systems would be to allow users to better automate repetitive subtasks that arise from their unique circumstances.  The line transformation subtask was one such example where automation would have led to significant benefit.  There will always be subtasks like this that slip through the prepackaged functionality of applications because they result from the interactions of users with the complexities of the real world.  Task-time is often the only possible time to implement the algorithms that can automate these subtasks.\nBut is it necessary to focus the research problem on such a narrow slice of programming to make automating these subtasks practical?  After all, many of the obstacles facing just-in-time programming also affect other types of programming;  it is possible that researching other types of programming will produce effective just-in-time programming systems as a side effect.  Are there reasons for researching just-in-time programming specifically?\nOne reason is that a user must accomplish all of the following during task-time: assess risk, enter the algorithm, design the invocation scheme, solve data access problems, invoke the algorithm, verify correct program behavior, and resume work on the overlying task.  Thus it is crucial that techniques that support these activities be refined to a degree that other forms of research are unlikely to achieve.  For example, research that concentrates on programming-in-the-large is unlikely to adequately reduce the effort required to input the algorithm when managing program complexity is its overriding concern.  Research that assumes essential programming is unlikely consider techniques that reduce risk by enabling productive use of partially debugged programs.  Research that assumes task-time independent programming is unlikely to recognize that programming may not be the user's primary concern.  Thus it is unlikely to give adequate emphasis to minimizing distractions from the user's primary task.  It is also unlikely to motivate data and operator access that is flexible enough to process the user's data wherever it may be when the opportunity to apply just-in-time programming arises.\nAnother reason is there are solutions that are appropriate for just-in-time programming but are not necessarily appropriate for other types of programming.  For example, the pixel based techniques of Triggers [TRIGGERS CHAPTER] would not be appropriate for software that must run in the background.  The technique of programming and accomplishing the task at the same time discussed in the risk section does not make sense for programmers who are writing software for other people's use.\nBy recognizing the special nature of just-in-time programming and by addressing the limitations of current programming systems head-on, much research progress should result.  The five obstacles provide a set of subproblems that can be used to focus multiple avenues of research.  Researchers should be careful not to accentuate one obstacle in the elimination of another; it only takes one to prevent a just-in-time programming system from being effective.  It is crucial that a just-in-time programming system address risk because it is probably impossible to create a programming system where the user's every attempt at creating new automation will be profitable.  The goal should be to create a programming system where a user can know that in the worse case attempting just-in-time programming will not hinder progress towards completing the task.  Then the user will be able to confidently use the full extent of the programming system to profit from their algorithmic insights.\n\nReferences for Alan\n\n[Apple 91] Apple Computer, Inc., <Inside Macintosh, Volume VI> Addison Wesley, Reading, Massachusetts, 1991.\n\n[Cypher 86] Cypher A., \"The Structure of Users' Activities,\" <User Centered Design>, Lawrence Erlbaum Associates, Hillsdale, New Jersey, 1986.\n\n[Halbert 84] Halbert D., \"Programming by Example,\" Ph.D. Thesis, Department of Computer Science, University of California at Berkeley , 1984.\n"
      },
      "date": 1641329340068
    },
    {
      "type": "edit",
      "id": "921ea177f259d957",
      "item": {
        "type": "markdown",
        "id": "921ea177f259d957",
        "text": "It is worth emphasizing that the user's task could be from any domain (e.g. graphic drawing, scientific visualization, word processing, etc.) and that the algorithm to be implemented originates with the user.  Obviously, a user with more programming experience will be able to envision a more complex algorithm than a novice user.  How the user comes up with the algorithm is not a concern.  Also, no hint of a solution appears in the problem statement.  Any programming system could conceivably be used for just-in-time programming, including C, PASCAL, keyboard macros, scripting languages, or PBD. PBD will probably be an important part of the more successful just-in-time programming systems, but the problem statement leaves open the possibility for other solutions.\nJust-in-time programming research shares many of the motivations of other PBD research.  Chief among these is that users often do repetitive or algorithmic subtasks that the computer could be doing.  We call these subtasks potential computer subtasks and call these situations opportunities for new beneficial automation.  Because automating can increase productivity and user satisfaction and at the same time reduce errors, one would expect the user to delegate potential computer subtasks to the computer.  That users often do not take advantage of these opportunities motivates researching ways to improve the computer.  Just-in-time programming research and PBD research assert that easier to use programming tools will allow users to better take advantage of opportunities for new beneficial automation.\nJust-in-time programming research, however, is focused on making programming easier for a specific cross section of situations.  These situations are primarily defined by the user programming during task-time.  In other words, the user is attempting to write a program for a task that is already in progress.  Figure 1 summarizes the relationship between task progress and the user's expenditure of effort.  The expenditure of effort for just-in-time programming is shown separate from the other task related effort.  The difficulty of just-in-time programming results from the spreading of the user's mental resources between two activities.  Another difficulty is that the time spent programming contributes directly to total time between the start and completion of the task.\n"
      },
      "date": 1641329887228
    },
    {
      "type": "add",
      "id": "ca80aab2b586cd46",
      "item": {
        "type": "markdown",
        "id": "ca80aab2b586cd46",
        "text": "Figure 1:  Just-in-time programming intermixes programming effort with other task related effort.\n\n\n\n"
      },
      "after": "921ea177f259d957",
      "date": 1641329892547
    },
    {
      "item": {
        "type": "factory",
        "id": "43b95e8f5f339163"
      },
      "id": "43b95e8f5f339163",
      "type": "add",
      "after": "1b55857e3235aa15",
      "date": 1641329894508
    },
    {
      "type": "edit",
      "id": "43b95e8f5f339163",
      "item": {
        "type": "html",
        "id": "43b95e8f5f339163",
        "text": "<center><img width=\"100%\" src=\"data:image/png;base64,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5pGPfGSz/fbbj8qQchyJgcRAHww873nPa+68884+Z/LQuGBgpDQHSH3Qgx7U/Oqv/uq44DfnkRgYSww84AEPGPl5/exnP2ve+MY3Vpry1Kc+tfnyl7/cnHbaac3b3/725uSTTx7K+N/znvc0X//615tzzjlnUn+33357c/rppzfw9PM///PNP//zPzdvfvObm3XXXXdSu6X+YQyHHnpo84hHPGLWW6fPYVYUZYPEQGJgJWLgF37hF5pvf/vbzS677NLsvPPOzetf//rmIQ95SHPIIYfU6fzf//1fJdp+MKD867/+a/383//938a5f/mXf2n+/d//fWLqfveCts9+9rN7DzcY01lnndXcfffdzbbbblvv/Su/8iu1nXOg29+//du/1WPdf44ZU0C3vfHFNT6NI/rVHjP6p3/6p3qpMcQ8DjjggAnGEPPV6L//+7/rePQTMHKaQwxskM+77rqr+exnP1slgu9+97vNj3/84wkk0ED8PexhD2t++Zd/ufFg1lprreZJT3pS/VtvvfWaRz/60YPcZqzbWDg/+clPmic/+clznuc3vvGNKhX94Ac/aH7t136t4nrOnQxwgef6cz/3c815553X/L//9/+ab37zmw3JbL/99muOO+64Zu+9927+/u//vr4Mr3jFK5rPfOYzzW//9m/X5z+IhDTAEEayCYJGGv6N3/iNOY/v7/7u75of/vCHzYMf/OD6DJdbop3zBAa44D//8z+bz3/+883111/fXHfddc2b3vSmZt9992222WabZsMNN2zOPffc5r/+67+aF73oRc13vvOd5uEPf3jzmMc8prGeXfsXf/EXdU2/7W1vq22/9KUvNR/4wAcqPYnbf/zjH2/+4A/+IH5OfP76r/96ZTD8qH/4h39YifxWW21Vx7PXXns1l112WXPkkUc2J554Yj1Ps7FuQ6P5h3/4h+bwww+vzEyb9773vXWs+n3sYx/bfPKTn6zz0oY29JznPKeO+ZhjjmmMd4MNNmi+8IUvNLvttlvzlre8pUHvMEjazJ//+Z9XxrXJJps0559/fnPxxRc3v/M7v9M88YlPrGNCJ8GKYw64pAcEub6zff7Wb/1W86pXvaqao0gG//M//1M5oQf8H//xH5Vp/PSnP62fHvDVV19d7aW4JKL2zGc+s/55QBA0THAP4zAugEN7qTEu5/ymdt7vfver53F4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\"></center>"
      },
      "date": 1641329920258
    },
    {
      "id": "43b95e8f5f339163",
      "type": "move",
      "order": [
        "5be405ab12de44d0",
        "37a8826147eb0e1a",
        "3c894e6be1a053b1",
        "26fe073b834e8522",
        "5745e710a3f02563",
        "b67f51d14ea929c3",
        "921ea177f259d957",
        "ca80aab2b586cd46",
        "43b95e8f5f339163",
        "1b55857e3235aa15"
      ],
      "date": 1641329948186
    },
    {
      "id": "ca80aab2b586cd46",
      "type": "move",
      "order": [
        "5be405ab12de44d0",
        "37a8826147eb0e1a",
        "3c894e6be1a053b1",
        "26fe073b834e8522",
        "5745e710a3f02563",
        "b67f51d14ea929c3",
        "921ea177f259d957",
        "43b95e8f5f339163",
        "ca80aab2b586cd46",
        "1b55857e3235aa15"
      ],
      "date": 1641329956610
    },
    {
      "type": "edit",
      "id": "921ea177f259d957",
      "item": {
        "type": "markdown",
        "id": "921ea177f259d957",
        "text": "It is worth emphasizing that the user's task could be from any domain (e.g. graphic drawing, scientific visualization, word processing, etc.) and that the algorithm to be implemented originates with the user.  Obviously, a user with more programming experience will be able to envision a more complex algorithm than a novice user.  How the user comes up with the algorithm is not a concern.  Also, no hint of a solution appears in the problem statement.  Any programming system could conceivably be used for just-in-time programming, including C, PASCAL, keyboard macros, scripting languages, or PBD. PBD will probably be an important part of the more successful just-in-time programming systems, but the problem statement leaves open the possibility for other solutions.\n"
      },
      "date": 1641330107180
    },
    {
      "type": "add",
      "id": "60e7739bdc242a3d",
      "item": {
        "type": "markdown",
        "id": "60e7739bdc242a3d",
        "text": "Just-in-time programming research shares many of the motivations of other PBD research.  Chief among these is that users often do repetitive or algorithmic subtasks that the computer could be doing.  We call these subtasks *potential computer subtasks* and call these situations *opportunities for new beneficial automation*.  Because automating can increase productivity and user satisfaction and at the same time reduce errors, one would expect the user to delegate potential computer subtasks to the computer.  That users often do not take advantage of these opportunities motivates researching ways to improve the computer.  Just-in-time programming research and PBD research assert that easier to use *programming tools* will allow users to better take advantage of opportunities for new beneficial automation.\n"
      },
      "after": "921ea177f259d957",
      "date": 1641330199488
    },
    {
      "type": "add",
      "id": "52e6e49fce0e18e9",
      "item": {
        "type": "markdown",
        "id": "52e6e49fce0e18e9",
        "text": "Just-in-time programming research, however, is focused on making programming easier for a specific cross section of situations.  These situations are primarily defined by the user programming during task-time.  In other words, the user is attempting to write a program for a task that is already in progress.  Figure 1 summarizes the relationship between task progress and the user's expenditure of effort.  The expenditure of effort for just-in-time programming is shown separate from the other task related effort.  The difficulty of just-in-time programming results from the spreading of the user's mental resources between two activities.  Another difficulty is that the time spent programming contributes directly to total time between the start and completion of the task.\n"
      },
      "after": "60e7739bdc242a3d",
      "date": 1641330218753
    },
    {
      "type": "remove",
      "id": "3c894e6be1a053b1",
      "date": 1641330307016
    },
    {
      "type": "edit",
      "id": "37a8826147eb0e1a",
      "item": {
        "type": "paragraph",
        "id": "37a8826147eb0e1a",
        "text": "[[Just-in-Time Programming]] by [[Richard Potter]], Human Computer Interaction Lab, University of Maryland [http://web.media.mit.edu/~lieber/Teaching/Context/Potter.rtf rtf]"
      },
      "date": 1641330308908
    },
    {
      "type": "edit",
      "id": "5be405ab12de44d0",
      "item": {
        "type": "markdown",
        "id": "5be405ab12de44d0",
        "text": "[https://c2.com/xp/JustInTimeProgramming.html c2.com]"
      },
      "date": 1641330389432
    },
    {
      "type": "edit",
      "id": "5be405ab12de44d0",
      "item": {
        "type": "markdown",
        "id": "5be405ab12de44d0",
        "text": "An iterative approach to development. Focus on developing only what your current requirements call for. [https://c2.com/xp/JustInTimeProgramming.html c2.com]"
      },
      "date": 1641330403959
    },
    {
      "type": "edit",
      "id": "5be405ab12de44d0",
      "item": {
        "type": "markdown",
        "id": "5be405ab12de44d0",
        "text": "An iterative approach to development. Focus on developing only what your current requirements call for. [https://c2.com/xp/JustInTimeProgramming.html c2.com]  [[Do The Simplest Thing That Could Possibly Work]].  Assume that [[You Arent Gonna Need It]]."
      },
      "date": 1641330435914
    },
    {
      "type": "edit",
      "id": "ca80aab2b586cd46",
      "item": {
        "type": "markdown",
        "id": "ca80aab2b586cd46",
        "text": "Figure 1:  Just-in-time programming intermixes programming effort with other task related effort.\n"
      },
      "date": 1641970931301
    },
    {
      "item": {
        "type": "html",
        "id": "07398bac659aa1d4",
        "text": "<center>\n  <img\n    width=\"100%\"\n    src=\"http://acypher.com/wwid/Chapters/Chapter271.gif\"\n  >\n</center>"
      },
      "id": "07398bac659aa1d4",
      "type": "add",
      "after": "1b55857e3235aa15",
      "date": 1641970948680
    },
    {
      "type": "add",
      "id": "5d4947e3e1d04306",
      "item": {
        "type": "markdown",
        "id": "5d4947e3e1d04306",
        "text": "//FIXME http://acypher.com/wwid/Chapters/Chapter271.gif\nFigure 1. Two scenarios are shown of a user presented with an opportunity suitable for just-in-time programming. The intermixing of programming effort with other task related effort is shown for the second scenario where the user decides to apply just-in-time programming.\n\n\n"
      },
      "after": "ca80aab2b586cd46",
      "date": 1641970951624
    },
    {
      "type": "edit",
      "id": "07398bac659aa1d4",
      "item": {
        "type": "html",
        "id": "07398bac659aa1d4",
        "text": "<center>\n  <img\n    width=\"100%\"\n    src=\"http://acypher.com/wwid/Chapters/Chapter271.gif\"\n  >\n</center>"
      },
      "date": 1641970985735
    },
    {
      "id": "07398bac659aa1d4",
      "type": "move",
      "order": [
        "5be405ab12de44d0",
        "37a8826147eb0e1a",
        "26fe073b834e8522",
        "5745e710a3f02563",
        "b67f51d14ea929c3",
        "921ea177f259d957",
        "60e7739bdc242a3d",
        "52e6e49fce0e18e9",
        "43b95e8f5f339163",
        "ca80aab2b586cd46",
        "07398bac659aa1d4",
        "5d4947e3e1d04306",
        "1b55857e3235aa15"
      ],
      "date": 1641971118376
    },
    {
      "type": "edit",
      "id": "5d4947e3e1d04306",
      "item": {
        "type": "markdown",
        "id": "5d4947e3e1d04306",
        "text": "//FIXME http://acypher.com/wwid/Chapters/Chapter271.gif\nFigure 1. Two scenarios are shown of a user presented with an opportunity suitable for just-in-time programming. The intermixing of programming effort with other task related effort is shown for the second scenario where the user decides to apply just-in-time programming.\n\n\n"
      },
      "date": 1641971163267
    },
    {
      "type": "edit",
      "id": "1b55857e3235aa15",
      "item": {
        "type": "markdown",
        "id": "1b55857e3235aa15",
        "text": "## What is not Just-in-time Programming?\nOne might contrast just-in-time programming with, for lack of a better term, task-time independent programming which is summarized in figure 2.  For an example, consider a user who is programming a [[HyperCard]] mock-up of a user interface in preparation for a demonstration the next day.  The subtask of the software is to help an audience visualize a proposed user interface design during the meeting.  This example would be task-time independent programming because the software is created well before the meeting.  As is the case with many distinctions, there are examples that straddle the line between just-in-time programming and task-time independent programming, but the discussions that follow should hold regardless.\nFigure 2:  Task-time independent programming separates programming effort from other task-related effort.\n\n\n"
      },
      "date": 1641971276089
    },
    {
      "type": "add",
      "id": "279618ac11b7b347",
      "item": {
        "type": "markdown",
        "id": "279618ac11b7b347",
        "text": "Just-in-time programming can be contrasted with other forms of programming by considering implications of the situation characterized in the introduction.  For example, since the algorithm to be implemented is the product of the user's insight, it is typically simple.  Thus one could contrast just-in-time programming with programming-in-the-large.  For an example, developing a full featured word processor would not be just-in-time programming because an algorithm that implements all the features of a word processor is too complex for one person to envision.\n\n"
      },
      "after": "1b55857e3235aa15",
      "date": 1641971283408
    },
    {
      "type": "add",
      "id": "5fcfa3af16685de7",
      "item": {
        "type": "markdown",
        "id": "5fcfa3af16685de7",
        "text": "A Subtask Suitable for Just-in-Time Programming\nI happened upon an opportunity for just-in-time programming when Think C updated their class library to version 1.1.  Before version 1.1, rectangles were defined with 16-bit coordinates and in version 1.1 rectangles were defined by 32-bit coordinates.  When I first compiled my software project with the new class library, type mismatch errors occurred where my software expected 16-bit values.  Many of these were simple assignment statements.  The new class library included a utility function for converting 32-bit rectangles to 16-bit rectangles, so a typical fix involved changing a line of the form\n"
      },
      "after": "279618ac11b7b347",
      "date": 1641971297869
    },
    {
      "type": "add",
      "id": "2f006e42e4ec3116",
      "item": {
        "type": "markdown",
        "id": "2f006e42e4ec3116",
        "text": "So to break this situation down into the components of just-in-time programming:\nThe user: \nmyself\nThe task: \nmodifying a software project to work with an updated class library\nThe subtask: \nchanging certain lines of source code from the form {*}var1 = {*}var2; to the form longToQDRect({&}var2,{&}var1); (i.e. the line transformation subtask)\nThe algorithm: \ninsert leading white space\ninsert \"longToQDRect(\"\nif second variable name is not preceded by \"*\", insert \"&\"\ninsert second variable name\ninsert \",\"\nif first variable name is not preceded by \"*\", insert \"&\"\ninsert first variable name\ninsert \")\"\ninsert rest of line (the \";\" and comments, if any)\ndelete original line.\nThe attempt to automate:  \nActually I did not try to automate the subtask.  The rest of the chapter will explain why.\n\nFive Obstacles\nOne reason to explicitly state a problem is so that it can be broken down into meaningful subproblems.  One way to do this is to analyze current technology, identify common obstacles that prevent the technology from being effective, and let the subproblems be to find ways to eliminate these obstacles.  The following sections discuss five obstacles that often prevent users of current programming systems from profiting from their algorithmic insights.  Each section also discusses PBD's potential role in solving the subproblem represented by each obstacle.\n\t\nFigure 3:  A C algorithm that automates the line transformation subtask assuming the line has been isolated in a character buffer.\n\nEffort of entering the algorithm\nGiven that I understood the algorithmic structure of the line transformation subtask, why not automate it?  Since I was actually using a C programming system, let's first explore the possibility of using it.  Figure 3 shows a program in C that can transform the line as needed, assuming that the line has been loaded into a string (we will deal with this assumption more later).  One obstacle quickly becomes apparent: the effort of entering the algorithm.  Merely the physical effort of typing in the 749 characters of this program would likely undermine the benefits of automating this small part of the task.  But there is also the mental effort required to translate the algorithm into the idioms of the language and to work out the fine details.  For example, after years of programming in C, I still must look up the strcat function in the manual to see if it copies from the first argument to the second or vice versa.\nDiscussion  No matter what type of programming is being done, reducing this effort is desirable.  However, the effort of entering an algorithm is particularly important for just-in-time programming because the subtasks appropriate for just-in-time programming are typically special purpose needs that can not be as widely applied as functionality that is more generic.  The line transformation task is a good example of this because once I finished updating the software project, I had no need for this particular functionality.  When the benefits per programming effort are modest, only minimal effort can be expended towards entering the algorithm before the venture becomes pointless.  If the user's task is creative or involves problem solving, then the user can scarcely afford to expend mental effort for modest gains.  Of course, there are times when the payoffs of just-in-time programming are large enough that the effort to enter the algorithm is not as crucial.  But there are enough opportunities for modest payoffs that finding ways to reduce the effort required to enter the algorithm is an important subproblem to solve.\nSometimes creating new beneficial automation by programming pays off because the user can apply the automation many times in the future.  A script that automatically dials a remote computer and logs the user into their account would be a good example.  Here the distinction between just-in-time programming and task-time independent programming is blurred.  Strictly speaking, the programming effort is expended at a time independent of when the benefits of the automation are received.  However, the user is likely to automate this task at a time when they are about to dial in to the remote computer manually, that is, when the desirability of automating the subtask comes to mind.  So although the user could set aside some time and do task-time independent programming, psychologically the task-time aspects of whatever the user is doing are likely to impact the programming process.  In this sense, much of the special concerns of just-in-time programming still hold.\nReducing this effort is less important for programming-in-the-large because the effort required to manage the complexity of a large software project tends to overshadow the effort required to enter the algorithm.  In fact, programming languages such as Ada even increase the effort of entering the algorithm by requiring extra notation for modularizing the code.  Such notation does not contribute directly to functionality, but is appropriate for programming-in-the-large because complexity is such an overriding concern.\nJust-in-time programming accentuates the mental effort required to enter the algorithm because users must switch their mind-sets from the task domain to the programming domain as illustrated in figure 1.  After the algorithm has been implemented, users must also expend effort to return their mind-sets to the task domain.  Users might expend effort trying not to divert too much attention to the programming effort, sometimes trying to keep more in their short term memory than is reasonable.  For creative tasks, this diversion is especially costly.  In contrast, users who are programming independently of task time can change their mind-set over a longer period of time.\nTherefore when minimizing the effort of entering the algorithm, it is important to minimize distraction from the task.  One of the main sources of effort and distraction is the number of special programming concepts.  For example, writing the C algorithm in figure 3 required remembering how strings are allocated and referenced.  On this point, just-in-time programming and programming for novice programmers share similar goals because a programming system for novice programmers should require the understanding of as few new concepts as possible.  In cases where a just-in-time programming system is being designed specifically for novice programmers, the same would apply.\nThe idea of just-in-time programming, however, is not limited to novice programmers.  For expert programmers, whether a concept is familiar to a nonprogrammer is not the crucial factor.  Instead, the programming system should require the user to understand only concepts that can be ingrained and that the user can apply fluently.  Therefore, part of the research agenda of just-in-time programming should be to identify key skills that, if ingrained, will allow a user to more effectively write programs just in time.  These skills could be anything from something classic like regular expressions to some new esoteric programming paradigm.  It seems clear that, at least for the foreseeable future, users will have to understand the basic concepts of conditionals and iteration.\nSolution directions  Many techniques including code templates, code reuse, domain specific functionality, subroutines, copy/paste, and on-line documentation can help reduce the effort required to enter an algorithm.  PBD helps reduce this effort by allowing users to enter the algorithm using the same interface as they would normally use to work the subtask manually.  This helps reduce both the physical effort and the mental effort because the user is often well practiced at using this interface.  Since the user would use the same user interface to work the subtask manually, the artifacts are already in short term memory and programming with them is likely to be less distracting than with an off-line programming language.  The effort to enter the algorithm is also reduced because user interfaces are usually optimized to the task.\nFigure 4:  This Quickeys macro can partially automate the line transformation subtask.  The number of keystrokes required to enter the macro and the visual state of the editor are shown.\n\nFor a simple example of how PBD can reduce the effort of entering an algorithm, consider one partial solution to the line transformation subtask.  If the user first places the cursor to the left of the first variable in the line to be transformed and neither variable is a pointer, then the Quickeys macro shown in figure 4 will transform the line as required.  The macro also assumes that exactly three characters (\" = \") separate the two variable names.  Only the 33 keypresses shown in figure 4 are required to implement the macro.  The visual feedback of the editor also helps reduce the mental effort by showing intermediate results.\nLimited computational generality\nWhy illustrate the virtues of the keyboard macro by only partially automating the line transformation subtask?  The reason is that the subtask requires conditional logic to decide whether each variable is a pointer or not.  Keyboard macros only record straight-line algorithms and thus are not able to fully automate this subtask.  This illustrates an obstacle that users face when programming just in time:  the programming systems that make it easy to enter their algorithm can often only implement algorithms of limited computational generality.\nDiscussion  It is important for a just-in-time programming system to have full Turing-complete computational generality because there is no way to predict which of the vast array of algorithms the user might envision.  Unfortunately computational generality is not one of PBD's strengths.  Halbert recognized this when implementing SmallStar and concluded that control structures were better created by editing a static representation of the program than by demonstration [Halbert 84].  Others have used inference to generalize straight-line demonstrations into procedures with control structures.  Cypher's Eager and Myers' Peridot used domain knowledge to infer procedures with control structures solely from straight-line demonstrations [EAGER CHAPTER, PERIDOT CHAPTER].  The computational generality of these systems, however, was limited by limited domain knowledge.\nSolution directions  In order for a PBD to be used for just-in-time programming, it will have to be integrated with other techniques to give full computational generality.  Interesting directions include giving separate examples for each path of the algorithm as in Tinker [TINKER CHAPTER], or a combination of multiple demonstrations, inferencing, and special instructions from the user as in Metamouse [METAMOUSE CHAPTER].\nEffort of invoking algorithm\nAs stated previously, the effort to enter an algorithm is less of an obstacle when the benefits of automating are large.  So for the sake of argument, assume that I knew there would be hundreds of lines needing to be transformed and decided to automate the task using C.  Limited computational generality would not be an obstacle with C.  Are there other obstacles?\nWhen the compiler detected an error in my software project, it would load the file containing the error into its text editor and highlight the erroneous line.  To take advantage of the line transformation program, I would first have to judge if it was one of the simple type mismatch errors that could be fixed by the simple line transformation.  If so, I would then invoke the C implementation on the specific line.  But how would I do that?  One possibility would be to mark the line some special way, perhaps by placing a \"*\" at the beginning of the line, and then save the file out to disk.  Then I could run the C program which would then prompt me for the name of the file with the incorrect line.  The C program would then scan through the file for a line that started with a \"*\" and apply the transformation to it.  But this would be silly.  The effort to invoke the algorithm would undermine the benefits and would be yet another obstacle to automating this subtask.\nDiscussion  As in this case, a subtask appropriate for just-in-time programming typically applies to part of a larger document.  Thus, users must be able to implement the algorithm such that they can specify which part of the document should be processed when they invoke the algorithm.  It is important that they be able to do this with ease because the benefits to be obtained by automating can be easily negated by the invocation effort.  Unlike the effort to enter the algorithm, the effort to invoke the algorithm can not be amortized over the life of the new beneficial automation.  The effort must be small in comparison with the benefit received from each invocation of the algorithm.  When the payoffs per invocation are larger this obstacle is not as crucial, but enough opportunities for modest benefits exist that it is important to reduce the effort required to invoke algorithms implemented just in time.\nFor an example of how crucial the ease of invocation can be towards making automation beneficial, consider the feature on many word processors that allows a user to select a word simply by double clicking on it.  The word processor automatically does the tedious subtask of extending the selection out to the word boundaries.  Identifying these word boundaries manually is a simple subtask, so not much benefit is received each time the feature is used.  However, words are selected so commonly that, over time, the feature is very beneficial.  Another invocation strategy could easily undermine this benefit.  For example, even requiring the user to click on the word and then select the feature from a pull down menu could require too much effort.\nAs the previous example implies, this obstacle is not unique to just-in-time programming.  Because the effort to invoke the algorithm can not be amortized, any programming endeavor that produces interactive software needs to pay special attention to this obstacle.  The main difference for just-in-time programming is that the user can not amortize the effort to create the invocation scheme as much.\nSolution directions  How should just-in-time programming make it easy to invoke algorithms?  One clue is strongly implied by the hypothetical consideration of C for automating the line transformation subtask:  users should be able to implement their algorithms such that they can perform the subtask without having to save their documents to disk.  Instead their algorithms should be able to process data in its present form which is usually internal to some application.  Thus just-in-time programming systems should allow users to process data within their applications.  In addition, users should be able to use the application's data selection mechanisms to indicate what part of their document to process.  This would enable users to work manually, apply a newly implemented algorithm to the data, and continue to work manually without the overhead of saving the data to a file. Processing data within applications is central to PBD, so it already goes far to easing the effort to invoke the algorithm.\nBeyond automating within applications, just-in-time programming systems should allow the user to choose among various invocation strategies.  Standard invocations such as menu selections and keypresses should be supported.  The ability to create more refined invocations, like double clicking on a an object to apply some automation to it, would be important for making some highly interactive automation worth creating.  PBD techniques could possibly be used to have the fact that the user has started doing the subtask be what triggers the automation to be invoked.  David Maulsby's Turvy and Metamouse give hints of how this might work [TURVY CHAPTER, METAMOUSE CHAPTER].\nInaccessible data and operators\nSo far we have seen several reasons to want to process data while it resides within an application.  One is to make algorithms easier to enter by allowing the user to demonstration the algorithm through the user interface of the application.  Another is that invocations can be made easier if the data is processed within the application.  The Quickeys solution in figure 4 had these advantages, but it only partially automated the subtask.  No other programming system on my computer (including APL, C, Lisp, Scheme, or HyperTalk) can automate within Think C's editor because of the fourth obstacle, inaccessible data and operators.  In this case, this obstacle undermines the modest benefits of automating the subtask.  If the benefits per invocation were greater, then accessing the data independently of the application by saving the document to a file might have made creating the new automation worthwhile.\nIn other cases, limited data access can take the simplest algorithms and render them impossible to implement.  Consider the example discussed in [TRIGGERS CHAPTER REFERENCE] of automating the wrapping of a text field with a properly sized rounded rectangle.  The algorithm to automate this task is trivial when stated in terms of the text field's and the rounded rectangle's properties of location, length and width.  The central part of the algorithm is to set the rounded rectangle's location a bit above and to the left of the text field's location, and set the rounded rectangle's length and width to be a bit larger.  Automating this task independently of MacDraw II would involve extracting these properties from MacDraw II's coded file format, which would be very difficult.  Also, the user's algorithm may be based on special functionality provided by the application such as, in this case, the ability to create rounded rectangles.  Just-in-time programming systems should therefore be able to access properties from applications and invoke the operators provided by applications.\nSometimes an opportunity for new beneficial automation involves not so much the processing of data, but rather the repetitive manipulation of an application's user interface artifacts.  For example, the user may wish to automate the toggling between two window arrangements.  The only way a programming system can automate this is to access the state of the user interface and manipulate its components.\nDiscussion  Inaccessible data and operators is a particularly common obstacle for just-in-time programming because users must make do with whatever form their data is in when they envision the algorithm.  Usually this data exists within an application.  In contrast, task-time independent programming often allows the user to plan what form the data will be in when the automation is eventually used.  Many programming efforts, like games or educational software, are closed systems where the programmer can choose the format of the data to be whatever makes their programming effort easiest.\nSolution directions  In order for a programming system to access the data and operators of an application, there must be a communication protocol that both the programming system and the application follow.  One way to effect this protocol is to build the programming system into the application.  This strategy, however, limits the data access to the one application, so inaccessible data and operators would still be an obstacle when the user's algorithm involved multiple applications.  Therefore just-in-time programming systems should make use of specially established interapplication protocols like Apple Events [Apple 91].\nSometimes programming systems can overcome the inaccessible data and operators obstacle by using protocols established for reasons other than interapplication communication.  For example, the Quickeys solution uses the computer's keyboard input stream as a protocol to process data in the editor application.  The Triggers chapter discusses an extension to this technique where pixel data from the computer display can be used to gain a significant degree data access from any application.  PBD plays a large role in making this extension possible because the algorithms implemented using these techniques sometimes contain large bitmap constants.  Entering these bitmaps would be unwieldy if they could not be specified by demonstration.\nRisk\nThe fifth obstacle is the risk that the automation will fail, be ineffective, or produce unintended results.  Consider the risks of automating the line transformation subtask.  There are many possible scenarios.  In the best case the algorithm could have been entered almost effortlessly, and as each occurrence of a line needing the simple transformation was flagged by the compiler, I could have easily invoked the algorithm somehow.  To my surprise, perhaps more chances to use the new automation occurred than were anticipated, making the automation pay off more than expected.\nBut there are many other possible scenarios.  The algorithm could have taken a long time to enter, perhaps because some special purpose function had to be looked up in a manual.  A mistake in the implementation might have caused the new (not beneficial) automation to destroy part of the source file, perhaps too quickly to be noticed.  Limited data access could have turned the simple algorithm into one that was impossible to implement.  I was not sure exactly how many more assignments of 32-bit rectangles to 16-bit rectangles were left in my software project, and thus there may have been too few to make the programming effort worthwhile.  Unforeseen special cases may have made the envisioned algorithm simply wrong.\nA user who is considering a just-in-time programming effort has the option of continuing to work manually.  Given the many adverse scenarios, it is not surprising that the user would choose this option.  Thus just-in-time programming systems often fail because the user chooses not to use it.\nRisk was the main reason I chose not to automate the line transformation subtask.  The partial solution using keyboard macros was the only one worth considering because it was the only solution that did not require saving the file to disk.  In the past, my attempts to use keyboard macros have often been thwarted by unforeseen special cases, the difficulty of accommodating special cases into an already existing macro, and the uncontrollable speed of macros that make it difficult to verify that the macro works correctly.  In retrospect, a keyboard macro would have been worthwhile and would have prevented a few recompiles caused by typos in my manual transforming of the lines.  However at the time, the apparent risks convinced me to play it safe and transform the lines manually.\nDiscussion  Certainly all programming involves risk.  The risks of just-in-time programming are notable on two accounts.  One is that the time and effort spent implementing the algorithm relate directly to the success of the venture.  For example, any extra time or frustration involved in automating the line transformation subtask would have quickly eliminated the potential benefits.  In contrast, task-time independent programming efforts often relate only indirectly to success.  For example, say a user is programming an animated demo for a five-minute presentation.  If the demo take two hours longer to implement than expected, the presentation the next day can still be a success.\nBut the main reason risk affects just-in-time programming so strongly is that it is easy for users to choose to continue to work manually and avoid the risk.  In contrast, essential programming requires users to make the best of what their programming systems have to offer.  Users still have to assume whatever risks are present, but the programming system will not fail for lack of use.\nRisk is caused, in part, by the users' uncertainty about how the other four obstacles will affect their attempts to automate.  Thus, one way to reduce the risk is to work towards eliminating these four obstacles.  For example, if entering the algorithm were effortless, there would be no risk in taking that step.  Unfortunately, entirely eliminating these obstacles is very unlikely.  In addition, users will still have to assume the risk that their algorithms might not do as expected.  Thus, it is important to explicitly consider techniques that reduce the risks of just-in-time programming.\nSolution directions  One approach to addressing risk is to make it so that the user can accurately judge the effort required to implement the algorithm and accurately judge the benefits.  Simplicity and visibility are two attributes of a programming system that would contribute to this approach.  When users can confidently judge the benefits will be greater then the efforts, then they can proceed to profit from using the just-in-time programming system and the system will not fail from lack of use.  The limitation of this approach is that merely judging the risks is a risk in itself because the user must expend some mental effort.  Because it is unlikely that this effort can be eliminated entirely, the user will have good reason to simply continue working the task manually without ever giving the opportunity to use just-in-time programming a second thought.  Other techniques need to be considered.\nAnother approach to reducing risk is to enable users to profit from partial implementations of their algorithms.  This would help alleviate the risk that an obstacle might prevent the implementing of part of the algorithm, render the whole algorithm useless, and waste any effort already expended.  Users should be able to implement and profit from parts of their algorithms without requiring the entire algorithm to work flawlessly.\nFor example, assume a user has 20 book chapters saved as a separate MacWrite II files in a folder, and that a colleague requests a pure ASCII copy of each chapter.  To manually convert each chapter to pure ASCII, the user would have to load its file into the MacWrite II, select the Text Only option, and save it back out to disk using a different file name.  Assume files with the word \"backup\" in the file name should not be converted.  The simple algorithm in figure 5 could select all 20 chapters in turn and carry out these repetitive actions.  If the user were able to implement this algorithm, the tedium of keeping track of which files have been converted and the tedium of the repetitive actions would be avoided.\nFigure 5:  An algorithm that will convert a folder full of MacWrite II files to pure ASCII.\n\nIf the entire algorithm could be implemented confidently, easily, and flawlessly, then risk would not be an issue.  Unfortunately, any step in the algorithm could cause potential problems.  What if after putting some effort into the algorithm, the user discovers that only a subset of the nine steps can be implemented?  For example, what if step number 7 could not be implemented because the user's programming system could not invoke the operator that selects the Text Only operator?  The partial implementation can still potentially be beneficial if the user can manually do the steps that prove difficult to implement.  For example, the algorithm could invoke the \"Save As...\" dialog box and pause while the user selects Text Only manually.  The partial implementation would still be beneficial because it would take care of the tedium of keeping track of which files have been converted and a great majority of the other actions.\nFor step number 7, this strategy is easy to imagine because the application's existing user interface can allow the user to carry out the hard to implement action manually.  But what if step number 2 is too difficult to implement because the user's programming system has no built-in test for substrings?  In this case the list is in the programming system's execution environment, not the application.  If the user is to manually accomplish this step, the programming system must have an existing user interface that allows the user to manipulate the execution environment.  Some interactive programming systems and debuggers allow users to modify the execution environment during run-time, but few allow data to be manipulated easily enough for the user to do real work.  Also, the more that control has to pass between the user and their implementation, the more essential it will be that flexible invocation schemes are possible.\nEssentially the user's risk is that the manual method might be more effective than implementing the algorithm.  Therefore, another approach to addressing risk is to allow the user to pursue both alternatives in parallel.  In theory, the risk of attempting to automate the subtask would be eliminated because if unforeseen difficulties make the programming effort ineffective, then the user can fall back on the manual method already underway.\nIn practice, this approach would probably not eliminate risk, but it could reduce risk greatly.  PBD could play a large part in realizing this approach because it allows the user to implement algorithms by demonstrating on their actual task data.  In other words, the user can be programming and manually accomplishing the subtask simultaneously.  For example, recording the keyboard in figure 4 actually transforms one of the lines, so progress towards completing the overall task is hindered minimally.\nThis technique has its greatest potential when mixed with history based techniques.  For example, Allen Cypher's system Eager records the user's actions into an event history [EAGER CHAPTER].  When Eager detects the user doing repetitive actions, it indicates this to the user by highlighting what it expects the user to select next.  For certain classes of algorithms, the user can implement an algorithm at almost no risk because the user takes no special actions.  The decision of whether to invoke the algorithm still involves some risk because the exact behavior of some algorithms is difficult to predict.  Therefore additional techniques such as undo and slow motion execution will have to be extended and refined.\n\nConclusion\nIs creating a programming system that is effective for just-in-time programming an interesting research problem? The previous sections clearly show that it has not been solved already, so it meets this criterion.  A second criterion for interesting research is that there be some indication that solutions are possible.  The previous section touched on several promising research directions, many of which are based on PBD.  A third, important criterion for interesting research is that it lead to tangible benefits.  The benefits of improved just-in-time programming systems would be to allow users to better automate repetitive subtasks that arise from their unique circumstances.  The line transformation subtask was one such example where automation would have led to significant benefit.  There will always be subtasks like this that slip through the prepackaged functionality of applications because they result from the interactions of users with the complexities of the real world.  Task-time is often the only possible time to implement the algorithms that can automate these subtasks.\nBut is it necessary to focus the research problem on such a narrow slice of programming to make automating these subtasks practical?  After all, many of the obstacles facing just-in-time programming also affect other types of programming;  it is possible that researching other types of programming will produce effective just-in-time programming systems as a side effect.  Are there reasons for researching just-in-time programming specifically?\nOne reason is that a user must accomplish all of the following during task-time: assess risk, enter the algorithm, design the invocation scheme, solve data access problems, invoke the algorithm, verify correct program behavior, and resume work on the overlying task.  Thus it is crucial that techniques that support these activities be refined to a degree that other forms of research are unlikely to achieve.  For example, research that concentrates on programming-in-the-large is unlikely to adequately reduce the effort required to input the algorithm when managing program complexity is its overriding concern.  Research that assumes essential programming is unlikely consider techniques that reduce risk by enabling productive use of partially debugged programs.  Research that assumes task-time independent programming is unlikely to recognize that programming may not be the user's primary concern.  Thus it is unlikely to give adequate emphasis to minimizing distractions from the user's primary task.  It is also unlikely to motivate data and operator access that is flexible enough to process the user's data wherever it may be when the opportunity to apply just-in-time programming arises.\nAnother reason is there are solutions that are appropriate for just-in-time programming but are not necessarily appropriate for other types of programming.  For example, the pixel based techniques of Triggers [TRIGGERS CHAPTER] would not be appropriate for software that must run in the background.  The technique of programming and accomplishing the task at the same time discussed in the risk section does not make sense for programmers who are writing software for other people's use.\nBy recognizing the special nature of just-in-time programming and by addressing the limitations of current programming systems head-on, much research progress should result.  The five obstacles provide a set of subproblems that can be used to focus multiple avenues of research.  Researchers should be careful not to accentuate one obstacle in the elimination of another; it only takes one to prevent a just-in-time programming system from being effective.  It is crucial that a just-in-time programming system address risk because it is probably impossible to create a programming system where the user's every attempt at creating new automation will be profitable.  The goal should be to create a programming system where a user can know that in the worse case attempting just-in-time programming will not hinder progress towards completing the task.  Then the user will be able to confidently use the full extent of the programming system to profit from their algorithmic insights.\n\nReferences for Alan\n\n[Apple 91] Apple Computer, Inc., <Inside Macintosh, Volume VI> Addison Wesley, Reading, Massachusetts, 1991.\n\n[Cypher 86] Cypher A., \"The Structure of Users' Activities,\" <User Centered Design>, Lawrence Erlbaum Associates, Hillsdale, New Jersey, 1986.\n\n[Halbert 84] Halbert D., \"Programming by Example,\" Ph.D. Thesis, Department of Computer Science, University of California at Berkeley , 1984.\n"
      },
      "after": "5fcfa3af16685de7",
      "date": 1641971303338
    },
    {
      "type": "edit",
      "id": "279618ac11b7b347",
      "item": {
        "type": "markdown",
        "id": "279618ac11b7b347",
        "text": "Just-in-time programming can be contrasted with other forms of programming by considering implications of the situation characterized in the introduction.  For example, since the algorithm to be implemented is the product of the user's insight, it is typically simple.  Thus one could contrast just-in-time programming with programming-in-the-large.  For an example, developing a full featured word processor would not be just-in-time programming because an algorithm that implements all the features of a word processor is too complex for one person to envision.\n\n"
      },
      "date": 1641971308618
    },
    {
      "type": "add",
      "id": "37122d1b9316951a",
      "item": {
        "type": "markdown",
        "id": "37122d1b9316951a",
        "text": "Another implication of the situation characterized earlier is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\n\n"
      },
      "after": "279618ac11b7b347",
      "date": 1641971314299
    },
    {
      "type": "edit",
      "id": "37122d1b9316951a",
      "item": {
        "type": "markdown",
        "id": "37122d1b9316951a",
        "text": "Another implication of the situation characterized earlier is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\n\n"
      },
      "date": 1641971321273
    },
    {
      "type": "add",
      "id": "017090bcd890bbe4",
      "item": {
        "type": "markdown",
        "id": "017090bcd890bbe4",
        "text": "How does just-in-time programming relate to the more common PBD application of programming for novice programmers? These two types of programming are basically independent;  programming in a given situation could represent both, one, or neither of these.  \n"
      },
      "after": "37122d1b9316951a",
      "date": 1641971337957
    },
    {
      "type": "edit",
      "id": "37122d1b9316951a",
      "item": {
        "type": "markdown",
        "id": "37122d1b9316951a",
        "text": "Another implication of the situation characterized earlier is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\n\n"
      },
      "date": 1641971347006
    },
    {
      "type": "edit",
      "id": "37122d1b9316951a",
      "item": {
        "type": "markdown",
        "id": "37122d1b9316951a",
        "text": "Another implication of the situation characterized earlier is that the user has the option of avoiding programming altogether because the user can continue to manually accomplish the subtask.  Thus one might contrast just-in-time programming with, for lack of a better term, essential programming where the necessity of programming is accepted.  For example, a programmer who is creating software that performs a communication task on a satellite does not have the option of accomplishing the task manually.  Thus the programming effort is essential.\n\n"
      },
      "date": 1641971377963
    },
    {
      "type": "edit",
      "id": "017090bcd890bbe4",
      "item": {
        "type": "markdown",
        "id": "017090bcd890bbe4",
        "text": "How does just-in-time programming relate to the more common PBD application of programming for novice programmers? These two types of programming are basically independent;  programming in a given situation could represent both, one, or neither of these.  \n"
      },
      "date": 1641971443528
    },
    {
      "type": "add",
      "id": "5777e0a76f3a54ae",
      "item": {
        "type": "markdown",
        "id": "5777e0a76f3a54ae",
        "text": "A novice programmer writing a short program that changes all numbers in a document to a larger font would be an example of both types of programming, assuming the user was about to make the modifications by hand.  A novice programmer writing educational software to be used by students at a later time would be an example of a novice programmer programming, but not just-in-time programming.  I recently modified a postscript file to only print out the even pages of the document and then the odd pages so that it would print on both sides of the paper without requiring me to issue a separate print command for each page.  This would be an example of just-in-time programming that was not programming for the novice.\n\n\n"
      },
      "after": "017090bcd890bbe4",
      "date": 1641971444752
    },
    {
      "type": "edit",
      "id": "5fcfa3af16685de7",
      "item": {
        "type": "markdown",
        "id": "5fcfa3af16685de7",
        "text": "A Subtask Suitable for Just-in-Time Programming\nI happened upon an opportunity for just-in-time programming when Think C updated their class library to version 1.1.  Before version 1.1, rectangles were defined with 16-bit coordinates and in version 1.1 rectangles were defined by 32-bit coordinates.  When I first compiled my software project with the new class library, type mismatch errors occurred where my software expected 16-bit values.  Many of these were simple assignment statements.  The new class library included a utility function for converting 32-bit rectangles to 16-bit rectangles, so a typical fix involved changing a line of the form\n"
      },
      "date": 1641971517291
    },
    {
      "type": "add",
      "id": "8500011ce45ded08",
      "item": {
        "type": "markdown",
        "id": "8500011ce45ded08",
        "text": "\n"
      },
      "after": "5fcfa3af16685de7",
      "date": 1641971524426
    },
    {
      "item": {
        "type": "code",
        "id": "e265f8914f538469",
        "text": "*inset=frame;"
      },
      "id": "e265f8914f538469",
      "type": "add",
      "after": "2f006e42e4ec3116",
      "date": 1641971526957
    },
    {
      "type": "edit",
      "id": "e265f8914f538469",
      "item": {
        "type": "code",
        "id": "e265f8914f538469",
        "text": "*inset=frame;"
      },
      "date": 1641971533713
    },
    {
      "id": "e265f8914f538469",
      "type": "move",
      "order": [
        "5be405ab12de44d0",
        "37a8826147eb0e1a",
        "26fe073b834e8522",
        "5745e710a3f02563",
        "b67f51d14ea929c3",
        "921ea177f259d957",
        "60e7739bdc242a3d",
        "52e6e49fce0e18e9",
        "43b95e8f5f339163",
        "ca80aab2b586cd46",
        "07398bac659aa1d4",
        "5d4947e3e1d04306",
        "1b55857e3235aa15",
        "279618ac11b7b347",
        "37122d1b9316951a",
        "017090bcd890bbe4",
        "5777e0a76f3a54ae",
        "5fcfa3af16685de7",
        "8500011ce45ded08",
        "e265f8914f538469",
        "2f006e42e4ec3116"
      ],
      "date": 1641971574782
    },
    {
      "id": "e265f8914f538469",
      "type": "move",
      "order": [
        "5be405ab12de44d0",
        "37a8826147eb0e1a",
        "26fe073b834e8522",
        "5745e710a3f02563",
        "b67f51d14ea929c3",
        "921ea177f259d957",
        "60e7739bdc242a3d",
        "52e6e49fce0e18e9",
        "43b95e8f5f339163",
        "ca80aab2b586cd46",
        "07398bac659aa1d4",
        "5d4947e3e1d04306",
        "1b55857e3235aa15",
        "279618ac11b7b347",
        "37122d1b9316951a",
        "017090bcd890bbe4",
        "5777e0a76f3a54ae",
        "5fcfa3af16685de7",
        "e265f8914f538469",
        "8500011ce45ded08",
        "2f006e42e4ec3116"
      ],
      "date": 1641971583483
    },
    {
      "type": "edit",
      "id": "8500011ce45ded08",
      "item": {
        "type": "markdown",
        "id": "8500011ce45ded08",
        "text": "\n"
      },
      "date": 1641971591954
    },
    {
      "type": "add",
      "id": "f5afc6ca40da3c65",
      "item": {
        "type": "markdown",
        "id": "f5afc6ca40da3c65",
        "text": "to the form\n"
      },
      "after": "8500011ce45ded08",
      "date": 1641971596820
    },
    {
      "type": "add",
      "id": "5528af9204e0b71a",
      "item": {
        "type": "markdown",
        "id": "5528af9204e0b71a",
        "text": "Various other types of errors were found and fixed as well.  The second time an assignment of a 32-bit rectangle to a 16-bit rectangle caused an error, I recalled that there were many such assignments throughout my program and concluded I would, in time, be transforming many lines from assignment statements into function calls. Each would differ only in the names of the variables and whether each variable was a pointer or not (i.e. preceded by a \"*\").  For the rest of this paper, transforming one of these lines will be called the line transformation subtask.\nTo attempt to automate this subtask would have been just-in-time programming because of the situation.  This particular example also contrasts well with the other types of programming discussed above.  It would certainly not be task-time independent programming because I was in the midst of modifying my software project.  The subtask was algorithmically simple so it was not programming-in-the-large.  Automating the subtask was not essential, so it was not essential programming.\n"
      },
      "after": "f5afc6ca40da3c65",
      "date": 1641971608964
    },
    {
      "type": "edit",
      "id": "5fcfa3af16685de7",
      "item": {
        "type": "markdown",
        "id": "5fcfa3af16685de7",
        "text": "A Subtask Suitable for Just-in-Time Programming\nI happened upon an opportunity for just-in-time programming when Think C updated their class library to version 1.1.  Before version 1.1, rectangles were defined with 16-bit coordinates and in version 1.1 rectangles were defined by 32-bit coordinates.  When I first compiled my software project with the new class library, type mismatch errors occurred where my software expected 16-bit values.  Many of these were simple assignment statements.  The new class library included a utility function for converting 32-bit rectangles to 16-bit rectangles, so a typical fix involved changing a line of the form\n"
      },
      "date": 1641971619398
    },
    {
      "id": "e265f8914f538469",
      "type": "move",
      "order": [
        "5be405ab12de44d0",
        "37a8826147eb0e1a",
        "26fe073b834e8522",
        "5745e710a3f02563",
        "b67f51d14ea929c3",
        "921ea177f259d957",
        "60e7739bdc242a3d",
        "52e6e49fce0e18e9",
        "43b95e8f5f339163",
        "ca80aab2b586cd46",
        "07398bac659aa1d4",
        "5d4947e3e1d04306",
        "1b55857e3235aa15",
        "279618ac11b7b347",
        "37122d1b9316951a",
        "017090bcd890bbe4",
        "5777e0a76f3a54ae",
        "5fcfa3af16685de7",
        "e265f8914f538469",
        "408bda90c3142bd6",
        "8500011ce45ded08",
        "f5afc6ca40da3c65",
        "5528af9204e0b71a",
        "2f006e42e4ec3116"
      ],
      "date": 1641971622723,
      "error": {
        "type": "error",
        "msg": "Internal Server Error",
        "response": "Server Ignoring move. Try reload."
      }
    },
    {
      "type": "add",
      "id": "408bda90c3142bd6",
      "item": {
        "type": "markdown",
        "id": "408bda90c3142bd6",
        "text": " to the form longToQDRect(&frame,inset);. \n"
      },
      "after": "5fcfa3af16685de7",
      "date": 1641971630727
    },
    {
      "type": "edit",
      "id": "e265f8914f538469",
      "item": {
        "type": "code",
        "id": "e265f8914f538469",
        "text": "*inset=frame;"
      },
      "date": 1641971634513
    },
    {
      "type": "fork",
      "date": 1641971638279
    },
    {
      "type": "remove",
      "id": "f5afc6ca40da3c65",
      "date": 1641971655620
    },
    {
      "item": {
        "type": "factory",
        "id": "915045a4726e296e"
      },
      "id": "915045a4726e296e",
      "type": "add",
      "after": "2f006e42e4ec3116",
      "date": 1641971660213
    },
    {
      "type": "remove",
      "id": "915045a4726e296e",
      "date": 1641971663207
    },
    {
      "item": {
        "type": "factory",
        "id": "8075dff77027be9f"
      },
      "id": "8075dff77027be9f",
      "type": "add",
      "after": "2f006e42e4ec3116",
      "date": 1641971665851
    },
    {
      "id": "8075dff77027be9f",
      "type": "move",
      "order": [
        "5be405ab12de44d0",
        "37a8826147eb0e1a",
        "26fe073b834e8522",
        "5745e710a3f02563",
        "b67f51d14ea929c3",
        "921ea177f259d957",
        "60e7739bdc242a3d",
        "52e6e49fce0e18e9",
        "43b95e8f5f339163",
        "ca80aab2b586cd46",
        "07398bac659aa1d4",
        "5d4947e3e1d04306",
        "1b55857e3235aa15",
        "279618ac11b7b347",
        "37122d1b9316951a",
        "017090bcd890bbe4",
        "5777e0a76f3a54ae",
        "5fcfa3af16685de7",
        "e265f8914f538469",
        "408bda90c3142bd6",
        "8500011ce45ded08",
        "5528af9204e0b71a",
        "8075dff77027be9f",
        "2f006e42e4ec3116"
      ],
      "date": 1641971669378
    },
    {
      "id": "8075dff77027be9f",
      "type": "move",
      "order": [
        "5be405ab12de44d0",
        "37a8826147eb0e1a",
        "26fe073b834e8522",
        "5745e710a3f02563",
        "b67f51d14ea929c3",
        "921ea177f259d957",
        "60e7739bdc242a3d",
        "52e6e49fce0e18e9",
        "43b95e8f5f339163",
        "ca80aab2b586cd46",
        "07398bac659aa1d4",
        "5d4947e3e1d04306",
        "1b55857e3235aa15",
        "279618ac11b7b347",
        "37122d1b9316951a",
        "017090bcd890bbe4",
        "5777e0a76f3a54ae",
        "5fcfa3af16685de7",
        "e265f8914f538469",
        "408bda90c3142bd6",
        "8500011ce45ded08",
        "8075dff77027be9f",
        "5528af9204e0b71a",
        "2f006e42e4ec3116"
      ],
      "date": 1641971675976
    },
    {
      "type": "remove",
      "id": "8075dff77027be9f",
      "date": 1641971680740
    },
    {
      "item": {
        "type": "factory",
        "id": "a714d3608ae0bfb7"
      },
      "id": "a714d3608ae0bfb7",
      "type": "add",
      "after": "2f006e42e4ec3116",
      "date": 1641971696299
    },
    {
      "id": "a714d3608ae0bfb7",
      "type": "move",
      "order": [
        "5be405ab12de44d0",
        "37a8826147eb0e1a",
        "26fe073b834e8522",
        "5745e710a3f02563",
        "b67f51d14ea929c3",
        "921ea177f259d957",
        "60e7739bdc242a3d",
        "52e6e49fce0e18e9",
        "43b95e8f5f339163",
        "ca80aab2b586cd46",
        "07398bac659aa1d4",
        "5d4947e3e1d04306",
        "1b55857e3235aa15",
        "279618ac11b7b347",
        "37122d1b9316951a",
        "017090bcd890bbe4",
        "5777e0a76f3a54ae",
        "5fcfa3af16685de7",
        "e265f8914f538469",
        "408bda90c3142bd6",
        "8500011ce45ded08",
        "a714d3608ae0bfb7",
        "5528af9204e0b71a",
        "2f006e42e4ec3116"
      ],
      "date": 1641971703936
    },
    {
      "type": "edit",
      "id": "a714d3608ae0bfb7",
      "item": {
        "type": "code",
        "id": "a714d3608ae0bfb7",
        "text": "longToQDRect(&frame,inset);"
      },
      "date": 1641971713829
    },
    {
      "type": "edit",
      "id": "5528af9204e0b71a",
      "item": {
        "type": "markdown",
        "id": "5528af9204e0b71a",
        "text": ".\n"
      },
      "date": 1641971720722
    },
    {
      "type": "add",
      "id": "7a507bdf0e4f872e",
      "item": {
        "type": "markdown",
        "id": "7a507bdf0e4f872e",
        "text": "Various other types of errors were found and fixed as well.  The second time an assignment of a 32-bit rectangle to a 16-bit rectangle caused an error, I recalled that there were many such assignments throughout my program and concluded I would, in time, be transforming many lines from assignment statements into function calls. Each would differ only in the names of the variables and whether each variable was a pointer or not (i.e. preceded by a \"*\").  For the rest of this paper, transforming one of these lines will be called the line transformation subtask.\nTo attempt to automate this subtask would have been just-in-time programming because of the situation.  This particular example also contrasts well with the other types of programming discussed above.  It would certainly not be task-time independent programming because I was in the midst of modifying my software project.  The subtask was algorithmically simple so it was not programming-in-the-large.  Automating the subtask was not essential, so it was not essential programming.\n"
      },
      "after": "5528af9204e0b71a",
      "date": 1641971727748
    },
    {
      "type": "edit",
      "id": "408bda90c3142bd6",
      "item": {
        "type": "markdown",
        "id": "408bda90c3142bd6",
        "text": "to the form \n"
      },
      "date": 1641971739456
    }
  ]
}