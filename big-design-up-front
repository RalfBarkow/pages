{
  "title": "Big Design Up Front",
  "story": [
    {
      "type": "html",
      "text": "<b>Summary:</b>",
      "id": "77b45a0c3bbbc19e3f99be602d13da62"
    },
    {
      "type": "html",
      "text": "\nThe term [[Big Design Up Front]] is commonly used to describe methods of software development where a \"big\" detailed design is created <i>before</i> coding and testing takes place. Several [[Extreme Programming]] (XP) advocates have said that such \"big\" designs are not necessary, and that most design should occur throughout the development process. While Xp does have initial design (the [[System Metaphor]]), it is considered to be a relatively \"small\" design. Much of this page disputes the amount of up-front design required for software projects.",
      "id": "e6b9c028a11436800dd404917442fc7b"
    },
    {
      "type": "html",
      "text": "\"every OOA/D begins with identifying the problem space entities that are relevant to solving the problem. Once the relevant entities are identified one identifies the relationships in the problem space between those entities that are relevant to solving the problem in hand. One records both in a Class Diagram. Only then does one move on to identifying detailed responsibilities, dynamics, and flow of control collaborations.\" - H.S.Lahman (in 2006, folks)",
      "id": "0a96172d4d8e2e01f61ebf7f6f8a1198"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "<b>Design as part of the planning process</b>",
      "id": "5d267d79768630713e3b7e71fd1a1255"
    },
    {
      "type": "html",
      "text": "<i>\"In preparing for battle I have always found that plans are useless, but planning is indispensable.\" [Eisenhower quote taken from [[Planning Extreme Programming]]]</i>",
      "id": "b62eca9bc04864a3526d8d2473338e81"
    },
    {
      "type": "html",
      "text": "\nOr as [[Jerry Weinberg]] put it \"the <i>documentation</i> is nothing; the <i>documenting</i> is everything\".",
      "id": "ec633e236cb60c1de2154794f03a89c5"
    },
    {
      "type": "html",
      "text": "<i>\"A mistake in initial dispositions can seldom be put right.\" and \"No plan survives its first contact with the enemy.\" [Field Marshal von Moltke]</i> -- [[Josh Stults]]",
      "id": "3b1defcda3976d53900f618388f252c8"
    },
    {
      "type": "html",
      "text": "\nPerhaps it is the social and intellectual activity of designing, rather than the designs themselves that are important. Is it the scope of design or the attitude <i>towards</i> design that needs to change? -- [[Chris Steinbach]]",
      "id": "5074fa000294fadac50119424b8c4a41"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "<b>Some Up Front Design Required?</b>",
      "id": "17b0662d34cb2900cea74e8d1d19964b"
    },
    {
      "type": "html",
      "text": "[This section originally followed the Smalltalk design/prototyping discussion.]",
      "id": "701360bc17c69984f36c39aab5fd22f4"
    },
    {
      "type": "html",
      "text": "<i>Even in Smalltalk, though, some design has to be done upfront [...]. [What goes on the desktop, number of services and support machines, legacy connections, etc.]</i>",
      "id": "d210f970c77e4ee83fabd9ddc0ba5b28"
    },
    {
      "type": "html",
      "text": "\nWhich of these things can't be decided one at a time, when its turn comes to be implemented?",
      "id": "17e83d07ca437d317dbbe4a2a7243c68"
    },
    {
      "type": "html",
      "text": "<i>I can't really stand up in front of a project review team for a $60M call center installation and suggest that they \"read the code\" in order to understand whether the resulting system will satisfy the very real 3-second response-time constraint.</i>",
      "id": "52bba3a3eb943d5084a71fc7b7bd72ca"
    },
    {
      "type": "html",
      "text": "\nWhat makes reading the document more convincing? When our top customer challenged whether our system could be fast enough, we measured it, ran it in 10 parallel processes and measured it again. Did the math. <b>That</b> was convincing. -- [[Ron Jeffries]]",
      "id": "12f2de3b0a5dabc4e4613560c9ae59e9"
    },
    {
      "type": "html",
      "text": "<i>Did you document those tests? Make them repeatable? Did you prove that they would scale and the results would scale predictably?</i>",
      "id": "7617e4e439af588bfd64c12d12c53f4a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "<i>Which of these things can't be decided one at a time, when its turn comes to be implemented?</i>",
      "id": "11e6efcf34387fdc7094be324f318d0a"
    },
    {
      "type": "html",
      "text": "\nThe ones that have to be funded by the client <i>before</i> the subsystem is built. The ones where the client wants to know ahead of time how much the total solution is likely to cost.",
      "id": "d366db901451cf6097b7b03135f63917"
    },
    {
      "type": "html",
      "text": "<i>What makes reading the document more convincing?</i>",
      "id": "1e272b2a78bee589a82982af50887e22"
    },
    {
      "type": "html",
      "text": "\nThe fact that the document is written in English, and most of the review team (particularly the managers and recommenders whose approval is needed to close the phase and pay the bill) haven't read or written code in 30 years, if at all. Many system problems, such as call centers, don't succumb so readily to simple demonstrations of blazing speed. In my example, the <b>response time</b> of a call center is as likely to be affected by network load and the number of network transfers (because of network latency) as the performance of any one system. A data transfer that requires 100 hops at 100 milliseconds per hop is going to burn 10 seconds in transfer time, even if the participating systems are infinitely fast.",
      "id": "ea4b76cf1508c3b7267cd667388ea9b0"
    },
    {
      "type": "html",
      "text": "\nIn the hardware world, the \"design\", especially of a complex system, is how you answer questions about how close to critical limits you are, what margins of safety you've built in, how you know that a particular beam is thick enough or cooling element big enough. The same sort of thing has to be done in software, especially in mission- or life-critical applications. And it is NOT all in the source code, it's as much in the interconnections among components. And those <i>aren't</i> in the source code. No code is an island.",
      "id": "48494272054cee7a1abf5ff384b3c64e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "<b>Design and Architecture</b>",
      "id": "13a273d6807086e4ef3a9d55393cacf4"
    },
    {
      "type": "html",
      "text": "\nThe words [[Big Design Up Front]] do bring to mind something of the aim of much architectural design in the building sense. Good design often follows where Big Ideas precede Detail Design. Conversely it is rare for small scale, pragmatic Detail Design alone to bring forth Great (or even worthy) Architecture. Of course, some Big Ideas are so far removed from the pragmatics as to be spurious as Design generators. As noted in [[Noo Has Nothing To Do With Software]], the key seems to be to correlate Big Ideas that have a genuine relationship with the item being designed.",
      "id": "51bfb5335751b601087d9a245e778ab1"
    },
    {
      "type": "html",
      "text": "\n[[Big Design Up Front]] in architecture does not require that every aspect of the design is predetermined. However it does provide a powerful reference for evaluation of subsequent ideas in the iterative design process.",
      "id": "efc6ba3e95e559d9bb6bab71afa760f5"
    },
    {
      "type": "html",
      "text": "-- [[Martin Noutch]]",
      "id": "3d05bd61c9729d88876b9cc1dac353b6"
    },
    {
      "type": "html",
      "text": "\nWe are perhaps learning the need to be humbler at this stage of software development, Martin. But I guess the nearest parallel in [[Extreme Programming]] to what you're referring to as good and necessary [[Big Design Up Front]] in physical architecture is the [[System Metaphor]]. After that greatness comes (if it ever does) through brilliant teamwork on the detail. But see also the unresolved questions in [[External And Internal Design]]. -- [[Richard Drake]]",
      "id": "afc3aa921650de662625d44bba3b73c0"
    },
    {
      "type": "html",
      "text": "\nI'm not sure about the [[Extreme Programming]] people or the exact meaning of [[Big Design Up Front]], but a high-level up-front design is generally regarded by most as important to large-scale object-oriented software systems. There's a tremendous amount of quantification to support the position. However, in software, this high-level design is very dynamic and changes as implementation is created. For a long time, one could get away with nothing more than [[Code And Test]] and Refactoring, but as systems become more complex, a need arises for some consideration to high-level designs and strategies. This is maybe why there is such a rift between [[Software Architect]]s and [[Extreme Programming]]. Extreme Programmers don't agree with this position - and they may be right for the type of apps they develop. But some [[Extreme Programming]] enthusiasts are even hostile to the idea of [[Software Architecture]]. -- [[Robert Di Falco]]",
      "id": "46c5d4e4a9d6bca8d2a0388e1a93b074"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "<b>Design Documents</b>",
      "id": "b5df09b76c85ced976f7b9214f2faeba"
    },
    {
      "type": "html",
      "text": "\nI'm clearly the only programmer left who doesn't use Smalltalk at all. ",
      "id": "20f7c4ac3c15f703b9238d256294c1ad"
    },
    {
      "type": "html",
      "text": "\nI'm in an environment where I get pieces of a very large system to write. I start out by writing up a little analysis document that I use to ensure that I understand the requirements. I then write up a high level design and check to make sure that it will take care of all the requirements in the analysis. Then I refine the high level design into a low level design. I often write code to do this, sometimes I decide that [[The Source Code Is The Design]], other times I [[Use Prototypes To Challenge Assumptions]]. I don't, however, allow the design document to omit any information that is needed in order to understand the code. That means that I'm always twiddling the design doc while I'm writing the code. It's not really all that onerous either because I use the design doc as a sort of checklist that tells me when I'm done with the code. If I change my mind about how to do something I change the doc so that I can check off what I've really done. If I didn't do that then I'd have stuff on the doc that never got checked off and I'd have code that got written for no apparent reason. It seems like the same kind of relationship the Extreme guys have with Unit Tests. One result is that the design is definitely not done until the code is. We keep our design docs in revision control and I find that I always check in my designs when I check in my code.",
      "id": "ee3dfbc3ae4c4fcad7eec912b3491cae"
    },
    {
      "type": "html",
      "text": "\nI guess my point is that I believe strongly in [[Big Design Up Front]] - but only for a little part of the whole program at a time. <i>Wouldn't that be [[Little Design All Along]]?</i>",
      "id": "8196d75a66b30188c55628c94f5b2cfa"
    },
    {
      "type": "html",
      "text": "<i>An [[Extreme Programmer]] might write tests to represent what the code had to do, and then code until they ran. What is the documentation cycle adding to the story? If you have the tests, why aren't they sufficient to know when you're done? And if you don't, how do you know when to check something off? -- [[Ron Jeffries]]</i>",
      "id": "6a7f3005aa7dcad89548170554c9f31e"
    },
    {
      "type": "html",
      "text": "\nHow do you test the tests? How do you explain the purpose behind the test? How do you relate the test to the system? Design and documentation are still necessary. ",
      "id": "0c235ae72731abe06af536f1478d0f36"
    },
    {
      "type": "html",
      "text": "\nWhat output, in the end, does one have from the testing process? Is it correct that essentially one has, after the tests have run, simply a linear numbered list such as \"test0001 - OK. test0002 - OK. test0003 - failed. test0004 - OK.\"? Such a list fails to relate the significance of the test to the architecture of the system, in terms the customer can understand. Therefore, it could be argued that what the documentation cycle \"adds to the story\" is an additional level of abstraction of describing what the system should do in an arbitrarily expressive form (i.e. natural or formal language). However, with additional tools, perhaps the output of the testing process could be raised to a higher level of abstraction - say, by putting tests within a hierarchy, modeling dependencies between tests, etc. However, perhaps exactly this sort of modeling is the type of \"Design\" that XP claims is unnecessary.",
      "id": "56c96179c1cb0df46521e90b894a29c0"
    },
    {
      "type": "html",
      "text": "<i>Actually, it helps if the tests are actually named after what they're testing - \"testFunctionBlahReturnsTrueForGoodValues - OK, testGettingResultsFromDatabase - OK, testSomeOtherBusinessRule - OK\"</i>",
      "id": "3860060c0dee57e3b5f2c42c95cd590e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "<i>[[Smalltalk As Design Prototype Language]] moved to another page</i>",
      "id": "93c7f0b88f65d0caf6354c99dc60e53d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "<b>Other Discussion:</b>",
      "id": "20d333ba0ffae3bef1f1903b9d2f86fe"
    },
    {
      "type": "html",
      "text": "\nI don't keep up to date on the methodology wars, and it seems everyone's more on a patterns bandwagon of late, but last I recall ~92 the prevailing sensible view (i.e. matching mine) seemed to be some variation on cyclical development (recursive-parallel, iterated \"analyze a little, design a little, code a little, test a little\", whatever).",
      "id": "1aa6239f47b4cf0475dbddaade272bc2"
    },
    {
      "type": "html",
      "text": "\nHaven't looked at [[The Deadline]], but the write-up here make it sound as though a lot of experience is being discarded, especially as indicated in the \"don't allow implementation until the very last minute\" notion.",
      "id": "03769a4f3488e9c93b616fe7dbda8b9f"
    },
    {
      "type": "html",
      "text": "\nI'm big on design, compared to many here (to me the work is in design; coding is the process of converting that into a specific computer language and typing it in, and occurs quickly and semi-automatically) but always within that context of a larger cycle. This [[Big Design Up Front]] thing as described seems to be trouble waiting to happen. -- [[Jim Perry]]",
      "id": "99a9a3e99abadc374c6271cc72a43255"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "What is the problem statement that [[Extreme Programming]] is a good solution for? What is the problem statement that [[Big Design Up Front]] is a good solution for? I read that Nickolas Tesla pictured a fully designed and working alternating current generator in his head before he even started working on one.",
      "id": "b28143ef992ce1d54845c854185e43b9"
    },
    {
      "type": "html",
      "text": "\nMaybe [[Big Design Up Front]] is the correct solution when you already know everything you need to know and are ever going to know about a system before you start it. Why experiment and iterate if you aren't going to learn something?",
      "id": "9094de2769db2888813bf26ed2adb5c6"
    },
    {
      "type": "html",
      "text": "<i>Sounds impossible as stated, boring if it were. If I knew everything, wouldn't I know the design and not need [[Big Design Up Front]]? -- r</i>",
      "id": "95894ce110bc3eb39e0454c30f6ca407"
    },
    {
      "type": "html",
      "text": "\nMaybe [[Big Design Up Front]] is the correct solution when the medium you are working in is incomprehensible once it is built/written (e.g. machine code).",
      "id": "aeec577325c4655cb45ffcc7925927e2"
    },
    {
      "type": "html",
      "text": "\n[[Big Design Up Front]] is only appropriate when reached via a moment of satori. --[[Mark Janssen]]",
      "id": "5d8cd3602f0672853b3bbf56f04bd26c"
    },
    {
      "type": "html",
      "text": "<i>No one ever built a machine code program without debugging. We used to do lots of thinking and desk checking not because it was better than debugging, but because it was hard to get time on the machine. -- r</i>",
      "id": "eaac0b08c1219f8b366e7c0c35cf60c2"
    },
    {
      "type": "html",
      "text": "\nMaybe [[Big Design Up Front]] is the correct solution when the medium you are working in is unchangeable once it is built/written (e.g. Hubble Telescope). ",
      "id": "7c4e7924909edb6b90d1c21e45ca77cf"
    },
    {
      "type": "html",
      "text": "<i>[actually, wasn't there a big problem (focus) when Hubble (the telescope) first went up in 1990? Oh, and since it was only corrected 3 1/2 years later, this is where BDUF comes in...]</i>",
      "id": "bc55e4b2c6ef508b77cb2f459b504c71"
    },
    {
      "type": "html",
      "text": "<i>Actually the Hubble was built on the ground, and changed in space. I think, though, that the learning point is most important. You will learn: what's the best way in your circumstances? -- [[Ron Jeffries]]</i> ",
      "id": "ec6d2af58e216fb0fdc11f32b04936d4"
    },
    {
      "type": "html",
      "text": "<i>Interestingly, the Hubble's big problem came about because a test was incorrectly set up, and the telescope was built to pass that test. -- [[Dave Van Buren]]</i>",
      "id": "4d061d55cb2eb98002b2b9ca5576f8cd"
    },
    {
      "type": "html",
      "text": "-- [[Stan Silver]]",
      "id": "d3f2a3f9c03e1ca9e1a7542c1f0337c3"
    },
    {
      "type": "html",
      "text": "\nOff-topic clarification: The Hubble's main defractor was ground based on a faulty reference lens. The design was perfect, but an implementation flaw crept in. The flaw was an aberration of some sort, I think the result of a incorrectly calibrated instrument. In relation to that lens, though, the main Hubble mirror was the most precisely built instrument ever at the time it was created. The application of the aluminum coating, used for ultraviolet reflection, was a big worry (if the aluminum oxidized, it would have been about as reflective as black felt to ultraviolet light), but went off without a hitch because the process was so well designed and understood in advance. The reflectivity exceeded their best hopes! They called the fix \"glasses\" for the Hubble, but I forget whether it was optical or electronic. There are many web sites devoted to the instrument. I'm not sure whether this anecdote has any application to this discussion. Beware of metaphors! -- Brent",
      "id": "74018458b0644bac5371f3479f1b8e74"
    },
    {
      "type": "html",
      "text": "<i>The Hubble's mirror physically warped in space because of thermal contraction. This is something that could have been tested here, on the ground. This was not an implementation flaw so far as I can see; this was a \"what could possibly go wrong?\" kind of flaw (not sure what you'd call that - a <b>process</b> flaw perhaps?).  The fix for this was a hunk of glass ground to a lens with a deliberate </i>counter-astigmatism<i>. The basic idea is the same as you find in Schmidt-Cassegrain telescopes: those use a </i>spherical<i> mirror, and a front-end lens with a </i>hyperbolic<i> form factor to counter the spherical aberration that the primary mirror introduces. As you can see, the fix is aptly named - it </i>literally<i> is a set of glasses for the telescope.</i>",
      "id": "140f4dc47f91a13f9d9bdc560b370a2b"
    },
    {
      "type": "html",
      "text": "\nAdditional notes to the above clarification, at the risk of drifting further OT: The corrective lens was optical, and called COSTAR. They were actually two lenses on a single device, that was placed between the Big Lens and space. They defracted the light in such a way that it nullified the imperfection in the main lens (light from the center and light from sides weren't being focussed on the same place, resulting in blur) The problem occurred due to a tiny piece of paint that bladdered off a metal tube, thus creating an imperfection on one of the calibration lenses, results shown above. To bring it back to the main point of this page: I don't think any BDUF-designer could have thought up that something as miniscule as a small bladder of paint would have cause this problem, as it's not in the scope of the Big Design. Had the engineers followed a continuous testing-implementing-testing cycle they would have been more likely to spot such a problem, I think. (Sorry if this is 'Wrong'-ish on this Wiki, first time posting after lots of reading with great interest.) -- [[Sander Bol]]",
      "id": "d0fff6c2b431417eb6fb3869c4cdd492"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "To continue my last statement: Where is the most efficient and cost effective time and medium to do your experimenting, tinkering, and rearranging?",
      "id": "2bcf841b36deec9fd9f0d508de2b7306"
    },
    {
      "type": "html",
      "text": "\nMaybe the primary purpose (primary use?) of design notations is for tinkering, not for specifying? Maybe the better they are for specifying, the worse they are for tinkering, so the complicated ones don't get used?",
      "id": "0a3865b2f9e432f95c5e9a0ff1288360"
    },
    {
      "type": "html",
      "text": "\nIf I understand correctly, XPers seem to have come to the conclusion that stories, CRC, units tests, Smalltalk (and Wiki?) are the best phases/mediums for doing their tinkering and rearranging. Others do major tinkering in some [[Design Phase]]/design notation during iterations; still others do major tinkering in a big design phase/design notation at the beginning of a project. -- [[Stan Silver]]",
      "id": "7d91654c134bca5828afb15c74751166"
    },
    {
      "type": "html",
      "text": "<i>I can't speak for XPers, but I prefer to do my tinkering and rearranging in a medium that can tell me whether my current tinkering is working. I just don't trust my ability to think through everything - I know from experience that I always overlook something. I do most of my tinkering in code because it lets me know right away when my thinking is flawed.</i> -- [[Jason Arhart]]",
      "id": "30ec95ba9d484fbdf81b4486878f1170"
    },
    {
      "type": "html",
      "text": "\nHow about [[Use The Least Expensive Medium In Which You Can Learn As Much As Is Productive About The Particular Problem Domain You Are Exploring]]? Or maybe, [[Match The Cost Of Your Medium To The Level Of Knowledge Uncertainty]]? Hard to make it pithy. Anyway, here is the core of the issue from my perspective: In the phrase \"Big Design Up Front\", what is meant by the word \"Design\"? What problem domain are you exploring when you're \"tinkering\" or \"designing\" or whatever you want to call it? Are you exploring the essential requirements and user-perceptible form of the product (what should it do?), or are you exploring how to satisfy those requirements with libraries, data structures, and algorithms (how should it do it)? If the former, then code is a *very* expensive medium in which to learn that huge product changes are necessary - and trust me, if you haven't prototyped it, you will learn that huge product changes are necessary. (Try building a prototype with paper, or Powerpoint, or even VB - much cheaper media). If the latter, then by all means start coding - unless you've built the product once already, you're going to need the code to keep you honest, and writing reams of techn specs (that no one will read) will only waste time. (No harm in some interactive white-boarding along the way though.) Obviously, at some point there is a fine line between exploring the product and exploring its implementation ... But there is great efficiency to be gained if you can find where that line is and use it to keep projects from flailing. -- [[Jesse Watson]]",
      "id": "284a9bd09e7bd20f95bf6b98bf0e1c92"
    },
    {
      "type": "html",
      "text": "\nGeorge Orwell is quoted as saying 'I write to clarify my own thinking.' In the same way, I use design is as a way to clarify my own thinking about the problem and possible solutions. I find that tinkering with the problem in English or pseudo-code helps me realize a good enough design to get started with. It is all about having a reasonable enough initial approach that can be iterated on throughout the development process. -- [[Bryan Edds]]",
      "id": "edee1ccc29daaf1f7223c157a6db6d5b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "Another angle (to steal a knowledge representation technique from [[What Is Analysis]] page):",
      "id": "5788d69d70cebfcc5e1e9e8ef241c367"
    },
    {
      "type": "html",
      "text": " <b>Group 0</b>, software development is a trial and error process",
      "id": "4c4eb77b04d5d9068098df951457b90f"
    },
    {
      "type": "html",
      "text": " <b>Group 1</b>, software development is a series of deterministic transformations\nGroup 0 tries to partition their trial and error (into different mediums and time intervals) in a way that minimizes cost and time to market.",
      "id": "346662330a877d84c2c893bfe2dfe878"
    },
    {
      "type": "html",
      "text": "\nGroup 1 concerns themselves with specifying and capturing the complete and correct output of each transformation phase (since the assumption is that it is correct).",
      "id": "bc74f66505d463536f7711ee3dcd1b91"
    },
    {
      "type": "html",
      "text": "\nWhen some of group 1's code isn't accepted by the user, it is a \"mistake\" - they didn't do one of their transformations correctly. When some of group 0's code isn't accepted by the user, they fix it. -- [[Stan Silver]]",
      "id": "a436dd004980fe5bf1cf53007784a752"
    },
    {
      "type": "html",
      "text": "<i>I think the tendency to do [[Big Design Up Front]] may come from the confusion that non-programmers (I suppose) have: They see coding as manufacturing, not as design. So, quite logically, they want the product to be designed before it's manufactured, like in any other industry. Except that, after the supposed design is done, another design (plus refactorings) must be done by the coders. I suggest that, most of the time, seeing coding as manufacturing is a [[Notion Smell]]. -- [[Anonymous Donor]]</i>",
      "id": "e4546b5c403c3cb57a95ba21be034049"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "I like that characterization. :-) -- [[Alistair Cockburn]]",
      "id": "baaa91767d47e967ca42a4472a6af80d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "Two comments:",
      "id": "d95f5f6fc68ae4309a6324fd13b4feb4"
    },
    {
      "type": "html",
      "text": " I'm never sure whether the word `design` means what some thing looks like to the user, or what it looks like to the people creating and/or fixing the same thing.",
      "id": "dc48cfa1a28a6edcd86e8f7c3680ab6d"
    },
    {
      "type": "html",
      "text": " The best size of <i>design up front</i> surely depends on both the situation, and how fast that situation is changing.",
      "id": "3eb74fc3d4ebbbc4445023bc12c6a429"
    },
    {
      "type": "html",
      "text": "-- [[Dick Botting]]",
      "id": "0916623a1183e9b6f312f55825a6ad59"
    },
    {
      "type": "html",
      "text": "'Design' has to be one of the most over-used and mis-used words around at present. Consider whether other words are really meant, e.g. 'make', 'write' etc. For me, 'Design' encompasses a wide ranging process of investigation, evaluation, problem-solving and creative decision-making. Thoughtful analysis is the key to this.",
      "id": "a69b0ff59737d8b03be59a43baf67810"
    },
    {
      "type": "html",
      "text": "\nThe outrage of so much of modern (building/environmental) 'design' is that there is clearly no commitment to this process of thoughtful analysis, just a quick, commercially led and superficial decision-making process that only just precedes the actual making of the building by the Contractors.",
      "id": "26be766ee3d29905b772514f50471923"
    },
    {
      "type": "html",
      "text": "-- [[Martin Noutch]]",
      "id": "3d05bd61c9729d88876b9cc1dac353b6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "A nice quote from a \"[[Murphys Law]]\" calendar we have at work:",
      "id": "4d2da82ad6c938e4608aa165967fc039"
    },
    {
      "type": "html",
      "text": "Reisner's Rule of Conceptual Inertia",
      "id": "c4485f846edbda4815b9686cfdef69df"
    },
    {
      "type": "html",
      "text": "\"If you think big enough, you'll never have to do it.\"",
      "id": "04902c87a97b2d5ce3e6d1f6b7905fa6"
    },
    {
      "type": "html",
      "text": "What is it that makes some of us want to procrastinate, often in very creative ways? I think this may be part of the dynamic of [[Big Design Up Front]].",
      "id": "f98071470dc91348d0295cf97e00ec61"
    },
    {
      "type": "html",
      "text": "-- [[Jeff Mantei]]",
      "id": "ef93536781cc574fe464d580ffd33764"
    },
    {
      "type": "html",
      "text": "\nA good example IMHO of [[Conceptual Inertia]] is the [[Tunes Project]].",
      "id": "53f7a44b01f16febd1c3a23332caa1b6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "I guess I'm a little fuzzy on what is meant by [[Big Design Up Front]]. Does it mean detailed design? Or a high level design of the overall project/product? Because I believe you need some sort of high level design up front. A customer cannot \"steer\" the project if they do not know - on a high level - what they want this project to become. Details can change and features can be added and deleted, but you should know from the outset if you are building an IDE or just a word processor.",
      "id": "eab18e877632f49d12cfcc8f0d9045e6"
    },
    {
      "type": "html",
      "text": "-- [[Nicole Willson]]",
      "id": "e38a841b8603681031ade52479743dc4"
    },
    {
      "type": "html",
      "text": "\nI think [[Big Design Up Front]] (a.k.a. BDUF) is a waterfall-style attempt to do lots and lots of one phase (specifically design) before starting the next, and thus, to forsake any chance to get feedback.",
      "id": "9c31bd91d836d05c8934a6a1efef38da"
    },
    {
      "type": "html",
      "text": "\nThe alternative probably ought to be called [[Design As You Go]] (later: or better still, [[Continuous Design]]). -- [[Paul Chisholm]]",
      "id": "0534736efc8215a5c0a208c585092fcf"
    },
    {
      "type": "html",
      "text": "\nActually, I think that it should be called [[Not Enough Design]] - I don't have complete enough design that I can formally test against a formal requirements (in XP being code and unit tests), but I have enough of a design to send me on a wrong way with costly re-writes.",
      "id": "a801124c9f900aa8c332ce161385512c"
    },
    {
      "type": "html",
      "text": "\nI'd argue that all people do some level of up front design (on any level of granularity), simply by knowing the context. Of course, it would be a very interesting experiment, to try to build a system w/o people who build it knowing the context. Say just give a programmer a story (or part of), existing code w/o anything else. And then have a control team that works with the full context knowledge.",
      "id": "d205183118f8427b72f261b606741ab1"
    },
    {
      "type": "html",
      "text": "<i>I see this fairly often: programmers build \"infrastructure\" without knowing how those systems will be used. The result is typically bloated and difficult to use, because [[You Might Need It]]. A clear idea of requirements and/or the YAGNI principle is needed to cure this ailment.</i>",
      "id": "e0de965992c623f3decc18cd8f958326"
    },
    {
      "type": "html",
      "text": "[Don't know whether the following still belongs here]",
      "id": "157920711b1789c56401ace9d690b1d6"
    },
    {
      "type": "html",
      "text": "\nI prefer now instead of building a system say discovering a system. Then, you think about your system as a tree with the \"whole\" represented by the root and definite details as the leaves. With traditional methodologies, you do breadth first search/discovery. With agile ones, you do depth first. As anyone who implemented tree search algorithms, in depth first you need to hold less state -> your tree can actually change outside the branch you're just exploring w/o affecting your search.",
      "id": "16066a3a308a982fbc585088e26c6a1d"
    },
    {
      "type": "html",
      "text": "-- [[Vlad Ender]]",
      "id": "1084f310d27fe48753dee91b3307be1b"
    },
    {
      "type": "html",
      "text": "\nI think XP is more about going from the leaves up to the root, and [[Big Design Up Front]] is more about going from the root to the leaves. This is why XP tends to <i>discover</i> the tree. It comes from the leaves (the <i>real need</i> of the customers), and refactor as it discovers more leaves. Then it design some branches, and so on, up to the root. For me, that's the meaning of [[Design As You Go]] or [[Continuous Design]].",
      "id": "e73fd31b20c5cd5d0e934552d6a430a4"
    },
    {
      "type": "html",
      "text": "-- [[Cyrille Gachot]]",
      "id": "f41a75a5397b951428dc7e2bcc03414b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "<b>A customer cannot \"steer\" the project if they do not know - on a high level - what they want this project to become.</b>",
      "id": "eba7a275ce3d8981f3629c16d9532b17"
    },
    {
      "type": "html",
      "text": "\nI found this statement interesting because I found it 180 degrees opposed to my viewpoint. I feel the customer (specifically the front line users) know exactly what the project should become. It is the <i>developers</i> who need to know what the project should become. The question are the more effective and efficient means of communication from the users to the developers.",
      "id": "4e97f67da32f3315ab9100382a7a2b8a"
    },
    {
      "type": "html",
      "text": "\nThe problems I see with \"Big Design Up Front\" are that the two parties most interested in the communication (users and developers) are omitted; and the context of the user environment is lost when a large document listing precisely defined requirements is created.",
      "id": "37ecd5c9535a3046a99be08b0d0c0f6f"
    },
    {
      "type": "html",
      "text": "\nI have become firmly convinced that there is no substitute for having individual developers spend a day with individual users and understanding the environment of the user's job. The developers invariably come back from the experience with drastically changed views of what they should be doing. Developers have to intuitively make hundreds of unconscious decisions while creating software; direct user experience provides a context for those decisions.",
      "id": "93050e520320df65824d3be5de8e271d"
    },
    {
      "type": "html",
      "text": "\nAgain, the point is how best to get information and knowledge communicated from users to developers.",
      "id": "88a6366677aa7503f30a06b1ebbf54ad"
    },
    {
      "type": "html",
      "text": "-- [[Wayne Mack]]",
      "id": "7566e2a782d8b0b3b62e16f8b33e1b95"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "Is [[Big Design Up Front]] the same as [[Big Design]]? Should the pages be merged or at least refactored and crosslinked?",
      "id": "0b0bb3a99847a7fa5edf2a07889564ac"
    },
    {
      "type": "html",
      "text": "\nI think we should preserve the wording of \"Big Design\" linked with \"Up Front\". I don't think we can limit the size of the design, just the amount we do up front. Design should be an ongoing activity.",
      "id": "af433efca4afa47fb8fd603a9850ce94"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "Has anyone else considered whether methods of design and implementation are related to one's mental skills and abilities as much or more than they are about finding the \"best\" objective way to produce a machine? If someone is a spatial thinker, they will use very different ways of envisioning the way something works than will someone whose preferred way of thinking is logically-based. Most up front designers, I would guess, have spatial thinking skills - they want to utilized their skill with understanding structural relationships, while XPers might be better at process logic, and want to focus on the working interaction of components. But modes of thinking and abstracting have a big effect on how we go about constructing things. -- Brent",
      "id": "cc1508abcc849d49dc0145983b6be61e"
    },
    {
      "type": "html",
      "text": "<i>I'm not sure that you can prefer spatial thinking to logical. Both are heavily ingrained in the brain, as evidenced by a few sentences taken from any conversation. Things that have nothing to do with space or force are expressed in those terms.</i>",
      "id": "1399f992a5770e1ddb6915b475800b31"
    },
    {
      "type": "html",
      "text": "\nI think both types of thinking are needed, the question is the order in which they are applied. In [[Big Design Up Front]], one tries to apply only spatial thinking to create a design followed by only logical thinking to implement the design. In the XP iterative approach, one first applies logical thinking to [[Do The Simplest Thing That Could Possibly Work]], then one applies spatial thinking to [[Re Factor]], then one repeats the entire cycle. -- [[Wayne Mack]]",
      "id": "3dbe5d75941a9379daaa9b0e8757fcd0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "The discussions on this page were reordered for clarity. Does anyone but me see the irony of this?",
      "id": "cede523f0db74f3211e1594a892aa317"
    },
    {
      "type": "html",
      "text": "<i>Sorry. Such is the nature of [[Thread Mode]]. This page is not a design - it is an ongoing discussion waiting to be trimmed down to [[Dialectic Mode]] some fine day. Have at it.</i>",
      "id": "0d7863c585ba593ab0c8276ca3aad722"
    },
    {
      "type": "html",
      "text": "\nI missed the irony. Is it that the [[Big Design Up Front]] page was not designed and developed in one pass, but was done iteratively?",
      "id": "191b8a71103df3f385af94bc3c856953"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "The [[Big Design Up Front]] may also be seen as the [[High Level Design Up Front]]. I know that I don't always think of the details of how I will implement the tiny constructs (the new ones to add to the system) as much I am looking at the over all picture. In taking my senior level courses, we always were told to approach what was to by developed on a large scale. Though using this term confused most of us at first because we were trying to do everything at once. Stepping back and rethinking about what was being stated, we realized that thinking on a more abstract scale or of the overall design was large whereas thinking of every single detail brought us closer to getting the minor things solved. The [[Big Design Up Front]] is how you would like to get things rolling, and then time and the details will help to focus on what to change and to make sure your initial vision is maintained, if still needed. -- YemiIDBedu",
      "id": "412728b408d7addedeed1bdff7a58e75"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "This seems to overlap [[Analysis Paralysis]]",
      "id": "48d545603bae38281e90955f0ed7c82e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "I stumbled across this set of comments by accident while looking for something on [[Requirements Tracking]], and have been fascinated by the different points of view on design. As with most areas of disagreement, I believe many of these disagreements come from differing perspectives and experience.",
      "id": "94fb8c23978c48d2fb626241be001236"
    },
    {
      "type": "html",
      "text": "\nMy long years of experience in systems (over 35 years) have taught me that up-front design is always good. The only problem is in how much knowledge is available to do the design. BDUF is only possible in some situations. Consider these differing types of projects:",
      "id": "585b51bf5bd935cba67caa5603b9682f"
    },
    {
      "type": "html",
      "text": " knowledge of requirements: a lot is known (redevelopment of a legacy system) versus a leading edge relationship marketing system where requirements are developed as the system is built",
      "id": "6e1cc86448ff26d87c37e32b04b2e5b4"
    },
    {
      "type": "html",
      "text": " size of project: small (under ten staff) to large (over 100 staff)",
      "id": "1b011f45e4470ae10ae53ffbd1396545"
    },
    {
      "type": "html",
      "text": " knowledge of the system: the customer knows the system but the developers are new, or the senior staff of the project knows what is needed but the programmers do not, or the development team is experienced and has done this type of system before but the customer has not",
      "id": "68ab8a713b9c06c55d12a3d728039894"
    },
    {
      "type": "html",
      "text": "\nI believe one can see that in some cases above, more information is available to contribute to a good design, and in other cases, little information is available. In some cases (small project, little knowledge of requirements) the XP approach may be best. In other cases (small project, customers know the system), the XP approach will likely be as successful as any other approach.",
      "id": "f62c626feb46187f62c435dab9f20c26"
    },
    {
      "type": "html",
      "text": "\nBut in many other cases, up-front design will save overall time and money, and contribute to a better system. For example, in a large project (over 100 staff), how do you even know it is a large system unless some up-front work is done? Can a project manager set 100 programmers loose without some idea of what is to be built? (maybe in the case where the team has done the system many times already...).",
      "id": "4b5d349c17a58b7b0213aa4318c72ac0"
    },
    {
      "type": "html",
      "text": "\nAn experienced project manager knows that a plan (or design) is not perfect, and will evolve as more information becomes available. Good development methodologies allow for multiple iterative passes from the high level to detail, and call for prototyping of critical components early in the project.",
      "id": "bec9b238ea3ef0b9373c9f3ee7fdb4c1"
    },
    {
      "type": "html",
      "text": "\nI hope this contributes to the debate. -- [[Neil Carscadden]]",
      "id": "da140b6e90a4a3d524274b37401f37dd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "I've spent a great many years studying various project methodologies. On this particular issue, it is my opinion that both camps have points to concede.",
      "id": "1da915ab78b6862a9a31e10e5feffb0e"
    },
    {
      "type": "html",
      "text": "\nFirst off, the BDUF crowd needs to acknowledge that even in their world architecture and design are not completely specified up front but are in fact emergent. In nearly all projects, a certain amount of experimental work has to be done to answer any significant questions or mitigate any serious risks that could impact the success of the effort. There nearly always is a set of unknowns that can be resolved only through actual construction. This process is generally called R&D (research and development), and the result is a prototype that defines the basic nature of the end product. It establishes a framework upon which everything else can be built. The BDUF crowd tends to delineate this as a separate task (or sometimes even a separate project), and in many cases it's performed by a different team. XP, on the other hand, just considers it to be part of the overall process.",
      "id": "a6b296f4fc23f5ffb9aa3afafeb6c3e4"
    },
    {
      "type": "html",
      "text": "\nSecond, the XP crowd needs to acknowledge that even they commit to a design early on. One has to in order to get anything done. One cannot rework the whole system for each new feature. ",
      "id": "4aa6d4b87ce6f0da2d09f4d6af13d213"
    },
    {
      "type": "html",
      "text": " Any environment that requires system-wide rework for many features is not using XP. The whole point of refactoring is to minimize the change impact time and cost. Instead of 'commit to a design' you negotiate features with the client, which gives them what they most want in a shorter timespan than BDUF (and is much safer).",
      "id": "fdbbcca86c678c48716b64971b392966"
    },
    {
      "type": "html",
      "text": " The 'point' of refactoring may be to minimize change impact time and cost, but the <i>actual mechanism</i> of refactoring relies on the <i>assumption</i> that the functionality you'll be adding in the future look very similar to functionality you added in the past. This is not the case for all features, especially for [[Non Functional Requirements]] and various 'emergent' features. As a consequence, you are wrong: one can be 'using XP' and still end up requiring system-wide rework, and refactoring won't always help you. That said, [[Big Design Up Front]] isn't always the best answer even in situations that may end up requiring serious rework (very often you won't know all of your requirements up front). Reworking the system - essentially refactoring the entire codebase - can be acceptable so long as it doesn't happen too often. It's the entire basis of prototypes and [[Plan To Throw One Away]].",
      "id": "86a9d138a64b7cee788adb90d114554e"
    },
    {
      "type": "html",
      "text": "\nThere comes a point where a particular approach must be selected and adhered to. Again, the BDUF crowd tends to explicitly demarcate when this happens, whereas XP does not.",
      "id": "73c3b0903710d938eca3c405f5b44d1a"
    },
    {
      "type": "html",
      "text": "\nReally, the big difference between the two approaches is in how they treat R&D. BDUF tends to separate it from actual production work, with one leading into the other. XP, on the other hand, combines the two, thus enforcing the idea of emergence.",
      "id": "d5b8c0f73e5ff264d33c427a3fbecf10"
    },
    {
      "type": "html",
      "text": "-- Milo Hyson",
      "id": "7ca54f323a579a44be5123e2ebb3cc13"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "\nOkay, I'm new and this is my first (literally first ever post here) I would think the [[Right Thing]] is something like [[Convergent Desgin]] or [[Emergent Design]] depending on how clearly you understand where you want to end up. (If that's been defined elsewhere, just point me and off I'll go.) As an effort to scratch my own itch, IWannaLearnPython, I'm trying to write Something that does financial business modelling and forecasting. I'm quite sure there's stuff that exists that does that - the principal point is my learning to write a non-trivial piece of software - this just happens to be something I know about. I don't have a [[Big Design]], but I do have a [[Big Idea]] or 2, though, and I want to see how I can implement them, both as design and as code",
      "id": "0a953b57b7d43b53afc53d0d39aa0a93"
    },
    {
      "type": "html",
      "text": "-- [[Dan Esch]] (edited for [[Camel Caseification]] after reading some styleguides)",
      "id": "7e5189ef028c1064fee4513cd986037f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3728d8f4201d791a01b356357a74e7bf"
    },
    {
      "type": "html",
      "text": "\nSee: [[Clarity Up Front]], [[Design Diagrams Arent Evil]], [[Why Isnt Sam Coding Yet]], [[The Deadline On Big Design Up Front]], [[Adequate Architecture Up Front]], [[Can An Architecture Emerge]], [[Measure Twice Cut Once]], [[Design Up Front But Extreme Implementation]], [[Of Mice And Men]], [[System Size Metrics]], [[Design Approach Tina]], [[Big Reduction Up Front]], [[Yag Ni]]",
      "id": "f43d2f4bcf31af54728c610860271cd5"
    },
    {
      "type": "html",
      "text": "\n[[Category Design Issues]], [[Category Planning]], [[Category Analysis]], [[Category Decision Making]]",
      "id": "ab75e6befec5595d7a2240e5b22dc7db"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?BigDesignUpFront c2.com]",
      "id": "03a7d3a265246af72e173403d8ffad67"
    }
  ],
  "journal": [
    {
      "date": 1365860365000,
      "id": "d49db4f27c2769dd7bfb0494764ff2d0",
      "type": "create",
      "item": {
        "title": "Big Design Up Front",
        "story": [
          {
            "type": "html",
            "text": "<b>Summary:</b>",
            "id": "77b45a0c3bbbc19e3f99be602d13da62"
          },
          {
            "type": "html",
            "text": "\nThe term [[Big Design Up Front]] is commonly used to describe methods of software development where a \"big\" detailed design is created <i>before</i> coding and testing takes place. Several [[Extreme Programming]] (XP) advocates have said that such \"big\" designs are not necessary, and that most design should occur throughout the development process. While Xp does have initial design (the [[System Metaphor]]), it is considered to be a relatively \"small\" design. Much of this page disputes the amount of up-front design required for software projects.",
            "id": "e6b9c028a11436800dd404917442fc7b"
          },
          {
            "type": "html",
            "text": "\"every OOA/D begins with identifying the problem space entities that are relevant to solving the problem. Once the relevant entities are identified one identifies the relationships in the problem space between those entities that are relevant to solving the problem in hand. One records both in a Class Diagram. Only then does one move on to identifying detailed responsibilities, dynamics, and flow of control collaborations.\" - H.S.Lahman (in 2006, folks)",
            "id": "0a96172d4d8e2e01f61ebf7f6f8a1198"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "<b>Design as part of the planning process</b>",
            "id": "5d267d79768630713e3b7e71fd1a1255"
          },
          {
            "type": "html",
            "text": "<i>\"In preparing for battle I have always found that plans are useless, but planning is indispensable.\" [Eisenhower quote taken from [[Planning Extreme Programming]]]</i>",
            "id": "b62eca9bc04864a3526d8d2473338e81"
          },
          {
            "type": "html",
            "text": "\nOr as [[Jerry Weinberg]] put it \"the <i>documentation</i> is nothing; the <i>documenting</i> is everything\".",
            "id": "ec633e236cb60c1de2154794f03a89c5"
          },
          {
            "type": "html",
            "text": "<i>\"A mistake in initial dispositions can seldom be put right.\" and \"No plan survives its first contact with the enemy.\" [Field Marshal von Moltke]</i> -- [[Josh Stults]]",
            "id": "3b1defcda3976d53900f618388f252c8"
          },
          {
            "type": "html",
            "text": "\nPerhaps it is the social and intellectual activity of designing, rather than the designs themselves that are important. Is it the scope of design or the attitude <i>towards</i> design that needs to change? -- [[Chris Steinbach]]",
            "id": "5074fa000294fadac50119424b8c4a41"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "<b>Some Up Front Design Required?</b>",
            "id": "17b0662d34cb2900cea74e8d1d19964b"
          },
          {
            "type": "html",
            "text": "[This section originally followed the Smalltalk design/prototyping discussion.]",
            "id": "701360bc17c69984f36c39aab5fd22f4"
          },
          {
            "type": "html",
            "text": "<i>Even in Smalltalk, though, some design has to be done upfront [...]. [What goes on the desktop, number of services and support machines, legacy connections, etc.]</i>",
            "id": "d210f970c77e4ee83fabd9ddc0ba5b28"
          },
          {
            "type": "html",
            "text": "\nWhich of these things can't be decided one at a time, when its turn comes to be implemented?",
            "id": "17e83d07ca437d317dbbe4a2a7243c68"
          },
          {
            "type": "html",
            "text": "<i>I can't really stand up in front of a project review team for a $60M call center installation and suggest that they \"read the code\" in order to understand whether the resulting system will satisfy the very real 3-second response-time constraint.</i>",
            "id": "52bba3a3eb943d5084a71fc7b7bd72ca"
          },
          {
            "type": "html",
            "text": "\nWhat makes reading the document more convincing? When our top customer challenged whether our system could be fast enough, we measured it, ran it in 10 parallel processes and measured it again. Did the math. <b>That</b> was convincing. -- [[Ron Jeffries]]",
            "id": "12f2de3b0a5dabc4e4613560c9ae59e9"
          },
          {
            "type": "html",
            "text": "<i>Did you document those tests? Make them repeatable? Did you prove that they would scale and the results would scale predictably?</i>",
            "id": "7617e4e439af588bfd64c12d12c53f4a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "<i>Which of these things can't be decided one at a time, when its turn comes to be implemented?</i>",
            "id": "11e6efcf34387fdc7094be324f318d0a"
          },
          {
            "type": "html",
            "text": "\nThe ones that have to be funded by the client <i>before</i> the subsystem is built. The ones where the client wants to know ahead of time how much the total solution is likely to cost.",
            "id": "d366db901451cf6097b7b03135f63917"
          },
          {
            "type": "html",
            "text": "<i>What makes reading the document more convincing?</i>",
            "id": "1e272b2a78bee589a82982af50887e22"
          },
          {
            "type": "html",
            "text": "\nThe fact that the document is written in English, and most of the review team (particularly the managers and recommenders whose approval is needed to close the phase and pay the bill) haven't read or written code in 30 years, if at all. Many system problems, such as call centers, don't succumb so readily to simple demonstrations of blazing speed. In my example, the <b>response time</b> of a call center is as likely to be affected by network load and the number of network transfers (because of network latency) as the performance of any one system. A data transfer that requires 100 hops at 100 milliseconds per hop is going to burn 10 seconds in transfer time, even if the participating systems are infinitely fast.",
            "id": "ea4b76cf1508c3b7267cd667388ea9b0"
          },
          {
            "type": "html",
            "text": "\nIn the hardware world, the \"design\", especially of a complex system, is how you answer questions about how close to critical limits you are, what margins of safety you've built in, how you know that a particular beam is thick enough or cooling element big enough. The same sort of thing has to be done in software, especially in mission- or life-critical applications. And it is NOT all in the source code, it's as much in the interconnections among components. And those <i>aren't</i> in the source code. No code is an island.",
            "id": "48494272054cee7a1abf5ff384b3c64e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "<b>Design and Architecture</b>",
            "id": "13a273d6807086e4ef3a9d55393cacf4"
          },
          {
            "type": "html",
            "text": "\nThe words [[Big Design Up Front]] do bring to mind something of the aim of much architectural design in the building sense. Good design often follows where Big Ideas precede Detail Design. Conversely it is rare for small scale, pragmatic Detail Design alone to bring forth Great (or even worthy) Architecture. Of course, some Big Ideas are so far removed from the pragmatics as to be spurious as Design generators. As noted in [[Noo Has Nothing To Do With Software]], the key seems to be to correlate Big Ideas that have a genuine relationship with the item being designed.",
            "id": "51bfb5335751b601087d9a245e778ab1"
          },
          {
            "type": "html",
            "text": "\n[[Big Design Up Front]] in architecture does not require that every aspect of the design is predetermined. However it does provide a powerful reference for evaluation of subsequent ideas in the iterative design process.",
            "id": "efc6ba3e95e559d9bb6bab71afa760f5"
          },
          {
            "type": "html",
            "text": "-- [[Martin Noutch]]",
            "id": "3d05bd61c9729d88876b9cc1dac353b6"
          },
          {
            "type": "html",
            "text": "\nWe are perhaps learning the need to be humbler at this stage of software development, Martin. But I guess the nearest parallel in [[Extreme Programming]] to what you're referring to as good and necessary [[Big Design Up Front]] in physical architecture is the [[System Metaphor]]. After that greatness comes (if it ever does) through brilliant teamwork on the detail. But see also the unresolved questions in [[External And Internal Design]]. -- [[Richard Drake]]",
            "id": "afc3aa921650de662625d44bba3b73c0"
          },
          {
            "type": "html",
            "text": "\nI'm not sure about the [[Extreme Programming]] people or the exact meaning of [[Big Design Up Front]], but a high-level up-front design is generally regarded by most as important to large-scale object-oriented software systems. There's a tremendous amount of quantification to support the position. However, in software, this high-level design is very dynamic and changes as implementation is created. For a long time, one could get away with nothing more than [[Code And Test]] and Refactoring, but as systems become more complex, a need arises for some consideration to high-level designs and strategies. This is maybe why there is such a rift between [[Software Architect]]s and [[Extreme Programming]]. Extreme Programmers don't agree with this position - and they may be right for the type of apps they develop. But some [[Extreme Programming]] enthusiasts are even hostile to the idea of [[Software Architecture]]. -- [[Robert Di Falco]]",
            "id": "46c5d4e4a9d6bca8d2a0388e1a93b074"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "<b>Design Documents</b>",
            "id": "b5df09b76c85ced976f7b9214f2faeba"
          },
          {
            "type": "html",
            "text": "\nI'm clearly the only programmer left who doesn't use Smalltalk at all. ",
            "id": "20f7c4ac3c15f703b9238d256294c1ad"
          },
          {
            "type": "html",
            "text": "\nI'm in an environment where I get pieces of a very large system to write. I start out by writing up a little analysis document that I use to ensure that I understand the requirements. I then write up a high level design and check to make sure that it will take care of all the requirements in the analysis. Then I refine the high level design into a low level design. I often write code to do this, sometimes I decide that [[The Source Code Is The Design]], other times I [[Use Prototypes To Challenge Assumptions]]. I don't, however, allow the design document to omit any information that is needed in order to understand the code. That means that I'm always twiddling the design doc while I'm writing the code. It's not really all that onerous either because I use the design doc as a sort of checklist that tells me when I'm done with the code. If I change my mind about how to do something I change the doc so that I can check off what I've really done. If I didn't do that then I'd have stuff on the doc that never got checked off and I'd have code that got written for no apparent reason. It seems like the same kind of relationship the Extreme guys have with Unit Tests. One result is that the design is definitely not done until the code is. We keep our design docs in revision control and I find that I always check in my designs when I check in my code.",
            "id": "ee3dfbc3ae4c4fcad7eec912b3491cae"
          },
          {
            "type": "html",
            "text": "\nI guess my point is that I believe strongly in [[Big Design Up Front]] - but only for a little part of the whole program at a time. <i>Wouldn't that be [[Little Design All Along]]?</i>",
            "id": "8196d75a66b30188c55628c94f5b2cfa"
          },
          {
            "type": "html",
            "text": "<i>An [[Extreme Programmer]] might write tests to represent what the code had to do, and then code until they ran. What is the documentation cycle adding to the story? If you have the tests, why aren't they sufficient to know when you're done? And if you don't, how do you know when to check something off? -- [[Ron Jeffries]]</i>",
            "id": "6a7f3005aa7dcad89548170554c9f31e"
          },
          {
            "type": "html",
            "text": "\nHow do you test the tests? How do you explain the purpose behind the test? How do you relate the test to the system? Design and documentation are still necessary. ",
            "id": "0c235ae72731abe06af536f1478d0f36"
          },
          {
            "type": "html",
            "text": "\nWhat output, in the end, does one have from the testing process? Is it correct that essentially one has, after the tests have run, simply a linear numbered list such as \"test0001 - OK. test0002 - OK. test0003 - failed. test0004 - OK.\"? Such a list fails to relate the significance of the test to the architecture of the system, in terms the customer can understand. Therefore, it could be argued that what the documentation cycle \"adds to the story\" is an additional level of abstraction of describing what the system should do in an arbitrarily expressive form (i.e. natural or formal language). However, with additional tools, perhaps the output of the testing process could be raised to a higher level of abstraction - say, by putting tests within a hierarchy, modeling dependencies between tests, etc. However, perhaps exactly this sort of modeling is the type of \"Design\" that XP claims is unnecessary.",
            "id": "56c96179c1cb0df46521e90b894a29c0"
          },
          {
            "type": "html",
            "text": "<i>Actually, it helps if the tests are actually named after what they're testing - \"testFunctionBlahReturnsTrueForGoodValues - OK, testGettingResultsFromDatabase - OK, testSomeOtherBusinessRule - OK\"</i>",
            "id": "3860060c0dee57e3b5f2c42c95cd590e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "<i>[[Smalltalk As Design Prototype Language]] moved to another page</i>",
            "id": "93c7f0b88f65d0caf6354c99dc60e53d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "<b>Other Discussion:</b>",
            "id": "20d333ba0ffae3bef1f1903b9d2f86fe"
          },
          {
            "type": "html",
            "text": "\nI don't keep up to date on the methodology wars, and it seems everyone's more on a patterns bandwagon of late, but last I recall ~92 the prevailing sensible view (i.e. matching mine) seemed to be some variation on cyclical development (recursive-parallel, iterated \"analyze a little, design a little, code a little, test a little\", whatever).",
            "id": "1aa6239f47b4cf0475dbddaade272bc2"
          },
          {
            "type": "html",
            "text": "\nHaven't looked at [[The Deadline]], but the write-up here make it sound as though a lot of experience is being discarded, especially as indicated in the \"don't allow implementation until the very last minute\" notion.",
            "id": "03769a4f3488e9c93b616fe7dbda8b9f"
          },
          {
            "type": "html",
            "text": "\nI'm big on design, compared to many here (to me the work is in design; coding is the process of converting that into a specific computer language and typing it in, and occurs quickly and semi-automatically) but always within that context of a larger cycle. This [[Big Design Up Front]] thing as described seems to be trouble waiting to happen. -- [[Jim Perry]]",
            "id": "99a9a3e99abadc374c6271cc72a43255"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "What is the problem statement that [[Extreme Programming]] is a good solution for? What is the problem statement that [[Big Design Up Front]] is a good solution for? I read that Nickolas Tesla pictured a fully designed and working alternating current generator in his head before he even started working on one.",
            "id": "b28143ef992ce1d54845c854185e43b9"
          },
          {
            "type": "html",
            "text": "\nMaybe [[Big Design Up Front]] is the correct solution when you already know everything you need to know and are ever going to know about a system before you start it. Why experiment and iterate if you aren't going to learn something?",
            "id": "9094de2769db2888813bf26ed2adb5c6"
          },
          {
            "type": "html",
            "text": "<i>Sounds impossible as stated, boring if it were. If I knew everything, wouldn't I know the design and not need [[Big Design Up Front]]? -- r</i>",
            "id": "95894ce110bc3eb39e0454c30f6ca407"
          },
          {
            "type": "html",
            "text": "\nMaybe [[Big Design Up Front]] is the correct solution when the medium you are working in is incomprehensible once it is built/written (e.g. machine code).",
            "id": "aeec577325c4655cb45ffcc7925927e2"
          },
          {
            "type": "html",
            "text": "\n[[Big Design Up Front]] is only appropriate when reached via a moment of satori. --[[Mark Janssen]]",
            "id": "5d8cd3602f0672853b3bbf56f04bd26c"
          },
          {
            "type": "html",
            "text": "<i>No one ever built a machine code program without debugging. We used to do lots of thinking and desk checking not because it was better than debugging, but because it was hard to get time on the machine. -- r</i>",
            "id": "eaac0b08c1219f8b366e7c0c35cf60c2"
          },
          {
            "type": "html",
            "text": "\nMaybe [[Big Design Up Front]] is the correct solution when the medium you are working in is unchangeable once it is built/written (e.g. Hubble Telescope). ",
            "id": "7c4e7924909edb6b90d1c21e45ca77cf"
          },
          {
            "type": "html",
            "text": "<i>[actually, wasn't there a big problem (focus) when Hubble (the telescope) first went up in 1990? Oh, and since it was only corrected 3 1/2 years later, this is where BDUF comes in...]</i>",
            "id": "bc55e4b2c6ef508b77cb2f459b504c71"
          },
          {
            "type": "html",
            "text": "<i>Actually the Hubble was built on the ground, and changed in space. I think, though, that the learning point is most important. You will learn: what's the best way in your circumstances? -- [[Ron Jeffries]]</i> ",
            "id": "ec6d2af58e216fb0fdc11f32b04936d4"
          },
          {
            "type": "html",
            "text": "<i>Interestingly, the Hubble's big problem came about because a test was incorrectly set up, and the telescope was built to pass that test. -- [[Dave Van Buren]]</i>",
            "id": "4d061d55cb2eb98002b2b9ca5576f8cd"
          },
          {
            "type": "html",
            "text": "-- [[Stan Silver]]",
            "id": "d3f2a3f9c03e1ca9e1a7542c1f0337c3"
          },
          {
            "type": "html",
            "text": "\nOff-topic clarification: The Hubble's main defractor was ground based on a faulty reference lens. The design was perfect, but an implementation flaw crept in. The flaw was an aberration of some sort, I think the result of a incorrectly calibrated instrument. In relation to that lens, though, the main Hubble mirror was the most precisely built instrument ever at the time it was created. The application of the aluminum coating, used for ultraviolet reflection, was a big worry (if the aluminum oxidized, it would have been about as reflective as black felt to ultraviolet light), but went off without a hitch because the process was so well designed and understood in advance. The reflectivity exceeded their best hopes! They called the fix \"glasses\" for the Hubble, but I forget whether it was optical or electronic. There are many web sites devoted to the instrument. I'm not sure whether this anecdote has any application to this discussion. Beware of metaphors! -- Brent",
            "id": "74018458b0644bac5371f3479f1b8e74"
          },
          {
            "type": "html",
            "text": "<i>The Hubble's mirror physically warped in space because of thermal contraction. This is something that could have been tested here, on the ground. This was not an implementation flaw so far as I can see; this was a \"what could possibly go wrong?\" kind of flaw (not sure what you'd call that - a <b>process</b> flaw perhaps?).  The fix for this was a hunk of glass ground to a lens with a deliberate </i>counter-astigmatism<i>. The basic idea is the same as you find in Schmidt-Cassegrain telescopes: those use a </i>spherical<i> mirror, and a front-end lens with a </i>hyperbolic<i> form factor to counter the spherical aberration that the primary mirror introduces. As you can see, the fix is aptly named - it </i>literally<i> is a set of glasses for the telescope.</i>",
            "id": "140f4dc47f91a13f9d9bdc560b370a2b"
          },
          {
            "type": "html",
            "text": "\nAdditional notes to the above clarification, at the risk of drifting further OT: The corrective lens was optical, and called COSTAR. They were actually two lenses on a single device, that was placed between the Big Lens and space. They defracted the light in such a way that it nullified the imperfection in the main lens (light from the center and light from sides weren't being focussed on the same place, resulting in blur) The problem occurred due to a tiny piece of paint that bladdered off a metal tube, thus creating an imperfection on one of the calibration lenses, results shown above. To bring it back to the main point of this page: I don't think any BDUF-designer could have thought up that something as miniscule as a small bladder of paint would have cause this problem, as it's not in the scope of the Big Design. Had the engineers followed a continuous testing-implementing-testing cycle they would have been more likely to spot such a problem, I think. (Sorry if this is 'Wrong'-ish on this Wiki, first time posting after lots of reading with great interest.) -- [[Sander Bol]]",
            "id": "d0fff6c2b431417eb6fb3869c4cdd492"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "To continue my last statement: Where is the most efficient and cost effective time and medium to do your experimenting, tinkering, and rearranging?",
            "id": "2bcf841b36deec9fd9f0d508de2b7306"
          },
          {
            "type": "html",
            "text": "\nMaybe the primary purpose (primary use?) of design notations is for tinkering, not for specifying? Maybe the better they are for specifying, the worse they are for tinkering, so the complicated ones don't get used?",
            "id": "0a3865b2f9e432f95c5e9a0ff1288360"
          },
          {
            "type": "html",
            "text": "\nIf I understand correctly, XPers seem to have come to the conclusion that stories, CRC, units tests, Smalltalk (and Wiki?) are the best phases/mediums for doing their tinkering and rearranging. Others do major tinkering in some [[Design Phase]]/design notation during iterations; still others do major tinkering in a big design phase/design notation at the beginning of a project. -- [[Stan Silver]]",
            "id": "7d91654c134bca5828afb15c74751166"
          },
          {
            "type": "html",
            "text": "<i>I can't speak for XPers, but I prefer to do my tinkering and rearranging in a medium that can tell me whether my current tinkering is working. I just don't trust my ability to think through everything - I know from experience that I always overlook something. I do most of my tinkering in code because it lets me know right away when my thinking is flawed.</i> -- [[Jason Arhart]]",
            "id": "30ec95ba9d484fbdf81b4486878f1170"
          },
          {
            "type": "html",
            "text": "\nHow about [[Use The Least Expensive Medium In Which You Can Learn As Much As Is Productive About The Particular Problem Domain You Are Exploring]]? Or maybe, [[Match The Cost Of Your Medium To The Level Of Knowledge Uncertainty]]? Hard to make it pithy. Anyway, here is the core of the issue from my perspective: In the phrase \"Big Design Up Front\", what is meant by the word \"Design\"? What problem domain are you exploring when you're \"tinkering\" or \"designing\" or whatever you want to call it? Are you exploring the essential requirements and user-perceptible form of the product (what should it do?), or are you exploring how to satisfy those requirements with libraries, data structures, and algorithms (how should it do it)? If the former, then code is a *very* expensive medium in which to learn that huge product changes are necessary - and trust me, if you haven't prototyped it, you will learn that huge product changes are necessary. (Try building a prototype with paper, or Powerpoint, or even VB - much cheaper media). If the latter, then by all means start coding - unless you've built the product once already, you're going to need the code to keep you honest, and writing reams of techn specs (that no one will read) will only waste time. (No harm in some interactive white-boarding along the way though.) Obviously, at some point there is a fine line between exploring the product and exploring its implementation ... But there is great efficiency to be gained if you can find where that line is and use it to keep projects from flailing. -- [[Jesse Watson]]",
            "id": "284a9bd09e7bd20f95bf6b98bf0e1c92"
          },
          {
            "type": "html",
            "text": "\nGeorge Orwell is quoted as saying 'I write to clarify my own thinking.' In the same way, I use design is as a way to clarify my own thinking about the problem and possible solutions. I find that tinkering with the problem in English or pseudo-code helps me realize a good enough design to get started with. It is all about having a reasonable enough initial approach that can be iterated on throughout the development process. -- [[Bryan Edds]]",
            "id": "edee1ccc29daaf1f7223c157a6db6d5b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "Another angle (to steal a knowledge representation technique from [[What Is Analysis]] page):",
            "id": "5788d69d70cebfcc5e1e9e8ef241c367"
          },
          {
            "type": "html",
            "text": " <b>Group 0</b>, software development is a trial and error process",
            "id": "4c4eb77b04d5d9068098df951457b90f"
          },
          {
            "type": "html",
            "text": " <b>Group 1</b>, software development is a series of deterministic transformations\nGroup 0 tries to partition their trial and error (into different mediums and time intervals) in a way that minimizes cost and time to market.",
            "id": "346662330a877d84c2c893bfe2dfe878"
          },
          {
            "type": "html",
            "text": "\nGroup 1 concerns themselves with specifying and capturing the complete and correct output of each transformation phase (since the assumption is that it is correct).",
            "id": "bc74f66505d463536f7711ee3dcd1b91"
          },
          {
            "type": "html",
            "text": "\nWhen some of group 1's code isn't accepted by the user, it is a \"mistake\" - they didn't do one of their transformations correctly. When some of group 0's code isn't accepted by the user, they fix it. -- [[Stan Silver]]",
            "id": "a436dd004980fe5bf1cf53007784a752"
          },
          {
            "type": "html",
            "text": "<i>I think the tendency to do [[Big Design Up Front]] may come from the confusion that non-programmers (I suppose) have: They see coding as manufacturing, not as design. So, quite logically, they want the product to be designed before it's manufactured, like in any other industry. Except that, after the supposed design is done, another design (plus refactorings) must be done by the coders. I suggest that, most of the time, seeing coding as manufacturing is a [[Notion Smell]]. -- [[Anonymous Donor]]</i>",
            "id": "e4546b5c403c3cb57a95ba21be034049"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "I like that characterization. :-) -- [[Alistair Cockburn]]",
            "id": "baaa91767d47e967ca42a4472a6af80d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "Two comments:",
            "id": "d95f5f6fc68ae4309a6324fd13b4feb4"
          },
          {
            "type": "html",
            "text": " I'm never sure whether the word `design` means what some thing looks like to the user, or what it looks like to the people creating and/or fixing the same thing.",
            "id": "dc48cfa1a28a6edcd86e8f7c3680ab6d"
          },
          {
            "type": "html",
            "text": " The best size of <i>design up front</i> surely depends on both the situation, and how fast that situation is changing.",
            "id": "3eb74fc3d4ebbbc4445023bc12c6a429"
          },
          {
            "type": "html",
            "text": "-- [[Dick Botting]]",
            "id": "0916623a1183e9b6f312f55825a6ad59"
          },
          {
            "type": "html",
            "text": "'Design' has to be one of the most over-used and mis-used words around at present. Consider whether other words are really meant, e.g. 'make', 'write' etc. For me, 'Design' encompasses a wide ranging process of investigation, evaluation, problem-solving and creative decision-making. Thoughtful analysis is the key to this.",
            "id": "a69b0ff59737d8b03be59a43baf67810"
          },
          {
            "type": "html",
            "text": "\nThe outrage of so much of modern (building/environmental) 'design' is that there is clearly no commitment to this process of thoughtful analysis, just a quick, commercially led and superficial decision-making process that only just precedes the actual making of the building by the Contractors.",
            "id": "26be766ee3d29905b772514f50471923"
          },
          {
            "type": "html",
            "text": "-- [[Martin Noutch]]",
            "id": "3d05bd61c9729d88876b9cc1dac353b6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "A nice quote from a \"[[Murphys Law]]\" calendar we have at work:",
            "id": "4d2da82ad6c938e4608aa165967fc039"
          },
          {
            "type": "html",
            "text": "Reisner's Rule of Conceptual Inertia",
            "id": "c4485f846edbda4815b9686cfdef69df"
          },
          {
            "type": "html",
            "text": "\"If you think big enough, you'll never have to do it.\"",
            "id": "04902c87a97b2d5ce3e6d1f6b7905fa6"
          },
          {
            "type": "html",
            "text": "What is it that makes some of us want to procrastinate, often in very creative ways? I think this may be part of the dynamic of [[Big Design Up Front]].",
            "id": "f98071470dc91348d0295cf97e00ec61"
          },
          {
            "type": "html",
            "text": "-- [[Jeff Mantei]]",
            "id": "ef93536781cc574fe464d580ffd33764"
          },
          {
            "type": "html",
            "text": "\nA good example IMHO of [[Conceptual Inertia]] is the [[Tunes Project]].",
            "id": "53f7a44b01f16febd1c3a23332caa1b6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "I guess I'm a little fuzzy on what is meant by [[Big Design Up Front]]. Does it mean detailed design? Or a high level design of the overall project/product? Because I believe you need some sort of high level design up front. A customer cannot \"steer\" the project if they do not know - on a high level - what they want this project to become. Details can change and features can be added and deleted, but you should know from the outset if you are building an IDE or just a word processor.",
            "id": "eab18e877632f49d12cfcc8f0d9045e6"
          },
          {
            "type": "html",
            "text": "-- [[Nicole Willson]]",
            "id": "e38a841b8603681031ade52479743dc4"
          },
          {
            "type": "html",
            "text": "\nI think [[Big Design Up Front]] (a.k.a. BDUF) is a waterfall-style attempt to do lots and lots of one phase (specifically design) before starting the next, and thus, to forsake any chance to get feedback.",
            "id": "9c31bd91d836d05c8934a6a1efef38da"
          },
          {
            "type": "html",
            "text": "\nThe alternative probably ought to be called [[Design As You Go]] (later: or better still, [[Continuous Design]]). -- [[Paul Chisholm]]",
            "id": "0534736efc8215a5c0a208c585092fcf"
          },
          {
            "type": "html",
            "text": "\nActually, I think that it should be called [[Not Enough Design]] - I don't have complete enough design that I can formally test against a formal requirements (in XP being code and unit tests), but I have enough of a design to send me on a wrong way with costly re-writes.",
            "id": "a801124c9f900aa8c332ce161385512c"
          },
          {
            "type": "html",
            "text": "\nI'd argue that all people do some level of up front design (on any level of granularity), simply by knowing the context. Of course, it would be a very interesting experiment, to try to build a system w/o people who build it knowing the context. Say just give a programmer a story (or part of), existing code w/o anything else. And then have a control team that works with the full context knowledge.",
            "id": "d205183118f8427b72f261b606741ab1"
          },
          {
            "type": "html",
            "text": "<i>I see this fairly often: programmers build \"infrastructure\" without knowing how those systems will be used. The result is typically bloated and difficult to use, because [[You Might Need It]]. A clear idea of requirements and/or the YAGNI principle is needed to cure this ailment.</i>",
            "id": "e0de965992c623f3decc18cd8f958326"
          },
          {
            "type": "html",
            "text": "[Don't know whether the following still belongs here]",
            "id": "157920711b1789c56401ace9d690b1d6"
          },
          {
            "type": "html",
            "text": "\nI prefer now instead of building a system say discovering a system. Then, you think about your system as a tree with the \"whole\" represented by the root and definite details as the leaves. With traditional methodologies, you do breadth first search/discovery. With agile ones, you do depth first. As anyone who implemented tree search algorithms, in depth first you need to hold less state -> your tree can actually change outside the branch you're just exploring w/o affecting your search.",
            "id": "16066a3a308a982fbc585088e26c6a1d"
          },
          {
            "type": "html",
            "text": "-- [[Vlad Ender]]",
            "id": "1084f310d27fe48753dee91b3307be1b"
          },
          {
            "type": "html",
            "text": "\nI think XP is more about going from the leaves up to the root, and [[Big Design Up Front]] is more about going from the root to the leaves. This is why XP tends to <i>discover</i> the tree. It comes from the leaves (the <i>real need</i> of the customers), and refactor as it discovers more leaves. Then it design some branches, and so on, up to the root. For me, that's the meaning of [[Design As You Go]] or [[Continuous Design]].",
            "id": "e73fd31b20c5cd5d0e934552d6a430a4"
          },
          {
            "type": "html",
            "text": "-- [[Cyrille Gachot]]",
            "id": "f41a75a5397b951428dc7e2bcc03414b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "<b>A customer cannot \"steer\" the project if they do not know - on a high level - what they want this project to become.</b>",
            "id": "eba7a275ce3d8981f3629c16d9532b17"
          },
          {
            "type": "html",
            "text": "\nI found this statement interesting because I found it 180 degrees opposed to my viewpoint. I feel the customer (specifically the front line users) know exactly what the project should become. It is the <i>developers</i> who need to know what the project should become. The question are the more effective and efficient means of communication from the users to the developers.",
            "id": "4e97f67da32f3315ab9100382a7a2b8a"
          },
          {
            "type": "html",
            "text": "\nThe problems I see with \"Big Design Up Front\" are that the two parties most interested in the communication (users and developers) are omitted; and the context of the user environment is lost when a large document listing precisely defined requirements is created.",
            "id": "37ecd5c9535a3046a99be08b0d0c0f6f"
          },
          {
            "type": "html",
            "text": "\nI have become firmly convinced that there is no substitute for having individual developers spend a day with individual users and understanding the environment of the user's job. The developers invariably come back from the experience with drastically changed views of what they should be doing. Developers have to intuitively make hundreds of unconscious decisions while creating software; direct user experience provides a context for those decisions.",
            "id": "93050e520320df65824d3be5de8e271d"
          },
          {
            "type": "html",
            "text": "\nAgain, the point is how best to get information and knowledge communicated from users to developers.",
            "id": "88a6366677aa7503f30a06b1ebbf54ad"
          },
          {
            "type": "html",
            "text": "-- [[Wayne Mack]]",
            "id": "7566e2a782d8b0b3b62e16f8b33e1b95"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "Is [[Big Design Up Front]] the same as [[Big Design]]? Should the pages be merged or at least refactored and crosslinked?",
            "id": "0b0bb3a99847a7fa5edf2a07889564ac"
          },
          {
            "type": "html",
            "text": "\nI think we should preserve the wording of \"Big Design\" linked with \"Up Front\". I don't think we can limit the size of the design, just the amount we do up front. Design should be an ongoing activity.",
            "id": "af433efca4afa47fb8fd603a9850ce94"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "Has anyone else considered whether methods of design and implementation are related to one's mental skills and abilities as much or more than they are about finding the \"best\" objective way to produce a machine? If someone is a spatial thinker, they will use very different ways of envisioning the way something works than will someone whose preferred way of thinking is logically-based. Most up front designers, I would guess, have spatial thinking skills - they want to utilized their skill with understanding structural relationships, while XPers might be better at process logic, and want to focus on the working interaction of components. But modes of thinking and abstracting have a big effect on how we go about constructing things. -- Brent",
            "id": "cc1508abcc849d49dc0145983b6be61e"
          },
          {
            "type": "html",
            "text": "<i>I'm not sure that you can prefer spatial thinking to logical. Both are heavily ingrained in the brain, as evidenced by a few sentences taken from any conversation. Things that have nothing to do with space or force are expressed in those terms.</i>",
            "id": "1399f992a5770e1ddb6915b475800b31"
          },
          {
            "type": "html",
            "text": "\nI think both types of thinking are needed, the question is the order in which they are applied. In [[Big Design Up Front]], one tries to apply only spatial thinking to create a design followed by only logical thinking to implement the design. In the XP iterative approach, one first applies logical thinking to [[Do The Simplest Thing That Could Possibly Work]], then one applies spatial thinking to [[Re Factor]], then one repeats the entire cycle. -- [[Wayne Mack]]",
            "id": "3dbe5d75941a9379daaa9b0e8757fcd0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "The discussions on this page were reordered for clarity. Does anyone but me see the irony of this?",
            "id": "cede523f0db74f3211e1594a892aa317"
          },
          {
            "type": "html",
            "text": "<i>Sorry. Such is the nature of [[Thread Mode]]. This page is not a design - it is an ongoing discussion waiting to be trimmed down to [[Dialectic Mode]] some fine day. Have at it.</i>",
            "id": "0d7863c585ba593ab0c8276ca3aad722"
          },
          {
            "type": "html",
            "text": "\nI missed the irony. Is it that the [[Big Design Up Front]] page was not designed and developed in one pass, but was done iteratively?",
            "id": "191b8a71103df3f385af94bc3c856953"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "The [[Big Design Up Front]] may also be seen as the [[High Level Design Up Front]]. I know that I don't always think of the details of how I will implement the tiny constructs (the new ones to add to the system) as much I am looking at the over all picture. In taking my senior level courses, we always were told to approach what was to by developed on a large scale. Though using this term confused most of us at first because we were trying to do everything at once. Stepping back and rethinking about what was being stated, we realized that thinking on a more abstract scale or of the overall design was large whereas thinking of every single detail brought us closer to getting the minor things solved. The [[Big Design Up Front]] is how you would like to get things rolling, and then time and the details will help to focus on what to change and to make sure your initial vision is maintained, if still needed. -- YemiIDBedu",
            "id": "412728b408d7addedeed1bdff7a58e75"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "This seems to overlap [[Analysis Paralysis]]",
            "id": "48d545603bae38281e90955f0ed7c82e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "I stumbled across this set of comments by accident while looking for something on [[Requirements Tracking]], and have been fascinated by the different points of view on design. As with most areas of disagreement, I believe many of these disagreements come from differing perspectives and experience.",
            "id": "94fb8c23978c48d2fb626241be001236"
          },
          {
            "type": "html",
            "text": "\nMy long years of experience in systems (over 35 years) have taught me that up-front design is always good. The only problem is in how much knowledge is available to do the design. BDUF is only possible in some situations. Consider these differing types of projects:",
            "id": "585b51bf5bd935cba67caa5603b9682f"
          },
          {
            "type": "html",
            "text": " knowledge of requirements: a lot is known (redevelopment of a legacy system) versus a leading edge relationship marketing system where requirements are developed as the system is built",
            "id": "6e1cc86448ff26d87c37e32b04b2e5b4"
          },
          {
            "type": "html",
            "text": " size of project: small (under ten staff) to large (over 100 staff)",
            "id": "1b011f45e4470ae10ae53ffbd1396545"
          },
          {
            "type": "html",
            "text": " knowledge of the system: the customer knows the system but the developers are new, or the senior staff of the project knows what is needed but the programmers do not, or the development team is experienced and has done this type of system before but the customer has not",
            "id": "68ab8a713b9c06c55d12a3d728039894"
          },
          {
            "type": "html",
            "text": "\nI believe one can see that in some cases above, more information is available to contribute to a good design, and in other cases, little information is available. In some cases (small project, little knowledge of requirements) the XP approach may be best. In other cases (small project, customers know the system), the XP approach will likely be as successful as any other approach.",
            "id": "f62c626feb46187f62c435dab9f20c26"
          },
          {
            "type": "html",
            "text": "\nBut in many other cases, up-front design will save overall time and money, and contribute to a better system. For example, in a large project (over 100 staff), how do you even know it is a large system unless some up-front work is done? Can a project manager set 100 programmers loose without some idea of what is to be built? (maybe in the case where the team has done the system many times already...).",
            "id": "4b5d349c17a58b7b0213aa4318c72ac0"
          },
          {
            "type": "html",
            "text": "\nAn experienced project manager knows that a plan (or design) is not perfect, and will evolve as more information becomes available. Good development methodologies allow for multiple iterative passes from the high level to detail, and call for prototyping of critical components early in the project.",
            "id": "bec9b238ea3ef0b9373c9f3ee7fdb4c1"
          },
          {
            "type": "html",
            "text": "\nI hope this contributes to the debate. -- [[Neil Carscadden]]",
            "id": "da140b6e90a4a3d524274b37401f37dd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "I've spent a great many years studying various project methodologies. On this particular issue, it is my opinion that both camps have points to concede.",
            "id": "1da915ab78b6862a9a31e10e5feffb0e"
          },
          {
            "type": "html",
            "text": "\nFirst off, the BDUF crowd needs to acknowledge that even in their world architecture and design are not completely specified up front but are in fact emergent. In nearly all projects, a certain amount of experimental work has to be done to answer any significant questions or mitigate any serious risks that could impact the success of the effort. There nearly always is a set of unknowns that can be resolved only through actual construction. This process is generally called R&D (research and development), and the result is a prototype that defines the basic nature of the end product. It establishes a framework upon which everything else can be built. The BDUF crowd tends to delineate this as a separate task (or sometimes even a separate project), and in many cases it's performed by a different team. XP, on the other hand, just considers it to be part of the overall process.",
            "id": "a6b296f4fc23f5ffb9aa3afafeb6c3e4"
          },
          {
            "type": "html",
            "text": "\nSecond, the XP crowd needs to acknowledge that even they commit to a design early on. One has to in order to get anything done. One cannot rework the whole system for each new feature. ",
            "id": "4aa6d4b87ce6f0da2d09f4d6af13d213"
          },
          {
            "type": "html",
            "text": " Any environment that requires system-wide rework for many features is not using XP. The whole point of refactoring is to minimize the change impact time and cost. Instead of 'commit to a design' you negotiate features with the client, which gives them what they most want in a shorter timespan than BDUF (and is much safer).",
            "id": "fdbbcca86c678c48716b64971b392966"
          },
          {
            "type": "html",
            "text": " The 'point' of refactoring may be to minimize change impact time and cost, but the <i>actual mechanism</i> of refactoring relies on the <i>assumption</i> that the functionality you'll be adding in the future look very similar to functionality you added in the past. This is not the case for all features, especially for [[Non Functional Requirements]] and various 'emergent' features. As a consequence, you are wrong: one can be 'using XP' and still end up requiring system-wide rework, and refactoring won't always help you. That said, [[Big Design Up Front]] isn't always the best answer even in situations that may end up requiring serious rework (very often you won't know all of your requirements up front). Reworking the system - essentially refactoring the entire codebase - can be acceptable so long as it doesn't happen too often. It's the entire basis of prototypes and [[Plan To Throw One Away]].",
            "id": "86a9d138a64b7cee788adb90d114554e"
          },
          {
            "type": "html",
            "text": "\nThere comes a point where a particular approach must be selected and adhered to. Again, the BDUF crowd tends to explicitly demarcate when this happens, whereas XP does not.",
            "id": "73c3b0903710d938eca3c405f5b44d1a"
          },
          {
            "type": "html",
            "text": "\nReally, the big difference between the two approaches is in how they treat R&D. BDUF tends to separate it from actual production work, with one leading into the other. XP, on the other hand, combines the two, thus enforcing the idea of emergence.",
            "id": "d5b8c0f73e5ff264d33c427a3fbecf10"
          },
          {
            "type": "html",
            "text": "-- Milo Hyson",
            "id": "7ca54f323a579a44be5123e2ebb3cc13"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "\nOkay, I'm new and this is my first (literally first ever post here) I would think the [[Right Thing]] is something like [[Convergent Desgin]] or [[Emergent Design]] depending on how clearly you understand where you want to end up. (If that's been defined elsewhere, just point me and off I'll go.) As an effort to scratch my own itch, IWannaLearnPython, I'm trying to write Something that does financial business modelling and forecasting. I'm quite sure there's stuff that exists that does that - the principal point is my learning to write a non-trivial piece of software - this just happens to be something I know about. I don't have a [[Big Design]], but I do have a [[Big Idea]] or 2, though, and I want to see how I can implement them, both as design and as code",
            "id": "0a953b57b7d43b53afc53d0d39aa0a93"
          },
          {
            "type": "html",
            "text": "-- [[Dan Esch]] (edited for [[Camel Caseification]] after reading some styleguides)",
            "id": "7e5189ef028c1064fee4513cd986037f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3728d8f4201d791a01b356357a74e7bf"
          },
          {
            "type": "html",
            "text": "\nSee: [[Clarity Up Front]], [[Design Diagrams Arent Evil]], [[Why Isnt Sam Coding Yet]], [[The Deadline On Big Design Up Front]], [[Adequate Architecture Up Front]], [[Can An Architecture Emerge]], [[Measure Twice Cut Once]], [[Design Up Front But Extreme Implementation]], [[Of Mice And Men]], [[System Size Metrics]], [[Design Approach Tina]], [[Big Reduction Up Front]], [[Yag Ni]]",
            "id": "f43d2f4bcf31af54728c610860271cd5"
          },
          {
            "type": "html",
            "text": "\n[[Category Design Issues]], [[Category Planning]], [[Category Analysis]], [[Category Decision Making]]",
            "id": "ab75e6befec5595d7a2240e5b22dc7db"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?BigDesignUpFront c2.com]",
            "id": "03a7d3a265246af72e173403d8ffad67"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1634968594224
    }
  ]
}