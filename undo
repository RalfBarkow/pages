{
  "title": "Undo",
  "story": [
    {
      "type": "paragraph",
      "id": "ac89b0ea5c4fe82d",
      "text": "Fully non-destructive editors can easily implement an undo feature simply by \"backtracking\" in the edit decision list; no waveform data has to be changed on disk. It is more difficult for in-place editors, because they must save a copy of the samples before the edit, which can take time proportional to the size of the edit. With a simple modification, our sequence-based approach can be used to implement an unlimited undo mechanism that runs in constant time and wastes very little space. To do this, let each block of samples to which every node points be a reference-counted object instead of just a simple array. That way, two different nodes can point to the same set of samples, and the samples are not destroyed until both nodes pointing to them are deleted."
    },
    {
      "type": "pagefold",
      "id": "7ba60c9f96419d00",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "dab69052d86cd7c1",
      "text": "MAZZONI, Dominic and DANNENBERG, Roger B., 2002. A fast data structure for disk-based audio editing. Computer Music Journal. Online. 2002. Vol. 26, no. 2, p. 62–76. [Accessed 10 November 2023]. Available from: https://www.jstor.org/stable/3681457"
    },
    {
      "type": "image",
      "id": "4dd8bbad5438d8fa",
      "text": "From a FileLocator to a JSONObjectNode",
      "size": "wide",
      "width": 420,
      "height": 263,
      "url": "/assets/plugins/image/ccb9bfdbb91ccc50820abe99fc9de34d.jpg"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Undo",
        "story": []
      },
      "date": 1699636749588
    },
    {
      "item": {
        "type": "paragraph",
        "id": "ac89b0ea5c4fe82d",
        "text": "Fully non-destructive editors can easily implement an undo feature simply by \"backtracking\"in the edit decision list; no waveform datahas to be changed on disk. It is more difficult for in-place editors, because they must save a copy of the samples before the edit, which can take time proportional to the size of the edit. With a simple modification, our sequence-basedapproachcan be used to implement an unlimited undo mechanism that runs in constant time and wastes very little space. To do this, let each block of samples to which every node points be a reference-countedobject instead of just a simple array.That way, two differentnodes can point to the same set of samples, and the samples are not destroyed until both nodes pointing to them are deleted."
      },
      "id": "ac89b0ea5c4fe82d",
      "type": "add",
      "date": 1699636751136
    },
    {
      "type": "edit",
      "id": "ac89b0ea5c4fe82d",
      "item": {
        "type": "paragraph",
        "id": "ac89b0ea5c4fe82d",
        "text": "Fully non-destructive editors can easily implement an undo feature simply by \"backtracking\"in the edit decision list; no waveform datahas to be changed on disk. It is more difficult for in-place editors, because they must save a copy of the samples before the edit, which can take time proportional to the size of the edit. With a simple modification, our sequence-basedapproachcan be used to implement an unlimited undo mechanism that runs in constant time and wastes very little space. To do this, let each block of samples to which every node points be a reference-countedobject instead of just a simple array.That way, two differentnodes can point to the same set of samples, and the samples are not destroyed until both nodes pointing to them are deleted."
      },
      "date": 1699636753420
    },
    {
      "id": "dab69052d86cd7c1",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "dab69052d86cd7c1",
        "text": "MAZZONI, Dominic and DANNENBERG, Roger B., 2002. A fast data structure for disk-based audio editing. Computer Music Journal. Online. 2002. Vol. 26, no. 2, p. 62–76. [Accessed 10 November 2023]. Available from: https://www.jstor.org/stable/3681457"
      },
      "after": "ac89b0ea5c4fe82d",
      "attribution": {
        "page": "2023-11-10"
      },
      "date": 1699636768709
    },
    {
      "id": "7ba60c9f96419d00",
      "type": "move",
      "order": [
        "ac89b0ea5c4fe82d",
        "7ba60c9f96419d00",
        "dab69052d86cd7c1"
      ],
      "date": 1699636771678,
      "error": {
        "type": "error",
        "msg": "",
        "response": "Server Ignoring move. Try reload."
      }
    },
    {
      "item": {
        "type": "pagefold",
        "id": "7ba60c9f96419d00",
        "text": "~"
      },
      "id": "7ba60c9f96419d00",
      "type": "add",
      "after": "dab69052d86cd7c1",
      "date": 1699636769893
    },
    {
      "type": "edit",
      "id": "7ba60c9f96419d00",
      "item": {
        "type": "pagefold",
        "id": "7ba60c9f96419d00",
        "text": "~"
      },
      "date": 1699636777378
    },
    {
      "type": "fork",
      "date": 1699636781895
    },
    {
      "type": "fork",
      "date": 1699636781929
    },
    {
      "type": "fork",
      "date": 1699636784820
    },
    {
      "type": "remove",
      "date": 1699636838389
    },
    {
      "id": "7ba60c9f96419d00",
      "type": "move",
      "order": [
        "ac89b0ea5c4fe82d",
        "7ba60c9f96419d00",
        "dab69052d86cd7c1"
      ],
      "date": 1699636877608
    },
    {
      "type": "edit",
      "id": "ac89b0ea5c4fe82d",
      "item": {
        "type": "paragraph",
        "id": "ac89b0ea5c4fe82d",
        "text": "Fully non-destructive editors can easily implement an undo feature simply by \"backtracking\"in the edit decision list; no waveform data has to be changed on disk. It is more difficult for in-place editors, because they must save a copy of the samples before the edit, which can take time proportional to the size of the edit. With a simple modification, our sequence-based approach can be used to implement an unlimited undo mechanism that runs in constant time and wastes very little space. To do this, let each block of samples to which every node points be a reference-counted object instead of just a simple array.That way, two different nodes can point to the same set of samples, and the samples are not destroyed until both nodes pointing to them are deleted."
      },
      "date": 1699714207666
    },
    {
      "type": "edit",
      "id": "ac89b0ea5c4fe82d",
      "item": {
        "type": "paragraph",
        "id": "ac89b0ea5c4fe82d",
        "text": "Fully non-destructive editors can easily implement an undo feature simply by \"backtracking\"in the edit decision list; no waveform data has to be changed on disk. It is more difficult for in-place editors, because they must save a copy of the samples before the edit, which can take time proportional to the size of the edit. With a simple modification, our sequence-based approach can be used to implement an unlimited undo mechanism that runs in constant time and wastes very little space. To do this, let each block of samples to which every node points be a reference-counted object instead of just a simple array.That way, two different nodes can point to the same set of samples, and the samples are not destroyed until both nodes pointing to them are deleted."
      },
      "date": 1699714269864,
      "error": {
        "type": "error",
        "msg": ""
      }
    },
    {
      "type": "fork",
      "date": 1699714303625
    },
    {
      "type": "edit",
      "id": "ac89b0ea5c4fe82d",
      "item": {
        "type": "paragraph",
        "id": "ac89b0ea5c4fe82d",
        "text": "Fully non-destructive editors can easily implement an undo feature simply by \"backtracking\" in the edit decision list; no waveform data has to be changed on disk. It is more difficult for in-place editors, because they must save a copy of the samples before the edit, which can take time proportional to the size of the edit. With a simple modification, our sequence-based approach can be used to implement an unlimited undo mechanism that runs in constant time and wastes very little space. To do this, let each block of samples to which every node points be a reference-counted object instead of just a simple array.That way, two different nodes can point to the same set of samples, and the samples are not destroyed until both nodes pointing to them are deleted."
      },
      "date": 1699714367827
    },
    {
      "type": "edit",
      "id": "ac89b0ea5c4fe82d",
      "item": {
        "type": "paragraph",
        "id": "ac89b0ea5c4fe82d",
        "text": "Fully non-destructive editors can easily implement an undo feature simply by \"backtracking\" in the edit decision list; no waveform data has to be changed on disk. It is more difficult for in-place editors, because they must save a copy of the samples before the edit, which can take time proportional to the size of the edit. With a simple modification, our sequence-based approach can be used to implement an unlimited undo mechanism that runs in constant time and wastes very little space. To do this, let each block of samples to which every node points be a reference-counted object instead of just a simple array. That way, two different nodes can point to the same set of samples, and the samples are not destroyed until both nodes pointing to them are deleted."
      },
      "date": 1699714397162
    },
    {
      "type": "fork",
      "date": 1699716224716
    },
    {
      "item": {
        "type": "factory",
        "id": "4dd8bbad5438d8fa"
      },
      "id": "4dd8bbad5438d8fa",
      "type": "add",
      "after": "dab69052d86cd7c1",
      "date": 1699716228064
    },
    {
      "type": "edit",
      "id": "4dd8bbad5438d8fa",
      "item": {
        "type": "image",
        "id": "4dd8bbad5438d8fa",
        "text": "From a FileLocator to a JSONObjectNode",
        "size": "wide",
        "width": 420,
        "height": 263,
        "url": "/assets/plugins/image/ccb9bfdbb91ccc50820abe99fc9de34d.jpg"
      },
      "date": 1699716241069
    }
  ]
}