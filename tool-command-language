{
  "title": "Tool Command Language",
  "story": [
    {
      "type": "html",
      "text": "Tcl -- Tool Command Language",
      "id": "f34fd84c0118305811aa26202df3df24"
    },
    {
      "type": "html",
      "text": "\nSome important websites for more information and downloads:",
      "id": "8f9db0f4128b88fbecfea13f2719fe0c"
    },
    {
      "type": "html",
      "text": " [http://www.tcl.tk/ www.tcl.tk]",
      "id": "74d019da013ad1611c45088ce353e102"
    },
    {
      "type": "html",
      "text": " [[The Tclers Wiki]]",
      "id": "07ceecf4dcb073fd0dc71656aea5a6ee"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "<b>Description of the Tcl language</b>",
      "id": "968f56a381a0fc4b9794067325fe53e5"
    },
    {
      "type": "html",
      "text": "\nEasily extendable script language which became most famous for the \"[[Tcl Tk]] [[Gui Toolkit]]\" and \"[[Tcl Expect]]\", as well as for easy embeddability, but it is increasingly used in other spheres. Some of its most unique features:",
      "id": "f5acbb5830a13e6779d88989727eadcf"
    },
    {
      "type": "html",
      "text": " Everything is a string (native representation is used behind the scenes). All values can be used inter-changeably and anywhere where a string can be used for natural serialization.",
      "id": "4faec8b0b8ae1874eef045a6647c4fde"
    },
    {
      "type": "html",
      "text": " Extremely minimalistic syntax: cmd arg arg arg ...",
      "id": "995f36091a92de36e0800e3e33db5a9a"
    },
    {
      "type": "html",
      "text": " No reserved keywords",
      "id": "31d95bb0f00e50b7856e358cbd870268"
    },
    {
      "type": "html",
      "text": " No static language constructs (for, while etc. are just commands like any other)",
      "id": "8114776ecfa3fc78d5025c18e3728314"
    },
    {
      "type": "html",
      "text": " Flexible event-based programming. F.ex. IO and GUi events call callbacks which greatly reduces the need for threads",
      "id": "4918bb54e07d64bfb78fd982ead89e6c"
    },
    {
      "type": "html",
      "text": " Has a threading system, too.",
      "id": "c7d50ec2300635b6ed7fe0a54837064c"
    },
    {
      "type": "html",
      "text": " Everything can be dynamically changed and replaced (remember: language constructs are also just commands too!)",
      "id": "ff5766cb2c7915bf6405424ac86d8aad"
    },
    {
      "type": "html",
      "text": " The Virtual Filesystem mechanism",
      "id": "2c1027c86b2908d48038077442b36c14"
    },
    {
      "type": "html",
      "text": " Doesn't force any particular programming paradigm. For instance, a wide range of OO extensions exist from the more traditional [incr Tcl] to the more dynamic [[Extended Object Tcl]] and delegation -style Snit.",
      "id": "4eb8f013c5cfd16010938620381ccc8d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "<b>Cons of the TCL Language:</b>",
      "id": "5b5bb896544681bf567d949f07b48719"
    },
    {
      "type": "html",
      "text": " Not terribly fast, perl and python are generally faster. Usually fast enough though.",
      "id": "851e77c81547946f2924b519c60ce865"
    },
    {
      "type": "html",
      "text": " As usual, it depends on <i>exactly</i> what you are doing, with common benchmarks often being written to make other languages look good. The old quote about \"lies, damned lies and benchmarks\" does apply.",
      "id": "23703f9ed4e28dc81190ad4bce02de6e"
    },
    {
      "type": "html",
      "text": " Events in Tk are evaluated at the top level scope. No closure tricks for you.",
      "id": "b6538ddd85a4d69e6d9988e2d9d7f10d"
    },
    {
      "type": "html",
      "text": " Lots of \"gotchas\" with respect to quoting",
      "id": "de8dd8ad6cd8b45d9d0c07efbd289304"
    },
    {
      "type": "html",
      "text": " This is a bit inbetween really; the quoting rules are actually very simple, but beginners do sometimes have problems, as they infer extra semantics which aren't really there (typically by assuming {} marks blocks of code like in C).",
      "id": "831c2eb9eff5c92a7aba2cff312053cd"
    },
    {
      "type": "html",
      "text": " <i>I find it's difficult to x-ray or study all the potential levels of quoting and escape indirection unwinding. It's sort of the quote-level version of [[Thick Bread Smell]]. I'd rather break things up a bit, [[Divide And Conquer]] and have a language that facilitates such.</i>",
      "id": "4f8b3032f47c5d48cdddcf3f29abf3ec"
    },
    {
      "type": "html",
      "text": " No anonymous functions - packages that do appear to provide them create global objects that are not garbage collected among other problems.",
      "id": "b077cff8ac15480403851f62cb16f39c"
    },
    {
      "type": "html",
      "text": " However anonymous code fragments are available, and version 8.5 allows these fragments to have scopes.",
      "id": "9ddd59a17fdce5309d89ca5fa69a27d3"
    },
    {
      "type": "html",
      "text": " <i>Doesn't the \"apply\" command in Tcl 8.5 provide anonymous functions?</i>",
      "id": "981883c68fd62774b792014008b97c24"
    },
    {
      "type": "html",
      "text": " Suffered under a disgustingly hype-laden regime under scriptics. (\"Leverage your cross-functional b2b synergies with scripting!\") Thankfully no longer a problem after the dot com crash.",
      "id": "1441a412819664acbd05e932284f0943"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "<b>More on TCL</b>",
      "id": "2199bdba6e83896048b19756013d8f1e"
    },
    {
      "type": "html",
      "text": "\nIt is untyped and uncompiled [-- It does, however, utilize a bytecode compiler for efficiency now, making it about as slow as other scripting languages]. Tcl is much more a dynamic language than comparable scripting languages, and makes use of <i>data as code</i> model to great advantage.",
      "id": "937571c77a069a655067d13fe51b803d"
    },
    {
      "type": "html",
      "text": "\nTCL's main attraction is its small footprint, ease of network and GUI programming, event model, write-once-run-many (programmers usually have to go out of their way to make Tcl programs platform specific.)",
      "id": "fb39942feeed9fb47ec92489639832d5"
    },
    {
      "type": "html",
      "text": "\nIt has a C API which makes embedding an interpreter easy (making it an [[Embedded Language]]). Passing data back and forth is easy, as is writing extension commands to the interpreter.",
      "id": "0831cf4a289a0d76ae9542c19040bf43"
    },
    {
      "type": "html",
      "text": "\nSee [http://wiki.tcl.tk/4364 wiki.tcl.tk] (a two-player car racing game in 127 LOC) or [http://wiki.tcl.tk/4448 wiki.tcl.tk] (pages on [[The Tclers Wiki]]) for examples of why some people like Tcl so much - brevity and automation of complex tasks.",
      "id": "5be87f76831c62c4b0a59d867db06c2f"
    },
    {
      "type": "html",
      "text": "\nTcl was invented by [[John Ousterhout]] while he was a professor at [[Cal Berkeley]].",
      "id": "a25807923956db8c510b49ea5a68f702"
    },
    {
      "type": "html",
      "text": "\nTcl has several implementations and is widely available on many platforms: Unix, [[Mac Os]]9/ [[Mac Osx]], Windows, Palm OS, Windows CE, MSDOS, several realtime OS's, and as a browser plugin for Mozilla, Netscape, Windows IE. Tcl is also available as Jacl, a Tcl port to Java, thus it also runs anywhere Java runs. See: [http://tcljava.sf.net tcljava.sf.net]",
      "id": "9953ee03f155160533a25838b8ac147d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "<b>Hiring Tclers</b>",
      "id": "0885d7de397d8583f64046cbc0bd15c6"
    },
    {
      "type": "html",
      "text": " You will find a list of Tclers interested in doing contract work or working full time here: [http://wiki.tcl.tk/1588 wiki.tcl.tk] ",
      "id": "945e40d07d908a1a2e79bdaf9b33f526"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "<b>Comments</b>",
      "id": "eedc3e34f81ed1fa725a7c516e04ac1c"
    },
    {
      "type": "html",
      "text": "\nIndeed, Tk is popular; it can even be accessed from Python and Perl <i>(and Erlang)</i>. -- [[Falk Bruegmann]]",
      "id": "0e71fc5fe1deba9354832a85438d1bfa"
    },
    {
      "type": "html",
      "text": "\nTk is a common reason Tcl is widely used. It is a very good GUI toolkit: lightweight, easy to use, simple to extend. It had a Motif look and feel,but was far simpler to use than Motif. It now uses the local look-and-feel of the platform on which it is running [- which is Motif on UNIX]. It is quite common that programs written on Unix/X11 runs unchanged on Windows and Mac (the same is true for Windows to Unix.)",
      "id": "c16c541d0713fc44088ea145406c1d2a"
    },
    {
      "type": "html",
      "text": "\nTcl as a language is highly dynamic and provides useful introspection facilities. If one writes idiomatic Tcl, using [[Meta Programming]] techniques, rather than using it in the way one writes C or Pascal, one can write efficient and elegant programs.",
      "id": "26af3ac2f81c0db928140470920e20e4"
    },
    {
      "type": "html",
      "text": "-- [[Nat Pryce]]",
      "id": "edb6430d1bb729ce9829acb095b425dd"
    },
    {
      "type": "html",
      "text": "<i>Nat, how are those techniques when used for Tcl? I've written quite a lot of Tcl/Tk code but I am not sure of what you are talking about. A friend and I were thinking about writing a Tcl module so we could make an abstraction layer for access to databases. The idea was creating something similar to DBI in Perl or JDBC in Java, but for Tcl (starting with postgresql). I got a nice design and when I sent it to my friend, he had already written a prototype, which created a 'database widget', similar to a Tk widget, indeed virtually indistinguishable. I found the idea fascinating and so we took that approach. Is this that metaprogramming you're talking about? -- [[David De Lis]]</i>",
      "id": "323967ef1258a0f34b21c7424817cc1f"
    },
    {
      "type": "html",
      "text": "\nMetaprogramming is writing code that, itself, writes code. The code that is generated represents application data. For example, a Tcl script could parse an XML document to create another Tcl script that has same structure as the document, and in which commands are named after the nodes of the document. The top level script can provide implementations of the commands in the \"parse tree\" to process the nodes. Evaluating the parse as a script then processes the parsed data.",
      "id": "49fa885ae720220f38b2c8d38c86701e"
    },
    {
      "type": "html",
      "text": "\nSo processing and parsing are performed by:",
      "id": "441145d4ac1a162443f25a71c339314a"
    },
    {
      "type": "code",
      "text": " proc node_NODE1 { ... } {\n  ...\n }",
      "id": "cbbf8e4d75bb1a7b7067c2cd25836874"
    },
    {
      "type": "code",
      "text": " proc node_NODE2 { ... } {\n  ...\n }",
      "id": "061d9f29dcb1eacde0eaade0fce009a9"
    },
    {
      "type": "code",
      "text": " ...",
      "id": "40f423b122de599035d535007e505002"
    },
    {
      "type": "code",
      "text": " eval [xml::parse $file]",
      "id": "25e2f412fd95c676c6eb964986fe5320"
    },
    {
      "type": "html",
      "text": "The basic advantage of this is that, instead of interpreted code manipulating script-level data structures, you have C code (the interpreter) manipulating \nthe data structures that represent the language.",
      "id": "43179db397822db69bd84d779db06d85"
    },
    {
      "type": "html",
      "text": "\nSee [http://www-dse.doc.ic.ac.uk/~np2/patterns/scripting/ www-dse.doc.ic.ac.uk]",
      "id": "d59cfcda349bc57a925cc58dcae45e38"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "<b>Functional composition</b>",
      "id": "03e718ba198fa97ff548b87d08c4e858"
    },
    {
      "type": "html",
      "text": "\nHere is a small but mighty example of metaprogramming: functional composition",
      "id": "23488fbbb1f9260b0438de03142ce836"
    },
    {
      "type": "code",
      "text": " proc o args {\n  proc [set name [info level 0]] x \"\n  [join $args { [}] \\$x [string repeat \\] [expr {[llength $args]-1}]]\"\n  set name\n }",
      "id": "ac232b96635548addbbb90fec40a4a69"
    },
    {
      "type": "html",
      "text": "Maybe some explanations are necessary. A procedure named \"o\" is created (popular operator for function composition) which takes any number of arguments (indicated by the \"args\" special name). What the proc does is create another proc, with a name exactly as its creator was called (this is what [info level 0] returns), and exactly one argument, called x.",
      "id": "d1028e3e03e8cb1c85cdc8bf650a4150"
    },
    {
      "type": "html",
      "text": "\nThe body of this generated proc joins the args arguments (function names) with a space and an open bracket, indicating embedded evaluation, then the argument x - dereferenced by $ but deferred by the prepended backslash - and finally a sequence of closing brackets, one less than the length of the originally input args.",
      "id": "98fe03bf091e69dbfad549420cd72f40"
    },
    {
      "type": "html",
      "text": "\nFor example, consider the composition of three functions named \"foo\", \"bar\", and \"grill\":",
      "id": "9992f939ca75ddc82e1db50d21f57465"
    },
    {
      "type": "code",
      "text": " % o foo bar grill\n o foo bar grill",
      "id": "818e862d7b44b87544472c1c1c1aaaf6"
    },
    {
      "type": "html",
      "text": "The returned result is the name of the generated procedure (not a true lambda, as it has a name, but coming close). It contains spaces, but that is no problem in Tcl, just quote accordingly. For instance, if we want to see the body of the generated procedure,",
      "id": "8e73350826120fc20a2311d7ecb785df"
    },
    {
      "type": "code",
      "text": " % info body \"o foo bar grill\"\n foo [bar [grill $x ]]",
      "id": "bd84c249af0f9bf16abde59fcca04f55"
    },
    {
      "type": "html",
      "text": "See? A \"nest of invocations\" of the three functions has been created, and calling \"o foo bar grill\" with an argument just combines the three functions as intended. [[Richard Suchenwirth]]",
      "id": "3b24e0cfb5f8725fabf6d8a667cd1111"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "<b>More comments</b>",
      "id": "062b4a00c78db94a28438d6510214544"
    },
    {
      "type": "html",
      "text": "\nMore than a few programmers have been led into the world of Tcl because [[Philip Greenspun]] chose to base his open-source ACS on AOLServer. Some very high volume web sites run AOLServer.",
      "id": "1e71fc2349271b842bb69a21115aca81"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "Tcl is a powerful language when we use it for CAD applications.",
      "id": "315415e41d5bde1e7fee41ee39042d4b"
    },
    {
      "type": "html",
      "text": "\nTcl had, as its original purpose, to provide a common framework for writing the tiny languages that many applications have. In particular, think of things like spreadsheets, drawing programs, statistics programs - anything which requires one to issue commands or to take several actions - say a mail program for instance.\nTcl is great for creating tiny languages with a lot of power. And its syntax is simple enough to teach to nonprogrammers. <i>If they can get their brain around which brackets go where to express a simple if-then-else. Who would teach non-programmers to program in Tcl when there are Python and Ruby???</i> ",
      "id": "10f082f19fcb1b92609a46f418d2f0bc"
    },
    {
      "type": "html",
      "text": " Someone who doesn't know (or know of) Python or Ruby, someone whose student will be encountering Tcl (think of teaching a physicist how to moderately change a few widgets on an preexisting lab setup,), various other reasons. I like Python and Ruby too, much more so than Tcl, but that's no reason to start yet another [[Language Pissing Match]].",
      "id": "2010ac4008ee6b0fdb8d9f673c5ab6ff"
    },
    {
      "type": "html",
      "text": " Also, Tcl's syntax is considerably closer to natural languages: the words of a command are just separated by whitespace (like in LISP and Forth). So it's syntactically easy to write a Tcl procedure that parses and executes (that's the harder part)",
      "id": "d345a98f7da9f5f82d0fd2cb15c74be8"
    },
    {
      "type": "code",
      "text": " read my mind and do what I mean",
      "id": "8cee3aa7064057ad5ab3ba7d26750453"
    },
    {
      "type": "html",
      "text": "which in many other languages would have to be",
      "id": "3d9c8f58d393b5cd9096af929ea46ac0"
    },
    {
      "type": "code",
      "text": " read(\"my\", \"mind\", \"and\", \"do\", \"what\", \"I\", \"mean\");",
      "id": "fcdffe2ab98b7260a75325642951d34f"
    },
    {
      "type": "html",
      "text": "<i>And upvar is confusing enough to tie them up in knots for ever more. Tcl is a tragic case of a language design being severely degraded by a single feature.</i>",
      "id": "b77561d204597ca27580375b2469a32c"
    },
    {
      "type": "html",
      "text": "\nFUD. Upvar is 1) not needed all that often, 2) a very simple concept: given the name of a variable, and optionally a context (global or stack level), upvar sets up an alias so you can access that variable (r/w) via a local name. It's indispensable for Tcl's by-value / reference-free approach to data structures. -- jcw",
      "id": "e5e9ccf56267cb7b773ff1b1f513a5dc"
    },
    {
      "type": "html",
      "text": "<i>Yes. One should only use upvar when he wants to return two or more variables from a procedure and doesn't want to do that in a list.</i>",
      "id": "757abcfe0e0c37d4ad7e174dca3936a0"
    },
    {
      "type": "html",
      "text": "\nTo explain it even simpler: the [upvar] command is Tcl's way of [[Call By Name]], pretty equivalent to passing a pointer to a variable in C (only that you can specify the scope in which the name applies). It is mostly used to pass Tcl arrays (hash tables in fact), which can't be done by value. But it, together with [uplevel], also allows building all kind of debugging tools very simply. Here's an example - append an item to a list if it isn't there yet:",
      "id": "b7e6d5b5bf95b88b6192b15dfcdfb265"
    },
    {
      "type": "html",
      "text": "<i>If that explanation were in the manual entry for upvar or in the tcl tutorial at [http://www.tcl.tk www.tcl.tk], far less people would be confused by upvar.</i>",
      "id": "39a8424f3870572f76436530ca69241b"
    },
    {
      "type": "code",
      "text": " proc ladd {listVar item} {\n  upvar 1 $listVar list\n  if {[lsearch $list $item] == -1} {lappend list $item}\n }\n set aList {2 4 8 16} \n ladd $aList 16 ;# doing it wrong; you should pass the name of\n                 # the variable, not its value.\n ladd aList 32  ;# aList is now {2 4 8 16 32}.\n ladd aList 4   ;# aList is unchanged.",
      "id": "e4f295f73a6fa2c392342e6046b4c40d"
    },
    {
      "type": "html",
      "text": "Another example, first in C:",
      "id": "b5cc1f49d63b048201acea634ef90186"
    },
    {
      "type": "code",
      "text": " void f(int x, int *y) {\n    *y = x;\n }",
      "id": "4610580c04ea251eb41555c03d0cab15"
    },
    {
      "type": "html",
      "text": "then the equivalent in Tcl:",
      "id": "400fefefc53db6efa37579166c45256c"
    },
    {
      "type": "code",
      "text": " proc f {x _y} {\n   upvar $_y y\n   set y $x\n }",
      "id": "11207c39cba9c60d457ea62217bb578d"
    },
    {
      "type": "html",
      "text": "The difference to LISP (with its special forms and macros) is that you can always know whether you pass a value (as constant, or with \"$\" notation), or a variable name (via upvar) that may have side-effects, like changing the list, in the example.",
      "id": "315a15cb07bd526bba4d25eab7085474"
    },
    {
      "type": "html",
      "text": "\nIn general, I suppose people experienced in languages of the Fortran/Algol/C/Java heritage may sometimes be bewildered by Tcl's concepts, but coming from LISP, one might very soon feel at home... ",
      "id": "db49c6e1806384cb86510eaeb36aeb06"
    },
    {
      "type": "html",
      "text": "-- [[Richard Suchenwirth]]",
      "id": "6b2d6fef09e7e1686f61d153d7701d3e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "<b>[[Tcl War]] with [[Richard Stallman]]</b>",
      "id": "a71bc9ac1c275024a8ea2ec226b53fb4"
    },
    {
      "type": "html",
      "text": "\nSeveral years ago, there was a big bruhaha between Richard Stallman and TCL fans. Richard claimed that TCL does not scale to large applications, and thus should be avoided in case small applications grow large. (Naturally, RMS perferred [[Lisp Language]].) Personally, I suspect this depends on one's development style. If one uses a task-oriented and event-driven model, then \"large application\" is generally meaningless because you simply have a bunch of small programs that respond based on the state as recorded in files or databases with a few parameters passed between each script.",
      "id": "bc676dfe402a98437d91228a5c2256b2"
    },
    {
      "type": "html",
      "text": "<i>Unfortunately, [[Richard Stallman]] was right but did not put his point across in a politically astute way. His argument was that Tcl is a rather poor foundation for a universal language with which to make applications scriptable, and that it would be better to embed a Scheme interpreter into applications and compile different scripting languages to Scheme at read-time. Now we have Parrot and .NET both trying to be virtual machines for different languages, both of which can be used as embedded interpreters. However, Scheme would be a more elegant representation than bytecodes.</i>",
      "id": "4e0f233de7d49b86f58315a3bc33f74e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "<b>More comments</b>",
      "id": "062b4a00c78db94a28438d6510214544"
    },
    {
      "type": "html",
      "text": "\nI chose Tcl as my first (and, so far, only) programming language because it's simple and comprehensible; it's oriented more toward text and graphics (with the Tk toolkit) than toward maths and logic; it doesn't require the programmer to spend any time on loathsome tasks such as compiling; and yet you can do a whole lot of things with it. ",
      "id": "8e9f51e1f4e614bd4663e563f45ef20a"
    },
    {
      "type": "html",
      "text": "-- David [[Mc Clamrock]]? ",
      "id": "11e495bbec3095c39e34e3df663b5707"
    },
    {
      "type": "html",
      "text": "<i>Tcl is by far the simplest of the major scripting languages to extend with C modules. Especially using critcl. However, they all have their place. Even vbscript :) -- Pat Thoyts</i> ",
      "id": "440de1fb58ff45a16b76d0e588de3430"
    },
    {
      "type": "html",
      "text": "\nEvery time I have to do another project in Tcl/tk, I'm amazed at how easy it is to get my ideas into code quickly, and more importantly, correctly! ",
      "id": "cfa99f070171d793d7afc2a1f27ed2ec"
    },
    {
      "type": "html",
      "text": "<i>I don't like C++, as everything is sooo complicated. I do like Tcl/Tk, because it's not. -- Philipp</i> ",
      "id": "e6c8295d10debd5cbf9077d907027d6e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "\nI am not sure what is happening in constructs like this:",
      "id": "632ce7845f4e23b7333bbe990dc42046"
    },
    {
      "type": "code",
      "text": "  $t insert end \"Hello World!\"",
      "id": "d74cbec5603448a9b730fedfb9a8de92"
    },
    {
      "type": "html",
      "text": "The \"t\" variable is referencing some kind of widget (in this case a text GUI widget). What is happening in this case from a linguistical standpoint? How does it know which widget to operate on, especially if there are multiple text widgets?",
      "id": "a56c353bcf19f056929166054c93428f"
    },
    {
      "type": "html",
      "text": "<i>the $t will be expanded to the value stored in t, which as you say is an instance of a widget. you have to remember that the first word on a line in TCL is a command (the rest of the words are arguments to the command) . the text command created a new command which enables you to interact with that text widget. so you call the 'interact with text widget foo' command, which happens to be the path of the text widget, it then uses </i>insert end \"Hello world!\"<i> to do that operation on itself. hope that made sense - there is more info in the help that comes with TCL -- [[James Keogh]]</i>",
      "id": "14ad41554ec0f907d32de645c12fa265"
    },
    {
      "type": "html",
      "text": "\nI am still fuzzy on the steps the interpreter is taking. Tcl is not inherently object-oriented, so thinking of it in terms of an OOP language is probably misleading. The variable substitution may create a command that looks something like:",
      "id": "651d04858357c1dda752cf4ee3135453"
    },
    {
      "type": "code",
      "text": "  .myTextWidget insert end \"Hello World!\"",
      "id": "7cce4bbe127f2651dac2dd0aaec9b084"
    },
    {
      "type": "html",
      "text": "But what exactly is \".myTextWidget\"? It appears that \".myTextWidget\" is a dynamically created function, not an object, but my documentation talks about it like it is an object in some places. Is this to sound \"in fashion\" to attract more Tcl users, or is it really an object?",
      "id": "2593ff9a90691934253bb65fbda16e6c"
    },
    {
      "type": "html",
      "text": "<i>.myTextWidget is a string, namely the name (actually the \"path\" in tcl jargon). It's all strings. Actually there may be some gyrations you can go through to get the underlying widget, but in general, with Tcl, you're dealing with names, not references. As an optimization, the compiler generates code that knows about types, widgets, what have you, but the closest analog to tcl is shell script. In the context above, i.e. beginning a line with the widget name, it's interpreted as if it's a function or object (with no references, there's really no difference). You can't go getting a reference to .myTextWidget though, except for its name - Tcl has [[Call By Name]] semantics, and oh yes, you can abuse the hell out of those semantics if you try. Ultimately, however, these semantics tend to hinder the language from being able to implement advanced things instead of helping it, as was discovered in [[Algol Sixty]] (another language to have [[Call By Name]] semantics)</i>",
      "id": "a877828adffb7c1ba3334a56ef66b750"
    },
    {
      "type": "html",
      "text": "\nBut Tcl is supposed to follow the convention:",
      "id": "fa3bca639b7a52119ad56c1db9f76765"
    },
    {
      "type": "code",
      "text": "  command paramString1 paramString2 paramString3 ...",
      "id": "41a773d43a075bbef976d35d8bdf391c"
    },
    {
      "type": "html",
      "text": "So it tries to execute \".myTextWidget\" as a command. Is it actually \"registered\" as a command? For example, somehow put into the \"command/function list\"?",
      "id": "81f0462b3681027e5c5447f3c9698ef6"
    },
    {
      "type": "html",
      "text": "\nyes it is actually a command try this in wish:",
      "id": "1f39e76e10fa32724f14df12225f92f6"
    },
    {
      "type": "code",
      "text": " button .but -text \"test\"\n info commands .*",
      "id": "92837eb513aecb3cdd9f7ab554f268b0"
    },
    {
      "type": "html",
      "text": "button creates a new command called .but, .but command acts on a <i>particular</i> button widget. \"info\" commands list all the commands with the given pattern. -- [[James Keogh]] <i>{Did minor syntax editing}</i>",
      "id": "b5dc0c688a69d6567b56791ce186c573"
    },
    {
      "type": "html",
      "text": " text .myTextWidget",
      "id": "1c57d5b234ffd0c4c5e029eceaa516a9"
    },
    {
      "type": "html",
      "text": " set t .myTextWidget",
      "id": "9cdc5bbe76c6a103f2326664682479c8"
    },
    {
      "type": "html",
      "text": " pack $t",
      "id": "ebc1d28d121f0c21ea27606c9b5bb427"
    },
    {
      "type": "html",
      "text": " $t insert end \"Hello World!\"",
      "id": "76d5c7fb887a555fb1c05725df644c3b"
    },
    {
      "type": "html",
      "text": "Let's see if I've got this straight. The first line creates a command called \".myTextWidget\". The second line creates a variable \"t\" that contains the string \".myTextWidget\" (for reference convenience). The third line (\"pack\") sends the string \".myTextWidget\" to the \"pack\" command. The fourth line evaluates internally into:",
      "id": "ed595cdd4adeba72e76b258f9a42e6b5"
    },
    {
      "type": "code",
      "text": "  .myTextWidget insert end \"Hello World!\"",
      "id": "7cce4bbe127f2651dac2dd0aaec9b084"
    },
    {
      "type": "html",
      "text": "which executes the command created in line one. In line one, the Tk system creates both a command named \".myTextWidget\" <i>and</i> puts the name \".myTextWidget\" into an internal list. Line three uses the internal list, not the command (that was also created). Line four executes the command \".myTextWidget\" that was created in line one. It is confusing because the Tk system creates two things which can be referenced: a command and an entry in an internal list. These are two different things even though they have the same name. My Tcl book never seemed to clarify this double action, leaving me to scratch my head.",
      "id": "8467049bc4e2c1a649f5f01652192916"
    },
    {
      "type": "html",
      "text": "\nWell, I suppose the Tk system can use the command list as the \"internal list\" I talked about to achieve the same thing. But, the point is that in some of the commands we are passing a string (widget ID) and in others we are using it as a command.",
      "id": "5b15062ab1bac4f9cfc1bfdb3829ca84"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "\nRegarding this roll-your-own UNTIL loop example from [[Dynamic Strings Vs Functional]]:",
      "id": "b9d4cc0ccfcd6448b3b2032e58f8d6c0"
    },
    {
      "type": "code",
      "text": " proc until {condition body} {\n  uplevel 1 $body\n  while {![uplevel 1 [list expr $condition]]} {\n    uplevel 1 $body\n  }\n }",
      "id": "85b288e692ec9cf2d8da1ac9fe4616a4"
    },
    {
      "type": "html",
      "text": "Why do we need a \"list\" construct? Why not just:",
      "id": "ef8fcae42a7b000fa66b8a921ebd9d76"
    },
    {
      "type": "code",
      "text": "  while {![uplevel 1 $condition]} {...}",
      "id": "39c5e7aaa21104413e0f9cf1a16f6381"
    },
    {
      "type": "html",
      "text": "<i>These are the tricky parts. \"list\" can be used to protect from double-evaluation, if $condition for instance contains parts which start with $ we don't want them evaluated by the interpreter but to let the \"expr\" command deal with them. \"list\" is generally used for this with \"eval\" and \"uplevel\" and similar things -- [[Kristoffer Lawson]]</i>",
      "id": "1f3ba963b090af4070b681bf58cccf12"
    },
    {
      "type": "html",
      "text": "\nWhy don't the \"body\" uplevel's also need to use \"list\"?",
      "id": "5df8a3c5cc1b934061d26da5fa5ef5a8"
    },
    {
      "type": "html",
      "text": "<i>Because the \"body\" uplevels only get substituted once. Each time Tcl sees a command, it breaks it up into words (based on spaces and quoting). Then it does one level of expansion in those words (no expansion happens in {} quotes).</i>",
      "id": "389daa930a0de27dbd94660ce6642d26"
    },
    {
      "type": "html",
      "text": "\nSo, assume $body == {puts \"Hello, world!\"}, and $condition == {$a == 1}.",
      "id": "5ca9ed14beeabfb0b8587301d7c2afb8"
    },
    {
      "type": "html",
      "text": "\nTcl turns the \"uplevel 1 $body\" into:",
      "id": "f6369e779c67bdf508a7ab7afb56837a"
    },
    {
      "type": "code",
      "text": "  uplevel 1 \"puts \\\"Hello, world!\\\"\"",
      "id": "7da8feb3ec195551205361a406232d30"
    },
    {
      "type": "html",
      "text": "The uplevel then does an eval on the 3rd argument, so the command runs as:",
      "id": "f8abe33706f96c36fe1b68963aed3288"
    },
    {
      "type": "code",
      "text": "  puts \"Hello, world!\"",
      "id": "3b55261606927ea498404a9b6de875fc"
    },
    {
      "type": "html",
      "text": "Just as we intended it. ",
      "id": "6932bfbe3b69f4f29790e223a733266a"
    },
    {
      "type": "html",
      "text": "\nThe \"while\" command, on the other hand, gets passed with two words, the condition:",
      "id": "f4cfb7a2c491b784d3a334e9830c504a"
    },
    {
      "type": "code",
      "text": "  {![uplevel 1 [list expr $condition]]}",
      "id": "e9e39ef84dc4192f9475feea6813766d"
    },
    {
      "type": "html",
      "text": "And the body:",
      "id": "ded25fb0e785c8228a15a7a78e575c60"
    },
    {
      "type": "code",
      "text": "  { uplevel 1 $body }",
      "id": "982d1fb5547cbf965b0a6791143b62e9"
    },
    {
      "type": "html",
      "text": "The condition gets passed implicitly to the \"expr\" command (sort of; it won't call your expr if you redefine it). The \"expr\" command does variable, backslash and [command] substitution on the string. So:",
      "id": "6739202ccefed81579695ca03586c26c"
    },
    {
      "type": "code",
      "text": "  [uplevel 1 [list expr $condition]]",
      "id": "fbe0732cc954f3a983230bf7dce9d8fb"
    },
    {
      "type": "html",
      "text": "gets expanded recursively:",
      "id": "d1ed9cd1012ac168bdc12a08cfcb458c"
    },
    {
      "type": "code",
      "text": "  uplevel 1 [list expr $condition]",
      "id": "4f93c589c31ecabec48d3de34842fea5"
    },
    {
      "type": "html",
      "text": "then (because [list] quotes its operands):",
      "id": "61e21ec22598de08ffda37b47127eaf6"
    },
    {
      "type": "code",
      "text": "  expr {$a == 1}",
      "id": "0d60a35697e482d404cbf668efdac852"
    },
    {
      "type": "html",
      "text": "gets executed one level up in the stack context.",
      "id": "55fb607c04c5b6c143cf6bd41930571b"
    },
    {
      "type": "html",
      "text": "\nThe {} quoting around the expr argument is required because expr does its own substitution. If you let uplevel parse it as:",
      "id": "86bb010426754c1b3abb5a3d18f62c7c"
    },
    {
      "type": "code",
      "text": "  uplevel 1 expr $condition",
      "id": "65e7629c30f9dd72c7803c61ba387e16"
    },
    {
      "type": "html",
      "text": "the first level expansion will turn it into:",
      "id": "03dc1212e54473a829b634fc10f56fa4"
    },
    {
      "type": "code",
      "text": "  uplevel 1 expr \"$a == 1\"",
      "id": "211580a03bbee51154f1fb122d7793d7"
    },
    {
      "type": "html",
      "text": "then uplevel itself would substitute:",
      "id": "18b09241277f3f409e4112101e492932"
    },
    {
      "type": "code",
      "text": "  expr $a == 1",
      "id": "4c6bd2ac8fed592a9e7c8dc33b9ba9de"
    },
    {
      "type": "html",
      "text": "And if, for example, $a == \"x y\", the expr would fail with a syntax error when it does its own expansion, because it would try to parse:",
      "id": "3a5e3b2cfa190050c78e47fdb66c77a0"
    },
    {
      "type": "code",
      "text": "  {x y == 1}",
      "id": "666cbb445f879fe56be2770c6217d950"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "We use TCL where I work to make long-running network servers scriptable. The biggest advantage about TCL is that anyone that has ever written a beggining \"intro to C\" argc/argv style program knows exactly how to write a TCL command. Then the internal state and various options over behavior are exposed (via a socket attached to the global Tcl Interp) for our operational pleasure.",
      "id": "680dca018d6f3b357428f7c7baf9597e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "[[Richard Suchenwirth]] : Above it was said that \"Tcl is not OO\". There is more OO support in the making currently, but for a long while it has been possible to roll one's own OO in pretty simple ways. Example, a Stack \"class\" without any extra framework needed (both the class and its instances are implemented as namespaces):",
      "id": "fe7de1b26e7dc5a84d664f81fd047176"
    },
    {
      "type": "code",
      "text": " namespace eval Stack {variable n 0} ;#-- \"class variable\"",
      "id": "86b7624b482db26edb72939272c07fb0"
    },
    {
      "type": "code",
      "text": " proc Stack::Stack {} { #-- Constructor\n   variable n\n   set instance [namespace current]::[incr n]\n   namespace eval $instance {variable s {}} ;#-- \"member variable\" \n   interp alias {} $instance {} ::Stack::do $instance\n }\n proc Stack::do {self method args} { #-- Dispatcher with methods\n   upvar #0 ${self}::s s\n   switch -- $method {\n       push {eval lappend s $args}\n       pop  {\n           if ![llength $s] {error \"stack underflow\"}\n           K [lindex $s end] [set s [lrange $s 0 end-1]]\n       }\n       default {error \"unknown method $method\"}\n   }\n }\n proc K {a b} {set a}",
      "id": "33a241726e1d631b24bd0346604ca519"
    },
    {
      "type": "html",
      "text": "\nTesting in an interactive tclsh:",
      "id": "3632fabc211ef570bf856909af831c3d"
    },
    {
      "type": "code",
      "text": " % set s [Stack::Stack] ;#-- constructor\n ::Stack::1             ;#-- generated name of a stack instance\n % $s push hello\n hello\n % $s push world\n hello world\n % $s pop\n world\n % $s pop\n hello\n % $s pop\n stack underflow       ;#-- error message on empty stack\n % namespace delete $s ;#-- destructor",
      "id": "984ed9da59760ebbdf7d644e4b3b8682"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "<b>Some Tcl/Tk Links and Tutorials</b>",
      "id": "025602d7c45bf3a1ee46625cf786811d"
    },
    {
      "type": "html",
      "text": "\nOfficial tutorial: [http://www.tcl.tk/man/tcl8.5/tutorial/tcltutorial.html www.tcl.tk]",
      "id": "79ba2a6d23934e1bef1c1e40085a15b2"
    },
    {
      "type": "html",
      "text": "\n[http://www.geocities.com/binnyva/code/tcl/tutorial/index.html www.geocities.com]",
      "id": "b2ce9b5442751789d562dd163152703f"
    },
    {
      "type": "html",
      "text": "\n[http://wiki.tcl.tk wiki.tcl.tk]",
      "id": "59b404285859be659594882ad4e8f2d6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "[[Simplified Wrapper And Interface Generator]] (SWIG) can be used to make calls to [[Cee Language]] or [[Cee Plus Plus]] code.",
      "id": "8d11a02778a1c8d57a728914d5c455dc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "See also [[Tcl Tk]], [[Dynamic Strings Vs Functional]], [[Active Tcl]], [[Quote Free Language]]",
      "id": "14a049bed9991d13ea21e0cb08e38926"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2373c00992f26fba5c2a5e0801ab70e3"
    },
    {
      "type": "html",
      "text": "[[Category Programming Language]] [[Category Tcl]]",
      "id": "d1fbca8d3992fb9de264eba8b56608a1"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ToolCommandLanguage c2.com]",
      "id": "5575e3841cf6294d1c82bd5c8e814010"
    }
  ],
  "journal": [
    {
      "date": 1328252259000,
      "id": "b37c52eb34b87c9f58792126618ac6f1",
      "type": "create",
      "item": {
        "title": "Tool Command Language",
        "story": [
          {
            "type": "html",
            "text": "Tcl -- Tool Command Language",
            "id": "f34fd84c0118305811aa26202df3df24"
          },
          {
            "type": "html",
            "text": "\nSome important websites for more information and downloads:",
            "id": "8f9db0f4128b88fbecfea13f2719fe0c"
          },
          {
            "type": "html",
            "text": " [http://www.tcl.tk/ www.tcl.tk]",
            "id": "74d019da013ad1611c45088ce353e102"
          },
          {
            "type": "html",
            "text": " [[The Tclers Wiki]]",
            "id": "07ceecf4dcb073fd0dc71656aea5a6ee"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "<b>Description of the Tcl language</b>",
            "id": "968f56a381a0fc4b9794067325fe53e5"
          },
          {
            "type": "html",
            "text": "\nEasily extendable script language which became most famous for the \"[[Tcl Tk]] [[Gui Toolkit]]\" and \"[[Tcl Expect]]\", as well as for easy embeddability, but it is increasingly used in other spheres. Some of its most unique features:",
            "id": "f5acbb5830a13e6779d88989727eadcf"
          },
          {
            "type": "html",
            "text": " Everything is a string (native representation is used behind the scenes). All values can be used inter-changeably and anywhere where a string can be used for natural serialization.",
            "id": "4faec8b0b8ae1874eef045a6647c4fde"
          },
          {
            "type": "html",
            "text": " Extremely minimalistic syntax: cmd arg arg arg ...",
            "id": "995f36091a92de36e0800e3e33db5a9a"
          },
          {
            "type": "html",
            "text": " No reserved keywords",
            "id": "31d95bb0f00e50b7856e358cbd870268"
          },
          {
            "type": "html",
            "text": " No static language constructs (for, while etc. are just commands like any other)",
            "id": "8114776ecfa3fc78d5025c18e3728314"
          },
          {
            "type": "html",
            "text": " Flexible event-based programming. F.ex. IO and GUi events call callbacks which greatly reduces the need for threads",
            "id": "4918bb54e07d64bfb78fd982ead89e6c"
          },
          {
            "type": "html",
            "text": " Has a threading system, too.",
            "id": "c7d50ec2300635b6ed7fe0a54837064c"
          },
          {
            "type": "html",
            "text": " Everything can be dynamically changed and replaced (remember: language constructs are also just commands too!)",
            "id": "ff5766cb2c7915bf6405424ac86d8aad"
          },
          {
            "type": "html",
            "text": " The Virtual Filesystem mechanism",
            "id": "2c1027c86b2908d48038077442b36c14"
          },
          {
            "type": "html",
            "text": " Doesn't force any particular programming paradigm. For instance, a wide range of OO extensions exist from the more traditional [incr Tcl] to the more dynamic [[Extended Object Tcl]] and delegation -style Snit.",
            "id": "4eb8f013c5cfd16010938620381ccc8d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "<b>Cons of the TCL Language:</b>",
            "id": "5b5bb896544681bf567d949f07b48719"
          },
          {
            "type": "html",
            "text": " Not terribly fast, perl and python are generally faster. Usually fast enough though.",
            "id": "851e77c81547946f2924b519c60ce865"
          },
          {
            "type": "html",
            "text": " As usual, it depends on <i>exactly</i> what you are doing, with common benchmarks often being written to make other languages look good. The old quote about \"lies, damned lies and benchmarks\" does apply.",
            "id": "23703f9ed4e28dc81190ad4bce02de6e"
          },
          {
            "type": "html",
            "text": " Events in Tk are evaluated at the top level scope. No closure tricks for you.",
            "id": "b6538ddd85a4d69e6d9988e2d9d7f10d"
          },
          {
            "type": "html",
            "text": " Lots of \"gotchas\" with respect to quoting",
            "id": "de8dd8ad6cd8b45d9d0c07efbd289304"
          },
          {
            "type": "html",
            "text": " This is a bit inbetween really; the quoting rules are actually very simple, but beginners do sometimes have problems, as they infer extra semantics which aren't really there (typically by assuming {} marks blocks of code like in C).",
            "id": "831c2eb9eff5c92a7aba2cff312053cd"
          },
          {
            "type": "html",
            "text": " <i>I find it's difficult to x-ray or study all the potential levels of quoting and escape indirection unwinding. It's sort of the quote-level version of [[Thick Bread Smell]]. I'd rather break things up a bit, [[Divide And Conquer]] and have a language that facilitates such.</i>",
            "id": "4f8b3032f47c5d48cdddcf3f29abf3ec"
          },
          {
            "type": "html",
            "text": " No anonymous functions - packages that do appear to provide them create global objects that are not garbage collected among other problems.",
            "id": "b077cff8ac15480403851f62cb16f39c"
          },
          {
            "type": "html",
            "text": " However anonymous code fragments are available, and version 8.5 allows these fragments to have scopes.",
            "id": "9ddd59a17fdce5309d89ca5fa69a27d3"
          },
          {
            "type": "html",
            "text": " <i>Doesn't the \"apply\" command in Tcl 8.5 provide anonymous functions?</i>",
            "id": "981883c68fd62774b792014008b97c24"
          },
          {
            "type": "html",
            "text": " Suffered under a disgustingly hype-laden regime under scriptics. (\"Leverage your cross-functional b2b synergies with scripting!\") Thankfully no longer a problem after the dot com crash.",
            "id": "1441a412819664acbd05e932284f0943"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "<b>More on TCL</b>",
            "id": "2199bdba6e83896048b19756013d8f1e"
          },
          {
            "type": "html",
            "text": "\nIt is untyped and uncompiled [-- It does, however, utilize a bytecode compiler for efficiency now, making it about as slow as other scripting languages]. Tcl is much more a dynamic language than comparable scripting languages, and makes use of <i>data as code</i> model to great advantage.",
            "id": "937571c77a069a655067d13fe51b803d"
          },
          {
            "type": "html",
            "text": "\nTCL's main attraction is its small footprint, ease of network and GUI programming, event model, write-once-run-many (programmers usually have to go out of their way to make Tcl programs platform specific.)",
            "id": "fb39942feeed9fb47ec92489639832d5"
          },
          {
            "type": "html",
            "text": "\nIt has a C API which makes embedding an interpreter easy (making it an [[Embedded Language]]). Passing data back and forth is easy, as is writing extension commands to the interpreter.",
            "id": "0831cf4a289a0d76ae9542c19040bf43"
          },
          {
            "type": "html",
            "text": "\nSee [http://wiki.tcl.tk/4364 wiki.tcl.tk] (a two-player car racing game in 127 LOC) or [http://wiki.tcl.tk/4448 wiki.tcl.tk] (pages on [[The Tclers Wiki]]) for examples of why some people like Tcl so much - brevity and automation of complex tasks.",
            "id": "5be87f76831c62c4b0a59d867db06c2f"
          },
          {
            "type": "html",
            "text": "\nTcl was invented by [[John Ousterhout]] while he was a professor at [[Cal Berkeley]].",
            "id": "a25807923956db8c510b49ea5a68f702"
          },
          {
            "type": "html",
            "text": "\nTcl has several implementations and is widely available on many platforms: Unix, [[Mac Os]]9/ [[Mac Osx]], Windows, Palm OS, Windows CE, MSDOS, several realtime OS's, and as a browser plugin for Mozilla, Netscape, Windows IE. Tcl is also available as Jacl, a Tcl port to Java, thus it also runs anywhere Java runs. See: [http://tcljava.sf.net tcljava.sf.net]",
            "id": "9953ee03f155160533a25838b8ac147d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "<b>Hiring Tclers</b>",
            "id": "0885d7de397d8583f64046cbc0bd15c6"
          },
          {
            "type": "html",
            "text": " You will find a list of Tclers interested in doing contract work or working full time here: [http://wiki.tcl.tk/1588 wiki.tcl.tk] ",
            "id": "945e40d07d908a1a2e79bdaf9b33f526"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "<b>Comments</b>",
            "id": "eedc3e34f81ed1fa725a7c516e04ac1c"
          },
          {
            "type": "html",
            "text": "\nIndeed, Tk is popular; it can even be accessed from Python and Perl <i>(and Erlang)</i>. -- [[Falk Bruegmann]]",
            "id": "0e71fc5fe1deba9354832a85438d1bfa"
          },
          {
            "type": "html",
            "text": "\nTk is a common reason Tcl is widely used. It is a very good GUI toolkit: lightweight, easy to use, simple to extend. It had a Motif look and feel,but was far simpler to use than Motif. It now uses the local look-and-feel of the platform on which it is running [- which is Motif on UNIX]. It is quite common that programs written on Unix/X11 runs unchanged on Windows and Mac (the same is true for Windows to Unix.)",
            "id": "c16c541d0713fc44088ea145406c1d2a"
          },
          {
            "type": "html",
            "text": "\nTcl as a language is highly dynamic and provides useful introspection facilities. If one writes idiomatic Tcl, using [[Meta Programming]] techniques, rather than using it in the way one writes C or Pascal, one can write efficient and elegant programs.",
            "id": "26af3ac2f81c0db928140470920e20e4"
          },
          {
            "type": "html",
            "text": "-- [[Nat Pryce]]",
            "id": "edb6430d1bb729ce9829acb095b425dd"
          },
          {
            "type": "html",
            "text": "<i>Nat, how are those techniques when used for Tcl? I've written quite a lot of Tcl/Tk code but I am not sure of what you are talking about. A friend and I were thinking about writing a Tcl module so we could make an abstraction layer for access to databases. The idea was creating something similar to DBI in Perl or JDBC in Java, but for Tcl (starting with postgresql). I got a nice design and when I sent it to my friend, he had already written a prototype, which created a 'database widget', similar to a Tk widget, indeed virtually indistinguishable. I found the idea fascinating and so we took that approach. Is this that metaprogramming you're talking about? -- [[David De Lis]]</i>",
            "id": "323967ef1258a0f34b21c7424817cc1f"
          },
          {
            "type": "html",
            "text": "\nMetaprogramming is writing code that, itself, writes code. The code that is generated represents application data. For example, a Tcl script could parse an XML document to create another Tcl script that has same structure as the document, and in which commands are named after the nodes of the document. The top level script can provide implementations of the commands in the \"parse tree\" to process the nodes. Evaluating the parse as a script then processes the parsed data.",
            "id": "49fa885ae720220f38b2c8d38c86701e"
          },
          {
            "type": "html",
            "text": "\nSo processing and parsing are performed by:",
            "id": "441145d4ac1a162443f25a71c339314a"
          },
          {
            "type": "code",
            "text": " proc node_NODE1 { ... } {\n  ...\n }",
            "id": "cbbf8e4d75bb1a7b7067c2cd25836874"
          },
          {
            "type": "code",
            "text": " proc node_NODE2 { ... } {\n  ...\n }",
            "id": "061d9f29dcb1eacde0eaade0fce009a9"
          },
          {
            "type": "code",
            "text": " ...",
            "id": "40f423b122de599035d535007e505002"
          },
          {
            "type": "code",
            "text": " eval [xml::parse $file]",
            "id": "25e2f412fd95c676c6eb964986fe5320"
          },
          {
            "type": "html",
            "text": "The basic advantage of this is that, instead of interpreted code manipulating script-level data structures, you have C code (the interpreter) manipulating \nthe data structures that represent the language.",
            "id": "43179db397822db69bd84d779db06d85"
          },
          {
            "type": "html",
            "text": "\nSee [http://www-dse.doc.ic.ac.uk/~np2/patterns/scripting/ www-dse.doc.ic.ac.uk]",
            "id": "d59cfcda349bc57a925cc58dcae45e38"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "<b>Functional composition</b>",
            "id": "03e718ba198fa97ff548b87d08c4e858"
          },
          {
            "type": "html",
            "text": "\nHere is a small but mighty example of metaprogramming: functional composition",
            "id": "23488fbbb1f9260b0438de03142ce836"
          },
          {
            "type": "code",
            "text": " proc o args {\n  proc [set name [info level 0]] x \"\n  [join $args { [}] \\$x [string repeat \\] [expr {[llength $args]-1}]]\"\n  set name\n }",
            "id": "ac232b96635548addbbb90fec40a4a69"
          },
          {
            "type": "html",
            "text": "Maybe some explanations are necessary. A procedure named \"o\" is created (popular operator for function composition) which takes any number of arguments (indicated by the \"args\" special name). What the proc does is create another proc, with a name exactly as its creator was called (this is what [info level 0] returns), and exactly one argument, called x.",
            "id": "d1028e3e03e8cb1c85cdc8bf650a4150"
          },
          {
            "type": "html",
            "text": "\nThe body of this generated proc joins the args arguments (function names) with a space and an open bracket, indicating embedded evaluation, then the argument x - dereferenced by $ but deferred by the prepended backslash - and finally a sequence of closing brackets, one less than the length of the originally input args.",
            "id": "98fe03bf091e69dbfad549420cd72f40"
          },
          {
            "type": "html",
            "text": "\nFor example, consider the composition of three functions named \"foo\", \"bar\", and \"grill\":",
            "id": "9992f939ca75ddc82e1db50d21f57465"
          },
          {
            "type": "code",
            "text": " % o foo bar grill\n o foo bar grill",
            "id": "818e862d7b44b87544472c1c1c1aaaf6"
          },
          {
            "type": "html",
            "text": "The returned result is the name of the generated procedure (not a true lambda, as it has a name, but coming close). It contains spaces, but that is no problem in Tcl, just quote accordingly. For instance, if we want to see the body of the generated procedure,",
            "id": "8e73350826120fc20a2311d7ecb785df"
          },
          {
            "type": "code",
            "text": " % info body \"o foo bar grill\"\n foo [bar [grill $x ]]",
            "id": "bd84c249af0f9bf16abde59fcca04f55"
          },
          {
            "type": "html",
            "text": "See? A \"nest of invocations\" of the three functions has been created, and calling \"o foo bar grill\" with an argument just combines the three functions as intended. [[Richard Suchenwirth]]",
            "id": "3b24e0cfb5f8725fabf6d8a667cd1111"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "<b>More comments</b>",
            "id": "062b4a00c78db94a28438d6510214544"
          },
          {
            "type": "html",
            "text": "\nMore than a few programmers have been led into the world of Tcl because [[Philip Greenspun]] chose to base his open-source ACS on AOLServer. Some very high volume web sites run AOLServer.",
            "id": "1e71fc2349271b842bb69a21115aca81"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "Tcl is a powerful language when we use it for CAD applications.",
            "id": "315415e41d5bde1e7fee41ee39042d4b"
          },
          {
            "type": "html",
            "text": "\nTcl had, as its original purpose, to provide a common framework for writing the tiny languages that many applications have. In particular, think of things like spreadsheets, drawing programs, statistics programs - anything which requires one to issue commands or to take several actions - say a mail program for instance.\nTcl is great for creating tiny languages with a lot of power. And its syntax is simple enough to teach to nonprogrammers. <i>If they can get their brain around which brackets go where to express a simple if-then-else. Who would teach non-programmers to program in Tcl when there are Python and Ruby???</i> ",
            "id": "10f082f19fcb1b92609a46f418d2f0bc"
          },
          {
            "type": "html",
            "text": " Someone who doesn't know (or know of) Python or Ruby, someone whose student will be encountering Tcl (think of teaching a physicist how to moderately change a few widgets on an preexisting lab setup,), various other reasons. I like Python and Ruby too, much more so than Tcl, but that's no reason to start yet another [[Language Pissing Match]].",
            "id": "2010ac4008ee6b0fdb8d9f673c5ab6ff"
          },
          {
            "type": "html",
            "text": " Also, Tcl's syntax is considerably closer to natural languages: the words of a command are just separated by whitespace (like in LISP and Forth). So it's syntactically easy to write a Tcl procedure that parses and executes (that's the harder part)",
            "id": "d345a98f7da9f5f82d0fd2cb15c74be8"
          },
          {
            "type": "code",
            "text": " read my mind and do what I mean",
            "id": "8cee3aa7064057ad5ab3ba7d26750453"
          },
          {
            "type": "html",
            "text": "which in many other languages would have to be",
            "id": "3d9c8f58d393b5cd9096af929ea46ac0"
          },
          {
            "type": "code",
            "text": " read(\"my\", \"mind\", \"and\", \"do\", \"what\", \"I\", \"mean\");",
            "id": "fcdffe2ab98b7260a75325642951d34f"
          },
          {
            "type": "html",
            "text": "<i>And upvar is confusing enough to tie them up in knots for ever more. Tcl is a tragic case of a language design being severely degraded by a single feature.</i>",
            "id": "b77561d204597ca27580375b2469a32c"
          },
          {
            "type": "html",
            "text": "\nFUD. Upvar is 1) not needed all that often, 2) a very simple concept: given the name of a variable, and optionally a context (global or stack level), upvar sets up an alias so you can access that variable (r/w) via a local name. It's indispensable for Tcl's by-value / reference-free approach to data structures. -- jcw",
            "id": "e5e9ccf56267cb7b773ff1b1f513a5dc"
          },
          {
            "type": "html",
            "text": "<i>Yes. One should only use upvar when he wants to return two or more variables from a procedure and doesn't want to do that in a list.</i>",
            "id": "757abcfe0e0c37d4ad7e174dca3936a0"
          },
          {
            "type": "html",
            "text": "\nTo explain it even simpler: the [upvar] command is Tcl's way of [[Call By Name]], pretty equivalent to passing a pointer to a variable in C (only that you can specify the scope in which the name applies). It is mostly used to pass Tcl arrays (hash tables in fact), which can't be done by value. But it, together with [uplevel], also allows building all kind of debugging tools very simply. Here's an example - append an item to a list if it isn't there yet:",
            "id": "b7e6d5b5bf95b88b6192b15dfcdfb265"
          },
          {
            "type": "html",
            "text": "<i>If that explanation were in the manual entry for upvar or in the tcl tutorial at [http://www.tcl.tk www.tcl.tk], far less people would be confused by upvar.</i>",
            "id": "39a8424f3870572f76436530ca69241b"
          },
          {
            "type": "code",
            "text": " proc ladd {listVar item} {\n  upvar 1 $listVar list\n  if {[lsearch $list $item] == -1} {lappend list $item}\n }\n set aList {2 4 8 16} \n ladd $aList 16 ;# doing it wrong; you should pass the name of\n                 # the variable, not its value.\n ladd aList 32  ;# aList is now {2 4 8 16 32}.\n ladd aList 4   ;# aList is unchanged.",
            "id": "e4f295f73a6fa2c392342e6046b4c40d"
          },
          {
            "type": "html",
            "text": "Another example, first in C:",
            "id": "b5cc1f49d63b048201acea634ef90186"
          },
          {
            "type": "code",
            "text": " void f(int x, int *y) {\n    *y = x;\n }",
            "id": "4610580c04ea251eb41555c03d0cab15"
          },
          {
            "type": "html",
            "text": "then the equivalent in Tcl:",
            "id": "400fefefc53db6efa37579166c45256c"
          },
          {
            "type": "code",
            "text": " proc f {x _y} {\n   upvar $_y y\n   set y $x\n }",
            "id": "11207c39cba9c60d457ea62217bb578d"
          },
          {
            "type": "html",
            "text": "The difference to LISP (with its special forms and macros) is that you can always know whether you pass a value (as constant, or with \"$\" notation), or a variable name (via upvar) that may have side-effects, like changing the list, in the example.",
            "id": "315a15cb07bd526bba4d25eab7085474"
          },
          {
            "type": "html",
            "text": "\nIn general, I suppose people experienced in languages of the Fortran/Algol/C/Java heritage may sometimes be bewildered by Tcl's concepts, but coming from LISP, one might very soon feel at home... ",
            "id": "db49c6e1806384cb86510eaeb36aeb06"
          },
          {
            "type": "html",
            "text": "-- [[Richard Suchenwirth]]",
            "id": "6b2d6fef09e7e1686f61d153d7701d3e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "<b>[[Tcl War]] with [[Richard Stallman]]</b>",
            "id": "a71bc9ac1c275024a8ea2ec226b53fb4"
          },
          {
            "type": "html",
            "text": "\nSeveral years ago, there was a big bruhaha between Richard Stallman and TCL fans. Richard claimed that TCL does not scale to large applications, and thus should be avoided in case small applications grow large. (Naturally, RMS perferred [[Lisp Language]].) Personally, I suspect this depends on one's development style. If one uses a task-oriented and event-driven model, then \"large application\" is generally meaningless because you simply have a bunch of small programs that respond based on the state as recorded in files or databases with a few parameters passed between each script.",
            "id": "bc676dfe402a98437d91228a5c2256b2"
          },
          {
            "type": "html",
            "text": "<i>Unfortunately, [[Richard Stallman]] was right but did not put his point across in a politically astute way. His argument was that Tcl is a rather poor foundation for a universal language with which to make applications scriptable, and that it would be better to embed a Scheme interpreter into applications and compile different scripting languages to Scheme at read-time. Now we have Parrot and .NET both trying to be virtual machines for different languages, both of which can be used as embedded interpreters. However, Scheme would be a more elegant representation than bytecodes.</i>",
            "id": "4e0f233de7d49b86f58315a3bc33f74e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "<b>More comments</b>",
            "id": "062b4a00c78db94a28438d6510214544"
          },
          {
            "type": "html",
            "text": "\nI chose Tcl as my first (and, so far, only) programming language because it's simple and comprehensible; it's oriented more toward text and graphics (with the Tk toolkit) than toward maths and logic; it doesn't require the programmer to spend any time on loathsome tasks such as compiling; and yet you can do a whole lot of things with it. ",
            "id": "8e9f51e1f4e614bd4663e563f45ef20a"
          },
          {
            "type": "html",
            "text": "-- David [[Mc Clamrock]]? ",
            "id": "11e495bbec3095c39e34e3df663b5707"
          },
          {
            "type": "html",
            "text": "<i>Tcl is by far the simplest of the major scripting languages to extend with C modules. Especially using critcl. However, they all have their place. Even vbscript :) -- Pat Thoyts</i> ",
            "id": "440de1fb58ff45a16b76d0e588de3430"
          },
          {
            "type": "html",
            "text": "\nEvery time I have to do another project in Tcl/tk, I'm amazed at how easy it is to get my ideas into code quickly, and more importantly, correctly! ",
            "id": "cfa99f070171d793d7afc2a1f27ed2ec"
          },
          {
            "type": "html",
            "text": "<i>I don't like C++, as everything is sooo complicated. I do like Tcl/Tk, because it's not. -- Philipp</i> ",
            "id": "e6c8295d10debd5cbf9077d907027d6e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "\nI am not sure what is happening in constructs like this:",
            "id": "632ce7845f4e23b7333bbe990dc42046"
          },
          {
            "type": "code",
            "text": "  $t insert end \"Hello World!\"",
            "id": "d74cbec5603448a9b730fedfb9a8de92"
          },
          {
            "type": "html",
            "text": "The \"t\" variable is referencing some kind of widget (in this case a text GUI widget). What is happening in this case from a linguistical standpoint? How does it know which widget to operate on, especially if there are multiple text widgets?",
            "id": "a56c353bcf19f056929166054c93428f"
          },
          {
            "type": "html",
            "text": "<i>the $t will be expanded to the value stored in t, which as you say is an instance of a widget. you have to remember that the first word on a line in TCL is a command (the rest of the words are arguments to the command) . the text command created a new command which enables you to interact with that text widget. so you call the 'interact with text widget foo' command, which happens to be the path of the text widget, it then uses </i>insert end \"Hello world!\"<i> to do that operation on itself. hope that made sense - there is more info in the help that comes with TCL -- [[James Keogh]]</i>",
            "id": "14ad41554ec0f907d32de645c12fa265"
          },
          {
            "type": "html",
            "text": "\nI am still fuzzy on the steps the interpreter is taking. Tcl is not inherently object-oriented, so thinking of it in terms of an OOP language is probably misleading. The variable substitution may create a command that looks something like:",
            "id": "651d04858357c1dda752cf4ee3135453"
          },
          {
            "type": "code",
            "text": "  .myTextWidget insert end \"Hello World!\"",
            "id": "7cce4bbe127f2651dac2dd0aaec9b084"
          },
          {
            "type": "html",
            "text": "But what exactly is \".myTextWidget\"? It appears that \".myTextWidget\" is a dynamically created function, not an object, but my documentation talks about it like it is an object in some places. Is this to sound \"in fashion\" to attract more Tcl users, or is it really an object?",
            "id": "2593ff9a90691934253bb65fbda16e6c"
          },
          {
            "type": "html",
            "text": "<i>.myTextWidget is a string, namely the name (actually the \"path\" in tcl jargon). It's all strings. Actually there may be some gyrations you can go through to get the underlying widget, but in general, with Tcl, you're dealing with names, not references. As an optimization, the compiler generates code that knows about types, widgets, what have you, but the closest analog to tcl is shell script. In the context above, i.e. beginning a line with the widget name, it's interpreted as if it's a function or object (with no references, there's really no difference). You can't go getting a reference to .myTextWidget though, except for its name - Tcl has [[Call By Name]] semantics, and oh yes, you can abuse the hell out of those semantics if you try. Ultimately, however, these semantics tend to hinder the language from being able to implement advanced things instead of helping it, as was discovered in [[Algol Sixty]] (another language to have [[Call By Name]] semantics)</i>",
            "id": "a877828adffb7c1ba3334a56ef66b750"
          },
          {
            "type": "html",
            "text": "\nBut Tcl is supposed to follow the convention:",
            "id": "fa3bca639b7a52119ad56c1db9f76765"
          },
          {
            "type": "code",
            "text": "  command paramString1 paramString2 paramString3 ...",
            "id": "41a773d43a075bbef976d35d8bdf391c"
          },
          {
            "type": "html",
            "text": "So it tries to execute \".myTextWidget\" as a command. Is it actually \"registered\" as a command? For example, somehow put into the \"command/function list\"?",
            "id": "81f0462b3681027e5c5447f3c9698ef6"
          },
          {
            "type": "html",
            "text": "\nyes it is actually a command try this in wish:",
            "id": "1f39e76e10fa32724f14df12225f92f6"
          },
          {
            "type": "code",
            "text": " button .but -text \"test\"\n info commands .*",
            "id": "92837eb513aecb3cdd9f7ab554f268b0"
          },
          {
            "type": "html",
            "text": "button creates a new command called .but, .but command acts on a <i>particular</i> button widget. \"info\" commands list all the commands with the given pattern. -- [[James Keogh]] <i>{Did minor syntax editing}</i>",
            "id": "b5dc0c688a69d6567b56791ce186c573"
          },
          {
            "type": "html",
            "text": " text .myTextWidget",
            "id": "1c57d5b234ffd0c4c5e029eceaa516a9"
          },
          {
            "type": "html",
            "text": " set t .myTextWidget",
            "id": "9cdc5bbe76c6a103f2326664682479c8"
          },
          {
            "type": "html",
            "text": " pack $t",
            "id": "ebc1d28d121f0c21ea27606c9b5bb427"
          },
          {
            "type": "html",
            "text": " $t insert end \"Hello World!\"",
            "id": "76d5c7fb887a555fb1c05725df644c3b"
          },
          {
            "type": "html",
            "text": "Let's see if I've got this straight. The first line creates a command called \".myTextWidget\". The second line creates a variable \"t\" that contains the string \".myTextWidget\" (for reference convenience). The third line (\"pack\") sends the string \".myTextWidget\" to the \"pack\" command. The fourth line evaluates internally into:",
            "id": "ed595cdd4adeba72e76b258f9a42e6b5"
          },
          {
            "type": "code",
            "text": "  .myTextWidget insert end \"Hello World!\"",
            "id": "7cce4bbe127f2651dac2dd0aaec9b084"
          },
          {
            "type": "html",
            "text": "which executes the command created in line one. In line one, the Tk system creates both a command named \".myTextWidget\" <i>and</i> puts the name \".myTextWidget\" into an internal list. Line three uses the internal list, not the command (that was also created). Line four executes the command \".myTextWidget\" that was created in line one. It is confusing because the Tk system creates two things which can be referenced: a command and an entry in an internal list. These are two different things even though they have the same name. My Tcl book never seemed to clarify this double action, leaving me to scratch my head.",
            "id": "8467049bc4e2c1a649f5f01652192916"
          },
          {
            "type": "html",
            "text": "\nWell, I suppose the Tk system can use the command list as the \"internal list\" I talked about to achieve the same thing. But, the point is that in some of the commands we are passing a string (widget ID) and in others we are using it as a command.",
            "id": "5b15062ab1bac4f9cfc1bfdb3829ca84"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "\nRegarding this roll-your-own UNTIL loop example from [[Dynamic Strings Vs Functional]]:",
            "id": "b9d4cc0ccfcd6448b3b2032e58f8d6c0"
          },
          {
            "type": "code",
            "text": " proc until {condition body} {\n  uplevel 1 $body\n  while {![uplevel 1 [list expr $condition]]} {\n    uplevel 1 $body\n  }\n }",
            "id": "85b288e692ec9cf2d8da1ac9fe4616a4"
          },
          {
            "type": "html",
            "text": "Why do we need a \"list\" construct? Why not just:",
            "id": "ef8fcae42a7b000fa66b8a921ebd9d76"
          },
          {
            "type": "code",
            "text": "  while {![uplevel 1 $condition]} {...}",
            "id": "39c5e7aaa21104413e0f9cf1a16f6381"
          },
          {
            "type": "html",
            "text": "<i>These are the tricky parts. \"list\" can be used to protect from double-evaluation, if $condition for instance contains parts which start with $ we don't want them evaluated by the interpreter but to let the \"expr\" command deal with them. \"list\" is generally used for this with \"eval\" and \"uplevel\" and similar things -- [[Kristoffer Lawson]]</i>",
            "id": "1f3ba963b090af4070b681bf58cccf12"
          },
          {
            "type": "html",
            "text": "\nWhy don't the \"body\" uplevel's also need to use \"list\"?",
            "id": "5df8a3c5cc1b934061d26da5fa5ef5a8"
          },
          {
            "type": "html",
            "text": "<i>Because the \"body\" uplevels only get substituted once. Each time Tcl sees a command, it breaks it up into words (based on spaces and quoting). Then it does one level of expansion in those words (no expansion happens in {} quotes).</i>",
            "id": "389daa930a0de27dbd94660ce6642d26"
          },
          {
            "type": "html",
            "text": "\nSo, assume $body == {puts \"Hello, world!\"}, and $condition == {$a == 1}.",
            "id": "5ca9ed14beeabfb0b8587301d7c2afb8"
          },
          {
            "type": "html",
            "text": "\nTcl turns the \"uplevel 1 $body\" into:",
            "id": "f6369e779c67bdf508a7ab7afb56837a"
          },
          {
            "type": "code",
            "text": "  uplevel 1 \"puts \\\"Hello, world!\\\"\"",
            "id": "7da8feb3ec195551205361a406232d30"
          },
          {
            "type": "html",
            "text": "The uplevel then does an eval on the 3rd argument, so the command runs as:",
            "id": "f8abe33706f96c36fe1b68963aed3288"
          },
          {
            "type": "code",
            "text": "  puts \"Hello, world!\"",
            "id": "3b55261606927ea498404a9b6de875fc"
          },
          {
            "type": "html",
            "text": "Just as we intended it. ",
            "id": "6932bfbe3b69f4f29790e223a733266a"
          },
          {
            "type": "html",
            "text": "\nThe \"while\" command, on the other hand, gets passed with two words, the condition:",
            "id": "f4cfb7a2c491b784d3a334e9830c504a"
          },
          {
            "type": "code",
            "text": "  {![uplevel 1 [list expr $condition]]}",
            "id": "e9e39ef84dc4192f9475feea6813766d"
          },
          {
            "type": "html",
            "text": "And the body:",
            "id": "ded25fb0e785c8228a15a7a78e575c60"
          },
          {
            "type": "code",
            "text": "  { uplevel 1 $body }",
            "id": "982d1fb5547cbf965b0a6791143b62e9"
          },
          {
            "type": "html",
            "text": "The condition gets passed implicitly to the \"expr\" command (sort of; it won't call your expr if you redefine it). The \"expr\" command does variable, backslash and [command] substitution on the string. So:",
            "id": "6739202ccefed81579695ca03586c26c"
          },
          {
            "type": "code",
            "text": "  [uplevel 1 [list expr $condition]]",
            "id": "fbe0732cc954f3a983230bf7dce9d8fb"
          },
          {
            "type": "html",
            "text": "gets expanded recursively:",
            "id": "d1ed9cd1012ac168bdc12a08cfcb458c"
          },
          {
            "type": "code",
            "text": "  uplevel 1 [list expr $condition]",
            "id": "4f93c589c31ecabec48d3de34842fea5"
          },
          {
            "type": "html",
            "text": "then (because [list] quotes its operands):",
            "id": "61e21ec22598de08ffda37b47127eaf6"
          },
          {
            "type": "code",
            "text": "  expr {$a == 1}",
            "id": "0d60a35697e482d404cbf668efdac852"
          },
          {
            "type": "html",
            "text": "gets executed one level up in the stack context.",
            "id": "55fb607c04c5b6c143cf6bd41930571b"
          },
          {
            "type": "html",
            "text": "\nThe {} quoting around the expr argument is required because expr does its own substitution. If you let uplevel parse it as:",
            "id": "86bb010426754c1b3abb5a3d18f62c7c"
          },
          {
            "type": "code",
            "text": "  uplevel 1 expr $condition",
            "id": "65e7629c30f9dd72c7803c61ba387e16"
          },
          {
            "type": "html",
            "text": "the first level expansion will turn it into:",
            "id": "03dc1212e54473a829b634fc10f56fa4"
          },
          {
            "type": "code",
            "text": "  uplevel 1 expr \"$a == 1\"",
            "id": "211580a03bbee51154f1fb122d7793d7"
          },
          {
            "type": "html",
            "text": "then uplevel itself would substitute:",
            "id": "18b09241277f3f409e4112101e492932"
          },
          {
            "type": "code",
            "text": "  expr $a == 1",
            "id": "4c6bd2ac8fed592a9e7c8dc33b9ba9de"
          },
          {
            "type": "html",
            "text": "And if, for example, $a == \"x y\", the expr would fail with a syntax error when it does its own expansion, because it would try to parse:",
            "id": "3a5e3b2cfa190050c78e47fdb66c77a0"
          },
          {
            "type": "code",
            "text": "  {x y == 1}",
            "id": "666cbb445f879fe56be2770c6217d950"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "We use TCL where I work to make long-running network servers scriptable. The biggest advantage about TCL is that anyone that has ever written a beggining \"intro to C\" argc/argv style program knows exactly how to write a TCL command. Then the internal state and various options over behavior are exposed (via a socket attached to the global Tcl Interp) for our operational pleasure.",
            "id": "680dca018d6f3b357428f7c7baf9597e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "[[Richard Suchenwirth]] : Above it was said that \"Tcl is not OO\". There is more OO support in the making currently, but for a long while it has been possible to roll one's own OO in pretty simple ways. Example, a Stack \"class\" without any extra framework needed (both the class and its instances are implemented as namespaces):",
            "id": "fe7de1b26e7dc5a84d664f81fd047176"
          },
          {
            "type": "code",
            "text": " namespace eval Stack {variable n 0} ;#-- \"class variable\"",
            "id": "86b7624b482db26edb72939272c07fb0"
          },
          {
            "type": "code",
            "text": " proc Stack::Stack {} { #-- Constructor\n   variable n\n   set instance [namespace current]::[incr n]\n   namespace eval $instance {variable s {}} ;#-- \"member variable\" \n   interp alias {} $instance {} ::Stack::do $instance\n }\n proc Stack::do {self method args} { #-- Dispatcher with methods\n   upvar #0 ${self}::s s\n   switch -- $method {\n       push {eval lappend s $args}\n       pop  {\n           if ![llength $s] {error \"stack underflow\"}\n           K [lindex $s end] [set s [lrange $s 0 end-1]]\n       }\n       default {error \"unknown method $method\"}\n   }\n }\n proc K {a b} {set a}",
            "id": "33a241726e1d631b24bd0346604ca519"
          },
          {
            "type": "html",
            "text": "\nTesting in an interactive tclsh:",
            "id": "3632fabc211ef570bf856909af831c3d"
          },
          {
            "type": "code",
            "text": " % set s [Stack::Stack] ;#-- constructor\n ::Stack::1             ;#-- generated name of a stack instance\n % $s push hello\n hello\n % $s push world\n hello world\n % $s pop\n world\n % $s pop\n hello\n % $s pop\n stack underflow       ;#-- error message on empty stack\n % namespace delete $s ;#-- destructor",
            "id": "984ed9da59760ebbdf7d644e4b3b8682"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "<b>Some Tcl/Tk Links and Tutorials</b>",
            "id": "025602d7c45bf3a1ee46625cf786811d"
          },
          {
            "type": "html",
            "text": "\nOfficial tutorial: [http://www.tcl.tk/man/tcl8.5/tutorial/tcltutorial.html www.tcl.tk]",
            "id": "79ba2a6d23934e1bef1c1e40085a15b2"
          },
          {
            "type": "html",
            "text": "\n[http://www.geocities.com/binnyva/code/tcl/tutorial/index.html www.geocities.com]",
            "id": "b2ce9b5442751789d562dd163152703f"
          },
          {
            "type": "html",
            "text": "\n[http://wiki.tcl.tk wiki.tcl.tk]",
            "id": "59b404285859be659594882ad4e8f2d6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "[[Simplified Wrapper And Interface Generator]] (SWIG) can be used to make calls to [[Cee Language]] or [[Cee Plus Plus]] code.",
            "id": "8d11a02778a1c8d57a728914d5c455dc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "See also [[Tcl Tk]], [[Dynamic Strings Vs Functional]], [[Active Tcl]], [[Quote Free Language]]",
            "id": "14a049bed9991d13ea21e0cb08e38926"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2373c00992f26fba5c2a5e0801ab70e3"
          },
          {
            "type": "html",
            "text": "[[Category Programming Language]] [[Category Tcl]]",
            "id": "d1fbca8d3992fb9de264eba8b56608a1"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ToolCommandLanguage c2.com]",
            "id": "5575e3841cf6294d1c82bd5c8e814010"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1707801180819
    }
  ]
}