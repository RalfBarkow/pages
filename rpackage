{
  "title": "RPackage",
  "story": [
    {
      "type": "markdown",
      "id": "907e745c24b6dba1",
      "text": "A RPackage is a new implementation of package. Note that it does not touch classes but it is just a layer on top of classes therefore removing a method from a package does not change the underlying class. \n\n\nInstance Variables\n\tclassDefinedSelectors:\t\tDictionary\n\tclassExtensionSelectors:\t\tDictionary\n\tmetaclassDefinedSelectors:\t\tDictionary\n\tmetaclassExtensionSelectors:\t\tDictionary\n\tpackageName:\t\tString\n\tclasses: OrderedCollection of Symbols\n\tclassTags: is a mapping from tags to classNames\n\nThe reason we use four dictionaries is that this way we only store #Point in both as the class and the metaclass are involved. We do not have to with Point_class problem when comparing defined and extended classes. The idea is taken from the RBSelectorEnvironment. \t\t\t\t\t\n\t\t\nClass Invariant one:\n\tClasses should not contain metaclass name, but only class names\n\t\n\t\n\nImplementation notes \n====================\nThis class went over 3 internal representations implementation. \n\t- first: \ta list of class + two dictionaries: class * methods\n\tThis was not good since we add to go all the time over the list of classes.\n\t- second: 4 dictionaries class * selectors \n\tThis was not good since we want to have defined classes without methods. \n\t- third: 4 dictionaries + definedClasses\n\nOriginally I wanted to avoid to have a defined class list and I wanted to avoid to have to declare the class as defined. But this is not really good since\n\t- we will want to know if a class definition (without method for example is defined in a given package)\n\t- second this is easier to hook the packageOf: behavior (we register the package class when the class is \tadded to the package).\n\ndefined classes information is redundant with the dictionary keys of defined methods but we would have to check and register the class to the packageOrganizer the first time a method is defined then also check on remove to unregister the class from the packageOrganizer.\n\nAdding a method does not define the class as a defined package class. This has to be done explictly. The reason for this choice is that a class should register to the packageOrganizer and that I do not want to do it each time a method is added and I do not want to test it each time a method is added. Now this is done only when the class is declared as defined. \nWe could also give the complete freedom to the client to register the class but I thought it was a good compromise. \n\t\n\t\nClassTag are tags that can be associated to classes. They help user organizing their class internal. \nSo that we can have a package infrastructure as follows:\n\tPackage1\n\t\tClassA\n\t\tClassB\n\tin case there is no tags associated to the package\n\tor\n\tPackage2\t\n\t\tTag1\n\t\t\tClassA\n\t\t\tClassB\n\t\tTag2\n\t\t\tClassC\n\t\t\tClassD\n\t\t\tClassE\n\t\t\tClassA\t\t\n\t\nTodo\n====\n\tNext: \n\t- finish \n\t- build up a synchronizer that import PackageInfo.\n\t\n\n\t\n\n\t\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "RPackage",
        "story": []
      },
      "date": 1654063854081
    },
    {
      "item": {
        "type": "factory",
        "id": "907e745c24b6dba1"
      },
      "id": "907e745c24b6dba1",
      "type": "add",
      "date": 1654063859178
    },
    {
      "type": "edit",
      "id": "907e745c24b6dba1",
      "item": {
        "type": "markdown",
        "id": "907e745c24b6dba1",
        "text": "A RPackage is a new implementation of package. Note that it does not touch classes but it is just a layer on top of classes therefore removing a method from a package does not change the underlying class. \n\n\nInstance Variables\n\tclassDefinedSelectors:\t\tDictionary\n\tclassExtensionSelectors:\t\tDictionary\n\tmetaclassDefinedSelectors:\t\tDictionary\n\tmetaclassExtensionSelectors:\t\tDictionary\n\tpackageName:\t\tString\n\tclasses: OrderedCollection of Symbols\n\tclassTags: is a mapping from tags to classNames\n\nThe reason we use four dictionaries is that this way we only store #Point in both as the class and the metaclass are involved. We do not have to with Point_class problem when comparing defined and extended classes. The idea is taken from the RBSelectorEnvironment. \t\t\t\t\t\n\t\t\nClass Invariant one:\n\tClasses should not contain metaclass name, but only class names\n\t\n\t\n\nImplementation notes \n====================\nThis class went over 3 internal representations implementation. \n\t- first: \ta list of class + two dictionaries: class * methods\n\tThis was not good since we add to go all the time over the list of classes.\n\t- second: 4 dictionaries class * selectors \n\tThis was not good since we want to have defined classes without methods. \n\t- third: 4 dictionaries + definedClasses\n\nOriginally I wanted to avoid to have a defined class list and I wanted to avoid to have to declare the class as defined. But this is not really good since\n\t- we will want to know if a class definition (without method for example is defined in a given package)\n\t- second this is easier to hook the packageOf: behavior (we register the package class when the class is \tadded to the package).\n\ndefined classes information is redundant with the dictionary keys of defined methods but we would have to check and register the class to the packageOrganizer the first time a method is defined then also check on remove to unregister the class from the packageOrganizer.\n\nAdding a method does not define the class as a defined package class. This has to be done explictly. The reason for this choice is that a class should register to the packageOrganizer and that I do not want to do it each time a method is added and I do not want to test it each time a method is added. Now this is done only when the class is declared as defined. \nWe could also give the complete freedom to the client to register the class but I thought it was a good compromise. \n\t\n\t\nClassTag are tags that can be associated to classes. They help user organizing their class internal. \nSo that we can have a package infrastructure as follows:\n\tPackage1\n\t\tClassA\n\t\tClassB\n\tin case there is no tags associated to the package\n\tor\n\tPackage2\t\n\t\tTag1\n\t\t\tClassA\n\t\t\tClassB\n\t\tTag2\n\t\t\tClassC\n\t\t\tClassD\n\t\t\tClassE\n\t\t\tClassA\t\t\n\t\nTodo\n====\n\tNext: \n\t- finish \n\t- build up a synchronizer that import PackageInfo.\n\t\n\n\t\n\n\t\n"
      },
      "date": 1654063861106
    }
  ]
}