{
  "title": "Test Types Instead Of Dispatch",
  "story": [
    {
      "type": "html",
      "text": "One [[Cee Plus Plus]] optimization that might save both time and code space is to check for types and cast instead of using polymorphism. For instance, ",
      "id": "f8a1244e4b49d4ed4f82a0c88c53defd"
    },
    {
      "type": "code",
      "text": " struct B''''''aseClass\n {\n  enum TYPE {\n    SubclassA,\n    SubclassB,\n  };\n  unsigned char type;\n  ...\n };",
      "id": "9f74ed73fcc506a314daf5ce9f14944a"
    },
    {
      "type": "html",
      "text": "struct SubclassA :<br>public B<b></b>aseClass",
      "id": "8222189163ad31d332016a092ad3b670"
    },
    {
      "type": "code",
      "text": " {\n  int width;\n  ...\n };",
      "id": "8d32409c43d1712ef1816f30cebcc89f"
    },
    {
      "type": "html",
      "text": "struct SubclassB :<br>public B<b></b>aseClass",
      "id": "b28ce0fe2dd7150e0a3031c2904ccead"
    },
    {
      "type": "code",
      "text": " {\n  int stride;\n  ...\n };",
      "id": "44f602f613156d03002041c715635ec7"
    },
    {
      "type": "code",
      "text": " B''''''aseClass *pInstance;\n ...\n int bufferWidth;\n if( B''''''aseClass::SubclassA == pInstance->type )\n {\n  bufferWidth = ((SubclassA*)pInstance)->width;\n }\n else if( B''''''aseClass::SubclassB == pInstance->type )\n {\n  bufferWidth = ((SubclassB*)pInstance)->stride;\n }",
      "id": "267f971e994b1813ec0938049569fdd2"
    },
    {
      "type": "html",
      "text": "\nIf we were coding a pure object-oriented design, this would surely be a [[Code Smell]]. Actually, in this trivial example, it is a [[Code Smell]]. But there exist real cases where it's smaller and faster to check for type information than to use polymorphic dispatch. Note also that the type information is available through a member variable. Alternatively, one could write:",
      "id": "3a0084ba6d780b412b2523de34d33db7"
    },
    {
      "type": "code",
      "text": " struct B''''''aseClass\n {\n  enum TYPE {\n    SubclassA,\n    SubclassB,\n  };\n  virtual B''''''aseClass::TYPE getType() const = 0; \n };",
      "id": "3ea09cba139e6d2b0a6cced13db52d02"
    },
    {
      "type": "html",
      "text": "\nand then return the type through a polymorphic call. However, to create the polymorphic function, this may require upwards around 100 bytes a class, at a cost of 1 byte (or at most 1 alignment) an instance. This trade-off can be significant in memory-constrained environments like embedded devices. Moreover, the polymorphic dispatch can take many times as many bytes as a simple member access.",
      "id": "5ef64d752783dfdf2b791825762c64ed"
    },
    {
      "type": "html",
      "text": "<i>Besides which, if you're going to introduce a polymorphic get<b></b>Type(), why not just introduce a polymorphic get<b></b>Buffer<b></b>Width() through which each subclass can use whatever subclass-specific member variables it needs to use?</i> -- [[Mike Smith]]",
      "id": "af583f89e117d5d635207db943814ffa"
    },
    {
      "type": "html",
      "text": "\nThis is one of those fine trade-off cases. There are many reasons not to do this. For one, it's a ridiculous optimization, and we all [[Optimize Later]] anyway. But in general, this really only works well if:",
      "id": "2bd124e863f5156c15b5d9312e6c08d7"
    },
    {
      "type": "html",
      "text": " <b>You really, really, really need code space efficiency!</b>",
      "id": "b153b4d04fe3746befe47198f1dc148e"
    },
    {
      "type": "html",
      "text": " You are only really cheating for get methods.",
      "id": "4a215c1a10e63b9d47c176e1cca46f6e"
    },
    {
      "type": "html",
      "text": " There are very few (say, one or two) subclasses who have a member that you want to retrieve, but most (say > 10) don't.",
      "id": "fd914763dc13afd8b5ff1d42a709093a"
    },
    {
      "type": "html",
      "text": " You don't want to get the member variable dynamically very often.",
      "id": "7d1fde8d1e0ec982d30dbc9155d2133e"
    },
    {
      "type": "html",
      "text": " You spend the five minutes to compile both models to see which is better.",
      "id": "61aad0af953a4104d7107aed9fbe4b9c"
    },
    {
      "type": "html",
      "text": "\nNote that if you have to check a lot of types, it's more expensive to do the lookup than it is just to call the method. This is because you need an if-else cascade or a switch statement, which means a lot of compares and jumps. After a certain point, using the dispatch table is much more efficient because it uses the principle, \"The instance knows about itself.\" -- [[Sunir Shah]]",
      "id": "0c74641b8a5a5b26177fecd5915a89b9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b335413227518cc42c2b6d9f6307eb"
    },
    {
      "type": "html",
      "text": "\nBy the way, this is a reasonable thing to do on a desktop for highly constrained domains like widget toolkits. Widgets should be thin and light or else you will eat memory badly and be very slow. Consider a poor widget toolkit like java.swt or javax.swing. Of course, both of those are quite bloated anyway, so there's no real point in trying. -- [[Sunir Shah]]",
      "id": "aa0184997822bd0978da158ba1d56b96"
    },
    {
      "type": "html",
      "text": "<i>A useful GUI toolkit has so many necessary features - internationalization, configuration, resource management etc. - that I fail to see how avoiding good OO design to save a few bytes will gain you anything. You will probably lose any advantage you gain in the base classes with extra special-case logic in derived classes to work round these hacks. I've certainly found such logic necessary when working with AWT Component and Container base classes.</i>",
      "id": "56caf423c4fb7fd7cbb02197f4b549e5"
    },
    {
      "type": "html",
      "text": "\nI don't mean to be excessively rude, but your half-assed guessing is totally bogus. ;) This is what others and I do <i>in practice</i> and it works very well. The \"scary\" concepts of internationalization, configuration, resource management have very little impact on the simplest thing that could possibly work. Often, it's simpler to not implement them because no one cares. Perhaps you're doing too much [[Big Design Up Front]] in your head. -- [[Sunir Shah]]",
      "id": "659b91af2995cfcece22acfa2b204bc6"
    },
    {
      "type": "html",
      "text": "\nWhat kind of wins could be expected for a typical application using this technique? A hundred bytes per class and a few bytes per object doesn't sound like the end of the world, but I don't know much about GUI frameworks. -- [[Anders Bengtsson]]",
      "id": "07f2316298da05226e30618e77607315"
    },
    {
      "type": "html",
      "text": "\nWell, ~100 bytes per class * 21 classes ~= 2kb, which is currently 10% of the library I'm working on. Most classes are currently 550 bytes. When I first noticed this and the annoying automagically-inlined constructor/destructors, I cut the library size in half. As I was told once, \"Code like Fortran!\" I haven't written the widget library yet, but I expect it to be similar, albeit not as dramatic as the paint methods will be larger and I have tweaked my Perl script to generate even more efficient code (in C++) since then. Bear in mind that I work on small devices, not desktops, as I point out above. Crossing 32kb is bad, 64kb very bad. -- [[Sunir Shah]]",
      "id": "b0408a44825e421524f6540231c461ea"
    },
    {
      "type": "html",
      "text": "\nPart of the problem sounds like the language implementation. C++ is not very intelligent about implementing polymorphism and its linking model reduces the compiler's ability to aggressively optimize polymorphic dispatch.",
      "id": "c5f4baaa6d6457057c6e299be83aa7c1"
    },
    {
      "type": "html",
      "text": "<i>So what? We still have to use C++.</i>",
      "id": "802fba0a23b6c103c81821641d1542a9"
    },
    {
      "type": "html",
      "text": "\nI'm just emphasizing that this is a C++-specific idiom, rather than a generally useful pattern. Although there is a link to this page from [[Code Smells Illustrated With Java Awt]], the context of the pattern does not readily apply to Java and the AWT.",
      "id": "3d76a5e221fda997518123ecc9d8919a"
    },
    {
      "type": "html",
      "text": "This is Wiki. Referring pages aren't necessarily important, nor should you really depend on them because they may be edited to remove the link. Each page should stand on its own. -- ss",
      "id": "ddcf0630a2c63f159cebd8fc40ca8afd"
    },
    {
      "type": "html",
      "text": "\nPurely as a matter of interest, why do you have to use C++? With those tight memory requirements I'd prefer to use C because it gives one much better control over what the compiler generates (what you see is pretty much what you get) and you can implement polymorphism just as easily if you are not using vtables. Additionally, if you want vtables, you can implement vtables and inheritance by hand and tune the implementation wrt speed or space.",
      "id": "2161ead73b5fe92ef289b5f97843f877"
    },
    {
      "type": "html",
      "text": "Actually, C++ gives you better control over what the compiler generates because most compilers now use the C++ code generator for even C. Using object-based systems vs. object-oriented systems vs. simple aggregate types is another argument. But, of course, using C++ for polymorphism is usually more efficient (and more maintainable--I still [[Code For The Maintainer]]) than using polymorphism in C because the compiler has a better chance and better algorithms to do the static analysis. We actually use both C and C++ and C-like C++ and assembler and a Perl script that compiles an higher-level file to C++ and a bunch of other things. -- ss",
      "id": "65b31b1f4a6ad1c4f5d1610448a62813"
    },
    {
      "type": "html",
      "text": "<i>Given the lack of virtual functions and dynamic_cast<>, I see the sample code at the top as largely a \"C\" subset of C++ - with class based syntactic conveniences. I recommend keeping C++ because the limited language features he chooses to use do help with maintenance.</i>",
      "id": "8a2a1f86861fd25d0358b0c12d45875b"
    },
    {
      "type": "html",
      "text": "<i>A trivial note: Instead of \"(SubclassA*)\" - C syntax to cast a pointer, I would use \"reinterpret_cast<SubclassA*>\". (Books will tell you to use \"dynamic_cast<>\", which is \"right,\" but you're trying to avoid the cost of the dynamic dispatch.) -- [[Jeff Grigg]]</i>",
      "id": "e6f03b3e9550ce14d8d34448c7d04268"
    },
    {
      "type": "html",
      "text": "\nNo, use a static_cast<> if you have [[Run Time Type Information]] turned on, dynamic_cast<> if you don't (no penalty--it degrades to static_cast<>). reinterpret_cast<> is used when you are completely changing the meaning of things, like unsigned char *videoMemory = reinterpret_cast<unsigned char *>(0xA0000000L); A static_cast<> is generally equivalent to a C-style cast. The gain of using static_cast<> over a C-style cast is that the static_cast is more readable. The disadvantage is that GCC doesn't really do the new style casts correctly (at least const_cast<>), so I gave up on them completely. C++ is fun because when you have to work with many different compilers, your end up having to use some lowest common denominator (for some definition that you believe will limit the portability problems). For instance, recently we had problems compiling for the Agenda because the [[Gnu Cpp]] they use (~2.9.0) didn't do namespaces. Fortunately, GCC is Light, so I begged and pleaded very nicely with the developer to build the latest GCC. She agreed and I didn't have to manually name mangle all my code. -- [[Sunir Shah]]",
      "id": "de75c6f71e763eb243c40fc90dc1c0bd"
    },
    {
      "type": "html",
      "text": "<i>And you're both wrong. Use a static_cast for the above code, whether or not you turn off standard features like [[Run Time Type Information]]. [[Cstyle Casts]] are evil in C++. Avoid at all costs. Also, try to avoid reinterpret_cast where possible, but prefer it over C-style casts, and prefer static_cast or dynamic_cast more. reinterpret_cast has surprisingly little defined behavior, much less so than most people believe, and it generally hides errors whereas static_cast would fail to compile showing the error. Also, in today's age gcc 3.4.3 is considered old, and it supports the C++ casts correctly, so use them as intended.</i>",
      "id": "018d5025392cc38e1307b988be964915"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b335413227518cc42c2b6d9f6307eb"
    },
    {
      "type": "html",
      "text": "\nFunny, what think ye of the results of [[Test Types Instead Of Dispatch Profile Code]]'s?:",
      "id": "7661e181f88b0a2089124557349439f9"
    },
    {
      "type": "html",
      "text": "\nOn this machine (WinME, [[Cyg Win]]'s [[Gnu Cpp]]), I got results consistently like this:",
      "id": "6139607e78ff7be567e5a72f14e3ba59"
    },
    {
      "type": "code",
      "text": " ./plain\n Normal: 220\n Manual: 279",
      "id": "99b539b6236d444947ab475baa84d72a"
    },
    {
      "type": "code",
      "text": " ./optimized\n Normal: 65\n Manual: 220",
      "id": "a01e4d32460308ca71a11c349a1eca91"
    },
    {
      "type": "html",
      "text": "(Key: \"Normal\" uses standard polymorphism, and \"Manual\" is the way described on this page).",
      "id": "9e760db92da868b8587837be0c400f88"
    },
    {
      "type": "html",
      "text": "\nMaybe I messed something up in the code to make it an unfair test. I didn't test the space consumption, though I can't really see where space would be lost or saved.",
      "id": "e8d05530a19e4f42c66ea1a5a7be1c2f"
    },
    {
      "type": "html",
      "text": "\nHelp! Is this the same thing that happened in [[Catch Dont Check]]/[[Catch Dont Check Refuted]] where someone posts some ugly code in the name of optimization that ends up not even being as optimal as the legible version?",
      "id": "bc7a7d136960891ce3024e18b6ec7f9b"
    },
    {
      "type": "html",
      "text": "<i>Inlining is evil. Remove the inlining. You also eat it on the inlined constructors and destructors. By the way, I'm not making this up based on suppositions about the compiler. I spend a lot of time trying different constructs out under the environment I work in and then I choose the best one empirically. I often make assumptions that aren't true, which is why I test everything out.</i>",
      "id": "b115115fe3d55011c4f853e4e013f90a"
    },
    {
      "type": "html",
      "text": "\nI think that \"Inlining is evil\" is much too strong a statement. On many platforms, calling a function has some non-trivial cost (in both code size and execution time). An OO system favors short methods; in a lot of cases, inlining the shortest methods actually reduces code size because the method is shorter than the code required to call it. The purpose of inlining is <b>to expose the inlined code to compiler optimization in the context of its caller</b>. Properly refactored small methods may still contain redundancies which most compilers can only exploit when they are inlined into some larger context. Note that \"clean\" C++ code practically depends on compiler inlining to achieve the same performance as C. Unless you are using C++ as a bigger-better-c, judicious use of inlining is a good thing, not a bad thing.",
      "id": "629247f956d9ddc9afce6ded8a24f308"
    },
    {
      "type": "html",
      "text": "\nI think what you're really railing against is not inlining in itself, but the <i>implementation</i> of inlining in various compilers. In particular, the language/compiler should probably give the programmer more control over inlining than it usually does, since the compiler is sometimes not smart enough to control inlining itself. -- [[Wylie Garvin]]",
      "id": "318c107f4ab02454fa20105955ac4b8b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b335413227518cc42c2b6d9f6307eb"
    },
    {
      "type": "html",
      "text": "\nSeems to me that this technique, as written up, is <i>very</i> questionable, perhaps even mostly harmful. First of all, it doesn't even work in all languages. Second, it reduces the code's flexibility and communication. Third, the page gives little or no guidance on when, <b>and when not</b> to use the technique. Perhaps it should be rewritten as a pattern, with due attention to forces and related patterns. -- [[Ron Jeffries]]",
      "id": "fc7bfa91b870cb2db29d9b2818f9ee4c"
    },
    {
      "type": "html",
      "text": "<i>You'd want to use it when performance is far more important to you than any other factors, like maintainability. And you'd have to prove with metrics that this is really needed. <I've never seen a need for this level of optimization, but then I don't do [[Embedded System]]s work. -- [[Jeff Grigg]]></i>",
      "id": "7ee07cc2ee6a2bc36c63df9e5cf4b10c"
    },
    {
      "type": "html",
      "text": "\nYes, stuff like that is the answer. The exposition should bring such things out, in my opinion. -- [[Ron Jeffries]]",
      "id": "c99684a04b8d75a76fabba09848e6a0e"
    },
    {
      "type": "html",
      "text": "\nYeah, I see that it wasn't clear that this was a very limited hack. And it so is very much a hack. I've amended it a bit more. -- ss",
      "id": "73d90e0d8381a685d62934bb7885e551"
    },
    {
      "type": "html",
      "text": "\nBut note that this might be related to a more general principle; something like ([[Reduce Compiler Bloat]]). In particular, the size of deliverables produced by various C/C++ compilers can often be reduced by 50% or more with an hour or two of fiddling with compiler switches. If curtailing some inlining gives you a 50% reduction in code size with little performance impact, isn't that a good thing? (e.g. the Intel C/C++ compiler produces slightly faster code than MSVC++ but it also tends to be like 10+% larger in code size). Reducing <i>unnecessary</i> compiler bloat is a good thing, and may even make your program run faster (less code == perhaps better use of I-cache). I read some papers on code compression once where they found interesting results like, compressing an entire large commercial application such as Microsoft Word did not really make it slower--in some cases it made it faster! Why? The I/O cost of demand-loading and paging code turned out to be a significant cost. The reduction of this cost completely offset the extra time spent decompressing code on demand. (Sorry for the off-topic rant..) -- [[Wylie Garvin]]",
      "id": "77567a742f3a66b4bffca8fae4c9b8f3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b335413227518cc42c2b6d9f6307eb"
    },
    {
      "type": "html",
      "text": "\nInteresting. I just finished a project to write an interpreter for a SCHEME like language for school. Now the deadline pressure has gone away, I'm reviewing some of the decisions I have made, and maybe change / rewrite from scratch some things.",
      "id": "a7bdce3e789a807b6f2dc7c3eb4e5768"
    },
    {
      "type": "html",
      "text": "\nI created a base class S<b></b>chemeObject and sub classes S<b></b>chemeString, S<b></b>chemePair, SchemeNIL etc. S<b></b>chemeObjects are passed around a lot. Only at some places it matters what type it is. For example an arithmetic function: it should only accept [[Scheme Numbers]], every other type should throw an error.",
      "id": "6a5b76281b4917169d2fd493c40b53f1"
    },
    {
      "type": "html",
      "text": "\nTherefore I decided to do put type checking and explicit casting into the base class in this fashion:",
      "id": "d89f811ea51923d1c1291eccc85822e7"
    },
    {
      "type": "code",
      "text": " class S''''''chemeObject {\n   ...\n   public S''''''chemeString asString() {\n     if (this instanceof S''''''chemeString) return (S''''''chemeString)this;\n     throw new W''''''rongTypeError(this, \"string\"); // found, expected\n   }\n   ...\n }",
      "id": "422b8199fbb4a4c3f8efc9a0de99c4f7"
    },
    {
      "type": "html",
      "text": "\nThis is done for every subtype. For example, when I need a list where the first element is a string, I can do:",
      "id": "d5eeec2dd03f106085d3ddbc9af9443a"
    },
    {
      "type": "code",
      "text": " public void doSomething(S''''''chemeObject argument) {\n   S''''''chemeString s = argument.asPair().getCar().asString();\n   ...\n }",
      "id": "ba59fe9e718598b8916e8b835839adcb"
    },
    {
      "type": "html",
      "text": "\nThis statement will throw a W<b></b>rongTypeError when either the argument isn't a list, or the first element isn't a string. This is a very common form of casting/type checking/error throwing in my appication. So this solution is very convenient. Only when I need to do something else than throwing an error, which is pretty rare, I use the instanceof operator.",
      "id": "0115f37aa0bfcfc39d2e8aa2d7304209"
    },
    {
      "type": "html",
      "text": "\nI understand that this looks bad in many ways, but in every way I think about it, it's really the best solution. The number of \"things that are done\" with S<b></b>chemeObjects (more specifically: implementations of built-in Scheme functions) is huge, and in a lot of cases work only on one type and throw a W<b></b>rongTypeError on every other type. Note that a W<b></b>rongTypeError is converted into a Scheme error, and does not necessarily have to be considered to be a Java error.",
      "id": "a039be27b3f9b69f2d11ce7b3578c6ae"
    },
    {
      "type": "html",
      "text": "\nPolymorphism wouldn't help me. String concatenation is only applicable to strings, so a concat(..) function does not belong in S<b></b>chemeObject. The same goes for arithmetic functions: add, subst.... don't belong in S<b></b>chemeObject because they are not applicable to strings, pairs etc. etc.",
      "id": "b9ac3708efa1b8fd03f3ae76b62dd321"
    },
    {
      "type": "html",
      "text": "\nOnly the evaluation function could be implemented trough polymorphism, but since eval is a Scheme function too, and I already had a Scheme \"procedure\" abstract class, I implemented eval in the same way as every other procedure, separately. Only equals() and toString() are implemented polymorphically.",
      "id": "6287f08428d83003bdffe47f16e981d3"
    },
    {
      "type": "html",
      "text": "\nIn this case, every S<b></b>chemeObject is a Scheme data type, but that's really the only similarity. A S<b></b>chemeString and a S<b></b>chemeNumber share nothing but being Scheme data types. I think that there are other cases in which [[Test Types Instead Of Dispatch]] can be useful: When a certain collection of classes is similar in one way but polymorphous in another way, when (most) actions are naturally implemented separately, because these actions are entities of themselves, not bound to classes, [[Test Types Instead Of Dispatch]] will be necessary.",
      "id": "f9a42755aae7fbfe6b7d26ee386c9fec"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b335413227518cc42c2b6d9f6307eb"
    },
    {
      "type": "html",
      "text": "\nThis strikes me as an optimization which is <i>only</i> appropriate for very small or performance-critical systems (or for places where you wish to avoid the default language mechanism for dynamic dispatch).  It certainly isn't the simplest thing which could possibly work (just using virtual functions is), it's error-prone, and it smacks of [[Pointer Cast Polymorphism]] (which is, after all, a similar technique formalized with preprocessor macros).",
      "id": "b35984648d25a151ed8a883ca0e621d6"
    },
    {
      "type": "html",
      "text": "\nThe gains it buys you:",
      "id": "3c89a0e3206939b19f2f808900647f13"
    },
    {
      "type": "html",
      "text": " Avoidance of generating vtables.",
      "id": "51be111430ac4a7dd4418cb47c8a5c0f"
    },
    {
      "type": "html",
      "text": " Avoid the additional overhead involved in C++ dynamic dispatch, used to implement [[Multiple Inheritance]].",
      "id": "4adec245e22b49a9c6b5a333facdd092"
    },
    {
      "type": "html",
      "text": " Avoiding an extra indirection in a different area of memory, possibly resulting in a cache miss.  (Assuming, of course, that a cache is used--if you have 64k of total memory available, caching is probably not an issue).",
      "id": "2ac76775090a0bc5187397146a83264f"
    },
    {
      "type": "html",
      "text": "\nIf profiling tells you you need to do this, go ahead.  OTOH, if you're writing PC software.... this sounds rather questionable to me.",
      "id": "c4f9a3914a6c08888eb8afcb7a4861a2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "74b335413227518cc42c2b6d9f6307eb"
    },
    {
      "type": "html",
      "text": "[[Category Optimization]], [[Category Language Typing]], [[Category Conditionals And Dispatching]], [[Category Cpp]]",
      "id": "39af3dda9d899f557cd40d7b4323403f"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?TestTypesInsteadOfDispatch c2.com]",
      "id": "77aad1d741dd94ff83782948f2079ffc"
    }
  ],
  "journal": [
    {
      "date": 1239757284000,
      "id": "8a527727af13471c946f3075c3b39959",
      "type": "create",
      "item": {
        "title": "Test Types Instead Of Dispatch",
        "story": [
          {
            "type": "html",
            "text": "One [[Cee Plus Plus]] optimization that might save both time and code space is to check for types and cast instead of using polymorphism. For instance, ",
            "id": "f8a1244e4b49d4ed4f82a0c88c53defd"
          },
          {
            "type": "code",
            "text": " struct B''''''aseClass\n {\n  enum TYPE {\n    SubclassA,\n    SubclassB,\n  };\n  unsigned char type;\n  ...\n };",
            "id": "9f74ed73fcc506a314daf5ce9f14944a"
          },
          {
            "type": "html",
            "text": "struct SubclassA :<br>public B<b></b>aseClass",
            "id": "8222189163ad31d332016a092ad3b670"
          },
          {
            "type": "code",
            "text": " {\n  int width;\n  ...\n };",
            "id": "8d32409c43d1712ef1816f30cebcc89f"
          },
          {
            "type": "html",
            "text": "struct SubclassB :<br>public B<b></b>aseClass",
            "id": "b28ce0fe2dd7150e0a3031c2904ccead"
          },
          {
            "type": "code",
            "text": " {\n  int stride;\n  ...\n };",
            "id": "44f602f613156d03002041c715635ec7"
          },
          {
            "type": "code",
            "text": " B''''''aseClass *pInstance;\n ...\n int bufferWidth;\n if( B''''''aseClass::SubclassA == pInstance->type )\n {\n  bufferWidth = ((SubclassA*)pInstance)->width;\n }\n else if( B''''''aseClass::SubclassB == pInstance->type )\n {\n  bufferWidth = ((SubclassB*)pInstance)->stride;\n }",
            "id": "267f971e994b1813ec0938049569fdd2"
          },
          {
            "type": "html",
            "text": "\nIf we were coding a pure object-oriented design, this would surely be a [[Code Smell]]. Actually, in this trivial example, it is a [[Code Smell]]. But there exist real cases where it's smaller and faster to check for type information than to use polymorphic dispatch. Note also that the type information is available through a member variable. Alternatively, one could write:",
            "id": "3a0084ba6d780b412b2523de34d33db7"
          },
          {
            "type": "code",
            "text": " struct B''''''aseClass\n {\n  enum TYPE {\n    SubclassA,\n    SubclassB,\n  };\n  virtual B''''''aseClass::TYPE getType() const = 0; \n };",
            "id": "3ea09cba139e6d2b0a6cced13db52d02"
          },
          {
            "type": "html",
            "text": "\nand then return the type through a polymorphic call. However, to create the polymorphic function, this may require upwards around 100 bytes a class, at a cost of 1 byte (or at most 1 alignment) an instance. This trade-off can be significant in memory-constrained environments like embedded devices. Moreover, the polymorphic dispatch can take many times as many bytes as a simple member access.",
            "id": "5ef64d752783dfdf2b791825762c64ed"
          },
          {
            "type": "html",
            "text": "<i>Besides which, if you're going to introduce a polymorphic get<b></b>Type(), why not just introduce a polymorphic get<b></b>Buffer<b></b>Width() through which each subclass can use whatever subclass-specific member variables it needs to use?</i> -- [[Mike Smith]]",
            "id": "af583f89e117d5d635207db943814ffa"
          },
          {
            "type": "html",
            "text": "\nThis is one of those fine trade-off cases. There are many reasons not to do this. For one, it's a ridiculous optimization, and we all [[Optimize Later]] anyway. But in general, this really only works well if:",
            "id": "2bd124e863f5156c15b5d9312e6c08d7"
          },
          {
            "type": "html",
            "text": " <b>You really, really, really need code space efficiency!</b>",
            "id": "b153b4d04fe3746befe47198f1dc148e"
          },
          {
            "type": "html",
            "text": " You are only really cheating for get methods.",
            "id": "4a215c1a10e63b9d47c176e1cca46f6e"
          },
          {
            "type": "html",
            "text": " There are very few (say, one or two) subclasses who have a member that you want to retrieve, but most (say > 10) don't.",
            "id": "fd914763dc13afd8b5ff1d42a709093a"
          },
          {
            "type": "html",
            "text": " You don't want to get the member variable dynamically very often.",
            "id": "7d1fde8d1e0ec982d30dbc9155d2133e"
          },
          {
            "type": "html",
            "text": " You spend the five minutes to compile both models to see which is better.",
            "id": "61aad0af953a4104d7107aed9fbe4b9c"
          },
          {
            "type": "html",
            "text": "\nNote that if you have to check a lot of types, it's more expensive to do the lookup than it is just to call the method. This is because you need an if-else cascade or a switch statement, which means a lot of compares and jumps. After a certain point, using the dispatch table is much more efficient because it uses the principle, \"The instance knows about itself.\" -- [[Sunir Shah]]",
            "id": "0c74641b8a5a5b26177fecd5915a89b9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b335413227518cc42c2b6d9f6307eb"
          },
          {
            "type": "html",
            "text": "\nBy the way, this is a reasonable thing to do on a desktop for highly constrained domains like widget toolkits. Widgets should be thin and light or else you will eat memory badly and be very slow. Consider a poor widget toolkit like java.swt or javax.swing. Of course, both of those are quite bloated anyway, so there's no real point in trying. -- [[Sunir Shah]]",
            "id": "aa0184997822bd0978da158ba1d56b96"
          },
          {
            "type": "html",
            "text": "<i>A useful GUI toolkit has so many necessary features - internationalization, configuration, resource management etc. - that I fail to see how avoiding good OO design to save a few bytes will gain you anything. You will probably lose any advantage you gain in the base classes with extra special-case logic in derived classes to work round these hacks. I've certainly found such logic necessary when working with AWT Component and Container base classes.</i>",
            "id": "56caf423c4fb7fd7cbb02197f4b549e5"
          },
          {
            "type": "html",
            "text": "\nI don't mean to be excessively rude, but your half-assed guessing is totally bogus. ;) This is what others and I do <i>in practice</i> and it works very well. The \"scary\" concepts of internationalization, configuration, resource management have very little impact on the simplest thing that could possibly work. Often, it's simpler to not implement them because no one cares. Perhaps you're doing too much [[Big Design Up Front]] in your head. -- [[Sunir Shah]]",
            "id": "659b91af2995cfcece22acfa2b204bc6"
          },
          {
            "type": "html",
            "text": "\nWhat kind of wins could be expected for a typical application using this technique? A hundred bytes per class and a few bytes per object doesn't sound like the end of the world, but I don't know much about GUI frameworks. -- [[Anders Bengtsson]]",
            "id": "07f2316298da05226e30618e77607315"
          },
          {
            "type": "html",
            "text": "\nWell, ~100 bytes per class * 21 classes ~= 2kb, which is currently 10% of the library I'm working on. Most classes are currently 550 bytes. When I first noticed this and the annoying automagically-inlined constructor/destructors, I cut the library size in half. As I was told once, \"Code like Fortran!\" I haven't written the widget library yet, but I expect it to be similar, albeit not as dramatic as the paint methods will be larger and I have tweaked my Perl script to generate even more efficient code (in C++) since then. Bear in mind that I work on small devices, not desktops, as I point out above. Crossing 32kb is bad, 64kb very bad. -- [[Sunir Shah]]",
            "id": "b0408a44825e421524f6540231c461ea"
          },
          {
            "type": "html",
            "text": "\nPart of the problem sounds like the language implementation. C++ is not very intelligent about implementing polymorphism and its linking model reduces the compiler's ability to aggressively optimize polymorphic dispatch.",
            "id": "c5f4baaa6d6457057c6e299be83aa7c1"
          },
          {
            "type": "html",
            "text": "<i>So what? We still have to use C++.</i>",
            "id": "802fba0a23b6c103c81821641d1542a9"
          },
          {
            "type": "html",
            "text": "\nI'm just emphasizing that this is a C++-specific idiom, rather than a generally useful pattern. Although there is a link to this page from [[Code Smells Illustrated With Java Awt]], the context of the pattern does not readily apply to Java and the AWT.",
            "id": "3d76a5e221fda997518123ecc9d8919a"
          },
          {
            "type": "html",
            "text": "This is Wiki. Referring pages aren't necessarily important, nor should you really depend on them because they may be edited to remove the link. Each page should stand on its own. -- ss",
            "id": "ddcf0630a2c63f159cebd8fc40ca8afd"
          },
          {
            "type": "html",
            "text": "\nPurely as a matter of interest, why do you have to use C++? With those tight memory requirements I'd prefer to use C because it gives one much better control over what the compiler generates (what you see is pretty much what you get) and you can implement polymorphism just as easily if you are not using vtables. Additionally, if you want vtables, you can implement vtables and inheritance by hand and tune the implementation wrt speed or space.",
            "id": "2161ead73b5fe92ef289b5f97843f877"
          },
          {
            "type": "html",
            "text": "Actually, C++ gives you better control over what the compiler generates because most compilers now use the C++ code generator for even C. Using object-based systems vs. object-oriented systems vs. simple aggregate types is another argument. But, of course, using C++ for polymorphism is usually more efficient (and more maintainable--I still [[Code For The Maintainer]]) than using polymorphism in C because the compiler has a better chance and better algorithms to do the static analysis. We actually use both C and C++ and C-like C++ and assembler and a Perl script that compiles an higher-level file to C++ and a bunch of other things. -- ss",
            "id": "65b31b1f4a6ad1c4f5d1610448a62813"
          },
          {
            "type": "html",
            "text": "<i>Given the lack of virtual functions and dynamic_cast<>, I see the sample code at the top as largely a \"C\" subset of C++ - with class based syntactic conveniences. I recommend keeping C++ because the limited language features he chooses to use do help with maintenance.</i>",
            "id": "8a2a1f86861fd25d0358b0c12d45875b"
          },
          {
            "type": "html",
            "text": "<i>A trivial note: Instead of \"(SubclassA*)\" - C syntax to cast a pointer, I would use \"reinterpret_cast<SubclassA*>\". (Books will tell you to use \"dynamic_cast<>\", which is \"right,\" but you're trying to avoid the cost of the dynamic dispatch.) -- [[Jeff Grigg]]</i>",
            "id": "e6f03b3e9550ce14d8d34448c7d04268"
          },
          {
            "type": "html",
            "text": "\nNo, use a static_cast<> if you have [[Run Time Type Information]] turned on, dynamic_cast<> if you don't (no penalty--it degrades to static_cast<>). reinterpret_cast<> is used when you are completely changing the meaning of things, like unsigned char *videoMemory = reinterpret_cast<unsigned char *>(0xA0000000L); A static_cast<> is generally equivalent to a C-style cast. The gain of using static_cast<> over a C-style cast is that the static_cast is more readable. The disadvantage is that GCC doesn't really do the new style casts correctly (at least const_cast<>), so I gave up on them completely. C++ is fun because when you have to work with many different compilers, your end up having to use some lowest common denominator (for some definition that you believe will limit the portability problems). For instance, recently we had problems compiling for the Agenda because the [[Gnu Cpp]] they use (~2.9.0) didn't do namespaces. Fortunately, GCC is Light, so I begged and pleaded very nicely with the developer to build the latest GCC. She agreed and I didn't have to manually name mangle all my code. -- [[Sunir Shah]]",
            "id": "de75c6f71e763eb243c40fc90dc1c0bd"
          },
          {
            "type": "html",
            "text": "<i>And you're both wrong. Use a static_cast for the above code, whether or not you turn off standard features like [[Run Time Type Information]]. [[Cstyle Casts]] are evil in C++. Avoid at all costs. Also, try to avoid reinterpret_cast where possible, but prefer it over C-style casts, and prefer static_cast or dynamic_cast more. reinterpret_cast has surprisingly little defined behavior, much less so than most people believe, and it generally hides errors whereas static_cast would fail to compile showing the error. Also, in today's age gcc 3.4.3 is considered old, and it supports the C++ casts correctly, so use them as intended.</i>",
            "id": "018d5025392cc38e1307b988be964915"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b335413227518cc42c2b6d9f6307eb"
          },
          {
            "type": "html",
            "text": "\nFunny, what think ye of the results of [[Test Types Instead Of Dispatch Profile Code]]'s?:",
            "id": "7661e181f88b0a2089124557349439f9"
          },
          {
            "type": "html",
            "text": "\nOn this machine (WinME, [[Cyg Win]]'s [[Gnu Cpp]]), I got results consistently like this:",
            "id": "6139607e78ff7be567e5a72f14e3ba59"
          },
          {
            "type": "code",
            "text": " ./plain\n Normal: 220\n Manual: 279",
            "id": "99b539b6236d444947ab475baa84d72a"
          },
          {
            "type": "code",
            "text": " ./optimized\n Normal: 65\n Manual: 220",
            "id": "a01e4d32460308ca71a11c349a1eca91"
          },
          {
            "type": "html",
            "text": "(Key: \"Normal\" uses standard polymorphism, and \"Manual\" is the way described on this page).",
            "id": "9e760db92da868b8587837be0c400f88"
          },
          {
            "type": "html",
            "text": "\nMaybe I messed something up in the code to make it an unfair test. I didn't test the space consumption, though I can't really see where space would be lost or saved.",
            "id": "e8d05530a19e4f42c66ea1a5a7be1c2f"
          },
          {
            "type": "html",
            "text": "\nHelp! Is this the same thing that happened in [[Catch Dont Check]]/[[Catch Dont Check Refuted]] where someone posts some ugly code in the name of optimization that ends up not even being as optimal as the legible version?",
            "id": "bc7a7d136960891ce3024e18b6ec7f9b"
          },
          {
            "type": "html",
            "text": "<i>Inlining is evil. Remove the inlining. You also eat it on the inlined constructors and destructors. By the way, I'm not making this up based on suppositions about the compiler. I spend a lot of time trying different constructs out under the environment I work in and then I choose the best one empirically. I often make assumptions that aren't true, which is why I test everything out.</i>",
            "id": "b115115fe3d55011c4f853e4e013f90a"
          },
          {
            "type": "html",
            "text": "\nI think that \"Inlining is evil\" is much too strong a statement. On many platforms, calling a function has some non-trivial cost (in both code size and execution time). An OO system favors short methods; in a lot of cases, inlining the shortest methods actually reduces code size because the method is shorter than the code required to call it. The purpose of inlining is <b>to expose the inlined code to compiler optimization in the context of its caller</b>. Properly refactored small methods may still contain redundancies which most compilers can only exploit when they are inlined into some larger context. Note that \"clean\" C++ code practically depends on compiler inlining to achieve the same performance as C. Unless you are using C++ as a bigger-better-c, judicious use of inlining is a good thing, not a bad thing.",
            "id": "629247f956d9ddc9afce6ded8a24f308"
          },
          {
            "type": "html",
            "text": "\nI think what you're really railing against is not inlining in itself, but the <i>implementation</i> of inlining in various compilers. In particular, the language/compiler should probably give the programmer more control over inlining than it usually does, since the compiler is sometimes not smart enough to control inlining itself. -- [[Wylie Garvin]]",
            "id": "318c107f4ab02454fa20105955ac4b8b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b335413227518cc42c2b6d9f6307eb"
          },
          {
            "type": "html",
            "text": "\nSeems to me that this technique, as written up, is <i>very</i> questionable, perhaps even mostly harmful. First of all, it doesn't even work in all languages. Second, it reduces the code's flexibility and communication. Third, the page gives little or no guidance on when, <b>and when not</b> to use the technique. Perhaps it should be rewritten as a pattern, with due attention to forces and related patterns. -- [[Ron Jeffries]]",
            "id": "fc7bfa91b870cb2db29d9b2818f9ee4c"
          },
          {
            "type": "html",
            "text": "<i>You'd want to use it when performance is far more important to you than any other factors, like maintainability. And you'd have to prove with metrics that this is really needed. <I've never seen a need for this level of optimization, but then I don't do [[Embedded System]]s work. -- [[Jeff Grigg]]></i>",
            "id": "7ee07cc2ee6a2bc36c63df9e5cf4b10c"
          },
          {
            "type": "html",
            "text": "\nYes, stuff like that is the answer. The exposition should bring such things out, in my opinion. -- [[Ron Jeffries]]",
            "id": "c99684a04b8d75a76fabba09848e6a0e"
          },
          {
            "type": "html",
            "text": "\nYeah, I see that it wasn't clear that this was a very limited hack. And it so is very much a hack. I've amended it a bit more. -- ss",
            "id": "73d90e0d8381a685d62934bb7885e551"
          },
          {
            "type": "html",
            "text": "\nBut note that this might be related to a more general principle; something like ([[Reduce Compiler Bloat]]). In particular, the size of deliverables produced by various C/C++ compilers can often be reduced by 50% or more with an hour or two of fiddling with compiler switches. If curtailing some inlining gives you a 50% reduction in code size with little performance impact, isn't that a good thing? (e.g. the Intel C/C++ compiler produces slightly faster code than MSVC++ but it also tends to be like 10+% larger in code size). Reducing <i>unnecessary</i> compiler bloat is a good thing, and may even make your program run faster (less code == perhaps better use of I-cache). I read some papers on code compression once where they found interesting results like, compressing an entire large commercial application such as Microsoft Word did not really make it slower--in some cases it made it faster! Why? The I/O cost of demand-loading and paging code turned out to be a significant cost. The reduction of this cost completely offset the extra time spent decompressing code on demand. (Sorry for the off-topic rant..) -- [[Wylie Garvin]]",
            "id": "77567a742f3a66b4bffca8fae4c9b8f3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b335413227518cc42c2b6d9f6307eb"
          },
          {
            "type": "html",
            "text": "\nInteresting. I just finished a project to write an interpreter for a SCHEME like language for school. Now the deadline pressure has gone away, I'm reviewing some of the decisions I have made, and maybe change / rewrite from scratch some things.",
            "id": "a7bdce3e789a807b6f2dc7c3eb4e5768"
          },
          {
            "type": "html",
            "text": "\nI created a base class S<b></b>chemeObject and sub classes S<b></b>chemeString, S<b></b>chemePair, SchemeNIL etc. S<b></b>chemeObjects are passed around a lot. Only at some places it matters what type it is. For example an arithmetic function: it should only accept [[Scheme Numbers]], every other type should throw an error.",
            "id": "6a5b76281b4917169d2fd493c40b53f1"
          },
          {
            "type": "html",
            "text": "\nTherefore I decided to do put type checking and explicit casting into the base class in this fashion:",
            "id": "d89f811ea51923d1c1291eccc85822e7"
          },
          {
            "type": "code",
            "text": " class S''''''chemeObject {\n   ...\n   public S''''''chemeString asString() {\n     if (this instanceof S''''''chemeString) return (S''''''chemeString)this;\n     throw new W''''''rongTypeError(this, \"string\"); // found, expected\n   }\n   ...\n }",
            "id": "422b8199fbb4a4c3f8efc9a0de99c4f7"
          },
          {
            "type": "html",
            "text": "\nThis is done for every subtype. For example, when I need a list where the first element is a string, I can do:",
            "id": "d5eeec2dd03f106085d3ddbc9af9443a"
          },
          {
            "type": "code",
            "text": " public void doSomething(S''''''chemeObject argument) {\n   S''''''chemeString s = argument.asPair().getCar().asString();\n   ...\n }",
            "id": "ba59fe9e718598b8916e8b835839adcb"
          },
          {
            "type": "html",
            "text": "\nThis statement will throw a W<b></b>rongTypeError when either the argument isn't a list, or the first element isn't a string. This is a very common form of casting/type checking/error throwing in my appication. So this solution is very convenient. Only when I need to do something else than throwing an error, which is pretty rare, I use the instanceof operator.",
            "id": "0115f37aa0bfcfc39d2e8aa2d7304209"
          },
          {
            "type": "html",
            "text": "\nI understand that this looks bad in many ways, but in every way I think about it, it's really the best solution. The number of \"things that are done\" with S<b></b>chemeObjects (more specifically: implementations of built-in Scheme functions) is huge, and in a lot of cases work only on one type and throw a W<b></b>rongTypeError on every other type. Note that a W<b></b>rongTypeError is converted into a Scheme error, and does not necessarily have to be considered to be a Java error.",
            "id": "a039be27b3f9b69f2d11ce7b3578c6ae"
          },
          {
            "type": "html",
            "text": "\nPolymorphism wouldn't help me. String concatenation is only applicable to strings, so a concat(..) function does not belong in S<b></b>chemeObject. The same goes for arithmetic functions: add, subst.... don't belong in S<b></b>chemeObject because they are not applicable to strings, pairs etc. etc.",
            "id": "b9ac3708efa1b8fd03f3ae76b62dd321"
          },
          {
            "type": "html",
            "text": "\nOnly the evaluation function could be implemented trough polymorphism, but since eval is a Scheme function too, and I already had a Scheme \"procedure\" abstract class, I implemented eval in the same way as every other procedure, separately. Only equals() and toString() are implemented polymorphically.",
            "id": "6287f08428d83003bdffe47f16e981d3"
          },
          {
            "type": "html",
            "text": "\nIn this case, every S<b></b>chemeObject is a Scheme data type, but that's really the only similarity. A S<b></b>chemeString and a S<b></b>chemeNumber share nothing but being Scheme data types. I think that there are other cases in which [[Test Types Instead Of Dispatch]] can be useful: When a certain collection of classes is similar in one way but polymorphous in another way, when (most) actions are naturally implemented separately, because these actions are entities of themselves, not bound to classes, [[Test Types Instead Of Dispatch]] will be necessary.",
            "id": "f9a42755aae7fbfe6b7d26ee386c9fec"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b335413227518cc42c2b6d9f6307eb"
          },
          {
            "type": "html",
            "text": "\nThis strikes me as an optimization which is <i>only</i> appropriate for very small or performance-critical systems (or for places where you wish to avoid the default language mechanism for dynamic dispatch).  It certainly isn't the simplest thing which could possibly work (just using virtual functions is), it's error-prone, and it smacks of [[Pointer Cast Polymorphism]] (which is, after all, a similar technique formalized with preprocessor macros).",
            "id": "b35984648d25a151ed8a883ca0e621d6"
          },
          {
            "type": "html",
            "text": "\nThe gains it buys you:",
            "id": "3c89a0e3206939b19f2f808900647f13"
          },
          {
            "type": "html",
            "text": " Avoidance of generating vtables.",
            "id": "51be111430ac4a7dd4418cb47c8a5c0f"
          },
          {
            "type": "html",
            "text": " Avoid the additional overhead involved in C++ dynamic dispatch, used to implement [[Multiple Inheritance]].",
            "id": "4adec245e22b49a9c6b5a333facdd092"
          },
          {
            "type": "html",
            "text": " Avoiding an extra indirection in a different area of memory, possibly resulting in a cache miss.  (Assuming, of course, that a cache is used--if you have 64k of total memory available, caching is probably not an issue).",
            "id": "2ac76775090a0bc5187397146a83264f"
          },
          {
            "type": "html",
            "text": "\nIf profiling tells you you need to do this, go ahead.  OTOH, if you're writing PC software.... this sounds rather questionable to me.",
            "id": "c4f9a3914a6c08888eb8afcb7a4861a2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "74b335413227518cc42c2b6d9f6307eb"
          },
          {
            "type": "html",
            "text": "[[Category Optimization]], [[Category Language Typing]], [[Category Conditionals And Dispatching]], [[Category Cpp]]",
            "id": "39af3dda9d899f557cd40d7b4323403f"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?TestTypesInsteadOfDispatch c2.com]",
            "id": "77aad1d741dd94ff83782948f2079ffc"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1699944434772
    }
  ]
}