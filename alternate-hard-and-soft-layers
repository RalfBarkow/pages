{
  "title": "Alternate Hard And Soft Layers",
  "story": [
    {
      "type": "html",
      "text": "<b>[[Pattern Form]] Version:</b>",
      "id": "8e3bf88238a378d3211f67cf14b8bb3c"
    },
    {
      "type": "html",
      "text": "<b>Aliases:</b> Scripting System, Interpreter, Extensible Middle Layer",
      "id": "9db5be7ee1546686fd6f642877df5b11"
    },
    {
      "type": "html",
      "text": "<b>Problem:</b>\nThe mapping between the primitives available and the driver that\ncontrols them is too static. Combinations of the primitives are\nlimited, and no universal data type exists to transfer data\nbetween components of the system.",
      "id": "c0d36ab34e206929fda1c6e2d69eea60"
    },
    {
      "type": "html",
      "text": "<b>Context:</b>\nThe primitive elements of the system are used in a limited but\neffective way. The applications serve existing needs using well-\ndefined business rules. New needs are emerging that do not have\nwell-defined business rules, but must be integrated as quickly\nas the rules are defined. The success of integrating the new\nneeds into the system depends in part on the changes to the\nwork flow that supporting the new features produces.",
      "id": "9fa4b428b3be41d45b50d51ee447bd58"
    },
    {
      "type": "html",
      "text": "<b>Forces:</b>\nA context for rapid experimentation and novel functionality requires\nnew infrastructure. New data types must be created to accommodate\nthe need for a universal transport mechanism between all existing\nelements in the system. The added complexity of introducing such\ninfrastructure to the system could markedly reduce efficiency of the\nexisting system functions.",
      "id": "f622ad5d23a4f5d5f0c6b99e874e7fb6"
    },
    {
      "type": "html",
      "text": "<b>Solution:</b>\nBuild an extensible interpreter environment that makes all the\nprimitive elements of the existing system available via universal\ndata types. Provide 'exec' and 'eval' functions that create localized\nsub-environments where both inputs and outputs are defined in terms\nof universal data types.",
      "id": "02b9340cf473fc0b535ab51b306698ce"
    },
    {
      "type": "html",
      "text": "<b>Resulting Context:</b>\nA single generic driver system provides an entry point for a data type\nthat relates the combinations and relationships of the primitive elements.\nThe relationships could be pipelines, multiplexing, or combining data in\norder to create the desired results. All the previous functions are\nsupported, but a much larger context has been created at the same time.",
      "id": "9ed42d03186b9649a0edd028e57f8c75"
    },
    {
      "type": "html",
      "text": "<b>Design Rationale:</b>\nIf a system is designed such that its driver layer can be removed from\na scripting layer, and the scripting layer can execute strings composed\nby the script (like back-quotes in the Unix shell), then it achieves\nfractal complexity. The scripting layer sits on top of atomic\nfunctionality like regular expressions, mathematical functions,\nvariables, database access, file control, etc. An extended concrete\nexample:  Customize a web server to take URL's that mapped to HTML\npages with embedded Tcl, then run as server-side includes. Cache the\npre-processed page as a Tcl script, rebuilding it if the source file\ntimestamp changed.  Customize the Tcl interpreter to add database\naccess and some native Tcl functions for convenience.  Since Tcl has an",
      "id": "06234b3baf4e7204842b8a3952a5f7e0"
    },
    {
      "type": "html",
      "text": "<i>exec</i> functionality, code can be stored in the database and coupled\nwith a driver script for any template page. This kind of structure uses\nonly 3 layers to achieve 2n+1 (n=1->k) <i>virtual layers</i>.  The key seems\nto be that if the interpreter operates unaware of where it is being\ncalled <i>from</i>, then a wonderful simplicity suddenly arises, since the\nlevel of <i>reusability</i> of the interpreter itself jumps a level. The\nlanguage itself allows for localized contexts that are unaware (at\nleast directly) of where they are invoked from.  Writing your compiler\nin the language it compiles is a similar idea, kind of like writing the\nYACC specification <i>in</i> YACC syntax (but that is not for the faint at\nheart).",
      "id": "eb8d34a5501d41f1a6b6c10b73708e58"
    },
    {
      "type": "html",
      "text": "<b>Examples:</b>\nSh, Ksh, Csh, Perl, [[Tool Command Language]] (Tcl), Python, [[Lua Language]], Java (not strongly), [[Bean Shell]] (for Java), compilers written in the language they compile, [[Java Script]], networks of WWW servers.",
      "id": "1387ae0f7b48e5d748e7dd214adc6239"
    },
    {
      "type": "html",
      "text": "<b>Related Patterns:</b>\n[[Decide On The Primitives]], [[Create Flexible Messaging]], ([http://laputa.isdn.uiuc.edu/metamorphosis/metamorphosis.html laputa.isdn.uiuc.edu] -- [[Brian Foote]]), [[Data Driven Programs]]",
      "id": "70f4a0baee9730623681d049f1591350"
    },
    {
      "type": "html",
      "text": "-- [[David Cymbala]]",
      "id": "b7b9b1a7406be85f7a693abccade6c8d"
    },
    {
      "type": "html",
      "text": "\nCouldn't find the metamorphosis paper at the cited URL - I assume it is now here: [http://www.laputan.org/metamorphosis/metamorphosis.html#Metamorphosis www.laputan.org] --[[Paul Morrison]]",
      "id": "fc90df4009168a5fa9323be9c2cd2173"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "<b>Short version:</b>",
      "id": "7115d6259ad12df487063bc0a3406b2b"
    },
    {
      "type": "html",
      "text": "\nBy virtue of the first rule of optimization, go ahead and write most of your code in the highest level language you can find.",
      "id": "83e9611468f354111a41ed936e2b69b4"
    },
    {
      "type": "html",
      "text": "\nBy virtue of the third rule of optimization, when you must, use a profiler and find the slow parts of your program.  Take those parts, and write them in a lower-level language.",
      "id": "08280e96610b2c95d9961b8af9e8c2fd"
    },
    {
      "type": "html",
      "text": "\nSee [[Rules Of Optimization]]",
      "id": "26a08d3597bfdb1a224d562304c362aa"
    },
    {
      "type": "html",
      "text": "(Almost every language out there lets you drop down to C or the like.  Some languages even make it easy (See: Perl's Inline::C module: [http://search.cpan.org/~ingy/Inline-0.44/C/C.pod search.cpan.org] and Python's Pyrex: [http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/ www.cosc.canterbury.ac.nz])).",
      "id": "e355073b4a21e7ee774b20e99e9ee8e7"
    },
    {
      "type": "html",
      "text": "<i>So why not use something like [[Common Lisp]], where you have all of this in one place?</i>",
      "id": "95fac378130ede89000c7e898c34579f"
    },
    {
      "type": "html",
      "text": "\nWas that a joke?",
      "id": "b0151fe47bdb0f90e4603f50e7208bcc"
    },
    {
      "type": "html",
      "text": "<i>Doesn't sound like one to me. Lisp has a reputation for being slow, but there are (both free and commercial) Common Lisp implementations that can provide speed near that of C, C++, or Fortran when the code is written for speed. Most Common Lisp implementations provide some sort of built-in profiling facility, as well as the ability to call C code.</i>",
      "id": "fad7edb7eb2bd419fe25ae82ab42f087"
    },
    {
      "type": "html",
      "text": "\nI've been learning [[Common Lisp]], and although it's possible to write code with speed comparable to C, it's more difficult.  You have to fight the inherent dynamicity of the language, and the higher level abstractions are more difficult to mentally correlate with the assembly code it will compile to.  Experts can do it, but it'll take longer to become an expert.  All in all, I'd rather do C for low level code, though avoiding FFI ugliness and having use of real macros may make it worth using [[Common Lisp]].",
      "id": "9f00fedda7dd62176a92c9f4fa93500a"
    },
    {
      "type": "html",
      "text": "<i>I'd have to disagree.  It took me about 2 weeks to learn how to generate really efficient code in CL (cmucl or sbcl).  There are, granted, some exceptions a problem areas that can be a bit of a pain (some related to the fact that those compilers are maintained by volunteers).  But you say it is more difficult.  Do you mean more difficult than writing non-optimized CL code?  I'd agree.  More difficult than writting fast C code?  In that case, I'd say not much.  I've written a lot more high-performance C than CL, also.  Writing fast CL code to a large degree involves putting in things you have to do *all the time* in C anyway, so it isn't a loss there.  High level abstractions can be a problem, I agree, but that has nothing to do with the language you are using.  Well, possibly in the case that a more powerful language (in this sense) like CL makes it easy to do things you would hesitate to even try in C, I guess that is true.  But that is not the languages fault --- if you want high performance code you have to understand something about performance, after all.</i>",
      "id": "6a6efac8bc435143f047799f94dad4c8"
    },
    {
      "type": "html",
      "text": "\nSupposedly (because I've only read about this, not used it myself), Lisp implementations support both fast development and fast execution by producing very fast code when you declare the types of variables.  You can develop in the dynamically typed Python/Perl mode and then, when you identify bottlenecks, add type declarations to allow code optimization based on static typing a la C++.  Dynamism and efficiency, without rewriting your code in a different language.  Also (in my experience, not just supposedly), Lisp macros allow you to disguise obfuscatory efficiency hacks that would force you to write less readable code in other languages.",
      "id": "895f13c2e26115ad479f04a80f321052"
    },
    {
      "type": "html",
      "text": "\nIn general, writing simple code in most cases and then marking up critical sections to help the compiler generate efficient code is an old trick that in most languages is considered arcane and only done using nonstandard extensions.  When I write Python and C++ the biggest <b>visual</b> difference is all the type specifications.  Why have two different languages?  Future languages will, I hope, be designed with multiple modes of programming and execution in mind, so that they support the smooth evolution of code from stab-in-the-dark hacking to dynamic scripting to statically optimized application or library code.  I'm hoping to find that already implemented in Lisp.  (The Lisp advocates keep pointing out how many \"new\" features have been available in Lisp for years, so I figure I should turn to Lisp for the functionality that I expect to reach the mainstream ten years from now.)",
      "id": "d3805fd6b6e5e8b7f351d81c98812494"
    },
    {
      "type": "html",
      "text": "<i>Common Lisp isn't good enough here not because it isn't sufficiently good hard language, but because it isn't sufficiently good soft language. This is simply because of the unavailability of the necessary breadth of maintained and widely used (and thus better bug-fixed) libraries available from the intarwebs, forcing a DIY approach which interferes with RAD. Just compare the set of better than alpha-grade libraries/frameworks significantly (or at all!) updated in the last two years for CL and Python/Ruby. You could say that this is not a language problem as such, but that's cold comfort in the real world where vaporware is worth zilch and actually existing software matters. It's also easy to get support for Python/Ruby from the net, whereas lispers tend to be more likely to skin you (or your newbie co-developer) alive than help you, which will again slow you down comparatively speaking.</i>",
      "id": "d50155cc46f4a6db987e25efeeb1a5d2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "\nAs one authors, one can experiment in the soft language, and then refactor repeatedly used or time critical functions into the hard language. Decision to migrate influences future abstraction trade-offs. Functions in the hard layer abstract as dynamic dispatch with at least the Adapter [[Design Pattern]]. Functions in the soft layer abstract by replacing their source files.",
      "id": "44112efe1206889b9079ef7c083fa189"
    },
    {
      "type": "html",
      "text": "\nThe result over time is a system has grown a perfect [[Application Programming Interface]] in its hard layer; one that satisfies all the needs of the soft layer above it as if by magic. This comprehensiveness can surprise initiates to the system.",
      "id": "44734159539d2b091d73dbd22601fad0"
    },
    {
      "type": "html",
      "text": "<i>\"Granma what a big API you have!\"</i>",
      "id": "07451cd4315c773259701e01d041061a"
    },
    {
      "type": "html",
      "text": "<i>\"All the better to [[Embrace And Extend]] you with, my dear!\"</i>",
      "id": "cd71bb4d33a0e588834414fadbffed98"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "\nWriting your compiler in the language it compiles is a similar idea, kind of like writing the YACC specification <i>in</i> YACC syntax (but that is not for the faint at\nheart).",
      "id": "b53a9e4af4c643b72eef5d5d0ae65ce3"
    },
    {
      "type": "html",
      "text": "<i>Sure it is. The only slightly hard part about writing a Yacc grammar for Yacc is that it is an LALR(2) language whereas Yacc only accepts LALR(1) grammars, but this is trivial to work around, in the same way that one always does Yacc workarounds: have the lexer do it. In this case, have the lexer do the extra one-token lookahead (it comes up on RULENAME ':'...the lexer has to lookahead and see the ':' in order to know to return RULENAME rather than NAME). Everything else about Yacc in Yacc is really easy. And I've done this, so I'm not just speculating. -- dm</i>",
      "id": "c07a4bc7315c77fb6f2e78a8c73fde64"
    },
    {
      "type": "html",
      "text": "\nA trendy version of that is the part of the XML Spec where they describe DTD syntax using much the same syntax they are describing, as DTD is a lot like BNF. --[[Daniel Earwicker]]",
      "id": "47ccfb9d3c2b384ea7a9ae6d13cab546"
    },
    {
      "type": "html",
      "text": "\nThe language of XML Schemas can be described in every detail by an XML Schema.  The Schema committee worked hard to make sure this was so.  They kept a working schema describing the language, and I think it is actually the \"authoritative\" version (if it interprets something differently from the english spec, the schema takes priority).",
      "id": "be92e4aec6e340818ab38ef494b92501"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "\nDrawback No 1. Hard languages tend to have [[Static Type Safety]]. Soft ones usually don't. So square pegs end up in round holes, and who's going to warn ya? Eh? -- [[Daniel Earwicker]]",
      "id": "121b8e16478910b6d1f241b9e3d53338"
    },
    {
      "type": "html",
      "text": "<i>Static languages perform type checks at compile time; dynamic languages perform type checks at run time.  (Static languages such as Haskell and O'Caml can be good soft languages.)  It's reasonable to worry that when static and dynamic languages meet, there will be some confusion about who should check, resulting in uncaught errors.  \"Did you check?\"  \"No, I thought you checked!\"  In practice, types are checked in the dynamic language at the interface between the two languages.  For example, before calling a C++ function, Boost.Python checks the Python argument types against the C++ function signature and throws an exception if the types aren't compatible.  For example, when calling the C++ function void foo::bar(std::string), Boost.Python allows foo.bar('Hi there') (and automatically converts 'Hi there' to a C++ string), but foo.bar(3) results in an exception being raised.  The run-time checking on the soft side makes up for the lack of run-time checking on the hard side.</i>",
      "id": "123f8802997a15335548fd60e4071dea"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "\nMy favorite example of this pattern is modern 3D shooter games (!). Quake 3: Arena has a particularly beautiful architecture -- the game executable is merely a library of optimized C code that renders 3D objects, plays sounds, and synchronizes data among networked players. The game logic itself (physics, weapons, scoring, etc) runs atop the engine in a flexible virtual machine. Game code communicates with the engine through system calls or \"traps\" (there is also a small shared memory segment for high-bandwidth communication).   ",
      "id": "664498d7850b3ff769c75f6b9fcfaa81"
    },
    {
      "type": "html",
      "text": "\nIn Quake 3 the game code is written in a dialect of C, and then compiled down to bytecode (which the engine may JIT compile for extra speed). This means VM programs can be run on any CPU to which the engine has been ported. Also, the VM environment is sandboxed to prevent malicious or buggy game code from harming your system. (implementing the game logic as native CPU code in a DLL - the approach taken by Quake 2 and Halflife - affords no such protection, and is platform-specific).",
      "id": "3c09e84a560dd1201c96af0901dd47e2"
    },
    {
      "type": "html",
      "text": "\nThe advantage of this split between engine and game code is that you can swap out the game logic without recompiling the engine. Also, the discipline of maintaining a clean, well-defined \"system call\" API is a great benefit to third parties who want to write new extensions for the game. ",
      "id": "dc02bfbde63028773a075369412f5c35"
    },
    {
      "type": "html",
      "text": "\nIt is also possible to make the game engine API available through other languages. I've seen versions of Quake that support game code running in a standard Java VM and in a Python interpreter.",
      "id": "40887f8254f0620bf1dae13587ce12d8"
    },
    {
      "type": "html",
      "text": "\nAll Quake-, Unreal- and Halflife-based games have architectures like this. I doubt they were the first games to use these techniques though.",
      "id": "0da20dcebd4deb8d1232700f56127cb3"
    },
    {
      "type": "html",
      "text": "-- Dan Maas",
      "id": "3b346cde31bcdd5ae714c32651834cc9"
    },
    {
      "type": "html",
      "text": "<i>Interesting.  Are the shared mem writes bounds checked?  Any idea where to get the source? --[[An Aspirant]]</i>\nYes, all memory access by the virtual machine code is bounds-checked for safety (even in JIT compiled code, there is still a check). The shared memory segment exists as part of the virtual machine's heap, so it is still safe.. The engine source code for Quake 1 and 2, and the game source code for Quake 1-3 are available at ftp.idsoftware.com. (Quake I has a similar virtual machine architecture, however Quake II uses a native DLL for the game code)",
      "id": "ad7cb220af1e55274c4514fec345e444"
    },
    {
      "type": "html",
      "text": "\nWhat about Z-code ([[Zork Code]])?",
      "id": "d3415c605507a45d7270cb19d523d0b3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "\nThis seems like a really powerful pattern. I have lots of things to say!",
      "id": "0b77495c6091b4763f4f323797f474b7"
    },
    {
      "type": "html",
      "text": "\nSome more concrete examples would be helpful; i suppose the obvious one is unix shell script, which has almost no useful operations of its own and yet is really rather powerful.",
      "id": "bca8ab1ba96c2b511824178617ff8958"
    },
    {
      "type": "html",
      "text": "\nThe name of this pattern is a bit confusing; is 'alternate' a verb or an adjective? Either way, it seems to suggest a system with many layers, alternately soft and hard, but it seems to actually talk about a system with just two layers, a hard low-level one (the components) and a soft high-level one (the script). Perhaps a better name would be [[Soft Over Hard]]?",
      "id": "0e9d88a5e532d4b56c38ce87b631664f"
    },
    {
      "type": "html",
      "text": "\nThe idea that big, evolving systems are best built using two layers, one hard and one soft, implies that such projects will need two languages, one hard and one soft (where a [[Hard Language]] is what we usually call a [[Programming Language]] and a [[Soft Language]] is what we often call a [[Scripting Language]]). This suggests that attempting to invent languages to build big systems is folly; rather, we need to develop <i>pairs</i> of languages, one hard and one soft, that work well together - [[Symbiotic Languages]], if you will. Can we observe this anywhere in the wild? Perhaps [[Micro Soft]] is doing it with [[Cee Sharp]]/[[Cee Plus Plus]] or [[Visual Basic]]/[[Cee Plus Plus]]; the scriptable Office apps certainly looks a bit like [[Alternate Hard And Soft Layers]]. One could argue that web browsers, supporting [[Java Script]] and [[Java Applet]]s, are a hard-soft environment, but to my knowledge, nobody has actually built a system in which modular applets are composed into an application on a single page using [[Java Script]], but it is certainly possible.",
      "id": "5c887a6dc5b8447b6912a44f06381bac"
    },
    {
      "type": "html",
      "text": "\nThe idea of [[Alternate Hard And Soft Layers]] depends absolutely on the assumption that no one language can provide enough performance to be used in the hard layers and enough flexibility to be used in the soft layers; is this really true? [[Small Talk]] and [[Self Language]] are both very flexible and fast to develop, and seem ideal for the [[Soft Layer]], but modern VMs actually make them run quite fast (not as fast as C yet, but getting there); could they be used for both sets of layers, thus eliminating this distinction? I suppose one could argue that since the VM, and a set of primitive operations, is implemented in C that constitutes the [[Hard Layer]], and it's just a lot smaller and less application-specific than discussed above, but i don't think i'd buy this.",
      "id": "4843c525609a7a58b359ffa363d4cb91"
    },
    {
      "type": "html",
      "text": "-- [[Tom Anderson]]",
      "id": "761cd1f8149aebaa9b2e0818a95242aa"
    },
    {
      "type": "html",
      "text": "<i>Lisp has this feature; extremely high level but with native code compilation..</i> ",
      "id": "57f03951a64a9c052d3b14cd6c052fd3"
    },
    {
      "type": "html",
      "text": "\nThis misses the point. The issue is not interpretation versus native code compilation, but rather strategies for leveraged optimization and trade-offs between clarity and efficiency. It applies to replacing [[Cee Language]] code with [[Assembly Language]] code just as much as it does to replacing [[Lisp Language]] code with [[Cee Language]] code. ",
      "id": "6eb725097283961679cd8d7b156cadf3"
    },
    {
      "type": "html",
      "text": "<i>How about replacing Lisp code with tighter Lisp code?</i>",
      "id": "c0640a5b06eed0a6766fc4a1bb793657"
    },
    {
      "type": "html",
      "text": "\nLet us say that you have a large program written in (to use my own preference) [[Scheme Language]]. By using the high level language, with a suitably optimizing compiler, you are able to write it in a manner that is both efficient and elegant - but there's one a single large hot-spot which is slowing down the whole program, even after careful refactoring. This one function needs to run as fast as possible, and any speed improvement in it would affect the overall performance of the program.",
      "id": "da09e709b17db58201d9dfa04c56c9ec"
    },
    {
      "type": "html",
      "text": "\nAt that point, wouldn't sacrificing 5 lines of Scheme code in exchange for, say, 50 lines of optimized Assembly code to get an speed-up of an order of magnitude, be a worthwhile tradeoff? If the rest of the program is well-written, it shouldn't even present a portability problem - after all, 50 lines is not very much even in assembly. Even given the [[Foreign Function Interface]] overhead, this would be a Good Thing.",
      "id": "7bb6a6e0b344ec64fb301ca7c13c8266"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "[[Objective Cee]] has the soft and hard languages in one \"language\" -- most of the flexibility of [[Small Talk]] in the OO extensions, and the 'hard' layer of C/C++... Apple's [[Apple Script]] Studio puts an even \"softer\" layer -- [[Apple Script]] -- on top of the gui classes provided by Cocoa implemented in [[Objective Cee]]. --[[Keith Ray]]",
      "id": "3e8c1ac6082e096d4f02ead9b856131a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "[[Forth Language]] traditionally has both hard and soft layers in the same language.  Normal words are compiled to threaded-interpreted code, but you had the option to use the assembler wordset to recode frequently used and bottleneck words as CODE words.  Such words had full access to the machine's instruction set and could be referenced just like normally compiled words.  Naturally, most of the core wordset of a Forth system (DUP, DROP, etc.) were implemented as CODE words.  (Of course, Forth is pretty low-level itself, so this might be considered alternating Hard and Harder layers. Same with C with inline assembly.)",
      "id": "03016b3543bdc12d4fafab5b7039fea5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "\nThe book [[Software Development Ona Leash]] [ISBN: 1893115917] seems to support the \"[[Alternate Hard And Soft Layers]]\" proposal.",
      "id": "738cf5c225f59f30b0509213cdece9c8"
    },
    {
      "type": "html",
      "text": "\nFrom Amazon's Editorial Review:",
      "id": "87e4d9be1862bb3181eb4455f62d1f2e"
    },
    {
      "type": "html",
      "text": "<i>\"He ties the building blocks together with structural and behavioral metadata, allowing simple, interpreted macros to drive everything from database access, screen layouts and many aspects of software development normally embedded directly into the software program. The rapid deployment effect this creates allows developers to perform simple surgical application changes, or rapid sweeping rework / enhancement - without changing compiled software.\"</i>",
      "id": "74acd5e37de41078559351c8b640a653"
    },
    {
      "type": "html",
      "text": "\nAlso see [[Adaptive Object Model]], which [[Software Development Ona Leash]] seems to be an instance of.",
      "id": "c0ec3d94d852b5712223df69a5a1d83b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "<i>All Quake-, Unreal- and Halflife-based games have architectures like this. I doubt they were the first games to use these techniques though.</i>",
      "id": "6a629d2c28a880cc0b6191060b8f5135"
    },
    {
      "type": "html",
      "text": "\nMany games written on the BBC micro 20 years ago used this pattern, with a combination of BBC BASIC for the game logic and assembler routines for the graphics.",
      "id": "26c4f899d23b5116dc0307794e2f7994"
    },
    {
      "type": "html",
      "text": "\nI used this pattern for some numerical simulation work in chemical engineering in the early 1970's. This was on a Honeywell computer which had its main language as an interpreted BASIC.  We had a FORTRAN compiler and could add  compiled modules to the operating system which could then be called from BASIC. By modern standards we were very tight on memory, 16k if I remember correctly. The computer was a Honeywell 316. -- [[John Fletcher]]",
      "id": "4992b4e8ed23b4576eca240589476bfa"
    },
    {
      "type": "html",
      "text": "\nThis pattern is used a lot by Python programmers, usually with the aid of tools like the [[Simplified Wrapper And Interface Generator]]. [[John Ousterhout]] wrote a paper in 1998 comparing development times for similar projects using system languages like C and scripting languages like TCL:  [http://home.pacbell.net/ouster/scripting.html home.pacbell.net]",
      "id": "e87fed5abfd627ba92059f3aee00e2f8"
    },
    {
      "type": "html",
      "text": "\n[[Nat Pryce]] also wrote a set of patterns for scripting languages: [http://www.doc.ic.ac.uk/~np2/patterns/scripting/index.html www.doc.ic.ac.uk]",
      "id": "7ca71a7e35e295856894d884874879e2"
    },
    {
      "type": "html",
      "text": "-- [[Dave Kirby]]",
      "id": "1e687273806bf309e4fcd1ef4ca7fe47"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "My [[Htag Language]] is exactly such a [[Symbiotic Pair]]. With [[Delphi Language]] of course being the symbiont. [[Htag Language]] provides the efficient [[High Level]] constructs while [[Custom Commands]] written in [[Delphi Language]]  provide the oomph and maximum flexibility.",
      "id": "0f30fb1238b41e9f147542abf14ee45d"
    },
    {
      "type": "html",
      "text": "-- [[Sven Neumann]]",
      "id": "21cd7ce09cc62dbf5974b8e9d412f923"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "How about this problem: I have a small section of code that must be in C (to read a from an external device) and the rest of the code needs to write to a MySQL database. I was originally wanting to do this using Python, but the MySQL libraries don't look as well developed as perl's. So, I'm trying to decide how I want to use perl to access these C functions. I've used the Inline::C module and it seems to work, but is there a better way to do this? I'm developing this under the linux platform so is there a way you could simply compile any C file and then access it's functions directly from perl without using the Inline::C module? Overall, I've found that most languages make it difficult to [[Alternate Hard And Soft Layers]]. --[[Blake Mason]]",
      "id": "5b713074f33e63f3dee6ce93767f7709"
    },
    {
      "type": "html",
      "text": "<i>[[Ruby Language]] is very nice for writing C modules. [[Python Language]] is less good, but still good. [[Perl Language]] is absolutely a mess, but not impossible to work with. Try perldoc perlxstut to start with.</i> -- [[Robert Church]]",
      "id": "121dcf29b7f37e655b64b1aa8bf3ae2b"
    },
    {
      "type": "html",
      "text": "\nBefore the family of Inline modules existed that was certainly true, but e.g. Inline::C changes that. --[[Johan Lindstrom]]",
      "id": "4dd256fa90aa4abbde5ecbfb36b78f01"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "See also: [[Multi Language Refactoring]]",
      "id": "a9e0c749347b2a7b67fc9c09f0bd7604"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "<b>One big drawback with this approach is how much development time you will spend <i>in between</i> the layers. The time to write and debug the transitions between the layers can quickly become significant. It becomes another design task to construct the API, and the goals are moving targets as your project progresses. -- [[An Aspirant]]</b>",
      "id": "345416be7add2e28bc46ffb744fdbed4"
    },
    {
      "type": "html",
      "text": "\nOne of the recurrent problems with many large projects, that leads to their failure or to large delays (a large percentage of the total numbers of projects), is that interfaces between lower level layers and \"middleware\" or applicative layers are underspecified and, (worse) that by sloppy design or laziness of the programmers (which one cannot always control in large teams), the layers become [[Extremely Interstrangled]], eventually leading to spaghetti designs. ",
      "id": "54c43006e2770e9ed516143926bb3b65"
    },
    {
      "type": "html",
      "text": "\nIn addition to adding flexibility when programming the applicative layers, where the vast majority of bugs reside and where 80 to 90% of the programming effort is spent, using two different languages forces to make the distinction between lower layers and applicative layers clear. There is no possible trade-off.",
      "id": "dd8474d4aa7955b625963ea1069e481a"
    },
    {
      "type": "html",
      "text": "\nIn my experience, in large projects (> 20 man-years) the time taken at the beginning for designing well-specified interfaces, when the project is easily manageable, is never wasted. It is slow at the beginning, but it ALWAYS pays towards the middle and the end of the project, when things get complicated.\nIn the contrary, projects that make wrong design decisions at the beginning because they are in a hurry to show quick results to the client will carry the burden all along the course of development, and this burden will always get heavier along the road.",
      "id": "c4e4118a27c8d39305d732b4b0006a87"
    },
    {
      "type": "html",
      "text": "\nMost importantly, the larger and the more complex the project, the more acute these problems are. ",
      "id": "fb4c24ae04f6e070e74ac6c9f19ffa47"
    },
    {
      "type": "html",
      "text": "<i>Also: someone may well have done much of the work for you nowadays. For instance, the [[Boost Python Library]] deals with C++/Python interoperation. You'll still have to do some of the work, but it might not be as hard as you think. That doesn't mean it'll be easy of course!</i>",
      "id": "3c5f06e607295c148f12fcabade87926"
    },
    {
      "type": "html",
      "text": "\nThere is also the [[Simplified Wrapper And Interface Generator]] which can interface many other languages to C and C++. -- [[John Fletcher]]",
      "id": "ca82fdaabe1ecdb3d16c3bb4cf246544"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "As another example of this pattern, what about LPMuds?, there we have a hard layer, the driver, and a soft layer, the mudlib, where the driver and mudlib may call into each other, the mudlib may override driver-supplied functions with different ones, and functions may be moved from the mudlib into the driver for speed. -- [[Martin Rudat]]",
      "id": "3f8b8b704e6a780f1aa5e0b57ae2d09f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "Much of this discussion has considered using hard/soft to resolve CPU bandwidth limitations; the other constraint is memory, and that one is tricker to resolve in a soft/hard split. Many of the preferred \"soft\" languages have bulky memory usage. Replacing data structures built there with the hard, lower-level ones can pose a nasty architecturing issue unless the original data structure was used in a few well-defined, uniform ways. This is probably the number one limitation that stops \"maximally soft\" programming style from being usable in all projects.",
      "id": "3a0a8e7369fadfaf57132a63baf9c0d3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "See [[Tool Chain]], [[Xslt As Soft Layer]], [[Low Level Parts Written In Cee]], [[Symbiotic Languages]], [[Lush Language]]",
      "id": "dc421d57f32c674f094cd48898677cde"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "973a18b80f8269ae9f8184e3ab102804"
    },
    {
      "type": "html",
      "text": "[[Category Pattern]]",
      "id": "e7c606503eeccbf77dd6fa77ac00d24d"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?AlternateHardAndSoftLayers c2.com]",
      "id": "20eecd56efe243136abb353bb3c8b64e"
    }
  ],
  "journal": [
    {
      "date": 1419275323000,
      "id": "42e810f5fd7e58a4523efee039b3ae95",
      "type": "create",
      "item": {
        "title": "Alternate Hard And Soft Layers",
        "story": [
          {
            "type": "html",
            "text": "<b>[[Pattern Form]] Version:</b>",
            "id": "8e3bf88238a378d3211f67cf14b8bb3c"
          },
          {
            "type": "html",
            "text": "<b>Aliases:</b> Scripting System, Interpreter, Extensible Middle Layer",
            "id": "9db5be7ee1546686fd6f642877df5b11"
          },
          {
            "type": "html",
            "text": "<b>Problem:</b>\nThe mapping between the primitives available and the driver that\ncontrols them is too static. Combinations of the primitives are\nlimited, and no universal data type exists to transfer data\nbetween components of the system.",
            "id": "c0d36ab34e206929fda1c6e2d69eea60"
          },
          {
            "type": "html",
            "text": "<b>Context:</b>\nThe primitive elements of the system are used in a limited but\neffective way. The applications serve existing needs using well-\ndefined business rules. New needs are emerging that do not have\nwell-defined business rules, but must be integrated as quickly\nas the rules are defined. The success of integrating the new\nneeds into the system depends in part on the changes to the\nwork flow that supporting the new features produces.",
            "id": "9fa4b428b3be41d45b50d51ee447bd58"
          },
          {
            "type": "html",
            "text": "<b>Forces:</b>\nA context for rapid experimentation and novel functionality requires\nnew infrastructure. New data types must be created to accommodate\nthe need for a universal transport mechanism between all existing\nelements in the system. The added complexity of introducing such\ninfrastructure to the system could markedly reduce efficiency of the\nexisting system functions.",
            "id": "f622ad5d23a4f5d5f0c6b99e874e7fb6"
          },
          {
            "type": "html",
            "text": "<b>Solution:</b>\nBuild an extensible interpreter environment that makes all the\nprimitive elements of the existing system available via universal\ndata types. Provide 'exec' and 'eval' functions that create localized\nsub-environments where both inputs and outputs are defined in terms\nof universal data types.",
            "id": "02b9340cf473fc0b535ab51b306698ce"
          },
          {
            "type": "html",
            "text": "<b>Resulting Context:</b>\nA single generic driver system provides an entry point for a data type\nthat relates the combinations and relationships of the primitive elements.\nThe relationships could be pipelines, multiplexing, or combining data in\norder to create the desired results. All the previous functions are\nsupported, but a much larger context has been created at the same time.",
            "id": "9ed42d03186b9649a0edd028e57f8c75"
          },
          {
            "type": "html",
            "text": "<b>Design Rationale:</b>\nIf a system is designed such that its driver layer can be removed from\na scripting layer, and the scripting layer can execute strings composed\nby the script (like back-quotes in the Unix shell), then it achieves\nfractal complexity. The scripting layer sits on top of atomic\nfunctionality like regular expressions, mathematical functions,\nvariables, database access, file control, etc. An extended concrete\nexample:  Customize a web server to take URL's that mapped to HTML\npages with embedded Tcl, then run as server-side includes. Cache the\npre-processed page as a Tcl script, rebuilding it if the source file\ntimestamp changed.  Customize the Tcl interpreter to add database\naccess and some native Tcl functions for convenience.  Since Tcl has an",
            "id": "06234b3baf4e7204842b8a3952a5f7e0"
          },
          {
            "type": "html",
            "text": "<i>exec</i> functionality, code can be stored in the database and coupled\nwith a driver script for any template page. This kind of structure uses\nonly 3 layers to achieve 2n+1 (n=1->k) <i>virtual layers</i>.  The key seems\nto be that if the interpreter operates unaware of where it is being\ncalled <i>from</i>, then a wonderful simplicity suddenly arises, since the\nlevel of <i>reusability</i> of the interpreter itself jumps a level. The\nlanguage itself allows for localized contexts that are unaware (at\nleast directly) of where they are invoked from.  Writing your compiler\nin the language it compiles is a similar idea, kind of like writing the\nYACC specification <i>in</i> YACC syntax (but that is not for the faint at\nheart).",
            "id": "eb8d34a5501d41f1a6b6c10b73708e58"
          },
          {
            "type": "html",
            "text": "<b>Examples:</b>\nSh, Ksh, Csh, Perl, [[Tool Command Language]] (Tcl), Python, [[Lua Language]], Java (not strongly), [[Bean Shell]] (for Java), compilers written in the language they compile, [[Java Script]], networks of WWW servers.",
            "id": "1387ae0f7b48e5d748e7dd214adc6239"
          },
          {
            "type": "html",
            "text": "<b>Related Patterns:</b>\n[[Decide On The Primitives]], [[Create Flexible Messaging]], ([http://laputa.isdn.uiuc.edu/metamorphosis/metamorphosis.html laputa.isdn.uiuc.edu] -- [[Brian Foote]]), [[Data Driven Programs]]",
            "id": "70f4a0baee9730623681d049f1591350"
          },
          {
            "type": "html",
            "text": "-- [[David Cymbala]]",
            "id": "b7b9b1a7406be85f7a693abccade6c8d"
          },
          {
            "type": "html",
            "text": "\nCouldn't find the metamorphosis paper at the cited URL - I assume it is now here: [http://www.laputan.org/metamorphosis/metamorphosis.html#Metamorphosis www.laputan.org] --[[Paul Morrison]]",
            "id": "fc90df4009168a5fa9323be9c2cd2173"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "<b>Short version:</b>",
            "id": "7115d6259ad12df487063bc0a3406b2b"
          },
          {
            "type": "html",
            "text": "\nBy virtue of the first rule of optimization, go ahead and write most of your code in the highest level language you can find.",
            "id": "83e9611468f354111a41ed936e2b69b4"
          },
          {
            "type": "html",
            "text": "\nBy virtue of the third rule of optimization, when you must, use a profiler and find the slow parts of your program.  Take those parts, and write them in a lower-level language.",
            "id": "08280e96610b2c95d9961b8af9e8c2fd"
          },
          {
            "type": "html",
            "text": "\nSee [[Rules Of Optimization]]",
            "id": "26a08d3597bfdb1a224d562304c362aa"
          },
          {
            "type": "html",
            "text": "(Almost every language out there lets you drop down to C or the like.  Some languages even make it easy (See: Perl's Inline::C module: [http://search.cpan.org/~ingy/Inline-0.44/C/C.pod search.cpan.org] and Python's Pyrex: [http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/ www.cosc.canterbury.ac.nz])).",
            "id": "e355073b4a21e7ee774b20e99e9ee8e7"
          },
          {
            "type": "html",
            "text": "<i>So why not use something like [[Common Lisp]], where you have all of this in one place?</i>",
            "id": "95fac378130ede89000c7e898c34579f"
          },
          {
            "type": "html",
            "text": "\nWas that a joke?",
            "id": "b0151fe47bdb0f90e4603f50e7208bcc"
          },
          {
            "type": "html",
            "text": "<i>Doesn't sound like one to me. Lisp has a reputation for being slow, but there are (both free and commercial) Common Lisp implementations that can provide speed near that of C, C++, or Fortran when the code is written for speed. Most Common Lisp implementations provide some sort of built-in profiling facility, as well as the ability to call C code.</i>",
            "id": "fad7edb7eb2bd419fe25ae82ab42f087"
          },
          {
            "type": "html",
            "text": "\nI've been learning [[Common Lisp]], and although it's possible to write code with speed comparable to C, it's more difficult.  You have to fight the inherent dynamicity of the language, and the higher level abstractions are more difficult to mentally correlate with the assembly code it will compile to.  Experts can do it, but it'll take longer to become an expert.  All in all, I'd rather do C for low level code, though avoiding FFI ugliness and having use of real macros may make it worth using [[Common Lisp]].",
            "id": "9f00fedda7dd62176a92c9f4fa93500a"
          },
          {
            "type": "html",
            "text": "<i>I'd have to disagree.  It took me about 2 weeks to learn how to generate really efficient code in CL (cmucl or sbcl).  There are, granted, some exceptions a problem areas that can be a bit of a pain (some related to the fact that those compilers are maintained by volunteers).  But you say it is more difficult.  Do you mean more difficult than writing non-optimized CL code?  I'd agree.  More difficult than writting fast C code?  In that case, I'd say not much.  I've written a lot more high-performance C than CL, also.  Writing fast CL code to a large degree involves putting in things you have to do *all the time* in C anyway, so it isn't a loss there.  High level abstractions can be a problem, I agree, but that has nothing to do with the language you are using.  Well, possibly in the case that a more powerful language (in this sense) like CL makes it easy to do things you would hesitate to even try in C, I guess that is true.  But that is not the languages fault --- if you want high performance code you have to understand something about performance, after all.</i>",
            "id": "6a6efac8bc435143f047799f94dad4c8"
          },
          {
            "type": "html",
            "text": "\nSupposedly (because I've only read about this, not used it myself), Lisp implementations support both fast development and fast execution by producing very fast code when you declare the types of variables.  You can develop in the dynamically typed Python/Perl mode and then, when you identify bottlenecks, add type declarations to allow code optimization based on static typing a la C++.  Dynamism and efficiency, without rewriting your code in a different language.  Also (in my experience, not just supposedly), Lisp macros allow you to disguise obfuscatory efficiency hacks that would force you to write less readable code in other languages.",
            "id": "895f13c2e26115ad479f04a80f321052"
          },
          {
            "type": "html",
            "text": "\nIn general, writing simple code in most cases and then marking up critical sections to help the compiler generate efficient code is an old trick that in most languages is considered arcane and only done using nonstandard extensions.  When I write Python and C++ the biggest <b>visual</b> difference is all the type specifications.  Why have two different languages?  Future languages will, I hope, be designed with multiple modes of programming and execution in mind, so that they support the smooth evolution of code from stab-in-the-dark hacking to dynamic scripting to statically optimized application or library code.  I'm hoping to find that already implemented in Lisp.  (The Lisp advocates keep pointing out how many \"new\" features have been available in Lisp for years, so I figure I should turn to Lisp for the functionality that I expect to reach the mainstream ten years from now.)",
            "id": "d3805fd6b6e5e8b7f351d81c98812494"
          },
          {
            "type": "html",
            "text": "<i>Common Lisp isn't good enough here not because it isn't sufficiently good hard language, but because it isn't sufficiently good soft language. This is simply because of the unavailability of the necessary breadth of maintained and widely used (and thus better bug-fixed) libraries available from the intarwebs, forcing a DIY approach which interferes with RAD. Just compare the set of better than alpha-grade libraries/frameworks significantly (or at all!) updated in the last two years for CL and Python/Ruby. You could say that this is not a language problem as such, but that's cold comfort in the real world where vaporware is worth zilch and actually existing software matters. It's also easy to get support for Python/Ruby from the net, whereas lispers tend to be more likely to skin you (or your newbie co-developer) alive than help you, which will again slow you down comparatively speaking.</i>",
            "id": "d50155cc46f4a6db987e25efeeb1a5d2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "\nAs one authors, one can experiment in the soft language, and then refactor repeatedly used or time critical functions into the hard language. Decision to migrate influences future abstraction trade-offs. Functions in the hard layer abstract as dynamic dispatch with at least the Adapter [[Design Pattern]]. Functions in the soft layer abstract by replacing their source files.",
            "id": "44112efe1206889b9079ef7c083fa189"
          },
          {
            "type": "html",
            "text": "\nThe result over time is a system has grown a perfect [[Application Programming Interface]] in its hard layer; one that satisfies all the needs of the soft layer above it as if by magic. This comprehensiveness can surprise initiates to the system.",
            "id": "44734159539d2b091d73dbd22601fad0"
          },
          {
            "type": "html",
            "text": "<i>\"Granma what a big API you have!\"</i>",
            "id": "07451cd4315c773259701e01d041061a"
          },
          {
            "type": "html",
            "text": "<i>\"All the better to [[Embrace And Extend]] you with, my dear!\"</i>",
            "id": "cd71bb4d33a0e588834414fadbffed98"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "\nWriting your compiler in the language it compiles is a similar idea, kind of like writing the YACC specification <i>in</i> YACC syntax (but that is not for the faint at\nheart).",
            "id": "b53a9e4af4c643b72eef5d5d0ae65ce3"
          },
          {
            "type": "html",
            "text": "<i>Sure it is. The only slightly hard part about writing a Yacc grammar for Yacc is that it is an LALR(2) language whereas Yacc only accepts LALR(1) grammars, but this is trivial to work around, in the same way that one always does Yacc workarounds: have the lexer do it. In this case, have the lexer do the extra one-token lookahead (it comes up on RULENAME ':'...the lexer has to lookahead and see the ':' in order to know to return RULENAME rather than NAME). Everything else about Yacc in Yacc is really easy. And I've done this, so I'm not just speculating. -- dm</i>",
            "id": "c07a4bc7315c77fb6f2e78a8c73fde64"
          },
          {
            "type": "html",
            "text": "\nA trendy version of that is the part of the XML Spec where they describe DTD syntax using much the same syntax they are describing, as DTD is a lot like BNF. --[[Daniel Earwicker]]",
            "id": "47ccfb9d3c2b384ea7a9ae6d13cab546"
          },
          {
            "type": "html",
            "text": "\nThe language of XML Schemas can be described in every detail by an XML Schema.  The Schema committee worked hard to make sure this was so.  They kept a working schema describing the language, and I think it is actually the \"authoritative\" version (if it interprets something differently from the english spec, the schema takes priority).",
            "id": "be92e4aec6e340818ab38ef494b92501"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "\nDrawback No 1. Hard languages tend to have [[Static Type Safety]]. Soft ones usually don't. So square pegs end up in round holes, and who's going to warn ya? Eh? -- [[Daniel Earwicker]]",
            "id": "121b8e16478910b6d1f241b9e3d53338"
          },
          {
            "type": "html",
            "text": "<i>Static languages perform type checks at compile time; dynamic languages perform type checks at run time.  (Static languages such as Haskell and O'Caml can be good soft languages.)  It's reasonable to worry that when static and dynamic languages meet, there will be some confusion about who should check, resulting in uncaught errors.  \"Did you check?\"  \"No, I thought you checked!\"  In practice, types are checked in the dynamic language at the interface between the two languages.  For example, before calling a C++ function, Boost.Python checks the Python argument types against the C++ function signature and throws an exception if the types aren't compatible.  For example, when calling the C++ function void foo::bar(std::string), Boost.Python allows foo.bar('Hi there') (and automatically converts 'Hi there' to a C++ string), but foo.bar(3) results in an exception being raised.  The run-time checking on the soft side makes up for the lack of run-time checking on the hard side.</i>",
            "id": "123f8802997a15335548fd60e4071dea"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "\nMy favorite example of this pattern is modern 3D shooter games (!). Quake 3: Arena has a particularly beautiful architecture -- the game executable is merely a library of optimized C code that renders 3D objects, plays sounds, and synchronizes data among networked players. The game logic itself (physics, weapons, scoring, etc) runs atop the engine in a flexible virtual machine. Game code communicates with the engine through system calls or \"traps\" (there is also a small shared memory segment for high-bandwidth communication).   ",
            "id": "664498d7850b3ff769c75f6b9fcfaa81"
          },
          {
            "type": "html",
            "text": "\nIn Quake 3 the game code is written in a dialect of C, and then compiled down to bytecode (which the engine may JIT compile for extra speed). This means VM programs can be run on any CPU to which the engine has been ported. Also, the VM environment is sandboxed to prevent malicious or buggy game code from harming your system. (implementing the game logic as native CPU code in a DLL - the approach taken by Quake 2 and Halflife - affords no such protection, and is platform-specific).",
            "id": "3c09e84a560dd1201c96af0901dd47e2"
          },
          {
            "type": "html",
            "text": "\nThe advantage of this split between engine and game code is that you can swap out the game logic without recompiling the engine. Also, the discipline of maintaining a clean, well-defined \"system call\" API is a great benefit to third parties who want to write new extensions for the game. ",
            "id": "dc02bfbde63028773a075369412f5c35"
          },
          {
            "type": "html",
            "text": "\nIt is also possible to make the game engine API available through other languages. I've seen versions of Quake that support game code running in a standard Java VM and in a Python interpreter.",
            "id": "40887f8254f0620bf1dae13587ce12d8"
          },
          {
            "type": "html",
            "text": "\nAll Quake-, Unreal- and Halflife-based games have architectures like this. I doubt they were the first games to use these techniques though.",
            "id": "0da20dcebd4deb8d1232700f56127cb3"
          },
          {
            "type": "html",
            "text": "-- Dan Maas",
            "id": "3b346cde31bcdd5ae714c32651834cc9"
          },
          {
            "type": "html",
            "text": "<i>Interesting.  Are the shared mem writes bounds checked?  Any idea where to get the source? --[[An Aspirant]]</i>\nYes, all memory access by the virtual machine code is bounds-checked for safety (even in JIT compiled code, there is still a check). The shared memory segment exists as part of the virtual machine's heap, so it is still safe.. The engine source code for Quake 1 and 2, and the game source code for Quake 1-3 are available at ftp.idsoftware.com. (Quake I has a similar virtual machine architecture, however Quake II uses a native DLL for the game code)",
            "id": "ad7cb220af1e55274c4514fec345e444"
          },
          {
            "type": "html",
            "text": "\nWhat about Z-code ([[Zork Code]])?",
            "id": "d3415c605507a45d7270cb19d523d0b3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "\nThis seems like a really powerful pattern. I have lots of things to say!",
            "id": "0b77495c6091b4763f4f323797f474b7"
          },
          {
            "type": "html",
            "text": "\nSome more concrete examples would be helpful; i suppose the obvious one is unix shell script, which has almost no useful operations of its own and yet is really rather powerful.",
            "id": "bca8ab1ba96c2b511824178617ff8958"
          },
          {
            "type": "html",
            "text": "\nThe name of this pattern is a bit confusing; is 'alternate' a verb or an adjective? Either way, it seems to suggest a system with many layers, alternately soft and hard, but it seems to actually talk about a system with just two layers, a hard low-level one (the components) and a soft high-level one (the script). Perhaps a better name would be [[Soft Over Hard]]?",
            "id": "0e9d88a5e532d4b56c38ce87b631664f"
          },
          {
            "type": "html",
            "text": "\nThe idea that big, evolving systems are best built using two layers, one hard and one soft, implies that such projects will need two languages, one hard and one soft (where a [[Hard Language]] is what we usually call a [[Programming Language]] and a [[Soft Language]] is what we often call a [[Scripting Language]]). This suggests that attempting to invent languages to build big systems is folly; rather, we need to develop <i>pairs</i> of languages, one hard and one soft, that work well together - [[Symbiotic Languages]], if you will. Can we observe this anywhere in the wild? Perhaps [[Micro Soft]] is doing it with [[Cee Sharp]]/[[Cee Plus Plus]] or [[Visual Basic]]/[[Cee Plus Plus]]; the scriptable Office apps certainly looks a bit like [[Alternate Hard And Soft Layers]]. One could argue that web browsers, supporting [[Java Script]] and [[Java Applet]]s, are a hard-soft environment, but to my knowledge, nobody has actually built a system in which modular applets are composed into an application on a single page using [[Java Script]], but it is certainly possible.",
            "id": "5c887a6dc5b8447b6912a44f06381bac"
          },
          {
            "type": "html",
            "text": "\nThe idea of [[Alternate Hard And Soft Layers]] depends absolutely on the assumption that no one language can provide enough performance to be used in the hard layers and enough flexibility to be used in the soft layers; is this really true? [[Small Talk]] and [[Self Language]] are both very flexible and fast to develop, and seem ideal for the [[Soft Layer]], but modern VMs actually make them run quite fast (not as fast as C yet, but getting there); could they be used for both sets of layers, thus eliminating this distinction? I suppose one could argue that since the VM, and a set of primitive operations, is implemented in C that constitutes the [[Hard Layer]], and it's just a lot smaller and less application-specific than discussed above, but i don't think i'd buy this.",
            "id": "4843c525609a7a58b359ffa363d4cb91"
          },
          {
            "type": "html",
            "text": "-- [[Tom Anderson]]",
            "id": "761cd1f8149aebaa9b2e0818a95242aa"
          },
          {
            "type": "html",
            "text": "<i>Lisp has this feature; extremely high level but with native code compilation..</i> ",
            "id": "57f03951a64a9c052d3b14cd6c052fd3"
          },
          {
            "type": "html",
            "text": "\nThis misses the point. The issue is not interpretation versus native code compilation, but rather strategies for leveraged optimization and trade-offs between clarity and efficiency. It applies to replacing [[Cee Language]] code with [[Assembly Language]] code just as much as it does to replacing [[Lisp Language]] code with [[Cee Language]] code. ",
            "id": "6eb725097283961679cd8d7b156cadf3"
          },
          {
            "type": "html",
            "text": "<i>How about replacing Lisp code with tighter Lisp code?</i>",
            "id": "c0640a5b06eed0a6766fc4a1bb793657"
          },
          {
            "type": "html",
            "text": "\nLet us say that you have a large program written in (to use my own preference) [[Scheme Language]]. By using the high level language, with a suitably optimizing compiler, you are able to write it in a manner that is both efficient and elegant - but there's one a single large hot-spot which is slowing down the whole program, even after careful refactoring. This one function needs to run as fast as possible, and any speed improvement in it would affect the overall performance of the program.",
            "id": "da09e709b17db58201d9dfa04c56c9ec"
          },
          {
            "type": "html",
            "text": "\nAt that point, wouldn't sacrificing 5 lines of Scheme code in exchange for, say, 50 lines of optimized Assembly code to get an speed-up of an order of magnitude, be a worthwhile tradeoff? If the rest of the program is well-written, it shouldn't even present a portability problem - after all, 50 lines is not very much even in assembly. Even given the [[Foreign Function Interface]] overhead, this would be a Good Thing.",
            "id": "7bb6a6e0b344ec64fb301ca7c13c8266"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "[[Objective Cee]] has the soft and hard languages in one \"language\" -- most of the flexibility of [[Small Talk]] in the OO extensions, and the 'hard' layer of C/C++... Apple's [[Apple Script]] Studio puts an even \"softer\" layer -- [[Apple Script]] -- on top of the gui classes provided by Cocoa implemented in [[Objective Cee]]. --[[Keith Ray]]",
            "id": "3e8c1ac6082e096d4f02ead9b856131a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "[[Forth Language]] traditionally has both hard and soft layers in the same language.  Normal words are compiled to threaded-interpreted code, but you had the option to use the assembler wordset to recode frequently used and bottleneck words as CODE words.  Such words had full access to the machine's instruction set and could be referenced just like normally compiled words.  Naturally, most of the core wordset of a Forth system (DUP, DROP, etc.) were implemented as CODE words.  (Of course, Forth is pretty low-level itself, so this might be considered alternating Hard and Harder layers. Same with C with inline assembly.)",
            "id": "03016b3543bdc12d4fafab5b7039fea5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "\nThe book [[Software Development Ona Leash]] [ISBN: 1893115917] seems to support the \"[[Alternate Hard And Soft Layers]]\" proposal.",
            "id": "738cf5c225f59f30b0509213cdece9c8"
          },
          {
            "type": "html",
            "text": "\nFrom Amazon's Editorial Review:",
            "id": "87e4d9be1862bb3181eb4455f62d1f2e"
          },
          {
            "type": "html",
            "text": "<i>\"He ties the building blocks together with structural and behavioral metadata, allowing simple, interpreted macros to drive everything from database access, screen layouts and many aspects of software development normally embedded directly into the software program. The rapid deployment effect this creates allows developers to perform simple surgical application changes, or rapid sweeping rework / enhancement - without changing compiled software.\"</i>",
            "id": "74acd5e37de41078559351c8b640a653"
          },
          {
            "type": "html",
            "text": "\nAlso see [[Adaptive Object Model]], which [[Software Development Ona Leash]] seems to be an instance of.",
            "id": "c0ec3d94d852b5712223df69a5a1d83b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "<i>All Quake-, Unreal- and Halflife-based games have architectures like this. I doubt they were the first games to use these techniques though.</i>",
            "id": "6a629d2c28a880cc0b6191060b8f5135"
          },
          {
            "type": "html",
            "text": "\nMany games written on the BBC micro 20 years ago used this pattern, with a combination of BBC BASIC for the game logic and assembler routines for the graphics.",
            "id": "26c4f899d23b5116dc0307794e2f7994"
          },
          {
            "type": "html",
            "text": "\nI used this pattern for some numerical simulation work in chemical engineering in the early 1970's. This was on a Honeywell computer which had its main language as an interpreted BASIC.  We had a FORTRAN compiler and could add  compiled modules to the operating system which could then be called from BASIC. By modern standards we were very tight on memory, 16k if I remember correctly. The computer was a Honeywell 316. -- [[John Fletcher]]",
            "id": "4992b4e8ed23b4576eca240589476bfa"
          },
          {
            "type": "html",
            "text": "\nThis pattern is used a lot by Python programmers, usually with the aid of tools like the [[Simplified Wrapper And Interface Generator]]. [[John Ousterhout]] wrote a paper in 1998 comparing development times for similar projects using system languages like C and scripting languages like TCL:  [http://home.pacbell.net/ouster/scripting.html home.pacbell.net]",
            "id": "e87fed5abfd627ba92059f3aee00e2f8"
          },
          {
            "type": "html",
            "text": "\n[[Nat Pryce]] also wrote a set of patterns for scripting languages: [http://www.doc.ic.ac.uk/~np2/patterns/scripting/index.html www.doc.ic.ac.uk]",
            "id": "7ca71a7e35e295856894d884874879e2"
          },
          {
            "type": "html",
            "text": "-- [[Dave Kirby]]",
            "id": "1e687273806bf309e4fcd1ef4ca7fe47"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "My [[Htag Language]] is exactly such a [[Symbiotic Pair]]. With [[Delphi Language]] of course being the symbiont. [[Htag Language]] provides the efficient [[High Level]] constructs while [[Custom Commands]] written in [[Delphi Language]]  provide the oomph and maximum flexibility.",
            "id": "0f30fb1238b41e9f147542abf14ee45d"
          },
          {
            "type": "html",
            "text": "-- [[Sven Neumann]]",
            "id": "21cd7ce09cc62dbf5974b8e9d412f923"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "How about this problem: I have a small section of code that must be in C (to read a from an external device) and the rest of the code needs to write to a MySQL database. I was originally wanting to do this using Python, but the MySQL libraries don't look as well developed as perl's. So, I'm trying to decide how I want to use perl to access these C functions. I've used the Inline::C module and it seems to work, but is there a better way to do this? I'm developing this under the linux platform so is there a way you could simply compile any C file and then access it's functions directly from perl without using the Inline::C module? Overall, I've found that most languages make it difficult to [[Alternate Hard And Soft Layers]]. --[[Blake Mason]]",
            "id": "5b713074f33e63f3dee6ce93767f7709"
          },
          {
            "type": "html",
            "text": "<i>[[Ruby Language]] is very nice for writing C modules. [[Python Language]] is less good, but still good. [[Perl Language]] is absolutely a mess, but not impossible to work with. Try perldoc perlxstut to start with.</i> -- [[Robert Church]]",
            "id": "121dcf29b7f37e655b64b1aa8bf3ae2b"
          },
          {
            "type": "html",
            "text": "\nBefore the family of Inline modules existed that was certainly true, but e.g. Inline::C changes that. --[[Johan Lindstrom]]",
            "id": "4dd256fa90aa4abbde5ecbfb36b78f01"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "See also: [[Multi Language Refactoring]]",
            "id": "a9e0c749347b2a7b67fc9c09f0bd7604"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "<b>One big drawback with this approach is how much development time you will spend <i>in between</i> the layers. The time to write and debug the transitions between the layers can quickly become significant. It becomes another design task to construct the API, and the goals are moving targets as your project progresses. -- [[An Aspirant]]</b>",
            "id": "345416be7add2e28bc46ffb744fdbed4"
          },
          {
            "type": "html",
            "text": "\nOne of the recurrent problems with many large projects, that leads to their failure or to large delays (a large percentage of the total numbers of projects), is that interfaces between lower level layers and \"middleware\" or applicative layers are underspecified and, (worse) that by sloppy design or laziness of the programmers (which one cannot always control in large teams), the layers become [[Extremely Interstrangled]], eventually leading to spaghetti designs. ",
            "id": "54c43006e2770e9ed516143926bb3b65"
          },
          {
            "type": "html",
            "text": "\nIn addition to adding flexibility when programming the applicative layers, where the vast majority of bugs reside and where 80 to 90% of the programming effort is spent, using two different languages forces to make the distinction between lower layers and applicative layers clear. There is no possible trade-off.",
            "id": "dd8474d4aa7955b625963ea1069e481a"
          },
          {
            "type": "html",
            "text": "\nIn my experience, in large projects (> 20 man-years) the time taken at the beginning for designing well-specified interfaces, when the project is easily manageable, is never wasted. It is slow at the beginning, but it ALWAYS pays towards the middle and the end of the project, when things get complicated.\nIn the contrary, projects that make wrong design decisions at the beginning because they are in a hurry to show quick results to the client will carry the burden all along the course of development, and this burden will always get heavier along the road.",
            "id": "c4e4118a27c8d39305d732b4b0006a87"
          },
          {
            "type": "html",
            "text": "\nMost importantly, the larger and the more complex the project, the more acute these problems are. ",
            "id": "fb4c24ae04f6e070e74ac6c9f19ffa47"
          },
          {
            "type": "html",
            "text": "<i>Also: someone may well have done much of the work for you nowadays. For instance, the [[Boost Python Library]] deals with C++/Python interoperation. You'll still have to do some of the work, but it might not be as hard as you think. That doesn't mean it'll be easy of course!</i>",
            "id": "3c5f06e607295c148f12fcabade87926"
          },
          {
            "type": "html",
            "text": "\nThere is also the [[Simplified Wrapper And Interface Generator]] which can interface many other languages to C and C++. -- [[John Fletcher]]",
            "id": "ca82fdaabe1ecdb3d16c3bb4cf246544"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "As another example of this pattern, what about LPMuds?, there we have a hard layer, the driver, and a soft layer, the mudlib, where the driver and mudlib may call into each other, the mudlib may override driver-supplied functions with different ones, and functions may be moved from the mudlib into the driver for speed. -- [[Martin Rudat]]",
            "id": "3f8b8b704e6a780f1aa5e0b57ae2d09f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "Much of this discussion has considered using hard/soft to resolve CPU bandwidth limitations; the other constraint is memory, and that one is tricker to resolve in a soft/hard split. Many of the preferred \"soft\" languages have bulky memory usage. Replacing data structures built there with the hard, lower-level ones can pose a nasty architecturing issue unless the original data structure was used in a few well-defined, uniform ways. This is probably the number one limitation that stops \"maximally soft\" programming style from being usable in all projects.",
            "id": "3a0a8e7369fadfaf57132a63baf9c0d3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "See [[Tool Chain]], [[Xslt As Soft Layer]], [[Low Level Parts Written In Cee]], [[Symbiotic Languages]], [[Lush Language]]",
            "id": "dc421d57f32c674f094cd48898677cde"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "973a18b80f8269ae9f8184e3ab102804"
          },
          {
            "type": "html",
            "text": "[[Category Pattern]]",
            "id": "e7c606503eeccbf77dd6fa77ac00d24d"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?AlternateHardAndSoftLayers c2.com]",
            "id": "20eecd56efe243136abb353bb3c8b64e"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1660216423073
    }
  ]
}