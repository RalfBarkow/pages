{
  "title": "Graph",
  "story": [
    {
      "type": "markdown",
      "id": "6cbc0856f1310861",
      "text": "[[Croquet]] requires that the replicated [[Model]] declare what classes will be present in the data that it is replicating.  In our case that list is short: [https://github.com/WardCunningham/assets/blob/d5509357d400a42be55588224b5b117d41424b20/pages/super-collaborator/beam.js#L30-L36 github]. \n"
    },
    {
      "type": "code",
      "id": "eb775d62337786e5",
      "text": "  static types() {\n    return {\n      \"Graph\": Graph\n    };\n  }\n"
    },
    {
      "type": "markdown",
      "id": "c24d194d1c10784f",
      "text": "This is what makes [[Hypertext Super Collaborator]] a very simple program. Everything we do is done with that one object. Even our schema are constructed out of this one object. [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1664121042189676DnHlh:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]\n"
    },
    {
      "type": "pagefold",
      "id": "3d85a3dca66852a2",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "85aad1db218e256b",
      "text": "* [[Property Graph]] ⇒ [[Fork Network Graph]] ⇒ [[Network Dialect]]"
    },
    {
      "type": "markdown",
      "id": "e97743ba914a329a",
      "text": "Property Graphs Explained. [http://graphdatamodeling.com/Graph%20Data%20Modeling/GraphDataModeling/page/PropertyGraphs.html page] ⇒ What is a *Graph* anyway?"
    },
    {
      "type": "paragraph",
      "id": "94a83d66bf5e53ac",
      "text": "super-collaborator/graph.js [https://github.com/WardCunningham/assets/blob/d5509357d400a42be55588224b5b117d41424b20/pages/super-collaborator/graph.js github]:"
    },
    {
      "type": "code",
      "id": "ef04d15a1957b212",
      "text": "'use strict';\n\nimport * as cypher from './cypher.js'\n\nconst uniq = (value, index, self) => self.indexOf(value) === index\n\nexport class Graph {\n  constructor(nodes=[], rels=[]) {\n    this.nodes = nodes;\n    this.rels = rels;\n  }\n\n  addNode(type, props={}){\n    const obj = {type, in:[], out:[], props};\n    this.nodes.push(obj);\n    return this.nodes.length-1;\n  }\n\n  addRel(type, from, to, props={}) {\n    const obj = {type, from, to, props};\n    this.rels.push(obj);\n    const rid = this.rels.length-1;\n    this.nodes[from].out.push(rid)\n    this.nodes[to].in.push(rid);\n    return rid;\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { nodes:tally(this.nodes), rels:tally(this.rels)};\n  }\n\n  size(){\n    return this.nodes.length + this.rels.length;\n  }\n\n  static load(obj) {\n    // let obj = await fetch(url).then(res => res.json())\n    return new Graph(obj.nodes, obj.rels)\n  }\n\n  static async fetch(url) {\n    const obj = await fetch(url).then(res => res.json())\n    return Graph.load(obj)\n  }\n\n  static async read(path) {\n    const json = await Deno.readTextFile(path);\n    const obj = JSON.parse(json);\n    return Graph.load(obj)\n  }\n\n  // static async import(path) {\n  //   let module = await import(path, {assert: {type: \"json\"}})\n  //   return Graph.load(module.default)\n  // }\n\n  n(type=null, props={}) {\n    let nids = Object.keys(this.nodes).map(key => +key)\n    if (type) nids = nids.filter(nid => this.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.nodes[nid].props[key] == props[key])\n    return new Nodes(this, nids)\n  }\n\n  /**\n   * Converts a graph to a JavaScript Object Notation (JSON) string using JSON.stringify.\n   @param - replacer A function that transforms the results.\n   @param - space Adds indentation, white space, and line break characters to the return-\n   * @returns {string} JSON string containing serialized graph\n  */\n  stringify(...args) {\n    const obj = { nodes: this.nodes, rels: this.rels }\n    return JSON.stringify(obj, ...args)\n  }\n\n\n  search (query, opt={}) {\n    const tree = cypher.parse(query)\n    // console.dir(tree, {depth:15})\n    const code = cypher.gen(0,tree[0][0],{})\n    // console.log(code)\n    cypher.check(this.tally(),code,opt.errors)\n    return cypher.apply(this, code)\n  }\n\n}\n\n\n\n\n\n\n// Fluent Interface (deprecated?)\n\nexport class Nodes {\n  constructor (graph, nids) {\n    // console.log('Nodes',{graph:graph.size(),type,nids})\n    this.graph = graph\n    this.nids = nids\n  }\n\n  // n(type=null, props={}) {\n  //   // console.log('Nodes.n',{type,props})\n  //   let nids = this.nids\n  //   if (type) nids = nids.filter(nid => this.nodes[nid].type == type)\n  //   for (let key in props) nids = nids.filter(nid => this.nodes[nid].props[key] == props[key])\n  //   return new Nodes(this.graph, type, nids)\n  // }\n\n  i(type=null, props={}) {\n    // console.log('Nodes.i',{type,props})\n    let rids = this.nids.map(nid => this.graph.nodes[nid].in).flat().filter(uniq)\n    if (type) rids = rids.filter(rid => this.graph.rels[rid].type == type)\n    for (const key in props) rids = rids.filter(rid => this.graph.rels[rid].props[key] == props[key])\n    return new Rels(this.graph, rids)\n  }\n\n  o(type=null, props={}) {\n    // console.log('Nodes.o',{type,props})\n    let rids = this.nids.map(nid => this.graph.nodes[nid].out).flat().filter(uniq)\n    if (type) rids = rids.filter(rid => this.graph.rels[rid].type == type)\n    for (const key in props) rids = rids.filter(rid => this.graph.rels[rid].props[key] == props[key])\n    return new Rels(this.graph, rids)\n  }\n\n  props(key='name') {\n    // console.log('Nodes.p',{key})\n    return this.nids.map(nid => this.graph.nodes[nid].props[key]).filter(uniq).sort()\n  }\n\n  types() {\n    return this.nids.map(nid => this.graph.nodes[nid].type).filter(uniq).sort()\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { nodes:tally(this.nids.map(nid => this.graph.nodes[nid]))};\n  }\n\n  size(){\n    return this.nids.length\n  }\n\n  filter(f) {\n    const nodes = this.graph.nodes\n    const nids = this.nids.filter(nid => {\n      const node = nodes[nid]\n      return f(node.type,node.props)\n    })\n    return new Nodes(this.graph,nids)\n  }\n\n  map(f) {\n    const nodes = this.graph.nodes\n    const result = this.nids.map(nid => {\n      const node = nodes[nid]\n      return f(node)\n    })\n    return result\n  }\n}\n\nexport class Rels {\n  constructor (graph, rids) {\n    // console.log('Rels',{graph:graph.size(),type,rids})\n    this.graph = graph\n    this.rids = rids\n  }\n\n  f(type=null, props={}) {\n    // console.log('Rels.f',{type,props})\n    let nids = this.rids.map(rid => this.graph.rels[rid].from).filter(uniq)\n    if (type) nids = nids.filter(nid => this.graph.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.graph.nodes[nid].props[key] == props[key])\n    return new Nodes(this.graph, nids)\n  }\n\n  t(type=null, props={}) {\n    // console.log('Rels.t',{type,props})\n    let nids = this.rids.map(rid => this.graph.rels[rid].to).filter(uniq)\n    if (type) nids = nids.filter(nid => this.graph.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.graph.nodes[nid].props[key] == props[key])\n    return new Nodes(this.graph, nids)\n  }\n\n  props(key='name') {\n    // console.log('Rels.p',{key})\n    return this.rids.map(rid => this.graph.rels[rid].props[key]).filter(uniq).sort()\n  }\n\n  types() {\n    return this.rids.map(rid => this.graph.rels[rid].type).filter(uniq).sort()\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { rels:tally(this.rids.map(nid => this.graph.rels[nid]))};\n  }\n\n  size(){\n    return this.rids.length\n  }\n\n  filter(f) {\n    const rels = this.graph.rels\n    const rids = this.rids.filter(rid => {\n      const rel = rels[rid]\n      return f(rel.type,rel.props)\n    })\n    return new Rels(this.graph,rids)\n  }\n\n  map(f) {\n    const rels = this.graph.rels\n    const result = this.rids.map(rid => {\n      const rel = rels[rid]\n      return f(rel)\n    })\n    return result\n  }\n}"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Graph",
        "story": []
      },
      "date": 1649680253901
    },
    {
      "item": {
        "type": "factory",
        "id": "85aad1db218e256b"
      },
      "id": "85aad1db218e256b",
      "type": "add",
      "date": 1649680268726
    },
    {
      "type": "edit",
      "id": "85aad1db218e256b",
      "item": {
        "type": "markdown",
        "id": "85aad1db218e256b",
        "text": "* [Property Graph]]"
      },
      "date": 1649680278471
    },
    {
      "type": "edit",
      "id": "85aad1db218e256b",
      "item": {
        "type": "markdown",
        "id": "85aad1db218e256b",
        "text": "* [[Property Graph]]"
      },
      "date": 1649680286765
    },
    {
      "type": "edit",
      "id": "85aad1db218e256b",
      "item": {
        "type": "markdown",
        "id": "85aad1db218e256b",
        "text": "* [[Property Graph]] ⇒"
      },
      "date": 1649680321502
    },
    {
      "type": "edit",
      "id": "85aad1db218e256b",
      "item": {
        "type": "markdown",
        "id": "85aad1db218e256b",
        "text": "* [[Property Graph]] ⇒ [[Fork Network Graph]]"
      },
      "date": 1649680340500
    },
    {
      "item": {
        "type": "factory",
        "id": "e97743ba914a329a"
      },
      "id": "e97743ba914a329a",
      "type": "add",
      "after": "85aad1db218e256b",
      "date": 1649680522238
    },
    {
      "type": "edit",
      "id": "e97743ba914a329a",
      "item": {
        "type": "paragraph",
        "id": "e97743ba914a329a",
        "text": "http://graphdatamodeling.com/Graph%20Data%20Modeling/GraphDataModeling/page/PropertyGraphs.html"
      },
      "date": 1649680526899
    },
    {
      "type": "edit",
      "id": "e97743ba914a329a",
      "item": {
        "type": "markdown",
        "id": "e97743ba914a329a",
        "text": "http://graphdatamodeling.com/Graph%20Data%20Modeling/GraphDataModeling/page/PropertyGraphs.html"
      },
      "date": 1649680530806
    },
    {
      "type": "edit",
      "id": "e97743ba914a329a",
      "item": {
        "type": "markdown",
        "id": "e97743ba914a329a",
        "text": "Property Graphs Explained [http://graphdatamodeling.com/Graph%20Data%20Modeling/GraphDataModeling/page/PropertyGraphs.html page]"
      },
      "date": 1649680573393
    },
    {
      "type": "edit",
      "id": "e97743ba914a329a",
      "item": {
        "type": "markdown",
        "id": "e97743ba914a329a",
        "text": "Property Graphs Explained [http://graphdatamodeling.com/Graph%20Data%20Modeling/GraphDataModeling/page/PropertyGraphs.html page] What is a Graph anyway?"
      },
      "date": 1649680588638
    },
    {
      "type": "edit",
      "id": "e97743ba914a329a",
      "item": {
        "type": "markdown",
        "id": "e97743ba914a329a",
        "text": "Property Graphs Explained [http://graphdatamodeling.com/Graph%20Data%20Modeling/GraphDataModeling/page/PropertyGraphs.html page] ⇒ What is a [[Graph]] anyway?"
      },
      "date": 1649680600472
    },
    {
      "type": "edit",
      "id": "e97743ba914a329a",
      "item": {
        "type": "markdown",
        "id": "e97743ba914a329a",
        "text": "Property Graphs Explained. [http://graphdatamodeling.com/Graph%20Data%20Modeling/GraphDataModeling/page/PropertyGraphs.html page] ⇒ What is a [[Graph]] anyway?"
      },
      "date": 1649680615582
    },
    {
      "item": {
        "type": "factory",
        "id": "9d8d05ec7de1a199"
      },
      "id": "9d8d05ec7de1a199",
      "type": "add",
      "after": "e97743ba914a329a",
      "date": 1652157019673
    },
    {
      "type": "edit",
      "id": "9d8d05ec7de1a199",
      "item": {
        "type": "graphviz",
        "id": "9d8d05ec7de1a199",
        "text": "DOT strict digraph\n  \nrankdir=LR\n\n  node [style=filled fillcolor=lightyellow penwidth=3 color=black fontname=\"Helvetica\"]\n  HERE NODE\n\n    node [style=filled fillcolor=lightblue]\n    WHERE /^⇒/\n      LINKS HERE -> NODE\n          node [style=filled fillcolor=white]\n          HERE NODE\n            WHERE /^⇒/\n              LINKS HERE -> NODE\n\n    node [style=filled fillcolor=white penwidth=3 color=black]\n    LINKS HERE -> NODE\n       node [style=filled fillcolor=white penwidth=1 color=black]\n       HERE NODE\n         LINKS HERE -> NODE\n\n   node [style=\"filled,rounded,dotted\" fillcolor=white]\n   edge [style=dotted]\n   HERE NODE\n      BACKLINKS NODE -> HERE"
      },
      "date": 1652157029258
    },
    {
      "id": "6cbc0856f1310861",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "6cbc0856f1310861",
        "text": "[[Croquet]] requires that the replicated model declare what classes will be present in the data that it is replicating. [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1664121042189676DnHlh:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix].  In our case that list is short: [https://github.com/WardCunningham/assets/blob/d5509357d400a42be55588224b5b117d41424b20/pages/super-collaborator/beam.js#L30-L36 github]. This is what makes [[Hypertext Super Collaborator]] a very simple program. Everything we do is done with that one object. Even our schema are constructed out of this one object. \n\n⇒ [[Graph]]"
      },
      "date": 1664201091921
    },
    {
      "type": "edit",
      "id": "6cbc0856f1310861",
      "item": {
        "type": "markdown",
        "id": "6cbc0856f1310861",
        "text": "[[Croquet]] requires that the replicated model declare what classes will be present in the data that it is replicating. [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1664121042189676DnHlh:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix].  In our case that list is short: [https://github.com/WardCunningham/assets/blob/d5509357d400a42be55588224b5b117d41424b20/pages/super-collaborator/beam.js#L30-L36 github]. This is what makes [[Hypertext Super Collaborator]] a very simple program. Everything we do is done with that one object. Even our schema are constructed out of this one object. \n"
      },
      "date": 1664201099495
    },
    {
      "type": "add",
      "id": "a825291da972426c",
      "item": {
        "type": "markdown",
        "id": "a825291da972426c",
        "text": "\n⇒ [[Graph]]"
      },
      "after": "6cbc0856f1310861",
      "date": 1664201100540
    },
    {
      "id": "a825291da972426c",
      "type": "remove",
      "date": 1664201102372
    },
    {
      "type": "edit",
      "id": "e97743ba914a329a",
      "item": {
        "type": "markdown",
        "id": "e97743ba914a329a",
        "text": "Property Graphs Explained. [http://graphdatamodeling.com/Graph%20Data%20Modeling/GraphDataModeling/page/PropertyGraphs.html page] ⇒ What is a *Graph* anyway?"
      },
      "date": 1664201118452
    },
    {
      "item": {
        "type": "code",
        "id": "eb775d62337786e5",
        "text": "\n  static types() {\n    return {\n      \"Graph\": Graph\n    };\n  }\n"
      },
      "id": "eb775d62337786e5",
      "type": "add",
      "after": "9d8d05ec7de1a199",
      "date": 1664202713713
    },
    {
      "id": "eb775d62337786e5",
      "type": "move",
      "order": [
        "6cbc0856f1310861",
        "eb775d62337786e5",
        "85aad1db218e256b",
        "e97743ba914a329a",
        "9d8d05ec7de1a199"
      ],
      "date": 1664202718311
    },
    {
      "type": "edit",
      "id": "6cbc0856f1310861",
      "item": {
        "type": "markdown",
        "id": "6cbc0856f1310861",
        "text": "[[Croquet]] requires that the replicated model declare what classes will be present in the data that it is replicating. [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1664121042189676DnHlh:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix].  In our case that list is short: [https://github.com/WardCunningham/assets/blob/d5509357d400a42be55588224b5b117d41424b20/pages/super-collaborator/beam.js#L30-L36 github]. \n"
      },
      "date": 1664202727614
    },
    {
      "id": "eb775d62337786e5",
      "type": "move",
      "order": [
        "6cbc0856f1310861",
        "eb775d62337786e5",
        "c24d194d1c10784f",
        "85aad1db218e256b",
        "e97743ba914a329a",
        "9d8d05ec7de1a199"
      ],
      "date": 1664202730333,
      "error": {
        "type": "error",
        "msg": "Internal Server Error",
        "response": "Server Ignoring move. Try reload."
      }
    },
    {
      "type": "add",
      "id": "c24d194d1c10784f",
      "item": {
        "type": "markdown",
        "id": "c24d194d1c10784f",
        "text": "This is what makes [[Hypertext Super Collaborator]] a very simple program. Everything we do is done with that one object. Even our schema are constructed out of this one object. \n"
      },
      "after": "6cbc0856f1310861",
      "date": 1664202731439
    },
    {
      "type": "edit",
      "id": "eb775d62337786e5",
      "item": {
        "type": "code",
        "id": "eb775d62337786e5",
        "text": "\n  static types() {\n    return {\n      \"Graph\": Graph\n    };\n  }\n"
      },
      "date": 1664202741112
    },
    {
      "type": "fork",
      "date": 1664202746823
    },
    {
      "type": "edit",
      "id": "6cbc0856f1310861",
      "item": {
        "type": "markdown",
        "id": "6cbc0856f1310861",
        "text": "[[Croquet]] requires that the replicated model declare what classes will be present in the data that it is replicating ([https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1664121042189676DnHlh:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]).  In our case that list is short: [https://github.com/WardCunningham/assets/blob/d5509357d400a42be55588224b5b117d41424b20/pages/super-collaborator/beam.js#L30-L36 github]. \n"
      },
      "date": 1664202787022
    },
    {
      "type": "edit",
      "id": "6cbc0856f1310861",
      "item": {
        "type": "markdown",
        "id": "6cbc0856f1310861",
        "text": "[[Croquet]] requires that the replicated model declare what classes will be present in the data that it is replicating.  In our case that list is short: [https://github.com/WardCunningham/assets/blob/d5509357d400a42be55588224b5b117d41424b20/pages/super-collaborator/beam.js#L30-L36 github]. \n"
      },
      "date": 1664202812081
    },
    {
      "type": "edit",
      "id": "c24d194d1c10784f",
      "item": {
        "type": "markdown",
        "id": "c24d194d1c10784f",
        "text": "This is what makes [[Hypertext Super Collaborator]] a very simple program. Everything we do is done with that one object. Even our schema are constructed out of this one object. [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1664121042189676DnHlh:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]\n"
      },
      "date": 1664202818932
    },
    {
      "item": {
        "type": "factory",
        "id": "3d85a3dca66852a2"
      },
      "id": "3d85a3dca66852a2",
      "type": "add",
      "after": "9d8d05ec7de1a199",
      "date": 1664202830364
    },
    {
      "id": "3d85a3dca66852a2",
      "type": "move",
      "order": [
        "6cbc0856f1310861",
        "eb775d62337786e5",
        "c24d194d1c10784f",
        "3d85a3dca66852a2",
        "85aad1db218e256b",
        "e97743ba914a329a",
        "9d8d05ec7de1a199"
      ],
      "date": 1664202835372
    },
    {
      "type": "edit",
      "id": "3d85a3dca66852a2",
      "item": {
        "type": "pagefold",
        "id": "3d85a3dca66852a2",
        "text": "~"
      },
      "date": 1664202838103
    },
    {
      "type": "edit",
      "id": "eb775d62337786e5",
      "item": {
        "type": "code",
        "id": "eb775d62337786e5",
        "text": "  static types() {\n    return {\n      \"Graph\": Graph\n    };\n  }\n"
      },
      "date": 1664203047958
    },
    {
      "item": {
        "type": "factory",
        "id": "ef04d15a1957b212"
      },
      "id": "ef04d15a1957b212",
      "type": "add",
      "after": "9d8d05ec7de1a199",
      "date": 1674462956016
    },
    {
      "type": "edit",
      "id": "ef04d15a1957b212",
      "item": {
        "type": "code",
        "id": "ef04d15a1957b212",
        "text": "\nSkip to content\nPull requests\nIssues\nCodespaces\nMarketplace\nExplore\n@RalfBarkow\nWardCunningham /\nassets\nPublic\n\nFork your own copy of WardCunningham/assets\n\nCode\nIssues\nPull requests 1\nActions\nProjects\nSecurity\n\n    Insights\n\nassets/pages/super-collaborator/graph.js /\n@WardCunningham\nWardCunningham local import of graph/cyper with diagnostics\nLatest commit 98dcda2 Sep 15, 2022\nHistory\n1 contributor\n221 lines (180 sloc) 6.08 KB\n'use strict';\n\nimport * as cypher from './cypher.js'\n\nconst uniq = (value, index, self) => self.indexOf(value) === index\n\nexport class Graph {\n  constructor(nodes=[], rels=[]) {\n    this.nodes = nodes;\n    this.rels = rels;\n  }\n\n  addNode(type, props={}){\n    const obj = {type, in:[], out:[], props};\n    this.nodes.push(obj);\n    return this.nodes.length-1;\n  }\n\n  addRel(type, from, to, props={}) {\n    const obj = {type, from, to, props};\n    this.rels.push(obj);\n    const rid = this.rels.length-1;\n    this.nodes[from].out.push(rid)\n    this.nodes[to].in.push(rid);\n    return rid;\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { nodes:tally(this.nodes), rels:tally(this.rels)};\n  }\n\n  size(){\n    return this.nodes.length + this.rels.length;\n  }\n\n  static load(obj) {\n    // let obj = await fetch(url).then(res => res.json())\n    return new Graph(obj.nodes, obj.rels)\n  }\n\n  static async fetch(url) {\n    const obj = await fetch(url).then(res => res.json())\n    return Graph.load(obj)\n  }\n\n  static async read(path) {\n    const json = await Deno.readTextFile(path);\n    const obj = JSON.parse(json);\n    return Graph.load(obj)\n  }\n\n  // static async import(path) {\n  //   let module = await import(path, {assert: {type: \"json\"}})\n  //   return Graph.load(module.default)\n  // }\n\n  n(type=null, props={}) {\n    let nids = Object.keys(this.nodes).map(key => +key)\n    if (type) nids = nids.filter(nid => this.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.nodes[nid].props[key] == props[key])\n    return new Nodes(this, nids)\n  }\n\n  /**\n   * Converts a graph to a JavaScript Object Notation (JSON) string using JSON.stringify.\n   @param - replacer A function that transforms the results.\n   @param - space Adds indentation, white space, and line break characters to the return-\n   * @returns {string} JSON string containing serialized graph\n  */\n  stringify(...args) {\n    const obj = { nodes: this.nodes, rels: this.rels }\n    return JSON.stringify(obj, ...args)\n  }\n\n\n  search (query, opt={}) {\n    const tree = cypher.parse(query)\n    // console.dir(tree, {depth:15})\n    const code = cypher.gen(0,tree[0][0],{})\n    // console.log(code)\n    cypher.check(this.tally(),code,opt.errors)\n    return cypher.apply(this, code)\n  }\n\n}\n\n\n\n\n\n\n// Fluent Interface (deprecated?)\n\nexport class Nodes {\n  constructor (graph, nids) {\n    // console.log('Nodes',{graph:graph.size(),type,nids})\n    this.graph = graph\n    this.nids = nids\n  }\n\n  // n(type=null, props={}) {\n  //   // console.log('Nodes.n',{type,props})\n  //   let nids = this.nids\n  //   if (type) nids = nids.filter(nid => this.nodes[nid].type == type)\n  //   for (let key in props) nids = nids.filter(nid => this.nodes[nid].props[key] == props[key])\n  //   return new Nodes(this.graph, type, nids)\n  // }\n\n  i(type=null, props={}) {\n    // console.log('Nodes.i',{type,props})\n    let rids = this.nids.map(nid => this.graph.nodes[nid].in).flat().filter(uniq)\n    if (type) rids = rids.filter(rid => this.graph.rels[rid].type == type)\n    for (const key in props) rids = rids.filter(rid => this.graph.rels[rid].props[key] == props[key])\n    return new Rels(this.graph, rids)\n  }\n\n  o(type=null, props={}) {\n    // console.log('Nodes.o',{type,props})\n    let rids = this.nids.map(nid => this.graph.nodes[nid].out).flat().filter(uniq)\n    if (type) rids = rids.filter(rid => this.graph.rels[rid].type == type)\n    for (const key in props) rids = rids.filter(rid => this.graph.rels[rid].props[key] == props[key])\n    return new Rels(this.graph, rids)\n  }\n\n  props(key='name') {\n    // console.log('Nodes.p',{key})\n    return this.nids.map(nid => this.graph.nodes[nid].props[key]).filter(uniq).sort()\n  }\n\n  types() {\n    return this.nids.map(nid => this.graph.nodes[nid].type).filter(uniq).sort()\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { nodes:tally(this.nids.map(nid => this.graph.nodes[nid]))};\n  }\n\n  size(){\n    return this.nids.length\n  }\n\n  filter(f) {\n    const nodes = this.graph.nodes\n    const nids = this.nids.filter(nid => {\n      const node = nodes[nid]\n      return f(node.type,node.props)\n    })\n    return new Nodes(this.graph,nids)\n  }\n\n  map(f) {\n    const nodes = this.graph.nodes\n    const result = this.nids.map(nid => {\n      const node = nodes[nid]\n      return f(node)\n    })\n    return result\n  }\n}\n\nexport class Rels {\n  constructor (graph, rids) {\n    // console.log('Rels',{graph:graph.size(),type,rids})\n    this.graph = graph\n    this.rids = rids\n  }\n\n  f(type=null, props={}) {\n    // console.log('Rels.f',{type,props})\n    let nids = this.rids.map(rid => this.graph.rels[rid].from).filter(uniq)\n    if (type) nids = nids.filter(nid => this.graph.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.graph.nodes[nid].props[key] == props[key])\n    return new Nodes(this.graph, nids)\n  }\n\n  t(type=null, props={}) {\n    // console.log('Rels.t',{type,props})\n    let nids = this.rids.map(rid => this.graph.rels[rid].to).filter(uniq)\n    if (type) nids = nids.filter(nid => this.graph.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.graph.nodes[nid].props[key] == props[key])\n    return new Nodes(this.graph, nids)\n  }\n\n  props(key='name') {\n    // console.log('Rels.p',{key})\n    return this.rids.map(rid => this.graph.rels[rid].props[key]).filter(uniq).sort()\n  }\n\n  types() {\n    return this.rids.map(rid => this.graph.rels[rid].type).filter(uniq).sort()\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { rels:tally(this.rids.map(nid => this.graph.rels[nid]))};\n  }\n\n  size(){\n    return this.rids.length\n  }\n\n  filter(f) {\n    const rels = this.graph.rels\n    const rids = this.rids.filter(rid => {\n      const rel = rels[rid]\n      return f(rel.type,rel.props)\n    })\n    return new Rels(this.graph,rids)\n  }\n\n  map(f) {\n    const rels = this.graph.rels\n    const result = this.rids.map(rid => {\n      const rel = rels[rid]\n      return f(rel)\n    })\n    return result\n  }\n}\nFooter\n© 2023 GitHub, Inc.\nFooter navigation\n\n    Terms\n    Privacy\n    Security\n    Status\n    Docs\n    Contact GitHub\n    Pricing\n    API\n    Training\n    Blog\n    About\n\nassets/graph.js at d5509357d400a42be55588224b5b117d41424b20 · WardCunningham/assets\n"
      },
      "date": 1674462959458
    },
    {
      "type": "edit",
      "id": "ef04d15a1957b212",
      "item": {
        "type": "code",
        "id": "ef04d15a1957b212",
        "text": "'use strict';\n\nimport * as cypher from './cypher.js'\n\nconst uniq = (value, index, self) => self.indexOf(value) === index\n\nexport class Graph {\n  constructor(nodes=[], rels=[]) {\n    this.nodes = nodes;\n    this.rels = rels;\n  }\n\n  addNode(type, props={}){\n    const obj = {type, in:[], out:[], props};\n    this.nodes.push(obj);\n    return this.nodes.length-1;\n  }\n\n  addRel(type, from, to, props={}) {\n    const obj = {type, from, to, props};\n    this.rels.push(obj);\n    const rid = this.rels.length-1;\n    this.nodes[from].out.push(rid)\n    this.nodes[to].in.push(rid);\n    return rid;\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { nodes:tally(this.nodes), rels:tally(this.rels)};\n  }\n\n  size(){\n    return this.nodes.length + this.rels.length;\n  }\n\n  static load(obj) {\n    // let obj = await fetch(url).then(res => res.json())\n    return new Graph(obj.nodes, obj.rels)\n  }\n\n  static async fetch(url) {\n    const obj = await fetch(url).then(res => res.json())\n    return Graph.load(obj)\n  }\n\n  static async read(path) {\n    const json = await Deno.readTextFile(path);\n    const obj = JSON.parse(json);\n    return Graph.load(obj)\n  }\n\n  // static async import(path) {\n  //   let module = await import(path, {assert: {type: \"json\"}})\n  //   return Graph.load(module.default)\n  // }\n\n  n(type=null, props={}) {\n    let nids = Object.keys(this.nodes).map(key => +key)\n    if (type) nids = nids.filter(nid => this.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.nodes[nid].props[key] == props[key])\n    return new Nodes(this, nids)\n  }\n\n  /**\n   * Converts a graph to a JavaScript Object Notation (JSON) string using JSON.stringify.\n   @param - replacer A function that transforms the results.\n   @param - space Adds indentation, white space, and line break characters to the return-\n   * @returns {string} JSON string containing serialized graph\n  */\n  stringify(...args) {\n    const obj = { nodes: this.nodes, rels: this.rels }\n    return JSON.stringify(obj, ...args)\n  }\n\n\n  search (query, opt={}) {\n    const tree = cypher.parse(query)\n    // console.dir(tree, {depth:15})\n    const code = cypher.gen(0,tree[0][0],{})\n    // console.log(code)\n    cypher.check(this.tally(),code,opt.errors)\n    return cypher.apply(this, code)\n  }\n\n}\n\n\n\n\n\n\n// Fluent Interface (deprecated?)\n\nexport class Nodes {\n  constructor (graph, nids) {\n    // console.log('Nodes',{graph:graph.size(),type,nids})\n    this.graph = graph\n    this.nids = nids\n  }\n\n  // n(type=null, props={}) {\n  //   // console.log('Nodes.n',{type,props})\n  //   let nids = this.nids\n  //   if (type) nids = nids.filter(nid => this.nodes[nid].type == type)\n  //   for (let key in props) nids = nids.filter(nid => this.nodes[nid].props[key] == props[key])\n  //   return new Nodes(this.graph, type, nids)\n  // }\n\n  i(type=null, props={}) {\n    // console.log('Nodes.i',{type,props})\n    let rids = this.nids.map(nid => this.graph.nodes[nid].in).flat().filter(uniq)\n    if (type) rids = rids.filter(rid => this.graph.rels[rid].type == type)\n    for (const key in props) rids = rids.filter(rid => this.graph.rels[rid].props[key] == props[key])\n    return new Rels(this.graph, rids)\n  }\n\n  o(type=null, props={}) {\n    // console.log('Nodes.o',{type,props})\n    let rids = this.nids.map(nid => this.graph.nodes[nid].out).flat().filter(uniq)\n    if (type) rids = rids.filter(rid => this.graph.rels[rid].type == type)\n    for (const key in props) rids = rids.filter(rid => this.graph.rels[rid].props[key] == props[key])\n    return new Rels(this.graph, rids)\n  }\n\n  props(key='name') {\n    // console.log('Nodes.p',{key})\n    return this.nids.map(nid => this.graph.nodes[nid].props[key]).filter(uniq).sort()\n  }\n\n  types() {\n    return this.nids.map(nid => this.graph.nodes[nid].type).filter(uniq).sort()\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { nodes:tally(this.nids.map(nid => this.graph.nodes[nid]))};\n  }\n\n  size(){\n    return this.nids.length\n  }\n\n  filter(f) {\n    const nodes = this.graph.nodes\n    const nids = this.nids.filter(nid => {\n      const node = nodes[nid]\n      return f(node.type,node.props)\n    })\n    return new Nodes(this.graph,nids)\n  }\n\n  map(f) {\n    const nodes = this.graph.nodes\n    const result = this.nids.map(nid => {\n      const node = nodes[nid]\n      return f(node)\n    })\n    return result\n  }\n}\n\nexport class Rels {\n  constructor (graph, rids) {\n    // console.log('Rels',{graph:graph.size(),type,rids})\n    this.graph = graph\n    this.rids = rids\n  }\n\n  f(type=null, props={}) {\n    // console.log('Rels.f',{type,props})\n    let nids = this.rids.map(rid => this.graph.rels[rid].from).filter(uniq)\n    if (type) nids = nids.filter(nid => this.graph.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.graph.nodes[nid].props[key] == props[key])\n    return new Nodes(this.graph, nids)\n  }\n\n  t(type=null, props={}) {\n    // console.log('Rels.t',{type,props})\n    let nids = this.rids.map(rid => this.graph.rels[rid].to).filter(uniq)\n    if (type) nids = nids.filter(nid => this.graph.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.graph.nodes[nid].props[key] == props[key])\n    return new Nodes(this.graph, nids)\n  }\n\n  props(key='name') {\n    // console.log('Rels.p',{key})\n    return this.rids.map(rid => this.graph.rels[rid].props[key]).filter(uniq).sort()\n  }\n\n  types() {\n    return this.rids.map(rid => this.graph.rels[rid].type).filter(uniq).sort()\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { rels:tally(this.rids.map(nid => this.graph.rels[nid]))};\n  }\n\n  size(){\n    return this.rids.length\n  }\n\n  filter(f) {\n    const rels = this.graph.rels\n    const rids = this.rids.filter(rid => {\n      const rel = rels[rid]\n      return f(rel.type,rel.props)\n    })\n    return new Rels(this.graph,rids)\n  }\n\n  map(f) {\n    const rels = this.graph.rels\n    const result = this.rids.map(rid => {\n      const rel = rels[rid]\n      return f(rel)\n    })\n    return result\n  }\n}"
      },
      "date": 1674462974284
    },
    {
      "item": {
        "type": "factory",
        "id": "94a83d66bf5e53ac"
      },
      "id": "94a83d66bf5e53ac",
      "type": "add",
      "after": "ef04d15a1957b212",
      "date": 1674463188816
    },
    {
      "type": "edit",
      "id": "94a83d66bf5e53ac",
      "item": {
        "type": "paragraph",
        "id": "94a83d66bf5e53ac",
        "text": "super-collaborator/graph.js :"
      },
      "date": 1674463192953
    },
    {
      "id": "94a83d66bf5e53ac",
      "type": "move",
      "order": [
        "6cbc0856f1310861",
        "eb775d62337786e5",
        "c24d194d1c10784f",
        "3d85a3dca66852a2",
        "85aad1db218e256b",
        "e97743ba914a329a",
        "9d8d05ec7de1a199",
        "94a83d66bf5e53ac",
        "ef04d15a1957b212"
      ],
      "date": 1674463208096
    },
    {
      "type": "edit",
      "id": "94a83d66bf5e53ac",
      "item": {
        "type": "paragraph",
        "id": "94a83d66bf5e53ac",
        "text": "super-collaborator/graph.js [https://github.com/WardCunningham/assets/blob/d5509357d400a42be55588224b5b117d41424b20/pages/super-collaborator/graph.js github]:"
      },
      "date": 1674463224629
    },
    {
      "type": "edit",
      "id": "85aad1db218e256b",
      "item": {
        "type": "markdown",
        "id": "85aad1db218e256b",
        "text": "* [[Property Graph]] ⇒ [[Fork Network Graph]] ⇒ [[Network Dialect]]"
      },
      "date": 1675287238391
    },
    {
      "type": "edit",
      "id": "6cbc0856f1310861",
      "item": {
        "type": "markdown",
        "id": "6cbc0856f1310861",
        "text": "[[Croquet]] requires that the replicated [[Model]] declare what classes will be present in the data that it is replicating.  In our case that list is short: [https://github.com/WardCunningham/assets/blob/d5509357d400a42be55588224b5b117d41424b20/pages/super-collaborator/beam.js#L30-L36 github]. \n"
      },
      "date": 1691575480456
    },
    {
      "type": "remove",
      "id": "9d8d05ec7de1a199",
      "date": 1713422354810
    }
  ]
}