{
  "title": "TransformStream",
  "story": [
    {
      "type": "paragraph",
      "id": "c5d9cc0ef58ab4ae",
      "text": "[[Matthias Buelens]] via [https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$Z_Yd-yqKfZXQMxQBFIiNHzlRKLZb7yXPEc5a5uuEg5M?via=mozilla.org&via=matrix.org&via=igalia.com matrix]"
    },
    {
      "type": "paragraph",
      "id": "493a7c82f0f62b39",
      "text": "Jim Pryor: I think these questions deserve an issue in whatwg/streams. You're right, there's no way for a TransformStream to observe cancel or abort on its readable or writable end. I have personally had to do the same trick with piping through another identity transform in order to observe errors from the pipeTo promise. Not very elegant. ðŸ˜›"
    },
    {
      "type": "paragraph",
      "id": "c5d1c50bfe3c0bff",
      "text": "Jim Pryor\nMattias Buelens: I've seen this in some code with nodestreams too. The scenario is, you have some outside-supplied readable stream (may be the readable end of a pipeline), that you want to observe and/or catch errors in. With node streams, I've seen code do stream.pipeline(suppliedStream, new stream.PassThrough (), callback) in order to catch errors raised by the supplied stream. I guess we're close to being able to do the same with [[webstreams]], something like suppliedStream.pipeThrough(new IdentityTransform()).catch(callback). Only issue is that pipeThrough returns the readable end of the TransformStream, instead of a promise. Whereas pipeTo provides a promise, but expects a writable destination.\nI guess what we'd have to do is: function installCallback(suppliedStream: ReadableStream, callback): ReadableStream { const t = new TransformStream(); suppliedStream.pipeTo(t.writable).catch(callback); return t.readable; }\nThanks, was helpful to talk this through.\n"
    },
    {
      "type": "pagefold",
      "id": "abf1ab71cb82a6f2",
      "text": "web-streams-polyfill"
    },
    {
      "type": "paragraph",
      "id": "66a29f7f98640089",
      "text": "[[Web Streams]], based on the [[WHATWG]] spec reference implementation. [https://github.com/MattiasBuelens/web-streams-polyfill github]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "TransformStream",
        "story": []
      },
      "date": 1638088407284
    },
    {
      "item": {
        "type": "factory",
        "id": "c5d9cc0ef58ab4ae"
      },
      "id": "c5d9cc0ef58ab4ae",
      "type": "add",
      "date": 1638088412602
    },
    {
      "type": "edit",
      "id": "c5d9cc0ef58ab4ae",
      "item": {
        "type": "paragraph",
        "id": "c5d9cc0ef58ab4ae",
        "text": "Jim Pryor: I think these questions deserve an issue in whatwg/streams. You're right, there's no way for a TransformStream to observe cancel or abort on its readable or writable end. I have personally had to do the same trick with piping through another identity transform in order to observe errors from the pipeTo promise. Not very elegant. ðŸ˜›"
      },
      "date": 1638088420977
    },
    {
      "type": "edit",
      "id": "c5d9cc0ef58ab4ae",
      "item": {
        "type": "paragraph",
        "id": "c5d9cc0ef58ab4ae",
        "text": "Matthias Buelens via [https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$Z_Yd-yqKfZXQMxQBFIiNHzlRKLZb7yXPEc5a5uuEg5M?via=mozilla.org&via=matrix.org&via=igalia.com matrix]"
      },
      "date": 1638088463038
    },
    {
      "type": "add",
      "id": "493a7c82f0f62b39",
      "item": {
        "type": "paragraph",
        "id": "493a7c82f0f62b39",
        "text": "Jim Pryor: I think these questions deserve an issue in whatwg/streams. You're right, there's no way for a TransformStream to observe cancel or abort on its readable or writable end. I have personally had to do the same trick with piping through another identity transform in order to observe errors from the pipeTo promise. Not very elegant. ðŸ˜›"
      },
      "after": "c5d9cc0ef58ab4ae",
      "date": 1638088463653
    },
    {
      "item": {
        "type": "factory",
        "id": "c5d1c50bfe3c0bff"
      },
      "id": "c5d1c50bfe3c0bff",
      "type": "add",
      "after": "493a7c82f0f62b39",
      "date": 1638088493123
    },
    {
      "type": "edit",
      "id": "c5d1c50bfe3c0bff",
      "item": {
        "type": "paragraph",
        "id": "c5d1c50bfe3c0bff",
        "text": "Jim Pryor\nMattias Buelens: I've seen this in some code with nodestreams too. The scenario is, you have some outside-supplied readable stream (may be the readable end of a pipeline), that you want to observe and/or catch errors in. With node streams, I've seen code do stream.pipeline(suppliedStream, new stream.PassThrough (), callback) in order to catch errors raised by the supplied stream. I guess we're close to being able to do the same with webstreams, something like suppliedStream.pipeThrough(new IdentityTransform()).catch(callback). Only issue is that pipeThrough returns the readable end of the TransformStream, instead of a promise. Whereas pipeTo provides a promise, but expects a writable destination.\nI guess what we'd have to do is: function installCallback(suppliedStream: ReadableStream, callback): ReadableStream { const t = new TransformStream(); suppliedStream.pipeTo(t.writable).catch(callback); return t.readable; }\nThanks, was helpful to talk this through.\n"
      },
      "date": 1638088494577
    },
    {
      "type": "edit",
      "id": "c5d9cc0ef58ab4ae",
      "item": {
        "type": "paragraph",
        "id": "c5d9cc0ef58ab4ae",
        "text": "[[Matthias Buelens]] via [https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$Z_Yd-yqKfZXQMxQBFIiNHzlRKLZb7yXPEc5a5uuEg5M?via=mozilla.org&via=matrix.org&via=igalia.com matrix]"
      },
      "date": 1638088557968
    },
    {
      "type": "edit",
      "id": "c5d1c50bfe3c0bff",
      "item": {
        "type": "paragraph",
        "id": "c5d1c50bfe3c0bff",
        "text": "Jim Pryor\nMattias Buelens: I've seen this in some code with nodestreams too. The scenario is, you have some outside-supplied readable stream (may be the readable end of a pipeline), that you want to observe and/or catch errors in. With node streams, I've seen code do stream.pipeline(suppliedStream, new stream.PassThrough (), callback) in order to catch errors raised by the supplied stream. I guess we're close to being able to do the same with [[webstreams]], something like suppliedStream.pipeThrough(new IdentityTransform()).catch(callback). Only issue is that pipeThrough returns the readable end of the TransformStream, instead of a promise. Whereas pipeTo provides a promise, but expects a writable destination.\nI guess what we'd have to do is: function installCallback(suppliedStream: ReadableStream, callback): ReadableStream { const t = new TransformStream(); suppliedStream.pipeTo(t.writable).catch(callback); return t.readable; }\nThanks, was helpful to talk this through.\n"
      },
      "date": 1638088647884
    },
    {
      "item": {
        "type": "factory",
        "id": "66a29f7f98640089"
      },
      "id": "66a29f7f98640089",
      "type": "add",
      "after": "c5d1c50bfe3c0bff",
      "date": 1638088737243
    },
    {
      "type": "edit",
      "id": "66a29f7f98640089",
      "item": {
        "type": "paragraph",
        "id": "66a29f7f98640089",
        "text": "See also [https://github.com/MattiasBuelens/web-streams-polyfill github]"
      },
      "date": 1638088760306
    },
    {
      "item": {
        "type": "factory",
        "id": "abf1ab71cb82a6f2"
      },
      "id": "abf1ab71cb82a6f2",
      "type": "add",
      "after": "66a29f7f98640089",
      "date": 1638088769930
    },
    {
      "type": "edit",
      "id": "abf1ab71cb82a6f2",
      "item": {
        "type": "pagefold",
        "id": "abf1ab71cb82a6f2",
        "text": "web-streams-polyfill"
      },
      "date": 1638088773006
    },
    {
      "id": "abf1ab71cb82a6f2",
      "type": "move",
      "order": [
        "c5d9cc0ef58ab4ae",
        "493a7c82f0f62b39",
        "c5d1c50bfe3c0bff",
        "abf1ab71cb82a6f2",
        "66a29f7f98640089"
      ],
      "date": 1638088775507
    },
    {
      "type": "edit",
      "id": "66a29f7f98640089",
      "item": {
        "type": "paragraph",
        "id": "66a29f7f98640089",
        "text": "Web Streams, based on the WHATWG spec reference implementation.[https://github.com/MattiasBuelens/web-streams-polyfill github]"
      },
      "date": 1638088792958
    },
    {
      "type": "edit",
      "id": "66a29f7f98640089",
      "item": {
        "type": "paragraph",
        "id": "66a29f7f98640089",
        "text": "Web Streams, based on the WHATWG spec reference implementation. [https://github.com/MattiasBuelens/web-streams-polyfill github]"
      },
      "date": 1638088796250
    },
    {
      "type": "edit",
      "id": "66a29f7f98640089",
      "item": {
        "type": "paragraph",
        "id": "66a29f7f98640089",
        "text": "[[Web Streams]], based on the WHATWG spec reference implementation. [https://github.com/MattiasBuelens/web-streams-polyfill github]"
      },
      "date": 1638088808726
    },
    {
      "type": "edit",
      "id": "66a29f7f98640089",
      "item": {
        "type": "paragraph",
        "id": "66a29f7f98640089",
        "text": "[[Web Streams]], based on the [[WHATWG]] spec reference implementation. [https://github.com/MattiasBuelens/web-streams-polyfill github]"
      },
      "date": 1638089083960
    }
  ]
}