{
  "title": "Memoization",
  "story": [
    {
      "type": "paragraph",
      "id": "098443cc2284f990",
      "text": "The term memoization was coined by [[Donald Michie]] (1968) to refer to the process by which a function is made to automatically remember the results of previous computations. The idea has become more popular in recent years with the rise of functional languages; Field and Harrison (1988) devote a whole chapter to it. The basic idea is just to keep a table of previously computed input/result pairs. [⇒ [[Table Lookup]]]"
    },
    {
      "type": "pagefold",
      "id": "d2edab61302a22c9",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "90e3becd881883aa",
      "text": "NORVIG, Peter, 1991. Techniques for automatic memoization with applications to context-free parsing. Computational Linguistics. 1991. Vol. 17, no. 1, p. 91–98. \n"
    },
    {
      "type": "paragraph",
      "id": "6506fb46a3f9ae03",
      "text": "Memoization is a technique for storing values of a function instead of recomputing them each time the function is called. [https://wiki.haskell.org/Memoization wiki.haskell]"
    },
    {
      "type": "paragraph",
      "id": "57fecb4e72fbcebc",
      "text": "For further and detailed explanations, see"
    },
    {
      "type": "markdown",
      "id": "f2f96d2f866f16d4",
      "text": "* Ralf Hinze: Memo functions, polytypically! [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.3272 page]\n* Ralf Hinze: Generalizing generalized tries [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.4069 page]\n* Conal Elliott: Elegant memoization with functional memo tries [http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries post] and other posts on memoization. [http://conal.net/blog/tag/memoization blog]\n* Conal Elliott Denotational design with type class morphisms, section 9 (Memo tries). [http://conal.net/papers/type-class-morphisms/ page]"
    },
    {
      "type": "reference",
      "id": "6a094534c5aca644",
      "site": "wiki.ralfbarkow.ch",
      "slug": "functions-are-containers",
      "title": "Functions Are Containers",
      "text": "Memoization via Representables [https://iagoleal.com/posts/representable-memoize/ post]"
    },
    {
      "type": "reference",
      "id": "14ff4a37711e412b",
      "site": "wiki.ralfbarkow.ch",
      "slug": "memoization-via-representables",
      "title": "Memoization via Representables",
      "text": "What is the most basic [[Container]] type a language can have? Some people may answer vectors, others would go with hash tables, but in this post [[Iago Leal de Freitas]] is arguing in favor of functions. [https://iagoleal.com/posts/representable-memoize/ post]"
    },
    {
      "type": "reference",
      "id": "76619f0509f5d293",
      "site": "wiki.ralfbarkow.ch",
      "slug": "understanding-machines",
      "title": "Understanding Machines",
      "text": "⇒ [[Model Free Method Zoo]]"
    },
    {
      "type": "markdown",
      "id": "c3ac8e6f3894c578",
      "text": "> [[Table Lookup]] (of gathered experience) – 53:32;  \nGraph algorithms (table to graph transformation) [https://www.educative.io/blog/graph-algorithms-tutorial page]\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Memoization",
        "story": []
      },
      "date": 1679895561559
    },
    {
      "item": {
        "type": "factory",
        "id": "6a094534c5aca644"
      },
      "id": "6a094534c5aca644",
      "type": "add",
      "date": 1679895563128
    },
    {
      "type": "edit",
      "id": "6a094534c5aca644",
      "item": {
        "type": "reference",
        "id": "6a094534c5aca644",
        "site": "wiki.ralfbarkow.ch",
        "slug": "functions-are-containers",
        "title": "Functions Are Containers",
        "text": "Memoization via Representables [https://iagoleal.com/posts/representable-memoize/ post]"
      },
      "date": 1679895566159
    },
    {
      "item": {
        "type": "factory",
        "id": "14ff4a37711e412b"
      },
      "id": "14ff4a37711e412b",
      "type": "add",
      "after": "6a094534c5aca644",
      "date": 1680002823574
    },
    {
      "type": "edit",
      "id": "14ff4a37711e412b",
      "item": {
        "type": "reference",
        "id": "14ff4a37711e412b",
        "site": "wiki.ralfbarkow.ch",
        "slug": "memoization-via-representables",
        "title": "Memoization via Representables",
        "text": "What is the most basic [[Container]] type a language can have? Some people may answer vectors, others would go with hash tables, but in this post [[Iago Leal de Freitas]] is arguing in favor of functions. [https://iagoleal.com/posts/representable-memoize/ post]"
      },
      "date": 1680002826390
    },
    {
      "item": {
        "type": "factory",
        "id": "098443cc2284f990"
      },
      "id": "098443cc2284f990",
      "type": "add",
      "after": "14ff4a37711e412b",
      "date": 1680003197152
    },
    {
      "id": "098443cc2284f990",
      "type": "move",
      "order": [
        "098443cc2284f990",
        "6a094534c5aca644",
        "14ff4a37711e412b"
      ],
      "date": 1680003199070
    },
    {
      "type": "edit",
      "id": "098443cc2284f990",
      "item": {
        "type": "paragraph",
        "id": "098443cc2284f990",
        "text": "The term memoization was coined by Donald Michie (1968) to refer to the process by which a function is made to automatically remember the results of previous computations. The idea has become more popular in recent years with the rise of functional languages; Field and Harrison (1988) devote a whole chapter to it. The basic idea is just to keep a table of previously computed input/result pairs. In Common Lisp one could write: 1"
      },
      "date": 1680003201326
    },
    {
      "type": "edit",
      "id": "098443cc2284f990",
      "item": {
        "type": "paragraph",
        "id": "098443cc2284f990",
        "text": "The term memoization was coined by Donald Michie (1968) to refer to the process by which a function is made to automatically remember the results of previous computations. The idea has become more popular in recent years with the rise of functional languages; Field and Harrison (1988) devote a whole chapter to it. The basic idea is just to keep a table of previously computed input/result pairs. "
      },
      "date": 1680003253054
    },
    {
      "item": {
        "type": "factory",
        "id": "d2edab61302a22c9"
      },
      "id": "d2edab61302a22c9",
      "type": "add",
      "after": "14ff4a37711e412b",
      "date": 1680003265338
    },
    {
      "id": "d2edab61302a22c9",
      "type": "move",
      "order": [
        "098443cc2284f990",
        "d2edab61302a22c9",
        "6a094534c5aca644",
        "14ff4a37711e412b"
      ],
      "date": 1680003267161
    },
    {
      "type": "edit",
      "id": "d2edab61302a22c9",
      "item": {
        "type": "pagefold",
        "id": "d2edab61302a22c9",
        "text": "~"
      },
      "date": 1680003269673
    },
    {
      "item": {
        "type": "factory",
        "id": "90e3becd881883aa"
      },
      "id": "90e3becd881883aa",
      "type": "add",
      "after": "14ff4a37711e412b",
      "date": 1680003271501
    },
    {
      "id": "90e3becd881883aa",
      "type": "move",
      "order": [
        "098443cc2284f990",
        "d2edab61302a22c9",
        "90e3becd881883aa",
        "6a094534c5aca644",
        "14ff4a37711e412b"
      ],
      "date": 1680003274262
    },
    {
      "type": "edit",
      "id": "90e3becd881883aa",
      "item": {
        "type": "paragraph",
        "id": "90e3becd881883aa",
        "text": "NORVIG, Peter, 1991. Techniques for automatic memoization with applications to context-free parsing. Computational Linguistics. 1991. Vol. 17, no. 1, p. 91–98. \n"
      },
      "date": 1680003281649
    },
    {
      "type": "edit",
      "id": "098443cc2284f990",
      "item": {
        "type": "paragraph",
        "id": "098443cc2284f990",
        "text": "The term memoization was coined by [[Donald Michie]] (1968) to refer to the process by which a function is made to automatically remember the results of previous computations. The idea has become more popular in recent years with the rise of functional languages; Field and Harrison (1988) devote a whole chapter to it. The basic idea is just to keep a table of previously computed input/result pairs. "
      },
      "date": 1680003293311
    },
    {
      "type": "add",
      "id": "6506fb46a3f9ae03",
      "item": {
        "type": "paragraph",
        "id": "6506fb46a3f9ae03",
        "text": "Memoization is a technique for storing values of a function instead of recomputing them each time the function is called. "
      },
      "after": "90e3becd881883aa",
      "date": 1680004508745
    },
    {
      "type": "edit",
      "id": "6506fb46a3f9ae03",
      "item": {
        "type": "paragraph",
        "id": "6506fb46a3f9ae03",
        "text": "Memoization is a technique for storing values of a function instead of recomputing them each time the function is called. [https://wiki.haskell.org/Memoization wiki.haskell]"
      },
      "date": 1680004523024
    },
    {
      "item": {
        "type": "factory",
        "id": "76619f0509f5d293"
      },
      "id": "76619f0509f5d293",
      "type": "add",
      "after": "14ff4a37711e412b",
      "date": 1694020200566
    },
    {
      "type": "edit",
      "id": "76619f0509f5d293",
      "item": {
        "type": "reference",
        "id": "76619f0509f5d293",
        "site": "wiki.ralfbarkow.ch",
        "slug": "understanding-machines",
        "title": "Understanding Machines",
        "text": "Computer based analysis of the Semantics of language expressed as text is an AI level problem."
      },
      "date": 1694020203704
    },
    {
      "id": "c3ac8e6f3894c578",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "c3ac8e6f3894c578",
        "text": "* Trial and Error (try anything)\n* Enumeration (try everything once)\n* [[Track successes and failures]]\n* [[Table Lookup]] (of gathered experience) – 53:32;  \nGraph algorithms (table to graph transformation) [https://www.educative.io/blog/graph-algorithms-tutorial page]\n* Track Correlations \n* Pattern Discovery based methods\n* [[Adaptation]]\n* [[Evolution]] or [[Evolutionary Computation]]"
      },
      "after": "76619f0509f5d293",
      "attribution": {
        "page": "Understanding Machines"
      },
      "date": 1694020210634
    },
    {
      "type": "edit",
      "id": "c3ac8e6f3894c578",
      "item": {
        "type": "markdown",
        "id": "c3ac8e6f3894c578",
        "text": "* [[Table Lookup]] (of gathered experience) – 53:32;  \nGraph algorithms (table to graph transformation) [https://www.educative.io/blog/graph-algorithms-tutorial page]\n"
      },
      "date": 1694020232041
    },
    {
      "type": "edit",
      "id": "c3ac8e6f3894c578",
      "item": {
        "type": "markdown",
        "id": "c3ac8e6f3894c578",
        "text": "> [[Table Lookup]] (of gathered experience) – 53:32;  \nGraph algorithms (table to graph transformation) [https://www.educative.io/blog/graph-algorithms-tutorial page]\n"
      },
      "date": 1694020240513
    },
    {
      "type": "edit",
      "id": "76619f0509f5d293",
      "item": {
        "type": "reference",
        "id": "76619f0509f5d293",
        "site": "wiki.ralfbarkow.ch",
        "slug": "understanding-machines",
        "title": "Understanding Machines",
        "text": "⇒ [[Model Free Method Zoo]]"
      },
      "date": 1694020305483
    },
    {
      "type": "edit",
      "id": "098443cc2284f990",
      "item": {
        "type": "paragraph",
        "id": "098443cc2284f990",
        "text": "The term memoization was coined by [[Donald Michie]] (1968) to refer to the process by which a function is made to automatically remember the results of previous computations. The idea has become more popular in recent years with the rise of functional languages; Field and Harrison (1988) devote a whole chapter to it. The basic idea is just to keep a table of previously computed input/result pairs. [⇒ [[Table Lookup]]]"
      },
      "date": 1694021400710
    },
    {
      "type": "add",
      "id": "57fecb4e72fbcebc",
      "item": {
        "type": "paragraph",
        "id": "57fecb4e72fbcebc",
        "text": "For further and detailed explanations, see\n\n    Ralf Hinze: Memo functions, polytypically!\n    Ralf Hinze: Generalizing generalized tries\n    Conal Elliott: Elegant memoization with functional memo tries and other posts on memoization.\n    Conal Elliott Denotational design with type class morphisms, section 9 (Memo tries)."
      },
      "after": "6506fb46a3f9ae03",
      "date": 1694021547219
    },
    {
      "type": "edit",
      "id": "57fecb4e72fbcebc",
      "item": {
        "type": "paragraph",
        "id": "57fecb4e72fbcebc",
        "text": "For further and detailed explanations, see"
      },
      "date": 1694021560892
    },
    {
      "type": "add",
      "id": "f2f96d2f866f16d4",
      "item": {
        "type": "paragraph",
        "id": "f2f96d2f866f16d4",
        "text": "* Ralf Hinze: Memo functions, polytypically!\n* Ralf Hinze: Generalizing generalized tries\n* Conal Elliott: Elegant memoization with functional memo tries and other posts on memoization.\n* Conal Elliott Denotational design with type class morphisms, section 9 (Memo tries)."
      },
      "after": "57fecb4e72fbcebc",
      "date": 1694021574268
    },
    {
      "type": "edit",
      "id": "f2f96d2f866f16d4",
      "item": {
        "type": "markdown",
        "id": "f2f96d2f866f16d4",
        "text": "* Ralf Hinze: Memo functions, polytypically!\n* Ralf Hinze: Generalizing generalized tries\n* Conal Elliott: Elegant memoization with functional memo tries and other posts on memoization.\n* Conal Elliott Denotational design with type class morphisms, section 9 (Memo tries)."
      },
      "date": 1694021576119
    },
    {
      "type": "edit",
      "id": "f2f96d2f866f16d4",
      "item": {
        "type": "markdown",
        "id": "f2f96d2f866f16d4",
        "text": "* Ralf Hinze: Memo functions, polytypically! [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.3272 page]\n* Ralf Hinze: Generalizing generalized tries\n* Conal Elliott: Elegant memoization with functional memo tries and other posts on memoization.\n* Conal Elliott Denotational design with type class morphisms, section 9 (Memo tries)."
      },
      "date": 1694021617221
    },
    {
      "type": "edit",
      "id": "f2f96d2f866f16d4",
      "item": {
        "type": "markdown",
        "id": "f2f96d2f866f16d4",
        "text": "* Ralf Hinze: Memo functions, polytypically! [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.3272 page]\n* Ralf Hinze: Generalizing generalized tries [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.4069 page]\n* Conal Elliott: Elegant memoization with functional memo tries and other posts on memoization.\n* Conal Elliott Denotational design with type class morphisms, section 9 (Memo tries)."
      },
      "date": 1694024246364
    },
    {
      "type": "edit",
      "id": "f2f96d2f866f16d4",
      "item": {
        "type": "markdown",
        "id": "f2f96d2f866f16d4",
        "text": "* Ralf Hinze: Memo functions, polytypically! [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.3272 page]\n* Ralf Hinze: Generalizing generalized tries [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.4069 page]\n* Conal Elliott: Elegant memoization with functional memo tries [http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries blog] and other posts on memoization.\n* Conal Elliott Denotational design with type class morphisms, section 9 (Memo tries)."
      },
      "date": 1694024309071
    },
    {
      "type": "edit",
      "id": "f2f96d2f866f16d4",
      "item": {
        "type": "markdown",
        "id": "f2f96d2f866f16d4",
        "text": "* Ralf Hinze: Memo functions, polytypically! [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.3272 page]\n* Ralf Hinze: Generalizing generalized tries [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.4069 page]\n* Conal Elliott: Elegant memoization with functional memo tries [http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries post] and other posts on memoization.\n* Conal Elliott Denotational design with type class morphisms, section 9 (Memo tries)."
      },
      "date": 1694024326376
    },
    {
      "type": "edit",
      "id": "f2f96d2f866f16d4",
      "item": {
        "type": "markdown",
        "id": "f2f96d2f866f16d4",
        "text": "* Ralf Hinze: Memo functions, polytypically! [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.3272 page]\n* Ralf Hinze: Generalizing generalized tries [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.4069 page]\n* Conal Elliott: Elegant memoization with functional memo tries [http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries post] and other posts on memoization. [http://conal.net/blog/tag/memoization blog]\n* Conal Elliott Denotational design with type class morphisms, section 9 (Memo tries)."
      },
      "date": 1694024360487
    },
    {
      "type": "edit",
      "id": "f2f96d2f866f16d4",
      "item": {
        "type": "markdown",
        "id": "f2f96d2f866f16d4",
        "text": "* Ralf Hinze: Memo functions, polytypically! [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.3272 page]\n* Ralf Hinze: Generalizing generalized tries [https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.4069 page]\n* Conal Elliott: Elegant memoization with functional memo tries [http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries post] and other posts on memoization. [http://conal.net/blog/tag/memoization blog]\n* Conal Elliott Denotational design with type class morphisms, section 9 (Memo tries). [http://conal.net/papers/type-class-morphisms/ page]"
      },
      "date": 1694024383751
    }
  ]
}