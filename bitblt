{
  "title": "BitBlt",
  "story": [
    {
      "type": "paragraph",
      "id": "41c3ed6ba2a3c018",
      "text": "See [[Bit blit]] (wikipedia)"
    },
    {
      "type": "markdown",
      "id": "f4c22595d00da6ed",
      "text": "I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "95be3d4b880d1c7d",
      "text": "The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:\n\t8:\tif source is 0 and destination is 0\n\t4:\tif source is 0 and destination is 1\n\t2:\tif source is 1 and destination is 0\n\t1:\tif source is 1 and destination is 1.\n\n"
    },
    {
      "type": "markdown",
      "id": "a75afebf82f90f62",
      "text": "At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class [[Form]].\n"
    },
    {
      "type": "markdown",
      "id": "8a838e03ad47568c",
      "text": "In addition to the original 16 combination rules, this BitBlt supports\n\t16\tfails (to simulate paint bits)\n\t17\tfails (to simulate erase bits)\n\t18\tsourceWord + destinationWord\n\t19\tsourceWord - destinationWord\n\t20\trgbAdd: sourceWord with: destinationWord.  Sum of color components\n\t21\trgbSub: sourceWord with: destinationWord.  Difference of color components\n\t22\tOLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components\n\t23\tOLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap\n\t\t\tthese old versions don't do bitwise dest clipping.  Use 32 and 33 now.\n\t24\talphaBlend: sourceWord with: destinationWord.  32-bit source and dest only\n\t25\tpixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.\n\t26\tpixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.\n\t27\trgbMax: sourceWord with: destinationWord.  Max of each color component.\n\t28\trgbMin: sourceWord with: destinationWord.  Min of each color component.\n\t29\trgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)\n\t30\talphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.\n\t31\talphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.\n\t32\trgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components\n\t33\ttallyIntoMap: destinationWord.  Tallies pixValues into a colorMap\n\t34\talphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.\n\nThe color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.\n\nAny transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.\n\tTo make a small Form repeat and fill a big form, use an InfiniteForm as the source.\n\tTo write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.\n\nPixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  \n\nThe colorMap, if specified, must be a either word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source, or a fully specified ColorMap which may contain a lookup table (ie Bitmap) and/or four separate masks and shifts which are applied to the pixels. For every source pixel, BitBlt will first perform masking and shifting and then index the lookup table, and select the corresponding pixelValue and mask it to the destination pixel size before storing.\n\tWhen blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).\n\tNormal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.\n\tColors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "BitBlt",
        "story": []
      },
      "date": 1651751768243
    },
    {
      "item": {
        "type": "factory",
        "id": "41c3ed6ba2a3c018"
      },
      "id": "41c3ed6ba2a3c018",
      "type": "add",
      "date": 1651751781147
    },
    {
      "type": "edit",
      "id": "41c3ed6ba2a3c018",
      "item": {
        "type": "paragraph",
        "id": "41c3ed6ba2a3c018",
        "text": "See [[Bit blit]] (wikipedia)"
      },
      "date": 1651751791496
    },
    {
      "item": {
        "type": "factory",
        "id": "f4c22595d00da6ed"
      },
      "id": "f4c22595d00da6ed",
      "type": "add",
      "after": "41c3ed6ba2a3c018",
      "date": 1655491320047
    },
    {
      "type": "edit",
      "id": "f4c22595d00da6ed",
      "item": {
        "type": "markdown",
        "id": "f4c22595d00da6ed",
        "text": "I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.\n\nThe combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:\n\t8:\tif source is 0 and destination is 0\n\t4:\tif source is 0 and destination is 1\n\t2:\tif source is 1 and destination is 0\n\t1:\tif source is 1 and destination is 1.\nAt each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.\n\nIn addition to the original 16 combination rules, this BitBlt supports\n\t16\tfails (to simulate paint bits)\n\t17\tfails (to simulate erase bits)\n\t18\tsourceWord + destinationWord\n\t19\tsourceWord - destinationWord\n\t20\trgbAdd: sourceWord with: destinationWord.  Sum of color components\n\t21\trgbSub: sourceWord with: destinationWord.  Difference of color components\n\t22\tOLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components\n\t23\tOLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap\n\t\t\tthese old versions don't do bitwise dest clipping.  Use 32 and 33 now.\n\t24\talphaBlend: sourceWord with: destinationWord.  32-bit source and dest only\n\t25\tpixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.\n\t26\tpixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.\n\t27\trgbMax: sourceWord with: destinationWord.  Max of each color component.\n\t28\trgbMin: sourceWord with: destinationWord.  Min of each color component.\n\t29\trgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)\n\t30\talphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.\n\t31\talphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.\n\t32\trgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components\n\t33\ttallyIntoMap: destinationWord.  Tallies pixValues into a colorMap\n\t34\talphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.\n\nThe color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.\n\nAny transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.\n\tTo make a small Form repeat and fill a big form, use an InfiniteForm as the source.\n\tTo write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.\n\nPixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  \n\nThe colorMap, if specified, must be a either word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source, or a fully specified ColorMap which may contain a lookup table (ie Bitmap) and/or four separate masks and shifts which are applied to the pixels. For every source pixel, BitBlt will first perform masking and shifting and then index the lookup table, and select the corresponding pixelValue and mask it to the destination pixel size before storing.\n\tWhen blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).\n\tNormal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.\n\tColors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)"
      },
      "date": 1655491322734
    },
    {
      "type": "edit",
      "id": "f4c22595d00da6ed",
      "item": {
        "type": "markdown",
        "id": "f4c22595d00da6ed",
        "text": "I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.\n\n\n"
      },
      "date": 1655491400393
    },
    {
      "type": "add",
      "id": "95be3d4b880d1c7d",
      "item": {
        "type": "markdown",
        "id": "95be3d4b880d1c7d",
        "text": "The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:\n\t8:\tif source is 0 and destination is 0\n\t4:\tif source is 0 and destination is 1\n\t2:\tif source is 1 and destination is 0\n\t1:\tif source is 1 and destination is 1.\n\n"
      },
      "after": "f4c22595d00da6ed",
      "date": 1655491406591
    },
    {
      "type": "add",
      "id": "a75afebf82f90f62",
      "item": {
        "type": "markdown",
        "id": "a75afebf82f90f62",
        "text": "At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class [[Form]].\n"
      },
      "after": "95be3d4b880d1c7d",
      "date": 1655491418423
    },
    {
      "type": "add",
      "id": "8a838e03ad47568c",
      "item": {
        "type": "markdown",
        "id": "8a838e03ad47568c",
        "text": "\nIn addition to the original 16 combination rules, this BitBlt supports\n\t16\tfails (to simulate paint bits)\n\t17\tfails (to simulate erase bits)\n\t18\tsourceWord + destinationWord\n\t19\tsourceWord - destinationWord\n\t20\trgbAdd: sourceWord with: destinationWord.  Sum of color components\n\t21\trgbSub: sourceWord with: destinationWord.  Difference of color components\n\t22\tOLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components\n\t23\tOLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap\n\t\t\tthese old versions don't do bitwise dest clipping.  Use 32 and 33 now.\n\t24\talphaBlend: sourceWord with: destinationWord.  32-bit source and dest only\n\t25\tpixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.\n\t26\tpixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.\n\t27\trgbMax: sourceWord with: destinationWord.  Max of each color component.\n\t28\trgbMin: sourceWord with: destinationWord.  Min of each color component.\n\t29\trgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)\n\t30\talphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.\n\t31\talphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.\n\t32\trgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components\n\t33\ttallyIntoMap: destinationWord.  Tallies pixValues into a colorMap\n\t34\talphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.\n\nThe color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.\n\nAny transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.\n\tTo make a small Form repeat and fill a big form, use an InfiniteForm as the source.\n\tTo write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.\n\nPixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  \n\nThe colorMap, if specified, must be a either word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source, or a fully specified ColorMap which may contain a lookup table (ie Bitmap) and/or four separate masks and shifts which are applied to the pixels. For every source pixel, BitBlt will first perform masking and shifting and then index the lookup table, and select the corresponding pixelValue and mask it to the destination pixel size before storing.\n\tWhen blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).\n\tNormal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.\n\tColors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)"
      },
      "after": "a75afebf82f90f62",
      "date": 1655491419549
    },
    {
      "type": "edit",
      "id": "8a838e03ad47568c",
      "item": {
        "type": "markdown",
        "id": "8a838e03ad47568c",
        "text": "In addition to the original 16 combination rules, this BitBlt supports\n\t16\tfails (to simulate paint bits)\n\t17\tfails (to simulate erase bits)\n\t18\tsourceWord + destinationWord\n\t19\tsourceWord - destinationWord\n\t20\trgbAdd: sourceWord with: destinationWord.  Sum of color components\n\t21\trgbSub: sourceWord with: destinationWord.  Difference of color components\n\t22\tOLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components\n\t23\tOLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap\n\t\t\tthese old versions don't do bitwise dest clipping.  Use 32 and 33 now.\n\t24\talphaBlend: sourceWord with: destinationWord.  32-bit source and dest only\n\t25\tpixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.\n\t26\tpixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.\n\t27\trgbMax: sourceWord with: destinationWord.  Max of each color component.\n\t28\trgbMin: sourceWord with: destinationWord.  Min of each color component.\n\t29\trgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)\n\t30\talphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.\n\t31\talphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.\n\t32\trgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components\n\t33\ttallyIntoMap: destinationWord.  Tallies pixValues into a colorMap\n\t34\talphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.\n\nThe color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.\n\nAny transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.\n\tTo make a small Form repeat and fill a big form, use an InfiniteForm as the source.\n\tTo write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.\n\nPixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  \n\nThe colorMap, if specified, must be a either word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source, or a fully specified ColorMap which may contain a lookup table (ie Bitmap) and/or four separate masks and shifts which are applied to the pixels. For every source pixel, BitBlt will first perform masking and shifting and then index the lookup table, and select the corresponding pixelValue and mask it to the destination pixel size before storing.\n\tWhen blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).\n\tNormal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.\n\tColors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)"
      },
      "date": 1655491496890
    }
  ]
}