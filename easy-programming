{
  "title": "Easy Programming",
  "story": [
    {
      "type": "paragraph",
      "id": "55253794ba83dd10",
      "text": "A conversation among Ruby programmers got me thinking about why some people are drawn naturally to pair-programming and others aren't. It has to do with their worldviews: programming is either easy or hard."
    },
    {
      "type": "html",
      "id": "b4d26e2ab6a60fa6",
      "text": "<h3> The Worldviews"
    },
    {
      "type": "paragraph",
      "id": "f1ccc1da15ac7bd6",
      "text": "Pair-programming is often misunderstood.\n"
    },
    {
      "type": "paragraph",
      "id": "4a80fd22fa904995",
      "text": "To understand pairing one must examine the worldviews of programmers. For many (perhaps all programmers historically) programming is difficult and requires skill and concentration to be successful. For others, and here we find roots in dynamic languages, programming is easy but requires imagination and interpretation to find success.\n\n"
    },
    {
      "type": "paragraph",
      "id": "c086c31204789269",
      "text": "When two people work together on hard programming their expectation is that skills will be transferred but there will not be sufficient concentration to perform more than educational tasks. Normally there is the mentor and the student. The mentor's judgement is used to decide when the student is skilled enough to work alone.\n\n"
    },
    {
      "type": "paragraph",
      "id": "c5e85041b831d77e",
      "text": "When two people work together on easy programming their expectation is that flights of imagination will be transferred. Long bouts of deep and mandatory concentration interfere with imagination, both in the individual and especially within the pair. When hard problems surface, the easy programmer's strategy is to reframe the problem so as to keep imagination working. (I would famously ask Kent, what is the simplest thing that could possibly work?)\n\n"
    },
    {
      "type": "html",
      "id": "67473a6515442e0d",
      "text": "<h3> The Experience"
    },
    {
      "type": "paragraph",
      "id": "177388e3a61aa934",
      "text": "I like both kinds of programming.\n\n"
    },
    {
      "type": "paragraph",
      "id": "76d8e8c81221cb0a",
      "text": "Hard programming feels like climbing a mountain. There is a goal with a fabulous view. The experience remains personal.\n\n"
    },
    {
      "type": "paragraph",
      "id": "6ca61e9b338eb9cb",
      "text": "Easy programming feels like drifting a river. The fabulous views are all along the way and they are best enjoyed with others.\n\n"
    },
    {
      "type": "paragraph",
      "id": "73234e32311e3fd9",
      "text": "We know more about hard programming than easy programming. Most of us learned our craft by tackling harder and harder problems. The hardest problems have intricate dependencies among many resources and yield only when the programmer can reason about all of them at once. As we become more practiced at this we discover that we are pretty much alone. \n\n"
    },
    {
      "type": "paragraph",
      "id": "8bb94e4c4934bfe6",
      "text": "Easy programming isn't about solving easy problems. "
    },
    {
      "type": "paragraph",
      "id": "496118b8982cbe21",
      "text": "Easy programming has roots in the difficult problems of artificial intelligence. One can assume that just thinking through \"intelligence\" isn't going to work. Instead, in this field,  just discovering a new approach counts as success. Also, a new approach will make both your problem and everyone else's problems easer. "
    },
    {
      "type": "paragraph",
      "id": "1428087fcc8e7802",
      "text": "This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\n"
    },
    {
      "type": "html",
      "id": "56909ef729f0f176",
      "text": "<h3> The Internet"
    },
    {
      "type": "paragraph",
      "id": "3a076ba88de6af12",
      "text": "The internet made easy programming, well, easy.\n\n"
    },
    {
      "type": "paragraph",
      "id": "d40509e4fe265354",
      "text": "Techniques now spreads quickly within the communities of practice that bubble up continuously on the net. Old hands at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. It's all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\n"
    },
    {
      "type": "paragraph",
      "id": "facdac684485dff0",
      "text": "Matz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\n"
    },
    {
      "type": "paragraph",
      "id": "0063ac2994d1f1f2",
      "text": "City leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n"
    },
    {
      "type": "html",
      "id": "abffbddefeb348dd",
      "text": "<h3> Notes"
    },
    {
      "type": "paragraph",
      "id": "38a5b00b2df399cc",
      "text": "The precipitating conversation took place on the Portland Ruby list in November, 2012. [https://groups.google.com/forum/#!msg/pdxruby/9wyVzy-H7yY/-c__ZAxJC1MJ post]"
    },
    {
      "type": "paragraph",
      "id": "d930b6a3d71e6865",
      "text": "Robb Shecter suggested a programmer new to Ruby \"be assigned to another programmer for pair-programming until she's \"got it\". "
    },
    {
      "type": "paragraph",
      "id": "373cab486b1c3aae",
      "text": "Sam Livingston-Gray observed, \"It's the best for her, for you, but mostly, for your organization.\n"
    },
    {
      "type": "paragraph",
      "id": "a52c3400201b30e6",
      "text": "Sam went on, \"I wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Easy Programming"
      },
      "date": 1354206288181
    },
    {
      "item": {
        "type": "factory",
        "id": "55253794ba83dd10"
      },
      "id": "55253794ba83dd10",
      "type": "add",
      "date": 1354206299347
    },
    {
      "type": "edit",
      "id": "55253794ba83dd10",
      "item": {
        "type": "paragraph",
        "id": "55253794ba83dd10",
        "text": "A conversation among Ruby programmers got me thinking about why some people are drawn naturally to pair-programming and others aren't. It has to do with their world views: is programming easy or hard?"
      },
      "date": 1354206439110
    },
    {
      "item": {
        "type": "paragraph",
        "id": "b4d26e2ab6a60fa6",
        "text": "Pair programming is often misunderstood.\n\nTo understand pairing one must examine the world views of programmers. For many (perhaps all programmers historically) programming is difficult and requires skill and concentration to be successful. For others, and here we find roots in dynamic languages, programming is easy but requires imagination and interpretation to find success.\n\nWhen two people work together on hard programming their expectation is that skills will be transferred but there will not be sufficient concentration to perform more than educational tasks. Normally there is the mentor and the student. The mentor's judgement is used to decide when the student is skilled enough to work alone.\n\nWhen two people work together on easy programming their expectation is that flights of imagination will be transferred. Long bouts of deep and mandatory concentration interfere with imagination, both in the individual and especially within the pair. When hard problems surface, the easy programmer's strategy is to reframe the problem so as to keep imagination working. (I would famously ask Kent, what is the simplest thing that could possibly work?)\n\nI like both kinds of programming.\n\nHard programming feels like climbing a mountain. There is a goal with a fabulous view. The experience remains personal.\n\nEasy programming feels like drifting a river. The fabulous views are all along the way and they are best enjoyed with others.\n\nWe know more about hard programming than easy programming. Most of us learned our craft by tackling harder and harder problems. The hardest problems have intricate dependencies among many resources and yield only when the programmer can reason about all of them at once. As we become more practiced at this we discover that we are pretty much alone. \n\nEasy programming isn't about solving easy problems. It's roots are in the most difficult problems: artificial intelligence. We can assume that just thinking thinking through isn't going to work. Instead, just discovering a new approach that brings some leverage to the problem is success. A new approach, a new abstraction, will make your problem easier and everyone else's problems easer too. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\nThe internet made easy programming, well, easy.\n\nTechniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\nMatz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "b4d26e2ab6a60fa6",
      "type": "add",
      "after": "55253794ba83dd10",
      "date": 1354206439621
    },
    {
      "type": "edit",
      "id": "b4d26e2ab6a60fa6",
      "item": {
        "type": "paragraph",
        "id": "b4d26e2ab6a60fa6",
        "text": "<h3>Pair programming is often misunderstood.\n\n"
      },
      "date": 1354206450829
    },
    {
      "item": {
        "type": "paragraph",
        "id": "4a80fd22fa904995",
        "text": "To understand pairing one must examine the world views of programmers. For many (perhaps all programmers historically) programming is difficult and requires skill and concentration to be successful. For others, and here we find roots in dynamic languages, programming is easy but requires imagination and interpretation to find success.\n\nWhen two people work together on hard programming their expectation is that skills will be transferred but there will not be sufficient concentration to perform more than educational tasks. Normally there is the mentor and the student. The mentor's judgement is used to decide when the student is skilled enough to work alone.\n\nWhen two people work together on easy programming their expectation is that flights of imagination will be transferred. Long bouts of deep and mandatory concentration interfere with imagination, both in the individual and especially within the pair. When hard problems surface, the easy programmer's strategy is to reframe the problem so as to keep imagination working. (I would famously ask Kent, what is the simplest thing that could possibly work?)\n\nI like both kinds of programming.\n\nHard programming feels like climbing a mountain. There is a goal with a fabulous view. The experience remains personal.\n\nEasy programming feels like drifting a river. The fabulous views are all along the way and they are best enjoyed with others.\n\nWe know more about hard programming than easy programming. Most of us learned our craft by tackling harder and harder problems. The hardest problems have intricate dependencies among many resources and yield only when the programmer can reason about all of them at once. As we become more practiced at this we discover that we are pretty much alone. \n\nEasy programming isn't about solving easy problems. It's roots are in the most difficult problems: artificial intelligence. We can assume that just thinking thinking through isn't going to work. Instead, just discovering a new approach that brings some leverage to the problem is success. A new approach, a new abstraction, will make your problem easier and everyone else's problems easer too. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\nThe internet made easy programming, well, easy.\n\nTechniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\nMatz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "4a80fd22fa904995",
      "type": "add",
      "after": "b4d26e2ab6a60fa6",
      "date": 1354206451345
    },
    {
      "type": "edit",
      "id": "4a80fd22fa904995",
      "item": {
        "type": "paragraph",
        "id": "4a80fd22fa904995",
        "text": "To understand pairing one must examine the world views of programmers. For many (perhaps all programmers historically) programming is difficult and requires skill and concentration to be successful. For others, and here we find roots in dynamic languages, programming is easy but requires imagination and interpretation to find success.\n\n"
      },
      "date": 1354206463644
    },
    {
      "item": {
        "type": "paragraph",
        "id": "c086c31204789269",
        "text": "When two people work together on hard programming their expectation is that skills will be transferred but there will not be sufficient concentration to perform more than educational tasks. Normally there is the mentor and the student. The mentor's judgement is used to decide when the student is skilled enough to work alone.\n\nWhen two people work together on easy programming their expectation is that flights of imagination will be transferred. Long bouts of deep and mandatory concentration interfere with imagination, both in the individual and especially within the pair. When hard problems surface, the easy programmer's strategy is to reframe the problem so as to keep imagination working. (I would famously ask Kent, what is the simplest thing that could possibly work?)\n\nI like both kinds of programming.\n\nHard programming feels like climbing a mountain. There is a goal with a fabulous view. The experience remains personal.\n\nEasy programming feels like drifting a river. The fabulous views are all along the way and they are best enjoyed with others.\n\nWe know more about hard programming than easy programming. Most of us learned our craft by tackling harder and harder problems. The hardest problems have intricate dependencies among many resources and yield only when the programmer can reason about all of them at once. As we become more practiced at this we discover that we are pretty much alone. \n\nEasy programming isn't about solving easy problems. It's roots are in the most difficult problems: artificial intelligence. We can assume that just thinking thinking through isn't going to work. Instead, just discovering a new approach that brings some leverage to the problem is success. A new approach, a new abstraction, will make your problem easier and everyone else's problems easer too. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\nThe internet made easy programming, well, easy.\n\nTechniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\nMatz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "c086c31204789269",
      "type": "add",
      "after": "4a80fd22fa904995",
      "date": 1354206464153
    },
    {
      "type": "edit",
      "id": "c086c31204789269",
      "item": {
        "type": "paragraph",
        "id": "c086c31204789269",
        "text": "When two people work together on hard programming their expectation is that skills will be transferred but there will not be sufficient concentration to perform more than educational tasks. Normally there is the mentor and the student. The mentor's judgement is used to decide when the student is skilled enough to work alone.\n\n"
      },
      "date": 1354206468605
    },
    {
      "item": {
        "type": "paragraph",
        "id": "c5e85041b831d77e",
        "text": "When two people work together on easy programming their expectation is that flights of imagination will be transferred. Long bouts of deep and mandatory concentration interfere with imagination, both in the individual and especially within the pair. When hard problems surface, the easy programmer's strategy is to reframe the problem so as to keep imagination working. (I would famously ask Kent, what is the simplest thing that could possibly work?)\n\nI like both kinds of programming.\n\nHard programming feels like climbing a mountain. There is a goal with a fabulous view. The experience remains personal.\n\nEasy programming feels like drifting a river. The fabulous views are all along the way and they are best enjoyed with others.\n\nWe know more about hard programming than easy programming. Most of us learned our craft by tackling harder and harder problems. The hardest problems have intricate dependencies among many resources and yield only when the programmer can reason about all of them at once. As we become more practiced at this we discover that we are pretty much alone. \n\nEasy programming isn't about solving easy problems. It's roots are in the most difficult problems: artificial intelligence. We can assume that just thinking thinking through isn't going to work. Instead, just discovering a new approach that brings some leverage to the problem is success. A new approach, a new abstraction, will make your problem easier and everyone else's problems easer too. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\nThe internet made easy programming, well, easy.\n\nTechniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\nMatz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "c5e85041b831d77e",
      "type": "add",
      "after": "c086c31204789269",
      "date": 1354206469118
    },
    {
      "type": "edit",
      "id": "c5e85041b831d77e",
      "item": {
        "type": "paragraph",
        "id": "c5e85041b831d77e",
        "text": "When two people work together on easy programming their expectation is that flights of imagination will be transferred. Long bouts of deep and mandatory concentration interfere with imagination, both in the individual and especially within the pair. When hard problems surface, the easy programmer's strategy is to reframe the problem so as to keep imagination working. (I would famously ask Kent, what is the simplest thing that could possibly work?)\n\n"
      },
      "date": 1354206475348
    },
    {
      "item": {
        "type": "paragraph",
        "id": "67473a6515442e0d",
        "text": "I like both kinds of programming.\n\nHard programming feels like climbing a mountain. There is a goal with a fabulous view. The experience remains personal.\n\nEasy programming feels like drifting a river. The fabulous views are all along the way and they are best enjoyed with others.\n\nWe know more about hard programming than easy programming. Most of us learned our craft by tackling harder and harder problems. The hardest problems have intricate dependencies among many resources and yield only when the programmer can reason about all of them at once. As we become more practiced at this we discover that we are pretty much alone. \n\nEasy programming isn't about solving easy problems. It's roots are in the most difficult problems: artificial intelligence. We can assume that just thinking thinking through isn't going to work. Instead, just discovering a new approach that brings some leverage to the problem is success. A new approach, a new abstraction, will make your problem easier and everyone else's problems easer too. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\nThe internet made easy programming, well, easy.\n\nTechniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\nMatz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "67473a6515442e0d",
      "type": "add",
      "after": "c5e85041b831d77e",
      "date": 1354206475858
    },
    {
      "type": "edit",
      "id": "67473a6515442e0d",
      "item": {
        "type": "paragraph",
        "id": "67473a6515442e0d",
        "text": "<h3> I like both kinds of programming.\n\n"
      },
      "date": 1354206484964
    },
    {
      "item": {
        "type": "paragraph",
        "id": "76d8e8c81221cb0a",
        "text": "Hard programming feels like climbing a mountain. There is a goal with a fabulous view. The experience remains personal.\n\nEasy programming feels like drifting a river. The fabulous views are all along the way and they are best enjoyed with others.\n\nWe know more about hard programming than easy programming. Most of us learned our craft by tackling harder and harder problems. The hardest problems have intricate dependencies among many resources and yield only when the programmer can reason about all of them at once. As we become more practiced at this we discover that we are pretty much alone. \n\nEasy programming isn't about solving easy problems. It's roots are in the most difficult problems: artificial intelligence. We can assume that just thinking thinking through isn't going to work. Instead, just discovering a new approach that brings some leverage to the problem is success. A new approach, a new abstraction, will make your problem easier and everyone else's problems easer too. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\nThe internet made easy programming, well, easy.\n\nTechniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\nMatz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "76d8e8c81221cb0a",
      "type": "add",
      "after": "67473a6515442e0d",
      "date": 1354206485476
    },
    {
      "type": "edit",
      "id": "76d8e8c81221cb0a",
      "item": {
        "type": "paragraph",
        "id": "76d8e8c81221cb0a",
        "text": "Hard programming feels like climbing a mountain. There is a goal with a fabulous view. The experience remains personal.\n\n"
      },
      "date": 1354206487997
    },
    {
      "item": {
        "type": "paragraph",
        "id": "6ca61e9b338eb9cb",
        "text": "Easy programming feels like drifting a river. The fabulous views are all along the way and they are best enjoyed with others.\n\nWe know more about hard programming than easy programming. Most of us learned our craft by tackling harder and harder problems. The hardest problems have intricate dependencies among many resources and yield only when the programmer can reason about all of them at once. As we become more practiced at this we discover that we are pretty much alone. \n\nEasy programming isn't about solving easy problems. It's roots are in the most difficult problems: artificial intelligence. We can assume that just thinking thinking through isn't going to work. Instead, just discovering a new approach that brings some leverage to the problem is success. A new approach, a new abstraction, will make your problem easier and everyone else's problems easer too. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\nThe internet made easy programming, well, easy.\n\nTechniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\nMatz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "6ca61e9b338eb9cb",
      "type": "add",
      "after": "76d8e8c81221cb0a",
      "date": 1354206488506
    },
    {
      "type": "edit",
      "id": "6ca61e9b338eb9cb",
      "item": {
        "type": "paragraph",
        "id": "6ca61e9b338eb9cb",
        "text": "Easy programming feels like drifting a river. The fabulous views are all along the way and they are best enjoyed with others.\n\n"
      },
      "date": 1354206496147
    },
    {
      "item": {
        "type": "paragraph",
        "id": "73234e32311e3fd9",
        "text": "We know more about hard programming than easy programming. Most of us learned our craft by tackling harder and harder problems. The hardest problems have intricate dependencies among many resources and yield only when the programmer can reason about all of them at once. As we become more practiced at this we discover that we are pretty much alone. \n\nEasy programming isn't about solving easy problems. It's roots are in the most difficult problems: artificial intelligence. We can assume that just thinking thinking through isn't going to work. Instead, just discovering a new approach that brings some leverage to the problem is success. A new approach, a new abstraction, will make your problem easier and everyone else's problems easer too. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\nThe internet made easy programming, well, easy.\n\nTechniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\nMatz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "73234e32311e3fd9",
      "type": "add",
      "after": "6ca61e9b338eb9cb",
      "date": 1354206496655
    },
    {
      "type": "edit",
      "id": "73234e32311e3fd9",
      "item": {
        "type": "paragraph",
        "id": "73234e32311e3fd9",
        "text": "We know more about hard programming than easy programming. Most of us learned our craft by tackling harder and harder problems. The hardest problems have intricate dependencies among many resources and yield only when the programmer can reason about all of them at once. As we become more practiced at this we discover that we are pretty much alone. \n\n"
      },
      "date": 1354206503059
    },
    {
      "item": {
        "type": "paragraph",
        "id": "8bb94e4c4934bfe6",
        "text": "Easy programming isn't about solving easy problems. It's roots are in the most difficult problems: artificial intelligence. We can assume that just thinking thinking through isn't going to work. Instead, just discovering a new approach that brings some leverage to the problem is success. A new approach, a new abstraction, will make your problem easier and everyone else's problems easer too. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\nThe internet made easy programming, well, easy.\n\nTechniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\nMatz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "8bb94e4c4934bfe6",
      "type": "add",
      "after": "73234e32311e3fd9",
      "date": 1354206503568
    },
    {
      "type": "edit",
      "id": "8bb94e4c4934bfe6",
      "item": {
        "type": "paragraph",
        "id": "8bb94e4c4934bfe6",
        "text": "Easy programming isn't about solving easy problems. It's roots are in the most difficult problems: artificial intelligence. We can assume that just thinking thinking through isn't going to work. Instead, just discovering a new approach that brings some leverage to the problem is success. A new approach, a new abstraction, will make your problem easier and everyone else's problems easer too. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\n"
      },
      "date": 1354206509116
    },
    {
      "item": {
        "type": "paragraph",
        "id": "56909ef729f0f176",
        "text": "The internet made easy programming, well, easy.\n\nTechniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\nMatz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "56909ef729f0f176",
      "type": "add",
      "after": "8bb94e4c4934bfe6",
      "date": 1354206509623
    },
    {
      "type": "edit",
      "id": "56909ef729f0f176",
      "item": {
        "type": "paragraph",
        "id": "56909ef729f0f176",
        "text": "<h3> The internet made easy programming, well, easy.\n\n"
      },
      "date": 1354206519699
    },
    {
      "item": {
        "type": "paragraph",
        "id": "d40509e4fe265354",
        "text": "Techniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\nMatz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "d40509e4fe265354",
      "type": "add",
      "after": "56909ef729f0f176",
      "date": 1354206520206
    },
    {
      "type": "edit",
      "id": "d40509e4fe265354",
      "item": {
        "type": "paragraph",
        "id": "d40509e4fe265354",
        "text": "Techniques now spreads quickly within the communities of practice that bubble up continuously on the net. An old hand at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. Its all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\n"
      },
      "date": 1354206531716
    },
    {
      "item": {
        "type": "paragraph",
        "id": "facdac684485dff0",
        "text": "Matz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\nCity leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "facdac684485dff0",
      "type": "add",
      "after": "d40509e4fe265354",
      "date": 1354206532226
    },
    {
      "type": "edit",
      "id": "facdac684485dff0",
      "item": {
        "type": "paragraph",
        "id": "facdac684485dff0",
        "text": "Matz channeled Alan Kay and Larry Wall when he set out to give us all easy programming. DHH showed us easy programming could be a business and that just believing that programming could be easy is a barrier to entry. Imagine that?\n\n"
      },
      "date": 1354206535234
    },
    {
      "item": {
        "type": "paragraph",
        "id": "0063ac2994d1f1f2",
        "text": "City leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n\nBest regards. -- Ward\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "0063ac2994d1f1f2",
      "type": "add",
      "after": "facdac684485dff0",
      "date": 1354206535741
    },
    {
      "type": "edit",
      "id": "0063ac2994d1f1f2",
      "item": {
        "type": "paragraph",
        "id": "0063ac2994d1f1f2",
        "text": "City leaders wring their hands about venture funds drawing our best talent south. I wonder if the \"great man\" theory that all VCs hold isn't negated by the mere presence of Calagator and the upcoming Winter Social. Portland might just be the next great easy programming laboratory. Our willingness to work together could be the juice that will push computers forward. We will all have to master pair-programming (not just mentoring) to make this work. It will be awesome.\n"
      },
      "date": 1354206551458
    },
    {
      "item": {
        "type": "paragraph",
        "id": "abffbddefeb348dd",
        "text": "\n\n\n\n\nOn Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "abffbddefeb348dd",
      "type": "add",
      "after": "0063ac2994d1f1f2",
      "date": 1354206551964
    },
    {
      "type": "edit",
      "id": "abffbddefeb348dd",
      "item": {
        "type": "paragraph",
        "id": "abffbddefeb348dd",
        "text": "<h3> Notes\n\n\n\n"
      },
      "date": 1354206597778
    },
    {
      "item": {
        "type": "paragraph",
        "id": "d930b6a3d71e6865",
        "text": "On Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "d930b6a3d71e6865",
      "type": "add",
      "after": "abffbddefeb348dd",
      "date": 1354206598286
    },
    {
      "type": "edit",
      "id": "d930b6a3d71e6865",
      "item": {
        "type": "paragraph",
        "id": "d930b6a3d71e6865",
        "text": "<pre>On Nov 28, 2012, at 11:43 PM, Sam Livingston-Gray wrote:\n\nOn Wed, Nov 28, 2012 at 2:06 PM, Robb Shecter <robb@weblaws.org> wrote:\n* she be assigned to another programmer for pair programming until she's\n\"got it\".\n\nIt's the best for her, for you, but mostly, for your organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "date": 1354206607227
    },
    {
      "type": "edit",
      "id": "d930b6a3d71e6865",
      "item": {
        "type": "paragraph",
        "id": "d930b6a3d71e6865",
        "text": "Robb Shecter suggested a programmer new to Ruby \"be assigned to another programmer for pair programming until she's \"got it\". "
      },
      "date": 1354206760805
    },
    {
      "item": {
        "type": "paragraph",
        "id": "373cab486b1c3aae",
        "text": "It's the best for her, for you, but mostly, for the organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "373cab486b1c3aae",
      "type": "add",
      "after": "d930b6a3d71e6865",
      "date": 1354206761311
    },
    {
      "type": "edit",
      "id": "373cab486b1c3aae",
      "item": {
        "type": "paragraph",
        "id": "373cab486b1c3aae",
        "text": "Sam Livingston-Gray went on to observe \"It's the best for her, for you, but mostly, for the organization.\n\nI wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "date": 1354206798182
    },
    {
      "type": "edit",
      "id": "373cab486b1c3aae",
      "item": {
        "type": "paragraph",
        "id": "373cab486b1c3aae",
        "text": "Sam Livingston-Gray went on to observe \"It's the best for her, for you, but mostly, for the organization.\n\n"
      },
      "date": 1354206813859
    },
    {
      "item": {
        "type": "paragraph",
        "id": "a52c3400201b30e6",
        "text": "I wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?\n\n-Sam\n\n-- "
      },
      "id": "a52c3400201b30e6",
      "type": "add",
      "after": "373cab486b1c3aae",
      "date": 1354206814364
    },
    {
      "type": "edit",
      "id": "a52c3400201b30e6",
      "item": {
        "type": "paragraph",
        "id": "a52c3400201b30e6",
        "text": "Sam went on, \"I wouldn't say I've \"got it\" -- not by a long shot -- but I'm a\nreasonably competent developer who's been using Ruby for six years...\nand even now, the code I commit while pair programming is noticeably\nbetter than the code I hack out by myself.  There are some tasks that\nreally just don't need a pair, but I'm curious why pairing seems to be\nframed here as a temporary or remedial measure, instead of being the\nnorm (or at least *a* norm)?"
      },
      "date": 1354206829002
    },
    {
      "type": "edit",
      "id": "b4d26e2ab6a60fa6",
      "item": {
        "type": "paragraph",
        "id": "b4d26e2ab6a60fa6",
        "text": "<h3>Pair-Programming Misunderstood.\n\n"
      },
      "date": 1354206913233
    },
    {
      "type": "edit",
      "id": "67473a6515442e0d",
      "item": {
        "type": "paragraph",
        "id": "67473a6515442e0d",
        "text": "<h3> Experience"
      },
      "date": 1354207000654
    },
    {
      "item": {
        "type": "paragraph",
        "id": "177388e3a61aa934",
        "text": "I like both kinds of programming.\n\n"
      },
      "id": "177388e3a61aa934",
      "type": "add",
      "after": "67473a6515442e0d",
      "date": 1354207001160
    },
    {
      "type": "edit",
      "id": "67473a6515442e0d",
      "item": {
        "type": "paragraph",
        "id": "67473a6515442e0d",
        "text": "<h3> The Experience"
      },
      "date": 1354207013684
    },
    {
      "type": "edit",
      "id": "b4d26e2ab6a60fa6",
      "item": {
        "type": "paragraph",
        "id": "b4d26e2ab6a60fa6",
        "text": "<h3> The Worldviews"
      },
      "date": 1354207033989
    },
    {
      "item": {
        "type": "paragraph",
        "id": "f1ccc1da15ac7bd6",
        "text": "\n\n"
      },
      "id": "f1ccc1da15ac7bd6",
      "type": "add",
      "after": "b4d26e2ab6a60fa6",
      "date": 1354207034495
    },
    {
      "type": "edit",
      "id": "f1ccc1da15ac7bd6",
      "item": {
        "type": "paragraph",
        "id": "f1ccc1da15ac7bd6",
        "text": "Pair-programming is often misunderstood.\n"
      },
      "date": 1354207049683
    },
    {
      "type": "edit",
      "id": "56909ef729f0f176",
      "item": {
        "type": "paragraph",
        "id": "56909ef729f0f176",
        "text": "<h3> The Internet"
      },
      "date": 1354207093619
    },
    {
      "item": {
        "type": "paragraph",
        "id": "3a076ba88de6af12",
        "text": "The internet made easy programming, well, easy.\n\n"
      },
      "id": "3a076ba88de6af12",
      "type": "add",
      "after": "56909ef729f0f176",
      "date": 1354207094124
    },
    {
      "type": "edit",
      "id": "abffbddefeb348dd",
      "item": {
        "type": "paragraph",
        "id": "abffbddefeb348dd",
        "text": "<h3> Notes"
      },
      "date": 1354207141873
    },
    {
      "item": {
        "type": "paragraph",
        "id": "38a5b00b2df399cc",
        "text": ""
      },
      "id": "38a5b00b2df399cc",
      "type": "add",
      "after": "abffbddefeb348dd",
      "date": 1354207142378
    },
    {
      "type": "edit",
      "id": "38a5b00b2df399cc",
      "item": {
        "type": "paragraph",
        "id": "38a5b00b2df399cc",
        "text": "The precipitating conversation took place on the Portland Ruby list in November, 2012."
      },
      "date": 1354207180914
    },
    {
      "type": "edit",
      "id": "373cab486b1c3aae",
      "item": {
        "type": "paragraph",
        "id": "373cab486b1c3aae",
        "text": "Sam Livingston-Gray went on to observe \"It's the best for her, for you, but mostly, for your organization.\n\n"
      },
      "date": 1354207213825
    },
    {
      "type": "edit",
      "id": "55253794ba83dd10",
      "item": {
        "type": "paragraph",
        "id": "55253794ba83dd10",
        "text": "A conversation among Ruby programmers got me thinking about why some people are drawn naturally to pair-programming and others aren't. It has to do with their worldviews: is programming easy or hard?"
      },
      "date": 1354207340140
    },
    {
      "type": "edit",
      "id": "d40509e4fe265354",
      "item": {
        "type": "paragraph",
        "id": "d40509e4fe265354",
        "text": "Techniques now spreads quickly within the communities of practice that bubble up continuously on the net. Old hands at programming like myself will find that they are as likely to learn a new technique from an intern as an expert. It's all very exciting but a little scary too since nothing ever gets mastered, or so it seams.\n\n"
      },
      "date": 1354210931419
    },
    {
      "type": "edit",
      "id": "38a5b00b2df399cc",
      "item": {
        "type": "paragraph",
        "id": "38a5b00b2df399cc",
        "text": "The precipitating conversation took place on the Portland Ruby list in November, 2012. [https://groups.google.com/forum/#!msg/pdxruby/9wyVzy-H7yY/-c__ZAxJC1MJ post]"
      },
      "date": 1354211090511
    },
    {
      "type": "edit",
      "id": "d930b6a3d71e6865",
      "item": {
        "type": "paragraph",
        "id": "d930b6a3d71e6865",
        "text": "Robb Shecter suggested a programmer new to Ruby \"be assigned to another programmer for pair-programming until she's \"got it\". "
      },
      "date": 1354211144221
    },
    {
      "type": "edit",
      "id": "373cab486b1c3aae",
      "item": {
        "type": "paragraph",
        "id": "373cab486b1c3aae",
        "text": "Sam Livingston-Gray observed \"It's the best for her, for you, but mostly, for your organization.\n"
      },
      "date": 1354211172236
    },
    {
      "type": "edit",
      "id": "d930b6a3d71e6865",
      "item": {
        "type": "paragraph",
        "id": "d930b6a3d71e6865",
        "text": "Robb Shecter suggested a programmer new to Ruby, \"be assigned to another programmer for pair-programming until she's \"got it\". "
      },
      "date": 1354211186164
    },
    {
      "type": "edit",
      "id": "d930b6a3d71e6865",
      "item": {
        "type": "paragraph",
        "id": "d930b6a3d71e6865",
        "text": "Robb Shecter suggested a programmer new to Ruby \"be assigned to another programmer for pair-programming until she's \"got it\". "
      },
      "date": 1354211201996
    },
    {
      "type": "edit",
      "id": "373cab486b1c3aae",
      "item": {
        "type": "paragraph",
        "id": "373cab486b1c3aae",
        "text": "Sam Livingston-Gray observed, \"It's the best for her, for you, but mostly, for your organization.\n"
      },
      "date": 1354211215291
    },
    {
      "type": "edit",
      "id": "55253794ba83dd10",
      "item": {
        "type": "paragraph",
        "id": "55253794ba83dd10",
        "text": "A conversation among Ruby programmers got me thinking about why some people are drawn naturally to pair-programming and others aren't. It has to do with their worldviews: programming is either easy or hard."
      },
      "date": 1354211369111
    },
    {
      "type": "edit",
      "id": "4a80fd22fa904995",
      "item": {
        "type": "paragraph",
        "id": "4a80fd22fa904995",
        "text": "To understand pairing one must examine the worldviews of programmers. For many (perhaps all programmers historically) programming is difficult and requires skill and concentration to be successful. For others, and here we find roots in dynamic languages, programming is easy but requires imagination and interpretation to find success.\n\n"
      },
      "date": 1354211404103
    },
    {
      "type": "edit",
      "id": "8bb94e4c4934bfe6",
      "item": {
        "type": "paragraph",
        "id": "8bb94e4c4934bfe6",
        "text": "Easy programming isn't about solving easy problems. It's roots are in the most difficult problems: artificial intelligence. We can assume that just thinking through \"intelligence\" isn't going to work. Instead, just discovering a new approach that brings some leverage counts as success. A new approach, a new abstraction, for example, will make both your problem and everyone else's problems easer. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\n"
      },
      "date": 1354218307849
    },
    {
      "type": "edit",
      "id": "8bb94e4c4934bfe6",
      "item": {
        "type": "paragraph",
        "id": "8bb94e4c4934bfe6",
        "text": "Easy programming isn't about solving easy problems. It's roots are in the most difficult problems of artificial intelligence. We can assume that just thinking through \"intelligence\" isn't going to work. Instead, just discovering a new approach that brings some leverage counts as success. A new approach, a new abstraction, for example, will make both your problem and everyone else's problems easer. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\n"
      },
      "date": 1354218360606
    },
    {
      "type": "edit",
      "id": "8bb94e4c4934bfe6",
      "item": {
        "type": "paragraph",
        "id": "8bb94e4c4934bfe6",
        "text": "Easy programming isn't about solving easy problems. "
      },
      "date": 1354218383527
    },
    {
      "item": {
        "type": "paragraph",
        "id": "5c49410485d3ffd8",
        "text": " roots are in the most difficult problems of artificial intelligence. We can assume that just thinking through \"intelligence\" isn't going to work. Instead, just discovering a new approach that brings some leverage counts as success. A new approach, a new abstraction, for example, will make both your problem and everyone else's problems easer. This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\n"
      },
      "id": "5c49410485d3ffd8",
      "type": "add",
      "after": "8bb94e4c4934bfe6",
      "date": 1354218384032
    },
    {
      "item": {
        "type": "paragraph",
        "id": "496118b8982cbe21",
        "text": "It's"
      },
      "id": "496118b8982cbe21",
      "type": "add",
      "after": "8bb94e4c4934bfe6",
      "date": 1354218384036
    },
    {
      "type": "remove",
      "id": "5c49410485d3ffd8",
      "date": 1354218403368
    },
    {
      "type": "edit",
      "id": "496118b8982cbe21",
      "item": {
        "type": "paragraph",
        "id": "496118b8982cbe21",
        "text": "Easy programming has roots in the difficult problems of artificial intelligence. One can assume that just thinking through \"intelligence\" isn't going to work. Instead, just discovering a new approach counts as success. Also, a new approach will make both your problem and everyone else's problems easer. "
      },
      "date": 1354218551252
    },
    {
      "item": {
        "type": "paragraph",
        "id": "1428087fcc8e7802",
        "text": "This is how the great AI labs worked. Techniques spread quickly there. The programmers were powerful, but the power didn't spread far beyond Stanford or MIT because there was too much technique to learn outside of those communities.\n\n"
      },
      "id": "1428087fcc8e7802",
      "type": "add",
      "after": "496118b8982cbe21",
      "date": 1354218551757
    },
    {
      "type": "edit",
      "id": "496118b8982cbe21",
      "item": {
        "type": "paragraph",
        "id": "496118b8982cbe21",
        "text": "Easy programming has roots in the difficult problems of artificial intelligence. One can assume that just thinking through \"intelligence\" isn't going to work. Instead, in this field,  just discovering a new approach counts as success. Also, a new approach will make both your problem and everyone else's problems easer. "
      },
      "date": 1354218629143
    },
    {
      "type": "edit",
      "id": "b4d26e2ab6a60fa6",
      "item": {
        "type": "html",
        "id": "b4d26e2ab6a60fa6",
        "text": "<h3> The Worldviews"
      },
      "date": 1420346018313
    },
    {
      "type": "edit",
      "id": "67473a6515442e0d",
      "item": {
        "type": "html",
        "id": "67473a6515442e0d",
        "text": "<h3> The Experience"
      },
      "date": 1420346025973
    },
    {
      "type": "edit",
      "id": "56909ef729f0f176",
      "item": {
        "type": "html",
        "id": "56909ef729f0f176",
        "text": "<h3> The Internet"
      },
      "date": 1420346030310
    },
    {
      "type": "edit",
      "id": "abffbddefeb348dd",
      "item": {
        "type": "html",
        "id": "abffbddefeb348dd",
        "text": "<h3> Notes"
      },
      "date": 1420346033602
    },
    {
      "type": "fork",
      "site": "ward.fed.wiki.org",
      "date": 1662689154589
    }
  ]
}