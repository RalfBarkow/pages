{
  "title": "TestCase",
  "story": [
    {
      "type": "markdown",
      "id": "0cfd9eae4801765b",
      "text": "`TestCase` instances are created with the class method `TestCase class>>#selector:`, passing the symbol that names the method to be executed when the test case runs.  TestCase instances are then executed using the method `TestCase>>#run`. Now usually you do not execute your tests that primitive way\nbut tests are grouped in `TestSuite` (a.k.a. a composite of TestCase) and run using a test runner.\nVarious UIs exist to run these instances and they can also be created and run programmatically.\n\nEach method of a `TestCase` subclass starting with 'test' acts an executable test. When you create a subclass of `TestCase`, the framework automatically builds a test suite from the test methods of such class. \nThe methods `setUp` and `tearDown` are always executed before and after the execution of a test method. You use them to set a specific context in which your test methods are executed. \n\n\n"
    },
    {
      "type": "markdown",
      "id": "b22a4d190bd4781f",
      "text": "### As you go...\n\nWhen you discover a new fixture (context) for your test, encapsulates it in a specific TestCase subclass. \nYou can create a #test... method for the first test.  As that method develops and more #test... methods are added, you will find yourself refactoring temps into instance variables for the objects in the fixture and overriding #setUp to initialize these variables.  \nAs required, override #tearDown to nil references, release objects and deallocate.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "5cc5487a33adcc29",
      "text": "### Design Point\n\nA TestCase is an implementation of the [[Command pattern]] to run a test. \n\n### Mini tutorial - step one\n\nCreate a specific subclass\n\n```\nTestCase << #MyExampleSetTest\n\tpackage: 'MySetTest'\n```\n\n### Mini tutorial - step two \n\nDefine a test method\n\n```\nMyExampleSetTest >> testIncludes\n\t| full empty |\n\tfull := Set with: 5 with: 6.\n\tempty := Set new.\n\tself assert: (full includes: 5).\n\tself assert: (full includes: 6).\n\tself assert: (empty includes: 5) not\n```\t\n\n### Mini tutorial - step three\n\nExecute your tests\n\n```\nMyExampleSetTest run: testIncludes \n```\n\nSee my superclass' comment for assertion and logging information.\n\n### Mini tutorial - step four\n\nCreate a setUp method (add the empty and full instances to the class)\n\n```\nMyExampleSetTest >> setUp\n\tsuper setUp.\n\tempty := Set new.\n\tfull := Set with: 5 with: 6\n```\n\nRedefine your method to avoid duplicating the setUp logic\n```\nMyExampleSetTest >> testIncludes\n\n\tself assert: (full includes: 5).\n\tself assert: (full includes: 6).\n\tself assert: (empty includes: 5) not\n```\t\n\nRun your test!\n\n```\nMyExampleSetTest run: testIncludes \n```\n\nYou are done. Remember tests are your best friends. \nAnd enjoy coding in the debugger."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "TestCase",
        "story": []
      },
      "date": 1654016920934
    },
    {
      "item": {
        "type": "factory",
        "id": "0cfd9eae4801765b"
      },
      "id": "0cfd9eae4801765b",
      "type": "add",
      "date": 1654016922691
    },
    {
      "type": "edit",
      "id": "0cfd9eae4801765b",
      "item": {
        "type": "markdown",
        "id": "0cfd9eae4801765b",
        "text": "`TestCase` instances are created with the class method `TestCase class>>#selector:`, passing the symbol that names the method to be executed when the test case runs.  TestCase instances are then executed using the method `TestCase>>#run`. Now usually you do not execute your tests that primitive way\nbut tests are grouped in `TestSuite` (a.k.a. a composite of TestCase) and run using a test runner.\nVarious UIs exist to run these instances and they can also be created and run programmatically.\n\nEach method of a `TestCase` subclass starting with 'test' acts an executable test. When you create a subclass of `TestCase`, the framework automatically builds a test suite from the test methods of such class. \nThe methods `setUp` and `tearDown` are always executed before and after the execution of a test method. You use them to set a specific context in which your test methods are executed. \n\n### As you go...\n\nWhen you discover a new fixture (context) for your test, encapsulates it in a specific TestCase subclass. \nYou can create a #test... method for the first test.  As that method develops and more #test... methods are added, you will find yourself refactoring temps into instance variables for the objects in the fixture and overriding #setUp to initialize these variables.  \nAs required, override #tearDown to nil references, release objects and deallocate.\n\n### Design Point\n\nA TestCase is an implementation of the Command pattern to run a test. \n\n### Mini tutorial - step one\n\nCreate a specific subclass\n\n```\nTestCase << #MyExampleSetTest\n\tpackage: 'MySetTest'\n```\n\n### Mini tutorial - step two \n\nDefine a test method\n\n```\nMyExampleSetTest >> testIncludes\n\t| full empty |\n\tfull := Set with: 5 with: 6.\n\tempty := Set new.\n\tself assert: (full includes: 5).\n\tself assert: (full includes: 6).\n\tself assert: (empty includes: 5) not\n```\t\n\n### Mini tutorial - step three\n\nExecute your tests\n\n```\nMyExampleSetTest run: testIncludes \n```\n\nSee my superclass' comment for assertion and logging information.\n\n### Mini tutorial - step four\n\nCreate a setUp method (add the empty and full instances to the class)\n\n```\nMyExampleSetTest >> setUp\n\tsuper setUp.\n\tempty := Set new.\n\tfull := Set with: 5 with: 6\n```\n\nRedefine your method to avoid duplicating the setUp logic\n```\nMyExampleSetTest >> testIncludes\n\n\tself assert: (full includes: 5).\n\tself assert: (full includes: 6).\n\tself assert: (empty includes: 5) not\n```\t\n\nRun your test!\n\n```\nMyExampleSetTest run: testIncludes \n```\n\nYou are done. Remember tests are your best friends. \nAnd enjoy coding in the debugger."
      },
      "date": 1654016929189
    },
    {
      "type": "edit",
      "id": "0cfd9eae4801765b",
      "item": {
        "type": "markdown",
        "id": "0cfd9eae4801765b",
        "text": "`TestCase` instances are created with the class method `TestCase class>>#selector:`, passing the symbol that names the method to be executed when the test case runs.  TestCase instances are then executed using the method `TestCase>>#run`. Now usually you do not execute your tests that primitive way\nbut tests are grouped in `TestSuite` (a.k.a. a composite of TestCase) and run using a test runner.\nVarious UIs exist to run these instances and they can also be created and run programmatically.\n\nEach method of a `TestCase` subclass starting with 'test' acts an executable test. When you create a subclass of `TestCase`, the framework automatically builds a test suite from the test methods of such class. \nThe methods `setUp` and `tearDown` are always executed before and after the execution of a test method. You use them to set a specific context in which your test methods are executed. \n\n\n"
      },
      "date": 1654017025512
    },
    {
      "type": "add",
      "id": "b22a4d190bd4781f",
      "item": {
        "type": "markdown",
        "id": "b22a4d190bd4781f",
        "text": "### As you go...\n\nWhen you discover a new fixture (context) for your test, encapsulates it in a specific TestCase subclass. \nYou can create a #test... method for the first test.  As that method develops and more #test... methods are added, you will find yourself refactoring temps into instance variables for the objects in the fixture and overriding #setUp to initialize these variables.  \nAs required, override #tearDown to nil references, release objects and deallocate.\n\n\n"
      },
      "after": "0cfd9eae4801765b",
      "date": 1654017033028
    },
    {
      "type": "add",
      "id": "5cc5487a33adcc29",
      "item": {
        "type": "markdown",
        "id": "5cc5487a33adcc29",
        "text": "### Design Point\n\nA TestCase is an implementation of the [[Command pattern]] to run a test. \n\n### Mini tutorial - step one\n\nCreate a specific subclass\n\n```\nTestCase << #MyExampleSetTest\n\tpackage: 'MySetTest'\n```\n\n### Mini tutorial - step two \n\nDefine a test method\n\n```\nMyExampleSetTest >> testIncludes\n\t| full empty |\n\tfull := Set with: 5 with: 6.\n\tempty := Set new.\n\tself assert: (full includes: 5).\n\tself assert: (full includes: 6).\n\tself assert: (empty includes: 5) not\n```\t\n\n### Mini tutorial - step three\n\nExecute your tests\n\n```\nMyExampleSetTest run: testIncludes \n```\n\nSee my superclass' comment for assertion and logging information.\n\n### Mini tutorial - step four\n\nCreate a setUp method (add the empty and full instances to the class)\n\n```\nMyExampleSetTest >> setUp\n\tsuper setUp.\n\tempty := Set new.\n\tfull := Set with: 5 with: 6\n```\n\nRedefine your method to avoid duplicating the setUp logic\n```\nMyExampleSetTest >> testIncludes\n\n\tself assert: (full includes: 5).\n\tself assert: (full includes: 6).\n\tself assert: (empty includes: 5) not\n```\t\n\nRun your test!\n\n```\nMyExampleSetTest run: testIncludes \n```\n\nYou are done. Remember tests are your best friends. \nAnd enjoy coding in the debugger."
      },
      "after": "b22a4d190bd4781f",
      "date": 1654017042620
    }
  ]
}