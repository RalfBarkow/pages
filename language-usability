{
  "title": "Language Usability",
  "story": [
    {
      "type": "html",
      "text": "<i>[Moved from [[Source Code Is User Interface]].]</i> See also: [[Source Code]]",
      "id": "9d3f5e95265436a8f67a480d2fcdc1e1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nI've always thought <i>[that \"[[Source Code Is User Interface]]\"]</i>, especially when reading [[Language Pissing Match]] flame wars.",
      "id": "c9217cb81a08b9301afc1444375a8593"
    },
    {
      "type": "html",
      "text": "<b>What the software industry needs is  usability testing to show which language features are best at reducing operator (that is, programmer) error and providing other measurable benefits.  Other industries do this, so why not ours?</b>",
      "id": "5c038f2ad42b8de66961a03c31a174f3"
    },
    {
      "type": "html",
      "text": "\nAnd then, when the results have been collected and tabulated, we can design a language based on best principles, and end up with... Smalltalk :-)",
      "id": "50526b6183a8c68070a19a002c21978f"
    },
    {
      "type": "html",
      "text": "\nMaybe, maybe not. [[Usability Is Hard]] to implement, you have to cater to the needs of [[Human Being]]s who are fallible prone to various slips and errors and so adaptable that they will learn something that is [[Hard To Use]] and not want to give it up because they put so much time and energy into learning it in the first place. This last is the cause of most [[Language Pissing Match]] discussions.",
      "id": "e4c44e478734ce065f24a69e1d61221a"
    },
    {
      "type": "html",
      "text": "<i>Usability testing would be hard to do well since it would be almost impossible to use a research protocol that didn't bias the results.</i>",
      "id": "7de67237e62369607485f921cfc9e850"
    },
    {
      "type": "html",
      "text": "\nYou could say that about any human factors experiments, or any \"soft\" science experiments.  You have the same danger in hard science as well. That is why we have the scientific process, peer reviewed publications and repeatable experiments.  Unfortunately, very little \"computer science\" is actually science in the strict sense of the word.",
      "id": "ea266699eb3ea0248c116fc6b6d44787"
    },
    {
      "type": "html",
      "text": "\nThe programming community has a real cultural problem with the concept that [[Source Code Is User Interface]], and that therefore some language features are better than others.  I think this is because programmers think of themselves as a mix of artistic prima donnas and tall-foreheaded geniuses who can understand complex tools that are beyond the ken of normal folk (I know I sometimes do).\nUnfortunately we shoot ourselves in the foot because of it.  Software has the image of being unreliable and insecure because, to use the terminology [[Fred Brooks]] used in [[No Silver Bullet]], our languages force us to work too hard on the \"accidental\" difficulties of programming and so we cannot concentrate on the \"essential\" difficulties where we should be focussing our efforts.",
      "id": "c7c1f0a645141d91279b74241fff0819"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nI get the sense that [[Alan Kay]] and [[Adele Goldberg]] did consider this when writing [[Small Talk]] and that some of the features especially the class browser are directly intended as cognitive support for the programmer. Of course smalltalk does have it's drawbacks, but they are mostly performance related, and even when st falls down (learning the class library) on user interface things it's still much better than most other languages.",
      "id": "95331a2c90ade3b029ff6d21a9d9e555"
    },
    {
      "type": "html",
      "text": "\n[[Python Language]] will eventually be everywhere because [[Guido Van Rossum]] has this figured out. In the middle of a culture that placed a premium on power and flexibility he focused on legibility and ease of use. I've been using IDLE the past month or so and it's surprising how much of [[Small Talk]] has been appropriated and adapted to a more Unixish language. I wonder if Python wasn't designed with [[Worse Is Better]] in mind.",
      "id": "1d509535527659999552f7bf37db108b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nExperiments in language usability have been done. One example is: [http://www.parmita.com/verilogcenter/contest.html www.parmita.com]. The languages in question are two hardware description languages. VHDL is similar (in appearance and philosophy) to the [[Ada Language]]; Verilog is similar to C. Experienced users of each language were asked to tackle a fairly simple design problem using their favoured language. Whilst the results can be debated, the experiment does at least provide a stake in the ground around which language usability experiments can be discussed. --[[Dave Whipp]]",
      "id": "237821fecfc5b7b4beb85f7bcc52183b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nVery interesting, especially the bit about how the various language vendors were all over him trying to spin the results of the test one way or the other.",
      "id": "8a66b31d2cac180f37689cf565172457"
    },
    {
      "type": "html",
      "text": "\nDoes anyone besides me think that the concept of <i>owning a language</i> is just a tad bit strange...",
      "id": "be72bdffdda3e43369f1d5147bbe64ba"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nThis isn't going to be a very scientific discussion, but what language features <i>are</i> more usable than their equivalent in other languages?",
      "id": "cf3c534652e0b17afe30e88fdb2b5f1f"
    },
    {
      "type": "html",
      "text": "\nI'll have a stab.  Feel free to add your own. Maybe we can actually perform some experiments to prove/disprove these assertions?",
      "id": "e7213c904566be0cc7e8ddc4e317b780"
    },
    {
      "type": "html",
      "text": "<b>Assignment</b>",
      "id": "352c7911e9cd37124a14fdb236658ecb"
    },
    {
      "type": "html",
      "text": "\nThe assignment operator should not look like the equality operator.  E.g. the \":=\" of Pascal, Modula, Ada and Smalltalk is less error prone than the \"=\" of C, C++ and Java.  (I believe that there have been studies that show this, but I have been unable to track down references).",
      "id": "47586d5938fb0c1cdb62beda374a383e"
    },
    {
      "type": "html",
      "text": "''This was a problem in C but is pretty much eliminated in Java, since\nassignments aren't expressions in Java.'' [AFAIK, assignment IS an expression in\nJava, but because type checking is stronger in Java (i.e. \"if (x=y)\" is a type error for everything except boolean x and y), most of \"if(x=y)\" errors are caught by the type-checker.]",
      "id": "3f7b31c6e11046aacd5d237c6a40746c"
    },
    {
      "type": "html",
      "text": "\nPerhaps the best would be = for comparison and <- for assignment. ",
      "id": "f0bd45ebced1bf687154cccef2e0013d"
    },
    {
      "type": "html",
      "text": "<b>Function or Method Calls</b>",
      "id": "4f56af9977bd81e86b7a49d88c48260f"
    },
    {
      "type": "html",
      "text": "\nSmalltalk's keyword-based method syntax is more readable than the traditional way of passing tuples of arguments to a function.  This is especially true when deciphering someone else's code.",
      "id": "c2d01aee9066d01ffdfb1d1c0a6c2397"
    },
    {
      "type": "html",
      "text": "<i>Highly debatable.  I've tried languages like Smalltalk,  [[Ml Language]], and [[Forth Language]] (way back when), but gave up largely because the syntax has never seemed natural for me - things run together due to the lack of grouping symbols.  On the other hand, the [[Lisp Language]] goes too far to the other extreme.  A moderate amount of grouping symbols seems best.</i>",
      "id": "9d9b506fe2afc8e0ced18a47f419d6a8"
    },
    {
      "type": "html",
      "text": "''On the other hand, keywords like 'and' and 'or' seem better than\nsymbols.''",
      "id": "e3194e2cdf322f1fdff5a230640356c2"
    },
    {
      "type": "html",
      "text": "\nIn Python, you can do this:",
      "id": "46f97e32653032c844fe315b9dc83ab6"
    },
    {
      "type": "code",
      "text": "  \n  obj.f(x=12, y=24)",
      "id": "a5542bb0a46adf4f25d96a6f52d803d9"
    },
    {
      "type": "html",
      "text": "\nIn [[Objective Caml]], you can do this:",
      "id": "4a3e7dc4586bb86b209e6d009775f723"
    },
    {
      "type": "code",
      "text": "  obj#f x:12 y:24",
      "id": "8b34398bb87f0c8aa96a7a9fc9e66ac3"
    },
    {
      "type": "html",
      "text": "<i>In [[Visual Basic]], you can do this:</i>",
      "id": "b77219d9559ed1dc6e0eb97154bc749e"
    },
    {
      "type": "code",
      "text": "  ThisDocument.SaveAs \"foo.doc\", EmbedTrueTypeFonts := True\n  ",
      "id": "6202d157954433407716b293c27aa840"
    },
    {
      "type": "html",
      "text": "I.e., a combination of Smalltalk-like and C-like. IMHO, this is very readable.",
      "id": "44e16a80ada626487e704c6f95007d09"
    },
    {
      "type": "html",
      "text": "<i>Especially since a lot of Visual Basic for Applications classes have methods with lots and lots of optional arguments.  Without named arguments, the above example would have to be written like this:</i>",
      "id": "2269bca47edf016ad00fe9ba1bb1be28"
    },
    {
      "type": "code",
      "text": "  ThisDocument.SaveAs \"foo.doc\",,,,,,,True",
      "id": "59a0afb40c41f6e8cd6b8eb77dae1167"
    },
    {
      "type": "html",
      "text": "<b>Blocks</b>",
      "id": "3ff9245424ee71da8e031706bc2f3f92"
    },
    {
      "type": "html",
      "text": "\nDefining blocks by indentation, as is done in Miranda, Haskell and Python, is less error prone than defining blocks for the compiler with braces or begin/end keywords <i>and</i> for the human reader with indentation. <i>Moreover, Haskell optionally still allows {} and ;, in order to faciliate writing automatic code generators (thinks like Yacc/Lex).</i> See [[Indentation Equals Grouping]].",
      "id": "a729a0a6cbc4f8ab5eeb1aaf479abc32"
    },
    {
      "type": "html",
      "text": "\nAlternatively: Use different delimiters for different kinds of blocks, so that if the programmer writes \"begin foo ... [50 lines of code deleted] ... end bar\", the interpreter or compiler will catch it.",
      "id": "56094c3e01dbb7f6c135a21c7d5f956d"
    },
    {
      "type": "html",
      "text": "<i>But of course having 50 lines of code between \"begin foo\" and \"end bar\" in the first place is very bad style. Verbose block open-block close construct penalize writing lots of small functions and make writing multi-page functions easier.</i>",
      "id": "40812eaf1fc777d29f704e794ec790bd"
    },
    {
      "type": "html",
      "text": "<b>Nouns and Verbs</b>",
      "id": "31fd05ebf147d1958c10775fb0f28474"
    },
    {
      "type": "html",
      "text": "(moved from [[Adjectives And Adverbs]]:) All natural human languages distinguish nouns and verbs.  A procedure or operator that both returns a value and has side effects is acting like a noun and a verb simultaneously, and therefore is apt to appear in buggy code.  Think of these classic C mistakes:",
      "id": "55403bd72b6bf32f581b7456fb5306a7"
    },
    {
      "type": "code",
      "text": " if (x = 0) { doStuff(); }\n #define MAX(x,y) ( x > y ? x : y )\n /* folks with more experience than I at making C mistakes can add to this */",
      "id": "aa42a9571d17009bc7f356b4577ae20a"
    },
    {
      "type": "html",
      "text": "<i>Is this a language feature, or a use of the language.  Which languages explicitly separate nouns and verbs?  And how do they stop the user making a noun appear to be a verb and vice versa. (And isn't MAX an adjective?).</i>",
      "id": "efb221a91850a15290da49b5921355ae"
    },
    {
      "type": "html",
      "text": "\nNo widely-used languages explicitly separate nouns and verbs (except, perhaps, for the purely functional languages, in which verbs are excluded entirely).  I think this is part of the problem.  For example, suppose the syntax of C treated <i>x = 0</i> as a pure verb (that is, it returns no value) and treated <i>x == 0</i> as a pure noun (that is, it can have no side effect).  Then <i>if (x = 0)</i> would be a compile-time error.",
      "id": "e79b265563c5de5ec4f591c6cab7bf74"
    },
    {
      "type": "html",
      "text": "<i>What about Perl? $scalar_noun, @plural_noun, &verb</i>",
      "id": "7dbd4e0e6da1ac9c9be3a6ebb1bdebb5"
    },
    {
      "type": "html",
      "text": "\nEvery language distinguishes between <i>variables</i> and <i>procedures</i>; that's not what I'm talking about.",
      "id": "9f14779e30bd01215d8e139c0a64bccf"
    },
    {
      "type": "html",
      "text": "<b>Depth Recursion</b>",
      "id": "7228f901c877c53df4318717e9c837e3"
    },
    {
      "type": "html",
      "text": "\nThe mechanism in the human brain that parses sentences has a very shallow stack.  Consider the following sentences (the third from [[Marvin Minsky]]):",
      "id": "396e44fb6c10f535c4bad72e510d3f01"
    },
    {
      "type": "html",
      "text": " The mouse died.",
      "id": "2bce1a9df4e27e021f4089112d329e44"
    },
    {
      "type": "html",
      "text": " The mouse that the cat chased died.",
      "id": "095833c48553feb8220ad3dd858f0ce2"
    },
    {
      "type": "html",
      "text": " The mouse that the cat that the dog chased bit died.",
      "id": "e85205da35870cf88e1cddf53c6ff8ee"
    },
    {
      "type": "html",
      "text": " The dog chased a cat, who bit a mouse, who died.",
      "id": "42ab678e3d681197c4e4a9f85a67c3d5"
    },
    {
      "type": "html",
      "text": "<i>Isn't that third one similar to [[Forth Language]]?  (Or some constructs in [[German Language]], or Greek, see [[The Miracle Of And]])</i>  I was thinking of the sort of hard-to-read Lisp programs that gave Lisp a bad name, but now that you mention it....<i>For those confusing lisp programs, you just need to learn to read them. Most of the standard complex-looking recursive functions are easy if you think of them in terms of: what is the result of one \"loop\" through the function, what changes between \"loops\", and how does it decide to stop? [[The Little Schemer]] is a handy tutorial on this</i>",
      "id": "fbd243eddb7f51a82da59a27badfa65e"
    },
    {
      "type": "html",
      "text": "\nRemember the [[Forth Language]] bumper sticker: I Forth (Heart)? Or the one that said \"Forth (Heart) if honk\"?",
      "id": "027c61c53129e9df8d707471bbabe0c7"
    },
    {
      "type": "html",
      "text": "\nAnd what preposition-retentive critic can quickly parse: \"What did you bring the book I don't like to be read to out of up for?\"",
      "id": "1d19a56478fb6515908a8e057365a020"
    },
    {
      "type": "html",
      "text": "\nAll this reminds me of the little-known but excellent fact that the following is a perfectly grammatical English sentence: \"Oysters oysters oysters split split split\". I shan't explain how to parse it just yet, so as to give any curious readers the chance to work it out. I've read code that feels rather like that sentence... :-)",
      "id": "adca90ca3fb91ea790d780854a6fda95"
    },
    {
      "type": "html",
      "text": "\nRosenfelder's Advanced Language Construction quotes Anne de Roeck in response to the idea of a limit on the size of the mental stack for interior recursion: <i>But don't you find that sentences that people you know produce are easier to understand?</i>",
      "id": "8907dcac034263f8963f00a585048929"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nI think that the focus on individual language features is misplaced:\nA language is \"better\" than another if it makes it easier to solve the problems you're trying to solve.",
      "id": "bebfdb3f0279efe046eb4ff7fe04ec7c"
    },
    {
      "type": "html",
      "text": "\nSo, the \"better or worse\" rating of a tool or language depends heavily on the problem you chose to solve with it.",
      "id": "ad0fec9ae0b0ec8cf86d6d7226b1ae69"
    },
    {
      "type": "html",
      "text": "\nIf you're producing lots of reports, consider using a report generating tool.\nIt will probably be much more effective at its task than C/C++, COBOL, [[Visual Basic]], etc, etc, etc...\nBut the report generating tool will be useless for business screens, server-side business logic, or device drivers.",
      "id": "bcba22a4c44e603012c936f49ea96c64"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nIt's been my experience that the most powerful tools, the ones that give you the greatest leverage -- and hence highest productivity, have a more limited scope.  That is, they're less \"general purpose.\"  So, you trade development efficiency/productivity for limited scope of solutions you can deliver.  -- [[Jeff Grigg]]",
      "id": "ad6a4d6a9c32a11c25537e16ae8ea291"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nAgreed, but this page is about the <i>[[User Interface]]</i> of a language, and that is made up of these individual syntactic features.  That is, the page is not discussing what kewl features we would like to have in a language, but how one should best represent features so that humans can better understand them and understand how they are combined.",
      "id": "3fda8103f877fd5ae0d4e59ac43deb37"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nBut the <b>user interface</b> of a language may actually include a real \"user interface\" -- like [[Visual Basic]]'s GUI for designing forms.  (And there are similar tools for a number of other languages.)  I usually find dragging and dropping and easier way to design business forms than, for example, putting lots of X,Y coordinates into tables in C/C++ code.",
      "id": "5a7dc882223598ef515623889711ef25"
    },
    {
      "type": "html",
      "text": "\nThus, a language, including its development environment, can help or hinder your efforts, depending on the kind of support it gives.  -- [[Jeff Grigg]]",
      "id": "d4d76d3c1624be85bfa1e4cbf2dcf5fb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nPersonally, I find knowing a good [[Graphical User Interface]] framework and typing code to be more efficient than using a GUI builder, especially when you have to tie the application logic to the GUI.  However, visual tools cover only a tiny part of programming, and one that is not the major area for real bugs.  When it comes down to it, GUI programming (at least the kind you can do with a mouse and dialog boxes) is not much more than instantiating objects, setting properties of those objects, and putting objects inside other objects.",
      "id": "f8672557b5a1b999aaac17499db4fbb1"
    },
    {
      "type": "html",
      "text": "\nGetting the logic of a program correct is the hard part and understanding existing logic is even harder.  Those tasks are helped or hindered by how well or badly a language makes that logic comprehensible to a human being.",
      "id": "3e3fd43782f49b03904dbcef7b4664b1"
    },
    {
      "type": "html",
      "text": "\nOur industry has the habit of not addressing this issue, but instead inventing new technologies (GUI builders, Wizards, visual programming, CASE tools) and promising that they will make programming easier.   However, when it comes down to it, complex logic and dynamic relationships have to be programmed in a textual language.  The simple features of a language do have an impact on the quality of software and the ease of its development.",
      "id": "e32c8bc6f19cc2750b4f3baac3c6d57c"
    },
    {
      "type": "html",
      "text": "\nThat's not to say that there may not be more fundamental improvements we can make to languages, such as [[Aspect Oriented Programming]].  However, most of us are still using third generation languages based on the C syntax, the awkward features of which have been known for almost 30 years!",
      "id": "d996a1aa104eca023373ab5d59b49cb5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nIt is important to distinguish between experienced and newbie users. Different people find different interfaces better. In GUIs, menus are good for new users and for rarely used features; power users will [nearly] always prefer keyboard shortcuts. In a language, symbols are good for regular users, but very cryptic for new users and rarely used features. A good example is perl: the symbols in $scalar, @plural, etc. are intimidating for new users but after a couple of hours seem perfectly natural. I recently had a reasonably experienced C programmer ask me what \"^\" means -- he'd never used it and guessed it was \"raise to power\"! Symbols are good for power users, words for others.",
      "id": "6a07574fa2d897f13c1c8ec50e95d384"
    },
    {
      "type": "html",
      "text": "<i>This is exactly what was found with COBOL.  It was designed to be easy to read by non-programmers, and so used thousands of verbose english keywords (\"ADD ITEM-PRICE TO SALES-TOTAL\").  However, studies found that programmers worked better with languages that used mathematical symbols (\"sales_total := sales_total + item_price\").</i>",
      "id": "09b9c3b09f59feadcc6fc4bb2e2c7e5e"
    },
    {
      "type": "html",
      "text": "\nI think it is good to use an [[Model View Controller]] architecture for languages! If you can have several ways of viewing and manipulating the source code then it can be more natural. For example, you might choose between the [[Business Object Notation]]\nand the [[Eiffel Language]]; or between state diagrams and state tables; or between ADFDs and ASL (in [[Shlaer Mellor Method]]). Languages that allow you to choose between concise and verbose representations are nice too.",
      "id": "6c6634b85827bfcf4ad7bb85e50e3cec"
    },
    {
      "type": "html",
      "text": "\nThis is partly a development environment issue, but also a core language issue. If a language is defined largely by its syntax then it is difficult to provide 1:1 mappings into (out of) other representations. Even something as complex as a subset of the UML would have difficulty to provide a 1:1 mapping of c++",
      "id": "842830f9e37762098b13e791d43f552a"
    },
    {
      "type": "html",
      "text": "--[[Dave Whipp]]",
      "id": "1e4ed46ab248152b24853c12ce32d9b0"
    },
    {
      "type": "html",
      "text": "\nI like Dave's  idea of having multiple views on the language, although I can see that it would be very difficult to do well with most of the existing languages. Tools like Together or [[Rational Rose]] do cover some of the problem domain in that they give a better presentation of structure than is possible to acquire from reading the source code and building a diagram in your head, and Together does support some of the switching back and forth but neither addresses the ease of creating correct logical structures using the language.",
      "id": "2ad96ba4deb3c3c605b9f8933d20f5fc"
    },
    {
      "type": "html",
      "text": "\nSome tools that do try to address that are [[Net Rexx]] and Jpython which both layer a simplified syntax over the JVM.  <i>Any high level language provides a more convenient interface to a lower level language, all the way down to assembly being a convenient interface to machine language</i>.",
      "id": "786ce9467d49942e171c9612b2f8bd93"
    },
    {
      "type": "html",
      "text": "\nAs far as the whole GUI bit earlier in the thread.",
      "id": "8c7aef23e944640798df12ba21900cd5"
    },
    {
      "type": "html",
      "text": "\nGUI's work for graphics but they are clumsy and inefficient for modelling logic. Just think after all of how few graphical programming environments have succeeded in the market vs. how many have been tried. (note: the only graphical programming environments I'd consider to be effective are Macromedia Director, and an environment for CNC machine paths a friend showed me; narrowly defined applications both)--[[Larry Price]] <i>For gate-level \"logic\" design, when given a choice between schematics (GUI) or a netlist (text), most hardware engineers would choose the schematics --dw</i>",
      "id": "ce3678de459f3cee12f1d166b20bae08"
    },
    {
      "type": "html",
      "text": "... and Macromedia Director uses a scripting language, Lingo, for specifying animation and logic that is more complex than can be described with its GUI (i.e: most of it).",
      "id": "956c228071ba29d660cbe934235e016d"
    },
    {
      "type": "html",
      "text": "\nI think the GUIs may be a bit of a [[Red Herring]]. You can get multiple non-GUI views. As an example, consider Skill (IL) vs Lisp. Skill uses Lisp semantics for a scripting language within a family of CAD tools. However, it has a C-like front-end syntax that uses [[Infix Notation]] for various common expressions. For example, instead of writing \"(setq c (+ a b))\" you can write \"c=a+b\". Lisp experts (power users) might not appreciate the advantage that this gives to new users.",
      "id": "9c775e1ad1e94f9ffe631bc382666672"
    },
    {
      "type": "html",
      "text": "\nI first used Skill as in intern, about 10 years ago. At the time I knew Pascal and C (plus assembler). The learning curve for the new language was very easy -- basically just a few semicolon rules. As I progressed, I learned to appreciate the underlying power of the Lisp engine. I was soon able to think in Lisp. But for those first few days, whilst my brain didn't know how to scan lisp code, the C look really helped. I think that the Smalltalk community might learn a lesson from this. --dw",
      "id": "2dc256d6e3db5bb62a8e06644acc681f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nAn interesting and underresearched point going beyond [[Language Usability]] are the [[Human Factors]] involved in security holes. Why do developers make the same mistakes in their Web applications over and over again (see e.g. [http://www.owasp.org/ www.owasp.org])? Why do developers love languages so much that allow them to implement buffer overflow bugs in the most efficient manner?",
      "id": "8b4846b91f1066698bbdf1d091b3a336"
    },
    {
      "type": "html",
      "text": "-- [[Sven Tuerpe]]",
      "id": "35e4687a23fe8232ecc842bd51fe3c08"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "\nThere has been a little work in the language usability area. The [[Psychology Of Programming]] people do some, and have developed [[Cognitive Dimensions]], a framework to analyse the usability of visual notations. Also, there's Alice (at [http://www.alice.org www.alice.org]), where they developed an API for 3D programming using many many usability studies (>100 studies). They were so successfull that primary school kids can wrote interactive 3D apps using their tool.",
      "id": "0a18226a2ca1e87160f98369f1ab9f86"
    },
    {
      "type": "html",
      "text": "-- [[Tim Wright]]",
      "id": "e044111db1a2d513be40ad2b4b3932a3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "89f7a10811eed5f505aa3be0a279896e"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?LanguageUsability c2.com]",
      "id": "df59c12754f9332a2403e2a1cbb31f58"
    }
  ],
  "journal": [
    {
      "date": 1413784069000,
      "id": "f37a82e70477642ad69a8b79e4e1be13",
      "type": "create",
      "item": {
        "title": "Language Usability",
        "story": [
          {
            "type": "html",
            "text": "<i>[Moved from [[Source Code Is User Interface]].]</i> See also: [[Source Code]]",
            "id": "9d3f5e95265436a8f67a480d2fcdc1e1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nI've always thought <i>[that \"[[Source Code Is User Interface]]\"]</i>, especially when reading [[Language Pissing Match]] flame wars.",
            "id": "c9217cb81a08b9301afc1444375a8593"
          },
          {
            "type": "html",
            "text": "<b>What the software industry needs is  usability testing to show which language features are best at reducing operator (that is, programmer) error and providing other measurable benefits.  Other industries do this, so why not ours?</b>",
            "id": "5c038f2ad42b8de66961a03c31a174f3"
          },
          {
            "type": "html",
            "text": "\nAnd then, when the results have been collected and tabulated, we can design a language based on best principles, and end up with... Smalltalk :-)",
            "id": "50526b6183a8c68070a19a002c21978f"
          },
          {
            "type": "html",
            "text": "\nMaybe, maybe not. [[Usability Is Hard]] to implement, you have to cater to the needs of [[Human Being]]s who are fallible prone to various slips and errors and so adaptable that they will learn something that is [[Hard To Use]] and not want to give it up because they put so much time and energy into learning it in the first place. This last is the cause of most [[Language Pissing Match]] discussions.",
            "id": "e4c44e478734ce065f24a69e1d61221a"
          },
          {
            "type": "html",
            "text": "<i>Usability testing would be hard to do well since it would be almost impossible to use a research protocol that didn't bias the results.</i>",
            "id": "7de67237e62369607485f921cfc9e850"
          },
          {
            "type": "html",
            "text": "\nYou could say that about any human factors experiments, or any \"soft\" science experiments.  You have the same danger in hard science as well. That is why we have the scientific process, peer reviewed publications and repeatable experiments.  Unfortunately, very little \"computer science\" is actually science in the strict sense of the word.",
            "id": "ea266699eb3ea0248c116fc6b6d44787"
          },
          {
            "type": "html",
            "text": "\nThe programming community has a real cultural problem with the concept that [[Source Code Is User Interface]], and that therefore some language features are better than others.  I think this is because programmers think of themselves as a mix of artistic prima donnas and tall-foreheaded geniuses who can understand complex tools that are beyond the ken of normal folk (I know I sometimes do).\nUnfortunately we shoot ourselves in the foot because of it.  Software has the image of being unreliable and insecure because, to use the terminology [[Fred Brooks]] used in [[No Silver Bullet]], our languages force us to work too hard on the \"accidental\" difficulties of programming and so we cannot concentrate on the \"essential\" difficulties where we should be focussing our efforts.",
            "id": "c7c1f0a645141d91279b74241fff0819"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nI get the sense that [[Alan Kay]] and [[Adele Goldberg]] did consider this when writing [[Small Talk]] and that some of the features especially the class browser are directly intended as cognitive support for the programmer. Of course smalltalk does have it's drawbacks, but they are mostly performance related, and even when st falls down (learning the class library) on user interface things it's still much better than most other languages.",
            "id": "95331a2c90ade3b029ff6d21a9d9e555"
          },
          {
            "type": "html",
            "text": "\n[[Python Language]] will eventually be everywhere because [[Guido Van Rossum]] has this figured out. In the middle of a culture that placed a premium on power and flexibility he focused on legibility and ease of use. I've been using IDLE the past month or so and it's surprising how much of [[Small Talk]] has been appropriated and adapted to a more Unixish language. I wonder if Python wasn't designed with [[Worse Is Better]] in mind.",
            "id": "1d509535527659999552f7bf37db108b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nExperiments in language usability have been done. One example is: [http://www.parmita.com/verilogcenter/contest.html www.parmita.com]. The languages in question are two hardware description languages. VHDL is similar (in appearance and philosophy) to the [[Ada Language]]; Verilog is similar to C. Experienced users of each language were asked to tackle a fairly simple design problem using their favoured language. Whilst the results can be debated, the experiment does at least provide a stake in the ground around which language usability experiments can be discussed. --[[Dave Whipp]]",
            "id": "237821fecfc5b7b4beb85f7bcc52183b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nVery interesting, especially the bit about how the various language vendors were all over him trying to spin the results of the test one way or the other.",
            "id": "8a66b31d2cac180f37689cf565172457"
          },
          {
            "type": "html",
            "text": "\nDoes anyone besides me think that the concept of <i>owning a language</i> is just a tad bit strange...",
            "id": "be72bdffdda3e43369f1d5147bbe64ba"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nThis isn't going to be a very scientific discussion, but what language features <i>are</i> more usable than their equivalent in other languages?",
            "id": "cf3c534652e0b17afe30e88fdb2b5f1f"
          },
          {
            "type": "html",
            "text": "\nI'll have a stab.  Feel free to add your own. Maybe we can actually perform some experiments to prove/disprove these assertions?",
            "id": "e7213c904566be0cc7e8ddc4e317b780"
          },
          {
            "type": "html",
            "text": "<b>Assignment</b>",
            "id": "352c7911e9cd37124a14fdb236658ecb"
          },
          {
            "type": "html",
            "text": "\nThe assignment operator should not look like the equality operator.  E.g. the \":=\" of Pascal, Modula, Ada and Smalltalk is less error prone than the \"=\" of C, C++ and Java.  (I believe that there have been studies that show this, but I have been unable to track down references).",
            "id": "47586d5938fb0c1cdb62beda374a383e"
          },
          {
            "type": "html",
            "text": "''This was a problem in C but is pretty much eliminated in Java, since\nassignments aren't expressions in Java.'' [AFAIK, assignment IS an expression in\nJava, but because type checking is stronger in Java (i.e. \"if (x=y)\" is a type error for everything except boolean x and y), most of \"if(x=y)\" errors are caught by the type-checker.]",
            "id": "3f7b31c6e11046aacd5d237c6a40746c"
          },
          {
            "type": "html",
            "text": "\nPerhaps the best would be = for comparison and <- for assignment. ",
            "id": "f0bd45ebced1bf687154cccef2e0013d"
          },
          {
            "type": "html",
            "text": "<b>Function or Method Calls</b>",
            "id": "4f56af9977bd81e86b7a49d88c48260f"
          },
          {
            "type": "html",
            "text": "\nSmalltalk's keyword-based method syntax is more readable than the traditional way of passing tuples of arguments to a function.  This is especially true when deciphering someone else's code.",
            "id": "c2d01aee9066d01ffdfb1d1c0a6c2397"
          },
          {
            "type": "html",
            "text": "<i>Highly debatable.  I've tried languages like Smalltalk,  [[Ml Language]], and [[Forth Language]] (way back when), but gave up largely because the syntax has never seemed natural for me - things run together due to the lack of grouping symbols.  On the other hand, the [[Lisp Language]] goes too far to the other extreme.  A moderate amount of grouping symbols seems best.</i>",
            "id": "9d9b506fe2afc8e0ced18a47f419d6a8"
          },
          {
            "type": "html",
            "text": "''On the other hand, keywords like 'and' and 'or' seem better than\nsymbols.''",
            "id": "e3194e2cdf322f1fdff5a230640356c2"
          },
          {
            "type": "html",
            "text": "\nIn Python, you can do this:",
            "id": "46f97e32653032c844fe315b9dc83ab6"
          },
          {
            "type": "code",
            "text": "  \n  obj.f(x=12, y=24)",
            "id": "a5542bb0a46adf4f25d96a6f52d803d9"
          },
          {
            "type": "html",
            "text": "\nIn [[Objective Caml]], you can do this:",
            "id": "4a3e7dc4586bb86b209e6d009775f723"
          },
          {
            "type": "code",
            "text": "  obj#f x:12 y:24",
            "id": "8b34398bb87f0c8aa96a7a9fc9e66ac3"
          },
          {
            "type": "html",
            "text": "<i>In [[Visual Basic]], you can do this:</i>",
            "id": "b77219d9559ed1dc6e0eb97154bc749e"
          },
          {
            "type": "code",
            "text": "  ThisDocument.SaveAs \"foo.doc\", EmbedTrueTypeFonts := True\n  ",
            "id": "6202d157954433407716b293c27aa840"
          },
          {
            "type": "html",
            "text": "I.e., a combination of Smalltalk-like and C-like. IMHO, this is very readable.",
            "id": "44e16a80ada626487e704c6f95007d09"
          },
          {
            "type": "html",
            "text": "<i>Especially since a lot of Visual Basic for Applications classes have methods with lots and lots of optional arguments.  Without named arguments, the above example would have to be written like this:</i>",
            "id": "2269bca47edf016ad00fe9ba1bb1be28"
          },
          {
            "type": "code",
            "text": "  ThisDocument.SaveAs \"foo.doc\",,,,,,,True",
            "id": "59a0afb40c41f6e8cd6b8eb77dae1167"
          },
          {
            "type": "html",
            "text": "<b>Blocks</b>",
            "id": "3ff9245424ee71da8e031706bc2f3f92"
          },
          {
            "type": "html",
            "text": "\nDefining blocks by indentation, as is done in Miranda, Haskell and Python, is less error prone than defining blocks for the compiler with braces or begin/end keywords <i>and</i> for the human reader with indentation. <i>Moreover, Haskell optionally still allows {} and ;, in order to faciliate writing automatic code generators (thinks like Yacc/Lex).</i> See [[Indentation Equals Grouping]].",
            "id": "a729a0a6cbc4f8ab5eeb1aaf479abc32"
          },
          {
            "type": "html",
            "text": "\nAlternatively: Use different delimiters for different kinds of blocks, so that if the programmer writes \"begin foo ... [50 lines of code deleted] ... end bar\", the interpreter or compiler will catch it.",
            "id": "56094c3e01dbb7f6c135a21c7d5f956d"
          },
          {
            "type": "html",
            "text": "<i>But of course having 50 lines of code between \"begin foo\" and \"end bar\" in the first place is very bad style. Verbose block open-block close construct penalize writing lots of small functions and make writing multi-page functions easier.</i>",
            "id": "40812eaf1fc777d29f704e794ec790bd"
          },
          {
            "type": "html",
            "text": "<b>Nouns and Verbs</b>",
            "id": "31fd05ebf147d1958c10775fb0f28474"
          },
          {
            "type": "html",
            "text": "(moved from [[Adjectives And Adverbs]]:) All natural human languages distinguish nouns and verbs.  A procedure or operator that both returns a value and has side effects is acting like a noun and a verb simultaneously, and therefore is apt to appear in buggy code.  Think of these classic C mistakes:",
            "id": "55403bd72b6bf32f581b7456fb5306a7"
          },
          {
            "type": "code",
            "text": " if (x = 0) { doStuff(); }\n #define MAX(x,y) ( x > y ? x : y )\n /* folks with more experience than I at making C mistakes can add to this */",
            "id": "aa42a9571d17009bc7f356b4577ae20a"
          },
          {
            "type": "html",
            "text": "<i>Is this a language feature, or a use of the language.  Which languages explicitly separate nouns and verbs?  And how do they stop the user making a noun appear to be a verb and vice versa. (And isn't MAX an adjective?).</i>",
            "id": "efb221a91850a15290da49b5921355ae"
          },
          {
            "type": "html",
            "text": "\nNo widely-used languages explicitly separate nouns and verbs (except, perhaps, for the purely functional languages, in which verbs are excluded entirely).  I think this is part of the problem.  For example, suppose the syntax of C treated <i>x = 0</i> as a pure verb (that is, it returns no value) and treated <i>x == 0</i> as a pure noun (that is, it can have no side effect).  Then <i>if (x = 0)</i> would be a compile-time error.",
            "id": "e79b265563c5de5ec4f591c6cab7bf74"
          },
          {
            "type": "html",
            "text": "<i>What about Perl? $scalar_noun, @plural_noun, &verb</i>",
            "id": "7dbd4e0e6da1ac9c9be3a6ebb1bdebb5"
          },
          {
            "type": "html",
            "text": "\nEvery language distinguishes between <i>variables</i> and <i>procedures</i>; that's not what I'm talking about.",
            "id": "9f14779e30bd01215d8e139c0a64bccf"
          },
          {
            "type": "html",
            "text": "<b>Depth Recursion</b>",
            "id": "7228f901c877c53df4318717e9c837e3"
          },
          {
            "type": "html",
            "text": "\nThe mechanism in the human brain that parses sentences has a very shallow stack.  Consider the following sentences (the third from [[Marvin Minsky]]):",
            "id": "396e44fb6c10f535c4bad72e510d3f01"
          },
          {
            "type": "html",
            "text": " The mouse died.",
            "id": "2bce1a9df4e27e021f4089112d329e44"
          },
          {
            "type": "html",
            "text": " The mouse that the cat chased died.",
            "id": "095833c48553feb8220ad3dd858f0ce2"
          },
          {
            "type": "html",
            "text": " The mouse that the cat that the dog chased bit died.",
            "id": "e85205da35870cf88e1cddf53c6ff8ee"
          },
          {
            "type": "html",
            "text": " The dog chased a cat, who bit a mouse, who died.",
            "id": "42ab678e3d681197c4e4a9f85a67c3d5"
          },
          {
            "type": "html",
            "text": "<i>Isn't that third one similar to [[Forth Language]]?  (Or some constructs in [[German Language]], or Greek, see [[The Miracle Of And]])</i>  I was thinking of the sort of hard-to-read Lisp programs that gave Lisp a bad name, but now that you mention it....<i>For those confusing lisp programs, you just need to learn to read them. Most of the standard complex-looking recursive functions are easy if you think of them in terms of: what is the result of one \"loop\" through the function, what changes between \"loops\", and how does it decide to stop? [[The Little Schemer]] is a handy tutorial on this</i>",
            "id": "fbd243eddb7f51a82da59a27badfa65e"
          },
          {
            "type": "html",
            "text": "\nRemember the [[Forth Language]] bumper sticker: I Forth (Heart)? Or the one that said \"Forth (Heart) if honk\"?",
            "id": "027c61c53129e9df8d707471bbabe0c7"
          },
          {
            "type": "html",
            "text": "\nAnd what preposition-retentive critic can quickly parse: \"What did you bring the book I don't like to be read to out of up for?\"",
            "id": "1d19a56478fb6515908a8e057365a020"
          },
          {
            "type": "html",
            "text": "\nAll this reminds me of the little-known but excellent fact that the following is a perfectly grammatical English sentence: \"Oysters oysters oysters split split split\". I shan't explain how to parse it just yet, so as to give any curious readers the chance to work it out. I've read code that feels rather like that sentence... :-)",
            "id": "adca90ca3fb91ea790d780854a6fda95"
          },
          {
            "type": "html",
            "text": "\nRosenfelder's Advanced Language Construction quotes Anne de Roeck in response to the idea of a limit on the size of the mental stack for interior recursion: <i>But don't you find that sentences that people you know produce are easier to understand?</i>",
            "id": "8907dcac034263f8963f00a585048929"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nI think that the focus on individual language features is misplaced:\nA language is \"better\" than another if it makes it easier to solve the problems you're trying to solve.",
            "id": "bebfdb3f0279efe046eb4ff7fe04ec7c"
          },
          {
            "type": "html",
            "text": "\nSo, the \"better or worse\" rating of a tool or language depends heavily on the problem you chose to solve with it.",
            "id": "ad0fec9ae0b0ec8cf86d6d7226b1ae69"
          },
          {
            "type": "html",
            "text": "\nIf you're producing lots of reports, consider using a report generating tool.\nIt will probably be much more effective at its task than C/C++, COBOL, [[Visual Basic]], etc, etc, etc...\nBut the report generating tool will be useless for business screens, server-side business logic, or device drivers.",
            "id": "bcba22a4c44e603012c936f49ea96c64"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nIt's been my experience that the most powerful tools, the ones that give you the greatest leverage -- and hence highest productivity, have a more limited scope.  That is, they're less \"general purpose.\"  So, you trade development efficiency/productivity for limited scope of solutions you can deliver.  -- [[Jeff Grigg]]",
            "id": "ad6a4d6a9c32a11c25537e16ae8ea291"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nAgreed, but this page is about the <i>[[User Interface]]</i> of a language, and that is made up of these individual syntactic features.  That is, the page is not discussing what kewl features we would like to have in a language, but how one should best represent features so that humans can better understand them and understand how they are combined.",
            "id": "3fda8103f877fd5ae0d4e59ac43deb37"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nBut the <b>user interface</b> of a language may actually include a real \"user interface\" -- like [[Visual Basic]]'s GUI for designing forms.  (And there are similar tools for a number of other languages.)  I usually find dragging and dropping and easier way to design business forms than, for example, putting lots of X,Y coordinates into tables in C/C++ code.",
            "id": "5a7dc882223598ef515623889711ef25"
          },
          {
            "type": "html",
            "text": "\nThus, a language, including its development environment, can help or hinder your efforts, depending on the kind of support it gives.  -- [[Jeff Grigg]]",
            "id": "d4d76d3c1624be85bfa1e4cbf2dcf5fb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nPersonally, I find knowing a good [[Graphical User Interface]] framework and typing code to be more efficient than using a GUI builder, especially when you have to tie the application logic to the GUI.  However, visual tools cover only a tiny part of programming, and one that is not the major area for real bugs.  When it comes down to it, GUI programming (at least the kind you can do with a mouse and dialog boxes) is not much more than instantiating objects, setting properties of those objects, and putting objects inside other objects.",
            "id": "f8672557b5a1b999aaac17499db4fbb1"
          },
          {
            "type": "html",
            "text": "\nGetting the logic of a program correct is the hard part and understanding existing logic is even harder.  Those tasks are helped or hindered by how well or badly a language makes that logic comprehensible to a human being.",
            "id": "3e3fd43782f49b03904dbcef7b4664b1"
          },
          {
            "type": "html",
            "text": "\nOur industry has the habit of not addressing this issue, but instead inventing new technologies (GUI builders, Wizards, visual programming, CASE tools) and promising that they will make programming easier.   However, when it comes down to it, complex logic and dynamic relationships have to be programmed in a textual language.  The simple features of a language do have an impact on the quality of software and the ease of its development.",
            "id": "e32c8bc6f19cc2750b4f3baac3c6d57c"
          },
          {
            "type": "html",
            "text": "\nThat's not to say that there may not be more fundamental improvements we can make to languages, such as [[Aspect Oriented Programming]].  However, most of us are still using third generation languages based on the C syntax, the awkward features of which have been known for almost 30 years!",
            "id": "d996a1aa104eca023373ab5d59b49cb5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nIt is important to distinguish between experienced and newbie users. Different people find different interfaces better. In GUIs, menus are good for new users and for rarely used features; power users will [nearly] always prefer keyboard shortcuts. In a language, symbols are good for regular users, but very cryptic for new users and rarely used features. A good example is perl: the symbols in $scalar, @plural, etc. are intimidating for new users but after a couple of hours seem perfectly natural. I recently had a reasonably experienced C programmer ask me what \"^\" means -- he'd never used it and guessed it was \"raise to power\"! Symbols are good for power users, words for others.",
            "id": "6a07574fa2d897f13c1c8ec50e95d384"
          },
          {
            "type": "html",
            "text": "<i>This is exactly what was found with COBOL.  It was designed to be easy to read by non-programmers, and so used thousands of verbose english keywords (\"ADD ITEM-PRICE TO SALES-TOTAL\").  However, studies found that programmers worked better with languages that used mathematical symbols (\"sales_total := sales_total + item_price\").</i>",
            "id": "09b9c3b09f59feadcc6fc4bb2e2c7e5e"
          },
          {
            "type": "html",
            "text": "\nI think it is good to use an [[Model View Controller]] architecture for languages! If you can have several ways of viewing and manipulating the source code then it can be more natural. For example, you might choose between the [[Business Object Notation]]\nand the [[Eiffel Language]]; or between state diagrams and state tables; or between ADFDs and ASL (in [[Shlaer Mellor Method]]). Languages that allow you to choose between concise and verbose representations are nice too.",
            "id": "6c6634b85827bfcf4ad7bb85e50e3cec"
          },
          {
            "type": "html",
            "text": "\nThis is partly a development environment issue, but also a core language issue. If a language is defined largely by its syntax then it is difficult to provide 1:1 mappings into (out of) other representations. Even something as complex as a subset of the UML would have difficulty to provide a 1:1 mapping of c++",
            "id": "842830f9e37762098b13e791d43f552a"
          },
          {
            "type": "html",
            "text": "--[[Dave Whipp]]",
            "id": "1e4ed46ab248152b24853c12ce32d9b0"
          },
          {
            "type": "html",
            "text": "\nI like Dave's  idea of having multiple views on the language, although I can see that it would be very difficult to do well with most of the existing languages. Tools like Together or [[Rational Rose]] do cover some of the problem domain in that they give a better presentation of structure than is possible to acquire from reading the source code and building a diagram in your head, and Together does support some of the switching back and forth but neither addresses the ease of creating correct logical structures using the language.",
            "id": "2ad96ba4deb3c3c605b9f8933d20f5fc"
          },
          {
            "type": "html",
            "text": "\nSome tools that do try to address that are [[Net Rexx]] and Jpython which both layer a simplified syntax over the JVM.  <i>Any high level language provides a more convenient interface to a lower level language, all the way down to assembly being a convenient interface to machine language</i>.",
            "id": "786ce9467d49942e171c9612b2f8bd93"
          },
          {
            "type": "html",
            "text": "\nAs far as the whole GUI bit earlier in the thread.",
            "id": "8c7aef23e944640798df12ba21900cd5"
          },
          {
            "type": "html",
            "text": "\nGUI's work for graphics but they are clumsy and inefficient for modelling logic. Just think after all of how few graphical programming environments have succeeded in the market vs. how many have been tried. (note: the only graphical programming environments I'd consider to be effective are Macromedia Director, and an environment for CNC machine paths a friend showed me; narrowly defined applications both)--[[Larry Price]] <i>For gate-level \"logic\" design, when given a choice between schematics (GUI) or a netlist (text), most hardware engineers would choose the schematics --dw</i>",
            "id": "ce3678de459f3cee12f1d166b20bae08"
          },
          {
            "type": "html",
            "text": "... and Macromedia Director uses a scripting language, Lingo, for specifying animation and logic that is more complex than can be described with its GUI (i.e: most of it).",
            "id": "956c228071ba29d660cbe934235e016d"
          },
          {
            "type": "html",
            "text": "\nI think the GUIs may be a bit of a [[Red Herring]]. You can get multiple non-GUI views. As an example, consider Skill (IL) vs Lisp. Skill uses Lisp semantics for a scripting language within a family of CAD tools. However, it has a C-like front-end syntax that uses [[Infix Notation]] for various common expressions. For example, instead of writing \"(setq c (+ a b))\" you can write \"c=a+b\". Lisp experts (power users) might not appreciate the advantage that this gives to new users.",
            "id": "9c775e1ad1e94f9ffe631bc382666672"
          },
          {
            "type": "html",
            "text": "\nI first used Skill as in intern, about 10 years ago. At the time I knew Pascal and C (plus assembler). The learning curve for the new language was very easy -- basically just a few semicolon rules. As I progressed, I learned to appreciate the underlying power of the Lisp engine. I was soon able to think in Lisp. But for those first few days, whilst my brain didn't know how to scan lisp code, the C look really helped. I think that the Smalltalk community might learn a lesson from this. --dw",
            "id": "2dc256d6e3db5bb62a8e06644acc681f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nAn interesting and underresearched point going beyond [[Language Usability]] are the [[Human Factors]] involved in security holes. Why do developers make the same mistakes in their Web applications over and over again (see e.g. [http://www.owasp.org/ www.owasp.org])? Why do developers love languages so much that allow them to implement buffer overflow bugs in the most efficient manner?",
            "id": "8b4846b91f1066698bbdf1d091b3a336"
          },
          {
            "type": "html",
            "text": "-- [[Sven Tuerpe]]",
            "id": "35e4687a23fe8232ecc842bd51fe3c08"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "\nThere has been a little work in the language usability area. The [[Psychology Of Programming]] people do some, and have developed [[Cognitive Dimensions]], a framework to analyse the usability of visual notations. Also, there's Alice (at [http://www.alice.org www.alice.org]), where they developed an API for 3D programming using many many usability studies (>100 studies). They were so successfull that primary school kids can wrote interactive 3D apps using their tool.",
            "id": "0a18226a2ca1e87160f98369f1ab9f86"
          },
          {
            "type": "html",
            "text": "-- [[Tim Wright]]",
            "id": "e044111db1a2d513be40ad2b4b3932a3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "89f7a10811eed5f505aa3be0a279896e"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?LanguageUsability c2.com]",
            "id": "df59c12754f9332a2403e2a1cbb31f58"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1707800871245
    }
  ]
}