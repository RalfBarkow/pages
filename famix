{
  "title": "FAMIX",
  "story": [
    {
      "type": "markdown",
      "id": "08ffdc6c2f4eb012",
      "text": "FAMIX started as an interchange model, but within the context of [[GT]] is used as analysis target"
    },
    {
      "type": "paragraph",
      "id": "a6aa0e3cc8dee09f",
      "text": "Now, the essence is not FAMIX, but a model (any model) that represents the system you are interested in."
    },
    {
      "type": "reference",
      "id": "c2fbdcb8d8cd252d",
      "site": "wiki.ralfbarkow.ch",
      "slug": "model",
      "title": "Model",
      "text": "A model is an informal or a formal **representation of a system**, made by an observer, to **distinguish features** of a system which are significant and to predict the consequences of a disturbance or change on the system. Modeling is a process everyone engages in every day. We have a model of the commuter traffic patterns on the way to work, models of the members of our family and our coworkers; in short a model of almost every significant aspect of our lives. If our models are good ones, we will be able to [[make sense]] of the world and predict, with"
    },
    {
      "type": "paragraph",
      "id": "cff59428fb7e6b97",
      "text": "There is no boundary when it comes to the model. The boundaries come from the importers that produce the objects. Of course, the default parsers / importers are about known languages, but that is just a way to sample the space.\nWe worked recently on a few example analyses to show what is possible. Here is an example in which we don't really build a complete FAMIX model, but go directly towards the system specific one (for toggles, in this case): [https://lepiter.io/feenk/steering-agile-architecture-by-example--th-e2p6aps2brbby94deek31xqxh/ Steering Agile Architecture by Example: the Feature Toggles From Open edX]."
    },
    {
      "type": "markdown",
      "id": "19690ac1b99cefb4",
      "text": "See [[Moldable Development]]"
    },
    {
      "type": "reference",
      "id": "78968aed0f431fa1",
      "site": "wiki.ralfbarkow.ch",
      "slug": "jdt2famix",
      "title": "jdt2famix",
      "text": "[https://github.com/feenkcom/jdt2famix/raw/master/doc/jdt2famix.png jdt2famix ]"
    },
    {
      "type": "pagefold",
      "id": "846d32da306935b6",
      "text": "https://pavel-krivanek.github.io/famix/"
    },
    {
      "type": "paragraph",
      "id": "7c35033cfe49f784",
      "text": "Famix is a basic meta-modeling framework for [[Moose]]. It provides building blocks from which you can build own custom meta-model that fits your particular needs while you still can benefit from the advantages that Moose offers. [https://pavel-krivanek.github.io/famix/ site]"
    },
    {
      "type": "markdown",
      "id": "c0cd8fcea6d9b169",
      "text": "## Historical perspective\n"
    },
    {
      "type": "markdown",
      "id": "3d87c07cc9408979",
      "text": "In Moose preceding the versions 7, the FAMIX was a single meta-model that tried to cover the most common properties of all standard languages. This approach has several obvious advantages. With a single meta-model for all languages, you can easily do a software analysis on projects written in them and easily cover very common cases when you have a single project that uses multiple languages at once. The meta-model that provides descriptions of language elements like functions, classes or variables simply uniforms everything into a single frame. "
    },
    {
      "type": "paragraph",
      "id": "fde89c2596411abd",
      "text": "This approach where only one meta-model is used has the single but very important disadvantage: it does not work generally. The FAMIX meta-model described well languages like Java, C#, C, C++ and Smalltalk. However, even in the case of these languages, the description was rough and haven't covered all details it could. For example, in the case of Smalltalk, the FAMIX was not describing entities like slots, traits, shared pools and so on. When you analyzed a model in this language, such details were hidden and slots had to be described only with the concept of instance variables. It was possible to investigate the name of slots, browser their users or computer metrics related to them but by default, FAMIX had no default way of modeling other slot properties like their definition. "
    },
    {
      "type": "paragraph",
      "id": "555a67c2396956d4",
      "text": "The [[Pharo]] as one particular Smalltalk implementation slightly changed the language metamodel in version 7 by an introduction of stateful traits. It was not possible to cover it with the FAMIX meta-model. It was impossible to describe languages like SQL, various types of domain specific languages nor data without significant ad-hoc extensions to the FAMIX meta-model. "
    },
    {
      "type": "paragraph",
      "id": "8695b5b8227952df",
      "text": "The need for meta-model unification lead sometimes to bizarre design decisions that had no sense in particular languages. For example, the methods were owned by general type, not by classes that are only a kind of types. The inheritance was described on the level of types too so then it was possible to theoretically have a Java model that has a primitive type int with several methods and inherits from float. For FAMIX it was still a valid model. "
    },
    {
      "type": "paragraph",
      "id": "4f71b067b8e98378",
      "text": "The basic meta-model for Moose prior versions 7 was named FAMIX (all characters were uppercase). The name for the new generation of the meta-model based on groups of traits is named simply Famix."
    },
    {
      "type": "paragraph",
      "id": "22de5c1f48b4cba2",
      "text": "While FAMIX tried to unify the meta-models for various languages, it had to unite the most common concepts. Let's take a look at a simplified fragment of Java meta-model (figure ). "
    },
    {
      "type": "html",
      "id": "a35f445075793320",
      "text": "<center><img width=\"100%\" src=\"https://pavel-krivanek.github.io/famix/Chapters/Introduction/figures/hierarchy-java.svg\"></center>",
      "alias": "dd3fba2dbdcc783a"
    },
    {
      "type": "paragraph",
      "id": "8c891e6bcd2de04e",
      "text": "Java and C meta-model fragments",
      "alias": "fd01fba4f28405cb"
    },
    {
      "type": "paragraph",
      "id": "1c6929f05824b78b",
      "text": "Java meta-model needs to describe methods and classes. Both of the meta-model elements share some behavior (e.g. they can have a link to source) so they inherit from common superclass JavaEntity. The C language does not have classes or methods. On the other hand, it needs to describe the concept of functions that is not used in Java. ",
      "alias": "b9810e4891b6fd12"
    },
    {
      "type": "paragraph",
      "id": "423ceff7a885236f",
      "text": "The C++ has classes and it the programs can use methods and functions together. Functions and methods are to some extent similar behavioural entities so it makes sense to introduce a common generalization for them. ",
      "alias": "d488b90303f72d3b"
    },
    {
      "type": "html",
      "id": "d3aa05a317e36b8a",
      "text": "<center><img width=\"100%\" src=\"https://pavel-krivanek.github.io/famix/Chapters/Introduction/figures/hierarchy-cpp.svg\"></center>",
      "alias": "8a4fea01cc6c9523"
    },
    {
      "type": "paragraph",
      "id": "3a41bf9e88782fb2",
      "text": "C++ meta-model fragment",
      "alias": "afa80257bfff9070"
    },
    {
      "type": "paragraph",
      "id": "ae7dc8997cf7a0fe",
      "text": "While FAMIX tried to uniform all these languages, its metamodel followed the structure of the C++ metamodel. So when a user analyzed a C program using Moose, the tools provided a lot of data like metrics for classes that had not any sense in the context of the C program. ",
      "alias": "0951331052c537aa"
    },
    {
      "type": "paragraph",
      "id": "f1d31d82543ab547",
      "text": "Next: [[Standalone Meta-Models]]",
      "alias": "3802cbee2c1a0624"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "FAMIX",
        "story": []
      },
      "date": 1635930836788
    },
    {
      "item": {
        "type": "markdown",
        "id": "08ffdc6c2f4eb012",
        "text": "FAMIX started as an interchange model, but within the context of GT is used as analysis target"
      },
      "id": "08ffdc6c2f4eb012",
      "type": "add",
      "date": 1635930838005
    },
    {
      "type": "edit",
      "id": "08ffdc6c2f4eb012",
      "item": {
        "type": "markdown",
        "id": "08ffdc6c2f4eb012",
        "text": "FAMIX started as an interchange model, but within the context of GT is used as analysis target"
      },
      "date": 1635930839855
    },
    {
      "item": {
        "type": "paragraph",
        "id": "a6aa0e3cc8dee09f",
        "text": "Now, the essence is not FAMIX, but a model (any model) that represents the system you are interested in."
      },
      "id": "a6aa0e3cc8dee09f",
      "type": "add",
      "after": "08ffdc6c2f4eb012",
      "date": 1635930848173
    },
    {
      "type": "edit",
      "id": "a6aa0e3cc8dee09f",
      "item": {
        "type": "paragraph",
        "id": "a6aa0e3cc8dee09f",
        "text": "Now, the essence is not FAMIX, but a model (any model) that represents the system you are interested in."
      },
      "date": 1635930849897
    },
    {
      "type": "edit",
      "id": "a6aa0e3cc8dee09f",
      "item": {
        "type": "paragraph",
        "id": "a6aa0e3cc8dee09f",
        "text": "Now, the essence is not FAMIX, but a model (any model) that represents the system you are interested in."
      },
      "date": 1635930922929
    },
    {
      "type": "add",
      "id": "cff59428fb7e6b97",
      "item": {
        "type": "paragraph",
        "id": "cff59428fb7e6b97",
        "text": "There is no boundary when it comes to the model. The boundaries come from the importers that produce the objects. Of course, the default parsers / importers are about known languages, but that is just a way to sample the space.\nWe worked recently on a few example analyses to show what is possible. Here is an example in which we don't really build a complete FAMIX model, but go directly towards the system specific one (for toggles, in this case): https://lepiter.io/feenk/steering-agile-architecture-by-example--th-e2p6aps2brbby94deek31xqxh/"
      },
      "after": "a6aa0e3cc8dee09f",
      "date": 1635930923215
    },
    {
      "item": {
        "type": "factory",
        "id": "c2fbdcb8d8cd252d"
      },
      "id": "c2fbdcb8d8cd252d",
      "type": "add",
      "after": "cff59428fb7e6b97",
      "date": 1635930925093
    },
    {
      "id": "c2fbdcb8d8cd252d",
      "type": "move",
      "order": [
        "08ffdc6c2f4eb012",
        "a6aa0e3cc8dee09f",
        "c2fbdcb8d8cd252d",
        "261bff602c41450a",
        "cff59428fb7e6b97"
      ],
      "date": 1635930928030,
      "error": {
        "type": "error",
        "msg": "",
        "response": "Server Ignoring move. Try reload."
      }
    },
    {
      "type": "fork",
      "date": 1635930930846
    },
    {
      "type": "edit",
      "id": "c2fbdcb8d8cd252d",
      "item": {
        "type": "reference",
        "id": "c2fbdcb8d8cd252d",
        "site": "wiki.ralfbarkow.ch",
        "slug": "model",
        "title": "Model",
        "text": "A model is an informal or a formal **representation of a system**, made by an observer, to **distinguish features** of a system which are significant and to predict the consequences of a disturbance or change on the system. Modeling is a process everyone engages in every day. We have a model of the commuter traffic patterns on the way to work, models of the members of our family and our coworkers; in short a model of almost every significant aspect of our lives. If our models are good ones, we will be able to [[make sense]] of the world and predict, with"
      },
      "date": 1635930933448
    },
    {
      "type": "edit",
      "id": "cff59428fb7e6b97",
      "item": {
        "type": "paragraph",
        "id": "cff59428fb7e6b97",
        "text": "There is no boundary when it comes to the model. The boundaries come from the importers that produce the objects. Of course, the default parsers / importers are about known languages, but that is just a way to sample the space.\nWe worked recently on a few example analyses to show what is possible. Here is an example in which we don't really build a complete FAMIX model, but go directly towards the system specific one (for toggles, in this case): [https://lepiter.io/feenk/steering-agile-architecture-by-example--th-e2p6aps2brbby94deek31xqxh/ Steering Agile Architecture by Example: the Feature Toggles From Open edX]."
      },
      "date": 1635930994304
    },
    {
      "item": {
        "type": "factory",
        "id": "19690ac1b99cefb4"
      },
      "id": "19690ac1b99cefb4",
      "type": "add",
      "after": "cff59428fb7e6b97",
      "date": 1635931018296
    },
    {
      "type": "edit",
      "id": "19690ac1b99cefb4",
      "item": {
        "type": "markdown",
        "id": "19690ac1b99cefb4",
        "text": "See [[Moldable Development]]"
      },
      "date": 1635931025389
    },
    {
      "item": {
        "type": "factory",
        "id": "78968aed0f431fa1"
      },
      "id": "78968aed0f431fa1",
      "type": "add",
      "after": "19690ac1b99cefb4",
      "date": 1635931391899
    },
    {
      "type": "edit",
      "id": "78968aed0f431fa1",
      "item": {
        "type": "reference",
        "id": "78968aed0f431fa1",
        "site": "wiki.ralfbarkow.ch",
        "slug": "jdt2famix",
        "title": "jdt2famix",
        "text": "[https://github.com/feenkcom/jdt2famix/raw/master/doc/jdt2famix.png jdt2famix ]"
      },
      "date": 1635931395309
    },
    {
      "item": {
        "type": "factory",
        "id": "846d32da306935b6"
      },
      "id": "846d32da306935b6",
      "type": "add",
      "after": "78968aed0f431fa1",
      "date": 1640585463424
    },
    {
      "type": "edit",
      "id": "846d32da306935b6",
      "item": {
        "type": "pagefold",
        "id": "846d32da306935b6",
        "text": "https://pavel-krivanek.github.io/famix/"
      },
      "date": 1640585465460
    },
    {
      "item": {
        "type": "factory",
        "id": "7c35033cfe49f784"
      },
      "id": "7c35033cfe49f784",
      "type": "add",
      "after": "846d32da306935b6",
      "date": 1640585467351
    },
    {
      "type": "edit",
      "id": "7c35033cfe49f784",
      "item": {
        "type": "paragraph",
        "id": "7c35033cfe49f784",
        "text": "Famix is a basic meta-modeling framework for Moose. It provides building blocks from which you can build own custom meta-model that fits your particular needs while you still can benefit from the advantages that Moose offers. "
      },
      "date": 1640585473104
    },
    {
      "type": "edit",
      "id": "7c35033cfe49f784",
      "item": {
        "type": "paragraph",
        "id": "7c35033cfe49f784",
        "text": "Famix is a basic meta-modeling framework for [[Moose]]. It provides building blocks from which you can build own custom meta-model that fits your particular needs while you still can benefit from the advantages that Moose offers. "
      },
      "date": 1640585481932
    },
    {
      "item": {
        "type": "factory",
        "id": "c0cd8fcea6d9b169"
      },
      "id": "c0cd8fcea6d9b169",
      "type": "add",
      "after": "7c35033cfe49f784",
      "date": 1640585491835
    },
    {
      "type": "edit",
      "id": "c0cd8fcea6d9b169",
      "item": {
        "type": "markdown",
        "id": "c0cd8fcea6d9b169",
        "text": "## Historical perspective"
      },
      "date": 1640585509492
    },
    {
      "type": "edit",
      "id": "c0cd8fcea6d9b169",
      "item": {
        "type": "markdown",
        "id": "c0cd8fcea6d9b169",
        "text": "## Historical perspective\n"
      },
      "date": 1640585518987
    },
    {
      "type": "add",
      "id": "3d87c07cc9408979",
      "item": {
        "type": "markdown",
        "id": "3d87c07cc9408979",
        "text": "In Moose preceding the versions 7, the FAMIX was a single meta-model that tried to cover the most common properties of all standard languages. This approach has several obvious advantages. With a single meta-model for all languages, you can easily do a software analysis on projects written in them and easily cover very common cases when you have a single project that uses multiple languages at once. The meta-model that provides descriptions of language elements like functions, classes or variables simply uniforms everything into a single frame. "
      },
      "after": "c0cd8fcea6d9b169",
      "date": 1640585519458
    },
    {
      "item": {
        "type": "factory",
        "id": "fde89c2596411abd"
      },
      "id": "fde89c2596411abd",
      "type": "add",
      "after": "3d87c07cc9408979",
      "date": 1640585550113
    },
    {
      "type": "edit",
      "id": "fde89c2596411abd",
      "item": {
        "type": "paragraph",
        "id": "fde89c2596411abd",
        "text": "This approach where only one meta-model is used has the single but very important disadvantage: it does not work generally. The FAMIX meta-model described well languages like Java, C#, C, C++ and Smalltalk. However, even in the case of these languages, the description was rough and haven't covered all details it could. For example, in the case of Smalltalk, the FAMIX was not describing entities like slots, traits, shared pools and so on. When you analyzed a model in this language, such details were hidden and slots had to be described only with the concept of instance variables. It was possible to investigate the name of slots, browser their users or computer metrics related to them but by default, FAMIX had no default way of modeling other slot properties like their definition. "
      },
      "date": 1640585551419
    },
    {
      "type": "add",
      "id": "555a67c2396956d4",
      "item": {
        "type": "paragraph",
        "id": "555a67c2396956d4",
        "text": "The [[Pharo]] as one particular Smalltalk implementation slightly changed the language metamodel in version 7 by an introduction of stateful traits. It was not possible to cover it with the FAMIX meta-model. It was impossible to describe languages like SQL, various types of domain specific languages nor data without significant ad-hoc extensions to the FAMIX meta-model. "
      },
      "after": "fde89c2596411abd",
      "date": 1640585597577
    },
    {
      "type": "add",
      "id": "8695b5b8227952df",
      "item": {
        "type": "paragraph",
        "id": "8695b5b8227952df",
        "text": "The need for meta-model unification lead sometimes to bizarre design decisions that had no sense in particular languages. For example, the methods were owned by general type, not by classes that are only a kind of types. The inheritance was described on the level of types too so then it was possible to theoretically have a Java model that has a primitive type int with several methods and inherits from float. For FAMIX it was still a valid model. "
      },
      "after": "555a67c2396956d4",
      "date": 1640585621599
    },
    {
      "type": "add",
      "id": "4f71b067b8e98378",
      "item": {
        "type": "paragraph",
        "id": "4f71b067b8e98378",
        "text": "The basic meta-model for Moose prior versions 7 was named FAMIX (all characters were uppercase). The name for the new generation of the meta-model based on groups of traits is named simply Famix."
      },
      "after": "8695b5b8227952df",
      "date": 1640585651715
    },
    {
      "item": {
        "type": "factory",
        "id": "dd3fba2dbdcc783a"
      },
      "id": "dd3fba2dbdcc783a",
      "type": "add",
      "after": "22de5c1f48b4cba2",
      "date": 1640585666274
    },
    {
      "type": "add",
      "id": "22de5c1f48b4cba2",
      "item": {
        "type": "paragraph",
        "id": "22de5c1f48b4cba2",
        "text": "While FAMIX tried to unify the meta-models for various languages, it had to unite the most common concepts. Let's take a look at a simplified fragment of Java meta-model (figure ). "
      },
      "after": "4f71b067b8e98378",
      "date": 1640585668467
    },
    {
      "type": "edit",
      "id": "dd3fba2dbdcc783a",
      "item": {
        "type": "html",
        "id": "dd3fba2dbdcc783a",
        "text": "<center><img width=\"100%\" src=\"https://pavel-krivanek.github.io/famix/Chapters/Introduction/figures/hierarchy-java.svg\"></center>"
      },
      "date": 1640585693869
    },
    {
      "item": {
        "type": "factory",
        "id": "fd01fba4f28405cb"
      },
      "id": "fd01fba4f28405cb",
      "type": "add",
      "after": "dd3fba2dbdcc783a",
      "date": 1640585703223
    },
    {
      "type": "edit",
      "id": "fd01fba4f28405cb",
      "item": {
        "type": "paragraph",
        "id": "fd01fba4f28405cb",
        "text": "Java and C meta-model fragments"
      },
      "date": 1640585704706
    },
    {
      "type": "edit",
      "id": "7c35033cfe49f784",
      "item": {
        "type": "paragraph",
        "id": "7c35033cfe49f784",
        "text": "Famix is a basic meta-modeling framework for [[Moose]]. It provides building blocks from which you can build own custom meta-model that fits your particular needs while you still can benefit from the advantages that Moose offers. [https://pavel-krivanek.github.io/famix/ site]"
      },
      "date": 1640585733483
    },
    {
      "type": "edit",
      "id": "08ffdc6c2f4eb012",
      "item": {
        "type": "markdown",
        "id": "08ffdc6c2f4eb012",
        "text": "FAMIX started as an interchange model, but within the context of [[GT]] is used as analysis target"
      },
      "date": 1640585885834
    },
    {
      "item": {
        "type": "factory",
        "id": "b9810e4891b6fd12"
      },
      "id": "b9810e4891b6fd12",
      "type": "add",
      "after": "fd01fba4f28405cb",
      "date": 1640585908437
    },
    {
      "type": "edit",
      "id": "b9810e4891b6fd12",
      "item": {
        "type": "paragraph",
        "id": "b9810e4891b6fd12",
        "text": "Java meta-model needs to describe methods and classes. Both of the meta-model elements share some behavior (e.g. they can have a link to source) so they inherit from common superclass JavaEntity. The C language does not have classes or methods. On the other hand, it needs to describe the concept of functions that is not used in Java. "
      },
      "date": 1640585909722
    },
    {
      "item": {
        "type": "factory",
        "id": "d488b90303f72d3b"
      },
      "id": "d488b90303f72d3b",
      "type": "add",
      "after": "b9810e4891b6fd12",
      "date": 1640585930171
    },
    {
      "type": "edit",
      "id": "d488b90303f72d3b",
      "item": {
        "type": "paragraph",
        "id": "d488b90303f72d3b",
        "text": "The C++ has classes and it the programs can use methods and functions together. Functions and methods are to some extent similar behavioural entities so it makes sense to introduce a common generalization for them. "
      },
      "date": 1640585931817
    },
    {
      "item": {
        "type": "factory",
        "id": "8a4fea01cc6c9523"
      },
      "id": "8a4fea01cc6c9523",
      "type": "add",
      "after": "d488b90303f72d3b",
      "date": 1640585947571
    },
    {
      "type": "edit",
      "id": "8a4fea01cc6c9523",
      "item": {
        "type": "html",
        "id": "8a4fea01cc6c9523",
        "text": "<center><img width=\"100%\" src=\"https://pavel-krivanek.github.io/famix/Chapters/Introduction/figures/hierarchy-cpp.svg\"></center>"
      },
      "date": 1640585961346
    },
    {
      "item": {
        "type": "factory",
        "id": "afa80257bfff9070"
      },
      "id": "afa80257bfff9070",
      "type": "add",
      "after": "8a4fea01cc6c9523",
      "date": 1640585971750
    },
    {
      "type": "edit",
      "id": "afa80257bfff9070",
      "item": {
        "type": "paragraph",
        "id": "afa80257bfff9070",
        "text": "C++ meta-model fragment"
      },
      "date": 1640585973343
    },
    {
      "item": {
        "type": "factory",
        "id": "0951331052c537aa"
      },
      "id": "0951331052c537aa",
      "type": "add",
      "after": "afa80257bfff9070",
      "date": 1640585980143
    },
    {
      "type": "edit",
      "id": "0951331052c537aa",
      "item": {
        "type": "paragraph",
        "id": "0951331052c537aa",
        "text": "While FAMIX tried to uniform all these languages, its metamodel followed the structure of the C++ metamodel. So when a user analyzed a C program using Moose, the tools provided a lot of data like metrics for classes that had not any sense in the context of the C program. "
      },
      "date": 1640585981770
    },
    {
      "item": {
        "type": "factory",
        "id": "3802cbee2c1a0624"
      },
      "id": "3802cbee2c1a0624",
      "type": "add",
      "after": "0951331052c537aa",
      "date": 1640586000884
    },
    {
      "type": "edit",
      "id": "3802cbee2c1a0624",
      "item": {
        "type": "paragraph",
        "id": "3802cbee2c1a0624",
        "text": "Next: [[Standalone Meta-Models]]"
      },
      "date": 1640586008141
    },
    {
      "id": "a35f445075793320",
      "type": "add",
      "item": {
        "type": "html",
        "id": "a35f445075793320",
        "text": "<center><img width=\"100%\" src=\"https://pavel-krivanek.github.io/famix/Chapters/Introduction/figures/hierarchy-java.svg\"></center>",
        "alias": "dd3fba2dbdcc783a"
      },
      "after": "22de5c1f48b4cba2",
      "date": 1640601550355
    },
    {
      "id": "8c891e6bcd2de04e",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "8c891e6bcd2de04e",
        "text": "Java and C meta-model fragments",
        "alias": "fd01fba4f28405cb"
      },
      "after": "a35f445075793320",
      "date": 1640601553422
    },
    {
      "id": "1c6929f05824b78b",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "1c6929f05824b78b",
        "text": "Java meta-model needs to describe methods and classes. Both of the meta-model elements share some behavior (e.g. they can have a link to source) so they inherit from common superclass JavaEntity. The C language does not have classes or methods. On the other hand, it needs to describe the concept of functions that is not used in Java. ",
        "alias": "b9810e4891b6fd12"
      },
      "after": "8c891e6bcd2de04e",
      "date": 1640601561649
    },
    {
      "id": "423ceff7a885236f",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "423ceff7a885236f",
        "text": "The C++ has classes and it the programs can use methods and functions together. Functions and methods are to some extent similar behavioural entities so it makes sense to introduce a common generalization for them. ",
        "alias": "d488b90303f72d3b"
      },
      "after": "1c6929f05824b78b",
      "date": 1640601571929
    },
    {
      "id": "d3aa05a317e36b8a",
      "type": "add",
      "item": {
        "type": "html",
        "id": "d3aa05a317e36b8a",
        "text": "<center><img width=\"100%\" src=\"https://pavel-krivanek.github.io/famix/Chapters/Introduction/figures/hierarchy-cpp.svg\"></center>",
        "alias": "8a4fea01cc6c9523"
      },
      "after": "423ceff7a885236f",
      "date": 1640601577949
    },
    {
      "id": "3a41bf9e88782fb2",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "3a41bf9e88782fb2",
        "text": "C++ meta-model fragment",
        "alias": "afa80257bfff9070"
      },
      "after": "d3aa05a317e36b8a",
      "date": 1640601583664
    },
    {
      "id": "ae7dc8997cf7a0fe",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "ae7dc8997cf7a0fe",
        "text": "While FAMIX tried to uniform all these languages, its metamodel followed the structure of the C++ metamodel. So when a user analyzed a C program using Moose, the tools provided a lot of data like metrics for classes that had not any sense in the context of the C program. ",
        "alias": "0951331052c537aa"
      },
      "after": "3a41bf9e88782fb2",
      "date": 1640601586655
    },
    {
      "id": "f1d31d82543ab547",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "f1d31d82543ab547",
        "text": "Next: [[Standalone Meta-Models]]",
        "alias": "3802cbee2c1a0624"
      },
      "after": "ae7dc8997cf7a0fe",
      "date": 1640601590526
    },
    {
      "type": "remove",
      "id": "dd3fba2dbdcc783a",
      "date": 1640601598353
    },
    {
      "type": "remove",
      "id": "fd01fba4f28405cb",
      "date": 1640601599991
    },
    {
      "type": "remove",
      "id": "b9810e4891b6fd12",
      "date": 1640601601506
    },
    {
      "type": "remove",
      "id": "d488b90303f72d3b",
      "date": 1640601602786
    },
    {
      "type": "remove",
      "id": "8a4fea01cc6c9523",
      "date": 1640601604622
    },
    {
      "type": "remove",
      "id": "0951331052c537aa",
      "date": 1640601609012
    },
    {
      "type": "remove",
      "id": "afa80257bfff9070",
      "date": 1640601613740
    },
    {
      "type": "remove",
      "id": "3802cbee2c1a0624",
      "date": 1640601617121
    }
  ]
}