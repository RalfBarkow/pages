{
  "title": "graph.js",
  "story": [
    {
      "type": "code",
      "id": "02c649409cf414d9",
      "text": "'use strict';\n\nimport * as cypher from './cypher.js'\n\nconst uniq = (value, index, self) => self.indexOf(value) === index\n\nexport class Graph {\n  constructor(nodes=[], rels=[]) {\n    this.nodes = nodes;\n    this.rels = rels;\n  }\n\n  addNode(type, props={}){\n    const obj = {type, in:[], out:[], props};\n    this.nodes.push(obj);\n    return this.nodes.length-1;\n  }\n\n  addRel(type, from, to, props={}) {\n    const obj = {type, from, to, props};\n    this.rels.push(obj);\n    const rid = this.rels.length-1;\n    this.nodes[from].out.push(rid)\n    this.nodes[to].in.push(rid);\n    return rid;\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { nodes:tally(this.nodes), rels:tally(this.rels)};\n  }\n\n  size(){\n    return this.nodes.length + this.rels.length;\n  }\n\n  static load(obj) {\n    // let obj = await fetch(url).then(res => res.json())\n    return new Graph(obj.nodes, obj.rels)\n  }\n\n  static async fetch(url) {\n    const obj = await fetch(url).then(res => res.json())\n    return Graph.load(obj)\n  }\n\n  static async read(path) {\n    const json = await Deno.readTextFile(path);\n    const obj = JSON.parse(json);\n    return Graph.load(obj)\n  }\n\n  // static async import(path) {\n  //   let module = await import(path, {assert: {type: \"json\"}})\n  //   return Graph.load(module.default)\n  // }\n\n  n(type=null, props={}) {\n    let nids = Object.keys(this.nodes).map(key => +key)\n    if (type) nids = nids.filter(nid => this.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.nodes[nid].props[key] == props[key])\n    return new Nodes(this, nids)\n  }\n\n  /**\n   * Converts a graph to a JavaScript Object Notation (JSON) string using JSON.stringify.\n   @param - replacer A function that transforms the results.\n   @param - space Adds indentation, white space, and line break characters to the return-\n   * @returns {string} JSON string containing serialized graph\n  */\n  stringify(...args) {\n    const obj = { nodes: this.nodes, rels: this.rels }\n    return JSON.stringify(obj, ...args)\n  }\n\n\n  search (query, opt={}) {\n    const tree = cypher.parse(query)\n    // console.dir(tree, {depth:15})\n    const code = cypher.gen(0,tree[0][0],{})\n    // console.log(code)\n    cypher.check(this.tally(),code,opt.errors)\n    return cypher.apply(this, code)\n  }\n\n}\n\n\n\n\n\n\n// Fluent Interface (deprecated?)\n\nexport class Nodes {\n  constructor (graph, nids) {\n    // console.log('Nodes',{graph:graph.size(),type,nids})\n    this.graph = graph\n    this.nids = nids\n  }\n\n  // n(type=null, props={}) {\n  //   // console.log('Nodes.n',{type,props})\n  //   let nids = this.nids\n  //   if (type) nids = nids.filter(nid => this.nodes[nid].type == type)\n  //   for (let key in props) nids = nids.filter(nid => this.nodes[nid].props[key] == props[key])\n  //   return new Nodes(this.graph, type, nids)\n  // }\n\n  i(type=null, props={}) {\n    // console.log('Nodes.i',{type,props})\n    let rids = this.nids.map(nid => this.graph.nodes[nid].in).flat().filter(uniq)\n    if (type) rids = rids.filter(rid => this.graph.rels[rid].type == type)\n    for (const key in props) rids = rids.filter(rid => this.graph.rels[rid].props[key] == props[key])\n    return new Rels(this.graph, rids)\n  }\n\n  o(type=null, props={}) {\n    // console.log('Nodes.o',{type,props})\n    let rids = this.nids.map(nid => this.graph.nodes[nid].out).flat().filter(uniq)\n    if (type) rids = rids.filter(rid => this.graph.rels[rid].type == type)\n    for (const key in props) rids = rids.filter(rid => this.graph.rels[rid].props[key] == props[key])\n    return new Rels(this.graph, rids)\n  }\n\n  props(key='name') {\n    // console.log('Nodes.p',{key})\n    return this.nids.map(nid => this.graph.nodes[nid].props[key]).filter(uniq).sort()\n  }\n\n  types() {\n    return this.nids.map(nid => this.graph.nodes[nid].type).filter(uniq).sort()\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { nodes:tally(this.nids.map(nid => this.graph.nodes[nid]))};\n  }\n\n  size(){\n    return this.nids.length\n  }\n\n  filter(f) {\n    const nodes = this.graph.nodes\n    const nids = this.nids.filter(nid => {\n      const node = nodes[nid]\n      return f(node.type,node.props)\n    })\n    return new Nodes(this.graph,nids)\n  }\n\n  map(f) {\n    const nodes = this.graph.nodes\n    const result = this.nids.map(nid => {\n      const node = nodes[nid]\n      return f(node)\n    })\n    return result\n  }\n}\n\nexport class Rels {\n  constructor (graph, rids) {\n    // console.log('Rels',{graph:graph.size(),type,rids})\n    this.graph = graph\n    this.rids = rids\n  }\n\n  f(type=null, props={}) {\n    // console.log('Rels.f',{type,props})\n    let nids = this.rids.map(rid => this.graph.rels[rid].from).filter(uniq)\n    if (type) nids = nids.filter(nid => this.graph.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.graph.nodes[nid].props[key] == props[key])\n    return new Nodes(this.graph, nids)\n  }\n\n  t(type=null, props={}) {\n    // console.log('Rels.t',{type,props})\n    let nids = this.rids.map(rid => this.graph.rels[rid].to).filter(uniq)\n    if (type) nids = nids.filter(nid => this.graph.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.graph.nodes[nid].props[key] == props[key])\n    return new Nodes(this.graph, nids)\n  }\n\n  props(key='name') {\n    // console.log('Rels.p',{key})\n    return this.rids.map(rid => this.graph.rels[rid].props[key]).filter(uniq).sort()\n  }\n\n  types() {\n    return this.rids.map(rid => this.graph.rels[rid].type).filter(uniq).sort()\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { rels:tally(this.rids.map(nid => this.graph.rels[nid]))};\n  }\n\n  size(){\n    return this.rids.length\n  }\n\n  filter(f) {\n    const rels = this.graph.rels\n    const rids = this.rids.filter(rid => {\n      const rel = rels[rid]\n      return f(rel.type,rel.props)\n    })\n    return new Rels(this.graph,rids)\n  }\n\n  map(f) {\n    const rels = this.graph.rels\n    const result = this.rids.map(rid => {\n      const rel = rels[rid]\n      return f(rel)\n    })\n    return result\n  }\n}"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "graph.js",
        "story": []
      },
      "date": 1664083321323
    },
    {
      "item": {
        "type": "factory",
        "id": "02c649409cf414d9"
      },
      "id": "02c649409cf414d9",
      "type": "add",
      "date": 1664083322662
    },
    {
      "type": "edit",
      "id": "02c649409cf414d9",
      "item": {
        "type": "code",
        "id": "02c649409cf414d9",
        "text": "'use strict';\n\nimport * as cypher from './cypher.js'\n\nconst uniq = (value, index, self) => self.indexOf(value) === index\n\nexport class Graph {\n  constructor(nodes=[], rels=[]) {\n    this.nodes = nodes;\n    this.rels = rels;\n  }\n\n  addNode(type, props={}){\n    const obj = {type, in:[], out:[], props};\n    this.nodes.push(obj);\n    return this.nodes.length-1;\n  }\n\n  addRel(type, from, to, props={}) {\n    const obj = {type, from, to, props};\n    this.rels.push(obj);\n    const rid = this.rels.length-1;\n    this.nodes[from].out.push(rid)\n    this.nodes[to].in.push(rid);\n    return rid;\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { nodes:tally(this.nodes), rels:tally(this.rels)};\n  }\n\n  size(){\n    return this.nodes.length + this.rels.length;\n  }\n\n  static load(obj) {\n    // let obj = await fetch(url).then(res => res.json())\n    return new Graph(obj.nodes, obj.rels)\n  }\n\n  static async fetch(url) {\n    const obj = await fetch(url).then(res => res.json())\n    return Graph.load(obj)\n  }\n\n  static async read(path) {\n    const json = await Deno.readTextFile(path);\n    const obj = JSON.parse(json);\n    return Graph.load(obj)\n  }\n\n  // static async import(path) {\n  //   let module = await import(path, {assert: {type: \"json\"}})\n  //   return Graph.load(module.default)\n  // }\n\n  n(type=null, props={}) {\n    let nids = Object.keys(this.nodes).map(key => +key)\n    if (type) nids = nids.filter(nid => this.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.nodes[nid].props[key] == props[key])\n    return new Nodes(this, nids)\n  }\n\n  /**\n   * Converts a graph to a JavaScript Object Notation (JSON) string using JSON.stringify.\n   @param - replacer A function that transforms the results.\n   @param - space Adds indentation, white space, and line break characters to the return-\n   * @returns {string} JSON string containing serialized graph\n  */\n  stringify(...args) {\n    const obj = { nodes: this.nodes, rels: this.rels }\n    return JSON.stringify(obj, ...args)\n  }\n\n\n  search (query, opt={}) {\n    const tree = cypher.parse(query)\n    // console.dir(tree, {depth:15})\n    const code = cypher.gen(0,tree[0][0],{})\n    // console.log(code)\n    cypher.check(this.tally(),code,opt.errors)\n    return cypher.apply(this, code)\n  }\n\n}\n\n\n\n\n\n\n// Fluent Interface (deprecated?)\n\nexport class Nodes {\n  constructor (graph, nids) {\n    // console.log('Nodes',{graph:graph.size(),type,nids})\n    this.graph = graph\n    this.nids = nids\n  }\n\n  // n(type=null, props={}) {\n  //   // console.log('Nodes.n',{type,props})\n  //   let nids = this.nids\n  //   if (type) nids = nids.filter(nid => this.nodes[nid].type == type)\n  //   for (let key in props) nids = nids.filter(nid => this.nodes[nid].props[key] == props[key])\n  //   return new Nodes(this.graph, type, nids)\n  // }\n\n  i(type=null, props={}) {\n    // console.log('Nodes.i',{type,props})\n    let rids = this.nids.map(nid => this.graph.nodes[nid].in).flat().filter(uniq)\n    if (type) rids = rids.filter(rid => this.graph.rels[rid].type == type)\n    for (const key in props) rids = rids.filter(rid => this.graph.rels[rid].props[key] == props[key])\n    return new Rels(this.graph, rids)\n  }\n\n  o(type=null, props={}) {\n    // console.log('Nodes.o',{type,props})\n    let rids = this.nids.map(nid => this.graph.nodes[nid].out).flat().filter(uniq)\n    if (type) rids = rids.filter(rid => this.graph.rels[rid].type == type)\n    for (const key in props) rids = rids.filter(rid => this.graph.rels[rid].props[key] == props[key])\n    return new Rels(this.graph, rids)\n  }\n\n  props(key='name') {\n    // console.log('Nodes.p',{key})\n    return this.nids.map(nid => this.graph.nodes[nid].props[key]).filter(uniq).sort()\n  }\n\n  types() {\n    return this.nids.map(nid => this.graph.nodes[nid].type).filter(uniq).sort()\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { nodes:tally(this.nids.map(nid => this.graph.nodes[nid]))};\n  }\n\n  size(){\n    return this.nids.length\n  }\n\n  filter(f) {\n    const nodes = this.graph.nodes\n    const nids = this.nids.filter(nid => {\n      const node = nodes[nid]\n      return f(node.type,node.props)\n    })\n    return new Nodes(this.graph,nids)\n  }\n\n  map(f) {\n    const nodes = this.graph.nodes\n    const result = this.nids.map(nid => {\n      const node = nodes[nid]\n      return f(node)\n    })\n    return result\n  }\n}\n\nexport class Rels {\n  constructor (graph, rids) {\n    // console.log('Rels',{graph:graph.size(),type,rids})\n    this.graph = graph\n    this.rids = rids\n  }\n\n  f(type=null, props={}) {\n    // console.log('Rels.f',{type,props})\n    let nids = this.rids.map(rid => this.graph.rels[rid].from).filter(uniq)\n    if (type) nids = nids.filter(nid => this.graph.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.graph.nodes[nid].props[key] == props[key])\n    return new Nodes(this.graph, nids)\n  }\n\n  t(type=null, props={}) {\n    // console.log('Rels.t',{type,props})\n    let nids = this.rids.map(rid => this.graph.rels[rid].to).filter(uniq)\n    if (type) nids = nids.filter(nid => this.graph.nodes[nid].type == type)\n    for (const key in props) nids = nids.filter(nid => this.graph.nodes[nid].props[key] == props[key])\n    return new Nodes(this.graph, nids)\n  }\n\n  props(key='name') {\n    // console.log('Rels.p',{key})\n    return this.rids.map(rid => this.graph.rels[rid].props[key]).filter(uniq).sort()\n  }\n\n  types() {\n    return this.rids.map(rid => this.graph.rels[rid].type).filter(uniq).sort()\n  }\n\n  tally(){\n    const tally = list => list.reduce((s,e)=>{s[e.type] = s[e.type] ? s[e.type]+1 : 1; return s}, {});\n    return { rels:tally(this.rids.map(nid => this.graph.rels[nid]))};\n  }\n\n  size(){\n    return this.rids.length\n  }\n\n  filter(f) {\n    const rels = this.graph.rels\n    const rids = this.rids.filter(rid => {\n      const rel = rels[rid]\n      return f(rel.type,rel.props)\n    })\n    return new Rels(this.graph,rids)\n  }\n\n  map(f) {\n    const rels = this.graph.rels\n    const result = this.rids.map(rid => {\n      const rel = rels[rid]\n      return f(rel)\n    })\n    return result\n  }\n}"
      },
      "date": 1664083324737
    }
  ]
}