{
  "title": "Capability Security Model",
  "story": [
    {
      "type": "html",
      "text": "'[[Capability Security Model]]' describes a broad spectrum of [[Security Model]]s that attach service-authorizations to the entities demanding the service.  These service-authorizations are appropriately termed 'capabilities'.  This is in opposition to attaching service authorizations to the entity providing the service; for example, an [[Access Control List]] that is attached to a directory and indicates 'who' may enter/read/write/etc. does not qualify as a capability.  ",
      "id": "cc577acc14755dc388352f9e46b14cf2"
    },
    {
      "type": "html",
      "text": "\nThe practical advantages of a [[Capability Security Model]] over its alternative (the main competitor being [[Access Control List]]s) stem from the fact that changing [[Access Control List]]s is, in practice, a very difficult <i>social</i> and <i>political</i> problem: there is rarely a clear indicator of exactly whom should have authority (the capability) to change it, which means it gets delegated to some 'Trusted Computing Base' (e.g. the root hacker), and all change requests end up being bottlenecked through some individual who's had a long day and is nursing a headache.  Capabilities, in comparison, offer a great deal more flexibility and <i>reduce</i> maintenance costs: if you have a capability, you can copy it to someone else, so they have the capability too, and it would be very much like you were doing whatever it is they want to do on their behalf... except that you can go home and watch Simpsons while your trusted friend, Fred, does whatever he wanted to do.  It has been proven that [[Capability Security Model]] and [[Access Control List]]s <i>technically</i> offer the same theoretical granularity when it comes to controlling service access (since they both expand to the same sparse matrix with entities on one axis and services to resources on another), but it is unlikely that it will ever be realized.",
      "id": "b75f2e86f95d194e98508b5e0cadf721"
    },
    {
      "type": "html",
      "text": "\nThat said, the [[Access Control List]] approach does offer some advantages.  First, <i>in reality</i>, trust is NOT transitive... i.e. if I trust you, and you trust Fred, it doesn't mean that I trust Fred, or that I'd let Fred into my house where he can drink my beer. And if I loaned you my lawnmower, it doesn't mean I'm permitting you to loan it out to everyone else - especially given that I could be liable if some child were hurt.  [[Access Control List]] allow for direct expression and enforcing non-transitive trust, whereas capabilities do not.  However, it can be reasonably argued that [[Access Control List]] is promising something impossible: that if you have access to a resource, you can always copy that resource and show it to Fred... or you can even give Fred all the information he needs to masquerade as you and confuse me (e.g. give Fred your passwords, supposing the authenticity tests don't involve study of habit-patterns and biometrics), or you can allow Fred to use you by relaying requests through you.  These are all possible.  Thus, some people have noted that despite trust not being transitive, attempting to enforce non-transitive trust is difficult or impossible in the face of treachery.  So, perhaps, what ACLs offer isn't protection against intentional treachery, but rather protection against treachery of the more accidental sort, and a certain degree of social pressure to avoid mistake (e.g. if giving away a particular capability requires giving away both your [[Common Access Card]] and Password which has access to your e-money, most people can be taught and comprehend that this is a bad thing; if it also requires giving one of your eyeballs for an iris scan challenge by the CAC, then most people would be quite resistant to ever trying.)",
      "id": "3a024a83715e8ffe7531de99eb0799e9"
    },
    {
      "type": "html",
      "text": "\nThere actually have been attempts to unify these.  The [[Hybrid Capability Model]] simply glues both together (you must satisfy ACL and Capability), which neatly gains you both some of the best and some of the very worst of both worlds.  [[Split Capability Model]] is even worse, requiring the same 'trusted computing block' table as the original ACLs plus requiring that every capability call back into this TCB.  SPKI and certificates, however, do offer a fairly simple approach: allow capabilities to be tied to a particular user by requiring they sign with a private key each use of the capability with a time (or any uniquely scoped session identifier verifiable by the capability enforcer - e.g. a transaction ID from a shared transaction manager - to prevent replay attacks).  So long as these entities can keep their private key private (which for process-objects only requires trusting the hosts upon which they are running... which does limit mobility a bit) one has the potential to create capabilities that are scoped to exactly one entity... i.e. the equivalent to ACL-granted authority.",
      "id": "22c2dfa315a50c70260257a2230b167c"
    },
    {
      "type": "html",
      "text": "<i>How about some specific realistic scenarios that show the alleged drawbacks of ACL's. The accusations against it here are not specific enough to dissect, analyze, and confirm.</i>",
      "id": "07e45f835696c658bbc477ce9bbfa85a"
    },
    {
      "type": "html",
      "text": "\nDo you have a specific question? Your claim against the accusations is not specific enough to answer.",
      "id": "032e3b7b3f592f6104725e0c0114a795"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "28e04da8f318fc11dde954d3365b5e15"
    },
    {
      "type": "html",
      "text": "<b> 'The original' [[Object Capability Model]]:</b>",
      "id": "ce82aa2605e3ffd3ff17bfcf9062d3af"
    },
    {
      "type": "html",
      "text": "\nA security model ([[Category Security Model]]) in which all resources are referenced by \"capabilities\" that both designate the resource, and authorize access to it.  The mechanism by which resources are created ensures that 'names' cannot easily be guessed and are thus 'unforgeable'.  Possessing a reference to an object is considered a sufficient indicator of the right to act upon that reference.  It is assumed that if you pass a reference to another object, you're giving them full permission to do anything that object is willing to do.  Security is enforced by creating 'new' objects that limit the actions (e.g. by throwing exceptions or returning without operation) when the caller attempts a blocked action.  It is assumed that you can trust the [[Object System]] environment and host computer to not intentionally violate the security system.",
      "id": "9b4aaabf8086b14a464f2dbd5b7c9423"
    },
    {
      "type": "html",
      "text": "\nThis is 'the original' capability security model as described by [[Dennis And Van Horn]]. However, the term \"capability security\" has since been used rather imprecisely, sometimes to describe security models that have little to do with the [[Dennis And Van Horn]] model. The new name [[Object Capability Model]] has been proposed by some researchers (see [[Paradigm Regained]]) in an attempt to reduce this confusion.",
      "id": "f6da719c4c2ab7fa9a6b5d14bee60498"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "28e04da8f318fc11dde954d3365b5e15"
    },
    {
      "type": "html",
      "text": "\nSome of the other models that have come to be known as \"capability\" models are ",
      "id": "3a337cb9a523419b639fc7edc4542a3e"
    },
    {
      "type": "html",
      "text": " [[Capabilities As Rows Model]] (as in, rows of Lampson's access matrix)",
      "id": "d977f01633584a440fda9b88485e4c8d"
    },
    {
      "type": "html",
      "text": " [[Capabilities As Keys Model]] (also known as \"capabilities as tickets\")",
      "id": "761ee039d82feac8449d4da57e055ebe"
    },
    {
      "type": "html",
      "text": " [[Posix Capabilities]] (The least like any of the others, and purposely named to be confusing. \"Linux capabilities\" are the same thing.) ",
      "id": "4408d5c551dd4ec2d8bd3657c4151fa1"
    },
    {
      "type": "html",
      "text": " [[Password Capability Model]] (which includes cryptographic capability protocols and certificates)",
      "id": "2f603e4a9aa1d53b5a15ba3c1f0e8eb7"
    },
    {
      "type": "html",
      "text": " [[Split Capability Model]] (hard to classify:<br>in some ways like the [[Object Capability Model]], the [[Capabilities As Keys Model]], and the [[Access Control List]] model)",
      "id": "10e45103ed6c03739de0814df6e8b2d8"
    },
    {
      "type": "html",
      "text": " [[Hybrid Capability Model]] (access must satisfy both capability and [[Access Control List]] rules)",
      "id": "c9f7c8ee291cf921e562287cd1a709f1"
    },
    {
      "type": "html",
      "text": " [[Distributed Object Capability Model]] (local [[Object Capability Model]] systems connected by [[Password Capability Model]] protocols)",
      "id": "f8f89af8107decee76cfc1fc5cee59ae"
    },
    {
      "type": "html",
      "text": "\nIf you know of others, please add them to this list, and explain their differences from the [[Object Capability Model]].",
      "id": "eec148a27346becbf3449721d53d1de7"
    },
    {
      "type": "html",
      "text": "<i> Is the [[Wiki Pedia]] \"Capability based security\" at [http://en.wikipedia.org/wiki/Capability-based_security en.wikipedia.org] talking about the same subject?</i>",
      "id": "65bbc8a4129ccf02beab82c6c2136fe5"
    },
    {
      "type": "html",
      "text": " another link there is [http://en.wikipedia.org/wiki/Secure_computing#Capabilities_vs._ACLs en.wikipedia.org]",
      "id": "eaccdb2d3efdcd4d2593ed3a6d76ea89"
    },
    {
      "type": "html",
      "text": "\nOutside Links: [http://www.cap-lore.com/CapTheory/index.html www.cap-lore.com] and [http://www.eros-os.org/essays/00Essays.html www.eros-os.org].",
      "id": "8b44285930a73041155a5d451a38069c"
    },
    {
      "type": "html",
      "text": "\nDiscussion moved into [[Capability Security Discussion]].",
      "id": "f4c4868e2098e546ea1775957e074322"
    },
    {
      "type": "html",
      "text": "\nFor differences between capability and OO programming, see [[Capability Oriented Programming]].",
      "id": "1c35e29b291bcc0cbacdfe6560e6f377"
    },
    {
      "type": "html",
      "text": "\nSee [[Rights Amplification]], which discusses couple variations on a useful pattern oft found in [[Capability Security Model]]s. ",
      "id": "0600e5ec81b55c59280bd937de3af15d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "28e04da8f318fc11dde954d3365b5e15"
    },
    {
      "type": "html",
      "text": "See also [[Capability User Interface]] [[Anti Cap Quotes]].",
      "id": "4c0d70384c91aca4430263277d674cb3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "28e04da8f318fc11dde954d3365b5e15"
    },
    {
      "type": "html",
      "text": "[[Category Security Model]] [[Category Security]]",
      "id": "4376d29f3a9304250af2984c3e6b60eb"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?CapabilitySecurityModel c2.com]",
      "id": "7b604dca39d724b7a89f82dcdf4a2fbd"
    }
  ],
  "journal": [
    {
      "date": 1270852564000,
      "id": "9786c6fd6a5173c305e7b9151094bca9",
      "type": "create",
      "item": {
        "title": "Capability Security Model",
        "story": [
          {
            "type": "html",
            "text": "'[[Capability Security Model]]' describes a broad spectrum of [[Security Model]]s that attach service-authorizations to the entities demanding the service.  These service-authorizations are appropriately termed 'capabilities'.  This is in opposition to attaching service authorizations to the entity providing the service; for example, an [[Access Control List]] that is attached to a directory and indicates 'who' may enter/read/write/etc. does not qualify as a capability.  ",
            "id": "cc577acc14755dc388352f9e46b14cf2"
          },
          {
            "type": "html",
            "text": "\nThe practical advantages of a [[Capability Security Model]] over its alternative (the main competitor being [[Access Control List]]s) stem from the fact that changing [[Access Control List]]s is, in practice, a very difficult <i>social</i> and <i>political</i> problem: there is rarely a clear indicator of exactly whom should have authority (the capability) to change it, which means it gets delegated to some 'Trusted Computing Base' (e.g. the root hacker), and all change requests end up being bottlenecked through some individual who's had a long day and is nursing a headache.  Capabilities, in comparison, offer a great deal more flexibility and <i>reduce</i> maintenance costs: if you have a capability, you can copy it to someone else, so they have the capability too, and it would be very much like you were doing whatever it is they want to do on their behalf... except that you can go home and watch Simpsons while your trusted friend, Fred, does whatever he wanted to do.  It has been proven that [[Capability Security Model]] and [[Access Control List]]s <i>technically</i> offer the same theoretical granularity when it comes to controlling service access (since they both expand to the same sparse matrix with entities on one axis and services to resources on another), but it is unlikely that it will ever be realized.",
            "id": "b75f2e86f95d194e98508b5e0cadf721"
          },
          {
            "type": "html",
            "text": "\nThat said, the [[Access Control List]] approach does offer some advantages.  First, <i>in reality</i>, trust is NOT transitive... i.e. if I trust you, and you trust Fred, it doesn't mean that I trust Fred, or that I'd let Fred into my house where he can drink my beer. And if I loaned you my lawnmower, it doesn't mean I'm permitting you to loan it out to everyone else - especially given that I could be liable if some child were hurt.  [[Access Control List]] allow for direct expression and enforcing non-transitive trust, whereas capabilities do not.  However, it can be reasonably argued that [[Access Control List]] is promising something impossible: that if you have access to a resource, you can always copy that resource and show it to Fred... or you can even give Fred all the information he needs to masquerade as you and confuse me (e.g. give Fred your passwords, supposing the authenticity tests don't involve study of habit-patterns and biometrics), or you can allow Fred to use you by relaying requests through you.  These are all possible.  Thus, some people have noted that despite trust not being transitive, attempting to enforce non-transitive trust is difficult or impossible in the face of treachery.  So, perhaps, what ACLs offer isn't protection against intentional treachery, but rather protection against treachery of the more accidental sort, and a certain degree of social pressure to avoid mistake (e.g. if giving away a particular capability requires giving away both your [[Common Access Card]] and Password which has access to your e-money, most people can be taught and comprehend that this is a bad thing; if it also requires giving one of your eyeballs for an iris scan challenge by the CAC, then most people would be quite resistant to ever trying.)",
            "id": "3a024a83715e8ffe7531de99eb0799e9"
          },
          {
            "type": "html",
            "text": "\nThere actually have been attempts to unify these.  The [[Hybrid Capability Model]] simply glues both together (you must satisfy ACL and Capability), which neatly gains you both some of the best and some of the very worst of both worlds.  [[Split Capability Model]] is even worse, requiring the same 'trusted computing block' table as the original ACLs plus requiring that every capability call back into this TCB.  SPKI and certificates, however, do offer a fairly simple approach: allow capabilities to be tied to a particular user by requiring they sign with a private key each use of the capability with a time (or any uniquely scoped session identifier verifiable by the capability enforcer - e.g. a transaction ID from a shared transaction manager - to prevent replay attacks).  So long as these entities can keep their private key private (which for process-objects only requires trusting the hosts upon which they are running... which does limit mobility a bit) one has the potential to create capabilities that are scoped to exactly one entity... i.e. the equivalent to ACL-granted authority.",
            "id": "22c2dfa315a50c70260257a2230b167c"
          },
          {
            "type": "html",
            "text": "<i>How about some specific realistic scenarios that show the alleged drawbacks of ACL's. The accusations against it here are not specific enough to dissect, analyze, and confirm.</i>",
            "id": "07e45f835696c658bbc477ce9bbfa85a"
          },
          {
            "type": "html",
            "text": "\nDo you have a specific question? Your claim against the accusations is not specific enough to answer.",
            "id": "032e3b7b3f592f6104725e0c0114a795"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "28e04da8f318fc11dde954d3365b5e15"
          },
          {
            "type": "html",
            "text": "<b> 'The original' [[Object Capability Model]]:</b>",
            "id": "ce82aa2605e3ffd3ff17bfcf9062d3af"
          },
          {
            "type": "html",
            "text": "\nA security model ([[Category Security Model]]) in which all resources are referenced by \"capabilities\" that both designate the resource, and authorize access to it.  The mechanism by which resources are created ensures that 'names' cannot easily be guessed and are thus 'unforgeable'.  Possessing a reference to an object is considered a sufficient indicator of the right to act upon that reference.  It is assumed that if you pass a reference to another object, you're giving them full permission to do anything that object is willing to do.  Security is enforced by creating 'new' objects that limit the actions (e.g. by throwing exceptions or returning without operation) when the caller attempts a blocked action.  It is assumed that you can trust the [[Object System]] environment and host computer to not intentionally violate the security system.",
            "id": "9b4aaabf8086b14a464f2dbd5b7c9423"
          },
          {
            "type": "html",
            "text": "\nThis is 'the original' capability security model as described by [[Dennis And Van Horn]]. However, the term \"capability security\" has since been used rather imprecisely, sometimes to describe security models that have little to do with the [[Dennis And Van Horn]] model. The new name [[Object Capability Model]] has been proposed by some researchers (see [[Paradigm Regained]]) in an attempt to reduce this confusion.",
            "id": "f6da719c4c2ab7fa9a6b5d14bee60498"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "28e04da8f318fc11dde954d3365b5e15"
          },
          {
            "type": "html",
            "text": "\nSome of the other models that have come to be known as \"capability\" models are ",
            "id": "3a337cb9a523419b639fc7edc4542a3e"
          },
          {
            "type": "html",
            "text": " [[Capabilities As Rows Model]] (as in, rows of Lampson's access matrix)",
            "id": "d977f01633584a440fda9b88485e4c8d"
          },
          {
            "type": "html",
            "text": " [[Capabilities As Keys Model]] (also known as \"capabilities as tickets\")",
            "id": "761ee039d82feac8449d4da57e055ebe"
          },
          {
            "type": "html",
            "text": " [[Posix Capabilities]] (The least like any of the others, and purposely named to be confusing. \"Linux capabilities\" are the same thing.) ",
            "id": "4408d5c551dd4ec2d8bd3657c4151fa1"
          },
          {
            "type": "html",
            "text": " [[Password Capability Model]] (which includes cryptographic capability protocols and certificates)",
            "id": "2f603e4a9aa1d53b5a15ba3c1f0e8eb7"
          },
          {
            "type": "html",
            "text": " [[Split Capability Model]] (hard to classify:<br>in some ways like the [[Object Capability Model]], the [[Capabilities As Keys Model]], and the [[Access Control List]] model)",
            "id": "10e45103ed6c03739de0814df6e8b2d8"
          },
          {
            "type": "html",
            "text": " [[Hybrid Capability Model]] (access must satisfy both capability and [[Access Control List]] rules)",
            "id": "c9f7c8ee291cf921e562287cd1a709f1"
          },
          {
            "type": "html",
            "text": " [[Distributed Object Capability Model]] (local [[Object Capability Model]] systems connected by [[Password Capability Model]] protocols)",
            "id": "f8f89af8107decee76cfc1fc5cee59ae"
          },
          {
            "type": "html",
            "text": "\nIf you know of others, please add them to this list, and explain their differences from the [[Object Capability Model]].",
            "id": "eec148a27346becbf3449721d53d1de7"
          },
          {
            "type": "html",
            "text": "<i> Is the [[Wiki Pedia]] \"Capability based security\" at [http://en.wikipedia.org/wiki/Capability-based_security en.wikipedia.org] talking about the same subject?</i>",
            "id": "65bbc8a4129ccf02beab82c6c2136fe5"
          },
          {
            "type": "html",
            "text": " another link there is [http://en.wikipedia.org/wiki/Secure_computing#Capabilities_vs._ACLs en.wikipedia.org]",
            "id": "eaccdb2d3efdcd4d2593ed3a6d76ea89"
          },
          {
            "type": "html",
            "text": "\nOutside Links: [http://www.cap-lore.com/CapTheory/index.html www.cap-lore.com] and [http://www.eros-os.org/essays/00Essays.html www.eros-os.org].",
            "id": "8b44285930a73041155a5d451a38069c"
          },
          {
            "type": "html",
            "text": "\nDiscussion moved into [[Capability Security Discussion]].",
            "id": "f4c4868e2098e546ea1775957e074322"
          },
          {
            "type": "html",
            "text": "\nFor differences between capability and OO programming, see [[Capability Oriented Programming]].",
            "id": "1c35e29b291bcc0cbacdfe6560e6f377"
          },
          {
            "type": "html",
            "text": "\nSee [[Rights Amplification]], which discusses couple variations on a useful pattern oft found in [[Capability Security Model]]s. ",
            "id": "0600e5ec81b55c59280bd937de3af15d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "28e04da8f318fc11dde954d3365b5e15"
          },
          {
            "type": "html",
            "text": "See also [[Capability User Interface]] [[Anti Cap Quotes]].",
            "id": "4c0d70384c91aca4430263277d674cb3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "28e04da8f318fc11dde954d3365b5e15"
          },
          {
            "type": "html",
            "text": "[[Category Security Model]] [[Category Security]]",
            "id": "4376d29f3a9304250af2984c3e6b60eb"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?CapabilitySecurityModel c2.com]",
            "id": "7b604dca39d724b7a89f82dcdf4a2fbd"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1704998327333
    }
  ]
}