{
  "title": "LangSec",
  "story": [
    {
      "type": "paragraph",
      "id": "db6f958c49aa6567",
      "text": "The Language-theoretic approach (LANGSEC) regards the Internet insecurity epidemic as a consequence of ad hoc programming of input handling at all layers of network stacks, and in other kinds of software stacks. [http://langsec.org/ site]"
    },
    {
      "type": "paragraph",
      "id": "519a2e5a0b63599f",
      "text": " LANGSEC posits that the only path to trustworthy software that takes untrusted inputs is treating all valid or expected inputs as a formal language, and the respective input-handling routines as a recognizer for that language. The recognition must be feasible, and the recognizer must match the language in required computation power. "
    },
    {
      "type": "paragraph",
      "id": "3adc6ed425baef5b",
      "text": "See [[Secure Automata]]"
    },
    {
      "type": "paragraph",
      "id": "6efed749760bbcfd",
      "text": "An input should be verified before it is parsed. A verifier for a regular language is simpler because it has finite state. In our effort to tally json we have found that similarly benefit from finite variability of our input."
    },
    {
      "type": "paragraph",
      "id": "f5d71a33194cf55c",
      "text": "A regular expression matcher can be subject to combinatorial explosion unless care is taken to handle special cases. Russ Cox discuss efficient implementations due to Ken Thompson. [https://swtch.com/~rsc/regexp/regexp1.html page]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "LangSec",
        "story": []
      },
      "date": 1490641314876
    },
    {
      "item": {
        "type": "factory",
        "id": "db6f958c49aa6567"
      },
      "id": "db6f958c49aa6567",
      "type": "add",
      "date": 1490641364593
    },
    {
      "type": "edit",
      "id": "db6f958c49aa6567",
      "item": {
        "type": "paragraph",
        "id": "db6f958c49aa6567",
        "text": "The Language-theoretic approach (LANGSEC) regards the Internet insecurity epidemic as a consequence of ad hoc programming of input handling at all layers of network stacks, and in other kinds of software stacks. LANGSEC posits that the only path to trustworthy software that takes untrusted inputs is treating all valid or expected inputs as a formal language, and the respective input-handling routines as a recognizer for that language. The recognition must be feasible, and the recognizer must match the language in required computation power."
      },
      "date": 1490641368638
    },
    {
      "type": "edit",
      "id": "db6f958c49aa6567",
      "item": {
        "type": "paragraph",
        "id": "db6f958c49aa6567",
        "text": "The Language-theoretic approach (LANGSEC) regards the Internet insecurity epidemic as a consequence of ad hoc programming of input handling at all layers of network stacks, and in other kinds of software stacks. LANGSEC posits that the only path to trustworthy software that takes untrusted inputs is treating all valid or expected inputs as a formal language, and the respective input-handling routines as a recognizer for that language. The recognition must be feasible, and the recognizer must match the language in required computation power. [http://langsec.org/ site]"
      },
      "date": 1490641434277
    },
    {
      "type": "edit",
      "id": "db6f958c49aa6567",
      "item": {
        "type": "paragraph",
        "id": "db6f958c49aa6567",
        "text": "The Language-theoretic approach (LANGSEC) regards the Internet insecurity epidemic as a consequence of ad hoc programming of input handling at all layers of network stacks, and in other kinds of software stacks. [http://langsec.org/ site]"
      },
      "date": 1490641529873
    },
    {
      "type": "add",
      "id": "519a2e5a0b63599f",
      "item": {
        "type": "paragraph",
        "id": "519a2e5a0b63599f",
        "text": " LANGSEC posits that the only path to trustworthy software that takes untrusted inputs is treating all valid or expected inputs as a formal language, and the respective input-handling routines as a recognizer for that language. The recognition must be feasible, and the recognizer must match the language in required computation power. "
      },
      "after": "db6f958c49aa6567",
      "date": 1490641531423
    },
    {
      "type": "add",
      "id": "3adc6ed425baef5b",
      "item": {
        "type": "paragraph",
        "id": "3adc6ed425baef5b",
        "text": "See [[Secure Automata]]"
      },
      "after": "519a2e5a0b63599f",
      "date": 1490641556769
    },
    {
      "type": "add",
      "id": "6efed749760bbcfd",
      "item": {
        "type": "paragraph",
        "id": "6efed749760bbcfd",
        "text": "An input should be verified before it is parsed. A verifier for a regular language is simpler because it has finite state. In our effort to tally json we have found that similarly benefit from finite variability of our input."
      },
      "after": "3adc6ed425baef5b",
      "date": 1490641811200
    },
    {
      "type": "add",
      "id": "f5d71a33194cf55c",
      "item": {
        "type": "paragraph",
        "id": "f5d71a33194cf55c",
        "text": "A regular expression matcher can be subject to combinatorial explosion unless care is taken to handle special cases. Russ Cox discuss efficient implementations due to Ken Thompson. [Regular Expression Matching Can Be Simple And Fast "
      },
      "after": "6efed749760bbcfd",
      "date": 1490648299373
    },
    {
      "type": "edit",
      "id": "f5d71a33194cf55c",
      "item": {
        "type": "paragraph",
        "id": "f5d71a33194cf55c",
        "text": "A regular expression matcher can be subject to combinatorial explosion unless care is taken to handle special cases. Russ Cox discuss efficient implementations due to Ken Thompson. [https://swtch.com/~rsc/regexp/regexp1.html page]"
      },
      "date": 1490648332023
    },
    {
      "type": "fork",
      "site": "context.asia.wiki.org",
      "date": 1709622207811
    }
  ]
}