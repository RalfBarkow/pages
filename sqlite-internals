{
  "title": "SQLite Internals",
  "story": [
    {
      "type": "paragraph",
      "id": "1fa6827db5f62968",
      "text": "There's a comfort with being able to read through a spec or a code repository and know that you've covered the full breadth of a tool. That's why I love SQLite's 130KLOC core code base. It's something that you can read through in a long weekend if, ya know, that's what you do on weekends. [https://fly.io/blog/sqlite-internals-btree/ post]"
    },
    {
      "type": "paragraph",
      "id": "c0d04f2687885c17",
      "text": "Varints use a simple trick. The high bit is used as a flag to indicate if there are more bytes to be read and the other 7 bits are our actual data. To represent 1,000, we start with its binary representation split into 7 bit chunks."
    },
    {
      "type": "paragraph",
      "id": "3764a12176bd50be",
      "text": "SQLite groups rows together into 4KB chunks called \"pages\". Why 4KB? That's what file systems typically use as their page size so keeping everything aligned reduces page fetches from disk. Disks are usually the slowest part of a database so limiting page fetches can have a huge performance win."
    },
    {
      "type": "paragraph",
      "id": "6df3fdcb8b151849",
      "text": "SQLite is structured as a b-tree, which is a data structure where each node can point to two or more child nodes and the values in these child nodes are all sorted. There are a ton of different variants of b-trees but the one that SQLite uses is called a b+tree."
    },
    {
      "type": "paragraph",
      "id": "324c58cb259e3c3c",
      "text": "At a tree depth of 4, we can hold about 500³ leaf pages, or about 476GB. That means we only need to read 4 pages to find a given record—even in a huge database."
    },
    {
      "type": "paragraph",
      "id": "882b63a26ecbcc6d",
      "text": "I'll be writing more on SQLite internals in future posts—from rollback journals to write-ahead logs to the SQLite virtual machine."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "SQLite Internals",
        "story": []
      },
      "date": 1658979047613
    },
    {
      "item": {
        "type": "factory",
        "id": "1fa6827db5f62968"
      },
      "id": "1fa6827db5f62968",
      "type": "add",
      "date": 1658979119725
    },
    {
      "type": "edit",
      "id": "1fa6827db5f62968",
      "item": {
        "type": "paragraph",
        "id": "1fa6827db5f62968",
        "text": "There's a comfort with being able to read through a spec or a code repository and know that you've covered the full breadth of a tool. That's why I love SQLite's 130KLOC core code base. It's something that you can read through in a long weekend if, ya know, that's what you do on weekends."
      },
      "date": 1658979146748
    },
    {
      "type": "edit",
      "id": "1fa6827db5f62968",
      "item": {
        "type": "paragraph",
        "id": "1fa6827db5f62968",
        "text": "There's a comfort with being able to read through a spec or a code repository and know that you've covered the full breadth of a tool. That's why I love SQLite's 130KLOC core code base. It's something that you can read through in a long weekend if, ya know, that's what you do on weekends. [https://fly.io/blog/sqlite-internals-btree/ post]"
      },
      "date": 1658979162705
    },
    {
      "type": "add",
      "id": "c0d04f2687885c17",
      "item": {
        "type": "paragraph",
        "id": "c0d04f2687885c17",
        "text": "Varints use a simple trick. The high bit is used as a flag to indicate if there are more bytes to be read and the other 7 bits are our actual data. So if we wanted to represent 1,000, we start with its binary representation split into 7 bit chunks."
      },
      "after": "1fa6827db5f62968",
      "date": 1658979217647
    },
    {
      "type": "edit",
      "id": "c0d04f2687885c17",
      "item": {
        "type": "paragraph",
        "id": "c0d04f2687885c17",
        "text": "Varints use a simple trick. The high bit is used as a flag to indicate if there are more bytes to be read and the other 7 bits are our actual data. To represent 1,000, we start with its binary representation split into 7 bit chunks."
      },
      "date": 1658979250750
    },
    {
      "type": "add",
      "id": "3764a12176bd50be",
      "item": {
        "type": "paragraph",
        "id": "3764a12176bd50be",
        "text": "SQLite groups rows together into 4KB chunks called \"pages\". Why 4KB? That's what file systems typically use as their page size so keeping everything aligned reduces page fetches from disk. Disks are usually the slowest part of a database so limiting page fetches can have a huge performance win."
      },
      "after": "c0d04f2687885c17",
      "date": 1658979335528
    },
    {
      "type": "add",
      "id": "6df3fdcb8b151849",
      "item": {
        "type": "paragraph",
        "id": "6df3fdcb8b151849",
        "text": "SQLite is structured as a b-tree, which is a data structure where each node can point to two or more child nodes and the values in these child nodes are all sorted. There are a ton of different variants of b-trees but the one that SQLite uses is called a b+tree."
      },
      "after": "3764a12176bd50be",
      "date": 1658979445746
    },
    {
      "type": "add",
      "id": "324c58cb259e3c3c",
      "item": {
        "type": "paragraph",
        "id": "324c58cb259e3c3c",
        "text": "At a tree depth of 4, we can hold about 500³ leaf pages, or about a 476GB database. That means we only need to read 4 pages to find a given record—even in a huge database."
      },
      "after": "6df3fdcb8b151849",
      "date": 1658979482984
    },
    {
      "type": "edit",
      "id": "324c58cb259e3c3c",
      "item": {
        "type": "paragraph",
        "id": "324c58cb259e3c3c",
        "text": "At a tree depth of 4, we can hold about 500³ leaf pages, or about 476GB. That means we only need to read 4 pages to find a given record—even in a huge database."
      },
      "date": 1658979507540
    },
    {
      "type": "add",
      "id": "882b63a26ecbcc6d",
      "item": {
        "type": "paragraph",
        "id": "882b63a26ecbcc6d",
        "text": "I'll be writing more on SQLite internals in future posts—from rollback journals to write-ahead logs to the SQLite virtual machine."
      },
      "after": "324c58cb259e3c3c",
      "date": 1658979553215
    },
    {
      "type": "fork",
      "site": "found.ward.bay.wiki.org",
      "date": 1659010584305
    }
  ]
}