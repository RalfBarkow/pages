{
  "title": "serialize",
  "story": [
    {
      "type": "markdown",
      "id": "3821697eee4ccb70",
      "text": "* object graphs \n⇒ [[Fuel]]"
    },
    {
      "type": "markdown",
      "id": "fd8a12fef6f61dcc",
      "text": "* a full execution stack and later reload it! "
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "serialize",
        "story": []
      },
      "date": 1666620860587
    },
    {
      "id": "3821697eee4ccb70",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "3821697eee4ccb70",
        "text": "> Serializing object graphs is an important activity since objects should be stored and reloaded on different environments. There is a plethora of frameworks to serialize objects based on recursive parsing of the object graphs. However such approaches are often too slow. Most approaches are limited in their provided features. For example, several serializers do not support class shape changes, global references, transient references or hooks to execute something before or after being stored or loaded. Moreover, to be faster, some serializers are not written taking into account the object-oriented paradigm and they are sometimes even implemented in the Virtual Machine hampering code portability. VM-based serializers such as ImageSegment are difficult to understand, maintain, and fix. For the final user, it means a serializer which is difficult to customize, adapt or extend to his own needs. In this paper we present a general purpose object graph serializer based on a pickling format and algorithm. We implement and validate this approach in the Pharo Smalltalk environment. We demonstrate that we can build a really fast serializer without specific VM support, with a clean object-oriented design, and providing most possible required features for a serializer. We show that our approach is faster that traditional serializers and compare favorably with ImageSegment as soon as serialized objects are not in isolation.\n"
      },
      "date": 1666620867095
    },
    {
      "type": "edit",
      "id": "3821697eee4ccb70",
      "item": {
        "type": "markdown",
        "id": "3821697eee4ccb70",
        "text": "* object graphs "
      },
      "date": 1666620877975
    },
    {
      "type": "edit",
      "id": "3821697eee4ccb70",
      "item": {
        "type": "markdown",
        "id": "3821697eee4ccb70",
        "text": "* object graphs \n[[Fuel]]"
      },
      "date": 1666620892723
    },
    {
      "type": "edit",
      "id": "3821697eee4ccb70",
      "item": {
        "type": "markdown",
        "id": "3821697eee4ccb70",
        "text": "* object graphs \n⇒ [[Fuel]]"
      },
      "date": 1666620899027
    },
    {
      "id": "fd8a12fef6f61dcc",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "fd8a12fef6f61dcc",
        "text": "Part of the speed of Fuel comes from the idea that objects are loaded more often than stored. This makes it worth to spend more time while storing to yield faster loading. Also, its storage scheme is based on the pickle format that puts similar objects into groups for efficiency and performance. As a result, Fuel has been shown to be one of the fastest object loaders, while still being a really fast object saver. Moreover, Fuel can serialize nearly any object in the image, it can even serialize a full execution stack and later reload it! "
      },
      "after": "3821697eee4ccb70",
      "date": 1666621085626
    },
    {
      "type": "edit",
      "id": "fd8a12fef6f61dcc",
      "item": {
        "type": "markdown",
        "id": "fd8a12fef6f61dcc",
        "text": "* a full execution stack and later reload it! "
      },
      "date": 1666621094944
    }
  ]
}