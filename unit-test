{
  "title": "Unit Test",
  "story": [
    {
      "type": "html",
      "text": "A kind of [[Automated Test]], though some would say a better name is [[Developer Test]]",
      "id": "060d04d0403efc3b8f20c0301c697793"
    },
    {
      "type": "html",
      "text": "\"Unit\" casually refers to low-level test cases written in the same language as the production code, which directly access its objects and members.",
      "id": "89aa8534710d303444acd188ded03532"
    },
    {
      "type": "html",
      "text": "\nUnder the strict definition, for QA purposes, the failure of a [[Unit Test]] implicates only one unit. You know exactly where to search to find the bug.",
      "id": "9715b0e17a0c67b06173bfbab70d86cf"
    },
    {
      "type": "html",
      "text": "\n[[Test Driven Development]] produces [[Developer Test]]s. The failure of a test case implicates only the developer's most recent edit. This implies that developers don't need to use [[Mock Object]]s to split all their code up into testable units. And it implies a developer may always avoid debugging by reverting that last edit.",
      "id": "ced796419fbb07a4d89f079b7a62cbec"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "(Note that although most of the text on this Wiki uses the term [[Unit Test]], the canonical [[Extreme Programming]] name has been changed to [[Programmer Test]].)",
      "id": "f4142f9a2004f816a94daa5cba2c0c26"
    },
    {
      "type": "html",
      "text": "\n[[Unit Test]]s are programs written to run in batches and test classes. Each typically sends a class a fixed message and verifies it returns the predicted answer.",
      "id": "7305c703dca98a83792e4cc57f772094"
    },
    {
      "type": "html",
      "text": "\n[[Unit Test]]s are a key component of software engineering, and the [[Extreme Programming]] discipline leverages them to permit easy code changes. Developers write tests for every class they produce. The tests are intended to test every aspect of the class that could conceivably not work. (Do test adding and removing, don't test accessors.)",
      "id": "1a6b57215b93c5c0e9a936c3b262cf8a"
    },
    {
      "type": "html",
      "text": "\nKey here is to [[Code Unit Test First]].",
      "id": "ac21008fc39798963595b34ba528a539"
    },
    {
      "type": "html",
      "text": "\n[[Unit Test]]s are all combined into a huge suite of tests, using e.g. [[Kent Beck]]'s [[Testing Framework]]. When developers go to release new code, they run all the unit tests, not just theirs, on the integration machine. The tests <b>must</b> run at 100%. If any test fails, they figure out why and fix the problem. The problem certainly resides in something they did ... since they know the tests ran at 100% the last time anything was released.",
      "id": "17aaa9887492bf851f0c55aa48a38b41"
    },
    {
      "type": "html",
      "text": "\nOf course, sometimes the tests let something slip through. When that happens, developers unconditionally enhance the unit tests so that that problem, and any similar one that comes to mind, won't happen again.",
      "id": "0563bf28a75a521801274947b5d27a4e"
    },
    {
      "type": "html",
      "text": "-- [[Ron Jeffries]]",
      "id": "1fb192cd379ce5c816e4ff5f4a59d105"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nC3 [[[Chrysler Comprehensive Compensation]]] has over 1300 unit tests, performing over 13,000 individual checks. They run in about 10 minutes in [[Visual Works]]. -- [[Ron Jeffries]]",
      "id": "0e7d60b94f4436049a573c9ed76e6a0b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nAlso, did you introduce tests late in development that identified unforeseen problems? If so, did your fixes to those problems break other things? In other words, how did you fight the \"if it ain't broke don't fix it\" attitude? -- [[Kieran Barry]]",
      "id": "4ba8bcede58fe409235733d46d255162"
    },
    {
      "type": "html",
      "text": "\nIt is the [[Unit Test]]s themselves that allow you to get away from the \"if it ain't broke don't fix it attitude.\" You must be able to modify anything in the entire system at anytime. Ah the freedom of it! The only way you can do that is to require the [[Unit Test]]s be run before any code is released at a [[Single Release Point]]. -- [[Don Wells]]",
      "id": "c6dd52db5a6dda3ee9395f4a863d873d"
    },
    {
      "type": "html",
      "text": "\nThis isn't 100% true though. It is quite possible to introduce a modification, run the tests and have 100% test coverage with all tests passing, and still have broken the system. It's just less likely the more tests there are (but more likely the more complex the system is). In these cases the passing tests have induced a false sense of security. The probability of a change causing a bug to slip through a set of tests can only approach zero for an arbitrary system, although some specific systems may have such a zero probability. This is because an arbitrary system can describe the [[Halting Problem]], which is provably undecidable, therefore an algorithm that describes it is untestable, which means that arbitrary systems are not 100% testable, and of course if there aren't tests for a piece of code, a bug can slip though. Contrived, sure, but true in lots of other more practical examples too. -- [[Mike Amy]]",
      "id": "1f0a1c383d9dff86faabf5f0691bcc69"
    },
    {
      "type": "html",
      "text": "<i>I don't think Don's talking about whether or not unit test can guarantee that a function is bug-free.  I believe he's talking about how they can \"cure\" the \"If it ain't broke, don't fix it\" attitude.  BTW, the inability of unit test's to guarentee correct behavior is not tied to the halting problem.  We can construct languages where the halting problem (for that language) is solvable, but still can't be 100% unit tested.</i>",
      "id": "2b75d00b64ee2843701c7f1ba0a5d52c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nWhat about things that can't be tested without human interaction? For example, suppose you have some code that handles printing. (And suppose the code is sufficiently deep in the system that it's not directly tested by a customer-written acceptance test. And suppose that it is necessary to test it at each integration, because breaking it can have subtle effects that will not easily be identified with this code without unit tests.) For most projects, the only practical way to test this printing code is to have a human inspect the paper that comes out of the printer and verify that it appears as it should. How does the XP testing process deal with this?",
      "id": "0952c2747e6d1e49000bc8a3510ab93e"
    },
    {
      "type": "html",
      "text": "<i>You can always install a pseudo printer (virtual printer like PDFCreator for Windows) and have the application print to it. It would generate post script or PDF file which you can easily compare with a valid .ps or .pdf file. Perhaps you picked the wrong example in printing.</i>",
      "id": "d91debad54619351b1df3b868d305a16"
    },
    {
      "type": "html",
      "text": "<i>If you [[Code Unit Test First]] your design will be far different from what you might expect. Most likely you will isolate the code which actually prints something to a physical printer from the code which formats something to be printed. Once the physical printer driver is tested it is unlikely to be changed anytime soon. That puts it into the not-likely-to-break category and is then exempt from unit tests. If it ever does change it is tested again by inspection of the physical output. The code that formats output destined for printing can be unit tested as usual. </i>",
      "id": "961b95183461a5be0d3eb91f9308a251"
    },
    {
      "type": "html",
      "text": "<i>Also remember that [[Acceptance Test]]s (XP style) cover anything that is of value to the customer. If it is not valuable enough to figure out how to test it then it should be removed immediately if not sooner. </i>Where there is a will there is a way to test.<i> -- [[Don Wells]]</i>",
      "id": "f56c19efb2f686312140699c0212fa93"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "How does one test [[Artificial Intelligence]] algorithms? I'm inclined to think they require human interaction, and they also tend to change often. -- [[Yuri Khan]]",
      "id": "9da16d8c8f492a18850b9db9c60c2efc"
    },
    {
      "type": "html",
      "text": "\nCreating [[Artificial Intelligence]] algorithms like [[Artificial Neural Network]] or [[Genetic Algorithm]] usually starts with creating a testset. This testset is often used in the process of creating the algorithm, for example for training a neural network or for the selection in genetic programming.",
      "id": "85caf5fa1d6ee24d94d6334bb8c4de1d"
    },
    {
      "type": "html",
      "text": "\n[[Numerical Optimization]] code is tricky to [[Unit Test]] exactly, but it is possible to [[Unit Test]] it heuristically. Has the accuracy of the learner increased over several training epochs? If not, maybe the [[Learning Rate]] is too high. (This test may be too high-level to be considered a [[Unit Test]], [[Per Se]].) Finer-grained tests include asserting that analytic computations of gradients (used for [[Back Prop]] in [[Neural Networks]]) is equal to numerical computations thereof, [[Plus Or Minus]] some epsilon.  -- [[Joseph Turian]]",
      "id": "c135109035a13115d2e520a6dc2733da"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nI just came across this paper, which oozes XP-ness: [[Guerilla Hci]] on usability testing. It's by [[Jakob Nielsen]], author of [[Usability Engineering]], and though he doesn't mention the word [[Unit Test]] (he talks of 'scenarios'), it is a kind of unit testing for usability (of course, it's not automated; but his tests are not meant to be full acceptance tests). Interesting reading. -- [[Brian Ewins]] ",
      "id": "75468fc882e84c0893b5ebebe5eb7050"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nHas anyone tried a local Wiki to store unit tests in? -- [[Thaddeus Olczyk]]",
      "id": "4e33a8c252db9d99608fd13f5a3153a2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nI find it hard to write [[Unit Test]]s where the unit being tested is heavily network-related, especially where it relies on components across the network to function properly. Does anyone have experience with [[Unit Testing Network Functionality]]? -- [[Gabriel Wachob]]",
      "id": "8edf6f4613c2aeb6fbfc97385bde0e39"
    },
    {
      "type": "html",
      "text": "\nI would suggest looking at [[Mock Object]] to help here. Your code should be designed to separate the model from network interaction (perhaps through appropriate APIs). The model can be tested properly with a set of [[Mock Object]]s implementing your networking API. Testing the networking API itself can be done without involving your model too. But then again, your particular problem might just be the exception to the rule. -- [[Channing Walton]]",
      "id": "a7a28075f79ab84b7a79558ea0a5d4b5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nWhat if you have most of your code outside the classes? Like in [[Php Language]], with [[Php Unit]]. -- [[David Escala]]",
      "id": "7f4dea9583267bb282683efce0803eca"
    },
    {
      "type": "html",
      "text": "<i>Maybe you are not programming object oriented?</i> -- [[Xavi Albaladejo]]",
      "id": "57f4dc35f2f0a935877794fb37864d68"
    },
    {
      "type": "html",
      "text": "\nYes. In php there is almost always some code outside the classes. I know I ought to make everything [[Object Oriented]], but sometimes it is difficult to do so. -- [[David Escala]]",
      "id": "a4aa0cdfb4dacfedb5b7b079ec2546a3"
    },
    {
      "type": "html",
      "text": "\nThe key point of testing, of course, is that you get good enough test coverage, cheaply enough. This is why unit tests are good: you can test the same things with functional tests, but you can generally do it more easily and cheaply with unit tests. That is why the real trick is not to work harder on writing the tests, but to write code that is more easily testable. When you take this approach, I think you'll find your logic naturally migrating out of pages and into classes.",
      "id": "82b83b7b42bb9016d3cf6a2170869e30"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nShould unit testing test the public interface of a class or the private implementation?",
      "id": "67b01b029be9e07daf1e8b16be65429c"
    },
    {
      "type": "html",
      "text": "(Apologies if this is an old chestnut)",
      "id": "87c69598fb015ea05973ff81e18bcc61"
    },
    {
      "type": "html",
      "text": "\nI'm coding in Java and I frequently find that I want to test private methods of my classes in isolation. I usually resort to giving the methods default access instead and testing from a test case in the same package. However, this smells and feels like a violation of encapsulation.",
      "id": "8276ad485a3d27099af240ce07fe6e71"
    },
    {
      "type": "html",
      "text": "\nI've seen a number of commentators state that unit tests should all be done against the [[Public Interface]]. However, frequently when I resort to testing the public interface, my tests become harder to construct and take on the feel of acceptance tests. This is perhaps because my objects are too big. However, if I were to break them down into smaller public classes to facilitate testing, aren't these additional public classes just exposing the implementation anyway?",
      "id": "84a459c04f0682a1018e993158fc4bfa"
    },
    {
      "type": "html",
      "text": "\nPerhaps I'm really missing the point given Michael Hills comment above in <b>Are we testing too much?</b> about testing privates? I believe unit testing is about testing method implementations not public interfaces, but there doesn't seem an easy way to do this in languages like Java. Now I'm really missing that much slighted <i>friend declaration</i> from my C++ days!",
      "id": "edd606e9376674e676e8fc1bc6e7a8c1"
    },
    {
      "type": "html",
      "text": "-- [[Martin Bayly]]",
      "id": "db756f3ced6d0c5ea4ed9c2c20884852"
    },
    {
      "type": "html",
      "text": "\nSee [[Extreme Programming Testing Private Methods]], and [[Methods Should Be Public]]. You specifically do <b>not</b> want to test method implementations unless you are really desperate to put in some tests (perhaps when [[Unit Testing Legacy Code]]). If the implementation changes, the tests break; not fun. You don't want the tests to force you into a particular implementation. You want the tests to work as scaffolding, not a cage.",
      "id": "9fcd5c30a3db0998a626d6b5244d6c75"
    },
    {
      "type": "html",
      "text": "\nI've found that when I really get into testing, I end up refactoring the code into [[Lots Of Short Methods]], most public or package, and most with their own tests. There are several ways to deal with this \"interface pollution\":",
      "id": "b3a96d9bf8feba7933d759b9a4bf3369"
    },
    {
      "type": "html",
      "text": " Ignore it",
      "id": "570b8954aa6413ecc8c90d0fd67a37ff"
    },
    {
      "type": "html",
      "text": " [[Re Factor]] a big class into many smaller classes and use delegation instead of having the class do everything on its own",
      "id": "ab4e600071497261621feca0cb4cffef"
    },
    {
      "type": "html",
      "text": " Use package visibility rather than public",
      "id": "baaeb7ff8e88f9a4957198f5b644f153"
    },
    {
      "type": "html",
      "text": " Expose your class through an interface that doesn't use all the methods",
      "id": "36fb9c230688ee3fd70051607927ec14"
    },
    {
      "type": "html",
      "text": "\nActually, the first one isn't so bad during development because it gives you more opportunities to do refactorings such as [[Move Method]]. The second one is probably an all-around good thing to do anyway since it will help your code conform to the [[Law Of Demeter]]. There are probably other ways I haven't considered...",
      "id": "c012e275a8853fd71d81990f84c32a4d"
    },
    {
      "type": "html",
      "text": "<i>Recently I have been involved in lots of discussions about [[Writing Testable Classes]]. The essence of this is that often you morph your [[Class Under Test]] to facilitate good testing.</i>",
      "id": "0321d3bde258f00c96cb4948ae5ffdca"
    },
    {
      "type": "html",
      "text": "<i>-- [[Mike Porter]]</i>",
      "id": "3fe2fa64fe14b0707e3877dec6152efa"
    },
    {
      "type": "html",
      "text": "<b>This is where [[Re Factoring]] ties in.</b>",
      "id": "3deff8fcc273acddeadf8229e9b75304"
    },
    {
      "type": "html",
      "text": "\nI think unit tests should test the interface: if the interface didn't change, how could it break the application?... invariants ([[Class Invariant]]) are good for testing internals. -- [[Panu Kalliokoski]]",
      "id": "9b235f49daa56e551a7e559dee141e34"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nI'm not sure if it's good practice, but it seems logical to do white-box testing by exercising package-private methods in the parallel test hierarchy.  I have found myself adding package-private methods just for testing, it seems like an ideal solution to the problem you describe.",
      "id": "5448c34f418338f050abd6429401adfa"
    },
    {
      "type": "html",
      "text": "<i>-- Orbfish</i>",
      "id": "39f1f4ae7ace9cdfe4c88f88d9c6ddcd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "<b>[[Unit Test]]s for XML/XSLT</b>",
      "id": "662b03d5ea95018727202908cd71a144"
    },
    {
      "type": "html",
      "text": "\nI am really stuck on testing XSLT (and CSS as well). Things in my world seem to be headed toward XML for data and XSLT for presentation and transformation (with possible use of CSS, XFORM, etc.).",
      "id": "efa56092913b45ce3df2de79d78ed7f0"
    },
    {
      "type": "html",
      "text": "\nIt seems that future applications may consist of little more than XML, XSLT and maybe a little script glue.",
      "id": "706f5655b2f14dc7dd7157b03cad952b"
    },
    {
      "type": "html",
      "text": "\nAnyone care to make any suggestions on how to apply XP unit testing on this stuff? Object-oriented it ain't!",
      "id": "ad57d3946c1da486aaf1535606acd9e8"
    },
    {
      "type": "html",
      "text": "-- [[Dan Vokt]]",
      "id": "f5b89e21fb035695a6b0e0fb83ab6223"
    },
    {
      "type": "html",
      "text": "\nSee [[Xml Unit]], [[Xslt Unit]]",
      "id": "d3a90b98ad3fc4423ee5342b673b5715"
    },
    {
      "type": "html",
      "text": "\nFor data transformers (filters) such as XSLT, a good unit testing method is often to drive the transformation once, check that it is what was intended, store the result, and run <b>diff -u</b> against the stored result and the current result of the transformation. -- [[Panu Kalliokoski]]",
      "id": "a72f396a8587f99f24a50867a63bbddb"
    },
    {
      "type": "html",
      "text": "\nThere is another approach. It is possible to verify transformation logic of one template only: whether it is invoked via call-template or apply-templates. Some time ago I've created a small Java library allowing to call or apply transformations of one template and then to verify result of the transformation. Verification can be achieved via XPath. I did not have any time to publish this tool, or to continue its developing, so if anyone interested in it one could contact me. -- [[Pavel Sher]]",
      "id": "119b355d5b74c088cd65209725a698d7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "<i>Are we confusing tradition with necessity?</i>",
      "id": "b016e6a054dc3c5167ef99acb90b412f"
    },
    {
      "type": "html",
      "text": "\nPerhaps the distinction between an [[Acceptance Test]] (nee \"functional test\") and a [[Unit Test]] is not what they test or how they're done, but in who they satisfy. The acceptance test makes the customer satisfied that the software provides the business value that makes them willing to pay for it. The unit test makes the programmer satisfied that the software does what the programmer thinks it does. ",
      "id": "f2f27b4096dd2f84fae06ecb468b918d"
    },
    {
      "type": "html",
      "text": "\nIt could be that some people confuse traditions with the actual definition of the tests. One might say, for example, \"A unit test is testing an individual class in isolation,\" or \"An acceptance test tests the entire program.\" That would be wrong. They are not the definitions, just traditions resulting from the forces that act upon you when you are doing testing. There is absolutely nothing wrong with the programmer writing a so-called unit test that tests the whole program, or with the customer defining an acceptance test that stubs out part of the system. It's up to the people doing it to weigh the costs and benefits, not to be arbitrarily constrained to tradition.",
      "id": "1bb5a2b2eed2f14730b8f351347158e7"
    },
    {
      "type": "html",
      "text": "\nHowever, some authors such as [[Martin Fowler]] and [[Matthew Foemmel]] believe that \"Unit tests are written by developers and typically test an individual class or small group of classes.\" [[http://www.martinfowler.com/articles/continuousIntegration.html#N222 www.martinfowler.com]] It may be that the authors are providing definitions or it may be that they are acknowledging a traditional understanding of the terms. In any case, [[Martin Fowler]] would probably be the first to say do what works and not be constrained to traditions when they do not serve well.",
      "id": "5903473df09733bbbaf9b4e6af42c24c"
    },
    {
      "type": "html",
      "text": "<i>[[[Do Both Unit And Acceptance Tests]].]</i>",
      "id": "0bbc807e75b987b64eff32aeba653211"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nFrom the XP mailing list:",
      "id": "4214818a61b18b934d8e9894716b9e99"
    },
    {
      "type": "html",
      "text": "I'm trying to introduce some XP practices where I work. People are resisting unit tests for a couple of reasons and I'm looking for help. One of the problems is that the tests are fragile in the face of XP's dynamic and evolving design. Someone goes to the effort of writing a bunch of unit tests, and then they realize that their design was wrong. To change the design they have to modify some or all of the tests. Typically they just comment out the tests. The feeling is that it would be easier to write the tests once the design has solidified a bit more. -- Chris",
      "id": "2a52634e6649a22d4eea9a75b2d0d0f3"
    },
    {
      "type": "html",
      "text": "\nChris, it sounds as if there are a few issues in your testing approach that could be fixed.",
      "id": "3fafd31132f2101581dba61ccdc79b2a"
    },
    {
      "type": "html",
      "text": " <b>Is the testing framework awkward?</b> Most of the time, it should be easier to add a new test than to add the code that passes it.",
      "id": "b3c79ce5f2fe7c163dde54cc21bcd9c0"
    },
    {
      "type": "html",
      "text": " <b>Are we writing mini-functionals?</b> A common newbie mis-step is to write [[Unit Test]]s which focus on an object's behavior in complex interactions with other objects. Focus on isolated behavior. Sometimes tests can be mini-functionals, but we can move with more confidence if we know that the collaborators are themselves thoroughly tested.",
      "id": "95e79d4768b26196eb03a5ded6b9bab1"
    },
    {
      "type": "html",
      "text": " <b>But we can't test this object without pulling in all those other objects.</b> This is often a smell. Objects should be tiny and stupid. That way we can write tests that are tiny and stupid. Bang at the object until you <i>can</i> test it in isolation. Or abandon the design that created that object. Investigate [[Mock Object]]s and other strategies that help to put one object at a time under the microscope.",
      "id": "78ac482a51a0356570ab6719eafaee4f"
    },
    {
      "type": "html",
      "text": " <b>Are the tests looking too deep into the guts?</b> If our tests poke too deep into mechanisms, then every time we change the mechanism we have to change all the tests. The less you expose to the world, the fewer the unit tests you will write.",
      "id": "1b8f751b265cdd52b36e8ac1cf9955c2"
    },
    {
      "type": "html",
      "text": " <b>Are we testing too much?</b> The purpose of unit testing is to increase developer mobility. It is <i>not</i> to verify the correctness of your program. Are you testing privates? Are you testing simple accessors? Are you trying to make unit tests perform 100% code coverage? These are all practices that may have some value, but also may serve to defeat the real purpose of unit tests.",
      "id": "764dc78d1b329417136624d6ccee2657"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nIt's a wonderful humbling experience, [[Unit Test]]s. I don't write code any other way anymore. My code has less problems, I have more confidence and management has more confidence. -- sg",
      "id": "f1de95938e0422fd4950061b6925920f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "Writing test often needs more time than implementing the features, but I think that's good because testing is the most important activity to create good software.",
      "id": "c4e14ed868f91f7810701d0a5597f6ea"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "[[Answer Me]]. Does anyone have experience unit testing Informatica mappings? -- [[Eric Hodges]]",
      "id": "d9d0c8b45d9092d19820b4e00cf2b213"
    },
    {
      "type": "html",
      "text": "\nEvery day. I work there. - [[Anonymous Donor]]",
      "id": "c5144c96bc1d7957bf145757ccf2e492"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "I found that unit testing add a very nice immediate access to the code I'm currently working on. If I don't [[Unit Test]] then before testing a chunk of code I must run the whole app (wait 5s), load some data (1s to 1 minute ) and walk across the application until a place I can exerce [?] my new code. When I [[Unit Test]] I just run the test.",
      "id": "ce2bae032c5f258962cb9db1e5511f57"
    },
    {
      "type": "html",
      "text": "\nI never see anyone notice this here but it happens to be a very nice improvement in my working process. Am I just unlucky working on application with heavy setup or does other people see this as an basic [[Good Sense]] improvement ?",
      "id": "c246e3cc71ae4bbac582881637d1663c"
    },
    {
      "type": "html",
      "text": "\nI [[Have This Pattern]]. The current behaviour I'm testing would take tedious setup and 10 to 15 minutes of running to get to without [[Unit Test]]s. Not only would this be a boring pain in the ass, but it would be a constant flow breaker. Also, it's intricate enough that even with a written down test procedure, I'd probably never end up refactoring the code once it works; I'd not want to go through and manually test the code again, when it's not even fresh in my mind. Unfortunately, I'm still arranging the app to be easier to set up state to test other such situations. -- [[Joe Weaver]]",
      "id": "e9e1e967664e9f93beb85a17b252fff0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "[[Wayne Miller]]'s question moved to [[Programmer Test]]",
      "id": "323edf3c74479f809a3d3d465ce2bb16"
    },
    {
      "type": "html",
      "text": "\nAll runround..wondering.. What To Do Best and How ??",
      "id": "de779206215064601fba2569d177a825"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "<b>See</b>",
      "id": "cc69aeedfc8740a4f40591b46d07fdf3"
    },
    {
      "type": "html",
      "text": "\nSpecific tips on doing [[Unit Test]]s:",
      "id": "9d30b09a48d618e50828ad69bbf6f343"
    },
    {
      "type": "html",
      "text": "[[Developer Test Techniques]], [[Xp Test Faq]], [[Unit Test Examples]], [[Code Unit Test First]], [[Test Everything That Could Possibly Break]], [[Optimizing Unit Tests]], [[Unit Test Examples And Guidelines]], [[Mock Object]], [[Unit Testing Errors]], [[Unit Testing Corba]], [[Fragile Tests]]",
      "id": "82e32d7f9e575d9971069ff8ee4abd33"
    },
    {
      "type": "html",
      "text": "\nDomain-specific advice:",
      "id": "902164cf9690701c6fc3ac14a6d4edb1"
    },
    {
      "type": "html",
      "text": "[[Unit Tests And Databases]], [[Gui Unit Testing]], [[Unit Testing Mars Orbiters]], [[Unit Testing Legacy Code]], [[Unit Tests For Synchronization Logic]], [[Test Printed Output]], [[Unit Tests For Libraries]]",
      "id": "083def5baa3805cda00bf7dcdd242abf"
    },
    {
      "type": "html",
      "text": "\nStop-gap measures for when you can't figure out how to test it properly:",
      "id": "4ed61a6ca68a5acc5175172a55784c97"
    },
    {
      "type": "html",
      "text": "[[Dont Change The Code Test]], [[No Tests Yet Test]], [[Untestable Units]]",
      "id": "58d2b96b4829e4c0afd089cae53e4774"
    },
    {
      "type": "html",
      "text": "\nHow does unit-testing change the way you think about programming?",
      "id": "d6ca4b54904f2cbcefb54d6a9a5bdee8"
    },
    {
      "type": "html",
      "text": "[[Unit Testing Is Design]], [[Arguing Through Unit Tests]], [[Resilience Vs Anticipation]], [[Programmer Test]]",
      "id": "5f787c2c89293a16c266d960a5d33ae0"
    },
    {
      "type": "html",
      "text": "\nSemantics & renaming:",
      "id": "896eccf018efafa535e31163cdb9e598"
    },
    {
      "type": "html",
      "text": "[[Renaming Unit Tests]], [[Unit Tests Defined]], [[Xp Vs Standard Definition Of Unit Test]], [[Programmer Test]]",
      "id": "713e6d5e47b5cdf873495ce45a484a16"
    },
    {
      "type": "html",
      "text": "\nOthers:",
      "id": "1218f9e422cf93c63c6ffe362497dd03"
    },
    {
      "type": "html",
      "text": "[[Unit Testing Costs Benefits]], [[Unit Test Trial]], [[Source Test]], [[Qa Is Not Qc]], [[Is Unit Testing Extreme]], [[Acceptance Test]]s, [[Separate Coding And Testing]], [[Poor Mans Testing Framework]]",
      "id": "b0e7bcd3bfdae2ab2bd206028c38f8a6"
    },
    {
      "type": "html",
      "text": "\nNew: [[Late Onset Testing]] - writing tests for code that's already written",
      "id": "fd2154d957a68c5a19d482886d6f6b4c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "Here's a [[Stupid Question]]: could someone define what a 'Unit' is in the lexicon of XP? I tend to think \"compiler unit\", or \"integration unit\", but I'm thinking that these units are more like at the level of individual methods. Is there any official definition?",
      "id": "2ca63e74bf30055ffaa365cb5d4966fa"
    },
    {
      "type": "html",
      "text": "\nThe Nomenclature of Unit Tests\n[http://smallwiki.unibe.ch/nomenclatureofunittests/ smallwiki.unibe.ch]\nsays a Unit is ... um ... nevermind.",
      "id": "40938b6284af3f778ccdf98caba1d374"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "[http://www.testingfaqs.org/t-unit.html www.testingfaqs.org] has a list of [[Java Unit Clones]]",
      "id": "22bf99484ef352ca68a434f7b81bf69d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nI am starting a new web application where we will be using SSL certificates for authentication.  I would like to use a web testing framework like [[Http Unit]] or [[Html Unit]] to test that user Alice with certificate A gets the right privileges, user Bob with certificate B gets his different set of privileges, and user Sam (the Saboteur) with certificate S gets no privileges.  The members of the [[Http Unit]] mailing list told me that [[Http Unit]] couldn't do that, and that I should roll my own using the Jakarta Commons [[Http Client]] library, but there seems to be no way to explicitly say what binary certificates the client should offer the server.",
      "id": "baa553bd5bd9ab40a83dda27daa0c59e"
    },
    {
      "type": "html",
      "text": "\nIs there a tool I've missed? -- [[Eric Jablow]]",
      "id": "a99ed15302733057303508183a34ee59"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "[http://ojesunit.blogspot.com/ ojesunit.blogspot.com] is a new way of writing unit test in php",
      "id": "09b5e07b6034638ee7e570009d08c20c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nUnit testing for our teams has become a proven tool and provides the developers a comfortable way in which they can reach the levels of desired quality. Especially on projects where we use test driven development for system as wel as integration tests, we see a high increase in commitment towards testing from the developers when applying unit testing to realize and fulfill requirements for different test stages. We currently succesfully apply this in agile as well as traditional project approaches. ",
      "id": "ccf6e7fb62f92d1f9433672a7fc031ff"
    },
    {
      "type": "html",
      "text": "-- [[Ronaldvan Aken]]",
      "id": "7653ba8341dc603dac07c055772bc591"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "\nWhat happens when a one or more functions are dependent on a function whose behavior is likely to change with time?  i.e., a function for selecting tax rate based on income will probably be changed from year to year.  Therefore, if another function computes the tax owed using this changing function, its unit tests will fail with every change.  Worse yet, a function to compute the gross income, which uses both of these functions, will also have its unit tests break.  -- mb",
      "id": "e800f292d199ddb3ccab1210ee4a1951"
    },
    {
      "type": "html",
      "text": "\nConsider that a [[Code Smell]]. If your code isn't working for [[Unit Test]]s, your code needs fixed. In this case, either give the tax-rate function an extra parameter (year), so you can simply add new [[Unit Test]]s to handle it. Or consider use of a tax-rate [[Context Object]] with a appropriate [[Functor Object]]s configured for region and year. ",
      "id": "be8b769a0aa3b8abaf8577c93da99617"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "<i>Any ideas on how to test asynchronous code. For example I want to test the Lucene indexing & querying mechanism. And both in concerto. Should I change the production code to have hooks where I can put my testing code into? ~~~</i>",
      "id": "a1f0c9d6376084a1a84d4eb024f00f9c"
    },
    {
      "type": "html",
      "text": "\nThis is the FAQ \"How do I test { complexity | performance | concurrency | security | look-n-feel | awesomeness | etc }?\"",
      "id": "6549dd4f59b68751cdf2671cfa558fd8"
    },
    {
      "type": "html",
      "text": "\nThe answer is you don't, because ordinary tests are for [[Software Engineering]], and exhaustively examining any of those topics is [[Computer Science]]. For each of those things, you pick from the [[Computer Science]] literature a good-enough algorithm. Then you use [[Developer Test]]s to check that each detail of the algorithm is correctly implemented. (See [http://broadcast.oreilly.com/2009/02/merb-mind-maps.html broadcast.oreilly.com] for an example implementing [[Minimum Cost Spanning Tree]].)",
      "id": "e14e1a6eb0cf44649d77071bbeb3689b"
    },
    {
      "type": "html",
      "text": "\nFor concurrency, a test case should configure a mock object to perform one way, then another, and you would assert that your production code dealt with the results correctly.",
      "id": "9c72b61f7d6b5eb1981770653bf7fe35"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bb824a9c8a209ede8575bc50d80adbae"
    },
    {
      "type": "html",
      "text": "[[Category Testing]]",
      "id": "14203ce136b5f6c54510bc8297b5500d"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?UnitTest c2.com]",
      "id": "cfa1b33bb8733957d59b7d082df68106"
    }
  ],
  "journal": [
    {
      "date": 1362171581000,
      "id": "2385700e8f31ea892977a4dd33c3087e",
      "type": "create",
      "item": {
        "title": "Unit Test",
        "story": [
          {
            "type": "html",
            "text": "A kind of [[Automated Test]], though some would say a better name is [[Developer Test]]",
            "id": "060d04d0403efc3b8f20c0301c697793"
          },
          {
            "type": "html",
            "text": "\"Unit\" casually refers to low-level test cases written in the same language as the production code, which directly access its objects and members.",
            "id": "89aa8534710d303444acd188ded03532"
          },
          {
            "type": "html",
            "text": "\nUnder the strict definition, for QA purposes, the failure of a [[Unit Test]] implicates only one unit. You know exactly where to search to find the bug.",
            "id": "9715b0e17a0c67b06173bfbab70d86cf"
          },
          {
            "type": "html",
            "text": "\n[[Test Driven Development]] produces [[Developer Test]]s. The failure of a test case implicates only the developer's most recent edit. This implies that developers don't need to use [[Mock Object]]s to split all their code up into testable units. And it implies a developer may always avoid debugging by reverting that last edit.",
            "id": "ced796419fbb07a4d89f079b7a62cbec"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "(Note that although most of the text on this Wiki uses the term [[Unit Test]], the canonical [[Extreme Programming]] name has been changed to [[Programmer Test]].)",
            "id": "f4142f9a2004f816a94daa5cba2c0c26"
          },
          {
            "type": "html",
            "text": "\n[[Unit Test]]s are programs written to run in batches and test classes. Each typically sends a class a fixed message and verifies it returns the predicted answer.",
            "id": "7305c703dca98a83792e4cc57f772094"
          },
          {
            "type": "html",
            "text": "\n[[Unit Test]]s are a key component of software engineering, and the [[Extreme Programming]] discipline leverages them to permit easy code changes. Developers write tests for every class they produce. The tests are intended to test every aspect of the class that could conceivably not work. (Do test adding and removing, don't test accessors.)",
            "id": "1a6b57215b93c5c0e9a936c3b262cf8a"
          },
          {
            "type": "html",
            "text": "\nKey here is to [[Code Unit Test First]].",
            "id": "ac21008fc39798963595b34ba528a539"
          },
          {
            "type": "html",
            "text": "\n[[Unit Test]]s are all combined into a huge suite of tests, using e.g. [[Kent Beck]]'s [[Testing Framework]]. When developers go to release new code, they run all the unit tests, not just theirs, on the integration machine. The tests <b>must</b> run at 100%. If any test fails, they figure out why and fix the problem. The problem certainly resides in something they did ... since they know the tests ran at 100% the last time anything was released.",
            "id": "17aaa9887492bf851f0c55aa48a38b41"
          },
          {
            "type": "html",
            "text": "\nOf course, sometimes the tests let something slip through. When that happens, developers unconditionally enhance the unit tests so that that problem, and any similar one that comes to mind, won't happen again.",
            "id": "0563bf28a75a521801274947b5d27a4e"
          },
          {
            "type": "html",
            "text": "-- [[Ron Jeffries]]",
            "id": "1fb192cd379ce5c816e4ff5f4a59d105"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nC3 [[[Chrysler Comprehensive Compensation]]] has over 1300 unit tests, performing over 13,000 individual checks. They run in about 10 minutes in [[Visual Works]]. -- [[Ron Jeffries]]",
            "id": "0e7d60b94f4436049a573c9ed76e6a0b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nAlso, did you introduce tests late in development that identified unforeseen problems? If so, did your fixes to those problems break other things? In other words, how did you fight the \"if it ain't broke don't fix it\" attitude? -- [[Kieran Barry]]",
            "id": "4ba8bcede58fe409235733d46d255162"
          },
          {
            "type": "html",
            "text": "\nIt is the [[Unit Test]]s themselves that allow you to get away from the \"if it ain't broke don't fix it attitude.\" You must be able to modify anything in the entire system at anytime. Ah the freedom of it! The only way you can do that is to require the [[Unit Test]]s be run before any code is released at a [[Single Release Point]]. -- [[Don Wells]]",
            "id": "c6dd52db5a6dda3ee9395f4a863d873d"
          },
          {
            "type": "html",
            "text": "\nThis isn't 100% true though. It is quite possible to introduce a modification, run the tests and have 100% test coverage with all tests passing, and still have broken the system. It's just less likely the more tests there are (but more likely the more complex the system is). In these cases the passing tests have induced a false sense of security. The probability of a change causing a bug to slip through a set of tests can only approach zero for an arbitrary system, although some specific systems may have such a zero probability. This is because an arbitrary system can describe the [[Halting Problem]], which is provably undecidable, therefore an algorithm that describes it is untestable, which means that arbitrary systems are not 100% testable, and of course if there aren't tests for a piece of code, a bug can slip though. Contrived, sure, but true in lots of other more practical examples too. -- [[Mike Amy]]",
            "id": "1f0a1c383d9dff86faabf5f0691bcc69"
          },
          {
            "type": "html",
            "text": "<i>I don't think Don's talking about whether or not unit test can guarantee that a function is bug-free.  I believe he's talking about how they can \"cure\" the \"If it ain't broke, don't fix it\" attitude.  BTW, the inability of unit test's to guarentee correct behavior is not tied to the halting problem.  We can construct languages where the halting problem (for that language) is solvable, but still can't be 100% unit tested.</i>",
            "id": "2b75d00b64ee2843701c7f1ba0a5d52c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nWhat about things that can't be tested without human interaction? For example, suppose you have some code that handles printing. (And suppose the code is sufficiently deep in the system that it's not directly tested by a customer-written acceptance test. And suppose that it is necessary to test it at each integration, because breaking it can have subtle effects that will not easily be identified with this code without unit tests.) For most projects, the only practical way to test this printing code is to have a human inspect the paper that comes out of the printer and verify that it appears as it should. How does the XP testing process deal with this?",
            "id": "0952c2747e6d1e49000bc8a3510ab93e"
          },
          {
            "type": "html",
            "text": "<i>You can always install a pseudo printer (virtual printer like PDFCreator for Windows) and have the application print to it. It would generate post script or PDF file which you can easily compare with a valid .ps or .pdf file. Perhaps you picked the wrong example in printing.</i>",
            "id": "d91debad54619351b1df3b868d305a16"
          },
          {
            "type": "html",
            "text": "<i>If you [[Code Unit Test First]] your design will be far different from what you might expect. Most likely you will isolate the code which actually prints something to a physical printer from the code which formats something to be printed. Once the physical printer driver is tested it is unlikely to be changed anytime soon. That puts it into the not-likely-to-break category and is then exempt from unit tests. If it ever does change it is tested again by inspection of the physical output. The code that formats output destined for printing can be unit tested as usual. </i>",
            "id": "961b95183461a5be0d3eb91f9308a251"
          },
          {
            "type": "html",
            "text": "<i>Also remember that [[Acceptance Test]]s (XP style) cover anything that is of value to the customer. If it is not valuable enough to figure out how to test it then it should be removed immediately if not sooner. </i>Where there is a will there is a way to test.<i> -- [[Don Wells]]</i>",
            "id": "f56c19efb2f686312140699c0212fa93"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "How does one test [[Artificial Intelligence]] algorithms? I'm inclined to think they require human interaction, and they also tend to change often. -- [[Yuri Khan]]",
            "id": "9da16d8c8f492a18850b9db9c60c2efc"
          },
          {
            "type": "html",
            "text": "\nCreating [[Artificial Intelligence]] algorithms like [[Artificial Neural Network]] or [[Genetic Algorithm]] usually starts with creating a testset. This testset is often used in the process of creating the algorithm, for example for training a neural network or for the selection in genetic programming.",
            "id": "85caf5fa1d6ee24d94d6334bb8c4de1d"
          },
          {
            "type": "html",
            "text": "\n[[Numerical Optimization]] code is tricky to [[Unit Test]] exactly, but it is possible to [[Unit Test]] it heuristically. Has the accuracy of the learner increased over several training epochs? If not, maybe the [[Learning Rate]] is too high. (This test may be too high-level to be considered a [[Unit Test]], [[Per Se]].) Finer-grained tests include asserting that analytic computations of gradients (used for [[Back Prop]] in [[Neural Networks]]) is equal to numerical computations thereof, [[Plus Or Minus]] some epsilon.  -- [[Joseph Turian]]",
            "id": "c135109035a13115d2e520a6dc2733da"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nI just came across this paper, which oozes XP-ness: [[Guerilla Hci]] on usability testing. It's by [[Jakob Nielsen]], author of [[Usability Engineering]], and though he doesn't mention the word [[Unit Test]] (he talks of 'scenarios'), it is a kind of unit testing for usability (of course, it's not automated; but his tests are not meant to be full acceptance tests). Interesting reading. -- [[Brian Ewins]] ",
            "id": "75468fc882e84c0893b5ebebe5eb7050"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nHas anyone tried a local Wiki to store unit tests in? -- [[Thaddeus Olczyk]]",
            "id": "4e33a8c252db9d99608fd13f5a3153a2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nI find it hard to write [[Unit Test]]s where the unit being tested is heavily network-related, especially where it relies on components across the network to function properly. Does anyone have experience with [[Unit Testing Network Functionality]]? -- [[Gabriel Wachob]]",
            "id": "8edf6f4613c2aeb6fbfc97385bde0e39"
          },
          {
            "type": "html",
            "text": "\nI would suggest looking at [[Mock Object]] to help here. Your code should be designed to separate the model from network interaction (perhaps through appropriate APIs). The model can be tested properly with a set of [[Mock Object]]s implementing your networking API. Testing the networking API itself can be done without involving your model too. But then again, your particular problem might just be the exception to the rule. -- [[Channing Walton]]",
            "id": "a7a28075f79ab84b7a79558ea0a5d4b5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nWhat if you have most of your code outside the classes? Like in [[Php Language]], with [[Php Unit]]. -- [[David Escala]]",
            "id": "7f4dea9583267bb282683efce0803eca"
          },
          {
            "type": "html",
            "text": "<i>Maybe you are not programming object oriented?</i> -- [[Xavi Albaladejo]]",
            "id": "57f4dc35f2f0a935877794fb37864d68"
          },
          {
            "type": "html",
            "text": "\nYes. In php there is almost always some code outside the classes. I know I ought to make everything [[Object Oriented]], but sometimes it is difficult to do so. -- [[David Escala]]",
            "id": "a4aa0cdfb4dacfedb5b7b079ec2546a3"
          },
          {
            "type": "html",
            "text": "\nThe key point of testing, of course, is that you get good enough test coverage, cheaply enough. This is why unit tests are good: you can test the same things with functional tests, but you can generally do it more easily and cheaply with unit tests. That is why the real trick is not to work harder on writing the tests, but to write code that is more easily testable. When you take this approach, I think you'll find your logic naturally migrating out of pages and into classes.",
            "id": "82b83b7b42bb9016d3cf6a2170869e30"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nShould unit testing test the public interface of a class or the private implementation?",
            "id": "67b01b029be9e07daf1e8b16be65429c"
          },
          {
            "type": "html",
            "text": "(Apologies if this is an old chestnut)",
            "id": "87c69598fb015ea05973ff81e18bcc61"
          },
          {
            "type": "html",
            "text": "\nI'm coding in Java and I frequently find that I want to test private methods of my classes in isolation. I usually resort to giving the methods default access instead and testing from a test case in the same package. However, this smells and feels like a violation of encapsulation.",
            "id": "8276ad485a3d27099af240ce07fe6e71"
          },
          {
            "type": "html",
            "text": "\nI've seen a number of commentators state that unit tests should all be done against the [[Public Interface]]. However, frequently when I resort to testing the public interface, my tests become harder to construct and take on the feel of acceptance tests. This is perhaps because my objects are too big. However, if I were to break them down into smaller public classes to facilitate testing, aren't these additional public classes just exposing the implementation anyway?",
            "id": "84a459c04f0682a1018e993158fc4bfa"
          },
          {
            "type": "html",
            "text": "\nPerhaps I'm really missing the point given Michael Hills comment above in <b>Are we testing too much?</b> about testing privates? I believe unit testing is about testing method implementations not public interfaces, but there doesn't seem an easy way to do this in languages like Java. Now I'm really missing that much slighted <i>friend declaration</i> from my C++ days!",
            "id": "edd606e9376674e676e8fc1bc6e7a8c1"
          },
          {
            "type": "html",
            "text": "-- [[Martin Bayly]]",
            "id": "db756f3ced6d0c5ea4ed9c2c20884852"
          },
          {
            "type": "html",
            "text": "\nSee [[Extreme Programming Testing Private Methods]], and [[Methods Should Be Public]]. You specifically do <b>not</b> want to test method implementations unless you are really desperate to put in some tests (perhaps when [[Unit Testing Legacy Code]]). If the implementation changes, the tests break; not fun. You don't want the tests to force you into a particular implementation. You want the tests to work as scaffolding, not a cage.",
            "id": "9fcd5c30a3db0998a626d6b5244d6c75"
          },
          {
            "type": "html",
            "text": "\nI've found that when I really get into testing, I end up refactoring the code into [[Lots Of Short Methods]], most public or package, and most with their own tests. There are several ways to deal with this \"interface pollution\":",
            "id": "b3a96d9bf8feba7933d759b9a4bf3369"
          },
          {
            "type": "html",
            "text": " Ignore it",
            "id": "570b8954aa6413ecc8c90d0fd67a37ff"
          },
          {
            "type": "html",
            "text": " [[Re Factor]] a big class into many smaller classes and use delegation instead of having the class do everything on its own",
            "id": "ab4e600071497261621feca0cb4cffef"
          },
          {
            "type": "html",
            "text": " Use package visibility rather than public",
            "id": "baaeb7ff8e88f9a4957198f5b644f153"
          },
          {
            "type": "html",
            "text": " Expose your class through an interface that doesn't use all the methods",
            "id": "36fb9c230688ee3fd70051607927ec14"
          },
          {
            "type": "html",
            "text": "\nActually, the first one isn't so bad during development because it gives you more opportunities to do refactorings such as [[Move Method]]. The second one is probably an all-around good thing to do anyway since it will help your code conform to the [[Law Of Demeter]]. There are probably other ways I haven't considered...",
            "id": "c012e275a8853fd71d81990f84c32a4d"
          },
          {
            "type": "html",
            "text": "<i>Recently I have been involved in lots of discussions about [[Writing Testable Classes]]. The essence of this is that often you morph your [[Class Under Test]] to facilitate good testing.</i>",
            "id": "0321d3bde258f00c96cb4948ae5ffdca"
          },
          {
            "type": "html",
            "text": "<i>-- [[Mike Porter]]</i>",
            "id": "3fe2fa64fe14b0707e3877dec6152efa"
          },
          {
            "type": "html",
            "text": "<b>This is where [[Re Factoring]] ties in.</b>",
            "id": "3deff8fcc273acddeadf8229e9b75304"
          },
          {
            "type": "html",
            "text": "\nI think unit tests should test the interface: if the interface didn't change, how could it break the application?... invariants ([[Class Invariant]]) are good for testing internals. -- [[Panu Kalliokoski]]",
            "id": "9b235f49daa56e551a7e559dee141e34"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nI'm not sure if it's good practice, but it seems logical to do white-box testing by exercising package-private methods in the parallel test hierarchy.  I have found myself adding package-private methods just for testing, it seems like an ideal solution to the problem you describe.",
            "id": "5448c34f418338f050abd6429401adfa"
          },
          {
            "type": "html",
            "text": "<i>-- Orbfish</i>",
            "id": "39f1f4ae7ace9cdfe4c88f88d9c6ddcd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "<b>[[Unit Test]]s for XML/XSLT</b>",
            "id": "662b03d5ea95018727202908cd71a144"
          },
          {
            "type": "html",
            "text": "\nI am really stuck on testing XSLT (and CSS as well). Things in my world seem to be headed toward XML for data and XSLT for presentation and transformation (with possible use of CSS, XFORM, etc.).",
            "id": "efa56092913b45ce3df2de79d78ed7f0"
          },
          {
            "type": "html",
            "text": "\nIt seems that future applications may consist of little more than XML, XSLT and maybe a little script glue.",
            "id": "706f5655b2f14dc7dd7157b03cad952b"
          },
          {
            "type": "html",
            "text": "\nAnyone care to make any suggestions on how to apply XP unit testing on this stuff? Object-oriented it ain't!",
            "id": "ad57d3946c1da486aaf1535606acd9e8"
          },
          {
            "type": "html",
            "text": "-- [[Dan Vokt]]",
            "id": "f5b89e21fb035695a6b0e0fb83ab6223"
          },
          {
            "type": "html",
            "text": "\nSee [[Xml Unit]], [[Xslt Unit]]",
            "id": "d3a90b98ad3fc4423ee5342b673b5715"
          },
          {
            "type": "html",
            "text": "\nFor data transformers (filters) such as XSLT, a good unit testing method is often to drive the transformation once, check that it is what was intended, store the result, and run <b>diff -u</b> against the stored result and the current result of the transformation. -- [[Panu Kalliokoski]]",
            "id": "a72f396a8587f99f24a50867a63bbddb"
          },
          {
            "type": "html",
            "text": "\nThere is another approach. It is possible to verify transformation logic of one template only: whether it is invoked via call-template or apply-templates. Some time ago I've created a small Java library allowing to call or apply transformations of one template and then to verify result of the transformation. Verification can be achieved via XPath. I did not have any time to publish this tool, or to continue its developing, so if anyone interested in it one could contact me. -- [[Pavel Sher]]",
            "id": "119b355d5b74c088cd65209725a698d7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "<i>Are we confusing tradition with necessity?</i>",
            "id": "b016e6a054dc3c5167ef99acb90b412f"
          },
          {
            "type": "html",
            "text": "\nPerhaps the distinction between an [[Acceptance Test]] (nee \"functional test\") and a [[Unit Test]] is not what they test or how they're done, but in who they satisfy. The acceptance test makes the customer satisfied that the software provides the business value that makes them willing to pay for it. The unit test makes the programmer satisfied that the software does what the programmer thinks it does. ",
            "id": "f2f27b4096dd2f84fae06ecb468b918d"
          },
          {
            "type": "html",
            "text": "\nIt could be that some people confuse traditions with the actual definition of the tests. One might say, for example, \"A unit test is testing an individual class in isolation,\" or \"An acceptance test tests the entire program.\" That would be wrong. They are not the definitions, just traditions resulting from the forces that act upon you when you are doing testing. There is absolutely nothing wrong with the programmer writing a so-called unit test that tests the whole program, or with the customer defining an acceptance test that stubs out part of the system. It's up to the people doing it to weigh the costs and benefits, not to be arbitrarily constrained to tradition.",
            "id": "1bb5a2b2eed2f14730b8f351347158e7"
          },
          {
            "type": "html",
            "text": "\nHowever, some authors such as [[Martin Fowler]] and [[Matthew Foemmel]] believe that \"Unit tests are written by developers and typically test an individual class or small group of classes.\" [[http://www.martinfowler.com/articles/continuousIntegration.html#N222 www.martinfowler.com]] It may be that the authors are providing definitions or it may be that they are acknowledging a traditional understanding of the terms. In any case, [[Martin Fowler]] would probably be the first to say do what works and not be constrained to traditions when they do not serve well.",
            "id": "5903473df09733bbbaf9b4e6af42c24c"
          },
          {
            "type": "html",
            "text": "<i>[[[Do Both Unit And Acceptance Tests]].]</i>",
            "id": "0bbc807e75b987b64eff32aeba653211"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nFrom the XP mailing list:",
            "id": "4214818a61b18b934d8e9894716b9e99"
          },
          {
            "type": "html",
            "text": "I'm trying to introduce some XP practices where I work. People are resisting unit tests for a couple of reasons and I'm looking for help. One of the problems is that the tests are fragile in the face of XP's dynamic and evolving design. Someone goes to the effort of writing a bunch of unit tests, and then they realize that their design was wrong. To change the design they have to modify some or all of the tests. Typically they just comment out the tests. The feeling is that it would be easier to write the tests once the design has solidified a bit more. -- Chris",
            "id": "2a52634e6649a22d4eea9a75b2d0d0f3"
          },
          {
            "type": "html",
            "text": "\nChris, it sounds as if there are a few issues in your testing approach that could be fixed.",
            "id": "3fafd31132f2101581dba61ccdc79b2a"
          },
          {
            "type": "html",
            "text": " <b>Is the testing framework awkward?</b> Most of the time, it should be easier to add a new test than to add the code that passes it.",
            "id": "b3c79ce5f2fe7c163dde54cc21bcd9c0"
          },
          {
            "type": "html",
            "text": " <b>Are we writing mini-functionals?</b> A common newbie mis-step is to write [[Unit Test]]s which focus on an object's behavior in complex interactions with other objects. Focus on isolated behavior. Sometimes tests can be mini-functionals, but we can move with more confidence if we know that the collaborators are themselves thoroughly tested.",
            "id": "95e79d4768b26196eb03a5ded6b9bab1"
          },
          {
            "type": "html",
            "text": " <b>But we can't test this object without pulling in all those other objects.</b> This is often a smell. Objects should be tiny and stupid. That way we can write tests that are tiny and stupid. Bang at the object until you <i>can</i> test it in isolation. Or abandon the design that created that object. Investigate [[Mock Object]]s and other strategies that help to put one object at a time under the microscope.",
            "id": "78ac482a51a0356570ab6719eafaee4f"
          },
          {
            "type": "html",
            "text": " <b>Are the tests looking too deep into the guts?</b> If our tests poke too deep into mechanisms, then every time we change the mechanism we have to change all the tests. The less you expose to the world, the fewer the unit tests you will write.",
            "id": "1b8f751b265cdd52b36e8ac1cf9955c2"
          },
          {
            "type": "html",
            "text": " <b>Are we testing too much?</b> The purpose of unit testing is to increase developer mobility. It is <i>not</i> to verify the correctness of your program. Are you testing privates? Are you testing simple accessors? Are you trying to make unit tests perform 100% code coverage? These are all practices that may have some value, but also may serve to defeat the real purpose of unit tests.",
            "id": "764dc78d1b329417136624d6ccee2657"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nIt's a wonderful humbling experience, [[Unit Test]]s. I don't write code any other way anymore. My code has less problems, I have more confidence and management has more confidence. -- sg",
            "id": "f1de95938e0422fd4950061b6925920f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "Writing test often needs more time than implementing the features, but I think that's good because testing is the most important activity to create good software.",
            "id": "c4e14ed868f91f7810701d0a5597f6ea"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "[[Answer Me]]. Does anyone have experience unit testing Informatica mappings? -- [[Eric Hodges]]",
            "id": "d9d0c8b45d9092d19820b4e00cf2b213"
          },
          {
            "type": "html",
            "text": "\nEvery day. I work there. - [[Anonymous Donor]]",
            "id": "c5144c96bc1d7957bf145757ccf2e492"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "I found that unit testing add a very nice immediate access to the code I'm currently working on. If I don't [[Unit Test]] then before testing a chunk of code I must run the whole app (wait 5s), load some data (1s to 1 minute ) and walk across the application until a place I can exerce [?] my new code. When I [[Unit Test]] I just run the test.",
            "id": "ce2bae032c5f258962cb9db1e5511f57"
          },
          {
            "type": "html",
            "text": "\nI never see anyone notice this here but it happens to be a very nice improvement in my working process. Am I just unlucky working on application with heavy setup or does other people see this as an basic [[Good Sense]] improvement ?",
            "id": "c246e3cc71ae4bbac582881637d1663c"
          },
          {
            "type": "html",
            "text": "\nI [[Have This Pattern]]. The current behaviour I'm testing would take tedious setup and 10 to 15 minutes of running to get to without [[Unit Test]]s. Not only would this be a boring pain in the ass, but it would be a constant flow breaker. Also, it's intricate enough that even with a written down test procedure, I'd probably never end up refactoring the code once it works; I'd not want to go through and manually test the code again, when it's not even fresh in my mind. Unfortunately, I'm still arranging the app to be easier to set up state to test other such situations. -- [[Joe Weaver]]",
            "id": "e9e1e967664e9f93beb85a17b252fff0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "[[Wayne Miller]]'s question moved to [[Programmer Test]]",
            "id": "323edf3c74479f809a3d3d465ce2bb16"
          },
          {
            "type": "html",
            "text": "\nAll runround..wondering.. What To Do Best and How ??",
            "id": "de779206215064601fba2569d177a825"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "<b>See</b>",
            "id": "cc69aeedfc8740a4f40591b46d07fdf3"
          },
          {
            "type": "html",
            "text": "\nSpecific tips on doing [[Unit Test]]s:",
            "id": "9d30b09a48d618e50828ad69bbf6f343"
          },
          {
            "type": "html",
            "text": "[[Developer Test Techniques]], [[Xp Test Faq]], [[Unit Test Examples]], [[Code Unit Test First]], [[Test Everything That Could Possibly Break]], [[Optimizing Unit Tests]], [[Unit Test Examples And Guidelines]], [[Mock Object]], [[Unit Testing Errors]], [[Unit Testing Corba]], [[Fragile Tests]]",
            "id": "82e32d7f9e575d9971069ff8ee4abd33"
          },
          {
            "type": "html",
            "text": "\nDomain-specific advice:",
            "id": "902164cf9690701c6fc3ac14a6d4edb1"
          },
          {
            "type": "html",
            "text": "[[Unit Tests And Databases]], [[Gui Unit Testing]], [[Unit Testing Mars Orbiters]], [[Unit Testing Legacy Code]], [[Unit Tests For Synchronization Logic]], [[Test Printed Output]], [[Unit Tests For Libraries]]",
            "id": "083def5baa3805cda00bf7dcdd242abf"
          },
          {
            "type": "html",
            "text": "\nStop-gap measures for when you can't figure out how to test it properly:",
            "id": "4ed61a6ca68a5acc5175172a55784c97"
          },
          {
            "type": "html",
            "text": "[[Dont Change The Code Test]], [[No Tests Yet Test]], [[Untestable Units]]",
            "id": "58d2b96b4829e4c0afd089cae53e4774"
          },
          {
            "type": "html",
            "text": "\nHow does unit-testing change the way you think about programming?",
            "id": "d6ca4b54904f2cbcefb54d6a9a5bdee8"
          },
          {
            "type": "html",
            "text": "[[Unit Testing Is Design]], [[Arguing Through Unit Tests]], [[Resilience Vs Anticipation]], [[Programmer Test]]",
            "id": "5f787c2c89293a16c266d960a5d33ae0"
          },
          {
            "type": "html",
            "text": "\nSemantics & renaming:",
            "id": "896eccf018efafa535e31163cdb9e598"
          },
          {
            "type": "html",
            "text": "[[Renaming Unit Tests]], [[Unit Tests Defined]], [[Xp Vs Standard Definition Of Unit Test]], [[Programmer Test]]",
            "id": "713e6d5e47b5cdf873495ce45a484a16"
          },
          {
            "type": "html",
            "text": "\nOthers:",
            "id": "1218f9e422cf93c63c6ffe362497dd03"
          },
          {
            "type": "html",
            "text": "[[Unit Testing Costs Benefits]], [[Unit Test Trial]], [[Source Test]], [[Qa Is Not Qc]], [[Is Unit Testing Extreme]], [[Acceptance Test]]s, [[Separate Coding And Testing]], [[Poor Mans Testing Framework]]",
            "id": "b0e7bcd3bfdae2ab2bd206028c38f8a6"
          },
          {
            "type": "html",
            "text": "\nNew: [[Late Onset Testing]] - writing tests for code that's already written",
            "id": "fd2154d957a68c5a19d482886d6f6b4c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "Here's a [[Stupid Question]]: could someone define what a 'Unit' is in the lexicon of XP? I tend to think \"compiler unit\", or \"integration unit\", but I'm thinking that these units are more like at the level of individual methods. Is there any official definition?",
            "id": "2ca63e74bf30055ffaa365cb5d4966fa"
          },
          {
            "type": "html",
            "text": "\nThe Nomenclature of Unit Tests\n[http://smallwiki.unibe.ch/nomenclatureofunittests/ smallwiki.unibe.ch]\nsays a Unit is ... um ... nevermind.",
            "id": "40938b6284af3f778ccdf98caba1d374"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "[http://www.testingfaqs.org/t-unit.html www.testingfaqs.org] has a list of [[Java Unit Clones]]",
            "id": "22bf99484ef352ca68a434f7b81bf69d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nI am starting a new web application where we will be using SSL certificates for authentication.  I would like to use a web testing framework like [[Http Unit]] or [[Html Unit]] to test that user Alice with certificate A gets the right privileges, user Bob with certificate B gets his different set of privileges, and user Sam (the Saboteur) with certificate S gets no privileges.  The members of the [[Http Unit]] mailing list told me that [[Http Unit]] couldn't do that, and that I should roll my own using the Jakarta Commons [[Http Client]] library, but there seems to be no way to explicitly say what binary certificates the client should offer the server.",
            "id": "baa553bd5bd9ab40a83dda27daa0c59e"
          },
          {
            "type": "html",
            "text": "\nIs there a tool I've missed? -- [[Eric Jablow]]",
            "id": "a99ed15302733057303508183a34ee59"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "[http://ojesunit.blogspot.com/ ojesunit.blogspot.com] is a new way of writing unit test in php",
            "id": "09b5e07b6034638ee7e570009d08c20c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nUnit testing for our teams has become a proven tool and provides the developers a comfortable way in which they can reach the levels of desired quality. Especially on projects where we use test driven development for system as wel as integration tests, we see a high increase in commitment towards testing from the developers when applying unit testing to realize and fulfill requirements for different test stages. We currently succesfully apply this in agile as well as traditional project approaches. ",
            "id": "ccf6e7fb62f92d1f9433672a7fc031ff"
          },
          {
            "type": "html",
            "text": "-- [[Ronaldvan Aken]]",
            "id": "7653ba8341dc603dac07c055772bc591"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "\nWhat happens when a one or more functions are dependent on a function whose behavior is likely to change with time?  i.e., a function for selecting tax rate based on income will probably be changed from year to year.  Therefore, if another function computes the tax owed using this changing function, its unit tests will fail with every change.  Worse yet, a function to compute the gross income, which uses both of these functions, will also have its unit tests break.  -- mb",
            "id": "e800f292d199ddb3ccab1210ee4a1951"
          },
          {
            "type": "html",
            "text": "\nConsider that a [[Code Smell]]. If your code isn't working for [[Unit Test]]s, your code needs fixed. In this case, either give the tax-rate function an extra parameter (year), so you can simply add new [[Unit Test]]s to handle it. Or consider use of a tax-rate [[Context Object]] with a appropriate [[Functor Object]]s configured for region and year. ",
            "id": "be8b769a0aa3b8abaf8577c93da99617"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "<i>Any ideas on how to test asynchronous code. For example I want to test the Lucene indexing & querying mechanism. And both in concerto. Should I change the production code to have hooks where I can put my testing code into? ~~~</i>",
            "id": "a1f0c9d6376084a1a84d4eb024f00f9c"
          },
          {
            "type": "html",
            "text": "\nThis is the FAQ \"How do I test { complexity | performance | concurrency | security | look-n-feel | awesomeness | etc }?\"",
            "id": "6549dd4f59b68751cdf2671cfa558fd8"
          },
          {
            "type": "html",
            "text": "\nThe answer is you don't, because ordinary tests are for [[Software Engineering]], and exhaustively examining any of those topics is [[Computer Science]]. For each of those things, you pick from the [[Computer Science]] literature a good-enough algorithm. Then you use [[Developer Test]]s to check that each detail of the algorithm is correctly implemented. (See [http://broadcast.oreilly.com/2009/02/merb-mind-maps.html broadcast.oreilly.com] for an example implementing [[Minimum Cost Spanning Tree]].)",
            "id": "e14e1a6eb0cf44649d77071bbeb3689b"
          },
          {
            "type": "html",
            "text": "\nFor concurrency, a test case should configure a mock object to perform one way, then another, and you would assert that your production code dealt with the results correctly.",
            "id": "9c72b61f7d6b5eb1981770653bf7fe35"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bb824a9c8a209ede8575bc50d80adbae"
          },
          {
            "type": "html",
            "text": "[[Category Testing]]",
            "id": "14203ce136b5f6c54510bc8297b5500d"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?UnitTest c2.com]",
            "id": "cfa1b33bb8733957d59b7d082df68106"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1628111910422
    }
  ]
}