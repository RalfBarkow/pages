{
  "title": "GUI Patterns",
  "story": [
    {
      "type": "paragraph",
      "id": "4114a707e955560f",
      "text": "There are several design patterns that have been proposed over the years by the software community to address common concerns in UI development. Concepts such as [[Model-View-Controller]] (MVC), [[Model-View-Presenter]] (MVP), Presentation Model (PM) or Model-View-ViewModel (MVVM) have been discussed in numerous articles, blog posts and forums.\n"
    },
    {
      "type": "paragraph",
      "id": "5bab9c703ab58b4c",
      "text": "The decision of using one over another depends on many factors including type and size of the application, particular language and widget toolkit features, the level of desired testability, or personal preferences of developers."
    },
    {
      "type": "paragraph",
      "id": "ee645192c4468105",
      "text": "JavaFX by itself does not impose any particular pattern, but it implies a natural split between the visual part (FXML) and the logic (controller). Nonetheless, depending on the chosen approach, the actual implementation of the FXML controller may take different forms."
    },
    {
      "type": "paragraph",
      "id": "513dfbf36db9b517",
      "text": "In the simplest case it can play a role of a [[Supervising Controller]] [https://martinfowler.com/eaaDev/SupervisingPresenter.html page] containing complete logic, initializing bindings between different components, handling input events, interacting with external services and updating the view (see Fig. 1). The application’s state is mostly kept in the view but the controller may also keep part of it when necessary."
    },
    {
      "type": "paragraph",
      "id": "eceab27ac16b8926",
      "text": "Figure 1: Simple variant of a Supervising Controller"
    },
    {
      "type": "paragraph",
      "id": "e81662cb023912ca",
      "text": "For simple applications this might be completely sufficient and appropriate. By separating the behavioural complexity from the view it makes the application easier to understand and greatly improves its testability."
    },
    {
      "type": "paragraph",
      "id": "70c40fa34e2111fa",
      "text": "In applications that are more complex and contain multiple views, it is typically much more profitable to introduce some sort of model."
    },
    {
      "type": "paragraph",
      "id": "2ba085e68983f08d",
      "text": "In one variant, the model can be completely passive, containing only state (properties) of the view to be shared with other views and their controllers. This eliminates the need of controllers exposing state of their views to other controllers. In many cases it may also eliminate the need of controllers knowing each other, removing coupling between them and therefore improving their testability. In such case the model is the only communication channel between different entities (see Fig. 2)."
    },
    {
      "type": "paragraph",
      "id": "e404154d87b261e7",
      "text": "Figure 2: Example usage of a shared model"
    },
    {
      "type": "paragraph",
      "id": "f7fa8ca5efcd7677",
      "text": "Finally, if testability is the main driver and writing unit tests involving GUI components is either not desired or difficult, the model can completely take over business logic, becoming a realization of a Presentation Model [3] like on the Figure 3. The responsibility of the FXML controller is reduced to a role of a “thin” bridge between the view and the model, which handles all events and updates the view via property bindings."
    },
    {
      "type": "paragraph",
      "id": "bd2aab28ec3223e5",
      "text": "Figure 3: An example of a Presentation Model"
    },
    {
      "type": "paragraph",
      "id": "05b6fbadb1de8aef",
      "text": "This approach requires a bit more coding compared to previous scenarios, giving in exchange fully testable business logic, not bound to any graphical components."
    },
    {
      "type": "markdown",
      "id": "a13cdad71e998e07",
      "text": "# See Also"
    },
    {
      "type": "reference",
      "id": "2b6839f7e8ee37d1",
      "site": "wiki.ralfbarkow.ch",
      "slug": "model-view-presenter",
      "title": "Model-View-Presenter",
      "text": "I am evaluating [[Wiki Engines]] and [[Wiki Farms]] prior to choosing one for my own personal use and for various public uses.  To get additional input from experienced wiki users, and help others, I am putting the review on this wiki."
    },
    {
      "type": "reference",
      "id": "c2dcf206559dc26c",
      "site": "wiki.ralfbarkow.ch",
      "slug": "supervising-controller",
      "title": "Supervising Controller",
      "text": "The Presenter handles user gestures. The View binds to the Model directly through data binding. In this case, it's the Presenter's job to pass off the Model to the View so that it can bind to it. The Presenter will also contain logic for gestures like pressing a button, navigation, etc."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "GUI Patterns",
        "story": []
      },
      "date": 1640731814111
    },
    {
      "item": {
        "type": "factory",
        "id": "4114a707e955560f"
      },
      "id": "4114a707e955560f",
      "type": "add",
      "date": 1640731820993
    },
    {
      "type": "edit",
      "id": "4114a707e955560f",
      "item": {
        "type": "paragraph",
        "id": "4114a707e955560f",
        "text": "There are several design patterns that have been proposed over the years by the software community to ad- dress common concerns in UI development. Concepts such as Model-View-Controller (MVC), Model-View- Presenter (MVP), Presentation Model (PM) or Model- View-ViewModel (MVVM) have been discussed in nu- merous articles, blog posts and forums.\nThe decision of using one over another depends on many factors including type and size of the application, particular language and widget toolkit features, the level of desired testability, or personal preferences of develop- ers.\nJavaFX by itself does not impose any particular pattern, but it implies a natural split between the visual part (FXML) and the logic (controller). Nonetheless, depend- ing on the chosen approach, the actual implementation of the FXML controller may take different forms.\nIn the simplest case it can play a role of a Supervising Controller [2] containing complete logic, initializing bindings between different components, handling input events, interacting with external services and updating the view (see Fig. 1). The application’s state is mostly kept in the view but the controller may also keep part of it when necessary."
      },
      "date": 1640731829757
    },
    {
      "type": "edit",
      "id": "4114a707e955560f",
      "item": {
        "type": "paragraph",
        "id": "4114a707e955560f",
        "text": "There are several design patterns that have been proposed over the years by the software community to address common concerns in UI development. Concepts such as Model-View-Controller (MVC), Model-View-Presenter (MVP), Presentation Model (PM) or Model-View-ViewModel (MVVM) have been discussed in numerous articles, blog posts and forums.\n"
      },
      "date": 1640731869693
    },
    {
      "type": "add",
      "id": "5bab9c703ab58b4c",
      "item": {
        "type": "paragraph",
        "id": "5bab9c703ab58b4c",
        "text": "The decision of using one over another depends on many factors including type and size of the application, particular language and widget toolkit features, the level of desired testability, or personal preferences of developers."
      },
      "after": "4114a707e955560f",
      "date": 1640731881434
    },
    {
      "type": "add",
      "id": "ee645192c4468105",
      "item": {
        "type": "paragraph",
        "id": "ee645192c4468105",
        "text": "JavaFX by itself does not impose any particular pattern, but it implies a natural split between the visual part (FXML) and the logic (controller). Nonetheless, depending on the chosen approach, the actual implementation of the FXML controller may take different forms."
      },
      "after": "5bab9c703ab58b4c",
      "date": 1640731900982
    },
    {
      "type": "add",
      "id": "513dfbf36db9b517",
      "item": {
        "type": "paragraph",
        "id": "513dfbf36db9b517",
        "text": "In the simplest case it can play a role of a Supervising Controller [2] containing complete logic, initializing bindings between different components, handling input events, interacting with external services and updating the view (see Fig. 1). The application’s state is mostly kept in the view but the controller may also keep part of it when necessary."
      },
      "after": "ee645192c4468105",
      "date": 1640731929394
    },
    {
      "item": {
        "type": "factory",
        "id": "eceab27ac16b8926"
      },
      "id": "eceab27ac16b8926",
      "type": "add",
      "after": "513dfbf36db9b517",
      "date": 1640731934306
    },
    {
      "type": "edit",
      "id": "eceab27ac16b8926",
      "item": {
        "type": "paragraph",
        "id": "eceab27ac16b8926",
        "text": "Figure 1: Simple variant of a Supervising Controller"
      },
      "date": 1640731940497
    },
    {
      "item": {
        "type": "factory",
        "id": "e81662cb023912ca"
      },
      "id": "e81662cb023912ca",
      "type": "add",
      "after": "eceab27ac16b8926",
      "date": 1640731945245
    },
    {
      "type": "edit",
      "id": "e81662cb023912ca",
      "item": {
        "type": "paragraph",
        "id": "e81662cb023912ca",
        "text": "For simple applications this might be completely sufficient and appropriate. By separating the behavioural complexity from the view it makes the application easier to understand and greatly improves its testability."
      },
      "date": 1640731959112
    },
    {
      "item": {
        "type": "factory",
        "id": "70c40fa34e2111fa"
      },
      "id": "70c40fa34e2111fa",
      "type": "add",
      "after": "e81662cb023912ca",
      "date": 1640731963765
    },
    {
      "type": "edit",
      "id": "70c40fa34e2111fa",
      "item": {
        "type": "paragraph",
        "id": "70c40fa34e2111fa",
        "text": "In applications that are more complex and contain multiple views, it is typically much more profitable to introduce some sort of model."
      },
      "date": 1640731971919
    },
    {
      "item": {
        "type": "factory",
        "id": "2ba085e68983f08d"
      },
      "id": "2ba085e68983f08d",
      "type": "add",
      "after": "70c40fa34e2111fa",
      "date": 1640731978515
    },
    {
      "type": "edit",
      "id": "2ba085e68983f08d",
      "item": {
        "type": "paragraph",
        "id": "2ba085e68983f08d",
        "text": "In one variant, the model can be completely passive, containing only state (properties) of the view to be shared with other views and their controllers. This eliminates the need of controllers exposing state of their views to other controllers. In many cases it may also eliminate the need of controllers knowing each other, removing coupling between them and therefore improving their testability. In"
      },
      "date": 1640731983318
    },
    {
      "type": "edit",
      "id": "2ba085e68983f08d",
      "item": {
        "type": "paragraph",
        "id": "2ba085e68983f08d",
        "text": "In one variant, the model can be completely passive, containing only state (properties) of the view to be shared with other views and their controllers. This eliminates the need of controllers exposing state of their views to other controllers. In many cases it may also eliminate the need of controllers knowing each other, removing coupling between them and therefore improving their testability. In such case the model is the only communication channel between different entities (see Fig. 2)."
      },
      "date": 1640731994716
    },
    {
      "item": {
        "type": "factory",
        "id": "e404154d87b261e7"
      },
      "id": "e404154d87b261e7",
      "type": "add",
      "after": "2ba085e68983f08d",
      "date": 1640732002782
    },
    {
      "type": "edit",
      "id": "e404154d87b261e7",
      "item": {
        "type": "paragraph",
        "id": "e404154d87b261e7",
        "text": "Figure 2: Example usage of a shared model"
      },
      "date": 1640732004177
    },
    {
      "item": {
        "type": "factory",
        "id": "f7fa8ca5efcd7677"
      },
      "id": "f7fa8ca5efcd7677",
      "type": "add",
      "after": "e404154d87b261e7",
      "date": 1640732029348
    },
    {
      "type": "edit",
      "id": "f7fa8ca5efcd7677",
      "item": {
        "type": "paragraph",
        "id": "f7fa8ca5efcd7677",
        "text": "Finally, if testability is the main driver and writing unit tests involving GUI components is either not desired or difficult, the model can completely take over business logic, becoming a realization of a Presentation Model [3] like on the Figure 3. The responsibility of the FXML controller is reduced to a role of a “thin” bridge between the view and the model, which handles all events and updates the view via property bindings."
      },
      "date": 1640732034212
    },
    {
      "item": {
        "type": "factory",
        "id": "bd2aab28ec3223e5"
      },
      "id": "bd2aab28ec3223e5",
      "type": "add",
      "after": "f7fa8ca5efcd7677",
      "date": 1640732045204
    },
    {
      "type": "edit",
      "id": "bd2aab28ec3223e5",
      "item": {
        "type": "paragraph",
        "id": "bd2aab28ec3223e5",
        "text": "Figure 3: An example of a Presentation Model"
      },
      "date": 1640732049741
    },
    {
      "item": {
        "type": "factory",
        "id": "05b6fbadb1de8aef"
      },
      "id": "05b6fbadb1de8aef",
      "type": "add",
      "after": "bd2aab28ec3223e5",
      "date": 1640732053711
    },
    {
      "type": "edit",
      "id": "05b6fbadb1de8aef",
      "item": {
        "type": "paragraph",
        "id": "05b6fbadb1de8aef",
        "text": "This approach requires a bit more coding compared to previous scenarios, giving in exchange fully testable business logic, not bound to any graphical components."
      },
      "date": 1640732055343
    },
    {
      "item": {
        "type": "factory",
        "id": "2b6839f7e8ee37d1"
      },
      "id": "2b6839f7e8ee37d1",
      "type": "add",
      "after": "05b6fbadb1de8aef",
      "date": 1640732178799
    },
    {
      "type": "edit",
      "id": "2b6839f7e8ee37d1",
      "item": {
        "type": "reference",
        "id": "2b6839f7e8ee37d1",
        "site": "wiki.ralfbarkow.ch",
        "slug": "model-view-presenter",
        "title": "Model-View-Presenter",
        "text": "I am evaluating [[Wiki Engines]] and [[Wiki Farms]] prior to choosing one for my own personal use and for various public uses.  To get additional input from experienced wiki users, and help others, I am putting the review on this wiki."
      },
      "date": 1640732183838
    },
    {
      "id": "2b6839f7e8ee37d1",
      "type": "move",
      "order": [
        "4114a707e955560f",
        "5bab9c703ab58b4c",
        "ee645192c4468105",
        "513dfbf36db9b517",
        "eceab27ac16b8926",
        "2b6839f7e8ee37d1",
        "e81662cb023912ca",
        "70c40fa34e2111fa",
        "2ba085e68983f08d",
        "e404154d87b261e7",
        "f7fa8ca5efcd7677",
        "bd2aab28ec3223e5",
        "05b6fbadb1de8aef"
      ],
      "date": 1640732187081
    },
    {
      "id": "2b6839f7e8ee37d1",
      "type": "move",
      "order": [
        "4114a707e955560f",
        "5bab9c703ab58b4c",
        "ee645192c4468105",
        "513dfbf36db9b517",
        "eceab27ac16b8926",
        "e81662cb023912ca",
        "70c40fa34e2111fa",
        "2ba085e68983f08d",
        "e404154d87b261e7",
        "f7fa8ca5efcd7677",
        "bd2aab28ec3223e5",
        "05b6fbadb1de8aef",
        "2b6839f7e8ee37d1"
      ],
      "date": 1640732194880
    },
    {
      "item": {
        "type": "factory",
        "id": "a13cdad71e998e07"
      },
      "id": "a13cdad71e998e07",
      "type": "add",
      "after": "2b6839f7e8ee37d1",
      "date": 1640732196020
    },
    {
      "type": "edit",
      "id": "a13cdad71e998e07",
      "item": {
        "type": "paragraph",
        "id": "a13cdad71e998e07",
        "text": "# See Also"
      },
      "date": 1640732204290
    },
    {
      "type": "edit",
      "id": "a13cdad71e998e07",
      "item": {
        "type": "markdown",
        "id": "a13cdad71e998e07",
        "text": "# See Also"
      },
      "date": 1640732205551
    },
    {
      "id": "2b6839f7e8ee37d1",
      "type": "move",
      "order": [
        "4114a707e955560f",
        "5bab9c703ab58b4c",
        "ee645192c4468105",
        "513dfbf36db9b517",
        "eceab27ac16b8926",
        "e81662cb023912ca",
        "70c40fa34e2111fa",
        "2ba085e68983f08d",
        "e404154d87b261e7",
        "f7fa8ca5efcd7677",
        "bd2aab28ec3223e5",
        "05b6fbadb1de8aef",
        "a13cdad71e998e07",
        "2b6839f7e8ee37d1"
      ],
      "date": 1640732208047
    },
    {
      "id": "c04116ca99ecfe88",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "c04116ca99ecfe88",
        "text": "**Supervising Controller**: The Presenter handles user gestures. The View binds to the Model directly through data binding. In this case, it's the Presenter's job to pass off the Model to the View so that it can bind to it. The Presenter will also contain logic for gestures like pressing a button, navigation, etc.\n\n* Pro: by leveraging data binding the amount of code is reduced.\n* Con: there's a less testable surface (because of data binding), and there's less encapsulation in the View since it talks directly to the Model.\n"
      },
      "after": "2b6839f7e8ee37d1",
      "date": 1640732231454
    },
    {
      "item": {
        "type": "factory",
        "id": "c2dcf206559dc26c"
      },
      "id": "c2dcf206559dc26c",
      "type": "add",
      "after": "c04116ca99ecfe88",
      "date": 1640732382788
    },
    {
      "type": "edit",
      "id": "c2dcf206559dc26c",
      "item": {
        "type": "reference",
        "id": "c2dcf206559dc26c",
        "site": "wiki.ralfbarkow.ch",
        "slug": "supervising-controller",
        "title": "Supervising Controller",
        "text": "The Presenter handles user gestures. The View binds to the Model directly through data binding. In this case, it's the Presenter's job to pass off the Model to the View so that it can bind to it. The Presenter will also contain logic for gestures like pressing a button, navigation, etc."
      },
      "date": 1640732385265
    },
    {
      "type": "remove",
      "id": "c04116ca99ecfe88",
      "date": 1640732390386
    },
    {
      "type": "edit",
      "id": "513dfbf36db9b517",
      "item": {
        "type": "paragraph",
        "id": "513dfbf36db9b517",
        "text": "In the simplest case it can play a role of a [[Supervising Controller]] [2] containing complete logic, initializing bindings between different components, handling input events, interacting with external services and updating the view (see Fig. 1). The application’s state is mostly kept in the view but the controller may also keep part of it when necessary."
      },
      "date": 1640732415337
    },
    {
      "type": "edit",
      "id": "4114a707e955560f",
      "item": {
        "type": "paragraph",
        "id": "4114a707e955560f",
        "text": "There are several design patterns that have been proposed over the years by the software community to address common concerns in UI development. Concepts such as [[Model-View-Controller]] (MVC), Model-View-Presenter (MVP), Presentation Model (PM) or Model-View-ViewModel (MVVM) have been discussed in numerous articles, blog posts and forums.\n"
      },
      "date": 1640732488905
    },
    {
      "type": "edit",
      "id": "4114a707e955560f",
      "item": {
        "type": "paragraph",
        "id": "4114a707e955560f",
        "text": "There are several design patterns that have been proposed over the years by the software community to address common concerns in UI development. Concepts such as [[Model-View-Controller]] (MVC), [[Model-View-Presenter]] (MVP), Presentation Model (PM) or Model-View-ViewModel (MVVM) have been discussed in numerous articles, blog posts and forums.\n"
      },
      "date": 1640732514388
    },
    {
      "type": "edit",
      "id": "513dfbf36db9b517",
      "item": {
        "type": "paragraph",
        "id": "513dfbf36db9b517",
        "text": "In the simplest case it can play a role of a [[Supervising Controller]] [https://martinfowler.com/eaaDev/SupervisingPresenter.html page] containing complete logic, initializing bindings between different components, handling input events, interacting with external services and updating the view (see Fig. 1). The application’s state is mostly kept in the view but the controller may also keep part of it when necessary."
      },
      "date": 1640732623552
    }
  ]
}