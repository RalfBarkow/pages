{
  "title": "Little Language",
  "story": [
    {
      "type": "html",
      "text": "One spin-off of the [[Unix Design Philosophy]] was the realization that it is easier to implement a task-specific language optimized for that task than it is to implement a general-purpose language optimized for all possible uses. The <b>Little Language</b> title was given by [[Jon Bentley]] in the Communications of the ACM [Jon Bentley, \"Little languages\", <i>Communications of the ACM</i>, 29(8):711-21, August 1986.].",
      "id": "64623b11d9bf0c3b5991e3e10c1167b4"
    },
    {
      "type": "html",
      "text": "\nWhat Bell Labs did was to make separate languages for the tasks they found, and optimized them for those tasks. These tasks include:",
      "id": "d5989daac764595b7aa5dabccf37dd22"
    },
    {
      "type": "html",
      "text": " Pattern matching (and thus [[Regular Expression]]s were born)",
      "id": "ccefe77de5c0bb12f5d3f19389597fc5"
    },
    {
      "type": "html",
      "text": " text line editing (ed/sed)",
      "id": "33a853ff5ef7003d9cd4ed281ad2b698"
    },
    {
      "type": "html",
      "text": " language grammar (lex/yacc)",
      "id": "153bf50b9e10233e24491a61bd67345d"
    },
    {
      "type": "html",
      "text": " Regex record data manipulation (AWK [[[Awk Language]]])",
      "id": "6705ee3c9df85608734606abd3fc4f84"
    },
    {
      "type": "html",
      "text": " shell services (sh)",
      "id": "a58d9a94620e16b247ef1bab0625ba5f"
    },
    {
      "type": "html",
      "text": " text formatting (troff/nroff); spawned multiple interacting little languages:",
      "id": "6e987d0748ecbd688a94fa12a536662e"
    },
    {
      "type": "html",
      "text": " picture drawing (pic, IDEAL)",
      "id": "16a3edb35cf4086f2a882935325ae498"
    },
    {
      "type": "html",
      "text": " graph drawing (grap, dot, [[Gnu Plot]])",
      "id": "bf9c39bef64d40116410645328bdea8e"
    },
    {
      "type": "html",
      "text": " typesetting mathematics (eqn)",
      "id": "78784a55ff3412c4bbf9a869b74d82a6"
    },
    {
      "type": "html",
      "text": " typesetting tables (tbl)",
      "id": "a4b204b0961dacb13f54f0e2da316ea1"
    },
    {
      "type": "html",
      "text": " CHEM (chemical structures)",
      "id": "3b82ff80412ef85eab2d0480c9301ce5"
    },
    {
      "type": "html",
      "text": " bib, refer (bibliographic notations)",
      "id": "5a89702e50cd0158b124e38c0e9703ba"
    },
    {
      "type": "html",
      "text": " dformat -- data structure/record format drawings",
      "id": "e7551acf9ff008749adbcd1eeb582a9b"
    },
    {
      "type": "html",
      "text": " ptx (create permuted KWIC (keyword in context) index)",
      "id": "f8ee0ab17ef9401769130b74d06ce40d"
    },
    {
      "type": "html",
      "text": " macro packages like mm, me, ms",
      "id": "77fb42a5206d76c7f0534cb4c746c73a"
    },
    {
      "type": "html",
      "text": " incremental rebuilds (make)",
      "id": "867800a681b90cc171fdc486f9fce947"
    },
    {
      "type": "html",
      "text": " preprocessing (cpp, m4)",
      "id": "f5530d15f85761133f3c52ff6bad5879"
    },
    {
      "type": "html",
      "text": " arithmetic (dc [[[Dee Cee]]], bc)",
      "id": "c267bdeacb6471b6fc1b1b804d54ef99"
    },
    {
      "type": "html",
      "text": " find (non-power users may not have noticed that it supports full boolean expressions over file attributes)",
      "id": "c5cb70fc90ce186cea7054d860e97e9d"
    },
    {
      "type": "html",
      "text": "\nAfter UNIX left Bell Labs, more other little languages got added to it, including:",
      "id": "8d67bdd2af51d26f0dbb0fe6572ff5ba"
    },
    {
      "type": "html",
      "text": " shell services (csh, ash, ksh, zsh, bash, tcsh, etc.)",
      "id": "2f78d24c0daf6c8e438de813b0e8ea51"
    },
    {
      "type": "html",
      "text": " file editing (vi) (vim and several other clones are now big)",
      "id": "b15676beb5d79f200d08df2221ec6e2e"
    },
    {
      "type": "html",
      "text": " sendmail CF configuration language ([[Turing Complete]], I think, but obfuscated)",
      "id": "1dbad92ff2da1b80178de38a8371738c"
    },
    {
      "type": "html",
      "text": "\nI know there are more. Could someone fill these in? Thanks.",
      "id": "86f85c20b9dde4a7b00b9ba5407d40d3"
    },
    {
      "type": "html",
      "text": "<b>Little Languages</b> have these characteristics:",
      "id": "f0ad2225098c38199dd362a519471888"
    },
    {
      "type": "html",
      "text": " may or may not be [[Turing Complete]] (see table below)",
      "id": "aabde9ae135c3c72867a8d268fca4cd4"
    },
    {
      "type": "html",
      "text": " very efficient to execute (for example, sed scripts don't need to be tokenized; they already are.) both in terms of speed and memory (most cases) in their intended scope.",
      "id": "7f95aea24f1f1b6c5e1d94bf83702c67"
    },
    {
      "type": "html",
      "text": " reasonably simple to express ([[Regular Expression]]s are simple enough to be concisely described on a single sheet 8 1/2\"x11\" paper, single spaced, 10 point font.)",
      "id": "3272b6da78c53576495f545e877af72a"
    },
    {
      "type": "html",
      "text": " very powerful, within their scope, frequently to the logical extreme of their scope.",
      "id": "7f9cba168ed6e8e3ce46d2a63f95b928"
    },
    {
      "type": "html",
      "text": " pathologically cryptic, requiring users to become experts before using them",
      "id": "618bf433d872d6f94befb3e3dda4998b"
    },
    {
      "type": "html",
      "text": " Some little languages are not designed with efficiency in mind at all. Instead, it's intended to save the developer time and effort by allowing her to express her intentions at a much higher level of abstraction. This allows the developer's programs to be much shorter than equivalent programs in other languages.",
      "id": "fba7056e185185cda6d8930c8ff4d7ff"
    },
    {
      "type": "html",
      "text": "\nThe \"little\" part primarily refers to the scope of what the language tackles.",
      "id": "dca7e170320de7447dbc4fbcbce2f4fa"
    },
    {
      "type": "html",
      "text": "(For example,\nTeX is purely focused on typesetting, so it qualifies as a little language no matter how big the implementation).",
      "id": "75c25d6d29f8a6c74fc38de0fc500a1f"
    },
    {
      "type": "html",
      "text": "<b>Little Languages</b> are related to:",
      "id": "984066aa3d977f53c6b0c69159446e41"
    },
    {
      "type": "html",
      "text": " [[Domain Specific Language]]s: a little language is a kind of domain specific language in a very narrow domain.",
      "id": "a010c4ad6ac5f3a2f23fed8267c8a113"
    },
    {
      "type": "html",
      "text": " [[Minimalist Language]], a language whose interpreter/compiler can be run on systems with very little RAM. Unfortunately, this typically requires user programs to be much longer than equivalent programs in other languages, as the user manually implements stuff the interpreter left out.",
      "id": "fab91d345aa54f960673df65486a9154"
    },
    {
      "type": "html",
      "text": " [[Low Keystroke Formal Languages]] ?",
      "id": "d576a0b2976ac242b4f7b05dcc8165e7"
    },
    {
      "type": "html",
      "text": "\nBelow is a long discussion about the [[Turing Complete]]ness of the languages above. Let's summarize here what we know about the [[Turing Complete]]ness of the above:",
      "id": "2a9b659e26abbf42151f4549883d4e4c"
    },
    {
      "type": "html",
      "text": " [[Regular Expression]]s: not TC, equivalent to [[Finite Automata]], but is TC if match and replace and also repeats are allowed",
      "id": "159a27e936d7b1a7367f4e11cff10c6d"
    },
    {
      "type": "html",
      "text": " ed/sed: TC (but data may be tricky to represent)",
      "id": "cc623fdf9118ade83f3523cb8a7aad2d"
    },
    {
      "type": "html",
      "text": " lex/yacc: not TC per se, equivalent to [[Push Down Automata]] ([[Context Free Grammars]])",
      "id": "5e831471ce7669ec8ce7c50dda5297cb"
    },
    {
      "type": "html",
      "text": " AWK: TC",
      "id": "866e962f1d6225b1466a4a6e699fff7c"
    },
    {
      "type": "html",
      "text": " vi/ex: TC",
      "id": "eb81a633461d3909d91842a9628b47da"
    },
    {
      "type": "html",
      "text": " sh: almost TC, only needs some way to manipulate data structures (dd is enough; dd/sh is even used to distribute CLC-INTERCAL)",
      "id": "61b48405474e7c1ab1f4795fcfd6e24c"
    },
    {
      "type": "html",
      "text": " troff/nroff: ?",
      "id": "e1042561dbd62f5773c04cfc655a9571"
    },
    {
      "type": "html",
      "text": " TeX: TC",
      "id": "016901031cf5c10c586c70cb61d15f5a"
    },
    {
      "type": "html",
      "text": " make: not TC, lacks means for representing data.  Needs a shell to do anything.",
      "id": "25cf420224cbc93025bdc3cf49162214"
    },
    {
      "type": "html",
      "text": " cpp: some implementations are TC (but loops have to be written by #include'ing the current file)",
      "id": "6d1ab7583c0497f0e71abccb344ac9ee"
    },
    {
      "type": "html",
      "text": " m4: TC",
      "id": "098a4117f0364d4d2a41317e897f6762"
    },
    {
      "type": "html",
      "text": " dc/bc: TC (but data may be tricky to represent)",
      "id": "c9abcdced6d4620a79a1e0f7489d85f1"
    },
    {
      "type": "html",
      "text": " IDEAL: not TC",
      "id": "2464fc046c5fa65d5d95974dea4778c7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "\nOther little languages:",
      "id": "262316dbfa9c82089ec2f0827e2bfc9b"
    },
    {
      "type": "html",
      "text": " \"dc is the oldest language on Unix; it was written on the PDP-7 and ported to the PDP-11 before Unix [itself] was ported.\" ([[Ken Thompson]])",
      "id": "e0704ffc5c234c6e5b2ccdfeeb60977c"
    },
    {
      "type": "html",
      "text": " Tcl \"[[Tool Command Language]]\" ( see \"little language\" -- [http://wiki.tcl.tk/3075 wiki.tcl.tk] )",
      "id": "484db27d6a6d77a059e2b69ebf950ab9"
    },
    {
      "type": "html",
      "text": " \"SQL used to be a little language\"",
      "id": "6c023fd6e61f090742f8c4222a569cf2"
    },
    {
      "type": "html",
      "text": " the Berkeley Packet Filter (BPF)",
      "id": "8dc567b14da121f255892d1c268126ed"
    },
    {
      "type": "html",
      "text": " control languages for the BPF, such as OpenBSD's pf ([http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&apropos=0&sektion=5&format=html www.openbsd.org])",
      "id": "cf05418e2f1323035cfbe057a0ee0996"
    },
    {
      "type": "html",
      "text": " Would Jakarta Struts application configuration (struts-config.xml) be considered a little language? <i>Only if you consider every XML DTD to be a little language.</i>",
      "id": "7a37e1a92ef564173717529f9488e361"
    },
    {
      "type": "html",
      "text": " [[Bit Scope]] [http://massmind.org/techref/language/meta-l/bitscope.htm massmind.org]",
      "id": "6c180edb640e67f434545c35476ee70b"
    },
    {
      "type": "html",
      "text": " [[Rebol Language]] ??? <i>REBOL isn't a little language itself, but it's designed for creating them. --Gregg Irwin</i>",
      "id": "e17d76c6c413565f3aa75c198b51b03f"
    },
    {
      "type": "html",
      "text": " LOGO ??? <i>Logo is a dialect of Lisp, but it's not a little language. The little language inside Logo is the one related to Turtle Graphics. --Gregg Irwin</i>",
      "id": "35058a3d470c383dc8ad443f61d6da7e"
    },
    {
      "type": "html",
      "text": " In general, [[Low Keystroke Formal Languages]] tend to be [[Little Languages]]",
      "id": "8d28bad45fbbdf52ac03d4240f55c987"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "\nSome <b>Little Languages</b> are [[Turing Complete]].\nFor example, I see no reason why somebody couldn't write a Universal [[Turing Machine]] interpreter in AWK to prove it. (If that sounds like too much work, you could simulate a URM machine - I would have thought the AWK associative arrays would be great for that.) how about a sed Universal [[Turing Machine]]? <[http://queen.rett.polimi.it/~paolob/seders/scripts/turing.sed queen.rett.polimi.it]> -- (That's down, try <i>[http://sed.sourceforge.net/local/scripts/turing.sed.html sed.sourceforge.net]</i>)",
      "id": "daccf8287901b808ca36f7aad3a2fc4c"
    },
    {
      "type": "html",
      "text": "\nHow about Lex/Yacc, TeX, and AWK?",
      "id": "a724b54a6ccb51bebdcedac7ae794006"
    },
    {
      "type": "html",
      "text": "\nA related sort of little language is the little language that isn't designed with efficiency in mind at all. Instead, it's intended to save the developer time and effort by allowing her to express her intentions at a much higher level of abstraction.",
      "id": "ea678ce9c98d07928150fd1f972b97cc"
    },
    {
      "type": "html",
      "text": "\nSQL used to be one of these, I think. Prolog and the various expert system shells also. The idea seems sadly quiescent these days; instead we're all standing around marvelling at bytecode, container libraries, and garbage collection as if these things somehow represented advances in the state of the art.",
      "id": "d1949c308382fdd330aa9d2dff33a91d"
    },
    {
      "type": "html",
      "text": "-- [[William Grosso]]",
      "id": "e9785c79b13ca60513eebdaed9bfff7e"
    },
    {
      "type": "html",
      "text": "\nLex/Yacc, sure. TeX? Maybe at one time. It no longer seems very little to me anymore. I guess it still could fit, due to ancestry, but I personally would never list it. AWK? probably, though it's also growing. Part of my argument against AWK would be that most things people do in perl could also be done in AWK, and I would certainly not call perl little. AWK is admittedly smaller, and it was originally little (the version on the AIX box at work is easily a <b>Little Language</b>. The version on my Linux box at home probably isn't.  <i>For the record: on my Linux box, sed is 35k, mawk is 88k, and gawk is 255k.</i>)",
      "id": "459b31c5bdca2a9c8b88ede7314978a2"
    },
    {
      "type": "html",
      "text": " The size of the implementation code is not the point, especially given the Moore's Law side effect that most programs keep growing larger over time, whether they need to or not. Someone might implement any of these things (bc, ed, lex, tic tac toe) in a hundred billion line C++ program that requires a petabyte of RAM sometime in the future, but that wouldn't necessarily mean that it's no longer a \"little language\" (although it would certainly make the term ironic, and one would have to wonder if bc really needed a real-time ray tracer etc to draw the numerals in a pretty way)",
      "id": "0104a79380e707218d510c16b15da7ba"
    },
    {
      "type": "html",
      "text": " The \"little\" part primarily refers to the scope of what the language tackles. TeX is purely focused on typesetting, so it qualifies as a little language no matter how big the implementation.",
      "id": "51c8df313f1dd2e639af3914d44dff51"
    },
    {
      "type": "html",
      "text": "\nFirst of all, the [[Turing Test]] refers to an AI problem rather than computability.",
      "id": "048b4b6ba179ff54cd665e3b6d937169"
    },
    {
      "type": "html",
      "text": "\n[[Turing Complete]] is framed in terms of mathematical operations on the integers {0,1,2,...} rather than in terms of machine words or whatever other data type you use in practice. (So long as your data types are finite, you could code them up as numbers and compute over them with functions.)",
      "id": "0eff340957e5390105c92c1c8f3f4d8d"
    },
    {
      "type": "html",
      "text": "\nThe fact that you can't write a device driver in AWK, or interface with a graphics system is irrelevant from the computability theory perspective. The argument would run like this:",
      "id": "992cec7a92cde95f27637c6176a6a25d"
    },
    {
      "type": "html",
      "text": " Allowing for finite-space limitations, the computational problems solved by the device driver or graphics system are effectively computable. 2. Unix and its device drivers and graphics systems are effectively computable - so it is possible to write a universal [[Turing Machine]] program which emulates the Unix system and its device drivers.(I said it is possible, not that it's fun!)",
      "id": "01ecc3aa17e59a3fbf2d119aa156b934"
    },
    {
      "type": "html",
      "text": " Write a universal [[Turing Machine]] simulator in AWK.",
      "id": "2c91251ec58ac356d63806dff9f22d47"
    },
    {
      "type": "html",
      "text": " Run the [[Turing Machine]] simulator in AWK, and load in the Unix emulator as data.",
      "id": "425e34fcea7f12ed870bfcbc4a48e8f0"
    },
    {
      "type": "html",
      "text": "\nYou end up having solved the graphics, operating systems and device driver computations solely using AWK. The fact that it's not practically feasible doesn't matter.",
      "id": "aef8fa7dc7124e7ea4682426b977c580"
    },
    {
      "type": "html",
      "text": "(An alternative strategy would be to produce a universal [[Turing Machine]] to AWK compiler rather than write the emulator.) <i>Then write a C compiler to target the UTM.</i>",
      "id": "fb7c90216a1bed9a82f76d1064b6de5c"
    },
    {
      "type": "html",
      "text": "\n[[Turing Complete]] is about being able to solve any effectively computable mathematical problem in a language - it's not about practical software architecture issues such as interfacing with device drivers. -- some guy",
      "id": "28a5161f5bf341ef3a793fec7546a694"
    },
    {
      "type": "html",
      "text": "\n[[Greg Mc Farlane]] wrote a set of macros to demonstrate that vi is [[Turing Complete]]; they're distributed as part of the standard vim distribution at [http://www.vim.org www.vim.org] . AWK should be no problem; egrep probably isn't [[Turing Complete]]; Sed neither. Csh?",
      "id": "75447efbf3e7335797850b496ae863ed"
    },
    {
      "type": "html",
      "text": "\nFirst, having been corrected on my misunderstanding of [[Turing Complete]], I believe I've corrected the introductory description.",
      "id": "22d3bb1f5282307eae989984877de505"
    },
    {
      "type": "html",
      "text": "\nI'd say shells in general have problems - basically, shells are big [[Escape Hatch]]es; most of the shell's abilities are to run other programs, and they have very limited abilities on their own.",
      "id": "332ee1ba20e5fe7ee4f2f28c6503a215"
    },
    {
      "type": "html",
      "text": "\nThat being said, I would propose that ksh, bash, and zsh are probably [[Turing Complete]], and Bourne Shell is definitely not [[Turing Complete]].",
      "id": "ee8e651519deaf957cfcb6e7989b77a3"
    },
    {
      "type": "html",
      "text": "<i>Why do you think Bourne Shell is not [[Turing Complete]]?</i>",
      "id": "2430dab030a41759074b3d70e01e6810"
    },
    {
      "type": "html",
      "text": "\nSed? Around 1992 or so, [[Kevin Braunsdorf]] told me about a 100-line sed script written to do arbitrary-precision integer mathematics. It wasn't pretty, it apparently got sed banned from all future obfuscated code contests, but it apparently worked. Beyond putting fear into me (I'm not sure if it was because someone could do that in sed, or that someone did do that in sed, that scared me more) it made me decide to not doubt sed's computational abilities.",
      "id": "b1f5b0275fd22f41656e4db392fdad6e"
    },
    {
      "type": "html",
      "text": "-- [[Ed Grimm]]",
      "id": "4b55ae85c1e889cd47a93995a751643d"
    },
    {
      "type": "html",
      "text": "\nHere's a C++ program you can't write in sed:",
      "id": "f9e76be6d8e50615bdc92c391ee3ed79"
    },
    {
      "type": "code",
      "text": "    #include <iostream>\n    main() {\n  for(;;) { cout << \"foo\" << endl; }\n  return 0;\n    }",
      "id": "08ff9aa7a587c912cba65e97e5019315"
    },
    {
      "type": "html",
      "text": "\nEr, yes it can:",
      "id": "4a4a28a8fa172beda4aa81a137db68f1"
    },
    {
      "type": "code",
      "text": "    :loop\n    s/.*/foo/p\n    b loop",
      "id": "47a273cb00e89cfd1a97d955651369ba"
    },
    {
      "type": "html",
      "text": "-- [[Jim Perry]]",
      "id": "76311f257f4953685186c2c688a2819c"
    },
    {
      "type": "html",
      "text": "\nI found a proof of sed's turing completeness: [http://robertkotcher.com/sed.html robertkotcher.com]",
      "id": "112ae21a3e1137552f35855f18556900"
    },
    {
      "type": "html",
      "text": "<i>Look it's even shorter in sed!</i> >:)",
      "id": "f2ed8f1fab59ff8bc7b4bf62b23ce8cb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "\nA Little Language is designed for a specific task, and not for throwing at any computational task that comes along. As such, it usually has no need to be [[Turing Complete]] - at least, that is what is expected. But along comes a task that lies just on the wrong side of the border of its abilities, and the temptation to extend it a little bit to handle the edge case can be irresistible. If such a [[Little Language]] ends up being [[Turing Complete]] then it's pretty much by accident, and the result is virtually guaranteed to be a particularly uncomfortable [[Turing Tarpit]].",
      "id": "93b0b039b8a695482c0389abf05c1bc9"
    },
    {
      "type": "html",
      "text": "\nIf a [[Little Language]] is designed from the outset to be [[Turing Complete]] then those borders don't exist and the pressure from that direction to extend the language is eliminated; it has a better chance of retaining what conceptual purity (coherent semantic model, robustness of implementation, etc.) it started out with, even if it is subsequently extended for other reasons. It may still be a [[Turing Tarpit]] in the general case, but if you're working anywhere in the vicinity of its bailiwick, at least you won't suddenly run into an impossibility or gotcha.",
      "id": "fe9e8fe7d05f97b302c2befcb4b02eab"
    },
    {
      "type": "html",
      "text": "\nFor an example of an \"accidentally TC\" [[Little Language]] I nominate sendmail; and for a deliberately TC [[Little Language]], [[Post Script]].",
      "id": "bc2bdb9e05a50f84d98a1eb8ac8ac2c5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "\nIt bothered me that a page on <b>Little Languages</b> should not contain a reference to [[Jon Bentley]] or [[Programming Pearls]], so here they are. (Actually, Bentley's column on <b>Little Languages</b> appeared in the second collection, [[More Programming Pearls]].)",
      "id": "a7bf407c0e86df144c1c9513aa30f7b4"
    },
    {
      "type": "html",
      "text": "\nAlso, I have the feeling that the idea of [[Language As Interface]] is relevant (or that, if it isn't, it ought to be).",
      "id": "8dbae50e77ba44c0f6d4300ef493c118"
    },
    {
      "type": "html",
      "text": "-- [[Cameron Smith]]",
      "id": "f2c6e010af298cf9173062d0cf130cc3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "\"sed scripts don't need to be tokenized; they already are\"",
      "id": "5abe53bd4245dd39a7d28ee09f6b1d6e"
    },
    {
      "type": "html",
      "text": "I've often read this but never known what it means. Would someone explain? -- [[Anonymous Donor]]",
      "id": "890ad046aef4c2cbf417c2992077bcd5"
    },
    {
      "type": "html",
      "text": "\nAll sed commands are one byte long, not including arguments. -- [[Ed Grimm]]",
      "id": "7f417df2d1f68820ec73dcc7b8b94e21"
    },
    {
      "type": "html",
      "text": "\nMore languages than just sed have this property or a similar one. The qmail security guarantee talks about using this (and null-terminated lines) under the subject of parsing. dc is similar; there are only one and two character commands, some of which have a mandatory one character argument, and no two-character command overshadows a one character command except !.",
      "id": "4b8d4dbfc717f466c4c512b8385f0be4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "\nIf a little language is [[Turing Complete]], many properties of program written in that language become undecidable: Such languages suffer from the [[Halting Problem]].",
      "id": "fd79b8d0234808cac642900403543444"
    },
    {
      "type": "html",
      "text": "\nSQL is another well known little language that has no way to express loops nor recursion, and which is not [[Turing Complete]].",
      "id": "12bdd779fa5bbb7920331eab09867b48"
    },
    {
      "type": "html",
      "text": "<i>But queries are a form of implicit looping over all records...</i>",
      "id": "98f9d62fe8b1aaae753961d4ac7526f8"
    },
    {
      "type": "html",
      "text": "<i>In fact,</i> I have written a SQL statement that did run forever reading a table with one row. - Joshua",
      "id": "c8cc9cca86a4966702462a42cbba2bce"
    },
    {
      "type": "html",
      "text": "<i>Yes, there is queries looping over records (you can even make it access multiple tables and do a bunch of other stuff), and you can make it to do things with it by creating a trigger and then inserting into a read-only view that has that trigger attached. They can even be made recursive. You can even do conditionals (with a WHERE clause), and a lot of other stuff. Numeric loops are missing, although a virtual table provides that, so you can use that.</i>",
      "id": "43e9129c7e32ccf6d795eff031820715"
    },
    {
      "type": "html",
      "text": "\nKeeping a little language declarative does have some advantages such as making it possible to use the scripts for multiple purposes (code generation, sanity checks, documentation, ...)",
      "id": "f62ac0e5239d057d60114e821c74fb10"
    },
    {
      "type": "html",
      "text": "\nFor those interested - see a paper I wrote in 1997 titled Little Languages: Little Maintenance? (it's on my homepage), which also discusses whether a little language should be [[Turing Complete]]. -- [[Arie Van Deursen]]",
      "id": "08d8a1dc1a973cf90fb3b8f602d7c8a3"
    },
    {
      "type": "html",
      "text": "\nAlso, the Berkeley Packet Filter (BPF), can be considered as a \"little language\". It is also decidedly turing-incomplete.",
      "id": "a8c0acdeaca7cc855c398d9b0b1f7746"
    },
    {
      "type": "html",
      "text": "\nThe basic [[Rebol Language]] book describes it as a [[Minimalist Language]]. Implementations have a very small footprint. Is it appropriate to think of <b>Little Language</b> as a logical categorization of a language while [[Minimalist Language]] emphasizes the physical size of the implementation? -- [[David Ness]]",
      "id": "a46d2596db9cd2125ab0c2c18ae55c19"
    },
    {
      "type": "html",
      "text": "\n[[Olin Shivers]] has a nice take on little languages at: [http://www.cc.gatech.edu/fac/Olin.Shivers/citations.html#ll www.cc.gatech.edu]. He argues, that instead of little languages, we should use a single extensible language plus a lot of libraries. Why redesign things like variables and functions over and over? <i>Wasn't that the idea behind [[Tool Command Language]]?</i>",
      "id": "256d84a785f2136df104fdb3e51d3454"
    },
    {
      "type": "html",
      "text": "\n[[Regular Expression]]s are also [[Turing Complete]], if they get applied in turn until none of them matches. Actually, plain text substitutions suffice - they are an instance of [[Semi Thue Grammars]]. -- [[Panu Kalliokoski]]",
      "id": "1e449342a5d2fe6de56fac9bed2226dd"
    },
    {
      "type": "html",
      "text": "<i>No...as phrased this isn't right. Plain old regular expressions, as you know, are not TC. Applying them in turn doesn't help, that's just (RE)*, another RE, and strictly speaking, it doesn't even matter if they're NDFA or DFA. What you must have meant to say is that regular expression match <b>and replace</b> is equivalent to a [[Semi Thue Grammar]], since then you can have arbitrary RHS and LHS on each grammar rule. -- [[Doug Merritt]]</i>",
      "id": "c8200581daebb1097bcf3aca34f28f58"
    },
    {
      "type": "html",
      "text": "\nBy which point regular expressions have become overkill, since search-and-replace on plain substrings is sufficient to implement a Semi-Thue grammar.",
      "id": "fd7829d868e661cca115c32a3512f074"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "So why are [[Little Language]]s seen to be a good idea but [[Fourth Generation Language]]s seen to be a bad idea?  The 4GLs I have used seemed to be collections of related [[Little Language]]s.",
      "id": "b7e2cfde06733f425fb76812dc33a772"
    },
    {
      "type": "html",
      "text": "<i>4GL began as a technical term but was emptied of all meaning by marketroids back in the 1980s, so it currently tends to be considered to be marketing fluff unless proven otherwise. Nor is there a \"fifth generation language\" by which to contrast, despite the passage of time. Terminology trends change. \"fourth generation\" and \"generation\" in general used to be commonly applied to many things, not just languages, and now they are (mostly) not. The last usage I personally saw was Bentley calling awk a 4GL, and meaning that in a positive sense (which he described in detail).</i>",
      "id": "fa2f0979931a73559e42fa430698f594"
    },
    {
      "type": "html",
      "text": "\nWasn't Prolog given the fifth generation tag by Japanese marketroids?  - [[Scott Elliott]]",
      "id": "177151ef14220a6e4969c42df989193b"
    },
    {
      "type": "html",
      "text": "<i>I forgot about that one. But I meant used <b>meaningfully</b>; the Japanese 5th generation label was empty in general, and there was no reason to apply that label to Prolog (except that it was the official language of their 5th Gen. project). \"Fourth Generation\" was once in a while used in a non-empty way.</i>",
      "id": "0253ea63e9dcd858622b597cf7bc5c83"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "\nOne interesting thing about little languages is that they must interface to the world. When they do, it will usually display some awkwardness. Otherwise little languages are really nice.",
      "id": "5984f85ef5da136d2a62d08c1a5a5945"
    },
    {
      "type": "html",
      "text": "\nTake a rather libre view of the classification of little languages, C is good at managing the memory, but some part of the world is better interfaced using OO, there comes the awkwardness of writing GUI applications in C.",
      "id": "ab5a1acd4b2786ff2c003496aaf5cd0e"
    },
    {
      "type": "html",
      "text": "\nAwk and sed are good at parsing flat files. When you want to parse EBNF using awk and sed, you would hate yourself. Yacc is for that.",
      "id": "da1f882c05de6fa55f4528961e6f1923"
    },
    {
      "type": "html",
      "text": "<i>A few more examples would be good.</i>",
      "id": "f7987f27685fe421f3df02c780f23fb3"
    },
    {
      "type": "html",
      "text": "\nWhen we talked about little languages, there must be mentioned that a good method for these little languages to interface with to the world is just equally important. In UNIX, that is the pipe. With pipe, the little languages can stay little.",
      "id": "41ea93fac22cb6e748a0384429d749b7"
    },
    {
      "type": "html",
      "text": "\nThe pipe is not perfect though, for it is unable to prevent people from inventing Perl. Or we could say that awk and sed is of no use to yacc and lex. When we want to parsing EBNF with another little language, the pipe can't let us utilize the other previously existing little languages. When we want to use a functional style to parse the EBNF instead of the C used in yacc, again we can not effectively utilize the yacc and lex but have to be forcef to implement our own yet another yacc in our own favorite functional language, ie. haskell etc.. The pipe cannot help us on that.",
      "id": "b2fe51dcdd55046d334b7d537124bafd"
    },
    {
      "type": "html",
      "text": "-- [[Zhao Way]]",
      "id": "7a76181b6101840d10e74fad8c15f708"
    },
    {
      "type": "html",
      "text": "\nFor a description of a possible class of [[Little Language]]s in the [[Flow Based Programming]] context, see [http://www.jpaulmorrison.com/fbp/bdl.htm www.jpaulmorrison.com].  [[Flow Based Programming]] supports a network of \"pipes\", and so should be a great environment for hooking together different (types of) [[Little Language]]s. -- [[Paul Morrison]]",
      "id": "247b222261c2a9151096f9bd2477b7ab"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "Does [[Furry Script]] count? It is domain specific, and I think for mostly a narrow domain; it can be used with other stuff but not very well. What about, [[Dada Engine]] and rmutt, which have some similar purposes (even though none of them was based on the other)?",
      "id": "a41cd1fd1ad7589440013f755e27b5e6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "Is [[Music Macro Language]] (MML) a [[Little Language]]?",
      "id": "9abbf7144de215715bf7f69aa81ed557"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "See Minilanguages:\nFinding a Notation That Sings\n[http://www.faqs.org/docs/artu/minilanguageschapter.html www.faqs.org]",
      "id": "72e419455f8976d5e0a0ca165170a6b2"
    },
    {
      "type": "html",
      "text": "\nSee also [[Domain Specific Language]]s, [[Minimal Parsing]], [[Helpers Instead Of Wrappers]]",
      "id": "5ab6b2a104e3911c87d5773ff7a81eca"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b96f4a3626c74af13afb71b77564e4ec"
    },
    {
      "type": "html",
      "text": "[[Category Language]]",
      "id": "dc4b716aae48bec470edc0d67c14e795"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?LittleLanguage c2.com]",
      "id": "42ec4c5c23f56acc9242cc74be5c7e59"
    }
  ],
  "journal": [
    {
      "date": 1411942118000,
      "id": "953bf7e1ab30736314abdf843043383f",
      "type": "create",
      "item": {
        "title": "Little Language",
        "story": [
          {
            "type": "html",
            "text": "One spin-off of the [[Unix Design Philosophy]] was the realization that it is easier to implement a task-specific language optimized for that task than it is to implement a general-purpose language optimized for all possible uses. The <b>Little Language</b> title was given by [[Jon Bentley]] in the Communications of the ACM [Jon Bentley, \"Little languages\", <i>Communications of the ACM</i>, 29(8):711-21, August 1986.].",
            "id": "64623b11d9bf0c3b5991e3e10c1167b4"
          },
          {
            "type": "html",
            "text": "\nWhat Bell Labs did was to make separate languages for the tasks they found, and optimized them for those tasks. These tasks include:",
            "id": "d5989daac764595b7aa5dabccf37dd22"
          },
          {
            "type": "html",
            "text": " Pattern matching (and thus [[Regular Expression]]s were born)",
            "id": "ccefe77de5c0bb12f5d3f19389597fc5"
          },
          {
            "type": "html",
            "text": " text line editing (ed/sed)",
            "id": "33a853ff5ef7003d9cd4ed281ad2b698"
          },
          {
            "type": "html",
            "text": " language grammar (lex/yacc)",
            "id": "153bf50b9e10233e24491a61bd67345d"
          },
          {
            "type": "html",
            "text": " Regex record data manipulation (AWK [[[Awk Language]]])",
            "id": "6705ee3c9df85608734606abd3fc4f84"
          },
          {
            "type": "html",
            "text": " shell services (sh)",
            "id": "a58d9a94620e16b247ef1bab0625ba5f"
          },
          {
            "type": "html",
            "text": " text formatting (troff/nroff); spawned multiple interacting little languages:",
            "id": "6e987d0748ecbd688a94fa12a536662e"
          },
          {
            "type": "html",
            "text": " picture drawing (pic, IDEAL)",
            "id": "16a3edb35cf4086f2a882935325ae498"
          },
          {
            "type": "html",
            "text": " graph drawing (grap, dot, [[Gnu Plot]])",
            "id": "bf9c39bef64d40116410645328bdea8e"
          },
          {
            "type": "html",
            "text": " typesetting mathematics (eqn)",
            "id": "78784a55ff3412c4bbf9a869b74d82a6"
          },
          {
            "type": "html",
            "text": " typesetting tables (tbl)",
            "id": "a4b204b0961dacb13f54f0e2da316ea1"
          },
          {
            "type": "html",
            "text": " CHEM (chemical structures)",
            "id": "3b82ff80412ef85eab2d0480c9301ce5"
          },
          {
            "type": "html",
            "text": " bib, refer (bibliographic notations)",
            "id": "5a89702e50cd0158b124e38c0e9703ba"
          },
          {
            "type": "html",
            "text": " dformat -- data structure/record format drawings",
            "id": "e7551acf9ff008749adbcd1eeb582a9b"
          },
          {
            "type": "html",
            "text": " ptx (create permuted KWIC (keyword in context) index)",
            "id": "f8ee0ab17ef9401769130b74d06ce40d"
          },
          {
            "type": "html",
            "text": " macro packages like mm, me, ms",
            "id": "77fb42a5206d76c7f0534cb4c746c73a"
          },
          {
            "type": "html",
            "text": " incremental rebuilds (make)",
            "id": "867800a681b90cc171fdc486f9fce947"
          },
          {
            "type": "html",
            "text": " preprocessing (cpp, m4)",
            "id": "f5530d15f85761133f3c52ff6bad5879"
          },
          {
            "type": "html",
            "text": " arithmetic (dc [[[Dee Cee]]], bc)",
            "id": "c267bdeacb6471b6fc1b1b804d54ef99"
          },
          {
            "type": "html",
            "text": " find (non-power users may not have noticed that it supports full boolean expressions over file attributes)",
            "id": "c5cb70fc90ce186cea7054d860e97e9d"
          },
          {
            "type": "html",
            "text": "\nAfter UNIX left Bell Labs, more other little languages got added to it, including:",
            "id": "8d67bdd2af51d26f0dbb0fe6572ff5ba"
          },
          {
            "type": "html",
            "text": " shell services (csh, ash, ksh, zsh, bash, tcsh, etc.)",
            "id": "2f78d24c0daf6c8e438de813b0e8ea51"
          },
          {
            "type": "html",
            "text": " file editing (vi) (vim and several other clones are now big)",
            "id": "b15676beb5d79f200d08df2221ec6e2e"
          },
          {
            "type": "html",
            "text": " sendmail CF configuration language ([[Turing Complete]], I think, but obfuscated)",
            "id": "1dbad92ff2da1b80178de38a8371738c"
          },
          {
            "type": "html",
            "text": "\nI know there are more. Could someone fill these in? Thanks.",
            "id": "86f85c20b9dde4a7b00b9ba5407d40d3"
          },
          {
            "type": "html",
            "text": "<b>Little Languages</b> have these characteristics:",
            "id": "f0ad2225098c38199dd362a519471888"
          },
          {
            "type": "html",
            "text": " may or may not be [[Turing Complete]] (see table below)",
            "id": "aabde9ae135c3c72867a8d268fca4cd4"
          },
          {
            "type": "html",
            "text": " very efficient to execute (for example, sed scripts don't need to be tokenized; they already are.) both in terms of speed and memory (most cases) in their intended scope.",
            "id": "7f95aea24f1f1b6c5e1d94bf83702c67"
          },
          {
            "type": "html",
            "text": " reasonably simple to express ([[Regular Expression]]s are simple enough to be concisely described on a single sheet 8 1/2\"x11\" paper, single spaced, 10 point font.)",
            "id": "3272b6da78c53576495f545e877af72a"
          },
          {
            "type": "html",
            "text": " very powerful, within their scope, frequently to the logical extreme of their scope.",
            "id": "7f9cba168ed6e8e3ce46d2a63f95b928"
          },
          {
            "type": "html",
            "text": " pathologically cryptic, requiring users to become experts before using them",
            "id": "618bf433d872d6f94befb3e3dda4998b"
          },
          {
            "type": "html",
            "text": " Some little languages are not designed with efficiency in mind at all. Instead, it's intended to save the developer time and effort by allowing her to express her intentions at a much higher level of abstraction. This allows the developer's programs to be much shorter than equivalent programs in other languages.",
            "id": "fba7056e185185cda6d8930c8ff4d7ff"
          },
          {
            "type": "html",
            "text": "\nThe \"little\" part primarily refers to the scope of what the language tackles.",
            "id": "dca7e170320de7447dbc4fbcbce2f4fa"
          },
          {
            "type": "html",
            "text": "(For example,\nTeX is purely focused on typesetting, so it qualifies as a little language no matter how big the implementation).",
            "id": "75c25d6d29f8a6c74fc38de0fc500a1f"
          },
          {
            "type": "html",
            "text": "<b>Little Languages</b> are related to:",
            "id": "984066aa3d977f53c6b0c69159446e41"
          },
          {
            "type": "html",
            "text": " [[Domain Specific Language]]s: a little language is a kind of domain specific language in a very narrow domain.",
            "id": "a010c4ad6ac5f3a2f23fed8267c8a113"
          },
          {
            "type": "html",
            "text": " [[Minimalist Language]], a language whose interpreter/compiler can be run on systems with very little RAM. Unfortunately, this typically requires user programs to be much longer than equivalent programs in other languages, as the user manually implements stuff the interpreter left out.",
            "id": "fab91d345aa54f960673df65486a9154"
          },
          {
            "type": "html",
            "text": " [[Low Keystroke Formal Languages]] ?",
            "id": "d576a0b2976ac242b4f7b05dcc8165e7"
          },
          {
            "type": "html",
            "text": "\nBelow is a long discussion about the [[Turing Complete]]ness of the languages above. Let's summarize here what we know about the [[Turing Complete]]ness of the above:",
            "id": "2a9b659e26abbf42151f4549883d4e4c"
          },
          {
            "type": "html",
            "text": " [[Regular Expression]]s: not TC, equivalent to [[Finite Automata]], but is TC if match and replace and also repeats are allowed",
            "id": "159a27e936d7b1a7367f4e11cff10c6d"
          },
          {
            "type": "html",
            "text": " ed/sed: TC (but data may be tricky to represent)",
            "id": "cc623fdf9118ade83f3523cb8a7aad2d"
          },
          {
            "type": "html",
            "text": " lex/yacc: not TC per se, equivalent to [[Push Down Automata]] ([[Context Free Grammars]])",
            "id": "5e831471ce7669ec8ce7c50dda5297cb"
          },
          {
            "type": "html",
            "text": " AWK: TC",
            "id": "866e962f1d6225b1466a4a6e699fff7c"
          },
          {
            "type": "html",
            "text": " vi/ex: TC",
            "id": "eb81a633461d3909d91842a9628b47da"
          },
          {
            "type": "html",
            "text": " sh: almost TC, only needs some way to manipulate data structures (dd is enough; dd/sh is even used to distribute CLC-INTERCAL)",
            "id": "61b48405474e7c1ab1f4795fcfd6e24c"
          },
          {
            "type": "html",
            "text": " troff/nroff: ?",
            "id": "e1042561dbd62f5773c04cfc655a9571"
          },
          {
            "type": "html",
            "text": " TeX: TC",
            "id": "016901031cf5c10c586c70cb61d15f5a"
          },
          {
            "type": "html",
            "text": " make: not TC, lacks means for representing data.  Needs a shell to do anything.",
            "id": "25cf420224cbc93025bdc3cf49162214"
          },
          {
            "type": "html",
            "text": " cpp: some implementations are TC (but loops have to be written by #include'ing the current file)",
            "id": "6d1ab7583c0497f0e71abccb344ac9ee"
          },
          {
            "type": "html",
            "text": " m4: TC",
            "id": "098a4117f0364d4d2a41317e897f6762"
          },
          {
            "type": "html",
            "text": " dc/bc: TC (but data may be tricky to represent)",
            "id": "c9abcdced6d4620a79a1e0f7489d85f1"
          },
          {
            "type": "html",
            "text": " IDEAL: not TC",
            "id": "2464fc046c5fa65d5d95974dea4778c7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "\nOther little languages:",
            "id": "262316dbfa9c82089ec2f0827e2bfc9b"
          },
          {
            "type": "html",
            "text": " \"dc is the oldest language on Unix; it was written on the PDP-7 and ported to the PDP-11 before Unix [itself] was ported.\" ([[Ken Thompson]])",
            "id": "e0704ffc5c234c6e5b2ccdfeeb60977c"
          },
          {
            "type": "html",
            "text": " Tcl \"[[Tool Command Language]]\" ( see \"little language\" -- [http://wiki.tcl.tk/3075 wiki.tcl.tk] )",
            "id": "484db27d6a6d77a059e2b69ebf950ab9"
          },
          {
            "type": "html",
            "text": " \"SQL used to be a little language\"",
            "id": "6c023fd6e61f090742f8c4222a569cf2"
          },
          {
            "type": "html",
            "text": " the Berkeley Packet Filter (BPF)",
            "id": "8dc567b14da121f255892d1c268126ed"
          },
          {
            "type": "html",
            "text": " control languages for the BPF, such as OpenBSD's pf ([http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&apropos=0&sektion=5&format=html www.openbsd.org])",
            "id": "cf05418e2f1323035cfbe057a0ee0996"
          },
          {
            "type": "html",
            "text": " Would Jakarta Struts application configuration (struts-config.xml) be considered a little language? <i>Only if you consider every XML DTD to be a little language.</i>",
            "id": "7a37e1a92ef564173717529f9488e361"
          },
          {
            "type": "html",
            "text": " [[Bit Scope]] [http://massmind.org/techref/language/meta-l/bitscope.htm massmind.org]",
            "id": "6c180edb640e67f434545c35476ee70b"
          },
          {
            "type": "html",
            "text": " [[Rebol Language]] ??? <i>REBOL isn't a little language itself, but it's designed for creating them. --Gregg Irwin</i>",
            "id": "e17d76c6c413565f3aa75c198b51b03f"
          },
          {
            "type": "html",
            "text": " LOGO ??? <i>Logo is a dialect of Lisp, but it's not a little language. The little language inside Logo is the one related to Turtle Graphics. --Gregg Irwin</i>",
            "id": "35058a3d470c383dc8ad443f61d6da7e"
          },
          {
            "type": "html",
            "text": " In general, [[Low Keystroke Formal Languages]] tend to be [[Little Languages]]",
            "id": "8d28bad45fbbdf52ac03d4240f55c987"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "\nSome <b>Little Languages</b> are [[Turing Complete]].\nFor example, I see no reason why somebody couldn't write a Universal [[Turing Machine]] interpreter in AWK to prove it. (If that sounds like too much work, you could simulate a URM machine - I would have thought the AWK associative arrays would be great for that.) how about a sed Universal [[Turing Machine]]? <[http://queen.rett.polimi.it/~paolob/seders/scripts/turing.sed queen.rett.polimi.it]> -- (That's down, try <i>[http://sed.sourceforge.net/local/scripts/turing.sed.html sed.sourceforge.net]</i>)",
            "id": "daccf8287901b808ca36f7aad3a2fc4c"
          },
          {
            "type": "html",
            "text": "\nHow about Lex/Yacc, TeX, and AWK?",
            "id": "a724b54a6ccb51bebdcedac7ae794006"
          },
          {
            "type": "html",
            "text": "\nA related sort of little language is the little language that isn't designed with efficiency in mind at all. Instead, it's intended to save the developer time and effort by allowing her to express her intentions at a much higher level of abstraction.",
            "id": "ea678ce9c98d07928150fd1f972b97cc"
          },
          {
            "type": "html",
            "text": "\nSQL used to be one of these, I think. Prolog and the various expert system shells also. The idea seems sadly quiescent these days; instead we're all standing around marvelling at bytecode, container libraries, and garbage collection as if these things somehow represented advances in the state of the art.",
            "id": "d1949c308382fdd330aa9d2dff33a91d"
          },
          {
            "type": "html",
            "text": "-- [[William Grosso]]",
            "id": "e9785c79b13ca60513eebdaed9bfff7e"
          },
          {
            "type": "html",
            "text": "\nLex/Yacc, sure. TeX? Maybe at one time. It no longer seems very little to me anymore. I guess it still could fit, due to ancestry, but I personally would never list it. AWK? probably, though it's also growing. Part of my argument against AWK would be that most things people do in perl could also be done in AWK, and I would certainly not call perl little. AWK is admittedly smaller, and it was originally little (the version on the AIX box at work is easily a <b>Little Language</b>. The version on my Linux box at home probably isn't.  <i>For the record: on my Linux box, sed is 35k, mawk is 88k, and gawk is 255k.</i>)",
            "id": "459b31c5bdca2a9c8b88ede7314978a2"
          },
          {
            "type": "html",
            "text": " The size of the implementation code is not the point, especially given the Moore's Law side effect that most programs keep growing larger over time, whether they need to or not. Someone might implement any of these things (bc, ed, lex, tic tac toe) in a hundred billion line C++ program that requires a petabyte of RAM sometime in the future, but that wouldn't necessarily mean that it's no longer a \"little language\" (although it would certainly make the term ironic, and one would have to wonder if bc really needed a real-time ray tracer etc to draw the numerals in a pretty way)",
            "id": "0104a79380e707218d510c16b15da7ba"
          },
          {
            "type": "html",
            "text": " The \"little\" part primarily refers to the scope of what the language tackles. TeX is purely focused on typesetting, so it qualifies as a little language no matter how big the implementation.",
            "id": "51c8df313f1dd2e639af3914d44dff51"
          },
          {
            "type": "html",
            "text": "\nFirst of all, the [[Turing Test]] refers to an AI problem rather than computability.",
            "id": "048b4b6ba179ff54cd665e3b6d937169"
          },
          {
            "type": "html",
            "text": "\n[[Turing Complete]] is framed in terms of mathematical operations on the integers {0,1,2,...} rather than in terms of machine words or whatever other data type you use in practice. (So long as your data types are finite, you could code them up as numbers and compute over them with functions.)",
            "id": "0eff340957e5390105c92c1c8f3f4d8d"
          },
          {
            "type": "html",
            "text": "\nThe fact that you can't write a device driver in AWK, or interface with a graphics system is irrelevant from the computability theory perspective. The argument would run like this:",
            "id": "992cec7a92cde95f27637c6176a6a25d"
          },
          {
            "type": "html",
            "text": " Allowing for finite-space limitations, the computational problems solved by the device driver or graphics system are effectively computable. 2. Unix and its device drivers and graphics systems are effectively computable - so it is possible to write a universal [[Turing Machine]] program which emulates the Unix system and its device drivers.(I said it is possible, not that it's fun!)",
            "id": "01ecc3aa17e59a3fbf2d119aa156b934"
          },
          {
            "type": "html",
            "text": " Write a universal [[Turing Machine]] simulator in AWK.",
            "id": "2c91251ec58ac356d63806dff9f22d47"
          },
          {
            "type": "html",
            "text": " Run the [[Turing Machine]] simulator in AWK, and load in the Unix emulator as data.",
            "id": "425e34fcea7f12ed870bfcbc4a48e8f0"
          },
          {
            "type": "html",
            "text": "\nYou end up having solved the graphics, operating systems and device driver computations solely using AWK. The fact that it's not practically feasible doesn't matter.",
            "id": "aef8fa7dc7124e7ea4682426b977c580"
          },
          {
            "type": "html",
            "text": "(An alternative strategy would be to produce a universal [[Turing Machine]] to AWK compiler rather than write the emulator.) <i>Then write a C compiler to target the UTM.</i>",
            "id": "fb7c90216a1bed9a82f76d1064b6de5c"
          },
          {
            "type": "html",
            "text": "\n[[Turing Complete]] is about being able to solve any effectively computable mathematical problem in a language - it's not about practical software architecture issues such as interfacing with device drivers. -- some guy",
            "id": "28a5161f5bf341ef3a793fec7546a694"
          },
          {
            "type": "html",
            "text": "\n[[Greg Mc Farlane]] wrote a set of macros to demonstrate that vi is [[Turing Complete]]; they're distributed as part of the standard vim distribution at [http://www.vim.org www.vim.org] . AWK should be no problem; egrep probably isn't [[Turing Complete]]; Sed neither. Csh?",
            "id": "75447efbf3e7335797850b496ae863ed"
          },
          {
            "type": "html",
            "text": "\nFirst, having been corrected on my misunderstanding of [[Turing Complete]], I believe I've corrected the introductory description.",
            "id": "22d3bb1f5282307eae989984877de505"
          },
          {
            "type": "html",
            "text": "\nI'd say shells in general have problems - basically, shells are big [[Escape Hatch]]es; most of the shell's abilities are to run other programs, and they have very limited abilities on their own.",
            "id": "332ee1ba20e5fe7ee4f2f28c6503a215"
          },
          {
            "type": "html",
            "text": "\nThat being said, I would propose that ksh, bash, and zsh are probably [[Turing Complete]], and Bourne Shell is definitely not [[Turing Complete]].",
            "id": "ee8e651519deaf957cfcb6e7989b77a3"
          },
          {
            "type": "html",
            "text": "<i>Why do you think Bourne Shell is not [[Turing Complete]]?</i>",
            "id": "2430dab030a41759074b3d70e01e6810"
          },
          {
            "type": "html",
            "text": "\nSed? Around 1992 or so, [[Kevin Braunsdorf]] told me about a 100-line sed script written to do arbitrary-precision integer mathematics. It wasn't pretty, it apparently got sed banned from all future obfuscated code contests, but it apparently worked. Beyond putting fear into me (I'm not sure if it was because someone could do that in sed, or that someone did do that in sed, that scared me more) it made me decide to not doubt sed's computational abilities.",
            "id": "b1f5b0275fd22f41656e4db392fdad6e"
          },
          {
            "type": "html",
            "text": "-- [[Ed Grimm]]",
            "id": "4b55ae85c1e889cd47a93995a751643d"
          },
          {
            "type": "html",
            "text": "\nHere's a C++ program you can't write in sed:",
            "id": "f9e76be6d8e50615bdc92c391ee3ed79"
          },
          {
            "type": "code",
            "text": "    #include <iostream>\n    main() {\n  for(;;) { cout << \"foo\" << endl; }\n  return 0;\n    }",
            "id": "08ff9aa7a587c912cba65e97e5019315"
          },
          {
            "type": "html",
            "text": "\nEr, yes it can:",
            "id": "4a4a28a8fa172beda4aa81a137db68f1"
          },
          {
            "type": "code",
            "text": "    :loop\n    s/.*/foo/p\n    b loop",
            "id": "47a273cb00e89cfd1a97d955651369ba"
          },
          {
            "type": "html",
            "text": "-- [[Jim Perry]]",
            "id": "76311f257f4953685186c2c688a2819c"
          },
          {
            "type": "html",
            "text": "\nI found a proof of sed's turing completeness: [http://robertkotcher.com/sed.html robertkotcher.com]",
            "id": "112ae21a3e1137552f35855f18556900"
          },
          {
            "type": "html",
            "text": "<i>Look it's even shorter in sed!</i> >:)",
            "id": "f2ed8f1fab59ff8bc7b4bf62b23ce8cb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "\nA Little Language is designed for a specific task, and not for throwing at any computational task that comes along. As such, it usually has no need to be [[Turing Complete]] - at least, that is what is expected. But along comes a task that lies just on the wrong side of the border of its abilities, and the temptation to extend it a little bit to handle the edge case can be irresistible. If such a [[Little Language]] ends up being [[Turing Complete]] then it's pretty much by accident, and the result is virtually guaranteed to be a particularly uncomfortable [[Turing Tarpit]].",
            "id": "93b0b039b8a695482c0389abf05c1bc9"
          },
          {
            "type": "html",
            "text": "\nIf a [[Little Language]] is designed from the outset to be [[Turing Complete]] then those borders don't exist and the pressure from that direction to extend the language is eliminated; it has a better chance of retaining what conceptual purity (coherent semantic model, robustness of implementation, etc.) it started out with, even if it is subsequently extended for other reasons. It may still be a [[Turing Tarpit]] in the general case, but if you're working anywhere in the vicinity of its bailiwick, at least you won't suddenly run into an impossibility or gotcha.",
            "id": "fe9e8fe7d05f97b302c2befcb4b02eab"
          },
          {
            "type": "html",
            "text": "\nFor an example of an \"accidentally TC\" [[Little Language]] I nominate sendmail; and for a deliberately TC [[Little Language]], [[Post Script]].",
            "id": "bc2bdb9e05a50f84d98a1eb8ac8ac2c5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "\nIt bothered me that a page on <b>Little Languages</b> should not contain a reference to [[Jon Bentley]] or [[Programming Pearls]], so here they are. (Actually, Bentley's column on <b>Little Languages</b> appeared in the second collection, [[More Programming Pearls]].)",
            "id": "a7bf407c0e86df144c1c9513aa30f7b4"
          },
          {
            "type": "html",
            "text": "\nAlso, I have the feeling that the idea of [[Language As Interface]] is relevant (or that, if it isn't, it ought to be).",
            "id": "8dbae50e77ba44c0f6d4300ef493c118"
          },
          {
            "type": "html",
            "text": "-- [[Cameron Smith]]",
            "id": "f2c6e010af298cf9173062d0cf130cc3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "\"sed scripts don't need to be tokenized; they already are\"",
            "id": "5abe53bd4245dd39a7d28ee09f6b1d6e"
          },
          {
            "type": "html",
            "text": "I've often read this but never known what it means. Would someone explain? -- [[Anonymous Donor]]",
            "id": "890ad046aef4c2cbf417c2992077bcd5"
          },
          {
            "type": "html",
            "text": "\nAll sed commands are one byte long, not including arguments. -- [[Ed Grimm]]",
            "id": "7f417df2d1f68820ec73dcc7b8b94e21"
          },
          {
            "type": "html",
            "text": "\nMore languages than just sed have this property or a similar one. The qmail security guarantee talks about using this (and null-terminated lines) under the subject of parsing. dc is similar; there are only one and two character commands, some of which have a mandatory one character argument, and no two-character command overshadows a one character command except !.",
            "id": "4b8d4dbfc717f466c4c512b8385f0be4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "\nIf a little language is [[Turing Complete]], many properties of program written in that language become undecidable: Such languages suffer from the [[Halting Problem]].",
            "id": "fd79b8d0234808cac642900403543444"
          },
          {
            "type": "html",
            "text": "\nSQL is another well known little language that has no way to express loops nor recursion, and which is not [[Turing Complete]].",
            "id": "12bdd779fa5bbb7920331eab09867b48"
          },
          {
            "type": "html",
            "text": "<i>But queries are a form of implicit looping over all records...</i>",
            "id": "98f9d62fe8b1aaae753961d4ac7526f8"
          },
          {
            "type": "html",
            "text": "<i>In fact,</i> I have written a SQL statement that did run forever reading a table with one row. - Joshua",
            "id": "c8cc9cca86a4966702462a42cbba2bce"
          },
          {
            "type": "html",
            "text": "<i>Yes, there is queries looping over records (you can even make it access multiple tables and do a bunch of other stuff), and you can make it to do things with it by creating a trigger and then inserting into a read-only view that has that trigger attached. They can even be made recursive. You can even do conditionals (with a WHERE clause), and a lot of other stuff. Numeric loops are missing, although a virtual table provides that, so you can use that.</i>",
            "id": "43e9129c7e32ccf6d795eff031820715"
          },
          {
            "type": "html",
            "text": "\nKeeping a little language declarative does have some advantages such as making it possible to use the scripts for multiple purposes (code generation, sanity checks, documentation, ...)",
            "id": "f62ac0e5239d057d60114e821c74fb10"
          },
          {
            "type": "html",
            "text": "\nFor those interested - see a paper I wrote in 1997 titled Little Languages: Little Maintenance? (it's on my homepage), which also discusses whether a little language should be [[Turing Complete]]. -- [[Arie Van Deursen]]",
            "id": "08d8a1dc1a973cf90fb3b8f602d7c8a3"
          },
          {
            "type": "html",
            "text": "\nAlso, the Berkeley Packet Filter (BPF), can be considered as a \"little language\". It is also decidedly turing-incomplete.",
            "id": "a8c0acdeaca7cc855c398d9b0b1f7746"
          },
          {
            "type": "html",
            "text": "\nThe basic [[Rebol Language]] book describes it as a [[Minimalist Language]]. Implementations have a very small footprint. Is it appropriate to think of <b>Little Language</b> as a logical categorization of a language while [[Minimalist Language]] emphasizes the physical size of the implementation? -- [[David Ness]]",
            "id": "a46d2596db9cd2125ab0c2c18ae55c19"
          },
          {
            "type": "html",
            "text": "\n[[Olin Shivers]] has a nice take on little languages at: [http://www.cc.gatech.edu/fac/Olin.Shivers/citations.html#ll www.cc.gatech.edu]. He argues, that instead of little languages, we should use a single extensible language plus a lot of libraries. Why redesign things like variables and functions over and over? <i>Wasn't that the idea behind [[Tool Command Language]]?</i>",
            "id": "256d84a785f2136df104fdb3e51d3454"
          },
          {
            "type": "html",
            "text": "\n[[Regular Expression]]s are also [[Turing Complete]], if they get applied in turn until none of them matches. Actually, plain text substitutions suffice - they are an instance of [[Semi Thue Grammars]]. -- [[Panu Kalliokoski]]",
            "id": "1e449342a5d2fe6de56fac9bed2226dd"
          },
          {
            "type": "html",
            "text": "<i>No...as phrased this isn't right. Plain old regular expressions, as you know, are not TC. Applying them in turn doesn't help, that's just (RE)*, another RE, and strictly speaking, it doesn't even matter if they're NDFA or DFA. What you must have meant to say is that regular expression match <b>and replace</b> is equivalent to a [[Semi Thue Grammar]], since then you can have arbitrary RHS and LHS on each grammar rule. -- [[Doug Merritt]]</i>",
            "id": "c8200581daebb1097bcf3aca34f28f58"
          },
          {
            "type": "html",
            "text": "\nBy which point regular expressions have become overkill, since search-and-replace on plain substrings is sufficient to implement a Semi-Thue grammar.",
            "id": "fd7829d868e661cca115c32a3512f074"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "So why are [[Little Language]]s seen to be a good idea but [[Fourth Generation Language]]s seen to be a bad idea?  The 4GLs I have used seemed to be collections of related [[Little Language]]s.",
            "id": "b7e2cfde06733f425fb76812dc33a772"
          },
          {
            "type": "html",
            "text": "<i>4GL began as a technical term but was emptied of all meaning by marketroids back in the 1980s, so it currently tends to be considered to be marketing fluff unless proven otherwise. Nor is there a \"fifth generation language\" by which to contrast, despite the passage of time. Terminology trends change. \"fourth generation\" and \"generation\" in general used to be commonly applied to many things, not just languages, and now they are (mostly) not. The last usage I personally saw was Bentley calling awk a 4GL, and meaning that in a positive sense (which he described in detail).</i>",
            "id": "fa2f0979931a73559e42fa430698f594"
          },
          {
            "type": "html",
            "text": "\nWasn't Prolog given the fifth generation tag by Japanese marketroids?  - [[Scott Elliott]]",
            "id": "177151ef14220a6e4969c42df989193b"
          },
          {
            "type": "html",
            "text": "<i>I forgot about that one. But I meant used <b>meaningfully</b>; the Japanese 5th generation label was empty in general, and there was no reason to apply that label to Prolog (except that it was the official language of their 5th Gen. project). \"Fourth Generation\" was once in a while used in a non-empty way.</i>",
            "id": "0253ea63e9dcd858622b597cf7bc5c83"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "\nOne interesting thing about little languages is that they must interface to the world. When they do, it will usually display some awkwardness. Otherwise little languages are really nice.",
            "id": "5984f85ef5da136d2a62d08c1a5a5945"
          },
          {
            "type": "html",
            "text": "\nTake a rather libre view of the classification of little languages, C is good at managing the memory, but some part of the world is better interfaced using OO, there comes the awkwardness of writing GUI applications in C.",
            "id": "ab5a1acd4b2786ff2c003496aaf5cd0e"
          },
          {
            "type": "html",
            "text": "\nAwk and sed are good at parsing flat files. When you want to parse EBNF using awk and sed, you would hate yourself. Yacc is for that.",
            "id": "da1f882c05de6fa55f4528961e6f1923"
          },
          {
            "type": "html",
            "text": "<i>A few more examples would be good.</i>",
            "id": "f7987f27685fe421f3df02c780f23fb3"
          },
          {
            "type": "html",
            "text": "\nWhen we talked about little languages, there must be mentioned that a good method for these little languages to interface with to the world is just equally important. In UNIX, that is the pipe. With pipe, the little languages can stay little.",
            "id": "41ea93fac22cb6e748a0384429d749b7"
          },
          {
            "type": "html",
            "text": "\nThe pipe is not perfect though, for it is unable to prevent people from inventing Perl. Or we could say that awk and sed is of no use to yacc and lex. When we want to parsing EBNF with another little language, the pipe can't let us utilize the other previously existing little languages. When we want to use a functional style to parse the EBNF instead of the C used in yacc, again we can not effectively utilize the yacc and lex but have to be forcef to implement our own yet another yacc in our own favorite functional language, ie. haskell etc.. The pipe cannot help us on that.",
            "id": "b2fe51dcdd55046d334b7d537124bafd"
          },
          {
            "type": "html",
            "text": "-- [[Zhao Way]]",
            "id": "7a76181b6101840d10e74fad8c15f708"
          },
          {
            "type": "html",
            "text": "\nFor a description of a possible class of [[Little Language]]s in the [[Flow Based Programming]] context, see [http://www.jpaulmorrison.com/fbp/bdl.htm www.jpaulmorrison.com].  [[Flow Based Programming]] supports a network of \"pipes\", and so should be a great environment for hooking together different (types of) [[Little Language]]s. -- [[Paul Morrison]]",
            "id": "247b222261c2a9151096f9bd2477b7ab"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "Does [[Furry Script]] count? It is domain specific, and I think for mostly a narrow domain; it can be used with other stuff but not very well. What about, [[Dada Engine]] and rmutt, which have some similar purposes (even though none of them was based on the other)?",
            "id": "a41cd1fd1ad7589440013f755e27b5e6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "Is [[Music Macro Language]] (MML) a [[Little Language]]?",
            "id": "9abbf7144de215715bf7f69aa81ed557"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "See Minilanguages:\nFinding a Notation That Sings\n[http://www.faqs.org/docs/artu/minilanguageschapter.html www.faqs.org]",
            "id": "72e419455f8976d5e0a0ca165170a6b2"
          },
          {
            "type": "html",
            "text": "\nSee also [[Domain Specific Language]]s, [[Minimal Parsing]], [[Helpers Instead Of Wrappers]]",
            "id": "5ab6b2a104e3911c87d5773ff7a81eca"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b96f4a3626c74af13afb71b77564e4ec"
          },
          {
            "type": "html",
            "text": "[[Category Language]]",
            "id": "dc4b716aae48bec470edc0d67c14e795"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?LittleLanguage c2.com]",
            "id": "42ec4c5c23f56acc9242cc74be5c7e59"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1707798394879
    }
  ]
}