{
  "title": "Dictionary",
  "story": [
    {
      "type": "markdown",
      "id": "fe5cde77c2740697",
      "text": "I am a collection of elements that [[associate]] a key object with a value object."
    },
    {
      "type": "markdown",
      "id": "ff342ec7fd3289d0",
      "text": "Description\n--------------------------\n\nI  can be viewed from one of two perspectives: a set of associations, or a [[Container]] of values that are externally named where the name can be any object that responds to #=. The external name is referred to as the key.  I inherit many operations from Set.\nI use the #= method to locate a key. If you want a collection that use the #== method (same pointers) you can use an IdentityDictionary."
    },
    {
      "type": "markdown",
      "id": "1b02764fac1667c0",
      "text": "I'm used when we need a collection of objects which I can access with a key. For example if you associate some words with a definition, the word will be the key and the definition will be the value. Both of them can be any kind of objects.\n\nInternally I use Associations. The Association class can help to use me. (See examples lower)\n\nPublic API and Key Messages\n--------------------------\n\n- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue \t\tallow to add an element.\n  \n- #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock \t\tallow to access my values.\n\n- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: \t\tallow to iterate on me effectively\n\nExamples \n--------------------------\n\nTo create a dictiony with indexes as key: \n\n\tDictionary withAll: #(7 3 1 3)   \t\t\"returns:  a Dictionary(1->7 2->3 3->1 4->3 \"\n\nTo use Objects as key (here symbols): \n\n\tcolors := Dictionary new \n\t\t\t\tat: #yellow put: Color yellow; \n\t\t\t\tat: #blue put: Color blue;\n\t\t\t\tat: #red put: Color red;\n\t\t\t\tyourself.\n\t\t\t\t\n\tcolors at: #yellow. \t\"returns:  Color yellow\"\n\tcolors keys          \"returns: a Set(#blue #yellow #red)\"\n\tcolors values       \"returns:  {Color blue. Color yellow. Color red}\" \n\nYou can also directly use Associations: \n\n\tcolors := Dictionary with: #yellow -> Color yellow with: #blue -> Color blue.\n\tcolors add: #red -> Color red.\n\t\n\tcolors associations  \t\"returns: {#yellow->Color yellow. #red->Color red. #blue->Color blue}\"\n\t\t\nHere some more examples: \n\n\tcolors := Dictionary newFrom: { #blue->Color blue . #red->Color red . #yellow->Color yellow }. \n\tcolors removeKey: #blue. \n\tcolors at: #red ifPresent: [ :color |  color darker] ifAbsent: [ Error signal: 'The red color should be here.' ] .\t\t\"return: (Color r: 0.92 g: 0.0 b: 0.0 alpha: 1.0)\"\n\tcolors associations \t\t \"{#yellow->Color yellow. #red->Color red}\"\n \nInternal Representation and Key Implementation Points.\n--------------------------\n\nI am just a collection of associations. If I need my keys I will just return the keys of my associations. Idem for my values.\nI use the #= method in order to manipulate my keys. I cannot have two associations that are equals with the #= method."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Dictionary",
        "story": []
      },
      "date": 1639830539470
    },
    {
      "item": {
        "type": "factory",
        "id": "fe5cde77c2740697"
      },
      "id": "fe5cde77c2740697",
      "type": "add",
      "date": 1639830550559
    },
    {
      "type": "edit",
      "id": "fe5cde77c2740697",
      "item": {
        "type": "paragraph",
        "id": "fe5cde77c2740697",
        "text": "I am a collection of elements that associate a key object with a value object.\n\nDescription\n--------------------------\n\nI  can be viewed from one of two perspectives: a set of associations, or a container of values that are externally named where the name can be any object that responds to #=. The external name is referred to as the key.  I inherit many operations from Set.\nI use the #= method to locate a key. If you want a collection that use the #== method (same pointers) you can use an IdentityDictionary.\n\nI'm used when we need a collection of objects which I can access with a key. For example if you associate some words with a definition, the word will be the key and the definition will be the value. Both of them can be any kind of objects.\n\nInternally I use Associations. The Association class can help to use me. (See examples lower)\n\nPublic API and Key Messages\n--------------------------\n\n- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue \t\tallow to add an element.\n  \n- #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock \t\tallow to access my values.\n\n- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: \t\tallow to iterate on me effectively\n\nExamples \n--------------------------\n\nTo create a dictiony with indexes as key: \n\n\tDictionary withAll: #(7 3 1 3)   \t\t\"returns:  a Dictionary(1->7 2->3 3->1 4->3 \"\n\nTo use Objects as key (here symbols): \n\n\tcolors := Dictionary new \n\t\t\t\tat: #yellow put: Color yellow; \n\t\t\t\tat: #blue put: Color blue;\n\t\t\t\tat: #red put: Color red;\n\t\t\t\tyourself.\n\t\t\t\t\n\tcolors at: #yellow. \t\"returns:  Color yellow\"\n\tcolors keys          \"returns: a Set(#blue #yellow #red)\"\n\tcolors values       \"returns:  {Color blue. Color yellow. Color red}\" \n\nYou can also directly use Associations: \n\n\tcolors := Dictionary with: #yellow -> Color yellow with: #blue -> Color blue.\n\tcolors add: #red -> Color red.\n\t\n\tcolors associations  \t\"returns: {#yellow->Color yellow. #red->Color red. #blue->Color blue}\"\n\t\t\nHere some more examples: \n\n\tcolors := Dictionary newFrom: { #blue->Color blue . #red->Color red . #yellow->Color yellow }. \n\tcolors removeKey: #blue. \n\tcolors at: #red ifPresent: [ :color |  color darker] ifAbsent: [ Error signal: 'The red color should be here.' ] .\t\t\"return: (Color r: 0.92 g: 0.0 b: 0.0 alpha: 1.0)\"\n\tcolors associations \t\t \"{#yellow->Color yellow. #red->Color red}\"\n \nInternal Representation and Key Implementation Points.\n--------------------------\n\nI am just a collection of associations. If I need my keys I will just return the keys of my associations. Idem for my values.\nI use the #= method in order to manipulate my keys. I cannot have two associations that are equals with the #= method."
      },
      "date": 1639830553828
    },
    {
      "type": "edit",
      "id": "fe5cde77c2740697",
      "item": {
        "type": "markdown",
        "id": "fe5cde77c2740697",
        "text": "I am a collection of elements that associate a key object with a value object.\n\nDescription\n--------------------------\n\nI  can be viewed from one of two perspectives: a set of associations, or a container of values that are externally named where the name can be any object that responds to #=. The external name is referred to as the key.  I inherit many operations from Set.\nI use the #= method to locate a key. If you want a collection that use the #== method (same pointers) you can use an IdentityDictionary.\n\nI'm used when we need a collection of objects which I can access with a key. For example if you associate some words with a definition, the word will be the key and the definition will be the value. Both of them can be any kind of objects.\n\nInternally I use Associations. The Association class can help to use me. (See examples lower)\n\nPublic API and Key Messages\n--------------------------\n\n- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue \t\tallow to add an element.\n  \n- #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock \t\tallow to access my values.\n\n- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: \t\tallow to iterate on me effectively\n\nExamples \n--------------------------\n\nTo create a dictiony with indexes as key: \n\n\tDictionary withAll: #(7 3 1 3)   \t\t\"returns:  a Dictionary(1->7 2->3 3->1 4->3 \"\n\nTo use Objects as key (here symbols): \n\n\tcolors := Dictionary new \n\t\t\t\tat: #yellow put: Color yellow; \n\t\t\t\tat: #blue put: Color blue;\n\t\t\t\tat: #red put: Color red;\n\t\t\t\tyourself.\n\t\t\t\t\n\tcolors at: #yellow. \t\"returns:  Color yellow\"\n\tcolors keys          \"returns: a Set(#blue #yellow #red)\"\n\tcolors values       \"returns:  {Color blue. Color yellow. Color red}\" \n\nYou can also directly use Associations: \n\n\tcolors := Dictionary with: #yellow -> Color yellow with: #blue -> Color blue.\n\tcolors add: #red -> Color red.\n\t\n\tcolors associations  \t\"returns: {#yellow->Color yellow. #red->Color red. #blue->Color blue}\"\n\t\t\nHere some more examples: \n\n\tcolors := Dictionary newFrom: { #blue->Color blue . #red->Color red . #yellow->Color yellow }. \n\tcolors removeKey: #blue. \n\tcolors at: #red ifPresent: [ :color |  color darker] ifAbsent: [ Error signal: 'The red color should be here.' ] .\t\t\"return: (Color r: 0.92 g: 0.0 b: 0.0 alpha: 1.0)\"\n\tcolors associations \t\t \"{#yellow->Color yellow. #red->Color red}\"\n \nInternal Representation and Key Implementation Points.\n--------------------------\n\nI am just a collection of associations. If I need my keys I will just return the keys of my associations. Idem for my values.\nI use the #= method in order to manipulate my keys. I cannot have two associations that are equals with the #= method."
      },
      "date": 1639830645189
    },
    {
      "type": "edit",
      "id": "fe5cde77c2740697",
      "item": {
        "type": "markdown",
        "id": "fe5cde77c2740697",
        "text": "I am a collection of elements that associate a key object with a value object."
      },
      "date": 1702406778700
    },
    {
      "type": "add",
      "id": "ff342ec7fd3289d0",
      "item": {
        "type": "markdown",
        "id": "ff342ec7fd3289d0",
        "text": "Description\n--------------------------\n\nI  can be viewed from one of two perspectives: a set of associations, or a container of values that are externally named where the name can be any object that responds to #=. The external name is referred to as the key.  I inherit many operations from Set.\nI use the #= method to locate a key. If you want a collection that use the #== method (same pointers) you can use an IdentityDictionary.\n\nI'm used when we need a collection of objects which I can access with a key. For example if you associate some words with a definition, the word will be the key and the definition will be the value. Both of them can be any kind of objects.\n\nInternally I use Associations. The Association class can help to use me. (See examples lower)\n\nPublic API and Key Messages\n--------------------------\n\n- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue \t\tallow to add an element.\n  \n- #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock \t\tallow to access my values.\n\n- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: \t\tallow to iterate on me effectively\n\nExamples \n--------------------------\n\nTo create a dictiony with indexes as key: \n\n\tDictionary withAll: #(7 3 1 3)   \t\t\"returns:  a Dictionary(1->7 2->3 3->1 4->3 \"\n\nTo use Objects as key (here symbols): \n\n\tcolors := Dictionary new \n\t\t\t\tat: #yellow put: Color yellow; \n\t\t\t\tat: #blue put: Color blue;\n\t\t\t\tat: #red put: Color red;\n\t\t\t\tyourself.\n\t\t\t\t\n\tcolors at: #yellow. \t\"returns:  Color yellow\"\n\tcolors keys          \"returns: a Set(#blue #yellow #red)\"\n\tcolors values       \"returns:  {Color blue. Color yellow. Color red}\" \n\nYou can also directly use Associations: \n\n\tcolors := Dictionary with: #yellow -> Color yellow with: #blue -> Color blue.\n\tcolors add: #red -> Color red.\n\t\n\tcolors associations  \t\"returns: {#yellow->Color yellow. #red->Color red. #blue->Color blue}\"\n\t\t\nHere some more examples: \n\n\tcolors := Dictionary newFrom: { #blue->Color blue . #red->Color red . #yellow->Color yellow }. \n\tcolors removeKey: #blue. \n\tcolors at: #red ifPresent: [ :color |  color darker] ifAbsent: [ Error signal: 'The red color should be here.' ] .\t\t\"return: (Color r: 0.92 g: 0.0 b: 0.0 alpha: 1.0)\"\n\tcolors associations \t\t \"{#yellow->Color yellow. #red->Color red}\"\n \nInternal Representation and Key Implementation Points.\n--------------------------\n\nI am just a collection of associations. If I need my keys I will just return the keys of my associations. Idem for my values.\nI use the #= method in order to manipulate my keys. I cannot have two associations that are equals with the #= method."
      },
      "after": "fe5cde77c2740697",
      "date": 1702406779184
    },
    {
      "type": "edit",
      "id": "ff342ec7fd3289d0",
      "item": {
        "type": "markdown",
        "id": "ff342ec7fd3289d0",
        "text": "Description\n--------------------------\n\nI  can be viewed from one of two perspectives: a set of associations, or a container of values that are externally named where the name can be any object that responds to #=. The external name is referred to as the key.  I inherit many operations from Set.\nI use the #= method to locate a key. If you want a collection that use the #== method (same pointers) you can use an IdentityDictionary."
      },
      "date": 1702406797976
    },
    {
      "type": "add",
      "id": "1b02764fac1667c0",
      "item": {
        "type": "markdown",
        "id": "1b02764fac1667c0",
        "text": "I'm used when we need a collection of objects which I can access with a key. For example if you associate some words with a definition, the word will be the key and the definition will be the value. Both of them can be any kind of objects.\n\nInternally I use Associations. The Association class can help to use me. (See examples lower)\n\nPublic API and Key Messages\n--------------------------\n\n- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue \t\tallow to add an element.\n  \n- #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock \t\tallow to access my values.\n\n- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: \t\tallow to iterate on me effectively\n\nExamples \n--------------------------\n\nTo create a dictiony with indexes as key: \n\n\tDictionary withAll: #(7 3 1 3)   \t\t\"returns:  a Dictionary(1->7 2->3 3->1 4->3 \"\n\nTo use Objects as key (here symbols): \n\n\tcolors := Dictionary new \n\t\t\t\tat: #yellow put: Color yellow; \n\t\t\t\tat: #blue put: Color blue;\n\t\t\t\tat: #red put: Color red;\n\t\t\t\tyourself.\n\t\t\t\t\n\tcolors at: #yellow. \t\"returns:  Color yellow\"\n\tcolors keys          \"returns: a Set(#blue #yellow #red)\"\n\tcolors values       \"returns:  {Color blue. Color yellow. Color red}\" \n\nYou can also directly use Associations: \n\n\tcolors := Dictionary with: #yellow -> Color yellow with: #blue -> Color blue.\n\tcolors add: #red -> Color red.\n\t\n\tcolors associations  \t\"returns: {#yellow->Color yellow. #red->Color red. #blue->Color blue}\"\n\t\t\nHere some more examples: \n\n\tcolors := Dictionary newFrom: { #blue->Color blue . #red->Color red . #yellow->Color yellow }. \n\tcolors removeKey: #blue. \n\tcolors at: #red ifPresent: [ :color |  color darker] ifAbsent: [ Error signal: 'The red color should be here.' ] .\t\t\"return: (Color r: 0.92 g: 0.0 b: 0.0 alpha: 1.0)\"\n\tcolors associations \t\t \"{#yellow->Color yellow. #red->Color red}\"\n \nInternal Representation and Key Implementation Points.\n--------------------------\n\nI am just a collection of associations. If I need my keys I will just return the keys of my associations. Idem for my values.\nI use the #= method in order to manipulate my keys. I cannot have two associations that are equals with the #= method."
      },
      "after": "ff342ec7fd3289d0",
      "date": 1702406799201
    },
    {
      "type": "edit",
      "id": "fe5cde77c2740697",
      "item": {
        "type": "markdown",
        "id": "fe5cde77c2740697",
        "text": "I am a collection of elements that [[associate]] a key object with a value object."
      },
      "date": 1713009812023
    },
    {
      "type": "edit",
      "id": "ff342ec7fd3289d0",
      "item": {
        "type": "markdown",
        "id": "ff342ec7fd3289d0",
        "text": "Description\n--------------------------\n\nI  can be viewed from one of two perspectives: a set of associations, or a [[Container]] of values that are externally named where the name can be any object that responds to #=. The external name is referred to as the key.  I inherit many operations from Set.\nI use the #= method to locate a key. If you want a collection that use the #== method (same pointers) you can use an IdentityDictionary."
      },
      "date": 1713010103869
    }
  ]
}