{
  "title": "Literate Programming Essentials",
  "story": [
    {
      "type": "paragraph",
      "id": "f4e61ded91d38656",
      "text": "[[Literate Programming]] (LP) is a programming style for developing programs and their documentation. In this style a program is primarily seen as a document that explains a problem solution to a human reader."
    },
    {
      "type": "paragraph",
      "id": "a610e9386844a6cf",
      "text": "This view is radically different from the widely accepted view of a program as a list of instructions to a computer to solve a problem. In the latter view, human understanding is, to a lesser or greater extent, treated as a sort of secondary issue. Knuth [1984] maintains that, if applied correctly, LP leads to the development of better programs which are more elegant, effective, transportable and understandable. The maintenance and amendment of such programs will also be eased. The essentials of LP may be summarised as follows:"
    },
    {
      "type": "markdown",
      "id": "63373464890d0a51",
      "text": "# Literate Quality"
    },
    {
      "type": "paragraph",
      "id": "5056b15b9811547b",
      "text": "The completed program is a literate work of art that explains to the reader what the computer is supposed to do. A program, as seen by the computer, is a set of components combined in some structure. The literate programmer can be regarded as an essayist that explains the solution to a human by crisply defining the components and delicately weaving them together into a complete artistic creation [Knuth, 1984]. Lee [1994] goes so far as to describe a literate program as a publishable-quality document that argues mathematically for its own correctness. However most practitioners would not insist on such a level of formality."
    },
    {
      "type": "paragraph",
      "id": "f79d8423f5bb40ee",
      "text": "NB. One of the practitioners who does is [[Konrad Hinsen]] with his [[Leibniz]] notation."
    },
    {
      "type": "markdown",
      "id": "571f142ab1771bda",
      "text": "> My aim with Leibniz is to introduce a variant. Technically speaking it could be called \"literate specifications\" (though that's not a good term for its intended audience, hence my term \"[[Digital Scientific Notation]]\"). I believe that specifications are a better support for communicating software behavior to humans than fully fleshed out source code with all its technical details."
    },
    {
      "type": "paragraph",
      "id": "ef2e921f646ba638",
      "text": "Konrad Hinsen via [https://scholar.social/@khinsen/112336174641602498 mastodon]"
    },
    {
      "type": "paragraph",
      "id": "43170979b3554a9b",
      "text": "[…]"
    },
    {
      "type": "pagefold",
      "id": "e206be46c885b0be",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "f6608825de941747",
      "text": "PIETERSE, Vreda, KOURIE, Derrick G. and BOAKE, Andrew, 2004. A case for contemporary literate programming. In: ACM International Conference Proceeding Series. Online. 2004. p. 2–9. [https://www.academia.edu/download/41498868/A_case_for_contemporary_literate_program20160123-30753-1twqql3.pdf pdf]."
    },
    {
      "type": "paragraph",
      "id": "aac721425c5179cb",
      "text": "See also \"What is the difference between Moldable Development and ... --- literate programming\" [https://book.gtoolkit.com/what-is-the-difference-between-moldable-de-6k5konofqz2tb197qgxroxvnk gt book]"
    },
    {
      "type": "markdown",
      "id": "e0784883c6612e2e",
      "text": "> They are similar in that they both promote the use of narratives for depicting systems. However, literate programming offers exactly a single narrative, and that narrative is tied to the definition of the code. Through moldable development we recognize that we always need multiple narratives, and that those narratives must be able to address any part of the system (not only static code). "
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Literate Programming Essentials",
        "story": []
      },
      "date": 1714038780786
    },
    {
      "item": {
        "type": "factory",
        "id": "f4e61ded91d38656"
      },
      "id": "f4e61ded91d38656",
      "type": "add",
      "date": 1714038782078
    },
    {
      "type": "edit",
      "id": "f4e61ded91d38656",
      "item": {
        "type": "paragraph",
        "id": "f4e61ded91d38656",
        "text": "LP is a programming style for developing programs and their documentation. In this style a program is primarily seen as a document that explains a problem solution to a human reader. This view is radically different from the widely accepted view of a program as a list of instructions to a computer to solve a problem. In the latter view, human understanding is, to a lesser or greater extent, treated as a sort of secondary issue. Knuth [1984] maintains that, if applied correctly, LP leads to the development of better programs which are more elegant, effective, transportable and understandable. The maintenance and amendment of such programs will also be eased. The essentials of LP may be summarised as follows:"
      },
      "date": 1714038783824
    },
    {
      "type": "edit",
      "id": "f4e61ded91d38656",
      "item": {
        "type": "paragraph",
        "id": "f4e61ded91d38656",
        "text": "[[Literate Programming]] (LP) is a programming style for developing programs and their documentation. In this style a program is primarily seen as a document that explains a problem solution to a human reader. This view is radically different from the widely accepted view of a program as a list of instructions to a computer to solve a problem. In the latter view, human understanding is, to a lesser or greater extent, treated as a sort of secondary issue. Knuth [1984] maintains that, if applied correctly, LP leads to the development of better programs which are more elegant, effective, transportable and understandable. The maintenance and amendment of such programs will also be eased. The essentials of LP may be summarised as follows:"
      },
      "date": 1714038811891
    },
    {
      "type": "edit",
      "id": "f4e61ded91d38656",
      "item": {
        "type": "paragraph",
        "id": "f4e61ded91d38656",
        "text": "[[Literate Programming]] (LP) is a programming style for developing programs and their documentation. In this style a program is primarily seen as a document that explains a problem solution to a human reader."
      },
      "date": 1714038835679
    },
    {
      "type": "add",
      "id": "a610e9386844a6cf",
      "item": {
        "type": "paragraph",
        "id": "a610e9386844a6cf",
        "text": "This view is radically different from the widely accepted view of a program as a list of instructions to a computer to solve a problem. In the latter view, human understanding is, to a lesser or greater extent, treated as a sort of secondary issue. Knuth [1984] maintains that, if applied correctly, LP leads to the development of better programs which are more elegant, effective, transportable and understandable. The maintenance and amendment of such programs will also be eased. The essentials of LP may be summarised as follows:"
      },
      "after": "f4e61ded91d38656",
      "date": 1714038839224
    },
    {
      "item": {
        "type": "factory",
        "id": "e206be46c885b0be"
      },
      "id": "e206be46c885b0be",
      "type": "add",
      "after": "a610e9386844a6cf",
      "date": 1714038852383
    },
    {
      "type": "edit",
      "id": "e206be46c885b0be",
      "item": {
        "type": "pagefold",
        "id": "e206be46c885b0be",
        "text": "~"
      },
      "date": 1714038855142
    },
    {
      "item": {
        "type": "factory",
        "id": "f6608825de941747"
      },
      "id": "f6608825de941747",
      "type": "add",
      "after": "e206be46c885b0be",
      "date": 1714038856535
    },
    {
      "type": "edit",
      "id": "f6608825de941747",
      "item": {
        "type": "paragraph",
        "id": "f6608825de941747",
        "text": "PIETERSE, Vreda, KOURIE, Derrick G. and BOAKE, Andrew, 2004. A case for contemporary literate programming. In: ACM International Conference Proceeding Series. Online. 2004. p. 2–9. Available from: https://www.academia.edu/download/41498868/A_case_for_contemporary_literate_program20160123-30753-1twqql3.pdf [Accessed 13 February 2024]."
      },
      "date": 1714038858490
    },
    {
      "type": "add",
      "id": "43170979b3554a9b",
      "item": {
        "type": "paragraph",
        "id": "43170979b3554a9b",
        "text": "[…]"
      },
      "after": "a610e9386844a6cf",
      "date": 1714038906776
    },
    {
      "type": "add",
      "id": "63373464890d0a51",
      "item": {
        "type": "paragraph",
        "id": "63373464890d0a51",
        "text": "# Literate Quality"
      },
      "after": "a610e9386844a6cf",
      "date": 1714038954350
    },
    {
      "type": "add",
      "id": "5056b15b9811547b",
      "item": {
        "type": "paragraph",
        "id": "5056b15b9811547b",
        "text": "The completed program is a literate work of art that explains to the reader what the computer is supposed to do. A program, as seen by the computer, is a set of components combined in some structure. The literate programmer can be regarded as an essayist that explains the solution to a human by crisply defining the components and delicately weaving them together into a complete artistic creation [Knuth, 1984]. Lee [1994] goes so far as to describe a literate program as a publishable-quality document that argues mathematically for its own correctness. However most practitioners would not insist on such a level of formality."
      },
      "after": "63373464890d0a51",
      "date": 1714038966114
    },
    {
      "type": "edit",
      "id": "63373464890d0a51",
      "item": {
        "type": "markdown",
        "id": "63373464890d0a51",
        "text": "# Literate Quality"
      },
      "date": 1714038967431
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1714039240321
    },
    {
      "type": "edit",
      "id": "f6608825de941747",
      "item": {
        "type": "paragraph",
        "id": "f6608825de941747",
        "text": "PIETERSE, Vreda, KOURIE, Derrick G. and BOAKE, Andrew, 2004. A case for contemporary literate programming. In: ACM International Conference Proceeding Series. Online. 2004. p. 2–9. [https://www.academia.edu/download/41498868/A_case_for_contemporary_literate_program20160123-30753-1twqql3.pdf pdf]."
      },
      "date": 1714039477150
    },
    {
      "type": "fork",
      "site": "wiki.ralfbarkow.ch",
      "date": 1714040951730
    },
    {
      "type": "add",
      "id": "aac721425c5179cb",
      "item": {
        "type": "paragraph",
        "id": "aac721425c5179cb",
        "text": "See also \"What is the difference between Moldable Development and ... --- literate programming\" [https://book.gtoolkit.com/what-is-the-difference-between-moldable-de-6k5konofqz2tb197qgxroxvnk gt book]"
      },
      "after": "f6608825de941747",
      "date": 1714041095557
    },
    {
      "type": "add",
      "id": "e0784883c6612e2e",
      "item": {
        "type": "paragraph",
        "id": "e0784883c6612e2e",
        "text": "> They are similar in that they both promote the use of narratives for depicting systems. However, literate programming offers exactly a single narrative, and that narrative is tied to the definition of the code. Through moldable development we recognize that we always need multiple narratives, and that those narratives must be able to address any part of the system (not only static code). "
      },
      "after": "aac721425c5179cb",
      "date": 1714041102951
    },
    {
      "type": "edit",
      "id": "e0784883c6612e2e",
      "item": {
        "type": "markdown",
        "id": "e0784883c6612e2e",
        "text": "> They are similar in that they both promote the use of narratives for depicting systems. However, literate programming offers exactly a single narrative, and that narrative is tied to the definition of the code. Through moldable development we recognize that we always need multiple narratives, and that those narratives must be able to address any part of the system (not only static code). "
      },
      "date": 1714041105331
    },
    {
      "type": "add",
      "id": "f79d8423f5bb40ee",
      "item": {
        "type": "paragraph",
        "id": "f79d8423f5bb40ee",
        "text": "NB. One of the practitioners who does is [[Konrad Hinsen] with his Leibniz notation."
      },
      "after": "5056b15b9811547b",
      "date": 1714075562058
    },
    {
      "type": "edit",
      "id": "f79d8423f5bb40ee",
      "item": {
        "type": "paragraph",
        "id": "f79d8423f5bb40ee",
        "text": "NB. One of the practitioners who does is [[Konrad Hinsen]] with his [[Leibniz]] notation."
      },
      "date": 1714075574396
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1714080359360
    },
    {
      "id": "571f142ab1771bda",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "571f142ab1771bda",
        "text": "My aim with Leibniz is to introduce a variant. Technically speaking it could be called \"literate specifications\" (though that's not a good term for its intended audience, hence my term \"digital scientific notation\"). I believe that specifications are a better support for communicating software behavior to humans than fully fleshed out source code with all its technical details."
      },
      "after": "f79d8423f5bb40ee",
      "attribution": {
        "page": "2024-04-26"
      },
      "date": 1714124367892
    },
    {
      "type": "edit",
      "id": "571f142ab1771bda",
      "item": {
        "type": "markdown",
        "id": "571f142ab1771bda",
        "text": "> My aim with Leibniz is to introduce a variant. Technically speaking it could be called \"literate specifications\" (though that's not a good term for its intended audience, hence my term \"digital scientific notation\"). I believe that specifications are a better support for communicating software behavior to humans than fully fleshed out source code with all its technical details."
      },
      "date": 1714124374892
    },
    {
      "id": "ef2e921f646ba638",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "ef2e921f646ba638",
        "text": "Konrad Hinsen via [https://scholar.social/@khinsen/112336174641602498 mastodon]"
      },
      "after": "571f142ab1771bda",
      "attribution": {
        "page": "2024-04-26"
      },
      "date": 1714124399916
    },
    {
      "type": "edit",
      "id": "571f142ab1771bda",
      "item": {
        "type": "markdown",
        "id": "571f142ab1771bda",
        "text": "> My aim with Leibniz is to introduce a variant. Technically speaking it could be called \"literate specifications\" (though that's not a good term for its intended audience, hence my term \"[[Digital Sientific Notation]]\"). I believe that specifications are a better support for communicating software behavior to humans than fully fleshed out source code with all its technical details."
      },
      "date": 1714124467758
    },
    {
      "type": "edit",
      "id": "571f142ab1771bda",
      "item": {
        "type": "markdown",
        "id": "571f142ab1771bda",
        "text": "> My aim with Leibniz is to introduce a variant. Technically speaking it could be called \"literate specifications\" (though that's not a good term for its intended audience, hence my term \"[[Digital Scientific Notation\"]]\"). I believe that specifications are a better support for communicating software behavior to humans than fully fleshed out source code with all its technical details."
      },
      "date": 1714124543772
    },
    {
      "type": "edit",
      "id": "571f142ab1771bda",
      "item": {
        "type": "markdown",
        "id": "571f142ab1771bda",
        "text": "> My aim with Leibniz is to introduce a variant. Technically speaking it could be called \"literate specifications\" (though that's not a good term for its intended audience, hence my term \"[[Digital Scientific Notation]]\"). I believe that specifications are a better support for communicating software behavior to humans than fully fleshed out source code with all its technical details."
      },
      "date": 1714124551214
    }
  ]
}