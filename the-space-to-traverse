{
  "title": "The Space to Traverse",
  "story": [
    {
      "type": "paragraph",
      "id": "636a4e94feb2c4fd",
      "text": "Since we will be considering the traversal of a space, the first thing we should consider is the shape of the space in question. The Smalltalk image can be seen in many ways, but as we are interested in references, we could take a look at it from a garbage collection point of view."
    },
    {
      "type": "markdown",
      "id": "ee99b6bc51135bfe",
      "text": "With these intentions, the image “starts” at some globally visible object that is considered to be not garbage by convention. Typically, this is the `Smalltalk` dictionary. Anything that is directly or indirectly referenced by this non garbage context is said to be not garbage either."
    },
    {
      "type": "markdown",
      "id": "7c02fc31a5821b64",
      "text": "And what is a reference? If we look at objects from a Smalltalk point of view, references occur via regular instance names. For example, associations reference the values of their `key` and `value` instance names. In addition, references also occur by means of index based storage. For instance, arrays reference whatever is stored in any of their integer named slots."
    },
    {
      "type": "paragraph",
      "id": "783859eee629793a",
      "text": "These are the only ways in which an object can reference another object. This is because things like class names and pool dictionaries are implemented in terms of instance names or integer named slots."
    },
    {
      "type": "markdown",
      "id": "2c377fea39dbb238",
      "text": "So it seems we could think of the Smalltalk image as a tree starting at `Smalltalk`. But since the leaves could easily reference their parents or even `Smalltalk` itself, it does not quite qualify as a tree. In reality, it is a graph where nodes are objects and references are represented by arrows connecting the nodes.\n"
    },
    {
      "type": "markdown",
      "id": "b7a8de35ef3bcb4b",
      "text": "Interestingly, the node for Smalltalk is not special by itself. We just start traversing the graph from this node only because of our convention to never consider it garbage.\n"
    },
    {
      "type": "markdown",
      "id": "7d84e96a783ddd9a",
      "text": "To be more precise, we are interest in finding out all the objects that are connected to `Smalltalk`. The fact that we are going to say they are not garbage does not matter as far as the connectedness check itself is concerned."
    },
    {
      "type": "paragraph",
      "id": "2737829639263042",
      "text": "Also, note how the arrows only have one direction: no object has immediate knowledge of where it is referenced from. This is why tools like a reference finder become necessary so that we can derive this knowledge from the graph."
    },
    {
      "type": "markdown",
      "id": "2bab33c37b13117d",
      "text": "The truly interesting references to an object are the ones that occur closest to `Smalltalk`. Since these are the most natural reference paths, we should build a breadth first reference finder — one that works as some sort of onion peeler in reverse."
    },
    {
      "type": "paragraph",
      "id": "669f283bbf8daad4",
      "text": "Unfortunately, the nature of the space and the implementation techniques available make it too easy to implement depth first reference finders instead. For example, we could let an object iterate over instance names and indexable slots. However, this forces the static context to remember which ones it chose to dive through, and things typically get quite complicated soon thereafter. As if managing that iteration was not difficult enough already!"
    },
    {
      "type": "markdown",
      "id": "7a816e499bc39f74",
      "text": "We could also try to take advantage of an existing primitive that answers where a given object is directly referenced from. But, alas, the answer of this primitive leaves us with figuring out a breadth first path from `Smalltalk` to the object in question, while the information we are provided happens to be oriented in a direction opposite to the one we want. Making sense out of the result is typically left as an exercise for the developer. Sorting through the mess of false positives, even when done mechanically, takes a lot of time and effort."
    },
    {
      "type": "paragraph",
      "id": "81dfa82e4af5a934",
      "text": "To summarize, while these techniques make it very easy to implement a depth first reference finder, the problem is that depth first traversal has the irritating behavior of producing extremely long and convoluted reference paths. What we need is a breadth first reference finder, and these tools give us no easy way to implement one. It looks like this is going nowhere."
    },
    {
      "type": "paragraph",
      "id": "452bb4ff8cc03d2a",
      "text": "But there is another way to take a look at objects and their mechanisms for referencing other objects. What if we saw the reference graph in terms of forms and distinctions instead?"
    },
    {
      "type": "paragraph",
      "id": "f37079a8f4fff32e",
      "text": "⇒ [[Distinctions, Forms, and Objects]]"
    },
    {
      "type": "pagefold",
      "id": "98599762d152305b",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "20ccf38878bbf9cb",
      "text": "Section 5.2 of [[A Mentoring Course on Smalltalk]], [[An Efficient Reference Finder]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "The Space to Traverse",
        "story": []
      },
      "date": 1660208460951
    },
    {
      "item": {
        "type": "factory",
        "id": "636a4e94feb2c4fd"
      },
      "id": "636a4e94feb2c4fd",
      "type": "add",
      "date": 1660208473770
    },
    {
      "type": "edit",
      "id": "636a4e94feb2c4fd",
      "item": {
        "type": "paragraph",
        "id": "636a4e94feb2c4fd",
        "text": "Since we will be considering the traversal of a space, the first thing we should consider is the shape of the space in question. The Smalltalk image can be seen in many ways, but as we are interested in references, we could take a look at it from a garbage collection point of view."
      },
      "date": 1660208475237
    },
    {
      "item": {
        "type": "factory",
        "id": "ee99b6bc51135bfe"
      },
      "id": "ee99b6bc51135bfe",
      "type": "add",
      "after": "636a4e94feb2c4fd",
      "date": 1660208495574
    },
    {
      "type": "edit",
      "id": "ee99b6bc51135bfe",
      "item": {
        "type": "paragraph",
        "id": "ee99b6bc51135bfe",
        "text": "Since we will be considering the traversal of a space, the first thing we should consider is the shape of the space in question. The Smalltalk image can be seen in many ways, but as we are interested in references, we could take a look at it from a garbage collection point of view."
      },
      "date": 1660208516613
    },
    {
      "type": "edit",
      "id": "ee99b6bc51135bfe",
      "item": {
        "type": "paragraph",
        "id": "ee99b6bc51135bfe",
        "text": "With these intentions, the image “starts” at some globally visible object that is considered to be not garbage by convention. Typically, this is the Smalltalk dictionary. Anything that is directly or indirectly referenced by this non garbage"
      },
      "date": 1660208525000
    },
    {
      "type": "edit",
      "id": "ee99b6bc51135bfe",
      "item": {
        "type": "paragraph",
        "id": "ee99b6bc51135bfe",
        "text": "With these intentions, the image “starts” at some globally visible object that is considered to be not garbage by convention. Typically, this is the Smalltalk dictionary. Anything that is directly or indirectly referenced by this non garbage context is said to be not garbage either."
      },
      "date": 1660208532282
    },
    {
      "type": "edit",
      "id": "ee99b6bc51135bfe",
      "item": {
        "type": "paragraph",
        "id": "ee99b6bc51135bfe",
        "text": "With these intentions, the image “starts” at some globally visible object that is considered to be not garbage by convention. Typically, this is the `Smalltalk` dictionary. Anything that is directly or indirectly referenced by this non garbage context is said to be not garbage either."
      },
      "date": 1660208552199
    },
    {
      "type": "edit",
      "id": "ee99b6bc51135bfe",
      "item": {
        "type": "markdown",
        "id": "ee99b6bc51135bfe",
        "text": "With these intentions, the image “starts” at some globally visible object that is considered to be not garbage by convention. Typically, this is the `Smalltalk` dictionary. Anything that is directly or indirectly referenced by this non garbage context is said to be not garbage either."
      },
      "date": 1660208553640
    },
    {
      "item": {
        "type": "factory",
        "id": "7c02fc31a5821b64"
      },
      "id": "7c02fc31a5821b64",
      "type": "add",
      "after": "ee99b6bc51135bfe",
      "date": 1660208589870
    },
    {
      "type": "edit",
      "id": "7c02fc31a5821b64",
      "item": {
        "type": "paragraph",
        "id": "7c02fc31a5821b64",
        "text": "And what is a reference? If we look at objects from a Smalltalk point of view, references occur via regular instance names. For example, associations reference the values of their key and value instance names. In addition, references also occur by means of index based storage. For instance, arrays reference whatever is stored in any of their integer named slots."
      },
      "date": 1660208592685
    },
    {
      "type": "edit",
      "id": "7c02fc31a5821b64",
      "item": {
        "type": "paragraph",
        "id": "7c02fc31a5821b64",
        "text": "And what is a reference? If we look at objects from a Smalltalk point of view, references occur via regular instance names. For example, associations reference the values of their `key` and `value` instance names. In addition, references also occur by means of index based storage. For instance, arrays reference whatever is stored in any of their integer named slots."
      },
      "date": 1660208609184
    },
    {
      "type": "edit",
      "id": "7c02fc31a5821b64",
      "item": {
        "type": "markdown",
        "id": "7c02fc31a5821b64",
        "text": "And what is a reference? If we look at objects from a Smalltalk point of view, references occur via regular instance names. For example, associations reference the values of their `key` and `value` instance names. In addition, references also occur by means of index based storage. For instance, arrays reference whatever is stored in any of their integer named slots."
      },
      "date": 1660208612026
    },
    {
      "item": {
        "type": "factory",
        "id": "783859eee629793a"
      },
      "id": "783859eee629793a",
      "type": "add",
      "after": "7c02fc31a5821b64",
      "date": 1660208703944
    },
    {
      "type": "edit",
      "id": "783859eee629793a",
      "item": {
        "type": "paragraph",
        "id": "783859eee629793a",
        "text": "These are the only ways in which an object can reference another object. This is because things like class names and pool dictionaries are implemented in terms of instance names or integer named slots."
      },
      "date": 1660208722825
    },
    {
      "item": {
        "type": "factory",
        "id": "2c377fea39dbb238"
      },
      "id": "2c377fea39dbb238",
      "type": "add",
      "after": "783859eee629793a",
      "date": 1660208734670
    },
    {
      "type": "edit",
      "id": "2c377fea39dbb238",
      "item": {
        "type": "paragraph",
        "id": "2c377fea39dbb238",
        "text": "So it seems we could think of the Smalltalk image as a tree starting at Smalltalk. But since the leaves could easily reference their parents or even Smalltalk itself, it does not quite qualify as a tree. In reality, it is a graph where nodes are objects and references are represented by arrows connecting the nodes."
      },
      "date": 1660208737887
    },
    {
      "type": "edit",
      "id": "2c377fea39dbb238",
      "item": {
        "type": "paragraph",
        "id": "2c377fea39dbb238",
        "text": "So it seems we could think of the Smalltalk image as a tree starting at `Smalltalk`. But since the leaves could easily reference their parents or even Smalltalk itself, it does not quite qualify as a tree. In reality, it is a graph where nodes are objects and references are represented by arrows connecting the nodes."
      },
      "date": 1660208751426
    },
    {
      "type": "edit",
      "id": "2c377fea39dbb238",
      "item": {
        "type": "markdown",
        "id": "2c377fea39dbb238",
        "text": "So it seems we could think of the Smalltalk image as a tree starting at `Smalltalk`. But since the leaves could easily reference their parents or even Smalltalk itself, it does not quite qualify as a tree. In reality, it is a graph where nodes are objects and references are represented by arrows connecting the nodes."
      },
      "date": 1660208753902
    },
    {
      "type": "edit",
      "id": "2c377fea39dbb238",
      "item": {
        "type": "markdown",
        "id": "2c377fea39dbb238",
        "text": "So it seems we could think of the Smalltalk image as a tree starting at `Smalltalk`. But since the leaves could easily reference their parents or even `Smalltalk` itself, it does not quite qualify as a tree. In reality, it is a graph where nodes are objects and references are represented by arrows connecting the nodes."
      },
      "date": 1660208771244
    },
    {
      "type": "edit",
      "id": "2c377fea39dbb238",
      "item": {
        "type": "markdown",
        "id": "2c377fea39dbb238",
        "text": "So it seems we could think of the Smalltalk image as a tree starting at `Smalltalk`. But since the leaves could easily reference their parents or even `Smalltalk` itself, it does not quite qualify as a tree. In reality, it is a graph where nodes are objects and references are represented by arrows connecting the nodes.\n"
      },
      "date": 1660208805667
    },
    {
      "type": "add",
      "id": "b7a8de35ef3bcb4b",
      "item": {
        "type": "markdown",
        "id": "b7a8de35ef3bcb4b",
        "text": "Interestingly, the node for Smalltalk is not special by itself. We just start traversing the graph from this node only because of our convention to never consider it garbage1."
      },
      "after": "2c377fea39dbb238",
      "date": 1660208806472
    },
    {
      "type": "edit",
      "id": "b7a8de35ef3bcb4b",
      "item": {
        "type": "markdown",
        "id": "b7a8de35ef3bcb4b",
        "text": "Interestingly, the node for Smalltalk is not special by itself. We just start traversing the graph from this node only because of our convention to never consider it garbage.\n"
      },
      "date": 1660208821383
    },
    {
      "type": "add",
      "id": "7d84e96a783ddd9a",
      "item": {
        "type": "markdown",
        "id": "7d84e96a783ddd9a",
        "text": "To be more precise, we are interest in finding out all the objects that are connected to Smalltalk. The fact that we are going to say they are not garbage does not matter as far as the connectedness check itself is concerned."
      },
      "after": "b7a8de35ef3bcb4b",
      "date": 1660208822015
    },
    {
      "type": "edit",
      "id": "7d84e96a783ddd9a",
      "item": {
        "type": "markdown",
        "id": "7d84e96a783ddd9a",
        "text": "To be more precise, we are interest in finding out all the objects that are connected to `Smalltalk`. The fact that we are going to say they are not garbage does not matter as far as the connectedness check itself is concerned."
      },
      "date": 1660208833923
    },
    {
      "item": {
        "type": "factory",
        "id": "2737829639263042"
      },
      "id": "2737829639263042",
      "type": "add",
      "after": "7d84e96a783ddd9a",
      "date": 1660208861274
    },
    {
      "type": "edit",
      "id": "2737829639263042",
      "item": {
        "type": "paragraph",
        "id": "2737829639263042",
        "text": "Also, note how the arrows only have one direction: no object has immediate knowledge of where it is referenced from. This is why tools like a reference finder become necessary so that we can derive this knowledge from the graph."
      },
      "date": 1660208862876
    },
    {
      "item": {
        "type": "factory",
        "id": "2bab33c37b13117d"
      },
      "id": "2bab33c37b13117d",
      "type": "add",
      "after": "2737829639263042",
      "date": 1660208881690
    },
    {
      "type": "edit",
      "id": "2bab33c37b13117d",
      "item": {
        "type": "paragraph",
        "id": "2bab33c37b13117d",
        "text": "The truly interesting references to an object are the ones that occur closest to `Smalltalk`. Since these are the most natural reference paths, we should build a breadth first reference finder — one that works as some sort of onion peeler in reverse."
      },
      "date": 1660208893827
    },
    {
      "type": "edit",
      "id": "2bab33c37b13117d",
      "item": {
        "type": "markdown",
        "id": "2bab33c37b13117d",
        "text": "The truly interesting references to an object are the ones that occur closest to `Smalltalk`. Since these are the most natural reference paths, we should build a breadth first reference finder — one that works as some sort of onion peeler in reverse."
      },
      "date": 1660208897408
    },
    {
      "item": {
        "type": "factory",
        "id": "669f283bbf8daad4"
      },
      "id": "669f283bbf8daad4",
      "type": "add",
      "after": "2bab33c37b13117d",
      "date": 1660208923589
    },
    {
      "type": "edit",
      "id": "669f283bbf8daad4",
      "item": {
        "type": "paragraph",
        "id": "669f283bbf8daad4",
        "text": "Unfortunately, the nature of the space and the implementation techniques available make it too easy to implement depth first reference finders instead. For example, we could let an object iterate over instance names and indexable slots. However, this forces the static context to remember which ones it chose to dive through, and things typically get quite complicated soon thereafter. As if managing that iteration was not difficult enough already!"
      },
      "date": 1660208925305
    },
    {
      "item": {
        "type": "factory",
        "id": "7a816e499bc39f74"
      },
      "id": "7a816e499bc39f74",
      "type": "add",
      "after": "669f283bbf8daad4",
      "date": 1660208950338
    },
    {
      "type": "edit",
      "id": "7a816e499bc39f74",
      "item": {
        "type": "paragraph",
        "id": "7a816e499bc39f74",
        "text": "We could also try to take advantage of an existing primitive that answers where a given object is directly referenced from. But, alas, the answer of this primitive leaves us with figuring out a breadth first path from `Smalltalk` to the object in question, while the information we are provided happens to be oriented in a direction opposite to the one we want. Making sense out of the result is typically left as an exercise for the developer. Sorting through the mess of false"
      },
      "date": 1660208965422
    },
    {
      "type": "edit",
      "id": "7a816e499bc39f74",
      "item": {
        "type": "markdown",
        "id": "7a816e499bc39f74",
        "text": "We could also try to take advantage of an existing primitive that answers where a given object is directly referenced from. But, alas, the answer of this primitive leaves us with figuring out a breadth first path from `Smalltalk` to the object in question, while the information we are provided happens to be oriented in a direction opposite to the one we want. Making sense out of the result is typically left as an exercise for the developer. Sorting through the mess of false"
      },
      "date": 1660208966612
    },
    {
      "type": "edit",
      "id": "7a816e499bc39f74",
      "item": {
        "type": "markdown",
        "id": "7a816e499bc39f74",
        "text": "We could also try to take advantage of an existing primitive that answers where a given object is directly referenced from. But, alas, the answer of this primitive leaves us with figuring out a breadth first path from `Smalltalk` to the object in question, while the information we are provided happens to be oriented in a direction opposite to the one we want. Making sense out of the result is typically left as an exercise for the developer. Sorting through the mess of false positives, even when done mechanically, takes a lot of time and effort."
      },
      "date": 1660208985331
    },
    {
      "item": {
        "type": "factory",
        "id": "81dfa82e4af5a934"
      },
      "id": "81dfa82e4af5a934",
      "type": "add",
      "after": "7a816e499bc39f74",
      "date": 1660209002124
    },
    {
      "type": "edit",
      "id": "81dfa82e4af5a934",
      "item": {
        "type": "paragraph",
        "id": "81dfa82e4af5a934",
        "text": "To summarize, while these techniques make it very easy to implement a depth first reference finder, the problem is that depth first traversal has the irritating behavior of producing extremely long and convoluted reference paths. What we need is a breadth first reference finder, and these tools give us no easy way to implement one. It looks like this is going nowhere."
      },
      "date": 1660209003961
    },
    {
      "item": {
        "type": "factory",
        "id": "452bb4ff8cc03d2a"
      },
      "id": "452bb4ff8cc03d2a",
      "type": "add",
      "after": "81dfa82e4af5a934",
      "date": 1660209028073
    },
    {
      "type": "edit",
      "id": "452bb4ff8cc03d2a",
      "item": {
        "type": "paragraph",
        "id": "452bb4ff8cc03d2a",
        "text": "But there is another way to take a look at objects and their mechanisms for referencing other objects. What if we saw the reference graph in terms of forms and distinctions instead?"
      },
      "date": 1660209030780
    },
    {
      "item": {
        "type": "factory",
        "id": "f37079a8f4fff32e"
      },
      "id": "f37079a8f4fff32e",
      "type": "add",
      "after": "452bb4ff8cc03d2a",
      "date": 1660209056018
    },
    {
      "type": "edit",
      "id": "f37079a8f4fff32e",
      "item": {
        "type": "paragraph",
        "id": "f37079a8f4fff32e",
        "text": "– [[Distinctions, Forms, and Objects]]"
      },
      "date": 1660209063638
    },
    {
      "type": "edit",
      "id": "f37079a8f4fff32e",
      "item": {
        "type": "paragraph",
        "id": "f37079a8f4fff32e",
        "text": "⇒ [[Distinctions, Forms, and Objects]]"
      },
      "date": 1660217415740
    },
    {
      "item": {
        "type": "factory",
        "id": "98599762d152305b"
      },
      "id": "98599762d152305b",
      "type": "add",
      "after": "f37079a8f4fff32e",
      "date": 1660219603985
    },
    {
      "type": "edit",
      "id": "98599762d152305b",
      "item": {
        "type": "pagefold",
        "id": "98599762d152305b",
        "text": "~"
      },
      "date": 1660219608979
    },
    {
      "item": {
        "type": "factory",
        "id": "20ccf38878bbf9cb"
      },
      "id": "20ccf38878bbf9cb",
      "type": "add",
      "after": "98599762d152305b",
      "date": 1660219610559
    },
    {
      "type": "edit",
      "id": "20ccf38878bbf9cb",
      "item": {
        "type": "paragraph",
        "id": "20ccf38878bbf9cb",
        "text": "Section "
      },
      "date": 1660219614490
    },
    {
      "type": "edit",
      "id": "20ccf38878bbf9cb",
      "item": {
        "type": "paragraph",
        "id": "20ccf38878bbf9cb",
        "text": "Section 5.2 of"
      },
      "date": 1660219627105
    },
    {
      "type": "edit",
      "id": "20ccf38878bbf9cb",
      "item": {
        "type": "paragraph",
        "id": "20ccf38878bbf9cb",
        "text": "Section 5.2 of [[A Mentoring Course on Smalltalk]]"
      },
      "date": 1660219637271
    },
    {
      "type": "edit",
      "id": "20ccf38878bbf9cb",
      "item": {
        "type": "paragraph",
        "id": "20ccf38878bbf9cb",
        "text": "Section 5.2 of [[A Mentoring Course on Smalltalk]], [[An Efficient Reference Finder]]"
      },
      "date": 1660219659455
    }
  ]
}