{
  "title": "Functional Programming",
  "story": [
    {
      "type": "html",
      "text": "[[Functional Programming]] is when functions, not objects or procedures, are used as the fundamental building blocks of a program. Functions in this sense, not to be confused with [[Cee Language]] functions which are just procedures, are analogous to mathematical equations: they declare a relationship between two or more entities.",
      "id": "79efe5d4e37bb1442c5ec396bbf09aad"
    },
    {
      "type": "html",
      "text": "\n[[Functional Programming]], however, is not about mathematics but about abstraction and reducing complexity: as such, it provides a powerful paradigm in which to tackle complex, real-world programming tasks.",
      "id": "4736be22622c63dc801aaaf09b060ac6"
    },
    {
      "type": "html",
      "text": "\n[[Functional Programming Language]]s, which support this style of programming, provide at least some of the following features:",
      "id": "b39216dfe4012f2d396ac22ba0af271c"
    },
    {
      "type": "html",
      "text": " [[First Class]] functions",
      "id": "d9fc2f99084c5e251fdd38ab34b0844b"
    },
    {
      "type": "html",
      "text": " [[Higher Order Function]]s",
      "id": "3d649f86e857ada54c826f95d6103226"
    },
    {
      "type": "html",
      "text": " [[Lexical Closure]]s",
      "id": "97b1bf5d46c56f56bbf1b9c9211158e1"
    },
    {
      "type": "html",
      "text": " [[Pattern Matching]]",
      "id": "c9bc8babf8c33b52dc5f7daad837a9c5"
    },
    {
      "type": "html",
      "text": " [[Single Assignment]]",
      "id": "be81975a814fe761ecc9b07c5a390d45"
    },
    {
      "type": "html",
      "text": " [[Lazy Evaluation]]",
      "id": "f4a419144b461ef13b829e00ac6026cf"
    },
    {
      "type": "html",
      "text": " [[Garbage Collection]]",
      "id": "b2ae3461cf245b6db38ac0e06588a7da"
    },
    {
      "type": "html",
      "text": " [[Type Inference]]",
      "id": "73299f221f92c7537629a8f2efb3025b"
    },
    {
      "type": "html",
      "text": " [[Tail Call Optimization]]",
      "id": "23da7c3e380829f27fcc5db0f31f3717"
    },
    {
      "type": "html",
      "text": " [[List Comprehension]]s",
      "id": "dbc3624bfb86727a808ea08519d3d919"
    },
    {
      "type": "html",
      "text": " Monadic effects [[[On Monads]]]",
      "id": "abf27476da03350a7cae9976af542980"
    },
    {
      "type": "html",
      "text": "\nThese features enable or support the following aims:",
      "id": "5e3179c72499fc52cd9d120061edd2c1"
    },
    {
      "type": "html",
      "text": " shorter programs (lower lines-to-effect ratio)",
      "id": "0249f02a7aa188664e6e0bd1cd93ddda"
    },
    {
      "type": "html",
      "text": " program correctness",
      "id": "29b0805c5a70907a6c661ff742e42233"
    },
    {
      "type": "html",
      "text": " expressive programs",
      "id": "bfd5403ced781f99f9581e3682d05024"
    },
    {
      "type": "html",
      "text": "... and thus overall improved productivity. [[Functional Programming]] is also very enjoyable.",
      "id": "53eda9494ec2b310c961543ae4da36f1"
    },
    {
      "type": "html",
      "text": "\nAlthough some of these features exist in [[Object Oriented]] languages, or may be simulated via [[Object Functional Patterns]], [[Functional Programming]] really requires (and allows) a paradigm shift. [[Object Functional]] languages try to combine the best of both worlds.",
      "id": "4f0067f3a32ba4a2683a70d704f7eb89"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "<b>Books</b>",
      "id": "48db4b18747f0f74659b6c09f847d64d"
    },
    {
      "type": "html",
      "text": " [[Purely Functional Data Structures]]",
      "id": "e373f658bb32e1a14b3da4a63b8f9459"
    },
    {
      "type": "html",
      "text": " [[Type Theory And Functional Programming]]",
      "id": "ef690af693994bcd8c46905b63a6a402"
    },
    {
      "type": "html",
      "text": " Khan, Aslam. Grokking Functional Programming. Manning Publications (2015). p. 475. ISBN 9781617291838",
      "id": "c2b02034f340723cea0f3622c662d23b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "This document [http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html www.ccs.neu.edu] is a very good explanation of [[Functional Programming]]. It gently takes you through the features, and may produce that required paradigm shift. -- [[Peter Lynch]] ",
      "id": "bab7c8ff73dc763f3fd5d4bde7841b83"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "\nA classic example, to provide a feel for what [[Functional Programming]] is like, is the [[Quick Sort]] algorithm, using [[Pattern Matching]], [[List Comprehension]]s and recursion.",
      "id": "c38be5ad51eee61929fd9f796297a140"
    },
    {
      "type": "html",
      "text": "\nIn [[Haskell Language]] (see [[Quick Sort In Haskell]]):",
      "id": "8195dca1f46cf164e5cf406b8efce1ab"
    },
    {
      "type": "code",
      "text": " qsort []  = []\n qsort (x:xs) = qsort elts_lt_x ++ [x] ++ qsort elts_greq_x\n      where\n      elts_lt_x  = [y | y <- xs, y < x]\n      elts_greq_x = [y | y <- xs, y >= x]",
      "id": "b385cca53d1e86f9722121341bb63790"
    },
    {
      "type": "html",
      "text": "\nOr, taking advantage of the [[Filter Function]] and of Sections (still in [[Haskell Language]]):",
      "id": "4d621e462245bd54d057c09d4f1afc1d"
    },
    {
      "type": "code",
      "text": " qsort []  = []\n qsort (x:xs) = (qsort (filter (<x) xs)) ++ [x] ++ (qsort (filter (>=x) xs))",
      "id": "dbd2186710b00da402a88690032ca546"
    },
    {
      "type": "html",
      "text": "\nOr with partition (still in [[Haskell Language]]):",
      "id": "79953010613ef422982a97c3805c7082"
    },
    {
      "type": "code",
      "text": " qsort []  = []\n qsort (x:xs) = qsort lt ++ [x] ++ qsort gte\n  where (lt,gte) = partition (<x) xs",
      "id": "bd22d3d8840c74533cfd34465c7b14c0"
    },
    {
      "type": "html",
      "text": "\nIn [[Erlang Language]]:",
      "id": "fd1397d028bdd7fb9e673f7d111cd047"
    },
    {
      "type": "code",
      "text": " qsort([]) -> []; \n qsort([X|T]) ->\n  ElementsLessThanX = [Y || Y<-T, Y<X],\n  ElementsGreaterEqualToX = [Y || Y<-T, Y>=X],\n  [qsort(ElementsLessThanX),X,qsort(ElementsGreaterEqualToX)].",
      "id": "e2bbf681cd57db43acfeda97ebb44786"
    },
    {
      "type": "html",
      "text": "<i>A stray thought: These implementations of [[Quick Sort]] have in common that they use the first element as a pivot. This is a very bad choice of pivot, because it tends to make the execution time quadratic when the input is already sorted. This undesirable property is not a forced consequence of functional programming, but because functional languages tend to prefer list-like data structures, the simple implementations of [[Quick Sort]] tend to have that drawback. For this reason, I think that [[Merge Sort]] is often a better choice for functional languages. --[[Andrew Koenig]]</i>",
      "id": "045722a49eb0f8f524b7dec8e83bfb91"
    },
    {
      "type": "html",
      "text": "\nThe also have in common that two of them use [[Syntactic Sugar]] to perform the list filtering. For that reason, the second Haskell implementation is a better example here, since it shows off a more normal [[Higher Order Function]] than the first implementation, which is a little more of a trick. At least the way I see it. ",
      "id": "8d6dd51175fa3e496b9f24c69ebdbdcd"
    },
    {
      "type": "html",
      "text": "<i>[[Andrew Koenig]]'s comment about [[Merge Sort]] being a better fit for functional programming than [[Quick Sort]] is borne out by experiment. In 2002, the GHC implementation of Haskell replaced the stable [[Quick Sort]] implementation in its standard library with [[Merge Sort]]:</i>",
      "id": "5cd7e40b5af7cb4a35941ec884076009"
    },
    {
      "type": "code",
      "text": " sortBy cmp l = mergesort cmp l\n sort l = mergesort compare l",
      "id": "f95c829a3866f641b89d665ac58d0e2e"
    },
    {
      "type": "html",
      "text": "mergesort ::<br>(a -> a -> Ordering) -> [a] -> [a]",
      "id": "d82b24c0c61b3e88a802b8469506b543"
    },
    {
      "type": "code",
      "text": " mergesort cmp = mergesort' cmp . map wrap",
      "id": "70d6fb8976ed96d5d151419ebec91397"
    },
    {
      "type": "html",
      "text": "mergesort' ::<br>(a -> a -> Ordering) -> [[a]] -> [a]",
      "id": "e1891b964b6f166a29e8486f41d447f0"
    },
    {
      "type": "code",
      "text": " mergesort' cmp [] = []\n mergesort' cmp [xs] = xs\n mergesort' cmp xss = mergesort' cmp (merge_pairs cmp xss)",
      "id": "89125d4c59efddf07d30377be3af4434"
    },
    {
      "type": "html",
      "text": "merge_pairs ::<br>(a -> a -> Ordering) -> [[a]] -> [[a]]",
      "id": "0c5a3a776667ac2813c2e4ee60a811b5"
    },
    {
      "type": "code",
      "text": " merge_pairs cmp [] = []\n merge_pairs cmp [xs] = [xs]\n merge_pairs cmp (xs:ys:xss) = merge cmp xs ys : merge_pairs cmp xss",
      "id": "69bc28328f1bc98bdbfe1312e07ee6c2"
    },
    {
      "type": "html",
      "text": "merge ::<br>(a -> a -> Ordering) -> [a] -> [a] -> [a]",
      "id": "97e4c2685c17e249309b9b468e666037"
    },
    {
      "type": "code",
      "text": " merge cmp xs [] = xs\n merge cmp [] ys = ys\n merge cmp (x:xs) (y:ys)\n  = case x `cmp` y of\n         GT -> y : merge cmp (x:xs)   ys\n         _  -> x : merge cmp    xs (y:ys)",
      "id": "5dcef8f7ff5527ebeada5ad2d5b0e70b"
    },
    {
      "type": "html",
      "text": "wrap ::<br>a -> [a]",
      "id": "7d33d47e5e21a5e7d42ed079d8d50df6"
    },
    {
      "type": "code",
      "text": " wrap x = [x]",
      "id": "662704b32026e17e089661fa06e10a2e"
    },
    {
      "type": "html",
      "text": "<i>The accompanying documentation confirms [[Andrew Koenig]]'s suspicion about [[Merge Sort]] being quicker, but also says that [[Merge Sort]] uses far more memory.</i>",
      "id": "73a824a71ae072f01151a72614f5ccd1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "\nAn important part of (pure) [[Functional Programming]] philosophy is [[Referential Transparency]], which requires writing [[Side Effect Free]] functions. In order to encourage this, variables are [[Single Assignment]], or immutable: once they are initialized, their value cannot be changed. Arguments to functions may only be passed by value, and rather than modify arguments, functions must return new variables.",
      "id": "b9f4025ce73067870038eb3bb4c2228c"
    },
    {
      "type": "html",
      "text": "\nThis alone has several implications on the style of programming (compiler implementation and performance aspects are discussed later):",
      "id": "31cb420b055948854622ba45ae72628b"
    },
    {
      "type": "html",
      "text": " Since functions cannot modify  arguments, they need to be able to return more than one piece of information: therefore tuples and lists are widely used, and may be created on the fly in most [[Functional Programming Language]]s.",
      "id": "b2f180574b379abc22998c78ed4bc920"
    },
    {
      "type": "html",
      "text": " Since variables, even within functions, are immutable, writing loops using counters is impossible or at best unwieldy: the dominant style of algorithm is therefore recursive.",
      "id": "a447b2a35ee5dcac910eb146ac1f612a"
    },
    {
      "type": "html",
      "text": " Since functions cannot modify variables, they cannot store state between successive calls. Thus data and functions are kept completely separate, which is the opposite philosophy to [[Object Oriented]] encapsulation.",
      "id": "b5a18e1ec31b5b064a1b3aebb64a86cd"
    },
    {
      "type": "html",
      "text": " There may be a need for a data structure to represent the global state and top-level functions that operate on the global state. Most other functions only operate on a small part of the data, so the top-level functions extract pieces of the global state, pass them to lower-level functions, and construct a new global state using the results. (Incidentally, this makes it trivial to instantiate multiple copies of the entire application. For example, maintain a copy of the entire program state as it existed five minutes ago, and revert to it if there is an error.)",
      "id": "c0e27dc40a4be264fe77e3d47d1d4b6d"
    },
    {
      "type": "html",
      "text": " The emphasis is on writing pure, generic functions which could work in any environment, and choosing actual program behaviour at the top of the call hierarchy. This is in contrast to [[Object Oriented]] programming which encourages pushing behaviour into class methods and making decisions low down by overriding them in subclasses. (Document example moved to [[Functional Modeling]]).",
      "id": "9f12032c03258630e7fa8caa5cc94d99"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "\n[[Single Assignment]], [[Call By Value]] and recursion comes with an implementation cost: lots of garbage generation, potentially huge stack, and lots of copying. In a naive implementation, all state changes generate garbage. Functional languages have optimizing compilers to get rid of the bloat with tricks such as turning copying code into modify-in-place behind the scenes, and [[Tail Call Optimization]]. On the one hand, functional languages provide many more opportunities for optimization, since everything can be inlined and refactored safely by the compiler. On the other hand, functional programs require a good optimizer to get decent performance. Some languages have automatic [[Lazy Evaluation]].",
      "id": "7a78365158cc98101762b417c698fbff"
    },
    {
      "type": "html",
      "text": "<i>Functional languages do not require good optimizers, that is a myth. For example, OCaml, one of the most performant functional languages around, uses a straightforward compiler that has a well-designed compilation scheme but does no fancy optimizations at all. What you need, though, is a well-engineered runtime system. In particular, you want to optimize your memory layout and garbage collector for small objects, high allocation rates, and short lifetimes. That is quite different from a typical OO runtime.</i>",
      "id": "7c1a60dc6bb1b8b8dd49196bef249ec1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "\nSee also the following Wiki pages:",
      "id": "d12396faabc896a89f323c681bef9849"
    },
    {
      "type": "html",
      "text": " [[Advantages Of Functional Programming]]",
      "id": "3aac921fd80aa2e4e1a6882c4b7f6e79"
    },
    {
      "type": "html",
      "text": " [[Fp Vs Oo]] and [[Oo Vs Functional]]",
      "id": "b03f1cee391e36287f41ac21e349d69e"
    },
    {
      "type": "html",
      "text": " [[Functional Modeling]]",
      "id": "fece8298e54535d430f07af886a98127"
    },
    {
      "type": "html",
      "text": " [[Currying Schonfinkelling]]",
      "id": "dd451b004c1a2b2b6c5fb9dee59cd973"
    },
    {
      "type": "html",
      "text": " [[Lambda Calculus]]",
      "id": "934b049766b4a47d3d3b9a4681f33181"
    },
    {
      "type": "html",
      "text": " [[Functional Programming Language]]s",
      "id": "fcb2de10ba209e3702ba5a3b3a66b55d"
    },
    {
      "type": "html",
      "text": " [[Functional Imperative Rosetta Stone]]",
      "id": "cee036090e50edb393ceebae69d080b3"
    },
    {
      "type": "html",
      "text": " [[Functional Programming In Cpp]]",
      "id": "e9d50f0adb7c99f00a1b2fccc211bf56"
    },
    {
      "type": "html",
      "text": "\nSome external links:",
      "id": "8bdc1196f400b3fd0416748d135edc0d"
    },
    {
      "type": "html",
      "text": " [[John Hughes]] classic paper [[Why Functional Programming Matters]]",
      "id": "9fb6945201cdbbf41b949c4fd89d2fcb"
    },
    {
      "type": "html",
      "text": " FAQ for comp.lang.functional: [http://www.cs.nott.ac.uk/~gmh/faq.html www.cs.nott.ac.uk]",
      "id": "f685a08fce0438480d8e9011313114de"
    },
    {
      "type": "html",
      "text": " List of real-world applications using [[Functional Programming]]: [http://homepages.inf.ed.ac.uk/wadler/realworld/ homepages.inf.ed.ac.uk]",
      "id": "a3943cbb2352ee5f9ffc278f9e55a44c"
    },
    {
      "type": "html",
      "text": " Discussion of the relationship between [[Functional Programming]] and [[Flow Based Programming]] in [http://www.jpaulmorrison.com/fbp/recurs.htm www.jpaulmorrison.com] - FP people can skip the early section!.",
      "id": "11a39b1eae57174dcf0a95bb8469fc23"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "Supposedly the:",
      "id": "62e826078d6fa9ee8c41d6756debdaa4"
    },
    {
      "type": "html",
      "text": " <b>fun</b> was put in functional programming by STL of C++ fame (?)",
      "id": "74f43117e848f331b023e1552560e95c"
    },
    {
      "type": "html",
      "text": " <b>funk</b> was put in functional programming by Haskell (?)",
      "id": "a60ed22bc89492bf3c6341672e36dc5f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "<b>Discussion:</b>",
      "id": "577dce3a28cbc1086bd197545c0a2858"
    },
    {
      "type": "html",
      "text": "\nFunctional programming is pure nonsense.. the print(\"hello world\") is still a procedure in any language (it affects the state and modifies the screen too). It's actually just a big [[Syntax Game]] and a form of <b>different</b> procedural programming. Eventually the program <b>does</b> something. ",
      "id": "262bffe58e5bbdf6a10a13e925ee7f8d"
    },
    {
      "type": "html",
      "text": " Programming in general is intended to cause things to happen, the question is how the things to happen are specified. [[Declarative Programming]] (for example [[Functional Programming]] and [[Logic Programming]]) allow the programmer to concentrate on what has to happen, and let the question of the steps required to make them happen be decided elsewhere.  Just like [[Garbage Collection]], we can automate various things to relieve us of the repetitive minutiae. That's why we have computers.  If you're happier programming in [[Assembly Language]] then please feel free to do so.",
      "id": "45a872aecc5489bdadd56e661b7549c6"
    },
    {
      "type": "html",
      "text": " <i>Gotta love the people who bring up assembly language when that has nothing to do with the discussion, such as the print statement being a procedural call - <b>not</b> declarative.</i>",
      "id": "683b40ff8ea91293a646ae3e48c6cb03"
    },
    {
      "type": "html",
      "text": "<i>Of course functional programs <b>do</b> something. They take in parameters and return a result.</i>",
      "id": "acb49058a193266085e5eb8d6e48ce75"
    },
    {
      "type": "html",
      "text": "<i>It's not true that print() is a procedure in any language. In Haskell, print() returns an IO object. It does NOT affect the state or the screen. Of course, eventually this IO object has to be executed to affect the screen - but the point is that the print function itself does NOT have side effects, and IS referentially transparent.</i>",
      "id": "71674b49f71416f0219ce7f04704d068"
    },
    {
      "type": "html",
      "text": "\nMeh. `print \"foo\"` is essentially a procedure in a [[Domain Specific Language]] called IO. The Haskell print function returns a representation of this procedure. To the extent program logic and behavior is expressed through the IO language, we're doing imperative programming. The fact that the Haskell function is pure is only relevant for reasoning about program construction. Reasoning doesn't stop at program construction, and `print` is definitely not referentially transparent within the IO language.",
      "id": "bae4b033878a2c14e439e174597c1045"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "\nYou could write a Java program that feels very much like a functional program by not using mutable static variables and making all objects immutable. (Local variables don't matter so much because they're well encapsulated.) -- [[Brian Slesinsky]]",
      "id": "a72a2d8d9a0ccf9cea20264e2c7c025e"
    },
    {
      "type": "html",
      "text": "\nAlthough I have not tried this in Java, I would imagine it to be rather difficult and frustrating without the corresponding facilities such as on the fly generation of tuples, list manipulations, and [[Tail Call Optimization]]. Moreover, I don't think that would suffice to make it feel like a functional program. -- [[Dominic Williams]]",
      "id": "09fc2c8290c837d926b16b2fc9863f2e"
    },
    {
      "type": "html",
      "text": "<i>Java is sorely lacking [[Higher Order Function]]s. To effectively write functional programs you want recursion schemata like \"map\" and \"fold\" and these must be polymorphic. While Java can emulate these, wrapping every function in an object is cumbersome at best. You also lose the powerful type system of the ML-family languages.</i>",
      "id": "7b1f819654c7af4e6e8d0f815b1383a4"
    },
    {
      "type": "html",
      "text": "\nIndeed. And then to use [[Higher Order Function]]s a lot, you need real [[Lexical Closure]]s to be easy to write on the fly (not through something cumbersome like [[Anonymous Inner Class]]es). And even with all that (which you do get in [[Ruby Language]]), it still would not feel much like [[Functional Programming]] without [[Pattern Matching]]... -- [[Dominic Williams]].",
      "id": "2889e0b3d39c90d9cc0ad09b3e6efdf7"
    },
    {
      "type": "html",
      "text": "<i>You can write functional like programming in any language, and it gets hard to do in some languages. The question is whether massaging data into more and more functions is useful, especially since performance considerations are still prevalent today on web servers and such (despite what people think with today's processing power). Massaging more functions into more functions isn't any way we can clearly map it to a computer processor in our minds,  and when it comes to mapping the code to the computer - we're at a loss. I many times wonder whether people just throw around phrases like [[Higher Order Function]] just to be be hip and cool, and just to make programming sound complex and hard.  Doing silly stuff like in the below screenshot is hip, and cool, but I really question whether massaging stuff into other functions is the way humans think - and whether the benefits are worthwhile. Recursion, abusing functions instead of clearly written structured code like iterators and loops,  sending other functions into other functions.. that is all academically interesting, But does it get us anywhere? Or really is it just hip, cool, complex, and wizardry? How often do we really need to massage functions into other functions, and reuse functions that pass each other functions? Is it all in people's mind, that this functional magic is so beneficial to society?</i>",
      "id": "20e132f13c6296bfe0420c1f433e68b4"
    },
    {
      "type": "image",
      "url": "http://z505.com/images/imperative-reuse.png",
      "text": "z505.com",
      "id": "f52db2840d5dde5ca3b70baef048de7a"
    },
    {
      "type": "html",
      "text": "\n",
      "id": "ce4a4682440e6ff552c93607d9e969ad"
    },
    {
      "type": "html",
      "text": "<i>In above screenshot I push stuff around into other functions instead of rewriting the same loop each time (reusing chunks of code, similar to how functional programming reuses functions in functions in functions). But really, how useful is this? Is this just wizardry and is it over hyped that the idea of reusing functions inside functions inside functions some how magically improves a programmers life or company profits?</i>",
      "id": "8a3d45f2c3c9583281ba5164cd15ee0d"
    },
    {
      "type": "html",
      "text": " Your \"argument\" seems to be that functional programming doesn't match the way you map processes to computers.  If you only think in terms of fundamental computer operations, then you are limited in your thinking.  If you can't think in higher level abstractions, then you are limited in your thinking.  You appear to suffer from the [[Blub Paradox]].  I suggest you read, and do all the exercises in, the SICP book.  It's a mind-expanding experience.  It's clear from other contributions on this wiki that you'll take no one's advice or experience.",
      "id": "bce7ca8f080d85397bedf99984d0dc41"
    },
    {
      "type": "html",
      "text": " <i>A false dichotomy between low-level thinking and FP. There are plenty of non-FP abstractions that are quite useful. If you measure a benefit and demonstrate the higher numeric score, I will pay attention. But I will ignore most non-scientific hype and bullshit because there's too much of it. The functional fans are sounding a lot like the OOP-everywhere fans of the last decade. [[Blub Paradox]] is FP's version of the [[You Just Dont Get It]] claims of the OOE-ers. <b>Measure it or shove it, FPers!</b> -t</i>",
      "id": "2543d27765afa8510758c06a908779f1"
    },
    {
      "type": "html",
      "text": "\nSee also [[Functional Programming Discussion]]",
      "id": "cea04b8e01baeef77a03662ef988df1d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "<i>How do data items persist?</i>",
      "id": "43abd5c62c948ad16ea90e9cf54b9f31"
    },
    {
      "type": "html",
      "text": "\nOn the stack. In a sequential, batch program, data is initialized and transformed in a top-level function. In a long-lived program like a server, a top level looping function is called recursively, passing global state from one call to the next.",
      "id": "2faf76983bfb06a77b673b19bf40fd5c"
    },
    {
      "type": "html",
      "text": "<i>Pure functional languages have REAL PROBLEMS referring to large stateful objects, because you lose [[Referential Transparency]].</i>",
      "id": "ab2e5b11c80eb6c0d4f3081132feb209"
    },
    {
      "type": "html",
      "text": "\nThis is not true. You can hold state in a top level function, pass bits of it to pure functions, use their results to construct a new global state. There are no side effects here. In practice, a program without side-effects is not very useful, so it is common in functional programs to have mostly pure functions, glued together by some impure stuff. This does not take anything away from the usefulness of the functional paradigm.",
      "id": "750c722bd22ea84624a1da9790f73572"
    },
    {
      "type": "html",
      "text": "<i>Some issues with representing state: modifying an element of an array in a functional language is inefficient because you have to copy the whole array (though the compiler could optimize this out if you throw away the reference to the old copy). Tree structures might be more efficient since you only copy the nodes from the root to the element being modified. It seems like it would be rather hard to know whether code is efficient because many ways of optimizing code cannot be expressed - the compiler must do it for you.</i>",
      "id": "8228c35aef86995243c5903d86aec74c"
    },
    {
      "type": "html",
      "text": "\nMost [[Functional Programming Language]]s use lists and tuples (from which arbitrary structures may be built), not arrays. Moreover, the functional paradigm aims to be at a more abstract level: such implementation details are left to optimizing compilers.",
      "id": "1181ec280dede21d8206f188ac6bb59d"
    },
    {
      "type": "html",
      "text": "<i>I think I am missing something rather basic. How is a data value ever changed (or even entered)? If someone mistypes a text string, how does correcting it in a clone class help?</i>",
      "id": "c43e116aeed486d6bc1ff45c3ecb92ba"
    },
    {
      "type": "html",
      "text": "\nAssuming you're familiar with java: How do you deal with a String object that's been mistyped? You create a new, corrected String, and throw away the old one. It's the same thing here.",
      "id": "253fe684fd1119184253f4cd4dca84c2"
    },
    {
      "type": "html",
      "text": "<i>Pure functional languages preclude any sort of side effect. Not only can no data be modified in place, it is also impossible to change bits on persistent storage or even read input from somewhere. Clearly, no interactive program can be written this way. Three solutions are in use:</i>",
      "id": "0b57a8ec845ca66ab14fe8088a557b5d"
    },
    {
      "type": "html",
      "text": " Represent input and output as lists of commands to some enclosing system. Many of these stream processors can be combined. Though this is somewhat cumbersome, it works. In the [[Fudgets Library]] such a design has actually worked out pretty well.",
      "id": "500b75c2b7cfc5c1abf34fe62f4d1554"
    },
    {
      "type": "html",
      "text": " Extend the type system with data types that can be used only once ([[Unique Type]]s). As the old value becomes inaccessible, the program doesn't mind if the compiler decides to do an in-place update. The world is represented by a special token and side-effecting functions conceptually produce a new world. [[Clean Language]] does this. It works, though the explicit passing around of the world can get annoying.",
      "id": "0f865b5049334a79a6259c5cf9811a36"
    },
    {
      "type": "html",
      "text": " Use monads to hide the state (see [[On Monads]]). The hidden state can be queried, but old values are inaccessible. As with [[Unique Type]]s it doesn't matter if an in-place update is done behind the scenes. [[Haskell Language]] does this. [[Monadic Programming]] is actually quite convenient, not only for hiding side effects. If overdone, it starts looking like procedural code.",
      "id": "29c4fbf5fc57fe2ce5aa87c065c39e8c"
    },
    {
      "type": "html",
      "text": "<i>Concerning the need for mutable state: it is needed for truly interactive programs, in one form or another. <b>Many programs are not that interactive, they can be neatly split into input, processing and output. Such programs work really well in a pure functional setting.</b> In [[Haskell Language]] it is quite common to write a monadic main function that does input, calls processing, then does output.</i>",
      "id": "b65f735089819d2f77a9f4655574bfc4"
    },
    {
      "type": "html",
      "text": "<i>Apart from that there are some algorithms that seem to incur an inefficiency if done purely functional. These are algorithms with state that is to be mutated in random order with constant access time, graph algorithms are typical. Without mutable arrays, the run time takes an additional logarithmic hit. [[Haskell Language]] provides mutable arrays, of course hidden in a monad, exactly for this reason.</i>",
      "id": "7a07c0fe69bdfe0cf61c62a1759550bd"
    },
    {
      "type": "html",
      "text": "\nThe highlighted part is really insightful. (Similar idea to the [[Unix Way]]). Probably the majority of code being written is devoted to reading [[Data Base]]'s and emitting [[Extensible Markup Language]], or vice versa, or one or the other, or something similar. <i>If this is what you're doing anyway</i>, pure FP loses you nothing and gains you a whole lot of bug-proofing.",
      "id": "27d0481afa3a634ea69eedf9f79b79d9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "\nI don't know much about garbage collection, but I've been interested to hear about a couple of the tricks/properties that are possible with functional languages, Erlang in particular. I'd like to share them with you guys, with the disclaimer that they're just some ideas I heard and like, and I don't know much about how things are implemented in practice. Do correct me on any mistakes I make.",
      "id": "b91a84c1facf0c61eaf0d26480d323e9"
    },
    {
      "type": "html",
      "text": "\nTake a [[Mark And Sweep]] scheme as an example. The basic idea is that you have a \"root set\" of objects that are directly accessible because (depending on the language) they're in global variables, in a stack frame or local variable of an active thread, etc. When you want to garbage collect, you follow all the references out of your root set and \"mark\" each object that you reach. After you've done this, anything that's not marked can be reclaimed. In pseudocode:",
      "id": "ea17110bdfbcc9218d1aa3efb026d5df"
    },
    {
      "type": "code",
      "text": " for each element of root set:\n  spider out through code marking each reachable object\n for each element of heap\n  if (marked) keep\n  else reclaim",
      "id": "f11544cf6e759468d80a2bb93398d42d"
    },
    {
      "type": "html",
      "text": "This process spiders out until it finds every object that can be accessed and marks it, after which time you can walk through the heap from start to finish and throw away anything that's not marked.",
      "id": "52eb0b4a5cb0f12c84ef9f55528a98be"
    },
    {
      "type": "html",
      "text": "\nNow in a language which doesn't support destructive operations, there's a special property: objects can only reference other objects that are older than themselves - because the newer ones didn't exist.",
      "id": "1ceb7df6b8d1a08c6bba117bab63cdfc"
    },
    {
      "type": "html",
      "text": "<i>Note that this property depends on the language implementation not doing certain other optimizations, and usually does not hold for implementations of functional languages that support [[Lazy Evaluation]].</i>",
      "id": "02b3015fd0428e2ab2131a16b9253d16"
    },
    {
      "type": "html",
      "text": "\nNow, suppose you have the objects in the heap sorted by age (very easy with a [[Copying Collector]] for example). The [[Mark And Sweep]] can be simplified into one pass, based on the fact that if an object hasn't been marked by any of the objects newer than itself, then it can't be marked at all due to the lack of forward reference. In pseudocode:",
      "id": "1922ff108255f32c8540881c71f4676b"
    },
    {
      "type": "code",
      "text": " for each object on the heap, newest to oldest:\n  if (marked) mark all directly accessible objects, and keep\n  else reclaim",
      "id": "baaa38cfb608247b7832ef2ee66ffcdc"
    },
    {
      "type": "html",
      "text": "Much faster and simpler. Also, since the heap isn't changing, just being appended to, you can do the GC incrementally very easily.",
      "id": "11997d13a775fc28144fcd7481804ea7"
    },
    {
      "type": "html",
      "text": "\nAlso, in Erlang you have a lot of separate processes, many of which are small and short-lived. Each of these processes has its own heap, and can be garbage collected separately. Now, for short-lived processes which do something quick like send an email and then terminate, it may not be necessary to do a fine-grained GC of the heap - just let it run and make some garbage, and when its finished just throw the whole heap away. So garbage collection can be \"free\" for these short-lived processes, and you may have many of them. -- [[Luke Gorrie]]",
      "id": "81b7ce38d95cf353d0a2dde1b5718cc0"
    },
    {
      "type": "html",
      "text": "<i>Something else thats worth noting about languages without destructive updates, is that [[Reference Counting]] becomes a viable memory management scheme all on its own; cyclic garbage is impossible. Reference counted objects are collected as soon as they are unreachable, which is useful when timing is important. [[Reference Counting]] may be inefficient, but its probably the easiest form of automatic memory management one could implement.</i>",
      "id": "096f92e01ae85d3fd4c2b889210ca92f"
    },
    {
      "type": "html",
      "text": "<b>except for [[Lazy Evaluation]]. With [[Strict Evaluation]], the above holds.</b>",
      "id": "b68ca0a90c330904a5a8265f4c010d81"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "\nWould I be incorrect to say that [[Functional Programming]] can be summarized by this -",
      "id": "c8d07e7934194ef493ad92a0ba05997e"
    },
    {
      "type": "code",
      "text": " \"Result = Process(Data)\"\n Where \"Result\" is the variable representing the output of the function called \"Process\" \n and \"Data\" is the list of arguments?",
      "id": "d1b41df806311e9290ff9e4a7dccb9fb"
    },
    {
      "type": "html",
      "text": "<i>No, it's Result(Process(Data))</i> :)  ",
      "id": "e03e008d4533eec53d948a39803f0d66"
    },
    {
      "type": "html",
      "text": "\nIf so, this appears to me to be the most intuitive interface to programming of all. ",
      "id": "3c815a3ef43e9ebc658f903ae7ac3962"
    },
    {
      "type": "code",
      "text": " For example,\n  Reply = Get Reply(\"Where do you want to go today?\")\n  Customer Address = Get Data(\"Customers\", \"Address\", Customer Id)\n  Choice = Get Selection(\"Please select one of these\", \"Dog,Cat,Fox\")\n  Notify(\"The customer you have selected is a bad payer\")",
      "id": "04346b6d907ae0b32596aef410b62bf6"
    },
    {
      "type": "html",
      "text": "\nGiven that we will one day (soon?) be talking to the machine, is it not a model we will have to embrace eventually anyway? -- [[Peter Lynch]]",
      "id": "d688c72dc851d8a2d45e369c0557eb6b"
    },
    {
      "type": "html",
      "text": "<i>How does \"talking to the machine\" have any bearing on this? Besides the complexity that speech recognition adds, how is talking different from typing? If you mean to imply that functional is somehow more human than the alternatives, or that there is some subset of human requirements that can only be expressed in a functional way, then my reply would be simply:  No, we will not have to embrace the model eventually. (And no, it is not the most intuitive interface of all, although there may be a subset of humanity for which it is more intuitive than, say, the simple imperative, e.g.:</i>",
      "id": "e26cf01f971b1cf0c17190e06152abb7"
    },
    {
      "type": "html",
      "text": "Human:<br>Gas Bill!",
      "id": "965b855031eb625fad7dc1c92505868b"
    },
    {
      "type": "html",
      "text": "Machine:<br>What about it?",
      "id": "42cded7375c8b476d50d823046fc3205"
    },
    {
      "type": "html",
      "text": "Human:<br>Have I paid it?",
      "id": "3a2b671196b6a50b594fa8f91ee1b273"
    },
    {
      "type": "html",
      "text": "Machine:<br>Which one?",
      "id": "eab58eadea61abff7a672e3273cec98b"
    },
    {
      "type": "html",
      "text": "Human:<br>The latest one, of course!",
      "id": "db6a1bb47f10b7887697c312dfdaf6af"
    },
    {
      "type": "html",
      "text": "Machine:<br>You mean April 2004?",
      "id": "c909bc97b6151de300a2e53a8c6b3f69"
    },
    {
      "type": "html",
      "text": "Human:<br>No, there should be one for July...",
      "id": "f24ddbb9f29456c25f45103e4517da95"
    },
    {
      "type": "html",
      "text": "Machine:<br>I don't know anything about that...",
      "id": "6e436c3394e3d464946278059f754e51"
    },
    {
      "type": "html",
      "text": "Human:<br>OK, what's their number?",
      "id": "d0492f648e4f546cd500bb12a6b615a9"
    },
    {
      "type": "html",
      "text": "Machine:<br>Their phone number?",
      "id": "914e7938acf0de911a990a4cce389e7d"
    },
    {
      "type": "html",
      "text": "Human:<br>Yes.",
      "id": "c92b57a6e3b3af222061f88ad64118bd"
    },
    {
      "type": "html",
      "text": "Machine:<br>Whose?",
      "id": "bb0ab978150eee21fd28c341a61dc2b7"
    },
    {
      "type": "html",
      "text": "Human:<br>The gas company's",
      "id": "adfb4b62b11880e1cf0823d079fbb421"
    },
    {
      "type": "html",
      "text": "Machine:<br>Which one?",
      "id": "eab58eadea61abff7a672e3273cec98b"
    },
    {
      "type": "html",
      "text": "Human:<br>The one who sends the bills",
      "id": "517e661ce323829852c262981fe80374"
    },
    {
      "type": "html",
      "text": "Machine:<br>The gas company who sends the gas bills?",
      "id": "751ddfffe6fecd1611a05d2fdccb2b74"
    },
    {
      "type": "html",
      "text": "Human:<br>Yes.",
      "id": "c92b57a6e3b3af222061f88ad64118bd"
    },
    {
      "type": "html",
      "text": "Machine:<br>Which ones?",
      "id": "a7f8e28b23584a1d85e41cc8a07e8d26"
    },
    {
      "type": "html",
      "text": "Human:<br>The last one.",
      "id": "9d4c140be1b89112602a4f6d7281e36e"
    },
    {
      "type": "html",
      "text": "Machine:<br>You mean April 2004?",
      "id": "c909bc97b6151de300a2e53a8c6b3f69"
    },
    {
      "type": "html",
      "text": "Human:<br><sigh> I suppose so.",
      "id": "6762f0bdf41e7a52c0ce3ce9a79ac8b5"
    },
    {
      "type": "html",
      "text": "Machine:<br>I don't know, is it on the bill?",
      "id": "cbb9ec8b6b9a55bb4bf1c9a0b09c6c2f"
    },
    {
      "type": "html",
      "text": "Human:<br>I suppose so, let's have a look...",
      "id": "1e14c6109b0ff7ec0df506bc3ad98f7e"
    },
    {
      "type": "html",
      "text": "Machine:<br>Shall I display your April 2004 gas bill?",
      "id": "df1048db79ef42caf1ae6e9d148e82d6"
    },
    {
      "type": "html",
      "text": "Human:<br>Please.",
      "id": "fd44aa53caa92e42c8331019fb4fbcd0"
    },
    {
      "type": "html",
      "text": "Machine:<br>No need to be polite, I'm only a machine! To you and...? ",
      "id": "d68a675a74ca9f9a57f97e6162051021"
    },
    {
      "type": "html",
      "text": "Human:<br>Just to me!",
      "id": "f4a7a4d4f8176dc8a90f916a78a49227"
    },
    {
      "type": "html",
      "text": "Machine:<br>Here you are... grumpy",
      "id": "244de6336144e1ed54ec75a1ca16b074"
    },
    {
      "type": "html",
      "text": "<i>Ok, maybe you're right after all!)</i>",
      "id": "1e87d2cbd6fe35d4075902d62f688016"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5f031304b6ffce00e9b191b46ff1d6b1"
    },
    {
      "type": "html",
      "text": "See also: [[Programming Paradigm]], [[Functional Functions]], [[Functional In Imperative]]",
      "id": "bbca0d19ac6e374c88f385651f4c3379"
    },
    {
      "type": "html",
      "text": "\n[[Category Functional Programming]]",
      "id": "feff46db9922a61547e47a3213ca13ad"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?FunctionalProgramming c2.com]",
      "id": "43e143727d92a17d8eef2f788b1ef17d"
    }
  ],
  "journal": [
    {
      "date": 1419419843000,
      "id": "f2929954c5bfe937f8cc19bd0ef37eca",
      "type": "create",
      "item": {
        "title": "Functional Programming",
        "story": [
          {
            "type": "html",
            "text": "[[Functional Programming]] is when functions, not objects or procedures, are used as the fundamental building blocks of a program. Functions in this sense, not to be confused with [[Cee Language]] functions which are just procedures, are analogous to mathematical equations: they declare a relationship between two or more entities.",
            "id": "79efe5d4e37bb1442c5ec396bbf09aad"
          },
          {
            "type": "html",
            "text": "\n[[Functional Programming]], however, is not about mathematics but about abstraction and reducing complexity: as such, it provides a powerful paradigm in which to tackle complex, real-world programming tasks.",
            "id": "4736be22622c63dc801aaaf09b060ac6"
          },
          {
            "type": "html",
            "text": "\n[[Functional Programming Language]]s, which support this style of programming, provide at least some of the following features:",
            "id": "b39216dfe4012f2d396ac22ba0af271c"
          },
          {
            "type": "html",
            "text": " [[First Class]] functions",
            "id": "d9fc2f99084c5e251fdd38ab34b0844b"
          },
          {
            "type": "html",
            "text": " [[Higher Order Function]]s",
            "id": "3d649f86e857ada54c826f95d6103226"
          },
          {
            "type": "html",
            "text": " [[Lexical Closure]]s",
            "id": "97b1bf5d46c56f56bbf1b9c9211158e1"
          },
          {
            "type": "html",
            "text": " [[Pattern Matching]]",
            "id": "c9bc8babf8c33b52dc5f7daad837a9c5"
          },
          {
            "type": "html",
            "text": " [[Single Assignment]]",
            "id": "be81975a814fe761ecc9b07c5a390d45"
          },
          {
            "type": "html",
            "text": " [[Lazy Evaluation]]",
            "id": "f4a419144b461ef13b829e00ac6026cf"
          },
          {
            "type": "html",
            "text": " [[Garbage Collection]]",
            "id": "b2ae3461cf245b6db38ac0e06588a7da"
          },
          {
            "type": "html",
            "text": " [[Type Inference]]",
            "id": "73299f221f92c7537629a8f2efb3025b"
          },
          {
            "type": "html",
            "text": " [[Tail Call Optimization]]",
            "id": "23da7c3e380829f27fcc5db0f31f3717"
          },
          {
            "type": "html",
            "text": " [[List Comprehension]]s",
            "id": "dbc3624bfb86727a808ea08519d3d919"
          },
          {
            "type": "html",
            "text": " Monadic effects [[[On Monads]]]",
            "id": "abf27476da03350a7cae9976af542980"
          },
          {
            "type": "html",
            "text": "\nThese features enable or support the following aims:",
            "id": "5e3179c72499fc52cd9d120061edd2c1"
          },
          {
            "type": "html",
            "text": " shorter programs (lower lines-to-effect ratio)",
            "id": "0249f02a7aa188664e6e0bd1cd93ddda"
          },
          {
            "type": "html",
            "text": " program correctness",
            "id": "29b0805c5a70907a6c661ff742e42233"
          },
          {
            "type": "html",
            "text": " expressive programs",
            "id": "bfd5403ced781f99f9581e3682d05024"
          },
          {
            "type": "html",
            "text": "... and thus overall improved productivity. [[Functional Programming]] is also very enjoyable.",
            "id": "53eda9494ec2b310c961543ae4da36f1"
          },
          {
            "type": "html",
            "text": "\nAlthough some of these features exist in [[Object Oriented]] languages, or may be simulated via [[Object Functional Patterns]], [[Functional Programming]] really requires (and allows) a paradigm shift. [[Object Functional]] languages try to combine the best of both worlds.",
            "id": "4f0067f3a32ba4a2683a70d704f7eb89"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "<b>Books</b>",
            "id": "48db4b18747f0f74659b6c09f847d64d"
          },
          {
            "type": "html",
            "text": " [[Purely Functional Data Structures]]",
            "id": "e373f658bb32e1a14b3da4a63b8f9459"
          },
          {
            "type": "html",
            "text": " [[Type Theory And Functional Programming]]",
            "id": "ef690af693994bcd8c46905b63a6a402"
          },
          {
            "type": "html",
            "text": " Khan, Aslam. Grokking Functional Programming. Manning Publications (2015). p. 475. ISBN 9781617291838",
            "id": "c2b02034f340723cea0f3622c662d23b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "This document [http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html www.ccs.neu.edu] is a very good explanation of [[Functional Programming]]. It gently takes you through the features, and may produce that required paradigm shift. -- [[Peter Lynch]] ",
            "id": "bab7c8ff73dc763f3fd5d4bde7841b83"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "\nA classic example, to provide a feel for what [[Functional Programming]] is like, is the [[Quick Sort]] algorithm, using [[Pattern Matching]], [[List Comprehension]]s and recursion.",
            "id": "c38be5ad51eee61929fd9f796297a140"
          },
          {
            "type": "html",
            "text": "\nIn [[Haskell Language]] (see [[Quick Sort In Haskell]]):",
            "id": "8195dca1f46cf164e5cf406b8efce1ab"
          },
          {
            "type": "code",
            "text": " qsort []  = []\n qsort (x:xs) = qsort elts_lt_x ++ [x] ++ qsort elts_greq_x\n      where\n      elts_lt_x  = [y | y <- xs, y < x]\n      elts_greq_x = [y | y <- xs, y >= x]",
            "id": "b385cca53d1e86f9722121341bb63790"
          },
          {
            "type": "html",
            "text": "\nOr, taking advantage of the [[Filter Function]] and of Sections (still in [[Haskell Language]]):",
            "id": "4d621e462245bd54d057c09d4f1afc1d"
          },
          {
            "type": "code",
            "text": " qsort []  = []\n qsort (x:xs) = (qsort (filter (<x) xs)) ++ [x] ++ (qsort (filter (>=x) xs))",
            "id": "dbd2186710b00da402a88690032ca546"
          },
          {
            "type": "html",
            "text": "\nOr with partition (still in [[Haskell Language]]):",
            "id": "79953010613ef422982a97c3805c7082"
          },
          {
            "type": "code",
            "text": " qsort []  = []\n qsort (x:xs) = qsort lt ++ [x] ++ qsort gte\n  where (lt,gte) = partition (<x) xs",
            "id": "bd22d3d8840c74533cfd34465c7b14c0"
          },
          {
            "type": "html",
            "text": "\nIn [[Erlang Language]]:",
            "id": "fd1397d028bdd7fb9e673f7d111cd047"
          },
          {
            "type": "code",
            "text": " qsort([]) -> []; \n qsort([X|T]) ->\n  ElementsLessThanX = [Y || Y<-T, Y<X],\n  ElementsGreaterEqualToX = [Y || Y<-T, Y>=X],\n  [qsort(ElementsLessThanX),X,qsort(ElementsGreaterEqualToX)].",
            "id": "e2bbf681cd57db43acfeda97ebb44786"
          },
          {
            "type": "html",
            "text": "<i>A stray thought: These implementations of [[Quick Sort]] have in common that they use the first element as a pivot. This is a very bad choice of pivot, because it tends to make the execution time quadratic when the input is already sorted. This undesirable property is not a forced consequence of functional programming, but because functional languages tend to prefer list-like data structures, the simple implementations of [[Quick Sort]] tend to have that drawback. For this reason, I think that [[Merge Sort]] is often a better choice for functional languages. --[[Andrew Koenig]]</i>",
            "id": "045722a49eb0f8f524b7dec8e83bfb91"
          },
          {
            "type": "html",
            "text": "\nThe also have in common that two of them use [[Syntactic Sugar]] to perform the list filtering. For that reason, the second Haskell implementation is a better example here, since it shows off a more normal [[Higher Order Function]] than the first implementation, which is a little more of a trick. At least the way I see it. ",
            "id": "8d6dd51175fa3e496b9f24c69ebdbdcd"
          },
          {
            "type": "html",
            "text": "<i>[[Andrew Koenig]]'s comment about [[Merge Sort]] being a better fit for functional programming than [[Quick Sort]] is borne out by experiment. In 2002, the GHC implementation of Haskell replaced the stable [[Quick Sort]] implementation in its standard library with [[Merge Sort]]:</i>",
            "id": "5cd7e40b5af7cb4a35941ec884076009"
          },
          {
            "type": "code",
            "text": " sortBy cmp l = mergesort cmp l\n sort l = mergesort compare l",
            "id": "f95c829a3866f641b89d665ac58d0e2e"
          },
          {
            "type": "html",
            "text": "mergesort ::<br>(a -> a -> Ordering) -> [a] -> [a]",
            "id": "d82b24c0c61b3e88a802b8469506b543"
          },
          {
            "type": "code",
            "text": " mergesort cmp = mergesort' cmp . map wrap",
            "id": "70d6fb8976ed96d5d151419ebec91397"
          },
          {
            "type": "html",
            "text": "mergesort' ::<br>(a -> a -> Ordering) -> [[a]] -> [a]",
            "id": "e1891b964b6f166a29e8486f41d447f0"
          },
          {
            "type": "code",
            "text": " mergesort' cmp [] = []\n mergesort' cmp [xs] = xs\n mergesort' cmp xss = mergesort' cmp (merge_pairs cmp xss)",
            "id": "89125d4c59efddf07d30377be3af4434"
          },
          {
            "type": "html",
            "text": "merge_pairs ::<br>(a -> a -> Ordering) -> [[a]] -> [[a]]",
            "id": "0c5a3a776667ac2813c2e4ee60a811b5"
          },
          {
            "type": "code",
            "text": " merge_pairs cmp [] = []\n merge_pairs cmp [xs] = [xs]\n merge_pairs cmp (xs:ys:xss) = merge cmp xs ys : merge_pairs cmp xss",
            "id": "69bc28328f1bc98bdbfe1312e07ee6c2"
          },
          {
            "type": "html",
            "text": "merge ::<br>(a -> a -> Ordering) -> [a] -> [a] -> [a]",
            "id": "97e4c2685c17e249309b9b468e666037"
          },
          {
            "type": "code",
            "text": " merge cmp xs [] = xs\n merge cmp [] ys = ys\n merge cmp (x:xs) (y:ys)\n  = case x `cmp` y of\n         GT -> y : merge cmp (x:xs)   ys\n         _  -> x : merge cmp    xs (y:ys)",
            "id": "5dcef8f7ff5527ebeada5ad2d5b0e70b"
          },
          {
            "type": "html",
            "text": "wrap ::<br>a -> [a]",
            "id": "7d33d47e5e21a5e7d42ed079d8d50df6"
          },
          {
            "type": "code",
            "text": " wrap x = [x]",
            "id": "662704b32026e17e089661fa06e10a2e"
          },
          {
            "type": "html",
            "text": "<i>The accompanying documentation confirms [[Andrew Koenig]]'s suspicion about [[Merge Sort]] being quicker, but also says that [[Merge Sort]] uses far more memory.</i>",
            "id": "73a824a71ae072f01151a72614f5ccd1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "\nAn important part of (pure) [[Functional Programming]] philosophy is [[Referential Transparency]], which requires writing [[Side Effect Free]] functions. In order to encourage this, variables are [[Single Assignment]], or immutable: once they are initialized, their value cannot be changed. Arguments to functions may only be passed by value, and rather than modify arguments, functions must return new variables.",
            "id": "b9f4025ce73067870038eb3bb4c2228c"
          },
          {
            "type": "html",
            "text": "\nThis alone has several implications on the style of programming (compiler implementation and performance aspects are discussed later):",
            "id": "31cb420b055948854622ba45ae72628b"
          },
          {
            "type": "html",
            "text": " Since functions cannot modify  arguments, they need to be able to return more than one piece of information: therefore tuples and lists are widely used, and may be created on the fly in most [[Functional Programming Language]]s.",
            "id": "b2f180574b379abc22998c78ed4bc920"
          },
          {
            "type": "html",
            "text": " Since variables, even within functions, are immutable, writing loops using counters is impossible or at best unwieldy: the dominant style of algorithm is therefore recursive.",
            "id": "a447b2a35ee5dcac910eb146ac1f612a"
          },
          {
            "type": "html",
            "text": " Since functions cannot modify variables, they cannot store state between successive calls. Thus data and functions are kept completely separate, which is the opposite philosophy to [[Object Oriented]] encapsulation.",
            "id": "b5a18e1ec31b5b064a1b3aebb64a86cd"
          },
          {
            "type": "html",
            "text": " There may be a need for a data structure to represent the global state and top-level functions that operate on the global state. Most other functions only operate on a small part of the data, so the top-level functions extract pieces of the global state, pass them to lower-level functions, and construct a new global state using the results. (Incidentally, this makes it trivial to instantiate multiple copies of the entire application. For example, maintain a copy of the entire program state as it existed five minutes ago, and revert to it if there is an error.)",
            "id": "c0e27dc40a4be264fe77e3d47d1d4b6d"
          },
          {
            "type": "html",
            "text": " The emphasis is on writing pure, generic functions which could work in any environment, and choosing actual program behaviour at the top of the call hierarchy. This is in contrast to [[Object Oriented]] programming which encourages pushing behaviour into class methods and making decisions low down by overriding them in subclasses. (Document example moved to [[Functional Modeling]]).",
            "id": "9f12032c03258630e7fa8caa5cc94d99"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "\n[[Single Assignment]], [[Call By Value]] and recursion comes with an implementation cost: lots of garbage generation, potentially huge stack, and lots of copying. In a naive implementation, all state changes generate garbage. Functional languages have optimizing compilers to get rid of the bloat with tricks such as turning copying code into modify-in-place behind the scenes, and [[Tail Call Optimization]]. On the one hand, functional languages provide many more opportunities for optimization, since everything can be inlined and refactored safely by the compiler. On the other hand, functional programs require a good optimizer to get decent performance. Some languages have automatic [[Lazy Evaluation]].",
            "id": "7a78365158cc98101762b417c698fbff"
          },
          {
            "type": "html",
            "text": "<i>Functional languages do not require good optimizers, that is a myth. For example, OCaml, one of the most performant functional languages around, uses a straightforward compiler that has a well-designed compilation scheme but does no fancy optimizations at all. What you need, though, is a well-engineered runtime system. In particular, you want to optimize your memory layout and garbage collector for small objects, high allocation rates, and short lifetimes. That is quite different from a typical OO runtime.</i>",
            "id": "7c1a60dc6bb1b8b8dd49196bef249ec1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "\nSee also the following Wiki pages:",
            "id": "d12396faabc896a89f323c681bef9849"
          },
          {
            "type": "html",
            "text": " [[Advantages Of Functional Programming]]",
            "id": "3aac921fd80aa2e4e1a6882c4b7f6e79"
          },
          {
            "type": "html",
            "text": " [[Fp Vs Oo]] and [[Oo Vs Functional]]",
            "id": "b03f1cee391e36287f41ac21e349d69e"
          },
          {
            "type": "html",
            "text": " [[Functional Modeling]]",
            "id": "fece8298e54535d430f07af886a98127"
          },
          {
            "type": "html",
            "text": " [[Currying Schonfinkelling]]",
            "id": "dd451b004c1a2b2b6c5fb9dee59cd973"
          },
          {
            "type": "html",
            "text": " [[Lambda Calculus]]",
            "id": "934b049766b4a47d3d3b9a4681f33181"
          },
          {
            "type": "html",
            "text": " [[Functional Programming Language]]s",
            "id": "fcb2de10ba209e3702ba5a3b3a66b55d"
          },
          {
            "type": "html",
            "text": " [[Functional Imperative Rosetta Stone]]",
            "id": "cee036090e50edb393ceebae69d080b3"
          },
          {
            "type": "html",
            "text": " [[Functional Programming In Cpp]]",
            "id": "e9d50f0adb7c99f00a1b2fccc211bf56"
          },
          {
            "type": "html",
            "text": "\nSome external links:",
            "id": "8bdc1196f400b3fd0416748d135edc0d"
          },
          {
            "type": "html",
            "text": " [[John Hughes]] classic paper [[Why Functional Programming Matters]]",
            "id": "9fb6945201cdbbf41b949c4fd89d2fcb"
          },
          {
            "type": "html",
            "text": " FAQ for comp.lang.functional: [http://www.cs.nott.ac.uk/~gmh/faq.html www.cs.nott.ac.uk]",
            "id": "f685a08fce0438480d8e9011313114de"
          },
          {
            "type": "html",
            "text": " List of real-world applications using [[Functional Programming]]: [http://homepages.inf.ed.ac.uk/wadler/realworld/ homepages.inf.ed.ac.uk]",
            "id": "a3943cbb2352ee5f9ffc278f9e55a44c"
          },
          {
            "type": "html",
            "text": " Discussion of the relationship between [[Functional Programming]] and [[Flow Based Programming]] in [http://www.jpaulmorrison.com/fbp/recurs.htm www.jpaulmorrison.com] - FP people can skip the early section!.",
            "id": "11a39b1eae57174dcf0a95bb8469fc23"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "Supposedly the:",
            "id": "62e826078d6fa9ee8c41d6756debdaa4"
          },
          {
            "type": "html",
            "text": " <b>fun</b> was put in functional programming by STL of C++ fame (?)",
            "id": "74f43117e848f331b023e1552560e95c"
          },
          {
            "type": "html",
            "text": " <b>funk</b> was put in functional programming by Haskell (?)",
            "id": "a60ed22bc89492bf3c6341672e36dc5f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "<b>Discussion:</b>",
            "id": "577dce3a28cbc1086bd197545c0a2858"
          },
          {
            "type": "html",
            "text": "\nFunctional programming is pure nonsense.. the print(\"hello world\") is still a procedure in any language (it affects the state and modifies the screen too). It's actually just a big [[Syntax Game]] and a form of <b>different</b> procedural programming. Eventually the program <b>does</b> something. ",
            "id": "262bffe58e5bbdf6a10a13e925ee7f8d"
          },
          {
            "type": "html",
            "text": " Programming in general is intended to cause things to happen, the question is how the things to happen are specified. [[Declarative Programming]] (for example [[Functional Programming]] and [[Logic Programming]]) allow the programmer to concentrate on what has to happen, and let the question of the steps required to make them happen be decided elsewhere.  Just like [[Garbage Collection]], we can automate various things to relieve us of the repetitive minutiae. That's why we have computers.  If you're happier programming in [[Assembly Language]] then please feel free to do so.",
            "id": "45a872aecc5489bdadd56e661b7549c6"
          },
          {
            "type": "html",
            "text": " <i>Gotta love the people who bring up assembly language when that has nothing to do with the discussion, such as the print statement being a procedural call - <b>not</b> declarative.</i>",
            "id": "683b40ff8ea91293a646ae3e48c6cb03"
          },
          {
            "type": "html",
            "text": "<i>Of course functional programs <b>do</b> something. They take in parameters and return a result.</i>",
            "id": "acb49058a193266085e5eb8d6e48ce75"
          },
          {
            "type": "html",
            "text": "<i>It's not true that print() is a procedure in any language. In Haskell, print() returns an IO object. It does NOT affect the state or the screen. Of course, eventually this IO object has to be executed to affect the screen - but the point is that the print function itself does NOT have side effects, and IS referentially transparent.</i>",
            "id": "71674b49f71416f0219ce7f04704d068"
          },
          {
            "type": "html",
            "text": "\nMeh. `print \"foo\"` is essentially a procedure in a [[Domain Specific Language]] called IO. The Haskell print function returns a representation of this procedure. To the extent program logic and behavior is expressed through the IO language, we're doing imperative programming. The fact that the Haskell function is pure is only relevant for reasoning about program construction. Reasoning doesn't stop at program construction, and `print` is definitely not referentially transparent within the IO language.",
            "id": "bae4b033878a2c14e439e174597c1045"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "\nYou could write a Java program that feels very much like a functional program by not using mutable static variables and making all objects immutable. (Local variables don't matter so much because they're well encapsulated.) -- [[Brian Slesinsky]]",
            "id": "a72a2d8d9a0ccf9cea20264e2c7c025e"
          },
          {
            "type": "html",
            "text": "\nAlthough I have not tried this in Java, I would imagine it to be rather difficult and frustrating without the corresponding facilities such as on the fly generation of tuples, list manipulations, and [[Tail Call Optimization]]. Moreover, I don't think that would suffice to make it feel like a functional program. -- [[Dominic Williams]]",
            "id": "09fc2c8290c837d926b16b2fc9863f2e"
          },
          {
            "type": "html",
            "text": "<i>Java is sorely lacking [[Higher Order Function]]s. To effectively write functional programs you want recursion schemata like \"map\" and \"fold\" and these must be polymorphic. While Java can emulate these, wrapping every function in an object is cumbersome at best. You also lose the powerful type system of the ML-family languages.</i>",
            "id": "7b1f819654c7af4e6e8d0f815b1383a4"
          },
          {
            "type": "html",
            "text": "\nIndeed. And then to use [[Higher Order Function]]s a lot, you need real [[Lexical Closure]]s to be easy to write on the fly (not through something cumbersome like [[Anonymous Inner Class]]es). And even with all that (which you do get in [[Ruby Language]]), it still would not feel much like [[Functional Programming]] without [[Pattern Matching]]... -- [[Dominic Williams]].",
            "id": "2889e0b3d39c90d9cc0ad09b3e6efdf7"
          },
          {
            "type": "html",
            "text": "<i>You can write functional like programming in any language, and it gets hard to do in some languages. The question is whether massaging data into more and more functions is useful, especially since performance considerations are still prevalent today on web servers and such (despite what people think with today's processing power). Massaging more functions into more functions isn't any way we can clearly map it to a computer processor in our minds,  and when it comes to mapping the code to the computer - we're at a loss. I many times wonder whether people just throw around phrases like [[Higher Order Function]] just to be be hip and cool, and just to make programming sound complex and hard.  Doing silly stuff like in the below screenshot is hip, and cool, but I really question whether massaging stuff into other functions is the way humans think - and whether the benefits are worthwhile. Recursion, abusing functions instead of clearly written structured code like iterators and loops,  sending other functions into other functions.. that is all academically interesting, But does it get us anywhere? Or really is it just hip, cool, complex, and wizardry? How often do we really need to massage functions into other functions, and reuse functions that pass each other functions? Is it all in people's mind, that this functional magic is so beneficial to society?</i>",
            "id": "20e132f13c6296bfe0420c1f433e68b4"
          },
          {
            "type": "image",
            "url": "http://z505.com/images/imperative-reuse.png",
            "text": "z505.com",
            "id": "f52db2840d5dde5ca3b70baef048de7a"
          },
          {
            "type": "html",
            "text": "\n",
            "id": "ce4a4682440e6ff552c93607d9e969ad"
          },
          {
            "type": "html",
            "text": "<i>In above screenshot I push stuff around into other functions instead of rewriting the same loop each time (reusing chunks of code, similar to how functional programming reuses functions in functions in functions). But really, how useful is this? Is this just wizardry and is it over hyped that the idea of reusing functions inside functions inside functions some how magically improves a programmers life or company profits?</i>",
            "id": "8a3d45f2c3c9583281ba5164cd15ee0d"
          },
          {
            "type": "html",
            "text": " Your \"argument\" seems to be that functional programming doesn't match the way you map processes to computers.  If you only think in terms of fundamental computer operations, then you are limited in your thinking.  If you can't think in higher level abstractions, then you are limited in your thinking.  You appear to suffer from the [[Blub Paradox]].  I suggest you read, and do all the exercises in, the SICP book.  It's a mind-expanding experience.  It's clear from other contributions on this wiki that you'll take no one's advice or experience.",
            "id": "bce7ca8f080d85397bedf99984d0dc41"
          },
          {
            "type": "html",
            "text": " <i>A false dichotomy between low-level thinking and FP. There are plenty of non-FP abstractions that are quite useful. If you measure a benefit and demonstrate the higher numeric score, I will pay attention. But I will ignore most non-scientific hype and bullshit because there's too much of it. The functional fans are sounding a lot like the OOP-everywhere fans of the last decade. [[Blub Paradox]] is FP's version of the [[You Just Dont Get It]] claims of the OOE-ers. <b>Measure it or shove it, FPers!</b> -t</i>",
            "id": "2543d27765afa8510758c06a908779f1"
          },
          {
            "type": "html",
            "text": "\nSee also [[Functional Programming Discussion]]",
            "id": "cea04b8e01baeef77a03662ef988df1d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "<i>How do data items persist?</i>",
            "id": "43abd5c62c948ad16ea90e9cf54b9f31"
          },
          {
            "type": "html",
            "text": "\nOn the stack. In a sequential, batch program, data is initialized and transformed in a top-level function. In a long-lived program like a server, a top level looping function is called recursively, passing global state from one call to the next.",
            "id": "2faf76983bfb06a77b673b19bf40fd5c"
          },
          {
            "type": "html",
            "text": "<i>Pure functional languages have REAL PROBLEMS referring to large stateful objects, because you lose [[Referential Transparency]].</i>",
            "id": "ab2e5b11c80eb6c0d4f3081132feb209"
          },
          {
            "type": "html",
            "text": "\nThis is not true. You can hold state in a top level function, pass bits of it to pure functions, use their results to construct a new global state. There are no side effects here. In practice, a program without side-effects is not very useful, so it is common in functional programs to have mostly pure functions, glued together by some impure stuff. This does not take anything away from the usefulness of the functional paradigm.",
            "id": "750c722bd22ea84624a1da9790f73572"
          },
          {
            "type": "html",
            "text": "<i>Some issues with representing state: modifying an element of an array in a functional language is inefficient because you have to copy the whole array (though the compiler could optimize this out if you throw away the reference to the old copy). Tree structures might be more efficient since you only copy the nodes from the root to the element being modified. It seems like it would be rather hard to know whether code is efficient because many ways of optimizing code cannot be expressed - the compiler must do it for you.</i>",
            "id": "8228c35aef86995243c5903d86aec74c"
          },
          {
            "type": "html",
            "text": "\nMost [[Functional Programming Language]]s use lists and tuples (from which arbitrary structures may be built), not arrays. Moreover, the functional paradigm aims to be at a more abstract level: such implementation details are left to optimizing compilers.",
            "id": "1181ec280dede21d8206f188ac6bb59d"
          },
          {
            "type": "html",
            "text": "<i>I think I am missing something rather basic. How is a data value ever changed (or even entered)? If someone mistypes a text string, how does correcting it in a clone class help?</i>",
            "id": "c43e116aeed486d6bc1ff45c3ecb92ba"
          },
          {
            "type": "html",
            "text": "\nAssuming you're familiar with java: How do you deal with a String object that's been mistyped? You create a new, corrected String, and throw away the old one. It's the same thing here.",
            "id": "253fe684fd1119184253f4cd4dca84c2"
          },
          {
            "type": "html",
            "text": "<i>Pure functional languages preclude any sort of side effect. Not only can no data be modified in place, it is also impossible to change bits on persistent storage or even read input from somewhere. Clearly, no interactive program can be written this way. Three solutions are in use:</i>",
            "id": "0b57a8ec845ca66ab14fe8088a557b5d"
          },
          {
            "type": "html",
            "text": " Represent input and output as lists of commands to some enclosing system. Many of these stream processors can be combined. Though this is somewhat cumbersome, it works. In the [[Fudgets Library]] such a design has actually worked out pretty well.",
            "id": "500b75c2b7cfc5c1abf34fe62f4d1554"
          },
          {
            "type": "html",
            "text": " Extend the type system with data types that can be used only once ([[Unique Type]]s). As the old value becomes inaccessible, the program doesn't mind if the compiler decides to do an in-place update. The world is represented by a special token and side-effecting functions conceptually produce a new world. [[Clean Language]] does this. It works, though the explicit passing around of the world can get annoying.",
            "id": "0f865b5049334a79a6259c5cf9811a36"
          },
          {
            "type": "html",
            "text": " Use monads to hide the state (see [[On Monads]]). The hidden state can be queried, but old values are inaccessible. As with [[Unique Type]]s it doesn't matter if an in-place update is done behind the scenes. [[Haskell Language]] does this. [[Monadic Programming]] is actually quite convenient, not only for hiding side effects. If overdone, it starts looking like procedural code.",
            "id": "29c4fbf5fc57fe2ce5aa87c065c39e8c"
          },
          {
            "type": "html",
            "text": "<i>Concerning the need for mutable state: it is needed for truly interactive programs, in one form or another. <b>Many programs are not that interactive, they can be neatly split into input, processing and output. Such programs work really well in a pure functional setting.</b> In [[Haskell Language]] it is quite common to write a monadic main function that does input, calls processing, then does output.</i>",
            "id": "b65f735089819d2f77a9f4655574bfc4"
          },
          {
            "type": "html",
            "text": "<i>Apart from that there are some algorithms that seem to incur an inefficiency if done purely functional. These are algorithms with state that is to be mutated in random order with constant access time, graph algorithms are typical. Without mutable arrays, the run time takes an additional logarithmic hit. [[Haskell Language]] provides mutable arrays, of course hidden in a monad, exactly for this reason.</i>",
            "id": "7a07c0fe69bdfe0cf61c62a1759550bd"
          },
          {
            "type": "html",
            "text": "\nThe highlighted part is really insightful. (Similar idea to the [[Unix Way]]). Probably the majority of code being written is devoted to reading [[Data Base]]'s and emitting [[Extensible Markup Language]], or vice versa, or one or the other, or something similar. <i>If this is what you're doing anyway</i>, pure FP loses you nothing and gains you a whole lot of bug-proofing.",
            "id": "27d0481afa3a634ea69eedf9f79b79d9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "\nI don't know much about garbage collection, but I've been interested to hear about a couple of the tricks/properties that are possible with functional languages, Erlang in particular. I'd like to share them with you guys, with the disclaimer that they're just some ideas I heard and like, and I don't know much about how things are implemented in practice. Do correct me on any mistakes I make.",
            "id": "b91a84c1facf0c61eaf0d26480d323e9"
          },
          {
            "type": "html",
            "text": "\nTake a [[Mark And Sweep]] scheme as an example. The basic idea is that you have a \"root set\" of objects that are directly accessible because (depending on the language) they're in global variables, in a stack frame or local variable of an active thread, etc. When you want to garbage collect, you follow all the references out of your root set and \"mark\" each object that you reach. After you've done this, anything that's not marked can be reclaimed. In pseudocode:",
            "id": "ea17110bdfbcc9218d1aa3efb026d5df"
          },
          {
            "type": "code",
            "text": " for each element of root set:\n  spider out through code marking each reachable object\n for each element of heap\n  if (marked) keep\n  else reclaim",
            "id": "f11544cf6e759468d80a2bb93398d42d"
          },
          {
            "type": "html",
            "text": "This process spiders out until it finds every object that can be accessed and marks it, after which time you can walk through the heap from start to finish and throw away anything that's not marked.",
            "id": "52eb0b4a5cb0f12c84ef9f55528a98be"
          },
          {
            "type": "html",
            "text": "\nNow in a language which doesn't support destructive operations, there's a special property: objects can only reference other objects that are older than themselves - because the newer ones didn't exist.",
            "id": "1ceb7df6b8d1a08c6bba117bab63cdfc"
          },
          {
            "type": "html",
            "text": "<i>Note that this property depends on the language implementation not doing certain other optimizations, and usually does not hold for implementations of functional languages that support [[Lazy Evaluation]].</i>",
            "id": "02b3015fd0428e2ab2131a16b9253d16"
          },
          {
            "type": "html",
            "text": "\nNow, suppose you have the objects in the heap sorted by age (very easy with a [[Copying Collector]] for example). The [[Mark And Sweep]] can be simplified into one pass, based on the fact that if an object hasn't been marked by any of the objects newer than itself, then it can't be marked at all due to the lack of forward reference. In pseudocode:",
            "id": "1922ff108255f32c8540881c71f4676b"
          },
          {
            "type": "code",
            "text": " for each object on the heap, newest to oldest:\n  if (marked) mark all directly accessible objects, and keep\n  else reclaim",
            "id": "baaa38cfb608247b7832ef2ee66ffcdc"
          },
          {
            "type": "html",
            "text": "Much faster and simpler. Also, since the heap isn't changing, just being appended to, you can do the GC incrementally very easily.",
            "id": "11997d13a775fc28144fcd7481804ea7"
          },
          {
            "type": "html",
            "text": "\nAlso, in Erlang you have a lot of separate processes, many of which are small and short-lived. Each of these processes has its own heap, and can be garbage collected separately. Now, for short-lived processes which do something quick like send an email and then terminate, it may not be necessary to do a fine-grained GC of the heap - just let it run and make some garbage, and when its finished just throw the whole heap away. So garbage collection can be \"free\" for these short-lived processes, and you may have many of them. -- [[Luke Gorrie]]",
            "id": "81b7ce38d95cf353d0a2dde1b5718cc0"
          },
          {
            "type": "html",
            "text": "<i>Something else thats worth noting about languages without destructive updates, is that [[Reference Counting]] becomes a viable memory management scheme all on its own; cyclic garbage is impossible. Reference counted objects are collected as soon as they are unreachable, which is useful when timing is important. [[Reference Counting]] may be inefficient, but its probably the easiest form of automatic memory management one could implement.</i>",
            "id": "096f92e01ae85d3fd4c2b889210ca92f"
          },
          {
            "type": "html",
            "text": "<b>except for [[Lazy Evaluation]]. With [[Strict Evaluation]], the above holds.</b>",
            "id": "b68ca0a90c330904a5a8265f4c010d81"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "\nWould I be incorrect to say that [[Functional Programming]] can be summarized by this -",
            "id": "c8d07e7934194ef493ad92a0ba05997e"
          },
          {
            "type": "code",
            "text": " \"Result = Process(Data)\"\n Where \"Result\" is the variable representing the output of the function called \"Process\" \n and \"Data\" is the list of arguments?",
            "id": "d1b41df806311e9290ff9e4a7dccb9fb"
          },
          {
            "type": "html",
            "text": "<i>No, it's Result(Process(Data))</i> :)  ",
            "id": "e03e008d4533eec53d948a39803f0d66"
          },
          {
            "type": "html",
            "text": "\nIf so, this appears to me to be the most intuitive interface to programming of all. ",
            "id": "3c815a3ef43e9ebc658f903ae7ac3962"
          },
          {
            "type": "code",
            "text": " For example,\n  Reply = Get Reply(\"Where do you want to go today?\")\n  Customer Address = Get Data(\"Customers\", \"Address\", Customer Id)\n  Choice = Get Selection(\"Please select one of these\", \"Dog,Cat,Fox\")\n  Notify(\"The customer you have selected is a bad payer\")",
            "id": "04346b6d907ae0b32596aef410b62bf6"
          },
          {
            "type": "html",
            "text": "\nGiven that we will one day (soon?) be talking to the machine, is it not a model we will have to embrace eventually anyway? -- [[Peter Lynch]]",
            "id": "d688c72dc851d8a2d45e369c0557eb6b"
          },
          {
            "type": "html",
            "text": "<i>How does \"talking to the machine\" have any bearing on this? Besides the complexity that speech recognition adds, how is talking different from typing? If you mean to imply that functional is somehow more human than the alternatives, or that there is some subset of human requirements that can only be expressed in a functional way, then my reply would be simply:  No, we will not have to embrace the model eventually. (And no, it is not the most intuitive interface of all, although there may be a subset of humanity for which it is more intuitive than, say, the simple imperative, e.g.:</i>",
            "id": "e26cf01f971b1cf0c17190e06152abb7"
          },
          {
            "type": "html",
            "text": "Human:<br>Gas Bill!",
            "id": "965b855031eb625fad7dc1c92505868b"
          },
          {
            "type": "html",
            "text": "Machine:<br>What about it?",
            "id": "42cded7375c8b476d50d823046fc3205"
          },
          {
            "type": "html",
            "text": "Human:<br>Have I paid it?",
            "id": "3a2b671196b6a50b594fa8f91ee1b273"
          },
          {
            "type": "html",
            "text": "Machine:<br>Which one?",
            "id": "eab58eadea61abff7a672e3273cec98b"
          },
          {
            "type": "html",
            "text": "Human:<br>The latest one, of course!",
            "id": "db6a1bb47f10b7887697c312dfdaf6af"
          },
          {
            "type": "html",
            "text": "Machine:<br>You mean April 2004?",
            "id": "c909bc97b6151de300a2e53a8c6b3f69"
          },
          {
            "type": "html",
            "text": "Human:<br>No, there should be one for July...",
            "id": "f24ddbb9f29456c25f45103e4517da95"
          },
          {
            "type": "html",
            "text": "Machine:<br>I don't know anything about that...",
            "id": "6e436c3394e3d464946278059f754e51"
          },
          {
            "type": "html",
            "text": "Human:<br>OK, what's their number?",
            "id": "d0492f648e4f546cd500bb12a6b615a9"
          },
          {
            "type": "html",
            "text": "Machine:<br>Their phone number?",
            "id": "914e7938acf0de911a990a4cce389e7d"
          },
          {
            "type": "html",
            "text": "Human:<br>Yes.",
            "id": "c92b57a6e3b3af222061f88ad64118bd"
          },
          {
            "type": "html",
            "text": "Machine:<br>Whose?",
            "id": "bb0ab978150eee21fd28c341a61dc2b7"
          },
          {
            "type": "html",
            "text": "Human:<br>The gas company's",
            "id": "adfb4b62b11880e1cf0823d079fbb421"
          },
          {
            "type": "html",
            "text": "Machine:<br>Which one?",
            "id": "eab58eadea61abff7a672e3273cec98b"
          },
          {
            "type": "html",
            "text": "Human:<br>The one who sends the bills",
            "id": "517e661ce323829852c262981fe80374"
          },
          {
            "type": "html",
            "text": "Machine:<br>The gas company who sends the gas bills?",
            "id": "751ddfffe6fecd1611a05d2fdccb2b74"
          },
          {
            "type": "html",
            "text": "Human:<br>Yes.",
            "id": "c92b57a6e3b3af222061f88ad64118bd"
          },
          {
            "type": "html",
            "text": "Machine:<br>Which ones?",
            "id": "a7f8e28b23584a1d85e41cc8a07e8d26"
          },
          {
            "type": "html",
            "text": "Human:<br>The last one.",
            "id": "9d4c140be1b89112602a4f6d7281e36e"
          },
          {
            "type": "html",
            "text": "Machine:<br>You mean April 2004?",
            "id": "c909bc97b6151de300a2e53a8c6b3f69"
          },
          {
            "type": "html",
            "text": "Human:<br><sigh> I suppose so.",
            "id": "6762f0bdf41e7a52c0ce3ce9a79ac8b5"
          },
          {
            "type": "html",
            "text": "Machine:<br>I don't know, is it on the bill?",
            "id": "cbb9ec8b6b9a55bb4bf1c9a0b09c6c2f"
          },
          {
            "type": "html",
            "text": "Human:<br>I suppose so, let's have a look...",
            "id": "1e14c6109b0ff7ec0df506bc3ad98f7e"
          },
          {
            "type": "html",
            "text": "Machine:<br>Shall I display your April 2004 gas bill?",
            "id": "df1048db79ef42caf1ae6e9d148e82d6"
          },
          {
            "type": "html",
            "text": "Human:<br>Please.",
            "id": "fd44aa53caa92e42c8331019fb4fbcd0"
          },
          {
            "type": "html",
            "text": "Machine:<br>No need to be polite, I'm only a machine! To you and...? ",
            "id": "d68a675a74ca9f9a57f97e6162051021"
          },
          {
            "type": "html",
            "text": "Human:<br>Just to me!",
            "id": "f4a7a4d4f8176dc8a90f916a78a49227"
          },
          {
            "type": "html",
            "text": "Machine:<br>Here you are... grumpy",
            "id": "244de6336144e1ed54ec75a1ca16b074"
          },
          {
            "type": "html",
            "text": "<i>Ok, maybe you're right after all!)</i>",
            "id": "1e87d2cbd6fe35d4075902d62f688016"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5f031304b6ffce00e9b191b46ff1d6b1"
          },
          {
            "type": "html",
            "text": "See also: [[Programming Paradigm]], [[Functional Functions]], [[Functional In Imperative]]",
            "id": "bbca0d19ac6e374c88f385651f4c3379"
          },
          {
            "type": "html",
            "text": "\n[[Category Functional Programming]]",
            "id": "feff46db9922a61547e47a3213ca13ad"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?FunctionalProgramming c2.com]",
            "id": "43e143727d92a17d8eef2f788b1ef17d"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1626127404812
    },
    {
      "type": "fork",
      "date": 1626127434845
    }
  ]
}