{
  "title": "NeoJSON",
  "story": [
    {
      "type": "markdown",
      "id": "40d92b2f609e72a0",
      "text": "Smalltalk framework to read and write [[JSON]] converting to or from Smalltalk objects, maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]"
    },
    {
      "type": "markdown",
      "id": "a562346c64e535fe",
      "text": "This section shows some quick examples but there is a great documentation made by Sven [https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md github] and a chapter in Enterprise Pharo (chapter 8) [https://books.pharo.org/enterprise-pharo/ site]. [http://files.pharo.org/books-pdfs/entreprise-pharo/2016-10-06-EnterprisePharo.pdf pdf] (2016-10-06)"
    },
    {
      "type": "paragraph",
      "id": "b7e165677c0a6954",
      "text": "Go ahead and read the NeoJSON paper. [https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md github]"
    },
    {
      "type": "markdown",
      "id": "75f24c58be4007c6",
      "text": "# JSON\n\n*Sven Van Caekenberghe*\n\n*June 2012*\n\n*(This is a draft)*\n\n\nJSON (JavaScript Object Notation) is a popular data-interchange format. NeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.   \n\n\n## An introduction to JSON\n\n\nJSON is a lightweight text-based open standard designed for human-readable data interchange. \nIt was derived from the JavaScript scripting language for representing simple data structures and associative arrays, called objects. \nDespite its relationship to JavaScript, it is language-independent, with parsers available for many languages.\n\nHere are some relevant links:\n\n- <http://www.json.org/>\n- <http://en.wikipedia.org/wiki/Json>\n- <http://www.ietf.org/rfc/rfc4627.txt?number=4627>\n\nThere are only a couple of primitive types in JSON:\n\n- numbers (integer or floating point)\n- strings\n- the boolean constants true and false\n- null\n\nOnly two composite types exist:\n\n- lists (an ordered sequenece of values)\n- maps (an unordered associative array, mapping string property names to values)\n\nThat is really all there is to it. No options or additions are defined in the standard.\n\n\n## NeoJSON\n\n\nThe NeoJSON framework contains a reader (NeoJSONReader) and a writer (NeoJSONWriter)\nto parse respectively generate JSON to or from Smalltalk objects.\nThe goals of this project are:\n\n- to be standalone (have no dependencies and have little requirements)\n- to be small, elegant and understandable\n- to be efficient (both in time and space)\n- to be flexible and non-intrusive\n\nCompared to other Smalltalk JSON frameworks, NeoJSON has\n\n- less dependencies and little requirements\n- can be more efficient (be faster and use less memory)\n- allows for the use of schemas and mappings\n\n\n## Primitives\n\nObviously, the primitive types are mapped to corresponding Smalltalk classes.\nWhile reading:\n\n- numbers become Integers or Floats\n- strings become Strings\n- booleans become Booleans\n- null become nil\n\nWhile writing\n\n- Numbers are converted to floats, except for Integers that become integers\n- Strings and subclasses become strings\n- Booleans become booleans\n- nil becomes null\n\n\n## Generic Mode\n\n\nNeoJSON can operate in a generic mode that requires no further configuration.\nWhile reading:\n\n- maps become instances of mapClass, Dictionary by default\n- lists become instance of listClass, Array by default\n\nThe reader can be customized to use a different mapClass or listClass.\nThere is also an option to convert all map keys to symbols, which is off by default.\nWhile writing:\n\n- Dictionary and SmallDictionary become maps\n- all other Collection classes become lists\n- all other Objects are rejected\n\nHere are some examples writing in generic mode:\n\n\tNeoJSONWriter toString: #(1 2 3).\n\t\n\tNeoJSONWriter toString: { Float pi. true. false. 'string' }.\n\t\n\tNeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).\n\nNeoJSONWriter can output either in a compact format (the default) or in a pretty printed format.\nAnd these are some examples reading in generic mode:\n\n\tNeoJSONReader fromString: ' [ 1,2,3 ] '.\n\n\tNeoJSONReader fromString: ' [ 3.14159, true, false, null, \"string\" ] '.\n\n\tNeoJSONReader fromString: ' { \"x\" : 1, \"y\" : 2 } '.\n\n\nIn order to use the generic mode, you have to convert your domain objects to and from\nDictionaries and SequenceableCollections. This is realatively easy but not very efficient,\ndepending on the use case.\n\n\n## Schemas and Mappings\n\n\nNeoJSON allows for the optional specification of schemas and mappings to be used\nwhen writing and/or when reading.\nA NeoJSONMapper holds a number of schemas.\nEach schema is identified by either a class or a symbol.\nEach schema specifies a mapping, an object that will help in doing the actual reading or writing.\n\nThe most common mapping deals with objects that define a number of named properties or attributes.\nThese can be defined based on instance variables (optionally derived by reflection), \naccessors (getter/setter pairs) or even blocks.\nSuch an object mapping is identified by a Smalltalk class, which is also used to create new instances.\nEach property mapping can have an optional value schema to be used recursively\nwhen reading and/or writing property values.\n\nThe less common custom mapping holds a generic reader and/or writer block to deal with \nspecial cases such as specific collection types with an optional schema for the elements, \nor a direct mapping of semi primitive types such as Date or DateAndTime.\n\nA mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.\n\nHere are some examples of mappings:\n\n\tmapper mapAllInstVarsFor: Point.\n\n\tmapper for: TestObject do: [ :mapping |\n\t\tmapping mapInstVars: #(id name).\n\t\t(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.\n\t\t(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.\n\t\t(mapping mapInstVar: #bytes) valueSchema: ByteArray ].\n\n\tmapper for: DateAndTime customDo: [ :mapping |\n\t\tmapping decoder: [ :string | DateAndTime fromString: string ].\n\t\tmapping encoder: [ :dateAndTime | dateAndTime printString ] ].\n\n\tmapper for: #ArrayOfPoints customDo: [ :mapping |\n\t\tmapping listOfElementSchema: Point ].\n\t\t\n\tmapper for: #DictionaryOfPoints customDo: [ :mapping |\n\t\tmapping mapWithValueSchema: Point ].\n\n\tmapper for: ByteArray customDo: [ :mapping |\n\t\tmapping listOfType: ByteArray ]\n\nThe classes NeoJSONReader and NeoJSONWriter are subclasses of NeoJSONMapper.\nWhen writing, mappings are used when arbitrary objects are seen.\nFor example, in order to be able to write an array of points, you could do as follows:\n\n\tString streamContents: [ :stream |\n\t\t(NeoJSONWriter on: stream)\n\t\t\tprettyPrint: true;\n\t\t\tmapInstVarsFor: Point;\n\t\t\tnextPut: (Array with: 1@3 with: -1@3) ].\n\nCollections are handled automatically, like in the generic case.\n"
    },
    {
      "type": "markdown",
      "id": "c2f23a98a1323133",
      "text": "When reading, a mapping is used as a binding or an explicit type specifying what Smalltalk objects that you want to read.\n"
    },
    {
      "type": "markdown",
      "id": "7258953cc1e074a5",
      "text": "Here is a very simple case, reading a map as a point:\n\n\t(NeoJSONReader on: ' { \"x\" : 1, \"y\" : 2 } ' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tnextAs: Point.\t\n\n\n"
    },
    {
      "type": "markdown",
      "id": "d4ad28cfc26772ec",
      "text": "Since JSON lacks a universal way to specify the class of an object/map, we have to specify the target schema that we want to use as an argument to #nextAs:.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "b6905f844ce6745c",
      "text": "With custom mappings, it is possible to \n- define the schema of the elements of a list\n- define the schema of the elements of a list as well as the class of the list\n- define the schema of the values of a map\nIn fact, NeoJSONCustomMapping can be extended to implement even more specialized mappings.\n \n\n"
    },
    {
      "type": "markdown",
      "id": "355e6fa20d497691",
      "text": "Finally, here is a more complex example, reading a list of maps as an array of points:\n\n\t(NeoJSONReader on: '[ { \"x\" : 1, \"y\" : 2 }, { \"x\" : 3, \"y\" : 4 } ]' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tfor: #ArrayOfPoints customDo: [ :mapping |\n\t\t\tmapping listOfElementSchema: Point ];\n\t\tnextAs: #ArrayOfPoints.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "e71d33914e8379ed",
      "text": "NeoJSON deals efficiently with mappings: the minimal amount of intermediary structures are created, which is quite different from the generic case.\n\n\n\n"
    },
    {
      "type": "markdown",
      "id": "2fa5e6db00837468",
      "text": "## Internals\n\n\nOn modern hardware, NeoJSON can write or read in the tens of thousands of small objects per second.\nSeveral benchmarks are included in the unit tests package.\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "NeoJSON",
        "story": []
      },
      "date": 1640089250736
    },
    {
      "item": {
        "type": "factory",
        "id": "40d92b2f609e72a0"
      },
      "id": "40d92b2f609e72a0",
      "type": "add",
      "date": 1640089257588
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "paragraph",
        "id": "40d92b2f609e72a0",
        "text": "NeoJSON is actually maintained by Sven Van Caekenberghe on [github](https://github.com/svenvc/NeoJSON). This section shows some quick examples but there is a great documentation made by Sven [github](https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md)and a chapter in Enterprise Pharo (chapter 8)."
      },
      "date": 1640089259726
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "paragraph",
        "id": "40d92b2f609e72a0",
        "text": "NeoJSON is actually maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]. This section shows some quick examples but there is a great documentation made by Sven [github](https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md)and a chapter in Enterprise Pharo (chapter 8)."
      },
      "date": 1640089273661
    },
    {
      "item": {
        "type": "factory",
        "id": "b7e165677c0a6954"
      },
      "id": "b7e165677c0a6954",
      "type": "add",
      "after": "40d92b2f609e72a0",
      "date": 1640090848364
    },
    {
      "type": "edit",
      "id": "b7e165677c0a6954",
      "item": {
        "type": "paragraph",
        "id": "b7e165677c0a6954",
        "text": "Go ahead and read the NeoJSON paper."
      },
      "date": 1640090852623
    },
    {
      "type": "edit",
      "id": "b7e165677c0a6954",
      "item": {
        "type": "paragraph",
        "id": "b7e165677c0a6954",
        "text": "Go ahead and read the NeoJSON paper. [https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md github]"
      },
      "date": 1640090873085
    },
    {
      "item": {
        "type": "factory",
        "id": "75f24c58be4007c6"
      },
      "id": "75f24c58be4007c6",
      "type": "add",
      "after": "b7e165677c0a6954",
      "date": 1640090891192
    },
    {
      "type": "edit",
      "id": "75f24c58be4007c6",
      "item": {
        "type": "markdown",
        "id": "75f24c58be4007c6",
        "text": "github"
      },
      "date": 1640090893565
    },
    {
      "type": "edit",
      "id": "75f24c58be4007c6",
      "item": {
        "type": "markdown",
        "id": "75f24c58be4007c6",
        "text": "# JSON\n\n*Sven Van Caekenberghe*\n\n*June 2012*\n\n*(This is a draft)*\n\n\nJSON (JavaScript Object Notation) is a popular data-interchange format.\nNeoJSON is an elegant and efficient standalone Smalltalk framework to \nread and write JSON converting to or from Smalltalk objects.   \n\n\n## An introduction to JSON\n\n\nJSON is a lightweight text-based open standard designed for human-readable data interchange. \nIt was derived from the JavaScript scripting language for representing simple data structures and associative arrays, called objects. \nDespite its relationship to JavaScript, it is language-independent, with parsers available for many languages.\n\nHere are some relevant links:\n\n- <http://www.json.org/>\n- <http://en.wikipedia.org/wiki/Json>\n- <http://www.ietf.org/rfc/rfc4627.txt?number=4627>\n\nThere are only a couple of primitive types in JSON:\n\n- numbers (integer or floating point)\n- strings\n- the boolean constants true and false\n- null\n\nOnly two composite types exist:\n\n- lists (an ordered sequenece of values)\n- maps (an unordered associative array, mapping string property names to values)\n\nThat is really all there is to it. No options or additions are defined in the standard.\n\n\n## NeoJSON\n\n\nThe NeoJSON framework contains a reader (NeoJSONReader) and a writer (NeoJSONWriter)\nto parse respectively generate JSON to or from Smalltalk objects.\nThe goals of this project are:\n\n- to be standalone (have no dependencies and have little requirements)\n- to be small, elegant and understandable\n- to be efficient (both in time and space)\n- to be flexible and non-intrusive\n\nCompared to other Smalltalk JSON frameworks, NeoJSON has\n\n- less dependencies and little requirements\n- can be more efficient (be faster and use less memory)\n- allows for the use of schemas and mappings\n\n\n## Primitives\n\nObviously, the primitive types are mapped to corresponding Smalltalk classes.\nWhile reading:\n\n- numbers become Integers or Floats\n- strings become Strings\n- booleans become Booleans\n- null become nil\n\nWhile writing\n\n- Numbers are converted to floats, except for Integers that become integers\n- Strings and subclasses become strings\n- Booleans become booleans\n- nil becomes null\n\n\n## Generic Mode\n\n\nNeoJSON can operate in a generic mode that requires no further configuration.\nWhile reading:\n\n- maps become instances of mapClass, Dictionary by default\n- lists become instance of listClass, Array by default\n\nThe reader can be customized to use a different mapClass or listClass.\nThere is also an option to convert all map keys to symbols, which is off by default.\nWhile writing:\n\n- Dictionary and SmallDictionary become maps\n- all other Collection classes become lists\n- all other Objects are rejected\n\nHere are some examples writing in generic mode:\n\n\tNeoJSONWriter toString: #(1 2 3).\n\t\n\tNeoJSONWriter toString: { Float pi. true. false. 'string' }.\n\t\n\tNeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).\n\nNeoJSONWriter can output either in a compact format (the default) or in a pretty printed format.\nAnd these are some examples reading in generic mode:\n\n\tNeoJSONReader fromString: ' [ 1,2,3 ] '.\n\n\tNeoJSONReader fromString: ' [ 3.14159, true, false, null, \"string\" ] '.\n\n\tNeoJSONReader fromString: ' { \"x\" : 1, \"y\" : 2 } '.\n\n\nIn order to use the generic mode, you have to convert your domain objects to and from\nDictionaries and SequenceableCollections. This is realatively easy but not very efficient,\ndepending on the use case.\n\n\n## Schemas and Mappings\n\n\nNeoJSON allows for the optional specification of schemas and mappings to be used\nwhen writing and/or when reading.\nA NeoJSONMapper holds a number of schemas.\nEach schema is identified by either a class or a symbol.\nEach schema specifies a mapping, an object that will help in doing the actual reading or writing.\n\nThe most common mapping deals with objects that define a number of named properties or attributes.\nThese can be defined based on instance variables (optionally derived by reflection), \naccessors (getter/setter pairs) or even blocks.\nSuch an object mapping is identified by a Smalltalk class, which is also used to create new instances.\nEach property mapping can have an optional value schema to be used recursively\nwhen reading and/or writing property values.\n\nThe less common custom mapping holds a generic reader and/or writer block to deal with \nspecial cases such as specific collection types with an optional schema for the elements, \nor a direct mapping of semi primitive types such as Date or DateAndTime.\n\nA mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.\n\nHere are some examples of mappings:\n\n\tmapper mapAllInstVarsFor: Point.\n\n\tmapper for: TestObject do: [ :mapping |\n\t\tmapping mapInstVars: #(id name).\n\t\t(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.\n\t\t(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.\n\t\t(mapping mapInstVar: #bytes) valueSchema: ByteArray ].\n\n\tmapper for: DateAndTime customDo: [ :mapping |\n\t\tmapping decoder: [ :string | DateAndTime fromString: string ].\n\t\tmapping encoder: [ :dateAndTime | dateAndTime printString ] ].\n\n\tmapper for: #ArrayOfPoints customDo: [ :mapping |\n\t\tmapping listOfElementSchema: Point ].\n\t\t\n\tmapper for: #DictionaryOfPoints customDo: [ :mapping |\n\t\tmapping mapWithValueSchema: Point ].\n\n\tmapper for: ByteArray customDo: [ :mapping |\n\t\tmapping listOfType: ByteArray ]\n\nThe classes NeoJSONReader and NeoJSONWriter are subclasses of NeoJSONMapper.\nWhen writing, mappings are used when arbitrary objects are seen.\nFor example, in order to be able to write an array of points, you could do as follows:\n\n\tString streamContents: [ :stream |\n\t\t(NeoJSONWriter on: stream)\n\t\t\tprettyPrint: true;\n\t\t\tmapInstVarsFor: Point;\n\t\t\tnextPut: (Array with: 1@3 with: -1@3) ].\n\nCollections are handled automatically, like in the generic case.\nWhen reading, a mapping is used as a binding or an explicit type specifying what Smalltalk objects that you want to read.\nHere is a very simple case, reading a map as a point:\n\n\t(NeoJSONReader on: ' { \"x\" : 1, \"y\" : 2 } ' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tnextAs: Point.\t\n\nSince JSON lacks a universal way to specify the class of an object/map, \nwe have to specify the target schema that we want to use as an argument to #nextAs:.\n\nWith custom mappings, it is possible to \n- define the schema of the elements of a list\n- define the schema of the elements of a list as well as the class of the list\n- define the schema of the values of a map\nIn fact, NeoJSONCustomMapping can be extended to implement even more specialized mappings.\n \nFinally, here is a more complex example, reading a list of maps as an array of points:\n\n\t(NeoJSONReader on: '[ { \"x\" : 1, \"y\" : 2 }, { \"x\" : 3, \"y\" : 4 } ]' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tfor: #ArrayOfPoints customDo: [ :mapping |\n\t\t\tmapping listOfElementSchema: Point ];\n\t\tnextAs: #ArrayOfPoints.\n\nNeoJSON deals efficiently with mappings: the minimal amount of intermediary structures are created,\nwhich is quite different from the generic case.\n\n\n## Internals\n\n\nOn modern hardware, NeoJSON can write or read in the tens of thousands of small objects per second.\nSeveral benchmarks are included in the unit tests package.\n"
      },
      "date": 1640090903849
    },
    {
      "type": "edit",
      "id": "75f24c58be4007c6",
      "item": {
        "type": "markdown",
        "id": "75f24c58be4007c6",
        "text": "# JSON\n\n*Sven Van Caekenberghe*\n\n*June 2012*\n\n*(This is a draft)*\n\n\nJSON (JavaScript Object Notation) is a popular data-interchange format.\nNeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.   \n\n\n## An introduction to JSON\n\n\nJSON is a lightweight text-based open standard designed for human-readable data interchange. \nIt was derived from the JavaScript scripting language for representing simple data structures and associative arrays, called objects. \nDespite its relationship to JavaScript, it is language-independent, with parsers available for many languages.\n\nHere are some relevant links:\n\n- <http://www.json.org/>\n- <http://en.wikipedia.org/wiki/Json>\n- <http://www.ietf.org/rfc/rfc4627.txt?number=4627>\n\nThere are only a couple of primitive types in JSON:\n\n- numbers (integer or floating point)\n- strings\n- the boolean constants true and false\n- null\n\nOnly two composite types exist:\n\n- lists (an ordered sequenece of values)\n- maps (an unordered associative array, mapping string property names to values)\n\nThat is really all there is to it. No options or additions are defined in the standard.\n\n\n## NeoJSON\n\n\nThe NeoJSON framework contains a reader (NeoJSONReader) and a writer (NeoJSONWriter)\nto parse respectively generate JSON to or from Smalltalk objects.\nThe goals of this project are:\n\n- to be standalone (have no dependencies and have little requirements)\n- to be small, elegant and understandable\n- to be efficient (both in time and space)\n- to be flexible and non-intrusive\n\nCompared to other Smalltalk JSON frameworks, NeoJSON has\n\n- less dependencies and little requirements\n- can be more efficient (be faster and use less memory)\n- allows for the use of schemas and mappings\n\n\n## Primitives\n\nObviously, the primitive types are mapped to corresponding Smalltalk classes.\nWhile reading:\n\n- numbers become Integers or Floats\n- strings become Strings\n- booleans become Booleans\n- null become nil\n\nWhile writing\n\n- Numbers are converted to floats, except for Integers that become integers\n- Strings and subclasses become strings\n- Booleans become booleans\n- nil becomes null\n\n\n## Generic Mode\n\n\nNeoJSON can operate in a generic mode that requires no further configuration.\nWhile reading:\n\n- maps become instances of mapClass, Dictionary by default\n- lists become instance of listClass, Array by default\n\nThe reader can be customized to use a different mapClass or listClass.\nThere is also an option to convert all map keys to symbols, which is off by default.\nWhile writing:\n\n- Dictionary and SmallDictionary become maps\n- all other Collection classes become lists\n- all other Objects are rejected\n\nHere are some examples writing in generic mode:\n\n\tNeoJSONWriter toString: #(1 2 3).\n\t\n\tNeoJSONWriter toString: { Float pi. true. false. 'string' }.\n\t\n\tNeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).\n\nNeoJSONWriter can output either in a compact format (the default) or in a pretty printed format.\nAnd these are some examples reading in generic mode:\n\n\tNeoJSONReader fromString: ' [ 1,2,3 ] '.\n\n\tNeoJSONReader fromString: ' [ 3.14159, true, false, null, \"string\" ] '.\n\n\tNeoJSONReader fromString: ' { \"x\" : 1, \"y\" : 2 } '.\n\n\nIn order to use the generic mode, you have to convert your domain objects to and from\nDictionaries and SequenceableCollections. This is realatively easy but not very efficient,\ndepending on the use case.\n\n\n## Schemas and Mappings\n\n\nNeoJSON allows for the optional specification of schemas and mappings to be used\nwhen writing and/or when reading.\nA NeoJSONMapper holds a number of schemas.\nEach schema is identified by either a class or a symbol.\nEach schema specifies a mapping, an object that will help in doing the actual reading or writing.\n\nThe most common mapping deals with objects that define a number of named properties or attributes.\nThese can be defined based on instance variables (optionally derived by reflection), \naccessors (getter/setter pairs) or even blocks.\nSuch an object mapping is identified by a Smalltalk class, which is also used to create new instances.\nEach property mapping can have an optional value schema to be used recursively\nwhen reading and/or writing property values.\n\nThe less common custom mapping holds a generic reader and/or writer block to deal with \nspecial cases such as specific collection types with an optional schema for the elements, \nor a direct mapping of semi primitive types such as Date or DateAndTime.\n\nA mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.\n\nHere are some examples of mappings:\n\n\tmapper mapAllInstVarsFor: Point.\n\n\tmapper for: TestObject do: [ :mapping |\n\t\tmapping mapInstVars: #(id name).\n\t\t(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.\n\t\t(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.\n\t\t(mapping mapInstVar: #bytes) valueSchema: ByteArray ].\n\n\tmapper for: DateAndTime customDo: [ :mapping |\n\t\tmapping decoder: [ :string | DateAndTime fromString: string ].\n\t\tmapping encoder: [ :dateAndTime | dateAndTime printString ] ].\n\n\tmapper for: #ArrayOfPoints customDo: [ :mapping |\n\t\tmapping listOfElementSchema: Point ].\n\t\t\n\tmapper for: #DictionaryOfPoints customDo: [ :mapping |\n\t\tmapping mapWithValueSchema: Point ].\n\n\tmapper for: ByteArray customDo: [ :mapping |\n\t\tmapping listOfType: ByteArray ]\n\nThe classes NeoJSONReader and NeoJSONWriter are subclasses of NeoJSONMapper.\nWhen writing, mappings are used when arbitrary objects are seen.\nFor example, in order to be able to write an array of points, you could do as follows:\n\n\tString streamContents: [ :stream |\n\t\t(NeoJSONWriter on: stream)\n\t\t\tprettyPrint: true;\n\t\t\tmapInstVarsFor: Point;\n\t\t\tnextPut: (Array with: 1@3 with: -1@3) ].\n\nCollections are handled automatically, like in the generic case.\nWhen reading, a mapping is used as a binding or an explicit type specifying what Smalltalk objects that you want to read.\nHere is a very simple case, reading a map as a point:\n\n\t(NeoJSONReader on: ' { \"x\" : 1, \"y\" : 2 } ' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tnextAs: Point.\t\n\nSince JSON lacks a universal way to specify the class of an object/map, \nwe have to specify the target schema that we want to use as an argument to #nextAs:.\n\nWith custom mappings, it is possible to \n- define the schema of the elements of a list\n- define the schema of the elements of a list as well as the class of the list\n- define the schema of the values of a map\nIn fact, NeoJSONCustomMapping can be extended to implement even more specialized mappings.\n \nFinally, here is a more complex example, reading a list of maps as an array of points:\n\n\t(NeoJSONReader on: '[ { \"x\" : 1, \"y\" : 2 }, { \"x\" : 3, \"y\" : 4 } ]' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tfor: #ArrayOfPoints customDo: [ :mapping |\n\t\t\tmapping listOfElementSchema: Point ];\n\t\tnextAs: #ArrayOfPoints.\n\nNeoJSON deals efficiently with mappings: the minimal amount of intermediary structures are created,\nwhich is quite different from the generic case.\n\n\n## Internals\n\n\nOn modern hardware, NeoJSON can write or read in the tens of thousands of small objects per second.\nSeveral benchmarks are included in the unit tests package.\n"
      },
      "date": 1640090921970
    },
    {
      "type": "edit",
      "id": "75f24c58be4007c6",
      "item": {
        "type": "markdown",
        "id": "75f24c58be4007c6",
        "text": "# JSON\n\n*Sven Van Caekenberghe*\n\n*June 2012*\n\n*(This is a draft)*\n\n\nJSON (JavaScript Object Notation) is a popular data-interchange format. NeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.   \n\n\n## An introduction to JSON\n\n\nJSON is a lightweight text-based open standard designed for human-readable data interchange. \nIt was derived from the JavaScript scripting language for representing simple data structures and associative arrays, called objects. \nDespite its relationship to JavaScript, it is language-independent, with parsers available for many languages.\n\nHere are some relevant links:\n\n- <http://www.json.org/>\n- <http://en.wikipedia.org/wiki/Json>\n- <http://www.ietf.org/rfc/rfc4627.txt?number=4627>\n\nThere are only a couple of primitive types in JSON:\n\n- numbers (integer or floating point)\n- strings\n- the boolean constants true and false\n- null\n\nOnly two composite types exist:\n\n- lists (an ordered sequenece of values)\n- maps (an unordered associative array, mapping string property names to values)\n\nThat is really all there is to it. No options or additions are defined in the standard.\n\n\n## NeoJSON\n\n\nThe NeoJSON framework contains a reader (NeoJSONReader) and a writer (NeoJSONWriter)\nto parse respectively generate JSON to or from Smalltalk objects.\nThe goals of this project are:\n\n- to be standalone (have no dependencies and have little requirements)\n- to be small, elegant and understandable\n- to be efficient (both in time and space)\n- to be flexible and non-intrusive\n\nCompared to other Smalltalk JSON frameworks, NeoJSON has\n\n- less dependencies and little requirements\n- can be more efficient (be faster and use less memory)\n- allows for the use of schemas and mappings\n\n\n## Primitives\n\nObviously, the primitive types are mapped to corresponding Smalltalk classes.\nWhile reading:\n\n- numbers become Integers or Floats\n- strings become Strings\n- booleans become Booleans\n- null become nil\n\nWhile writing\n\n- Numbers are converted to floats, except for Integers that become integers\n- Strings and subclasses become strings\n- Booleans become booleans\n- nil becomes null\n\n\n## Generic Mode\n\n\nNeoJSON can operate in a generic mode that requires no further configuration.\nWhile reading:\n\n- maps become instances of mapClass, Dictionary by default\n- lists become instance of listClass, Array by default\n\nThe reader can be customized to use a different mapClass or listClass.\nThere is also an option to convert all map keys to symbols, which is off by default.\nWhile writing:\n\n- Dictionary and SmallDictionary become maps\n- all other Collection classes become lists\n- all other Objects are rejected\n\nHere are some examples writing in generic mode:\n\n\tNeoJSONWriter toString: #(1 2 3).\n\t\n\tNeoJSONWriter toString: { Float pi. true. false. 'string' }.\n\t\n\tNeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).\n\nNeoJSONWriter can output either in a compact format (the default) or in a pretty printed format.\nAnd these are some examples reading in generic mode:\n\n\tNeoJSONReader fromString: ' [ 1,2,3 ] '.\n\n\tNeoJSONReader fromString: ' [ 3.14159, true, false, null, \"string\" ] '.\n\n\tNeoJSONReader fromString: ' { \"x\" : 1, \"y\" : 2 } '.\n\n\nIn order to use the generic mode, you have to convert your domain objects to and from\nDictionaries and SequenceableCollections. This is realatively easy but not very efficient,\ndepending on the use case.\n\n\n## Schemas and Mappings\n\n\nNeoJSON allows for the optional specification of schemas and mappings to be used\nwhen writing and/or when reading.\nA NeoJSONMapper holds a number of schemas.\nEach schema is identified by either a class or a symbol.\nEach schema specifies a mapping, an object that will help in doing the actual reading or writing.\n\nThe most common mapping deals with objects that define a number of named properties or attributes.\nThese can be defined based on instance variables (optionally derived by reflection), \naccessors (getter/setter pairs) or even blocks.\nSuch an object mapping is identified by a Smalltalk class, which is also used to create new instances.\nEach property mapping can have an optional value schema to be used recursively\nwhen reading and/or writing property values.\n\nThe less common custom mapping holds a generic reader and/or writer block to deal with \nspecial cases such as specific collection types with an optional schema for the elements, \nor a direct mapping of semi primitive types such as Date or DateAndTime.\n\nA mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.\n\nHere are some examples of mappings:\n\n\tmapper mapAllInstVarsFor: Point.\n\n\tmapper for: TestObject do: [ :mapping |\n\t\tmapping mapInstVars: #(id name).\n\t\t(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.\n\t\t(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.\n\t\t(mapping mapInstVar: #bytes) valueSchema: ByteArray ].\n\n\tmapper for: DateAndTime customDo: [ :mapping |\n\t\tmapping decoder: [ :string | DateAndTime fromString: string ].\n\t\tmapping encoder: [ :dateAndTime | dateAndTime printString ] ].\n\n\tmapper for: #ArrayOfPoints customDo: [ :mapping |\n\t\tmapping listOfElementSchema: Point ].\n\t\t\n\tmapper for: #DictionaryOfPoints customDo: [ :mapping |\n\t\tmapping mapWithValueSchema: Point ].\n\n\tmapper for: ByteArray customDo: [ :mapping |\n\t\tmapping listOfType: ByteArray ]\n\nThe classes NeoJSONReader and NeoJSONWriter are subclasses of NeoJSONMapper.\nWhen writing, mappings are used when arbitrary objects are seen.\nFor example, in order to be able to write an array of points, you could do as follows:\n\n\tString streamContents: [ :stream |\n\t\t(NeoJSONWriter on: stream)\n\t\t\tprettyPrint: true;\n\t\t\tmapInstVarsFor: Point;\n\t\t\tnextPut: (Array with: 1@3 with: -1@3) ].\n\nCollections are handled automatically, like in the generic case.\nWhen reading, a mapping is used as a binding or an explicit type specifying what Smalltalk objects that you want to read.\nHere is a very simple case, reading a map as a point:\n\n\t(NeoJSONReader on: ' { \"x\" : 1, \"y\" : 2 } ' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tnextAs: Point.\t\n\nSince JSON lacks a universal way to specify the class of an object/map, \nwe have to specify the target schema that we want to use as an argument to #nextAs:.\n\nWith custom mappings, it is possible to \n- define the schema of the elements of a list\n- define the schema of the elements of a list as well as the class of the list\n- define the schema of the values of a map\nIn fact, NeoJSONCustomMapping can be extended to implement even more specialized mappings.\n \nFinally, here is a more complex example, reading a list of maps as an array of points:\n\n\t(NeoJSONReader on: '[ { \"x\" : 1, \"y\" : 2 }, { \"x\" : 3, \"y\" : 4 } ]' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tfor: #ArrayOfPoints customDo: [ :mapping |\n\t\t\tmapping listOfElementSchema: Point ];\n\t\tnextAs: #ArrayOfPoints.\n\nNeoJSON deals efficiently with mappings: the minimal amount of intermediary structures are created,\nwhich is quite different from the generic case.\n\n\n## Internals\n\n\nOn modern hardware, NeoJSON can write or read in the tens of thousands of small objects per second.\nSeveral benchmarks are included in the unit tests package.\n"
      },
      "date": 1640090932003
    },
    {
      "type": "edit",
      "id": "75f24c58be4007c6",
      "item": {
        "type": "markdown",
        "id": "75f24c58be4007c6",
        "text": "# JSON\n\n*Sven Van Caekenberghe*\n\n*June 2012*\n\n*(This is a draft)*\n\n\nJSON (JavaScript Object Notation) is a popular data-interchange format. NeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.   \n\n\n## An introduction to JSON\n\n\nJSON is a lightweight text-based open standard designed for human-readable data interchange. \nIt was derived from the JavaScript scripting language for representing simple data structures and associative arrays, called objects. \nDespite its relationship to JavaScript, it is language-independent, with parsers available for many languages.\n\nHere are some relevant links:\n\n- <http://www.json.org/>\n- <http://en.wikipedia.org/wiki/Json>\n- <http://www.ietf.org/rfc/rfc4627.txt?number=4627>\n\nThere are only a couple of primitive types in JSON:\n\n- numbers (integer or floating point)\n- strings\n- the boolean constants true and false\n- null\n\nOnly two composite types exist:\n\n- lists (an ordered sequenece of values)\n- maps (an unordered associative array, mapping string property names to values)\n\nThat is really all there is to it. No options or additions are defined in the standard.\n\n\n## NeoJSON\n\n\nThe NeoJSON framework contains a reader (NeoJSONReader) and a writer (NeoJSONWriter)\nto parse respectively generate JSON to or from Smalltalk objects.\nThe goals of this project are:\n\n- to be standalone (have no dependencies and have little requirements)\n- to be small, elegant and understandable\n- to be efficient (both in time and space)\n- to be flexible and non-intrusive\n\nCompared to other Smalltalk JSON frameworks, NeoJSON has\n\n- less dependencies and little requirements\n- can be more efficient (be faster and use less memory)\n- allows for the use of schemas and mappings\n\n\n## Primitives\n\nObviously, the primitive types are mapped to corresponding Smalltalk classes.\nWhile reading:\n\n- numbers become Integers or Floats\n- strings become Strings\n- booleans become Booleans\n- null become nil\n\nWhile writing\n\n- Numbers are converted to floats, except for Integers that become integers\n- Strings and subclasses become strings\n- Booleans become booleans\n- nil becomes null\n\n\n## Generic Mode\n\n\nNeoJSON can operate in a generic mode that requires no further configuration.\nWhile reading:\n\n- maps become instances of mapClass, Dictionary by default\n- lists become instance of listClass, Array by default\n\nThe reader can be customized to use a different mapClass or listClass.\nThere is also an option to convert all map keys to symbols, which is off by default.\nWhile writing:\n\n- Dictionary and SmallDictionary become maps\n- all other Collection classes become lists\n- all other Objects are rejected\n\nHere are some examples writing in generic mode:\n\n\tNeoJSONWriter toString: #(1 2 3).\n\t\n\tNeoJSONWriter toString: { Float pi. true. false. 'string' }.\n\t\n\tNeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).\n\nNeoJSONWriter can output either in a compact format (the default) or in a pretty printed format.\nAnd these are some examples reading in generic mode:\n\n\tNeoJSONReader fromString: ' [ 1,2,3 ] '.\n\n\tNeoJSONReader fromString: ' [ 3.14159, true, false, null, \"string\" ] '.\n\n\tNeoJSONReader fromString: ' { \"x\" : 1, \"y\" : 2 } '.\n\n\nIn order to use the generic mode, you have to convert your domain objects to and from\nDictionaries and SequenceableCollections. This is realatively easy but not very efficient,\ndepending on the use case.\n\n\n## Schemas and Mappings\n\n\nNeoJSON allows for the optional specification of schemas and mappings to be used\nwhen writing and/or when reading.\nA NeoJSONMapper holds a number of schemas.\nEach schema is identified by either a class or a symbol.\nEach schema specifies a mapping, an object that will help in doing the actual reading or writing.\n\nThe most common mapping deals with objects that define a number of named properties or attributes.\nThese can be defined based on instance variables (optionally derived by reflection), \naccessors (getter/setter pairs) or even blocks.\nSuch an object mapping is identified by a Smalltalk class, which is also used to create new instances.\nEach property mapping can have an optional value schema to be used recursively\nwhen reading and/or writing property values.\n\nThe less common custom mapping holds a generic reader and/or writer block to deal with \nspecial cases such as specific collection types with an optional schema for the elements, \nor a direct mapping of semi primitive types such as Date or DateAndTime.\n\nA mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.\n\nHere are some examples of mappings:\n\n\tmapper mapAllInstVarsFor: Point.\n\n\tmapper for: TestObject do: [ :mapping |\n\t\tmapping mapInstVars: #(id name).\n\t\t(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.\n\t\t(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.\n\t\t(mapping mapInstVar: #bytes) valueSchema: ByteArray ].\n\n\tmapper for: DateAndTime customDo: [ :mapping |\n\t\tmapping decoder: [ :string | DateAndTime fromString: string ].\n\t\tmapping encoder: [ :dateAndTime | dateAndTime printString ] ].\n\n\tmapper for: #ArrayOfPoints customDo: [ :mapping |\n\t\tmapping listOfElementSchema: Point ].\n\t\t\n\tmapper for: #DictionaryOfPoints customDo: [ :mapping |\n\t\tmapping mapWithValueSchema: Point ].\n\n\tmapper for: ByteArray customDo: [ :mapping |\n\t\tmapping listOfType: ByteArray ]\n\nThe classes NeoJSONReader and NeoJSONWriter are subclasses of NeoJSONMapper.\nWhen writing, mappings are used when arbitrary objects are seen.\nFor example, in order to be able to write an array of points, you could do as follows:\n\n\tString streamContents: [ :stream |\n\t\t(NeoJSONWriter on: stream)\n\t\t\tprettyPrint: true;\n\t\t\tmapInstVarsFor: Point;\n\t\t\tnextPut: (Array with: 1@3 with: -1@3) ].\n\nCollections are handled automatically, like in the generic case.\nWhen reading, a mapping is used as a binding or an explicit type specifying what Smalltalk objects that you want to read.\nHere is a very simple case, reading a map as a point:\n\n\t(NeoJSONReader on: ' { \"x\" : 1, \"y\" : 2 } ' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tnextAs: Point.\t\n\nSince JSON lacks a universal way to specify the class of an object/map, \nwe have to specify the target schema that we want to use as an argument to #nextAs:.\n\nWith custom mappings, it is possible to \n- define the schema of the elements of a list\n- define the schema of the elements of a list as well as the class of the list\n- define the schema of the values of a map\nIn fact, NeoJSONCustomMapping can be extended to implement even more specialized mappings.\n \nFinally, here is a more complex example, reading a list of maps as an array of points:\n\n\t(NeoJSONReader on: '[ { \"x\" : 1, \"y\" : 2 }, { \"x\" : 3, \"y\" : 4 } ]' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tfor: #ArrayOfPoints customDo: [ :mapping |\n\t\t\tmapping listOfElementSchema: Point ];\n\t\tnextAs: #ArrayOfPoints.\n\nNeoJSON deals efficiently with mappings: the minimal amount of intermediary structures are created,\nwhich is quite different from the generic case.\n\n\n\n"
      },
      "date": 1640091097734
    },
    {
      "type": "add",
      "id": "2fa5e6db00837468",
      "item": {
        "type": "markdown",
        "id": "2fa5e6db00837468",
        "text": "## Internals\n\n\nOn modern hardware, NeoJSON can write or read in the tens of thousands of small objects per second.\nSeveral benchmarks are included in the unit tests package.\n"
      },
      "after": "75f24c58be4007c6",
      "date": 1640091103778
    },
    {
      "type": "edit",
      "id": "75f24c58be4007c6",
      "item": {
        "type": "markdown",
        "id": "75f24c58be4007c6",
        "text": "# JSON\n\n*Sven Van Caekenberghe*\n\n*June 2012*\n\n*(This is a draft)*\n\n\nJSON (JavaScript Object Notation) is a popular data-interchange format. NeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.   \n\n\n## An introduction to JSON\n\n\nJSON is a lightweight text-based open standard designed for human-readable data interchange. \nIt was derived from the JavaScript scripting language for representing simple data structures and associative arrays, called objects. \nDespite its relationship to JavaScript, it is language-independent, with parsers available for many languages.\n\nHere are some relevant links:\n\n- <http://www.json.org/>\n- <http://en.wikipedia.org/wiki/Json>\n- <http://www.ietf.org/rfc/rfc4627.txt?number=4627>\n\nThere are only a couple of primitive types in JSON:\n\n- numbers (integer or floating point)\n- strings\n- the boolean constants true and false\n- null\n\nOnly two composite types exist:\n\n- lists (an ordered sequenece of values)\n- maps (an unordered associative array, mapping string property names to values)\n\nThat is really all there is to it. No options or additions are defined in the standard.\n\n\n## NeoJSON\n\n\nThe NeoJSON framework contains a reader (NeoJSONReader) and a writer (NeoJSONWriter)\nto parse respectively generate JSON to or from Smalltalk objects.\nThe goals of this project are:\n\n- to be standalone (have no dependencies and have little requirements)\n- to be small, elegant and understandable\n- to be efficient (both in time and space)\n- to be flexible and non-intrusive\n\nCompared to other Smalltalk JSON frameworks, NeoJSON has\n\n- less dependencies and little requirements\n- can be more efficient (be faster and use less memory)\n- allows for the use of schemas and mappings\n\n\n## Primitives\n\nObviously, the primitive types are mapped to corresponding Smalltalk classes.\nWhile reading:\n\n- numbers become Integers or Floats\n- strings become Strings\n- booleans become Booleans\n- null become nil\n\nWhile writing\n\n- Numbers are converted to floats, except for Integers that become integers\n- Strings and subclasses become strings\n- Booleans become booleans\n- nil becomes null\n\n\n## Generic Mode\n\n\nNeoJSON can operate in a generic mode that requires no further configuration.\nWhile reading:\n\n- maps become instances of mapClass, Dictionary by default\n- lists become instance of listClass, Array by default\n\nThe reader can be customized to use a different mapClass or listClass.\nThere is also an option to convert all map keys to symbols, which is off by default.\nWhile writing:\n\n- Dictionary and SmallDictionary become maps\n- all other Collection classes become lists\n- all other Objects are rejected\n\nHere are some examples writing in generic mode:\n\n\tNeoJSONWriter toString: #(1 2 3).\n\t\n\tNeoJSONWriter toString: { Float pi. true. false. 'string' }.\n\t\n\tNeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).\n\nNeoJSONWriter can output either in a compact format (the default) or in a pretty printed format.\nAnd these are some examples reading in generic mode:\n\n\tNeoJSONReader fromString: ' [ 1,2,3 ] '.\n\n\tNeoJSONReader fromString: ' [ 3.14159, true, false, null, \"string\" ] '.\n\n\tNeoJSONReader fromString: ' { \"x\" : 1, \"y\" : 2 } '.\n\n\nIn order to use the generic mode, you have to convert your domain objects to and from\nDictionaries and SequenceableCollections. This is realatively easy but not very efficient,\ndepending on the use case.\n\n\n## Schemas and Mappings\n\n\nNeoJSON allows for the optional specification of schemas and mappings to be used\nwhen writing and/or when reading.\nA NeoJSONMapper holds a number of schemas.\nEach schema is identified by either a class or a symbol.\nEach schema specifies a mapping, an object that will help in doing the actual reading or writing.\n\nThe most common mapping deals with objects that define a number of named properties or attributes.\nThese can be defined based on instance variables (optionally derived by reflection), \naccessors (getter/setter pairs) or even blocks.\nSuch an object mapping is identified by a Smalltalk class, which is also used to create new instances.\nEach property mapping can have an optional value schema to be used recursively\nwhen reading and/or writing property values.\n\nThe less common custom mapping holds a generic reader and/or writer block to deal with \nspecial cases such as specific collection types with an optional schema for the elements, \nor a direct mapping of semi primitive types such as Date or DateAndTime.\n\nA mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.\n\nHere are some examples of mappings:\n\n\tmapper mapAllInstVarsFor: Point.\n\n\tmapper for: TestObject do: [ :mapping |\n\t\tmapping mapInstVars: #(id name).\n\t\t(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.\n\t\t(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.\n\t\t(mapping mapInstVar: #bytes) valueSchema: ByteArray ].\n\n\tmapper for: DateAndTime customDo: [ :mapping |\n\t\tmapping decoder: [ :string | DateAndTime fromString: string ].\n\t\tmapping encoder: [ :dateAndTime | dateAndTime printString ] ].\n\n\tmapper for: #ArrayOfPoints customDo: [ :mapping |\n\t\tmapping listOfElementSchema: Point ].\n\t\t\n\tmapper for: #DictionaryOfPoints customDo: [ :mapping |\n\t\tmapping mapWithValueSchema: Point ].\n\n\tmapper for: ByteArray customDo: [ :mapping |\n\t\tmapping listOfType: ByteArray ]\n\nThe classes NeoJSONReader and NeoJSONWriter are subclasses of NeoJSONMapper.\nWhen writing, mappings are used when arbitrary objects are seen.\nFor example, in order to be able to write an array of points, you could do as follows:\n\n\tString streamContents: [ :stream |\n\t\t(NeoJSONWriter on: stream)\n\t\t\tprettyPrint: true;\n\t\t\tmapInstVarsFor: Point;\n\t\t\tnextPut: (Array with: 1@3 with: -1@3) ].\n\nCollections are handled automatically, like in the generic case.\nWhen reading, a mapping is used as a binding or an explicit type specifying what Smalltalk objects that you want to read.\nHere is a very simple case, reading a map as a point:\n\n\t(NeoJSONReader on: ' { \"x\" : 1, \"y\" : 2 } ' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tnextAs: Point.\t\n\nSince JSON lacks a universal way to specify the class of an object/map, \nwe have to specify the target schema that we want to use as an argument to #nextAs:.\n\nWith custom mappings, it is possible to \n- define the schema of the elements of a list\n- define the schema of the elements of a list as well as the class of the list\n- define the schema of the values of a map\nIn fact, NeoJSONCustomMapping can be extended to implement even more specialized mappings.\n \nFinally, here is a more complex example, reading a list of maps as an array of points:\n\n\t(NeoJSONReader on: '[ { \"x\" : 1, \"y\" : 2 }, { \"x\" : 3, \"y\" : 4 } ]' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tfor: #ArrayOfPoints customDo: [ :mapping |\n\t\t\tmapping listOfElementSchema: Point ];\n\t\tnextAs: #ArrayOfPoints.\n\n\n"
      },
      "date": 1640091133559
    },
    {
      "type": "add",
      "id": "e71d33914e8379ed",
      "item": {
        "type": "markdown",
        "id": "e71d33914e8379ed",
        "text": "NeoJSON deals efficiently with mappings: the minimal amount of intermediary structures are created, which is quite different from the generic case.\n\n\n\n"
      },
      "after": "75f24c58be4007c6",
      "date": 1640091138600
    },
    {
      "type": "edit",
      "id": "75f24c58be4007c6",
      "item": {
        "type": "markdown",
        "id": "75f24c58be4007c6",
        "text": "# JSON\n\n*Sven Van Caekenberghe*\n\n*June 2012*\n\n*(This is a draft)*\n\n\nJSON (JavaScript Object Notation) is a popular data-interchange format. NeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.   \n\n\n## An introduction to JSON\n\n\nJSON is a lightweight text-based open standard designed for human-readable data interchange. \nIt was derived from the JavaScript scripting language for representing simple data structures and associative arrays, called objects. \nDespite its relationship to JavaScript, it is language-independent, with parsers available for many languages.\n\nHere are some relevant links:\n\n- <http://www.json.org/>\n- <http://en.wikipedia.org/wiki/Json>\n- <http://www.ietf.org/rfc/rfc4627.txt?number=4627>\n\nThere are only a couple of primitive types in JSON:\n\n- numbers (integer or floating point)\n- strings\n- the boolean constants true and false\n- null\n\nOnly two composite types exist:\n\n- lists (an ordered sequenece of values)\n- maps (an unordered associative array, mapping string property names to values)\n\nThat is really all there is to it. No options or additions are defined in the standard.\n\n\n## NeoJSON\n\n\nThe NeoJSON framework contains a reader (NeoJSONReader) and a writer (NeoJSONWriter)\nto parse respectively generate JSON to or from Smalltalk objects.\nThe goals of this project are:\n\n- to be standalone (have no dependencies and have little requirements)\n- to be small, elegant and understandable\n- to be efficient (both in time and space)\n- to be flexible and non-intrusive\n\nCompared to other Smalltalk JSON frameworks, NeoJSON has\n\n- less dependencies and little requirements\n- can be more efficient (be faster and use less memory)\n- allows for the use of schemas and mappings\n\n\n## Primitives\n\nObviously, the primitive types are mapped to corresponding Smalltalk classes.\nWhile reading:\n\n- numbers become Integers or Floats\n- strings become Strings\n- booleans become Booleans\n- null become nil\n\nWhile writing\n\n- Numbers are converted to floats, except for Integers that become integers\n- Strings and subclasses become strings\n- Booleans become booleans\n- nil becomes null\n\n\n## Generic Mode\n\n\nNeoJSON can operate in a generic mode that requires no further configuration.\nWhile reading:\n\n- maps become instances of mapClass, Dictionary by default\n- lists become instance of listClass, Array by default\n\nThe reader can be customized to use a different mapClass or listClass.\nThere is also an option to convert all map keys to symbols, which is off by default.\nWhile writing:\n\n- Dictionary and SmallDictionary become maps\n- all other Collection classes become lists\n- all other Objects are rejected\n\nHere are some examples writing in generic mode:\n\n\tNeoJSONWriter toString: #(1 2 3).\n\t\n\tNeoJSONWriter toString: { Float pi. true. false. 'string' }.\n\t\n\tNeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).\n\nNeoJSONWriter can output either in a compact format (the default) or in a pretty printed format.\nAnd these are some examples reading in generic mode:\n\n\tNeoJSONReader fromString: ' [ 1,2,3 ] '.\n\n\tNeoJSONReader fromString: ' [ 3.14159, true, false, null, \"string\" ] '.\n\n\tNeoJSONReader fromString: ' { \"x\" : 1, \"y\" : 2 } '.\n\n\nIn order to use the generic mode, you have to convert your domain objects to and from\nDictionaries and SequenceableCollections. This is realatively easy but not very efficient,\ndepending on the use case.\n\n\n## Schemas and Mappings\n\n\nNeoJSON allows for the optional specification of schemas and mappings to be used\nwhen writing and/or when reading.\nA NeoJSONMapper holds a number of schemas.\nEach schema is identified by either a class or a symbol.\nEach schema specifies a mapping, an object that will help in doing the actual reading or writing.\n\nThe most common mapping deals with objects that define a number of named properties or attributes.\nThese can be defined based on instance variables (optionally derived by reflection), \naccessors (getter/setter pairs) or even blocks.\nSuch an object mapping is identified by a Smalltalk class, which is also used to create new instances.\nEach property mapping can have an optional value schema to be used recursively\nwhen reading and/or writing property values.\n\nThe less common custom mapping holds a generic reader and/or writer block to deal with \nspecial cases such as specific collection types with an optional schema for the elements, \nor a direct mapping of semi primitive types such as Date or DateAndTime.\n\nA mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.\n\nHere are some examples of mappings:\n\n\tmapper mapAllInstVarsFor: Point.\n\n\tmapper for: TestObject do: [ :mapping |\n\t\tmapping mapInstVars: #(id name).\n\t\t(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.\n\t\t(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.\n\t\t(mapping mapInstVar: #bytes) valueSchema: ByteArray ].\n\n\tmapper for: DateAndTime customDo: [ :mapping |\n\t\tmapping decoder: [ :string | DateAndTime fromString: string ].\n\t\tmapping encoder: [ :dateAndTime | dateAndTime printString ] ].\n\n\tmapper for: #ArrayOfPoints customDo: [ :mapping |\n\t\tmapping listOfElementSchema: Point ].\n\t\t\n\tmapper for: #DictionaryOfPoints customDo: [ :mapping |\n\t\tmapping mapWithValueSchema: Point ].\n\n\tmapper for: ByteArray customDo: [ :mapping |\n\t\tmapping listOfType: ByteArray ]\n\nThe classes NeoJSONReader and NeoJSONWriter are subclasses of NeoJSONMapper.\nWhen writing, mappings are used when arbitrary objects are seen.\nFor example, in order to be able to write an array of points, you could do as follows:\n\n\tString streamContents: [ :stream |\n\t\t(NeoJSONWriter on: stream)\n\t\t\tprettyPrint: true;\n\t\t\tmapInstVarsFor: Point;\n\t\t\tnextPut: (Array with: 1@3 with: -1@3) ].\n\nCollections are handled automatically, like in the generic case.\nWhen reading, a mapping is used as a binding or an explicit type specifying what Smalltalk objects that you want to read.\nHere is a very simple case, reading a map as a point:\n\n\t(NeoJSONReader on: ' { \"x\" : 1, \"y\" : 2 } ' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tnextAs: Point.\t\n\nSince JSON lacks a universal way to specify the class of an object/map, \nwe have to specify the target schema that we want to use as an argument to #nextAs:.\n\nWith custom mappings, it is possible to \n- define the schema of the elements of a list\n- define the schema of the elements of a list as well as the class of the list\n- define the schema of the values of a map\nIn fact, NeoJSONCustomMapping can be extended to implement even more specialized mappings.\n \n\n"
      },
      "date": 1640091147772
    },
    {
      "type": "add",
      "id": "355e6fa20d497691",
      "item": {
        "type": "markdown",
        "id": "355e6fa20d497691",
        "text": "Finally, here is a more complex example, reading a list of maps as an array of points:\n\n\t(NeoJSONReader on: '[ { \"x\" : 1, \"y\" : 2 }, { \"x\" : 3, \"y\" : 4 } ]' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tfor: #ArrayOfPoints customDo: [ :mapping |\n\t\t\tmapping listOfElementSchema: Point ];\n\t\tnextAs: #ArrayOfPoints.\n\n\n"
      },
      "after": "75f24c58be4007c6",
      "date": 1640091151275
    },
    {
      "type": "edit",
      "id": "75f24c58be4007c6",
      "item": {
        "type": "markdown",
        "id": "75f24c58be4007c6",
        "text": "# JSON\n\n*Sven Van Caekenberghe*\n\n*June 2012*\n\n*(This is a draft)*\n\n\nJSON (JavaScript Object Notation) is a popular data-interchange format. NeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.   \n\n\n## An introduction to JSON\n\n\nJSON is a lightweight text-based open standard designed for human-readable data interchange. \nIt was derived from the JavaScript scripting language for representing simple data structures and associative arrays, called objects. \nDespite its relationship to JavaScript, it is language-independent, with parsers available for many languages.\n\nHere are some relevant links:\n\n- <http://www.json.org/>\n- <http://en.wikipedia.org/wiki/Json>\n- <http://www.ietf.org/rfc/rfc4627.txt?number=4627>\n\nThere are only a couple of primitive types in JSON:\n\n- numbers (integer or floating point)\n- strings\n- the boolean constants true and false\n- null\n\nOnly two composite types exist:\n\n- lists (an ordered sequenece of values)\n- maps (an unordered associative array, mapping string property names to values)\n\nThat is really all there is to it. No options or additions are defined in the standard.\n\n\n## NeoJSON\n\n\nThe NeoJSON framework contains a reader (NeoJSONReader) and a writer (NeoJSONWriter)\nto parse respectively generate JSON to or from Smalltalk objects.\nThe goals of this project are:\n\n- to be standalone (have no dependencies and have little requirements)\n- to be small, elegant and understandable\n- to be efficient (both in time and space)\n- to be flexible and non-intrusive\n\nCompared to other Smalltalk JSON frameworks, NeoJSON has\n\n- less dependencies and little requirements\n- can be more efficient (be faster and use less memory)\n- allows for the use of schemas and mappings\n\n\n## Primitives\n\nObviously, the primitive types are mapped to corresponding Smalltalk classes.\nWhile reading:\n\n- numbers become Integers or Floats\n- strings become Strings\n- booleans become Booleans\n- null become nil\n\nWhile writing\n\n- Numbers are converted to floats, except for Integers that become integers\n- Strings and subclasses become strings\n- Booleans become booleans\n- nil becomes null\n\n\n## Generic Mode\n\n\nNeoJSON can operate in a generic mode that requires no further configuration.\nWhile reading:\n\n- maps become instances of mapClass, Dictionary by default\n- lists become instance of listClass, Array by default\n\nThe reader can be customized to use a different mapClass or listClass.\nThere is also an option to convert all map keys to symbols, which is off by default.\nWhile writing:\n\n- Dictionary and SmallDictionary become maps\n- all other Collection classes become lists\n- all other Objects are rejected\n\nHere are some examples writing in generic mode:\n\n\tNeoJSONWriter toString: #(1 2 3).\n\t\n\tNeoJSONWriter toString: { Float pi. true. false. 'string' }.\n\t\n\tNeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).\n\nNeoJSONWriter can output either in a compact format (the default) or in a pretty printed format.\nAnd these are some examples reading in generic mode:\n\n\tNeoJSONReader fromString: ' [ 1,2,3 ] '.\n\n\tNeoJSONReader fromString: ' [ 3.14159, true, false, null, \"string\" ] '.\n\n\tNeoJSONReader fromString: ' { \"x\" : 1, \"y\" : 2 } '.\n\n\nIn order to use the generic mode, you have to convert your domain objects to and from\nDictionaries and SequenceableCollections. This is realatively easy but not very efficient,\ndepending on the use case.\n\n\n## Schemas and Mappings\n\n\nNeoJSON allows for the optional specification of schemas and mappings to be used\nwhen writing and/or when reading.\nA NeoJSONMapper holds a number of schemas.\nEach schema is identified by either a class or a symbol.\nEach schema specifies a mapping, an object that will help in doing the actual reading or writing.\n\nThe most common mapping deals with objects that define a number of named properties or attributes.\nThese can be defined based on instance variables (optionally derived by reflection), \naccessors (getter/setter pairs) or even blocks.\nSuch an object mapping is identified by a Smalltalk class, which is also used to create new instances.\nEach property mapping can have an optional value schema to be used recursively\nwhen reading and/or writing property values.\n\nThe less common custom mapping holds a generic reader and/or writer block to deal with \nspecial cases such as specific collection types with an optional schema for the elements, \nor a direct mapping of semi primitive types such as Date or DateAndTime.\n\nA mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.\n\nHere are some examples of mappings:\n\n\tmapper mapAllInstVarsFor: Point.\n\n\tmapper for: TestObject do: [ :mapping |\n\t\tmapping mapInstVars: #(id name).\n\t\t(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.\n\t\t(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.\n\t\t(mapping mapInstVar: #bytes) valueSchema: ByteArray ].\n\n\tmapper for: DateAndTime customDo: [ :mapping |\n\t\tmapping decoder: [ :string | DateAndTime fromString: string ].\n\t\tmapping encoder: [ :dateAndTime | dateAndTime printString ] ].\n\n\tmapper for: #ArrayOfPoints customDo: [ :mapping |\n\t\tmapping listOfElementSchema: Point ].\n\t\t\n\tmapper for: #DictionaryOfPoints customDo: [ :mapping |\n\t\tmapping mapWithValueSchema: Point ].\n\n\tmapper for: ByteArray customDo: [ :mapping |\n\t\tmapping listOfType: ByteArray ]\n\nThe classes NeoJSONReader and NeoJSONWriter are subclasses of NeoJSONMapper.\nWhen writing, mappings are used when arbitrary objects are seen.\nFor example, in order to be able to write an array of points, you could do as follows:\n\n\tString streamContents: [ :stream |\n\t\t(NeoJSONWriter on: stream)\n\t\t\tprettyPrint: true;\n\t\t\tmapInstVarsFor: Point;\n\t\t\tnextPut: (Array with: 1@3 with: -1@3) ].\n\nCollections are handled automatically, like in the generic case.\nWhen reading, a mapping is used as a binding or an explicit type specifying what Smalltalk objects that you want to read.\nHere is a very simple case, reading a map as a point:\n\n\t(NeoJSONReader on: ' { \"x\" : 1, \"y\" : 2 } ' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tnextAs: Point.\t\n\nSince JSON lacks a universal way to specify the class of an object/map, \nwe have to specify the target schema that we want to use as an argument to #nextAs:.\n\n\n"
      },
      "date": 1640091159113
    },
    {
      "type": "add",
      "id": "b6905f844ce6745c",
      "item": {
        "type": "markdown",
        "id": "b6905f844ce6745c",
        "text": "With custom mappings, it is possible to \n- define the schema of the elements of a list\n- define the schema of the elements of a list as well as the class of the list\n- define the schema of the values of a map\nIn fact, NeoJSONCustomMapping can be extended to implement even more specialized mappings.\n \n\n"
      },
      "after": "75f24c58be4007c6",
      "date": 1640091161341
    },
    {
      "type": "edit",
      "id": "75f24c58be4007c6",
      "item": {
        "type": "markdown",
        "id": "75f24c58be4007c6",
        "text": "# JSON\n\n*Sven Van Caekenberghe*\n\n*June 2012*\n\n*(This is a draft)*\n\n\nJSON (JavaScript Object Notation) is a popular data-interchange format. NeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.   \n\n\n## An introduction to JSON\n\n\nJSON is a lightweight text-based open standard designed for human-readable data interchange. \nIt was derived from the JavaScript scripting language for representing simple data structures and associative arrays, called objects. \nDespite its relationship to JavaScript, it is language-independent, with parsers available for many languages.\n\nHere are some relevant links:\n\n- <http://www.json.org/>\n- <http://en.wikipedia.org/wiki/Json>\n- <http://www.ietf.org/rfc/rfc4627.txt?number=4627>\n\nThere are only a couple of primitive types in JSON:\n\n- numbers (integer or floating point)\n- strings\n- the boolean constants true and false\n- null\n\nOnly two composite types exist:\n\n- lists (an ordered sequenece of values)\n- maps (an unordered associative array, mapping string property names to values)\n\nThat is really all there is to it. No options or additions are defined in the standard.\n\n\n## NeoJSON\n\n\nThe NeoJSON framework contains a reader (NeoJSONReader) and a writer (NeoJSONWriter)\nto parse respectively generate JSON to or from Smalltalk objects.\nThe goals of this project are:\n\n- to be standalone (have no dependencies and have little requirements)\n- to be small, elegant and understandable\n- to be efficient (both in time and space)\n- to be flexible and non-intrusive\n\nCompared to other Smalltalk JSON frameworks, NeoJSON has\n\n- less dependencies and little requirements\n- can be more efficient (be faster and use less memory)\n- allows for the use of schemas and mappings\n\n\n## Primitives\n\nObviously, the primitive types are mapped to corresponding Smalltalk classes.\nWhile reading:\n\n- numbers become Integers or Floats\n- strings become Strings\n- booleans become Booleans\n- null become nil\n\nWhile writing\n\n- Numbers are converted to floats, except for Integers that become integers\n- Strings and subclasses become strings\n- Booleans become booleans\n- nil becomes null\n\n\n## Generic Mode\n\n\nNeoJSON can operate in a generic mode that requires no further configuration.\nWhile reading:\n\n- maps become instances of mapClass, Dictionary by default\n- lists become instance of listClass, Array by default\n\nThe reader can be customized to use a different mapClass or listClass.\nThere is also an option to convert all map keys to symbols, which is off by default.\nWhile writing:\n\n- Dictionary and SmallDictionary become maps\n- all other Collection classes become lists\n- all other Objects are rejected\n\nHere are some examples writing in generic mode:\n\n\tNeoJSONWriter toString: #(1 2 3).\n\t\n\tNeoJSONWriter toString: { Float pi. true. false. 'string' }.\n\t\n\tNeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).\n\nNeoJSONWriter can output either in a compact format (the default) or in a pretty printed format.\nAnd these are some examples reading in generic mode:\n\n\tNeoJSONReader fromString: ' [ 1,2,3 ] '.\n\n\tNeoJSONReader fromString: ' [ 3.14159, true, false, null, \"string\" ] '.\n\n\tNeoJSONReader fromString: ' { \"x\" : 1, \"y\" : 2 } '.\n\n\nIn order to use the generic mode, you have to convert your domain objects to and from\nDictionaries and SequenceableCollections. This is realatively easy but not very efficient,\ndepending on the use case.\n\n\n## Schemas and Mappings\n\n\nNeoJSON allows for the optional specification of schemas and mappings to be used\nwhen writing and/or when reading.\nA NeoJSONMapper holds a number of schemas.\nEach schema is identified by either a class or a symbol.\nEach schema specifies a mapping, an object that will help in doing the actual reading or writing.\n\nThe most common mapping deals with objects that define a number of named properties or attributes.\nThese can be defined based on instance variables (optionally derived by reflection), \naccessors (getter/setter pairs) or even blocks.\nSuch an object mapping is identified by a Smalltalk class, which is also used to create new instances.\nEach property mapping can have an optional value schema to be used recursively\nwhen reading and/or writing property values.\n\nThe less common custom mapping holds a generic reader and/or writer block to deal with \nspecial cases such as specific collection types with an optional schema for the elements, \nor a direct mapping of semi primitive types such as Date or DateAndTime.\n\nA mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.\n\nHere are some examples of mappings:\n\n\tmapper mapAllInstVarsFor: Point.\n\n\tmapper for: TestObject do: [ :mapping |\n\t\tmapping mapInstVars: #(id name).\n\t\t(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.\n\t\t(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.\n\t\t(mapping mapInstVar: #bytes) valueSchema: ByteArray ].\n\n\tmapper for: DateAndTime customDo: [ :mapping |\n\t\tmapping decoder: [ :string | DateAndTime fromString: string ].\n\t\tmapping encoder: [ :dateAndTime | dateAndTime printString ] ].\n\n\tmapper for: #ArrayOfPoints customDo: [ :mapping |\n\t\tmapping listOfElementSchema: Point ].\n\t\t\n\tmapper for: #DictionaryOfPoints customDo: [ :mapping |\n\t\tmapping mapWithValueSchema: Point ].\n\n\tmapper for: ByteArray customDo: [ :mapping |\n\t\tmapping listOfType: ByteArray ]\n\nThe classes NeoJSONReader and NeoJSONWriter are subclasses of NeoJSONMapper.\nWhen writing, mappings are used when arbitrary objects are seen.\nFor example, in order to be able to write an array of points, you could do as follows:\n\n\tString streamContents: [ :stream |\n\t\t(NeoJSONWriter on: stream)\n\t\t\tprettyPrint: true;\n\t\t\tmapInstVarsFor: Point;\n\t\t\tnextPut: (Array with: 1@3 with: -1@3) ].\n\nCollections are handled automatically, like in the generic case.\nWhen reading, a mapping is used as a binding or an explicit type specifying what Smalltalk objects that you want to read.\nHere is a very simple case, reading a map as a point:\n\n\t(NeoJSONReader on: ' { \"x\" : 1, \"y\" : 2 } ' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tnextAs: Point.\t\n\n\n"
      },
      "date": 1640091165810
    },
    {
      "type": "add",
      "id": "d4ad28cfc26772ec",
      "item": {
        "type": "markdown",
        "id": "d4ad28cfc26772ec",
        "text": "Since JSON lacks a universal way to specify the class of an object/map, we have to specify the target schema that we want to use as an argument to #nextAs:.\n\n\n"
      },
      "after": "75f24c58be4007c6",
      "date": 1640091171384
    },
    {
      "type": "edit",
      "id": "75f24c58be4007c6",
      "item": {
        "type": "markdown",
        "id": "75f24c58be4007c6",
        "text": "# JSON\n\n*Sven Van Caekenberghe*\n\n*June 2012*\n\n*(This is a draft)*\n\n\nJSON (JavaScript Object Notation) is a popular data-interchange format. NeoJSON is an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects.   \n\n\n## An introduction to JSON\n\n\nJSON is a lightweight text-based open standard designed for human-readable data interchange. \nIt was derived from the JavaScript scripting language for representing simple data structures and associative arrays, called objects. \nDespite its relationship to JavaScript, it is language-independent, with parsers available for many languages.\n\nHere are some relevant links:\n\n- <http://www.json.org/>\n- <http://en.wikipedia.org/wiki/Json>\n- <http://www.ietf.org/rfc/rfc4627.txt?number=4627>\n\nThere are only a couple of primitive types in JSON:\n\n- numbers (integer or floating point)\n- strings\n- the boolean constants true and false\n- null\n\nOnly two composite types exist:\n\n- lists (an ordered sequenece of values)\n- maps (an unordered associative array, mapping string property names to values)\n\nThat is really all there is to it. No options or additions are defined in the standard.\n\n\n## NeoJSON\n\n\nThe NeoJSON framework contains a reader (NeoJSONReader) and a writer (NeoJSONWriter)\nto parse respectively generate JSON to or from Smalltalk objects.\nThe goals of this project are:\n\n- to be standalone (have no dependencies and have little requirements)\n- to be small, elegant and understandable\n- to be efficient (both in time and space)\n- to be flexible and non-intrusive\n\nCompared to other Smalltalk JSON frameworks, NeoJSON has\n\n- less dependencies and little requirements\n- can be more efficient (be faster and use less memory)\n- allows for the use of schemas and mappings\n\n\n## Primitives\n\nObviously, the primitive types are mapped to corresponding Smalltalk classes.\nWhile reading:\n\n- numbers become Integers or Floats\n- strings become Strings\n- booleans become Booleans\n- null become nil\n\nWhile writing\n\n- Numbers are converted to floats, except for Integers that become integers\n- Strings and subclasses become strings\n- Booleans become booleans\n- nil becomes null\n\n\n## Generic Mode\n\n\nNeoJSON can operate in a generic mode that requires no further configuration.\nWhile reading:\n\n- maps become instances of mapClass, Dictionary by default\n- lists become instance of listClass, Array by default\n\nThe reader can be customized to use a different mapClass or listClass.\nThere is also an option to convert all map keys to symbols, which is off by default.\nWhile writing:\n\n- Dictionary and SmallDictionary become maps\n- all other Collection classes become lists\n- all other Objects are rejected\n\nHere are some examples writing in generic mode:\n\n\tNeoJSONWriter toString: #(1 2 3).\n\t\n\tNeoJSONWriter toString: { Float pi. true. false. 'string' }.\n\t\n\tNeoJSONWriter toStringPretty: (Dictionary new at: #x put: 1; at: #y put: 2; yourself).\n\nNeoJSONWriter can output either in a compact format (the default) or in a pretty printed format.\nAnd these are some examples reading in generic mode:\n\n\tNeoJSONReader fromString: ' [ 1,2,3 ] '.\n\n\tNeoJSONReader fromString: ' [ 3.14159, true, false, null, \"string\" ] '.\n\n\tNeoJSONReader fromString: ' { \"x\" : 1, \"y\" : 2 } '.\n\n\nIn order to use the generic mode, you have to convert your domain objects to and from\nDictionaries and SequenceableCollections. This is realatively easy but not very efficient,\ndepending on the use case.\n\n\n## Schemas and Mappings\n\n\nNeoJSON allows for the optional specification of schemas and mappings to be used\nwhen writing and/or when reading.\nA NeoJSONMapper holds a number of schemas.\nEach schema is identified by either a class or a symbol.\nEach schema specifies a mapping, an object that will help in doing the actual reading or writing.\n\nThe most common mapping deals with objects that define a number of named properties or attributes.\nThese can be defined based on instance variables (optionally derived by reflection), \naccessors (getter/setter pairs) or even blocks.\nSuch an object mapping is identified by a Smalltalk class, which is also used to create new instances.\nEach property mapping can have an optional value schema to be used recursively\nwhen reading and/or writing property values.\n\nThe less common custom mapping holds a generic reader and/or writer block to deal with \nspecial cases such as specific collection types with an optional schema for the elements, \nor a direct mapping of semi primitive types such as Date or DateAndTime.\n\nA mapping can be specified explicitely on a mapper, or can be resolved using the #neoJsonMapping: class method.\n\nHere are some examples of mappings:\n\n\tmapper mapAllInstVarsFor: Point.\n\n\tmapper for: TestObject do: [ :mapping |\n\t\tmapping mapInstVars: #(id name).\n\t\t(mapping mapInstVar: #timestamp to: 'created-at') valueSchema: DateAndTime.\n\t\t(mapping mapInstVar: #points) valueSchema: #ArrayOfPoints.\n\t\t(mapping mapInstVar: #bytes) valueSchema: ByteArray ].\n\n\tmapper for: DateAndTime customDo: [ :mapping |\n\t\tmapping decoder: [ :string | DateAndTime fromString: string ].\n\t\tmapping encoder: [ :dateAndTime | dateAndTime printString ] ].\n\n\tmapper for: #ArrayOfPoints customDo: [ :mapping |\n\t\tmapping listOfElementSchema: Point ].\n\t\t\n\tmapper for: #DictionaryOfPoints customDo: [ :mapping |\n\t\tmapping mapWithValueSchema: Point ].\n\n\tmapper for: ByteArray customDo: [ :mapping |\n\t\tmapping listOfType: ByteArray ]\n\nThe classes NeoJSONReader and NeoJSONWriter are subclasses of NeoJSONMapper.\nWhen writing, mappings are used when arbitrary objects are seen.\nFor example, in order to be able to write an array of points, you could do as follows:\n\n\tString streamContents: [ :stream |\n\t\t(NeoJSONWriter on: stream)\n\t\t\tprettyPrint: true;\n\t\t\tmapInstVarsFor: Point;\n\t\t\tnextPut: (Array with: 1@3 with: -1@3) ].\n\nCollections are handled automatically, like in the generic case.\n"
      },
      "date": 1640091228407
    },
    {
      "type": "add",
      "id": "c2f23a98a1323133",
      "item": {
        "type": "markdown",
        "id": "c2f23a98a1323133",
        "text": "When reading, a mapping is used as a binding or an explicit type specifying what Smalltalk objects that you want to read.\nHere is a very simple case, reading a map as a point:\n\n\t(NeoJSONReader on: ' { \"x\" : 1, \"y\" : 2 } ' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tnextAs: Point.\t\n\n\n"
      },
      "after": "75f24c58be4007c6",
      "date": 1640091232347
    },
    {
      "type": "edit",
      "id": "c2f23a98a1323133",
      "item": {
        "type": "markdown",
        "id": "c2f23a98a1323133",
        "text": "When reading, a mapping is used as a binding or an explicit type specifying what Smalltalk objects that you want to read.\n"
      },
      "date": 1640091241369
    },
    {
      "type": "add",
      "id": "7258953cc1e074a5",
      "item": {
        "type": "markdown",
        "id": "7258953cc1e074a5",
        "text": "Here is a very simple case, reading a map as a point:\n\n\t(NeoJSONReader on: ' { \"x\" : 1, \"y\" : 2 } ' readStream)\n\t\tmapInstVarsFor: Point;\n\t\tnextAs: Point.\t\n\n\n"
      },
      "after": "c2f23a98a1323133",
      "date": 1640091241760
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "paragraph",
        "id": "40d92b2f609e72a0",
        "text": "NeoJSON is actually maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]. This section shows some quick examples but there is a great documentation made by Sven [https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md github] and a chapter in Enterprise Pharo (chapter 8)."
      },
      "date": 1640091305314
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "paragraph",
        "id": "40d92b2f609e72a0",
        "text": "NeoJSON is actually maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]. This section shows some quick examples but there is a great documentation made by Sven [https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md github] and a chapter in Enterprise Pharo (chapter 8) [https://books.pharo.org/enterprise-pharo/ site]."
      },
      "date": 1640091331127
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "paragraph",
        "id": "40d92b2f609e72a0",
        "text": "NeoJSON is actually maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]. This section shows some quick examples but there is a great documentation made by Sven [https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md github] and a chapter in Enterprise Pharo (chapter 8) [https://books.pharo.org/enterprise-pharo/ site]. http://files.pharo.org/books-pdfs/entreprise-pharo/2016-10-06-EnterprisePharo.pdf"
      },
      "date": 1640091374496
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "markdown",
        "id": "40d92b2f609e72a0",
        "text": "NeoJSON is actually maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]. This section shows some quick examples but there is a great documentation made by Sven [https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md github] and a chapter in Enterprise Pharo (chapter 8) [https://books.pharo.org/enterprise-pharo/ site]. http://files.pharo.org/books-pdfs/entreprise-pharo/2016-10-06-EnterprisePharo.pdf"
      },
      "date": 1640091376056
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "markdown",
        "id": "40d92b2f609e72a0",
        "text": "NeoJSON is actually maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]. This section shows some quick examples but there is a great documentation made by Sven [https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md github] and a chapter in Enterprise Pharo (chapter 8) [https://books.pharo.org/enterprise-pharo/ site]. [ http://files.pharo.org/books-pdfs/entreprise-pharo/2016-10-06-EnterprisePharo.pdf pdf] (2016-10-06)"
      },
      "date": 1640091407305
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "markdown",
        "id": "40d92b2f609e72a0",
        "text": "NeoJSON is actually maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]. This section shows some quick examples but there is a great documentation made by Sven [https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md github] and a chapter in Enterprise Pharo (chapter 8) [https://books.pharo.org/enterprise-pharo/ site]. [http://files.pharo.org/books-pdfs/entreprise-pharo/2016-10-06-EnterprisePharo.pdf pdf] (2016-10-06)"
      },
      "date": 1640091414960
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "markdown",
        "id": "40d92b2f609e72a0",
        "text": "maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]"
      },
      "date": 1703387832401
    },
    {
      "type": "add",
      "id": "a562346c64e535fe",
      "item": {
        "type": "markdown",
        "id": "a562346c64e535fe",
        "text": "This section shows some quick examples but there is a great documentation made by Sven [https://github.com/svenvc/docs/blob/master/neo/neo-json-paper.md github] and a chapter in Enterprise Pharo (chapter 8) [https://books.pharo.org/enterprise-pharo/ site]. [http://files.pharo.org/books-pdfs/entreprise-pharo/2016-10-06-EnterprisePharo.pdf pdf] (2016-10-06)"
      },
      "after": "40d92b2f609e72a0",
      "date": 1703387834563
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "markdown",
        "id": "40d92b2f609e72a0",
        "text": "an elegant and efficient standalone Smalltalk framework to read and write JSON converting to or from Smalltalk objects."
      },
      "date": 1703387871465
    },
    {
      "type": "add",
      "id": "6c485a38dc6e8616",
      "item": {
        "type": "markdown",
        "id": "6c485a38dc6e8616",
        "text": "Maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]"
      },
      "after": "40d92b2f609e72a0",
      "date": 1703387872179
    },
    {
      "type": "edit",
      "id": "6c485a38dc6e8616",
      "item": {
        "type": "markdown",
        "id": "6c485a38dc6e8616",
        "text": "Maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]."
      },
      "date": 1703387882940
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "markdown",
        "id": "40d92b2f609e72a0",
        "text": "Smalltalk framework to read and write [[JSON]] converting to or from Smalltalk objects"
      },
      "date": 1703387911705
    },
    {
      "type": "remove",
      "id": "6c485a38dc6e8616",
      "date": 1703387928136
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "markdown",
        "id": "40d92b2f609e72a0",
        "text": "Smalltalk framework to read and write [[JSON]] converting to or from Smalltalk objects Maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]."
      },
      "date": 1703387931325
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "markdown",
        "id": "40d92b2f609e72a0",
        "text": "Smalltalk framework to read and write [[JSON]] converting to or from Smalltalk objects maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]."
      },
      "date": 1703387955199
    },
    {
      "type": "edit",
      "id": "40d92b2f609e72a0",
      "item": {
        "type": "markdown",
        "id": "40d92b2f609e72a0",
        "text": "Smalltalk framework to read and write [[JSON]] converting to or from Smalltalk objects, maintained by Sven Van Caekenberghe on [https://github.com/svenvc/NeoJSON github]"
      },
      "date": 1703387972254
    }
  ]
}