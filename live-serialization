{
  "title": "Live serialization",
  "story": [
    {
      "type": "markdown",
      "id": "a33e3381c2c3dcbd",
      "text": "The fact that both sides of the conversation are objects in live Smalltalk systems affords many optimizations that aren’t possible when serializing objects to a static file. For this reason, we call this [[live serialization]]. For example, when transferring a compiled method between systems, if the method’s literals are objects which already exist in the receiving system, we may write references to them rather than serializing them.\n"
    },
    {
      "type": "markdown",
      "id": "713785d71b81e6c4",
      "text": "We can also take special measures when the receiving system is missing the classes whose instances we want to transfer. Instead of assuming in advance that the receiving system lacks the classes whose instances we’re transferring, and including them in our payload, as a static serialization file would, we can transfer such classes only on demand. This yields much higher accuracy in object transfer, and far fewer bytes sent over the wire. Since live serialization is part of a complete remote messaging protocol, any messages at all can be sent from either side to complete an object transfer.\n"
    },
    {
      "type": "markdown",
      "id": "cff9283d6730d556",
      "text": "With a receiver, selector, and parameters specified, the receiving system can perform the message sent from the sending system. Each object in the system is responsible for serializing itself over a [[Tether]]. If the answer to the remote message is a literal object, like a symbol or integer, it will write the bytes of its value on the Tether instance handling the message. If the answer isn’t a literal object, by default it will write a reference to itself. Developers can choose to pass objects by value or by reference as they see fit."
    },
    {
      "type": "markdown",
      "id": "e48bc5a7d7f42d94",
      "text": "Next: [[Scheduling]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Live serialization",
        "story": []
      },
      "date": 1628927077457
    },
    {
      "item": {
        "type": "factory",
        "id": "a33e3381c2c3dcbd"
      },
      "id": "a33e3381c2c3dcbd",
      "type": "add",
      "date": 1628927087611
    },
    {
      "type": "edit",
      "id": "a33e3381c2c3dcbd",
      "item": {
        "type": "markdown",
        "id": "a33e3381c2c3dcbd",
        "text": "The fact that both sides of the conversation are objects in live Smalltalk systems affords many optimizations that aren’t possible when serializing objects to a static file. For this reason, I call this live serialization. For example, when transferring a compiled method between systems, if the method’s literals are objects which already exist in the receiving system, we may write references to them rather than serializing them.\n\nWe can also take special measures when the receiving system is missing the classes whose instances we want to transfer. Instead of assuming in advance that the receiving system lacks the classes whose instances we’re transferring, and including them in our payload, as a static serialization file would, we can transfer such classes only on demand. This yields much higher accuracy in object transfer, and far fewer bytes sent over the wire. Since live serialization is part of a complete remote messaging protocol, any messages at all can be sent from either side to complete an object transfer.\n\nWith a receiver, selector, and parameters specified, the receiving system can perform the message sent from the sending system. Each object in the system is responsible for serializing itself over a Tether. If the answer to the remote message is a literal object, like a symbol or integer, it will write the bytes of its value on the Tether instance handling the message. If the answer isn’t a literal object, by default it will write a reference to itself. Developers can choose to pass objects by value or by reference as they see fit."
      },
      "date": 1628927090525
    },
    {
      "type": "edit",
      "id": "a33e3381c2c3dcbd",
      "item": {
        "type": "markdown",
        "id": "a33e3381c2c3dcbd",
        "text": "The fact that both sides of the conversation are objects in live Smalltalk systems affords many optimizations that aren’t possible when serializing objects to a static file. For this reason, we call this [[live serialization]]. For example, when transferring a compiled method between systems, if the method’s literals are objects which already exist in the receiving system, we may write references to them rather than serializing them.\n"
      },
      "date": 1628927124959
    },
    {
      "type": "add",
      "id": "713785d71b81e6c4",
      "item": {
        "type": "markdown",
        "id": "713785d71b81e6c4",
        "text": "\nWe can also take special measures when the receiving system is missing the classes whose instances we want to transfer. Instead of assuming in advance that the receiving system lacks the classes whose instances we’re transferring, and including them in our payload, as a static serialization file would, we can transfer such classes only on demand. This yields much higher accuracy in object transfer, and far fewer bytes sent over the wire. Since live serialization is part of a complete remote messaging protocol, any messages at all can be sent from either side to complete an object transfer.\n\nWith a receiver, selector, and parameters specified, the receiving system can perform the message sent from the sending system. Each object in the system is responsible for serializing itself over a Tether. If the answer to the remote message is a literal object, like a symbol or integer, it will write the bytes of its value on the Tether instance handling the message. If the answer isn’t a literal object, by default it will write a reference to itself. Developers can choose to pass objects by value or by reference as they see fit."
      },
      "after": "a33e3381c2c3dcbd",
      "date": 1628927126066
    },
    {
      "type": "edit",
      "id": "713785d71b81e6c4",
      "item": {
        "type": "markdown",
        "id": "713785d71b81e6c4",
        "text": "We can also take special measures when the receiving system is missing the classes whose instances we want to transfer. Instead of assuming in advance that the receiving system lacks the classes whose instances we’re transferring, and including them in our payload, as a static serialization file would, we can transfer such classes only on demand. This yields much higher accuracy in object transfer, and far fewer bytes sent over the wire. Since live serialization is part of a complete remote messaging protocol, any messages at all can be sent from either side to complete an object transfer.\n"
      },
      "date": 1628927200851
    },
    {
      "type": "add",
      "id": "cff9283d6730d556",
      "item": {
        "type": "markdown",
        "id": "cff9283d6730d556",
        "text": "\nWith a receiver, selector, and parameters specified, the receiving system can perform the message sent from the sending system. Each object in the system is responsible for serializing itself over a Tether. If the answer to the remote message is a literal object, like a symbol or integer, it will write the bytes of its value on the Tether instance handling the message. If the answer isn’t a literal object, by default it will write a reference to itself. Developers can choose to pass objects by value or by reference as they see fit."
      },
      "after": "713785d71b81e6c4",
      "date": 1628927201940
    },
    {
      "type": "edit",
      "id": "cff9283d6730d556",
      "item": {
        "type": "markdown",
        "id": "cff9283d6730d556",
        "text": "With a receiver, selector, and parameters specified, the receiving system can perform the message sent from the sending system. Each object in the system is responsible for serializing itself over a [[Tether]]. If the answer to the remote message is a literal object, like a symbol or integer, it will write the bytes of its value on the Tether instance handling the message. If the answer isn’t a literal object, by default it will write a reference to itself. Developers can choose to pass objects by value or by reference as they see fit."
      },
      "date": 1628927230252
    },
    {
      "item": {
        "type": "factory",
        "id": "e48bc5a7d7f42d94"
      },
      "id": "e48bc5a7d7f42d94",
      "type": "add",
      "after": "cff9283d6730d556",
      "date": 1628927284205
    },
    {
      "type": "edit",
      "id": "e48bc5a7d7f42d94",
      "item": {
        "type": "markdown",
        "id": "e48bc5a7d7f42d94",
        "text": "Next: [[Scheduling]]"
      },
      "date": 1628927297538
    }
  ]
}