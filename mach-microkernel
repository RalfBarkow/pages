{
  "title": "Mach Microkernel",
  "story": [
    {
      "type": "html",
      "text": "The Mach [[Micro Kernel]] started as a project in [[Operating Systems Design]] at [[Carnegie Mellon University]]. ",
      "id": "e10e0ce8510356cc7b1d8a0eb40e013b"
    },
    {
      "type": "html",
      "text": "\nThe [[Micro Kernel]] (which isn't so micro by some standards) handles task scheduling, virtual memory abstraction, and inter-process communication and leaves the rest to server processes.",
      "id": "ad7e4d86b8aa6f0249ca674a6bcf68b8"
    },
    {
      "type": "html",
      "text": "\nThe original [[Mach Microkernel]] was used to run the BSD kernel as a server task that provided UNIX system call semantics. Interestingly enough, I don't think this configuration ever took advantage of the [[Micro Kernel]] at all.",
      "id": "633070a3637881129204fd6f49c7d2ed"
    },
    {
      "type": "html",
      "text": "<i>How would a system take advantage of the [[Micro Kernel]]? I.e., what exactly are [[Mac Osx]] users missing?</i>",
      "id": "03fe775206b6c9653e9374287ee02c54"
    },
    {
      "type": "html",
      "text": "\nOperating Systems running on top of Mach:",
      "id": "c941add3feb852c0ac669405aecdfee0"
    },
    {
      "type": "html",
      "text": " [[Next Step]] operating system (which did use the features of the microkernel a bit better than the standard BSD sever)",
      "id": "481bf75d90271658f369d8edd6ed86ee"
    },
    {
      "type": "html",
      "text": " [[Mac Osx]], being highly derivative of [[Next Step]].",
      "id": "0eb63af3958ead1e57e0ac962472d678"
    },
    {
      "type": "html",
      "text": " [[Mk Linux]]",
      "id": "ff7209ba399a165913e9357ade198e26"
    },
    {
      "type": "html",
      "text": " The [[Gnu Hurd]]",
      "id": "d184bd7203776c9d33dfbf596d0d1e07"
    },
    {
      "type": "html",
      "text": " [[Tru Unix Sixty Four]] nee [[Digital Unix]] nee [[Dec Osf One]]",
      "id": "8753b040169b39fb455aa60db84b7d22"
    },
    {
      "type": "html",
      "text": " RISCOS from the former British computer company Acorn was based on the Mach-Kernel, at least initially. <i>Are you sure? Could you provide any additional evidence for or information on this?</i> RISC OS was based on an OS called Arthur; the [[Mach Microkernel]] was not involved. -- [[David Plumpton]].  Arthur was RISC OS 1.  It has a simple kernel (with no multitasking at all - the window manager handles co-operative multutasking [CMT]) with loadable modules.  RISC OS Gold was an attempt to port the RISC OS GUI on to Mach, but it failed horribly.  --Rob Kendrick.",
      "id": "6b7e143e26bfce0407beacaff741e76f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9b9073482eb8b7979c6c62ce200c5339"
    },
    {
      "type": "html",
      "text": " I've always wondered how possible it might be to simultaneously run mkLinux and OSX on top of the same Mach kernel as separate services. I never found out anything certain about this. Anyone know?  -[[Kristoffer Lawson]]",
      "id": "b94939de0682ea943b451521d8afaed1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9b9073482eb8b7979c6c62ce200c5339"
    },
    {
      "type": "html",
      "text": "<i>(which isn't so micro by some standards)</i>  --  why is it not so micro anymore?  I've always heard that it was bloated for a microkernel concept, but I've never seen anything <i>tangible</i> to back the claims.",
      "id": "b085458e70459e8c40bc43c8e60332a9"
    },
    {
      "type": "html",
      "text": "<i>How would a system take advantage of the [[Micro Kernel]]? I.e., what exactly are [[Mac Osx]] users missing?</i>  --  This depends on how far you want to go.",
      "id": "6f21e574eeafbee34fb8d62fd6f79f90"
    },
    {
      "type": "html",
      "text": "\nAt a coarse level, you can have microkernel processes on the same scale as Unix processes.  In this case, device drivers are maintained in user-level processes that can be launched from system start-up or from the shell with equal facility.  Because they're user-level, a process that dies (say, due to a privilege violation) won't bring the whole machine down (like Linux modules can).  A process, much like inetd, can be written to watch for driver interaction, and dynamically launch drivers on an as-needed basis.  That same process can also watch for premature failures of the driver processes, and relaunch them silently as required.  Additionally, you're free to run multiple instances of a driver as required.  For example, I can conceive of a system whereby a ramdisk process can provide up to 1GB of RAM space for storage.  If you need more, you can run multiple ram disk processes, and use another driver process to bind them together into a single virtual volume.  More practically, the same concept can be applied to physical disks, where RAID configurations become as simple as editing a shell script.",
      "id": "9e38a5bb60fc6d93e242872b4d9ed7dc"
    },
    {
      "type": "html",
      "text": "\nAt a finer grain, microkernel processes behave with semantics that are compatible with <i>actors</i> in object oriented programming.  Therefore, microkernels may provide a better substrate for parallel programming than traditional, monolithic kernels.  Since many microkernels provide such a close mapping to Erlang processes, I can easily conceive an operating system designed on top of a microkernel where Erlang is the language of choice, allowing it to better exploit the characteristics of the underlying kernel.  Indeed, some environments (IIRC, [[Qnx Microkernel]]) have IDL compilers that allows a programmer to code up a daemon process of some kind, and make an RPC client library that talks to it.  I suspect that most tools are aware of objects.",
      "id": "f4994631260c3166340fd7a3c15418e7"
    },
    {
      "type": "html",
      "text": "--[[Samuel Falvo]]",
      "id": "9cad081da7671e16e7b22ed132af3f18"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9b9073482eb8b7979c6c62ce200c5339"
    },
    {
      "type": "html",
      "text": "\n[[Object Capability Operating System]] [[Category Operating System]]",
      "id": "1c986d09e6a80785890f5558b77c22b7"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?MachMicrokernel c2.com]",
      "id": "867534374de6173a580508c77dde49bf"
    }
  ],
  "journal": [
    {
      "date": 1188583058000,
      "id": "73a16c73002ae99e5de6aa0c95bec686",
      "type": "create",
      "item": {
        "title": "Mach Microkernel",
        "story": [
          {
            "type": "html",
            "text": "The Mach [[Micro Kernel]] started as a project in [[Operating Systems Design]] at [[Carnegie Mellon University]]. ",
            "id": "e10e0ce8510356cc7b1d8a0eb40e013b"
          },
          {
            "type": "html",
            "text": "\nThe [[Micro Kernel]] (which isn't so micro by some standards) handles task scheduling, virtual memory abstraction, and inter-process communication and leaves the rest to server processes.",
            "id": "ad7e4d86b8aa6f0249ca674a6bcf68b8"
          },
          {
            "type": "html",
            "text": "\nThe original [[Mach Microkernel]] was used to run the BSD kernel as a server task that provided UNIX system call semantics. Interestingly enough, I don't think this configuration ever took advantage of the [[Micro Kernel]] at all.",
            "id": "633070a3637881129204fd6f49c7d2ed"
          },
          {
            "type": "html",
            "text": "<i>How would a system take advantage of the [[Micro Kernel]]? I.e., what exactly are [[Mac Osx]] users missing?</i>",
            "id": "03fe775206b6c9653e9374287ee02c54"
          },
          {
            "type": "html",
            "text": "\nOperating Systems running on top of Mach:",
            "id": "c941add3feb852c0ac669405aecdfee0"
          },
          {
            "type": "html",
            "text": " [[Next Step]] operating system (which did use the features of the microkernel a bit better than the standard BSD sever)",
            "id": "481bf75d90271658f369d8edd6ed86ee"
          },
          {
            "type": "html",
            "text": " [[Mac Osx]], being highly derivative of [[Next Step]].",
            "id": "0eb63af3958ead1e57e0ac962472d678"
          },
          {
            "type": "html",
            "text": " [[Mk Linux]]",
            "id": "ff7209ba399a165913e9357ade198e26"
          },
          {
            "type": "html",
            "text": " The [[Gnu Hurd]]",
            "id": "d184bd7203776c9d33dfbf596d0d1e07"
          },
          {
            "type": "html",
            "text": " [[Tru Unix Sixty Four]] nee [[Digital Unix]] nee [[Dec Osf One]]",
            "id": "8753b040169b39fb455aa60db84b7d22"
          },
          {
            "type": "html",
            "text": " RISCOS from the former British computer company Acorn was based on the Mach-Kernel, at least initially. <i>Are you sure? Could you provide any additional evidence for or information on this?</i> RISC OS was based on an OS called Arthur; the [[Mach Microkernel]] was not involved. -- [[David Plumpton]].  Arthur was RISC OS 1.  It has a simple kernel (with no multitasking at all - the window manager handles co-operative multutasking [CMT]) with loadable modules.  RISC OS Gold was an attempt to port the RISC OS GUI on to Mach, but it failed horribly.  --Rob Kendrick.",
            "id": "6b7e143e26bfce0407beacaff741e76f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9b9073482eb8b7979c6c62ce200c5339"
          },
          {
            "type": "html",
            "text": " I've always wondered how possible it might be to simultaneously run mkLinux and OSX on top of the same Mach kernel as separate services. I never found out anything certain about this. Anyone know?  -[[Kristoffer Lawson]]",
            "id": "b94939de0682ea943b451521d8afaed1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9b9073482eb8b7979c6c62ce200c5339"
          },
          {
            "type": "html",
            "text": "<i>(which isn't so micro by some standards)</i>  --  why is it not so micro anymore?  I've always heard that it was bloated for a microkernel concept, but I've never seen anything <i>tangible</i> to back the claims.",
            "id": "b085458e70459e8c40bc43c8e60332a9"
          },
          {
            "type": "html",
            "text": "<i>How would a system take advantage of the [[Micro Kernel]]? I.e., what exactly are [[Mac Osx]] users missing?</i>  --  This depends on how far you want to go.",
            "id": "6f21e574eeafbee34fb8d62fd6f79f90"
          },
          {
            "type": "html",
            "text": "\nAt a coarse level, you can have microkernel processes on the same scale as Unix processes.  In this case, device drivers are maintained in user-level processes that can be launched from system start-up or from the shell with equal facility.  Because they're user-level, a process that dies (say, due to a privilege violation) won't bring the whole machine down (like Linux modules can).  A process, much like inetd, can be written to watch for driver interaction, and dynamically launch drivers on an as-needed basis.  That same process can also watch for premature failures of the driver processes, and relaunch them silently as required.  Additionally, you're free to run multiple instances of a driver as required.  For example, I can conceive of a system whereby a ramdisk process can provide up to 1GB of RAM space for storage.  If you need more, you can run multiple ram disk processes, and use another driver process to bind them together into a single virtual volume.  More practically, the same concept can be applied to physical disks, where RAID configurations become as simple as editing a shell script.",
            "id": "9e38a5bb60fc6d93e242872b4d9ed7dc"
          },
          {
            "type": "html",
            "text": "\nAt a finer grain, microkernel processes behave with semantics that are compatible with <i>actors</i> in object oriented programming.  Therefore, microkernels may provide a better substrate for parallel programming than traditional, monolithic kernels.  Since many microkernels provide such a close mapping to Erlang processes, I can easily conceive an operating system designed on top of a microkernel where Erlang is the language of choice, allowing it to better exploit the characteristics of the underlying kernel.  Indeed, some environments (IIRC, [[Qnx Microkernel]]) have IDL compilers that allows a programmer to code up a daemon process of some kind, and make an RPC client library that talks to it.  I suspect that most tools are aware of objects.",
            "id": "f4994631260c3166340fd7a3c15418e7"
          },
          {
            "type": "html",
            "text": "--[[Samuel Falvo]]",
            "id": "9cad081da7671e16e7b22ed132af3f18"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9b9073482eb8b7979c6c62ce200c5339"
          },
          {
            "type": "html",
            "text": "\n[[Object Capability Operating System]] [[Category Operating System]]",
            "id": "1c986d09e6a80785890f5558b77c22b7"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?MachMicrokernel c2.com]",
            "id": "867534374de6173a580508c77dde49bf"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1665179718932
    }
  ]
}