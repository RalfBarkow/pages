{
  "title": "2023-09-06",
  "story": [
    {
      "type": "paragraph",
      "id": "448a859433bc861b",
      "text": "⇐ [[Wiki Module]] ⇒ [[Render Story]] ⇒ [[Trail Climbing]] ⇒ [[Functions Are Containers]] ⇐  [[Functions That Do Not Forget]] ⇒ [[Sequence]]"
    },
    {
      "type": "image",
      "id": "d61d994bbaeb36a4",
      "text": "Side-by-Side Comparison [https://github.com/dreyeck/blog/commit/27ba4048efae557d442773d44f0ba54715f627e6 commit]",
      "size": "wide",
      "width": 419,
      "height": 148,
      "url": "/assets/plugins/image/c5af8b0fa7c0fe03374303b4267aa2d6.jpg"
    },
    {
      "type": "paragraph",
      "id": "b7e235132ef58e4d",
      "text": "We see the same [[Wiki Page JSON]] displayed on one side (left) by the fedwiki reference implementation and on the other side (right) by the elm-pages prototype."
    },
    {
      "type": "paragraph",
      "id": "90ecc08458ac00e4",
      "text": "How to configure Systemd service unit to start Node app with \"npm start\" instead of \"app.js\"  ⇒ [[configuration.nix @dreyeck]] ⇒ [[elm-pages.service]] ⇒ [[wiki.nix @dreyeck.ch]]"
    },
    {
      "type": "pagefold",
      "id": "59beda0aa2463411",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "f0cbaf616f3e5ee9",
      "text": "ALVIN, Olle, 2020. Rendering Resolution Independent Fonts in Games and 3D Applications. Exam paper. Lund University. [https://lup.lub.lu.se/luur/download?func=downloadFile&recordOId=9024910&fileOId=9024911 pdf] This thesis describes how fonts can be rendered in 3D-applications. It provides a description of how to render glyphs using signed distance  elds as well as the Slug-algorithm. The thesis provides an analysis of these methods and investigates how they can be combined. The combined method overcomes some of the artefacts produced by signed distance  elds, while being faster than the Slug-algorithm in most cases. However it is not suited for complex glyphs or small font sizes.\n"
    },
    {
      "type": "paragraph",
      "id": "e85e677c1e853e56",
      "text": "A pixel contains a color, typically as an RGB value."
    },
    {
      "type": "pagefold",
      "id": "49ad6afe55cbd31f",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "4309af65b82e86d0",
      "text": "DuckDuckGo is available on Tor. [https://duckduckgogg42xjoc72x3sjasowoarfbgcmvfimaftt6twagswzczad.onion/ onion address]"
    },
    {
      "type": "image",
      "id": "1f3ab14e4ee1d302",
      "text": "DuckDuckGo is available on Tor. [https://duckduckgogg42xjoc72x3sjasowoarfbgcmvfimaftt6twagswzczad.onion/ onion address]",
      "size": "thumbnail",
      "width": 183,
      "height": 183,
      "url": "/assets/plugins/image/944ebf16c0308c94dc4f43066845c17c.jpg"
    },
    {
      "type": "pagefold",
      "id": "4e6e59cf2d478375",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "527e6186721bb1ad",
      "text": "⇒ [[dmx-headless]] 5.3.2~2deb+b18435 ⇒ [[fbx]] ⇒ [[dmx.service]] (stop and mask)"
    },
    {
      "type": "paragraph",
      "id": "7eb8ed9355f9b3d2",
      "text": "⇒ [[Martin Holzmann]]. [https://www.linkedin.com/in/martin-holzmann-353ab74/ linkedin]"
    },
    {
      "type": "paragraph",
      "id": "ffeb296afa5585f5",
      "text": "⇒ [[SPA]] ⇒ [[Sebastian Springer]]. [https://www.linkedin.com/in/sebastian-springer-5252064a/ linkedin]"
    },
    {
      "type": "paragraph",
      "id": "dc49c2839a81588b",
      "text": "SPRINGER, Sebastian, 2023. Die neue Generation der JavaScript-Metaframeworks. iX. 26 Juli 2023. Bd. 2023, Nr. 8, S. 108–110 [https://www.heise.de/select/ix/2023/8/2309408465876534332 page]"
    },
    {
      "type": "paragraph",
      "id": "6daedabb93e95fbf",
      "text": "The Single-Page-Applications-Architecture (SPA) has become so popular that almost every problem can be solved with it. Angular, Vue and React have established themselves among the SPA frameworks. In the meantime, however, one must ask oneself how things will continue. For example, there are indications that the strict separation between client and server is slowly but surely being softened and that server-side development away from data interfaces is once again coming more into focus."
    },
    {
      "type": "paragraph",
      "id": "6d759c19ce0ae0db",
      "text": "Another trend is metaframeworks. Common practice in the JavaScript world is to assemble an application, framework, or library from existing packages. An empty SPA can therefore be between 100 and 300 MBytes in size – depending on the setup path and the initial package configuration. Included in this amount of data are tools and libraries for the developer experience that assist in the build process and are not transferred to the client. Metaframeworks take up this idea: They themselves use frameworks such as Angular, React or Vue as a basis, combine them and add further features."
    },
    {
      "type": "paragraph",
      "id": "c5bca6dc41ef3a13",
      "text": "Leverage strengths of client and server "
    },
    {
      "type": "paragraph",
      "id": "7e61957d30e9372b",
      "text": "The term metaframework still says little about the orientation. [[Nest]], for example, is a metaframework, but a server-side one that uses [[Express]] as its foundation. The popular client-side metaframeworks are currently developing into hybrid frameworks that combine the strengths of client and server and thus make the web an overarching platform again. The direction the evolution may take is foreshadowed by a statement from [[Dan Abramov]], one of React's core developers. He had this to say about the future of Create React App, the previous standard tool for setting up a React application: \"When I was thinking about possible futures for Create React App, it was clear client-only doesn't make sense. Way too limiting. Why are we always producing an empty HTML file if React can pre-render to HTML? Why can't i make a blog by map()ing over markdown files on my disk?\" (For link to source see [https://www.heise.de/select/ix/2023/8/softlinks/za4c?wt_mc=pred.red.ix.ix082023.108.softlink.softlink ix.de/za4c], [https://twitter.com/dan_abramov/status/1636827365677383700 tweet]). "
    },
    {
      "type": "paragraph",
      "id": "727f4c5579340787",
      "text": "He considers the previous purely client-side approach of React to make little sense in the future, as this architecture entails too many restrictions. This culminates in a web server delivering an SPA as an (almost) empty HTML document, which the browser then gradually fills with life. React tackles the issue head-on, recommending in its documentation that developers start a new application directly with a metaframework like Next.js, Remix or Gatsby. This does not mean that a Node.js background process is then always required for a React application, but it does show what the future may look like. Competitors have similar approaches, although they advertise them much less aggressively. The following list shows metaframeworks of various SPA frameworks:"
    },
    {
      "type": "paragraph",
      "id": "0e9cacfe1d4f2f54",
      "text": "React: Next.js, Gatsby, Remix"
    },
    {
      "type": "paragraph",
      "id": "868e084c4dc75fed",
      "text": "Vue: Nuxt, VuePress, Gridsome"
    },
    {
      "type": "paragraph",
      "id": "d75612daf44cf77a",
      "text": "Svelte: SvelteKit, Elder.js, Jungle"
    },
    {
      "type": "paragraph",
      "id": "6e0abe67f29059b1",
      "text": "Angular: Analog"
    },
    {
      "type": "paragraph",
      "id": "754047d1de43624f",
      "text": "[[Astro]]"
    },
    {
      "type": "paragraph",
      "id": "4df29b1c29e293f1",
      "text": "Astro is a metaframework and focuses on rendering the static parts of a page. It shows that it doesn't take a large framework to follow the idea of meta and hybrid frameworks. Rather, Astro flips the approach and allows frontend frameworks to be integrated into its architecture."
    },
    {
      "type": "paragraph",
      "id": "55e5eec4b63057b5",
      "text": "Client-side rendering delays program startup "
    },
    {
      "type": "paragraph",
      "id": "d853d64cd73426fa",
      "text": "SPAs, unlike traditional multi-page applications (ordinary web pages), feel more like native applications installed on the respective end device, since complete page loads are omitted. When the SPA is initially invoked, the browser usually loads the entire static source code of the SPA; at runtime, the application only requests the dynamic data needed for display from the server. The static source code consists of the framework, additional libraries and the code of the application components. This leads to a considerable package size, which results in a longer loading time. "
    },
    {
      "type": "paragraph",
      "id": "fc5ff114576a6ac4",
      "text": "The lifecycle of an SPA begins with a white page on which the framework dynamically builds the application. The source code present in the browser at this point does not yet contain dynamic data. Therefore, the browser initially renders a component blank and then renders it again once the data is available. This is overhead and works well for internal business applications with a fast network and individual data. For pages publicly available on the Internet, an SPA is less suitable, since search engines are critical in their evaluation if a page has a longer loading time. "
    },
    {
      "type": "paragraph",
      "id": "86cadda16e9a0382",
      "text": "The idea behind metaframeworks is that delivering empty pages is unnecessary. In most cases, the server can prepare the content and send it to the client. If the content is the same for different user requests, the server can even cache it and provide it faster. However, modern metaframeworks contain even more features."
    },
    {
      "type": "paragraph",
      "id": "e8811b9a9ef830cf",
      "text": "Mature toolchain: Basic frameworks make it easier for programmers to get started with application development. Metaframeworks pursue the same goal and offer a preconfigured toolchain for the build process."
    },
    {
      "type": "paragraph",
      "id": "04d647fcb54a650b",
      "text": "Structure for front-end and back-end: Some SPA frameworks partially specify the structure for front-end and back-end as well as for the architecture. Developers have great freedom to organize files and directories. Metaframeworks, on the other hand, work with file system conventions. The rules for placing and naming files and directories are stricter. "
    },
    {
      "type": "paragraph",
      "id": "43bbd34c80095cb9",
      "text": "SEO optimization: One of the most important features of metaframeworks is to develop publicly available applications. Inseparable from this is search engine optimization. Therefore, the frameworks include tools that improve load times, reduce package sizes, and optimize applications for search engines in terms of content and structure. "
    },
    {
      "type": "paragraph",
      "id": "864878e57b87f907",
      "text": "Prebuilding (Static Site Generation): Metaframeworks try to avoid delivering empty web pages. They use the actual front-end framework already server-side to generate HTML structures, which they then deliver to the browser. Depending on when this page generation takes place, it is referred to as server-side rendering or static site generation. "
    },
    {
      "type": "paragraph",
      "id": "6cf3ae1d923ceb4b",
      "text": "Hybrid routing: In a client-server environment, as created by the metaframeworks, the navigation also differs from the previous one in the frontend. Resources requested by users are found in the application's file system structure. Metaframeworks combine server-side routing and client-side navigation for an optimal user experience. "
    },
    {
      "type": "paragraph",
      "id": "4d3df0d9f22c8814",
      "text": "Performance optimization: Modern metaframeworks aim to achieve optimal performance of applications for end users. This is achieved by an optimized initial loading process and a clever combination of features during the runtime of the application, such as lazy loading or pre-fetching. "
    },
    {
      "type": "paragraph",
      "id": "57bd339b7a114c84",
      "text": "One reason for the development of metaframeworks is that SPAs are reaching their limits in some areas. These include blogs, e-commerce platforms, marketing sites, product websites and portfolios. SPAs show their strength especially in individually designed applications, which are usually protected by a log-in, i.e. where the display is prepared specifically for a user. The more dynamic and individual content an application or the view in an application contains, the more likely a SPA is to be used."
    },
    {
      "type": "paragraph",
      "id": "f72782ce4c543a6f",
      "text": "However, if several users share data and display, or if the application is publicly accessible and presents at least partially static content – which is often the case, especially in the B2C environment – it is well suited for a metaframework. This is all about presenting data. The focus is on delivery speed to satisfy users, but also search engines. While SPA frameworks are developer-friendly and very flexible, they are significantly inferior to static HTML and CSS when it comes to speed. Therefore, the wave is currently sloshing back towards servers. The development teams of the major frameworks and the community are also taking this development into account."
    },
    {
      "type": "paragraph",
      "id": "3ce2989aaa8c75e9",
      "text": "Server-side rendering and static page generation"
    },
    {
      "type": "paragraph",
      "id": "e85d7ef3fe29a60a",
      "text": "The terms server-side rendering and static site generation are frequently used in connection with metaframeworks. Both approaches ensure that the HTML structure of the application is not initially built in the browser, but prepared on the server side. "
    },
    {
      "type": "paragraph",
      "id": "2b5e1bf04351432e",
      "text": "In Static Site Generation, the build process builds the structure of the application. To do this, the process executes the original client-side framework on the server side and uses it to generate static HTML. Static web servers such as [[Apache]] or [[nginx]] deliver it to the clients. With each client call, the server sends the same sources to the browser. Therefore, the data for display must already be available at build time. Static Site Generation is therefore only suitable for little dynamic data."
    },
    {
      "type": "paragraph",
      "id": "8019e3e633d62478",
      "text": "In server-side rendering, the server generates the responses to the client on demand. This requires running a server process (usually based on [[Node.js]]) that executes the framework. It generates static HTML on demand, which it sends to the client. Server-side rendering is slower than static site generation, but it ensures that the user doesn't see a blank page to begin with."
    },
    {
      "type": "paragraph",
      "id": "39434639a6755c60",
      "text": "Whether static site generation or server-side rendering, in both cases the client must take control of the generated structure after the initial request so that the frontend becomes dynamic. This process is called [[Hydration]]. After hydration is complete, an ordinary client-side SPA and a static-site generation or server-side rendering application are indistinguishable."
    },
    {
      "type": "paragraph",
      "id": "637d05d05fe7580f",
      "text": "Frameworks implement static site generation and server-side rendering differently, but the idea is the same. The React metaframework Next.js organizes the individual views of an application into page components. These are ordinary React components that become pages simply by being placed in a specific directory, defining reachable endpoints in the user front end."
    },
    {
      "type": "paragraph",
      "id": "756506d7a34b1b2b",
      "text": "[…]"
    },
    {
      "type": "paragraph",
      "id": "85995de570e2a8ae",
      "text": "One advantage of metaframeworks is that they do not restrict the functionality of the underlying SPA frameworks, but extend it. Thus, an application can use static site generation, server-side rendering, but also classic client-side data fetching. It is also possible to render a component server-side and then load further data in the client, thus combining both concepts."
    },
    {
      "type": "paragraph",
      "id": "070f4161970b2ce4",
      "text": "Navigate within the application"
    },
    {
      "type": "paragraph",
      "id": "7752dfa0b9ea56c8",
      "text": "SPAs follow a component-based architecture, thus consist of a component tree. It is however not static, but can be arranged dynamically by program logic. At run time one can attach or detach individual components or entire subtrees and so affect the display. Depending upon, where one intervenes into the component tree, for the user another display can be obtained. Such a conditional rendering of subtrees takes place in the simplest case by branches in the application source code. The disadvantage is that the navigation status is available only within the application."
    },
    {
      "type": "paragraph",
      "id": "522f3b9866b3e251",
      "text": "The common frameworks have routing extensions that can be installed as additional packages and integrated into the application. The routes of these frameworks work purely client-side and are configurable in the frontend in the components. Here, there are implementation differences between the individual products, but the general functionality hardly differs. The routers are based on the native browser interfaces and use either the older hash navigation with the jump marks in the URL or the newer [[History API]]."
    },
    {
      "type": "paragraph",
      "id": "b94a155e2506f221",
      "text": "In both cases, the [[Router]] maps the current state of the application via the URL and provides navigation interfaces. These can either be components that the framework renders regularly and that users can use like ordinary links, or navigation functions that the application itself uses to navigate from the program code. Hybrid frameworks such as [[Analog]], which operate on both the client and server sides, take this approach further and provide server-side routing in addition to client-side navigation. "
    },
    {
      "type": "paragraph",
      "id": "4ea74e73a8e53fc6",
      "text": "Most metaframeworks organize their views via page components in the file system. Here, the directory and file hierarchy defines the URL path for users. The path can be static or dynamic and contain variables. The page components access these variables and adjust the display. Both server-side rendering and static site generation support variables in routes, although with static site generation, all valid values must already be fixed and known at build time. The server then uses these values to generate the required structures and stores them in the file system. With server-side rendering, the server responds to the variables and can request additional resources such as a database or other data source and generate a structure for the current request. Dynamic routes [⇒ [[Dynamic Segments]]] can be used, for example, to generate detailed views of data records or pre-populated [[Forms]] for editing data."
    },
    {
      "type": "paragraph",
      "id": "6b987719aaed458c",
      "text": "The frameworks combine client-side and server-side navigation so cleverly that users get the impression that the application is an ordinary SPA with client-side navigation (Figure 2)."
    },
    {
      "type": "image",
      "id": "881c387ef0a65f6e",
      "text": "On the front end, hybrid frameworks work like ordinary SPAs without the delays of a multi-page application (Fig. 2).\nSource: Vercel, Inc.\n\n",
      "size": "wide",
      "width": 418,
      "height": 165,
      "url": "/assets/plugins/image/aeac6de56aa3952d5e2072e98ac3a90d.jpg"
    },
    {
      "type": "paragraph",
      "id": "27e87d54cc263c2b",
      "text": "When switching between two pages, the framework does not reload all HTML, CSS, and JavaScript, but only the additional resources needed to display the new content. The frameworks combine the advantages of classic multi-page applications including their server-side pre-generated content with the fluid operation of SPAs."
    },
    {
      "type": "paragraph",
      "id": "4ceaa6b8abcd87f6",
      "text": "Conclusion"
    },
    {
      "type": "paragraph",
      "id": "356958db25e18ab9",
      "text": "Single-page applications have become increasingly established in the web world in recent years and have developed into a universal solution for various problems. However, purely client-side single-page applications are subject to limitations and hardly exploit the potential of the backend infrastructure, since they regard the backend as a pure data provider."
    },
    {
      "type": "paragraph",
      "id": "7c45151a94b8b9eb",
      "text": "Modern metaframeworks consist of a server process and a client-side application. The server can pre-generate structures and run static site generation or generate the structures on demand and apply server-side rendering. In addition, frameworks have other features such as image and font optimization that positively affect the performance of an application. SPA frameworks can therefore gain a foothold in areas that were previously reserved for established CMS systems."
    },
    {
      "type": "paragraph",
      "id": "4ca44add29038f81",
      "text": "Opinion"
    },
    {
      "type": "paragraph",
      "id": "02bc174da2924ffc",
      "text": "Metaframeworks have what it takes to usher in a new era of front-end development. This goes hand in hand with a new programming paradigm: The server manages the data, makes it available and prepares the rendering of the interface. The client side then takes control and takes care of the display and interaction."
    },
    {
      "type": "paragraph",
      "id": "41300646478a5d59",
      "text": "React follows this path more consistently than its competitors and does not shy away from scaring away developers with this communication. One of my ([[Sebastian Springer]]) first thoughts was: Now Facebook is once again cooking its own soup without regard for losses. Facebook didn't develop React out of pure charity either, but largely out of self-interest, for example to implement Facebook and Instagram websites. One of the most widely used frontend frameworks was created as a by-product."
    },
    {
      "type": "paragraph",
      "id": "c03999ca7e88c0d6",
      "text": "The hybrid approach that React is now taking also pays back to a very Facebook-specific problem: a front-end application that can be prepared server-side. A big advantage of this brave new world is the excellent performance for public applications. This benefits the B2C environment in particular, where load time plays a major role. The danger I ([[Sebastian Springer]])  currently see is that the hybrid approach is the new all-purpose solution, and again it solves problems that don't lend themselves to it. Developers should use the option of opting in or opting out of the respective features and try to use the appropriate solution for the problem. "
    },
    {
      "type": "pagefold",
      "id": "f3d253d522818084",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "b6ebdd236939ab62",
      "text": "⇒ [[NixOS]]: The Ultimate Dev Environment? by [[Martin Myrseth]] [https://myme.no/posts/2022-01-16-nixos-the-ultimate-dev-environment.html page], shortcomings in Nix [https://github.com/tweag/rfcs/blob/flakes/rfcs/0049-flakes.md#motivation page]"
    },
    {
      "type": "paragraph",
      "id": "709cbda72f6ef0e9",
      "text": "⇒ [[Public Liquidity Backstop]]"
    },
    {
      "type": "pagefold",
      "id": "6e62a3dded7c23d3",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "35f2957d38e411eb",
      "text": "Open-Source-Entwicklungstool für AIoT auf ESP-Basis [https://www.heise.de/news/Open-Source-Entwicklungstool-fuer-AIoT-auf-ESP-Basis-9296763.html?wt_mc=rss.red.make.beitrag.atom.beitrag.beitrag page]"
    },
    {
      "type": "paragraph",
      "id": "d6759357e58ea173",
      "text": "Announcing native npm support on Deno Deploy [https://deno.com/blog/npm-on-deno-deploy page]"
    },
    {
      "type": "pagefold",
      "id": "7512d884dd08750b",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "af56e5ae3c0cfaa2",
      "text": "⇒ [[Iago Leal de Freitas]], Picturing Finite Relations as Graphs [https://iagoleal.com/posts/finite-relations-graph/ page]"
    },
    {
      "type": "paragraph",
      "id": "615c473b954fe2de",
      "text": "[[Functions Are Containers]]"
    },
    {
      "type": "paragraph",
      "id": "a3b3ab30fc1fa65e",
      "text": "GENTILE, Ann C., DOYLE, Wendy SK and ULMER, Craig D., 2008. FCLib: The Feature Characterization Library. Sandia National Lab.(SNL-NM), Albuquerque, NM (United States); Sandia …."
    },
    {
      "type": "paragraph",
      "id": "aeee65dc6b344da0",
      "text": "Figure 2: An item before [[Deformation]]. Note that the green plate is flush with the read container. (p. 29)"
    },
    {
      "type": "paragraph",
      "id": "ceb601562090be24",
      "text": "⇒ [[Iago Leal de Freitas]], simulations of the dynamics of self-deforming bodies and some models related to astronomy. [https://iagoleal.com/about/ page]",
      "alias": "af56e5ae3c0cfaa2"
    },
    {
      "type": "paragraph",
      "id": "fe8683f5ee79db42",
      "text": "The next #Hackergarten in #Basel has been scheduled: September 20th! Join us, all details at … [https://jit.social/@madmas/111017255853747673 post]"
    },
    {
      "type": "paragraph",
      "id": "2aa56c3c0a92e13b",
      "text": "Invariant Lifetimes as Static, Unique Tokens [https://lord.io/lifetimes-as-tokens/ page]"
    },
    {
      "type": "paragraph",
      "id": "65beb8f66865d32f",
      "text": "Fast, Arena-Allocated Graphs [https://github.com/lord/arena-graph github]"
    },
    {
      "type": "paragraph",
      "id": "5d7242d5541f94a4",
      "text": "anchors [https://github.com/lord/anchors github]"
    },
    {
      "type": "paragraph",
      "id": "9d43128ad4df0d42",
      "text": "How to Recalculate a [[Spreadsheet]] [https://lord.io/spreadsheets/ page]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2023-09-06",
        "story": []
      },
      "date": 1693976893757
    },
    {
      "id": "448a859433bc861b",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "448a859433bc861b",
        "text": "⇒ [[Wiki Module]] ⇒ [[Render Story]]"
      },
      "attribution": {
        "page": "2023-09-05"
      },
      "date": 1693976897144
    },
    {
      "item": {
        "type": "factory",
        "id": "d61d994bbaeb36a4"
      },
      "id": "d61d994bbaeb36a4",
      "type": "add",
      "after": "448a859433bc861b",
      "date": 1693976902247
    },
    {
      "type": "edit",
      "id": "d61d994bbaeb36a4",
      "item": {
        "type": "image",
        "id": "d61d994bbaeb36a4",
        "text": "Uploaded image",
        "size": "wide",
        "width": 419,
        "height": 148,
        "url": "/assets/plugins/image/c5af8b0fa7c0fe03374303b4267aa2d6.jpg"
      },
      "date": 1693976974798
    },
    {
      "item": {
        "type": "factory",
        "id": "59beda0aa2463411"
      },
      "id": "59beda0aa2463411",
      "type": "add",
      "after": "d61d994bbaeb36a4",
      "date": 1693977817352
    },
    {
      "type": "edit",
      "id": "59beda0aa2463411",
      "item": {
        "type": "pagefold",
        "id": "59beda0aa2463411",
        "text": "~"
      },
      "date": 1693977820808
    },
    {
      "item": {
        "type": "factory",
        "id": "f0cbaf616f3e5ee9"
      },
      "id": "f0cbaf616f3e5ee9",
      "type": "add",
      "after": "59beda0aa2463411",
      "date": 1693977822392
    },
    {
      "type": "edit",
      "id": "f0cbaf616f3e5ee9",
      "item": {
        "type": "paragraph",
        "id": "f0cbaf616f3e5ee9",
        "text": "\nALVIN, Olle, [no date]. Rendering Resolution Independent Fonts in Games and D Applications. . \n"
      },
      "date": 1693977824050
    },
    {
      "type": "edit",
      "id": "f0cbaf616f3e5ee9",
      "item": {
        "type": "paragraph",
        "id": "f0cbaf616f3e5ee9",
        "text": "\nALVIN, Olle, 2020. Rendering Resolution Independent Fonts in Games and 3D Applications.  Online. Exam paper. Lund University. Available from: https://lup.lub.lu.se/luur/download?func=downloadFile&recordOId=9024910&fileOId=9024911This thesis describes how fonts can be rendered in 3D-applications. It provides a description of how to render glyphs using signed distance  elds as well as the Slug-algorithm. The thesis provides an analysis of these methods and investigates how they can be combined. The combined method overcomes some of the artefacts produced by signed distance  elds, while being faster than the Slugalgorithm in most cases. However it is not suited for complex glyphs or small font sizes.\n"
      },
      "date": 1693978052181
    },
    {
      "type": "edit",
      "id": "f0cbaf616f3e5ee9",
      "item": {
        "type": "paragraph",
        "id": "f0cbaf616f3e5ee9",
        "text": "ALVIN, Olle, 2020. Rendering Resolution Independent Fonts in Games and 3D Applications. Exam paper. Lund University. Available from: https://lup.lub.lu.se/luur/download?func=downloadFile&recordOId=9024910&fileOId=9024911This thesis describes how fonts can be rendered in 3D-applications. It provides a description of how to render glyphs using signed distance  elds as well as the Slug-algorithm. The thesis provides an analysis of these methods and investigates how they can be combined. The combined method overcomes some of the artefacts produced by signed distance  elds, while being faster than the Slugalgorithm in most cases. However it is not suited for complex glyphs or small font sizes.\n"
      },
      "date": 1693978067064
    },
    {
      "type": "edit",
      "id": "f0cbaf616f3e5ee9",
      "item": {
        "type": "paragraph",
        "id": "f0cbaf616f3e5ee9",
        "text": "ALVIN, Olle, 2020. Rendering Resolution Independent Fonts in Games and 3D Applications. Exam paper. Lund University. [https://lup.lub.lu.se/luur/download?func=downloadFile&recordOId=9024910&fileOId=9024911 pdf] This thesis describes how fonts can be rendered in 3D-applications. It provides a description of how to render glyphs using signed distance  elds as well as the Slug-algorithm. The thesis provides an analysis of these methods and investigates how they can be combined. The combined method overcomes some of the artefacts produced by signed distance  elds, while being faster than the Slugalgorithm in most cases. However it is not suited for complex glyphs or small font sizes.\n"
      },
      "date": 1693978089492
    },
    {
      "type": "edit",
      "id": "f0cbaf616f3e5ee9",
      "item": {
        "type": "paragraph",
        "id": "f0cbaf616f3e5ee9",
        "text": "ALVIN, Olle, 2020. Rendering Resolution Independent Fonts in Games and 3D Applications. Exam paper. Lund University. [https://lup.lub.lu.se/luur/download?func=downloadFile&recordOId=9024910&fileOId=9024911 pdf] This thesis describes how fonts can be rendered in 3D-applications. It provides a description of how to render glyphs using signed distance  elds as well as the Slug-algorithm. The thesis provides an analysis of these methods and investigates how they can be combined. The combined method overcomes some of the artefacts produced by signed distance  elds, while being faster than the Slug-algorithm in most cases. However it is not suited for complex glyphs or small font sizes.\n"
      },
      "date": 1693978135849
    },
    {
      "item": {
        "type": "factory",
        "id": "e85e677c1e853e56"
      },
      "id": "e85e677c1e853e56",
      "type": "add",
      "after": "f0cbaf616f3e5ee9",
      "date": 1693978364870
    },
    {
      "type": "edit",
      "id": "e85e677c1e853e56",
      "item": {
        "type": "paragraph",
        "id": "e85e677c1e853e56",
        "text": "A pixel contains a color, typically as an RGB value."
      },
      "date": 1693978369355
    },
    {
      "type": "edit",
      "id": "d61d994bbaeb36a4",
      "item": {
        "type": "image",
        "id": "d61d994bbaeb36a4",
        "text": "Side-by-Side Comparison",
        "size": "wide",
        "width": 419,
        "height": 148,
        "url": "/assets/plugins/image/c5af8b0fa7c0fe03374303b4267aa2d6.jpg"
      },
      "date": 1693978464439
    },
    {
      "type": "edit",
      "id": "d61d994bbaeb36a4",
      "item": {
        "type": "image",
        "id": "d61d994bbaeb36a4",
        "text": "Side-by-Side Comparison [https://github.com/dreyeck/blog/commit/27ba4048efae557d442773d44f0ba54715f627e6 commit]",
        "size": "wide",
        "width": 419,
        "height": 148,
        "url": "/assets/plugins/image/c5af8b0fa7c0fe03374303b4267aa2d6.jpg"
      },
      "date": 1693978586604
    },
    {
      "type": "add",
      "id": "b7e235132ef58e4d",
      "item": {
        "type": "paragraph",
        "id": "b7e235132ef58e4d",
        "text": "We see the same [[Wiki Page JSON] displayed on one side (left) by the wiki reference implementation and on the other side (right) by the elm-pages prototype."
      },
      "after": "448a859433bc861b",
      "date": 1693978746738
    },
    {
      "id": "b7e235132ef58e4d",
      "type": "move",
      "order": [
        "448a859433bc861b",
        "d61d994bbaeb36a4",
        "b7e235132ef58e4d",
        "59beda0aa2463411",
        "f0cbaf616f3e5ee9",
        "e85e677c1e853e56"
      ],
      "date": 1693978751453
    },
    {
      "type": "edit",
      "id": "b7e235132ef58e4d",
      "item": {
        "type": "paragraph",
        "id": "b7e235132ef58e4d",
        "text": "We see the same [[Wiki Page JSON]] displayed on one side (left) by the wiki reference implementation and on the other side (right) by the elm-pages prototype."
      },
      "date": 1693978754837
    },
    {
      "type": "edit",
      "id": "b7e235132ef58e4d",
      "item": {
        "type": "paragraph",
        "id": "b7e235132ef58e4d",
        "text": "We see the same [[Wiki Page JSON]] displayed on one side (left) by the fedwiki reference implementation and on the other side (right) by the elm-pages prototype."
      },
      "date": 1693978860717
    },
    {
      "item": {
        "type": "factory",
        "id": "dbc789d6dbd1bdef"
      },
      "id": "dbc789d6dbd1bdef",
      "type": "add",
      "after": "e85e677c1e853e56",
      "date": 1693979527600
    },
    {
      "id": "dbc789d6dbd1bdef",
      "type": "move",
      "order": [
        "448a859433bc861b",
        "d61d994bbaeb36a4",
        "b7e235132ef58e4d",
        "dbc789d6dbd1bdef",
        "59beda0aa2463411",
        "f0cbaf616f3e5ee9",
        "e85e677c1e853e56"
      ],
      "date": 1693979534079
    },
    {
      "type": "edit",
      "id": "dbc789d6dbd1bdef",
      "item": {
        "type": "reference",
        "id": "dbc789d6dbd1bdef",
        "site": "stack.fed.wiki",
        "slug": "ward-cunningham",
        "title": "Ward Cunningham",
        "text": "As I write this I have lived with and incrementally improved federated wiki for six years. Before that I had come to the belief that the looseness of wiki might make for a better match with distributed computers than the strict guarantees of, say, a database. Federated wiki, here just wiki, is the reduction to practice of these ideas."
      },
      "date": 1693979538081
    },
    {
      "id": "ce8797173a17ceec",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "ce8797173a17ceec",
        "text": "Our most essential discovery in practice has been the substitution into hypertext of a history sensitive link. This embodies the original idea of a trail and the interpretive process dubbed trail climbing."
      },
      "after": "dbc789d6dbd1bdef",
      "attribution": {
        "page": "Ward Cunningham",
        "site": "stack.fed.wiki"
      },
      "date": 1693979558496
    },
    {
      "item": {
        "type": "factory",
        "id": "49ad6afe55cbd31f"
      },
      "id": "49ad6afe55cbd31f",
      "type": "add",
      "after": "e85e677c1e853e56",
      "date": 1693979719327
    },
    {
      "type": "edit",
      "id": "49ad6afe55cbd31f",
      "item": {
        "type": "pagefold",
        "id": "49ad6afe55cbd31f",
        "text": "~"
      },
      "date": 1693979722399
    },
    {
      "item": {
        "type": "factory",
        "id": "4309af65b82e86d0"
      },
      "id": "4309af65b82e86d0",
      "type": "add",
      "after": "49ad6afe55cbd31f",
      "date": 1693979723575
    },
    {
      "type": "edit",
      "id": "4309af65b82e86d0",
      "item": {
        "type": "paragraph",
        "id": "4309af65b82e86d0",
        "text": "DuckDuckGo is available on Tor"
      },
      "date": 1693979726468
    },
    {
      "type": "edit",
      "id": "4309af65b82e86d0",
      "item": {
        "type": "paragraph",
        "id": "4309af65b82e86d0",
        "text": "DuckDuckGo is available on Tor [onion address]"
      },
      "date": 1693979740993
    },
    {
      "type": "edit",
      "id": "4309af65b82e86d0",
      "item": {
        "type": "paragraph",
        "id": "4309af65b82e86d0",
        "text": "DuckDuckGo is available on Tor [https://duckduckgogg42xjoc72x3sjasowoarfbgcmvfimaftt6twagswzczad.onion/ onion address]"
      },
      "date": 1693979762596
    },
    {
      "type": "edit",
      "id": "4309af65b82e86d0",
      "item": {
        "type": "paragraph",
        "id": "4309af65b82e86d0",
        "text": "DuckDuckGo is available on Tor. [https://duckduckgogg42xjoc72x3sjasowoarfbgcmvfimaftt6twagswzczad.onion/ onion address]"
      },
      "date": 1693979770891
    },
    {
      "item": {
        "type": "factory",
        "id": "1f3ab14e4ee1d302"
      },
      "id": "1f3ab14e4ee1d302",
      "type": "add",
      "after": "4309af65b82e86d0",
      "date": 1693979787360
    },
    {
      "type": "edit",
      "id": "1f3ab14e4ee1d302",
      "item": {
        "type": "image",
        "id": "1f3ab14e4ee1d302",
        "text": "Uploaded image",
        "size": "thumbnail",
        "width": 183,
        "height": 183,
        "url": "/assets/plugins/image/944ebf16c0308c94dc4f43066845c17c.jpg"
      },
      "date": 1693979812337
    },
    {
      "type": "edit",
      "id": "1f3ab14e4ee1d302",
      "item": {
        "type": "image",
        "id": "1f3ab14e4ee1d302",
        "text": "DuckDuckGo is available on Tor. [https://duckduckgogg42xjoc72x3sjasowoarfbgcmvfimaftt6twagswzczad.onion/ onion address]",
        "size": "thumbnail",
        "width": 183,
        "height": 183,
        "url": "/assets/plugins/image/944ebf16c0308c94dc4f43066845c17c.jpg"
      },
      "date": 1693979823085
    },
    {
      "type": "add",
      "id": "0142b726c1a09bb7",
      "item": {
        "type": "paragraph",
        "id": "0142b726c1a09bb7",
        "text": "⇒ [[Trail Climbing]]"
      },
      "after": "ce8797173a17ceec",
      "date": 1693979871430
    },
    {
      "id": "ce8797173a17ceec",
      "type": "remove",
      "removedTo": {
        "page": "Trail Climbing"
      },
      "date": 1693979879757
    },
    {
      "id": "dbc789d6dbd1bdef",
      "type": "remove",
      "removedTo": {
        "page": "Trail Climbing"
      },
      "date": 1693979886706
    },
    {
      "type": "edit",
      "id": "448a859433bc861b",
      "item": {
        "type": "paragraph",
        "id": "448a859433bc861b",
        "text": "⇐ [[Wiki Module]] ⇒ [[Render Story]]"
      },
      "date": 1693982351443
    },
    {
      "item": {
        "type": "factory",
        "id": "4e6e59cf2d478375"
      },
      "id": "4e6e59cf2d478375",
      "type": "add",
      "after": "1f3ab14e4ee1d302",
      "date": 1693987074946
    },
    {
      "type": "edit",
      "id": "4e6e59cf2d478375",
      "item": {
        "type": "pagefold",
        "id": "4e6e59cf2d478375",
        "text": "~"
      },
      "date": 1693987077912
    },
    {
      "item": {
        "type": "factory",
        "id": "527e6186721bb1ad"
      },
      "id": "527e6186721bb1ad",
      "type": "add",
      "after": "4e6e59cf2d478375",
      "date": 1693987079287
    },
    {
      "type": "edit",
      "id": "527e6186721bb1ad",
      "item": {
        "type": "paragraph",
        "id": "527e6186721bb1ad",
        "text": "⇒ [[dmx-headless]]"
      },
      "date": 1693987087067
    },
    {
      "type": "edit",
      "id": "527e6186721bb1ad",
      "item": {
        "type": "paragraph",
        "id": "527e6186721bb1ad",
        "text": "⇒ [[dmx-headless]] 5.3.2~2deb+b18435"
      },
      "date": 1693987199479
    },
    {
      "type": "edit",
      "id": "527e6186721bb1ad",
      "item": {
        "type": "paragraph",
        "id": "527e6186721bb1ad",
        "text": "⇒ [[dmx-headless]] 5.3.2~2deb+b18435 ⇒ [[fbx]]"
      },
      "date": 1693987218266
    },
    {
      "item": {
        "type": "factory",
        "id": "dc49c2839a81588b"
      },
      "id": "dc49c2839a81588b",
      "type": "add",
      "after": "527e6186721bb1ad",
      "date": 1693987404535
    },
    {
      "type": "edit",
      "id": "dc49c2839a81588b",
      "item": {
        "type": "paragraph",
        "id": "dc49c2839a81588b",
        "text": "\nSPRINGER, Sebastian, 2023. Die neue Generation der JavaScript-Metaframeworks. iX. 26 Juli 2023. Bd. 2023, Nr. 8, S. 108–110\n"
      },
      "date": 1693987406302
    },
    {
      "type": "edit",
      "id": "dc49c2839a81588b",
      "item": {
        "type": "paragraph",
        "id": "dc49c2839a81588b",
        "text": "SPRINGER, Sebastian, 2023. Die neue Generation der JavaScript-Metaframeworks. iX. 26 Juli 2023. Bd. 2023, Nr. 8, S. 108–110 [https://www.heise.de/select/ix/2023/8/2309408465876534332 page]"
      },
      "date": 1693987473800
    },
    {
      "item": {
        "type": "factory",
        "id": "6daedabb93e95fbf"
      },
      "id": "6daedabb93e95fbf",
      "type": "add",
      "after": "dc49c2839a81588b",
      "date": 1693987498111
    },
    {
      "type": "edit",
      "id": "6daedabb93e95fbf",
      "item": {
        "type": "paragraph",
        "id": "6daedabb93e95fbf",
        "text": "The Single-Page-Applications-Architecture (SPA) has become so popular that almost every problem can be solved with it. Angular, Vue and React have established themselves among the SPA frameworks. In the meantime, however, one must ask oneself how things will continue. For example, there are indications that the strict separation between client and server is slowly but surely being softened and that server-side development away from data interfaces is once again coming more into focus. "
      },
      "date": 1693987499563
    },
    {
      "type": "add",
      "id": "ffeb296afa5585f5",
      "item": {
        "type": "paragraph",
        "id": "ffeb296afa5585f5",
        "text": "⇒ [[SPA]]"
      },
      "after": "527e6186721bb1ad",
      "date": 1693987551725
    },
    {
      "type": "edit",
      "id": "6daedabb93e95fbf",
      "item": {
        "type": "paragraph",
        "id": "6daedabb93e95fbf",
        "text": "The Single-Page-Applications-Architecture (SPA) has become so popular that almost every problem can be solved with it. Angular, Vue and React have established themselves among the SPA frameworks. In the meantime, however, one must ask oneself how things will continue. For example, there are indications that the strict separation between client and server is slowly but surely being softened and that server-side development away from data interface"
      },
      "date": 1693987722492
    },
    {
      "type": "add",
      "id": "6d759c19ce0ae0db",
      "item": {
        "type": "paragraph",
        "id": "6d759c19ce0ae0db",
        "text": "Another trend is metaframeworks. Common practice in the JavaScript world is to assemble an application, framework, or library from existing packages. An empty SPA can therefore be between 100 and 300 MBytes in size - depending on the setup path and the initial package configuration. Included in this amount of data are tools and libraries for the developer experience that assist in the build process and are not transferred to the client. Metaframeworks take up this idea: They themselves use frameworks such as Angular, React or Vue as a basis, combine them and add further features. s is once again coming more into focus."
      },
      "after": "6daedabb93e95fbf",
      "date": 1693987723017
    },
    {
      "type": "edit",
      "id": "6d759c19ce0ae0db",
      "item": {
        "type": "paragraph",
        "id": "6d759c19ce0ae0db",
        "text": "Another trend is metaframeworks. Common practice in the JavaScript world is to assemble an application, framework, or library from existing packages. An empty SPA can therefore be between 100 and 300 MBytes in size – depending on the setup path and the initial package configuration. Included in this amount of data are tools and libraries for the developer experience that assist in the build process and are not transferred to the client. Metaframeworks take up this idea: They themselves use frameworks such as Angular, React or Vue as a basis, combine them and add further features. s is once again coming more into focus."
      },
      "date": 1693987963243
    },
    {
      "type": "edit",
      "id": "527e6186721bb1ad",
      "item": {
        "type": "paragraph",
        "id": "527e6186721bb1ad",
        "text": "⇒ [[dmx-headless]] 5.3.2~2deb+b18435 ⇒ [[fbx]] ⇒ [[dmx.service]]"
      },
      "date": 1693988013692
    },
    {
      "type": "edit",
      "id": "527e6186721bb1ad",
      "item": {
        "type": "paragraph",
        "id": "527e6186721bb1ad",
        "text": "⇒ [[dmx-headless]] 5.3.2~2deb+b18435 ⇒ [[fbx]] ⇒ [[dmx.service]] (stop and mask)"
      },
      "date": 1693988036930
    },
    {
      "type": "edit",
      "id": "6d759c19ce0ae0db",
      "item": {
        "type": "paragraph",
        "id": "6d759c19ce0ae0db",
        "text": "Another trend is metaframeworks. Common practice in the JavaScript world is to assemble an application, framework, or library from existing packages. An empty SPA can therefore be between 100 and 300 MBytes in size – depending on the setup path and the initial package configuration. Included in this amount of data are tools and libraries for the developer experience that assist in the build process and are not transferred to the client. Metaframeworks take up this idea: They themselves use frameworks such as Angular, React or Vue as a basis, combine them and add further features. "
      },
      "date": 1693988127831
    },
    {
      "type": "edit",
      "id": "6daedabb93e95fbf",
      "item": {
        "type": "paragraph",
        "id": "6daedabb93e95fbf",
        "text": "The Single-Page-Applications-Architecture (SPA) has become so popular that almost every problem can be solved with it. Angular, Vue and React have established themselves among the SPA frameworks. In the meantime, however, one must ask oneself how things will continue. For example, there are indications that the strict separation between client and server is slowly but surely being softened and that server-side development away from data interfaces is once again coming more into focus."
      },
      "date": 1693988129454
    },
    {
      "type": "edit",
      "id": "6d759c19ce0ae0db",
      "item": {
        "type": "paragraph",
        "id": "6d759c19ce0ae0db",
        "text": "Another trend is metaframeworks. Common practice in the JavaScript world is to assemble an application, framework, or library from existing packages. An empty SPA can therefore be between 100 and 300 MBytes in size – depending on the setup path and the initial package configuration. Included in this amount of data are tools and libraries for the developer experience that assist in the build process and are not transferred to the client. Metaframeworks take up this idea: They themselves use frameworks such as Angular, React or Vue as a basis, combine them and add further features."
      },
      "date": 1693988213500
    },
    {
      "type": "add",
      "id": "c5bca6dc41ef3a13",
      "item": {
        "type": "paragraph",
        "id": "c5bca6dc41ef3a13",
        "text": "Leverage strengths of client and server "
      },
      "after": "6d759c19ce0ae0db",
      "date": 1693988215924
    },
    {
      "type": "edit",
      "id": "ffeb296afa5585f5",
      "item": {
        "type": "paragraph",
        "id": "ffeb296afa5585f5",
        "text": "⇒ [[SPA]] ⇒ [[Sebastian Springer]]"
      },
      "date": 1693988246981
    },
    {
      "item": {
        "type": "factory",
        "id": "7e61957d30e9372b"
      },
      "id": "7e61957d30e9372b",
      "type": "add",
      "after": "c5bca6dc41ef3a13",
      "date": 1693988285197
    },
    {
      "type": "edit",
      "id": "7e61957d30e9372b",
      "item": {
        "type": "paragraph",
        "id": "7e61957d30e9372b",
        "text": "The term metaframework still says little about the orientation. Nest, for example, is a metaframework, but a server-side one that uses Express as its foundation. The popular client-side metaframeworks are currently developing into hybrid frameworks that combine the strengths of client and server and thus make the web an overarching platform again. The direction the evolution may take is foreshadowed by a statement from Dan Abramov, one of React's core developers. He had this to say about the future of Create React App, the previous standard tool for setting up a React application: \"When I was thinking about possible futures for Create React App, it was clear client-only doesn't make sense. Way too limiting. Why are we always producing an empty HTML file if React can pre-render to HTML? Why can't i make a blog by map()ing over markdown files on my disk?\" (For link to source see ix.de/za4c). "
      },
      "date": 1693988286895
    },
    {
      "type": "edit",
      "id": "7e61957d30e9372b",
      "item": {
        "type": "paragraph",
        "id": "7e61957d30e9372b",
        "text": "The term metaframework still says little about the orientation. [[Nest]], for example, is a metaframework, but a server-side one that uses [[Express]] as its foundation. The popular client-side metaframeworks are currently developing into hybrid frameworks that combine the strengths of client and server and thus make the web an overarching platform again. The direction the evolution may take is foreshadowed by a statement from Dan Abramov, one of React's core developers. He had this to say about the future of Create React App, the previous standard tool for setting up a React application: \"When I was thinking about possible futures for Create React App, it was clear client-only doesn't make sense. Way too limiting. Why are we always producing an empty HTML file if React can pre-render to HTML? Why can't i make a blog by map()ing over markdown files on my disk?\" (For link to source see ix.de/za4c). "
      },
      "date": 1693988318260
    },
    {
      "type": "edit",
      "id": "7e61957d30e9372b",
      "item": {
        "type": "paragraph",
        "id": "7e61957d30e9372b",
        "text": "The term metaframework still says little about the orientation. [[Nest]], for example, is a metaframework, but a server-side one that uses [[Express]] as its foundation. The popular client-side metaframeworks are currently developing into hybrid frameworks that combine the strengths of client and server and thus make the web an overarching platform again. The direction the evolution may take is foreshadowed by a statement from [[Dan Abramov]], one of React's core developers. He had this to say about the future of Create React App, the previous standard tool for setting up a React application: \"When I was thinking about possible futures for Create React App, it was clear client-only doesn't make sense. Way too limiting. Why are we always producing an empty HTML file if React can pre-render to HTML? Why can't i make a blog by map()ing over markdown files on my disk?\" (For link to source see ix.de/za4c). "
      },
      "date": 1693988369188
    },
    {
      "type": "add",
      "id": "90ecc08458ac00e4",
      "item": {
        "type": "paragraph",
        "id": "90ecc08458ac00e4",
        "text": "How to configure Systemd service unit to start Node app with \"npm start\" instead of \"app.js\""
      },
      "after": "0142b726c1a09bb7",
      "date": 1693988474374
    },
    {
      "type": "edit",
      "id": "90ecc08458ac00e4",
      "item": {
        "type": "paragraph",
        "id": "90ecc08458ac00e4",
        "text": "How to configure Systemd service unit to start Node app with \"npm start\" instead of \"app.js\" [https://serverfault.com/questions/1018676/how-to-configure-systemd-service-unit-to-start-node-app-with-npm-start-instead page]"
      },
      "date": 1693988485061
    },
    {
      "item": {
        "type": "factory",
        "id": "f840a62e1a48e5bb"
      },
      "id": "f840a62e1a48e5bb",
      "type": "add",
      "after": "7e61957d30e9372b",
      "date": 1693988579145
    },
    {
      "type": "edit",
      "id": "f840a62e1a48e5bb",
      "item": {
        "type": "code",
        "id": "f840a62e1a48e5bb",
        "text": "...\n\n[Service]\nEnvironment=NODE_PORT=3000\nType=simple\nUser=www-data\nRestart=on-failure\nWorkingDirectory=/var/www/<your-code-directory>\nExecStart=npm start\n\n..."
      },
      "date": 1693988581096
    },
    {
      "id": "f840a62e1a48e5bb",
      "type": "move",
      "order": [
        "448a859433bc861b",
        "d61d994bbaeb36a4",
        "b7e235132ef58e4d",
        "0142b726c1a09bb7",
        "90ecc08458ac00e4",
        "f840a62e1a48e5bb",
        "59beda0aa2463411",
        "f0cbaf616f3e5ee9",
        "e85e677c1e853e56",
        "49ad6afe55cbd31f",
        "4309af65b82e86d0",
        "1f3ab14e4ee1d302",
        "4e6e59cf2d478375",
        "527e6186721bb1ad",
        "ffeb296afa5585f5",
        "dc49c2839a81588b",
        "6daedabb93e95fbf",
        "6d759c19ce0ae0db",
        "c5bca6dc41ef3a13",
        "7e61957d30e9372b"
      ],
      "date": 1693988591957
    },
    {
      "id": "0142b726c1a09bb7",
      "type": "move",
      "order": [
        "448a859433bc861b",
        "d61d994bbaeb36a4",
        "b7e235132ef58e4d",
        "90ecc08458ac00e4",
        "f840a62e1a48e5bb",
        "0142b726c1a09bb7",
        "59beda0aa2463411",
        "f0cbaf616f3e5ee9",
        "e85e677c1e853e56",
        "49ad6afe55cbd31f",
        "4309af65b82e86d0",
        "1f3ab14e4ee1d302",
        "4e6e59cf2d478375",
        "527e6186721bb1ad",
        "ffeb296afa5585f5",
        "dc49c2839a81588b",
        "6daedabb93e95fbf",
        "6d759c19ce0ae0db",
        "c5bca6dc41ef3a13",
        "7e61957d30e9372b"
      ],
      "date": 1693988637463
    },
    {
      "type": "edit",
      "id": "7e61957d30e9372b",
      "item": {
        "type": "paragraph",
        "id": "7e61957d30e9372b",
        "text": "The term metaframework still says little about the orientation. [[Nest]], for example, is a metaframework, but a server-side one that uses [[Express]] as its foundation. The popular client-side metaframeworks are currently developing into hybrid frameworks that combine the strengths of client and server and thus make the web an overarching platform again. The direction the evolution may take is foreshadowed by a statement from [[Dan Abramov]], one of React's core developers. He had this to say about the future of Create React App, the previous standard tool for setting up a React application: \"When I was thinking about possible futures for Create React App, it was clear client-only doesn't make sense. Way too limiting. Why are we always producing an empty HTML file if React can pre-render to HTML? Why can't i make a blog by map()ing over markdown files on my disk?\" (For link to source see [https://www.heise.de/select/ix/2023/8/softlinks/za4c?wt_mc=pred.red.ix.ix082023.108.softlink.softlink ix.de/za4c]). "
      },
      "date": 1693988809027
    },
    {
      "type": "edit",
      "id": "7e61957d30e9372b",
      "item": {
        "type": "paragraph",
        "id": "7e61957d30e9372b",
        "text": "The term metaframework still says little about the orientation. [[Nest]], for example, is a metaframework, but a server-side one that uses [[Express]] as its foundation. The popular client-side metaframeworks are currently developing into hybrid frameworks that combine the strengths of client and server and thus make the web an overarching platform again. The direction the evolution may take is foreshadowed by a statement from [[Dan Abramov]], one of React's core developers. He had this to say about the future of Create React App, the previous standard tool for setting up a React application: \"When I was thinking about possible futures for Create React App, it was clear client-only doesn't make sense. Way too limiting. Why are we always producing an empty HTML file if React can pre-render to HTML? Why can't i make a blog by map()ing over markdown files on my disk?\" (For link to source see [https://www.heise.de/select/ix/2023/8/softlinks/za4c?wt_mc=pred.red.ix.ix082023.108.softlink.softlink ix.de/za4c], []). "
      },
      "date": 1693988857956
    },
    {
      "type": "edit",
      "id": "7e61957d30e9372b",
      "item": {
        "type": "paragraph",
        "id": "7e61957d30e9372b",
        "text": "The term metaframework still says little about the orientation. [[Nest]], for example, is a metaframework, but a server-side one that uses [[Express]] as its foundation. The popular client-side metaframeworks are currently developing into hybrid frameworks that combine the strengths of client and server and thus make the web an overarching platform again. The direction the evolution may take is foreshadowed by a statement from [[Dan Abramov]], one of React's core developers. He had this to say about the future of Create React App, the previous standard tool for setting up a React application: \"When I was thinking about possible futures for Create React App, it was clear client-only doesn't make sense. Way too limiting. Why are we always producing an empty HTML file if React can pre-render to HTML? Why can't i make a blog by map()ing over markdown files on my disk?\" (For link to source see [https://www.heise.de/select/ix/2023/8/softlinks/za4c?wt_mc=pred.red.ix.ix082023.108.softlink.softlink ix.de/za4c], [https://twitter.com/dan_abramov/status/1636827365677383700 tweet]). "
      },
      "date": 1693988881967
    },
    {
      "item": {
        "type": "factory",
        "id": "727f4c5579340787"
      },
      "id": "727f4c5579340787",
      "type": "add",
      "after": "7e61957d30e9372b",
      "date": 1693988949637
    },
    {
      "type": "edit",
      "id": "727f4c5579340787",
      "item": {
        "type": "paragraph",
        "id": "727f4c5579340787",
        "text": "He considers the previous purely client-side approach of React to make little sense in the future, as this architecture entails too many restrictions. This culminates in a web server delivering an SPA as an (almost) empty HTML document, which the browser then gradually fills with life. React tackles the issue head-on, recommending in its documentation that developers start a new application directly with a metaframework like Next.js, Remix or Gatsby. This does not mean that a Node.js background process is then always required for a React application, but it does show what the future may look like. Competitors have similar approaches, although they advertise them much less aggressively. The following list shows metaframeworks of various SPA frameworks: "
      },
      "date": 1693988951637
    },
    {
      "type": "edit",
      "id": "727f4c5579340787",
      "item": {
        "type": "paragraph",
        "id": "727f4c5579340787",
        "text": "He considers the previous purely client-side approach of React to make little sense in the future, as this architecture entails too many restrictions. This culminates in a web server delivering an SPA as an (almost) empty HTML document, which the browser then gradually fills with life. React tackles the issue head-on, recommending in its documentation that developers start a new application directly with a metaframework like Next.js, Remix or Gatsby. This does not mean that a Node.js background process is then always required for a React application, but it does show what the future may look like. Competitors have similar approaches, although they advertise them much less aggressively. The following list shows metaframeworks of various SPA frameworks:"
      },
      "date": 1693989011453
    },
    {
      "type": "add",
      "id": "0e9cacfe1d4f2f54",
      "item": {
        "type": "paragraph",
        "id": "0e9cacfe1d4f2f54",
        "text": "\n    React: Next.js, Gatsby, Remix\n    Vue: Nuxt, VuePress, Gridsome\n    Svelte: SvelteKit, Elder.js, Jungle\n    Angular: Analog\n    Astro\n"
      },
      "after": "727f4c5579340787",
      "date": 1693989012708
    },
    {
      "type": "edit",
      "id": "0e9cacfe1d4f2f54",
      "item": {
        "type": "paragraph",
        "id": "0e9cacfe1d4f2f54",
        "text": "    React: Next.js, Gatsby, Remix\n    Vue: Nuxt, VuePress, Gridsome\n    Svelte: SvelteKit, Elder.js, Jungle\n    Angular: Analog\n    Astro\n"
      },
      "date": 1693989027939
    },
    {
      "type": "edit",
      "id": "0e9cacfe1d4f2f54",
      "item": {
        "type": "paragraph",
        "id": "0e9cacfe1d4f2f54",
        "text": "React: Next.js, Gatsby, Remix\nVue: Nuxt, VuePress, Gridsome\nSvelte: SvelteKit, Elder.js, Jungle\nAngular: Analog\nAstro\n"
      },
      "date": 1693989050476
    },
    {
      "type": "edit",
      "id": "0e9cacfe1d4f2f54",
      "item": {
        "type": "paragraph",
        "id": "0e9cacfe1d4f2f54",
        "text": "React: Next.js, Gatsby, Remix"
      },
      "date": 1693989056165
    },
    {
      "type": "add",
      "id": "868e084c4dc75fed",
      "item": {
        "type": "paragraph",
        "id": "868e084c4dc75fed",
        "text": "Vue: Nuxt, VuePress, Gridsome"
      },
      "after": "0e9cacfe1d4f2f54",
      "date": 1693989057315
    },
    {
      "type": "add",
      "id": "d75612daf44cf77a",
      "item": {
        "type": "paragraph",
        "id": "d75612daf44cf77a",
        "text": "Svelte: SvelteKit, Elder.js, Jungle"
      },
      "after": "868e084c4dc75fed",
      "date": 1693989058136
    },
    {
      "type": "add",
      "id": "6e0abe67f29059b1",
      "item": {
        "type": "paragraph",
        "id": "6e0abe67f29059b1",
        "text": "Angular: Analog\nAstro"
      },
      "after": "d75612daf44cf77a",
      "date": 1693989061473
    },
    {
      "type": "edit",
      "id": "6e0abe67f29059b1",
      "item": {
        "type": "paragraph",
        "id": "6e0abe67f29059b1",
        "text": "Angular: Analog"
      },
      "date": 1693989067691
    },
    {
      "type": "add",
      "id": "754047d1de43624f",
      "item": {
        "type": "paragraph",
        "id": "754047d1de43624f",
        "text": "Astro"
      },
      "after": "6e0abe67f29059b1",
      "date": 1693989070484
    },
    {
      "type": "add",
      "id": "4df29b1c29e293f1",
      "item": {
        "type": "paragraph",
        "id": "4df29b1c29e293f1",
        "text": "Astro is a metaframework and focuses on rendering the static parts of a page. It shows that it doesn't take a large framework to follow the idea of meta and hybrid frameworks. Rather, Astro flips the approach and allows frontend frameworks to be integrated into its architecture. "
      },
      "after": "754047d1de43624f",
      "date": 1693989099937
    },
    {
      "type": "edit",
      "id": "754047d1de43624f",
      "item": {
        "type": "paragraph",
        "id": "754047d1de43624f",
        "text": "[[Astro]]"
      },
      "date": 1693989181110
    },
    {
      "type": "edit",
      "id": "4df29b1c29e293f1",
      "item": {
        "type": "paragraph",
        "id": "4df29b1c29e293f1",
        "text": "Astro is a metaframework and focuses on rendering the static parts of a page. It shows that it doesn't take a large framework to follow the idea of meta and hybrid frameworks. Rather, Astro flips the approach and allows frontend frameworks to be integrated into its architecture."
      },
      "date": 1693990029921
    },
    {
      "type": "add",
      "id": "55e5eec4b63057b5",
      "item": {
        "type": "paragraph",
        "id": "55e5eec4b63057b5",
        "text": "Client-side rendering delays program startup "
      },
      "after": "4df29b1c29e293f1",
      "date": 1693990030982
    },
    {
      "item": {
        "type": "factory",
        "id": "d853d64cd73426fa"
      },
      "id": "d853d64cd73426fa",
      "type": "add",
      "after": "55e5eec4b63057b5",
      "date": 1693990047077
    },
    {
      "type": "edit",
      "id": "d853d64cd73426fa",
      "item": {
        "type": "paragraph",
        "id": "d853d64cd73426fa",
        "text": "SPAs, unlike traditional multi-page applications (ordinary web pages), feel more like native applications installed on the respective end device, since complete page loads are omitted. When the SPA is initially invoked, the browser usually loads the entire static source code of the SPA; at runtime, the application only requests the dynamic data needed for display from the server. The static source code consists of the framework, additional libraries and the code of the application components. This leads to a considerable package size, which results in a longer loading time. "
      },
      "date": 1693990048413
    },
    {
      "item": {
        "type": "factory",
        "id": "fc5ff114576a6ac4"
      },
      "id": "fc5ff114576a6ac4",
      "type": "add",
      "after": "d853d64cd73426fa",
      "date": 1693990106062
    },
    {
      "type": "edit",
      "id": "fc5ff114576a6ac4",
      "item": {
        "type": "paragraph",
        "id": "fc5ff114576a6ac4",
        "text": "The lifecycle of an SPA begins with a white page on which the framework dynamically builds the application. The source code present in the browser at this point does not yet contain dynamic data. Therefore, the browser initially renders a component blank and then renders it again once the data is available. This is overhead and works well for internal business applications with a fast network and individual data. For pages publicly available on the Internet, an SPA is less suitable, since search engines are critical in their evaluation if a page has a longer loading time. "
      },
      "date": 1693990107315
    },
    {
      "item": {
        "type": "factory",
        "id": "86cadda16e9a0382"
      },
      "id": "86cadda16e9a0382",
      "type": "add",
      "after": "fc5ff114576a6ac4",
      "date": 1693990165390
    },
    {
      "type": "edit",
      "id": "86cadda16e9a0382",
      "item": {
        "type": "paragraph",
        "id": "86cadda16e9a0382",
        "text": "The idea behind metaframeworks is that delivering empty pages is unnecessary. In most cases, the server can prepare the content and send it to the client. If the content is the same for different user requests, the server can even cache it and provide it faster. However, modern metaframeworks contain even more features."
      },
      "date": 1693990166927
    },
    {
      "item": {
        "type": "factory",
        "id": "e8811b9a9ef830cf"
      },
      "id": "e8811b9a9ef830cf",
      "type": "add",
      "after": "86cadda16e9a0382",
      "date": 1693990219309
    },
    {
      "type": "edit",
      "id": "e8811b9a9ef830cf",
      "item": {
        "type": "paragraph",
        "id": "e8811b9a9ef830cf",
        "text": "Mature toolchain: Basic frameworks make it easier for programmers to get started with application development. Metaframeworks pursue the same goal and offer a preconfigured toolchain for the build process. "
      },
      "date": 1693990227235
    },
    {
      "type": "edit",
      "id": "e8811b9a9ef830cf",
      "item": {
        "type": "paragraph",
        "id": "e8811b9a9ef830cf",
        "text": "Mature toolchain: Basic frameworks make it easier for programmers to get started with application development. Metaframeworks pursue the same goal and offer a preconfigured toolchain for the build process."
      },
      "date": 1693990254359
    },
    {
      "type": "add",
      "id": "04d647fcb54a650b",
      "item": {
        "type": "paragraph",
        "id": "04d647fcb54a650b",
        "text": "Structure for front-end and back-end: Some SPA frameworks partially specify the structure for front-end and back-end as well as for the architecture. Developers have great freedom to organize files and directories. Metaframeworks, on the other hand, work with file system conventions. The rules for placing and naming files and directories are stricter. "
      },
      "after": "e8811b9a9ef830cf",
      "date": 1693990254923
    },
    {
      "item": {
        "type": "factory",
        "id": "43bbd34c80095cb9"
      },
      "id": "43bbd34c80095cb9",
      "type": "add",
      "after": "04d647fcb54a650b",
      "date": 1693990292212
    },
    {
      "type": "edit",
      "id": "43bbd34c80095cb9",
      "item": {
        "type": "paragraph",
        "id": "43bbd34c80095cb9",
        "text": "SEO optimization: One of the most important features of metaframeworks is to develop publicly available applications. Inseparable from this is search engine optimization. Therefore, the frameworks include tools that improve load times, reduce package sizes, and optimize applications for search engines in terms of content and structure. "
      },
      "date": 1693990294165
    },
    {
      "item": {
        "type": "factory",
        "id": "864878e57b87f907"
      },
      "id": "864878e57b87f907",
      "type": "add",
      "after": "43bbd34c80095cb9",
      "date": 1693990325826
    },
    {
      "type": "edit",
      "id": "864878e57b87f907",
      "item": {
        "type": "paragraph",
        "id": "864878e57b87f907",
        "text": "Prebuilding (Static Site Generation): Metaframeworks try to avoid delivering empty web pages. They use the actual front-end framework already server-side to generate HTML structures, which they then deliver to the browser. Depending on when this page generation takes place, it is referred to as server-side rendering or static site generation. "
      },
      "date": 1693990327638
    },
    {
      "item": {
        "type": "factory",
        "id": "6cf3ae1d923ceb4b"
      },
      "id": "6cf3ae1d923ceb4b",
      "type": "add",
      "after": "864878e57b87f907",
      "date": 1693990370284
    },
    {
      "type": "edit",
      "id": "6cf3ae1d923ceb4b",
      "item": {
        "type": "paragraph",
        "id": "6cf3ae1d923ceb4b",
        "text": "Hybrid routing: In a client-server environment, as created by the metaframeworks, the navigation also differs from the previous one in the frontend. Resources requested by users are found in the application's file system structure. Metaframeworks combine server-side routing and client-side navigation for an optimal user experience. "
      },
      "date": 1693990371911
    },
    {
      "item": {
        "type": "factory",
        "id": "4d3df0d9f22c8814"
      },
      "id": "4d3df0d9f22c8814",
      "type": "add",
      "after": "6cf3ae1d923ceb4b",
      "date": 1693990415630
    },
    {
      "type": "edit",
      "id": "4d3df0d9f22c8814",
      "item": {
        "type": "paragraph",
        "id": "4d3df0d9f22c8814",
        "text": "Performance optimization: Modern metaframeworks aim to achieve optimal performance of applications for end users. This is achieved by an optimized initial loading process and a clever combination of features during the runtime of the application, such as lazy loading or pre-fetching. "
      },
      "date": 1693990417430
    },
    {
      "item": {
        "type": "factory",
        "id": "57bd339b7a114c84"
      },
      "id": "57bd339b7a114c84",
      "type": "add",
      "after": "4d3df0d9f22c8814",
      "date": 1693990446477
    },
    {
      "type": "edit",
      "id": "57bd339b7a114c84",
      "item": {
        "type": "paragraph",
        "id": "57bd339b7a114c84",
        "text": "One reason for the development of metaframeworks is that SPAs are reaching their limits in some areas. These include blogs, e-commerce platforms, marketing sites, product websites and portfolios. SPAs show their strength especially in individually designed applications, which are usually protected by a log-in, i.e. where the display is prepared specifically for a user. The more dynamic and individual content an application or the view in an application contains, the more likely a SPA is to be used. "
      },
      "date": 1693990448046
    },
    {
      "type": "edit",
      "id": "57bd339b7a114c84",
      "item": {
        "type": "paragraph",
        "id": "57bd339b7a114c84",
        "text": "One reason for the development of metaframeworks is that SPAs are reaching their limits in some areas. These include blogs, e-commerce platforms, marketing sites, product websites and portfolios. SPAs show their strength especially in individually designed applications, which are usually protected by a log-in, i.e. where the display is prepared specifically for a user. The more dynamic and individual content an application or the view in an application contains, the more likely a SPA is to be used."
      },
      "date": 1693990523120
    },
    {
      "type": "add",
      "id": "f72782ce4c543a6f",
      "item": {
        "type": "paragraph",
        "id": "f72782ce4c543a6f",
        "text": "However, if several users share data and display, or if the application is publicly accessible and presents at least partially static content - which is often the case, especially in the B2C environment - it is well suited for a metaframework. This is all about presenting data. The focus is on delivery speed to satisfy users, but also search engines. While SPA frameworks are developer-friendly and very flexible, they are significantly inferior to static HTML and CSS when it comes to speed. Therefore, the wave is currently sloshing back towards servers. The development teams of the major frameworks and the community are also taking this development into account. "
      },
      "after": "57bd339b7a114c84",
      "date": 1693990523809
    },
    {
      "type": "edit",
      "id": "f72782ce4c543a6f",
      "item": {
        "type": "paragraph",
        "id": "f72782ce4c543a6f",
        "text": "However, if several users share data and display, or if the application is publicly accessible and presents at least partially static content – which is often the case, especially in the B2C environment – it is well suited for a metaframework. This is all about presenting data. The focus is on delivery speed to satisfy users, but also search engines. While SPA frameworks are developer-friendly and very flexible, they are significantly inferior to static HTML and CSS when it comes to speed. Therefore, the wave is currently sloshing back towards servers. The development teams of the major frameworks and the community are also taking this development into account. "
      },
      "date": 1693990543717
    },
    {
      "type": "edit",
      "id": "f72782ce4c543a6f",
      "item": {
        "type": "paragraph",
        "id": "f72782ce4c543a6f",
        "text": "However, if several users share data and display, or if the application is publicly accessible and presents at least partially static content – which is often the case, especially in the B2C environment – it is well suited for a metaframework. This is all about presenting data. The focus is on delivery speed to satisfy users, but also search engines. While SPA frameworks are developer-friendly and very flexible, they are significantly inferior to static HTML and CSS when it comes to speed. Therefore, the wave is currently sloshing back towards servers. The development teams of the major frameworks and the community are also taking this development into account."
      },
      "date": 1693990592171
    },
    {
      "type": "add",
      "id": "3ce2989aaa8c75e9",
      "item": {
        "type": "paragraph",
        "id": "3ce2989aaa8c75e9",
        "text": "Server-side rendering and static page generation "
      },
      "after": "f72782ce4c543a6f",
      "date": 1693990592754
    },
    {
      "type": "edit",
      "id": "3ce2989aaa8c75e9",
      "item": {
        "type": "paragraph",
        "id": "3ce2989aaa8c75e9",
        "text": "Server-side rendering and static page generation"
      },
      "date": 1693990605850
    },
    {
      "type": "add",
      "id": "e85d7ef3fe29a60a",
      "item": {
        "type": "paragraph",
        "id": "e85d7ef3fe29a60a",
        "text": "The terms server-side rendering and static site generation are frequently used in connection with metaframeworks. Both approaches ensure that the HTML structure of the application is not initially built in the browser, but prepared on the server side. "
      },
      "after": "3ce2989aaa8c75e9",
      "date": 1693990606412
    },
    {
      "type": "add",
      "id": "7eb8ed9355f9b3d2",
      "item": {
        "type": "paragraph",
        "id": "7eb8ed9355f9b3d2",
        "text": "⇒ [[Martin Holzmann]]"
      },
      "after": "527e6186721bb1ad",
      "date": 1693990727453
    },
    {
      "type": "edit",
      "id": "7eb8ed9355f9b3d2",
      "item": {
        "type": "paragraph",
        "id": "7eb8ed9355f9b3d2",
        "text": "⇒ [[Martin Holzmann]]. [https://www.linkedin.com/in/martin-holzmann-353ab74/ linkedin]"
      },
      "date": 1693990782610
    },
    {
      "type": "edit",
      "id": "ffeb296afa5585f5",
      "item": {
        "type": "paragraph",
        "id": "ffeb296afa5585f5",
        "text": "⇒ [[SPA]] ⇒ [[Sebastian Springer]]. [https://www.linkedin.com/in/sebastian-springer-5252064a/ linkedin]"
      },
      "date": 1693991157951
    },
    {
      "item": {
        "type": "factory",
        "id": "2b5e1bf04351432e"
      },
      "id": "2b5e1bf04351432e",
      "type": "add",
      "after": "e85d7ef3fe29a60a",
      "date": 1693991233887
    },
    {
      "type": "edit",
      "id": "2b5e1bf04351432e",
      "item": {
        "type": "paragraph",
        "id": "2b5e1bf04351432e",
        "text": "In Static Site Generation, the build process builds the structure of the application. To do this, the process executes the original client-side framework on the server side and uses it to generate static HTML. Static web servers such as Apache or nginx deliver it to the clients. With each client call, the server sends the same sources to the browser. Therefore, the data for display must already be available at build time. Static Site Generation is therefore only suitable for little dynamic data. "
      },
      "date": 1693991235670
    },
    {
      "type": "edit",
      "id": "2b5e1bf04351432e",
      "item": {
        "type": "paragraph",
        "id": "2b5e1bf04351432e",
        "text": "In Static Site Generation, the build process builds the structure of the application. To do this, the process executes the original client-side framework on the server side and uses it to generate static HTML. Static web servers such as [[Apache]] or [[nginx]] deliver it to the clients. With each client call, the server sends the same sources to the browser. Therefore, the data for display must already be available at build time. Static Site Generation is therefore only suitable for little dynamic data. "
      },
      "date": 1693991269575
    },
    {
      "type": "edit",
      "id": "2b5e1bf04351432e",
      "item": {
        "type": "paragraph",
        "id": "2b5e1bf04351432e",
        "text": "In Static Site Generation, the build process builds the structure of the application. To do this, the process executes the original client-side framework on the server side and uses it to generate static HTML. Static web servers such as [[Apache]] or [[nginx]] deliver it to the clients. With each client call, the server sends the same sources to the browser. Therefore, the data for display must already be available at build time. Static Site Generation is therefore only suitable for little dynamic data."
      },
      "date": 1693991336962
    },
    {
      "type": "add",
      "id": "8019e3e633d62478",
      "item": {
        "type": "paragraph",
        "id": "8019e3e633d62478",
        "text": "In server-side rendering, the server generates the responses to the client on demand. This requires running a server process (usually based on Node.js) that executes the framework. It generates static HTML on demand, which it sends to the client. Server-side rendering is slower than static site generation, but it ensures that the user doesn't see a blank page to begin with. "
      },
      "after": "2b5e1bf04351432e",
      "date": 1693991337646
    },
    {
      "type": "edit",
      "id": "8019e3e633d62478",
      "item": {
        "type": "paragraph",
        "id": "8019e3e633d62478",
        "text": "In server-side rendering, the server generates the responses to the client on demand. This requires running a server process (usually based on [[Node.js]]) that executes the framework. It generates static HTML on demand, which it sends to the client. Server-side rendering is slower than static site generation, but it ensures that the user doesn't see a blank page to begin with. "
      },
      "date": 1693991369126
    },
    {
      "type": "edit",
      "id": "8019e3e633d62478",
      "item": {
        "type": "paragraph",
        "id": "8019e3e633d62478",
        "text": "In server-side rendering, the server generates the responses to the client on demand. This requires running a server process (usually based on [[Node.js]]) that executes the framework. It generates static HTML on demand, which it sends to the client. Server-side rendering is slower than static site generation, but it ensures that the user doesn't see a blank page to begin with."
      },
      "date": 1693991405562
    },
    {
      "type": "add",
      "id": "39434639a6755c60",
      "item": {
        "type": "paragraph",
        "id": "39434639a6755c60",
        "text": "Whether static site generation or server-side rendering, in both cases the client must take control of the generated structure after the initial request so that the frontend becomes dynamic. This process is called hydration. After hydration is complete, an ordinary client-side SPA and a static-site generation or server-side rendering application are indistinguishable. "
      },
      "after": "8019e3e633d62478",
      "date": 1693991406044
    },
    {
      "type": "edit",
      "id": "39434639a6755c60",
      "item": {
        "type": "paragraph",
        "id": "39434639a6755c60",
        "text": "Whether static site generation or server-side rendering, in both cases the client must take control of the generated structure after the initial request so that the frontend becomes dynamic. This process is called [[Hydration]]. After hydration is complete, an ordinary client-side SPA and a static-site generation or server-side rendering application are indistinguishable. "
      },
      "date": 1693991443924
    },
    {
      "type": "edit",
      "id": "39434639a6755c60",
      "item": {
        "type": "paragraph",
        "id": "39434639a6755c60",
        "text": "Whether static site generation or server-side rendering, in both cases the client must take control of the generated structure after the initial request so that the frontend becomes dynamic. This process is called [[Hydration]]. After hydration is complete, an ordinary client-side SPA and a static-site generation or server-side rendering application are indistinguishable."
      },
      "date": 1693991526675
    },
    {
      "type": "add",
      "id": "637d05d05fe7580f",
      "item": {
        "type": "paragraph",
        "id": "637d05d05fe7580f",
        "text": "Frameworks implement static site generation and server-side rendering differently, but the idea is the same. The React metaframework Next.js organizes the individual views of an application into page components. These are ordinary React components that become pages simply by being placed in a specific directory, defining reachable endpoints in the user front end."
      },
      "after": "39434639a6755c60",
      "date": 1693991527422
    },
    {
      "type": "add",
      "id": "756506d7a34b1b2b",
      "item": {
        "type": "paragraph",
        "id": "756506d7a34b1b2b",
        "text": "[…]"
      },
      "after": "637d05d05fe7580f",
      "date": 1693991640531
    },
    {
      "type": "add",
      "id": "85995de570e2a8ae",
      "item": {
        "type": "paragraph",
        "id": "85995de570e2a8ae",
        "text": "One advantage of metaframeworks is that they do not restrict the functionality of the underlying SPA frameworks, but extend it. Thus, an application can use static site generation, server-side rendering, but also classic client-side data fetching. It is also possible to render a component server-side and then load further data in the client, thus combining both concepts. "
      },
      "after": "756506d7a34b1b2b",
      "date": 1693991665837
    },
    {
      "type": "edit",
      "id": "85995de570e2a8ae",
      "item": {
        "type": "paragraph",
        "id": "85995de570e2a8ae",
        "text": "One advantage of metaframeworks is that they do not restrict the functionality of the underlying SPA frameworks, but extend it. Thus, an application can use static site generation, server-side rendering, but also classic client-side data fetching. It is also possible to render a component server-side and then load further data in the client, thus combining both concepts."
      },
      "date": 1693991693324
    },
    {
      "type": "add",
      "id": "070f4161970b2ce4",
      "item": {
        "type": "paragraph",
        "id": "070f4161970b2ce4",
        "text": "Navigate within the application"
      },
      "after": "85995de570e2a8ae",
      "date": 1693991693901
    },
    {
      "type": "add",
      "id": "7752dfa0b9ea56c8",
      "item": {
        "type": "paragraph",
        "id": "7752dfa0b9ea56c8",
        "text": "SPAs follow a component-based architecture, thus consist of a component tree. It is however not static, but can be arranged dynamically by program logic. At run time one can attach or detach individual components or entire subtrees and so affect the display. Depending upon, where one intervenes into the component tree, for the user another display can be obtained. Such a conditional rendering of subtrees takes place in the simplest case by branches in the application source code. The disadvantage is that the navigation status is available only within the application. "
      },
      "after": "070f4161970b2ce4",
      "date": 1693991704643
    },
    {
      "type": "edit",
      "id": "7752dfa0b9ea56c8",
      "item": {
        "type": "paragraph",
        "id": "7752dfa0b9ea56c8",
        "text": "SPAs follow a component-based architecture, thus consist of a component tree. It is however not static, but can be arranged dynamically by program logic. At run time one can attach or detach individual components or entire subtrees and so affect the display. Depending upon, where one intervenes into the component tree, for the user another display can be obtained. Such a conditional rendering of subtrees takes place in the simplest case by branches in the application source code. The disadvantage is that the navigation status is ava"
      },
      "date": 1693991743756
    },
    {
      "type": "edit",
      "id": "7752dfa0b9ea56c8",
      "item": {
        "type": "paragraph",
        "id": "7752dfa0b9ea56c8",
        "text": "SPAs follow a component-based architecture, thus consist of a component tree. It is however not static, but can be arranged dynamically by program logic. At run time one can attach or detach individual components or entire subtrees and so affect the display. Depending upon, where one intervenes into the component tree, for the user another display can be obtained. Such a conditional rendering of subtrees takes place in the simplest case by branches in the application source code. The disadvantage is that the navigation status is available only within the application."
      },
      "date": 1693991750684
    },
    {
      "type": "add",
      "id": "522f3b9866b3e251",
      "item": {
        "type": "paragraph",
        "id": "522f3b9866b3e251",
        "text": "The common frameworks have routing extensions that can be installed as additional packages and integrated into the application. The routes of these frameworks work purely client-side and are configurable in the frontend in the components. Here, there are implementation differences between the individual products, but the general functionality hardly differs. The routers are based on the native browser interfaces and use either the older hash navigation with the jump marks in the URL or the newer history API. "
      },
      "after": "7752dfa0b9ea56c8",
      "date": 1693991755350
    },
    {
      "type": "edit",
      "id": "522f3b9866b3e251",
      "item": {
        "type": "paragraph",
        "id": "522f3b9866b3e251",
        "text": "The common frameworks have routing extensions that can be installed as additional packages and integrated into the application. The routes of these frameworks work purely client-side and are configurable in the frontend in the components. Here, there are implementation differences between the individual products, but the general functionality hardly differs. The routers are based on the native browser interfaces and use either the older hash navigation with the jump marks in the URL or the newer [[History API]]. "
      },
      "date": 1693991812143
    },
    {
      "type": "edit",
      "id": "522f3b9866b3e251",
      "item": {
        "type": "paragraph",
        "id": "522f3b9866b3e251",
        "text": "The common frameworks have routing extensions that can be installed as additional packages and integrated into the application. The routes of these frameworks work purely client-side and are configurable in the frontend in the components. Here, there are implementation differences between the individual products, but the general functionality hardly differs. The routers are based on the native browser interfaces and use either the older hash navigation with the jump marks in the URL or the newer [[History API]]."
      },
      "date": 1693992270942
    },
    {
      "type": "add",
      "id": "b94a155e2506f221",
      "item": {
        "type": "paragraph",
        "id": "b94a155e2506f221",
        "text": "In both cases, the router maps the current state of the application via the URL and provides navigation interfaces. These can either be components that the framework renders regularly and that users can use like ordinary links, or navigation functions that the application itself uses to navigate from the program code. Hybrid frameworks such as Analog, which operate on both the client and server sides, take this approach further and provide server-side routing in addition to client-side navigation. "
      },
      "after": "522f3b9866b3e251",
      "date": 1693992271739
    },
    {
      "type": "edit",
      "id": "b94a155e2506f221",
      "item": {
        "type": "paragraph",
        "id": "b94a155e2506f221",
        "text": "In both cases, the [[Router]] maps the current state of the application via the URL and provides navigation interfaces. These can either be components that the framework renders regularly and that users can use like ordinary links, or navigation functions that the application itself uses to navigate from the program code. Hybrid frameworks such as Analog, which operate on both the client and server sides, take this approach further and provide server-side routing in addition to client-side navigation. "
      },
      "date": 1693992313373
    },
    {
      "type": "edit",
      "id": "b94a155e2506f221",
      "item": {
        "type": "paragraph",
        "id": "b94a155e2506f221",
        "text": "In both cases, the [[Router]] maps the current state of the application via the URL and provides navigation interfaces. These can either be components that the framework renders regularly and that users can use like ordinary links, or navigation functions that the application itself uses to navigate from the program code. Hybrid frameworks such as [[Analog]], which operate on both the client and server sides, take this approach further and provide server-side routing in addition to client-side navigation. "
      },
      "date": 1693992671702
    },
    {
      "item": {
        "type": "factory",
        "id": "4ea74e73a8e53fc6"
      },
      "id": "4ea74e73a8e53fc6",
      "type": "add",
      "after": "b94a155e2506f221",
      "date": 1693992723373
    },
    {
      "type": "edit",
      "id": "4ea74e73a8e53fc6",
      "item": {
        "type": "paragraph",
        "id": "4ea74e73a8e53fc6",
        "text": "Most metaframeworks organize their views via page components in the file system. Here, the directory and file hierarchy defines the URL path for users. The path can be static or dynamic and contain variables. The page components access these variables and adjust the display. Both server-side rendering and static site generation support variables in routes, although with static site generation, all valid values must already be fixed and known at build time. The server then uses these values to generate the required structures and stores them in the file system. With server-side rendering, the server responds to the variables and can request additional resources such as a database or other data source and generate a structure for the current request. Dynamic routes can be used, for example, to generate detailed views of data records or pre-populated forms for editing data. "
      },
      "date": 1693992725377
    },
    {
      "type": "edit",
      "id": "4ea74e73a8e53fc6",
      "item": {
        "type": "paragraph",
        "id": "4ea74e73a8e53fc6",
        "text": "Most metaframeworks organize their views via page components in the file system. Here, the directory and file hierarchy defines the URL path for users. The path can be static or dynamic and contain variables. The page components access these variables and adjust the display. Both server-side rendering and static site generation support variables in routes, although with static site generation, all valid values must already be fixed and known at build time. The server then uses these values to generate the required structures and stores them in the file system. With server-side rendering, the server responds to the variables and can request additional resources such as a database or other data source and generate a structure for the current request. Dynamic routes [⇒[[Dynamic Segments]]]can be used, for example, to generate detailed views of data records or pre-populated forms for editing data. "
      },
      "date": 1693992818453
    },
    {
      "type": "edit",
      "id": "4ea74e73a8e53fc6",
      "item": {
        "type": "paragraph",
        "id": "4ea74e73a8e53fc6",
        "text": "Most metaframeworks organize their views via page components in the file system. Here, the directory and file hierarchy defines the URL path for users. The path can be static or dynamic and contain variables. The page components access these variables and adjust the display. Both server-side rendering and static site generation support variables in routes, although with static site generation, all valid values must already be fixed and known at build time. The server then uses these values to generate the required structures and stores them in the file system. With server-side rendering, the server responds to the variables and can request additional resources such as a database or other data source and generate a structure for the current request. Dynamic routes [⇒ [[Dynamic Segments]]] can be used, for example, to generate detailed views of data records or pre-populated forms for editing data. "
      },
      "date": 1693992826760
    },
    {
      "type": "edit",
      "id": "4ea74e73a8e53fc6",
      "item": {
        "type": "paragraph",
        "id": "4ea74e73a8e53fc6",
        "text": "Most metaframeworks organize their views via page components in the file system. Here, the directory and file hierarchy defines the URL path for users. The path can be static or dynamic and contain variables. The page components access these variables and adjust the display. Both server-side rendering and static site generation support variables in routes, although with static site generation, all valid values must already be fixed and known at build time. The server then uses these values to generate the required structures and stores them in the file system. With server-side rendering, the server responds to the variables and can request additional resources such as a database or other data source and generate a structure for the current request. Dynamic routes [⇒ [[Dynamic Segments]]] can be used, for example, to generate detailed views of data records or pre-populated [[Forms]] for editing data. "
      },
      "date": 1693992904236
    },
    {
      "type": "edit",
      "id": "4ea74e73a8e53fc6",
      "item": {
        "type": "paragraph",
        "id": "4ea74e73a8e53fc6",
        "text": "Most metaframeworks organize their views via page components in the file system. Here, the directory and file hierarchy defines the URL path for users. The path can be static or dynamic and contain variables. The page components access these variables and adjust the display. Both server-side rendering and static site generation support variables in routes, although with static site generation, all valid values must already be fixed and known at build time. The server then uses these values to generate the required structures and stores them in the file system. With server-side rendering, the server responds to the variables and can request additional resources such as a database or other data source and generate a structure for the current request. Dynamic routes [⇒ [[Dynamic Segments]]] can be used, for example, to generate detailed views of data records or pre-populated [[Forms]] for editing data."
      },
      "date": 1693992952117
    },
    {
      "type": "add",
      "id": "6b987719aaed458c",
      "item": {
        "type": "paragraph",
        "id": "6b987719aaed458c",
        "text": "The frameworks combine client-side and server-side navigation so cleverly that users get the impression that the application is an ordinary SPA with client-side navigation (Figure 2). When switching between two pages, the framework does not reload all HTML, CSS, and JavaScript, but only the additional resources needed to display the new content. The frameworks combine the advantages of classic multi-page applications including their server-side pre-generated content with the fluid operation of SPAs. "
      },
      "after": "4ea74e73a8e53fc6",
      "date": 1693992953103
    },
    {
      "item": {
        "type": "factory",
        "id": "bb8f00e01d0611ad"
      },
      "id": "bb8f00e01d0611ad",
      "type": "add",
      "after": "6b987719aaed458c",
      "date": 1693993024599
    },
    {
      "type": "remove",
      "id": "bb8f00e01d0611ad",
      "date": 1693993067655
    },
    {
      "item": {
        "type": "factory",
        "id": "881c387ef0a65f6e"
      },
      "id": "881c387ef0a65f6e",
      "type": "add",
      "after": "6b987719aaed458c",
      "date": 1693993068953
    },
    {
      "type": "edit",
      "id": "881c387ef0a65f6e",
      "item": {
        "type": "image",
        "id": "881c387ef0a65f6e",
        "text": "\nOn the front end, hybrid frameworks work like ordinary SPAs without the delays of a multi-page application (Fig. 2).\nVercel, Inc.\n",
        "size": "wide",
        "width": 418,
        "height": 165,
        "url": "/assets/plugins/image/aeac6de56aa3952d5e2072e98ac3a90d.jpg"
      },
      "date": 1693993094581
    },
    {
      "type": "edit",
      "id": "6b987719aaed458c",
      "item": {
        "type": "paragraph",
        "id": "6b987719aaed458c",
        "text": "The frameworks combine client-side and server-side navigation so cleverly that users get the impression that the application is an ordinary SPA with client-side navigation (Figure 2)."
      },
      "date": 1693993102659
    },
    {
      "type": "add",
      "id": "27e87d54cc263c2b",
      "item": {
        "type": "paragraph",
        "id": "27e87d54cc263c2b",
        "text": "When switching between two pages, the framework does not reload all HTML, CSS, and JavaScript, but only the additional resources needed to display the new content. The frameworks combine the advantages of classic multi-page applications including their server-side pre-generated content with the fluid operation of SPAs."
      },
      "after": "6b987719aaed458c",
      "date": 1693993103381
    },
    {
      "id": "881c387ef0a65f6e",
      "type": "move",
      "order": [
        "448a859433bc861b",
        "d61d994bbaeb36a4",
        "b7e235132ef58e4d",
        "90ecc08458ac00e4",
        "f840a62e1a48e5bb",
        "0142b726c1a09bb7",
        "59beda0aa2463411",
        "f0cbaf616f3e5ee9",
        "e85e677c1e853e56",
        "49ad6afe55cbd31f",
        "4309af65b82e86d0",
        "1f3ab14e4ee1d302",
        "4e6e59cf2d478375",
        "527e6186721bb1ad",
        "7eb8ed9355f9b3d2",
        "ffeb296afa5585f5",
        "dc49c2839a81588b",
        "6daedabb93e95fbf",
        "6d759c19ce0ae0db",
        "c5bca6dc41ef3a13",
        "7e61957d30e9372b",
        "727f4c5579340787",
        "0e9cacfe1d4f2f54",
        "868e084c4dc75fed",
        "d75612daf44cf77a",
        "6e0abe67f29059b1",
        "754047d1de43624f",
        "4df29b1c29e293f1",
        "55e5eec4b63057b5",
        "d853d64cd73426fa",
        "fc5ff114576a6ac4",
        "86cadda16e9a0382",
        "e8811b9a9ef830cf",
        "04d647fcb54a650b",
        "43bbd34c80095cb9",
        "864878e57b87f907",
        "6cf3ae1d923ceb4b",
        "4d3df0d9f22c8814",
        "57bd339b7a114c84",
        "f72782ce4c543a6f",
        "3ce2989aaa8c75e9",
        "e85d7ef3fe29a60a",
        "2b5e1bf04351432e",
        "8019e3e633d62478",
        "39434639a6755c60",
        "637d05d05fe7580f",
        "756506d7a34b1b2b",
        "85995de570e2a8ae",
        "070f4161970b2ce4",
        "7752dfa0b9ea56c8",
        "522f3b9866b3e251",
        "b94a155e2506f221",
        "4ea74e73a8e53fc6",
        "6b987719aaed458c",
        "881c387ef0a65f6e",
        "27e87d54cc263c2b"
      ],
      "date": 1693993104977
    },
    {
      "type": "edit",
      "id": "881c387ef0a65f6e",
      "item": {
        "type": "image",
        "id": "881c387ef0a65f6e",
        "text": "On the front end, hybrid frameworks work like ordinary SPAs without the delays of a multi-page application (Fig. 2).\nSource: Vercel, Inc.\n\n",
        "size": "wide",
        "width": 418,
        "height": 165,
        "url": "/assets/plugins/image/aeac6de56aa3952d5e2072e98ac3a90d.jpg"
      },
      "date": 1693993149622
    },
    {
      "type": "add",
      "id": "4ceaa6b8abcd87f6",
      "item": {
        "type": "paragraph",
        "id": "4ceaa6b8abcd87f6",
        "text": "Conclusion"
      },
      "after": "27e87d54cc263c2b",
      "date": 1693993193164
    },
    {
      "item": {
        "type": "factory",
        "id": "356958db25e18ab9"
      },
      "id": "356958db25e18ab9",
      "type": "add",
      "after": "4ceaa6b8abcd87f6",
      "date": 1693993205233
    },
    {
      "type": "edit",
      "id": "356958db25e18ab9",
      "item": {
        "type": "paragraph",
        "id": "356958db25e18ab9",
        "text": "Single-page applications have become increasingly established in the web world in recent years and have developed into a universal solution for various problems. However, purely client-side single-page applications are subject to limitations and hardly exploit the potential of the backend infrastructure, since they regard the backend as a pure data provider. "
      },
      "date": 1693993206968
    },
    {
      "type": "edit",
      "id": "356958db25e18ab9",
      "item": {
        "type": "paragraph",
        "id": "356958db25e18ab9",
        "text": "Single-page applications have become increasingly established in the web world in recent years and have developed into a universal solution for various problems. However, purely client-side single-page applications are subject to limitations and hardly exploit the potential of the backend infrastructure, since they regard the backend as a pure data provider."
      },
      "date": 1693993286467
    },
    {
      "type": "add",
      "id": "7c45151a94b8b9eb",
      "item": {
        "type": "paragraph",
        "id": "7c45151a94b8b9eb",
        "text": "Modern metaframeworks consist of a server process and a client-side application. The server can pre-generate structures and run static site generation or generate the structures on demand and apply server-side rendering. In addition, frameworks have other features such as image and font optimization that positively affect the performance of an application. SPA frameworks can therefore gain a foothold in areas that were previously reserved for established CMS systems."
      },
      "after": "356958db25e18ab9",
      "date": 1693993287134
    },
    {
      "type": "edit",
      "id": "7c45151a94b8b9eb",
      "item": {
        "type": "paragraph",
        "id": "7c45151a94b8b9eb",
        "text": "Modern metaframeworks consist of a server process and a client-side application. The server can pre-generate structures and run static site generation or generate the structures on demand and apply server-side rendering. In addition, frameworks have other features such as image and font optimization that positively affect the performance of an application. SPA frameworks can therefore gain a foothold in areas that were previously reserved for established CMS systems"
      },
      "date": 1693993323297
    },
    {
      "type": "add",
      "id": "4ca44add29038f81",
      "item": {
        "type": "paragraph",
        "id": "4ca44add29038f81",
        "text": "Opinion"
      },
      "after": "7c45151a94b8b9eb",
      "date": 1693993326997
    },
    {
      "type": "edit",
      "id": "7c45151a94b8b9eb",
      "item": {
        "type": "paragraph",
        "id": "7c45151a94b8b9eb",
        "text": "Modern metaframeworks consist of a server process and a client-side application. The server can pre-generate structures and run static site generation or generate the structures on demand and apply server-side rendering. In addition, frameworks have other features such as image and font optimization that positively affect the performance of an application. SPA frameworks can therefore gain a foothold in areas that were previously reserved for established CMS systems."
      },
      "date": 1693993329643
    },
    {
      "type": "add",
      "id": "02bc174da2924ffc",
      "item": {
        "type": "paragraph",
        "id": "02bc174da2924ffc",
        "text": "Metaframeworks have what it takes to usher in a new era of front-end development. This goes hand in hand with a new programming paradigm: The server manages the data, makes it available and prepares the rendering of the interface. The client side then takes control and takes care of the display and interaction. "
      },
      "after": "4ca44add29038f81",
      "date": 1693993338680
    },
    {
      "type": "edit",
      "id": "02bc174da2924ffc",
      "item": {
        "type": "paragraph",
        "id": "02bc174da2924ffc",
        "text": "Metaframeworks have what it takes to usher in a new era of front-end development. This goes hand in hand with a new programming paradigm: The server manages the data, makes it available and prepares the rendering of the interface. The client side then takes control and takes care of the display and interaction."
      },
      "date": 1693993363668
    },
    {
      "type": "add",
      "id": "41300646478a5d59",
      "item": {
        "type": "paragraph",
        "id": "41300646478a5d59",
        "text": "React follows this path more consistently than its competitors and does not shy away from scaring away developers with this communication. One of my first thoughts was: Now Facebook is once again cooking its own soup without regard for losses. Facebook didn't develop React out of pure charity either, but largely out of self-interest, for example to implement Facebook and Instagram websites. One of the most widely used frontend frameworks was created as a waste product. "
      },
      "after": "02bc174da2924ffc",
      "date": 1693993364514
    },
    {
      "type": "edit",
      "id": "41300646478a5d59",
      "item": {
        "type": "paragraph",
        "id": "41300646478a5d59",
        "text": "React follows this path more consistently than its competitors and does not shy away from scaring away developers with this communication. One of my ([[Sebastian Springer]])first thoughts was: Now Facebook is once again cooking its own soup without regard for losses. Facebook didn't develop React out of pure charity either, but largely out of self-interest, for example to implement Facebook and Instagram websites. One of the most widely used frontend frameworks was created as a waste product. "
      },
      "date": 1693993403865
    },
    {
      "type": "edit",
      "id": "41300646478a5d59",
      "item": {
        "type": "paragraph",
        "id": "41300646478a5d59",
        "text": "React follows this path more consistently than its competitors and does not shy away from scaring away developers with this communication. One of my ([[Sebastian Springer]]) first thoughts was: Now Facebook is once again cooking its own soup without regard for losses. Facebook didn't develop React out of pure charity either, but largely out of self-interest, for example to implement Facebook and Instagram websites. One of the most widely used frontend frameworks was created as a waste product. "
      },
      "date": 1693993409196
    },
    {
      "type": "edit",
      "id": "41300646478a5d59",
      "item": {
        "type": "paragraph",
        "id": "41300646478a5d59",
        "text": "React follows this path more consistently than its competitors and does not shy away from scaring away developers with this communication. One of my ([[Sebastian Springer]]) first thoughts was: Now Facebook is once again cooking its own soup without regard for losses. Facebook didn't develop React out of pure charity either, but largely out of self-interest, for example to implement Facebook and Instagram websites. One of the most widely used frontend frameworks was created as a by-product. "
      },
      "date": 1693993457014
    },
    {
      "type": "edit",
      "id": "41300646478a5d59",
      "item": {
        "type": "paragraph",
        "id": "41300646478a5d59",
        "text": "React follows this path more consistently than its competitors and does not shy away from scaring away developers with this communication. One of my ([[Sebastian Springer]]) first thoughts was: Now Facebook is once again cooking its own soup without regard for losses. Facebook didn't develop React out of pure charity either, but largely out of self-interest, for example to implement Facebook and Instagram websites. One of the most widely used frontend frameworks was created as a by-product."
      },
      "date": 1693993468615
    },
    {
      "type": "add",
      "id": "c03999ca7e88c0d6",
      "item": {
        "type": "paragraph",
        "id": "c03999ca7e88c0d6",
        "text": "The hybrid approach that React is now taking also pays back to a very Facebook-specific problem: a front-end application that can be prepared server-side. A big advantage of this brave new world is the excellent performance for public applications. This benefits the B2C environment in particular, where load time plays a major role. The danger I currently see is that the hybrid approach is the new all-purpose solution, and again it solves problems that don't lend themselves to it. Developers should use the option of opting in or opting out of the respective features and try to use the appropriate solution for the problem. "
      },
      "after": "41300646478a5d59",
      "date": 1693993469182
    },
    {
      "type": "edit",
      "id": "c03999ca7e88c0d6",
      "item": {
        "type": "paragraph",
        "id": "c03999ca7e88c0d6",
        "text": "The hybrid approach that React is now taking also pays back to a very Facebook-specific problem: a front-end application that can be prepared server-side. A big advantage of this brave new world is the excellent performance for public applications. This benefits the B2C environment in particular, where load time plays a major role. The danger I ([[Sebastian Springer]])  currently see is that the hybrid approach is the new all-purpose solution, and again it solves problems that don't lend themselves to it. Developers should use the option of opting in or opting out of the respective features and try to use the appropriate solution for the problem. "
      },
      "date": 1693993516415
    },
    {
      "type": "remove",
      "id": "0142b726c1a09bb7",
      "date": 1693994698066
    },
    {
      "type": "edit",
      "id": "448a859433bc861b",
      "item": {
        "type": "paragraph",
        "id": "448a859433bc861b",
        "text": "⇐ [[Wiki Module]] ⇒ [[Render Story]] ⇒ [[Trail Climbing]]"
      },
      "date": 1693994699549
    },
    {
      "type": "add",
      "id": "94e72fd8ee0064d9",
      "item": {
        "type": "paragraph",
        "id": "94e72fd8ee0064d9",
        "text": "⇒ [[configuration.nix @dreyeck]]"
      },
      "after": "90ecc08458ac00e4",
      "date": 1693994869930
    },
    {
      "id": "94e72fd8ee0064d9",
      "type": "move",
      "order": [
        "448a859433bc861b",
        "d61d994bbaeb36a4",
        "b7e235132ef58e4d",
        "90ecc08458ac00e4",
        "f840a62e1a48e5bb",
        "94e72fd8ee0064d9",
        "59beda0aa2463411",
        "f0cbaf616f3e5ee9",
        "e85e677c1e853e56",
        "49ad6afe55cbd31f",
        "4309af65b82e86d0",
        "1f3ab14e4ee1d302",
        "4e6e59cf2d478375",
        "527e6186721bb1ad",
        "7eb8ed9355f9b3d2",
        "ffeb296afa5585f5",
        "dc49c2839a81588b",
        "6daedabb93e95fbf",
        "6d759c19ce0ae0db",
        "c5bca6dc41ef3a13",
        "7e61957d30e9372b",
        "727f4c5579340787",
        "0e9cacfe1d4f2f54",
        "868e084c4dc75fed",
        "d75612daf44cf77a",
        "6e0abe67f29059b1",
        "754047d1de43624f",
        "4df29b1c29e293f1",
        "55e5eec4b63057b5",
        "d853d64cd73426fa",
        "fc5ff114576a6ac4",
        "86cadda16e9a0382",
        "e8811b9a9ef830cf",
        "04d647fcb54a650b",
        "43bbd34c80095cb9",
        "864878e57b87f907",
        "6cf3ae1d923ceb4b",
        "4d3df0d9f22c8814",
        "57bd339b7a114c84",
        "f72782ce4c543a6f",
        "3ce2989aaa8c75e9",
        "e85d7ef3fe29a60a",
        "2b5e1bf04351432e",
        "8019e3e633d62478",
        "39434639a6755c60",
        "637d05d05fe7580f",
        "756506d7a34b1b2b",
        "85995de570e2a8ae",
        "070f4161970b2ce4",
        "7752dfa0b9ea56c8",
        "522f3b9866b3e251",
        "b94a155e2506f221",
        "4ea74e73a8e53fc6",
        "6b987719aaed458c",
        "881c387ef0a65f6e",
        "27e87d54cc263c2b",
        "4ceaa6b8abcd87f6",
        "356958db25e18ab9",
        "7c45151a94b8b9eb",
        "4ca44add29038f81",
        "02bc174da2924ffc",
        "41300646478a5d59",
        "c03999ca7e88c0d6"
      ],
      "date": 1693994886015
    },
    {
      "type": "edit",
      "id": "94e72fd8ee0064d9",
      "item": {
        "type": "paragraph",
        "id": "94e72fd8ee0064d9",
        "text": "⇒ [[configuration.nix @dreyeck]] ⇒ [[elm-pages.service]]"
      },
      "date": 1694000153662
    },
    {
      "type": "edit",
      "id": "90ecc08458ac00e4",
      "item": {
        "type": "paragraph",
        "id": "90ecc08458ac00e4",
        "text": "How to configure Systemd service unit to start Node app with \"npm start\" instead of \"app.js\" "
      },
      "date": 1694000175196
    },
    {
      "type": "remove",
      "id": "f840a62e1a48e5bb",
      "date": 1694000176827
    },
    {
      "type": "remove",
      "id": "94e72fd8ee0064d9",
      "date": 1694000180969
    },
    {
      "type": "edit",
      "id": "90ecc08458ac00e4",
      "item": {
        "type": "paragraph",
        "id": "90ecc08458ac00e4",
        "text": "How to configure Systemd service unit to start Node app with \"npm start\" instead of \"app.js\"  ⇒ [[configuration.nix @dreyeck]] ⇒ [[elm-pages.service]]"
      },
      "date": 1694000181609
    },
    {
      "item": {
        "type": "factory",
        "id": "f3d253d522818084"
      },
      "id": "f3d253d522818084",
      "type": "add",
      "after": "c03999ca7e88c0d6",
      "date": 1694000196124
    },
    {
      "type": "edit",
      "id": "f3d253d522818084",
      "item": {
        "type": "pagefold",
        "id": "f3d253d522818084",
        "text": "~"
      },
      "date": 1694000203043
    },
    {
      "item": {
        "type": "factory",
        "id": "b6ebdd236939ab62"
      },
      "id": "b6ebdd236939ab62",
      "type": "add",
      "after": "f3d253d522818084",
      "date": 1694000215550
    },
    {
      "type": "edit",
      "id": "b6ebdd236939ab62",
      "item": {
        "type": "paragraph",
        "id": "b6ebdd236939ab62",
        "text": "NixOS: The Ultimate Dev Environment?"
      },
      "date": 1694000219069
    },
    {
      "type": "edit",
      "id": "b6ebdd236939ab62",
      "item": {
        "type": "paragraph",
        "id": "b6ebdd236939ab62",
        "text": "⇒ [[NixOS]]: The Ultimate Dev Environment? [https://myme.no/posts/2022-01-16-nixos-the-ultimate-dev-environment.html#javascript-frontend page]"
      },
      "date": 1694000240012
    },
    {
      "type": "edit",
      "id": "b6ebdd236939ab62",
      "item": {
        "type": "paragraph",
        "id": "b6ebdd236939ab62",
        "text": "⇒ [[NixOS]]: The Ultimate Dev Environment? [https://myme.no/posts/2022-01-16-nixos-the-ultimate-dev-environment.html page]"
      },
      "date": 1694000271737
    },
    {
      "type": "edit",
      "id": "b6ebdd236939ab62",
      "item": {
        "type": "paragraph",
        "id": "b6ebdd236939ab62",
        "text": "⇒ [[NixOS]]: The Ultimate Dev Environment? [https://myme.no/posts/2022-01-16-nixos-the-ultimate-dev-environment.html page], [https://github.com/tweag/rfcs/blob/flakes/rfcs/0049-flakes.md#motivation page]"
      },
      "date": 1694000375126
    },
    {
      "type": "edit",
      "id": "b6ebdd236939ab62",
      "item": {
        "type": "paragraph",
        "id": "b6ebdd236939ab62",
        "text": "⇒ [[NixOS]]: The Ultimate Dev Environment? [https://myme.no/posts/2022-01-16-nixos-the-ultimate-dev-environment.html page], serious shortcomings in Nix[https://github.com/tweag/rfcs/blob/flakes/rfcs/0049-flakes.md#motivation page]"
      },
      "date": 1694000397317
    },
    {
      "type": "edit",
      "id": "b6ebdd236939ab62",
      "item": {
        "type": "paragraph",
        "id": "b6ebdd236939ab62",
        "text": "⇒ [[NixOS]]: The Ultimate Dev Environment? [https://myme.no/posts/2022-01-16-nixos-the-ultimate-dev-environment.html page], serious shortcomings in Nix [https://github.com/tweag/rfcs/blob/flakes/rfcs/0049-flakes.md#motivation page]"
      },
      "date": 1694000403547
    },
    {
      "type": "edit",
      "id": "b6ebdd236939ab62",
      "item": {
        "type": "paragraph",
        "id": "b6ebdd236939ab62",
        "text": "⇒ [[NixOS]]: The Ultimate Dev Environment? [https://myme.no/posts/2022-01-16-nixos-the-ultimate-dev-environment.html page], shortcomings in Nix [https://github.com/tweag/rfcs/blob/flakes/rfcs/0049-flakes.md#motivation page]"
      },
      "date": 1694000428092
    },
    {
      "type": "edit",
      "id": "b6ebdd236939ab62",
      "item": {
        "type": "paragraph",
        "id": "b6ebdd236939ab62",
        "text": "⇒ [[NixOS]]: The Ultimate Dev Environment? [https://myme.no/posts/2022-01-16-nixos-the-ultimate-dev-environment.html page] ([[Martin Myrseth]]), shortcomings in Nix [https://github.com/tweag/rfcs/blob/flakes/rfcs/0049-flakes.md#motivation page]"
      },
      "date": 1694000464161
    },
    {
      "type": "edit",
      "id": "b6ebdd236939ab62",
      "item": {
        "type": "paragraph",
        "id": "b6ebdd236939ab62",
        "text": "⇒ [[NixOS]]: The Ultimate Dev Environment? ([[Martin Myrseth]]) [https://myme.no/posts/2022-01-16-nixos-the-ultimate-dev-environment.html page], shortcomings in Nix [https://github.com/tweag/rfcs/blob/flakes/rfcs/0049-flakes.md#motivation page]"
      },
      "date": 1694000492197
    },
    {
      "type": "edit",
      "id": "b6ebdd236939ab62",
      "item": {
        "type": "paragraph",
        "id": "b6ebdd236939ab62",
        "text": "⇒ [[NixOS]]: The Ultimate Dev Environment? by [[Martin Myrseth]] [https://myme.no/posts/2022-01-16-nixos-the-ultimate-dev-environment.html page], shortcomings in Nix [https://github.com/tweag/rfcs/blob/flakes/rfcs/0049-flakes.md#motivation page]"
      },
      "date": 1694000506405
    },
    {
      "type": "edit",
      "id": "90ecc08458ac00e4",
      "item": {
        "type": "paragraph",
        "id": "90ecc08458ac00e4",
        "text": "How to configure Systemd service unit to start Node app with \"npm start\" instead of \"app.js\"  ⇒ [[configuration.nix @dreyeck]] ⇒ [[elm-pages.service]] ⇒ [[wiki.nix @dreyeck.ch]]"
      },
      "date": 1694001418183
    },
    {
      "item": {
        "type": "factory",
        "id": "709cbda72f6ef0e9"
      },
      "id": "709cbda72f6ef0e9",
      "type": "add",
      "after": "b6ebdd236939ab62",
      "date": 1694007524917
    },
    {
      "type": "edit",
      "id": "709cbda72f6ef0e9",
      "item": {
        "type": "paragraph",
        "id": "709cbda72f6ef0e9",
        "text": "⇒ [[Public Liquidity Backstop]]"
      },
      "date": 1694007536785
    },
    {
      "item": {
        "type": "factory",
        "id": "6e62a3dded7c23d3"
      },
      "id": "6e62a3dded7c23d3",
      "type": "add",
      "after": "709cbda72f6ef0e9",
      "date": 1694007847110
    },
    {
      "type": "edit",
      "id": "6e62a3dded7c23d3",
      "item": {
        "type": "pagefold",
        "id": "6e62a3dded7c23d3",
        "text": "~"
      },
      "date": 1694007850028
    },
    {
      "item": {
        "type": "factory",
        "id": "35f2957d38e411eb"
      },
      "id": "35f2957d38e411eb",
      "type": "add",
      "after": "6e62a3dded7c23d3",
      "date": 1694007851762
    },
    {
      "type": "edit",
      "id": "35f2957d38e411eb",
      "item": {
        "type": "paragraph",
        "id": "35f2957d38e411eb",
        "text": "Open-Source-Entwicklungstool für AIoT auf ESP-Basis "
      },
      "date": 1694007854047
    },
    {
      "type": "edit",
      "id": "35f2957d38e411eb",
      "item": {
        "type": "paragraph",
        "id": "35f2957d38e411eb",
        "text": "Open-Source-Entwicklungstool für AIoT auf ESP-Basis [https://www.heise.de/news/Open-Source-Entwicklungstool-fuer-AIoT-auf-ESP-Basis-9296763.html?wt_mc=rss.red.make.beitrag.atom.beitrag.beitrag page] "
      },
      "date": 1694007952278
    },
    {
      "type": "edit",
      "id": "35f2957d38e411eb",
      "item": {
        "type": "paragraph",
        "id": "35f2957d38e411eb",
        "text": "Open-Source-Entwicklungstool für AIoT auf ESP-Basis [https://www.heise.de/news/Open-Source-Entwicklungstool-fuer-AIoT-auf-ESP-Basis-9296763.html?wt_mc=rss.red.make.beitrag.atom.beitrag.beitrag page]"
      },
      "date": 1694008055248
    },
    {
      "type": "add",
      "id": "af56e5ae3c0cfaa2",
      "item": {
        "type": "paragraph",
        "id": "af56e5ae3c0cfaa2",
        "text": "Picturing Finite Relations as Graphs"
      },
      "after": "35f2957d38e411eb",
      "date": 1694008057054
    },
    {
      "type": "edit",
      "id": "af56e5ae3c0cfaa2",
      "item": {
        "type": "paragraph",
        "id": "af56e5ae3c0cfaa2",
        "text": "Picturing Finite Relations as Graphs [https://iagoleal.com/posts/finite-relations-graph/ page]"
      },
      "date": 1694008066024
    },
    {
      "type": "edit",
      "id": "af56e5ae3c0cfaa2",
      "item": {
        "type": "paragraph",
        "id": "af56e5ae3c0cfaa2",
        "text": "⇒ [[Iago Leal de Freitas]], Picturing Finite Relations as Graphs [https://iagoleal.com/posts/finite-relations-graph/ page]"
      },
      "date": 1694008212565
    },
    {
      "type": "add",
      "id": "615c473b954fe2de",
      "item": {
        "type": "paragraph",
        "id": "615c473b954fe2de",
        "text": "[[Functions Are Containers]]"
      },
      "after": "af56e5ae3c0cfaa2",
      "date": 1694008295347
    },
    {
      "item": {
        "type": "factory",
        "id": "a3b3ab30fc1fa65e"
      },
      "id": "a3b3ab30fc1fa65e",
      "type": "add",
      "after": "615c473b954fe2de",
      "date": 1694008828377
    },
    {
      "type": "edit",
      "id": "a3b3ab30fc1fa65e",
      "item": {
        "type": "paragraph",
        "id": "a3b3ab30fc1fa65e",
        "text": "\nGENTILE, Ann C., DOYLE, Wendy SK and ULMER, Craig D., 2008. FCLib: The Feature Characterization Library. Sandia National Lab.(SNL-NM), Albuquerque, NM (United States); Sandia …. \n"
      },
      "date": 1694008830293
    },
    {
      "type": "edit",
      "id": "a3b3ab30fc1fa65e",
      "item": {
        "type": "paragraph",
        "id": "a3b3ab30fc1fa65e",
        "text": "GENTILE, Ann C., DOYLE, Wendy SK and ULMER, Craig D., 2008. FCLib: The Feature Characterization Library. Sandia National Lab.(SNL-NM), Albuquerque, NM (United States); Sandia …."
      },
      "date": 1694008852697
    },
    {
      "type": "add",
      "id": "aeee65dc6b344da0",
      "item": {
        "type": "paragraph",
        "id": "aeee65dc6b344da0",
        "text": "Figure 2: An item before deformation. Note that the green plate is flush with the read container. (p. "
      },
      "after": "a3b3ab30fc1fa65e",
      "date": 1694008856854
    },
    {
      "type": "edit",
      "id": "aeee65dc6b344da0",
      "item": {
        "type": "paragraph",
        "id": "aeee65dc6b344da0",
        "text": "Figure 2: An item before deformation. Note that the green plate is flush with the read container. (p. 29)"
      },
      "date": 1694008869039
    },
    {
      "type": "edit",
      "id": "aeee65dc6b344da0",
      "item": {
        "type": "paragraph",
        "id": "aeee65dc6b344da0",
        "text": "Figure 2: An item before [[Deformation]]. Note that the green plate is flush with the read container. (p. 29)"
      },
      "date": 1694008884045
    },
    {
      "id": "ceb601562090be24",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "ceb601562090be24",
        "text": "⇒ [[Iago Leal de Freitas]], simulations of the dynamics of self-deforming bodies and some models related to astronomy. [https://iagoleal.com/about/ page]",
        "alias": "af56e5ae3c0cfaa2"
      },
      "after": "aeee65dc6b344da0",
      "attribution": {
        "page": "Deformation"
      },
      "date": 1694009200513
    },
    {
      "item": {
        "type": "factory",
        "id": "fe8683f5ee79db42"
      },
      "id": "fe8683f5ee79db42",
      "type": "add",
      "after": "ceb601562090be24",
      "date": 1694009375766
    },
    {
      "type": "edit",
      "id": "fe8683f5ee79db42",
      "item": {
        "type": "paragraph",
        "id": "fe8683f5ee79db42",
        "text": "The next #Hackergarten in #Basel has been scheduled: September 20th! Join us, all details at "
      },
      "date": 1694009378816
    },
    {
      "type": "edit",
      "id": "fe8683f5ee79db42",
      "item": {
        "type": "paragraph",
        "id": "fe8683f5ee79db42",
        "text": "The next #Hackergarten in #Basel has been scheduled: September 20th! Join us, all details at … [https://jit.social/@madmas/111017255853747673 post]"
      },
      "date": 1694009394411
    },
    {
      "item": {
        "type": "factory",
        "id": "9d43128ad4df0d42"
      },
      "id": "9d43128ad4df0d42",
      "type": "add",
      "after": "fe8683f5ee79db42",
      "date": 1694010239666
    },
    {
      "type": "edit",
      "id": "9d43128ad4df0d42",
      "item": {
        "type": "paragraph",
        "id": "9d43128ad4df0d42",
        "text": "How to Recalculate a Spreadsheet"
      },
      "date": 1694010243221
    },
    {
      "type": "edit",
      "id": "9d43128ad4df0d42",
      "item": {
        "type": "paragraph",
        "id": "9d43128ad4df0d42",
        "text": "How to Recalculate a Spreadsheet [https://lord.io/spreadsheets/ page]"
      },
      "date": 1694010251240
    },
    {
      "type": "edit",
      "id": "9d43128ad4df0d42",
      "item": {
        "type": "paragraph",
        "id": "9d43128ad4df0d42",
        "text": "How to Recalculate a [[Spreadsheet]] [https://lord.io/spreadsheets/ page]"
      },
      "date": 1694010267359
    },
    {
      "type": "edit",
      "id": "448a859433bc861b",
      "item": {
        "type": "paragraph",
        "id": "448a859433bc861b",
        "text": "⇐ [[Wiki Module]] ⇒ [[Render Story]] ⇒ [[Trail Climbing]] ⇒[[Functions Are Containers]]"
      },
      "date": 1694021233740
    },
    {
      "type": "edit",
      "id": "448a859433bc861b",
      "item": {
        "type": "paragraph",
        "id": "448a859433bc861b",
        "text": "⇐ [[Wiki Module]] ⇒ [[Render Story]] ⇒ [[Trail Climbing]] ⇒ [[Functions Are Containers]]"
      },
      "date": 1694021237047
    },
    {
      "item": {
        "type": "factory",
        "id": "2aa56c3c0a92e13b"
      },
      "id": "2aa56c3c0a92e13b",
      "type": "add",
      "after": "9d43128ad4df0d42",
      "date": 1694021757840
    },
    {
      "type": "edit",
      "id": "2aa56c3c0a92e13b",
      "item": {
        "type": "paragraph",
        "id": "2aa56c3c0a92e13b",
        "text": "Invariant Lifetimes as Static, Unique Tokens"
      },
      "date": 1694021762232
    },
    {
      "type": "edit",
      "id": "2aa56c3c0a92e13b",
      "item": {
        "type": "paragraph",
        "id": "2aa56c3c0a92e13b",
        "text": "Invariant Lifetimes as Static, Unique Tokens [https://lord.io/lifetimes-as-tokens/ page]"
      },
      "date": 1694021773802
    },
    {
      "id": "9d43128ad4df0d42",
      "type": "move",
      "order": [
        "448a859433bc861b",
        "d61d994bbaeb36a4",
        "b7e235132ef58e4d",
        "90ecc08458ac00e4",
        "59beda0aa2463411",
        "f0cbaf616f3e5ee9",
        "e85e677c1e853e56",
        "49ad6afe55cbd31f",
        "4309af65b82e86d0",
        "1f3ab14e4ee1d302",
        "4e6e59cf2d478375",
        "527e6186721bb1ad",
        "7eb8ed9355f9b3d2",
        "ffeb296afa5585f5",
        "dc49c2839a81588b",
        "6daedabb93e95fbf",
        "6d759c19ce0ae0db",
        "c5bca6dc41ef3a13",
        "7e61957d30e9372b",
        "727f4c5579340787",
        "0e9cacfe1d4f2f54",
        "868e084c4dc75fed",
        "d75612daf44cf77a",
        "6e0abe67f29059b1",
        "754047d1de43624f",
        "4df29b1c29e293f1",
        "55e5eec4b63057b5",
        "d853d64cd73426fa",
        "fc5ff114576a6ac4",
        "86cadda16e9a0382",
        "e8811b9a9ef830cf",
        "04d647fcb54a650b",
        "43bbd34c80095cb9",
        "864878e57b87f907",
        "6cf3ae1d923ceb4b",
        "4d3df0d9f22c8814",
        "57bd339b7a114c84",
        "f72782ce4c543a6f",
        "3ce2989aaa8c75e9",
        "e85d7ef3fe29a60a",
        "2b5e1bf04351432e",
        "8019e3e633d62478",
        "39434639a6755c60",
        "637d05d05fe7580f",
        "756506d7a34b1b2b",
        "85995de570e2a8ae",
        "070f4161970b2ce4",
        "7752dfa0b9ea56c8",
        "522f3b9866b3e251",
        "b94a155e2506f221",
        "4ea74e73a8e53fc6",
        "6b987719aaed458c",
        "881c387ef0a65f6e",
        "27e87d54cc263c2b",
        "4ceaa6b8abcd87f6",
        "356958db25e18ab9",
        "7c45151a94b8b9eb",
        "4ca44add29038f81",
        "02bc174da2924ffc",
        "41300646478a5d59",
        "c03999ca7e88c0d6",
        "f3d253d522818084",
        "b6ebdd236939ab62",
        "709cbda72f6ef0e9",
        "6e62a3dded7c23d3",
        "35f2957d38e411eb",
        "af56e5ae3c0cfaa2",
        "615c473b954fe2de",
        "a3b3ab30fc1fa65e",
        "aeee65dc6b344da0",
        "ceb601562090be24",
        "fe8683f5ee79db42",
        "2aa56c3c0a92e13b",
        "9d43128ad4df0d42"
      ],
      "date": 1694021893451
    },
    {
      "type": "add",
      "id": "5d7242d5541f94a4",
      "item": {
        "type": "paragraph",
        "id": "5d7242d5541f94a4",
        "text": "anchors [https://github.com/lord/anchors github]"
      },
      "after": "2aa56c3c0a92e13b",
      "date": 1694021926063
    },
    {
      "type": "add",
      "id": "65beb8f66865d32f",
      "item": {
        "type": "paragraph",
        "id": "65beb8f66865d32f",
        "text": "[]"
      },
      "after": "2aa56c3c0a92e13b",
      "date": 1694021946424
    },
    {
      "type": "edit",
      "id": "65beb8f66865d32f",
      "item": {
        "type": "paragraph",
        "id": "65beb8f66865d32f",
        "text": "arena-graph [https://github.com/lord/arena-graph github]"
      },
      "date": 1694021961652
    },
    {
      "type": "edit",
      "id": "65beb8f66865d32f",
      "item": {
        "type": "paragraph",
        "id": "65beb8f66865d32f",
        "text": "Fast, Arena-Allocated Graphs [https://github.com/lord/arena-graph github]"
      },
      "date": 1694021992390
    },
    {
      "type": "add",
      "id": "d6759357e58ea173",
      "item": {
        "type": "paragraph",
        "id": "d6759357e58ea173",
        "text": "Announcing native npm support on Deno Deploy"
      },
      "after": "35f2957d38e411eb",
      "date": 1694023966641
    },
    {
      "item": {
        "type": "factory",
        "id": "7512d884dd08750b"
      },
      "id": "7512d884dd08750b",
      "type": "add",
      "after": "9d43128ad4df0d42",
      "date": 1694023969350
    },
    {
      "id": "7512d884dd08750b",
      "type": "move",
      "order": [
        "448a859433bc861b",
        "d61d994bbaeb36a4",
        "b7e235132ef58e4d",
        "90ecc08458ac00e4",
        "59beda0aa2463411",
        "f0cbaf616f3e5ee9",
        "e85e677c1e853e56",
        "49ad6afe55cbd31f",
        "4309af65b82e86d0",
        "1f3ab14e4ee1d302",
        "4e6e59cf2d478375",
        "527e6186721bb1ad",
        "7eb8ed9355f9b3d2",
        "ffeb296afa5585f5",
        "dc49c2839a81588b",
        "6daedabb93e95fbf",
        "6d759c19ce0ae0db",
        "c5bca6dc41ef3a13",
        "7e61957d30e9372b",
        "727f4c5579340787",
        "0e9cacfe1d4f2f54",
        "868e084c4dc75fed",
        "d75612daf44cf77a",
        "6e0abe67f29059b1",
        "754047d1de43624f",
        "4df29b1c29e293f1",
        "55e5eec4b63057b5",
        "d853d64cd73426fa",
        "fc5ff114576a6ac4",
        "86cadda16e9a0382",
        "e8811b9a9ef830cf",
        "04d647fcb54a650b",
        "43bbd34c80095cb9",
        "864878e57b87f907",
        "6cf3ae1d923ceb4b",
        "4d3df0d9f22c8814",
        "57bd339b7a114c84",
        "f72782ce4c543a6f",
        "3ce2989aaa8c75e9",
        "e85d7ef3fe29a60a",
        "2b5e1bf04351432e",
        "8019e3e633d62478",
        "39434639a6755c60",
        "637d05d05fe7580f",
        "756506d7a34b1b2b",
        "85995de570e2a8ae",
        "070f4161970b2ce4",
        "7752dfa0b9ea56c8",
        "522f3b9866b3e251",
        "b94a155e2506f221",
        "4ea74e73a8e53fc6",
        "6b987719aaed458c",
        "881c387ef0a65f6e",
        "27e87d54cc263c2b",
        "4ceaa6b8abcd87f6",
        "356958db25e18ab9",
        "7c45151a94b8b9eb",
        "4ca44add29038f81",
        "02bc174da2924ffc",
        "41300646478a5d59",
        "c03999ca7e88c0d6",
        "f3d253d522818084",
        "b6ebdd236939ab62",
        "709cbda72f6ef0e9",
        "6e62a3dded7c23d3",
        "35f2957d38e411eb",
        "d6759357e58ea173",
        "7512d884dd08750b",
        "af56e5ae3c0cfaa2",
        "615c473b954fe2de",
        "a3b3ab30fc1fa65e",
        "aeee65dc6b344da0",
        "ceb601562090be24",
        "fe8683f5ee79db42",
        "2aa56c3c0a92e13b",
        "65beb8f66865d32f",
        "5d7242d5541f94a4",
        "9d43128ad4df0d42"
      ],
      "date": 1694023973931
    },
    {
      "type": "edit",
      "id": "7512d884dd08750b",
      "item": {
        "type": "pagefold",
        "id": "7512d884dd08750b",
        "text": "~"
      },
      "date": 1694023977912
    },
    {
      "type": "edit",
      "id": "d6759357e58ea173",
      "item": {
        "type": "paragraph",
        "id": "d6759357e58ea173",
        "text": "Announcing native npm support on Deno Deploy [https://deno.com/blog/npm-on-deno-deploy page]"
      },
      "date": 1694023997700
    },
    {
      "type": "edit",
      "id": "448a859433bc861b",
      "item": {
        "type": "paragraph",
        "id": "448a859433bc861b",
        "text": "⇐ [[Wiki Module]] ⇒ [[Render Story]] ⇒ [[Trail Climbing]] ⇒ [[Functions Are Containers]] ⇒ [[Functions That Do Not Forget]]"
      },
      "date": 1694028639574
    },
    {
      "type": "edit",
      "id": "448a859433bc861b",
      "item": {
        "type": "paragraph",
        "id": "448a859433bc861b",
        "text": "⇐ [[Wiki Module]] ⇒ [[Render Story]] ⇒ [[Trail Climbing]] ⇒ [[Functions Are Containers]] ⇐  [[Functions That Do Not Forget]]"
      },
      "date": 1694028687508
    },
    {
      "type": "edit",
      "id": "448a859433bc861b",
      "item": {
        "type": "paragraph",
        "id": "448a859433bc861b",
        "text": "⇐ [[Wiki Module]] ⇒ [[Render Story]] ⇒ [[Trail Climbing]] ⇒ [[Functions Are Containers]] ⇐  [[Functions That Do Not Forget]] ⇒ [[Sequence]]"
      },
      "date": 1694035797997
    }
  ]
}