{
  "title": "2023-10-02",
  "story": [
    {
      "type": "paragraph",
      "id": "1556ddc696991277",
      "text": "⇒ [[Parse Strings]] ⇒ [[Top Down Operator Precedence]] ⇒ [[Operator Grammar]]"
    },
    {
      "type": "paragraph",
      "id": "316c3e89c2ee3131",
      "text": "Accordingly we require that all arguments be de­limited by at least one token; such a grammar Floyd [1963] calls an [[Operator Grammar]]. (Pratt, [[Top Down Operator Precedence]], p. 46.)"
    },
    {
      "type": "paragraph",
      "id": "19c6122fb0e90655",
      "text": "The parser's operation may perhaps be better understood graphically. Consider the example 'if 3*a + b!↑-3 = 0 then print a + (b-1) else rewind'. We may exhibit the tree recovered by the parser from this expression as in the diagram below. The tokens encountered during one incarnation of the parser are enclosed in a dotted circle, and are connected via down-and-left links, while calls on the parser are connected to their caller by down-and-right links. Delimiters label the links of the expression they precede, if any. The no-op '(' is included, although it is not really a semantic object."
    },
    {
      "type": "image",
      "id": "27e792d83e5d35ba",
      "text": "Exhibit the [[Tree]] [[recover]]ed by the [[Parser]] (Pratt, [[Top Down Operator Precedence]], p. 48.)",
      "size": "wide",
      "width": 430,
      "height": 246,
      "url": "/assets/plugins/image/2bda5af78cb9eae5b4e3e88068d23059.jpg"
    },
    {
      "type": "paragraph",
      "id": "124dd890c33c085a",
      "text": "The major difference between the approach described here and the usual operator precedence scheme is that we have modified the Flovd operator precedence parser to work top-down, implementing the stack by means of recursion, a technique known as recursive descent."
    },
    {
      "type": "paragraph",
      "id": "fe47a487da6f5504",
      "text": "⇒ [[Roman R. Redziejowski]] "
    },
    {
      "type": "paragraph",
      "id": "9203912a43ea9e00",
      "text": "REDZIEJOWSKI, Roman R., 2007. Parsing Expression Grammar as a Primitive Recursive-Descent Parser with Backtracking. Fundamenta Informaticae. 1 January 2007. Vol. 79, no. 3–4, p. 513–524. Two recent developments in the field of formal languages are Parsing Expression Grammar ([[PEG]]) and packrat parsing. The PEG formalism is similar to BNF, but defines syntax in terms of recognizing strings, rather than constructing them. It is, in fact, precise specification of a backtracking recursive-descent parser. Packrat parsing is a general method to handle backtracking in recursive-descent parsers. It ensures linear working time, at a huge memory cost. This paper reports an experiment that consisted of defining the syntax of Java 1.5 in PEG formalism, and literally transcribing the PEG definitions into parsing procedures (accidentally, also in Java). The resulting primitive parser shows an acceptable behavior, indicating that packrat parsing might be an overkill for practical languages. The exercise with defining the Java syntax suggests that more work is needed on PEG as a language specification tool."
    },
    {
      "type": "paragraph",
      "id": "6be7c3dbe0e20f2d",
      "text": "The structure of a recursive-descent parser follows closely a grammar defined in Backus-Naur Form (BNF) or Extended BNF (EBNF). Each procedure is associated with one symbol of the grammar and attempts to recognize an input string corresponding to that symbol. It either reports ”success” and consumes the string, or reports ”failure”."
    },
    {
      "type": "paragraph",
      "id": "324fed3d7e173e6b",
      "text": "[7] Ford, B. Parsing expression grammars: A recognition-based syntactic foundation. In Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2004 (Venice, Italy, 14–16 January 2004), N. D. Jones and X. Leroy, Eds., ACM, pp. 111–122."
    },
    {
      "type": "paragraph",
      "id": "f6ae85c1225c1b52",
      "text": "⇒ [[elm-peg]]: Parsing expression grammar (PEG) in [[Elm]]. [https://github.com/microelm/elm-peg github]"
    },
    {
      "type": "markdown",
      "id": "7315cc4d8abf9658",
      "text": "Replace grammarString with a PEG grammar for parsing Wiki Style Links (see above). ⇐ [[elm-peg]]\n"
    },
    {
      "type": "paragraph",
      "id": "8ff0697d5f38d843",
      "text": "Support wiki-style internal page links\n#3606 [https://github.com/gohugoio/hugo/issues/3606 github], [https://github.com/gollum/gollum/wiki#linking-internal-pages github]"
    },
    {
      "type": "paragraph",
      "id": "e8a50218feea0b7d",
      "text": "Adding Actions to a PEG Grammar [https://medium.com/@gvanrossum_83706/adding-actions-to-a-peg-grammar-d5e00fa1092f post] by [[Guido van Rossum]]"
    },
    {
      "type": "paragraph",
      "id": "677a849584d86a4b",
      "text": "define a PEG grammar for a Wiki Style Link, e.g., [[Federated Wiki]]."
    },
    {
      "type": "markdown",
      "id": "bf7d5cfdf376d1cc",
      "text": "Certainly! Below is a PEG grammar for parsing Wiki Style Links:"
    },
    {
      "type": "code",
      "id": "19c89b11f842da94",
      "text": "wikiLink       <- openBracket openBracket linkText closeBracket closeBracket\nopenBracket    <- '['\ncloseBracket   <- ']'\nlinkText       <- ~['[', ']', '\\n']+\n"
    },
    {
      "type": "markdown",
      "id": "75a8adfba5fb1dd6",
      "text": "Explanation:\n\n- `wikiLink` is the main rule that defines a Wiki Style Link."
    },
    {
      "type": "markdown",
      "id": "4fcb6b8fe360a62d",
      "text": "- `openBracket` matches the opening double square brackets `[[`."
    },
    {
      "type": "markdown",
      "id": "adfd285abc78b536",
      "text": "- `closeBracket` matches the closing double square brackets `]]`."
    },
    {
      "type": "markdown",
      "id": "bbe0c9a70893eeb3",
      "text": "- `linkText` is the text inside the double square brackets, which can include any characters except `[`, `]`, and newline.\n\nThis grammar will successfully parse Wiki Style Links in the format `[[Link Text]]`. Keep in mind that this is a basic grammar and may need to be extended or modified depending on the specific requirements of your application. (ChatGPT September 25 Version)"
    },
    {
      "type": "paragraph",
      "id": "cea804f4e576ebf3",
      "text": "⇒ [[Define a PEG Grammar]] ⇒ [[PEG Syntax and Semantics]] [https://nim-lang.org/docs/pegs.html page], PEG vs regular expression [https://nim-lang.org/docs/pegs.html#peg-syntax-and-semantics-peg-vs-regular-expression page]"
    },
    {
      "type": "markdown",
      "id": "fe02c7f35a0684ff",
      "text": "ChatGPT — Release Notes [https://help.openai.com/en/articles/6825453-chatgpt-release-notes page]"
    },
    {
      "type": "markdown",
      "id": "42c2e93bfaff6310",
      "text": "> Browse is rolling back out to Plus users (September 27, 2023)\n\nBrowse is rolling out to all Plus users. ChatGPT can now browse the internet to provide you with current and authoritative information, complete with direct links to sources. It is no longer limited to data before September 2021. "
    },
    {
      "type": "pagefold",
      "id": "bcdce6de8cc6eadf",
      "text": "elm recursive parser"
    },
    {
      "type": "paragraph",
      "id": "223b8d7567779211",
      "text": "Propositions Parser using recursion in Elm [https://stackoverflow.com/questions/71717840/propositions-parser-using-recursion-in-elm stackoverflow]"
    },
    {
      "type": "markdown",
      "id": "5869238fb3a87ae7",
      "text": "> You should now be able to see that the structure of the parser mirrors the type it parses. We now have a propositionParser with a oneOf where each case corresponds to a case from the Proposition type, and with each individual case parser using propositionParser where the type says it needs a Proposition. Knowing this, you should hopefully be able to create a parser for any custom type by creating small parsers for each individual piece, and then combine them by simply mimicking the structure of the type."
    },
    {
      "type": "paragraph",
      "id": "3096509bfbc10005",
      "text": "How do I make this parser recursive? [https://discourse.elm-lang.org/t/how-do-i-make-this-parser-recursive/5017 page], [https://ellie-app.com/7MF2kDtLF83a1 ellie]"
    },
    {
      "type": "paragraph",
      "id": "265f16c668147f89",
      "text": "Design and Implementation Considerations [https://package.elm-lang.org/packages/dmy/elm-pratt-parser/2.0.0/ page], parenthesizedExpression"
    },
    {
      "type": "paragraph",
      "id": "900360f4f71df140",
      "text": "How do I parenthesize an expression? [https://stackoverflow.com/questions/548613/how-do-i-parenthesize-an-expression stackoverflow]"
    },
    {
      "type": "markdown",
      "id": "94d4df96c8ae1882",
      "text": "> You're going to need a parser of some sort that understands operator precendence. The usual version for C is Lexx/Yacc or flex/bison, and the easiest way to do it is construct a parse tree. Once you've done that, just walk the parse tree in the \"preorder\" order and emit [[Parens]] as you enter and leave a node."
    },
    {
      "type": "paragraph",
      "id": "e10cfa4bc6dc34f4",
      "text": "If you're trying to parse an expression enclosed in parentheses, you might want to do something like this:"
    },
    {
      "type": "code",
      "id": "dc1bd9bb8d414e6c",
      "text": "parenParser : Parser a -> Parser a\nparenParser innerParser =\n    chompIf (\\c -> c == '(')\n        |. innerParser\n        |. chompIf (\\c -> c == ')')\n"
    },
    {
      "type": "paragraph",
      "id": "273ac3e23c52bfcc",
      "text": "This function takes an inner parser as an argument, which is used to parse the content inside the parentheses. It first tries to parse an opening parenthesis, then applies the inner parser, and finally tries to parse a closing parenthesis.\n\nFor example, if you have a parser myParser : Parser Int, you can use parenParser myParser to parse an expression enclosed in parentheses. The result will be of type Parser Int.\n\nI (ChatGPT September 25 Version) hope this helps! Let me know if you have any further questions."
    },
    {
      "type": "paragraph",
      "id": "f0e07f9dbc05bbb3",
      "text": "Your parenParser function reminds me of:"
    },
    {
      "type": "code",
      "id": "ca2e834d7dc99b0a",
      "text": "parenthesizedExpression : Pratt.Config Float -> Parser Float\nparenthesizedExpression config =\n    Parser.succeed identity\n        |. symbol \"(\"\n        |= Pratt.subExpression 0 config\n        |. symbol \")\""
    },
    {
      "type": "paragraph",
      "id": "197a8b9483ea054e",
      "text": "Yes, the `parenthesizedExpression` function you provided is an example of a parser for parsing expressions enclosed in parentheses using the Pratt parsing technique. \n\nIn this case, it uses the `Parser.succeed` function to create a parser that always succeeds and returns its input unchanged (using the `identity` function). Then, it combines this parser with parsers for opening and closing parentheses, as well as an inner expression parser (created using `Pratt.subExpression` with a precedence level of 0).\n\nThis allows the parser to recognize and parse expressions like `(3 + 4)`.\n\nThe Pratt parsing technique is a powerful approach for parsing expressions with operator precedence, and it's commonly used in parser combinator libraries like elm/parser. Thank you for sharing this example! If you have any further questions or if there's anything else I (ChatGPT September 25 Version) can help you with, feel free to let me know."
    },
    {
      "type": "paragraph",
      "id": "4bfba3b5a8f78e4e",
      "text": "Cf. [https://github.com/dreyeck/blog/blob/f4e725bc5f74f7ed1e9500f4114b6968d4cd3a57/elm-pages-starter-express/src/Wiki.elm#L403-L414 code]"
    },
    {
      "type": "code",
      "id": "0291a5c4e544c936",
      "text": "link : Parser String\nlink =\n    {- Links are enclosed in doubled square brackets\n\n       Ref: Wikilinks (internal links) https://en.wikipedia.org/wiki/Help:Link\n       and http://ward.bay.wiki.org/view/internal-link\n    -}\n    succeed identity\n        |. symbol \"[[\"\n        |= (getChompedString <| chompWhile (\\c -> c /= ']'))\n        |. symbol \"]]\"\n"
    },
    {
      "type": "paragraph",
      "id": "9fc94877330cc915",
      "text": "and compare that with the calculator example [https://github.com/dmy/elm-pratt-parser/blob/34348b0334167b28d464aef24079a0d388c580f1/examples/Calc.elm#L41-L47 code]."
    },
    {
      "type": "pagefold",
      "id": "7e66863c702216b5",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "40031f2f7f1c9f42",
      "text": "After you start a comment, you have to\ndetect if there is another one inside it! And then you have to make sure all\nthe `{-` and `-}` match up properly! Saying `multiComment \"{-\" \"-}\" Nestable`\ndoes all that for you. [https://github.com/elm/parser/blob/02839df10e462d8423c91917271f4b6f8d2f284d/src/Parser.elm#L1246C37-L1249C23 code]"
    },
    {
      "type": "paragraph",
      "id": "9e60c425635d0287",
      "text": "Inconsistent internal parser state #53 [https://github.com/elm/parser/issues/53 github]"
    },
    {
      "type": "paragraph",
      "id": "8e666ee1f9dabafc",
      "text": "Parser.multiComment does not chomp comment terminator in NotNestable mode #2 [https://github.com/elm/parser/issues/2 github]"
    },
    {
      "type": "paragraph",
      "id": "910779249187aa37",
      "text": "Extensible markdown parser with custom rendering, in pure Elm. [https://github.com/dillonkearns/elm-markdown github], [https://package.elm-lang.org/packages/dillonkearns/elm-markdown/latest/ package]"
    },
    {
      "type": "paragraph",
      "id": "2d6119ab2b8d7cec",
      "text": "elm-sheet, schelme based spreadsheet. [https://github.com/bburdette/cellme github] by [[Ben Burdette]]"
    },
    {
      "type": "paragraph",
      "id": "abce4abd5900f327",
      "text": "⇒ [[Schelme]] [https://github.com/bburdette/schelme github] ⇒ [[Schelme Cells]]"
    },
    {
      "type": "paragraph",
      "id": "328579f02f943dc5",
      "text": "PRATT, Vaughan R., 1976. CGOL – an Alternative External Representation For LISP users Online. Working Paper. MIT Artificial Intelligence Laboratory. [Accessed 2 October 2023]. Available from: https://dspace.mit.edu/handle/1721.1/41951 Advantages of the standard external representation of LISP include its simple definition, its economical implementation and its convenient extensibility. These advantages have been gained by trading off syntactic variety for the rigidity of parenthesized prefix notation. This paper describes an approach to increasing the available notational variety in LISP without compromising the above advantages of the standard notation. A primary advantage of the availability of such variety is the extent to which documentation can be incorporated into the code itself, decreasing the chance of mismatches between cods and documentation. The approach differs from that of MLISP[superscript 4], which attempts to be a self-contained language rather than a notation available immediately on demand to the ordinary LISP user. A striking feature of a MACLISP implementation of this approach, the CGOL notation, is that any LISP user, at any time, without any prior preparation, and without significant compromise of storage or speed, can in mid-stream change to the CGOL notation merely by typing (CGOL) at the LISP he is presently using, even if he has already loaded and begun running his LISP program. Another striking feature is the possibility of notational transparency; a LISP user may ask LISP to read a file without needing to know the notation(s) used within that file.Accepted: 2008-08-25T19:38:26Z\n"
    },
    {
      "type": "paragraph",
      "id": "a6de2c30ce90b8c1",
      "text": "[…], indem die syntaktische Vielfalt gegen die Starrheit der geklammerten Präfix-Notation eingetauscht wurde."
    },
    {
      "type": "paragraph",
      "id": "1a00c490eeb864b0",
      "text": "⇒ [[elm-markdown]] ⇒ Markdown.Parser [https://package.elm-lang.org/packages/dillonkearns/elm-markdown/latest/Markdown-Parser page]"
    },
    {
      "type": "code",
      "id": "4e78b9a9c8693396",
      "text": "deadEndToString : DeadEnd String Problem -> String"
    },
    {
      "type": "paragraph",
      "id": "86a60fee8ac66a2a",
      "text": "Turn a parsing problem into the default String representation."
    },
    {
      "type": "paragraph",
      "id": "887afb1e5e396043",
      "text": "In elm-parser, why has \"deadEndToString\" not been implemented? [https://www.reddit.com/r/elm/comments/q7pcri/in_elmparser_why_has_deadendtostring_not_been/ reddit], [https://gist.github.com/harrysarson/234436a9f0517e14d0fd67fd63ba6619 gist]"
    },
    {
      "type": "paragraph",
      "id": "0bd963dcca97dd8a",
      "text": "Dead ends to string #16 [https://github.com/elm/parser/pull/16/files github]"
    },
    {
      "type": "paragraph",
      "id": "b54acf0ce94b7db5",
      "text": "Elm Result Pipeline [https://nicolas.perriault.net/code/2021/elm-result-pipeline/ post]"
    },
    {
      "type": "markdown",
      "id": "fa2a054502744288",
      "text": "> The absence of null and exceptions forces developers to state explicitely what should happen when expectations aren’t met, […]"
    },
    {
      "type": "paragraph",
      "id": "fbf48bd93298a0e7",
      "text": "(was geschehen soll, wenn die Erwartungen nicht erfüllt werden)"
    },
    {
      "type": "paragraph",
      "id": "0a9ec73026b36227",
      "text": "⇒ [[Result]] [https://package.elm-lang.org/packages/elm/core/latest/Result package] A Result is the result of a computation that may fail. This is a great way to manage errors in Elm."
    },
    {
      "type": "paragraph",
      "id": "46ec93b2da9d6dc1",
      "text": "Elm testing: how to check if a Result is an Err? [https://stackoverflow.com/questions/41413721/elm-testing-how-to-check-if-a-result-is-an-err stackoverflow]"
    },
    {
      "type": "pagefold",
      "id": "498a57e8ad988bed",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "38c63c59632027cb",
      "text": "DITA-OT 4.1.2 [https://www.dita-ot.org/4.1/release-notes/#v4.1.2 page]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2023-10-02",
        "story": []
      },
      "date": 1696225881557
    },
    {
      "item": {
        "type": "factory",
        "id": "b29069f8ed242205"
      },
      "id": "b29069f8ed242205",
      "type": "add",
      "date": 1696225883256
    },
    {
      "type": "remove",
      "id": "b29069f8ed242205",
      "date": 1696225886920
    },
    {
      "item": {
        "type": "factory",
        "id": "6443ab70fa88236d"
      },
      "id": "6443ab70fa88236d",
      "type": "add",
      "date": 1696226131854
    },
    {
      "type": "edit",
      "id": "6443ab70fa88236d",
      "item": {
        "type": "paragraph",
        "id": "6443ab70fa88236d",
        "text": "Given all of the above, the obvious way to parse strings (i.e. recover their trees) is, for each association problem, to associate to the left unless this yields semantic nonsense."
      },
      "date": 1696226133870
    },
    {
      "item": {
        "type": "factory",
        "id": "1556ddc696991277"
      },
      "id": "1556ddc696991277",
      "type": "add",
      "after": "6443ab70fa88236d",
      "date": 1696226153059
    },
    {
      "type": "edit",
      "id": "1556ddc696991277",
      "item": {
        "type": "paragraph",
        "id": "1556ddc696991277",
        "text": "⇒ [[Parse Strings]]"
      },
      "date": 1696226162691
    },
    {
      "id": "6443ab70fa88236d",
      "type": "remove",
      "removedTo": {
        "page": "Parse Strings"
      },
      "date": 1696226168938
    },
    {
      "type": "add",
      "id": "4d161fb789ea0a48",
      "item": {
        "type": "paragraph",
        "id": "4d161fb789ea0a48",
        "text": "Floyd, R.W. 1963. Syntactic Analysis and Operator Precedence. JACM 1_C[, 3, 316-333."
      },
      "after": "1556ddc696991277",
      "date": 1696228126913
    },
    {
      "type": "edit",
      "id": "4d161fb789ea0a48",
      "item": {
        "type": "paragraph",
        "id": "4d161fb789ea0a48",
        "text": "FLOYD, Robert W., 1963. Syntactic analysis and operator precedence. Journal of the ACM (JACM). 1963. Vol. 10, no. 3, p. 316–333. \n"
      },
      "date": 1696228392641
    },
    {
      "item": {
        "type": "factory",
        "id": "19c6122fb0e90655"
      },
      "id": "19c6122fb0e90655",
      "type": "add",
      "after": "4d161fb789ea0a48",
      "date": 1696228418634
    },
    {
      "type": "edit",
      "id": "19c6122fb0e90655",
      "item": {
        "type": "paragraph",
        "id": "19c6122fb0e90655",
        "text": "Three increasingly restricted types of formal grammar are phrase structure grammars, operator grammars and precedence grammars. Precedence grammars form models of mathematical and algorithmic languages which may Le analyzed mechanically by a simple procedure based on a matrix representation of a relation between character pairs."
      },
      "date": 1696228420175
    },
    {
      "type": "edit",
      "id": "19c6122fb0e90655",
      "item": {
        "type": "paragraph",
        "id": "19c6122fb0e90655",
        "text": "Three increasingly restricted types of formal grammar are phrase structure grammars, operator grammars and precedence grammars. Precedence grammars form models of mathematical and algorithmic languages which may be analyzed mechanically by a simple procedure based on a matrix representation of a relation between character pairs."
      },
      "date": 1696228457677
    },
    {
      "type": "edit",
      "id": "19c6122fb0e90655",
      "item": {
        "type": "paragraph",
        "id": "19c6122fb0e90655",
        "text": "Three increasingly restricted types of formal grammar are phrase structure grammars, operator grammars and precedence grammars. Precedence grammars form models of mathematical and algorithmic languages which may be analyzed mechanically by a simple procedure based on a matrix representation of a precedence relation between character pairs."
      },
      "date": 1696228493541
    },
    {
      "type": "add",
      "id": "316c3e89c2ee3131",
      "item": {
        "type": "paragraph",
        "id": "316c3e89c2ee3131",
        "text": "Accordingly we require that all arguments be de­ limited by at least one token;"
      },
      "after": "1556ddc696991277",
      "date": 1696228818266
    },
    {
      "type": "edit",
      "id": "316c3e89c2ee3131",
      "item": {
        "type": "paragraph",
        "id": "316c3e89c2ee3131",
        "text": "Accordingly we require that all arguments be de­ limited by at least one token; (Pratt, „Top down operator precedence“.)"
      },
      "date": 1696228839370
    },
    {
      "type": "edit",
      "id": "316c3e89c2ee3131",
      "item": {
        "type": "paragraph",
        "id": "316c3e89c2ee3131",
        "text": "Accordingly we require that all arguments be de­ limited by at least one token; such a grammar Floyd [1963] calls an operator grammar. (Pratt, „Top down operator precedence“.)"
      },
      "date": 1696228860091
    },
    {
      "type": "edit",
      "id": "1556ddc696991277",
      "item": {
        "type": "paragraph",
        "id": "1556ddc696991277",
        "text": "⇒ [[Parse Strings]] ⇒ [[Operator Grammar]]"
      },
      "date": 1696228929411
    },
    {
      "type": "edit",
      "id": "1556ddc696991277",
      "item": {
        "type": "paragraph",
        "id": "1556ddc696991277",
        "text": "⇒ [[Parse Strings]] ⇒ [[Top Down Operator Precedence]] ⇒ [[Operator Grammar]]"
      },
      "date": 1696229014804
    },
    {
      "id": "223b8d7567779211",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "223b8d7567779211",
        "text": "Propositions Parser using recursion in Elm [https://stackoverflow.com/questions/71717840/propositions-parser-using-recursion-in-elm stackoverflow]"
      },
      "after": "19c6122fb0e90655",
      "attribution": {
        "page": "Operator Grammar"
      },
      "date": 1696230740134
    },
    {
      "item": {
        "type": "factory",
        "id": "bcdce6de8cc6eadf"
      },
      "id": "bcdce6de8cc6eadf",
      "type": "add",
      "after": "223b8d7567779211",
      "date": 1696230805723
    },
    {
      "type": "edit",
      "id": "bcdce6de8cc6eadf",
      "item": {
        "type": "pagefold",
        "id": "bcdce6de8cc6eadf",
        "text": "elm recursive parser"
      },
      "date": 1696230808521
    },
    {
      "id": "bcdce6de8cc6eadf",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "4d161fb789ea0a48",
        "19c6122fb0e90655",
        "bcdce6de8cc6eadf",
        "223b8d7567779211"
      ],
      "date": 1696230810339
    },
    {
      "item": {
        "type": "factory",
        "id": "3096509bfbc10005"
      },
      "id": "3096509bfbc10005",
      "type": "add",
      "after": "223b8d7567779211",
      "date": 1696231573940
    },
    {
      "type": "edit",
      "id": "3096509bfbc10005",
      "item": {
        "type": "paragraph",
        "id": "3096509bfbc10005",
        "text": "How do I make this parser recursive? "
      },
      "date": 1696231581022
    },
    {
      "type": "edit",
      "id": "3096509bfbc10005",
      "item": {
        "type": "paragraph",
        "id": "3096509bfbc10005",
        "text": "How do I make this parser recursive? [https://discourse.elm-lang.org/t/how-do-i-make-this-parser-recursive/5017 page]"
      },
      "date": 1696231590758
    },
    {
      "type": "edit",
      "id": "3096509bfbc10005",
      "item": {
        "type": "paragraph",
        "id": "3096509bfbc10005",
        "text": "How do I make this parser recursive? [https://discourse.elm-lang.org/t/how-do-i-make-this-parser-recursive/5017 page], [https://ellie-app.com/7MF2kDtLF83a1 ellie]"
      },
      "date": 1696231604746
    },
    {
      "type": "edit",
      "id": "316c3e89c2ee3131",
      "item": {
        "type": "paragraph",
        "id": "316c3e89c2ee3131",
        "text": "Accordingly we require that all arguments be de­ limited by at least one token; such a grammar Floyd [1963] calls an [[Operator Grammar]]. (Pratt, „Top down operator precedence“.)"
      },
      "date": 1696231636476
    },
    {
      "item": {
        "type": "factory",
        "id": "265f16c668147f89"
      },
      "id": "265f16c668147f89",
      "type": "add",
      "after": "3096509bfbc10005",
      "date": 1696232672524
    },
    {
      "type": "edit",
      "id": "265f16c668147f89",
      "item": {
        "type": "paragraph",
        "id": "265f16c668147f89",
        "text": "[[Design and Implementation Considerations]]"
      },
      "date": 1696232680725
    },
    {
      "type": "edit",
      "id": "265f16c668147f89",
      "item": {
        "type": "paragraph",
        "id": "265f16c668147f89",
        "text": "Design and Implementation Considerations"
      },
      "date": 1696232702526
    },
    {
      "type": "edit",
      "id": "265f16c668147f89",
      "item": {
        "type": "paragraph",
        "id": "265f16c668147f89",
        "text": "Design and Implementation Considerations [https://package.elm-lang.org/packages/dmy/elm-pratt-parser/2.0.0/ page]"
      },
      "date": 1696232712902
    },
    {
      "type": "edit",
      "id": "265f16c668147f89",
      "item": {
        "type": "paragraph",
        "id": "265f16c668147f89",
        "text": "Design and Implementation Considerations [https://package.elm-lang.org/packages/dmy/elm-pratt-parser/2.0.0/ page], parenthesizedExpression"
      },
      "date": 1696232727252
    },
    {
      "item": {
        "type": "factory",
        "id": "900360f4f71df140"
      },
      "id": "900360f4f71df140",
      "type": "add",
      "after": "265f16c668147f89",
      "date": 1696232773996
    },
    {
      "type": "edit",
      "id": "900360f4f71df140",
      "item": {
        "type": "paragraph",
        "id": "900360f4f71df140",
        "text": "How do I parenthesize an expression?"
      },
      "date": 1696232776215
    },
    {
      "type": "edit",
      "id": "900360f4f71df140",
      "item": {
        "type": "paragraph",
        "id": "900360f4f71df140",
        "text": "How do I parenthesize an expression? [https://stackoverflow.com/questions/548613/how-do-i-parenthesize-an-expression stackoverflow]"
      },
      "date": 1696232791412
    },
    {
      "type": "add",
      "id": "94d4df96c8ae1882",
      "item": {
        "type": "paragraph",
        "id": "94d4df96c8ae1882",
        "text": "> You're going to need a parser of some sort that understands operator precendence. The usual version for C is Lexx/Yacc or flex/bison, and the easiest way to do it is construct a parse tree. Once you've done that, just walk the parse tree in the \"preorder\" order and emit parens as you enter and leave a node."
      },
      "after": "900360f4f71df140",
      "date": 1696232819027
    },
    {
      "type": "edit",
      "id": "94d4df96c8ae1882",
      "item": {
        "type": "markdown",
        "id": "94d4df96c8ae1882",
        "text": "> You're going to need a parser of some sort that understands operator precendence. The usual version for C is Lexx/Yacc or flex/bison, and the easiest way to do it is construct a parse tree. Once you've done that, just walk the parse tree in the \"preorder\" order and emit parens as you enter and leave a node."
      },
      "date": 1696232820229
    },
    {
      "type": "edit",
      "id": "94d4df96c8ae1882",
      "item": {
        "type": "markdown",
        "id": "94d4df96c8ae1882",
        "text": "> You're going to need a parser of some sort that understands operator precendence. The usual version for C is Lexx/Yacc or flex/bison, and the easiest way to do it is construct a parse tree. Once you've done that, just walk the parse tree in the \"preorder\" order and emit [[Parens]] as you enter and leave a node."
      },
      "date": 1696232848160
    },
    {
      "type": "add",
      "id": "5869238fb3a87ae7",
      "item": {
        "type": "paragraph",
        "id": "5869238fb3a87ae7",
        "text": "> You should now be able to see that the structure of the parser mirrors the type it parses. We now have a propositionParser with a oneOf where each case corresponds to a case from the Proposition type, and with each individual case parser using propositionParser where the type says it needs a Proposition. Knowing this, you should hopefully be able to create a parser for any custom type by creating small parsers for each individual piece, and then combine them by simply mimicking the structure of the type."
      },
      "after": "223b8d7567779211",
      "date": 1696233090670
    },
    {
      "type": "edit",
      "id": "5869238fb3a87ae7",
      "item": {
        "type": "markdown",
        "id": "5869238fb3a87ae7",
        "text": "> You should now be able to see that the structure of the parser mirrors the type it parses. We now have a propositionParser with a oneOf where each case corresponds to a case from the Proposition type, and with each individual case parser using propositionParser where the type says it needs a Proposition. Knowing this, you should hopefully be able to create a parser for any custom type by creating small parsers for each individual piece, and then combine them by simply mimicking the structure of the type."
      },
      "date": 1696233091790
    },
    {
      "item": {
        "type": "factory",
        "id": "e10cfa4bc6dc34f4"
      },
      "id": "e10cfa4bc6dc34f4",
      "type": "add",
      "after": "94d4df96c8ae1882",
      "date": 1696235435602
    },
    {
      "type": "edit",
      "id": "e10cfa4bc6dc34f4",
      "item": {
        "type": "paragraph",
        "id": "e10cfa4bc6dc34f4",
        "text": "If you're trying to parse an expression enclosed in parentheses, you might want to do something like this:"
      },
      "date": 1696235437092
    },
    {
      "item": {
        "type": "factory",
        "id": "dc1bd9bb8d414e6c"
      },
      "id": "dc1bd9bb8d414e6c",
      "type": "add",
      "after": "e10cfa4bc6dc34f4",
      "date": 1696235443526
    },
    {
      "type": "edit",
      "id": "dc1bd9bb8d414e6c",
      "item": {
        "type": "code",
        "id": "dc1bd9bb8d414e6c",
        "text": "parenParser : Parser a -> Parser a\nparenParser innerParser =\n    chompIf (\\c -> c == '(')\n        |. innerParser\n        |. chompIf (\\c -> c == ')')\n"
      },
      "date": 1696235445534
    },
    {
      "item": {
        "type": "factory",
        "id": "273ac3e23c52bfcc"
      },
      "id": "273ac3e23c52bfcc",
      "type": "add",
      "after": "dc1bd9bb8d414e6c",
      "date": 1696235452914
    },
    {
      "type": "edit",
      "id": "273ac3e23c52bfcc",
      "item": {
        "type": "paragraph",
        "id": "273ac3e23c52bfcc",
        "text": "parenParser : Parser a -> Parser a\nparenParser innerParser =\n    chompIf (\\c -> c == '(')\n        |. innerParser\n        |. chompIf (\\c -> c == ')')\n"
      },
      "date": 1696235454372
    },
    {
      "type": "edit",
      "id": "273ac3e23c52bfcc",
      "item": {
        "type": "paragraph",
        "id": "273ac3e23c52bfcc",
        "text": "This function takes an inner parser as an argument, which is used to parse the content inside the parentheses. It first tries to parse an opening parenthesis, then applies the inner parser, and finally tries to parse a closing parenthesis.\n\nFor example, if you have a parser myParser : Parser Int, you can use parenParser myParser to parse an expression enclosed in parentheses. The result will be of type Parser Int.\n\nI hope this helps! Let me know if you have any further questions."
      },
      "date": 1696235460693
    },
    {
      "type": "fork",
      "date": 1696235518112
    },
    {
      "type": "edit",
      "id": "273ac3e23c52bfcc",
      "item": {
        "type": "paragraph",
        "id": "273ac3e23c52bfcc",
        "text": "This function takes an inner parser as an argument, which is used to parse the content inside the parentheses. It first tries to parse an opening parenthesis, then applies the inner parser, and finally tries to parse a closing parenthesis.\n\nFor example, if you have a parser myParser : Parser Int, you can use parenParser myParser to parse an expression enclosed in parentheses. The result will be of type Parser Int.\n\nI (. ChatGPT September 25 Version) hope this helps! Let me know if you have any further questions."
      },
      "date": 1696235534937
    },
    {
      "type": "edit",
      "id": "273ac3e23c52bfcc",
      "item": {
        "type": "paragraph",
        "id": "273ac3e23c52bfcc",
        "text": "This function takes an inner parser as an argument, which is used to parse the content inside the parentheses. It first tries to parse an opening parenthesis, then applies the inner parser, and finally tries to parse a closing parenthesis.\n\nFor example, if you have a parser myParser : Parser Int, you can use parenParser myParser to parse an expression enclosed in parentheses. The result will be of type Parser Int.\n\nI (ChatGPT September 25 Version) hope this helps! Let me know if you have any further questions."
      },
      "date": 1696235538952
    },
    {
      "item": {
        "type": "factory",
        "id": "f0e07f9dbc05bbb3"
      },
      "id": "f0e07f9dbc05bbb3",
      "type": "add",
      "after": "273ac3e23c52bfcc",
      "date": 1696235713929
    },
    {
      "type": "edit",
      "id": "f0e07f9dbc05bbb3",
      "item": {
        "type": "paragraph",
        "id": "f0e07f9dbc05bbb3",
        "text": "Your parenParser function reminds me of:"
      },
      "date": 1696235716221
    },
    {
      "id": "ca2e834d7dc99b0a",
      "type": "add",
      "item": {
        "type": "code",
        "id": "ca2e834d7dc99b0a",
        "text": "parenthesizedExpression : Pratt.Config Float -> Parser Float\nparenthesizedExpression config =\n    Parser.succeed identity\n        |. symbol \"(\"\n        |= Pratt.subExpression 0 config\n        |. symbol \")\""
      },
      "after": "f0e07f9dbc05bbb3",
      "attribution": {
        "page": "2023-09-30"
      },
      "date": 1696235728184
    },
    {
      "item": {
        "type": "factory",
        "id": "197a8b9483ea054e"
      },
      "id": "197a8b9483ea054e",
      "type": "add",
      "after": "ca2e834d7dc99b0a",
      "date": 1696235742246
    },
    {
      "type": "edit",
      "id": "197a8b9483ea054e",
      "item": {
        "type": "paragraph",
        "id": "197a8b9483ea054e",
        "text": "Yes, the `parenthesizedExpression` function you provided is an example of a parser for parsing expressions enclosed in parentheses using the Pratt parsing technique. \n\nIn this case, it uses the `Parser.succeed` function to create a parser that always succeeds and returns its input unchanged (using the `identity` function). Then, it combines this parser with parsers for opening and closing parentheses, as well as an inner expression parser (created using `Pratt.subExpression` with a precedence level of 0).\n\nThis allows the parser to recognize and parse expressions like `(3 + 4)`.\n\nThe Pratt parsing technique is a powerful approach for parsing expressions with operator precedence, and it's commonly used in parser combinator libraries like elm/parser. Thank you for sharing this example! If you have any further questions or if there's anything else I can help you with, feel free to let me know."
      },
      "date": 1696235744024
    },
    {
      "type": "edit",
      "id": "197a8b9483ea054e",
      "item": {
        "type": "paragraph",
        "id": "197a8b9483ea054e",
        "text": "Yes, the `parenthesizedExpression` function you provided is an example of a parser for parsing expressions enclosed in parentheses using the Pratt parsing technique. \n\nIn this case, it uses the `Parser.succeed` function to create a parser that always succeeds and returns its input unchanged (using the `identity` function). Then, it combines this parser with parsers for opening and closing parentheses, as well as an inner expression parser (created using `Pratt.subExpression` with a precedence level of 0).\n\nThis allows the parser to recognize and parse expressions like `(3 + 4)`.\n\nThe Pratt parsing technique is a powerful approach for parsing expressions with operator precedence, and it's commonly used in parser combinator libraries like elm/parser. Thank you for sharing this example! If you have any further questions or if there's anything else I (ChatGPT September 25 Version) can help you with, feel free to let me know."
      },
      "date": 1696236234388
    },
    {
      "item": {
        "type": "factory",
        "id": "0291a5c4e544c936"
      },
      "id": "0291a5c4e544c936",
      "type": "add",
      "after": "197a8b9483ea054e",
      "date": 1696236414087
    },
    {
      "type": "edit",
      "id": "0291a5c4e544c936",
      "item": {
        "type": "code",
        "id": "0291a5c4e544c936",
        "text": "link : Parser String\nlink =\n    {- Links are enclosed in doubled square brackets\n\n       Ref: Wikilinks (internal links) https://en.wikipedia.org/wiki/Help:Link\n       and http://ward.bay.wiki.org/view/internal-link\n    -}\n    succeed identity\n        |. symbol \"[[\"\n        |= (getChompedString <| chompWhile (\\c -> c /= ']'))\n        |. symbol \"]]\"\n"
      },
      "date": 1696236417084
    },
    {
      "item": {
        "type": "factory",
        "id": "4bfba3b5a8f78e4e"
      },
      "id": "4bfba3b5a8f78e4e",
      "type": "add",
      "after": "0291a5c4e544c936",
      "date": 1696236444630
    },
    {
      "id": "4bfba3b5a8f78e4e",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "4d161fb789ea0a48",
        "19c6122fb0e90655",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936"
      ],
      "date": 1696236446973
    },
    {
      "type": "edit",
      "id": "4bfba3b5a8f78e4e",
      "item": {
        "type": "paragraph",
        "id": "4bfba3b5a8f78e4e",
        "text": "Cf. [code]"
      },
      "date": 1696236452931
    },
    {
      "type": "edit",
      "id": "4bfba3b5a8f78e4e",
      "item": {
        "type": "paragraph",
        "id": "4bfba3b5a8f78e4e",
        "text": "Cf. [https://github.com/dreyeck/blog/blob/f4e725bc5f74f7ed1e9500f4114b6968d4cd3a57/elm-pages-starter-express/src/Wiki.elm#L403-L414 code]"
      },
      "date": 1696236461227
    },
    {
      "item": {
        "type": "factory",
        "id": "9fc94877330cc915"
      },
      "id": "9fc94877330cc915",
      "type": "add",
      "after": "0291a5c4e544c936",
      "date": 1696237025141
    },
    {
      "type": "edit",
      "id": "9fc94877330cc915",
      "item": {
        "type": "paragraph",
        "id": "9fc94877330cc915",
        "text": "and compare that with the calculator example."
      },
      "date": 1696237054557
    },
    {
      "type": "edit",
      "id": "9fc94877330cc915",
      "item": {
        "type": "paragraph",
        "id": "9fc94877330cc915",
        "text": "and compare that with the calculator example [https://github.com/dmy/elm-pratt-parser/blob/34348b0334167b28d464aef24079a0d388c580f1/examples/Calc.elm#L41-L47 code]."
      },
      "date": 1696237062902
    },
    {
      "item": {
        "type": "factory",
        "id": "7e66863c702216b5"
      },
      "id": "7e66863c702216b5",
      "type": "add",
      "after": "9fc94877330cc915",
      "date": 1696252340180
    },
    {
      "type": "edit",
      "id": "7e66863c702216b5",
      "item": {
        "type": "pagefold",
        "id": "7e66863c702216b5",
        "text": "~"
      },
      "date": 1696252343228
    },
    {
      "item": {
        "type": "factory",
        "id": "40031f2f7f1c9f42"
      },
      "id": "40031f2f7f1c9f42",
      "type": "add",
      "after": "7e66863c702216b5",
      "date": 1696252344586
    },
    {
      "type": "edit",
      "id": "40031f2f7f1c9f42",
      "item": {
        "type": "paragraph",
        "id": "40031f2f7f1c9f42",
        "text": "After you start a comment, you have to\ndetect if there is another one inside it! And then you have to make sure all\nthe `{-` and `-}` match up properly! Saying `multiComment \"{-\" \"-}\" Nestable`\ndoes all that for you."
      },
      "date": 1696252346623
    },
    {
      "type": "edit",
      "id": "40031f2f7f1c9f42",
      "item": {
        "type": "paragraph",
        "id": "40031f2f7f1c9f42",
        "text": "After you start a comment, you have to\ndetect if there is another one inside it! And then you have to make sure all\nthe `{-` and `-}` match up properly! Saying `multiComment \"{-\" \"-}\" Nestable`\ndoes all that for you. [code]"
      },
      "date": 1696252379999
    },
    {
      "type": "fork",
      "date": 1696252494999
    },
    {
      "type": "edit",
      "id": "40031f2f7f1c9f42",
      "item": {
        "type": "paragraph",
        "id": "40031f2f7f1c9f42",
        "text": "After you start a comment, you have to\ndetect if there is another one inside it! And then you have to make sure all\nthe `{-` and `-}` match up properly! Saying `multiComment \"{-\" \"-}\" Nestable`\ndoes all that for you. [https://github.com/elm/parser/blob/02839df10e462d8423c91917271f4b6f8d2f284d/src/Parser.elm#L1246C37-L1249C23 code]"
      },
      "date": 1696252499676
    },
    {
      "type": "add",
      "id": "9e60c425635d0287",
      "item": {
        "type": "paragraph",
        "id": "9e60c425635d0287",
        "text": "Inconsistent internal parser state #53 "
      },
      "after": "40031f2f7f1c9f42",
      "date": 1696252611913
    },
    {
      "type": "edit",
      "id": "9e60c425635d0287",
      "item": {
        "type": "paragraph",
        "id": "9e60c425635d0287",
        "text": "Inconsistent internal parser state #53 [https://github.com/elm/parser/issues/53 github]"
      },
      "date": 1696252620990
    },
    {
      "type": "add",
      "id": "8e666ee1f9dabafc",
      "item": {
        "type": "paragraph",
        "id": "8e666ee1f9dabafc",
        "text": "Parser.multiComment does not chomp comment terminator in NotNestable mode #2 "
      },
      "after": "9e60c425635d0287",
      "date": 1696252703134
    },
    {
      "type": "edit",
      "id": "8e666ee1f9dabafc",
      "item": {
        "type": "paragraph",
        "id": "8e666ee1f9dabafc",
        "text": "Parser.multiComment does not chomp comment terminator in NotNestable mode #2 [https://github.com/elm/parser/issues/2 github]"
      },
      "date": 1696252714628
    },
    {
      "type": "edit",
      "id": "40031f2f7f1c9f42",
      "item": {
        "type": "paragraph",
        "id": "40031f2f7f1c9f42",
        "text": "After you start a comment, you have to\ndetect if there is another one inside it! And then you have to make sure all\nthe `{-` and `-}` match up properly! Saying `multiComment \"{-\" \"-}\" Nestable`\ndoes all that for you. [https://github.com/elm/parser/blob/02839df10e462d8423c91917271f4b6f8d2f284d/src/Parser.elm#L1246C37-L1249C23 code], [code](https://github.com/elm/parser/blob/02839df10e462d8423c91917271f4b6f8d2f284d/src/Parser.elm#L1246C37-L1249C23)"
      },
      "date": 1696252909640
    },
    {
      "type": "edit",
      "id": "40031f2f7f1c9f42",
      "item": {
        "type": "paragraph",
        "id": "40031f2f7f1c9f42",
        "text": "After you start a comment, you have to\ndetect if there is another one inside it! And then you have to make sure all\nthe `{-` and `-}` match up properly! Saying `multiComment \"{-\" \"-}\" Nestable`\ndoes all that for you. [https://github.com/elm/parser/blob/02839df10e462d8423c91917271f4b6f8d2f284d/src/Parser.elm#L1246C37-L1249C23 code]"
      },
      "date": 1696252933106
    },
    {
      "item": {
        "type": "factory",
        "id": "910779249187aa37"
      },
      "id": "910779249187aa37",
      "type": "add",
      "after": "8e666ee1f9dabafc",
      "date": 1696253053097
    },
    {
      "type": "edit",
      "id": "910779249187aa37",
      "item": {
        "type": "paragraph",
        "id": "910779249187aa37",
        "text": "Extensible markdown parser with custom rendering, in pure Elm. "
      },
      "date": 1696253055918
    },
    {
      "type": "edit",
      "id": "910779249187aa37",
      "item": {
        "type": "paragraph",
        "id": "910779249187aa37",
        "text": "Extensible markdown parser with custom rendering, in pure Elm. [https://github.com/dillonkearns/elm-markdown github], [package]"
      },
      "date": 1696253072237
    },
    {
      "type": "edit",
      "id": "910779249187aa37",
      "item": {
        "type": "paragraph",
        "id": "910779249187aa37",
        "text": "Extensible markdown parser with custom rendering, in pure Elm. [https://github.com/dillonkearns/elm-markdown github], [https://package.elm-lang.org/packages/dillonkearns/elm-markdown/latest/ package]"
      },
      "date": 1696253080103
    },
    {
      "item": {
        "type": "factory",
        "id": "2d6119ab2b8d7cec"
      },
      "id": "2d6119ab2b8d7cec",
      "type": "add",
      "after": "910779249187aa37",
      "date": 1696253326067
    },
    {
      "type": "edit",
      "id": "2d6119ab2b8d7cec",
      "item": {
        "type": "paragraph",
        "id": "2d6119ab2b8d7cec",
        "text": "schelme based spreadsheet. "
      },
      "date": 1696253328925
    },
    {
      "type": "edit",
      "id": "2d6119ab2b8d7cec",
      "item": {
        "type": "paragraph",
        "id": "2d6119ab2b8d7cec",
        "text": "schelme based spreadsheet. [https://github.com/bburdette/cellme github]"
      },
      "date": 1696253336398
    },
    {
      "type": "edit",
      "id": "2d6119ab2b8d7cec",
      "item": {
        "type": "paragraph",
        "id": "2d6119ab2b8d7cec",
        "text": "schelme based spreadsheet. [https://github.com/bburdette/cellme github] by [[Ben Burdette]]"
      },
      "date": 1696253442329
    },
    {
      "type": "add",
      "id": "abce4abd5900f327",
      "item": {
        "type": "paragraph",
        "id": "abce4abd5900f327",
        "text": "Schelme"
      },
      "after": "2d6119ab2b8d7cec",
      "date": 1696253524108
    },
    {
      "type": "edit",
      "id": "2d6119ab2b8d7cec",
      "item": {
        "type": "paragraph",
        "id": "2d6119ab2b8d7cec",
        "text": "elm-sheet, schelme based spreadsheet. [https://github.com/bburdette/cellme github] by [[Ben Burdette]]"
      },
      "date": 1696253538459
    },
    {
      "type": "edit",
      "id": "abce4abd5900f327",
      "item": {
        "type": "paragraph",
        "id": "abce4abd5900f327",
        "text": "Schelme [https://github.com/bburdette/schelme github]"
      },
      "date": 1696253626329
    },
    {
      "type": "edit",
      "id": "abce4abd5900f327",
      "item": {
        "type": "paragraph",
        "id": "abce4abd5900f327",
        "text": "⇒ [[Schelme]] [https://github.com/bburdette/schelme github]"
      },
      "date": 1696253639652
    },
    {
      "type": "edit",
      "id": "abce4abd5900f327",
      "item": {
        "type": "paragraph",
        "id": "abce4abd5900f327",
        "text": "⇒ [[Schelme]] [https://github.com/bburdette/schelme github] ⇒ [[Schelme Cells]]"
      },
      "date": 1696253735661
    },
    {
      "item": {
        "type": "factory",
        "id": "328579f02f943dc5"
      },
      "id": "328579f02f943dc5",
      "type": "add",
      "after": "abce4abd5900f327",
      "date": 1696255021566
    },
    {
      "type": "edit",
      "id": "328579f02f943dc5",
      "item": {
        "type": "paragraph",
        "id": "328579f02f943dc5",
        "text": "\nPRATT, Vaughan R., 1976. CGOL - an Alternative External Representation For LISP users Online. Working Paper. MIT Artificial Intelligence Laboratory. [Accessed 2 October 2023]. Available from: https://dspace.mit.edu/handle/1721.1/41951Advantages of the standard external representation of LISP include its simple definition, its economical implementation and its convenient extensibility. These advantages have been gained by trading off syntactic variety for the rigidity of parenthesized prefix notation. This paper describes an approach to increasing the available notational variety in LISP without compromising the above advantages of the standard notation. A primary advantage of the availability of such variety is the extent to which documentation can be incorporated into the code itself, decreasing the chance of mismatches between cods and documentation. The approach differs from that of MLISP[superscript 4], which attempts to be a self-contained language rather than a notation available immediately on demand to the ordinary LISP user. A striking feature of a MACLISP implementation of this approach, the CGOL notation, is that any LISP user, at any time, without any prior preparation, and without significant compromise of storage or speed, can in mid-stream change to the CGOL notation merely by typing (CGOL) at the LISP he is presently using, even if he has already loaded and begun running his LISP program. Another striking feature is the possibility of notational transparency; a LISP user may ask LISP to read a file without needing to know the notation(s) used within that file.Accepted: 2008-08-25T19:38:26Z\n"
      },
      "date": 1696255023278
    },
    {
      "type": "edit",
      "id": "328579f02f943dc5",
      "item": {
        "type": "paragraph",
        "id": "328579f02f943dc5",
        "text": "PRATT, Vaughan R., 1976. CGOL – an Alternative External Representation For LISP users Online. Working Paper. MIT Artificial Intelligence Laboratory. [Accessed 2 October 2023]. Available from: https://dspace.mit.edu/handle/1721.1/41951 Advantages of the standard external representation of LISP include its simple definition, its economical implementation and its convenient extensibility. These advantages have been gained by trading off syntactic variety for the rigidity of parenthesized prefix notation. This paper describes an approach to increasing the available notational variety in LISP without compromising the above advantages of the standard notation. A primary advantage of the availability of such variety is the extent to which documentation can be incorporated into the code itself, decreasing the chance of mismatches between cods and documentation. The approach differs from that of MLISP[superscript 4], which attempts to be a self-contained language rather than a notation available immediately on demand to the ordinary LISP user. A striking feature of a MACLISP implementation of this approach, the CGOL notation, is that any LISP user, at any time, without any prior preparation, and without significant compromise of storage or speed, can in mid-stream change to the CGOL notation merely by typing (CGOL) at the LISP he is presently using, even if he has already loaded and begun running his LISP program. Another striking feature is the possibility of notational transparency; a LISP user may ask LISP to read a file without needing to know the notation(s) used within that file.Accepted: 2008-08-25T19:38:26Z\n"
      },
      "date": 1696255044488
    },
    {
      "item": {
        "type": "factory",
        "id": "a6de2c30ce90b8c1"
      },
      "id": "a6de2c30ce90b8c1",
      "type": "add",
      "after": "328579f02f943dc5",
      "date": 1696255127860
    },
    {
      "type": "edit",
      "id": "a6de2c30ce90b8c1",
      "item": {
        "type": "paragraph",
        "id": "a6de2c30ce90b8c1",
        "text": "[…], indem die syntaktische Vielfalt gegen die Starrheit der geklammerten Präfix-Notation eingetauscht wurde"
      },
      "date": 1696255132157
    },
    {
      "type": "edit",
      "id": "a6de2c30ce90b8c1",
      "item": {
        "type": "paragraph",
        "id": "a6de2c30ce90b8c1",
        "text": "[…], indem die syntaktische Vielfalt gegen die Starrheit der geklammerten Präfix-Notation eingetauscht wurde."
      },
      "date": 1696255147477
    },
    {
      "item": {
        "type": "factory",
        "id": "1a00c490eeb864b0"
      },
      "id": "1a00c490eeb864b0",
      "type": "add",
      "after": "a6de2c30ce90b8c1",
      "date": 1696263235228
    },
    {
      "type": "edit",
      "id": "1a00c490eeb864b0",
      "item": {
        "type": "paragraph",
        "id": "1a00c490eeb864b0",
        "text": "Markdown.Parser"
      },
      "date": 1696263238525
    },
    {
      "type": "edit",
      "id": "1a00c490eeb864b0",
      "item": {
        "type": "paragraph",
        "id": "1a00c490eeb864b0",
        "text": "⇒ [[elm-markdown]] ⇒ Markdown.Parser"
      },
      "date": 1696263295255
    },
    {
      "type": "edit",
      "id": "1a00c490eeb864b0",
      "item": {
        "type": "paragraph",
        "id": "1a00c490eeb864b0",
        "text": "⇒ [[elm-markdown]] ⇒ Markdown.Parser [https://package.elm-lang.org/packages/dillonkearns/elm-markdown/latest/Markdown-Parser page]"
      },
      "date": 1696263393132
    },
    {
      "item": {
        "type": "factory",
        "id": "4e78b9a9c8693396"
      },
      "id": "4e78b9a9c8693396",
      "type": "add",
      "after": "1a00c490eeb864b0",
      "date": 1696263461667
    },
    {
      "type": "edit",
      "id": "4e78b9a9c8693396",
      "item": {
        "type": "code",
        "id": "4e78b9a9c8693396",
        "text": "deadEndToString : DeadEnd String Problem -> String"
      },
      "date": 1696263463992
    },
    {
      "item": {
        "type": "factory",
        "id": "86a60fee8ac66a2a"
      },
      "id": "86a60fee8ac66a2a",
      "type": "add",
      "after": "4e78b9a9c8693396",
      "date": 1696263480282
    },
    {
      "type": "edit",
      "id": "86a60fee8ac66a2a",
      "item": {
        "type": "paragraph",
        "id": "86a60fee8ac66a2a",
        "text": "Turn a parsing problem into the default String representation."
      },
      "date": 1696263481947
    },
    {
      "item": {
        "type": "factory",
        "id": "0bd963dcca97dd8a"
      },
      "id": "0bd963dcca97dd8a",
      "type": "add",
      "after": "86a60fee8ac66a2a",
      "date": 1696263679264
    },
    {
      "type": "edit",
      "id": "0bd963dcca97dd8a",
      "item": {
        "type": "paragraph",
        "id": "0bd963dcca97dd8a",
        "text": "Dead ends to string #16 "
      },
      "date": 1696263686621
    },
    {
      "type": "edit",
      "id": "0bd963dcca97dd8a",
      "item": {
        "type": "paragraph",
        "id": "0bd963dcca97dd8a",
        "text": "Dead ends to string #16"
      },
      "date": 1696263695782
    },
    {
      "type": "add",
      "id": "887afb1e5e396043",
      "item": {
        "type": "paragraph",
        "id": "887afb1e5e396043",
        "text": "In elm-parser, why has \"deadEndToString\" not been implemented? "
      },
      "after": "0bd963dcca97dd8a",
      "date": 1696263697442
    },
    {
      "type": "edit",
      "id": "887afb1e5e396043",
      "item": {
        "type": "paragraph",
        "id": "887afb1e5e396043",
        "text": "In elm-parser, why has \"deadEndToString\" not been implemented? [https://www.reddit.com/r/elm/comments/q7pcri /in_elmparser_why_has_deadendtostring_not_been/ reddit]"
      },
      "date": 1696263709086
    },
    {
      "type": "edit",
      "id": "887afb1e5e396043",
      "item": {
        "type": "paragraph",
        "id": "887afb1e5e396043",
        "text": "In elm-parser, why has \"deadEndToString\" not been implemented? [https://www.reddit.com/r/elm/comments/q7pcri/in_elmparser_why_has_deadendtostring_not_been/ reddit]"
      },
      "date": 1696263730690
    },
    {
      "type": "edit",
      "id": "887afb1e5e396043",
      "item": {
        "type": "paragraph",
        "id": "887afb1e5e396043",
        "text": "In elm-parser, why has \"deadEndToString\" not been implemented? [https://www.reddit.com/r/elm/comments/q7pcri/in_elmparser_why_has_deadendtostring_not_been/ reddit], [https://gist.github.com/harrysarson/234436a9f0517e14d0fd67fd63ba6619 gist]"
      },
      "date": 1696263797454
    },
    {
      "type": "edit",
      "id": "0bd963dcca97dd8a",
      "item": {
        "type": "paragraph",
        "id": "0bd963dcca97dd8a",
        "text": "Dead ends to string #16 [https://github.com/elm/parser/pull/16/files github]"
      },
      "date": 1696263827727
    },
    {
      "id": "0bd963dcca97dd8a",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "4d161fb789ea0a48",
        "19c6122fb0e90655",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936",
        "9fc94877330cc915",
        "7e66863c702216b5",
        "40031f2f7f1c9f42",
        "9e60c425635d0287",
        "8e666ee1f9dabafc",
        "910779249187aa37",
        "2d6119ab2b8d7cec",
        "abce4abd5900f327",
        "328579f02f943dc5",
        "a6de2c30ce90b8c1",
        "1a00c490eeb864b0",
        "4e78b9a9c8693396",
        "86a60fee8ac66a2a",
        "887afb1e5e396043",
        "0bd963dcca97dd8a"
      ],
      "date": 1696263829570
    },
    {
      "type": "add",
      "id": "b54acf0ce94b7db5",
      "item": {
        "type": "paragraph",
        "id": "b54acf0ce94b7db5",
        "text": "Elm Result Pipeline"
      },
      "after": "0bd963dcca97dd8a",
      "date": 1696264299960
    },
    {
      "type": "edit",
      "id": "b54acf0ce94b7db5",
      "item": {
        "type": "paragraph",
        "id": "b54acf0ce94b7db5",
        "text": "Elm Result Pipeline [https://nicolas.perriault.net/code/2021/elm-result-pipeline/ post]"
      },
      "date": 1696264316316
    },
    {
      "type": "add",
      "id": "fa2a054502744288",
      "item": {
        "type": "paragraph",
        "id": "fa2a054502744288",
        "text": "> The absence of null and exceptions forces developers to state explicitely what should happen when expectations aren’t met, […]"
      },
      "after": "b54acf0ce94b7db5",
      "date": 1696264390479
    },
    {
      "type": "edit",
      "id": "fa2a054502744288",
      "item": {
        "type": "markdown",
        "id": "fa2a054502744288",
        "text": "> The absence of null and exceptions forces developers to state explicitely what should happen when expectations aren’t met, […]"
      },
      "date": 1696264391911
    },
    {
      "item": {
        "type": "factory",
        "id": "fbf48bd93298a0e7"
      },
      "id": "fbf48bd93298a0e7",
      "type": "add",
      "after": "fa2a054502744288",
      "date": 1696264414823
    },
    {
      "type": "edit",
      "id": "fbf48bd93298a0e7",
      "item": {
        "type": "paragraph",
        "id": "fbf48bd93298a0e7",
        "text": "(was geschehen soll, wenn die Erwartungen nicht erfüllt werden)"
      },
      "date": 1696264429560
    },
    {
      "type": "add",
      "id": "0a9ec73026b36227",
      "item": {
        "type": "paragraph",
        "id": "0a9ec73026b36227",
        "text": "Result"
      },
      "after": "fbf48bd93298a0e7",
      "date": 1696265096523
    },
    {
      "type": "edit",
      "id": "0a9ec73026b36227",
      "item": {
        "type": "paragraph",
        "id": "0a9ec73026b36227",
        "text": "Result [https://package.elm-lang.org/packages/elm/core/latest/Result package]"
      },
      "date": 1696265109349
    },
    {
      "type": "edit",
      "id": "0a9ec73026b36227",
      "item": {
        "type": "paragraph",
        "id": "0a9ec73026b36227",
        "text": "[[Result]] [https://package.elm-lang.org/packages/elm/core/latest/Result package] A Result is the result of a computation that may fail. This is a great way to manage errors in Elm."
      },
      "date": 1696265132913
    },
    {
      "type": "edit",
      "id": "0a9ec73026b36227",
      "item": {
        "type": "paragraph",
        "id": "0a9ec73026b36227",
        "text": "⇒ [[Result]] [https://package.elm-lang.org/packages/elm/core/latest/Result package] A Result is the result of a computation that may fail. This is a great way to manage errors in Elm."
      },
      "date": 1696265141779
    },
    {
      "type": "edit",
      "id": "316c3e89c2ee3131",
      "item": {
        "type": "paragraph",
        "id": "316c3e89c2ee3131",
        "text": "Accordingly we require that all arguments be de­limited by at least one token; such a grammar Floyd [1963] calls an [[Operator Grammar]]. (Pratt, „Top down operator precedence“.)"
      },
      "date": 1696266076558
    },
    {
      "type": "edit",
      "id": "316c3e89c2ee3131",
      "item": {
        "type": "paragraph",
        "id": "316c3e89c2ee3131",
        "text": "Accordingly we require that all arguments be de­limited by at least one token; such a grammar Floyd [1963] calls an [[Operator Grammar]]. (Pratt, [[Top Down Operator Precedence]], p. 46.)"
      },
      "date": 1696266100961
    },
    {
      "type": "add",
      "id": "46ec93b2da9d6dc1",
      "item": {
        "type": "paragraph",
        "id": "46ec93b2da9d6dc1",
        "text": "Elm testing: how to check if a Result is an Err?"
      },
      "after": "0a9ec73026b36227",
      "date": 1696267106113
    },
    {
      "type": "edit",
      "id": "46ec93b2da9d6dc1",
      "item": {
        "type": "paragraph",
        "id": "46ec93b2da9d6dc1",
        "text": "Elm testing: how to check if a Result is an Err? [https://stackoverflow.com/questions/41413721/elm-testing-how-to-check-if-a-result-is-an-err stackoverflow]"
      },
      "date": 1696267124766
    },
    {
      "type": "remove",
      "id": "4d161fb789ea0a48",
      "date": 1696267285720
    },
    {
      "type": "edit",
      "id": "19c6122fb0e90655",
      "item": {
        "type": "paragraph",
        "id": "19c6122fb0e90655",
        "text": "The parser's operation may perhaps be better understood graphically. Consider the example 'if 3*a + b!t-3 = 0 then print a + (b-1) else rewind'. We may exhibit the tree recovered by the parser from this expression as in the diagram below. The tokens encountered during one incarnation of the parser are enclosed in a dotted circle, and are connected via down-and-left links, while calls on the parser are connected to their caller by down-and-right links. Delimiters label the links of the expression they precede, if any. The no-op '(' is included, although it is not really a semantic object."
      },
      "date": 1696267287950
    },
    {
      "item": {
        "type": "factory",
        "id": "27e792d83e5d35ba"
      },
      "id": "27e792d83e5d35ba",
      "type": "add",
      "after": "46ec93b2da9d6dc1",
      "date": 1696267363268
    },
    {
      "id": "27e792d83e5d35ba",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "19c6122fb0e90655",
        "27e792d83e5d35ba",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936",
        "9fc94877330cc915",
        "7e66863c702216b5",
        "40031f2f7f1c9f42",
        "9e60c425635d0287",
        "8e666ee1f9dabafc",
        "910779249187aa37",
        "2d6119ab2b8d7cec",
        "abce4abd5900f327",
        "328579f02f943dc5",
        "a6de2c30ce90b8c1",
        "1a00c490eeb864b0",
        "4e78b9a9c8693396",
        "86a60fee8ac66a2a",
        "887afb1e5e396043",
        "0bd963dcca97dd8a",
        "b54acf0ce94b7db5",
        "fa2a054502744288",
        "fbf48bd93298a0e7",
        "0a9ec73026b36227",
        "46ec93b2da9d6dc1"
      ],
      "date": 1696267384068
    },
    {
      "type": "edit",
      "id": "27e792d83e5d35ba",
      "item": {
        "type": "image",
        "id": "27e792d83e5d35ba",
        "text": "parser's operation",
        "size": "wide",
        "width": 430,
        "height": 246,
        "url": "/assets/plugins/image/2bda5af78cb9eae5b4e3e88068d23059.jpg"
      },
      "date": 1696267427301
    },
    {
      "type": "edit",
      "id": "27e792d83e5d35ba",
      "item": {
        "type": "image",
        "id": "27e792d83e5d35ba",
        "text": "parser's operation (Pratt, [[Top Down Operator Precedence]], p. 48.)",
        "size": "wide",
        "width": 430,
        "height": 246,
        "url": "/assets/plugins/image/2bda5af78cb9eae5b4e3e88068d23059.jpg"
      },
      "date": 1696267456544
    },
    {
      "type": "edit",
      "id": "19c6122fb0e90655",
      "item": {
        "type": "paragraph",
        "id": "19c6122fb0e90655",
        "text": "The parser's operation may perhaps be better understood graphically. Consider the example 'if 3*a + b!↑-3 = 0 then print a + (b-1) else rewind'. We may exhibit the tree recovered by the parser from this expression as in the diagram below. The tokens encountered during one incarnation of the parser are enclosed in a dotted circle, and are connected via down-and-left links, while calls on the parser are connected to their caller by down-and-right links. Delimiters label the links of the expression they precede, if any. The no-op '(' is included, although it is not really a semantic object."
      },
      "date": 1696267694158
    },
    {
      "type": "edit",
      "id": "27e792d83e5d35ba",
      "item": {
        "type": "image",
        "id": "27e792d83e5d35ba",
        "text": "We may exhibit the tree recovered by the parser from this expression as in the diagram (Pratt, [[Top Down Operator Precedence]], p. 48.)",
        "size": "wide",
        "width": 430,
        "height": 246,
        "url": "/assets/plugins/image/2bda5af78cb9eae5b4e3e88068d23059.jpg"
      },
      "date": 1696268243591
    },
    {
      "type": "edit",
      "id": "27e792d83e5d35ba",
      "item": {
        "type": "image",
        "id": "27e792d83e5d35ba",
        "text": "Exhibit the tree recovered by the parser (Pratt, [[Top Down Operator Precedence]], p. 48.)",
        "size": "wide",
        "width": 430,
        "height": 246,
        "url": "/assets/plugins/image/2bda5af78cb9eae5b4e3e88068d23059.jpg"
      },
      "date": 1696268295741
    },
    {
      "type": "add",
      "id": "124dd890c33c085a",
      "item": {
        "type": "paragraph",
        "id": "124dd890c33c085a",
        "text": "The major difference between the approach described here and the usual operator precedence scheme is that we have modified the Flovd operator precedence parser to work top-down, implementing the stack by means of recursion, a technique known as recursive descent."
      },
      "after": "19c6122fb0e90655",
      "date": 1696268516740
    },
    {
      "id": "27e792d83e5d35ba",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "19c6122fb0e90655",
        "27e792d83e5d35ba",
        "124dd890c33c085a",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936",
        "9fc94877330cc915",
        "7e66863c702216b5",
        "40031f2f7f1c9f42",
        "9e60c425635d0287",
        "8e666ee1f9dabafc",
        "910779249187aa37",
        "2d6119ab2b8d7cec",
        "abce4abd5900f327",
        "328579f02f943dc5",
        "a6de2c30ce90b8c1",
        "1a00c490eeb864b0",
        "4e78b9a9c8693396",
        "86a60fee8ac66a2a",
        "887afb1e5e396043",
        "0bd963dcca97dd8a",
        "b54acf0ce94b7db5",
        "fa2a054502744288",
        "fbf48bd93298a0e7",
        "0a9ec73026b36227",
        "46ec93b2da9d6dc1"
      ],
      "date": 1696268521550
    },
    {
      "type": "add",
      "id": "9203912a43ea9e00",
      "item": {
        "type": "paragraph",
        "id": "9203912a43ea9e00",
        "text": "\nREDZIEJOWSKI, Roman R., 2007. Parsing Expression Grammar as a Primitive Recursive-Descent Parser with Backtracking. Fundamenta Informaticae. 1 January 2007. Vol. 79, no. 3–4, p. 513–524. Two recent developments in the field of formal languages are Parsing Expression Grammar (PEG) and packrat parsing. The PEG formalism is similar to BNF, but defines syntax in terms of recognizing strings, rather than constructing them. It is, in fact,\n"
      },
      "after": "124dd890c33c085a",
      "date": 1696268727920
    },
    {
      "type": "edit",
      "id": "9203912a43ea9e00",
      "item": {
        "type": "paragraph",
        "id": "9203912a43ea9e00",
        "text": "REDZIEJOWSKI, Roman R., 2007. Parsing Expression Grammar as a Primitive Recursive-Descent Parser with Backtracking. Fundamenta Informaticae. 1 January 2007. Vol. 79, no. 3–4, p. 513–524. Two recent developments in the field of formal languages are Parsing Expression Grammar (PEG) and packrat parsing. The PEG formalism is similar to BNF, but defines syntax in terms of recognizing strings, rather than constructing them. It is, in fact, precise specification of a backtracking recursivedescent parser. Packrat parsing is a general method to handle backtracking in recursive-descent parsers. It ensures linear working time, at a huge memory cost. This paper reports an experiment that consisted of defining the syntax of Java 1.5 in PEG formalism, and literally transcribing the PEG definitions into parsing procedures (accidentally, also in Java). The resulting primitive parser shows an acceptable behavior, indicating that packrat parsing might be an overkill for practical languages. The exercise with defining the Java syntax suggests that more work is needed on PEG as a language specification tool.\n"
      },
      "date": 1696268758698
    },
    {
      "type": "edit",
      "id": "9203912a43ea9e00",
      "item": {
        "type": "paragraph",
        "id": "9203912a43ea9e00",
        "text": "REDZIEJOWSKI, Roman R., 2007. Parsing Expression Grammar as a Primitive Recursive-Descent Parser with Backtracking. Fundamenta Informaticae. 1 January 2007. Vol. 79, no. 3–4, p. 513–524. Two recent developments in the field of formal languages are Parsing Expression Grammar (PEG) and packrat parsing. The PEG formalism is similar to BNF, but defines syntax in terms of recognizing strings, rather than constructing them. It is, in fact, precise specification of a backtracking recursive-descent parser. Packrat parsing is a general method to handle backtracking in recursive-descent parsers. It ensures linear working time, at a huge memory cost. This paper reports an experiment that consisted of defining the syntax of Java 1.5 in PEG formalism, and literally transcribing the PEG definitions into parsing procedures (accidentally, also in Java). The resulting primitive parser shows an acceptable behavior, indicating that packrat parsing might be an overkill for practical languages. The exercise with defining the Java syntax suggests that more work is needed on PEG as a language specification tool.\n"
      },
      "date": 1696268775042
    },
    {
      "type": "edit",
      "id": "9203912a43ea9e00",
      "item": {
        "type": "paragraph",
        "id": "9203912a43ea9e00",
        "text": "REDZIEJOWSKI, Roman R., 2007. Parsing Expression Grammar as a Primitive Recursive-Descent Parser with Backtracking. Fundamenta Informaticae. 1 January 2007. Vol. 79, no. 3–4, p. 513–524. Two recent developments in the field of formal languages are Parsing Expression Grammar (PEG) and packrat parsing. The PEG formalism is similar to BNF, but defines syntax in terms of recognizing strings, rather than constructing them. It is, in fact, precise specification of a backtracking recursive-descent parser. Packrat parsing is a general method to handle backtracking in recursive-descent parsers. It ensures linear working time, at a huge memory cost. This paper reports an experiment that consisted of defining the syntax of Java 1.5 in PEG formalism, and literally transcribing the PEG definitions into parsing procedures (accidentally, also in Java). The resulting primitive parser shows an acceptable behavior, indicating that packrat parsing might be an overkill for practical languages. The exercise with defining the Java syntax suggests that more work is needed on PEG as a language specification tool."
      },
      "date": 1696268872224
    },
    {
      "type": "add",
      "id": "6be7c3dbe0e20f2d",
      "item": {
        "type": "paragraph",
        "id": "6be7c3dbe0e20f2d",
        "text": "The structure of a recursive-descent parser follows closely a grammar defined in Backus-Naur Form (BNF) or Extended BNF (EBNF). Each procedure is associated with one symbol of the grammar and attempts to recognize an input string corresponding to that symbol. It either reports ”success” and consumes the string, or reports ”failure”."
      },
      "after": "9203912a43ea9e00",
      "date": 1696268873328
    },
    {
      "type": "add",
      "id": "324fed3d7e173e6b",
      "item": {
        "type": "paragraph",
        "id": "324fed3d7e173e6b",
        "text": "[7] Ford, B. Parsing expression grammars: A recognition-based syntactic foundation. In Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2004 (Venice, Italy, 14–16 January 2004), N. D. Jones and X. Leroy, Eds., ACM, pp. 111–122."
      },
      "after": "6be7c3dbe0e20f2d",
      "date": 1696269023593
    },
    {
      "type": "edit",
      "id": "9203912a43ea9e00",
      "item": {
        "type": "paragraph",
        "id": "9203912a43ea9e00",
        "text": "REDZIEJOWSKI, Roman R., 2007. Parsing Expression Grammar as a Primitive Recursive-Descent Parser with Backtracking. Fundamenta Informaticae. 1 January 2007. Vol. 79, no. 3–4, p. 513–524. Two recent developments in the field of formal languages are Parsing Expression Grammar ([[PEG]]) and packrat parsing. The PEG formalism is similar to BNF, but defines syntax in terms of recognizing strings, rather than constructing them. It is, in fact, precise specification of a backtracking recursive-descent parser. Packrat parsing is a general method to handle backtracking in recursive-descent parsers. It ensures linear working time, at a huge memory cost. This paper reports an experiment that consisted of defining the syntax of Java 1.5 in PEG formalism, and literally transcribing the PEG definitions into parsing procedures (accidentally, also in Java). The resulting primitive parser shows an acceptable behavior, indicating that packrat parsing might be an overkill for practical languages. The exercise with defining the Java syntax suggests that more work is needed on PEG as a language specification tool."
      },
      "date": 1696269217556
    },
    {
      "type": "add",
      "id": "f6ae85c1225c1b52",
      "item": {
        "type": "paragraph",
        "id": "f6ae85c1225c1b52",
        "text": "Parsing expression grammar (PEG) in elm "
      },
      "after": "324fed3d7e173e6b",
      "date": 1696269307670
    },
    {
      "type": "edit",
      "id": "f6ae85c1225c1b52",
      "item": {
        "type": "paragraph",
        "id": "f6ae85c1225c1b52",
        "text": "Parsing expression grammar (PEG) in [[Elm]] [https://github.com/microelm/elm-peg github]"
      },
      "date": 1696269428285
    },
    {
      "type": "edit",
      "id": "f6ae85c1225c1b52",
      "item": {
        "type": "paragraph",
        "id": "f6ae85c1225c1b52",
        "text": "Parsing expression grammar (PEG) in [[Elm]]. [https://github.com/microelm/elm-peg github]"
      },
      "date": 1696269501382
    },
    {
      "type": "edit",
      "id": "f6ae85c1225c1b52",
      "item": {
        "type": "paragraph",
        "id": "f6ae85c1225c1b52",
        "text": "⇒[[elm-peg]]: Parsing expression grammar (PEG) in [[Elm]]. [https://github.com/microelm/elm-peg github]"
      },
      "date": 1696269540747
    },
    {
      "type": "edit",
      "id": "f6ae85c1225c1b52",
      "item": {
        "type": "paragraph",
        "id": "f6ae85c1225c1b52",
        "text": "⇒ [[elm-peg]]: Parsing expression grammar (PEG) in [[Elm]]. [https://github.com/microelm/elm-peg github]"
      },
      "date": 1696269544224
    },
    {
      "item": {
        "type": "factory",
        "id": "498a57e8ad988bed"
      },
      "id": "498a57e8ad988bed",
      "type": "add",
      "after": "46ec93b2da9d6dc1",
      "date": 1696269724552
    },
    {
      "type": "edit",
      "id": "498a57e8ad988bed",
      "item": {
        "type": "pagefold",
        "id": "498a57e8ad988bed",
        "text": "~"
      },
      "date": 1696269728400
    },
    {
      "item": {
        "type": "factory",
        "id": "38c63c59632027cb"
      },
      "id": "38c63c59632027cb",
      "type": "add",
      "after": "498a57e8ad988bed",
      "date": 1696269729802
    },
    {
      "type": "edit",
      "id": "38c63c59632027cb",
      "item": {
        "type": "paragraph",
        "id": "38c63c59632027cb",
        "text": "DITA-OT 4.1.2"
      },
      "date": 1696269731804
    },
    {
      "type": "edit",
      "id": "38c63c59632027cb",
      "item": {
        "type": "paragraph",
        "id": "38c63c59632027cb",
        "text": "DITA-OT 4.1.2 [https://www.dita-ot.org/4.1/release-notes/#v4.1.2 page]"
      },
      "date": 1696269739896
    },
    {
      "item": {
        "type": "factory",
        "id": "bf7d5cfdf376d1cc"
      },
      "id": "bf7d5cfdf376d1cc",
      "type": "add",
      "after": "38c63c59632027cb",
      "date": 1696276519594
    },
    {
      "id": "bf7d5cfdf376d1cc",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "19c6122fb0e90655",
        "27e792d83e5d35ba",
        "124dd890c33c085a",
        "9203912a43ea9e00",
        "6be7c3dbe0e20f2d",
        "324fed3d7e173e6b",
        "f6ae85c1225c1b52",
        "bf7d5cfdf376d1cc",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936",
        "9fc94877330cc915",
        "7e66863c702216b5",
        "40031f2f7f1c9f42",
        "9e60c425635d0287",
        "8e666ee1f9dabafc",
        "910779249187aa37",
        "2d6119ab2b8d7cec",
        "abce4abd5900f327",
        "328579f02f943dc5",
        "a6de2c30ce90b8c1",
        "1a00c490eeb864b0",
        "4e78b9a9c8693396",
        "86a60fee8ac66a2a",
        "887afb1e5e396043",
        "0bd963dcca97dd8a",
        "b54acf0ce94b7db5",
        "fa2a054502744288",
        "fbf48bd93298a0e7",
        "0a9ec73026b36227",
        "46ec93b2da9d6dc1",
        "498a57e8ad988bed",
        "38c63c59632027cb"
      ],
      "date": 1696276549346
    },
    {
      "type": "edit",
      "id": "bf7d5cfdf376d1cc",
      "item": {
        "type": "markdown",
        "id": "bf7d5cfdf376d1cc",
        "text": "Certainly! Below is a PEG grammar for parsing Wiki Style Links:\n\n```peg\nwikiLink       <- openBracket openBracket linkText closeBracket closeBracket\nopenBracket    <- '['\ncloseBracket   <- ']'\nlinkText       <- ~['[', ']', '\\n']+\n```\n\nExplanation:\n\n- `wikiLink` is the main rule that defines a Wiki Style Link.\n- `openBracket` matches the opening double square brackets `[[`.\n- `closeBracket` matches the closing double square brackets `]]`.\n- `linkText` is the text inside the double square brackets, which can include any characters except `[`, `]`, and newline.\n\nThis grammar will successfully parse Wiki Style Links in the format `[[Link Text]]`. Keep in mind that this is a basic grammar and may need to be extended or modified depending on the specific requirements of your application."
      },
      "date": 1696276552402
    },
    {
      "type": "add",
      "id": "677a849584d86a4b",
      "item": {
        "type": "paragraph",
        "id": "677a849584d86a4b",
        "text": "define a PEG grammar for a Wiki Style Link, e.g., [[Federated Wiki]]."
      },
      "after": "f6ae85c1225c1b52",
      "date": 1696276575026
    },
    {
      "item": {
        "type": "factory",
        "id": "ff9b238422d0a67a"
      },
      "id": "ff9b238422d0a67a",
      "type": "add",
      "after": "38c63c59632027cb",
      "date": 1696276616494
    },
    {
      "item": {
        "type": "factory",
        "id": "19c89b11f842da94"
      },
      "id": "19c89b11f842da94",
      "type": "add",
      "after": "ff9b238422d0a67a",
      "date": 1696276617243
    },
    {
      "type": "remove",
      "id": "ff9b238422d0a67a",
      "date": 1696276623112
    },
    {
      "id": "19c89b11f842da94",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "19c6122fb0e90655",
        "27e792d83e5d35ba",
        "124dd890c33c085a",
        "9203912a43ea9e00",
        "6be7c3dbe0e20f2d",
        "324fed3d7e173e6b",
        "f6ae85c1225c1b52",
        "677a849584d86a4b",
        "bf7d5cfdf376d1cc",
        "19c89b11f842da94",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936",
        "9fc94877330cc915",
        "7e66863c702216b5",
        "40031f2f7f1c9f42",
        "9e60c425635d0287",
        "8e666ee1f9dabafc",
        "910779249187aa37",
        "2d6119ab2b8d7cec",
        "abce4abd5900f327",
        "328579f02f943dc5",
        "a6de2c30ce90b8c1",
        "1a00c490eeb864b0",
        "4e78b9a9c8693396",
        "86a60fee8ac66a2a",
        "887afb1e5e396043",
        "0bd963dcca97dd8a",
        "b54acf0ce94b7db5",
        "fa2a054502744288",
        "fbf48bd93298a0e7",
        "0a9ec73026b36227",
        "46ec93b2da9d6dc1",
        "498a57e8ad988bed",
        "38c63c59632027cb"
      ],
      "date": 1696276641467
    },
    {
      "id": "19c89b11f842da94",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "19c6122fb0e90655",
        "27e792d83e5d35ba",
        "124dd890c33c085a",
        "9203912a43ea9e00",
        "6be7c3dbe0e20f2d",
        "324fed3d7e173e6b",
        "f6ae85c1225c1b52",
        "677a849584d86a4b",
        "19c89b11f842da94",
        "bf7d5cfdf376d1cc",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936",
        "9fc94877330cc915",
        "7e66863c702216b5",
        "40031f2f7f1c9f42",
        "9e60c425635d0287",
        "8e666ee1f9dabafc",
        "910779249187aa37",
        "2d6119ab2b8d7cec",
        "abce4abd5900f327",
        "328579f02f943dc5",
        "a6de2c30ce90b8c1",
        "1a00c490eeb864b0",
        "4e78b9a9c8693396",
        "86a60fee8ac66a2a",
        "887afb1e5e396043",
        "0bd963dcca97dd8a",
        "b54acf0ce94b7db5",
        "fa2a054502744288",
        "fbf48bd93298a0e7",
        "0a9ec73026b36227",
        "46ec93b2da9d6dc1",
        "498a57e8ad988bed",
        "38c63c59632027cb"
      ],
      "date": 1696276644943
    },
    {
      "type": "edit",
      "id": "bf7d5cfdf376d1cc",
      "item": {
        "type": "markdown",
        "id": "bf7d5cfdf376d1cc",
        "text": "Certainly! Below is a PEG grammar for parsing Wiki Style Links:"
      },
      "date": 1696276651811
    },
    {
      "type": "add",
      "id": "75a8adfba5fb1dd6",
      "item": {
        "type": "markdown",
        "id": "75a8adfba5fb1dd6",
        "text": "```peg\nwikiLink       <- openBracket openBracket linkText closeBracket closeBracket\nopenBracket    <- '['\ncloseBracket   <- ']'\nlinkText       <- ~['[', ']', '\\n']+\n```\n\nExplanation:\n\n- `wikiLink` is the main rule that defines a Wiki Style Link.\n- `openBracket` matches the opening double square brackets `[[`.\n- `closeBracket` matches the closing double square brackets `]]`.\n- `linkText` is the text inside the double square brackets, which can include any characters except `[`, `]`, and newline.\n\nThis grammar will successfully parse Wiki Style Links in the format `[[Link Text]]`. Keep in mind that this is a basic grammar and may need to be extended or modified depending on the specific requirements of your application."
      },
      "after": "bf7d5cfdf376d1cc",
      "date": 1696276652752
    },
    {
      "id": "19c89b11f842da94",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "19c6122fb0e90655",
        "27e792d83e5d35ba",
        "124dd890c33c085a",
        "9203912a43ea9e00",
        "6be7c3dbe0e20f2d",
        "324fed3d7e173e6b",
        "f6ae85c1225c1b52",
        "677a849584d86a4b",
        "bf7d5cfdf376d1cc",
        "19c89b11f842da94",
        "75a8adfba5fb1dd6",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936",
        "9fc94877330cc915",
        "7e66863c702216b5",
        "40031f2f7f1c9f42",
        "9e60c425635d0287",
        "8e666ee1f9dabafc",
        "910779249187aa37",
        "2d6119ab2b8d7cec",
        "abce4abd5900f327",
        "328579f02f943dc5",
        "a6de2c30ce90b8c1",
        "1a00c490eeb864b0",
        "4e78b9a9c8693396",
        "86a60fee8ac66a2a",
        "887afb1e5e396043",
        "0bd963dcca97dd8a",
        "b54acf0ce94b7db5",
        "fa2a054502744288",
        "fbf48bd93298a0e7",
        "0a9ec73026b36227",
        "46ec93b2da9d6dc1",
        "498a57e8ad988bed",
        "38c63c59632027cb"
      ],
      "date": 1696276655061
    },
    {
      "type": "edit",
      "id": "75a8adfba5fb1dd6",
      "item": {
        "type": "markdown",
        "id": "75a8adfba5fb1dd6",
        "text": "Explanation:\n\n- `wikiLink` is the main rule that defines a Wiki Style Link.\n- `openBracket` matches the opening double square brackets `[[`.\n- `closeBracket` matches the closing double square brackets `]]`.\n- `linkText` is the text inside the double square brackets, which can include any characters except `[`, `]`, and newline.\n\nThis grammar will successfully parse Wiki Style Links in the format `[[Link Text]]`. Keep in mind that this is a basic grammar and may need to be extended or modified depending on the specific requirements of your application."
      },
      "date": 1696276664117
    },
    {
      "type": "edit",
      "id": "19c89b11f842da94",
      "item": {
        "type": "code",
        "id": "19c89b11f842da94",
        "text": "wikiLink       <- openBracket openBracket linkText closeBracket closeBracket\nopenBracket    <- '['\ncloseBracket   <- ']'\nlinkText       <- ~['[', ']', '\\n']+\n"
      },
      "date": 1696276672134
    },
    {
      "type": "edit",
      "id": "75a8adfba5fb1dd6",
      "item": {
        "type": "markdown",
        "id": "75a8adfba5fb1dd6",
        "text": "Explanation:\n\n- `wikiLink` is the main rule that defines a Wiki Style Link.\n- `openBracket` matches the opening double square brackets `[[`."
      },
      "date": 1696276755625
    },
    {
      "type": "add",
      "id": "adfd285abc78b536",
      "item": {
        "type": "markdown",
        "id": "adfd285abc78b536",
        "text": "- `closeBracket` matches the closing double square brackets `]]`.\n- `linkText` is the text inside the double square brackets, which can include any characters except `[`, `]`, and newline.\n\nThis grammar will successfully parse Wiki Style Links in the format `[[Link Text]]`. Keep in mind that this is a basic grammar and may need to be extended or modified depending on the specific requirements of your application."
      },
      "after": "75a8adfba5fb1dd6",
      "date": 1696276757540
    },
    {
      "type": "edit",
      "id": "75a8adfba5fb1dd6",
      "item": {
        "type": "markdown",
        "id": "75a8adfba5fb1dd6",
        "text": "Explanation:\n\n- `wikiLink` is the main rule that defines a Wiki Style Link."
      },
      "date": 1696276764573
    },
    {
      "type": "add",
      "id": "4fcb6b8fe360a62d",
      "item": {
        "type": "markdown",
        "id": "4fcb6b8fe360a62d",
        "text": "- `openBracket` matches the opening double square brackets `[[`."
      },
      "after": "75a8adfba5fb1dd6",
      "date": 1696276765963
    },
    {
      "type": "edit",
      "id": "adfd285abc78b536",
      "item": {
        "type": "markdown",
        "id": "adfd285abc78b536",
        "text": "- `closeBracket` matches the closing double square brackets `]]`."
      },
      "date": 1696276769656
    },
    {
      "type": "add",
      "id": "bbe0c9a70893eeb3",
      "item": {
        "type": "markdown",
        "id": "bbe0c9a70893eeb3",
        "text": "- `linkText` is the text inside the double square brackets, which can include any characters except `[`, `]`, and newline.\n\nThis grammar will successfully parse Wiki Style Links in the format `[[Link Text]]`. Keep in mind that this is a basic grammar and may need to be extended or modified depending on the specific requirements of your application."
      },
      "after": "adfd285abc78b536",
      "date": 1696276770476
    },
    {
      "type": "edit",
      "id": "bbe0c9a70893eeb3",
      "item": {
        "type": "markdown",
        "id": "bbe0c9a70893eeb3",
        "text": "- `linkText` is the text inside the double square brackets, which can include any characters except `[`, `]`, and newline.\n\nThis grammar will successfully parse Wiki Style Links in the format `[[Link Text]]`. Keep in mind that this is a basic grammar and may need to be extended or modified depending on the specific requirements of your application. ()"
      },
      "date": 1696276793393
    },
    {
      "type": "edit",
      "id": "bbe0c9a70893eeb3",
      "item": {
        "type": "markdown",
        "id": "bbe0c9a70893eeb3",
        "text": "- `linkText` is the text inside the double square brackets, which can include any characters except `[`, `]`, and newline.\n\nThis grammar will successfully parse Wiki Style Links in the format `[[Link Text]]`. Keep in mind that this is a basic grammar and may need to be extended or modified depending on the specific requirements of your application. (ChatGPT September 25 Version)"
      },
      "date": 1696276853142
    },
    {
      "type": "add",
      "id": "fe02c7f35a0684ff",
      "item": {
        "type": "markdown",
        "id": "fe02c7f35a0684ff",
        "text": "."
      },
      "after": "bbe0c9a70893eeb3",
      "date": 1696276866140
    },
    {
      "type": "edit",
      "id": "fe02c7f35a0684ff",
      "item": {
        "type": "markdown",
        "id": "fe02c7f35a0684ff",
        "text": "ChatGPT — Release Notes"
      },
      "date": 1696276889389
    },
    {
      "type": "edit",
      "id": "fe02c7f35a0684ff",
      "item": {
        "type": "markdown",
        "id": "fe02c7f35a0684ff",
        "text": "ChatGPT — Release Notes [https://help.openai.com/en/articles/6825453-chatgpt-release-notes page]"
      },
      "date": 1696276917948
    },
    {
      "type": "add",
      "id": "42c2e93bfaff6310",
      "item": {
        "type": "markdown",
        "id": "42c2e93bfaff6310",
        "text": "> Browse is rolling back out to Plus users (September 27, 2023)\n\nBrowse is rolling out to all Plus users. ChatGPT can now browse the internet to provide you with current and authoritative information, complete with direct links to sources. It is no longer limited to data before September 2021. "
      },
      "after": "fe02c7f35a0684ff",
      "date": 1696276986742
    },
    {
      "type": "add",
      "id": "7315cc4d8abf9658",
      "item": {
        "type": "markdown",
        "id": "7315cc4d8abf9658",
        "text": "Replace grammarString with "
      },
      "after": "bbe0c9a70893eeb3",
      "date": 1696277098038
    },
    {
      "type": "edit",
      "id": "7315cc4d8abf9658",
      "item": {
        "type": "markdown",
        "id": "7315cc4d8abf9658",
        "text": "Replace grammarString with a PEG grammar for parsing Wiki Style Links (see above)."
      },
      "date": 1696277119759
    },
    {
      "type": "edit",
      "id": "27e792d83e5d35ba",
      "item": {
        "type": "image",
        "id": "27e792d83e5d35ba",
        "text": "Exhibit the tree [[recover]]ed by the parser (Pratt, [[Top Down Operator Precedence]], p. 48.)",
        "size": "wide",
        "width": 430,
        "height": 246,
        "url": "/assets/plugins/image/2bda5af78cb9eae5b4e3e88068d23059.jpg"
      },
      "date": 1696277637835
    },
    {
      "type": "edit",
      "id": "27e792d83e5d35ba",
      "item": {
        "type": "image",
        "id": "27e792d83e5d35ba",
        "text": "Exhibit the [[Tree]] [[recover]]ed by the [[Parser]] (Pratt, [[Top Down Operator Precedence]], p. 48.)",
        "size": "wide",
        "width": 430,
        "height": 246,
        "url": "/assets/plugins/image/2bda5af78cb9eae5b4e3e88068d23059.jpg"
      },
      "date": 1696280374766
    },
    {
      "id": "7315cc4d8abf9658",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "19c6122fb0e90655",
        "27e792d83e5d35ba",
        "124dd890c33c085a",
        "9203912a43ea9e00",
        "6be7c3dbe0e20f2d",
        "324fed3d7e173e6b",
        "f6ae85c1225c1b52",
        "677a849584d86a4b",
        "7315cc4d8abf9658",
        "bf7d5cfdf376d1cc",
        "19c89b11f842da94",
        "75a8adfba5fb1dd6",
        "4fcb6b8fe360a62d",
        "adfd285abc78b536",
        "bbe0c9a70893eeb3",
        "fe02c7f35a0684ff",
        "42c2e93bfaff6310",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936",
        "9fc94877330cc915",
        "7e66863c702216b5",
        "40031f2f7f1c9f42",
        "9e60c425635d0287",
        "8e666ee1f9dabafc",
        "910779249187aa37",
        "2d6119ab2b8d7cec",
        "abce4abd5900f327",
        "328579f02f943dc5",
        "a6de2c30ce90b8c1",
        "1a00c490eeb864b0",
        "4e78b9a9c8693396",
        "86a60fee8ac66a2a",
        "887afb1e5e396043",
        "0bd963dcca97dd8a",
        "b54acf0ce94b7db5",
        "fa2a054502744288",
        "fbf48bd93298a0e7",
        "0a9ec73026b36227",
        "46ec93b2da9d6dc1",
        "498a57e8ad988bed",
        "38c63c59632027cb"
      ],
      "date": 1696280902129
    },
    {
      "id": "7315cc4d8abf9658",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "19c6122fb0e90655",
        "27e792d83e5d35ba",
        "124dd890c33c085a",
        "9203912a43ea9e00",
        "6be7c3dbe0e20f2d",
        "324fed3d7e173e6b",
        "f6ae85c1225c1b52",
        "7315cc4d8abf9658",
        "677a849584d86a4b",
        "bf7d5cfdf376d1cc",
        "19c89b11f842da94",
        "75a8adfba5fb1dd6",
        "4fcb6b8fe360a62d",
        "adfd285abc78b536",
        "bbe0c9a70893eeb3",
        "fe02c7f35a0684ff",
        "42c2e93bfaff6310",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936",
        "9fc94877330cc915",
        "7e66863c702216b5",
        "40031f2f7f1c9f42",
        "9e60c425635d0287",
        "8e666ee1f9dabafc",
        "910779249187aa37",
        "2d6119ab2b8d7cec",
        "abce4abd5900f327",
        "328579f02f943dc5",
        "a6de2c30ce90b8c1",
        "1a00c490eeb864b0",
        "4e78b9a9c8693396",
        "86a60fee8ac66a2a",
        "887afb1e5e396043",
        "0bd963dcca97dd8a",
        "b54acf0ce94b7db5",
        "fa2a054502744288",
        "fbf48bd93298a0e7",
        "0a9ec73026b36227",
        "46ec93b2da9d6dc1",
        "498a57e8ad988bed",
        "38c63c59632027cb"
      ],
      "date": 1696280907495
    },
    {
      "type": "edit",
      "id": "7315cc4d8abf9658",
      "item": {
        "type": "markdown",
        "id": "7315cc4d8abf9658",
        "text": "Replace grammarString with a PEG grammar for parsing Wiki Style Links (see above). ⇐ [[elm-peg]]"
      },
      "date": 1696280982408
    },
    {
      "type": "edit",
      "id": "7315cc4d8abf9658",
      "item": {
        "type": "markdown",
        "id": "7315cc4d8abf9658",
        "text": "Replace grammarString with a PEG grammar for parsing Wiki Style Links (see above). ⇐ [[elm-peg]]\nSupport wiki-style internal page links\n#3606"
      },
      "date": 1696284364270
    },
    {
      "type": "edit",
      "id": "7315cc4d8abf9658",
      "item": {
        "type": "markdown",
        "id": "7315cc4d8abf9658",
        "text": "Replace grammarString with a PEG grammar for parsing Wiki Style Links (see above). ⇐ [[elm-peg]]\nSupport wiki-style internal page links\n#3606 [https://github.com/gohugoio/hugo/issues/3606 github]"
      },
      "date": 1696284395858
    },
    {
      "type": "edit",
      "id": "7315cc4d8abf9658",
      "item": {
        "type": "markdown",
        "id": "7315cc4d8abf9658",
        "text": "Replace grammarString with a PEG grammar for parsing Wiki Style Links (see above). ⇐ [[elm-peg]]\n"
      },
      "date": 1696284404765
    },
    {
      "type": "add",
      "id": "8ff0697d5f38d843",
      "item": {
        "type": "paragraph",
        "id": "8ff0697d5f38d843",
        "text": "Support wiki-style internal page links\n#3606 [https://github.com/gohugoio/hugo/issues/3606 github]"
      },
      "after": "f6ae85c1225c1b52",
      "date": 1696284408303
    },
    {
      "id": "8ff0697d5f38d843",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "19c6122fb0e90655",
        "27e792d83e5d35ba",
        "124dd890c33c085a",
        "9203912a43ea9e00",
        "6be7c3dbe0e20f2d",
        "324fed3d7e173e6b",
        "f6ae85c1225c1b52",
        "7315cc4d8abf9658",
        "8ff0697d5f38d843",
        "677a849584d86a4b",
        "bf7d5cfdf376d1cc",
        "19c89b11f842da94",
        "75a8adfba5fb1dd6",
        "4fcb6b8fe360a62d",
        "adfd285abc78b536",
        "bbe0c9a70893eeb3",
        "fe02c7f35a0684ff",
        "42c2e93bfaff6310",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936",
        "9fc94877330cc915",
        "7e66863c702216b5",
        "40031f2f7f1c9f42",
        "9e60c425635d0287",
        "8e666ee1f9dabafc",
        "910779249187aa37",
        "2d6119ab2b8d7cec",
        "abce4abd5900f327",
        "328579f02f943dc5",
        "a6de2c30ce90b8c1",
        "1a00c490eeb864b0",
        "4e78b9a9c8693396",
        "86a60fee8ac66a2a",
        "887afb1e5e396043",
        "0bd963dcca97dd8a",
        "b54acf0ce94b7db5",
        "fa2a054502744288",
        "fbf48bd93298a0e7",
        "0a9ec73026b36227",
        "46ec93b2da9d6dc1",
        "498a57e8ad988bed",
        "38c63c59632027cb"
      ],
      "date": 1696284412213
    },
    {
      "type": "edit",
      "id": "8ff0697d5f38d843",
      "item": {
        "type": "paragraph",
        "id": "8ff0697d5f38d843",
        "text": "Support wiki-style internal page links\n#3606 [https://github.com/gohugoio/hugo/issues/3606 github], [https://github.com/gollum/gollum/wiki#linking-internal-pages github]"
      },
      "date": 1696284470581
    },
    {
      "type": "add",
      "id": "d923ff3bf84a6974",
      "item": {
        "type": "paragraph",
        "id": "d923ff3bf84a6974",
        "text": "Adding Actions to a PEG Grammar"
      },
      "after": "8ff0697d5f38d843",
      "date": 1696285990965
    },
    {
      "type": "edit",
      "id": "d923ff3bf84a6974",
      "item": {
        "type": "paragraph",
        "id": "d923ff3bf84a6974",
        "text": "Adding Actions to a PEG Grammar [https://medium.com/@gvanrossum_83706/adding-actions-to-a-peg-grammar-d5e00fa1092f post]"
      },
      "date": 1696286000113
    },
    {
      "type": "add",
      "id": "fe47a487da6f5504",
      "item": {
        "type": "paragraph",
        "id": "fe47a487da6f5504",
        "text": "⇒ [[Roman R. Redziejowski]] "
      },
      "after": "124dd890c33c085a",
      "date": 1696325403180
    },
    {
      "id": "e8a50218feea0b7d",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "e8a50218feea0b7d",
        "text": "Adding Actions to a PEG Grammar [https://medium.com/@gvanrossum_83706/adding-actions-to-a-peg-grammar-d5e00fa1092f post] by [[Guido van Rossum]]"
      },
      "after": "8ff0697d5f38d843",
      "attribution": {
        "page": "elm-peg"
      },
      "date": 1696325817204
    },
    {
      "type": "remove",
      "id": "d923ff3bf84a6974",
      "date": 1696325820828
    },
    {
      "item": {
        "type": "factory",
        "id": "6c055920d9a51f25"
      },
      "id": "6c055920d9a51f25",
      "type": "add",
      "after": "38c63c59632027cb",
      "date": 1696325894040
    },
    {
      "id": "6c055920d9a51f25",
      "type": "move",
      "order": [
        "1556ddc696991277",
        "316c3e89c2ee3131",
        "19c6122fb0e90655",
        "27e792d83e5d35ba",
        "124dd890c33c085a",
        "fe47a487da6f5504",
        "9203912a43ea9e00",
        "6be7c3dbe0e20f2d",
        "324fed3d7e173e6b",
        "f6ae85c1225c1b52",
        "7315cc4d8abf9658",
        "8ff0697d5f38d843",
        "e8a50218feea0b7d",
        "677a849584d86a4b",
        "bf7d5cfdf376d1cc",
        "19c89b11f842da94",
        "75a8adfba5fb1dd6",
        "4fcb6b8fe360a62d",
        "adfd285abc78b536",
        "bbe0c9a70893eeb3",
        "6c055920d9a51f25",
        "fe02c7f35a0684ff",
        "42c2e93bfaff6310",
        "bcdce6de8cc6eadf",
        "223b8d7567779211",
        "5869238fb3a87ae7",
        "3096509bfbc10005",
        "265f16c668147f89",
        "900360f4f71df140",
        "94d4df96c8ae1882",
        "e10cfa4bc6dc34f4",
        "dc1bd9bb8d414e6c",
        "273ac3e23c52bfcc",
        "f0e07f9dbc05bbb3",
        "ca2e834d7dc99b0a",
        "197a8b9483ea054e",
        "4bfba3b5a8f78e4e",
        "0291a5c4e544c936",
        "9fc94877330cc915",
        "7e66863c702216b5",
        "40031f2f7f1c9f42",
        "9e60c425635d0287",
        "8e666ee1f9dabafc",
        "910779249187aa37",
        "2d6119ab2b8d7cec",
        "abce4abd5900f327",
        "328579f02f943dc5",
        "a6de2c30ce90b8c1",
        "1a00c490eeb864b0",
        "4e78b9a9c8693396",
        "86a60fee8ac66a2a",
        "887afb1e5e396043",
        "0bd963dcca97dd8a",
        "b54acf0ce94b7db5",
        "fa2a054502744288",
        "fbf48bd93298a0e7",
        "0a9ec73026b36227",
        "46ec93b2da9d6dc1",
        "498a57e8ad988bed",
        "38c63c59632027cb"
      ],
      "date": 1696325912061
    },
    {
      "type": "edit",
      "id": "6c055920d9a51f25",
      "item": {
        "type": "paragraph",
        "id": "6c055920d9a51f25",
        "text": "PEG vs regular expression"
      },
      "date": 1696325919566
    },
    {
      "id": "cea804f4e576ebf3",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "cea804f4e576ebf3",
        "text": "⇒ [[Define a PEG Grammar]] ⇒ [[PEG Syntax and Semantics]] [https://nim-lang.org/docs/pegs.html page], PEG vs regular expression [https://nim-lang.org/docs/pegs.html#peg-syntax-and-semantics-peg-vs-regular-expression page]"
      },
      "after": "bbe0c9a70893eeb3",
      "attribution": {
        "page": "2023-10-03"
      },
      "date": 1696325923531
    },
    {
      "type": "remove",
      "id": "6c055920d9a51f25",
      "date": 1696325928286
    },
    {
      "type": "add",
      "id": "5ca32937a47c9014",
      "item": {
        "type": "paragraph",
        "id": "5ca32937a47c9014",
        "text": "> As a regular expression \\[.*\\] matches the longest possible text between '[' and ']'. As a PEG it never matches anything, because a PEG is deterministic: .* consumes the rest of the input, so \\] never matches. As a PEG this needs to be written as: \\[ ( !\\] . )* \\] (or \\[ @ \\])."
      },
      "after": "cea804f4e576ebf3",
      "date": 1696325952331
    },
    {
      "type": "edit",
      "id": "5ca32937a47c9014",
      "item": {
        "type": "markdown",
        "id": "5ca32937a47c9014",
        "text": "> As a regular expression \\[.*\\] matches the longest possible text between '[' and ']'. As a PEG it never matches anything, because a PEG is deterministic: .* consumes the rest of the input, so \\] never matches. As a PEG this needs to be written as: \\[ ( !\\] . )* \\] (or \\[ @ \\])."
      },
      "date": 1696325953463
    },
    {
      "id": "5ca32937a47c9014",
      "type": "remove",
      "removedTo": {
        "page": "2023-10-03"
      },
      "date": 1696325987495
    }
  ]
}