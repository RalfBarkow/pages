{
  "title": "Reservoir Sampling",
  "story": [
    {
      "type": "paragraph",
      "id": "46f2ed79a50c8bde",
      "text": "Reservoir sampling is a family of randomized algorithms for choosing a simple random sample, without replacement, of k items from a population of unknown size n in a single pass over the items. The size of the population n is not known to the algorithm and is typically too large for all n items to fit into main memory. The population is revealed to the algorithm over time, and the algorithm cannot look back at previous items. At any point, the current state of the algorithm must permit extraction of a simple random sample without replacement of size k over the part of the population seen so far. [https://en.wikipedia.org/wiki/Reservoir_sampling wikipedia]"
    },
    {
      "type": "pagefold",
      "id": "4b7506aa7284491d",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "e6e9ce5897fef7b7",
      "text": "Reservoir-sampling algorithms of time complexity O(n(1 + log(N/n))). [https://doi.org/10.1145/198429.198435 doi] (1994)"
    },
    {
      "type": "markdown",
      "id": "3f446c4d6fb5e65a",
      "text": "> **Abstract**. One-pass algorithms for sampling n records without replacement from a population of unknown size n are known as **reservoir-sampling algorithms**. In this article, Vitter's reservoir-sampling algorithm, algorithm Z, is modified to give a more efficient algorithm, algorithm K. Additionally, two new algorithms, algorithm L and algorithm M, are proposed. If the time for scanning the population is ignored, all the four algorithms have expected CPU time O(n(1 + log(N/n))), which is optimum up to a constant factor. Expressions of the expected CPU time for the algorithms are presented. Among the four, algorithm L is the simplest, and algorithm M is the most efficient when n and N/n are large and N is O(n2)."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Reservoir Sampling",
        "story": []
      },
      "date": 1662048894582
    },
    {
      "item": {
        "type": "factory",
        "id": "46f2ed79a50c8bde"
      },
      "id": "46f2ed79a50c8bde",
      "type": "add",
      "date": 1662048896124
    },
    {
      "type": "edit",
      "id": "46f2ed79a50c8bde",
      "item": {
        "type": "paragraph",
        "id": "46f2ed79a50c8bde",
        "text": "Reservoir sampling is a family of randomized algorithms for choosing a simple random sample, without replacement, of k items from a population of unknown size n in a single pass over the items. The size of the population n is not known to the algorithm and is typically too large for all n items to fit into main memory. The population is revealed to the algorithm over time, and the algorithm cannot look back at previous items. At any point, the current state of the algorithm must permit extraction of a simple random sample without replacement of size k over the part of the population seen so far. "
      },
      "date": 1662048897649
    },
    {
      "type": "edit",
      "id": "46f2ed79a50c8bde",
      "item": {
        "type": "paragraph",
        "id": "46f2ed79a50c8bde",
        "text": "Reservoir sampling is a family of randomized algorithms for choosing a simple random sample, without replacement, of k items from a population of unknown size n in a single pass over the items. The size of the population n is not known to the algorithm and is typically too large for all n items to fit into main memory. The population is revealed to the algorithm over time, and the algorithm cannot look back at previous items. At any point, the current state of the algorithm must permit extraction of a simple random sample without replacement of size k over the part of the population seen so far. [https://en.wikipedia.org/wiki/Reservoir_sampling wikipedia]"
      },
      "date": 1662048910215
    },
    {
      "item": {
        "type": "factory",
        "id": "4b7506aa7284491d"
      },
      "id": "4b7506aa7284491d",
      "type": "add",
      "after": "46f2ed79a50c8bde",
      "date": 1662048963398
    },
    {
      "type": "edit",
      "id": "4b7506aa7284491d",
      "item": {
        "type": "pagefold",
        "id": "4b7506aa7284491d",
        "text": "~"
      },
      "date": 1662048966601
    },
    {
      "item": {
        "type": "factory",
        "id": "e6e9ce5897fef7b7"
      },
      "id": "e6e9ce5897fef7b7",
      "type": "add",
      "after": "4b7506aa7284491d",
      "date": 1662048970110
    },
    {
      "type": "edit",
      "id": "e6e9ce5897fef7b7",
      "item": {
        "type": "paragraph",
        "id": "e6e9ce5897fef7b7",
        "text": "Reservoir-sampling algorithms of time complexity O(n(1 + log(N/n)))"
      },
      "date": 1662048973586
    },
    {
      "type": "edit",
      "id": "e6e9ce5897fef7b7",
      "item": {
        "type": "paragraph",
        "id": "e6e9ce5897fef7b7",
        "text": "Reservoir-sampling algorithms of time complexity O(n(1 + log(N/n))). [https://doi.org/10.1145/198429.198435 doi]"
      },
      "date": 1662048986124
    },
    {
      "type": "edit",
      "id": "e6e9ce5897fef7b7",
      "item": {
        "type": "paragraph",
        "id": "e6e9ce5897fef7b7",
        "text": "Reservoir-sampling algorithms of time complexity O(n(1 + log(N/n))). [https://doi.org/10.1145/198429.198435 doi] (1994)"
      },
      "date": 1662049156236
    },
    {
      "item": {
        "type": "factory",
        "id": "3f446c4d6fb5e65a"
      },
      "id": "3f446c4d6fb5e65a",
      "type": "add",
      "after": "e6e9ce5897fef7b7",
      "date": 1662049167662
    },
    {
      "type": "edit",
      "id": "3f446c4d6fb5e65a",
      "item": {
        "type": "markdown",
        "id": "3f446c4d6fb5e65a",
        "text": "> **Abstract**. One-pass algorithms for sampling n records without replacement from a population of unknown size n are known as reservoir-sampling algorithms. In this article, Vitter's reservoir-sampling algorithm, algorithm Z, is modified to give a more efficient algorithm, algorithm K. Additionally, two new algorithms, algorithm L and algorithm M, are proposed. If the time for scanning the population is ignored, all the four algorithms have expected CPU time O(n(1 + log(N/n))), which is optimum up to a constant factor. Expressions of the expected CPU time for the algorithms are presented. Among the four, algorithm L is the simplest, and algorithm M is the most efficient when n and N/n are large and N is O(n2)."
      },
      "date": 1662049181733
    },
    {
      "type": "edit",
      "id": "3f446c4d6fb5e65a",
      "item": {
        "type": "markdown",
        "id": "3f446c4d6fb5e65a",
        "text": "> **Abstract**. One-pass algorithms for sampling n records without replacement from a population of unknown size n are known as ***reservoir-sampling algorithms**. In this article, Vitter's reservoir-sampling algorithm, algorithm Z, is modified to give a more efficient algorithm, algorithm K. Additionally, two new algorithms, algorithm L and algorithm M, are proposed. If the time for scanning the population is ignored, all the four algorithms have expected CPU time O(n(1 + log(N/n))), which is optimum up to a constant factor. Expressions of the expected CPU time for the algorithms are presented. Among the four, algorithm L is the simplest, and algorithm M is the most efficient when n and N/n are large and N is O(n2)."
      },
      "date": 1662049199883
    },
    {
      "type": "edit",
      "id": "3f446c4d6fb5e65a",
      "item": {
        "type": "markdown",
        "id": "3f446c4d6fb5e65a",
        "text": "> **Abstract**. One-pass algorithms for sampling n records without replacement from a population of unknown size n are known as **reservoir-sampling algorithms**. In this article, Vitter's reservoir-sampling algorithm, algorithm Z, is modified to give a more efficient algorithm, algorithm K. Additionally, two new algorithms, algorithm L and algorithm M, are proposed. If the time for scanning the population is ignored, all the four algorithms have expected CPU time O(n(1 + log(N/n))), which is optimum up to a constant factor. Expressions of the expected CPU time for the algorithms are presented. Among the four, algorithm L is the simplest, and algorithm M is the most efficient when n and N/n are large and N is O(n2)."
      },
      "date": 1662049205093
    }
  ]
}