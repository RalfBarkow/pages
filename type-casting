{
  "title": "Type casting",
  "story": [
    {
      "type": "paragraph",
      "id": "e5e5ad0903d8c2e3",
      "text": "There are only a hand full of types in JavaScript. Many operations implicitly convert one of the few types into another, in ways that can be unpredictable. One way to handle that uncertainty is to learn every single possible rule and combination, another is to convert the types explicitly on our own, so we don't get surprised. We call that conversion type casting, and it helps us avoid type confusion, which is one of the [[JavaScript Common Pitfalls]]."
    },
    {
      "type": "paragraph",
      "id": "fa1f9d02ffe54572",
      "text": "We're going to concentrate on converting to strings and numbers, since they seem to come up the most often."
    },
    {
      "type": "paragraph",
      "id": "d1074a1cc58a70f0",
      "text": "There are a handful of reliable ways to convert to a string. Concatenating with an existing string, calling the `String` constructor function (without new) on an item, calling .toString (on items that exist), and for a slightly different string representation, JSON.stringify."
    },
    {
      "type": "code",
      "id": "401cf87b644c2760",
      "text": "var manyTypes =\n  [ undefined\n  , null\n  , 1\n  , 'Foo'\n  , {a:'b'}\n  , ['c', 'd']\n  , /a/\n  , function () {}\n  , new Date()\n  ]\n\nvar conversions = manyTypes.map(function (a) {\n  return (\n    [ ''+a\n    , String(a)\n    , a ? a.toString() : 'N/A'\n    , JSON.stringify(a)\n    ]\n  )\n})\n\nconsole.log(conversions)"
    },
    {
      "type": "paragraph",
      "id": "0736fcb87e4442ab",
      "text": "Which gives us the output:"
    },
    {
      "type": "code",
      "id": "a1a88bb215b1eae9",
      "text": "[ [ 'undefined', 'undefined', 'N/A', undefined ],\n  [ 'null', 'null', 'N/A', 'null' ],\n  [ '1', '1', '1', '1' ],\n  [ 'Foo', 'Foo', 'Foo', '\"Foo\"' ],\n  [ '[object Object]',\n    '[object Object]',\n    '[object Object]',\n    '{\"a\":\"b\"}' ],\n  [ 'c,d', 'c,d', 'c,d', '[\"c\",\"d\"]' ],\n  [ '/a/', '/a/', '/a/', '{}' ],\n  [ 'function () {}',\n    'function () {}',\n    'function () {}',\n    undefined ],\n  [ 'Fri May 29 2015 22:43:53 GMT-0700 (PDT)',\n    'Fri May 29 2015 22:43:53 GMT-0700 (PDT)',\n    'Fri May 29 2015 22:43:53 GMT-0700 (PDT)',\n    '\"2015-05-30T05:43:53.206Z\"' ] ]"
    },
    {
      "type": "paragraph",
      "id": "1f945930018b4199",
      "text": "The first three always give us the same output, except we can't directly call .toString from null or undefined. JSON.stringify gives us interesting results for the object, but it doesn't actually give us a string for undefined or the function, instead returning undefined! So, if we don't know what we're getting in, and we want to be sure it's a string going out, concat it with an exiting string (or empty string literal), or call the String function on it. Just remember not to use new String, that does something similar, but broken."
    },
    {
      "type": "paragraph",
      "id": "47a09d63a063d056",
      "text": "Infact, to avoid that, stick with the ''+wantsToBeAString. On to numbers."
    },
    {
      "type": "code",
      "id": "983b3429e60b61a8",
      "text": "var manyTypes =\n  [ null\n  , true\n  , 1000\n  , '999aaa'\n  , '1234'\n  , new Date()\n  ]\n\nvar conversions = manyTypes.map(function (a) {\n  return (\n    [ +a\n    , Number(a)\n    , parseFloat(a)\n    , a ? a.valueOf() : 'N/A'\n    ]\n  )\n})\n\nconsole.log(conversions)\n"
    },
    {
      "type": "paragraph",
      "id": "40fbd2bfac102448",
      "text": "Which results in:"
    },
    {
      "type": "code",
      "id": "dc88d982e58ec7c5",
      "text": "[ [ 0, 0, NaN, 'N/A' ],\n  [ 1, 1, NaN, true ],\n  [ 1000, 1000, 1000, 1000 ],\n  [ NaN, NaN, 999, '999aaa' ],\n  [ 1234, 1234, 1234, '1234' ],\n  [ 1432965276619, 1432965276619, NaN, 1432965276619 ] ]"
    },
    {
      "type": "paragraph",
      "id": "988cbaac8eecc567",
      "text": "This is a much sadder looking set of results. At least the unary `+` operator and the Number function give us the same results, and they are all numbers (yes, NaN is a number). parseFloat also gives us all numbers, and it makes better sense of the string that is letters followed by numbers, but it fails at null, true, and the date object. .valueOf is intended to give us the value of an object, and is what gets called on objects for math operations. But it doesn't work well with most of samples other than Date."
    },
    {
      "type": "paragraph",
      "id": "a999e8f61c8df0a0",
      "text": "So it really comes down to the unary +, and parseFloat. If you want to convert strings that start with numbers and then may do something else, use parseFloat, but if you want to get nonNaN answers for oddball values (0 for falsey, 1 for truthy, etc) stick with the unary +."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Type casting",
        "story": []
      },
      "date": 1432959527630
    },
    {
      "item": {
        "type": "factory",
        "id": "e5e5ad0903d8c2e3"
      },
      "id": "e5e5ad0903d8c2e3",
      "type": "add",
      "date": 1432959529045
    },
    {
      "type": "edit",
      "id": "e5e5ad0903d8c2e3",
      "item": {
        "type": "paragraph",
        "id": "e5e5ad0903d8c2e3",
        "text": "There are only a hand full of types in JavaScript. Many operations implicitly convert one of the few types into another, in ways that can be unpredictable. One way to handle that uncertainty is to learn every single possible rule and combination, another is to convert the types explicitly on our own, so we don't get surprised. We call that conversion type casting, and it helps us avoid type confusion, which is one of the [[JavaScript Common Pitfalls]]."
      },
      "date": 1432960116186
    },
    {
      "item": {
        "type": "factory",
        "id": "fa1f9d02ffe54572"
      },
      "id": "fa1f9d02ffe54572",
      "type": "add",
      "after": "e5e5ad0903d8c2e3",
      "date": 1432960152286
    },
    {
      "type": "edit",
      "id": "fa1f9d02ffe54572",
      "item": {
        "type": "paragraph",
        "id": "fa1f9d02ffe54572",
        "text": "We're going to concentrate on converting to strings and numbers, since they seem to come up the most often."
      },
      "date": 1432960292542
    },
    {
      "item": {
        "type": "factory",
        "id": "d1074a1cc58a70f0"
      },
      "id": "d1074a1cc58a70f0",
      "type": "add",
      "after": "fa1f9d02ffe54572",
      "date": 1432964345549
    },
    {
      "type": "edit",
      "id": "d1074a1cc58a70f0",
      "item": {
        "type": "paragraph",
        "id": "d1074a1cc58a70f0",
        "text": "There are a handful of reliable ways to convert to a string. Concatenating with an existing string, calling the `String` constructor function (without new) on an item, calling .toString (on items that exist), and for a slightly different string representation, JSON.stringify."
      },
      "date": 1432964466063
    },
    {
      "item": {
        "type": "factory",
        "id": "401cf87b644c2760"
      },
      "id": "401cf87b644c2760",
      "type": "add",
      "after": "d1074a1cc58a70f0",
      "date": 1432964467504
    },
    {
      "type": "edit",
      "id": "401cf87b644c2760",
      "item": {
        "type": "code",
        "id": "401cf87b644c2760",
        "text": "var manyTypes = [ undefined, null, 1, 'Foo', {a:'b'}, ['c', 'd'], /a/, function () {}, new Date()]\n\nvar conversions = manyTypes.map(function (a) { return [ ''+a, String(a), a ? a.toString() : 'N/A', JSON.stringify(a)] })\n\nconsole.log(conversions)"
      },
      "date": 1432964476752
    },
    {
      "type": "edit",
      "id": "401cf87b644c2760",
      "item": {
        "type": "code",
        "id": "401cf87b644c2760",
        "text": "var manyTypes =\n  [ undefined\n  , null\n  , 1\n  , 'Foo'\n  , {a:'b'}\n  , ['c', 'd']\n  , /a/\n  , function () {}\n  , new Date()\n  ]\n\nvar conversions = m"
      },
      "date": 1432964575209
    },
    {
      "type": "edit",
      "id": "401cf87b644c2760",
      "item": {
        "type": "code",
        "id": "401cf87b644c2760",
        "text": "var manyTypes =\n  [ undefined\n  , null\n  , 1\n  , 'Foo'\n  , {a:'b'}\n  , ['c', 'd']\n  , /a/\n  , function () {}\n  , new Date()\n  ]\n\nvar conversions = manyTypes.map(function (a) {\n  return (\n    [ ''+a\n    , String(a)\n    , a ? a.toString() : 'N/A'\n    , JSON.stringify(a)\n    ]\n})\n\nconsole.log(conversions)"
      },
      "date": 1432964590962
    },
    {
      "item": {
        "type": "factory",
        "id": "0736fcb87e4442ab"
      },
      "id": "0736fcb87e4442ab",
      "type": "add",
      "after": "401cf87b644c2760",
      "date": 1432964598174
    },
    {
      "type": "edit",
      "id": "0736fcb87e4442ab",
      "item": {
        "type": "paragraph",
        "id": "0736fcb87e4442ab",
        "text": "Which gives us the output:"
      },
      "date": 1432964607865
    },
    {
      "item": {
        "type": "factory",
        "id": "a1a88bb215b1eae9"
      },
      "id": "a1a88bb215b1eae9",
      "type": "add",
      "after": "0736fcb87e4442ab",
      "date": 1432964649415
    },
    {
      "type": "edit",
      "id": "a1a88bb215b1eae9",
      "item": {
        "type": "code",
        "id": "a1a88bb215b1eae9",
        "text": "[ [ 'undefined', 'undefined', 'N/A', undefined ],\n  [ 'null', 'null', 'N/A', 'null' ],\n  [ '1', '1', '1', '1' ],\n  [ 'Foo', 'Foo', 'Foo', '\"Foo\"' ],\n  [ '[object Object]',\n    '[object Object]',\n    '[object Object]',\n    '{\"a\":\"b\"}' ],\n  [ 'c,d', 'c,d', 'c,d', '[\"c\",\"d\"]' ],\n  [ '/a/', '/a/', '/a/', '{}' ],\n  [ 'function () {}',\n    'function () {}',\n    'function () {}',\n    undefined ],\n  [ 'Fri May 29 2015 22:43:53 GMT-0700 (PDT)',\n    'Fri May 29 2015 22:43:53 GMT-0700 (PDT)',\n    'Fri May 29 2015 22:43:53 GMT-0700 (PDT)',\n    '\"2015-05-30T05:43:53.206Z\"' ] ]"
      },
      "date": 1432964655242
    },
    {
      "item": {
        "type": "factory",
        "id": "1f945930018b4199"
      },
      "id": "1f945930018b4199",
      "type": "add",
      "after": "a1a88bb215b1eae9",
      "date": 1432964678082
    },
    {
      "type": "edit",
      "id": "1f945930018b4199",
      "item": {
        "type": "paragraph",
        "id": "1f945930018b4199",
        "text": "The first three always give us the same output, except we can't directly call .toString from null or undefined. JSON.stringify gives us interesting results for the object, but it doesn't actually give us a string for undefined or the function, instead returning undefined! So, if we don't know what we're getting in, and we want to be sure it's a string going out, concat it with an exiting string (or empty string literal), or call the String function on it. Just remember not to use new String, that does something similar, but broken."
      },
      "date": 1432964909286
    },
    {
      "type": "add",
      "id": "47a09d63a063d056",
      "item": {
        "type": "paragraph",
        "id": "47a09d63a063d056",
        "text": "Infact, to avoid that, stick with the ''+wantsToBeAString."
      },
      "after": "1f945930018b4199",
      "date": 1432964940028
    },
    {
      "type": "edit",
      "id": "47a09d63a063d056",
      "item": {
        "type": "paragraph",
        "id": "47a09d63a063d056",
        "text": "Infact, to avoid that, stick with the ''+wantsToBeAString. On to numbers."
      },
      "date": 1432965614973
    },
    {
      "item": {
        "type": "factory",
        "id": "983b3429e60b61a8"
      },
      "id": "983b3429e60b61a8",
      "type": "add",
      "after": "47a09d63a063d056",
      "date": 1432965617712
    },
    {
      "type": "edit",
      "id": "983b3429e60b61a8",
      "item": {
        "type": "code",
        "id": "983b3429e60b61a8",
        "text": "var manyTypes =\n  [ null\n  , true\n  , 1000\n  , '999aaa'\n  , '1234'\n  , new Date()\n  ]\n\nvar conversions = manyTypes.map(function (a) {\n  return (\n    [ +a\n    , Number(a)\n    , parseFloat(a)\n    , a ? a.valueOf() : 'N/A'\n    ]\n  )\n})\n\nconsole.log(conversions)\n"
      },
      "date": 1432965626826
    },
    {
      "item": {
        "type": "factory",
        "id": "40fbd2bfac102448"
      },
      "id": "40fbd2bfac102448",
      "type": "add",
      "after": "983b3429e60b61a8",
      "date": 1432965631026
    },
    {
      "type": "edit",
      "id": "40fbd2bfac102448",
      "item": {
        "type": "paragraph",
        "id": "40fbd2bfac102448",
        "text": "Which results in:"
      },
      "date": 1432965642140
    },
    {
      "item": {
        "type": "factory",
        "id": "dc88d982e58ec7c5"
      },
      "id": "dc88d982e58ec7c5",
      "type": "add",
      "after": "40fbd2bfac102448",
      "date": 1432965655516
    },
    {
      "type": "edit",
      "id": "dc88d982e58ec7c5",
      "item": {
        "type": "code",
        "id": "dc88d982e58ec7c5",
        "text": "[ [ 0, 0, NaN, 'N/A' ],\n  [ 1, 1, NaN, true ],\n  [ 1000, 1000, 1000, 1000 ],\n  [ NaN, NaN, 999, '999aaa' ],\n  [ 1234, 1234, 1234, '1234' ],\n  [ 1432965276619, 1432965276619, NaN, 1432965276619 ] ]"
      },
      "date": 1432965671641
    },
    {
      "item": {
        "type": "factory",
        "id": "988cbaac8eecc567"
      },
      "id": "988cbaac8eecc567",
      "type": "add",
      "after": "dc88d982e58ec7c5",
      "date": 1432965715204
    },
    {
      "type": "edit",
      "id": "988cbaac8eecc567",
      "item": {
        "type": "paragraph",
        "id": "988cbaac8eecc567",
        "text": "This is a much sadder looking set of results. At least the unary `+` operator and the Number function give us the same results, and they are all numbers (yes, NaN is a number). parseFloat also gives us all numbers, and it makes better sense of the string that is letters followed by numbers, but it fails at null, true, and the date object. .valueOf is intended to give us the value of an object, and is what gets called on objects for math operations. But it doesn't work well with most of samples other than Date."
      },
      "date": 1432966083939
    },
    {
      "type": "add",
      "id": "a999e8f61c8df0a0",
      "item": {
        "type": "paragraph",
        "id": "a999e8f61c8df0a0",
        "text": "So it really comes down to the unary +, and parseFloat. If you want to convert strings that start with numbers and then may do something else, use parseFloat, but if you want to get nonNaN answers for oddball values (0 for falsey, 1 for truthy, etc) stick with the unary +."
      },
      "after": "988cbaac8eecc567",
      "date": 1432966198256
    },
    {
      "type": "add",
      "id": "e2b09a04de128933",
      "item": {
        "type": "paragraph",
        "id": "e2b09a04de128933",
        "text": "parseFloat has a hidden talent/hidden gotcha, the second argument is the radix (defaults to the expected 10). If you pass it as an iterator to an array it gets the index as the second argument, and does crazy things."
      },
      "after": "a999e8f61c8df0a0",
      "date": 1432966274060
    },
    {
      "type": "add",
      "id": "75fbef46bad1c289",
      "item": {
        "type": "paragraph",
        "id": "75fbef46bad1c289",
        "text": "unary + also has a hidden gotcha, if it starts a line after a line that doesn't end in a semicolon it will be interpreted as a binary plus, and add the thing you were trying to convert to a number with the last expression of the line before."
      },
      "after": "e2b09a04de128933",
      "date": 1432966375272
    },
    {
      "type": "remove",
      "id": "e2b09a04de128933",
      "date": 1432966528726
    },
    {
      "type": "remove",
      "id": "75fbef46bad1c289",
      "date": 1432966545637
    },
    {
      "item": {
        "type": "factory",
        "id": "389196d5136c1858"
      },
      "id": "389196d5136c1858",
      "type": "add",
      "after": "a999e8f61c8df0a0",
      "date": 1432966614728
    },
    {
      "type": "remove",
      "id": "389196d5136c1858",
      "date": 1432966618952
    },
    {
      "type": "edit",
      "id": "401cf87b644c2760",
      "item": {
        "type": "code",
        "id": "401cf87b644c2760",
        "text": "var manyTypes =\n  [ undefined\n  , null\n  , 1\n  , 'Foo'\n  , {a:'b'}\n  , ['c', 'd']\n  , /a/\n  , function () {}\n  , new Date()\n  ]\n\nvar conversions = manyTypes.map(function (a) {\n  return (\n    [ ''+a\n    , String(a)\n    , a ? a.toString() : 'N/A'\n    , JSON.stringify(a)\n    ]\n  )\n})\n\nconsole.log(conversions)"
      },
      "date": 1432966696978
    },
    {
      "type": "fork",
      "site": "nrn.io",
      "date": 1652868564846
    }
  ]
}