{
  "title": "Circular dependencies",
  "story": [
    {
      "type": "paragraph",
      "id": "109212e7a7068caf",
      "text": "Circular dependencies don't work. Well, kinda they do. But not really. Inherently if a is defined in terms of b, b can't be defined in terms of a, but if that's not quite the relationship of of your cycle, you might make it (scarily) work."
    },
    {
      "type": "code",
      "id": "c65d8010d7fa28c2",
      "text": "// Module a\nvar b = require('./circular-b-1')\n\nmodule.exports = 2 + b"
    },
    {
      "type": "code",
      "id": "dd448b579ae84c15",
      "text": "// Module b\nvar a = require('./circular-a-1')\n\nmodule.exports = a + 1\n\nconsole.log(module.exports)"
    },
    {
      "type": "paragraph",
      "id": "ab30b43d7ed0d8a4",
      "text": "When we run module b we get \"2[object Object]1\", which seems like a peculiar answer. What happens is we start executing module b, we get to the require statement, so we switch over to executing module a. We get to the require statement, but since a is already started, and requires only execute once and then share the result, the default (empty) exported object is available."
    },
    {
      "type": "paragraph",
      "id": "bacfd6e77638f87f",
      "text": "JavaScript naturally adds 2 to the empty object, forming \"2[object Object]\" which is now available as the a module to b. b resumes execution, tacking a '1' onto the end of our mess before we log it."
    },
    {
      "type": "paragraph",
      "id": "8c189030df438803",
      "text": "So keep your module dependency tree a tree, and don't let cycles of requires develop. And keep the odd failure mode in mind so it doesn't take you forever to debug if you do get your shoelaces tied together."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Circular dependencies",
        "story": []
      },
      "date": 1431583483615
    },
    {
      "item": {
        "type": "factory",
        "id": "109212e7a7068caf"
      },
      "id": "109212e7a7068caf",
      "type": "add",
      "date": 1431583489443
    },
    {
      "type": "edit",
      "id": "109212e7a7068caf",
      "item": {
        "type": "paragraph",
        "id": "109212e7a7068caf",
        "text": "Circular dependencies don't work. Well, kinda they do. But not really. Inherently if a is defined in terms of b, b can't be defined in terms of a, but if that's not quite the relationship of of your cycle, you might make it (scarily) work."
      },
      "date": 1431583671443
    },
    {
      "type": "edit",
      "id": "47e6a5cc8cf39d34",
      "item": {
        "type": "code",
        "id": "47e6a5cc8cf39d34",
        "text": "// Module a\nvar b = require('./circular-b-1')\n\nmodule.exports = 2 + b"
      },
      "date": 1431583855178
    },
    {
      "item": {
        "type": "factory",
        "id": "dd448b579ae84c15"
      },
      "id": "dd448b579ae84c15",
      "type": "add",
      "after": "47e6a5cc8cf39d34",
      "date": 1431583860348
    },
    {
      "type": "move",
      "order": [
        "109212e7a7068caf",
        "dd448b579ae84c15"
      ],
      "id": "dd448b579ae84c15",
      "date": 1431583921023
    },
    {
      "type": "edit",
      "id": "dd448b579ae84c15",
      "item": {
        "type": "code",
        "id": "dd448b579ae84c15",
        "text": "// Module b\nvar a = require('./circular-a-1')\n\nmodule.exports = a + 1\n\nconsole.log(module.exports)"
      },
      "date": 1431583933404
    },
    {
      "item": {
        "type": "factory",
        "id": "c65d8010d7fa28c2"
      },
      "id": "c65d8010d7fa28c2",
      "type": "add",
      "after": "dd448b579ae84c15",
      "date": 1431583935941
    },
    {
      "type": "edit",
      "id": "c65d8010d7fa28c2",
      "item": {
        "type": "code",
        "id": "c65d8010d7fa28c2",
        "text": "// Module a\nvar b = require('./circular-b-1')\n\nmodule.exports = 2 + b"
      },
      "date": 1431583955634
    },
    {
      "type": "move",
      "order": [
        "109212e7a7068caf",
        "c65d8010d7fa28c2",
        "dd448b579ae84c15"
      ],
      "id": "c65d8010d7fa28c2",
      "date": 1431583959949
    },
    {
      "item": {
        "type": "factory",
        "id": "ab30b43d7ed0d8a4"
      },
      "id": "ab30b43d7ed0d8a4",
      "type": "add",
      "after": "dd448b579ae84c15",
      "date": 1431583986269
    },
    {
      "type": "edit",
      "id": "ab30b43d7ed0d8a4",
      "item": {
        "type": "paragraph",
        "id": "ab30b43d7ed0d8a4",
        "text": "When we run module b we get \"2[object Object]1\", which seems like a peculiar answer. What happens is we start executing module b, we get to the require statement, so we switch over to executing module a. We get to the require statement, but since a is already started, and requires only execute once and then share the result, the default (empty) exported object is available."
      },
      "date": 1431584145509
    },
    {
      "type": "add",
      "id": "bacfd6e77638f87f",
      "item": {
        "type": "paragraph",
        "id": "bacfd6e77638f87f",
        "text": "JavaScript naturally adds 2 to the empty object, forming \"2[object Object]\" which is now available as the a module to b. b resumes execution, tacking a '1' onto the end of our mess before we log it."
      },
      "after": "ab30b43d7ed0d8a4",
      "date": 1431584277845
    },
    {
      "item": {
        "type": "factory",
        "id": "8c189030df438803"
      },
      "id": "8c189030df438803",
      "type": "add",
      "after": "bacfd6e77638f87f",
      "date": 1431584336191
    },
    {
      "type": "edit",
      "id": "8c189030df438803",
      "item": {
        "type": "paragraph",
        "id": "8c189030df438803",
        "text": "The straight forward way out of this is to make sure to keep your module dependencies a tree, and don't let cycles of requires develop. If the dependancies are both hard, synchronous, dependencies it won't work out no matter what. But, modules can change what they export over time! So if a has a synchronous dependency on b, but b only has an asynchronous dependency on a, we may be saved."
      },
      "date": 1431584607155
    },
    {
      "type": "edit",
      "id": "8c189030df438803",
      "item": {
        "type": "paragraph",
        "id": "8c189030df438803",
        "text": "So keep your module dependency tree a tree, and don't let cycles of requires develop. And keep the odd failure mode in mind so it doesn't take you forever to debug if you do get your shoelaces tied together."
      },
      "date": 1431619630449
    },
    {
      "type": "fork",
      "site": "nrn.io",
      "date": 1652868512207
    }
  ]
}