{
  "title": "Outline of a Shape",
  "story": [
    {
      "type": "paragraph",
      "id": "886ab8059189ee58",
      "text": "The algorithm for drawing the Outline of a Shape is as follows:"
    },
    {
      "type": "paragraph",
      "id": "e7dcc3ede36b2488",
      "text": "1) The Destination starts filled with whatever background we need to draw on top of. The distance buffer is assumed to be initially filled with 'infinite' (in practice, any sufficiently large value will do)."
    },
    {
      "type": "paragraph",
      "id": "516c2f998af19c85",
      "text": "2) The algorithm continues by following the [[Trajectory]] specified by the outline. This is done in discrete steps or jumps. At each step, the pen is moved to a new point in the trajectory, jumping by a fraction of a pixel. A step of about 1/4 of a pixel is small enough. This is done using float (or fixed point) arithmetic."
    },
    {
      "type": "paragraph",
      "id": "f9677b175b39587c",
      "text": "3) For each step, the pen is at some (float) point. The possibly affected pixels are in the circle defined by the pen outer diameter (w+r). For each of these pixels, the [[Euclidean Distance]] from the pixel center to the pen center is computed. This distance is stored in the distance buffer if it is less that the value already there."
    },
    {
      "type": "paragraph",
      "id": "9ad06aa83dd5b16a",
      "text": "4) When the pen has finished following the prescribed trajectory, the distance buffer contains, for each pixel, the minimum distance d to the trajectory. The opacity value is obtained by evaluating the opacity function of the filtering pen at distance d. This opacity value is used to alpha-blend the shape color over the destination frame buffer. Afterwards, the distance buffer is filled with infinite, to be ready for the next call."
    },
    {
      "type": "paragraph",
      "id": "da423ce3dbf2014d",
      "text": "[…] Figure 5. Each pixel is painted with the opacity obtained by taking its distance to the path, and using it as the argument to the prefiltering pen function. To illustrate, for some pixels, the small black arrows show this distance to the path. As a further example, for the two arrows closest to the bottom of the figure, the distance is projected (dashed lines) over the filtering pen function, to show how to obtain the opacity values used to paint the pixels. The same procedure is used for all pixels."
    },
    {
      "type": "pagefold",
      "id": "d4a2b60529da7b9a",
      "text": "chat.openai"
    },
    {
      "type": "paragraph",
      "id": "9254d6afffa54b8f",
      "text": "Here's a possible implementation of the algorithm in JavaScript:"
    },
    {
      "type": "code",
      "id": "86466e65b19d892c",
      "text": "function drawOutline(destination, trajectory, penOuterDiameter, filteringPen) {\n  const width = destination.width;\n  const height = destination.height;\n  const distanceBuffer = [];\n  for (let i = 0; i < width * height; i++) {\n    distanceBuffer[i] = Number.POSITIVE_INFINITY;\n  }\n\n  for (let i = 0; i < trajectory.length - 1; i++) {\n    const start = trajectory[i];\n    const end = trajectory[i + 1];\n    const step = (end - start) / 4;\n    let current = start;\n    while (current <= end) {\n      const x = Math.round(current.x);\n      const y = Math.round(current.y);\n      const r = penOuterDiameter / 2;\n      for (let i = Math.max(0, x - r); i <= Math.min(width - 1, x + r); i++) {\n        for (let j = Math.max(0, y - r); j <= Math.min(height - 1, y + r); j++) {\n          const distance = Math.sqrt((i - x) ** 2 + (j - y) ** 2);\n          if (distance < distanceBuffer[i + j * width]) {\n            distanceBuffer[i + j * width] = distance;\n          }\n        }\n      }\n      current = current.add(step);\n    }\n\n  for (let i = 0; i < width * height; i++) {\n    const x = i % width;\n    const y = Math.floor(i / width);\n    const opacity = filteringPen(distanceBuffer[i]);\n    const index = (x + y * width) * 4;\n    destination.data[index + 3] = opacity * 255;\n  }\n}\n"
    },
    {
      "type": "pagefold",
      "id": "f9aed2a4fcaf415e",
      "text": "~"
    },
    {
      "type": "reference",
      "id": "9058e6f8f9b26414",
      "site": "wiki.ralfbarkow.ch",
      "slug": "juan-manuel-vuletich",
      "title": "Juan Manuel Vuletich",
      "text": "[[Juan Manuel Vuletich]]"
    },
    {
      "type": "reference",
      "id": "adbefba538ecc557",
      "site": "wiki.ralfbarkow.ch",
      "slug": "prefiltering-antialiasing-for-general-vector-graphics",
      "title": "Prefiltering Antialiasing for General Vector Graphics",
      "text": "The graphics engines commonly used to draw vector graphics apply the antialiasing technique known as [[Pixel Coverage]]."
    },
    {
      "type": "reference",
      "id": "ec64835ec5f3d8bb",
      "site": "ward.dojo.fed.wiki",
      "slug": "generate-a-rectangular-grid",
      "title": "Generate a Rectangular Grid",
      "text": "[[kohonen-stars]] [https://github.com/seracio/kohonen-stars github] is an example for our library kohonen [https://github.com/seracio/kohonen github], a basic implementation of [[SOM]] algorithm in JavaScript."
    },
    {
      "type": "assets",
      "id": "715582819f359baa",
      "text": "pages/outline-of-a-shape"
    },
    {
      "type": "frame",
      "id": "c0b60a50f1beb36f",
      "text": "//wiki.ralfbarkow.ch/assets/pages/outline-of-a-shape/outline.html\nHEIGHT 333"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Outline of a Shape",
        "story": []
      },
      "date": 1675342954814
    },
    {
      "id": "886ab8059189ee58",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "886ab8059189ee58",
        "text": "The algorithm for drawing the Outline of a Shape is as follows:"
      },
      "date": 1675342958738
    },
    {
      "item": {
        "type": "factory",
        "id": "e7dcc3ede36b2488"
      },
      "id": "e7dcc3ede36b2488",
      "type": "add",
      "after": "886ab8059189ee58",
      "date": 1675343024198
    },
    {
      "type": "edit",
      "id": "e7dcc3ede36b2488",
      "item": {
        "type": "paragraph",
        "id": "e7dcc3ede36b2488",
        "text": "1) The Destination starts filled with whatever background we need to draw on top of. The distance buffer is assumed to be initially filled with 'infinite' (in practice, any sufficiently large value will do)."
      },
      "date": 1675343026322
    },
    {
      "item": {
        "type": "factory",
        "id": "516c2f998af19c85"
      },
      "id": "516c2f998af19c85",
      "type": "add",
      "after": "e7dcc3ede36b2488",
      "date": 1675343032780
    },
    {
      "type": "edit",
      "id": "516c2f998af19c85",
      "item": {
        "type": "paragraph",
        "id": "516c2f998af19c85",
        "text": "2) The algorithm continues by following the trajectory specified by the outline. This is done in discrete steps or jumps. At each step, the pen is moved to a new point in the trajectory, jumping by a fraction of a pixel. A step of about 1/4 of a pixel is small enough. This is done using float (or fixed point) arithmetic."
      },
      "date": 1675343035231
    },
    {
      "item": {
        "type": "factory",
        "id": "f9677b175b39587c"
      },
      "id": "f9677b175b39587c",
      "type": "add",
      "after": "516c2f998af19c85",
      "date": 1675343046308
    },
    {
      "type": "edit",
      "id": "f9677b175b39587c",
      "item": {
        "type": "paragraph",
        "id": "f9677b175b39587c",
        "text": "3) For each step, the pen is at some (float) point. The possibly affected pixels are in the circle defined by the pen outer diameter (w+r). For each of these pixels, the euclidean distance from the pixel center to the pen center is computed. This distance is stored in the distance buffer if it is less that the value already there."
      },
      "date": 1675343048080
    },
    {
      "item": {
        "type": "factory",
        "id": "9ad06aa83dd5b16a"
      },
      "id": "9ad06aa83dd5b16a",
      "type": "add",
      "after": "f9677b175b39587c",
      "date": 1675343057436
    },
    {
      "type": "edit",
      "id": "9ad06aa83dd5b16a",
      "item": {
        "type": "paragraph",
        "id": "9ad06aa83dd5b16a",
        "text": "4) When the pen has finished following the prescribed trajectory, the distance buffer contains, for each pixel, the minimum distance d to the trajectory. The opacity value is obtained by evaluating the opacity function of the filtering pen at distance d. This opacity value is used to alpha-blend the shape color over the destination frame buffer. Afterwards, the distance buffer is filled with infinite, to be ready for the next call."
      },
      "date": 1675343059025
    },
    {
      "type": "edit",
      "id": "516c2f998af19c85",
      "item": {
        "type": "paragraph",
        "id": "516c2f998af19c85",
        "text": "2) The algorithm continues by following the [[Trajectory]] specified by the outline. This is done in discrete steps or jumps. At each step, the pen is moved to a new point in the trajectory, jumping by a fraction of a pixel. A step of about 1/4 of a pixel is small enough. This is done using float (or fixed point) arithmetic."
      },
      "date": 1675343087987
    },
    {
      "type": "edit",
      "id": "f9677b175b39587c",
      "item": {
        "type": "paragraph",
        "id": "f9677b175b39587c",
        "text": "3) For each step, the pen is at some (float) point. The possibly affected pixels are in the circle defined by the pen outer diameter (w+r). For each of these pixels, the [[Euclidean Distance]] from the pixel center to the pen center is computed. This distance is stored in the distance buffer if it is less that the value already there."
      },
      "date": 1675343231650
    },
    {
      "item": {
        "type": "factory",
        "id": "da423ce3dbf2014d"
      },
      "id": "da423ce3dbf2014d",
      "type": "add",
      "after": "9ad06aa83dd5b16a",
      "date": 1675343276222
    },
    {
      "type": "edit",
      "id": "da423ce3dbf2014d",
      "item": {
        "type": "paragraph",
        "id": "da423ce3dbf2014d",
        "text": "[…] Figure 5. Each pixel is painted with the opacity obtained by taking its distance to the path, and using it as the argument to the prefiltering pen function. To illustrate, for some pixels, the small black arrows show this distance to the path. As a further example, for the two arrows closest to the bottom of the figure, the distance is projected (dashed lines) over the filtering pen function, to show how to obtain the opacity values used to paint the pixels. The same procedure is used for all pixels."
      },
      "date": 1675343283711
    },
    {
      "item": {
        "type": "factory",
        "id": "d4a2b60529da7b9a"
      },
      "id": "d4a2b60529da7b9a",
      "type": "add",
      "after": "da423ce3dbf2014d",
      "date": 1675343451174
    },
    {
      "type": "edit",
      "id": "d4a2b60529da7b9a",
      "item": {
        "type": "pagefold",
        "id": "d4a2b60529da7b9a",
        "text": "chat.openai"
      },
      "date": 1675343464939
    },
    {
      "item": {
        "type": "factory",
        "id": "9254d6afffa54b8f"
      },
      "id": "9254d6afffa54b8f",
      "type": "add",
      "after": "d4a2b60529da7b9a",
      "date": 1675343487438
    },
    {
      "type": "edit",
      "id": "9254d6afffa54b8f",
      "item": {
        "type": "paragraph",
        "id": "9254d6afffa54b8f",
        "text": "Here's a possible implementation of the algorithm in JavaScript:"
      },
      "date": 1675343489726
    },
    {
      "item": {
        "type": "factory",
        "id": "86466e65b19d892c"
      },
      "id": "86466e65b19d892c",
      "type": "add",
      "after": "9254d6afffa54b8f",
      "date": 1675343508060
    },
    {
      "type": "edit",
      "id": "86466e65b19d892c",
      "item": {
        "type": "code",
        "id": "86466e65b19d892c",
        "text": "function drawOutline(destination, trajectory, penOuterDiameter, filteringPen) {\n  const width = destination.width;\n  const height = destination.height;\n  const distanceBuffer = [];\n  for (let i = 0; i < width * height; i++) {\n    distanceBuffer[i] = Number.POSITIVE_INFINITY;\n  }\n\n  for (let i = 0; i < trajectory.length - 1; i++) {\n    const start = trajectory[i];\n    const end = trajectory[i + 1];\n    const step = (end - start) / 4;\n    let current = start;\n    while (current <= end) {\n      const x = Math.round(current.x);\n      const y = Math.round(current.y);\n      const r = penOuterDiameter / 2;\n      for (let i = Math.max(0, x - r); i <= Math.min(width - 1, x + r); i++) {\n        for (let j = Math.max(0, y - r); j <= Math.min(height - 1, y + r); j++) {\n          const distance = Math.sqrt((i - x) ** 2 + (j - y) ** 2);\n          if (distance < distanceBuffer[i + j * width]) {\n            distanceBuffer[i + j * width] = distance;\n          }\n        }\n      }\n      current = current.add(step);\n    }\n\n  for (let i = 0; i < width * height; i++) {\n    const x = i % width;\n    const y = Math.floor(i / width);\n    const opacity = filteringPen(distanceBuffer[i]);\n    const index = (x + y * width) * 4;\n    destination.data[index + 3] = opacity * 255;\n  }\n}\n"
      },
      "date": 1675343510681
    },
    {
      "item": {
        "type": "factory",
        "id": "f9aed2a4fcaf415e"
      },
      "id": "f9aed2a4fcaf415e",
      "type": "add",
      "after": "86466e65b19d892c",
      "date": 1675343799113
    },
    {
      "type": "edit",
      "id": "f9aed2a4fcaf415e",
      "item": {
        "type": "pagefold",
        "id": "f9aed2a4fcaf415e",
        "text": "~"
      },
      "date": 1675343805108
    },
    {
      "item": {
        "type": "factory",
        "id": "adbefba538ecc557"
      },
      "id": "adbefba538ecc557",
      "type": "add",
      "after": "f9aed2a4fcaf415e",
      "date": 1675343809554
    },
    {
      "type": "edit",
      "id": "adbefba538ecc557",
      "item": {
        "type": "reference",
        "id": "adbefba538ecc557",
        "site": "wiki.ralfbarkow.ch",
        "slug": "prefiltering-antialiasing-for-general-vector-graphics",
        "title": "Prefiltering Antialiasing for General Vector Graphics",
        "text": "The graphics engines commonly used to draw vector graphics apply the antialiasing technique known as [[Pixel Coverage]]."
      },
      "date": 1675343815248
    },
    {
      "item": {
        "type": "factory",
        "id": "9058e6f8f9b26414"
      },
      "id": "9058e6f8f9b26414",
      "type": "add",
      "after": "adbefba538ecc557",
      "date": 1675343845004
    },
    {
      "type": "edit",
      "id": "9058e6f8f9b26414",
      "item": {
        "type": "reference",
        "id": "9058e6f8f9b26414",
        "site": "wiki.ralfbarkow.ch",
        "slug": "juan-manuel-vuletich",
        "title": "Juan Manuel Vuletich",
        "text": "[[Juan Manuel Vuletich]]"
      },
      "date": 1675343848210
    },
    {
      "id": "9058e6f8f9b26414",
      "type": "move",
      "order": [
        "886ab8059189ee58",
        "e7dcc3ede36b2488",
        "516c2f998af19c85",
        "f9677b175b39587c",
        "9ad06aa83dd5b16a",
        "da423ce3dbf2014d",
        "d4a2b60529da7b9a",
        "9254d6afffa54b8f",
        "86466e65b19d892c",
        "f9aed2a4fcaf415e",
        "9058e6f8f9b26414",
        "adbefba538ecc557"
      ],
      "date": 1675343870269
    },
    {
      "item": {
        "type": "factory",
        "id": "ec64835ec5f3d8bb"
      },
      "id": "ec64835ec5f3d8bb",
      "type": "add",
      "after": "adbefba538ecc557",
      "date": 1675343977407
    },
    {
      "type": "edit",
      "id": "ec64835ec5f3d8bb",
      "item": {
        "type": "reference",
        "id": "ec64835ec5f3d8bb",
        "site": "ward.dojo.fed.wiki",
        "slug": "generate-a-rectangular-grid",
        "title": "Generate a Rectangular Grid",
        "text": "[[kohonen-stars]] [https://github.com/seracio/kohonen-stars github] is an example for our library kohonen [https://github.com/seracio/kohonen github], a basic implementation of [[SOM]] algorithm in JavaScript."
      },
      "date": 1675344002983
    },
    {
      "item": {
        "type": "factory",
        "id": "715582819f359baa"
      },
      "id": "715582819f359baa",
      "type": "add",
      "after": "ec64835ec5f3d8bb",
      "date": 1675344050171
    },
    {
      "type": "edit",
      "id": "715582819f359baa",
      "item": {
        "type": "assets",
        "id": "715582819f359baa",
        "text": "pages/outline-of-a-shape"
      },
      "date": 1675344056048
    },
    {
      "item": {
        "type": "factory",
        "id": "c0b60a50f1beb36f"
      },
      "id": "c0b60a50f1beb36f",
      "type": "add",
      "after": "715582819f359baa",
      "date": 1675344405205
    },
    {
      "type": "edit",
      "id": "c0b60a50f1beb36f",
      "item": {
        "type": "frame",
        "id": "c0b60a50f1beb36f",
        "text": "//wiki.ralfbarkow.ch/assets/pages/generate-a-rectangular-grid/grid.html\nHEIGHT 333"
      },
      "date": 1675344415257
    },
    {
      "type": "edit",
      "id": "c0b60a50f1beb36f",
      "item": {
        "type": "frame",
        "id": "c0b60a50f1beb36f",
        "text": "//wiki.ralfbarkow.ch/assets/pages/outline-of-a-shape/outline.html\nHEIGHT 333"
      },
      "date": 1675344429566
    }
  ]
}