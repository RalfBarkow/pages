{
  "title": "Graphical Programming Language",
  "story": [
    {
      "type": "html",
      "text": "The term \"visual programming\" seems to have been appropriated to describe GUI builders for conventional textual languages [for this see [[Visual Programming]], [[Visual Programming Language]]].",
      "id": "75754bbb3b7d5379b657d06c87275a18"
    },
    {
      "type": "html",
      "text": "\nThis page is about truly graphical languages, in which the source code is itself graphical in nature and does not principally consist of text. Normally, a chunk of code is a directed graph of some sort, where the direction of the graph edges indicates control or data flow.",
      "id": "17dd763709cc31386ad327deff14f04b"
    },
    {
      "type": "html",
      "text": "\nThere are somewhat weirder versions, where for instance graphical primitives are locked into a grid (like in the old [[Mac Os]] game [[Chip Wits]]), or some other structure, but these tend to be used for special-purpose scripting applications. -- [[Bill Tozier]]",
      "id": "3e8f027dec5e57cb47252dc18be43196"
    },
    {
      "type": "html",
      "text": "\nExamples:",
      "id": "3f19a1b9c4e614dabe76ed0b9e896a3f"
    },
    {
      "type": "html",
      "text": " [[Grail Language]]",
      "id": "14bb11dd67866e2224017ca50c3ef8a1"
    },
    {
      "type": "html",
      "text": " [[Graphical Program Editor]]",
      "id": "4e546ecf9e87a765bc32d841d12b539f"
    },
    {
      "type": "html",
      "text": " [[Prograph Language]]",
      "id": "251d68fb283e1ca426f84a22d3ae156d"
    },
    {
      "type": "html",
      "text": " [[Cube Language]]",
      "id": "7cbc03f2705666e3836b7c18d1147270"
    },
    {
      "type": "html",
      "text": " [[Gee Language]] ([[Lab View]])",
      "id": "e6258f46a8ea35fafdc46cbc015e29a1"
    },
    {
      "type": "html",
      "text": " [[San Script]]",
      "id": "24a039fbfe7d63b204898b31f1702bbe"
    },
    {
      "type": "html",
      "text": " [[Bounce Language]]",
      "id": "916bbf90c7f07973076025c8dec84df1"
    },
    {
      "type": "html",
      "text": " [[Vpl Language]]",
      "id": "53b20594514b178d0688b71bc4595965"
    },
    {
      "type": "html",
      "text": " [[Alternate Reality Kit]]",
      "id": "c48701d9ab5ad78d464b69b586ac27cc"
    },
    {
      "type": "html",
      "text": " [[Max Language]]",
      "id": "42a7b88808fd5013888fdb204158e0ff"
    },
    {
      "type": "html",
      "text": " Tomato -- [http://sourceforge.net/projects/tomatoide/ sourceforge.net]",
      "id": "20dd58f33ccbf2c242b393428b86da60"
    },
    {
      "type": "html",
      "text": " Thyrd -- [http://thyrd.org/ thyrd.org]",
      "id": "a039191d6f225254baf50e19445d2850"
    },
    {
      "type": "html",
      "text": " [[Pure Data]] or [[Max Msp]] -- [http://en.wikipedia.org/wiki/PureData en.wikipedia.org]",
      "id": "7146ac68a3518ccbd29c8d9bcefae221"
    },
    {
      "type": "html",
      "text": " [[Rel Project]] has an experimental graphical query editor called <i>Rev</i>.",
      "id": "975d25cea8809e6c7a97ce3433c36ad7"
    },
    {
      "type": "html",
      "text": "\nTeaching languages:",
      "id": "edbed991c473bc1e41962f191e380923"
    },
    {
      "type": "html",
      "text": " [[Toon Talk]]",
      "id": "35d58c44fbc4c3b147acf3aaf7b9a4de"
    },
    {
      "type": "html",
      "text": " [[Squeak Smalltalk]]: [[Squeak Etoys]], [[Scratch Language]], [[Squeak Alice]]",
      "id": "d2710b4164006de784fa909ab1cd9b07"
    },
    {
      "type": "html",
      "text": " [[Alice Software]]",
      "id": "1a49486067db3cfe993b377ad0661323"
    },
    {
      "type": "html",
      "text": " KTurtle",
      "id": "5bd3b219c098a03fba7a629e4d8799ff"
    },
    {
      "type": "html",
      "text": " [[One Laptop Per Child]]'s Turtle Art",
      "id": "2a385b78ef7590732dcc79b95ef2fdc4"
    },
    {
      "type": "html",
      "text": "\nLinks:",
      "id": "06589f944e4994907e85bee38098969e"
    },
    {
      "type": "html",
      "text": " [http://www-ist.massey.ac.nz/~plyons/711_html/vpl%20papers.html www-ist.massey.ac.nz] for a review of papers on graphical programming languages",
      "id": "c7c56133e5e2081066dbc335165b7649"
    },
    {
      "type": "html",
      "text": " [http://cui.unige.ch/langlist?visual cui.unige.ch]",
      "id": "631ba0f30fca0c0eae9ba5f04a36fa5e"
    },
    {
      "type": "html",
      "text": " [http://visual.wiki.taoriver.net/ visual.wiki.taoriver.net] -- an entire Wiki dedicated to graphical languages.",
      "id": "acc6af3bab627e2afa55da5015f3933d"
    },
    {
      "type": "html",
      "text": " [http://www.cs.berkeley.edu/~maratb/cs263/ www.cs.berkeley.edu]",
      "id": "8a46dfc812801e959cfaa3993e237990"
    },
    {
      "type": "html",
      "text": " [http://barada.canisius.edu/~meyer/CCSCNE/finalHTML/meyer.html barada.canisius.edu] [[[Broken Link]]]",
      "id": "44840fddeba8c44bbe58655d17f01066"
    },
    {
      "type": "html",
      "text": " [http://nickerson.to/visprog/visprog.htm nickerson.to] -- thesis of [[Jeffrey Nickerson]]",
      "id": "fcea9b20b5df7e46acbb442d7f67d5d1"
    },
    {
      "type": "html",
      "text": " [http://omicron.felk.cvut.cz/FAQ/articles/a249.html omicron.felk.cvut.cz] -- comp.lang.visual FAQ",
      "id": "45d73f9bca47976dde551e824310fe23"
    },
    {
      "type": "html",
      "text": " [http://www.cs.dal.ca/~smedley/Research.html www.cs.dal.ca]\nSee also: [[Visual Programming Book]].",
      "id": "5a9c2dce2aaecee0a341b5a6a51c5386"
    },
    {
      "type": "html",
      "text": "\nFor discussion of advantages and limitations of graphical languages, see [[Graphical Programming]].",
      "id": "cb0547466ef15d41f891e9eb13708d70"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "\nUpon more research in existing work, I found a system called bounce. It doesn't appear to be a general purpose language (it's meant for VR programming), but it does have some interesting stuff. Check out [http://catalog.com/hopkins/lang/bounce/bounce.html catalog.com]",
      "id": "e0e0ccf2b33ec30636f4dab9eb242400"
    },
    {
      "type": "html",
      "text": "\n[[Jaron Lanier]] was working on this problem when he invented VR.",
      "id": "49b3342810bdbd26590fd8e020ed5cce"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "<i>Does [[Befunge Language]] count?</i>",
      "id": "bc308e3993469091e59838628911e28d"
    },
    {
      "type": "html",
      "text": "\nA good question. [[Befunge Language]], [[Snusp Language]], or Ward's [[Biota Language]] (and [[Tom Ray]]<b></b>'s original Tierra language, for that matter) certainly rely on the <i>structure</i> of the code in a way that is unlike traditional source. But I'm not sure whether the people who (for instance) write their Ph.D. theses on graphical programming would lump them together with Prograph, say. Mayhap the natural lump/split line lives between \"Graphical Programming Languages\" and something like \"Structural Programming\"? Or is it between \"Drawn Programming Languages\" and \"Typewritten Programming Languages\"? -- [[Bill Tozier]]",
      "id": "a754184e07926515dbbcef1dca733965"
    },
    {
      "type": "html",
      "text": "\nWould that make [[Python Language]], with its significant whitespace ([[Syntactically Significant Whitespace Considered Harmful]]?) a [[Graphical Programming Language]]? -- [[Earle Martin]]",
      "id": "3ffa782f5bfb2fbce8b19d772c6484c1"
    },
    {
      "type": "html",
      "text": "\nCertainly not. That would water down the term to the point of almost being meaningless. We like to have pages laid out in some kind of nice 2D format regardless of what is being displayed, but the information presented by properly indented [[Cee Language]] or [[Pascal Language]] is no different from the syntactically required whitespace in [[Python Language]] or [[Haskell Language]].",
      "id": "51987292f353b8b1939be3af0f6049e7"
    },
    {
      "type": "html",
      "text": "\nThis kind of thing just shows that it is difficult to create strict definitions that capture true intentions and creates a 100% correct dividing line between true category members versus non-members. That's an issue with all definitions, not just this one.",
      "id": "46b23554fb32ea167e87d496d81f1d47"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "There is one neat language with graphical syntax: Aardappel by prolific language designer [[Wouter Van Oortmerssen]].",
      "id": "1da24edc5a04ddac6531e67c4f3102d4"
    },
    {
      "type": "html",
      "text": "\n[http://wouter.fov120.com/aardappel/index.html wouter.fov120.com]\n[http://www.google.com/search?q=cache:wouter.fov120.com/aardappel/ www.google.com]",
      "id": "75762ff05eb99b3eb7c8b488580a0e77"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "The [graphical language] that I use and like is [[Lab View]] [i.e. [[Gee Language]]]. Initially, HP came up with the idea, but they thought it would never fly. When [[National Instruments]] [[http://www.natinst.com www.natinst.com]] picked the idea up and made it a pretty big success, HP thought they could resurrect their own in HP-VEE. Labview did start out with modules written in another language, but it has extensibility and allows you to bring in code from other languages. -- [[Ben Willems]]",
      "id": "58b6e116871598069e47f18fbba2d980"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "Prograph is the closest to a true graphical language I've ever heard of, which used the [[Dataflow Programming]] paradigm for algorithm description.\nFairly recent page of links at [http://www.tritera.com/prograph.html www.tritera.com] and as far as I can tell it is still in commercial production although the company Pictorius looks as though they mainly do Java now.\n[http://www.pictorius.com/ www.pictorius.com] [[[Broken Link]]]",
      "id": "94a799a8c289ade5b5a89916973d7e6c"
    },
    {
      "type": "html",
      "text": "\nAnother interesting product was Serius, bought by Novell in 95 and renamed Visual [[App Builder]] which used visual programming to tie together components written in more conventional languages. There's a Byte article discussing Serius, Prograph et al:\n[http://www.byte.com/art/9407/sec12/art2.htm www.byte.com]",
      "id": "59a35508047221d368556331f57929a4"
    },
    {
      "type": "html",
      "text": "\nI have a longstanding fascination with different languages and development paradigms but never had a chance to try either of these (my mild amount of self-restraint comes down to only using stuff in a commercially-oriented project, I have a life!). -- [[Andy Dent]]",
      "id": "44c544636dab8d8a21dcdfa79b473316"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "\nI know that the Quest3D engine by Act-3D uses [a graphical language]. The program is for visual presentation of CAD designs, and many also use it for 3D games and things like that. Judging from the results this seem to work quite all right - especially for beginners.",
      "id": "882d5cde505c7011db41f701ca247981"
    },
    {
      "type": "html",
      "text": "\nAnd there are also [[Graphical Programming Language]]s in several high-end 3D applications like [[Maxon Cinema]] and [[Alias Maya]] (AFAIK). This is really a big help to create simple dependencies, that would otherwise need you to learn a special scripting language.",
      "id": "74052e27e7eee14d35d6f3aa384f06bc"
    },
    {
      "type": "html",
      "text": "\nAnd also there are several simple [[Game Makers]] that use a graphical approach - like [[Click Team]]s [[Multimedia Fusion]] (although different from the [[Lab View]] idea), among others. -- [[Thomas Schmall]]",
      "id": "082b66294cdb5f9cf0e62b112385f63d"
    },
    {
      "type": "html",
      "text": "\nNot to mention one really, really big one coming. [[Unreal Engine]] 3.0 will be using a multimodal [[Gee Language]]-style [[Graphical Programming Language]] called [[Kismet Language]]. Kismet will be primarily graphical, but include a text-mode for writing procedures that are easier in text (like mathematics). Keep in mind that this is the [[Unreal Engine]], which is notorious for having the entire classmodel of the whole engine represented in the scripting system (although many of the internal classes are \"hands off\"). In about a year, a very large and complete graphical programming application will be hitting the market (release for [[Unreal Tournament]] 2007 is slated for 2006). Plus, another, less popular but similar gamemaking app called [[Vir Tools]] already exists based on a similar multimodal language, although [[Vir Tools]] is considered a prototyping toy by gamedevs. -- [[Martin Zarate]]",
      "id": "ed6640dca643d8bbdf3bbd0a8aee7723"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "\nSee also [[Flow Based Programming]]. For some sample diagrams, see [http://www.jpaulmorrison.com/cgi-bin/wiki.pl?DrawFlow www.jpaulmorrison.com]. By the definition of [[Graphical Programming Language]] given above, it is only a partial one, as the graphical language is used to combine components written in various procedural languages, but we have found that the diagrams provide an excellent communication medium between users and developers, especially when most of the components have simple, self-explanatory functions, e.g. readers, writers, sorts, merges, etc. In addition the \"port\" concept allows these components to be generalized functions that are prewritten and pretested. Even the application-specific components can be given names like \"generate report\", \"summarize\", \"access such and such a database\", etc., that help with the visualization process. -- [[Paul Morrison]]",
      "id": "af56086351ca444733e6fbb80e2944bd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "<i>On the term \"visual programming language\":</i>",
      "id": "318a09d735e1b50388d3f68a07183178"
    },
    {
      "type": "html",
      "text": "\nI think that the term \"visual\" itself is pretty poor. All programming languages that I know of are visual. You look at the text. I'm sure that there are some blind programmers out there, but I shudder to think of them using C++. Imagine what that would sound like? Or, feel like in braille?",
      "id": "6c2c7798f7d0dbd5a8826623e4b26704"
    },
    {
      "type": "html",
      "text": "\nI think the nomenclature predates the prevalence of the GUI, so it's a historical name. I agree that all languages are \"visual\" in the sense you mean - the distinction here is between languages you type, and languages you draw. The latter ones are \"visual\" in the way the term is technically used. -- [[Bill Tozier]]",
      "id": "0024ff931c3906fb0b22890a44b83c40"
    },
    {
      "type": "html",
      "text": "\n[[Micro Soft]] has been using the word \"visual\" in [[Visual Basic]] and related development platforms for some time, but frankly the only thing that is \"visual\" about them is a handy way of building the layout of interface components. Sadly, over the years this has undermined the efforts to produce real visual/graphical languages like those referenced above.",
      "id": "bee171e688707bd78ed828c5f76c3192"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "I know that in the past graphical programming languages have been a joke. But recently I've been wondering if there was a way to create a serious graphical programming language. I think that such things could have numerous advantages. One possible one would be to be able to more intuitively see how a program works. Another idea was that we could get rid of the textual vagaries that make smart development environments a pain to write.",
      "id": "800504f31f5d82a7e7fa9e556a8f0d11"
    },
    {
      "type": "html",
      "text": "\nThe first thing that would need to be done differently is that the idea that this would be simpler than text programming has to go. What else would have to be different to make it work? Is anyone else doing research on this area?",
      "id": "b3b3ec5311242689c3d4249ee04deacf"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "(moved from [[Future Of Programming Languages]])",
      "id": "6edfe248d8ae6f6a2f5510bf774a6f65"
    },
    {
      "type": "html",
      "text": "\nI'm not sure the future of programming languages is even a \"language.\" I imagine that we'll be connecting components on a bus architecture. We'll rely on visualization, because the layout of the code will be much more schematic than it has been. We've moved in computing from more linear algorithmic (flow-charts) to the more divergent (UML [[Class Diagram]]s, for example.) I can only see this continuing: The relationships between modules will become increasingly less linear, and we will find that our expressive technology will be a problem.",
      "id": "cf1ea396d199977a3c344c2236ea6c32"
    },
    {
      "type": "html",
      "text": "\nWhen we finally make a good GUI platform, we'll find that our languages suddenly leap into the realm of schematics.",
      "id": "94e7216b4567b5a943ec142a6ae876e3"
    },
    {
      "type": "html",
      "text": "(What sucks about GUI technology right now? It's so primitive, that's what! Sure, it's great if all you need are buttons, text boxes, combo boxes, and trees. But <i>good</i> GUI technology will make it easy to program by setting icons down on a surface, rotate them, give icons awareness of neighboring icons, and how they are situated with respect to one another, automatically mirror internals in the external display, allow people to easily compose icons, shift scale, etc., etc., etc.,. The GUI technology we have now is <i>peanuts</i> compared to what we need. The only reason we're still using text, isn't because we love linearity. No, it's because it's the easiest to navigate and work with, <i>right now.</i>)",
      "id": "294bf3e8f880f639ece5a440021cf742"
    },
    {
      "type": "html",
      "text": "-- [[Lion Kimbro]]",
      "id": "5c7ef1657ea8a9137a369d05b25686c1"
    },
    {
      "type": "html",
      "text": "\nI'm going to be contrary, and say that the primary representation of programming will continue to be textual, though there may be visual views that are useful in certain circumstances or other alternate views. (For instance, the modern class browser is graphical, but is still fundamentally text based. Dialog boxes are borderline, but while the dialog box itself is probably best understood graphically, there's still an underlying text program that is the core of the functionality.)",
      "id": "e9f21f692e5be98c708c36f71b0c0bf7"
    },
    {
      "type": "html",
      "text": "\nWhile I normally hate to analogize computer languages to natural languages, computer languages won't become visual for reasons almost identical to the ones that have natural languages moving <i>away</i> from visual representations, not towards, even today. Other than visually pleasing typography, playing with visual representations like spiral typesetting or dense visual symbology is mostly the domain of poets and artists, not people seriously trying to communicate. Looking and seeing visual information is easy. Manipulation is fundamentally more difficult; so much so that I've never seen anyone come even close to a truly visual programming paradigm that actually works usefully beyond the \"hello world\" example. Too much software just isn't manipulable visually, and showing the few cases where it may be hardly disproves that.",
      "id": "2f023da2cac05eef725affcef153a410"
    },
    {
      "type": "html",
      "text": " I agree, but just to nitpick, [[Prograph Language]] and [[Lab View]]'s [[Gee Language]] are two successful truly [[Graphical Programming Language]]s. Both are 20 years old, though, and never took the world by storm (the former, in fact, is in limbo until an open source effort recreates it, and the latter is niche: equipment control and data analysis), so there's no reason to think that \"some day all will be visual\". Likewise [[Toon Talk]] is a cool 100% [[Graphical Programming Language]], suitable for teaching children, and very powerful, but again isn't gaining many converts. Excellent visual programming languages have been done. Few care.",
      "id": "8136cb475f625fdd2e1d452bbb0f6e65"
    },
    {
      "type": "html",
      "text": " the problem is that's pretty slim pickings.  [[Gee Language]] is trapped in [[Lab View]], as are most [[Graphical Programming Language]]s that were designed to be domain-specific ([[Kismet Language]], [[Vir Tools]], etc.) and [[Prograph Language]] is dead.  There is no current, live, general-purpose [[Graphical Programming Language]].  I haven't even heard of some sort of pathetic little opensource effort to make a G clone.  Nothing.  When do we get GDotNet or something similar?",
      "id": "ad3bcd914571b0801415a1a1d6285452"
    },
    {
      "type": "html",
      "text": "\nThis is another one of those \"In fifty years\" predictions that keeps receding at the rate of one year per year. The reason is that it sounds really cool if you just hand-wave it into existence, but there are fundamental flaws with the approach that severely limit its usefulness.",
      "id": "62f244604ccb93a23f652cccfa4c19c5"
    },
    {
      "type": "html",
      "text": "\nThat said, there's significant room for the continuing advancement of the re-factoring editor that understands more about the actual syntax of the program and may be able to do wild visualizations that may even be helpful; my point is not that no visualization progress will happen but that for serious programmers, the text representation will continue to be the \"real program\".",
      "id": "70bb38a92a56fb16e8a04c5660da9015"
    },
    {
      "type": "html",
      "text": "<i>I'd predict that we will move to a multi-modal style. Sometimes a textual view is better, sometimes graphical. As tools improve, we'll have various ways to \"frame the code\". Dependency graphs and visual gui editors are excellent complements to textual code.</i> ",
      "id": "68f1d6744812e73a3865a5bdacbd7621"
    },
    {
      "type": "html",
      "text": "\nI can't resist putting in my 2 bits: [[Flow Based Programming]] (FBP) is a very visual coordination language that allows the programmer to combine asynchronous components into a 2-dimensional network. Because communication is via ports, it lends itself to prewritten, pretested componentry, so it cries out for a visual interface, which could easily be extended to have quite a lot of smarts, e.g. knowledge of what ports a given component uses - put them up on the screen, connect them, run it, and maybe even watch the data as it travels (test mode, not production!). ",
      "id": "95ac50184a241772d4c881ba826e856c"
    },
    {
      "type": "html",
      "text": "\nThe components can be written in any language that understands data packets - granted that the components are coded in text right now, but if they are reusable components, who cares what language they were written in? However, some business transforms can be very visual - some components in the network will eventually be generated from pictures themselves. FBP has been in continuous use at a bank for 30 years - we were using it for production work long before we had decent graphics support (we used biiig sheets of paper!). Now we've got the technology: anyone want to step up to the challenge? The thing might finally take off! -- [[Paul Morrison]]",
      "id": "188a16bca582543ca06727dd208988ff"
    },
    {
      "type": "html",
      "text": "\nI've been thinking about it. The gap between your book and the issue of what support to put into a programming language is fairly large. I'm accustomed to bridging such gaps, but still...any comments on that? -- [[Doug Merritt]]",
      "id": "a620e3e216174ce300446291698d820f"
    },
    {
      "type": "html",
      "text": "\nWhat kind of support? Organizational? An IDE? Money?! Could you expand on your question? Bridging gaps is good - that's what Pontifex means. :-) -- [[Paul Morrison]]",
      "id": "87994d0035eaf9e088acb1478e4e057f"
    },
    {
      "type": "html",
      "text": "\nI just mean language constructs to support FBP natively. Or similarly, the ideal set of library functions to support FBP. -- dm",
      "id": "2980e4b8d5e57821c4bda828a86382c8"
    },
    {
      "type": "html",
      "text": "...",
      "id": "3432e2d557e013591bd229cef2eac3cb"
    },
    {
      "type": "html",
      "text": "<i>Never mind, I'll just stick with the FBP primitives I invented for the 1983 version of the language in question.</i>",
      "id": "ef8be46f1d3f9d18572d791b5208e3c1"
    },
    {
      "type": "html",
      "text": "\nCan you point us at them? Maybe put something up on the FBPWiki? -- pm",
      "id": "353ada5a5e106de4f08954b28ca69429"
    },
    {
      "type": "html",
      "text": "\nThat said, I could see having a small number of mini-languages running in the FBP environment whose job is to shift stuff from input ports to output ports, perhaps with small transformations, subtotals, etc. Approximately the expressive level of RPG, or less. In fact, as I suggested elsewhere, the logic could even be specified graphically, given an appropriate IDE (imagine a business-oriented [[Toon Talk]] :-)). Remember that FBP is primarily a <i>coordination</i> language, so there is no need to push a language (any of the ones used for writing components) beyond its comfort level!",
      "id": "f788e68b33fcffd35c949332c3248960"
    },
    {
      "type": "html",
      "text": "\nMore generally, I think a possible approach would be to establish a lowest common denominator for communication between FBP components, and I think this should probably be ASCII strings, probably with embedded delimiters, which I guess nowadays sounds a lot like XML! Except that the overhead involved means that you should only do this at the boundary between component vendors - between components that are more closely related we need a convention that is not so CPU-intensive! However, FBP <i>is</i> a natural environment to support streaming XML parsers. I wrote one using the so-called \"Babel Parser\" ([http://www.jpaulmorrison.com/cgi-bin/wiki.pl?BabelParser www.jpaulmorrison.com]) for the project we did in JavaFBP (the Java implementation of FBP), and we multiplexed it (3 ways) to take advantage of the multiple processors on our machine.",
      "id": "88ba2f880a79e6e434f15e025ebf0f89"
    },
    {
      "type": "html",
      "text": "\nIf we assume also that, in the PC world, code components can always be turned into DLL/.so libraries, then we can use FBP to hook together any languages that understand ASCII strings, and that can be compiled to a DLL/.so. I am also assuming that most compiled languages can handle pointers to ASCII strings... Languages that require VMs would require native interfaces. In such an environment, some threads would be running essentially machine language (generated by the compiler of your choice), and others would be interpretive using VMs - then hopefully there would be no need for a VM to support multiple threads. This would then give us the rather neat ability to write individual FBP components initially in a scripting (interpretive) language, and then switch to compiled code for performance reasons at a later stage in a project's life-cycle (avoiding [[Premature Optimization]]).",
      "id": "46a567a6f5eae21b7525497233c939b4"
    },
    {
      "type": "html",
      "text": "\nLooking into this, I realize that I didn't publish the JavaFBP component API yet, although it is in the jar file on my web site. I've put the APIs for THREADS and JavaFBP (the C++ and Java implementations of FBP, respectively) into [http://www.jpaulmorrison.com/cgi-bin/wiki.pl?FbpApi www.jpaulmorrison.com].",
      "id": "79c4099bab6f43442ca6b401dc83fb78"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "I think Rocky's Boots [[http://www.warrenrobinett.com/rockysboots/ www.warrenrobinett.com]] and Robot Odyssey [[http://members.aol.com/Fractal101/odyssey.htm members.aol.com]] deserve mention here.",
      "id": "7a79dc88b498919a82123596e7437933"
    },
    {
      "type": "html",
      "text": "\nLabview uses true graphical programming (G language).\nIt's a very intuitive way to program.\nIn my opinion, about 10 times faster than old-style text-based programming for most applications.",
      "id": "d91d4f9a17eebb16f57ebebc4425862f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "\nI'd be interested in learning what it would take to integrate graphical programming with a more traditional text-based programming language.  I don't believe that graphical programming entirely lends itself to <i>general purpose</i> programming (e.g. they are generally inadequate for conceptually atomic processing steps... such as mathematical functions and initial data description).  However, the use of graphical languages have proven very natural for describing <i>flow</i> of any sort: [[Work Flow]], [[Data Flow]], and [[Signal Flow]].  They essentially allow the internal processes to be nameless, and abstract away much of the nasty interfacing between processes and objects.  It also allows for automatic zoomable interfacing, going from the 2000 meter view (inter-business processes, web services) down to the 10 cm view (the exact flow within a particular procedure within a particular process within a ...).  Such things are good for communicating to [[Pointy Haired Bosses]].",
      "id": "9197bbb669e785d14a8a40d169044163"
    },
    {
      "type": "html",
      "text": "\nHow difficult would it be to create a graphical programming language that handles those tasks but corresponds directly to the use of certain underlying text programming, such that the graphical programming language is just a [[Domain Specific Language]] for workflow, dataflow, signal flow, and that sort of thing, and a possibly typeful sublanguage of another language (Lisp, Ocaml, Haskell with Monads, etc.).  I imagine something like a common set of wrappers could do the trick... a limited set of domain specific languages that are readily and intuitively translated to and from graphical components, and that integrate with an underlying language in some well-defined way.  However, that still leaves the difficult parts: creating/identifying and integrating these [[Domain Specific Language]]s that are good for graphical programming, ensuring they cover everything you and other users will possibly need and that they provide for extensibility (graphical macros?), and creating an [[Object Browser]] for all of this.",
      "id": "2305bc2acec906ffbb2da0e3f203009d"
    },
    {
      "type": "html",
      "text": "\nKey to finding what DSLs we want is finding: What are the [[Limits Of Graphical Programming]]?  It's easy to make a graphical language that is turing complete, but at what point will users stop gaining and start losing?  Are the inherent limits different between 2D and 3D graphical programming?",
      "id": "c12c309f46956e7a1ae612b715018aa1"
    },
    {
      "type": "html",
      "text": "\nI posit that the limit of graphical programming is conceptual <b>atoms</b> -- values, mathematical (pure) functions, and calculations.  ",
      "id": "d41d97db111dea91a109556870309025"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "\n[[Kismet Language]] (the language of the upcoming [[Unreal Engine]] 3.0) has the system you described - a traditional, flow-based [[Graphical Programming Language]] with a c-like text language that can be embedded into blocks within the flow-code to handle things like arithmetic that are much better described in text.",
      "id": "08ddbb8bdbe43383062e254ab1ee2dc3"
    },
    {
      "type": "html",
      "text": "\nAnd I think that the \"managerial view\" is unlikely to be as nice as you think.  Consider how well managers can read Cobol.  Consider how little you learn from one function of the outermost code of your system - flow-based programming is functionally the same as traditional functional programming languages except that the threading is automagic.  All it is is \"take results from call Foo and send it to calls Bar and Baz as argument Quux\" - whether that's phrased as ",
      "id": "e97228ebffa4da846b3ea3484c95f6bd"
    },
    {
      "type": "code",
      "text": " tempfoo = Foo();\n Bar(tempfoo);\n Baz(tempfoo);",
      "id": "a2ef4a46df2566f6095dc148e5c1a6f2"
    },
    {
      "type": "html",
      "text": "or a line drawn from Foo to the Quux input on Bar and Baz is just semantics.  Theoretically, you could selectively \"expand\" functions just like one could theoretically \"inline\" important methods to make the logic more clear in a code view in a text language... but notice that nobody does.",
      "id": "7fe0af434cb175f1fc85cd6b09a22f33"
    },
    {
      "type": "html",
      "text": "<i>\"Consider how little you learn from one function of the outermost code of your system - flow-based programming is functionally the same as traditional functional programming languages except that the threading is automagic.\"</i> -- Do you mean procedural?  Technically, there is no <i>flow</i> when working with <i>functions</i> (in the mathematical sense); '1+1' is completely equivalent to '2'.  This is part of why I posit that functions/calculations/values cannot be readily transformed to graphical languages.  If you've fully described the flow, above, then: ",
      "id": "5d3324f716c51320584b9ad9c1aa8574"
    },
    {
      "type": "code",
      "text": "   myBlock = { tempfoo = Foo();\n               Bar(tempfoo);\n               Baz(tempfoo);    }",
      "id": "43de21b6e62d95c86bd105976fb0a926"
    },
    {
      "type": "html",
      "text": "is completely equivalent to:",
      "id": "d63d974627fa44adda6eaba90cd8fa7e"
    },
    {
      "type": "code",
      "text": "   myBlock = {}",
      "id": "c6e5d0fb39000335b06e2a06a49133a1"
    },
    {
      "type": "html",
      "text": "This is because nothing is flowing out of the block.  ",
      "id": "f547236d2c42dbb1cd411a45c609b3c2"
    },
    {
      "type": "html",
      "text": "\nNow, if Foo() returns an object instead of a value, or Bar or Baz have <i>side-effects</i>, these facts simply aren't being represented.  I.e. you cannot tell by looking at it whether tempfoo is a value (immutable) or object/actor/process/etc (which can send and receive messages).  You also cannot tell whether Bar and Baz send/receive signals to and from tempfoo, the world, both, or neither.  You can't even tell whether Foo() sends and receives any signals to and from the world or not.",
      "id": "c37b786e640e667621e0d045449fd832"
    },
    {
      "type": "html",
      "text": "\nThese things would be represented in a flow-based language.  It would be misleading to call the procedural code above the same as <i>outermost code</i> of a flow-based language because there is no indication of what is flowing or how it is flowing.  And while one can produce a language that is computationally equivalent to a turing-complete procedural language, it wouldn't be right to call that language a <i>flow</i> language unless it is representing the right sorts of things -- flows in particular.  ",
      "id": "08c51c2f92afc130aef9f262300ca5f7"
    },
    {
      "type": "html",
      "text": "\nA language that actually captures the <i>flow</i> should allow you to learn a great deal by looking at the <i>outermost code of your system</i>, even if you 'box' certain processes (e.g. with Bar and Baz) to allow for something of zoomable interface and software componentry.  In particular, you should be able to learn every single source and destination for messages to and from those boxes (or some abstraction on that, e.g. if input data contains references for connections).  You'll have graphically captured the <i>side effects</i>, or at least identified their potential sources.  You should be able to figure out where signals are going, and where signals are coming from.  For fully typed flow-based language, ideally, you should also be able to look at it and learn both legal protocols (message patterns between two boxes on a single, connected line of 'flow' that don't cause runtime exceptions to propogate out of the 'box') and identify some emergent behavior (patterns of connections, for example).",
      "id": "9f5fb067c29c01bee92aa9ae9a432c28"
    },
    {
      "type": "html",
      "text": "\nI imagine that type Bar(Foo) in a flow-based language would simply be an abstraction that hooks up an object with a Foo interface to a process Bar.  Connecting the W<b></b>orldObject (or R<b></b>ootObject) to Foo and Bar would be a separate task... a separate connection, a separate <i>flow</i>.",
      "id": "80d1fe225ef52e5f2ed7adcbfd78128e"
    },
    {
      "type": "html",
      "text": "<i>You might want to look into [[Subtext Language]]. It doesn't loose the flow - quite the opposite. It may be only partly graphical in that it still uses functional expressions (except for the schematic table part), but it </i>does'' make all flow visible (more so than the code itself).\nSee the demo at [http://subtextual.org/demo1.html subtextual.org] -- [[Gunnar Zarncke]]''",
      "id": "4a0c4d1a5ee00e6df1194aa842e328a0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
    },
    {
      "type": "html",
      "text": "\nI think some graphic/visual languages are missing from this wiki:",
      "id": "bb8b42981e32f8ee17613ee7a289ce55"
    },
    {
      "type": "html",
      "text": "\nLimnor Studio: A visual programming language for .NET currently free (April 2011) [http://limnor.com/ limnor.com]",
      "id": "68c4976393a7bcbd14e98bdc85eac201"
    },
    {
      "type": "html",
      "text": "\nTersus: Commercial and open source versions (MS Windows, Linux) development of Windows, Linux, web, Android and Iphone applications [http://www.tersus.com www.tersus.com]",
      "id": "83d9941864ea6c9b1f4255120ae238a7"
    },
    {
      "type": "html",
      "text": "\nGoogle App Inventor: Open source development tool for Android OS, [http://appinventor.googlelabs.com/about/ appinventor.googlelabs.com] ",
      "id": "7d356f123da1aa35cd8d424fba108b82"
    },
    {
      "type": "html",
      "text": "\n[[Category User Interface]]",
      "id": "9080601972532a0ddfa213ea219dbfe1"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?GraphicalProgrammingLanguage c2.com]",
      "id": "f304d6127fdbe375b5c6814f92784370"
    }
  ],
  "journal": [
    {
      "date": 1417511873000,
      "id": "b7f91b7f6f9f0c611c349225062595f9",
      "type": "create",
      "item": {
        "title": "Graphical Programming Language",
        "story": [
          {
            "type": "html",
            "text": "The term \"visual programming\" seems to have been appropriated to describe GUI builders for conventional textual languages [for this see [[Visual Programming]], [[Visual Programming Language]]].",
            "id": "75754bbb3b7d5379b657d06c87275a18"
          },
          {
            "type": "html",
            "text": "\nThis page is about truly graphical languages, in which the source code is itself graphical in nature and does not principally consist of text. Normally, a chunk of code is a directed graph of some sort, where the direction of the graph edges indicates control or data flow.",
            "id": "17dd763709cc31386ad327deff14f04b"
          },
          {
            "type": "html",
            "text": "\nThere are somewhat weirder versions, where for instance graphical primitives are locked into a grid (like in the old [[Mac Os]] game [[Chip Wits]]), or some other structure, but these tend to be used for special-purpose scripting applications. -- [[Bill Tozier]]",
            "id": "3e8f027dec5e57cb47252dc18be43196"
          },
          {
            "type": "html",
            "text": "\nExamples:",
            "id": "3f19a1b9c4e614dabe76ed0b9e896a3f"
          },
          {
            "type": "html",
            "text": " [[Grail Language]]",
            "id": "14bb11dd67866e2224017ca50c3ef8a1"
          },
          {
            "type": "html",
            "text": " [[Graphical Program Editor]]",
            "id": "4e546ecf9e87a765bc32d841d12b539f"
          },
          {
            "type": "html",
            "text": " [[Prograph Language]]",
            "id": "251d68fb283e1ca426f84a22d3ae156d"
          },
          {
            "type": "html",
            "text": " [[Cube Language]]",
            "id": "7cbc03f2705666e3836b7c18d1147270"
          },
          {
            "type": "html",
            "text": " [[Gee Language]] ([[Lab View]])",
            "id": "e6258f46a8ea35fafdc46cbc015e29a1"
          },
          {
            "type": "html",
            "text": " [[San Script]]",
            "id": "24a039fbfe7d63b204898b31f1702bbe"
          },
          {
            "type": "html",
            "text": " [[Bounce Language]]",
            "id": "916bbf90c7f07973076025c8dec84df1"
          },
          {
            "type": "html",
            "text": " [[Vpl Language]]",
            "id": "53b20594514b178d0688b71bc4595965"
          },
          {
            "type": "html",
            "text": " [[Alternate Reality Kit]]",
            "id": "c48701d9ab5ad78d464b69b586ac27cc"
          },
          {
            "type": "html",
            "text": " [[Max Language]]",
            "id": "42a7b88808fd5013888fdb204158e0ff"
          },
          {
            "type": "html",
            "text": " Tomato -- [http://sourceforge.net/projects/tomatoide/ sourceforge.net]",
            "id": "20dd58f33ccbf2c242b393428b86da60"
          },
          {
            "type": "html",
            "text": " Thyrd -- [http://thyrd.org/ thyrd.org]",
            "id": "a039191d6f225254baf50e19445d2850"
          },
          {
            "type": "html",
            "text": " [[Pure Data]] or [[Max Msp]] -- [http://en.wikipedia.org/wiki/PureData en.wikipedia.org]",
            "id": "7146ac68a3518ccbd29c8d9bcefae221"
          },
          {
            "type": "html",
            "text": " [[Rel Project]] has an experimental graphical query editor called <i>Rev</i>.",
            "id": "975d25cea8809e6c7a97ce3433c36ad7"
          },
          {
            "type": "html",
            "text": "\nTeaching languages:",
            "id": "edbed991c473bc1e41962f191e380923"
          },
          {
            "type": "html",
            "text": " [[Toon Talk]]",
            "id": "35d58c44fbc4c3b147acf3aaf7b9a4de"
          },
          {
            "type": "html",
            "text": " [[Squeak Smalltalk]]: [[Squeak Etoys]], [[Scratch Language]], [[Squeak Alice]]",
            "id": "d2710b4164006de784fa909ab1cd9b07"
          },
          {
            "type": "html",
            "text": " [[Alice Software]]",
            "id": "1a49486067db3cfe993b377ad0661323"
          },
          {
            "type": "html",
            "text": " KTurtle",
            "id": "5bd3b219c098a03fba7a629e4d8799ff"
          },
          {
            "type": "html",
            "text": " [[One Laptop Per Child]]'s Turtle Art",
            "id": "2a385b78ef7590732dcc79b95ef2fdc4"
          },
          {
            "type": "html",
            "text": "\nLinks:",
            "id": "06589f944e4994907e85bee38098969e"
          },
          {
            "type": "html",
            "text": " [http://www-ist.massey.ac.nz/~plyons/711_html/vpl%20papers.html www-ist.massey.ac.nz] for a review of papers on graphical programming languages",
            "id": "c7c56133e5e2081066dbc335165b7649"
          },
          {
            "type": "html",
            "text": " [http://cui.unige.ch/langlist?visual cui.unige.ch]",
            "id": "631ba0f30fca0c0eae9ba5f04a36fa5e"
          },
          {
            "type": "html",
            "text": " [http://visual.wiki.taoriver.net/ visual.wiki.taoriver.net] -- an entire Wiki dedicated to graphical languages.",
            "id": "acc6af3bab627e2afa55da5015f3933d"
          },
          {
            "type": "html",
            "text": " [http://www.cs.berkeley.edu/~maratb/cs263/ www.cs.berkeley.edu]",
            "id": "8a46dfc812801e959cfaa3993e237990"
          },
          {
            "type": "html",
            "text": " [http://barada.canisius.edu/~meyer/CCSCNE/finalHTML/meyer.html barada.canisius.edu] [[[Broken Link]]]",
            "id": "44840fddeba8c44bbe58655d17f01066"
          },
          {
            "type": "html",
            "text": " [http://nickerson.to/visprog/visprog.htm nickerson.to] -- thesis of [[Jeffrey Nickerson]]",
            "id": "fcea9b20b5df7e46acbb442d7f67d5d1"
          },
          {
            "type": "html",
            "text": " [http://omicron.felk.cvut.cz/FAQ/articles/a249.html omicron.felk.cvut.cz] -- comp.lang.visual FAQ",
            "id": "45d73f9bca47976dde551e824310fe23"
          },
          {
            "type": "html",
            "text": " [http://www.cs.dal.ca/~smedley/Research.html www.cs.dal.ca]\nSee also: [[Visual Programming Book]].",
            "id": "5a9c2dce2aaecee0a341b5a6a51c5386"
          },
          {
            "type": "html",
            "text": "\nFor discussion of advantages and limitations of graphical languages, see [[Graphical Programming]].",
            "id": "cb0547466ef15d41f891e9eb13708d70"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "\nUpon more research in existing work, I found a system called bounce. It doesn't appear to be a general purpose language (it's meant for VR programming), but it does have some interesting stuff. Check out [http://catalog.com/hopkins/lang/bounce/bounce.html catalog.com]",
            "id": "e0e0ccf2b33ec30636f4dab9eb242400"
          },
          {
            "type": "html",
            "text": "\n[[Jaron Lanier]] was working on this problem when he invented VR.",
            "id": "49b3342810bdbd26590fd8e020ed5cce"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "<i>Does [[Befunge Language]] count?</i>",
            "id": "bc308e3993469091e59838628911e28d"
          },
          {
            "type": "html",
            "text": "\nA good question. [[Befunge Language]], [[Snusp Language]], or Ward's [[Biota Language]] (and [[Tom Ray]]<b></b>'s original Tierra language, for that matter) certainly rely on the <i>structure</i> of the code in a way that is unlike traditional source. But I'm not sure whether the people who (for instance) write their Ph.D. theses on graphical programming would lump them together with Prograph, say. Mayhap the natural lump/split line lives between \"Graphical Programming Languages\" and something like \"Structural Programming\"? Or is it between \"Drawn Programming Languages\" and \"Typewritten Programming Languages\"? -- [[Bill Tozier]]",
            "id": "a754184e07926515dbbcef1dca733965"
          },
          {
            "type": "html",
            "text": "\nWould that make [[Python Language]], with its significant whitespace ([[Syntactically Significant Whitespace Considered Harmful]]?) a [[Graphical Programming Language]]? -- [[Earle Martin]]",
            "id": "3ffa782f5bfb2fbce8b19d772c6484c1"
          },
          {
            "type": "html",
            "text": "\nCertainly not. That would water down the term to the point of almost being meaningless. We like to have pages laid out in some kind of nice 2D format regardless of what is being displayed, but the information presented by properly indented [[Cee Language]] or [[Pascal Language]] is no different from the syntactically required whitespace in [[Python Language]] or [[Haskell Language]].",
            "id": "51987292f353b8b1939be3af0f6049e7"
          },
          {
            "type": "html",
            "text": "\nThis kind of thing just shows that it is difficult to create strict definitions that capture true intentions and creates a 100% correct dividing line between true category members versus non-members. That's an issue with all definitions, not just this one.",
            "id": "46b23554fb32ea167e87d496d81f1d47"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "There is one neat language with graphical syntax: Aardappel by prolific language designer [[Wouter Van Oortmerssen]].",
            "id": "1da24edc5a04ddac6531e67c4f3102d4"
          },
          {
            "type": "html",
            "text": "\n[http://wouter.fov120.com/aardappel/index.html wouter.fov120.com]\n[http://www.google.com/search?q=cache:wouter.fov120.com/aardappel/ www.google.com]",
            "id": "75762ff05eb99b3eb7c8b488580a0e77"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "The [graphical language] that I use and like is [[Lab View]] [i.e. [[Gee Language]]]. Initially, HP came up with the idea, but they thought it would never fly. When [[National Instruments]] [[http://www.natinst.com www.natinst.com]] picked the idea up and made it a pretty big success, HP thought they could resurrect their own in HP-VEE. Labview did start out with modules written in another language, but it has extensibility and allows you to bring in code from other languages. -- [[Ben Willems]]",
            "id": "58b6e116871598069e47f18fbba2d980"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "Prograph is the closest to a true graphical language I've ever heard of, which used the [[Dataflow Programming]] paradigm for algorithm description.\nFairly recent page of links at [http://www.tritera.com/prograph.html www.tritera.com] and as far as I can tell it is still in commercial production although the company Pictorius looks as though they mainly do Java now.\n[http://www.pictorius.com/ www.pictorius.com] [[[Broken Link]]]",
            "id": "94a799a8c289ade5b5a89916973d7e6c"
          },
          {
            "type": "html",
            "text": "\nAnother interesting product was Serius, bought by Novell in 95 and renamed Visual [[App Builder]] which used visual programming to tie together components written in more conventional languages. There's a Byte article discussing Serius, Prograph et al:\n[http://www.byte.com/art/9407/sec12/art2.htm www.byte.com]",
            "id": "59a35508047221d368556331f57929a4"
          },
          {
            "type": "html",
            "text": "\nI have a longstanding fascination with different languages and development paradigms but never had a chance to try either of these (my mild amount of self-restraint comes down to only using stuff in a commercially-oriented project, I have a life!). -- [[Andy Dent]]",
            "id": "44c544636dab8d8a21dcdfa79b473316"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "\nI know that the Quest3D engine by Act-3D uses [a graphical language]. The program is for visual presentation of CAD designs, and many also use it for 3D games and things like that. Judging from the results this seem to work quite all right - especially for beginners.",
            "id": "882d5cde505c7011db41f701ca247981"
          },
          {
            "type": "html",
            "text": "\nAnd there are also [[Graphical Programming Language]]s in several high-end 3D applications like [[Maxon Cinema]] and [[Alias Maya]] (AFAIK). This is really a big help to create simple dependencies, that would otherwise need you to learn a special scripting language.",
            "id": "74052e27e7eee14d35d6f3aa384f06bc"
          },
          {
            "type": "html",
            "text": "\nAnd also there are several simple [[Game Makers]] that use a graphical approach - like [[Click Team]]s [[Multimedia Fusion]] (although different from the [[Lab View]] idea), among others. -- [[Thomas Schmall]]",
            "id": "082b66294cdb5f9cf0e62b112385f63d"
          },
          {
            "type": "html",
            "text": "\nNot to mention one really, really big one coming. [[Unreal Engine]] 3.0 will be using a multimodal [[Gee Language]]-style [[Graphical Programming Language]] called [[Kismet Language]]. Kismet will be primarily graphical, but include a text-mode for writing procedures that are easier in text (like mathematics). Keep in mind that this is the [[Unreal Engine]], which is notorious for having the entire classmodel of the whole engine represented in the scripting system (although many of the internal classes are \"hands off\"). In about a year, a very large and complete graphical programming application will be hitting the market (release for [[Unreal Tournament]] 2007 is slated for 2006). Plus, another, less popular but similar gamemaking app called [[Vir Tools]] already exists based on a similar multimodal language, although [[Vir Tools]] is considered a prototyping toy by gamedevs. -- [[Martin Zarate]]",
            "id": "ed6640dca643d8bbdf3bbd0a8aee7723"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "\nSee also [[Flow Based Programming]]. For some sample diagrams, see [http://www.jpaulmorrison.com/cgi-bin/wiki.pl?DrawFlow www.jpaulmorrison.com]. By the definition of [[Graphical Programming Language]] given above, it is only a partial one, as the graphical language is used to combine components written in various procedural languages, but we have found that the diagrams provide an excellent communication medium between users and developers, especially when most of the components have simple, self-explanatory functions, e.g. readers, writers, sorts, merges, etc. In addition the \"port\" concept allows these components to be generalized functions that are prewritten and pretested. Even the application-specific components can be given names like \"generate report\", \"summarize\", \"access such and such a database\", etc., that help with the visualization process. -- [[Paul Morrison]]",
            "id": "af56086351ca444733e6fbb80e2944bd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "<i>On the term \"visual programming language\":</i>",
            "id": "318a09d735e1b50388d3f68a07183178"
          },
          {
            "type": "html",
            "text": "\nI think that the term \"visual\" itself is pretty poor. All programming languages that I know of are visual. You look at the text. I'm sure that there are some blind programmers out there, but I shudder to think of them using C++. Imagine what that would sound like? Or, feel like in braille?",
            "id": "6c2c7798f7d0dbd5a8826623e4b26704"
          },
          {
            "type": "html",
            "text": "\nI think the nomenclature predates the prevalence of the GUI, so it's a historical name. I agree that all languages are \"visual\" in the sense you mean - the distinction here is between languages you type, and languages you draw. The latter ones are \"visual\" in the way the term is technically used. -- [[Bill Tozier]]",
            "id": "0024ff931c3906fb0b22890a44b83c40"
          },
          {
            "type": "html",
            "text": "\n[[Micro Soft]] has been using the word \"visual\" in [[Visual Basic]] and related development platforms for some time, but frankly the only thing that is \"visual\" about them is a handy way of building the layout of interface components. Sadly, over the years this has undermined the efforts to produce real visual/graphical languages like those referenced above.",
            "id": "bee171e688707bd78ed828c5f76c3192"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "I know that in the past graphical programming languages have been a joke. But recently I've been wondering if there was a way to create a serious graphical programming language. I think that such things could have numerous advantages. One possible one would be to be able to more intuitively see how a program works. Another idea was that we could get rid of the textual vagaries that make smart development environments a pain to write.",
            "id": "800504f31f5d82a7e7fa9e556a8f0d11"
          },
          {
            "type": "html",
            "text": "\nThe first thing that would need to be done differently is that the idea that this would be simpler than text programming has to go. What else would have to be different to make it work? Is anyone else doing research on this area?",
            "id": "b3b3ec5311242689c3d4249ee04deacf"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "(moved from [[Future Of Programming Languages]])",
            "id": "6edfe248d8ae6f6a2f5510bf774a6f65"
          },
          {
            "type": "html",
            "text": "\nI'm not sure the future of programming languages is even a \"language.\" I imagine that we'll be connecting components on a bus architecture. We'll rely on visualization, because the layout of the code will be much more schematic than it has been. We've moved in computing from more linear algorithmic (flow-charts) to the more divergent (UML [[Class Diagram]]s, for example.) I can only see this continuing: The relationships between modules will become increasingly less linear, and we will find that our expressive technology will be a problem.",
            "id": "cf1ea396d199977a3c344c2236ea6c32"
          },
          {
            "type": "html",
            "text": "\nWhen we finally make a good GUI platform, we'll find that our languages suddenly leap into the realm of schematics.",
            "id": "94e7216b4567b5a943ec142a6ae876e3"
          },
          {
            "type": "html",
            "text": "(What sucks about GUI technology right now? It's so primitive, that's what! Sure, it's great if all you need are buttons, text boxes, combo boxes, and trees. But <i>good</i> GUI technology will make it easy to program by setting icons down on a surface, rotate them, give icons awareness of neighboring icons, and how they are situated with respect to one another, automatically mirror internals in the external display, allow people to easily compose icons, shift scale, etc., etc., etc.,. The GUI technology we have now is <i>peanuts</i> compared to what we need. The only reason we're still using text, isn't because we love linearity. No, it's because it's the easiest to navigate and work with, <i>right now.</i>)",
            "id": "294bf3e8f880f639ece5a440021cf742"
          },
          {
            "type": "html",
            "text": "-- [[Lion Kimbro]]",
            "id": "5c7ef1657ea8a9137a369d05b25686c1"
          },
          {
            "type": "html",
            "text": "\nI'm going to be contrary, and say that the primary representation of programming will continue to be textual, though there may be visual views that are useful in certain circumstances or other alternate views. (For instance, the modern class browser is graphical, but is still fundamentally text based. Dialog boxes are borderline, but while the dialog box itself is probably best understood graphically, there's still an underlying text program that is the core of the functionality.)",
            "id": "e9f21f692e5be98c708c36f71b0c0bf7"
          },
          {
            "type": "html",
            "text": "\nWhile I normally hate to analogize computer languages to natural languages, computer languages won't become visual for reasons almost identical to the ones that have natural languages moving <i>away</i> from visual representations, not towards, even today. Other than visually pleasing typography, playing with visual representations like spiral typesetting or dense visual symbology is mostly the domain of poets and artists, not people seriously trying to communicate. Looking and seeing visual information is easy. Manipulation is fundamentally more difficult; so much so that I've never seen anyone come even close to a truly visual programming paradigm that actually works usefully beyond the \"hello world\" example. Too much software just isn't manipulable visually, and showing the few cases where it may be hardly disproves that.",
            "id": "2f023da2cac05eef725affcef153a410"
          },
          {
            "type": "html",
            "text": " I agree, but just to nitpick, [[Prograph Language]] and [[Lab View]]'s [[Gee Language]] are two successful truly [[Graphical Programming Language]]s. Both are 20 years old, though, and never took the world by storm (the former, in fact, is in limbo until an open source effort recreates it, and the latter is niche: equipment control and data analysis), so there's no reason to think that \"some day all will be visual\". Likewise [[Toon Talk]] is a cool 100% [[Graphical Programming Language]], suitable for teaching children, and very powerful, but again isn't gaining many converts. Excellent visual programming languages have been done. Few care.",
            "id": "8136cb475f625fdd2e1d452bbb0f6e65"
          },
          {
            "type": "html",
            "text": " the problem is that's pretty slim pickings.  [[Gee Language]] is trapped in [[Lab View]], as are most [[Graphical Programming Language]]s that were designed to be domain-specific ([[Kismet Language]], [[Vir Tools]], etc.) and [[Prograph Language]] is dead.  There is no current, live, general-purpose [[Graphical Programming Language]].  I haven't even heard of some sort of pathetic little opensource effort to make a G clone.  Nothing.  When do we get GDotNet or something similar?",
            "id": "ad3bcd914571b0801415a1a1d6285452"
          },
          {
            "type": "html",
            "text": "\nThis is another one of those \"In fifty years\" predictions that keeps receding at the rate of one year per year. The reason is that it sounds really cool if you just hand-wave it into existence, but there are fundamental flaws with the approach that severely limit its usefulness.",
            "id": "62f244604ccb93a23f652cccfa4c19c5"
          },
          {
            "type": "html",
            "text": "\nThat said, there's significant room for the continuing advancement of the re-factoring editor that understands more about the actual syntax of the program and may be able to do wild visualizations that may even be helpful; my point is not that no visualization progress will happen but that for serious programmers, the text representation will continue to be the \"real program\".",
            "id": "70bb38a92a56fb16e8a04c5660da9015"
          },
          {
            "type": "html",
            "text": "<i>I'd predict that we will move to a multi-modal style. Sometimes a textual view is better, sometimes graphical. As tools improve, we'll have various ways to \"frame the code\". Dependency graphs and visual gui editors are excellent complements to textual code.</i> ",
            "id": "68f1d6744812e73a3865a5bdacbd7621"
          },
          {
            "type": "html",
            "text": "\nI can't resist putting in my 2 bits: [[Flow Based Programming]] (FBP) is a very visual coordination language that allows the programmer to combine asynchronous components into a 2-dimensional network. Because communication is via ports, it lends itself to prewritten, pretested componentry, so it cries out for a visual interface, which could easily be extended to have quite a lot of smarts, e.g. knowledge of what ports a given component uses - put them up on the screen, connect them, run it, and maybe even watch the data as it travels (test mode, not production!). ",
            "id": "95ac50184a241772d4c881ba826e856c"
          },
          {
            "type": "html",
            "text": "\nThe components can be written in any language that understands data packets - granted that the components are coded in text right now, but if they are reusable components, who cares what language they were written in? However, some business transforms can be very visual - some components in the network will eventually be generated from pictures themselves. FBP has been in continuous use at a bank for 30 years - we were using it for production work long before we had decent graphics support (we used biiig sheets of paper!). Now we've got the technology: anyone want to step up to the challenge? The thing might finally take off! -- [[Paul Morrison]]",
            "id": "188a16bca582543ca06727dd208988ff"
          },
          {
            "type": "html",
            "text": "\nI've been thinking about it. The gap between your book and the issue of what support to put into a programming language is fairly large. I'm accustomed to bridging such gaps, but still...any comments on that? -- [[Doug Merritt]]",
            "id": "a620e3e216174ce300446291698d820f"
          },
          {
            "type": "html",
            "text": "\nWhat kind of support? Organizational? An IDE? Money?! Could you expand on your question? Bridging gaps is good - that's what Pontifex means. :-) -- [[Paul Morrison]]",
            "id": "87994d0035eaf9e088acb1478e4e057f"
          },
          {
            "type": "html",
            "text": "\nI just mean language constructs to support FBP natively. Or similarly, the ideal set of library functions to support FBP. -- dm",
            "id": "2980e4b8d5e57821c4bda828a86382c8"
          },
          {
            "type": "html",
            "text": "...",
            "id": "3432e2d557e013591bd229cef2eac3cb"
          },
          {
            "type": "html",
            "text": "<i>Never mind, I'll just stick with the FBP primitives I invented for the 1983 version of the language in question.</i>",
            "id": "ef8be46f1d3f9d18572d791b5208e3c1"
          },
          {
            "type": "html",
            "text": "\nCan you point us at them? Maybe put something up on the FBPWiki? -- pm",
            "id": "353ada5a5e106de4f08954b28ca69429"
          },
          {
            "type": "html",
            "text": "\nThat said, I could see having a small number of mini-languages running in the FBP environment whose job is to shift stuff from input ports to output ports, perhaps with small transformations, subtotals, etc. Approximately the expressive level of RPG, or less. In fact, as I suggested elsewhere, the logic could even be specified graphically, given an appropriate IDE (imagine a business-oriented [[Toon Talk]] :-)). Remember that FBP is primarily a <i>coordination</i> language, so there is no need to push a language (any of the ones used for writing components) beyond its comfort level!",
            "id": "f788e68b33fcffd35c949332c3248960"
          },
          {
            "type": "html",
            "text": "\nMore generally, I think a possible approach would be to establish a lowest common denominator for communication between FBP components, and I think this should probably be ASCII strings, probably with embedded delimiters, which I guess nowadays sounds a lot like XML! Except that the overhead involved means that you should only do this at the boundary between component vendors - between components that are more closely related we need a convention that is not so CPU-intensive! However, FBP <i>is</i> a natural environment to support streaming XML parsers. I wrote one using the so-called \"Babel Parser\" ([http://www.jpaulmorrison.com/cgi-bin/wiki.pl?BabelParser www.jpaulmorrison.com]) for the project we did in JavaFBP (the Java implementation of FBP), and we multiplexed it (3 ways) to take advantage of the multiple processors on our machine.",
            "id": "88ba2f880a79e6e434f15e025ebf0f89"
          },
          {
            "type": "html",
            "text": "\nIf we assume also that, in the PC world, code components can always be turned into DLL/.so libraries, then we can use FBP to hook together any languages that understand ASCII strings, and that can be compiled to a DLL/.so. I am also assuming that most compiled languages can handle pointers to ASCII strings... Languages that require VMs would require native interfaces. In such an environment, some threads would be running essentially machine language (generated by the compiler of your choice), and others would be interpretive using VMs - then hopefully there would be no need for a VM to support multiple threads. This would then give us the rather neat ability to write individual FBP components initially in a scripting (interpretive) language, and then switch to compiled code for performance reasons at a later stage in a project's life-cycle (avoiding [[Premature Optimization]]).",
            "id": "46a567a6f5eae21b7525497233c939b4"
          },
          {
            "type": "html",
            "text": "\nLooking into this, I realize that I didn't publish the JavaFBP component API yet, although it is in the jar file on my web site. I've put the APIs for THREADS and JavaFBP (the C++ and Java implementations of FBP, respectively) into [http://www.jpaulmorrison.com/cgi-bin/wiki.pl?FbpApi www.jpaulmorrison.com].",
            "id": "79c4099bab6f43442ca6b401dc83fb78"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "I think Rocky's Boots [[http://www.warrenrobinett.com/rockysboots/ www.warrenrobinett.com]] and Robot Odyssey [[http://members.aol.com/Fractal101/odyssey.htm members.aol.com]] deserve mention here.",
            "id": "7a79dc88b498919a82123596e7437933"
          },
          {
            "type": "html",
            "text": "\nLabview uses true graphical programming (G language).\nIt's a very intuitive way to program.\nIn my opinion, about 10 times faster than old-style text-based programming for most applications.",
            "id": "d91d4f9a17eebb16f57ebebc4425862f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "\nI'd be interested in learning what it would take to integrate graphical programming with a more traditional text-based programming language.  I don't believe that graphical programming entirely lends itself to <i>general purpose</i> programming (e.g. they are generally inadequate for conceptually atomic processing steps... such as mathematical functions and initial data description).  However, the use of graphical languages have proven very natural for describing <i>flow</i> of any sort: [[Work Flow]], [[Data Flow]], and [[Signal Flow]].  They essentially allow the internal processes to be nameless, and abstract away much of the nasty interfacing between processes and objects.  It also allows for automatic zoomable interfacing, going from the 2000 meter view (inter-business processes, web services) down to the 10 cm view (the exact flow within a particular procedure within a particular process within a ...).  Such things are good for communicating to [[Pointy Haired Bosses]].",
            "id": "9197bbb669e785d14a8a40d169044163"
          },
          {
            "type": "html",
            "text": "\nHow difficult would it be to create a graphical programming language that handles those tasks but corresponds directly to the use of certain underlying text programming, such that the graphical programming language is just a [[Domain Specific Language]] for workflow, dataflow, signal flow, and that sort of thing, and a possibly typeful sublanguage of another language (Lisp, Ocaml, Haskell with Monads, etc.).  I imagine something like a common set of wrappers could do the trick... a limited set of domain specific languages that are readily and intuitively translated to and from graphical components, and that integrate with an underlying language in some well-defined way.  However, that still leaves the difficult parts: creating/identifying and integrating these [[Domain Specific Language]]s that are good for graphical programming, ensuring they cover everything you and other users will possibly need and that they provide for extensibility (graphical macros?), and creating an [[Object Browser]] for all of this.",
            "id": "2305bc2acec906ffbb2da0e3f203009d"
          },
          {
            "type": "html",
            "text": "\nKey to finding what DSLs we want is finding: What are the [[Limits Of Graphical Programming]]?  It's easy to make a graphical language that is turing complete, but at what point will users stop gaining and start losing?  Are the inherent limits different between 2D and 3D graphical programming?",
            "id": "c12c309f46956e7a1ae612b715018aa1"
          },
          {
            "type": "html",
            "text": "\nI posit that the limit of graphical programming is conceptual <b>atoms</b> -- values, mathematical (pure) functions, and calculations.  ",
            "id": "d41d97db111dea91a109556870309025"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "\n[[Kismet Language]] (the language of the upcoming [[Unreal Engine]] 3.0) has the system you described - a traditional, flow-based [[Graphical Programming Language]] with a c-like text language that can be embedded into blocks within the flow-code to handle things like arithmetic that are much better described in text.",
            "id": "08ddbb8bdbe43383062e254ab1ee2dc3"
          },
          {
            "type": "html",
            "text": "\nAnd I think that the \"managerial view\" is unlikely to be as nice as you think.  Consider how well managers can read Cobol.  Consider how little you learn from one function of the outermost code of your system - flow-based programming is functionally the same as traditional functional programming languages except that the threading is automagic.  All it is is \"take results from call Foo and send it to calls Bar and Baz as argument Quux\" - whether that's phrased as ",
            "id": "e97228ebffa4da846b3ea3484c95f6bd"
          },
          {
            "type": "code",
            "text": " tempfoo = Foo();\n Bar(tempfoo);\n Baz(tempfoo);",
            "id": "a2ef4a46df2566f6095dc148e5c1a6f2"
          },
          {
            "type": "html",
            "text": "or a line drawn from Foo to the Quux input on Bar and Baz is just semantics.  Theoretically, you could selectively \"expand\" functions just like one could theoretically \"inline\" important methods to make the logic more clear in a code view in a text language... but notice that nobody does.",
            "id": "7fe0af434cb175f1fc85cd6b09a22f33"
          },
          {
            "type": "html",
            "text": "<i>\"Consider how little you learn from one function of the outermost code of your system - flow-based programming is functionally the same as traditional functional programming languages except that the threading is automagic.\"</i> -- Do you mean procedural?  Technically, there is no <i>flow</i> when working with <i>functions</i> (in the mathematical sense); '1+1' is completely equivalent to '2'.  This is part of why I posit that functions/calculations/values cannot be readily transformed to graphical languages.  If you've fully described the flow, above, then: ",
            "id": "5d3324f716c51320584b9ad9c1aa8574"
          },
          {
            "type": "code",
            "text": "   myBlock = { tempfoo = Foo();\n               Bar(tempfoo);\n               Baz(tempfoo);    }",
            "id": "43de21b6e62d95c86bd105976fb0a926"
          },
          {
            "type": "html",
            "text": "is completely equivalent to:",
            "id": "d63d974627fa44adda6eaba90cd8fa7e"
          },
          {
            "type": "code",
            "text": "   myBlock = {}",
            "id": "c6e5d0fb39000335b06e2a06a49133a1"
          },
          {
            "type": "html",
            "text": "This is because nothing is flowing out of the block.  ",
            "id": "f547236d2c42dbb1cd411a45c609b3c2"
          },
          {
            "type": "html",
            "text": "\nNow, if Foo() returns an object instead of a value, or Bar or Baz have <i>side-effects</i>, these facts simply aren't being represented.  I.e. you cannot tell by looking at it whether tempfoo is a value (immutable) or object/actor/process/etc (which can send and receive messages).  You also cannot tell whether Bar and Baz send/receive signals to and from tempfoo, the world, both, or neither.  You can't even tell whether Foo() sends and receives any signals to and from the world or not.",
            "id": "c37b786e640e667621e0d045449fd832"
          },
          {
            "type": "html",
            "text": "\nThese things would be represented in a flow-based language.  It would be misleading to call the procedural code above the same as <i>outermost code</i> of a flow-based language because there is no indication of what is flowing or how it is flowing.  And while one can produce a language that is computationally equivalent to a turing-complete procedural language, it wouldn't be right to call that language a <i>flow</i> language unless it is representing the right sorts of things -- flows in particular.  ",
            "id": "08c51c2f92afc130aef9f262300ca5f7"
          },
          {
            "type": "html",
            "text": "\nA language that actually captures the <i>flow</i> should allow you to learn a great deal by looking at the <i>outermost code of your system</i>, even if you 'box' certain processes (e.g. with Bar and Baz) to allow for something of zoomable interface and software componentry.  In particular, you should be able to learn every single source and destination for messages to and from those boxes (or some abstraction on that, e.g. if input data contains references for connections).  You'll have graphically captured the <i>side effects</i>, or at least identified their potential sources.  You should be able to figure out where signals are going, and where signals are coming from.  For fully typed flow-based language, ideally, you should also be able to look at it and learn both legal protocols (message patterns between two boxes on a single, connected line of 'flow' that don't cause runtime exceptions to propogate out of the 'box') and identify some emergent behavior (patterns of connections, for example).",
            "id": "9f5fb067c29c01bee92aa9ae9a432c28"
          },
          {
            "type": "html",
            "text": "\nI imagine that type Bar(Foo) in a flow-based language would simply be an abstraction that hooks up an object with a Foo interface to a process Bar.  Connecting the W<b></b>orldObject (or R<b></b>ootObject) to Foo and Bar would be a separate task... a separate connection, a separate <i>flow</i>.",
            "id": "80d1fe225ef52e5f2ed7adcbfd78128e"
          },
          {
            "type": "html",
            "text": "<i>You might want to look into [[Subtext Language]]. It doesn't loose the flow - quite the opposite. It may be only partly graphical in that it still uses functional expressions (except for the schematic table part), but it </i>does'' make all flow visible (more so than the code itself).\nSee the demo at [http://subtextual.org/demo1.html subtextual.org] -- [[Gunnar Zarncke]]''",
            "id": "4a0c4d1a5ee00e6df1194aa842e328a0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "bd15d2b49d1fdc6f37e4fdc359f94a8a"
          },
          {
            "type": "html",
            "text": "\nI think some graphic/visual languages are missing from this wiki:",
            "id": "bb8b42981e32f8ee17613ee7a289ce55"
          },
          {
            "type": "html",
            "text": "\nLimnor Studio: A visual programming language for .NET currently free (April 2011) [http://limnor.com/ limnor.com]",
            "id": "68c4976393a7bcbd14e98bdc85eac201"
          },
          {
            "type": "html",
            "text": "\nTersus: Commercial and open source versions (MS Windows, Linux) development of Windows, Linux, web, Android and Iphone applications [http://www.tersus.com www.tersus.com]",
            "id": "83d9941864ea6c9b1f4255120ae238a7"
          },
          {
            "type": "html",
            "text": "\nGoogle App Inventor: Open source development tool for Android OS, [http://appinventor.googlelabs.com/about/ appinventor.googlelabs.com] ",
            "id": "7d356f123da1aa35cd8d424fba108b82"
          },
          {
            "type": "html",
            "text": "\n[[Category User Interface]]",
            "id": "9080601972532a0ddfa213ea219dbfe1"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?GraphicalProgrammingLanguage c2.com]",
            "id": "f304d6127fdbe375b5c6814f92784370"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1707806910790
    }
  ]
}