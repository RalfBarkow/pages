{
  "title": "Database Functions in Elm-Time",
  "story": [
    {
      "type": "paragraph",
      "id": "c3c4afe256c1c0e1",
      "text": "Easy Database Updates in Production [https://michaelrätzel.com/blog/database-functions-in-elm-time-easy-database-updates-in-production blog]"
    },
    {
      "type": "video",
      "id": "c161f46fe4bc472c",
      "text": "YOUTUBE 9mFjdf_ABNM\n[[Elm-Time]] v2023-05-07"
    },
    {
      "type": "paragraph",
      "id": "91a75c188a2ba953",
      "text": "hello everyone this week I added a new \nfeature in Elm-Time and this enables us to   take a custom update function written in Elm and \napply that to an online database in production so   how does that work?"
    },
    {
      "type": "paragraph",
      "id": "8447352f46ab3262",
      "text": "I've got an example here and \nthis is a backend application written in Elm this   is a typical web service main declaration and in \nthe State type of our database you can see we have   this collection of user accounts and we might want \nto make a change here from time to time manually   so some changes will happen automatically \nvia the main update function but sometimes   we might to make a change without having \nto code it in our main update function first   to do this we add this module here \nwhen we add an Elm module with this name   into our project Elm-Time picks up the \nfunction declarations from this module   and exposes them on the admin interface and we've \ngot two new HTTP endpoints we have one to list   the exposed functions and one to apply a function \nlet's try this I've deployed this app here locally   and one way to use this new feature \nis via the command line interface   there are two new commands to support \nthis list functions and apply function so I can use list functions on my \nlocal instance here to get an overview in this way I see the type signatures of the   exposed functions in the graphical admin interface \nwe also have a listing of the exposed functions   and we can click on them to select them and see \nmore details when we've selected one of these   we can enter the the arguments that we want to \nuse to apply that function so this one has two   parameters the second one has the same type as the \nbackend state type so the runtime figures that   it will take the value from the from the \ndatabase so we don't need to enter that value   but we enter the value for the first argument \nso we enter the arguments manually and then we   can use this button to apply that function you \nalso get this info from the runtime telling us   that The Returned value is still the same \nwe've used in an ID here that doesn't exist   so nothing changed here in the backend State we \ncan use an ID that actually exists and see that get a different state now but that was not committed what does that \nmean we don't have to commit the new state   to the main branch when we are ready to do that we \nexplicitly confirmed this here so in the command   line interface we have an option to do that and \nonce we've applied this function for real we can   see the change reflected in the database state \nso this is how we can update the database of an Elm   backend without any downtime that's it from me for \ntoday thanks for watching and see you next time"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Database Functions in Elm-Time",
        "story": []
      },
      "date": 1711535915401
    },
    {
      "item": {
        "type": "factory",
        "id": "c3c4afe256c1c0e1"
      },
      "id": "c3c4afe256c1c0e1",
      "type": "add",
      "date": 1711535938165
    },
    {
      "type": "edit",
      "id": "c3c4afe256c1c0e1",
      "item": {
        "type": "paragraph",
        "id": "c3c4afe256c1c0e1",
        "text": "Easy Database Updates in Production"
      },
      "date": 1711535941710
    },
    {
      "type": "edit",
      "id": "c3c4afe256c1c0e1",
      "item": {
        "type": "paragraph",
        "id": "c3c4afe256c1c0e1",
        "text": "Easy Database Updates in Production [https://michaelrätzel.com/blog/database-functions-in-elm-time-easy-database-updates-in-production blog]"
      },
      "date": 1711535951562
    },
    {
      "id": "c161f46fe4bc472c",
      "type": "add",
      "item": {
        "type": "video",
        "id": "c161f46fe4bc472c",
        "text": "YOUTUBE 9mFjdf_ABNM"
      },
      "after": "c3c4afe256c1c0e1",
      "attribution": {
        "page": "2024-03-27"
      },
      "date": 1711535955963
    },
    {
      "item": {
        "type": "factory",
        "id": "91a75c188a2ba953"
      },
      "id": "91a75c188a2ba953",
      "type": "add",
      "after": "c161f46fe4bc472c",
      "date": 1711535998751
    },
    {
      "type": "edit",
      "id": "91a75c188a2ba953",
      "item": {
        "type": "paragraph",
        "id": "91a75c188a2ba953",
        "text": "hello everyone this week I added a new \nfeature in Elm-Time and this enables us to   take a custom update function written in Elm and \napply that to an online database in production so   how does that work? I've got an example here and \nthis is a backend application written in Elm this   is a typical web service main declaration and in \nthe State type of our database you can see we have   this collection of user accounts and we might want \nto make a change here from time to time manually   so some changes will happen automatically \nvia the main update function but sometimes   we might to make a change without having \nto code it in our main update function first   to do this we add this module here \nwhen we add an Elm module with this name   into our project Elm-Time picks up the \nfunction declarations from this module   and exposes them on the admin interface and we've \ngot two new HTTP endpoints we have one to list   the exposed functions and one to apply a function \nlet's try this I've deployed this app here locally   and one way to use this new feature \nis via the command line interface   there are two new commands to support \nthis list functions and apply function so I can use list functions on my \nlocal instance here to get an overview in this way I see the type signatures of the   exposed functions in the graphical admin interface \nwe also have a listing of the exposed functions   and we can click on them to select them and see \nmore details when we've selected one of these   we can enter the the arguments that we want to \nuse to apply that function so this one has two   parameters the second one has the same type as the \nbackend state type so the runtime figures that   it will take the value from the from the \ndatabase so we don't need to enter that value   but we enter the value for the first argument \nso we enter the arguments manually and then we   can use this button to apply that function you \nalso get this info from the runtime telling us   that The Returned value is still the same \nwe've used in an ID here that doesn't exist   so nothing changed here in the backend State we \ncan use an ID that actually exists and see that get a different state now but that was not committed what does that \nmean we don't have to commit the new state   to the main branch when we are ready to do that we \nexplicitly confirmed this here so in the command   line interface we have an option to do that and \nonce we've applied this function for real we can   see the change reflected in the database state \nso this is how we can update the database of an Elm   backend without any downtime that's it from me for \ntoday thanks for watching and see you next time"
      },
      "date": 1711536000883
    },
    {
      "type": "edit",
      "id": "c161f46fe4bc472c",
      "item": {
        "type": "video",
        "id": "c161f46fe4bc472c",
        "text": "YOUTUBE 9mFjdf_ABNM\n[[Elm-Time]] v2023-05-07"
      },
      "date": 1711536045985
    },
    {
      "type": "edit",
      "id": "91a75c188a2ba953",
      "item": {
        "type": "paragraph",
        "id": "91a75c188a2ba953",
        "text": "hello everyone this week I added a new \nfeature in Elm-Time and this enables us to   take a custom update function written in Elm and \napply that to an online database in production so   how does that work?"
      },
      "date": 1711536091919
    },
    {
      "type": "add",
      "id": "8447352f46ab3262",
      "item": {
        "type": "paragraph",
        "id": "8447352f46ab3262",
        "text": "I've got an example here and \nthis is a backend application written in Elm this   is a typical web service main declaration and in \nthe State type of our database you can see we have   this collection of user accounts and we might want \nto make a change here from time to time manually   so some changes will happen automatically \nvia the main update function but sometimes   we might to make a change without having \nto code it in our main update function first   to do this we add this module here \nwhen we add an Elm module with this name   into our project Elm-Time picks up the \nfunction declarations from this module   and exposes them on the admin interface and we've \ngot two new HTTP endpoints we have one to list   the exposed functions and one to apply a function \nlet's try this I've deployed this app here locally   and one way to use this new feature \nis via the command line interface   there are two new commands to support \nthis list functions and apply function so I can use list functions on my \nlocal instance here to get an overview in this way I see the type signatures of the   exposed functions in the graphical admin interface \nwe also have a listing of the exposed functions   and we can click on them to select them and see \nmore details when we've selected one of these   we can enter the the arguments that we want to \nuse to apply that function so this one has two   parameters the second one has the same type as the \nbackend state type so the runtime figures that   it will take the value from the from the \ndatabase so we don't need to enter that value   but we enter the value for the first argument \nso we enter the arguments manually and then we   can use this button to apply that function you \nalso get this info from the runtime telling us   that The Returned value is still the same \nwe've used in an ID here that doesn't exist   so nothing changed here in the backend State we \ncan use an ID that actually exists and see that get a different state now but that was not committed what does that \nmean we don't have to commit the new state   to the main branch when we are ready to do that we \nexplicitly confirmed this here so in the command   line interface we have an option to do that and \nonce we've applied this function for real we can   see the change reflected in the database state \nso this is how we can update the database of an Elm   backend without any downtime that's it from me for \ntoday thanks for watching and see you next time"
      },
      "after": "91a75c188a2ba953",
      "date": 1711536093235
    }
  ]
}