{
  "title": "External Polymorphism",
  "story": [
    {
      "type": "html",
      "text": "Any mechanism for implementing polymorphism that is external to the definition of the object displaying polymorphic behavior. Switch statements based on a type code are probably the simplest of such mechanisms. ",
      "id": "ad76c3979fb9819c89a7a7dea1e07093"
    },
    {
      "type": "html",
      "text": "\nThere are other, more ingenious mechanisms, available as well:",
      "id": "278ca2f0b0c0c7dfcbb914dee55be31b"
    },
    {
      "type": "html",
      "text": " The paper \"External Polymorphism -- An object structural pattern for transparently extending C++ concrete data types\" by Cleeland, Schmidt, and Harrison cleverly combines dynamic binding and the template mechanism. [http://www.cs.wustl.edu/~schmidt/PDF/External-Polymorphism.pdf www.cs.wustl.edu]",
      "id": "c664ef04d237379d95a3c0061ba51e31"
    },
    {
      "type": "html",
      "text": " The [[Generic Function]] (which is used by the [[Translator Pattern]]) uses a hashtable with class names as keys and corresponding functions (see [[Function Object Pattern]]) as values.",
      "id": "800e57e0173c53687fc08f29dd0c9130"
    },
    {
      "type": "html",
      "text": " [[Multi Methods]] -- methods that are polymorphic on all of their arguments rather than one. Implemented in languages such as [[Common Lisp Object System]], [[Dylan Language]], [[Cecil Language]], and [[Nice Language]]. These are useful for [[External Polymorphism]] even if having a single (polymorphic) argument, as they can be implemented without changing the underyling class.",
      "id": "8a8458495b24b65a2f507f71018203da"
    },
    {
      "type": "html",
      "text": " [[Table Oriented Programming]]? :)",
      "id": "b2e16d883de7360beca811819eee3f92"
    },
    {
      "type": "html",
      "text": "\nAlso see [[On Understanding Types]].",
      "id": "53b85793f027e43f1db1113518bd48b4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a65440441759b0036426ced53a7e75e4"
    },
    {
      "type": "html",
      "text": "\nIt should be said that, while [[External Polymorphism]] is often necessary (particularly in languages with unsubclassable features) it should be avoided wherever possible. It breaks the encapsulation inherent in OOP. Better to rely on the public attributes of an object than it's type - even if that means defining enums to describe the type's features.",
      "id": "ae7bf51204adeff251e821d0bfec8e29"
    },
    {
      "type": "html",
      "text": "\nFor example, ground-vehicle is subclassed to Car and Bus. Class Ferry checks whether type is Car or Bus to determine where to store Bus, because Bus is larger. However, a Minibus, subclassed from Bus, can fit in the same space as a Car - so a larger Bus slot is wasted. If attributes were used, this mistake would have been avoided.",
      "id": "57c2e28ae051d976a5b6d9d6a2971481"
    },
    {
      "type": "html",
      "text": "\nA common multimethod example is [[Rock Paper Scissors]]. By using extrinsic polymorphism, you require that subclasses of Scissors always be treated as Scissors, even if they have all of the attributes and features of Rock. Rather, it would make more sense to define an enum \"Rock, Paper, Scissors, Other\" and simply have each class return an entry from that on request. Thus, it would be painfully obvious to subclassers how the behaviour worked, rather than having inscrutable information hidden in an externally dispatched system.",
      "id": "b53766ea79904bacfc216a9bd8ad4387"
    },
    {
      "type": "html",
      "text": "\nIn other words: only use [[External Polymorphism]] if you are forced to - usually if you have no control over the design of the classes you work with.",
      "id": "ef348c8813aa43b630da9fa5febcada5"
    },
    {
      "type": "html",
      "text": "-- [[Martin Zarate]]",
      "id": "88044ca936bd228c67a8a6ffdd98dcae"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a65440441759b0036426ced53a7e75e4"
    },
    {
      "type": "html",
      "text": "\nA polymorphic method on an object can be thought of as a sort of super function. That is, it is one conceptual function that has several implementations that are customized according to the dynamic type of the object they are bound to. As long as the different implementations support [[Liskov Substitution]] it appears to clients as if there is only one function. Implementing this conceptual function using [[Internal Polymorphism]] causes the custom implementations to be cohesive to the types that specialize them so that when a new type is added it contains its own specialization of each polymorphic function it is associated with. [[External Polymorphism]] causes the custom implementations to be decoupled from the types upon which they are specialized and allows them to be cohesive to some other location. When a new function is added it contains its own specialization for each type it is associated with. So instead of messages being polymorphic with respect to the objects that they are sent to, we have functions that are polymorphic with respect to the object(s) that are passed to them as parameters.",
      "id": "c33152224a9e784b6773248c9bdc11fc"
    },
    {
      "type": "html",
      "text": "\nIn the imperative sentence: \"Joey, hit that ball!\", \"Joey\" is an active noun and \"ball\" is passive. [[Internal Polymorphism]] allows objects in an active role to vary their behavior based on their type. [[External Polymorphism]] allows the behavior of objects in a passive role to vary based on their type.",
      "id": "dd4ef5c1a78513304bb9925d0fcecd5c"
    },
    {
      "type": "html",
      "text": "\n[[External Polymorphism]] makes it difficult to add new types because when a new type is added every relevant function that is implemented with [[External Polymorphism]] must be found and specialized for the new type. On the other hand, [[Internal Polymorphism]] makes it difficult to add new functions because every implementing type must be updated with a new function definition.",
      "id": "cb4c87802b993c1fb9c96196829af0f5"
    },
    {
      "type": "html",
      "text": "\nActually, [[External Polymorphism]] makes is hard to add new types <b>if functions need to be defined in one block</b>, like in [[Functional Programming Language]]s with functions defined by [[Pattern Matching]]. It poses no problem if each case of a function (method) can be defined independently, like with [[Multi Methods]] and [[Predicate Dispatching]].",
      "id": "6967ecda8d3e253938160c1769b020d8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a65440441759b0036426ced53a7e75e4"
    },
    {
      "type": "html",
      "text": "Where can the \"External Polymorphism\" paper be found? -- [[Ted Neward]]",
      "id": "1371fdb40af86653a0e1c96e2ffbc971"
    },
    {
      "type": "html",
      "text": "\nHere: [http://www.cs.wustl.edu/~schmidt/PDF/External-Polymorphism.pdf www.cs.wustl.edu]",
      "id": "932c0f7924953c73bd598059e886c88c"
    },
    {
      "type": "html",
      "text": "\nIt's also available in MoreCPlusPlusGems starting on page 417. -- [[Chris Cleeland]]",
      "id": "d4cd0160891ed4dc2d611d37ea9839d9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a65440441759b0036426ced53a7e75e4"
    },
    {
      "type": "html",
      "text": "\nDoes anyone have an idea how to implement/fake [[External Polymorphism]] in Java? I'm tired of instanceof. -- [[Michael Schuerig]]",
      "id": "1b31d8e673389e6ada8dd3a7a47a8167"
    },
    {
      "type": "html",
      "text": "\nYou could use a dialect of Java that supports [[Multi Methods]]. See for instance the [[Nice Language]]. This solution requires that you use another compiler than javac (but java bytecodes are generated). On the other hand, the advantage is that the compiler, understanding what your are doing, can provide you with a nicer syntax, meaningful error messages, and can perform more static checking.",
      "id": "d1184a1dc47e2c94efe60df80c4ee27f"
    },
    {
      "type": "html",
      "text": "\nS<i>[from [[External Polymorphism]]] Does anyone have an idea how to implement/fake [[External Polymorphism]] in Java? I'm tired of instanceof. --[[Michael Schuerig]]</i>",
      "id": "82565f43c0530f99753d4bd799db0fae"
    },
    {
      "type": "html",
      "text": "\nThe key pieces would be a hash table and a static method. Since the static method will use it, the hash table should probably be static too. The static method takes an Object parameter and implements polymorphism by calling getClass() on the Object, using the resulting class as a key into the hash table to retrieve the implementation code and then delegating the call to that code.",
      "id": "48ce589c0115c778f34386efac5a6223"
    },
    {
      "type": "html",
      "text": "\nThe implementation code should probably be an instance of an inner class that implements an interface with a method that takes an Object parameter, converts it to it's proper type and then performs the desired operation. -- [[Phil Goodwin]]",
      "id": "28b5f10068f330a0a697f0db21451ac0"
    },
    {
      "type": "html",
      "text": "\nSounds like an instance of [[Collection And Loop Vs Selection Idiom]]. -- [[Michael Schuerig]]",
      "id": "9f696e3601593fce96cab2a11d7eacac"
    },
    {
      "type": "html",
      "text": "\nExcept there's no loop hash table lookups are much faster than the linear time it takes to loop through an array - at least if you have more than a couple of items. -- pg",
      "id": "0939a2afde63cbc7209480c2d1fe5fd5"
    },
    {
      "type": "html",
      "text": "\nBut hash tables have the drawback that they don't take subtyping into account. -- ms",
      "id": "b937ac8774d7438f539f228f083b7eae"
    },
    {
      "type": "html",
      "text": "\nHmm, yes, that's interesting, you'd either have to fill the table with all the types you were going to use (often workable) or implement a best-fit algorithm in order to determine which code to execute when an exact match can't be found. -- pg",
      "id": "8f3015f8059dff73476186ab4efd4a12"
    },
    {
      "type": "html",
      "text": "\nYou'd have to reimplement [[Multiple Dispatch]]. Actually, someone has already done this. See [[Method Thread]]. -- ms",
      "id": "b4ddc872ac1a5e50e213a15de079fbcf"
    },
    {
      "type": "html",
      "text": "\nI don't see the relationship. I mean, you <i>can</i> implement [[Multiple Dispatch]] as part of [[Generic Function]], that would be very useful, but I don't see why you'd have to. You just need a mechanism to search for entries that match one of the antecedents of the type in question. - pg",
      "id": "236959e7f1caa0acbe9aa09bc1d045ee"
    },
    {
      "type": "html",
      "text": "\nBut that <i>is</i> single dispatch, and in a language like Java you now have a method that is associated with two classes; it dispatches on both. -- [[Graham Hughes]]",
      "id": "97bfe83feb097673e99a7400521e5d4f"
    },
    {
      "type": "html",
      "text": "\nPolymorphism is where you have a method that is associated with more than one class and dispatches at runtime based on dynamic type information. [[Internal Polymorphism]] is when that method is owned by the classes that it can dispatch to - the classes elaborate the dispatch mechanism by defining which code will finally implement the call. [[External Polymorphism]] is when some agent other than the classes owns the right to elaborate the dispatch mechanism. ",
      "id": "bc402c6ee2b96e8be2d17a32bbe60a8d"
    },
    {
      "type": "html",
      "text": "\n[[Single Dispatch]] is a kind of Polymorphism where the dispatch mechanism works against a single dynamic type. I don't know of any [[Internal Polymorphism]] implementation that doesn't use [[Single Dispatch]]. [[Multiple Dispatch]] is where more than one dynamic type is used to make the dispatch decision. [[External Polymorphism]] allows and even seems to inspire [[Multiple Dispatch]] as well as dispatch based on information other than type information.",
      "id": "b868a55b90ef2c69f2e77a161791a8fb"
    },
    {
      "type": "html",
      "text": "\nSo if you just replace [[Internal Polymorphism]] with [[External Polymorphism]] you'll probably end up with [[Single Dispatch]], but you will probably find yourself wanting to extend that to [[Multiple Dispatch]] later. -- [[Phil Goodwin]]",
      "id": "557ae47f989ec55474cea638e4d0dfda"
    },
    {
      "type": "html",
      "text": "\nI realize now why Matz decided that Ruby would have Monkey Patching--it's a great way to implement [[External Polymorphism]] without actually having to use multimethods.  ([[Switched To Ruby From Python]] -- well, more accurately, [[Still Love Python Trying Out Ruby]].)",
      "id": "a1f90a5690bb69f6bf58d847b532a2b1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a65440441759b0036426ced53a7e75e4"
    },
    {
      "type": "html",
      "text": "\nSo is the Unix \"sort\" command a good example of [[External Polymorphism]]? -- [[Anonymous Coward]]",
      "id": "99e2bc502fae46a4e8da04fc312f7053"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a65440441759b0036426ced53a7e75e4"
    },
    {
      "type": "html",
      "text": "I am surprised the reflection has not entered this conversation. Here is a good example of how one can get [[External Polymorphism]] through reflection.",
      "id": "90d328e536ab5892aa66c41e4fcb471b"
    },
    {
      "type": "code",
      "text": " public class D''''''oubleDispatchReflector\n {\n       // Methods\n       public D''''''oubleDispatchReflector();\n       public D''''''oubleDispatchReflector(object subject, string methodName);\n       public M''''''ethodInfo D''''''ispatchTo(object[] args);\n       public M''''''ethodInfo D''''''ispatchTo(object arg);\n       public M''''''ethodInfo D''''''ispatchTo(object subject, string methodName, object[] args);\n       public M''''''ethodInfo D''''''ispatchTo(object subject, string methodName, object arg);",
      "id": "5f0695786d8fd6f23ed6ace3eb00bd6d"
    },
    {
      "type": "code",
      "text": "       // Properties\n       public string M''''''ethodName { get; set; }\n       public object Subject { get; set; }",
      "id": "a98886cbb85521993b7cf1373f8426bf"
    },
    {
      "type": "code",
      "text": "       // Fields\n       private string _MethodName;\n       private object _Subject;\n }",
      "id": "58c2bb7f3da413e0a81c0a50ed342c60"
    },
    {
      "type": "code",
      "text": " public M''''''ethodInfo D''''''ispatchTo(object subject, string methodName, object[] args)\n {\n       Type[] typeArray1 = new Type[args.Length];\n       int num2 = args.Length - 1;\n       for (int num1 = 0; num1 <= num2; num1++)\n       {\n             typeArray1[num1] = args[num1].G''''''etType();\n       }\n       M''''''ethodInfo info2 = subject.G''''''etType().G''''''etMethod(methodName, typeArray1);\n       if (info2 == null)\n       {\n             throw new I''''''nvalidOperationException(\"There is no method for that signature.\");\n       }\n       return info2;\n }",
      "id": "54b4dfb728306af93ec0dd11a0e24ce5"
    },
    {
      "type": "html",
      "text": "Subject is the Object that contains all implementations that would have be available polymorphically.\nM<b></b>ethodName is the name of the method that would have been available polymorphically.",
      "id": "d9fd5b3f85ce372a1f5c4a5069d63d73"
    },
    {
      "type": "html",
      "text": "\nNow first lets just focus on one arg. The arg would be the object that you are externally providing polymorphism for.",
      "id": "dfcd3d453aa596f2c4315b5e343be083"
    },
    {
      "type": "html",
      "text": "\nAn example is base class Exception. I wish MS and Sun had implemented the [[Visitor Pattern]] on their Exception classes. But they didn't, so what is a guy to do. [[External Polymorphism]] to the rescue. I can provide a class E<b></b>xceptionHandler as the Subject to D<b></b>oubleDispatchReflector.",
      "id": "732b5d0b9b3ea559a57be9e4fc433d92"
    },
    {
      "type": "html",
      "text": "\npublic class E<b></b>xceptionHandler",
      "id": "5233a197824e3ded2b217708bb86beb9"
    },
    {
      "type": "html",
      "text": "{",
      "id": "2c7e2e7611ec2330dc7fa59d38861810"
    },
    {
      "type": "code",
      "text": "      // Methods\n      public void Handle(Exception exception);\n      public void Handle(IOException exception);",
      "id": "9f73bb1024be20ca2df5c56b406c5161"
    },
    {
      "type": "html",
      "text": "}",
      "id": "f4ce33b5604b72e2b66fa08b2281c11f"
    },
    {
      "type": "html",
      "text": "\nNow I can",
      "id": "e5da755931062c2c38fed5afb9387e00"
    },
    {
      "type": "html",
      "text": "\ntry",
      "id": "baa1263073dc6dd5b7be3b47328b344e"
    },
    {
      "type": "html",
      "text": "{",
      "id": "2c7e2e7611ec2330dc7fa59d38861810"
    },
    {
      "type": "code",
      "text": "      throw new IOException(\"This is a test.\");",
      "id": "cadb6c0076bf1c659472e970b35244bf"
    },
    {
      "type": "html",
      "text": "}\ncatch (Exception ex)",
      "id": "c59d215c31572ba4b4ca1aa592a5421f"
    },
    {
      "type": "html",
      "text": "{",
      "id": "2c7e2e7611ec2330dc7fa59d38861810"
    },
    {
      "type": "code",
      "text": "      D''''''oubleDispatchReflector E''''''xtPoly = new D''''''oubleDispatchReflector(new E''''''xceptionHandler, \"Handle\")\n      E''''''xtPoly.D''''''ispatchTo(ex)",
      "id": "d2d4fc37b1103a3a56905d4d5a8ba544"
    },
    {
      "type": "html",
      "text": "}",
      "id": "f4ce33b5604b72e2b66fa08b2281c11f"
    },
    {
      "type": "html",
      "text": "\nJust to close the loop I wanted to do something like",
      "id": "0a53c1e5fe3ea6dd84c89a2db2f7c473"
    },
    {
      "type": "html",
      "text": "\ntry",
      "id": "baa1263073dc6dd5b7be3b47328b344e"
    },
    {
      "type": "html",
      "text": "{",
      "id": "2c7e2e7611ec2330dc7fa59d38861810"
    },
    {
      "type": "code",
      "text": "      throw new IOException(\"This is a test.\");",
      "id": "cadb6c0076bf1c659472e970b35244bf"
    },
    {
      "type": "html",
      "text": "}\ncatch (Exception ex)",
      "id": "c59d215c31572ba4b4ca1aa592a5421f"
    },
    {
      "type": "html",
      "text": "{",
      "id": "2c7e2e7611ec2330dc7fa59d38861810"
    },
    {
      "type": "code",
      "text": "      ex.Accept(new E''''''xceptionHandler)",
      "id": "cfc8492195ffa74929cee6d9af50de47"
    },
    {
      "type": "html",
      "text": "}",
      "id": "f4ce33b5604b72e2b66fa08b2281c11f"
    },
    {
      "type": "html",
      "text": "\nSo let's take it up a notch. Remember that D<b></b>ispatchTo accepts multiple arguments or an array of objects. Now this is where I start to get out of my experience. From my perspective some pretty wild things can be do with this. I come from a .NET background (VB, C#) so this so not something you normally see done. I am nervous to use it much as I have no wisdom to temper my application of the tool.",
      "id": "63a2154c77bcbfb5343949c9266bb518"
    },
    {
      "type": "html",
      "text": "\nHave Fun -- [[Jay Flowers]]",
      "id": "84f6d749d121a788f55d3fb5c564bfbb"
    },
    {
      "type": "html",
      "text": "\n[[Category Polymorphism]]",
      "id": "026e416f9e5b0a9df5335be31d2d021f"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ExternalPolymorphism c2.com]",
      "id": "c856d7f934132de17611fbd32b2e063b"
    }
  ],
  "journal": [
    {
      "date": 1374564146000,
      "id": "42759369bb9cd5dcb3386936c80480c7",
      "type": "create",
      "item": {
        "title": "External Polymorphism",
        "story": [
          {
            "type": "html",
            "text": "Any mechanism for implementing polymorphism that is external to the definition of the object displaying polymorphic behavior. Switch statements based on a type code are probably the simplest of such mechanisms. ",
            "id": "ad76c3979fb9819c89a7a7dea1e07093"
          },
          {
            "type": "html",
            "text": "\nThere are other, more ingenious mechanisms, available as well:",
            "id": "278ca2f0b0c0c7dfcbb914dee55be31b"
          },
          {
            "type": "html",
            "text": " The paper \"External Polymorphism -- An object structural pattern for transparently extending C++ concrete data types\" by Cleeland, Schmidt, and Harrison cleverly combines dynamic binding and the template mechanism. [http://www.cs.wustl.edu/~schmidt/PDF/External-Polymorphism.pdf www.cs.wustl.edu]",
            "id": "c664ef04d237379d95a3c0061ba51e31"
          },
          {
            "type": "html",
            "text": " The [[Generic Function]] (which is used by the [[Translator Pattern]]) uses a hashtable with class names as keys and corresponding functions (see [[Function Object Pattern]]) as values.",
            "id": "800e57e0173c53687fc08f29dd0c9130"
          },
          {
            "type": "html",
            "text": " [[Multi Methods]] -- methods that are polymorphic on all of their arguments rather than one. Implemented in languages such as [[Common Lisp Object System]], [[Dylan Language]], [[Cecil Language]], and [[Nice Language]]. These are useful for [[External Polymorphism]] even if having a single (polymorphic) argument, as they can be implemented without changing the underyling class.",
            "id": "8a8458495b24b65a2f507f71018203da"
          },
          {
            "type": "html",
            "text": " [[Table Oriented Programming]]? :)",
            "id": "b2e16d883de7360beca811819eee3f92"
          },
          {
            "type": "html",
            "text": "\nAlso see [[On Understanding Types]].",
            "id": "53b85793f027e43f1db1113518bd48b4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a65440441759b0036426ced53a7e75e4"
          },
          {
            "type": "html",
            "text": "\nIt should be said that, while [[External Polymorphism]] is often necessary (particularly in languages with unsubclassable features) it should be avoided wherever possible. It breaks the encapsulation inherent in OOP. Better to rely on the public attributes of an object than it's type - even if that means defining enums to describe the type's features.",
            "id": "ae7bf51204adeff251e821d0bfec8e29"
          },
          {
            "type": "html",
            "text": "\nFor example, ground-vehicle is subclassed to Car and Bus. Class Ferry checks whether type is Car or Bus to determine where to store Bus, because Bus is larger. However, a Minibus, subclassed from Bus, can fit in the same space as a Car - so a larger Bus slot is wasted. If attributes were used, this mistake would have been avoided.",
            "id": "57c2e28ae051d976a5b6d9d6a2971481"
          },
          {
            "type": "html",
            "text": "\nA common multimethod example is [[Rock Paper Scissors]]. By using extrinsic polymorphism, you require that subclasses of Scissors always be treated as Scissors, even if they have all of the attributes and features of Rock. Rather, it would make more sense to define an enum \"Rock, Paper, Scissors, Other\" and simply have each class return an entry from that on request. Thus, it would be painfully obvious to subclassers how the behaviour worked, rather than having inscrutable information hidden in an externally dispatched system.",
            "id": "b53766ea79904bacfc216a9bd8ad4387"
          },
          {
            "type": "html",
            "text": "\nIn other words: only use [[External Polymorphism]] if you are forced to - usually if you have no control over the design of the classes you work with.",
            "id": "ef348c8813aa43b630da9fa5febcada5"
          },
          {
            "type": "html",
            "text": "-- [[Martin Zarate]]",
            "id": "88044ca936bd228c67a8a6ffdd98dcae"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a65440441759b0036426ced53a7e75e4"
          },
          {
            "type": "html",
            "text": "\nA polymorphic method on an object can be thought of as a sort of super function. That is, it is one conceptual function that has several implementations that are customized according to the dynamic type of the object they are bound to. As long as the different implementations support [[Liskov Substitution]] it appears to clients as if there is only one function. Implementing this conceptual function using [[Internal Polymorphism]] causes the custom implementations to be cohesive to the types that specialize them so that when a new type is added it contains its own specialization of each polymorphic function it is associated with. [[External Polymorphism]] causes the custom implementations to be decoupled from the types upon which they are specialized and allows them to be cohesive to some other location. When a new function is added it contains its own specialization for each type it is associated with. So instead of messages being polymorphic with respect to the objects that they are sent to, we have functions that are polymorphic with respect to the object(s) that are passed to them as parameters.",
            "id": "c33152224a9e784b6773248c9bdc11fc"
          },
          {
            "type": "html",
            "text": "\nIn the imperative sentence: \"Joey, hit that ball!\", \"Joey\" is an active noun and \"ball\" is passive. [[Internal Polymorphism]] allows objects in an active role to vary their behavior based on their type. [[External Polymorphism]] allows the behavior of objects in a passive role to vary based on their type.",
            "id": "dd4ef5c1a78513304bb9925d0fcecd5c"
          },
          {
            "type": "html",
            "text": "\n[[External Polymorphism]] makes it difficult to add new types because when a new type is added every relevant function that is implemented with [[External Polymorphism]] must be found and specialized for the new type. On the other hand, [[Internal Polymorphism]] makes it difficult to add new functions because every implementing type must be updated with a new function definition.",
            "id": "cb4c87802b993c1fb9c96196829af0f5"
          },
          {
            "type": "html",
            "text": "\nActually, [[External Polymorphism]] makes is hard to add new types <b>if functions need to be defined in one block</b>, like in [[Functional Programming Language]]s with functions defined by [[Pattern Matching]]. It poses no problem if each case of a function (method) can be defined independently, like with [[Multi Methods]] and [[Predicate Dispatching]].",
            "id": "6967ecda8d3e253938160c1769b020d8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a65440441759b0036426ced53a7e75e4"
          },
          {
            "type": "html",
            "text": "Where can the \"External Polymorphism\" paper be found? -- [[Ted Neward]]",
            "id": "1371fdb40af86653a0e1c96e2ffbc971"
          },
          {
            "type": "html",
            "text": "\nHere: [http://www.cs.wustl.edu/~schmidt/PDF/External-Polymorphism.pdf www.cs.wustl.edu]",
            "id": "932c0f7924953c73bd598059e886c88c"
          },
          {
            "type": "html",
            "text": "\nIt's also available in MoreCPlusPlusGems starting on page 417. -- [[Chris Cleeland]]",
            "id": "d4cd0160891ed4dc2d611d37ea9839d9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a65440441759b0036426ced53a7e75e4"
          },
          {
            "type": "html",
            "text": "\nDoes anyone have an idea how to implement/fake [[External Polymorphism]] in Java? I'm tired of instanceof. -- [[Michael Schuerig]]",
            "id": "1b31d8e673389e6ada8dd3a7a47a8167"
          },
          {
            "type": "html",
            "text": "\nYou could use a dialect of Java that supports [[Multi Methods]]. See for instance the [[Nice Language]]. This solution requires that you use another compiler than javac (but java bytecodes are generated). On the other hand, the advantage is that the compiler, understanding what your are doing, can provide you with a nicer syntax, meaningful error messages, and can perform more static checking.",
            "id": "d1184a1dc47e2c94efe60df80c4ee27f"
          },
          {
            "type": "html",
            "text": "\nS<i>[from [[External Polymorphism]]] Does anyone have an idea how to implement/fake [[External Polymorphism]] in Java? I'm tired of instanceof. --[[Michael Schuerig]]</i>",
            "id": "82565f43c0530f99753d4bd799db0fae"
          },
          {
            "type": "html",
            "text": "\nThe key pieces would be a hash table and a static method. Since the static method will use it, the hash table should probably be static too. The static method takes an Object parameter and implements polymorphism by calling getClass() on the Object, using the resulting class as a key into the hash table to retrieve the implementation code and then delegating the call to that code.",
            "id": "48ce589c0115c778f34386efac5a6223"
          },
          {
            "type": "html",
            "text": "\nThe implementation code should probably be an instance of an inner class that implements an interface with a method that takes an Object parameter, converts it to it's proper type and then performs the desired operation. -- [[Phil Goodwin]]",
            "id": "28b5f10068f330a0a697f0db21451ac0"
          },
          {
            "type": "html",
            "text": "\nSounds like an instance of [[Collection And Loop Vs Selection Idiom]]. -- [[Michael Schuerig]]",
            "id": "9f696e3601593fce96cab2a11d7eacac"
          },
          {
            "type": "html",
            "text": "\nExcept there's no loop hash table lookups are much faster than the linear time it takes to loop through an array - at least if you have more than a couple of items. -- pg",
            "id": "0939a2afde63cbc7209480c2d1fe5fd5"
          },
          {
            "type": "html",
            "text": "\nBut hash tables have the drawback that they don't take subtyping into account. -- ms",
            "id": "b937ac8774d7438f539f228f083b7eae"
          },
          {
            "type": "html",
            "text": "\nHmm, yes, that's interesting, you'd either have to fill the table with all the types you were going to use (often workable) or implement a best-fit algorithm in order to determine which code to execute when an exact match can't be found. -- pg",
            "id": "8f3015f8059dff73476186ab4efd4a12"
          },
          {
            "type": "html",
            "text": "\nYou'd have to reimplement [[Multiple Dispatch]]. Actually, someone has already done this. See [[Method Thread]]. -- ms",
            "id": "b4ddc872ac1a5e50e213a15de079fbcf"
          },
          {
            "type": "html",
            "text": "\nI don't see the relationship. I mean, you <i>can</i> implement [[Multiple Dispatch]] as part of [[Generic Function]], that would be very useful, but I don't see why you'd have to. You just need a mechanism to search for entries that match one of the antecedents of the type in question. - pg",
            "id": "236959e7f1caa0acbe9aa09bc1d045ee"
          },
          {
            "type": "html",
            "text": "\nBut that <i>is</i> single dispatch, and in a language like Java you now have a method that is associated with two classes; it dispatches on both. -- [[Graham Hughes]]",
            "id": "97bfe83feb097673e99a7400521e5d4f"
          },
          {
            "type": "html",
            "text": "\nPolymorphism is where you have a method that is associated with more than one class and dispatches at runtime based on dynamic type information. [[Internal Polymorphism]] is when that method is owned by the classes that it can dispatch to - the classes elaborate the dispatch mechanism by defining which code will finally implement the call. [[External Polymorphism]] is when some agent other than the classes owns the right to elaborate the dispatch mechanism. ",
            "id": "bc402c6ee2b96e8be2d17a32bbe60a8d"
          },
          {
            "type": "html",
            "text": "\n[[Single Dispatch]] is a kind of Polymorphism where the dispatch mechanism works against a single dynamic type. I don't know of any [[Internal Polymorphism]] implementation that doesn't use [[Single Dispatch]]. [[Multiple Dispatch]] is where more than one dynamic type is used to make the dispatch decision. [[External Polymorphism]] allows and even seems to inspire [[Multiple Dispatch]] as well as dispatch based on information other than type information.",
            "id": "b868a55b90ef2c69f2e77a161791a8fb"
          },
          {
            "type": "html",
            "text": "\nSo if you just replace [[Internal Polymorphism]] with [[External Polymorphism]] you'll probably end up with [[Single Dispatch]], but you will probably find yourself wanting to extend that to [[Multiple Dispatch]] later. -- [[Phil Goodwin]]",
            "id": "557ae47f989ec55474cea638e4d0dfda"
          },
          {
            "type": "html",
            "text": "\nI realize now why Matz decided that Ruby would have Monkey Patching--it's a great way to implement [[External Polymorphism]] without actually having to use multimethods.  ([[Switched To Ruby From Python]] -- well, more accurately, [[Still Love Python Trying Out Ruby]].)",
            "id": "a1f90a5690bb69f6bf58d847b532a2b1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a65440441759b0036426ced53a7e75e4"
          },
          {
            "type": "html",
            "text": "\nSo is the Unix \"sort\" command a good example of [[External Polymorphism]]? -- [[Anonymous Coward]]",
            "id": "99e2bc502fae46a4e8da04fc312f7053"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a65440441759b0036426ced53a7e75e4"
          },
          {
            "type": "html",
            "text": "I am surprised the reflection has not entered this conversation. Here is a good example of how one can get [[External Polymorphism]] through reflection.",
            "id": "90d328e536ab5892aa66c41e4fcb471b"
          },
          {
            "type": "code",
            "text": " public class D''''''oubleDispatchReflector\n {\n       // Methods\n       public D''''''oubleDispatchReflector();\n       public D''''''oubleDispatchReflector(object subject, string methodName);\n       public M''''''ethodInfo D''''''ispatchTo(object[] args);\n       public M''''''ethodInfo D''''''ispatchTo(object arg);\n       public M''''''ethodInfo D''''''ispatchTo(object subject, string methodName, object[] args);\n       public M''''''ethodInfo D''''''ispatchTo(object subject, string methodName, object arg);",
            "id": "5f0695786d8fd6f23ed6ace3eb00bd6d"
          },
          {
            "type": "code",
            "text": "       // Properties\n       public string M''''''ethodName { get; set; }\n       public object Subject { get; set; }",
            "id": "a98886cbb85521993b7cf1373f8426bf"
          },
          {
            "type": "code",
            "text": "       // Fields\n       private string _MethodName;\n       private object _Subject;\n }",
            "id": "58c2bb7f3da413e0a81c0a50ed342c60"
          },
          {
            "type": "code",
            "text": " public M''''''ethodInfo D''''''ispatchTo(object subject, string methodName, object[] args)\n {\n       Type[] typeArray1 = new Type[args.Length];\n       int num2 = args.Length - 1;\n       for (int num1 = 0; num1 <= num2; num1++)\n       {\n             typeArray1[num1] = args[num1].G''''''etType();\n       }\n       M''''''ethodInfo info2 = subject.G''''''etType().G''''''etMethod(methodName, typeArray1);\n       if (info2 == null)\n       {\n             throw new I''''''nvalidOperationException(\"There is no method for that signature.\");\n       }\n       return info2;\n }",
            "id": "54b4dfb728306af93ec0dd11a0e24ce5"
          },
          {
            "type": "html",
            "text": "Subject is the Object that contains all implementations that would have be available polymorphically.\nM<b></b>ethodName is the name of the method that would have been available polymorphically.",
            "id": "d9fd5b3f85ce372a1f5c4a5069d63d73"
          },
          {
            "type": "html",
            "text": "\nNow first lets just focus on one arg. The arg would be the object that you are externally providing polymorphism for.",
            "id": "dfcd3d453aa596f2c4315b5e343be083"
          },
          {
            "type": "html",
            "text": "\nAn example is base class Exception. I wish MS and Sun had implemented the [[Visitor Pattern]] on their Exception classes. But they didn't, so what is a guy to do. [[External Polymorphism]] to the rescue. I can provide a class E<b></b>xceptionHandler as the Subject to D<b></b>oubleDispatchReflector.",
            "id": "732b5d0b9b3ea559a57be9e4fc433d92"
          },
          {
            "type": "html",
            "text": "\npublic class E<b></b>xceptionHandler",
            "id": "5233a197824e3ded2b217708bb86beb9"
          },
          {
            "type": "html",
            "text": "{",
            "id": "2c7e2e7611ec2330dc7fa59d38861810"
          },
          {
            "type": "code",
            "text": "      // Methods\n      public void Handle(Exception exception);\n      public void Handle(IOException exception);",
            "id": "9f73bb1024be20ca2df5c56b406c5161"
          },
          {
            "type": "html",
            "text": "}",
            "id": "f4ce33b5604b72e2b66fa08b2281c11f"
          },
          {
            "type": "html",
            "text": "\nNow I can",
            "id": "e5da755931062c2c38fed5afb9387e00"
          },
          {
            "type": "html",
            "text": "\ntry",
            "id": "baa1263073dc6dd5b7be3b47328b344e"
          },
          {
            "type": "html",
            "text": "{",
            "id": "2c7e2e7611ec2330dc7fa59d38861810"
          },
          {
            "type": "code",
            "text": "      throw new IOException(\"This is a test.\");",
            "id": "cadb6c0076bf1c659472e970b35244bf"
          },
          {
            "type": "html",
            "text": "}\ncatch (Exception ex)",
            "id": "c59d215c31572ba4b4ca1aa592a5421f"
          },
          {
            "type": "html",
            "text": "{",
            "id": "2c7e2e7611ec2330dc7fa59d38861810"
          },
          {
            "type": "code",
            "text": "      D''''''oubleDispatchReflector E''''''xtPoly = new D''''''oubleDispatchReflector(new E''''''xceptionHandler, \"Handle\")\n      E''''''xtPoly.D''''''ispatchTo(ex)",
            "id": "d2d4fc37b1103a3a56905d4d5a8ba544"
          },
          {
            "type": "html",
            "text": "}",
            "id": "f4ce33b5604b72e2b66fa08b2281c11f"
          },
          {
            "type": "html",
            "text": "\nJust to close the loop I wanted to do something like",
            "id": "0a53c1e5fe3ea6dd84c89a2db2f7c473"
          },
          {
            "type": "html",
            "text": "\ntry",
            "id": "baa1263073dc6dd5b7be3b47328b344e"
          },
          {
            "type": "html",
            "text": "{",
            "id": "2c7e2e7611ec2330dc7fa59d38861810"
          },
          {
            "type": "code",
            "text": "      throw new IOException(\"This is a test.\");",
            "id": "cadb6c0076bf1c659472e970b35244bf"
          },
          {
            "type": "html",
            "text": "}\ncatch (Exception ex)",
            "id": "c59d215c31572ba4b4ca1aa592a5421f"
          },
          {
            "type": "html",
            "text": "{",
            "id": "2c7e2e7611ec2330dc7fa59d38861810"
          },
          {
            "type": "code",
            "text": "      ex.Accept(new E''''''xceptionHandler)",
            "id": "cfc8492195ffa74929cee6d9af50de47"
          },
          {
            "type": "html",
            "text": "}",
            "id": "f4ce33b5604b72e2b66fa08b2281c11f"
          },
          {
            "type": "html",
            "text": "\nSo let's take it up a notch. Remember that D<b></b>ispatchTo accepts multiple arguments or an array of objects. Now this is where I start to get out of my experience. From my perspective some pretty wild things can be do with this. I come from a .NET background (VB, C#) so this so not something you normally see done. I am nervous to use it much as I have no wisdom to temper my application of the tool.",
            "id": "63a2154c77bcbfb5343949c9266bb518"
          },
          {
            "type": "html",
            "text": "\nHave Fun -- [[Jay Flowers]]",
            "id": "84f6d749d121a788f55d3fb5c564bfbb"
          },
          {
            "type": "html",
            "text": "\n[[Category Polymorphism]]",
            "id": "026e416f9e5b0a9df5335be31d2d021f"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ExternalPolymorphism c2.com]",
            "id": "c856d7f934132de17611fbd32b2e063b"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1664258951957
    }
  ]
}