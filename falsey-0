{
  "title": "Falsey 0",
  "story": [
    {
      "type": "paragraph",
      "id": "d5c4b155cb3ed893",
      "text": "0 is one of many [[falsey values]] in JavaScript. It seems like an odd choice, for a language with only a single type of number to have 0 be falsey. It harkens back to our C heritage where 0 was the only falsey value, it was the '\\0' at the end of a string it was the NULL value that pointed to nothing, it was the negative response to a comparison. I JavaScript it has some clever uses, but mostly just serves to trip us up."
    },
    {
      "type": "code",
      "id": "332c3d9cc6d6461a",
      "text": "var nodes =\n  [ { id: 0, val: 'a' }\n  , { id: 1, val: 'b' }\n  , { foo: 20 }\n  , { id: 2, val: 'c' }\n  ]\n\n// Broken!\nnodes.forEach(function (node) {\n  if (node.id) {\n    console.log(node.val)\n  }\n})"
    },
    {
      "type": "paragraph",
      "id": "3e7087111dea2608",
      "text": "Above is a common case where we are using the presence of the 'id' property to indicate an object is the kind of object we are expecting, and if it is doing something with it. In this case since 'id' is an incremental id starting at 0, we get the unexpected behavior that this code never logs 'a'."
    },
    {
      "type": "code",
      "id": "d5441ae23e898983",
      "text": "var nodes =\n  [ { id: 0, val: 'a' }\n  , { id: 1, val: 'b' }\n  , { foo: 20 }\n  , { id: 2, val: 'c' }\n  ]\n\nnodes.forEach(function (node) {\n  if ('id' in node) {\n    console.log(node.val)\n  }\n})"
    },
    {
      "type": "paragraph",
      "id": "5c0633d22e6f592a",
      "text": "One way to attack this is to check the properties membership in the object. It doesn't matter the value of the property, if it's there `\"property\" in object` returns truthy, however this also picks up inherited properties, and if you explicitly set an id to null to remove it from the set of things being operated on, this will still pick it up."
    },
    {
      "type": "code",
      "id": "600a8d7a21037146",
      "text": "var nodes =\n  [ { id: 0, val: 'a' }\n  , { id: 1, val: 'b' }\n  , { foo: 20 }\n  , { id: null, val: 'c' }\n  ]\n\nnodes.forEach(function (node) {\n  if (node.id != null) { // tricky\n    console.log(node.val)\n  }\n})"
    },
    {
      "type": "paragraph",
      "id": "0422b00e980f164c",
      "text": "Another way to attack it would be `!= null`. One of the most compelling use cases of double equal or not equal, the type coercing equality operators, is comparing to null, because it only catches null or undefined. Even this narrow use case is tricky to read, because most people have completely eliminated type coercive equality from their programs."
    },
    {
      "type": "code",
      "id": "34b8f4f2a039aea7",
      "text": "var nodes =\n  [ { id: 0, val: 'a' }\n  , { id: 1, val: 'b' }\n  , { foo: 20 }\n  , { id: null, val: 'c' }\n  ]\n\nnodes.forEach(function (node) {\n  if (typeof node.id !== 'undefined' && node.id !== null) {\n    console.log(node.val)\n  }\n})"
    },
    {
      "type": "paragraph",
      "id": "e9755e6690fdf916",
      "text": "That leaves us with this very verbose, but usually preferred form. In some environments you can reassign the value of the variable undefined, so it's safer to check for undefined using typeof. and using the triple equals, non-coercive equality checks you can be sure it is exactly not undefined and exactly not null. If you're going to be doing this check a lot it might be worth putting in it's own function!"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Falsey 0",
        "story": []
      },
      "date": 1431720446128
    },
    {
      "item": {
        "type": "factory",
        "id": "d5c4b155cb3ed893"
      },
      "id": "d5c4b155cb3ed893",
      "type": "add",
      "date": 1431720449130
    },
    {
      "type": "edit",
      "id": "d5c4b155cb3ed893",
      "item": {
        "type": "paragraph",
        "id": "d5c4b155cb3ed893",
        "text": "0 is one of many [[falsey values]] in JavaScript. It seems like an odd choice, for a language with only a single type of number to have 0 be falsey. It harkens back to our C heritage where 0 was the only falsey value, it was the '\\0' at the end of a string it was the NULL value that pointed to nothing, it was the negative response to a comparison. I JavaScript it has some clever uses, but mostly just serves to trip us up."
      },
      "date": 1431720663595
    },
    {
      "item": {
        "type": "factory",
        "id": "23506adcd6a4ee74"
      },
      "id": "23506adcd6a4ee74",
      "type": "add",
      "after": "d5c4b155cb3ed893",
      "date": 1431722473281
    },
    {
      "type": "remove",
      "id": "23506adcd6a4ee74",
      "date": 1431722518041
    },
    {
      "item": {
        "type": "factory",
        "id": "5f47d0c6e5e90363"
      },
      "id": "5f47d0c6e5e90363",
      "type": "add",
      "after": "d5c4b155cb3ed893",
      "date": 1431722778244
    },
    {
      "type": "remove",
      "id": "5f47d0c6e5e90363",
      "date": 1431722782283
    },
    {
      "item": {
        "type": "factory",
        "id": "332c3d9cc6d6461a"
      },
      "id": "332c3d9cc6d6461a",
      "type": "add",
      "after": "d5c4b155cb3ed893",
      "date": 1431722783667
    },
    {
      "type": "edit",
      "id": "332c3d9cc6d6461a",
      "item": {
        "type": "code",
        "id": "332c3d9cc6d6461a",
        "text": "var nodes =\n  [ { id: 0, val: 'a' }\n  , { id: 1, val: 'b' }\n  , { foo: 20 }\n  , { id: 2, val: 'c' }\n  ]\n\n// Broken!\nnodes.forEach(function (node) {\n  if (node.id) {\n    console.log(node.val)\n  }\n})"
      },
      "date": 1431722788345
    },
    {
      "item": {
        "type": "factory",
        "id": "3e7087111dea2608"
      },
      "id": "3e7087111dea2608",
      "type": "add",
      "after": "332c3d9cc6d6461a",
      "date": 1431722806775
    },
    {
      "type": "edit",
      "id": "3e7087111dea2608",
      "item": {
        "type": "paragraph",
        "id": "3e7087111dea2608",
        "text": "Above is a common case where we are using the presence of the 'id' property to indicate an object is the kind of object we are expecting, and if it is doing something with it. In this case since 'id' is an incremental id starting at 0, we get the unexpected behavior that this code never logs 'a'."
      },
      "date": 1431722909801
    },
    {
      "item": {
        "type": "factory",
        "id": "d5441ae23e898983"
      },
      "id": "d5441ae23e898983",
      "type": "add",
      "after": "3e7087111dea2608",
      "date": 1431723072371
    },
    {
      "type": "edit",
      "id": "d5441ae23e898983",
      "item": {
        "type": "code",
        "id": "d5441ae23e898983",
        "text": "var nodes =\n  [ { id: 0, val: 'a' }\n  , { id: 1, val: 'b' }\n  , { foo: 20 }\n  , { id: 2, val: 'c' }\n  ]\n\nnodes.forEach(function (node) {\n  if ('id' in node) {\n    console.log(node.val)\n  }\n})"
      },
      "date": 1431723080302
    },
    {
      "item": {
        "type": "factory",
        "id": "5c0633d22e6f592a"
      },
      "id": "5c0633d22e6f592a",
      "type": "add",
      "after": "d5441ae23e898983",
      "date": 1431723084710
    },
    {
      "type": "edit",
      "id": "5c0633d22e6f592a",
      "item": {
        "type": "paragraph",
        "id": "5c0633d22e6f592a",
        "text": "One way to attack this is to check the properties membership in the object. It doesn't matter the value of the property, if it's there `\"property\" in object` returns truthy, however this also picks up inherited properties, and if you explicitly set an id to null to remove it from the set of things being operated on, this will still pick it up."
      },
      "date": 1431723232207
    },
    {
      "item": {
        "type": "factory",
        "id": "600a8d7a21037146"
      },
      "id": "600a8d7a21037146",
      "type": "add",
      "after": "5c0633d22e6f592a",
      "date": 1431723328860
    },
    {
      "type": "edit",
      "id": "600a8d7a21037146",
      "item": {
        "type": "code",
        "id": "600a8d7a21037146",
        "text": "var nodes =\n  [ { id: 0, val: 'a' }\n  , { id: 1, val: 'b' }\n  , { foo: 20 }\n  , { id: null, val: 'c' }\n  ]\n\nnodes.forEach(function (node) {\n  if (node.id != null) { // tricky\n    console.log(node.val)\n  }\n})"
      },
      "date": 1431723334107
    },
    {
      "item": {
        "type": "factory",
        "id": "0422b00e980f164c"
      },
      "id": "0422b00e980f164c",
      "type": "add",
      "after": "600a8d7a21037146",
      "date": 1431723338302
    },
    {
      "type": "edit",
      "id": "0422b00e980f164c",
      "item": {
        "type": "paragraph",
        "id": "0422b00e980f164c",
        "text": "Another way to attack it would be `!= null`. One of the most compelling use cases of double equal or not equal, the type coercing equality operators, is comparing to null, because it only catches null or undefined. Even this narrow use case is tricky to read, because most people have completely eliminated type coercive equality from their programs."
      },
      "date": 1431723473782
    },
    {
      "item": {
        "type": "factory",
        "id": "34b8f4f2a039aea7"
      },
      "id": "34b8f4f2a039aea7",
      "type": "add",
      "after": "0422b00e980f164c",
      "date": 1431723633561
    },
    {
      "type": "edit",
      "id": "34b8f4f2a039aea7",
      "item": {
        "type": "code",
        "id": "34b8f4f2a039aea7",
        "text": "var nodes =\n  [ { id: 0, val: 'a' }\n  , { id: 1, val: 'b' }\n  , { foo: 20 }\n  , { id: null, val: 'c' }\n  ]\n\nnodes.forEach(function (node) {\n  if (typeof node.id !== 'undefined' && node.id !== null) {\n    console.log(node.val)\n  }\n})"
      },
      "date": 1431723639692
    },
    {
      "type": "edit",
      "id": "34b8f4f2a039aea7",
      "item": {
        "type": "code",
        "id": "34b8f4f2a039aea7",
        "text": "var nodes =\n  [ { id: 0, val: 'a' }\n  , { id: 1, val: 'b' }\n  , { foo: 20 }\n  , { id: null, val: 'c' }\n  ]\n\nnodes.forEach(function (node) {\n  if (typeof node.id !== 'undefined' &&\n      node.id !== null) {\n    console.log(node.val)\n  }\n})"
      },
      "date": 1431723682879
    },
    {
      "type": "edit",
      "id": "34b8f4f2a039aea7",
      "item": {
        "type": "code",
        "id": "34b8f4f2a039aea7",
        "text": "var nodes =\n  [ { id: 0, val: 'a' }\n  , { id: 1, val: 'b' }\n  , { foo: 20 }\n  , { id: null, val: 'c' }\n  ]\n\nnodes.forEach(function (node) {\n  if (typeof node.id !== 'undefined' && node.id !== null) {\n    console.log(node.val)\n  }\n})"
      },
      "date": 1431723700005
    },
    {
      "item": {
        "type": "factory",
        "id": "e9755e6690fdf916"
      },
      "id": "e9755e6690fdf916",
      "type": "add",
      "after": "34b8f4f2a039aea7",
      "date": 1431723707918
    },
    {
      "type": "edit",
      "id": "e9755e6690fdf916",
      "item": {
        "type": "paragraph",
        "id": "e9755e6690fdf916",
        "text": "That leaves us with this very verbose, but usually preferred form. In some environments you can reassign the value of the variable undefined, so it's safer to check for undefined using typeof. and using the triple equals, non-coercive equality checks you can be sure it is exactly not undefined and exactly not null. If you're going to be doing this check a lot it might be worth putting in it's own function!"
      },
      "date": 1431723885415
    },
    {
      "type": "fork",
      "site": "nrn.io",
      "date": 1652868516876
    }
  ]
}