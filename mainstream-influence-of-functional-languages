{
  "title": "Mainstream Influence Of Functional Languages",
  "story": [
    {
      "type": "html",
      "text": "See [[Informal History Of Programming Ideas]], [[Early History Of Smalltalk]], [[Ground Breaking Languages]], [[Worse Is Better]].",
      "id": "0cc1c36b059c06550ebac5c5b113f0dd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cf141876205e643d062f126a31bb797"
    },
    {
      "type": "html",
      "text": "\nFunctional languages have already had quite a strong impact on mainstream languages, but only indirectly. [It takes ages] for programming ideas to hit the mainstream. [[Java Language]] is the first example of a mainstream language which allows some of what [[Smalltalk Language]] enabled back around 1972. ",
      "id": "7cbfd50ccabfd2616b6817c4628d4c29"
    },
    {
      "type": "html",
      "text": "\nHowever, Java focuses almost exclusively on manifestly-typed object-orientation as its primary concept. It completely ignores two related features which make Smalltalk powerful: code blocks and closures. These Smalltalk features were actually derived from [[Lisp Language]], which at the time (1972) could only be called a proto-functional language. The first truly functional language was probably [[Scheme Language]], in 1975. ",
      "id": "c9b3db237bb07b04a9a6a49c92d56b6b"
    },
    {
      "type": "html",
      "text": "\nBecause the functional ideas inherent in Lisp were not fully developed at the time Smalltalk was created, the conceptual emphasis in Smalltalk was on object-orientation, derived from [[Simula Language]]. If Smalltalk had been able to draw from Scheme instead of Lisp, there's a strong chance that it would have had a more functional bent, which might have affected the languages which were influenced by Smalltalk. ",
      "id": "de618680d53db3a3aea7a2304a048765"
    },
    {
      "type": "html",
      "text": "\nInstead, Scheme came along just a little too late to directly influence the mainstream. Only recently have we started to see functional features appearing in mainstream languages. Perl and [[Java Script]] both support lambda-calculus-compliant closures, and first-class procedures, which are fully realized incarnations of the original concepts on which Smalltalk's somewhat limited code blocks and closures were based. [[Python Language]] has also recently moved in this direction. ",
      "id": "b75c9c1de20f5475c1600c7892617253"
    },
    {
      "type": "html",
      "text": "\nI predict that functional features will slowly be adopted by most mainstream languages over the next decade or two. Java will be the last new mainstream language that's completely non-functional ([[Pun Intended]]). The power of these functional capabilities is too great for language designers to ignore. ",
      "id": "3683ce33d74f0028646f9fe7a241ec13"
    },
    {
      "type": "html",
      "text": "\nNote that I'm not saying that current functional languages will become mainstream languages. Rather, just as mainstream languages have absorbed object-oriented concepts, they will also absorb functional concepts. ",
      "id": "fc46e7a77311f9385f93edcdc86911f2"
    },
    {
      "type": "html",
      "text": "\nAnyone writing a language today who isn't familiar with Scheme, [[Haskell Language]], and [[Ml Language]] may as well throw in the towel right now. Unless they plan to invent the next great paradigm, they will not succeed. I think it's impossible, in 2001, to write a language without taking functional concepts into account. (Of course I'm reminded of [[Andrew Tanenbaum]] telling [[Linus Torvalds]] that writing a [[Monolithic Kernel]] in 1991 was a fundamentally bad idea...) ",
      "id": "1c0c095a56bede298aedc11bd36c13e9"
    },
    {
      "type": "html",
      "text": "-- [[Ton Tobius]] (?)",
      "id": "213aa9a576c74e561413c5bf4a8691c6"
    },
    {
      "type": "html",
      "text": "<i>Alas, [[Micro Soft]] had to come up with another non-functional, mainstream, language, and spoil your nice prediction... If [[Csharp Language]] had true closures it would be a real improvement over [[Java Language]].</i> -- [[Carlos Scheidegger]]",
      "id": "eb492cbe134475655923b8db78b62a63"
    },
    {
      "type": "html",
      "text": "\nYou're wrong, closures are in the 2.0 spec, and it is a real improvement over [[Java Language]].",
      "id": "52fbebb15e186181b28f5b76e52a631a"
    },
    {
      "type": "html",
      "text": "<i>Actually I think that means he's right. He said that if C# had true closures then it would be a real improvement. You're saying that C# v2.0 will have real closures, and it is a real improvement. You appear to be in [[Violent Agreement]].</i>",
      "id": "c7992fd2aa22aa14e1b06d6eb5362197"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cf141876205e643d062f126a31bb797"
    },
    {
      "type": "html",
      "text": "\nAbove comment is from a [[Slash Dot]] discussion. I found it highly interesting, so I copied it here (with permission). If you think it doesn't belong here, please flame me, not the author. -- [[Falk Bruegmann]]",
      "id": "b7d891b22e63d041d149b13284f85a10"
    },
    {
      "type": "html",
      "text": "\nI have to agree with this. Extrapolating from current language evolution I predict that in 20 years time programmers will be using . . . Lisp. Except it won't be called Lisp and it might have a different syntax, but it will offer all the power and flexibility of the world's second oldest programming language. Now that's progress! -- [[Noel Welsh]]",
      "id": "0013f23a5892b6172b61f4accbf331d3"
    },
    {
      "type": "html",
      "text": "<i>That *is* progress. -- [[David Sarah Hopwood]]</i>",
      "id": "0b227b25ee7eca2e92c72d5eae067cf6"
    },
    {
      "type": "html",
      "text": "\nLisp-like languages with non-Lisp-like syntax:",
      "id": "69c5fa532c1298d5272d02805c0643ff"
    },
    {
      "type": "html",
      "text": " Egil MÃ¶ller's [[Sugar Language]].",
      "id": "4c434e85923bfa4db8b7363f1a26b87d"
    },
    {
      "type": "html",
      "text": " [[Dylan Language]] has semantics similar to Scheme, an object system similar to CLOS ([[Common Lisp Object System]]) and a syntax similar to [[Pascal Language]], [[Modula Three]], or [[Ada Language]].",
      "id": "804dabf309594f1cc1ac820c7e6136af"
    },
    {
      "type": "html",
      "text": " [[Io Language]]",
      "id": "3ca18bfd6e4619d99f04eb9e95789ecd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cf141876205e643d062f126a31bb797"
    },
    {
      "type": "html",
      "text": "<i>Except it won't be called Lisp and it might have a different syntax, but it will offer all the power and flexibility of the world's second oldest programming language.</i>",
      "id": "cce7a8b0e1781b6c41922e925457e224"
    },
    {
      "type": "html",
      "text": "\nPeople keep propagating this misconception, i.e. that the lisp syntax\nis in some way a problem. Nothing could be further from the truth: Lisp's\nsyntax is in fact one of its strongest advantages! Study just enough lisp\nto understand what DEFMACRO does, and why an expression like",
      "id": "785e56c4b95683548cd244b248530abf"
    },
    {
      "type": "code",
      "text": "        (html (:h1 \"foo\")\n                (:p     \"Some text\"))",
      "id": "abe99d71042c6b71260ae5c491824a36"
    },
    {
      "type": "html",
      "text": "can be viewed as either data or a program, and you'll know why Lispers\nare so reticent of letting go of their beautifully designed [[Ess Expressions]].",
      "id": "afdd5eca931e944104548fc4a33d4e22"
    },
    {
      "type": "html",
      "text": "-- [[Alain Picard]]",
      "id": "33b884027d393a932657fd3aa758f7b7"
    },
    {
      "type": "html",
      "text": "\nRight on.",
      "id": "2c89bb764ab153691d3895c590bda34b"
    },
    {
      "type": "html",
      "text": "<i>Viewing expressions as either data or a program is not dependent on Lisp's syntax. If Lisp had been defined with an infix syntax and [[Term Trees]] in place of [[Ess Expressions]], it would have been just as expressive, and probably a lot more popular. [[Syntax Does Matter]]. -- [[David Sarah Hopwood]]</i>",
      "id": "08d2b54dee24c4a6fa5bdd06a4a52e39"
    },
    {
      "type": "html",
      "text": "\n[[Dylan Language]] is Lisp with infix syntax.  It's <i>almost</i> as expressive (missing some of the more obscure parts of the [[Meta Object Protocol]], and [[Compiler At Run Time]]), but IMHO easier to read.  However, it's just as unpopular as Lisp.  I suspect marketing clout matters a whole lot more than expressiveness, and both matter more than syntax. -- [[Jonathan Tang]]",
      "id": "84c9c788b298c433ca65aac5c55c27d5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cf141876205e643d062f126a31bb797"
    },
    {
      "type": "html",
      "text": "\nOr it could be that functional languages are as stillborn as videophones. I don't mean to imply that the low-fi network we have today is better than videophones; It's just that we've been waiting a long time for Lisp to displace its less capable sisters and were aren't much further along.",
      "id": "b22603fde980b338331600f091b9738c"
    },
    {
      "type": "html",
      "text": "<i>It's not that Lisp will displace its less capable sisters. Its less capable sisters will absorb ideas from Lisp in the same way that [[Java Language]] is [[Smalltalk Minus Minus]]. [[Python Language]] is getting more [[Functional Programming Language]] features, [[Java Script]] is an object-functional hybrid, the C++ STL is functional programming in C++. [[Lisp Language]] isn't popular for many of the same reasons [[Small Talk]] isn't popular (I know lots of people use both of them, but its nothing compared to [[Java Language]]) but the ideas are slowly shifting into mainstream programming. You can wait for the future to arrive in mainstream languages, or you jump to the future today (or 15 years ago). -- [[Noel Welsh]]</i>",
      "id": "e0ba0856a44c24cda2af7c9f872a307b"
    },
    {
      "type": "html",
      "text": "\nAbsorption can only go so far. The central idea of functional languages is that there is no stored program state -- no variables. So even the venerable <i>while</i> loop is verboten. Java, Python, and other mainstream languages cannot absorb such a radically different idea. -- [[Ian Rae]]",
      "id": "f7e49a1a413ee27017074eb89bcea131"
    },
    {
      "type": "html",
      "text": "\nNonsense. A <i>while</i> construct in [[Haskell Language]] can be written as",
      "id": "53796712f5fddb3c0489b693ef111fe6"
    },
    {
      "type": "code",
      "text": "  while cond body =\n      do\n         testResult <- cond\n         if testResult\n           then body >> while cond body\n           else return ()",
      "id": "4a24c5277ad5680455cc0321c8cbae99"
    },
    {
      "type": "html",
      "text": "''Actually, the \"while cond body\" part is likely to be factored out:",
      "id": "0c0070494f8766bf2bf16c4dfa03add6"
    },
    {
      "type": "code",
      "text": " while cond body = loop\n   where loop = do testResult <- cond\n                   if testResult then do {body; loop}\n                                 else return ()''",
      "id": "56b18c25285cba6ea52c662613175f26"
    },
    {
      "type": "html",
      "text": "''And you're both cheating. This while loop does useful work only by\nbeing in a monad, presumably IO. Though you'll surely tell me, a State\nMonad is still purely functional, the code above isn't. This is",
      "id": "2fcce48ad4914d255afdc7d69ab35e89"
    },
    {
      "type": "html",
      "text": "<i>dysfunctional</i> code embedded in Haskell. A while \"loop\" in Haskell\nis usually implemented using \"iterate\" and \"find\", but that requires\nthinking and doesn't prove a stupid point.''",
      "id": "aad4703c4f3e47eb52bada792fc355db"
    },
    {
      "type": "html",
      "text": "\nTThe assertion \"the code above isn't [purely functional]\" is patently false. Both definitions given are indeed purely functional, the do-notation notwithstanding; it's just syntactic sugar. The following definition is equivalent and uses only lambda, function application and if-then:",
      "id": "bf0d96e825c40b041629ebde562dc73b"
    },
    {
      "type": "code",
      "text": " while = \\cond body ->\n   cond >>= (\\testResult ->\n     if testResult\n       then (body >> while cond body)\n       else (return ())\n   )",
      "id": "536664cc530c9a9b6613d028cbf0b54b"
    },
    {
      "type": "html",
      "text": "This definition, just like the others, satisfies all of Haskell's normal criteria of referential transparency and so forth. Granted, it can only be applied to monadic values, but since a value with a monadic type simply represents an action of some kind, it's no different than a while loop in any other language.",
      "id": "7b3b1e5a6ff250632e2a37481d5cbcb2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cf141876205e643d062f126a31bb797"
    },
    {
      "type": "html",
      "text": "\nThe main problem with Smalltalk is that it allows the programmer to do too much with too little effort. If you are going to create a new product and you have a bunch of people working for you, probably you would like these programmers to have the least ability to do any harm, to have them totally isolated and constrained, using your favorite compiler and each suspecting of each other. Make them compete with periodic evaluations and comparisons with their peers. The task will take longer because of the language you chose, but it does not matter since you can always make them work overtime, besides most people have C++ and Java skills, so they can be more easily replaced. Actually a boss gets rewarded if he can make his people work overtime, it shows that the boss knows the tools of the trade, so the one that gets rewarded for using a low productivity compiler like C++ and Java, is the manager. The project takes longer and he gets paid for his time, not for the time it takes to deliver. This is the usual\nreward for being incompetent.",
      "id": "95f7f1b6ff63910b02dafb8326efe5bd"
    },
    {
      "type": "html",
      "text": "\nSince more and more people work in C++ and Java, using another language make you look like a risk taker. Managers are not risk takers, since one pitfall may mean termination. Stockholders are risk takers (since they can invest in many stocks at the same time), but they do not make the decisions. ",
      "id": "ecf1de749f59449bfa63b6f8a066a99e"
    },
    {
      "type": "html",
      "text": "<i>OTOH, there are real advantages, both technical and social, to using a language that is well-supported and popular.</i>",
      "id": "0384e450fc008ab909a4bcb4a1587914"
    },
    {
      "type": "html",
      "text": "[The fallacy is in assuming that only one language can be used.\nMultiple languages (at least three: for heavy numeric, business logic\nand scripting, respectively) can happily coexist in a single\napplication.]",
      "id": "05d98007c64097524a3954d625dacece"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cf141876205e643d062f126a31bb797"
    },
    {
      "type": "html",
      "text": "<i>Software is not developed by a conspiracy of managers! [[Assume Ignorance Not Malice]], [[Assume Stupidity Not Malice]]. But also [[Keep An Open Mind]], matey. Maybe there are good reasons for people using the languages they use.</i> ",
      "id": "090bcaaa553e71e19a1b403569ed4201"
    },
    {
      "type": "html",
      "text": "[There are good reasons, for some value of 'good'. They just aren't software engineering (hardly surprising, as that does not really exist as yet) reasons.]",
      "id": "afc28c54ec695a4c77f78a05ba064d5a"
    },
    {
      "type": "html",
      "text": "<i>See [[Economic Efficiency Is Not Engineering Efficiency]] for further explication of one part of this issue. - [[Jay Osako]]</i>",
      "id": "6bfbb648109400b2cce3908c7eb21766"
    },
    {
      "type": "html",
      "text": "\nAnd maybe there aren't. Corporations have a terrible habit of deciding that some language or other will be the language used for <i>all</i> future development (until they choose the next one), irrespective of its suitability for many of the problems addressed.",
      "id": "9f622b03f783db2b4ae8f4c09d3e0bc2"
    },
    {
      "type": "html",
      "text": "<i>In that case you should be looking to [[Change Your Organization]] one way or another. Where I work currently, someone recently tried to lay a one-language law down in a business area (Java for everything). I stood and fought my ground for an analytics subsystem being in C++, and won my case. It boiled down to knocking down a lot of straw men, and finally implementing the new subsystem in both C++ and Java and showing that JNI latency was not an issue. If I had not been able to get the issue judged on its merits I would have started looking to work elsewhere because [[Lifes Too Short]] to deal with a losing company. This is not just rhetoric, I have actually left an employer for similar reasons before. In that case, it was because they were too scared to start moving business functionality in C as part of a necessary shift from a dying language (Clipper). That company is now out of business.</i>",
      "id": "8f536627bab3e76f34feb87e4a637b62"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cf141876205e643d062f126a31bb797"
    },
    {
      "type": "html",
      "text": "As an imperativist, I am wary of functional languages (and i'm really talking about pure functional languages here) because I don't see how to distribute state around the program. Consider the case of an client-side FTP library: there is all sorts of state associated with the connection, from a socket handle and buffers to connection status and the current directory; there is also loads of behaviour, such as methods for sending commands, reading responses, etc. In an OO language, I can bundle up the state into an object, and present a simple interface to the rest of the program. In a procedural language, I can bundle up the state in a struct, and still provide a pretty simple interface through a set of procedures to manipulate the struct. In a functional language, I can still have a struct, but it's now immutable, which means that if a function wants to 'change' it, it has to make a new version and hand that back to the caller, who then has to use that instead.",
      "id": "1328db98733e376c905e7b05f9dfb3a9"
    },
    {
      "type": "html",
      "text": "\nIn simple cases, this is still okay, but I can imagine more complex cases where some component on one side of the program wants to change the state of a component over on the other side, without bothering the code that's currently calling it. For example, let's say that in a P2P application (whose details are intentionally left blank!), when the Network<b></b>Browser, in the course of retrieving a file, discovers a new rendezvous server, it wants to update the Rendezvous<b></b>Server<b></b>Registry, without bothering the calling code with any kind of 'oh, by the way: I've found a new RV server' sort of message. In an imperative language, as long as the component has (or can get) a pointer to its target, it's trivial; in a functional language, it's impossible. Well, not impossible, but the only way i can see to do it is for <i>every</i> function which might want 'side-effects' of this sort to take the world as an argument and return a new version of the world with any changes it wants to make, which would suck.",
      "id": "67e06a689dc1dea169a6a7c533acd307"
    },
    {
      "type": "html",
      "text": "\nIn short, whilst functional languages may be very elegant for programming in the small, I suspect that they can't handle programming in the large. I'd be most interested to hear how functional programmers would tackle this situation.",
      "id": "00c0be051cff5607f147c074f5a3f6b3"
    },
    {
      "type": "html",
      "text": "<i>I assume you do know that you can rebuild the imperative state framework in a few lines of Haskell? After that, you can write any portion of your code you want in imperative style, and any portion in traditional functional.</i>",
      "id": "13feb74a76abad0557d6bb0c883b1c58"
    },
    {
      "type": "html",
      "text": "\nI didn't know that; my knowledge of functional languages is rather lacking. Still, using the functional language to reproduce an imperative language is a cop-out! How would my example be most cleanly implemented in a functional language?",
      "id": "6688bfbbac246c3d8aa52da53d886817"
    },
    {
      "type": "html",
      "text": "<i>The example above (network protocol client) would be, I think, most cleanly implemented by [[Co Routine]]s with local state.  You often get suboptimal results from trying to apply imperative flow-models to the functional framework - it restricts you a lot.</i> ",
      "id": "08b46fa5494f6d4c4e2e8f0cafcc00d4"
    },
    {
      "type": "html",
      "text": "\nNot surprising - it would be like emulating the relational model in procedural code or something. So, in the example, would it be that we would have a function registerRendezvousServer, which would be a coroutine with some internal state (a list of servers), and the network-browsing code would just call it when it found a new rendezvous server? That seems most straightforward. [[Thank You]].",
      "id": "18dee9538563124e1029e9654b204040"
    },
    {
      "type": "html",
      "text": "\nNow, how do I do it in a <i>pure</i> functional language?",
      "id": "7396735cf10b466986fb6ce04bf77bd5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cf141876205e643d062f126a31bb797"
    },
    {
      "type": "html",
      "text": "\nHow do you do threads in a functional language? In particular, how do they communicate? Futures?",
      "id": "37de4fb47e4dc79230a53ce67859f32a"
    },
    {
      "type": "html",
      "text": "<i>Functional languages sometimes provide </i>implicit<i> threading. I am yet to see a usage of threads which is not either an optimisation or a nice solution to a producer / consumer problem (or then, a misuse of threads where select() or somesuch would be more appropriate). But for the first one, functional languages mostly shift the optimisation burden off the programmer; and for the second one, lazy lists provide a better solution.</i>",
      "id": "d24380fce4e47d6d98b4ae38e5ee0b6f"
    },
    {
      "type": "html",
      "text": "<i>But yes, sometimes you want exactly that, threads. How you get them depends on the language, but eg Haskell would (does?) implement them as monadic operations of the IO monad, and using them will be boringly alike imperative languages.</i>",
      "id": "9c3ccb482a491cddb8420b41f78c3d7f"
    },
    {
      "type": "html",
      "text": "[There's also O'Haskell. In O'Haskell an Object, a Process, a Thread\nare basically the same and they communicate by exchanging messages.\nThis results in a program that is easy to understand, has clearly\ndefined interfaces and is reactive without much effort. I like this far\nbetter than classical threads.]",
      "id": "684e642f19f123e48064e4c6dea8683e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cf141876205e643d062f126a31bb797"
    },
    {
      "type": "html",
      "text": "[[Structure And Interpretation Of Computer Programs]] does a fine job of contrasting\nthe imperative, object-based approach with the functional approach. \nIt arrives at the tentative conclusion that neither is clearly better\nfor all applications. \nHowever, most functional âlanguagesâ (as contrasted with programming\nmethodologies) also allow an imperative style.\nIt is possible to use Haskell just as \"a better C\", to quote [[Bjarne Stroustrup]] out of\ncontext. ;-)",
      "id": "6bc031b584e8018811e12b7e5b45c262"
    },
    {
      "type": "html",
      "text": "-- [[Stephan Houben]]",
      "id": "bc14f11b1fff01de4cf33a35556c21dc"
    },
    {
      "type": "html",
      "text": "\nIs it not also possible to use imperative languages in a functional style? Perhaps not C or Java (although you can sort of do [[Blocks In Java]]), but Python certainly has first-class functions, closures, etc. Ah, of course this is the result of the [[Mainstream Influence Of Functional Languages]]!",
      "id": "dd80db532064f756665f8934ab383160"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cf141876205e643d062f126a31bb797"
    },
    {
      "type": "html",
      "text": "\nIt has already been hinted at with STL, but functional programming in [[Cee Plus Plus]] is possible by using templates to calculate the whole (sub)program at compile time, called [[Template Metaprogramming]] in C++ circles. Functional programming at compile time with OOP at run time seems to be a powerful tool.",
      "id": "3029dce53d99dc292010bee379c478be"
    },
    {
      "type": "html",
      "text": "\nA whole lot more can be done as well - see [[Functional Programming In Cpp]]. -- [[John Fletcher]]",
      "id": "e5cf039e2a1c5cbf4606e4125d796c6e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1cf141876205e643d062f126a31bb797"
    },
    {
      "type": "html",
      "text": "[[Category Functional Programming]]",
      "id": "aae0c056f4d168c41c8329ecc0e5731a"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?MainstreamInfluenceOfFunctionalLanguages c2.com]",
      "id": "e8734a244d10138f8a25501fe9fe3731"
    }
  ],
  "journal": [
    {
      "date": 1390431646000,
      "id": "896373efd477e8f0b7bbbc4b2ba84a27",
      "type": "create",
      "item": {
        "title": "Mainstream Influence Of Functional Languages",
        "story": [
          {
            "type": "html",
            "text": "See [[Informal History Of Programming Ideas]], [[Early History Of Smalltalk]], [[Ground Breaking Languages]], [[Worse Is Better]].",
            "id": "0cc1c36b059c06550ebac5c5b113f0dd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cf141876205e643d062f126a31bb797"
          },
          {
            "type": "html",
            "text": "\nFunctional languages have already had quite a strong impact on mainstream languages, but only indirectly. [It takes ages] for programming ideas to hit the mainstream. [[Java Language]] is the first example of a mainstream language which allows some of what [[Smalltalk Language]] enabled back around 1972. ",
            "id": "7cbfd50ccabfd2616b6817c4628d4c29"
          },
          {
            "type": "html",
            "text": "\nHowever, Java focuses almost exclusively on manifestly-typed object-orientation as its primary concept. It completely ignores two related features which make Smalltalk powerful: code blocks and closures. These Smalltalk features were actually derived from [[Lisp Language]], which at the time (1972) could only be called a proto-functional language. The first truly functional language was probably [[Scheme Language]], in 1975. ",
            "id": "c9b3db237bb07b04a9a6a49c92d56b6b"
          },
          {
            "type": "html",
            "text": "\nBecause the functional ideas inherent in Lisp were not fully developed at the time Smalltalk was created, the conceptual emphasis in Smalltalk was on object-orientation, derived from [[Simula Language]]. If Smalltalk had been able to draw from Scheme instead of Lisp, there's a strong chance that it would have had a more functional bent, which might have affected the languages which were influenced by Smalltalk. ",
            "id": "de618680d53db3a3aea7a2304a048765"
          },
          {
            "type": "html",
            "text": "\nInstead, Scheme came along just a little too late to directly influence the mainstream. Only recently have we started to see functional features appearing in mainstream languages. Perl and [[Java Script]] both support lambda-calculus-compliant closures, and first-class procedures, which are fully realized incarnations of the original concepts on which Smalltalk's somewhat limited code blocks and closures were based. [[Python Language]] has also recently moved in this direction. ",
            "id": "b75c9c1de20f5475c1600c7892617253"
          },
          {
            "type": "html",
            "text": "\nI predict that functional features will slowly be adopted by most mainstream languages over the next decade or two. Java will be the last new mainstream language that's completely non-functional ([[Pun Intended]]). The power of these functional capabilities is too great for language designers to ignore. ",
            "id": "3683ce33d74f0028646f9fe7a241ec13"
          },
          {
            "type": "html",
            "text": "\nNote that I'm not saying that current functional languages will become mainstream languages. Rather, just as mainstream languages have absorbed object-oriented concepts, they will also absorb functional concepts. ",
            "id": "fc46e7a77311f9385f93edcdc86911f2"
          },
          {
            "type": "html",
            "text": "\nAnyone writing a language today who isn't familiar with Scheme, [[Haskell Language]], and [[Ml Language]] may as well throw in the towel right now. Unless they plan to invent the next great paradigm, they will not succeed. I think it's impossible, in 2001, to write a language without taking functional concepts into account. (Of course I'm reminded of [[Andrew Tanenbaum]] telling [[Linus Torvalds]] that writing a [[Monolithic Kernel]] in 1991 was a fundamentally bad idea...) ",
            "id": "1c0c095a56bede298aedc11bd36c13e9"
          },
          {
            "type": "html",
            "text": "-- [[Ton Tobius]] (?)",
            "id": "213aa9a576c74e561413c5bf4a8691c6"
          },
          {
            "type": "html",
            "text": "<i>Alas, [[Micro Soft]] had to come up with another non-functional, mainstream, language, and spoil your nice prediction... If [[Csharp Language]] had true closures it would be a real improvement over [[Java Language]].</i> -- [[Carlos Scheidegger]]",
            "id": "eb492cbe134475655923b8db78b62a63"
          },
          {
            "type": "html",
            "text": "\nYou're wrong, closures are in the 2.0 spec, and it is a real improvement over [[Java Language]].",
            "id": "52fbebb15e186181b28f5b76e52a631a"
          },
          {
            "type": "html",
            "text": "<i>Actually I think that means he's right. He said that if C# had true closures then it would be a real improvement. You're saying that C# v2.0 will have real closures, and it is a real improvement. You appear to be in [[Violent Agreement]].</i>",
            "id": "c7992fd2aa22aa14e1b06d6eb5362197"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cf141876205e643d062f126a31bb797"
          },
          {
            "type": "html",
            "text": "\nAbove comment is from a [[Slash Dot]] discussion. I found it highly interesting, so I copied it here (with permission). If you think it doesn't belong here, please flame me, not the author. -- [[Falk Bruegmann]]",
            "id": "b7d891b22e63d041d149b13284f85a10"
          },
          {
            "type": "html",
            "text": "\nI have to agree with this. Extrapolating from current language evolution I predict that in 20 years time programmers will be using . . . Lisp. Except it won't be called Lisp and it might have a different syntax, but it will offer all the power and flexibility of the world's second oldest programming language. Now that's progress! -- [[Noel Welsh]]",
            "id": "0013f23a5892b6172b61f4accbf331d3"
          },
          {
            "type": "html",
            "text": "<i>That *is* progress. -- [[David Sarah Hopwood]]</i>",
            "id": "0b227b25ee7eca2e92c72d5eae067cf6"
          },
          {
            "type": "html",
            "text": "\nLisp-like languages with non-Lisp-like syntax:",
            "id": "69c5fa532c1298d5272d02805c0643ff"
          },
          {
            "type": "html",
            "text": " Egil MÃ¶ller's [[Sugar Language]].",
            "id": "4c434e85923bfa4db8b7363f1a26b87d"
          },
          {
            "type": "html",
            "text": " [[Dylan Language]] has semantics similar to Scheme, an object system similar to CLOS ([[Common Lisp Object System]]) and a syntax similar to [[Pascal Language]], [[Modula Three]], or [[Ada Language]].",
            "id": "804dabf309594f1cc1ac820c7e6136af"
          },
          {
            "type": "html",
            "text": " [[Io Language]]",
            "id": "3ca18bfd6e4619d99f04eb9e95789ecd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cf141876205e643d062f126a31bb797"
          },
          {
            "type": "html",
            "text": "<i>Except it won't be called Lisp and it might have a different syntax, but it will offer all the power and flexibility of the world's second oldest programming language.</i>",
            "id": "cce7a8b0e1781b6c41922e925457e224"
          },
          {
            "type": "html",
            "text": "\nPeople keep propagating this misconception, i.e. that the lisp syntax\nis in some way a problem. Nothing could be further from the truth: Lisp's\nsyntax is in fact one of its strongest advantages! Study just enough lisp\nto understand what DEFMACRO does, and why an expression like",
            "id": "785e56c4b95683548cd244b248530abf"
          },
          {
            "type": "code",
            "text": "        (html (:h1 \"foo\")\n                (:p     \"Some text\"))",
            "id": "abe99d71042c6b71260ae5c491824a36"
          },
          {
            "type": "html",
            "text": "can be viewed as either data or a program, and you'll know why Lispers\nare so reticent of letting go of their beautifully designed [[Ess Expressions]].",
            "id": "afdd5eca931e944104548fc4a33d4e22"
          },
          {
            "type": "html",
            "text": "-- [[Alain Picard]]",
            "id": "33b884027d393a932657fd3aa758f7b7"
          },
          {
            "type": "html",
            "text": "\nRight on.",
            "id": "2c89bb764ab153691d3895c590bda34b"
          },
          {
            "type": "html",
            "text": "<i>Viewing expressions as either data or a program is not dependent on Lisp's syntax. If Lisp had been defined with an infix syntax and [[Term Trees]] in place of [[Ess Expressions]], it would have been just as expressive, and probably a lot more popular. [[Syntax Does Matter]]. -- [[David Sarah Hopwood]]</i>",
            "id": "08d2b54dee24c4a6fa5bdd06a4a52e39"
          },
          {
            "type": "html",
            "text": "\n[[Dylan Language]] is Lisp with infix syntax.  It's <i>almost</i> as expressive (missing some of the more obscure parts of the [[Meta Object Protocol]], and [[Compiler At Run Time]]), but IMHO easier to read.  However, it's just as unpopular as Lisp.  I suspect marketing clout matters a whole lot more than expressiveness, and both matter more than syntax. -- [[Jonathan Tang]]",
            "id": "84c9c788b298c433ca65aac5c55c27d5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cf141876205e643d062f126a31bb797"
          },
          {
            "type": "html",
            "text": "\nOr it could be that functional languages are as stillborn as videophones. I don't mean to imply that the low-fi network we have today is better than videophones; It's just that we've been waiting a long time for Lisp to displace its less capable sisters and were aren't much further along.",
            "id": "b22603fde980b338331600f091b9738c"
          },
          {
            "type": "html",
            "text": "<i>It's not that Lisp will displace its less capable sisters. Its less capable sisters will absorb ideas from Lisp in the same way that [[Java Language]] is [[Smalltalk Minus Minus]]. [[Python Language]] is getting more [[Functional Programming Language]] features, [[Java Script]] is an object-functional hybrid, the C++ STL is functional programming in C++. [[Lisp Language]] isn't popular for many of the same reasons [[Small Talk]] isn't popular (I know lots of people use both of them, but its nothing compared to [[Java Language]]) but the ideas are slowly shifting into mainstream programming. You can wait for the future to arrive in mainstream languages, or you jump to the future today (or 15 years ago). -- [[Noel Welsh]]</i>",
            "id": "e0ba0856a44c24cda2af7c9f872a307b"
          },
          {
            "type": "html",
            "text": "\nAbsorption can only go so far. The central idea of functional languages is that there is no stored program state -- no variables. So even the venerable <i>while</i> loop is verboten. Java, Python, and other mainstream languages cannot absorb such a radically different idea. -- [[Ian Rae]]",
            "id": "f7e49a1a413ee27017074eb89bcea131"
          },
          {
            "type": "html",
            "text": "\nNonsense. A <i>while</i> construct in [[Haskell Language]] can be written as",
            "id": "53796712f5fddb3c0489b693ef111fe6"
          },
          {
            "type": "code",
            "text": "  while cond body =\n      do\n         testResult <- cond\n         if testResult\n           then body >> while cond body\n           else return ()",
            "id": "4a24c5277ad5680455cc0321c8cbae99"
          },
          {
            "type": "html",
            "text": "''Actually, the \"while cond body\" part is likely to be factored out:",
            "id": "0c0070494f8766bf2bf16c4dfa03add6"
          },
          {
            "type": "code",
            "text": " while cond body = loop\n   where loop = do testResult <- cond\n                   if testResult then do {body; loop}\n                                 else return ()''",
            "id": "56b18c25285cba6ea52c662613175f26"
          },
          {
            "type": "html",
            "text": "''And you're both cheating. This while loop does useful work only by\nbeing in a monad, presumably IO. Though you'll surely tell me, a State\nMonad is still purely functional, the code above isn't. This is",
            "id": "2fcce48ad4914d255afdc7d69ab35e89"
          },
          {
            "type": "html",
            "text": "<i>dysfunctional</i> code embedded in Haskell. A while \"loop\" in Haskell\nis usually implemented using \"iterate\" and \"find\", but that requires\nthinking and doesn't prove a stupid point.''",
            "id": "aad4703c4f3e47eb52bada792fc355db"
          },
          {
            "type": "html",
            "text": "\nTThe assertion \"the code above isn't [purely functional]\" is patently false. Both definitions given are indeed purely functional, the do-notation notwithstanding; it's just syntactic sugar. The following definition is equivalent and uses only lambda, function application and if-then:",
            "id": "bf0d96e825c40b041629ebde562dc73b"
          },
          {
            "type": "code",
            "text": " while = \\cond body ->\n   cond >>= (\\testResult ->\n     if testResult\n       then (body >> while cond body)\n       else (return ())\n   )",
            "id": "536664cc530c9a9b6613d028cbf0b54b"
          },
          {
            "type": "html",
            "text": "This definition, just like the others, satisfies all of Haskell's normal criteria of referential transparency and so forth. Granted, it can only be applied to monadic values, but since a value with a monadic type simply represents an action of some kind, it's no different than a while loop in any other language.",
            "id": "7b3b1e5a6ff250632e2a37481d5cbcb2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cf141876205e643d062f126a31bb797"
          },
          {
            "type": "html",
            "text": "\nThe main problem with Smalltalk is that it allows the programmer to do too much with too little effort. If you are going to create a new product and you have a bunch of people working for you, probably you would like these programmers to have the least ability to do any harm, to have them totally isolated and constrained, using your favorite compiler and each suspecting of each other. Make them compete with periodic evaluations and comparisons with their peers. The task will take longer because of the language you chose, but it does not matter since you can always make them work overtime, besides most people have C++ and Java skills, so they can be more easily replaced. Actually a boss gets rewarded if he can make his people work overtime, it shows that the boss knows the tools of the trade, so the one that gets rewarded for using a low productivity compiler like C++ and Java, is the manager. The project takes longer and he gets paid for his time, not for the time it takes to deliver. This is the usual\nreward for being incompetent.",
            "id": "95f7f1b6ff63910b02dafb8326efe5bd"
          },
          {
            "type": "html",
            "text": "\nSince more and more people work in C++ and Java, using another language make you look like a risk taker. Managers are not risk takers, since one pitfall may mean termination. Stockholders are risk takers (since they can invest in many stocks at the same time), but they do not make the decisions. ",
            "id": "ecf1de749f59449bfa63b6f8a066a99e"
          },
          {
            "type": "html",
            "text": "<i>OTOH, there are real advantages, both technical and social, to using a language that is well-supported and popular.</i>",
            "id": "0384e450fc008ab909a4bcb4a1587914"
          },
          {
            "type": "html",
            "text": "[The fallacy is in assuming that only one language can be used.\nMultiple languages (at least three: for heavy numeric, business logic\nand scripting, respectively) can happily coexist in a single\napplication.]",
            "id": "05d98007c64097524a3954d625dacece"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cf141876205e643d062f126a31bb797"
          },
          {
            "type": "html",
            "text": "<i>Software is not developed by a conspiracy of managers! [[Assume Ignorance Not Malice]], [[Assume Stupidity Not Malice]]. But also [[Keep An Open Mind]], matey. Maybe there are good reasons for people using the languages they use.</i> ",
            "id": "090bcaaa553e71e19a1b403569ed4201"
          },
          {
            "type": "html",
            "text": "[There are good reasons, for some value of 'good'. They just aren't software engineering (hardly surprising, as that does not really exist as yet) reasons.]",
            "id": "afc28c54ec695a4c77f78a05ba064d5a"
          },
          {
            "type": "html",
            "text": "<i>See [[Economic Efficiency Is Not Engineering Efficiency]] for further explication of one part of this issue. - [[Jay Osako]]</i>",
            "id": "6bfbb648109400b2cce3908c7eb21766"
          },
          {
            "type": "html",
            "text": "\nAnd maybe there aren't. Corporations have a terrible habit of deciding that some language or other will be the language used for <i>all</i> future development (until they choose the next one), irrespective of its suitability for many of the problems addressed.",
            "id": "9f622b03f783db2b4ae8f4c09d3e0bc2"
          },
          {
            "type": "html",
            "text": "<i>In that case you should be looking to [[Change Your Organization]] one way or another. Where I work currently, someone recently tried to lay a one-language law down in a business area (Java for everything). I stood and fought my ground for an analytics subsystem being in C++, and won my case. It boiled down to knocking down a lot of straw men, and finally implementing the new subsystem in both C++ and Java and showing that JNI latency was not an issue. If I had not been able to get the issue judged on its merits I would have started looking to work elsewhere because [[Lifes Too Short]] to deal with a losing company. This is not just rhetoric, I have actually left an employer for similar reasons before. In that case, it was because they were too scared to start moving business functionality in C as part of a necessary shift from a dying language (Clipper). That company is now out of business.</i>",
            "id": "8f536627bab3e76f34feb87e4a637b62"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cf141876205e643d062f126a31bb797"
          },
          {
            "type": "html",
            "text": "As an imperativist, I am wary of functional languages (and i'm really talking about pure functional languages here) because I don't see how to distribute state around the program. Consider the case of an client-side FTP library: there is all sorts of state associated with the connection, from a socket handle and buffers to connection status and the current directory; there is also loads of behaviour, such as methods for sending commands, reading responses, etc. In an OO language, I can bundle up the state into an object, and present a simple interface to the rest of the program. In a procedural language, I can bundle up the state in a struct, and still provide a pretty simple interface through a set of procedures to manipulate the struct. In a functional language, I can still have a struct, but it's now immutable, which means that if a function wants to 'change' it, it has to make a new version and hand that back to the caller, who then has to use that instead.",
            "id": "1328db98733e376c905e7b05f9dfb3a9"
          },
          {
            "type": "html",
            "text": "\nIn simple cases, this is still okay, but I can imagine more complex cases where some component on one side of the program wants to change the state of a component over on the other side, without bothering the code that's currently calling it. For example, let's say that in a P2P application (whose details are intentionally left blank!), when the Network<b></b>Browser, in the course of retrieving a file, discovers a new rendezvous server, it wants to update the Rendezvous<b></b>Server<b></b>Registry, without bothering the calling code with any kind of 'oh, by the way: I've found a new RV server' sort of message. In an imperative language, as long as the component has (or can get) a pointer to its target, it's trivial; in a functional language, it's impossible. Well, not impossible, but the only way i can see to do it is for <i>every</i> function which might want 'side-effects' of this sort to take the world as an argument and return a new version of the world with any changes it wants to make, which would suck.",
            "id": "67e06a689dc1dea169a6a7c533acd307"
          },
          {
            "type": "html",
            "text": "\nIn short, whilst functional languages may be very elegant for programming in the small, I suspect that they can't handle programming in the large. I'd be most interested to hear how functional programmers would tackle this situation.",
            "id": "00c0be051cff5607f147c074f5a3f6b3"
          },
          {
            "type": "html",
            "text": "<i>I assume you do know that you can rebuild the imperative state framework in a few lines of Haskell? After that, you can write any portion of your code you want in imperative style, and any portion in traditional functional.</i>",
            "id": "13feb74a76abad0557d6bb0c883b1c58"
          },
          {
            "type": "html",
            "text": "\nI didn't know that; my knowledge of functional languages is rather lacking. Still, using the functional language to reproduce an imperative language is a cop-out! How would my example be most cleanly implemented in a functional language?",
            "id": "6688bfbbac246c3d8aa52da53d886817"
          },
          {
            "type": "html",
            "text": "<i>The example above (network protocol client) would be, I think, most cleanly implemented by [[Co Routine]]s with local state.  You often get suboptimal results from trying to apply imperative flow-models to the functional framework - it restricts you a lot.</i> ",
            "id": "08b46fa5494f6d4c4e2e8f0cafcc00d4"
          },
          {
            "type": "html",
            "text": "\nNot surprising - it would be like emulating the relational model in procedural code or something. So, in the example, would it be that we would have a function registerRendezvousServer, which would be a coroutine with some internal state (a list of servers), and the network-browsing code would just call it when it found a new rendezvous server? That seems most straightforward. [[Thank You]].",
            "id": "18dee9538563124e1029e9654b204040"
          },
          {
            "type": "html",
            "text": "\nNow, how do I do it in a <i>pure</i> functional language?",
            "id": "7396735cf10b466986fb6ce04bf77bd5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cf141876205e643d062f126a31bb797"
          },
          {
            "type": "html",
            "text": "\nHow do you do threads in a functional language? In particular, how do they communicate? Futures?",
            "id": "37de4fb47e4dc79230a53ce67859f32a"
          },
          {
            "type": "html",
            "text": "<i>Functional languages sometimes provide </i>implicit<i> threading. I am yet to see a usage of threads which is not either an optimisation or a nice solution to a producer / consumer problem (or then, a misuse of threads where select() or somesuch would be more appropriate). But for the first one, functional languages mostly shift the optimisation burden off the programmer; and for the second one, lazy lists provide a better solution.</i>",
            "id": "d24380fce4e47d6d98b4ae38e5ee0b6f"
          },
          {
            "type": "html",
            "text": "<i>But yes, sometimes you want exactly that, threads. How you get them depends on the language, but eg Haskell would (does?) implement them as monadic operations of the IO monad, and using them will be boringly alike imperative languages.</i>",
            "id": "9c3ccb482a491cddb8420b41f78c3d7f"
          },
          {
            "type": "html",
            "text": "[There's also O'Haskell. In O'Haskell an Object, a Process, a Thread\nare basically the same and they communicate by exchanging messages.\nThis results in a program that is easy to understand, has clearly\ndefined interfaces and is reactive without much effort. I like this far\nbetter than classical threads.]",
            "id": "684e642f19f123e48064e4c6dea8683e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cf141876205e643d062f126a31bb797"
          },
          {
            "type": "html",
            "text": "[[Structure And Interpretation Of Computer Programs]] does a fine job of contrasting\nthe imperative, object-based approach with the functional approach. \nIt arrives at the tentative conclusion that neither is clearly better\nfor all applications. \nHowever, most functional âlanguagesâ (as contrasted with programming\nmethodologies) also allow an imperative style.\nIt is possible to use Haskell just as \"a better C\", to quote [[Bjarne Stroustrup]] out of\ncontext. ;-)",
            "id": "6bc031b584e8018811e12b7e5b45c262"
          },
          {
            "type": "html",
            "text": "-- [[Stephan Houben]]",
            "id": "bc14f11b1fff01de4cf33a35556c21dc"
          },
          {
            "type": "html",
            "text": "\nIs it not also possible to use imperative languages in a functional style? Perhaps not C or Java (although you can sort of do [[Blocks In Java]]), but Python certainly has first-class functions, closures, etc. Ah, of course this is the result of the [[Mainstream Influence Of Functional Languages]]!",
            "id": "dd80db532064f756665f8934ab383160"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cf141876205e643d062f126a31bb797"
          },
          {
            "type": "html",
            "text": "\nIt has already been hinted at with STL, but functional programming in [[Cee Plus Plus]] is possible by using templates to calculate the whole (sub)program at compile time, called [[Template Metaprogramming]] in C++ circles. Functional programming at compile time with OOP at run time seems to be a powerful tool.",
            "id": "3029dce53d99dc292010bee379c478be"
          },
          {
            "type": "html",
            "text": "\nA whole lot more can be done as well - see [[Functional Programming In Cpp]]. -- [[John Fletcher]]",
            "id": "e5cf039e2a1c5cbf4606e4125d796c6e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1cf141876205e643d062f126a31bb797"
          },
          {
            "type": "html",
            "text": "[[Category Functional Programming]]",
            "id": "aae0c056f4d168c41c8329ecc0e5731a"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?MainstreamInfluenceOfFunctionalLanguages c2.com]",
            "id": "e8734a244d10138f8a25501fe9fe3731"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1626125494218
    }
  ]
}