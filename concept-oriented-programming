{
  "title": "Concept Oriented Programming",
  "story": [
    {
      "type": "html",
      "text": "Informal Introduction into the [[Concept Oriented]] Programming: [http://conceptoriented.org/papers/CopInformalIntroduction.html conceptoriented.org]",
      "id": "13d4ba5719e5de30009794f061564e9b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "\nContents of this page is <b>NOT at all related to</b> DDJ \"Using networks for software development and distribution\" article in June 01, 1999, saying",
      "id": "53831eaf95b25ea6b4e9116b4f0fe6f0"
    },
    {
      "type": "html",
      "text": "<i>\"Concept-oriented programming makes it possible to write software that requires far less bandwidth to deliver, and thereby to increase apparent delivery speeds significantly. It also creates a mechanism for disseminating reusable code throughout the Internet.\"</i>",
      "id": "027def3ad4e2f58da273a651ae7a2e9d"
    },
    {
      "type": "html",
      "text": "\nDDJ Article: [http://www.ddj.com/184410968 www.ddj.com]",
      "id": "de89f51f4a5b7280d37e5838b483d514"
    },
    {
      "type": "html",
      "text": "\nThe [[Concept Oriented]] pages seem to be a \"[[Walled Garden]]\" on this Wiki.\nWhile '[[Concept Oriented Programming]]' is used on pages outside the [[Concept Oriented]] [[Walled Garden]], it's quite possible that they refer to the DDJ concept, not [[Alexandr Savinov]]'s concept",
      "id": "8aad263ce1f5050fbdfbbf0da578b73c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "\nIf [[Object Oriented Programming]] focuses on objects then CoP focuses on references or, more precisely, on reference-object pairs. In other words, any thing in the concept-oriented paradigm is viewed as consisting of two parts, called <i>reference-object</i> in CoP and <i>identity-entity</i> in [[Concept Oriented Model]]. For example, let us consider the following instruction: ",
      "id": "03654674b663f908611604f0251a07d2"
    },
    {
      "type": "code",
      "text": "  button.click(); ",
      "id": "0c2a5802def72332b7f271aae58db7bb"
    },
    {
      "type": "html",
      "text": "\nIn OOP there is one button object represented by a <i>native</i> or <i>direct</i> reference stored in the variable. It is important that all references in OOP have one and the same standard format and provide direct access to objects without any possibility to customize their structure and/or behaviour. ",
      "id": "66d84992c767ea338fdd1be8ef70916e"
    },
    {
      "type": "html",
      "text": "\nIn contrast, CoP models both references and objects so variables contain arbitrary references with the structure and functions defined by the programmer. Thus variable 'button' in the above example may store any data and method 'click' is actually intercepted by the reference before it can reach the object. For example, this button might be identified by name or by integer id. Notice that when a method is applied to a custom reference, the object native (direct) reference is not known and actually the object may reside anywhere in the world. So one of the main tasks of any reference consists in providing access to the represented object. On the other hand, the programmer still manipulates objects as if they were represented by direct native references (in the same way as in OOP) so we have the illusion of instant action. ",
      "id": "0a2dd50c080a4421c122e3cc5ac4c9f0"
    },
    {
      "type": "html",
      "text": "\nTo model references and objects CoP uses concepts ([[Concept In Cop]]) which generalize conventional classes. For example, instead of class Button we should define concept Button as follows: ",
      "id": "ac5e8026627e145a503555130c7ba72d"
    },
    {
      "type": "code",
      "text": "  '''concept''' Button \n  '''reference''' { // Reference class \n    int id; \n    ...\n  } \n  '''object''' { // Concept class \n    String title; \n    ...\n  } ",
      "id": "adcbf1623f7e56004dadb41634806307"
    },
    {
      "type": "html",
      "text": "\nNotice that the concept consists of two parts: one reference class and one object class. Thus if we have a variable of this concept then it will store an instance of the reference class while an instance of the location of the object (an instance of the object class) is unknown -- it can be on disk, on another computer, on CD or on Mars. It is important that instances of the reference class are passed-by-value while instances of the object class are passed-by-reference. ",
      "id": "5b9f6746a7da492ffc3641904e143c4a"
    },
    {
      "type": "html",
      "text": "\nEach concept has a parent concept specified by means of inclusion relation, i.e., any concept is included into a parent or base concept. Concept inclusion relation generalizes class inheritance. For example, concept Button could be included into concept Panel: ",
      "id": "7a30c4067d899b0d9c93ca9e0dd45c86"
    },
    {
      "type": "code",
      "text": "  '''concept''' Button '''in''' Panel ... ",
      "id": "5395fbb511377f4144936105c196979b"
    },
    {
      "type": "html",
      "text": "\nWhy <i>included</i> and not <i>inherited</i> or ''extends'â€™? Because the base concept plays a role of outside space, environment or context for this concept. An important consequence is that many extension reference-object pairs may exist within one base reference-object pair, i.e., a base reference-pair can be shared among extensions (in OOP it is not so). Thus elements in CoP exist within a hierarchy at run-time just as at compile-time. This hierarchy is analogous to the conventional postal addresses where many streets exist in one city, many houses exist in one street and so on. In our example, inclusion is used to include many buttons into one parent panel and therefore we say that one button is <b>IN</b> a panel. In contrast, in OOP if a button class inherits a panel class then one button <b>IS</b> a panel at run-time. Button within a panel are distinguished by their references (described in the reference class). Another important difference from OOP is that parts of objects in CoP (base and extensions) are represented by their own references and may have different locations. So panel object may have one address in memory while button object has another location, for example, on disk. ",
      "id": "46c851ff7002841b3562e0a69c81129f"
    },
    {
      "type": "html",
      "text": "\nPanels themselves may have a reference class and hence we can have many panels each having many buttons. In order to uniquely represent a button we need to specify its panel reference and its button reference within this panel. Such a reference consisting of many segments is referred to as complex reference. If concept Panel also has a parent concept then a fully quantified reference will include more segments. When an indirectly represented object is accessed, say, a button is clicked, then the complex reference has to provide access to the object. It is done automatically by a so called <i>continuation method</i>. ",
      "id": "f329607e14c73c468a2730121499e1ac"
    },
    {
      "type": "html",
      "text": "\nOne principle of CoP is that parent reference methods override child reference methods (while child object methods still override base object methods). In particular, panel reference will intercept all access requests to its child objects such buttons or labels or icons (all existing inside this panel). Normally such base reference methods are used to inject some additional behaviour or to wrap target object methods into some common function. For example, base reference methods might draw background, perform security checks etc. In other words, reference methods play a role of incoming methods of some scope like panel or button. Using reference methods the programmer can describe intermediate functionality executed implicitly behind the scenes during object access. In other words, they are responsible for functions which are triggered automatically when an access request intersects some space border. ",
      "id": "3c3e4295d2f6de3e54dd0c278b18d0b1"
    },
    {
      "type": "html",
      "text": "\nA concept-oriented program uses concepts instead of classes. In particular, concepts are used to declare a type of variables, fields, parameters and return values. The difference from OOP is that objects in CoP are represented and accessed indirectly. This allows the programmer to describe intermediate functionality which is triggered automatically when method calls intersect space borders described by concepts. For example, a single method call button.click() might implicitly trigger rather complex processes which are executed when the target object is being accessed. ",
      "id": "7e6948e354d4eb0dd6e3962e9adaae2b"
    },
    {
      "type": "html",
      "text": "\nMore information on the concept-oriented programming can be found at the concept-oriented portal here [http://conceptoriented.org conceptoriented.org]. It also includes information on the [[Concept Oriented Model]] and other related issues.",
      "id": "518b19bc80511a4b911eb3686db5d750"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "<i>This is an interesting idea, but I'm finding it difficult to grasp how it would work in practice.  Would you consider producing some simple examples of code or pseudocode, either here or on your Web site, to illustrate?  In particular, it would be helpful to see how [[Concept Oriented Programming]] differs from and/or extends (say) [[Object Oriented Programming]].</i> -- [[Dave Voorhis]]",
      "id": "113a9cc9eba50586aa7d4cedbcc65cf9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "\nThere is a name space collision here.  As far as I know, [[Brian Mc Connell]] originated this term in the June 1999 issue of [[Dr Dobbs Journal]], but is using it to describe something different.  This term appears again in Brian's book <i>Beyond Contact</i> published by O'Reilly in 2001.  I don't know how to resolve issues like this, but you might want to be informed of this.  When I use this term, I'm referring to Brian's definition, not this one. -- [[Jon Riehl]]",
      "id": "cfc56c0d281ce7ce76ebe0c22ff522a6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "\nI am interested in how this work may relate to the proposal to have concepts in C++, see [[Concept Cpp]]. -- [[John Fletcher]] ",
      "id": "6e19c4292d050ad4ad6c98957a0904d3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "\nPeople need to be aware that [[Concept Oriented Programming]] shares its TLA with another technique of programming: [[Context Oriented Programming]].",
      "id": "35bdd09b620a252abfd1b893fa641bc5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "\nOK, I read the whole paper at\n[http://conceptoriented.org/papers/CopInformalIntroduction.html conceptoriented.org]",
      "id": "6d159ead4140442c4a9decca021d5bca"
    },
    {
      "type": "html",
      "text": "(<i>\"Informal Introduction into the Concept-Oriented Programming\"</i> by [[Alexandr Savinov]])",
      "id": "e251a040ef177d2f29902e3880c14439"
    },
    {
      "type": "html",
      "text": "\nAnd I'm not impressed.",
      "id": "03760a04cd9402b38c63d1dcd75743a3"
    },
    {
      "type": "html",
      "text": "\nIt looks like the [[Concept Oriented Programming]] style could be achieved in [[Object Oriented Programming]] languages with consistent adherence to [[Interface Based Programming]] and the [[Proxy Pattern]].",
      "id": "f18ecc651d39229fcbddbeef580211f9"
    },
    {
      "type": "html",
      "text": "(The paper does mention proxies several times, reinforcing this idea.)\nThe \"Concept\" side of [[Concept Oriented Programming]] seems to address name-to-object mapping issues addressed by JNDI ([[Java Naming And Directory Interface]]) or the Moniker pattern ([[Micro Soft]] IMoniker interface).",
      "id": "5ccead0a6035da4366f6b2614062cea2"
    },
    {
      "type": "html",
      "text": " <i>I, at least, find coding in a [[Turing Tarpit]] to be unproductive, so I tend to observe related achievements as proof-of-concept, and their use as proof-of-value, rather than arguments against an idea. Admittedly, I'm also not impressed that COP is helping me achieve any [[Non Functional Requirements]], but it irritates me to see 'X could be achieved in Y' as implicit explanation for 'I'm not impressed.' (related: [[Design Patterns Are Missing Language Features]]).</i>",
      "id": "59529dbf0648a12b24eb3beaff91e920"
    },
    {
      "type": "html",
      "text": "\nThe paper describes the use of [[Aspect Oriented Programming]] in [[Object Oriented Programming]] languages to address cross-cutting concerns.",
      "id": "87480dda42ce588d0dc99b2bd72ad316"
    },
    {
      "type": "html",
      "text": "\nI wonder what [[Concept Oriented Programming]] may offer above and beyond the above.",
      "id": "df467d134f3b5b6227eabfb891297c70"
    },
    {
      "type": "html",
      "text": "\nObservations about the paper:",
      "id": "a72a1ad2ffb087ad78946cd1d092403a"
    },
    {
      "type": "html",
      "text": " They completely confuse inheritance with containment.  See \"Figure 4\":  They're criticizing the limitations of using inheritance when containment should have been used.",
      "id": "428504d2b78ac7bc63a4f71409e9af08"
    },
    {
      "type": "html",
      "text": " They don't understand that AOP Advice is defined independently of point cuts.",
      "id": "bfbb0eeab1f409acfd90ad2529eae40d"
    },
    {
      "type": "html",
      "text": " COP seems particularly weak, in comparison to AOP, with regard to mixing in multiple cross-cutting concerns in a single class, or distributing a single cross-cutting concern across multiple concept hierarchies.  COP seems to suffer from a \"single inheritance hierarchy\" problem when one needs to do cross-cutting concern mixins.",
      "id": "67bd50806990767c5f721ed610f5f863"
    },
    {
      "type": "html",
      "text": " They assume that ALL object instances are persisted and shared between processes.  This may be good for database and remote system access, but doesn't seem to address local code and data organization.",
      "id": "f80bef7e941e8543d6946f31123893a9"
    },
    {
      "type": "html",
      "text": " VERY strong hierarchical relationships are assumed, and these are baked into the design early.  This could suffer from similar problems that plagued [[Hierarchical Database]]s. (see [[Limits Of Hierarchies]])",
      "id": "d4948a737d7a3d6775dad250be5ccd9d"
    },
    {
      "type": "html",
      "text": " Objects are loaded and saved at every method access.  I see no provision for transactions that span multiple method calls.  This could be <b>really bad</b> for most business applications.",
      "id": "c27894f6ff2e510b18843820230be162"
    },
    {
      "type": "html",
      "text": " Their analogies are strained.  And not necessarily applicable to software development in general.",
      "id": "8549b49cbf17763ae2148fc451b7a503"
    },
    {
      "type": "html",
      "text": "\nHmmm...\nYou know, it's gonna be kinda hard to do much [[Concept Oriented Programming]] for a while because",
      "id": "48e2666aeb93c1c6ec5f37cbdea9b134"
    },
    {
      "type": "code",
      "text": " '''''\"Currently there are no concept-oriented programming languages\"'''''",
      "id": "449b138d27a87d3f73b233e34333cb89"
    },
    {
      "type": "html",
      "text": "as stated by the paper's author at [http://conceptoriented.org/forums/viewtopic.php?f=3&t=6#p8 conceptoriented.org]",
      "id": "93da17165fb7951c4fd00e452a95921e"
    },
    {
      "type": "html",
      "text": "-- [[Jeff Grigg]]",
      "id": "5c69177938a12e01c601f412dcd2a6a0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "\nI have found the following in the Conclusions of the introductory paper, [http://conceptoriented.org/papers/CopInformalIntroduction.html conceptoriented.org]<b></b>:",
      "id": "2f23504d25354a2fb0df64b4ed1faf72"
    },
    {
      "type": "html",
      "text": "The solution based on concepts could be informally compared with the introduction of complex numbers in mathematics which also have two constituents: real part and imaginary part. As a result of such mathematical generalization formulas and manipulations get much simpler and more natural in comparison with the conventional real numbers. The same effect is achieved in programming by introducing concepts instead of classes: programs get much simpler and their logic is expressed more naturally and elegantly when we manipulate pairs of references (imaginary part) and objects (real part).",
      "id": "c59dc19e1b5a061c9c1613ec10513d7d"
    },
    {
      "type": "html",
      "text": "\nThat seems to me to give some insight into the thinking of the author, [[Alexandr Savinov]], who is the only author he references. It also gives a clue as to how to implement the ideas, using a tuple object in e.g. [[Cee Plus Plus]] to as a basis. -- [[John Fletcher]]",
      "id": "b4b11d5d5c39aec272d668b5dea668a1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "\nI could implement this as a Java code generator, using Java [[Dynamic Proxy]]s to implement the reversed method overriding conventions of concept references.",
      "id": "1567e62c912dd17b0f5b28729ab848b6"
    },
    {
      "type": "html",
      "text": "(Would need an additional proxy for each level of parent reference calling to a 'sub' reference level, but that wouldn't be hard.)",
      "id": "cd34b9aeb238053d2f623754d0c9c0c9"
    },
    {
      "type": "html",
      "text": "\nI do hit a stumbling block where references use the 'object' keyword to call their object instances:\nThis seems to assume that the object for each reference is in memory, as the reference isn't implementing code, like serialization and deserialization, or creating objects from database data.\nSo this seems to imply to me that concept references could lookup their objects, using their concept identifiers, right when the references are created.",
      "id": "c4f2ab07fc6ace60ed197678287aa3fd"
    },
    {
      "type": "html",
      "text": "(IE: in a reference \"constructor\" method.)",
      "id": "e4f83abea2c1464911033610297ef787"
    },
    {
      "type": "html",
      "text": "\nThis makes me think that [[Concept Oriented Programming]] is <b>not</b> as general as claimed, as it would need some as yet unspecified way for reference definitions to explicitly define how one transforms reference keys to object instances.\nThat is, is needs something more than just an \"object.\" keyword.",
      "id": "fba2a39e093d1ab64c56eb9264fb787e"
    },
    {
      "type": "html",
      "text": "-- [[Jeff Grigg]]",
      "id": "5c69177938a12e01c601f412dcd2a6a0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "\n[[Concept Oriented Programming]] formalizes spaces by formalizing object-identity and capturing messaging automatically by having the outer-space serve [[Proxy Objects]] for the objects (or 'concepts') held within. I believe that formalizing the concept of 'spaces' is a fine idea. It allows for useful features to be developed, such as local optimizations while still integrating with global distribution, the ability to provide [[Container Managed Persistence]] at the level of 'spaces', a natural unit of runtime modularity (as opposed to source modularity), allowance for [[Hot Swap]]ping code in a given space by delaying events at space borders, support for code-chunking and distribution, and elimination of <b>global</b> variables in the 'global' sense while still allowing globals to be local to a parent space.",
      "id": "46e01081f8c792722496c3f5747b25e7"
    },
    {
      "type": "html",
      "text": "\nThat said, it is my impression that [[Concept Oriented Programming]] is an unnecessarily complicated approach to achieving these goals. It looks to me that each <b>concept</b>, such as <b>Button</b>, is being specialized based on its location (e.g. <b>Button in a Panel</b>, <b>Button on a Train</b>, <b>Button in the Rain</b>, <b>Button on Green Eggs and Ham</b>) in addition to having the normal [[Object Oriented]] specialization in its properties (e.g. <b>[[Radio Button]]</b>, <b>E</b><b>ggButton</b>, <b>H</b><b>amButton</b>). This implies an enormous specialization burden on the programmers. If we had asynchronous [[Message Passing]] between objects, would we further specialize concepts as <b>[[Red Button]] in a Panel on a [[Message Queue]]</b>?",
      "id": "6ebf5ae197f5c9056f3732838da46ce2"
    },
    {
      "type": "html",
      "text": "\nI would prefer approaches to managing spaces that allows programmers of a component to be ignorant of the space in which that component shall reside. In designs I've been working with, doing so requires that 'objects' (or 'actors' in my case) be constructed with references to 'resources' available in their local environment, and that the environment or locality provide these resources. Usefully, in addition to the normal benefits of controlling interaction with environment, this provides a mechanism for mobile code (a mobile code chunk is an abstract unit of code that needs a set of local resources in order to run) and supports coordination languages for actor/process configurations and [[Dataflow Programming]]. ",
      "id": "4bc22821791cc11c59edcec4fba8181a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "A particularly well built group of [[Endeme Set]]s could be used to wrap data in a [[Universal Identification]] using the potential of [[En Deme]]s and [[Endeme Path]]s to wrap data. This would meet the requirements of 'concepts' as described. However I have not figured out to do this yet.",
      "id": "f1edd4d9a8cd277edb53a7cf57d6cdde"
    },
    {
      "type": "html",
      "text": "-- [[Jon Grover]]",
      "id": "7f7a615c9a7cda14fb94326ed40f3d14"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "[[January Zero Nine]]",
      "id": "9355c3e745c9bf3369b7d61a0594177e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
    },
    {
      "type": "html",
      "text": "[[Category Information Orientation]]",
      "id": "b4bdb466ee85621e958447bfe3554abf"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ConceptOrientedProgramming c2.com]",
      "id": "031f54e76e4db76db4186cd50cd62c18"
    }
  ],
  "journal": [
    {
      "date": 1415908135000,
      "id": "b07e3b24ea2767ec26cfb03979e09a32",
      "type": "create",
      "item": {
        "title": "Concept Oriented Programming",
        "story": [
          {
            "type": "html",
            "text": "Informal Introduction into the [[Concept Oriented]] Programming: [http://conceptoriented.org/papers/CopInformalIntroduction.html conceptoriented.org]",
            "id": "13d4ba5719e5de30009794f061564e9b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "\nContents of this page is <b>NOT at all related to</b> DDJ \"Using networks for software development and distribution\" article in June 01, 1999, saying",
            "id": "53831eaf95b25ea6b4e9116b4f0fe6f0"
          },
          {
            "type": "html",
            "text": "<i>\"Concept-oriented programming makes it possible to write software that requires far less bandwidth to deliver, and thereby to increase apparent delivery speeds significantly. It also creates a mechanism for disseminating reusable code throughout the Internet.\"</i>",
            "id": "027def3ad4e2f58da273a651ae7a2e9d"
          },
          {
            "type": "html",
            "text": "\nDDJ Article: [http://www.ddj.com/184410968 www.ddj.com]",
            "id": "de89f51f4a5b7280d37e5838b483d514"
          },
          {
            "type": "html",
            "text": "\nThe [[Concept Oriented]] pages seem to be a \"[[Walled Garden]]\" on this Wiki.\nWhile '[[Concept Oriented Programming]]' is used on pages outside the [[Concept Oriented]] [[Walled Garden]], it's quite possible that they refer to the DDJ concept, not [[Alexandr Savinov]]'s concept",
            "id": "8aad263ce1f5050fbdfbbf0da578b73c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "\nIf [[Object Oriented Programming]] focuses on objects then CoP focuses on references or, more precisely, on reference-object pairs. In other words, any thing in the concept-oriented paradigm is viewed as consisting of two parts, called <i>reference-object</i> in CoP and <i>identity-entity</i> in [[Concept Oriented Model]]. For example, let us consider the following instruction: ",
            "id": "03654674b663f908611604f0251a07d2"
          },
          {
            "type": "code",
            "text": "  button.click(); ",
            "id": "0c2a5802def72332b7f271aae58db7bb"
          },
          {
            "type": "html",
            "text": "\nIn OOP there is one button object represented by a <i>native</i> or <i>direct</i> reference stored in the variable. It is important that all references in OOP have one and the same standard format and provide direct access to objects without any possibility to customize their structure and/or behaviour. ",
            "id": "66d84992c767ea338fdd1be8ef70916e"
          },
          {
            "type": "html",
            "text": "\nIn contrast, CoP models both references and objects so variables contain arbitrary references with the structure and functions defined by the programmer. Thus variable 'button' in the above example may store any data and method 'click' is actually intercepted by the reference before it can reach the object. For example, this button might be identified by name or by integer id. Notice that when a method is applied to a custom reference, the object native (direct) reference is not known and actually the object may reside anywhere in the world. So one of the main tasks of any reference consists in providing access to the represented object. On the other hand, the programmer still manipulates objects as if they were represented by direct native references (in the same way as in OOP) so we have the illusion of instant action. ",
            "id": "0a2dd50c080a4421c122e3cc5ac4c9f0"
          },
          {
            "type": "html",
            "text": "\nTo model references and objects CoP uses concepts ([[Concept In Cop]]) which generalize conventional classes. For example, instead of class Button we should define concept Button as follows: ",
            "id": "ac5e8026627e145a503555130c7ba72d"
          },
          {
            "type": "code",
            "text": "  '''concept''' Button \n  '''reference''' { // Reference class \n    int id; \n    ...\n  } \n  '''object''' { // Concept class \n    String title; \n    ...\n  } ",
            "id": "adcbf1623f7e56004dadb41634806307"
          },
          {
            "type": "html",
            "text": "\nNotice that the concept consists of two parts: one reference class and one object class. Thus if we have a variable of this concept then it will store an instance of the reference class while an instance of the location of the object (an instance of the object class) is unknown -- it can be on disk, on another computer, on CD or on Mars. It is important that instances of the reference class are passed-by-value while instances of the object class are passed-by-reference. ",
            "id": "5b9f6746a7da492ffc3641904e143c4a"
          },
          {
            "type": "html",
            "text": "\nEach concept has a parent concept specified by means of inclusion relation, i.e., any concept is included into a parent or base concept. Concept inclusion relation generalizes class inheritance. For example, concept Button could be included into concept Panel: ",
            "id": "7a30c4067d899b0d9c93ca9e0dd45c86"
          },
          {
            "type": "code",
            "text": "  '''concept''' Button '''in''' Panel ... ",
            "id": "5395fbb511377f4144936105c196979b"
          },
          {
            "type": "html",
            "text": "\nWhy <i>included</i> and not <i>inherited</i> or ''extends'â€™? Because the base concept plays a role of outside space, environment or context for this concept. An important consequence is that many extension reference-object pairs may exist within one base reference-object pair, i.e., a base reference-pair can be shared among extensions (in OOP it is not so). Thus elements in CoP exist within a hierarchy at run-time just as at compile-time. This hierarchy is analogous to the conventional postal addresses where many streets exist in one city, many houses exist in one street and so on. In our example, inclusion is used to include many buttons into one parent panel and therefore we say that one button is <b>IN</b> a panel. In contrast, in OOP if a button class inherits a panel class then one button <b>IS</b> a panel at run-time. Button within a panel are distinguished by their references (described in the reference class). Another important difference from OOP is that parts of objects in CoP (base and extensions) are represented by their own references and may have different locations. So panel object may have one address in memory while button object has another location, for example, on disk. ",
            "id": "46c851ff7002841b3562e0a69c81129f"
          },
          {
            "type": "html",
            "text": "\nPanels themselves may have a reference class and hence we can have many panels each having many buttons. In order to uniquely represent a button we need to specify its panel reference and its button reference within this panel. Such a reference consisting of many segments is referred to as complex reference. If concept Panel also has a parent concept then a fully quantified reference will include more segments. When an indirectly represented object is accessed, say, a button is clicked, then the complex reference has to provide access to the object. It is done automatically by a so called <i>continuation method</i>. ",
            "id": "f329607e14c73c468a2730121499e1ac"
          },
          {
            "type": "html",
            "text": "\nOne principle of CoP is that parent reference methods override child reference methods (while child object methods still override base object methods). In particular, panel reference will intercept all access requests to its child objects such buttons or labels or icons (all existing inside this panel). Normally such base reference methods are used to inject some additional behaviour or to wrap target object methods into some common function. For example, base reference methods might draw background, perform security checks etc. In other words, reference methods play a role of incoming methods of some scope like panel or button. Using reference methods the programmer can describe intermediate functionality executed implicitly behind the scenes during object access. In other words, they are responsible for functions which are triggered automatically when an access request intersects some space border. ",
            "id": "3c3e4295d2f6de3e54dd0c278b18d0b1"
          },
          {
            "type": "html",
            "text": "\nA concept-oriented program uses concepts instead of classes. In particular, concepts are used to declare a type of variables, fields, parameters and return values. The difference from OOP is that objects in CoP are represented and accessed indirectly. This allows the programmer to describe intermediate functionality which is triggered automatically when method calls intersect space borders described by concepts. For example, a single method call button.click() might implicitly trigger rather complex processes which are executed when the target object is being accessed. ",
            "id": "7e6948e354d4eb0dd6e3962e9adaae2b"
          },
          {
            "type": "html",
            "text": "\nMore information on the concept-oriented programming can be found at the concept-oriented portal here [http://conceptoriented.org conceptoriented.org]. It also includes information on the [[Concept Oriented Model]] and other related issues.",
            "id": "518b19bc80511a4b911eb3686db5d750"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "<i>This is an interesting idea, but I'm finding it difficult to grasp how it would work in practice.  Would you consider producing some simple examples of code or pseudocode, either here or on your Web site, to illustrate?  In particular, it would be helpful to see how [[Concept Oriented Programming]] differs from and/or extends (say) [[Object Oriented Programming]].</i> -- [[Dave Voorhis]]",
            "id": "113a9cc9eba50586aa7d4cedbcc65cf9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "\nThere is a name space collision here.  As far as I know, [[Brian Mc Connell]] originated this term in the June 1999 issue of [[Dr Dobbs Journal]], but is using it to describe something different.  This term appears again in Brian's book <i>Beyond Contact</i> published by O'Reilly in 2001.  I don't know how to resolve issues like this, but you might want to be informed of this.  When I use this term, I'm referring to Brian's definition, not this one. -- [[Jon Riehl]]",
            "id": "cfc56c0d281ce7ce76ebe0c22ff522a6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "\nI am interested in how this work may relate to the proposal to have concepts in C++, see [[Concept Cpp]]. -- [[John Fletcher]] ",
            "id": "6e19c4292d050ad4ad6c98957a0904d3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "\nPeople need to be aware that [[Concept Oriented Programming]] shares its TLA with another technique of programming: [[Context Oriented Programming]].",
            "id": "35bdd09b620a252abfd1b893fa641bc5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "\nOK, I read the whole paper at\n[http://conceptoriented.org/papers/CopInformalIntroduction.html conceptoriented.org]",
            "id": "6d159ead4140442c4a9decca021d5bca"
          },
          {
            "type": "html",
            "text": "(<i>\"Informal Introduction into the Concept-Oriented Programming\"</i> by [[Alexandr Savinov]])",
            "id": "e251a040ef177d2f29902e3880c14439"
          },
          {
            "type": "html",
            "text": "\nAnd I'm not impressed.",
            "id": "03760a04cd9402b38c63d1dcd75743a3"
          },
          {
            "type": "html",
            "text": "\nIt looks like the [[Concept Oriented Programming]] style could be achieved in [[Object Oriented Programming]] languages with consistent adherence to [[Interface Based Programming]] and the [[Proxy Pattern]].",
            "id": "f18ecc651d39229fcbddbeef580211f9"
          },
          {
            "type": "html",
            "text": "(The paper does mention proxies several times, reinforcing this idea.)\nThe \"Concept\" side of [[Concept Oriented Programming]] seems to address name-to-object mapping issues addressed by JNDI ([[Java Naming And Directory Interface]]) or the Moniker pattern ([[Micro Soft]] IMoniker interface).",
            "id": "5ccead0a6035da4366f6b2614062cea2"
          },
          {
            "type": "html",
            "text": " <i>I, at least, find coding in a [[Turing Tarpit]] to be unproductive, so I tend to observe related achievements as proof-of-concept, and their use as proof-of-value, rather than arguments against an idea. Admittedly, I'm also not impressed that COP is helping me achieve any [[Non Functional Requirements]], but it irritates me to see 'X could be achieved in Y' as implicit explanation for 'I'm not impressed.' (related: [[Design Patterns Are Missing Language Features]]).</i>",
            "id": "59529dbf0648a12b24eb3beaff91e920"
          },
          {
            "type": "html",
            "text": "\nThe paper describes the use of [[Aspect Oriented Programming]] in [[Object Oriented Programming]] languages to address cross-cutting concerns.",
            "id": "87480dda42ce588d0dc99b2bd72ad316"
          },
          {
            "type": "html",
            "text": "\nI wonder what [[Concept Oriented Programming]] may offer above and beyond the above.",
            "id": "df467d134f3b5b6227eabfb891297c70"
          },
          {
            "type": "html",
            "text": "\nObservations about the paper:",
            "id": "a72a1ad2ffb087ad78946cd1d092403a"
          },
          {
            "type": "html",
            "text": " They completely confuse inheritance with containment.  See \"Figure 4\":  They're criticizing the limitations of using inheritance when containment should have been used.",
            "id": "428504d2b78ac7bc63a4f71409e9af08"
          },
          {
            "type": "html",
            "text": " They don't understand that AOP Advice is defined independently of point cuts.",
            "id": "bfbb0eeab1f409acfd90ad2529eae40d"
          },
          {
            "type": "html",
            "text": " COP seems particularly weak, in comparison to AOP, with regard to mixing in multiple cross-cutting concerns in a single class, or distributing a single cross-cutting concern across multiple concept hierarchies.  COP seems to suffer from a \"single inheritance hierarchy\" problem when one needs to do cross-cutting concern mixins.",
            "id": "67bd50806990767c5f721ed610f5f863"
          },
          {
            "type": "html",
            "text": " They assume that ALL object instances are persisted and shared between processes.  This may be good for database and remote system access, but doesn't seem to address local code and data organization.",
            "id": "f80bef7e941e8543d6946f31123893a9"
          },
          {
            "type": "html",
            "text": " VERY strong hierarchical relationships are assumed, and these are baked into the design early.  This could suffer from similar problems that plagued [[Hierarchical Database]]s. (see [[Limits Of Hierarchies]])",
            "id": "d4948a737d7a3d6775dad250be5ccd9d"
          },
          {
            "type": "html",
            "text": " Objects are loaded and saved at every method access.  I see no provision for transactions that span multiple method calls.  This could be <b>really bad</b> for most business applications.",
            "id": "c27894f6ff2e510b18843820230be162"
          },
          {
            "type": "html",
            "text": " Their analogies are strained.  And not necessarily applicable to software development in general.",
            "id": "8549b49cbf17763ae2148fc451b7a503"
          },
          {
            "type": "html",
            "text": "\nHmmm...\nYou know, it's gonna be kinda hard to do much [[Concept Oriented Programming]] for a while because",
            "id": "48e2666aeb93c1c6ec5f37cbdea9b134"
          },
          {
            "type": "code",
            "text": " '''''\"Currently there are no concept-oriented programming languages\"'''''",
            "id": "449b138d27a87d3f73b233e34333cb89"
          },
          {
            "type": "html",
            "text": "as stated by the paper's author at [http://conceptoriented.org/forums/viewtopic.php?f=3&t=6#p8 conceptoriented.org]",
            "id": "93da17165fb7951c4fd00e452a95921e"
          },
          {
            "type": "html",
            "text": "-- [[Jeff Grigg]]",
            "id": "5c69177938a12e01c601f412dcd2a6a0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "\nI have found the following in the Conclusions of the introductory paper, [http://conceptoriented.org/papers/CopInformalIntroduction.html conceptoriented.org]<b></b>:",
            "id": "2f23504d25354a2fb0df64b4ed1faf72"
          },
          {
            "type": "html",
            "text": "The solution based on concepts could be informally compared with the introduction of complex numbers in mathematics which also have two constituents: real part and imaginary part. As a result of such mathematical generalization formulas and manipulations get much simpler and more natural in comparison with the conventional real numbers. The same effect is achieved in programming by introducing concepts instead of classes: programs get much simpler and their logic is expressed more naturally and elegantly when we manipulate pairs of references (imaginary part) and objects (real part).",
            "id": "c59dc19e1b5a061c9c1613ec10513d7d"
          },
          {
            "type": "html",
            "text": "\nThat seems to me to give some insight into the thinking of the author, [[Alexandr Savinov]], who is the only author he references. It also gives a clue as to how to implement the ideas, using a tuple object in e.g. [[Cee Plus Plus]] to as a basis. -- [[John Fletcher]]",
            "id": "b4b11d5d5c39aec272d668b5dea668a1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "\nI could implement this as a Java code generator, using Java [[Dynamic Proxy]]s to implement the reversed method overriding conventions of concept references.",
            "id": "1567e62c912dd17b0f5b28729ab848b6"
          },
          {
            "type": "html",
            "text": "(Would need an additional proxy for each level of parent reference calling to a 'sub' reference level, but that wouldn't be hard.)",
            "id": "cd34b9aeb238053d2f623754d0c9c0c9"
          },
          {
            "type": "html",
            "text": "\nI do hit a stumbling block where references use the 'object' keyword to call their object instances:\nThis seems to assume that the object for each reference is in memory, as the reference isn't implementing code, like serialization and deserialization, or creating objects from database data.\nSo this seems to imply to me that concept references could lookup their objects, using their concept identifiers, right when the references are created.",
            "id": "c4f2ab07fc6ace60ed197678287aa3fd"
          },
          {
            "type": "html",
            "text": "(IE: in a reference \"constructor\" method.)",
            "id": "e4f83abea2c1464911033610297ef787"
          },
          {
            "type": "html",
            "text": "\nThis makes me think that [[Concept Oriented Programming]] is <b>not</b> as general as claimed, as it would need some as yet unspecified way for reference definitions to explicitly define how one transforms reference keys to object instances.\nThat is, is needs something more than just an \"object.\" keyword.",
            "id": "fba2a39e093d1ab64c56eb9264fb787e"
          },
          {
            "type": "html",
            "text": "-- [[Jeff Grigg]]",
            "id": "5c69177938a12e01c601f412dcd2a6a0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "\n[[Concept Oriented Programming]] formalizes spaces by formalizing object-identity and capturing messaging automatically by having the outer-space serve [[Proxy Objects]] for the objects (or 'concepts') held within. I believe that formalizing the concept of 'spaces' is a fine idea. It allows for useful features to be developed, such as local optimizations while still integrating with global distribution, the ability to provide [[Container Managed Persistence]] at the level of 'spaces', a natural unit of runtime modularity (as opposed to source modularity), allowance for [[Hot Swap]]ping code in a given space by delaying events at space borders, support for code-chunking and distribution, and elimination of <b>global</b> variables in the 'global' sense while still allowing globals to be local to a parent space.",
            "id": "46e01081f8c792722496c3f5747b25e7"
          },
          {
            "type": "html",
            "text": "\nThat said, it is my impression that [[Concept Oriented Programming]] is an unnecessarily complicated approach to achieving these goals. It looks to me that each <b>concept</b>, such as <b>Button</b>, is being specialized based on its location (e.g. <b>Button in a Panel</b>, <b>Button on a Train</b>, <b>Button in the Rain</b>, <b>Button on Green Eggs and Ham</b>) in addition to having the normal [[Object Oriented]] specialization in its properties (e.g. <b>[[Radio Button]]</b>, <b>E</b><b>ggButton</b>, <b>H</b><b>amButton</b>). This implies an enormous specialization burden on the programmers. If we had asynchronous [[Message Passing]] between objects, would we further specialize concepts as <b>[[Red Button]] in a Panel on a [[Message Queue]]</b>?",
            "id": "6ebf5ae197f5c9056f3732838da46ce2"
          },
          {
            "type": "html",
            "text": "\nI would prefer approaches to managing spaces that allows programmers of a component to be ignorant of the space in which that component shall reside. In designs I've been working with, doing so requires that 'objects' (or 'actors' in my case) be constructed with references to 'resources' available in their local environment, and that the environment or locality provide these resources. Usefully, in addition to the normal benefits of controlling interaction with environment, this provides a mechanism for mobile code (a mobile code chunk is an abstract unit of code that needs a set of local resources in order to run) and supports coordination languages for actor/process configurations and [[Dataflow Programming]]. ",
            "id": "4bc22821791cc11c59edcec4fba8181a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "A particularly well built group of [[Endeme Set]]s could be used to wrap data in a [[Universal Identification]] using the potential of [[En Deme]]s and [[Endeme Path]]s to wrap data. This would meet the requirements of 'concepts' as described. However I have not figured out to do this yet.",
            "id": "f1edd4d9a8cd277edb53a7cf57d6cdde"
          },
          {
            "type": "html",
            "text": "-- [[Jon Grover]]",
            "id": "7f7a615c9a7cda14fb94326ed40f3d14"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "[[January Zero Nine]]",
            "id": "9355c3e745c9bf3369b7d61a0594177e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dadd341fea658db2a7e5bd8f4eb3e5f2"
          },
          {
            "type": "html",
            "text": "[[Category Information Orientation]]",
            "id": "b4bdb466ee85621e958447bfe3554abf"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ConceptOrientedProgramming c2.com]",
            "id": "031f54e76e4db76db4186cd50cd62c18"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1707907594007
    }
  ]
}