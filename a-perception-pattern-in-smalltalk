{
  "title": "A Perception Pattern in Smalltalk",
  "story": [
    {
      "type": "paragraph",
      "id": "9ab34900f1de59da",
      "text": "Once again, here we are facing the often dreaded situation. We know enough of what we want to tell if an implementation suits our requirements, but we have not written a single line of code yet. What do we do first? At this critical point, it will be most valuable to assess what could be the benefit of each of the actions available to us."
    },
    {
      "type": "paragraph",
      "id": "4534c588b6699602",
      "text": "There is a school of thought that says the first thing one should do is to write code and, um, see what happens. It seems quite optimistic, does it not? You just pound some code into existence, perhaps play with it a bit (whatever that means), and by magic you arrive at the desired result. Well, it may be just fine to proceed as such, but I contend that this approach is best only when our predictions are awful because our hands are not calibrated yet. In other words, this is most helpful when our information space is so removed from reality that regardless of what we think will be the theoretical effect of us doing something, in practice we cannot match the prediction of our theories to actual observed phenomena. In these situations, we can use this technique to get our bearings right quickly. Indeed, we have heavily used a similar approach to find good selectors in previous chapters. However, in this situation, we already know our problem to a fine enough degree of detail. As such, we choose to not write a single line of code."
    },
    {
      "type": "paragraph",
      "id": "09a68bdd1846e237",
      "text": "Well, you say, that surely cannot last for long. True enough. But what is important is what we will do before writing a single line of code, and why we will deliberately wait before typing in definitions for classes, messages and methods."
    },
    {
      "type": "paragraph",
      "id": "0aae866ff3bb7ca2",
      "text": "Our activity at this point will be to collect the objects we have distinguished, and to compare them looking for similarities at different levels of resolution. If possible, we should find an abstraction under which some of them are more or less the same. This is because doing so will make it easier to organize the implementation of our program. In addition to that, we will pretend the objects exist and that we debug a typical use case in our minds. The idea here is to see how these objects talk to each other. Conversations should be short and concise, without unnecessary chatter or roundabout communication traffic. We have seen good examples of a clean messaging patterns in this book already — for example, the [[Reference Finder]] we implemented is extremely quick not because it is hacked together, but rather because the objects involved do not talk more than they need to."
    },
    {
      "type": "paragraph",
      "id": "bda931df2e811697",
      "text": "So that is what we will do before we write code. The reasons for this are so important that it is impossible to overstate how critical they are. What would happen if we wrote code without having a good estimate of what the effect will be? Then, of course, we would have to change it. And here we must stop and take a hard look at what is going on. First, we do not know what we want to do because we cannot predict the effect of our actions, but we know enough of our problem that we should be able to predict with enough quality. In other words, we did not spend time evaluating the consequences of our actions when doing so could have provided value."
    },
    {
      "type": "paragraph",
      "id": "a70b5c0717b4c904",
      "text": "That, on its own, sounds less than optimum already. But there is more. Let’s say that we go through a feedback cycle and change the code so it is better. And how do we actually accomplish the change? Well, because we are observers living in our environment, we do that by crossing our first distinction, right? What we need to look at here is the huge cost of crossing our first distinction too frequently. If we use our hands to type, then we are not thinking about our problem — we are just emptying our outbound queue of actions to execute in our environment. And it so happens to be that typing is not something we do extraordinarily fast. Try this experiment: think about a problem, but type every single thought process you go through. Do this for ten minutes. How painful is that? If you talk instead of writing then it may not be as bad, but it is still very slow compared to the real thing, is it not?"
    },
    {
      "type": "paragraph",
      "id": "4efde8cb9b1e5aae",
      "text": "Therefore, to profusely type in order to describe frequent changes to computer programs is clearly tantamount to having an extremely low overall performance as developers. This is because the capabilities of our outbound interface with the environment are not those of an ethernet connection. They are more like those of a 300 baud modem without built in error correction. Thus, we should send data through this interface sparingly, reserving our precious CPU cycles to come up with a design that not only solves our problem but also minimizes the need to put traffic through such a constrained communication channel. What is more, we should further tweak our design so that it allows anybody else to make efficient use of their outbound connections as well."
    },
    {
      "type": "markdown",
      "id": "04787724005d5076",
      "text": "> Therefore, the productivity of a developer should never be measured in terms of how much code is typed."
    },
    {
      "type": "paragraph",
      "id": "01471fda1382798f",
      "text": "As you can see, the problem of how to implement programs efficiently in a computer language is very similar to a register allocation exercise in which we run the fastest when most of the information stays close to our [[7 ± 2]] scratch RAM slots. In this context, typing a lot is like thrashing the page file. We must learn to avoid this at all costs. If we do not, were somebody to run a time profiler on our development process would find that we spend 50% or more of the time in IO wait. Is that the mark of efficiency now?"
    },
    {
      "type": "paragraph",
      "id": "2570f1a62efcb1ae",
      "text": "So, given these constraints, how do we become really good at efficiently using our capillary wide outbound communication pipe? First, by training ourselves to withhold the emission of code until enough design iterations in our mind find code that remains stable over time. Then, and only then, we should implement the pieces that have become really close to their attractor. The more we practice this skill, the more benefit we will obtain from it. We can also improve our efficiency as developers by choosing a computer language that requires us to type a minimum of syntax sugar and comply with the least possible process rituals. Smalltalk ranks very well in these regards, and this is why it is such a valuable vehicle for human expression."
    },
    {
      "type": "paragraph",
      "id": "31af99c5cc126f0b",
      "text": "Given these considerations, let’s go through a round of training by looking at all the objects we have identified in the pattern of perception we have been talking about, and see if we can find similarities."
    },
    {
      "type": "paragraph",
      "id": "0eb388c28eba1be0",
      "text": "To make our discussion easier, let’s adopt the following convention first. As you have seen, we have been referring to the [[pattern of perception]] as the pattern we have been discussing, or the pattern we thought about, and so on. This is because we should be keenly aware that, as much as it may seem like a correct approach, the product of our work is just our interpretation and as such it is extremely likely to be correct only up to a certain point. However, to qualify the pattern we have been describing all the time causes us to incur in needless repetition. Thus, from now on, we will not explicitly mention the fact that we keep in mind that the pattern of perception discussed so far is just an arbitrary way to describe something we perceived."
    },
    {
      "type": "paragraph",
      "id": "309d2acd6aab7277",
      "text": "⇒ [[Characterization of the Parts]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "A Perception Pattern in Smalltalk",
        "story": []
      },
      "date": 1660924996716
    },
    {
      "item": {
        "type": "factory",
        "id": "9ab34900f1de59da"
      },
      "id": "9ab34900f1de59da",
      "type": "add",
      "date": 1660925002678
    },
    {
      "type": "edit",
      "id": "9ab34900f1de59da",
      "item": {
        "type": "paragraph",
        "id": "9ab34900f1de59da",
        "text": "Once again, here we are facing the often dreaded situation. We know enough of what we want to tell if an implementation suits our requirements, but we have not written a single line of code yet. What do we do first? At this critical point, it will be most valuable to assess what could be the benefit of each of the actions available to us."
      },
      "date": 1660925004960
    },
    {
      "type": "add",
      "id": "309d2acd6aab7277",
      "item": {
        "type": "paragraph",
        "id": "309d2acd6aab7277",
        "text": "[…]"
      },
      "after": "9ab34900f1de59da",
      "date": 1660925006901
    },
    {
      "item": {
        "type": "factory",
        "id": "4534c588b6699602"
      },
      "id": "4534c588b6699602",
      "type": "add",
      "after": "309d2acd6aab7277",
      "date": 1660925019956
    },
    {
      "id": "4534c588b6699602",
      "type": "move",
      "order": [
        "9ab34900f1de59da",
        "4534c588b6699602",
        "309d2acd6aab7277"
      ],
      "date": 1660925021849
    },
    {
      "type": "edit",
      "id": "4534c588b6699602",
      "item": {
        "type": "paragraph",
        "id": "4534c588b6699602",
        "text": "There is a school of thought that says the first thing one should do is to write code and, um, see what happens. It seems quite optimistic, does it not? You just pound some code into existence, perhaps play with it a bit (whatever that means), and by magic you arrive at the desired result. Well, it may be just fine to proceed as such, but I contend that this approach is best only when our predictions are awful because our hands are not calibrated yet. In other words, this is most helpful when our information space is so removed from reality that regardless of what we think will be the theoretical effect of us doing something, in practice we cannot match the prediction of our theories to actual observed phenomena. In these situations, we can use this technique to get our bearings right quickly. Indeed, we have heavily used a similar approach to find good selectors in previous chapters. However, in this situation, we already know our problem to a fine enough degree of detail. As such, we choose to not write a single line of code."
      },
      "date": 1660925023603
    },
    {
      "type": "add",
      "id": "09a68bdd1846e237",
      "item": {
        "type": "paragraph",
        "id": "09a68bdd1846e237",
        "text": "Well, you say, that surely cannot last for long. True enough. But what is important is what we will do before writing a single line of code, and why we will deliberately wait before typing in definitions for classes, messages and methods."
      },
      "after": "4534c588b6699602",
      "date": 1660925077479
    },
    {
      "type": "add",
      "id": "0aae866ff3bb7ca2",
      "item": {
        "type": "paragraph",
        "id": "0aae866ff3bb7ca2",
        "text": "Our activity at this point will be to collect the objects we have distinguished, and to compare them looking for similarities at different levels of resolution. If possible, we should find an abstraction under which some of them are more or less the same. This is because doing so will make it easier to organize the implementation of our program. In addition to that, we will pretend the objects exist and that we debug a typical use case in our minds. The idea here is to see how these objects talk to each other. Conversations should be short and concise, without unnecessary chatter or roundabout communication traffic. We have seen good examples of a clean messaging patterns in this book already — for example, the reference finder we implemented is extremely quick not because it is hacked together, but rather because the objects involved do not talk more than they need to."
      },
      "after": "09a68bdd1846e237",
      "date": 1660925090791
    },
    {
      "type": "add",
      "id": "bda931df2e811697",
      "item": {
        "type": "paragraph",
        "id": "bda931df2e811697",
        "text": "So that is what we will do before we write code. The reasons for this are so important that it is impossible to overstate how critical they are. What would happen if we wrote code without having a good estimate of what the effect will"
      },
      "after": "0aae866ff3bb7ca2",
      "date": 1660925140586
    },
    {
      "type": "edit",
      "id": "0aae866ff3bb7ca2",
      "item": {
        "type": "paragraph",
        "id": "0aae866ff3bb7ca2",
        "text": "Our activity at this point will be to collect the objects we have distinguished, and to compare them looking for similarities at different levels of resolution. If possible, we should find an abstraction under which some of them are more or less the same. This is because doing so will make it easier to organize the implementation of our program. In addition to that, we will pretend the objects exist and that we debug a typical use case in our minds. The idea here is to see how these objects talk to each other. Conversations should be short and concise, without unnecessary chatter or roundabout communication traffic. We have seen good examples of a clean messaging patterns in this book already — for example, the [[reference finder]] we implemented is extremely quick not because it is hacked together, but rather because the objects involved do not talk more than they need to."
      },
      "date": 1660925150369
    },
    {
      "type": "edit",
      "id": "0aae866ff3bb7ca2",
      "item": {
        "type": "paragraph",
        "id": "0aae866ff3bb7ca2",
        "text": "Our activity at this point will be to collect the objects we have distinguished, and to compare them looking for similarities at different levels of resolution. If possible, we should find an abstraction under which some of them are more or less the same. This is because doing so will make it easier to organize the implementation of our program. In addition to that, we will pretend the objects exist and that we debug a typical use case in our minds. The idea here is to see how these objects talk to each other. Conversations should be short and concise, without unnecessary chatter or roundabout communication traffic. We have seen good examples of a clean messaging patterns in this book already — for example, the [[Reference Finder]] we implemented is extremely quick not because it is hacked together, but rather because the objects involved do not talk more than they need to."
      },
      "date": 1660925199928
    },
    {
      "type": "edit",
      "id": "bda931df2e811697",
      "item": {
        "type": "paragraph",
        "id": "bda931df2e811697",
        "text": "So that is what we will do before we write code. The reasons for this are so important that it is impossible to overstate how critical they are. What would happen if we wrote code without having a good estimate of what the effect will be? Then, of course, we would have to change it. And here we must stop and take a hard look at what is going on. First, we do not know what we want to do because we cannot predict the effect of our actions, but we know enough of our problem that we should be able to predict with enough quality. In other words, we did not spend time evaluating the consequences of our actions when doing so could have provided value."
      },
      "date": 1660925271784
    },
    {
      "type": "add",
      "id": "a70b5c0717b4c904",
      "item": {
        "type": "paragraph",
        "id": "a70b5c0717b4c904",
        "text": "That, on its own, sounds less than optimum already. But there is more. Let’s say that we go through a feedback cycle and change the code so it is better. And how do we actually accomplish the change? Well, because we are observers living in our environment, we do that by crossing our first distinction, right? What we need to look at here is the huge cost of crossing our first distinction too frequently. If we use our hands to type, then we are not thinking about our problem — we are just emptying our outbound queue of actions to execute in our environment. And it so happens to be that typing is not something we do extraordinarily fast. Try this experiment: think about a problem, but type every single thought process you go through. Do this for ten minutes. How painful is that? If you talk instead of writing then it may not be as bad, but it is still very slow compared to the real thing, is it not?"
      },
      "after": "bda931df2e811697",
      "date": 1660925297371
    },
    {
      "type": "add",
      "id": "4efde8cb9b1e5aae",
      "item": {
        "type": "paragraph",
        "id": "4efde8cb9b1e5aae",
        "text": "Therefore, to profusely type in order to describe frequent changes to computer programs is clearly tantamount to having an extremely low overall performance as developers. This is because the capabilities of our outbound interface with the environment are not those of an ethernet connection. They are more like those of a 300 baud modem without built in error correction. Thus, we should send data through this interface sparingly, reserving our precious CPU cycles to come up with a design that not only solves our problem but also minimizes the need to put traffic through such a constrained communication channel. What is more, we should further tweak our design so that it allows anybody else to make efficient use of their outbound connections as well."
      },
      "after": "a70b5c0717b4c904",
      "date": 1660925386469
    },
    {
      "type": "add",
      "id": "04787724005d5076",
      "item": {
        "type": "paragraph",
        "id": "04787724005d5076",
        "text": "> Therefore, the productivity of a developer should never be measured in terms of how much code is typed."
      },
      "after": "4efde8cb9b1e5aae",
      "date": 1660925427099
    },
    {
      "type": "edit",
      "id": "04787724005d5076",
      "item": {
        "type": "markdown",
        "id": "04787724005d5076",
        "text": "> Therefore, the productivity of a developer should never be measured in terms of how much code is typed."
      },
      "date": 1660925429201
    },
    {
      "item": {
        "type": "factory",
        "id": "01471fda1382798f"
      },
      "id": "01471fda1382798f",
      "type": "add",
      "after": "309d2acd6aab7277",
      "date": 1660925440172
    },
    {
      "id": "01471fda1382798f",
      "type": "move",
      "order": [
        "9ab34900f1de59da",
        "4534c588b6699602",
        "09a68bdd1846e237",
        "0aae866ff3bb7ca2",
        "bda931df2e811697",
        "a70b5c0717b4c904",
        "4efde8cb9b1e5aae",
        "04787724005d5076",
        "01471fda1382798f",
        "309d2acd6aab7277"
      ],
      "date": 1660925444247
    },
    {
      "type": "edit",
      "id": "01471fda1382798f",
      "item": {
        "type": "paragraph",
        "id": "01471fda1382798f",
        "text": "As you can see, the problem of how to implement programs efficiently in a"
      },
      "date": 1660925447124
    },
    {
      "type": "edit",
      "id": "01471fda1382798f",
      "item": {
        "type": "paragraph",
        "id": "01471fda1382798f",
        "text": "As you can see, the problem of how to implement programs efficiently in a computer language is very similar to a register allocation exercise in which we run the fastest when most of the information stays close to our 7 ± 2 scratch RAM slots. In this context, typing a lot is like thrashing the page file. We must learn to avoid this at all costs. If we do not, were somebody to run a time profiler on our development process would find that we spend 50% or more of the time in IO wait. Is that the mark of efficiency now?"
      },
      "date": 1660925457261
    },
    {
      "type": "edit",
      "id": "01471fda1382798f",
      "item": {
        "type": "paragraph",
        "id": "01471fda1382798f",
        "text": "As you can see, the problem of how to implement programs efficiently in a computer language is very similar to a register allocation exercise in which we run the fastest when most of the information stays close to our [[7 ± 2]] scratch RAM slots. In this context, typing a lot is like thrashing the page file. We must learn to avoid this at all costs. If we do not, were somebody to run a time profiler on our development process would find that we spend 50% or more of the time in IO wait. Is that the mark of efficiency now?"
      },
      "date": 1660925472353
    },
    {
      "type": "add",
      "id": "2570f1a62efcb1ae",
      "item": {
        "type": "paragraph",
        "id": "2570f1a62efcb1ae",
        "text": "So, given these constraints, how do we become really good at efficiently using our capillary wide outbound communication pipe? First, by training ourselves to withhold the emission of code until enough design iterations in our mind find code"
      },
      "after": "01471fda1382798f",
      "date": 1660925502449
    },
    {
      "type": "edit",
      "id": "2570f1a62efcb1ae",
      "item": {
        "type": "paragraph",
        "id": "2570f1a62efcb1ae",
        "text": "So, given these constraints, how do we become really good at efficiently using our capillary wide outbound communication pipe? First, by training ourselves to withhold the emission of code until enough design iterations in our mind find code that remains stable over time. Then, and only then, we should implement the pieces that have become really close to their attractor. The more we practice this skill, the more benefit we will obtain from it. We can also improve our efficiency as developers by choosing a computer language that requires us to type a minimum of syntax sugar and comply with the least possible process rituals. Smalltalk ranks very well in these regards, and this is why it is such a valuable vehicle for human expression."
      },
      "date": 1660925524094
    },
    {
      "type": "add",
      "id": "31af99c5cc126f0b",
      "item": {
        "type": "paragraph",
        "id": "31af99c5cc126f0b",
        "text": "Given these considerations, let’s go through a round of training by looking at all the objects we have identified in the pattern of perception we have been talking about, and see if we can find similarities."
      },
      "after": "2570f1a62efcb1ae",
      "date": 1660925567465
    },
    {
      "type": "add",
      "id": "0eb388c28eba1be0",
      "item": {
        "type": "paragraph",
        "id": "0eb388c28eba1be0",
        "text": "To make our discussion easier, let’s adopt the following convention first. As you have seen, we have been referring to the pattern of perception as the pattern we have been discussing, or the pattern we thought about, and so on. This is because we should be keenly aware that, as much as it may seem like a correct approach, the product of our work is just our interpretation and as such it is extremely likely to be correct only up to a certain point. However, to qualify the pattern we have been describing all the time causes us to incur in needless repetition. Thus, from now on, we will not explicitly mention the fact that we keep in mind that the pattern of perception discussed so far is just an arbitrary way to describe something we perceived."
      },
      "after": "31af99c5cc126f0b",
      "date": 1660925600209
    },
    {
      "type": "edit",
      "id": "0eb388c28eba1be0",
      "item": {
        "type": "paragraph",
        "id": "0eb388c28eba1be0",
        "text": "To make our discussion easier, let’s adopt the following convention first. As you have seen, we have been referring to the [[pattern of perception]] as the pattern we have been discussing, or the pattern we thought about, and so on. This is because we should be keenly aware that, as much as it may seem like a correct approach, the product of our work is just our interpretation and as such it is extremely likely to be correct only up to a certain point. However, to qualify the pattern we have been describing all the time causes us to incur in needless repetition. Thus, from now on, we will not explicitly mention the fact that we keep in mind that the pattern of perception discussed so far is just an arbitrary way to describe something we perceived."
      },
      "date": 1660925623713
    },
    {
      "type": "fork",
      "date": 1660925671383
    },
    {
      "type": "edit",
      "id": "309d2acd6aab7277",
      "item": {
        "type": "paragraph",
        "id": "309d2acd6aab7277",
        "text": "[[Characterization of the Parts]]"
      },
      "date": 1660925729920
    },
    {
      "type": "edit",
      "id": "309d2acd6aab7277",
      "item": {
        "type": "paragraph",
        "id": "309d2acd6aab7277",
        "text": "⇒ [[Characterization of the Parts]]"
      },
      "date": 1660925744264
    }
  ]
}