{
  "title": "Smalltalk Blocks And Closures",
  "story": [
    {
      "type": "paragraph",
      "id": "64498be437050644",
      "text": "[https://wiki.c2.com/?SmalltalkBlocksAndClosures wiki.c2]"
    },
    {
      "type": "paragraph",
      "id": "a88dc05ae2bfb998",
      "text": "A Smalltalk Block is an object. That object is an instance of Block (or a similarly-named class). If the block has no parameters, as in [fred+ethel], it responds to the message #value, and that message answers, in this case, the value of the sum of fred and ethel. Those variables are bound to whatever they were bound to when the block was created. "
    },
    {
      "type": "paragraph",
      "id": "c2116b6872571df0",
      "text": "Suppose a class Lucy, with instance variables fred and ethel. The class includes a method #getBlock: "
    },
    {
      "type": "code",
      "id": "72fc0988122f7a70",
      "text": "Lucy>>getBlock\n\t^[fred + ethel]"
    },
    {
      "type": "paragraph",
      "id": "ca2a5ea6ccd1e609",
      "text": "and creation methods "
    },
    {
      "type": "code",
      "id": "a5d0b851820e2985",
      "text": "Lucy class>>fred: fredInteger ethel: ethelInteger\n\t^self new setFred: fredInteger ethel: ethelInteger\n\n"
    },
    {
      "type": "code",
      "id": "2d9e8b931194bef5",
      "text": "Lucy>>setFred: fredInteger ethel: ethelInteger\n\tfred := fredInteger.\n\tethel := ethelInteger."
    },
    {
      "type": "paragraph",
      "id": "becff43d20beca60",
      "text": "We do the following code: "
    },
    {
      "type": "code",
      "id": "01b29d54e6507a62",
      "text": "lucy := Lucy fred: 10 ethel: 15\nblock := lucy getBlock.\nval := block value."
    },
    {
      "type": "paragraph",
      "id": "26e8c4a2517a21c6",
      "text": "val will contain 25. We can hold on to that block as long as we want, send it value whenever we want. The block is bound to the instance variables of the lucy object we created. If we sent lucy messages changing its variables, then the next send of value would get the new answer: "
    },
    {
      "type": "code",
      "id": "62c1ebdc11de6ad2",
      "text": "lucy setFred: 1 ethel: 1.\nnewVal := block value."
    },
    {
      "type": "paragraph",
      "id": "d6b812fabb189983",
      "text": "newVal will be 2."
    },
    {
      "type": "paragraph",
      "id": "88c2ee2b2fb369c7",
      "text": "So, as I understand closures in the Lisp sense, a Smalltalk block is in fact a closure bound to the variables in effect at the time of creation. Holding on to the block can hold on to the object in question.\n\nIt is generally considered very poor programming style to pass blocks around and hold on to them for extended periods. It's an artifact of the language design that blocks are used for conditionals, but these are generally ephemeral and not held on to for ages.\n\nOther Smalltalk wizards: the above is off the cuff. Replace or improve it as you will.\n\n-- [[Ron Jeffries]]"
    },
    {
      "type": "paragraph",
      "id": "d1bfeb1456a6eb4f",
      "text": "The phrase \"closure\" came from the functional programming language community. If you really want to understand closures, read StructureAndInterpretationOfComputerPrograms, one of the great books of computer science. "
    },
    {
      "type": "paragraph",
      "id": "e9a297cb7eea2115",
      "text": "⇒ [[Structure And Interpretation Of Computer Programs]]"
    }
  ],
  "journal": [
    {
      "type": "add",
      "id": "e9a297cb7eea2115",
      "item": {
        "type": "paragraph",
        "id": "e9a297cb7eea2115",
        "text": "[[Structure And Interpretation Of Computer Programs]]"
      },
      "after": "d1bfeb1456a6eb4f",
      "date": 1654035521859,
      "error": {
        "type": "error",
        "msg": ""
      }
    },
    {
      "type": "edit",
      "id": "d1bfeb1456a6eb4f",
      "item": {
        "type": "paragraph",
        "id": "d1bfeb1456a6eb4f",
        "text": "The phrase \"closure\" came from the functional programming language community. If you really want to understand closures, read StructureAndInterpretationOfComputerPrograms, one of the great books of computer science. "
      },
      "date": 1654035489746
    },
    {
      "item": {
        "type": "paragraph",
        "id": "d1bfeb1456a6eb4f",
        "text": "The phrase \"closure\" came from the functional programming language community. If you really want to understand closures, read StructureAndInterpretationOfComputerPrograms, one of the great books of computer science. "
      },
      "id": "d1bfeb1456a6eb4f",
      "type": "add",
      "after": "88c2ee2b2fb369c7",
      "date": 1654035488231
    },
    {
      "type": "edit",
      "id": "88c2ee2b2fb369c7",
      "item": {
        "type": "paragraph",
        "id": "88c2ee2b2fb369c7",
        "text": "So, as I understand closures in the Lisp sense, a Smalltalk block is in fact a closure bound to the variables in effect at the time of creation. Holding on to the block can hold on to the object in question.\n\nIt is generally considered very poor programming style to pass blocks around and hold on to them for extended periods. It's an artifact of the language design that blocks are used for conditionals, but these are generally ephemeral and not held on to for ages.\n\nOther Smalltalk wizards: the above is off the cuff. Replace or improve it as you will.\n\n-- [[Ron Jeffries]]"
      },
      "date": 1654035419658
    },
    {
      "type": "create",
      "item": {
        "title": "Smalltalk Blocks And Closures",
        "story": []
      },
      "date": 1640446581014
    },
    {
      "item": {
        "type": "factory",
        "id": "64498be437050644"
      },
      "id": "64498be437050644",
      "type": "add",
      "date": 1640446601772
    },
    {
      "type": "edit",
      "id": "64498be437050644",
      "item": {
        "type": "paragraph",
        "id": "64498be437050644",
        "text": "[https://wiki.c2.com/?SmalltalkBlocksAndClosures wiki.c2]"
      },
      "date": 1640446617393
    },
    {
      "item": {
        "type": "factory",
        "id": "a88dc05ae2bfb998"
      },
      "id": "a88dc05ae2bfb998",
      "type": "add",
      "after": "64498be437050644",
      "date": 1654035021198
    },
    {
      "type": "edit",
      "id": "a88dc05ae2bfb998",
      "item": {
        "type": "paragraph",
        "id": "a88dc05ae2bfb998",
        "text": "A Smalltalk Block is an object. That object is an instance of Block (or a similarly-named class). If the block has no parameters, as in [fred+ethel], it responds to the message #value, and that message answers, in this case, the value of the sum of fred and ethel. Those variables are bound to whatever they were bound to when the block was created. "
      },
      "date": 1654035022600
    },
    {
      "item": {
        "type": "paragraph",
        "id": "c2116b6872571df0",
        "text": "Suppose a class Lucy, with instance variables fred and ethel. The class includes a method #getBlock: "
      },
      "id": "c2116b6872571df0",
      "type": "add",
      "after": "a88dc05ae2bfb998",
      "date": 1654035256495
    },
    {
      "type": "edit",
      "id": "c2116b6872571df0",
      "item": {
        "type": "paragraph",
        "id": "c2116b6872571df0",
        "text": "Suppose a class Lucy, with instance variables fred and ethel. The class includes a method #getBlock: "
      },
      "date": 1654035258966
    },
    {
      "item": {
        "type": "code",
        "id": "72fc0988122f7a70",
        "text": "Lucy>>getBlock\n\t^[fred + ethel]"
      },
      "id": "72fc0988122f7a70",
      "type": "add",
      "after": "c2116b6872571df0",
      "date": 1654035265310
    },
    {
      "type": "edit",
      "id": "72fc0988122f7a70",
      "item": {
        "type": "code",
        "id": "72fc0988122f7a70",
        "text": "Lucy>>getBlock\n\t^[fred + ethel]"
      },
      "date": 1654035268041
    },
    {
      "item": {
        "type": "paragraph",
        "id": "ca2a5ea6ccd1e609",
        "text": "and creation methods "
      },
      "id": "ca2a5ea6ccd1e609",
      "type": "add",
      "after": "72fc0988122f7a70",
      "date": 1654035299081
    },
    {
      "type": "edit",
      "id": "ca2a5ea6ccd1e609",
      "item": {
        "type": "paragraph",
        "id": "ca2a5ea6ccd1e609",
        "text": "and creation methods "
      },
      "date": 1654035302035
    },
    {
      "item": {
        "type": "code",
        "id": "a5d0b851820e2985",
        "text": "Lucy class>>fred: fredInteger ethel: ethelInteger\n\t^self new setFred: fredInteger ethel: ethelInteger\n\n"
      },
      "id": "a5d0b851820e2985",
      "type": "add",
      "after": "ca2a5ea6ccd1e609",
      "date": 1654035309986
    },
    {
      "type": "edit",
      "id": "a5d0b851820e2985",
      "item": {
        "type": "code",
        "id": "a5d0b851820e2985",
        "text": "Lucy class>>fred: fredInteger ethel: ethelInteger\n\t^self new setFred: fredInteger ethel: ethelInteger\n\n"
      },
      "date": 1654035313081
    },
    {
      "item": {
        "type": "code",
        "id": "2d9e8b931194bef5",
        "text": "Lucy>>setFred: fredInteger ethel: ethelInteger\n\tfred := fredInteger.\n\tethel := ethelInteger."
      },
      "id": "2d9e8b931194bef5",
      "type": "add",
      "after": "a5d0b851820e2985",
      "date": 1654035319841
    },
    {
      "type": "edit",
      "id": "2d9e8b931194bef5",
      "item": {
        "type": "code",
        "id": "2d9e8b931194bef5",
        "text": "Lucy>>setFred: fredInteger ethel: ethelInteger\n\tfred := fredInteger.\n\tethel := ethelInteger."
      },
      "date": 1654035324268
    },
    {
      "type": "edit",
      "id": "2d9e8b931194bef5",
      "item": {
        "type": "code",
        "id": "2d9e8b931194bef5",
        "text": "Lucy>>setFred: fredInteger ethel: ethelInteger\n\tfred := fredInteger.\n\tethel := ethelInteger."
      },
      "date": 1654035331229
    },
    {
      "item": {
        "type": "paragraph",
        "id": "becff43d20beca60",
        "text": "We do the following code: "
      },
      "id": "becff43d20beca60",
      "type": "add",
      "after": "2d9e8b931194bef5",
      "date": 1654035343680
    },
    {
      "type": "edit",
      "id": "becff43d20beca60",
      "item": {
        "type": "paragraph",
        "id": "becff43d20beca60",
        "text": "We do the following code: "
      },
      "date": 1654035346470
    },
    {
      "item": {
        "type": "code",
        "id": "01b29d54e6507a62",
        "text": "lucy := Lucy fred: 10 ethel: 15\nblock := lucy getBlock.\nval := block value."
      },
      "id": "01b29d54e6507a62",
      "type": "add",
      "after": "becff43d20beca60",
      "date": 1654035353611
    },
    {
      "type": "edit",
      "id": "01b29d54e6507a62",
      "item": {
        "type": "code",
        "id": "01b29d54e6507a62",
        "text": "lucy := Lucy fred: 10 ethel: 15\nblock := lucy getBlock.\nval := block value."
      },
      "date": 1654035359937
    },
    {
      "item": {
        "type": "paragraph",
        "id": "26e8c4a2517a21c6",
        "text": "val will contain 25. We can hold on to that block as long as we want, send it value whenever we want. The block is bound to the instance variables of the lucy object we created. If we sent lucy messages changing its variables, then the next send of value would get the new answer: "
      },
      "id": "26e8c4a2517a21c6",
      "type": "add",
      "after": "01b29d54e6507a62",
      "date": 1654035368845
    },
    {
      "type": "edit",
      "id": "26e8c4a2517a21c6",
      "item": {
        "type": "paragraph",
        "id": "26e8c4a2517a21c6",
        "text": "val will contain 25. We can hold on to that block as long as we want, send it value whenever we want. The block is bound to the instance variables of the lucy object we created. If we sent lucy messages changing its variables, then the next send of value would get the new answer: "
      },
      "date": 1654035370280
    },
    {
      "item": {
        "type": "code",
        "id": "62c1ebdc11de6ad2",
        "text": "lucy setFred: 1 ethel: 1.\nnewVal := block value."
      },
      "id": "62c1ebdc11de6ad2",
      "type": "add",
      "after": "26e8c4a2517a21c6",
      "date": 1654035376204
    },
    {
      "type": "edit",
      "id": "62c1ebdc11de6ad2",
      "item": {
        "type": "code",
        "id": "62c1ebdc11de6ad2",
        "text": "lucy setFred: 1 ethel: 1.\nnewVal := block value."
      },
      "date": 1654035380844
    },
    {
      "item": {
        "type": "paragraph",
        "id": "d6b812fabb189983",
        "text": "newVal will be 2."
      },
      "id": "d6b812fabb189983",
      "type": "add",
      "after": "62c1ebdc11de6ad2",
      "date": 1654035391177
    },
    {
      "type": "edit",
      "id": "d6b812fabb189983",
      "item": {
        "type": "paragraph",
        "id": "d6b812fabb189983",
        "text": "newVal will be 2."
      },
      "date": 1654035392660
    },
    {
      "item": {
        "type": "paragraph",
        "id": "88c2ee2b2fb369c7",
        "text": "So, as I understand closures in the Lisp sense, a Smalltalk block is in fact a closure bound to the variables in effect at the time of creation. Holding on to the block can hold on to the object in question.\n\nIt is generally considered very poor programming style to pass blocks around and hold on to them for extended periods. It's an artifact of the language design that blocks are used for conditionals, but these are generally ephemeral and not held on to for ages.\n\nOther Smalltalk wizards: the above is off the cuff. Replace or improve it as you will.\n\n-- [[Ron Jeffries]]"
      },
      "id": "88c2ee2b2fb369c7",
      "type": "add",
      "after": "d6b812fabb189983",
      "date": 1654035404776
    },
    {
      "type": "edit",
      "id": "88c2ee2b2fb369c7",
      "item": {
        "type": "paragraph",
        "id": "88c2ee2b2fb369c7",
        "text": "So, as I understand closures in the Lisp sense, a Smalltalk block is in fact a closure bound to the variables in effect at the time of creation. Holding on to the block can hold on to the object in question.\n\nIt is generally considered very poor programming style to pass blocks around and hold on to them for extended periods. It's an artifact of the language design that blocks are used for conditionals, but these are generally ephemeral and not held on to for ages.\n\nOther Smalltalk wizards: the above is off the cuff. Replace or improve it as you will.\n\n-- [[Ron Jeffries]]"
      },
      "date": 1654035413790
    },
    {
      "type": "edit",
      "id": "e9a297cb7eea2115",
      "item": {
        "type": "paragraph",
        "id": "e9a297cb7eea2115",
        "text": "⇒ [[Structure And Interpretation Of Computer Programs]]"
      },
      "date": 1654035546372
    },
    {
      "type": "fork",
      "date": 1654035548071
    }
  ]
}