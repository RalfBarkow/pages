{
  "title": "Restricted Programming Language",
  "story": [
    {
      "type": "html",
      "text": "(Inspired by [[Programming Is Not Fun]])",
      "id": "4bd70931e2e6bc1af4089852277697b6"
    },
    {
      "type": "html",
      "text": "\"Restricted programming language\" is my term for a language whose designers omit features because they're \"too complex\" or because some programmers have used them to write bad code.",
      "id": "8cdc7cb794dacde859d87b3ec83d5fa6"
    },
    {
      "type": "html",
      "text": "\n[[Java Language]] is a restricted [[Programming Language]]. The designers chose to omit [[Operator Overloading]] because they felt that overloading made the compiler and code too complex, and because it's possible for programmers to \"abuse\" it by, for example, using += to perform a stack push. [[Cee Sharp]] supports overloaded operators, which will probably make it more popular than Java. (But, to be fair, Java's restrictions aren't <i>that bad,</i> mainly because Java gives you other features in return, such as garbage collection and generics.)",
      "id": "afee804f74a5d9560fd67b9fecf479ae"
    },
    {
      "type": "html",
      "text": "\nI once used a restricted language which was only used in-house by a [[Data Processing]] company. The designers purposely left recursion out, because they were worried about programmers accidentally causing [[Infinite Recursion]]s. All variables were global, because [[Local Variables]] which appear and disappear as the program runs were thought to be over the heads of some of those looking at the program. This led to major headaches when writing code. (By contrast, in my style of [[Forth Language]] programming, all variables are global, and I tend to avoid RECURSE. <i>(Sounds like a job for LOCALS| or a similar Forth construct.)</i> But at least if I accidentally create a new Forth variable with the same name as an old one, it's created separately, so I can't clobber the old one by mistake. [[Hyper Static Global Environment]].)",
      "id": "5546e958001e705ac2c19064e9e30fb0"
    },
    {
      "type": "html",
      "text": "\n[[Cobol Language]] is probably the ultimate restricted language. I say \"probably\" because I've been fortunate enough to be able to avoid COBOL.",
      "id": "98dcb3ad6249ab3c195512aec548719f"
    },
    {
      "type": "html",
      "text": " Not even close. They didn't intend to leave features out, although by the standards of the 21st century there's a lot missing. But back when it was introduced, it was quite powerful. There were things it was better at than [[Fortran Language]], which was the primary alternative for many people, if they had any choice at all.",
      "id": "dfd8744ef478f1061b8ec20fb23453a4"
    },
    {
      "type": "html",
      "text": "\nObviously not every language can have every feature. [[Bjarne Stroustrup]] made the conscious decision to leave serialization out of [[Cee Plus Plus]] because he was afraid it would incur a space overhead on every object, including objects that didn't use serialization. [[Scheme Language]] is deliberately confined to a small number of special forms because the designers want to avoid the \"bloatedness\" of [[Common Lisp]]. (Instead, they added a macro facility so you can define your own special forms. See [[Define Syntax]]. <i>This sounds like Common Lisp has no such macro facilities, which isn't true.</i>) [[Forth Language]] is constrained in various ways so that it can be easy to implement. Nevertheless, these languages are targeted for programmers, and do not deny features to programmers on the ground that programmers, or others looking at the program code, would be too stupid to understand those features. However, this is, I think, the difference between <i>restrictions</i> and mere <i>limitations</i>: limitations are motivated by the nature of the problems that the language designer is trying to solve; restrictions are set out in advance of designing the language, usually in order to prevent programmers from doing things.",
      "id": "81a40f7dd5993d1a06f61ae3433d78f5"
    },
    {
      "type": "html",
      "text": "\nWhen I get saddled with such a [[Programming Language]] I often end up doing what looks like [[Gold Plating]]: my classical [[Computer Science]] education has caused me to see certain problems in terms of recursion or the use of [[Local Variables]], and I can't unsee it, so I find myself doing by hand what I think the language implementation ought to have done. I find myself implementing stacks and storing all my values there. I find myself implementing [[Continuation Passing Style]]. I find myself writing Forth-like code outside of [[Forth Language]]. In [[Java Language]], I find myself copying and pasting code because there are no templates, and using a class and an interface would incur too much overhead [[[Copy And Paste Programming]]]. [[Complexity Has To Go Somewhere]]. The code that gets written is very nearly unmaintainable to other people, <i>unless</i> the maintainer knows or figures out what has been done to produce this contorted code and can follow the process back and forth. Is it too much to hope that some maintainer will have an \"[[Ah Ha]]\" moment with my old code, that suddenly it will become clear to them, and they will start writing all their code like that? I suppose it would be a suitable revenge.",
      "id": "a0c4beca75749a56041742d89602bb4e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "44ab66a6b93359820cb198a3dcc81d91"
    },
    {
      "type": "html",
      "text": "Just to make it clear, it is not a feature of the language or the lack thereof that makes the language \"restricted.\" It's the motivation of the language designers when they chose to include or omit a feature.",
      "id": "58c0e5813942ef5cd41a4f332d773946"
    },
    {
      "type": "html",
      "text": "\nA restricted programming language is any language whose designers thought that <i>programmers would be too stupid</i> to do X, or refrain from doing Y, and that therefore the language should force them to do X and to refrain from doing Y.",
      "id": "9a5085eed32f80b6df8bab07ca8ab12a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "44ab66a6b93359820cb198a3dcc81d91"
    },
    {
      "type": "html",
      "text": "Some people say that what makes a language high-level is what it allows you to do, e.g., higher-level languages allow you to represent more abstract concepts directly in the code.",
      "id": "1623a194b82ae047e66fe815d54e3d72"
    },
    {
      "type": "html",
      "text": "\nOther people say that what makes a language high-level is what it prohibits you from doing, e.g., if a language allows you to use pointers or do bitwise xor or use SSE instructions then it is not high level, no matter what abstractions it supports.",
      "id": "c215d311844cbd1bbd575a4021a46693"
    },
    {
      "type": "html",
      "text": "\nI think the former view is good, while the latter is bad. It is praiseworthy to write a language where one does not <i>have</i> to use pointers (or bitwise xor). It is not praiseworthy to write a language where one is not <i>allowed</i> to use them. (The most common reason to use low-level features is to interoperate with code written in low-level languages. For example, [[Cee Sharp Language]] supports \"unsafe\" code, in part so that, if you cannot use the dot-Net framework to accomplish your goal, you can interoperate with the Windows API, which is a C API.)",
      "id": "133dca18cc694b43dbba8667afb49c9c"
    },
    {
      "type": "html",
      "text": "\nI would say that language implementors who are out to deny access to features are creating [[Restricted Programming Language]]s.",
      "id": "17017806f64c726f59aafc5cb54d3c37"
    },
    {
      "type": "html",
      "text": "\nI suppose an exception has to be made for languages where the program may have been written by untrustworthy people on the other end of the Internet. However, even in those cases, it is possible (albeit slow) to support \"pointers\" which are trapped inside a virtual machine. (Somebody once wrote a virtual machine in Java which can be used to execute C code, inside Java.)",
      "id": "ebc5cdea487ac97e16f0d0fd467bacb5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "44ab66a6b93359820cb198a3dcc81d91"
    },
    {
      "type": "html",
      "text": "I found the ultimate in restricted languages.  Take [[Java Language]] and remove primitive types, arrays, the ability to define classes and methods, and then use it for a web templating language by wrapping every statement in [[Case Sensitive]] XML [[[Extensible Markup Language]]] tags.  Some other features (like some equivalent statements crashing, but not the others) are merely bugs, but most of the language is an exercise in trying to make it \"easy\" and \"enterprise-level.\"",
      "id": "be62e1539930ad9f574f02274e584d63"
    },
    {
      "type": "code",
      "text": "  <ISPECT>String userLang = getUserPreferredLocale(theUser)</ISPECT>\n  <ISPECT>if (userLang==null)\n    <ISPECT>String userLang = i18n.getDefaultLocale()</ISPECT>\n  </ISPECT>",
      "id": "32aea0f665d935be325904f93c0fb7a6"
    },
    {
      "type": "html",
      "text": "<i>Egads -- it looks like [[Basic Language]] is actually better than something else!</i>",
      "id": "6c4dfa1f20d93a7b3f4f042a13681f7c"
    },
    {
      "type": "html",
      "text": "\nSorry, you still have a long way to go before you get to the usability level of [[Xslt Language]].",
      "id": "64290982cb451c094741cca3090180f2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "44ab66a6b93359820cb198a3dcc81d91"
    },
    {
      "type": "html",
      "text": "See [[Bondage And Discipline Language]].",
      "id": "f6868544b94913bc28d893cff6413dd5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "44ab66a6b93359820cb198a3dcc81d91"
    },
    {
      "type": "html",
      "text": "[[Category Programming Language]]",
      "id": "9b027ddd989c9b68aec3f77ad19830cf"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?RestrictedProgrammingLanguage c2.com]",
      "id": "b05ffa1e4ee91f02b342b83047a441c3"
    }
  ],
  "journal": [
    {
      "date": 1281673258000,
      "id": "537e1563c9216d7c59c03e6c0276e103",
      "type": "create",
      "item": {
        "title": "Restricted Programming Language",
        "story": [
          {
            "type": "html",
            "text": "(Inspired by [[Programming Is Not Fun]])",
            "id": "4bd70931e2e6bc1af4089852277697b6"
          },
          {
            "type": "html",
            "text": "\"Restricted programming language\" is my term for a language whose designers omit features because they're \"too complex\" or because some programmers have used them to write bad code.",
            "id": "8cdc7cb794dacde859d87b3ec83d5fa6"
          },
          {
            "type": "html",
            "text": "\n[[Java Language]] is a restricted [[Programming Language]]. The designers chose to omit [[Operator Overloading]] because they felt that overloading made the compiler and code too complex, and because it's possible for programmers to \"abuse\" it by, for example, using += to perform a stack push. [[Cee Sharp]] supports overloaded operators, which will probably make it more popular than Java. (But, to be fair, Java's restrictions aren't <i>that bad,</i> mainly because Java gives you other features in return, such as garbage collection and generics.)",
            "id": "afee804f74a5d9560fd67b9fecf479ae"
          },
          {
            "type": "html",
            "text": "\nI once used a restricted language which was only used in-house by a [[Data Processing]] company. The designers purposely left recursion out, because they were worried about programmers accidentally causing [[Infinite Recursion]]s. All variables were global, because [[Local Variables]] which appear and disappear as the program runs were thought to be over the heads of some of those looking at the program. This led to major headaches when writing code. (By contrast, in my style of [[Forth Language]] programming, all variables are global, and I tend to avoid RECURSE. <i>(Sounds like a job for LOCALS| or a similar Forth construct.)</i> But at least if I accidentally create a new Forth variable with the same name as an old one, it's created separately, so I can't clobber the old one by mistake. [[Hyper Static Global Environment]].)",
            "id": "5546e958001e705ac2c19064e9e30fb0"
          },
          {
            "type": "html",
            "text": "\n[[Cobol Language]] is probably the ultimate restricted language. I say \"probably\" because I've been fortunate enough to be able to avoid COBOL.",
            "id": "98dcb3ad6249ab3c195512aec548719f"
          },
          {
            "type": "html",
            "text": " Not even close. They didn't intend to leave features out, although by the standards of the 21st century there's a lot missing. But back when it was introduced, it was quite powerful. There were things it was better at than [[Fortran Language]], which was the primary alternative for many people, if they had any choice at all.",
            "id": "dfd8744ef478f1061b8ec20fb23453a4"
          },
          {
            "type": "html",
            "text": "\nObviously not every language can have every feature. [[Bjarne Stroustrup]] made the conscious decision to leave serialization out of [[Cee Plus Plus]] because he was afraid it would incur a space overhead on every object, including objects that didn't use serialization. [[Scheme Language]] is deliberately confined to a small number of special forms because the designers want to avoid the \"bloatedness\" of [[Common Lisp]]. (Instead, they added a macro facility so you can define your own special forms. See [[Define Syntax]]. <i>This sounds like Common Lisp has no such macro facilities, which isn't true.</i>) [[Forth Language]] is constrained in various ways so that it can be easy to implement. Nevertheless, these languages are targeted for programmers, and do not deny features to programmers on the ground that programmers, or others looking at the program code, would be too stupid to understand those features. However, this is, I think, the difference between <i>restrictions</i> and mere <i>limitations</i>: limitations are motivated by the nature of the problems that the language designer is trying to solve; restrictions are set out in advance of designing the language, usually in order to prevent programmers from doing things.",
            "id": "81a40f7dd5993d1a06f61ae3433d78f5"
          },
          {
            "type": "html",
            "text": "\nWhen I get saddled with such a [[Programming Language]] I often end up doing what looks like [[Gold Plating]]: my classical [[Computer Science]] education has caused me to see certain problems in terms of recursion or the use of [[Local Variables]], and I can't unsee it, so I find myself doing by hand what I think the language implementation ought to have done. I find myself implementing stacks and storing all my values there. I find myself implementing [[Continuation Passing Style]]. I find myself writing Forth-like code outside of [[Forth Language]]. In [[Java Language]], I find myself copying and pasting code because there are no templates, and using a class and an interface would incur too much overhead [[[Copy And Paste Programming]]]. [[Complexity Has To Go Somewhere]]. The code that gets written is very nearly unmaintainable to other people, <i>unless</i> the maintainer knows or figures out what has been done to produce this contorted code and can follow the process back and forth. Is it too much to hope that some maintainer will have an \"[[Ah Ha]]\" moment with my old code, that suddenly it will become clear to them, and they will start writing all their code like that? I suppose it would be a suitable revenge.",
            "id": "a0c4beca75749a56041742d89602bb4e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "44ab66a6b93359820cb198a3dcc81d91"
          },
          {
            "type": "html",
            "text": "Just to make it clear, it is not a feature of the language or the lack thereof that makes the language \"restricted.\" It's the motivation of the language designers when they chose to include or omit a feature.",
            "id": "58c0e5813942ef5cd41a4f332d773946"
          },
          {
            "type": "html",
            "text": "\nA restricted programming language is any language whose designers thought that <i>programmers would be too stupid</i> to do X, or refrain from doing Y, and that therefore the language should force them to do X and to refrain from doing Y.",
            "id": "9a5085eed32f80b6df8bab07ca8ab12a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "44ab66a6b93359820cb198a3dcc81d91"
          },
          {
            "type": "html",
            "text": "Some people say that what makes a language high-level is what it allows you to do, e.g., higher-level languages allow you to represent more abstract concepts directly in the code.",
            "id": "1623a194b82ae047e66fe815d54e3d72"
          },
          {
            "type": "html",
            "text": "\nOther people say that what makes a language high-level is what it prohibits you from doing, e.g., if a language allows you to use pointers or do bitwise xor or use SSE instructions then it is not high level, no matter what abstractions it supports.",
            "id": "c215d311844cbd1bbd575a4021a46693"
          },
          {
            "type": "html",
            "text": "\nI think the former view is good, while the latter is bad. It is praiseworthy to write a language where one does not <i>have</i> to use pointers (or bitwise xor). It is not praiseworthy to write a language where one is not <i>allowed</i> to use them. (The most common reason to use low-level features is to interoperate with code written in low-level languages. For example, [[Cee Sharp Language]] supports \"unsafe\" code, in part so that, if you cannot use the dot-Net framework to accomplish your goal, you can interoperate with the Windows API, which is a C API.)",
            "id": "133dca18cc694b43dbba8667afb49c9c"
          },
          {
            "type": "html",
            "text": "\nI would say that language implementors who are out to deny access to features are creating [[Restricted Programming Language]]s.",
            "id": "17017806f64c726f59aafc5cb54d3c37"
          },
          {
            "type": "html",
            "text": "\nI suppose an exception has to be made for languages where the program may have been written by untrustworthy people on the other end of the Internet. However, even in those cases, it is possible (albeit slow) to support \"pointers\" which are trapped inside a virtual machine. (Somebody once wrote a virtual machine in Java which can be used to execute C code, inside Java.)",
            "id": "ebc5cdea487ac97e16f0d0fd467bacb5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "44ab66a6b93359820cb198a3dcc81d91"
          },
          {
            "type": "html",
            "text": "I found the ultimate in restricted languages.  Take [[Java Language]] and remove primitive types, arrays, the ability to define classes and methods, and then use it for a web templating language by wrapping every statement in [[Case Sensitive]] XML [[[Extensible Markup Language]]] tags.  Some other features (like some equivalent statements crashing, but not the others) are merely bugs, but most of the language is an exercise in trying to make it \"easy\" and \"enterprise-level.\"",
            "id": "be62e1539930ad9f574f02274e584d63"
          },
          {
            "type": "code",
            "text": "  <ISPECT>String userLang = getUserPreferredLocale(theUser)</ISPECT>\n  <ISPECT>if (userLang==null)\n    <ISPECT>String userLang = i18n.getDefaultLocale()</ISPECT>\n  </ISPECT>",
            "id": "32aea0f665d935be325904f93c0fb7a6"
          },
          {
            "type": "html",
            "text": "<i>Egads -- it looks like [[Basic Language]] is actually better than something else!</i>",
            "id": "6c4dfa1f20d93a7b3f4f042a13681f7c"
          },
          {
            "type": "html",
            "text": "\nSorry, you still have a long way to go before you get to the usability level of [[Xslt Language]].",
            "id": "64290982cb451c094741cca3090180f2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "44ab66a6b93359820cb198a3dcc81d91"
          },
          {
            "type": "html",
            "text": "See [[Bondage And Discipline Language]].",
            "id": "f6868544b94913bc28d893cff6413dd5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "44ab66a6b93359820cb198a3dcc81d91"
          },
          {
            "type": "html",
            "text": "[[Category Programming Language]]",
            "id": "9b027ddd989c9b68aec3f77ad19830cf"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?RestrictedProgrammingLanguage c2.com]",
            "id": "b05ffa1e4ee91f02b342b83047a441c3"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1649691376341
    }
  ]
}