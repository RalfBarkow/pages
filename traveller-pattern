{
  "title": "Traveller Pattern",
  "story": [
    {
      "type": "html",
      "text": "<i>A thought: The [[Visitor Pattern]]'s match.</i>",
      "id": "8eb81fb6f7f2201ed4966a8bbe04fedc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d8404d0e616ef81cc3e21b527c17ec5f"
    },
    {
      "type": "html",
      "text": "\nIn an event based system, there are many objects which have events to be listened to. Sometimes they merely delegate to another object which they are composed of, other times they delegate to a [[Event Multicaster]]. Beyond a basic addListener() method (and possibly a removeListener), it's possible that the multicaster contains several methods that may be interesting to a client object, but which will not be available unless they are passed through somehow.",
      "id": "58b78b6fe57a2727f32844b669b91c58"
    },
    {
      "type": "html",
      "text": "\nSingle-Inheritance is rarely workable. Even ignoring the fact that you may already have to extend some class and therefore can't extend the multicaster, what happens if you want to maintain two discrete subscriptions?",
      "id": "72be7ec56b3589983702fd7f22924dcf"
    },
    {
      "type": "html",
      "text": "\nDelegation is often chosen, but it has its drawbacks as well. Delegating every method in the multicaster can be pretty ugly, and exposes a lot of functionality which the client may have no right to (why should the client be able to remove an unrelated listener?). It comes down to the fact that, although useful to the client, it's not the responsibility of the Object to directly provide this access.",
      "id": "936ce997b9ec3038031d65f76a289f2b"
    },
    {
      "type": "html",
      "text": "There might be a case for the multicaster returning a Visitor of its own (the Traveller). The Traveller could encapsulate, at its simplest, the act of returning/removing the original Visitor. A more complex version could allow the caller to replace the contributed Visitor with a different one. This has several advantages: because the Object only has to pass through the Traveller, a single 'addListener()' type method is now sufficient for most functionality. Secondly, the Traveller <i>safely</i> exposes the client to powerful functionality (replacing the contributed listener, cancelling the listener, etc.), as it grants this access per visitor, and not by multicaster. In some cases, the client may not even need retain a reference to the listener any more.",
      "id": "cbf8d42ca2a2a6eea8d250c2abfa149e"
    },
    {
      "type": "html",
      "text": "-- [[William Underwood]]",
      "id": "94c53d99d5ef37a86dfa600b70a4ece0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d8404d0e616ef81cc3e21b527c17ec5f"
    },
    {
      "type": "html",
      "text": "[[Category Pattern]]",
      "id": "01fedc59a6c1d0ac206b42922fb456ce"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?TravellerPattern c2.com]",
      "id": "42e08419ffd8e7857ceb10d6b6051949"
    }
  ],
  "journal": [
    {
      "date": 1165587960000,
      "id": "10c63d2ab1528632085b28f898f868ab",
      "type": "create",
      "item": {
        "title": "Traveller Pattern",
        "story": [
          {
            "type": "html",
            "text": "<i>A thought: The [[Visitor Pattern]]'s match.</i>",
            "id": "8eb81fb6f7f2201ed4966a8bbe04fedc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d8404d0e616ef81cc3e21b527c17ec5f"
          },
          {
            "type": "html",
            "text": "\nIn an event based system, there are many objects which have events to be listened to. Sometimes they merely delegate to another object which they are composed of, other times they delegate to a [[Event Multicaster]]. Beyond a basic addListener() method (and possibly a removeListener), it's possible that the multicaster contains several methods that may be interesting to a client object, but which will not be available unless they are passed through somehow.",
            "id": "58b78b6fe57a2727f32844b669b91c58"
          },
          {
            "type": "html",
            "text": "\nSingle-Inheritance is rarely workable. Even ignoring the fact that you may already have to extend some class and therefore can't extend the multicaster, what happens if you want to maintain two discrete subscriptions?",
            "id": "72be7ec56b3589983702fd7f22924dcf"
          },
          {
            "type": "html",
            "text": "\nDelegation is often chosen, but it has its drawbacks as well. Delegating every method in the multicaster can be pretty ugly, and exposes a lot of functionality which the client may have no right to (why should the client be able to remove an unrelated listener?). It comes down to the fact that, although useful to the client, it's not the responsibility of the Object to directly provide this access.",
            "id": "936ce997b9ec3038031d65f76a289f2b"
          },
          {
            "type": "html",
            "text": "\nThere might be a case for the multicaster returning a Visitor of its own (the Traveller). The Traveller could encapsulate, at its simplest, the act of returning/removing the original Visitor. A more complex version could allow the caller to replace the contributed Visitor with a different one. This has several advantages: because the Object only has to pass through the Traveller, a single 'addListener()' type method is now sufficient for most functionality. Secondly, the Traveller <i>safely</i> exposes the client to powerful functionality (replacing the contributed listener, cancelling the listener, etc.), as it grants this access per visitor, and not by multicaster. In some cases, the client may not even need retain a reference to the listener any more.",
            "id": "cbf8d42ca2a2a6eea8d250c2abfa149e"
          },
          {
            "type": "html",
            "text": "-- [[William Underwood]]",
            "id": "94c53d99d5ef37a86dfa600b70a4ece0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d8404d0e616ef81cc3e21b527c17ec5f"
          },
          {
            "type": "html",
            "text": "[[Category Pattern]]",
            "id": "01fedc59a6c1d0ac206b42922fb456ce"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?TravellerPattern c2.com]",
            "id": "42e08419ffd8e7857ceb10d6b6051949"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1719657978287
    },
    {
      "type": "edit",
      "id": "cbf8d42ca2a2a6eea8d250c2abfa149e",
      "item": {
        "type": "html",
        "text": "There might be a case for the multicaster returning a Visitor of its own (the Traveller). The Traveller could encapsulate, at its simplest, the act of returning/removing the original Visitor. A more complex version could allow the caller to replace the contributed Visitor with a different one. This has several advantages: because the Object only has to pass through the Traveller, a single 'addListener()' type method is now sufficient for most functionality. Secondly, the Traveller <i>safely</i> exposes the client to powerful functionality (replacing the contributed listener, cancelling the listener, etc.), as it grants this access per visitor, and not by multicaster. In some cases, the client may not even need retain a reference to the listener any more.",
        "id": "cbf8d42ca2a2a6eea8d250c2abfa149e"
      },
      "date": 1719658057075
    }
  ]
}