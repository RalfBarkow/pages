{
  "title": "Dynamic code evolution",
  "story": [
    {
      "type": "markdown",
      "id": "5033090cfd033d26",
      "text": "Dynamic code evolution is a technique to update a program while it is running. \n"
    },
    {
      "type": "markdown",
      "id": "cc3215efbf95d363",
      "text": "In an object-oriented language such as Java, this can be seen as replacing a set of classes by new versions. We [1] modified an existing high-performance virtual machine to allow arbitrary changes to the definition of loaded classes. \n"
    },
    {
      "type": "markdown",
      "id": "746f6b2c71cd2c8c",
      "text": "Besides adding and deleting fields and methods, we also allow any kind of changes to the class and interface hierarchy. Our approach focuses on increasing developer productivity during debugging, but can also be applied for updating of long-running applications. Changes can be applied at any point at which a Java program can be suspended.\n"
    },
    {
      "type": "markdown",
      "id": "96db7a515d5089c3",
      "text": "Our virtual machine is able to continue execution of old changed or deleted methods and also to access deleted static fields. A dynamic verification of the current state of the program ensures type safety of complex class hierarchy changes. However, the programmer still has to ensure that the semantics of the modified program are correct and that the new program version can start running from the state left behind by the old program version.\n"
    },
    {
      "type": "markdown",
      "id": "2d6bd14bc16f4864",
      "text": "The evaluation section shows that our modifications to the virtual machine have no negative performance impact on normal program execution. The in-place instance update algorithm is in many cases faster than a full garbage collection. Standard Java development environments automatically use the code evolution features of our modified virtual machine, so no additional tools are required."
    },
    {
      "type": "markdown",
      "id": "ac3f4367303deaaa",
      "text": "**[1]** T. Würthinger, C. Wimmer, and L. Stadler, “Unrestricted and safe dynamic code evolution for Java,” Science of Computer Programming, vol. 78, no. 5, pp. 481–498, May 2013, doi: 10.1016/j.scico.2011.06.005.\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Dynamic code evolution",
        "story": []
      },
      "date": 1628748180278
    },
    {
      "item": {
        "type": "factory",
        "id": "5033090cfd033d26"
      },
      "id": "5033090cfd033d26",
      "type": "add",
      "date": 1628748181755
    },
    {
      "type": "edit",
      "id": "5033090cfd033d26",
      "item": {
        "type": "markdown",
        "id": "5033090cfd033d26",
        "text": "Dynamic code evolution is a technique to update a program while it is running. In an object- oriented language such as Java, this can be seen as replacing a set of classes by new versions. We modified an existing high-performance virtual machine to allow arbitrary changes to the definition of loaded classes. Besides adding and deleting fields and methods, we also allow any kind of changes to the class and interface hierarchy. Our approach focuses on increasing developer productivity during debugging, but can also be applied for updating of long-running applications. Changes can be applied at any point at which a Java program can be suspended.\nOur virtual machine is able to continue execution of old changed or deleted methods and also to access deleted static fields. A dynamic verification of the current state of the program ensures type safety of complex class hierarchy changes. However, the programmer still has to ensure that the semantics of the modified program are correct and that the new program version can start running from the state left behind by the old program version.\nThe evaluation section shows that our modifications to the virtual machine have no negative performance impact on normal program execution. The in-place instance update algorithm is in many cases faster than a full garbage collection. Standard Java development environments automatically use the code evolution features of our modified virtual machine, so no additional tools are required."
      },
      "date": 1628748184173
    },
    {
      "type": "edit",
      "id": "5033090cfd033d26",
      "item": {
        "type": "markdown",
        "id": "5033090cfd033d26",
        "text": "Dynamic code evolution is a technique to update a program while it is running. \n"
      },
      "date": 1628748194936
    },
    {
      "type": "add",
      "id": "cc3215efbf95d363",
      "item": {
        "type": "markdown",
        "id": "cc3215efbf95d363",
        "text": "In an object-oriented language such as Java, this can be seen as replacing a set of classes by new versions. We modified an existing high-performance virtual machine to allow arbitrary changes to the definition of loaded classes. Besides adding and deleting fields and methods, we also allow any kind of changes to the class and interface hierarchy. Our approach focuses on increasing developer productivity during debugging, but can also be applied for updating of long-running applications. Changes can be applied at any point at which a Java program can be suspended.\nOur virtual machine is able to continue execution of old changed or deleted methods and also to access deleted static fields. A dynamic verification of the current state of the program ensures type safety of complex class hierarchy changes. However, the programmer still has to ensure that the semantics of the modified program are correct and that the new program version can start running from the state left behind by the old program version.\nThe evaluation section shows that our modifications to the virtual machine have no negative performance impact on normal program execution. The in-place instance update algorithm is in many cases faster than a full garbage collection. Standard Java development environments automatically use the code evolution features of our modified virtual machine, so no additional tools are required."
      },
      "after": "5033090cfd033d26",
      "date": 1628748196167
    },
    {
      "type": "edit",
      "id": "cc3215efbf95d363",
      "item": {
        "type": "markdown",
        "id": "cc3215efbf95d363",
        "text": "In an object-oriented language such as Java, this can be seen as replacing a set of classes by new versions. We [1] modified an existing high-performance virtual machine to allow arbitrary changes to the definition of loaded classes. Besides adding and deleting fields and methods, we also allow any kind of changes to the class and interface hierarchy. Our approach focuses on increasing developer productivity during debugging, but can also be applied for updating of long-running applications. Changes can be applied at any point at which a Java program can be suspended.\nOur virtual machine is able to continue execution of old changed or deleted methods and also to access deleted static fields. A dynamic verification of the current state of the program ensures type safety of complex class hierarchy changes. However, the programmer still has to ensure that the semantics of the modified program are correct and that the new program version can start running from the state left behind by the old program version.\nThe evaluation section shows that our modifications to the virtual machine have no negative performance impact on normal program execution. The in-place instance update algorithm is in many cases faster than a full garbage collection. Standard Java development environments automatically use the code evolution features of our modified virtual machine, so no additional tools are required."
      },
      "date": 1628748214124
    },
    {
      "item": {
        "type": "factory",
        "id": "cfa79bd6d7d4557e"
      },
      "id": "cfa79bd6d7d4557e",
      "type": "add",
      "after": "cc3215efbf95d363",
      "date": 1628748228675
    },
    {
      "type": "remove",
      "id": "cfa79bd6d7d4557e",
      "date": 1628748230772
    },
    {
      "item": {
        "type": "factory",
        "id": "ac3f4367303deaaa"
      },
      "id": "ac3f4367303deaaa",
      "type": "add",
      "after": "cc3215efbf95d363",
      "date": 1628748232148
    },
    {
      "type": "edit",
      "id": "ac3f4367303deaaa",
      "item": {
        "type": "markdown",
        "id": "ac3f4367303deaaa",
        "text": "**[1]** T. Würthinger, C. Wimmer, and L. Stadler, “Unrestricted and safe dynamic code evolution for Java,” Science of Computer Programming, vol. 78, no. 5, pp. 481–498, May 2013, doi: 10.1016/j.scico.2011.06.005.\n"
      },
      "date": 1628748248934
    },
    {
      "type": "edit",
      "id": "cc3215efbf95d363",
      "item": {
        "type": "markdown",
        "id": "cc3215efbf95d363",
        "text": "In an object-oriented language such as Java, this can be seen as replacing a set of classes by new versions. We [1] modified an existing high-performance virtual machine to allow arbitrary changes to the definition of loaded classes. \n"
      },
      "date": 1628748269514
    },
    {
      "type": "add",
      "id": "746f6b2c71cd2c8c",
      "item": {
        "type": "markdown",
        "id": "746f6b2c71cd2c8c",
        "text": "Besides adding and deleting fields and methods, we also allow any kind of changes to the class and interface hierarchy. Our approach focuses on increasing developer productivity during debugging, but can also be applied for updating of long-running applications. Changes can be applied at any point at which a Java program can be suspended.\n"
      },
      "after": "cc3215efbf95d363",
      "date": 1628748273667
    },
    {
      "type": "add",
      "id": "96db7a515d5089c3",
      "item": {
        "type": "markdown",
        "id": "96db7a515d5089c3",
        "text": "Our virtual machine is able to continue execution of old changed or deleted methods and also to access deleted static fields. A dynamic verification of the current state of the program ensures type safety of complex class hierarchy changes. However, the programmer still has to ensure that the semantics of the modified program are correct and that the new program version can start running from the state left behind by the old program version.\nThe evaluation section shows that our modifications to the virtual machine have no negative performance impact on normal program execution. The in-place instance update algorithm is in many cases faster than a full garbage collection. Standard Java development environments automatically use the code evolution features of our modified virtual machine, so no additional tools are required."
      },
      "after": "746f6b2c71cd2c8c",
      "date": 1628748275180
    },
    {
      "type": "edit",
      "id": "96db7a515d5089c3",
      "item": {
        "type": "markdown",
        "id": "96db7a515d5089c3",
        "text": "Our virtual machine is able to continue execution of old changed or deleted methods and also to access deleted static fields. A dynamic verification of the current state of the program ensures type safety of complex class hierarchy changes. However, the programmer still has to ensure that the semantics of the modified program are correct and that the new program version can start running from the state left behind by the old program version.\n"
      },
      "date": 1628748279797
    },
    {
      "type": "add",
      "id": "2d6bd14bc16f4864",
      "item": {
        "type": "markdown",
        "id": "2d6bd14bc16f4864",
        "text": "The evaluation section shows that our modifications to the virtual machine have no negative performance impact on normal program execution. The in-place instance update algorithm is in many cases faster than a full garbage collection. Standard Java development environments automatically use the code evolution features of our modified virtual machine, so no additional tools are required."
      },
      "after": "96db7a515d5089c3",
      "date": 1628748280704
    }
  ]
}