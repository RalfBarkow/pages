{
  "title": "BrStencil",
  "story": [
    {
      "type": "markdown",
      "id": "7659aa84f2b55f5a",
      "text": "From the Oxford Dictionary:\n[[Stencil]] - a thin sheet of card, plastic, or metal with a pattern or letters cut out of it, used to produce the cut design on the surface below by the application of ink or paint through the holes.\n\nIn Bloc I play a role of an abstract factory to create predefined visual elements. The two scenarios where stencils should be used are:\n\n1. When lazy element creation is needed, e.g. a variable number of tabs in a view.\n2. When the element being created depends on run time information, e.g. the structure or content of the data to be displayed.\n\nThe idea behind a stencil as concept is to help developers reduce the use of block closures used with scripting API. The reason for that is the fact that block closures can not be recompiled while in a debugger, which makes system less debuggable and live programmable.\n\nThe only essential Stencil API is `=#create`= method, developers should implement it in their stencil subclasses. Note, that `=#create`= has zero arguments which by default makes Stencil stateless. It is also possible to implement a statefull Stencil. Let us formalise the both types:\n"
    },
    {
      "type": "markdown",
      "id": "58dfe1471151e3ed",
      "text": "Stateless Stencil - A stencil that does not have any parameters and the result of #create method is always identical. Two stateless stencils are equal then and only then when their type is the same.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "33a6daa859d01196",
      "text": "Stateful Stencil - A parametrizable stencil whose result of a #create method depends on configuration. Two stencils of the same type configured differently are not considered to be equal.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "5d240ffd38ecdd86",
      "text": "While subclassing is being the preferable way of creating Stencils we still want to provide the support of block closures that play a role of a stencil. Any Valuable object can be converted to so the ValuableStencil by sending `=#asStencil`= convertion method to the object that implements it.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "e2fa9b3f74f304f5",
      "text": "For example the following code creates a Stateless stencil that creates a simple visual element out of BlockClosure:\n"
    },
    {
      "type": "code",
      "id": "449e40fab4b6d05e",
      "text": "| aStencil anElement |\naStencil := [ BlElement new background: Color gray ] asStencil.\nanElement := aStencil create.\n\n"
    },
    {
      "type": "markdown",
      "id": "3cf4ab4fe87a3cb6",
      "text": "Users can additionally provide Stencil arguments to achive a Stateful Stencil:\n"
    },
    {
      "type": "code",
      "id": "29dfa62f0485024a",
      "text": "| aStencil anElement |\naStencil := [ :aColor | BlElement new background: aColor ] asStencil.\naStencil arguments: { Color gray }.\nanElement := aStencil create.\n"
    }
  ],
  "journal": [
    {
      "item": {
        "type": "markdown",
        "id": "7659aa84f2b55f5a",
        "text": "From the Oxford Dictionary:\nStencil - a thin sheet of card, plastic, or metal with a pattern or letters cut out of it, used to produce the cut design on the surface below by the application of ink or paint through the holes.\n\nIn Bloc I play a role of an abstract factory to create predefined visual elements. The two scenarios where stencils should be used are:\n\n1. When lazy element creation is needed, e.g. a variable number of tabs in a view.\n2. When the element being created depends on run time information, e.g. the structure or content of the data to be displayed.\n\nThe idea behind a stencil as concept is to help developers reduce the use of block closures used with scripting API. The reason for that is the fact that block closures can not be recompiled while in a debugger, which makes system less debuggable and live programmable.\n\nThe only essential Stencil API is `=#create`= method, developers should implement it in their stencil subclasses. Note, that `=#create`= has zero arguments which by default makes Stencil stateless. It is also possible to implement a statefull Stencil. Let us formalise the both types:\n\n Stateless Stencil - A stencil that does not have any parameters and the result of #create method is always identical. Two stateless stencils are equal then and only then when their type is the same.\n\n Stateful Stencil - A parametrizable stencil whose result of a #create method depends on configuration. Two stencils of the same type configured differently are not considered to be equal.\n\nWhile subclassing is being the preferable way of creating Stencils we still want to provide the support of block closures that play a role of a stencil. Any Valuable object can be converted to so the ValuableStencil by sending `=#asStencil`= convertion method to the object that implements it.\n\nFor example the following code creates a Stateless stencil that creates a simple visual element out of BlockClosure:\n```\n| aStencil anElement |\naStencil := [ BlElement new background: Color gray ] asStencil.\nanElement := aStencil create.\n```\n\nUsers can additionally provide Stencil arguments to achive a Stateful Stencil:\n\n```\n| aStencil anElement |\naStencil := [ :aColor | BlElement new background: aColor ] asStencil.\naStencil arguments: { Color gray }.\nanElement := aStencil create.\n```\n"
      },
      "id": "7659aa84f2b55f5a",
      "type": "add",
      "date": 1662374558562
    },
    {
      "type": "edit",
      "id": "7659aa84f2b55f5a",
      "item": {
        "type": "markdown",
        "id": "7659aa84f2b55f5a",
        "text": "From the Oxford Dictionary:\nStencil - a thin sheet of card, plastic, or metal with a pattern or letters cut out of it, used to produce the cut design on the surface below by the application of ink or paint through the holes.\n\nIn Bloc I play a role of an abstract factory to create predefined visual elements. The two scenarios where stencils should be used are:\n\n1. When lazy element creation is needed, e.g. a variable number of tabs in a view.\n2. When the element being created depends on run time information, e.g. the structure or content of the data to be displayed.\n\nThe idea behind a stencil as concept is to help developers reduce the use of block closures used with scripting API. The reason for that is the fact that block closures can not be recompiled while in a debugger, which makes system less debuggable and live programmable.\n\nThe only essential Stencil API is `=#create`= method, developers should implement it in their stencil subclasses. Note, that `=#create`= has zero arguments which by default makes Stencil stateless. It is also possible to implement a statefull Stencil. Let us formalise the both types:\n\n Stateless Stencil - A stencil that does not have any parameters and the result of #create method is always identical. Two stateless stencils are equal then and only then when their type is the same.\n\n Stateful Stencil - A parametrizable stencil whose result of a #create method depends on configuration. Two stencils of the same type configured differently are not considered to be equal.\n\nWhile subclassing is being the preferable way of creating Stencils we still want to provide the support of block closures that play a role of a stencil. Any Valuable object can be converted to so the ValuableStencil by sending `=#asStencil`= convertion method to the object that implements it.\n\nFor example the following code creates a Stateless stencil that creates a simple visual element out of BlockClosure:\n```\n| aStencil anElement |\naStencil := [ BlElement new background: Color gray ] asStencil.\nanElement := aStencil create.\n```\n\nUsers can additionally provide Stencil arguments to achive a Stateful Stencil:\n\n```\n| aStencil anElement |\naStencil := [ :aColor | BlElement new background: aColor ] asStencil.\naStencil arguments: { Color gray }.\nanElement := aStencil create.\n```\n"
      },
      "date": 1662374560823
    },
    {
      "type": "fork",
      "date": 1662374563743
    },
    {
      "type": "edit",
      "id": "7659aa84f2b55f5a",
      "item": {
        "type": "markdown",
        "id": "7659aa84f2b55f5a",
        "text": "From the Oxford Dictionary:\n[[Stencil]] - a thin sheet of card, plastic, or metal with a pattern or letters cut out of it, used to produce the cut design on the surface below by the application of ink or paint through the holes.\n\nIn Bloc I play a role of an abstract factory to create predefined visual elements. The two scenarios where stencils should be used are:\n\n1. When lazy element creation is needed, e.g. a variable number of tabs in a view.\n2. When the element being created depends on run time information, e.g. the structure or content of the data to be displayed.\n\nThe idea behind a stencil as concept is to help developers reduce the use of block closures used with scripting API. The reason for that is the fact that block closures can not be recompiled while in a debugger, which makes system less debuggable and live programmable.\n\nThe only essential Stencil API is `=#create`= method, developers should implement it in their stencil subclasses. Note, that `=#create`= has zero arguments which by default makes Stencil stateless. It is also possible to implement a statefull Stencil. Let us formalise the both types:\n\n Stateless Stencil - A stencil that does not have any parameters and the result of #create method is always identical. Two stateless stencils are equal then and only then when their type is the same.\n\n Stateful Stencil - A parametrizable stencil whose result of a #create method depends on configuration. Two stencils of the same type configured differently are not considered to be equal.\n\nWhile subclassing is being the preferable way of creating Stencils we still want to provide the support of block closures that play a role of a stencil. Any Valuable object can be converted to so the ValuableStencil by sending `=#asStencil`= convertion method to the object that implements it.\n\nFor example the following code creates a Stateless stencil that creates a simple visual element out of BlockClosure:\n```\n| aStencil anElement |\naStencil := [ BlElement new background: Color gray ] asStencil.\nanElement := aStencil create.\n```\n\nUsers can additionally provide Stencil arguments to achive a Stateful Stencil:\n\n```\n| aStencil anElement |\naStencil := [ :aColor | BlElement new background: aColor ] asStencil.\naStencil arguments: { Color gray }.\nanElement := aStencil create.\n```\n"
      },
      "date": 1662374573512
    },
    {
      "type": "edit",
      "id": "7659aa84f2b55f5a",
      "item": {
        "type": "markdown",
        "id": "7659aa84f2b55f5a",
        "text": "From the Oxford Dictionary:\n[[Stencil]] - a thin sheet of card, plastic, or metal with a pattern or letters cut out of it, used to produce the cut design on the surface below by the application of ink or paint through the holes.\n\nIn Bloc I play a role of an abstract factory to create predefined visual elements. The two scenarios where stencils should be used are:\n\n1. When lazy element creation is needed, e.g. a variable number of tabs in a view.\n2. When the element being created depends on run time information, e.g. the structure or content of the data to be displayed.\n\nThe idea behind a stencil as concept is to help developers reduce the use of block closures used with scripting API. The reason for that is the fact that block closures can not be recompiled while in a debugger, which makes system less debuggable and live programmable.\n\nThe only essential Stencil API is `=#create`= method, developers should implement it in their stencil subclasses. Note, that `=#create`= has zero arguments which by default makes Stencil stateless. It is also possible to implement a statefull Stencil. Let us formalise the both types:\n"
      },
      "date": 1662374657881
    },
    {
      "type": "add",
      "id": "58dfe1471151e3ed",
      "item": {
        "type": "markdown",
        "id": "58dfe1471151e3ed",
        "text": "Stateless Stencil - A stencil that does not have any parameters and the result of #create method is always identical. Two stateless stencils are equal then and only then when their type is the same.\n\n\n"
      },
      "after": "7659aa84f2b55f5a",
      "date": 1662374666093
    },
    {
      "type": "add",
      "id": "33a6daa859d01196",
      "item": {
        "type": "markdown",
        "id": "33a6daa859d01196",
        "text": "Stateful Stencil - A parametrizable stencil whose result of a #create method depends on configuration. Two stencils of the same type configured differently are not considered to be equal.\n\n\n"
      },
      "after": "58dfe1471151e3ed",
      "date": 1662374669913
    },
    {
      "type": "add",
      "id": "5d240ffd38ecdd86",
      "item": {
        "type": "markdown",
        "id": "5d240ffd38ecdd86",
        "text": "While subclassing is being the preferable way of creating Stencils we still want to provide the support of block closures that play a role of a stencil. Any Valuable object can be converted to so the ValuableStencil by sending `=#asStencil`= convertion method to the object that implements it.\n\nFor example the following code creates a Stateless stencil that creates a simple visual element out of BlockClosure:\n```\n| aStencil anElement |\naStencil := [ BlElement new background: Color gray ] asStencil.\nanElement := aStencil create.\n```\n\nUsers can additionally provide Stencil arguments to achive a Stateful Stencil:\n\n```\n| aStencil anElement |\naStencil := [ :aColor | BlElement new background: aColor ] asStencil.\naStencil arguments: { Color gray }.\nanElement := aStencil create.\n```\n"
      },
      "after": "33a6daa859d01196",
      "date": 1662374675114
    },
    {
      "item": {
        "type": "code",
        "id": "449e40fab4b6d05e",
        "text": "| aStencil anElement |\naStencil := [ BlElement new background: Color gray ] asStencil.\nanElement := aStencil create.\n\n"
      },
      "id": "449e40fab4b6d05e",
      "type": "add",
      "after": "5d240ffd38ecdd86",
      "date": 1662374761554
    },
    {
      "type": "edit",
      "id": "5d240ffd38ecdd86",
      "item": {
        "type": "markdown",
        "id": "5d240ffd38ecdd86",
        "text": "While subclassing is being the preferable way of creating Stencils we still want to provide the support of block closures that play a role of a stencil. Any Valuable object can be converted to so the ValuableStencil by sending `=#asStencil`= convertion method to the object that implements it.\n\nFor example the following code creates a Stateless stencil that creates a simple visual element out of BlockClosure:\n"
      },
      "date": 1662374779233
    },
    {
      "type": "add",
      "id": "8047c89b61ca3ce5",
      "item": {
        "type": "markdown",
        "id": "8047c89b61ca3ce5",
        "text": ""
      },
      "after": "5d240ffd38ecdd86",
      "date": 1662374783292
    },
    {
      "id": "449e40fab4b6d05e",
      "type": "move",
      "order": [
        "7659aa84f2b55f5a",
        "58dfe1471151e3ed",
        "33a6daa859d01196",
        "5d240ffd38ecdd86",
        "8047c89b61ca3ce5",
        "449e40fab4b6d05e",
        "3cf4ab4fe87a3cb6"
      ],
      "date": 1662374786177,
      "error": {
        "type": "error",
        "msg": "Internal Server Error",
        "response": "Server Ignoring move. Try reload."
      }
    },
    {
      "type": "add",
      "id": "3cf4ab4fe87a3cb6",
      "item": {
        "type": "markdown",
        "id": "3cf4ab4fe87a3cb6",
        "text": "Users can additionally provide Stencil arguments to achive a Stateful Stencil:\n\n```\n| aStencil anElement |\naStencil := [ :aColor | BlElement new background: aColor ] asStencil.\naStencil arguments: { Color gray }.\nanElement := aStencil create.\n```\n"
      },
      "after": "8047c89b61ca3ce5",
      "date": 1662374787306
    },
    {
      "type": "remove",
      "id": "8047c89b61ca3ce5",
      "date": 1662374790469
    },
    {
      "type": "edit",
      "id": "449e40fab4b6d05e",
      "item": {
        "type": "code",
        "id": "449e40fab4b6d05e",
        "text": "| aStencil anElement |\naStencil := [ BlElement new background: Color gray ] asStencil.\nanElement := aStencil create.\n\n"
      },
      "date": 1662374799640
    },
    {
      "type": "fork",
      "date": 1662374803422
    },
    {
      "type": "edit",
      "id": "5d240ffd38ecdd86",
      "item": {
        "type": "markdown",
        "id": "5d240ffd38ecdd86",
        "text": "While subclassing is being the preferable way of creating Stencils we still want to provide the support of block closures that play a role of a stencil. Any Valuable object can be converted to so the ValuableStencil by sending `=#asStencil`= convertion method to the object that implements it.\n\n\n"
      },
      "date": 1662374866094
    },
    {
      "type": "add",
      "id": "e2fa9b3f74f304f5",
      "item": {
        "type": "markdown",
        "id": "e2fa9b3f74f304f5",
        "text": "For example the following code creates a Stateless stencil that creates a simple visual element out of BlockClosure:\n"
      },
      "after": "5d240ffd38ecdd86",
      "date": 1662374872088
    },
    {
      "id": "449e40fab4b6d05e",
      "type": "move",
      "order": [
        "7659aa84f2b55f5a",
        "58dfe1471151e3ed",
        "33a6daa859d01196",
        "5d240ffd38ecdd86",
        "e2fa9b3f74f304f5",
        "449e40fab4b6d05e",
        "3cf4ab4fe87a3cb6"
      ],
      "date": 1662374960987
    },
    {
      "item": {
        "type": "factory",
        "id": "29dfa62f0485024a"
      },
      "id": "29dfa62f0485024a",
      "type": "add",
      "after": "3cf4ab4fe87a3cb6",
      "date": 1662374987337
    },
    {
      "type": "edit",
      "id": "3cf4ab4fe87a3cb6",
      "item": {
        "type": "markdown",
        "id": "3cf4ab4fe87a3cb6",
        "text": "Users can additionally provide Stencil arguments to achive a Stateful Stencil:\n"
      },
      "date": 1662374999544
    },
    {
      "type": "edit",
      "id": "29dfa62f0485024a",
      "item": {
        "type": "code",
        "id": "29dfa62f0485024a",
        "text": "| aStencil anElement |\naStencil := [ :aColor | BlElement new background: aColor ] asStencil.\naStencil arguments: { Color gray }.\nanElement := aStencil create.\n"
      },
      "date": 1662375010904
    }
  ]
}