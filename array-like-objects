{
  "title": "Array like objects",
  "story": [
    {
      "type": "paragraph",
      "id": "44d1b541def1387e",
      "text": "For historical reasons there are places in JavaScript where you end up interacting with objects that are a lot like Arrays, but technically aren't. The main difference is that they don't have Array.prototype in their prototype chain, and thus don't inherit the common array methods."
    },
    {
      "type": "paragraph",
      "id": "15d9a2728977e02f",
      "text": "The most common one of these array like objects is 'arguments'. It gets injected into every single function scope, and contains a list of all of arguments that were passed to the function. It is super handy for doing variable argument functions. Often you will want to manipulate these arguments, and since it feels like an [[Array]] you start with your familiar array stuff."
    },
    {
      "type": "code",
      "id": "f64233282d921f5b",
      "text": "// WARNING: this doesn't work.\nfunction sum () {\n  return arguments.reduce(function (a, b) { return a + b })\n}\n\nconsole.log(sum(1, 2, 3))\n// KABOOM"
    },
    {
      "type": "paragraph",
      "id": "9954cd276c78c158",
      "text": "Trying to call reduce isn't going to work, because we don't have an array. Reduce isn't defined, so we get the common and frustrating 'undefined is not a function' error."
    },
    {
      "type": "paragraph",
      "id": "dff2da0536a6a7ac",
      "text": "We have two options. Figure out how to work with array like objects in an acceptable way, or figure out how to convert an array like object into an array."
    },
    {
      "type": "paragraph",
      "id": "c372b04f16aff913",
      "text": "You can use a for loop to work with an array like object. However it's even easier to convert the object to a proper array. This has the added benefit that you are working with a copy, so you don't have to worry about mutating the original arguments object (which you want to avoid)."
    },
    {
      "type": "code",
      "id": "dacd152b14bd2e9b",
      "text": "var slice = Array.prototype.slice\n\nfunction sum () {\n  return slice.call(arguments).reduce(\n    function (a, b) { return a + b }\n  )\n}\n\nconsole.log(sum(1, 2, 3))\n// 6\n"
    },
    {
      "type": "paragraph",
      "id": "38773a3e9c1fb793",
      "text": "The conventional way to do this is to use the native slice method. Since the method isn't available on Objects, we get a stand alone reference off of array, and then use the call method to apply it in the context of the arguments object. This does the default action of slice, returning us a new array that is a copy starting at the beginning and going to the end."
    },
    {
      "type": "paragraph",
      "id": "aa679ee747a7f643",
      "text": "It looks a little cheesy, but it works most places and is pretty fast and safe. This trick works for node lists and other objects with sequential keys starting at '0' that aren't actually arrays. Why aren't they arrays you might want to ask? Well, because we can't have nice things. At least we can have nice workarounds."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Array like objects",
        "story": []
      },
      "date": 1431235782545
    },
    {
      "item": {
        "type": "factory",
        "id": "44d1b541def1387e"
      },
      "id": "44d1b541def1387e",
      "type": "add",
      "date": 1431235787330
    },
    {
      "type": "edit",
      "id": "44d1b541def1387e",
      "item": {
        "type": "paragraph",
        "id": "44d1b541def1387e",
        "text": "For historical reasons there are places in JavaScript where you end up interacting with objects that are a lot like Arrays, but technically aren't. The only real difference is that they don't have Array.prototype in their prototype chain, and thus don't inherit the common array methods."
      },
      "date": 1431235934577
    },
    {
      "type": "edit",
      "id": "44d1b541def1387e",
      "item": {
        "type": "paragraph",
        "id": "44d1b541def1387e",
        "text": "For historical reasons there are places in JavaScript where you end up interacting with objects that are a lot like Arrays, but technically aren't. The main difference is that they don't have Array.prototype in their prototype chain, and thus don't inherit the common array methods."
      },
      "date": 1431235952316
    },
    {
      "item": {
        "type": "factory",
        "id": "15d9a2728977e02f"
      },
      "id": "15d9a2728977e02f",
      "type": "add",
      "after": "44d1b541def1387e",
      "date": 1431235965002
    },
    {
      "type": "edit",
      "id": "15d9a2728977e02f",
      "item": {
        "type": "paragraph",
        "id": "15d9a2728977e02f",
        "text": "The most common one of these array like objects is 'arguments'. It gets injected into every single function scope, and contains a list of all of arguments that were passed to the function. It is super handy for doing variable argument functions. Often you will want to manipulate these arguments, and since it feels like an array you start with your familiar array stuff."
      },
      "date": 1431236082726
    },
    {
      "item": {
        "type": "factory",
        "id": "f64233282d921f5b"
      },
      "id": "f64233282d921f5b",
      "type": "add",
      "after": "15d9a2728977e02f",
      "date": 1431236398504
    },
    {
      "type": "edit",
      "id": "f64233282d921f5b",
      "item": {
        "type": "code",
        "id": "f64233282d921f5b",
        "text": "// WARNING: this doesn't work.\nfunction sum () {\n  return arguments.reduce(function (a, b) { return a + b })\n}\n\nconsole.log(sum(1, 2, 3))\n// KABOOM"
      },
      "date": 1431236404267
    },
    {
      "item": {
        "type": "factory",
        "id": "9954cd276c78c158"
      },
      "id": "9954cd276c78c158",
      "type": "add",
      "after": "f64233282d921f5b",
      "date": 1431236415330
    },
    {
      "type": "edit",
      "id": "9954cd276c78c158",
      "item": {
        "type": "paragraph",
        "id": "9954cd276c78c158",
        "text": "Trying to call reduce isn't going to work, because we don't have an array. Reduce isn't defined, so we get the common and frustrating 'undefined is not a function' error."
      },
      "date": 1431236557950
    },
    {
      "item": {
        "type": "factory",
        "id": "dff2da0536a6a7ac"
      },
      "id": "dff2da0536a6a7ac",
      "type": "add",
      "after": "9954cd276c78c158",
      "date": 1431236576658
    },
    {
      "type": "edit",
      "id": "dff2da0536a6a7ac",
      "item": {
        "type": "paragraph",
        "id": "dff2da0536a6a7ac",
        "text": "We have two options. Figure out how to work with array like objects in an acceptable way, or figure out how to convert an array like object into an array."
      },
      "date": 1431236684930
    },
    {
      "type": "add",
      "id": "c372b04f16aff913",
      "item": {
        "type": "paragraph",
        "id": "c372b04f16aff913",
        "text": "You can use a for loop to work with an array like object. However it's even easier to convert the object to a proper array. This has the added benefit that you are working with a copy, so you don't have to worry about mutating the original arguments object (which you want to avoid)."
      },
      "after": "dff2da0536a6a7ac",
      "date": 1431236771143
    },
    {
      "item": {
        "type": "factory",
        "id": "dacd152b14bd2e9b"
      },
      "id": "dacd152b14bd2e9b",
      "type": "add",
      "after": "c372b04f16aff913",
      "date": 1431236791593
    },
    {
      "type": "edit",
      "id": "dacd152b14bd2e9b",
      "item": {
        "type": "code",
        "id": "dacd152b14bd2e9b",
        "text": "var slice = Array.prototype.slice\n\nfunction sum () {\n  return slice.call(arguments).reduce(function (a, b) { return a + b })\n}\n\nconsole.log(sum(1, 2, 3))\n// 6\n"
      },
      "date": 1431236796750
    },
    {
      "type": "edit",
      "id": "dacd152b14bd2e9b",
      "item": {
        "type": "code",
        "id": "dacd152b14bd2e9b",
        "text": "var slice = Array.prototype.slice\n\nfunction sum () {\n  return slice.call(arguments).reduce(\n    function (a, b) { return a + b }\n  )\n}\n\nconsole.log(sum(1, 2, 3))\n// 6\n"
      },
      "date": 1431236838392
    },
    {
      "item": {
        "type": "factory",
        "id": "38773a3e9c1fb793"
      },
      "id": "38773a3e9c1fb793",
      "type": "add",
      "after": "dacd152b14bd2e9b",
      "date": 1431236878908
    },
    {
      "type": "edit",
      "id": "38773a3e9c1fb793",
      "item": {
        "type": "paragraph",
        "id": "38773a3e9c1fb793",
        "text": "The conventional way to do this is to use the native slice method. Since the method isn't available on Objects, we get a stand alone reference off of array, and then use the call method to apply it in the context of the arguments object. This does the default action of slice, returning us a new array that is a copy starting at the beginning and going to the end."
      },
      "date": 1431237030606
    },
    {
      "item": {
        "type": "factory",
        "id": "aa679ee747a7f643"
      },
      "id": "aa679ee747a7f643",
      "type": "add",
      "after": "38773a3e9c1fb793",
      "date": 1431237045757
    },
    {
      "type": "edit",
      "id": "aa679ee747a7f643",
      "item": {
        "type": "paragraph",
        "id": "aa679ee747a7f643",
        "text": "It looks a little cheesy, but it works most places and is pretty fast and safe. This trick works for node lists and other objects with sequential keys starting at '0' that aren't actually arrays. Why aren't they arrays you might want to ask? Well, because we can't have nice things. At least we can have nice workarounds."
      },
      "date": 1431237180135
    },
    {
      "type": "fork",
      "site": "nrn.io",
      "date": 1652868373432
    },
    {
      "type": "edit",
      "id": "15d9a2728977e02f",
      "item": {
        "type": "paragraph",
        "id": "15d9a2728977e02f",
        "text": "The most common one of these array like objects is 'arguments'. It gets injected into every single function scope, and contains a list of all of arguments that were passed to the function. It is super handy for doing variable argument functions. Often you will want to manipulate these arguments, and since it feels like an [[Array]] you start with your familiar array stuff."
      },
      "date": 1708256479525
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1709466331977
    }
  ]
}