{
  "title": "2023-09-22",
  "story": [
    {
      "type": "paragraph",
      "id": "4828b8eae118a5fa",
      "text": "⇒ [[PEG]] ⇐ Expression and cut parser"
    },
    {
      "type": "paragraph",
      "id": "7e33ef8e8453a242",
      "text": "\nREDZIEJOWSKI, Roman R., 2016. Cut Points in PEG. Fundamenta Informaticae. Online. 1 January 2016. Vol. 143, no. 1–2, p. 141–149. [Accessed 22 September 2023]. DOI 10.3233/FI-2016-1308. Parsing Expression Grammar (PEG) encodes a recursive-descent parser with limited backtracking. It has been recently noticed that in the situation when the parser is to explore several alternatives one after another, no further alternatives need to be\n"
    },
    {
      "type": "paragraph",
      "id": "420f7b2565abdae8",
      "text": "Parsing Expression Grammars (PEGs) have been introduced by Ford in [3] as a new formalism for describing syntax of programming languages. The formalism is recognition-based; in fact, PEG can be seen as encoding of a recursive-descent parser with limited backtracking. Backtracking lifts the LL(1) restriction usually imposed on top-down parsers. The backtracking being limited means that the parser can work in linear time, at the cost of large memory consumption. This is achieved with the help of ”[[Memoization]]” or ”packrat” technology described in [1, 2], The technology consists in saving all partial results for reuse after backtracking."
    },
    {
      "type": "paragraph",
      "id": "24d124d834926d63",
      "text": "[3] Ford, B.: [[Parsing Expression Grammars]]: A Recognition-Based Syntactic Foundation, Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2004 (N. D. Jones, X. Leroy, Eds.), ACM, Venice, Italy, 14–16 January 2004."
    },
    {
      "type": "paragraph",
      "id": "ce54654ec8befa64",
      "text": "⇒ HP Officejet Pro 276dw MFP (2015-05-28_STEG Electronics Quittung Drucker.pdf)"
    },
    {
      "type": "paragraph",
      "id": "a6a356cc83e6aeb1",
      "text": "Bis zu dreimaliges Neueinsetzen des Druckkopfs [https://support.hp.com/ch-de/document/c06466051 page]"
    },
    {
      "type": "paragraph",
      "id": "79b643439e2bffd5",
      "text": "Ersetzen des Druckkopfs"
    },
    {
      "type": "paragraph",
      "id": "0f71fb4a6a9e0fca",
      "text": "Druckerpatronennummer: HP 950, 951"
    },
    {
      "type": "paragraph",
      "id": "77414ba09e602e5b",
      "text": "Land/Region: Europa, …"
    },
    {
      "type": "paragraph",
      "id": "ebf4fe5bf6eac1b2",
      "text": "Druckkopfnummer: CR324A"
    },
    {
      "type": "paragraph",
      "id": "c05a7fcbfe36a798",
      "text": "CR324A   Teil wird nachbestellt, Menge im Bestand ist 0   \nHP 950/951 Printhead EMEA Rplcmnt Kit"
    },
    {
      "type": "paragraph",
      "id": "f4cc98be865c1a5e",
      "text": "Listenpreis (EUR): 225.48"
    },
    {
      "type": "paragraph",
      "id": "664ee1bb4f503286",
      "text": "HP Autorisierte Teilepartner"
    },
    {
      "type": "paragraph",
      "id": "46e28fde57860bf0",
      "text": "Europe, …"
    },
    {
      "type": "paragraph",
      "id": "b81b430e05035b49",
      "text": "Swissparts AG\nDottikon\ntel:+41 56 616 72 11\nfax:+41 56 616 72 19\ninfo@swissparts.ch\nhttp://www.swissparts.ch"
    },
    {
      "type": "pagefold",
      "id": "1affe46f7a16d8be",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "8ac5f816456e47e3",
      "text": "~/workspace/khinsen/malleable-message-manage"
    },
    {
      "type": "paragraph",
      "id": "5663619169e40301",
      "text": "A [[Common Lisp]] library for working with messages on Mastodon, e-mails, and RSS feeds. [⇐ [[Common Lisp Layer]]]"
    },
    {
      "type": "paragraph",
      "id": "cbbee2e70b1f45d0",
      "text": "Learn Common Lisp [https://lisp-lang.org/learn/ site], [[Lisp]] syntax [https://lisp-lang.org/learn/first-steps page]"
    },
    {
      "type": "markdown",
      "id": "49eeb13eaa114a3b",
      "text": "> Syntax is made up of [[S-expression]]s. An S-expression is either an atom or a list."
    },
    {
      "type": "code",
      "id": "136406d907815ae2",
      "text": "; SLIME 2.28\nCL-USER> (format t \"Hello, world!\")\nHello, world!\nNIL\nCL-USER> "
    },
    {
      "type": "paragraph",
      "id": "6941cf47f912742a",
      "text": "Note: t (the truth constant)"
    },
    {
      "type": "paragraph",
      "id": "1a23ad453908cedb",
      "text": "Truth constants are considered as atomic formulas? [https://math.stackexchange.com/questions/2503085/truth-constants-are-considered-as-atomic-formulas stackexchange]"
    },
    {
      "type": "paragraph",
      "id": "925c6ece534bcbc3",
      "text": "There are actually three ways in which you can treat the ⊥ (and same for ⊤, if that is part of your language)."
    },
    {
      "type": "paragraph",
      "id": "40c8e9514facef5b",
      "text": "Package QL does not exist."
    },
    {
      "type": "paragraph",
      "id": "5d2b42df7be8e2af",
      "text": "Confused about ``ql:quickload`` and executable scripts in SBCL [https://stackoverflow.com/questions/25858237/confused-about-qlquickload-and-executable-scripts-in-sbcl stackoverflow]"
    },
    {
      "type": "paragraph",
      "id": "5765d3147cdc8573",
      "text": "Quicklisp is a library manager for Common Lisp. It works with your existing Common Lisp implementation to download, install, and load any of over 1,500 libraries with a few simple commands. [https://www.quicklisp.org/beta/ site]"
    },
    {
      "type": "reference",
      "id": "b61a0278d98c6f44",
      "site": "wiki.ralfbarkow.ch",
      "slug": "lambda-browsing",
      "title": "Lambda Browsing",
      "text": "Here is the page that is the template for main navigational diagram used in this wiki. Changes to the code in this diagram will change the drawing of all those diagrams that reference this page. (Cf. [[Preview Next Diagram]])"
    },
    {
      "type": "pagefold",
      "id": "b4668dc4dcf6cefa",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "b597fba759e7a6c6",
      "text": "Encode a recursive-descent parser with limited backtracking in the Elm programming language."
    },
    {
      "type": "paragraph",
      "id": "d0ace9c553caddef",
      "text": "Certainly! Below is an example of a simple recursive-descent parser with limited backtracking written in the Elm programming language. This parser can recognize a simple arithmetic expression consisting of addition and multiplication operations. […] (ChatGPT)"
    },
    {
      "type": "paragraph",
      "id": "e4f25f0821f9d2ce",
      "text": "[[Missing Closing Parenthesis]]"
    },
    {
      "type": "paragraph",
      "id": "8d525f738d36c4d6",
      "text": "Correction to: …, e.g. In section x.y, a missing closing parenthesis has been included."
    },
    {
      "type": "paragraph",
      "id": "25676a8499bc8f57",
      "text": "⇒ [[Investigate the Problem Dyck(s) Of Checking Matching Parentheses]]"
    },
    {
      "type": "paragraph",
      "id": "0727197588887da1",
      "text": "Abstract Data Structures: Stacks [https://elm-stack.surge.sh site], [https://github.com/mhoare/elm-stack github], [https://package.elm-lang.org/packages/mhoare/elm-stack/latest/Stack package] ⇒ [[Elm Stack]]"
    },
    {
      "type": "markdown",
      "id": "eba13b32db4fed8d",
      "text": "> The item must be of the same type as the stack."
    },
    {
      "type": "code",
      "id": "8107ffac3a74ad44",
      "text": "{-| Removes the item at the top of the stack and returns it as the first item of a tuple.\n-}\npop : Stack a -> ( Maybe a, Stack a )\npop (Stack stack) =\n    case stack of\n        [] ->\n            ( Nothing, Stack [] )\n\n        head :: tail ->\n            ( Just head, Stack tail )"
    },
    {
      "type": "reference",
      "id": "dc1b57b96b87789e",
      "site": "wiki.ralfbarkow.ch",
      "slug": "parenthesis",
      "title": "Parenthesis",
      "text": "is the only typographical delimiter that changes meaning across two different systems. (Bricken, [[Iconic Arithmetic]] Volume I, p. 84N5)"
    },
    {
      "type": "paragraph",
      "id": "d034b266eee76e9a",
      "text": "⇒ [[Meaning of Addition]]"
    },
    {
      "type": "reference",
      "id": "bfa592d047c92588",
      "site": "wiki.ralfbarkow.ch",
      "slug": "order-of-magnitude",
      "title": "Order of Magnitude",
      "text": "The order of magnitude of a digit within a conventional number identifies how many times that digit is multiplied by ten. Instead of increasing the power of a digit by moving to the next position on the left (thousands, hundreds, tens, units), depth-value increases power by depth of nesting. Crossing a boundary outward changes the order of magnitude by one power-of-ten, more generally by one power of an arbitrary base. 5283 in [[Positional Notation]] is (((5)2)8)3 in [[Depth-Value Notation]]. The depth-value form of 5003 is (((5)))3. "
    },
    {
      "type": "paragraph",
      "id": "7f4d91be07ed7e69",
      "text": "Bricken, [[Iconic Arithmetic]] Volume I, p. 84N6:"
    },
    {
      "type": "paragraph",
      "id": "e4148d546b407aa4",
      "text": "6. integrating boundary notation for large numbers with boundary operations on those numbers: The idea of nesting to convey the exponent of a number was present in Roman numerals."
    },
    {
      "type": "image",
      "id": "1454f46074fe3f3d",
      "text": "Roman tally stick",
      "size": "thumbnail",
      "width": 183,
      "height": 92,
      "url": "/assets/plugins/image/278ed795fbee03227b34965229fcdbe5.jpg"
    },
    {
      "type": "paragraph",
      "id": "86bdb9f1294a9891",
      "text": "What we identify now as letters (I, V, X, L, C, M) were not letters to the Romans, but rather particular symbols, probably derived from marking tally sticks. I is not the letter I, it is a notch in a stick. V and X are each types of tally notches that are easy to distinguish when the tally stick is split in half. M, one thousand, evolved from ᴄIᴐ, which itself began as a circle drawn round a vertical stroke. The Romans used ᴄᴐ to stand in place of [[Parentheses]]. Thus depth-value notation was in use over two thousand years ago. The Roman numeral for 10,000 is ᴄᴄIᴐᴐ, while 100,000 is ᴄᴄᴄIᴐᴐᴐ. F. Cajori (1928) A History of Mathematical Notations §51."
    },
    {
      "type": "reference",
      "id": "60f787b83b54106c",
      "site": "wiki.ralfbarkow.ch",
      "slug": "parens-arithmetic",
      "title": "Parens Arithmetic",
      "text": "explicitly separates the operations of arithmetic from the standardization of how a number is written or displayed."
    },
    {
      "type": "markdown",
      "id": "b17cf9a231d314e7",
      "text": "> The primary change is to think of conventional arithmetic operations like addition or multiplication as extremely simple: one parallel put together for addition, one parallel put inside for multiplication. "
    },
    {
      "type": "pagefold",
      "id": "f8c5bfd678d30abf",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "e6d51d4f85c21bbc",
      "text": "It seems like you're referring to a concept from Bricken's Iconic Arithmetic, which simplifies conventional arithmetic operations like addition and multiplication. In this approach, addition is represented as putting things together in parallel [⇒ [[Lineup]]], and multiplication involves putting one thing inside another [⇒ [[Drag-and-Drop]]].\n\nThis way of thinking about arithmetic operations is a fundamental shift from the traditional view, which often involves carrying out multi-step algorithms. Instead, Bricken's approach emphasizes a more visual and intuitive understanding of arithmetic operations.\n\nFor example:\n\n- **Addition (Putting Together)**: Instead of carrying out a step-by-step addition algorithm, you might think of it as simply combining things side by side in a parallel [[Arrangement]]. [⇒ [[Lineup]]]\n\n- **Multiplication (Putting Inside)**: Similarly, multiplication is viewed as putting one thing inside another. This could be visualized as fitting objects together, or placing objects in a [[Container]]. [⇒ [[Drag-and-Drop]]]\n\nThis approach can be especially useful for conceptualizing arithmetic operations in a more intuitive and visually accessible way. It may be particularly beneficial for learners who benefit from visual or spatial representations of mathematical concepts.\n\nRemember, Bricken's Iconic Arithmetic represents a unique and innovative approach to teaching and understanding mathematics. It's based on the idea of providing more intuitive and concrete representations for mathematical operations. If you're studying or interested in this approach, it could be a valuable tool for your mathematical understanding. (ChatGPT)"
    },
    {
      "type": "pagefold",
      "id": "0e6ea36f98384adf",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "4245b38d014a0304",
      "text": "What is taught as [[Addition]] is an amalgam of number facts, group theory, number theory, notational structure, bundle management, and pragmatic algorithms for knitting place-value numerals together.4 In contrast, unit-ensembles separate theory, structure and algorithm by using the generic tools of [[pattern-matching]] to enact transformations. We have also reverted to the original theory of numbers as additive ensembles of units. To isolate the structural mechanism of grouping units, we’ll introduce a new type of boundary that supports manipulation of groups. The parenthesis ( ), called parens, identifies groups and their base. But a word of caution, the parenthesis-bracket will have a different definition when we get to James algebra.5 (Bricken, [[Iconic Arithmetic]] Volume I, p. 66)"
    },
    {
      "type": "paragraph",
      "id": "89ce2baf2d87e711",
      "text": "5. a different definition when we get to James algebra: Beginning in Chapter 5, we’ll redefine the [[Parenthesis]] to be the basic numeric unit in the James system, calling it the round-bracket. The parenthesis is the only typographical delimiter that changes meaning across two different systems. (Bricken, [[Iconic Arithmetic]] Volume I, p. 84N5)"
    },
    {
      "type": "paragraph",
      "id": "07c0f9ffef48e97b",
      "text": "⇒ Depth-value ⇒ [[Depth-Value Notation]]"
    },
    {
      "type": "paragraph",
      "id": "bb3b373ea24eb1d9",
      "text": "Dyck Tests [https://github.com/RalfBarkow/vite-elm-dojo/commit/d54714da26655bf77b97c54e2d1a8f7df4cd8045 commit] (created by a LLM + me)"
    },
    {
      "type": "reference",
      "id": "ffeeb583bd6b9e67",
      "site": "wiki.ralfbarkow.ch",
      "slug": "parenthesis",
      "title": "Parenthesis",
      "text": "is the only typographical delimiter that changes meaning across two different systems. (Bricken, [[Iconic Arithmetic]] Volume I, p. 84N5)"
    },
    {
      "type": "paragraph",
      "id": "ac893e078874b7f1",
      "text": "refactor: redefine the Parenthesis [https://github.com/RalfBarkow/vite-elm-dojo/commit/f63a4c6327c65eb0f0e5f1ecd3b765f4d5dba064 commit]"
    },
    {
      "type": "code",
      "id": "021f95b342290b3b",
      "text": "type Parenthesis\n    = RoundBracket"
    },
    {
      "type": "reference",
      "id": "2459e14d82044fa6",
      "site": "wiki.ralfbarkow.ch",
      "slug": "investigate-the-problem-dycks-of-checking-matching-parentheses",
      "title": "Investigate the Problem Dyck(s) Of Checking Matching Parentheses",
      "text": "Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of [[Parenthesis]]."
    },
    {
      "type": "code",
      "id": "36d7377d317db6f9",
      "text": "isDyck : List Parenthesis -> Bool\nisDyck input =\n    let\n        initState =\n            { stack = []\n            , isValid = True\n            }\n    in\n    let\n        state =\n            List.foldr updateState initState input\n    in\n    List.isEmpty state.stack && state.isValid\n"
    },
    {
      "type": "markdown",
      "id": "9b12df081e9e4850",
      "text": "The `isDyck` function is used to determine if a list of `Parenthesis` forms a valid Dyck sequence. In Dyck language theory, a Dyck word is a string consisting of balanced pairs of characters, such as [[Parentheses]]. For example, `((()))` and `()()()` are valid Dyck words, while `(()(` and `())(` are not.\n\nHere's how the `isDyck` function works:\n\n1. **Type Signature**:\n   ```elm\n   isDyck : List Parenthesis -> Bool\n   ```\n   This means `isDyck` is a function that takes a list of `Parenthesis` and returns a `Bool`.\n\n2. **Function Body**:\n   ```elm\n   isDyck input =\n       let\n           initState =\n               { stack = []\n               , isValid = True\n               }\n       in\n       let\n           state =\n               List.foldr updateState initState input\n       in\n       List.isEmpty state.stack && state.isValid\n   ```\n   - **`initState`**: This initializes the state with an empty stack and sets `isValid` to `True`.\n   - **`state`**: This variable is obtained by folding (`List.foldr`) the `updateState` function over the input list. `updateState` takes a `Parenthesis` and a `State`, and returns a modified `State` after applying the operation defined for `updateState`.\n   - **`List.isEmpty state.stack && state.isValid`**: This checks if the final state has an empty stack (meaning all parentheses were matched) and `isValid` is still `True`. If both conditions are met, it returns `True`, indicating that the input forms a valid Dyck sequence.\n\n3. **`updateState` Function**:\n   `updateState` is a helper function that updates the state based on the type of `Parenthesis` encountered. In this case, it only deals with `Parenthesis` and pushes them onto the stack.\n\nOverall, `isDyck` applies the `updateState` operation to each `Parenthesis` in the input list and checks if the resulting state indicates a valid Dyck sequence. (ChatGPT)"
    },
    {
      "type": "code",
      "id": "af8fe55ec35cb34d",
      "text": "updateState : Parenthesis -> State -> State\nupdateState bracket state =\n    case bracket of\n        RoundBracket ->\n            push RoundBracket state\n\n"
    },
    {
      "type": "markdown",
      "id": "27daa03cd158f0e3",
      "text": "The `updateState` function is responsible for updating the state based on the type of `Parenthesis` encountered. Here's how it works:\n\n1. **Type Signature**:\n   ```elm\n   updateState : Parenthesis -> State -> State\n   ```\n   This means `updateState` is a function that takes a `Parenthesis` and a `State` and returns a modified `State`.\n\n2. **Function Body**:\n   ```elm\n   updateState bracket state =\n       case bracket of\n           RoundBracket ->\n               push RoundBracket state\n   ```\n   - `bracket`: This is the `Parenthesis` that is being processed.\n   - `state`: This is the current state.\n\n   - **`case bracket of`**: This is a pattern matching construct. It checks the type of `bracket`.\n\n   - **`RoundBracket ->`**: If the `bracket` is of type `RoundBracket` (which is synonymous with `Parenthesis` in this context), the following code will be executed:\n\n       - `push RoundBracket state`: This calls the `push` function with the `RoundBracket` (which is essentially a `Parenthesis`) and the current `state`. The `push` function updates the state by adding the `RoundBracket` to the stack.\n\n       If `bracket` is not `RoundBracket`, this function will not perform any operation.\n\n3. **`push` Function**:\n   The `push` function, which is not shown here, is responsible for adding a `RoundBracket` to the stack in the state. It takes a `RoundBracket` and a `State` and returns a modified `State` with the updated stack.\n\nIn summary, `updateState` takes a `Parenthesis` and a `State`, and if the `Parenthesis` is a `RoundBracket`, it calls the `push` function to update the state. The `push` function handles the actual stacking operation. (ChatGPT)"
    },
    {
      "type": "code",
      "id": "efe57ba9dc3f4338",
      "text": "push : Parenthesis -> State -> State\npush bracket state =\n    { state | stack = bracket :: state.stack }\n"
    },
    {
      "type": "markdown",
      "id": "3a038fa99b3d834e",
      "text": "The `push` function is responsible for adding a `Parenthesis` to the stack in the current state. Here's how it works:\n\n1. **Type Signature**:\n   ```elm\n   push : Parenthesis -> State -> State\n   ```\n   This means `push` is a function that takes a `Parenthesis` and a `State`, and it returns a modified `State`.\n\n2. **Function Body**:\n   ```elm\n   push bracket state =\n       { state | stack = bracket :: state.stack }\n   ```\n   - `bracket`: This is the `Parenthesis` that needs to be added to the stack.\n   - `state`: This is the current state.\n\n   - `state | stack = bracket :: state.stack`: This is an Elm record update syntax. It creates a new state by modifying the `stack` field.\n\n       - `stack = bracket :: state.stack`: This means that the new `stack` will be the result of adding `bracket` to the front of the current `state.stack`. This effectively pushes `bracket` onto the stack.\n\n       - The `::` operator is the list cons operator. It adds an element to the beginning of a list.\n\n   - The rest of the fields in the state (in this case, `isValid`) remain unchanged.\n\nIn summary, the `push` function takes a `Parenthesis` and a `State`, and it returns a new `State` where the `Parenthesis` has been added to the stack. The original state is not modified; instead, a new state with the updated stack is returned. (ChatGPT)"
    },
    {
      "type": "code",
      "id": "158fd207422817dc",
      "text": "pop : State -> State\npop state =\n    case state.stack of\n        [] ->\n            state\n\n        _ :: rest ->\n            { state | stack = rest }\n"
    },
    {
      "type": "markdown",
      "id": "7ce85a0182d198d4",
      "text": "The `pop` function is responsible for removing the topmost element from the stack in the current state. Here's how it works:\n\n1. **Type Signature**:\n   ```elm\n   pop : State -> State\n   ```\n   This means `pop` is a function that takes a `State` and returns a modified `State`.\n\n2. **Function Body**:\n   ```elm\n   pop state =\n       case state.stack of\n           [] ->\n               state\n\n           _ :: rest ->\n               { state | stack = rest }\n   ```\n\n   - `state`: This is the current state.\n\n   - `case state.stack of`: This is a pattern matching expression that checks the value of `state.stack`.\n\n   - `[] -> state`: If `state.stack` is an empty list, it means the stack is already empty. In this case, the function simply returns the original `state` without making any changes.\n\n   - `_ :: rest -> { state | stack = rest }`: If `state.stack` is not empty, it means there's at least one element on the stack. Here's what happens next:\n\n       - `::_rest`: This pattern matches any non-empty list, and it binds the head of the list (the first element) to `_`. We're not using the head value, so we use the wildcard `_` to indicate that we're ignoring it. The rest of the list is bound to `rest`.\n\n       - `{ state | stack = rest }`: This is an Elm record update syntax. It creates a new state by modifying the `stack` field.\n\n           - `stack = rest`: This means that the new `stack` will be the tail of the current `state.stack`. This effectively removes the topmost element from the stack.\n\n           - The rest of the fields in the state (in this case, `isValid`) remain unchanged.\n\nIn summary, the `pop` function takes a `State` and returns a new `State` where the topmost element has been removed from the stack. The original state is not modified; instead, a new state with the updated stack is returned. If the stack was already empty, the original state is returned without changes. (ChatGPT)"
    },
    {
      "type": "paragraph",
      "id": "1f4166ae03f09872",
      "text": "We assume that RoundBracket is either a opening or a closing round-bracket. How to modify the code?"
    },
    {
      "type": "markdown",
      "id": "b3102079cbc8e7b4",
      "text": "If `RoundBracket` can represent either an opening or a closing round-bracket, we need to adjust the code accordingly. Here's how you can modify the code:\n\nIn Main.elm:\n\n```elm\ntype RoundBracket\n    = OpenBracket\n    | CloseBracket\n```\n\nIn MainSpec.elm, you'll need to adjust the tests to use `OpenBracket` and `CloseBracket`:\n\n```elm\ntests : Test\ntests =\n    describe \"Dyck Tests\"\n        [ test \"Test 1\" <|\n            \\() ->\n                Expect.equal True (isDyck [ OpenBracket, OpenBracket, OpenBracket, CloseBracket, CloseBracket, CloseBracket ])\n        -- Add more tests as needed\n        -- ...\n        ]\n```\n\nAdditionally, you'll need to adjust the `updateState` function in Main.elm to handle both types of `RoundBracket`:\n\n```elm\nupdateState : RoundBracket -> State -> State\nupdateState bracket state =\n    case bracket of\n        OpenBracket ->\n            push bracket state\n\n        CloseBracket ->\n            case state.stack of\n                [] ->\n                    { state | isValid = False }\n\n                _ :: rest ->\n                    pop state\n```\n\nWith these modifications, the code should now handle both opening and closing round-brackets correctly. Remember to adjust the tests and logic as needed for your specific use case. (ChatGPT)"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2023-09-22",
        "story": []
      },
      "date": 1695361190489
    },
    {
      "item": {
        "type": "factory",
        "id": "567736ecaa96aad5"
      },
      "id": "567736ecaa96aad5",
      "type": "add",
      "date": 1695361192372
    },
    {
      "type": "edit",
      "id": "567736ecaa96aad5",
      "item": {
        "type": "paragraph",
        "id": "567736ecaa96aad5",
        "text": "Expression and cut parser"
      },
      "date": 1695361194733
    },
    {
      "item": {
        "type": "factory",
        "id": "7e33ef8e8453a242"
      },
      "id": "7e33ef8e8453a242",
      "type": "add",
      "after": "567736ecaa96aad5",
      "date": 1695361437739
    },
    {
      "type": "edit",
      "id": "7e33ef8e8453a242",
      "item": {
        "type": "paragraph",
        "id": "7e33ef8e8453a242",
        "text": "\nREDZIEJOWSKI, Roman R., 2016. Cut Points in PEG. Fundamenta Informaticae. Online. 1 January 2016. Vol. 143, no. 1–2, p. 141–149. [Accessed 22 September 2023]. DOI 10.3233/FI-2016-1308. Parsing Expression Grammar (PEG) encodes a recursive-descent parser with limited backtracking. It has been recently noticed that in the situation when the parser is to explore several alternatives one after another, no further alternatives need to be\n"
      },
      "date": 1695361439697
    },
    {
      "item": {
        "type": "factory",
        "id": "4828b8eae118a5fa"
      },
      "id": "4828b8eae118a5fa",
      "type": "add",
      "after": "7e33ef8e8453a242",
      "date": 1695361473673
    },
    {
      "type": "edit",
      "id": "4828b8eae118a5fa",
      "item": {
        "type": "paragraph",
        "id": "4828b8eae118a5fa",
        "text": "⇒ [[PEG]]"
      },
      "date": 1695361487613
    },
    {
      "id": "4828b8eae118a5fa",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242"
      ],
      "date": 1695361494870
    },
    {
      "item": {
        "type": "factory",
        "id": "79367fcb2f633b57"
      },
      "id": "79367fcb2f633b57",
      "type": "add",
      "after": "7e33ef8e8453a242",
      "date": 1695361747923
    },
    {
      "type": "remove",
      "id": "79367fcb2f633b57",
      "date": 1695361749386
    },
    {
      "item": {
        "type": "factory",
        "id": "420f7b2565abdae8"
      },
      "id": "420f7b2565abdae8",
      "type": "add",
      "after": "7e33ef8e8453a242",
      "date": 1695361750695
    },
    {
      "type": "edit",
      "id": "420f7b2565abdae8",
      "item": {
        "type": "paragraph",
        "id": "420f7b2565abdae8",
        "text": "Parsing Expression Grammars (PEGs) have been introduced by Ford in [3] as a new formalism for describing syntax of programming languages. The formalism is recognition-based; in fact, PEG can be seen as encoding of a recursive-descent parser with limited backtracking. Backtracking lifts the LL(1) restriction usually imposed on top-down parsers. The backtracking being limited means that the parser can work in linear time, at the cost of large memory consumption. This is achieved with the help of ”memoization” or ”packrat” technology described in [1, 2], The technology consists in saving all partial results for reuse after backtracking."
      },
      "date": 1695361752594
    },
    {
      "type": "edit",
      "id": "420f7b2565abdae8",
      "item": {
        "type": "paragraph",
        "id": "420f7b2565abdae8",
        "text": "Parsing Expression Grammars (PEGs) have been introduced by Ford in [3] as a new formalism for describing syntax of programming languages. The formalism is recognition-based; in fact, PEG can be seen as encoding of a recursive-descent parser with limited backtracking. Backtracking lifts the LL(1) restriction usually imposed on top-down parsers. The backtracking being limited means that the parser can work in linear time, at the cost of large memory consumption. This is achieved with the help of ”[[memoization]]” or ”packrat” technology described in [1, 2], The technology consists in saving all partial results for reuse after backtracking."
      },
      "date": 1695361770310
    },
    {
      "type": "edit",
      "id": "420f7b2565abdae8",
      "item": {
        "type": "paragraph",
        "id": "420f7b2565abdae8",
        "text": "Parsing Expression Grammars (PEGs) have been introduced by Ford in [3] as a new formalism for describing syntax of programming languages. The formalism is recognition-based; in fact, PEG can be seen as encoding of a recursive-descent parser with limited backtracking. Backtracking lifts the LL(1) restriction usually imposed on top-down parsers. The backtracking being limited means that the parser can work in linear time, at the cost of large memory consumption. This is achieved with the help of ”[[Memoization]]” or ”packrat” technology described in [1, 2], The technology consists in saving all partial results for reuse after backtracking."
      },
      "date": 1695361784946
    },
    {
      "item": {
        "type": "factory",
        "id": "24d124d834926d63"
      },
      "id": "24d124d834926d63",
      "type": "add",
      "after": "420f7b2565abdae8",
      "date": 1695361931266
    },
    {
      "type": "edit",
      "id": "24d124d834926d63",
      "item": {
        "type": "paragraph",
        "id": "24d124d834926d63",
        "text": "[3] Ford, B.: Parsing Expression Grammars: A Recognition-Based Syntactic Foundation, Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2004 (N. D. Jones, X. Leroy, Eds.), ACM, Venice, Italy, 14–16 January 2004."
      },
      "date": 1695361933261
    },
    {
      "type": "edit",
      "id": "24d124d834926d63",
      "item": {
        "type": "paragraph",
        "id": "24d124d834926d63",
        "text": "[3] Ford, B.: [[Parsing Expression Grammars]]: A Recognition-Based Syntactic Foundation, Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2004 (N. D. Jones, X. Leroy, Eds.), ACM, Venice, Italy, 14–16 January 2004."
      },
      "date": 1695361943255
    },
    {
      "item": {
        "type": "factory",
        "id": "ce54654ec8befa64"
      },
      "id": "ce54654ec8befa64",
      "type": "add",
      "after": "24d124d834926d63",
      "date": 1695362106620
    },
    {
      "type": "edit",
      "id": "ce54654ec8befa64",
      "item": {
        "type": "paragraph",
        "id": "ce54654ec8befa64",
        "text": "⇒ HP Officejet Pro 276dw MFP"
      },
      "date": 1695362141889
    },
    {
      "item": {
        "type": "factory",
        "id": "a6a356cc83e6aeb1"
      },
      "id": "a6a356cc83e6aeb1",
      "type": "add",
      "after": "ce54654ec8befa64",
      "date": 1695362236282
    },
    {
      "type": "edit",
      "id": "a6a356cc83e6aeb1",
      "item": {
        "type": "paragraph",
        "id": "a6a356cc83e6aeb1",
        "text": "Bis zu dreimaliges Neueinsetzen des Druckkopfs"
      },
      "date": 1695362238846
    },
    {
      "type": "edit",
      "id": "a6a356cc83e6aeb1",
      "item": {
        "type": "paragraph",
        "id": "a6a356cc83e6aeb1",
        "text": "Bis zu dreimaliges Neueinsetzen des Druckkopfs [https://support.hp.com/ch-de/document/c06466051 page]"
      },
      "date": 1695362249900
    },
    {
      "item": {
        "type": "factory",
        "id": "0f71fb4a6a9e0fca"
      },
      "id": "0f71fb4a6a9e0fca",
      "type": "add",
      "after": "a6a356cc83e6aeb1",
      "date": 1695363385886
    },
    {
      "type": "edit",
      "id": "0f71fb4a6a9e0fca",
      "item": {
        "type": "paragraph",
        "id": "0f71fb4a6a9e0fca",
        "text": "Druckerpatronennummer: "
      },
      "date": 1695363390858
    },
    {
      "type": "edit",
      "id": "0f71fb4a6a9e0fca",
      "item": {
        "type": "paragraph",
        "id": "0f71fb4a6a9e0fca",
        "text": "Druckerpatronennummer: HP 950, 951"
      },
      "date": 1695363414961
    },
    {
      "type": "add",
      "id": "77414ba09e602e5b",
      "item": {
        "type": "paragraph",
        "id": "77414ba09e602e5b",
        "text": "Land/Region: "
      },
      "after": "0f71fb4a6a9e0fca",
      "date": 1695363423764
    },
    {
      "type": "edit",
      "id": "77414ba09e602e5b",
      "item": {
        "type": "paragraph",
        "id": "77414ba09e602e5b",
        "text": "Land/Region: Europa, …"
      },
      "date": 1695363434413
    },
    {
      "type": "add",
      "id": "ebf4fe5bf6eac1b2",
      "item": {
        "type": "paragraph",
        "id": "ebf4fe5bf6eac1b2",
        "text": "Druckkopfnummer: "
      },
      "after": "77414ba09e602e5b",
      "date": 1695363442200
    },
    {
      "type": "edit",
      "id": "ebf4fe5bf6eac1b2",
      "item": {
        "type": "paragraph",
        "id": "ebf4fe5bf6eac1b2",
        "text": "Druckkopfnummer: CR324A"
      },
      "date": 1695363448189
    },
    {
      "type": "edit",
      "id": "ce54654ec8befa64",
      "item": {
        "type": "paragraph",
        "id": "ce54654ec8befa64",
        "text": "⇒ HP Officejet Pro 276dw MFP (2015-05-28_STEG Electronics Quittung Drucker.pdf)"
      },
      "date": 1695363770897
    },
    {
      "type": "add",
      "id": "79b643439e2bffd5",
      "item": {
        "type": "paragraph",
        "id": "79b643439e2bffd5",
        "text": "Ersetzen des Druckkopfs"
      },
      "after": "a6a356cc83e6aeb1",
      "date": 1695363970631
    },
    {
      "type": "add",
      "id": "c05a7fcbfe36a798",
      "item": {
        "type": "paragraph",
        "id": "c05a7fcbfe36a798",
        "text": "CR324A   Teil wird nachbestellt, Menge im Bestand ist 0   \nHP 950/951 Printhead EMEA Rplcmnt Kit   "
      },
      "after": "ebf4fe5bf6eac1b2",
      "date": 1695364528894
    },
    {
      "type": "edit",
      "id": "c05a7fcbfe36a798",
      "item": {
        "type": "paragraph",
        "id": "c05a7fcbfe36a798",
        "text": "CR324A   Teil wird nachbestellt, Menge im Bestand ist 0   \nHP 950/951 Printhead EMEA Rplcmnt Kit"
      },
      "date": 1695364540456
    },
    {
      "type": "add",
      "id": "f4cc98be865c1a5e",
      "item": {
        "type": "paragraph",
        "id": "f4cc98be865c1a5e",
        "text": "Listenpreis\n(EUR)"
      },
      "after": "c05a7fcbfe36a798",
      "date": 1695364541779
    },
    {
      "type": "edit",
      "id": "f4cc98be865c1a5e",
      "item": {
        "type": "paragraph",
        "id": "f4cc98be865c1a5e",
        "text": "Listenpreis (EUR): 225.48"
      },
      "date": 1695364557674
    },
    {
      "type": "add",
      "id": "664ee1bb4f503286",
      "item": {
        "type": "paragraph",
        "id": "664ee1bb4f503286",
        "text": "."
      },
      "after": "f4cc98be865c1a5e",
      "date": 1695364636075
    },
    {
      "type": "add",
      "id": "cbfac31ac300b169",
      "item": {
        "type": "paragraph",
        "id": "cbfac31ac300b169",
        "text": "ET Europarts (Schweiz) GmbH\nHunenberg\ntel:+41 41 785 13 13\nfax:+41 41 785 13 14\ninfo@eeteuroparts.ch\nhttp://www.eeteuroparts.ch\n\nSwissparts AG\nDottikon\ntel:+41 56 616 72 11\nfax:+41 56 616 72 19\ninfo@swissparts.ch\nhttp://www.swissparts.ch"
      },
      "after": "664ee1bb4f503286",
      "date": 1695364637662
    },
    {
      "type": "edit",
      "id": "664ee1bb4f503286",
      "item": {
        "type": "paragraph",
        "id": "664ee1bb4f503286",
        "text": "HP Autorisierte Teilepartner"
      },
      "date": 1695364651975
    },
    {
      "type": "add",
      "id": "46e28fde57860bf0",
      "item": {
        "type": "paragraph",
        "id": "46e28fde57860bf0",
        "text": "Europe, …"
      },
      "after": "664ee1bb4f503286",
      "date": 1695364662443
    },
    {
      "type": "edit",
      "id": "cbfac31ac300b169",
      "item": {
        "type": "paragraph",
        "id": "cbfac31ac300b169",
        "text": "ET Europarts (Schweiz) GmbH\nHunenberg\ntel:+41 41 785 13 13\nfax:+41 41 785 13 14\ninfo@eeteuroparts.ch\nhttp://www.eeteuroparts.ch"
      },
      "date": 1695364955569
    },
    {
      "type": "add",
      "id": "b81b430e05035b49",
      "item": {
        "type": "paragraph",
        "id": "b81b430e05035b49",
        "text": "Swissparts AG\nDottikon\ntel:+41 56 616 72 11\nfax:+41 56 616 72 19\ninfo@swissparts.ch\nhttp://www.swissparts.ch"
      },
      "after": "cbfac31ac300b169",
      "date": 1695364956463
    },
    {
      "id": "b81b430e05035b49",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242",
        "420f7b2565abdae8",
        "24d124d834926d63",
        "ce54654ec8befa64",
        "a6a356cc83e6aeb1",
        "79b643439e2bffd5",
        "0f71fb4a6a9e0fca",
        "77414ba09e602e5b",
        "ebf4fe5bf6eac1b2",
        "c05a7fcbfe36a798",
        "f4cc98be865c1a5e",
        "664ee1bb4f503286",
        "46e28fde57860bf0",
        "b81b430e05035b49",
        "cbfac31ac300b169"
      ],
      "date": 1695364958530
    },
    {
      "item": {
        "type": "factory",
        "id": "8ac5f816456e47e3"
      },
      "id": "8ac5f816456e47e3",
      "type": "add",
      "after": "cbfac31ac300b169",
      "date": 1695366418484
    },
    {
      "type": "edit",
      "id": "8ac5f816456e47e3",
      "item": {
        "type": "paragraph",
        "id": "8ac5f816456e47e3",
        "text": "~/workspace/khinsen/malleable-message-manage"
      },
      "date": 1695366424021
    },
    {
      "type": "remove",
      "id": "cbfac31ac300b169",
      "date": 1695366425243
    },
    {
      "item": {
        "type": "factory",
        "id": "1affe46f7a16d8be"
      },
      "id": "1affe46f7a16d8be",
      "type": "add",
      "after": "8ac5f816456e47e3",
      "date": 1695366426960
    },
    {
      "type": "edit",
      "id": "1affe46f7a16d8be",
      "item": {
        "type": "pagefold",
        "id": "1affe46f7a16d8be",
        "text": "~"
      },
      "date": 1695366429631
    },
    {
      "id": "1affe46f7a16d8be",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242",
        "420f7b2565abdae8",
        "24d124d834926d63",
        "ce54654ec8befa64",
        "a6a356cc83e6aeb1",
        "79b643439e2bffd5",
        "0f71fb4a6a9e0fca",
        "77414ba09e602e5b",
        "ebf4fe5bf6eac1b2",
        "c05a7fcbfe36a798",
        "f4cc98be865c1a5e",
        "664ee1bb4f503286",
        "46e28fde57860bf0",
        "b81b430e05035b49",
        "1affe46f7a16d8be",
        "8ac5f816456e47e3"
      ],
      "date": 1695366431758
    },
    {
      "type": "add",
      "id": "5663619169e40301",
      "item": {
        "type": "paragraph",
        "id": "5663619169e40301",
        "text": "A Common Lisp library for working with messages on Mastodon, e-mails, and RSS feeds.\n"
      },
      "after": "8ac5f816456e47e3",
      "date": 1695366464827
    },
    {
      "type": "edit",
      "id": "5663619169e40301",
      "item": {
        "type": "paragraph",
        "id": "5663619169e40301",
        "text": "A Common Lisp library for working with messages on Mastodon, e-mails, and RSS feeds."
      },
      "date": 1695366484115
    },
    {
      "type": "add",
      "id": "5b5652e39cc52ac9",
      "item": {
        "type": "paragraph",
        "id": "5b5652e39cc52ac9",
        "text": "[[Common Lisp Layer]]"
      },
      "after": "5663619169e40301",
      "date": 1695366487458
    },
    {
      "type": "edit",
      "id": "5663619169e40301",
      "item": {
        "type": "paragraph",
        "id": "5663619169e40301",
        "text": "A [[Common Lisp]] library for working with messages on Mastodon, e-mails, and RSS feeds."
      },
      "date": 1695367467315
    },
    {
      "type": "remove",
      "id": "5b5652e39cc52ac9",
      "date": 1695367505376
    },
    {
      "type": "edit",
      "id": "5663619169e40301",
      "item": {
        "type": "paragraph",
        "id": "5663619169e40301",
        "text": "A [[Common Lisp]] library for working with messages on Mastodon, e-mails, and RSS feeds. [⇐ [[Common Lisp Layer]]]"
      },
      "date": 1695367506431
    },
    {
      "type": "add",
      "id": "cbbee2e70b1f45d0",
      "item": {
        "type": "paragraph",
        "id": "cbbee2e70b1f45d0",
        "text": "Learn Common Lisp"
      },
      "after": "5663619169e40301",
      "date": 1695367563457
    },
    {
      "type": "edit",
      "id": "cbbee2e70b1f45d0",
      "item": {
        "type": "paragraph",
        "id": "cbbee2e70b1f45d0",
        "text": "Learn Common Lisp [https://lisp-lang.org/learn/ site]"
      },
      "date": 1695367571477
    },
    {
      "type": "edit",
      "id": "cbbee2e70b1f45d0",
      "item": {
        "type": "paragraph",
        "id": "cbbee2e70b1f45d0",
        "text": "Learn Common Lisp [https://lisp-lang.org/learn/ site], Lisp syntax"
      },
      "date": 1695367609324
    },
    {
      "type": "edit",
      "id": "cbbee2e70b1f45d0",
      "item": {
        "type": "paragraph",
        "id": "cbbee2e70b1f45d0",
        "text": "Learn Common Lisp [https://lisp-lang.org/learn/ site], Lisp syntax [https://lisp-lang.org/learn/first-steps page]"
      },
      "date": 1695367618860
    },
    {
      "type": "add",
      "id": "49eeb13eaa114a3b",
      "item": {
        "type": "paragraph",
        "id": "49eeb13eaa114a3b",
        "text": "> Syntax is made up of S-expressions. An S-expression is either an atom or a list."
      },
      "after": "cbbee2e70b1f45d0",
      "date": 1695367645244
    },
    {
      "type": "edit",
      "id": "49eeb13eaa114a3b",
      "item": {
        "type": "markdown",
        "id": "49eeb13eaa114a3b",
        "text": "> Syntax is made up of S-expressions. An S-expression is either an atom or a list."
      },
      "date": 1695367646826
    },
    {
      "type": "edit",
      "id": "49eeb13eaa114a3b",
      "item": {
        "type": "markdown",
        "id": "49eeb13eaa114a3b",
        "text": "> Syntax is made up of [[S-expressions]]. An S-expression is either an atom or a list."
      },
      "date": 1695367656276
    },
    {
      "type": "edit",
      "id": "49eeb13eaa114a3b",
      "item": {
        "type": "markdown",
        "id": "49eeb13eaa114a3b",
        "text": "> Syntax is made up of [[S-expression]]s. An S-expression is either an atom or a list."
      },
      "date": 1695367663601
    },
    {
      "item": {
        "type": "factory",
        "id": "136406d907815ae2"
      },
      "id": "136406d907815ae2",
      "type": "add",
      "after": "49eeb13eaa114a3b",
      "date": 1695367700201
    },
    {
      "type": "edit",
      "id": "136406d907815ae2",
      "item": {
        "type": "code",
        "id": "136406d907815ae2",
        "text": "; SLIME 2.28\nCL-USER> (format t \"Hello, world!\")\nHello, world!\nNIL\nCL-USER> "
      },
      "date": 1695367701882
    },
    {
      "item": {
        "type": "factory",
        "id": "6941cf47f912742a"
      },
      "id": "6941cf47f912742a",
      "type": "add",
      "after": "136406d907815ae2",
      "date": 1695367733104
    },
    {
      "type": "edit",
      "id": "6941cf47f912742a",
      "item": {
        "type": "paragraph",
        "id": "6941cf47f912742a",
        "text": "Note: t (the truth constant)"
      },
      "date": 1695367751641
    },
    {
      "type": "add",
      "id": "1a23ad453908cedb",
      "item": {
        "type": "paragraph",
        "id": "1a23ad453908cedb",
        "text": "Truth constants are considered as atomic formulas?"
      },
      "after": "6941cf47f912742a",
      "date": 1695367805176
    },
    {
      "type": "edit",
      "id": "1a23ad453908cedb",
      "item": {
        "type": "paragraph",
        "id": "1a23ad453908cedb",
        "text": "Truth constants are considered as atomic formulas? [https://math.stackexchange.com/questions/2503085/truth-constants-are-considered-as-atomic-formulas stackexchange]"
      },
      "date": 1695367820647
    },
    {
      "item": {
        "type": "factory",
        "id": "925c6ece534bcbc3"
      },
      "id": "925c6ece534bcbc3",
      "type": "add",
      "after": "1a23ad453908cedb",
      "date": 1695367862065
    },
    {
      "type": "edit",
      "id": "925c6ece534bcbc3",
      "item": {
        "type": "paragraph",
        "id": "925c6ece534bcbc3",
        "text": "There are actually three ways in which you can treat the ⊥ (and same for ⊤, if that is part of your language)."
      },
      "date": 1695367863592
    },
    {
      "item": {
        "type": "factory",
        "id": "40c8e9514facef5b"
      },
      "id": "40c8e9514facef5b",
      "type": "add",
      "after": "925c6ece534bcbc3",
      "date": 1695368184021
    },
    {
      "type": "edit",
      "id": "40c8e9514facef5b",
      "item": {
        "type": "paragraph",
        "id": "40c8e9514facef5b",
        "text": "Package QL does not exist."
      },
      "date": 1695368191170
    },
    {
      "type": "edit",
      "id": "40c8e9514facef5b",
      "item": {
        "type": "paragraph",
        "id": "40c8e9514facef5b",
        "text": "Package QL does not exist. [https://github.com/jupyter/jupyter_console/issues/252 page]"
      },
      "date": 1695368244813
    },
    {
      "type": "edit",
      "id": "40c8e9514facef5b",
      "item": {
        "type": "paragraph",
        "id": "40c8e9514facef5b",
        "text": "Package QL does not exist."
      },
      "date": 1695368305336
    },
    {
      "type": "add",
      "id": "5d2b42df7be8e2af",
      "item": {
        "type": "paragraph",
        "id": "5d2b42df7be8e2af",
        "text": "Confused about ``ql:quickload`` and executable scripts in SBCL"
      },
      "after": "40c8e9514facef5b",
      "date": 1695368307710
    },
    {
      "type": "edit",
      "id": "5d2b42df7be8e2af",
      "item": {
        "type": "paragraph",
        "id": "5d2b42df7be8e2af",
        "text": "Confused about ``ql:quickload`` and executable scripts in SBCL [https://stackoverflow.com/questions/25858237/confused-about-qlquickload-and-executable-scripts-in-sbcl stackoverflow]"
      },
      "date": 1695368318449
    },
    {
      "type": "add",
      "id": "5765d3147cdc8573",
      "item": {
        "type": "paragraph",
        "id": "5765d3147cdc8573",
        "text": "Quicklisp is a library manager for Common Lisp. It works with your existing Common Lisp implementation to download, install, and load any of over 1,500 libraries with a few simple commands."
      },
      "after": "5d2b42df7be8e2af",
      "date": 1695368418015
    },
    {
      "type": "edit",
      "id": "5765d3147cdc8573",
      "item": {
        "type": "paragraph",
        "id": "5765d3147cdc8573",
        "text": "Quicklisp is a library manager for Common Lisp. It works with your existing Common Lisp implementation to download, install, and load any of over 1,500 libraries with a few simple commands. [https://www.quicklisp.org/beta/ site]"
      },
      "date": 1695368427485
    },
    {
      "type": "edit",
      "id": "cbbee2e70b1f45d0",
      "item": {
        "type": "paragraph",
        "id": "cbbee2e70b1f45d0",
        "text": "Learn Common Lisp [https://lisp-lang.org/learn/ site], [[Lisp]] syntax [https://lisp-lang.org/learn/first-steps page]"
      },
      "date": 1695368538359
    },
    {
      "item": {
        "type": "factory",
        "id": "b61a0278d98c6f44"
      },
      "id": "b61a0278d98c6f44",
      "type": "add",
      "after": "5765d3147cdc8573",
      "date": 1695368966005
    },
    {
      "type": "edit",
      "id": "b61a0278d98c6f44",
      "item": {
        "type": "reference",
        "id": "b61a0278d98c6f44",
        "site": "wiki.ralfbarkow.ch",
        "slug": "lambda-browsing",
        "title": "Lambda Browsing",
        "text": "Here is the page that is the template for main navigational diagram used in this wiki. Changes to the code in this diagram will change the drawing of all those diagrams that reference this page. (Cf. [[Preview Next Diagram]])"
      },
      "date": 1695368977288
    },
    {
      "item": {
        "type": "factory",
        "id": "d72017b4fd6b0c25"
      },
      "id": "d72017b4fd6b0c25",
      "type": "add",
      "after": "b61a0278d98c6f44",
      "date": 1695369046751
    },
    {
      "type": "remove",
      "id": "d72017b4fd6b0c25",
      "date": 1695369052337
    },
    {
      "item": {
        "type": "factory",
        "id": "b4668dc4dcf6cefa"
      },
      "id": "b4668dc4dcf6cefa",
      "type": "add",
      "after": "b61a0278d98c6f44",
      "date": 1695371810962
    },
    {
      "type": "edit",
      "id": "b4668dc4dcf6cefa",
      "item": {
        "type": "pagefold",
        "id": "b4668dc4dcf6cefa",
        "text": "~"
      },
      "date": 1695371814114
    },
    {
      "item": {
        "type": "factory",
        "id": "b597fba759e7a6c6"
      },
      "id": "b597fba759e7a6c6",
      "type": "add",
      "after": "b4668dc4dcf6cefa",
      "date": 1695371815859
    },
    {
      "type": "edit",
      "id": "b597fba759e7a6c6",
      "item": {
        "type": "paragraph",
        "id": "b597fba759e7a6c6",
        "text": "Encode of a recursive-descent parser with limited backtracking in the Elm programming language."
      },
      "date": 1695371817927
    },
    {
      "item": {
        "type": "factory",
        "id": "d0ace9c553caddef"
      },
      "id": "d0ace9c553caddef",
      "type": "add",
      "after": "b597fba759e7a6c6",
      "date": 1695371826874
    },
    {
      "type": "edit",
      "id": "d0ace9c553caddef",
      "item": {
        "type": "paragraph",
        "id": "d0ace9c553caddef",
        "text": "Certainly! Below is an example of a simple recursive-descent parser with limited backtracking written in the Elm programming language. This parser can recognize a simple arithmetic expression consisting of addition and multiplication operations. […] ("
      },
      "date": 1695371833078
    },
    {
      "type": "edit",
      "id": "d0ace9c553caddef",
      "item": {
        "type": "paragraph",
        "id": "d0ace9c553caddef",
        "text": "Certainly! Below is an example of a simple recursive-descent parser with limited backtracking written in the Elm programming language. This parser can recognize a simple arithmetic expression consisting of addition and multiplication operations. […] (Chat"
      },
      "date": 1695371841038
    },
    {
      "type": "edit",
      "id": "d0ace9c553caddef",
      "item": {
        "type": "paragraph",
        "id": "d0ace9c553caddef",
        "text": "Certainly! Below is an example of a simple recursive-descent parser with limited backtracking written in the Elm programming language. This parser can recognize a simple arithmetic expression consisting of addition and multiplication operations. […] (ChatGPT)"
      },
      "date": 1695371850969
    },
    {
      "type": "edit",
      "id": "b597fba759e7a6c6",
      "item": {
        "type": "paragraph",
        "id": "b597fba759e7a6c6",
        "text": "Encode a recursive-descent parser with limited backtracking in the Elm programming language."
      },
      "date": 1695371865319
    },
    {
      "item": {
        "type": "factory",
        "id": "e4f25f0821f9d2ce"
      },
      "id": "e4f25f0821f9d2ce",
      "type": "add",
      "after": "d0ace9c553caddef",
      "date": 1695374237699
    },
    {
      "type": "edit",
      "id": "e4f25f0821f9d2ce",
      "item": {
        "type": "paragraph",
        "id": "e4f25f0821f9d2ce",
        "text": "[[Missing Closing Parenthesis]]"
      },
      "date": 1695374252575
    },
    {
      "type": "add",
      "id": "8d525f738d36c4d6",
      "item": {
        "type": "paragraph",
        "id": "8d525f738d36c4d6",
        "text": "Correction to"
      },
      "after": "e4f25f0821f9d2ce",
      "date": 1695374352204
    },
    {
      "type": "edit",
      "id": "8d525f738d36c4d6",
      "item": {
        "type": "paragraph",
        "id": "8d525f738d36c4d6",
        "text": "Correction to: …, e.g. "
      },
      "date": 1695374362438
    },
    {
      "type": "edit",
      "id": "8d525f738d36c4d6",
      "item": {
        "type": "paragraph",
        "id": "8d525f738d36c4d6",
        "text": "Correction to: …, e.g. In section x.y, a missing closing parenthesis has been included."
      },
      "date": 1695374377236
    },
    {
      "item": {
        "type": "factory",
        "id": "81551d17a9fb92e8"
      },
      "id": "81551d17a9fb92e8",
      "type": "add",
      "after": "8d525f738d36c4d6",
      "date": 1695375166978
    },
    {
      "type": "edit",
      "id": "81551d17a9fb92e8",
      "item": {
        "type": "paragraph",
        "id": "81551d17a9fb92e8",
        "text": "\nMAGNIEZ, Frédéric, MATHIEU, Claire and NAYAK, Ashwin, 2010. Recognizing well-parenthesized expressions in the streaming model. In: Proceedings of the forty-second ACM symposium on Theory of computing. Online. New York, NY, USA: Association for Computing Machinery. 5 June 2010. p. 261–270. [Accessed 22 September 2023]. STOC ’10. ISBN 978-1-4503-0050-6. DOI 10.1145/1806689.1806727. Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of parenthesis. We present a one-pass randomized streaming algorithm for Dyck(2) with space O(√ n log(n)) bits, time per letter polylog(n), and one-sided error. We prove that this one-pass algorithm is optimal, up to a log(n) factor, even when two-sided error is allowed, and conjecture that a similar bound holds for any constant number of passes over the input. Surprisingly, the space requirement shrinks drastically if we have access to the input stream “in reverse”. We present a two-pass randomized streaming algorithm for Dyck(2) with space O((log n)2), time polylog(n) and one-sided error, where the second pass is in the reverse direction. Both algorithms can be extended to Dyck(s) since this problem is reducible to Dyck(2) for a suitable notion of reduction in the streaming model. Except for an extra O(√ log(s)) multiplicative overhead in the space required in the one-pass algorithm, the resource requirements are of the same order. For the lower bound, we exhibit hard instances Ascension(m) of Dyck(2) with length Θ(mn). We embed these in what we call a “one-pass” communication problem with 2m-players, where m=~O(n). To establish the hardness of Ascension(m), we prove a direct sum result by following the “information cost” approach, but with a few twists. Indeed, we play a subtle game between public and private coins for Mountain, which corresponds to a primitive instance Ascension(1). This mixture between public and private coins for m results from a balancing act between the direct sum result and a combinatorial lower bound for m.\n"
      },
      "date": 1695375169236
    },
    {
      "type": "edit",
      "id": "81551d17a9fb92e8",
      "item": {
        "type": "paragraph",
        "id": "81551d17a9fb92e8",
        "text": "MAGNIEZ, Frédéric, MATHIEU, Claire and NAYAK, Ashwin, 2010. Recognizing well-parenthesized expressions in the streaming model. In: Proceedings of the forty-second ACM symposium on Theory of computing. Online. New York, NY, USA: Association for Computing Machinery. 5 June 2010. p. 261–270. [Accessed 22 September 2023]. STOC ’10. ISBN 978-1-4503-0050-6. DOI 10.1145/1806689.1806727. Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of parenthesis. We present a one-pass randomized streaming algorithm for Dyck(2) with space O(√ n log(n)) bits, time per letter polylog(n), and one-sided error. We prove that this one-pass algorithm is optimal, up to a log(n) factor, even when two-sided error is allowed, and conjecture that a similar bound holds for any constant number of passes over the input. Surprisingly, the space requirement shrinks drastically if we have access to the input stream “in reverse”. We present a two-pass randomized streaming algorithm for Dyck(2) with space O((log n)2), time polylog(n) and one-sided error, where the second pass is in the reverse direction. Both algorithms can be extended to Dyck(s) since this problem is reducible to Dyck(2) for a suitable notion of reduction in the streaming model. Except for an extra O(√ log(s)) multiplicative overhead in the space required in the one-pass algorithm, the resource requirements are of the same order. For the lower bound, we exhibit hard instances Ascension(m) of Dyck(2) with length Θ(mn). We embed these in what we call a “one-pass” communication problem with 2m-players, where m=~O(n). To establish the hardness of Ascension(m), we prove a direct sum result by following the “information cost” approach, but with a few twists. Indeed, we play a subtle game between public and private coins for Mountain, which corresponds to a primitive instance Ascension(1). This mixture between public and private coins for m results from a balancing act between the direct sum result and a combinatorial lower bound for m.\n"
      },
      "date": 1695375217332
    },
    {
      "item": {
        "type": "factory",
        "id": "0727197588887da1"
      },
      "id": "0727197588887da1",
      "type": "add",
      "after": "81551d17a9fb92e8",
      "date": 1695375833781
    },
    {
      "type": "edit",
      "id": "0727197588887da1",
      "item": {
        "type": "paragraph",
        "id": "0727197588887da1",
        "text": "Abstract Data Structures: Stacks"
      },
      "date": 1695375838058
    },
    {
      "type": "edit",
      "id": "0727197588887da1",
      "item": {
        "type": "paragraph",
        "id": "0727197588887da1",
        "text": "Abstract Data Structures: Stacks [https://elm-stack.surge.sh site]"
      },
      "date": 1695375847929
    },
    {
      "type": "edit",
      "id": "0727197588887da1",
      "item": {
        "type": "paragraph",
        "id": "0727197588887da1",
        "text": "Abstract Data Structures: Stacks [https://elm-stack.surge.sh site], [https://github.com/mhoare/elm-stack github]"
      },
      "date": 1695376409679
    },
    {
      "type": "add",
      "id": "eba13b32db4fed8d",
      "item": {
        "type": "paragraph",
        "id": "eba13b32db4fed8d",
        "text": "> The item must be of the same type as the stack."
      },
      "after": "0727197588887da1",
      "date": 1695376502687
    },
    {
      "type": "edit",
      "id": "eba13b32db4fed8d",
      "item": {
        "type": "markdown",
        "id": "eba13b32db4fed8d",
        "text": "> The item must be of the same type as the stack."
      },
      "date": 1695376503896
    },
    {
      "item": {
        "type": "factory",
        "id": "8107ffac3a74ad44"
      },
      "id": "8107ffac3a74ad44",
      "type": "add",
      "after": "eba13b32db4fed8d",
      "date": 1695376533416
    },
    {
      "type": "edit",
      "id": "8107ffac3a74ad44",
      "item": {
        "type": "code",
        "id": "8107ffac3a74ad44",
        "text": "{-| Removes the item at the top of the stack and returns it as the first item of a tuple.\n-}\npop : Stack a -> ( Maybe a, Stack a )\npop (Stack stack) =\n    case stack of\n        [] ->\n            ( Nothing, Stack [] )\n\n        head :: tail ->\n            ( Just head, Stack tail )"
      },
      "date": 1695376535478
    },
    {
      "type": "edit",
      "id": "0727197588887da1",
      "item": {
        "type": "paragraph",
        "id": "0727197588887da1",
        "text": "Abstract Data Structures: Stacks [https://elm-stack.surge.sh site], [https://github.com/mhoare/elm-stack github], [https://package.elm-lang.org/packages/mhoare/elm-stack/latest/Stack package]"
      },
      "date": 1695377183490
    },
    {
      "type": "edit",
      "id": "0727197588887da1",
      "item": {
        "type": "paragraph",
        "id": "0727197588887da1",
        "text": "Abstract Data Structures: Stacks [https://elm-stack.surge.sh site], [https://github.com/mhoare/elm-stack github], [https://package.elm-lang.org/packages/mhoare/elm-stack/latest/Stack package] ⇒ [[Elm Stack]]"
      },
      "date": 1695377224236
    },
    {
      "type": "add",
      "id": "25676a8499bc8f57",
      "item": {
        "type": "paragraph",
        "id": "25676a8499bc8f57",
        "text": "[[Investigate the Problem Dyck(s) Of Checking Matching Parentheses]]"
      },
      "after": "8d525f738d36c4d6",
      "date": 1695377825072
    },
    {
      "id": "81551d17a9fb92e8",
      "type": "remove",
      "removedTo": {
        "page": "Investigate the Problem Dyck(s) Of Checking Matching Parentheses"
      },
      "date": 1695377875451
    },
    {
      "type": "edit",
      "id": "25676a8499bc8f57",
      "item": {
        "type": "paragraph",
        "id": "25676a8499bc8f57",
        "text": "⇒ [[Investigate the Problem Dyck(s) Of Checking Matching Parentheses]]"
      },
      "date": 1695377893256
    },
    {
      "item": {
        "type": "factory",
        "id": "dc1b57b96b87789e"
      },
      "id": "dc1b57b96b87789e",
      "type": "add",
      "after": "8107ffac3a74ad44",
      "date": 1695378454728
    },
    {
      "type": "edit",
      "id": "dc1b57b96b87789e",
      "item": {
        "type": "reference",
        "id": "dc1b57b96b87789e",
        "site": "wiki.ralfbarkow.ch",
        "slug": "parenthesis",
        "title": "Parenthesis",
        "text": "is the only typographical delimiter that changes meaning across two different systems. (Bricken, [[Iconic Arithmetic]] Volume I, p. 84N5)"
      },
      "date": 1695378457401
    },
    {
      "item": {
        "type": "factory",
        "id": "d034b266eee76e9a"
      },
      "id": "d034b266eee76e9a",
      "type": "add",
      "after": "dc1b57b96b87789e",
      "date": 1695378459144
    },
    {
      "type": "edit",
      "id": "d034b266eee76e9a",
      "item": {
        "type": "paragraph",
        "id": "d034b266eee76e9a",
        "text": "A premiere example of a physically dysfunctional symbolic concept is the associative law of addition."
      },
      "date": 1695378470411
    },
    {
      "item": {
        "type": "factory",
        "id": "1b2f56a1ec32d6e0"
      },
      "id": "1b2f56a1ec32d6e0",
      "type": "add",
      "after": "d034b266eee76e9a",
      "date": 1695378483678
    },
    {
      "type": "edit",
      "id": "1b2f56a1ec32d6e0",
      "item": {
        "type": "code",
        "id": "1b2f56a1ec32d6e0",
        "text": "(a + b) + c = a + (b + c)"
      },
      "date": 1695378485387
    },
    {
      "item": {
        "type": "factory",
        "id": "58fd17feaa08433d"
      },
      "id": "58fd17feaa08433d",
      "type": "add",
      "after": "1b2f56a1ec32d6e0",
      "date": 1695378499878
    },
    {
      "type": "edit",
      "id": "58fd17feaa08433d",
      "item": {
        "type": "paragraph",
        "id": "58fd17feaa08433d",
        "text": "The parentheses used to assert this law create visual interference that undermines the meaning of addition, that of putting together. Putting things together twoat-a-time is not a property of addition. The associative law specifies a method to achieve addition, one that is not particularly efficient. The sequential two-at-a-time strategy might be because there are two sides to a textual plus sign; it might be because addition tables are constructed to add only two numbers at a time; it might be because relations are usually binary; it might be because group theory incorporates right- and left-side rules; or it might be a hangover from counting by adding one at a time. But here’s what we can learn from children. To a"
      },
      "date": 1695378501662
    },
    {
      "type": "edit",
      "id": "58fd17feaa08433d",
      "item": {
        "type": "paragraph",
        "id": "58fd17feaa08433d",
        "text": "The parentheses used to assert this law create visual interference that undermines the meaning of addition, that of putting together. Putting things together twoat-a-time is not a property of addition. The associative law specifies a method to achieve addition, one that is not particularly efficient. The sequential two-at-a-time strategy might be because there are two sides to a textual plus sign; it might be because addition tables are constructed to add only two numbers at a time; it might be because relations are usually binary; it might be because group theory incorporates right- and left-side rules; or it might be a hangover from counting by adding one at a time. But here’s what we can learn from children. To add many things, put them together. It doesn’t matter how."
      },
      "date": 1695378586678
    },
    {
      "type": "edit",
      "id": "58fd17feaa08433d",
      "item": {
        "type": "paragraph",
        "id": "58fd17feaa08433d",
        "text": "The parentheses used to assert this law create visual interference that undermines the meaning of addition, that of putting together. Putting things together twoat-a-time is not a property of addition. The associative law specifies a method to achieve addition, one that is not particularly efficient. The sequential two-at-a-time strategy might be because there are two sides to a textual plus sign; it might be because addition tables are constructed to add only two numbers at a time; it might be because relations are usually binary; it might be because group theory incorporates right- and left-side rules; or it might be a hangover from counting by adding one at a time. But here’s what we can learn from children. To add many things, put them together. It doesn’t matter how. (, p. 10)"
      },
      "date": 1695378626942
    },
    {
      "type": "edit",
      "id": "58fd17feaa08433d",
      "item": {
        "type": "paragraph",
        "id": "58fd17feaa08433d",
        "text": "The parentheses used to assert this law create visual interference that undermines the meaning of addition, that of putting together. Putting things together twoat-a-time is not a property of addition. The associative law specifies a method to achieve addition, one that is not particularly efficient. The sequential two-at-a-time strategy might be because there are two sides to a textual plus sign; it might be because addition tables are constructed to add only two numbers at a time; it might be because relations are usually binary; it might be because group theory incorporates right- and left-side rules; or it might be a hangover from counting by adding one at a time. But here’s what we can learn from children. To add many things, put them together. It doesn’t matter how. (Bricken, [[Iconic Arithmetic]] Volume I,, p. 10)"
      },
      "date": 1695378641174
    },
    {
      "type": "edit",
      "id": "d034b266eee76e9a",
      "item": {
        "type": "paragraph",
        "id": "d034b266eee76e9a",
        "text": "⇒ [[Meaning of Addition]]"
      },
      "date": 1695378709156
    },
    {
      "type": "add",
      "id": "3f7aaca4ca660f67",
      "item": {
        "type": "paragraph",
        "id": "3f7aaca4ca660f67",
        "text": "A premiere example of a physically dysfunctional symbolic concept is the associative law of addition."
      },
      "after": "d034b266eee76e9a",
      "date": 1695378709789
    },
    {
      "id": "3f7aaca4ca660f67",
      "type": "remove",
      "removedTo": {
        "page": "Meaning of Addition"
      },
      "date": 1695378724422
    },
    {
      "id": "1b2f56a1ec32d6e0",
      "type": "remove",
      "removedTo": {
        "page": "Meaning of Addition"
      },
      "date": 1695378727072
    },
    {
      "id": "58fd17feaa08433d",
      "type": "remove",
      "removedTo": {
        "page": "Meaning of Addition"
      },
      "date": 1695378731405
    },
    {
      "item": {
        "type": "factory",
        "id": "bfa592d047c92588"
      },
      "id": "bfa592d047c92588",
      "type": "add",
      "after": "d034b266eee76e9a",
      "date": 1695380515351
    },
    {
      "type": "edit",
      "id": "bfa592d047c92588",
      "item": {
        "type": "reference",
        "id": "bfa592d047c92588",
        "site": "wiki.ralfbarkow.ch",
        "slug": "order-of-magnitude",
        "title": "Order of Magnitude",
        "text": "The order of magnitude of a digit within a conventional number identifies how many times that digit is multiplied by ten. Instead of increasing the power of a digit by moving to the next position on the left (thousands, hundreds, tens, units), depth-value increases power by depth of nesting. Crossing a boundary outward changes the order of magnitude by one power-of-ten, more generally by one power of an arbitrary base. 5283 in [[Positional Notation]] is (((5)2)8)3 in [[Depth-Value Notation]]. The depth-value form of 5003 is (((5)))3. The absence of a dig"
      },
      "date": 1695380518080
    },
    {
      "type": "edit",
      "id": "bfa592d047c92588",
      "item": {
        "type": "reference",
        "id": "bfa592d047c92588",
        "site": "wiki.ralfbarkow.ch",
        "slug": "order-of-magnitude",
        "title": "Order of Magnitude",
        "text": "The order of magnitude of a digit within a conventional number identifies how many times that digit is multiplied by ten. Instead of increasing the power of a digit by moving to the next position on the left (thousands, hundreds, tens, units), depth-value increases power by depth of nesting. Crossing a boundary outward changes the order of magnitude by one power-of-ten, more generally by one power of an arbitrary base. 5283 in [[Positional Notation]] is (((5)2)8)3 in [[Depth-Value Notation]]. The depth-value form of 5003 is (((5)))3. "
      },
      "date": 1695380539076
    },
    {
      "item": {
        "type": "factory",
        "id": "e4148d546b407aa4"
      },
      "id": "e4148d546b407aa4",
      "type": "add",
      "after": "bfa592d047c92588",
      "date": 1695380541047
    },
    {
      "type": "edit",
      "id": "e4148d546b407aa4",
      "item": {
        "type": "paragraph",
        "id": "e4148d546b407aa4",
        "text": "6. integrating boundary notation for large numbers with boundary operations on those numbers: The idea of nesting to convey the exponent of a number was present in Roman numerals. What we identify now as letters (I, V, X, L, C, M) were not letters to the Romans, but rather particular symbols, probably derived from marking tally sticks. I is not the letter I, it is a notch in a stick. V and X are each types of tally notches that are easy to distinguish when the tally stick is split in half. M, one thousand, evolved from ᴄIᴐ, which itself began as a circle drawn round a vertical stroke. The Romans used ᴄᴐ to stand in place of parentheses. Thus depth-value notation was in use over two thousand years ago. The Roman numeral for 10,000 is ᴄᴄIᴐᴐ, while 100,000 is ᴄᴄᴄIᴐᴐᴐ. F. Cajori (1928) A History of Mathematical Notations §51."
      },
      "date": 1695380542583
    },
    {
      "id": "7f4d91be07ed7e69",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "7f4d91be07ed7e69",
        "text": "Bricken, [[Iconic Arithmetic]] Volume I, p. 67–69."
      },
      "after": "bfa592d047c92588",
      "attribution": {
        "page": "Order of Magnitude"
      },
      "date": 1695380553874
    },
    {
      "type": "edit",
      "id": "7f4d91be07ed7e69",
      "item": {
        "type": "paragraph",
        "id": "7f4d91be07ed7e69",
        "text": "Bricken, [[Iconic Arithmetic]] Volume I, p. 84N6:"
      },
      "date": 1695380563322
    },
    {
      "item": {
        "type": "factory",
        "id": "1454f46074fe3f3d"
      },
      "id": "1454f46074fe3f3d",
      "type": "add",
      "after": "e4148d546b407aa4",
      "date": 1695380625484
    },
    {
      "type": "edit",
      "id": "1454f46074fe3f3d",
      "item": {
        "type": "image",
        "id": "1454f46074fe3f3d",
        "text": "Roman tally stick",
        "size": "thumbnail",
        "width": 183,
        "height": 92,
        "url": "/assets/plugins/image/278ed795fbee03227b34965229fcdbe5.jpg"
      },
      "date": 1695380652609
    },
    {
      "id": "1454f46074fe3f3d",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242",
        "420f7b2565abdae8",
        "24d124d834926d63",
        "ce54654ec8befa64",
        "a6a356cc83e6aeb1",
        "79b643439e2bffd5",
        "0f71fb4a6a9e0fca",
        "77414ba09e602e5b",
        "ebf4fe5bf6eac1b2",
        "c05a7fcbfe36a798",
        "f4cc98be865c1a5e",
        "664ee1bb4f503286",
        "46e28fde57860bf0",
        "b81b430e05035b49",
        "1affe46f7a16d8be",
        "8ac5f816456e47e3",
        "5663619169e40301",
        "cbbee2e70b1f45d0",
        "49eeb13eaa114a3b",
        "136406d907815ae2",
        "6941cf47f912742a",
        "1a23ad453908cedb",
        "925c6ece534bcbc3",
        "40c8e9514facef5b",
        "5d2b42df7be8e2af",
        "5765d3147cdc8573",
        "b61a0278d98c6f44",
        "b4668dc4dcf6cefa",
        "b597fba759e7a6c6",
        "d0ace9c553caddef",
        "e4f25f0821f9d2ce",
        "8d525f738d36c4d6",
        "25676a8499bc8f57",
        "0727197588887da1",
        "eba13b32db4fed8d",
        "8107ffac3a74ad44",
        "dc1b57b96b87789e",
        "d034b266eee76e9a",
        "bfa592d047c92588",
        "7f4d91be07ed7e69",
        "1454f46074fe3f3d",
        "e4148d546b407aa4"
      ],
      "date": 1695380664152
    },
    {
      "type": "edit",
      "id": "e4148d546b407aa4",
      "item": {
        "type": "paragraph",
        "id": "e4148d546b407aa4",
        "text": "6. integrating boundary notation for large numbers with boundary operations on those numbers: The idea of nesting to convey the exponent of a number was present in Roman numerals."
      },
      "date": 1695380681897
    },
    {
      "type": "add",
      "id": "86bdb9f1294a9891",
      "item": {
        "type": "paragraph",
        "id": "86bdb9f1294a9891",
        "text": "What we identify now as letters (I, V, X, L, C, M) were not letters to the Romans, but rather particular symbols, probably derived from marking tally sticks. I is not the letter I, it is a notch in a stick. V and X are each types of tally notches that are easy to distinguish when the tally stick is split in half. M, one thousand, evolved from ᴄIᴐ, which itself began as a circle drawn round a vertical stroke. The Romans used ᴄᴐ to stand in place of parentheses. Thus depth-value notation was in use over two thousand years ago. The Roman numeral for 10,000 is ᴄᴄIᴐᴐ, while 100,000 is ᴄᴄᴄIᴐᴐᴐ. F. Cajori (1928) A History of Mathematical Notations §51."
      },
      "after": "e4148d546b407aa4",
      "date": 1695380682722
    },
    {
      "id": "1454f46074fe3f3d",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242",
        "420f7b2565abdae8",
        "24d124d834926d63",
        "ce54654ec8befa64",
        "a6a356cc83e6aeb1",
        "79b643439e2bffd5",
        "0f71fb4a6a9e0fca",
        "77414ba09e602e5b",
        "ebf4fe5bf6eac1b2",
        "c05a7fcbfe36a798",
        "f4cc98be865c1a5e",
        "664ee1bb4f503286",
        "46e28fde57860bf0",
        "b81b430e05035b49",
        "1affe46f7a16d8be",
        "8ac5f816456e47e3",
        "5663619169e40301",
        "cbbee2e70b1f45d0",
        "49eeb13eaa114a3b",
        "136406d907815ae2",
        "6941cf47f912742a",
        "1a23ad453908cedb",
        "925c6ece534bcbc3",
        "40c8e9514facef5b",
        "5d2b42df7be8e2af",
        "5765d3147cdc8573",
        "b61a0278d98c6f44",
        "b4668dc4dcf6cefa",
        "b597fba759e7a6c6",
        "d0ace9c553caddef",
        "e4f25f0821f9d2ce",
        "8d525f738d36c4d6",
        "25676a8499bc8f57",
        "0727197588887da1",
        "eba13b32db4fed8d",
        "8107ffac3a74ad44",
        "dc1b57b96b87789e",
        "d034b266eee76e9a",
        "bfa592d047c92588",
        "7f4d91be07ed7e69",
        "e4148d546b407aa4",
        "1454f46074fe3f3d",
        "86bdb9f1294a9891"
      ],
      "date": 1695380685437
    },
    {
      "type": "edit",
      "id": "86bdb9f1294a9891",
      "item": {
        "type": "paragraph",
        "id": "86bdb9f1294a9891",
        "text": "What we identify now as letters (I, V, X, L, C, M) were not letters to the Romans, but rather particular symbols, probably derived from marking tally sticks. I is not the letter I, it is a notch in a stick. V and X are each types of tally notches that are easy to distinguish when the tally stick is split in half. M, one thousand, evolved from ᴄIᴐ, which itself began as a circle drawn round a vertical stroke. The Romans used ᴄᴐ to stand in place of [[Parentheses]]. Thus depth-value notation was in use over two thousand years ago. The Roman numeral for 10,000 is ᴄᴄIᴐᴐ, while 100,000 is ᴄᴄᴄIᴐᴐᴐ. F. Cajori (1928) A History of Mathematical Notations §51."
      },
      "date": 1695380742970
    },
    {
      "item": {
        "type": "factory",
        "id": "f8c5bfd678d30abf"
      },
      "id": "f8c5bfd678d30abf",
      "type": "add",
      "after": "86bdb9f1294a9891",
      "date": 1695381052235
    },
    {
      "type": "edit",
      "id": "f8c5bfd678d30abf",
      "item": {
        "type": "pagefold",
        "id": "f8c5bfd678d30abf",
        "text": "~"
      },
      "date": 1695381057654
    },
    {
      "item": {
        "type": "factory",
        "id": "eb5fab63184f1e3d"
      },
      "id": "eb5fab63184f1e3d",
      "type": "add",
      "after": "f8c5bfd678d30abf",
      "date": 1695381059765
    },
    {
      "type": "edit",
      "id": "eb5fab63184f1e3d",
      "item": {
        "type": "paragraph",
        "id": "eb5fab63184f1e3d",
        "text": "The primary change is to think of conventional arithmetic operations like addition or multiplication as extremely simple: one parallel put together for addition, one parallel put inside for multiplication. "
      },
      "date": 1695381061713
    },
    {
      "item": {
        "type": "factory",
        "id": "60f787b83b54106c"
      },
      "id": "60f787b83b54106c",
      "type": "add",
      "after": "eb5fab63184f1e3d",
      "date": 1695381104463
    },
    {
      "type": "edit",
      "id": "60f787b83b54106c",
      "item": {
        "type": "reference",
        "id": "60f787b83b54106c",
        "site": "wiki.ralfbarkow.ch",
        "slug": "parens-arithmetic",
        "title": "Parens Arithmetic",
        "text": "explicitly separates the operations of arithmetic from the standardization of how a number is written or displayed."
      },
      "date": 1695381107005
    },
    {
      "id": "60f787b83b54106c",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242",
        "420f7b2565abdae8",
        "24d124d834926d63",
        "ce54654ec8befa64",
        "a6a356cc83e6aeb1",
        "79b643439e2bffd5",
        "0f71fb4a6a9e0fca",
        "77414ba09e602e5b",
        "ebf4fe5bf6eac1b2",
        "c05a7fcbfe36a798",
        "f4cc98be865c1a5e",
        "664ee1bb4f503286",
        "46e28fde57860bf0",
        "b81b430e05035b49",
        "1affe46f7a16d8be",
        "8ac5f816456e47e3",
        "5663619169e40301",
        "cbbee2e70b1f45d0",
        "49eeb13eaa114a3b",
        "136406d907815ae2",
        "6941cf47f912742a",
        "1a23ad453908cedb",
        "925c6ece534bcbc3",
        "40c8e9514facef5b",
        "5d2b42df7be8e2af",
        "5765d3147cdc8573",
        "b61a0278d98c6f44",
        "b4668dc4dcf6cefa",
        "b597fba759e7a6c6",
        "d0ace9c553caddef",
        "e4f25f0821f9d2ce",
        "8d525f738d36c4d6",
        "25676a8499bc8f57",
        "0727197588887da1",
        "eba13b32db4fed8d",
        "8107ffac3a74ad44",
        "dc1b57b96b87789e",
        "d034b266eee76e9a",
        "bfa592d047c92588",
        "7f4d91be07ed7e69",
        "e4148d546b407aa4",
        "1454f46074fe3f3d",
        "86bdb9f1294a9891",
        "f8c5bfd678d30abf",
        "60f787b83b54106c",
        "eb5fab63184f1e3d"
      ],
      "date": 1695381108751
    },
    {
      "type": "edit",
      "id": "eb5fab63184f1e3d",
      "item": {
        "type": "paragraph",
        "id": "eb5fab63184f1e3d",
        "text": "> The primary change is to think of conventional arithmetic operations like addition or multiplication as extremely simple: one parallel put together for addition, one parallel put inside for multiplication. "
      },
      "date": 1695381113821
    },
    {
      "type": "edit",
      "id": "eb5fab63184f1e3d",
      "item": {
        "type": "markdown",
        "id": "eb5fab63184f1e3d",
        "text": "> The primary change is to think of conventional arithmetic operations like addition or multiplication as extremely simple: one parallel put together for addition, one parallel put inside for multiplication. "
      },
      "date": 1695381115629
    },
    {
      "id": "f8c5bfd678d30abf",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242",
        "420f7b2565abdae8",
        "24d124d834926d63",
        "ce54654ec8befa64",
        "a6a356cc83e6aeb1",
        "79b643439e2bffd5",
        "0f71fb4a6a9e0fca",
        "77414ba09e602e5b",
        "ebf4fe5bf6eac1b2",
        "c05a7fcbfe36a798",
        "f4cc98be865c1a5e",
        "664ee1bb4f503286",
        "46e28fde57860bf0",
        "b81b430e05035b49",
        "1affe46f7a16d8be",
        "8ac5f816456e47e3",
        "5663619169e40301",
        "cbbee2e70b1f45d0",
        "49eeb13eaa114a3b",
        "136406d907815ae2",
        "6941cf47f912742a",
        "1a23ad453908cedb",
        "925c6ece534bcbc3",
        "40c8e9514facef5b",
        "5d2b42df7be8e2af",
        "5765d3147cdc8573",
        "b61a0278d98c6f44",
        "b4668dc4dcf6cefa",
        "b597fba759e7a6c6",
        "d0ace9c553caddef",
        "e4f25f0821f9d2ce",
        "8d525f738d36c4d6",
        "25676a8499bc8f57",
        "0727197588887da1",
        "eba13b32db4fed8d",
        "8107ffac3a74ad44",
        "dc1b57b96b87789e",
        "d034b266eee76e9a",
        "bfa592d047c92588",
        "7f4d91be07ed7e69",
        "e4148d546b407aa4",
        "1454f46074fe3f3d",
        "86bdb9f1294a9891",
        "60f787b83b54106c",
        "eb5fab63184f1e3d",
        "f8c5bfd678d30abf"
      ],
      "date": 1695381122253
    },
    {
      "item": {
        "type": "factory",
        "id": "e6d51d4f85c21bbc"
      },
      "id": "e6d51d4f85c21bbc",
      "type": "add",
      "after": "f8c5bfd678d30abf",
      "date": 1695381130894
    },
    {
      "type": "edit",
      "id": "e6d51d4f85c21bbc",
      "item": {
        "type": "markdown",
        "id": "e6d51d4f85c21bbc",
        "text": "It seems like you're referring to a concept from Bricken's Iconic Arithmetic, which simplifies conventional arithmetic operations like addition and multiplication. In this approach, addition is represented as putting things together in parallel, and multiplication involves putting one thing inside another.\n\nThis way of thinking about arithmetic operations is a fundamental shift from the traditional view, which often involves carrying out multi-step algorithms. Instead, Bricken's approach emphasizes a more visual and intuitive understanding of arithmetic operations.\n\nFor example:\n\n- **Addition (Putting Together)**: Instead of carrying out a step-by-step addition algorithm, you might think of it as simply combining things side by side in a parallel arrangement.\n\n- **Multiplication (Putting Inside)**: Similarly, multiplication is viewed as putting one thing inside another. This could be visualized as fitting objects together, or placing objects in a container.\n\nThis approach can be especially useful for conceptualizing arithmetic operations in a more intuitive and visually accessible way. It may be particularly beneficial for learners who benefit from visual or spatial representations of mathematical concepts.\n\nRemember, Bricken's Iconic Arithmetic represents a unique and innovative approach to teaching and understanding mathematics. It's based on the idea of providing more intuitive and concrete representations for mathematical operations. If you're studying or interested in this approach, it could be a valuable tool for your mathematical understanding. (ChatGPT)"
      },
      "date": 1695381138056
    },
    {
      "type": "edit",
      "id": "e6d51d4f85c21bbc",
      "item": {
        "type": "markdown",
        "id": "e6d51d4f85c21bbc",
        "text": "It seems like you're referring to a concept from Bricken's Iconic Arithmetic, which simplifies conventional arithmetic operations like addition and multiplication. In this approach, addition is represented as putting things together in parallel [⇒ [[Lineup]], and multiplication involves putting one thing inside another.\n\nThis way of thinking about arithmetic operations is a fundamental shift from the traditional view, which often involves carrying out multi-step algorithms. Instead, Bricken's approach emphasizes a more visual and intuitive understanding of arithmetic operations.\n\nFor example:\n\n- **Addition (Putting Together)**: Instead of carrying out a step-by-step addition algorithm, you might think of it as simply combining things side by side in a parallel arrangement.\n\n- **Multiplication (Putting Inside)**: Similarly, multiplication is viewed as putting one thing inside another. This could be visualized as fitting objects together, or placing objects in a container.\n\nThis approach can be especially useful for conceptualizing arithmetic operations in a more intuitive and visually accessible way. It may be particularly beneficial for learners who benefit from visual or spatial representations of mathematical concepts.\n\nRemember, Bricken's Iconic Arithmetic represents a unique and innovative approach to teaching and understanding mathematics. It's based on the idea of providing more intuitive and concrete representations for mathematical operations. If you're studying or interested in this approach, it could be a valuable tool for your mathematical understanding. (ChatGPT)"
      },
      "date": 1695381173300
    },
    {
      "type": "edit",
      "id": "e6d51d4f85c21bbc",
      "item": {
        "type": "markdown",
        "id": "e6d51d4f85c21bbc",
        "text": "It seems like you're referring to a concept from Bricken's Iconic Arithmetic, which simplifies conventional arithmetic operations like addition and multiplication. In this approach, addition is represented as putting things together in parallel [⇒ [[Lineup]]], and multiplication involves putting one thing inside another.\n\nThis way of thinking about arithmetic operations is a fundamental shift from the traditional view, which often involves carrying out multi-step algorithms. Instead, Bricken's approach emphasizes a more visual and intuitive understanding of arithmetic operations.\n\nFor example:\n\n- **Addition (Putting Together)**: Instead of carrying out a step-by-step addition algorithm, you might think of it as simply combining things side by side in a parallel arrangement.\n\n- **Multiplication (Putting Inside)**: Similarly, multiplication is viewed as putting one thing inside another. This could be visualized as fitting objects together, or placing objects in a container.\n\nThis approach can be especially useful for conceptualizing arithmetic operations in a more intuitive and visually accessible way. It may be particularly beneficial for learners who benefit from visual or spatial representations of mathematical concepts.\n\nRemember, Bricken's Iconic Arithmetic represents a unique and innovative approach to teaching and understanding mathematics. It's based on the idea of providing more intuitive and concrete representations for mathematical operations. If you're studying or interested in this approach, it could be a valuable tool for your mathematical understanding. (ChatGPT)"
      },
      "date": 1695381178408
    },
    {
      "type": "edit",
      "id": "e6d51d4f85c21bbc",
      "item": {
        "type": "markdown",
        "id": "e6d51d4f85c21bbc",
        "text": "It seems like you're referring to a concept from Bricken's Iconic Arithmetic, which simplifies conventional arithmetic operations like addition and multiplication. In this approach, addition is represented as putting things together in parallel [⇒ [[Lineup]]], and multiplication involves putting one thing inside another [[.\n\nThis way of thinking about arithmetic operations is a fundamental shift from the traditional view, which often involves carrying out multi-step algorithms. Instead, Bricken's approach emphasizes a more visual and intuitive understanding of arithmetic operations.\n\nFor example:\n\n- **Addition (Putting Together)**: Instead of carrying out a step-by-step addition algorithm, you might think of it as simply combining things side by side in a parallel arrangement.\n\n- **Multiplication (Putting Inside)**: Similarly, multiplication is viewed as putting one thing inside another. This could be visualized as fitting objects together, or placing objects in a container.\n\nThis approach can be especially useful for conceptualizing arithmetic operations in a more intuitive and visually accessible way. It may be particularly beneficial for learners who benefit from visual or spatial representations of mathematical concepts.\n\nRemember, Bricken's Iconic Arithmetic represents a unique and innovative approach to teaching and understanding mathematics. It's based on the idea of providing more intuitive and concrete representations for mathematical operations. If you're studying or interested in this approach, it could be a valuable tool for your mathematical understanding. (ChatGPT)"
      },
      "date": 1695381226723
    },
    {
      "type": "edit",
      "id": "e6d51d4f85c21bbc",
      "item": {
        "type": "markdown",
        "id": "e6d51d4f85c21bbc",
        "text": "It seems like you're referring to a concept from Bricken's Iconic Arithmetic, which simplifies conventional arithmetic operations like addition and multiplication. In this approach, addition is represented as putting things together in parallel [⇒ [[Lineup]]], and multiplication involves putting one thing inside another [⇒ [[Drag-and-Drop]]].\n\nThis way of thinking about arithmetic operations is a fundamental shift from the traditional view, which often involves carrying out multi-step algorithms. Instead, Bricken's approach emphasizes a more visual and intuitive understanding of arithmetic operations.\n\nFor example:\n\n- **Addition (Putting Together)**: Instead of carrying out a step-by-step addition algorithm, you might think of it as simply combining things side by side in a parallel arrangement.\n\n- **Multiplication (Putting Inside)**: Similarly, multiplication is viewed as putting one thing inside another. This could be visualized as fitting objects together, or placing objects in a container.\n\nThis approach can be especially useful for conceptualizing arithmetic operations in a more intuitive and visually accessible way. It may be particularly beneficial for learners who benefit from visual or spatial representations of mathematical concepts.\n\nRemember, Bricken's Iconic Arithmetic represents a unique and innovative approach to teaching and understanding mathematics. It's based on the idea of providing more intuitive and concrete representations for mathematical operations. If you're studying or interested in this approach, it could be a valuable tool for your mathematical understanding. (ChatGPT)"
      },
      "date": 1695381256629
    },
    {
      "type": "remove",
      "id": "eb5fab63184f1e3d",
      "date": 1695381355796
    },
    {
      "id": "b17cf9a231d314e7",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "b17cf9a231d314e7",
        "text": "The primary change is to think of conventional arithmetic operations like addition or multiplication as extremely simple: one parallel put together for addition, one parallel put inside for multiplication. "
      },
      "after": "60f787b83b54106c",
      "attribution": {
        "page": "Parens Arithmetic"
      },
      "date": 1695381360891
    },
    {
      "type": "edit",
      "id": "b17cf9a231d314e7",
      "item": {
        "type": "paragraph",
        "id": "b17cf9a231d314e7",
        "text": "> The primary change is to think of conventional arithmetic operations like addition or multiplication as extremely simple: one parallel put together for addition, one parallel put inside for multiplication. "
      },
      "date": 1695381364790
    },
    {
      "type": "edit",
      "id": "b17cf9a231d314e7",
      "item": {
        "type": "markdown",
        "id": "b17cf9a231d314e7",
        "text": "> The primary change is to think of conventional arithmetic operations like addition or multiplication as extremely simple: one parallel put together for addition, one parallel put inside for multiplication. "
      },
      "date": 1695381365749
    },
    {
      "type": "edit",
      "id": "e6d51d4f85c21bbc",
      "item": {
        "type": "markdown",
        "id": "e6d51d4f85c21bbc",
        "text": "It seems like you're referring to a concept from Bricken's Iconic Arithmetic, which simplifies conventional arithmetic operations like addition and multiplication. In this approach, addition is represented as putting things together in parallel [⇒ [[Lineup]]], and multiplication involves putting one thing inside another [⇒ [[Drag-and-Drop]]].\n\nThis way of thinking about arithmetic operations is a fundamental shift from the traditional view, which often involves carrying out multi-step algorithms. Instead, Bricken's approach emphasizes a more visual and intuitive understanding of arithmetic operations.\n\nFor example:\n\n- **Addition (Putting Together)**: Instead of carrying out a step-by-step addition algorithm, you might think of it as simply combining things side by side in a parallel [[Arrangement]]. [⇒ [[Lineup]]]\n\n- **Multiplication (Putting Inside)**: Similarly, multiplication is viewed as putting one thing inside another. This could be visualized as fitting objects together, or placing objects in a [[Container]]. [⇒ [[Drag-and-Drop]]]\n\nThis approach can be especially useful for conceptualizing arithmetic operations in a more intuitive and visually accessible way. It may be particularly beneficial for learners who benefit from visual or spatial representations of mathematical concepts.\n\nRemember, Bricken's Iconic Arithmetic represents a unique and innovative approach to teaching and understanding mathematics. It's based on the idea of providing more intuitive and concrete representations for mathematical operations. If you're studying or interested in this approach, it could be a valuable tool for your mathematical understanding. (ChatGPT)"
      },
      "date": 1695381515744
    },
    {
      "item": {
        "type": "factory",
        "id": "0e6ea36f98384adf"
      },
      "id": "0e6ea36f98384adf",
      "type": "add",
      "after": "e6d51d4f85c21bbc",
      "date": 1695381573570
    },
    {
      "type": "edit",
      "id": "0e6ea36f98384adf",
      "item": {
        "type": "pagefold",
        "id": "0e6ea36f98384adf",
        "text": "~"
      },
      "date": 1695381576057
    },
    {
      "id": "4245b38d014a0304",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "4245b38d014a0304",
        "text": "What is taught as addition is an amalgam of number facts, group theory, number theory, notational structure, bundle management, and pragmatic algorithms for knitting place-value numerals together.4 In contrast, unit-ensembles separate theory, structure and algorithm by using the generic tools of [[pattern-matching]] to enact transformations. We have also reverted to the original theory of numbers as additive ensembles of units. To isolate the structural mechanism of grouping units, we’ll introduce a new type of boundary that supports manipulation of groups. The parenthesis ( ), called parens, identifies groups and their base. But a word of caution, the parenthesis-bracket will have a different definition when we get to James algebra.5"
      },
      "after": "e6d51d4f85c21bbc",
      "attribution": {
        "page": "Meaning of Addition"
      },
      "date": 1695381581623
    },
    {
      "id": "0e6ea36f98384adf",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242",
        "420f7b2565abdae8",
        "24d124d834926d63",
        "ce54654ec8befa64",
        "a6a356cc83e6aeb1",
        "79b643439e2bffd5",
        "0f71fb4a6a9e0fca",
        "77414ba09e602e5b",
        "ebf4fe5bf6eac1b2",
        "c05a7fcbfe36a798",
        "f4cc98be865c1a5e",
        "664ee1bb4f503286",
        "46e28fde57860bf0",
        "b81b430e05035b49",
        "1affe46f7a16d8be",
        "8ac5f816456e47e3",
        "5663619169e40301",
        "cbbee2e70b1f45d0",
        "49eeb13eaa114a3b",
        "136406d907815ae2",
        "6941cf47f912742a",
        "1a23ad453908cedb",
        "925c6ece534bcbc3",
        "40c8e9514facef5b",
        "5d2b42df7be8e2af",
        "5765d3147cdc8573",
        "b61a0278d98c6f44",
        "b4668dc4dcf6cefa",
        "b597fba759e7a6c6",
        "d0ace9c553caddef",
        "e4f25f0821f9d2ce",
        "8d525f738d36c4d6",
        "25676a8499bc8f57",
        "0727197588887da1",
        "eba13b32db4fed8d",
        "8107ffac3a74ad44",
        "dc1b57b96b87789e",
        "d034b266eee76e9a",
        "bfa592d047c92588",
        "7f4d91be07ed7e69",
        "e4148d546b407aa4",
        "1454f46074fe3f3d",
        "86bdb9f1294a9891",
        "60f787b83b54106c",
        "b17cf9a231d314e7",
        "f8c5bfd678d30abf",
        "e6d51d4f85c21bbc",
        "0e6ea36f98384adf",
        "4245b38d014a0304"
      ],
      "date": 1695381583548
    },
    {
      "type": "edit",
      "id": "4245b38d014a0304",
      "item": {
        "type": "paragraph",
        "id": "4245b38d014a0304",
        "text": "What is taught as [[Addition]] is an amalgam of number facts, group theory, number theory, notational structure, bundle management, and pragmatic algorithms for knitting place-value numerals together.4 In contrast, unit-ensembles separate theory, structure and algorithm by using the generic tools of [[pattern-matching]] to enact transformations. We have also reverted to the original theory of numbers as additive ensembles of units. To isolate the structural mechanism of grouping units, we’ll introduce a new type of boundary that supports manipulation of groups. The parenthesis ( ), called parens, identifies groups and their base. But a word of caution, the parenthesis-bracket will have a different definition when we get to James algebra.5"
      },
      "date": 1695381594357
    },
    {
      "type": "edit",
      "id": "4245b38d014a0304",
      "item": {
        "type": "paragraph",
        "id": "4245b38d014a0304",
        "text": "What is taught as [[Addition]] is an amalgam of number facts, group theory, number theory, notational structure, bundle management, and pragmatic algorithms for knitting place-value numerals together.4 In contrast, unit-ensembles separate theory, structure and algorithm by using the generic tools of [[pattern-matching]] to enact transformations. We have also reverted to the original theory of numbers as additive ensembles of units. To isolate the structural mechanism of grouping units, we’ll introduce a new type of boundary that supports manipulation of groups. The parenthesis ( ), called parens, identifies groups and their base. But a word of caution, the parenthesis-bracket will have a different definition when we get to James algebra.5 (Bricken, [[Iconic Arithmetic]] Volume I, p. 66)"
      },
      "date": 1695381646748
    },
    {
      "type": "add",
      "id": "07c0f9ffef48e97b",
      "item": {
        "type": "paragraph",
        "id": "07c0f9ffef48e97b",
        "text": "⇒ Depth-value"
      },
      "after": "4245b38d014a0304",
      "date": 1695381665645
    },
    {
      "type": "edit",
      "id": "07c0f9ffef48e97b",
      "item": {
        "type": "paragraph",
        "id": "07c0f9ffef48e97b",
        "text": "⇒ Depth-value ⇒ [[Depth-Value Notation]]"
      },
      "date": 1695381688491
    },
    {
      "type": "add",
      "id": "89ce2baf2d87e711",
      "item": {
        "type": "paragraph",
        "id": "89ce2baf2d87e711",
        "text": "5. a different definition when we get to James algebra: Beginning in Chapter 5, we’ll redefine the parenthesis to be the basic numeric unit in the James system, calling it the round-bracket. The parenthesis is the only typographical delimiter that changes meaning across two different systems."
      },
      "after": "4245b38d014a0304",
      "date": 1695381750053
    },
    {
      "type": "edit",
      "id": "89ce2baf2d87e711",
      "item": {
        "type": "paragraph",
        "id": "89ce2baf2d87e711",
        "text": "5. a different definition when we get to James algebra: Beginning in Chapter 5, we’ll redefine the parenthesis to be the basic numeric unit in the James system, calling it the round-bracket. The parenthesis is the only typographical delimiter that changes meaning across two different systems. (Bricken, [[Iconic Arithmetic]] Volume I, p. 84N5)"
      },
      "date": 1695381775148
    },
    {
      "type": "edit",
      "id": "89ce2baf2d87e711",
      "item": {
        "type": "paragraph",
        "id": "89ce2baf2d87e711",
        "text": "5. a different definition when we get to James algebra: Beginning in Chapter 5, we’ll redefine the [[Parenthesis]] to be the basic numeric unit in the James system, calling it the round-bracket. The parenthesis is the only typographical delimiter that changes meaning across two different systems. (Bricken, [[Iconic Arithmetic]] Volume I, p. 84N5)"
      },
      "date": 1695381800166
    },
    {
      "item": {
        "type": "factory",
        "id": "021f95b342290b3b"
      },
      "id": "021f95b342290b3b",
      "type": "add",
      "after": "07c0f9ffef48e97b",
      "date": 1695384852503
    },
    {
      "type": "edit",
      "id": "021f95b342290b3b",
      "item": {
        "type": "code",
        "id": "021f95b342290b3b",
        "text": "type RoundBracket\n    = Parenthesis\n"
      },
      "date": 1695384856164
    },
    {
      "type": "add",
      "id": "bb3b373ea24eb1d9",
      "item": {
        "type": "paragraph",
        "id": "bb3b373ea24eb1d9",
        "text": "Dyck Tests [commit]"
      },
      "after": "07c0f9ffef48e97b",
      "date": 1695384897703
    },
    {
      "type": "edit",
      "id": "bb3b373ea24eb1d9",
      "item": {
        "type": "paragraph",
        "id": "bb3b373ea24eb1d9",
        "text": "Dyck Tests [commit] (created by the LLM + me)"
      },
      "date": 1695384924155
    },
    {
      "type": "edit",
      "id": "bb3b373ea24eb1d9",
      "item": {
        "type": "paragraph",
        "id": "bb3b373ea24eb1d9",
        "text": "Dyck Tests [commit] (created by a LLM + me)"
      },
      "date": 1695384932176
    },
    {
      "type": "edit",
      "id": "bb3b373ea24eb1d9",
      "item": {
        "type": "paragraph",
        "id": "bb3b373ea24eb1d9",
        "text": "Dyck Tests [https://github.com/RalfBarkow/vite-elm-dojo/commit/d54714da26655bf77b97c54e2d1a8f7df4cd8045 commit] (created by a LLM + me)"
      },
      "date": 1695385013620
    },
    {
      "type": "edit",
      "id": "021f95b342290b3b",
      "item": {
        "type": "code",
        "id": "021f95b342290b3b",
        "text": "type Parenthesis\n    = RoundBracket"
      },
      "date": 1695385889111
    },
    {
      "item": {
        "type": "factory",
        "id": "ffeeb583bd6b9e67"
      },
      "id": "ffeeb583bd6b9e67",
      "type": "add",
      "after": "021f95b342290b3b",
      "date": 1695385901145
    },
    {
      "type": "edit",
      "id": "ffeeb583bd6b9e67",
      "item": {
        "type": "reference",
        "id": "ffeeb583bd6b9e67",
        "site": "wiki.ralfbarkow.ch",
        "slug": "parenthesis",
        "title": "Parenthesis",
        "text": "is the only typographical delimiter that changes meaning across two different systems. (Bricken, [[Iconic Arithmetic]] Volume I, p. 84N5)"
      },
      "date": 1695385903612
    },
    {
      "id": "ffeeb583bd6b9e67",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242",
        "420f7b2565abdae8",
        "24d124d834926d63",
        "ce54654ec8befa64",
        "a6a356cc83e6aeb1",
        "79b643439e2bffd5",
        "0f71fb4a6a9e0fca",
        "77414ba09e602e5b",
        "ebf4fe5bf6eac1b2",
        "c05a7fcbfe36a798",
        "f4cc98be865c1a5e",
        "664ee1bb4f503286",
        "46e28fde57860bf0",
        "b81b430e05035b49",
        "1affe46f7a16d8be",
        "8ac5f816456e47e3",
        "5663619169e40301",
        "cbbee2e70b1f45d0",
        "49eeb13eaa114a3b",
        "136406d907815ae2",
        "6941cf47f912742a",
        "1a23ad453908cedb",
        "925c6ece534bcbc3",
        "40c8e9514facef5b",
        "5d2b42df7be8e2af",
        "5765d3147cdc8573",
        "b61a0278d98c6f44",
        "b4668dc4dcf6cefa",
        "b597fba759e7a6c6",
        "d0ace9c553caddef",
        "e4f25f0821f9d2ce",
        "8d525f738d36c4d6",
        "25676a8499bc8f57",
        "0727197588887da1",
        "eba13b32db4fed8d",
        "8107ffac3a74ad44",
        "dc1b57b96b87789e",
        "d034b266eee76e9a",
        "bfa592d047c92588",
        "7f4d91be07ed7e69",
        "e4148d546b407aa4",
        "1454f46074fe3f3d",
        "86bdb9f1294a9891",
        "60f787b83b54106c",
        "b17cf9a231d314e7",
        "f8c5bfd678d30abf",
        "e6d51d4f85c21bbc",
        "0e6ea36f98384adf",
        "4245b38d014a0304",
        "89ce2baf2d87e711",
        "07c0f9ffef48e97b",
        "bb3b373ea24eb1d9",
        "ffeeb583bd6b9e67",
        "021f95b342290b3b"
      ],
      "date": 1695385905459
    },
    {
      "type": "add",
      "id": "ac893e078874b7f1",
      "item": {
        "type": "paragraph",
        "id": "ac893e078874b7f1",
        "text": "refactor: redefine the Parenthesis "
      },
      "after": "bb3b373ea24eb1d9",
      "date": 1695385972421
    },
    {
      "id": "ac893e078874b7f1",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242",
        "420f7b2565abdae8",
        "24d124d834926d63",
        "ce54654ec8befa64",
        "a6a356cc83e6aeb1",
        "79b643439e2bffd5",
        "0f71fb4a6a9e0fca",
        "77414ba09e602e5b",
        "ebf4fe5bf6eac1b2",
        "c05a7fcbfe36a798",
        "f4cc98be865c1a5e",
        "664ee1bb4f503286",
        "46e28fde57860bf0",
        "b81b430e05035b49",
        "1affe46f7a16d8be",
        "8ac5f816456e47e3",
        "5663619169e40301",
        "cbbee2e70b1f45d0",
        "49eeb13eaa114a3b",
        "136406d907815ae2",
        "6941cf47f912742a",
        "1a23ad453908cedb",
        "925c6ece534bcbc3",
        "40c8e9514facef5b",
        "5d2b42df7be8e2af",
        "5765d3147cdc8573",
        "b61a0278d98c6f44",
        "b4668dc4dcf6cefa",
        "b597fba759e7a6c6",
        "d0ace9c553caddef",
        "e4f25f0821f9d2ce",
        "8d525f738d36c4d6",
        "25676a8499bc8f57",
        "0727197588887da1",
        "eba13b32db4fed8d",
        "8107ffac3a74ad44",
        "dc1b57b96b87789e",
        "d034b266eee76e9a",
        "bfa592d047c92588",
        "7f4d91be07ed7e69",
        "e4148d546b407aa4",
        "1454f46074fe3f3d",
        "86bdb9f1294a9891",
        "60f787b83b54106c",
        "b17cf9a231d314e7",
        "f8c5bfd678d30abf",
        "e6d51d4f85c21bbc",
        "0e6ea36f98384adf",
        "4245b38d014a0304",
        "89ce2baf2d87e711",
        "07c0f9ffef48e97b",
        "bb3b373ea24eb1d9",
        "ffeeb583bd6b9e67",
        "ac893e078874b7f1",
        "021f95b342290b3b"
      ],
      "date": 1695385974140
    },
    {
      "type": "edit",
      "id": "ac893e078874b7f1",
      "item": {
        "type": "paragraph",
        "id": "ac893e078874b7f1",
        "text": "refactor: redefine the Parenthesis [https://github.com/RalfBarkow/vite-elm-dojo/commit/f63a4c6327c65eb0f0e5f1ecd3b765f4d5dba064 commit]"
      },
      "date": 1695385983248
    },
    {
      "item": {
        "type": "factory",
        "id": "9b12df081e9e4850"
      },
      "id": "9b12df081e9e4850",
      "type": "add",
      "after": "021f95b342290b3b",
      "date": 1695386004738
    },
    {
      "type": "edit",
      "id": "9b12df081e9e4850",
      "item": {
        "type": "markdown",
        "id": "9b12df081e9e4850",
        "text": "The `isDyck` function is used to determine if a list of `Parenthesis` forms a valid Dyck sequence. In Dyck language theory, a Dyck word is a string consisting of balanced pairs of characters, such as parentheses. For example, `((()))` and `()()()` are valid Dyck words, while `(()(` and `())(` are not.\n\nHere's how the `isDyck` function works:\n\n1. **Type Signature**:\n   ```elm\n   isDyck : List Parenthesis -> Bool\n   ```\n   This means `isDyck` is a function that takes a list of `Parenthesis` and returns a `Bool`.\n\n2. **Function Body**:\n   ```elm\n   isDyck input =\n       let\n           initState =\n               { stack = []\n               , isValid = True\n               }\n       in\n       let\n           state =\n               List.foldr updateState initState input\n       in\n       List.isEmpty state.stack && state.isValid\n   ```\n   - **`initState`**: This initializes the state with an empty stack and sets `isValid` to `True`.\n   - **`state`**: This variable is obtained by folding (`List.foldr`) the `updateState` function over the input list. `updateState` takes a `Parenthesis` and a `State`, and returns a modified `State` after applying the operation defined for `updateState`.\n   - **`List.isEmpty state.stack && state.isValid`**: This checks if the final state has an empty stack (meaning all parentheses were matched) and `isValid` is still `True`. If both conditions are met, it returns `True`, indicating that the input forms a valid Dyck sequence.\n\n3. **`updateState` Function**:\n   `updateState` is a helper function that updates the state based on the type of `Parenthesis` encountered. In this case, it only deals with `Parenthesis` and pushes them onto the stack.\n\nOverall, `isDyck` applies the `updateState` operation to each `Parenthesis` in the input list and checks if the resulting state indicates a valid Dyck sequence."
      },
      "date": 1695386007813
    },
    {
      "type": "edit",
      "id": "9b12df081e9e4850",
      "item": {
        "type": "markdown",
        "id": "9b12df081e9e4850",
        "text": "The `isDyck` function is used to determine if a list of `Parenthesis` forms a valid Dyck sequence. In Dyck language theory, a Dyck word is a string consisting of balanced pairs of characters, such as parentheses. For example, `((()))` and `()()()` are valid Dyck words, while `(()(` and `())(` are not.\n\nHere's how the `isDyck` function works:\n\n1. **Type Signature**:\n   ```elm\n   isDyck : List Parenthesis -> Bool\n   ```\n   This means `isDyck` is a function that takes a list of `Parenthesis` and returns a `Bool`.\n\n2. **Function Body**:\n   ```elm\n   isDyck input =\n       let\n           initState =\n               { stack = []\n               , isValid = True\n               }\n       in\n       let\n           state =\n               List.foldr updateState initState input\n       in\n       List.isEmpty state.stack && state.isValid\n   ```\n   - **`initState`**: This initializes the state with an empty stack and sets `isValid` to `True`.\n   - **`state`**: This variable is obtained by folding (`List.foldr`) the `updateState` function over the input list. `updateState` takes a `Parenthesis` and a `State`, and returns a modified `State` after applying the operation defined for `updateState`.\n   - **`List.isEmpty state.stack && state.isValid`**: This checks if the final state has an empty stack (meaning all parentheses were matched) and `isValid` is still `True`. If both conditions are met, it returns `True`, indicating that the input forms a valid Dyck sequence.\n\n3. **`updateState` Function**:\n   `updateState` is a helper function that updates the state based on the type of `Parenthesis` encountered. In this case, it only deals with `Parenthesis` and pushes them onto the stack.\n\nOverall, `isDyck` applies the `updateState` operation to each `Parenthesis` in the input list and checks if the resulting state indicates a valid Dyck sequence. (ChatGPT)"
      },
      "date": 1695386070788
    },
    {
      "item": {
        "type": "factory",
        "id": "2459e14d82044fa6"
      },
      "id": "2459e14d82044fa6",
      "type": "add",
      "after": "9b12df081e9e4850",
      "date": 1695386096162
    },
    {
      "type": "edit",
      "id": "2459e14d82044fa6",
      "item": {
        "type": "reference",
        "id": "2459e14d82044fa6",
        "site": "wiki.ralfbarkow.ch",
        "slug": "investigate-the-problem-dycks-of-checking-matching-parentheses",
        "title": "Investigate the Problem Dyck(s) Of Checking Matching Parentheses",
        "text": "Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of [[Parenthesis]]."
      },
      "date": 1695386100262
    },
    {
      "id": "2459e14d82044fa6",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242",
        "420f7b2565abdae8",
        "24d124d834926d63",
        "ce54654ec8befa64",
        "a6a356cc83e6aeb1",
        "79b643439e2bffd5",
        "0f71fb4a6a9e0fca",
        "77414ba09e602e5b",
        "ebf4fe5bf6eac1b2",
        "c05a7fcbfe36a798",
        "f4cc98be865c1a5e",
        "664ee1bb4f503286",
        "46e28fde57860bf0",
        "b81b430e05035b49",
        "1affe46f7a16d8be",
        "8ac5f816456e47e3",
        "5663619169e40301",
        "cbbee2e70b1f45d0",
        "49eeb13eaa114a3b",
        "136406d907815ae2",
        "6941cf47f912742a",
        "1a23ad453908cedb",
        "925c6ece534bcbc3",
        "40c8e9514facef5b",
        "5d2b42df7be8e2af",
        "5765d3147cdc8573",
        "b61a0278d98c6f44",
        "b4668dc4dcf6cefa",
        "b597fba759e7a6c6",
        "d0ace9c553caddef",
        "e4f25f0821f9d2ce",
        "8d525f738d36c4d6",
        "25676a8499bc8f57",
        "0727197588887da1",
        "eba13b32db4fed8d",
        "8107ffac3a74ad44",
        "dc1b57b96b87789e",
        "d034b266eee76e9a",
        "bfa592d047c92588",
        "7f4d91be07ed7e69",
        "e4148d546b407aa4",
        "1454f46074fe3f3d",
        "86bdb9f1294a9891",
        "60f787b83b54106c",
        "b17cf9a231d314e7",
        "f8c5bfd678d30abf",
        "e6d51d4f85c21bbc",
        "0e6ea36f98384adf",
        "4245b38d014a0304",
        "89ce2baf2d87e711",
        "07c0f9ffef48e97b",
        "bb3b373ea24eb1d9",
        "ffeeb583bd6b9e67",
        "ac893e078874b7f1",
        "021f95b342290b3b",
        "2459e14d82044fa6",
        "9b12df081e9e4850"
      ],
      "date": 1695386106395
    },
    {
      "item": {
        "type": "factory",
        "id": "36d7377d317db6f9"
      },
      "id": "36d7377d317db6f9",
      "type": "add",
      "after": "9b12df081e9e4850",
      "date": 1695386188140
    },
    {
      "id": "36d7377d317db6f9",
      "type": "move",
      "order": [
        "567736ecaa96aad5",
        "4828b8eae118a5fa",
        "7e33ef8e8453a242",
        "420f7b2565abdae8",
        "24d124d834926d63",
        "ce54654ec8befa64",
        "a6a356cc83e6aeb1",
        "79b643439e2bffd5",
        "0f71fb4a6a9e0fca",
        "77414ba09e602e5b",
        "ebf4fe5bf6eac1b2",
        "c05a7fcbfe36a798",
        "f4cc98be865c1a5e",
        "664ee1bb4f503286",
        "46e28fde57860bf0",
        "b81b430e05035b49",
        "1affe46f7a16d8be",
        "8ac5f816456e47e3",
        "5663619169e40301",
        "cbbee2e70b1f45d0",
        "49eeb13eaa114a3b",
        "136406d907815ae2",
        "6941cf47f912742a",
        "1a23ad453908cedb",
        "925c6ece534bcbc3",
        "40c8e9514facef5b",
        "5d2b42df7be8e2af",
        "5765d3147cdc8573",
        "b61a0278d98c6f44",
        "b4668dc4dcf6cefa",
        "b597fba759e7a6c6",
        "d0ace9c553caddef",
        "e4f25f0821f9d2ce",
        "8d525f738d36c4d6",
        "25676a8499bc8f57",
        "0727197588887da1",
        "eba13b32db4fed8d",
        "8107ffac3a74ad44",
        "dc1b57b96b87789e",
        "d034b266eee76e9a",
        "bfa592d047c92588",
        "7f4d91be07ed7e69",
        "e4148d546b407aa4",
        "1454f46074fe3f3d",
        "86bdb9f1294a9891",
        "60f787b83b54106c",
        "b17cf9a231d314e7",
        "f8c5bfd678d30abf",
        "e6d51d4f85c21bbc",
        "0e6ea36f98384adf",
        "4245b38d014a0304",
        "89ce2baf2d87e711",
        "07c0f9ffef48e97b",
        "bb3b373ea24eb1d9",
        "ffeeb583bd6b9e67",
        "ac893e078874b7f1",
        "021f95b342290b3b",
        "2459e14d82044fa6",
        "36d7377d317db6f9",
        "9b12df081e9e4850"
      ],
      "date": 1695386194064
    },
    {
      "type": "edit",
      "id": "36d7377d317db6f9",
      "item": {
        "type": "code",
        "id": "36d7377d317db6f9",
        "text": "isDyck : List Parenthesis -> Bool\nisDyck input =\n    let\n        initState =\n            { stack = []\n            , isValid = True\n            }\n    in\n    let\n        state =\n            List.foldr updateState initState input\n    in\n    List.isEmpty state.stack && state.isValid\n"
      },
      "date": 1695386196423
    },
    {
      "type": "edit",
      "id": "9b12df081e9e4850",
      "item": {
        "type": "markdown",
        "id": "9b12df081e9e4850",
        "text": "The `isDyck` function is used to determine if a list of `Parenthesis` forms a valid Dyck sequence. In Dyck language theory, a Dyck word is a string consisting of balanced pairs of characters, such as [[Parentheses]]. For example, `((()))` and `()()()` are valid Dyck words, while `(()(` and `())(` are not.\n\nHere's how the `isDyck` function works:\n\n1. **Type Signature**:\n   ```elm\n   isDyck : List Parenthesis -> Bool\n   ```\n   This means `isDyck` is a function that takes a list of `Parenthesis` and returns a `Bool`.\n\n2. **Function Body**:\n   ```elm\n   isDyck input =\n       let\n           initState =\n               { stack = []\n               , isValid = True\n               }\n       in\n       let\n           state =\n               List.foldr updateState initState input\n       in\n       List.isEmpty state.stack && state.isValid\n   ```\n   - **`initState`**: This initializes the state with an empty stack and sets `isValid` to `True`.\n   - **`state`**: This variable is obtained by folding (`List.foldr`) the `updateState` function over the input list. `updateState` takes a `Parenthesis` and a `State`, and returns a modified `State` after applying the operation defined for `updateState`.\n   - **`List.isEmpty state.stack && state.isValid`**: This checks if the final state has an empty stack (meaning all parentheses were matched) and `isValid` is still `True`. If both conditions are met, it returns `True`, indicating that the input forms a valid Dyck sequence.\n\n3. **`updateState` Function**:\n   `updateState` is a helper function that updates the state based on the type of `Parenthesis` encountered. In this case, it only deals with `Parenthesis` and pushes them onto the stack.\n\nOverall, `isDyck` applies the `updateState` operation to each `Parenthesis` in the input list and checks if the resulting state indicates a valid Dyck sequence. (ChatGPT)"
      },
      "date": 1695386254513
    },
    {
      "item": {
        "type": "factory",
        "id": "af8fe55ec35cb34d"
      },
      "id": "af8fe55ec35cb34d",
      "type": "add",
      "after": "9b12df081e9e4850",
      "date": 1695386424691
    },
    {
      "type": "edit",
      "id": "af8fe55ec35cb34d",
      "item": {
        "type": "code",
        "id": "af8fe55ec35cb34d",
        "text": "updateState : Parenthesis -> State -> State\nupdateState bracket state =\n    case bracket of\n        RoundBracket ->\n            push RoundBracket state\n\n"
      },
      "date": 1695386427694
    },
    {
      "item": {
        "type": "factory",
        "id": "27daa03cd158f0e3"
      },
      "id": "27daa03cd158f0e3",
      "type": "add",
      "after": "af8fe55ec35cb34d",
      "date": 1695386467558
    },
    {
      "type": "edit",
      "id": "27daa03cd158f0e3",
      "item": {
        "type": "markdown",
        "id": "27daa03cd158f0e3",
        "text": "The `updateState` function is responsible for updating the state based on the type of `Parenthesis` encountered. Here's how it works:\n\n1. **Type Signature**:\n   ```elm\n   updateState : Parenthesis -> State -> State\n   ```\n   This means `updateState` is a function that takes a `Parenthesis` and a `State` and returns a modified `State`.\n\n2. **Function Body**:\n   ```elm\n   updateState bracket state =\n       case bracket of\n           RoundBracket ->\n               push RoundBracket state\n   ```\n   - `bracket`: This is the `Parenthesis` that is being processed.\n   - `state`: This is the current state.\n\n   - **`case bracket of`**: This is a pattern matching construct. It checks the type of `bracket`.\n\n   - **`RoundBracket ->`**: If the `bracket` is of type `RoundBracket` (which is synonymous with `Parenthesis` in this context), the following code will be executed:\n\n       - `push RoundBracket state`: This calls the `push` function with the `RoundBracket` (which is essentially a `Parenthesis`) and the current `state`. The `push` function updates the state by adding the `RoundBracket` to the stack.\n\n       If `bracket` is not `RoundBracket`, this function will not perform any operation.\n\n3. **`push` Function**:\n   The `push` function, which is not shown here, is responsible for adding a `RoundBracket` to the stack in the state. It takes a `RoundBracket` and a `State` and returns a modified `State` with the updated stack.\n\nIn summary, `updateState` takes a `Parenthesis` and a `State`, and if the `Parenthesis` is a `RoundBracket`, it calls the `push` function to update the state. The `push` function handles the actual stacking operation."
      },
      "date": 1695386469648
    },
    {
      "type": "edit",
      "id": "27daa03cd158f0e3",
      "item": {
        "type": "markdown",
        "id": "27daa03cd158f0e3",
        "text": "The `updateState` function is responsible for updating the state based on the type of `Parenthesis` encountered. Here's how it works:\n\n1. **Type Signature**:\n   ```elm\n   updateState : Parenthesis -> State -> State\n   ```\n   This means `updateState` is a function that takes a `Parenthesis` and a `State` and returns a modified `State`.\n\n2. **Function Body**:\n   ```elm\n   updateState bracket state =\n       case bracket of\n           RoundBracket ->\n               push RoundBracket state\n   ```\n   - `bracket`: This is the `Parenthesis` that is being processed.\n   - `state`: This is the current state.\n\n   - **`case bracket of`**: This is a pattern matching construct. It checks the type of `bracket`.\n\n   - **`RoundBracket ->`**: If the `bracket` is of type `RoundBracket` (which is synonymous with `Parenthesis` in this context), the following code will be executed:\n\n       - `push RoundBracket state`: This calls the `push` function with the `RoundBracket` (which is essentially a `Parenthesis`) and the current `state`. The `push` function updates the state by adding the `RoundBracket` to the stack.\n\n       If `bracket` is not `RoundBracket`, this function will not perform any operation.\n\n3. **`push` Function**:\n   The `push` function, which is not shown here, is responsible for adding a `RoundBracket` to the stack in the state. It takes a `RoundBracket` and a `State` and returns a modified `State` with the updated stack.\n\nIn summary, `updateState` takes a `Parenthesis` and a `State`, and if the `Parenthesis` is a `RoundBracket`, it calls the `push` function to update the state. The `push` function handles the actual stacking operation. (ChatGPT)"
      },
      "date": 1695386486674
    },
    {
      "item": {
        "type": "factory",
        "id": "efe57ba9dc3f4338"
      },
      "id": "efe57ba9dc3f4338",
      "type": "add",
      "after": "27daa03cd158f0e3",
      "date": 1695386722940
    },
    {
      "type": "edit",
      "id": "efe57ba9dc3f4338",
      "item": {
        "type": "code",
        "id": "efe57ba9dc3f4338",
        "text": "push : Parenthesis -> State -> State\npush bracket state =\n    { state | stack = bracket :: state.stack }\n"
      },
      "date": 1695386727198
    },
    {
      "item": {
        "type": "factory",
        "id": "3a038fa99b3d834e"
      },
      "id": "3a038fa99b3d834e",
      "type": "add",
      "after": "efe57ba9dc3f4338",
      "date": 1695386762635
    },
    {
      "type": "edit",
      "id": "3a038fa99b3d834e",
      "item": {
        "type": "markdown",
        "id": "3a038fa99b3d834e",
        "text": "The `push` function is responsible for adding a `Parenthesis` to the stack in the current state. Here's how it works:\n\n1. **Type Signature**:\n   ```elm\n   push : Parenthesis -> State -> State\n   ```\n   This means `push` is a function that takes a `Parenthesis` and a `State`, and it returns a modified `State`.\n\n2. **Function Body**:\n   ```elm\n   push bracket state =\n       { state | stack = bracket :: state.stack }\n   ```\n   - `bracket`: This is the `Parenthesis` that needs to be added to the stack.\n   - `state`: This is the current state.\n\n   - `state | stack = bracket :: state.stack`: This is an Elm record update syntax. It creates a new state by modifying the `stack` field.\n\n       - `stack = bracket :: state.stack`: This means that the new `stack` will be the result of adding `bracket` to the front of the current `state.stack`. This effectively pushes `bracket` onto the stack.\n\n       - The `::` operator is the list cons operator. It adds an element to the beginning of a list.\n\n   - The rest of the fields in the state (in this case, `isValid`) remain unchanged.\n\nIn summary, the `push` function takes a `Parenthesis` and a `State`, and it returns a new `State` where the `Parenthesis` has been added to the stack. The original state is not modified; instead, a new state with the updated stack is returned."
      },
      "date": 1695386764546
    },
    {
      "type": "edit",
      "id": "3a038fa99b3d834e",
      "item": {
        "type": "markdown",
        "id": "3a038fa99b3d834e",
        "text": "The `push` function is responsible for adding a `Parenthesis` to the stack in the current state. Here's how it works:\n\n1. **Type Signature**:\n   ```elm\n   push : Parenthesis -> State -> State\n   ```\n   This means `push` is a function that takes a `Parenthesis` and a `State`, and it returns a modified `State`.\n\n2. **Function Body**:\n   ```elm\n   push bracket state =\n       { state | stack = bracket :: state.stack }\n   ```\n   - `bracket`: This is the `Parenthesis` that needs to be added to the stack.\n   - `state`: This is the current state.\n\n   - `state | stack = bracket :: state.stack`: This is an Elm record update syntax. It creates a new state by modifying the `stack` field.\n\n       - `stack = bracket :: state.stack`: This means that the new `stack` will be the result of adding `bracket` to the front of the current `state.stack`. This effectively pushes `bracket` onto the stack.\n\n       - The `::` operator is the list cons operator. It adds an element to the beginning of a list.\n\n   - The rest of the fields in the state (in this case, `isValid`) remain unchanged.\n\nIn summary, the `push` function takes a `Parenthesis` and a `State`, and it returns a new `State` where the `Parenthesis` has been added to the stack. The original state is not modified; instead, a new state with the updated stack is returned. (ChatGPT)"
      },
      "date": 1695386774419
    },
    {
      "item": {
        "type": "factory",
        "id": "158fd207422817dc"
      },
      "id": "158fd207422817dc",
      "type": "add",
      "after": "3a038fa99b3d834e",
      "date": 1695386931500
    },
    {
      "type": "edit",
      "id": "158fd207422817dc",
      "item": {
        "type": "code",
        "id": "158fd207422817dc",
        "text": "pop : State -> State\npop state =\n    case state.stack of\n        [] ->\n            state\n\n        _ :: rest ->\n            { state | stack = rest }\n"
      },
      "date": 1695386935404
    },
    {
      "item": {
        "type": "factory",
        "id": "7ce85a0182d198d4"
      },
      "id": "7ce85a0182d198d4",
      "type": "add",
      "after": "158fd207422817dc",
      "date": 1695386973326
    },
    {
      "type": "edit",
      "id": "7ce85a0182d198d4",
      "item": {
        "type": "markdown",
        "id": "7ce85a0182d198d4",
        "text": "The `pop` function is responsible for removing the topmost element from the stack in the current state. Here's how it works:\n\n1. **Type Signature**:\n   ```elm\n   pop : State -> State\n   ```\n   This means `pop` is a function that takes a `State` and returns a modified `State`.\n\n2. **Function Body**:\n   ```elm\n   pop state =\n       case state.stack of\n           [] ->\n               state\n\n           _ :: rest ->\n               { state | stack = rest }\n   ```\n\n   - `state`: This is the current state.\n\n   - `case state.stack of`: This is a pattern matching expression that checks the value of `state.stack`.\n\n   - `[] -> state`: If `state.stack` is an empty list, it means the stack is already empty. In this case, the function simply returns the original `state` without making any changes.\n\n   - `_ :: rest -> { state | stack = rest }`: If `state.stack` is not empty, it means there's at least one element on the stack. Here's what happens next:\n\n       - `::_rest`: This pattern matches any non-empty list, and it binds the head of the list (the first element) to `_`. We're not using the head value, so we use the wildcard `_` to indicate that we're ignoring it. The rest of the list is bound to `rest`.\n\n       - `{ state | stack = rest }`: This is an Elm record update syntax. It creates a new state by modifying the `stack` field.\n\n           - `stack = rest`: This means that the new `stack` will be the tail of the current `state.stack`. This effectively removes the topmost element from the stack.\n\n           - The rest of the fields in the state (in this case, `isValid`) remain unchanged.\n\nIn summary, the `pop` function takes a `State` and returns a new `State` where the topmost element has been removed from the stack. The original state is not modified; instead, a new state with the updated stack is returned. If the stack was already empty, the original state is returned without changes. (ChatGPT)"
      },
      "date": 1695386980315
    },
    {
      "item": {
        "type": "factory",
        "id": "1f4166ae03f09872"
      },
      "id": "1f4166ae03f09872",
      "type": "add",
      "after": "7ce85a0182d198d4",
      "date": 1695387526136
    },
    {
      "type": "edit",
      "id": "1f4166ae03f09872",
      "item": {
        "type": "paragraph",
        "id": "1f4166ae03f09872",
        "text": "We assume that RoundBracket is either a opening or a closing round-bracket. How to modify the code?"
      },
      "date": 1695387527838
    },
    {
      "item": {
        "type": "factory",
        "id": "b3102079cbc8e7b4"
      },
      "id": "b3102079cbc8e7b4",
      "type": "add",
      "after": "1f4166ae03f09872",
      "date": 1695387543931
    },
    {
      "type": "edit",
      "id": "b3102079cbc8e7b4",
      "item": {
        "type": "markdown",
        "id": "b3102079cbc8e7b4",
        "text": "If `RoundBracket` can represent either an opening or a closing round-bracket, we need to adjust the code accordingly. Here's how you can modify the code:\n\nIn Main.elm:\n\n```elm\ntype RoundBracket\n    = OpenBracket\n    | CloseBracket\n```\n\nIn MainSpec.elm, you'll need to adjust the tests to use `OpenBracket` and `CloseBracket`:\n\n```elm\ntests : Test\ntests =\n    describe \"Dyck Tests\"\n        [ test \"Test 1\" <|\n            \\() ->\n                Expect.equal True (isDyck [ OpenBracket, OpenBracket, OpenBracket, CloseBracket, CloseBracket, CloseBracket ])\n        -- Add more tests as needed\n        -- ...\n        ]\n```\n\nAdditionally, you'll need to adjust the `updateState` function in Main.elm to handle both types of `RoundBracket`:\n\n```elm\nupdateState : RoundBracket -> State -> State\nupdateState bracket state =\n    case bracket of\n        OpenBracket ->\n            push bracket state\n\n        CloseBracket ->\n            case state.stack of\n                [] ->\n                    { state | isValid = False }\n\n                _ :: rest ->\n                    pop state\n```\n\nWith these modifications, the code should now handle both opening and closing round-brackets correctly. Remember to adjust the tests and logic as needed for your specific use case."
      },
      "date": 1695387546752
    },
    {
      "type": "edit",
      "id": "b3102079cbc8e7b4",
      "item": {
        "type": "markdown",
        "id": "b3102079cbc8e7b4",
        "text": "If `RoundBracket` can represent either an opening or a closing round-bracket, we need to adjust the code accordingly. Here's how you can modify the code:\n\nIn Main.elm:\n\n```elm\ntype RoundBracket\n    = OpenBracket\n    | CloseBracket\n```\n\nIn MainSpec.elm, you'll need to adjust the tests to use `OpenBracket` and `CloseBracket`:\n\n```elm\ntests : Test\ntests =\n    describe \"Dyck Tests\"\n        [ test \"Test 1\" <|\n            \\() ->\n                Expect.equal True (isDyck [ OpenBracket, OpenBracket, OpenBracket, CloseBracket, CloseBracket, CloseBracket ])\n        -- Add more tests as needed\n        -- ...\n        ]\n```\n\nAdditionally, you'll need to adjust the `updateState` function in Main.elm to handle both types of `RoundBracket`:\n\n```elm\nupdateState : RoundBracket -> State -> State\nupdateState bracket state =\n    case bracket of\n        OpenBracket ->\n            push bracket state\n\n        CloseBracket ->\n            case state.stack of\n                [] ->\n                    { state | isValid = False }\n\n                _ :: rest ->\n                    pop state\n```\n\nWith these modifications, the code should now handle both opening and closing round-brackets correctly. Remember to adjust the tests and logic as needed for your specific use case. (ChatGPT)"
      },
      "date": 1695387561672
    },
    {
      "type": "remove",
      "id": "567736ecaa96aad5",
      "date": 1695447405401
    },
    {
      "type": "edit",
      "id": "4828b8eae118a5fa",
      "item": {
        "type": "paragraph",
        "id": "4828b8eae118a5fa",
        "text": "⇒ [[PEG]] ⇐ Expression and cut parser"
      },
      "date": 1695447413790
    }
  ]
}