{
  "title": "Functional Programming Language",
  "story": [
    {
      "type": "html",
      "text": "A [[Programming Language]] is called functional if it supports and/or encourages [[Functional Programming]]. <i>Dysfunctional otherwise. *Arr arr arr*</i>",
      "id": "67ecd5e4d1636877a2c4ce61f31333c3"
    },
    {
      "type": "html",
      "text": "\nA list of [[Functional Programming Language]] descriptions and links:",
      "id": "0c2915df2ba089d2a18f8a8b4fbe5da5"
    },
    {
      "type": "html",
      "text": " Haskell [[[Haskell Language]]] - the archetypal FPL in the 1990s, it is lazily evaluated (as opposed to strictly or eagerly evaluated, see [[Lazy Evaluation]]), [[Statically Typed]] and supports input/output, GUIs, animation, databases, COM and ActiveX, etc. I.e. all the usual \"side effects\" that are not usually considered to be practical in functional programming are practical in Haskell with [[Referential Transparency]] (See [[On Monads]]). There are several open source systems. See also [[Template Haskell]].",
      "id": "89653f876f1d5f336192bcc75217514e"
    },
    {
      "type": "html",
      "text": " Erlang [[[Erlang Language]]] - the champion FPL in the 1990s, it is [[Dynamically Typed]], mostly functional (i.e. supports some imperative side effects that break [[Referential Transparency]]). Erlang applications are composed from [[Communicating Sequential Processes]] (shared nothing message passing). This is the champion FPL for the 1990s because was developed by Ericsson and is used in several released products (switches, etc.) for soft real time distributed telecommunications. There is one open source system that includes a CORBA ORB, Naming service, Event service, a distributed soft real time database with nested transactions, replication, and a query language, among other goodies like SNMP, HTTP, etc.",
      "id": "529a0e387fee6e005c8344df242181de"
    },
    {
      "type": "html",
      "text": " ML [[[Ml Language]]] e.g., SML [Standard ML, [[Sml Language]]], SML/NJ, CAML, CAML-light, [[Objective Caml]], [[Alice Language]], [[Fsharp Language]], etc. Statically typed, eagerly evaluated, etc.  Interesting ways of combining source code based on \"functors\" (basically, mappings from collections of functions to collections of functions).",
      "id": "8150e3ed153530cc58aa75ffcf342ad8"
    },
    {
      "type": "html",
      "text": " [[Common Lisp]] (and others)-- though impurely, and as only one of the many paradigms supported",
      "id": "3c78911770843a8e550b48f25fe371df"
    },
    {
      "type": "html",
      "text": " Scheme [[[Scheme Language]]] (and variants)-- though impurely, and as only one of the many paradigms supported",
      "id": "02e0285d84edc19ba9775314fca7b3d5"
    },
    {
      "type": "html",
      "text": " m4 (the macro processor), which is available in almost any [[Unix Like]] environment, is largely functional even though it supports imperative features.  It has an exotic [[Level Of Quoting]] concept, and allows all kinds of quirks by being ultimately text-based.  Implementations often have undocumented limitations which causes your macro expansion to fail in spectacularly bamboozling ways.",
      "id": "7d8c484cf1ff1001e6d281618bdfb70f"
    },
    {
      "type": "html",
      "text": " FP - an interesting twist on functional languages -- no variables! You write programs by composing functions into new functions.  Mostly a proof-of-concept language, little real use, but interesting to play with. It is described in [[John Backus]]' ACM [[Turing Award Lecture]] \"[[Can Programming Be Liberated From The Von Neumann Style]]\" (1977).  This is the functional language that made functional programming an (academically) household name.  Succeeded by FL.",
      "id": "92768f78e06caa6b2645307ff27bdb21"
    },
    {
      "type": "html",
      "text": " FL - As with FP in nearly every respect, it remained a research vehicle at IBM, ultimately providing a foundation on which Iverson's [[Apl Language]] and [[Jay Language]] builds on.",
      "id": "6bc3add836eb72f2889f560baae8688e"
    },
    {
      "type": "html",
      "text": " [[Cindy Script]] the functional scripting language of Cinderella",
      "id": "d68f581c2a70d337a3942d2518dabdce"
    },
    {
      "type": "html",
      "text": " Clean [[[Clean Language]]]",
      "id": "45511076833e72a1f74b74ff1f748a97"
    },
    {
      "type": "html",
      "text": " Clojure [[[Clojure Language]]] A lisp variant that emphasizes functional programming more than other dialects (and more than other paradigms). ",
      "id": "1f5ccab79dacefde48a674416a823884"
    },
    {
      "type": "html",
      "text": " Gofer [[[Gofer Language]]]",
      "id": "482af96805a88ea7b0d2db6607a52661"
    },
    {
      "type": "html",
      "text": " Miranda [[[Miranda Language]]] - a language designed during the 80's that was a precursor to Haskell, using a very similar syntax. (A short introduction is at [http://blackcat.brynmawr.edu/~kimberly/Miranda.html blackcat.brynmawr.edu]).",
      "id": "6c1551611a85d53abfd11c3c9e0c8c42"
    },
    {
      "type": "html",
      "text": " J [[[Jay Language]]]",
      "id": "ca500af64c245fc34b363843cfe62164"
    },
    {
      "type": "html",
      "text": " Joy [[[Joy Language]]] - a purely functional language based on the composition of functions",
      "id": "214835a405b60f766847ff72e7711388"
    },
    {
      "type": "html",
      "text": " Pizza [[[Pizza Language]]] -  Extension of Java with [[Parametric Polymorphism]], [[Higher Order Function]]s and [[Algebraic Type]]s.",
      "id": "e1451e47b56a1a77f5693aed8ccd92ce"
    },
    {
      "type": "html",
      "text": " Nemerle [[[Nemerle Language]]] - an OO/functional language for the [[Common Language Infrastructure]] with hygienic code generating macros, algebraic datatypes and matching, higher order functions, lexical closures, and partial type inference (types are only inferred within methods, in order to avoid accidental changes to class interfaces). Syntax is superficially similar to C#, but the language is semantically more similar to [[Ml Language]] and descendants.",
      "id": "19ff1ce71fc752a0e9335991f74a58c8"
    },
    {
      "type": "html",
      "text": " Mercury - The [[Mercury Language]] is a new logic/functional programming language, which combines the clarity and expressiveness of declarative programming with advanced static analysis and error detection features. Its highly optimized execution algorithm delivers efficiency far in excess of existing logic programming systems, and close to conventional programming systems. Mercury addresses the problems of large-scale program development, allowing modularity, separate compilation, and numerous optimization/time trade-offs.",
      "id": "2077b5114fa67bf0b5752f1a75e8f5eb"
    },
    {
      "type": "html",
      "text": " Pure [[[Pure Language]]] - Term-rewriting language. [http://code.google.com/p/pure-lang/ code.google.com]",
      "id": "590a08b3c1e2c8a1bfb2674b7e103abd"
    },
    {
      "type": "html",
      "text": " The [[Un Lambda Language]] has only functions.  <i>(But it's probably of theoretical interest only.)</i> It's an [[Esoteric Programming Language]].",
      "id": "7c7633c0c1688d8c1d8a0899c8561a49"
    },
    {
      "type": "html",
      "text": " There is also another (purer) functional [[Esoteric Programming Language]]:<br>Lazy-K.",
      "id": "c37ff4d98cf55126f6f296da2adb2fe7"
    },
    {
      "type": "html",
      "text": " Opal -- [http://uebb.cs.tu-berlin.de/~opal/opal-language.html uebb.cs.tu-berlin.de]",
      "id": "37d59d419998673d560784ff0f1ff51a"
    },
    {
      "type": "html",
      "text": " Refal [[[Refal Language]]]",
      "id": "bf176dab5c0eb9022299d79f61be381a"
    },
    {
      "type": "html",
      "text": " Dylan [[[Dylan Language]]] -- allows functional programming style, but also imperative/o-o style",
      "id": "25bd8c8c3f479c288cc4a5083679526a"
    },
    {
      "type": "html",
      "text": " Needle [[[Needle Language]]] -- similar to Dylan, but leans more towards the statically-typed side",
      "id": "d3f6826585bb3b86405cadaa353a3022"
    },
    {
      "type": "html",
      "text": " Goo [[[Goo Language]]] -- Scheme with some concepts (notable [[Generic Function]]s) borrowed from Dylan.",
      "id": "658897428ad21e4b5f9c6fae43119923"
    },
    {
      "type": "html",
      "text": " Mathematica [[[Mathematica Language]]] -- the crux of the [[Mathematica Package]]  produced by [[Wolfram Research]]",
      "id": "352c0ed868f703e864006ed48b83c7ee"
    },
    {
      "type": "html",
      "text": " XSLT [[[Xslt Language]]] -- \"The Functional Programming Language XSLT - A proof through examples\" [http://www.topxml.com/xsl/articles/fp/ www.topxml.com]",
      "id": "409e26e337e0fccb573a612bd00f370d"
    },
    {
      "type": "html",
      "text": " Scala [[[Scala Language]]]",
      "id": "b8cb007cbb41af612b5532516cb1af83"
    },
    {
      "type": "html",
      "text": " Ruby [[[Ruby Language]]] -- pretty mix of functional and object oriented",
      "id": "dea99ddc0a7d8b0d3490fcf191292131"
    },
    {
      "type": "html",
      "text": " Pick language and derivatives - [[Open Insight]], [[Advanced Revelation]], Universe, Unidata, Maverick, Jbase and many others.",
      "id": "8e8f87208b853f6ce5ddba203616ebb1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "<i>What are the criteria for inclusion above?</i>",
      "id": "008b6447fedf43f6fda0fab793a6c934"
    },
    {
      "type": "html",
      "text": "\nThere will be different opinions. I would include any language that\t\nencourages a functional style of programming. So ML and [[Common Lisp]] and \nScheme could be in this list.",
      "id": "7c75001e651564ba2ba4930c36518441"
    },
    {
      "type": "html",
      "text": "<i>What about Lisp? Too old? Too many side effects? Too many dialects?</i>",
      "id": "20de19b0402ec69f43f0cbe67fb0391b"
    },
    {
      "type": "html",
      "text": "\nEach Lisp should be listed on its own since they are so different especially\nin how they encourage functional programming. Clojure is the most \"functional purist\" of them, followed by Scheme and Common Lisp (in that order), which like to think of themselves as being multi-paradigm.",
      "id": "a283584b7beefcac091a98891f0c6757"
    },
    {
      "type": "html",
      "text": "<i>What about Pizza? Too young? Too short-lived? Too close to Java?</i>",
      "id": "3ac5461e58876b7062a3d1378ff9a883"
    },
    {
      "type": "html",
      "text": "\nI would include Pizza since it extends Java by adding first-class functions,\nand so encourages a functional style of programming. Much more so than the\nanonymous classes of Java.",
      "id": "9622b8bcbb29dc21aaaee4ace48634d3"
    },
    {
      "type": "html",
      "text": "<i>What about Prolog?  Too old, too academic?</i>",
      "id": "4752167c7ee2240e775571908ca166ab"
    },
    {
      "type": "html",
      "text": "\nYou cannot define a function in the [[Prolog Language]], or apply a function to its arguments. Prolog is not about functions, it is about predicates; it is a [[Logic Programming Language]].  However, both Erlang and Mercury were developed from Prolog.",
      "id": "89a55ce171b7d5132bd56711a9c6f490"
    },
    {
      "type": "html",
      "text": "<i>What about [[Python Language]]?...</i>",
      "id": "240b2950b65a97c2bf66ba55fdb59ec0"
    },
    {
      "type": "html",
      "text": "\nGuido seems to have spent a lot of breath convincing us that Python is <i>not</i> a functional programming language.  Guido even wanted to remove lambdas; however, public outcry ultimately forced him to keep lambdas in the language.",
      "id": "8135eca847cba432eccb6b5ea0e2912c"
    },
    {
      "type": "html",
      "text": "<i>Guido wanted to remove lambdas in the belief that named functions are easier to read, not out of any particular dislike for functional programming. Python contains functional features adopted from many other languages, such as Haskell's list comprehensions and LISP's map/filter/reduce (= Haskell foldl). Use of first-class functions is common in the standard library's API.</i>",
      "id": "ae22b2e4985961f4488fddf89b01c381"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "There is some discussion about the relative advantages and disadvantages of [[Functional Programming]] and [[Object Oriented Programming]] and about the degree that [[Functional Programming]] and [[Object Oriented Programming]] can be used in the same language. See [[Fp Vs Oo]], [[Oo Vs Functional]], [[Closures And Objects Are Equivalent]].",
      "id": "54b548639802708d32f1d6602cdbeaca"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "<i>What about [[Cee Omega]] and C# 3.0? They have a hybrid mix of imperative and functional paradigms.</i>",
      "id": "170b86f207239586234b9cb7cc315297"
    },
    {
      "type": "html",
      "text": "\nThose are basically vaporware at the moment, aren't they? If so, then who knows what directions they may take in the future.",
      "id": "483ddc41e929e3e2e6ab318093ae192e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "Most newer [[Functional Programming Language]]s support static type-checking, so if you have a function f of type A->B i.e. f takes an arg of type A and returns a result of type B, and an expression x of type A then you can apply f to x to get something of type B.\nSince functions are first class citizens the x could it self be a function. E.g. suppose I want a function dot which takes two functions and returns a function which applies the second fn then the first fn , its type would be:-",
      "id": "614d4dff7d499f0e659ab458cfaf393d"
    },
    {
      "type": "html",
      "text": "dot ::<br>(b -> c) -> (a -> b) -> (a -> c)",
      "id": "8b89f2fe9019f486a27fdb2cc2a6a381"
    },
    {
      "type": "html",
      "text": "(using Haskell syntax - x :: T means x is of type T. Identifiers in types starting with lower case are [[Type Variable]]s and denote arbitrary type. That is called [[Parametric Polymorphism]]). It could be defined as:-",
      "id": "2ae8901c2e42f2e70cf5a4a792434e6b"
    },
    {
      "type": "code",
      "text": "  dot f g = \\x -> f (g x)",
      "id": "a437222cd94d41b7bbd0d1b065a21714"
    },
    {
      "type": "html",
      "text": "(The \"\\x -> ..\" part is an [[Anonymous Function]].) This would be another way of defining dot:-",
      "id": "328bc96d12a6f81158b790faf51b2d0b"
    },
    {
      "type": "code",
      "text": "  dot f g x = f (g x)",
      "id": "1f2bb2fce2cfdb648578dd7dbf6abb68"
    },
    {
      "type": "html",
      "text": "(The dot function is actually defined as an infix \".\" operator in [[Haskell Language]])\nAnother example is the curry function from the Haskell prelude :-",
      "id": "faadda71e9b62ce1ebb198aac3651ed8"
    },
    {
      "type": "html",
      "text": "curry\t  ::<br>((a,b) -> c) -> (a -> b -> c)",
      "id": "238c8193e7886e73c896c8c19ee531c1"
    },
    {
      "type": "code",
      "text": "  curry f x y  = f (x,y)",
      "id": "b3b9b96a4e5fd461f40c7f41d91c180d"
    },
    {
      "type": "html",
      "text": "\ni.e. it takes a function which takes it arguments as a pair and returns an equivalent function which takes it arguments in a curried form. (See [[Currying Schonfinkelling]].)",
      "id": "be949f0b8f22b7f3d4f5a66abe40dea0"
    },
    {
      "type": "html",
      "text": "\nHence functions can be manipulated in a quite sophisticated fashion. Try to do this in C++/Java and you will probably have to write an FP interpreter. -- [[Jon Hanson]]",
      "id": "d2df5e1dd9c05dbf0a6224342980a32d"
    },
    {
      "type": "html",
      "text": "\nI wonder if you could write an [[Fp Interpreter Using Templates]]?",
      "id": "351018ab24ab0f8d0182b7a70bb8f3d1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "<b>[[[Clean Language]]]</b>",
      "id": "7c9c3eb008fde0ef72a688ce360182c7"
    },
    {
      "type": "html",
      "text": "\nTo do I/O in Clean in a functional way, you pass the world around, and compute new values of the world. Because Clean has [[Unique Type]]s, the Clean compiler can guarantee that there is always only one live copy of the world around. Therefore, it can mutate the world in-place, rather than having to copy it entirely, which would be computationally costly, to say the least. ;-)",
      "id": "2ee41098072c8f592267c73ec9cc1841"
    },
    {
      "type": "html",
      "text": "\nHaskell doesn't have [[Unique Type]]s, so it cannot take this approach.\nTherefore it uses monads. ",
      "id": "71d346e61e2c994f9040b19f7f3d46b4"
    },
    {
      "type": "html",
      "text": "<i>This is a subject of [[Holy War]]s, but </i>I<i> prefer using monads to [[Unique Type]]s. Monads are at least native functional constructs and don't need specific language support. Besides, you get rid of the explicit passing of world - which has no benefit anyway, because you can't copy the world.</i>",
      "id": "abb35539acba2e26d55091faf633130c"
    },
    {
      "type": "html",
      "text": "\n[[Unique Type]]s aren't used just for IO, other uses include arrays with destructive updating. Also [[Unique Type]]s are easier to use when you want to write code that has two kinds of effects (e.g. read a file and put the contents in an imperative array). In Clean you can freely mix the two kinds of [[Unique Type]]s where in Haskell you need to write some specific monad transformer to let you mix IO and State monads. Also you can have monads (modulo syntatic sugar like [[Do Notation]]) in Clean, but the inverse isn't possible in Haskell. Saying that [[Unique Type]]s can be very hard to grok.",
      "id": "a67bd4326eacf06de7a68a9234a81baf"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "<b>[[[Jay Language]]]</b>",
      "id": "3685eacb43e7221e97936dc6ad6459a5"
    },
    {
      "type": "html",
      "text": "I've been peeking at J, from [http://www.jsoftware.com/ www.jsoftware.com], and see the ad phrase that says \"OOP is easy with J4!\".  But reading the documentation, I can't see that \"locales\" can be constructed as variables, so I can't see how to implement polymorphism or inheritance.  Anyone got a clue?  --[[Alistair Cockburn]], 7/99",
      "id": "2c2d592e9a16ca837a71f8adeff16b4e"
    },
    {
      "type": "html",
      "text": "<i>[I believe the \"J4 makes OOP easy!\" statement was some part fluff, in response, after OO abilities were added, to many previous \"Does J do OOP?\" questions.]</i>",
      "id": "1062de5eb721157fbc8c1f44eb9ad516"
    },
    {
      "type": "html",
      "text": "\nIt doesn't look OO at all to me, it looks like Backus's FP revived.\nWhere does it say that OOP is easy with J4?\nI think I am too old to decipher line noise any more. --[[John Farrell]]",
      "id": "b915ffadd8e8fc92dd4f8e36902b193b"
    },
    {
      "type": "html",
      "text": "\nIt says, \"J4 makes OOP easy! \nNew language extensions include hierarchical paths and object locales that can be dynamically created and referenced. The underlying primitives allow you to follow the OOP model exactly. The new facilities are of general applicability, and so powerful and easy to use that they should dramatically improve the way we build systems in J. \" from the j download page.",
      "id": "d3448283197642ea5a7c9148cbbe7036"
    },
    {
      "type": "html",
      "text": "\n[http://www.jsoftware.com/download/download.htm www.jsoftware.com] ?\nMaybe the page has changed. The site now talks about J403. <i>[J4 refers to all releases numbered J4xx; J403 is the 3rd revision of J4.]</i>",
      "id": "d21581ffbb970d612806f62e8497b00b"
    },
    {
      "type": "html",
      "text": "\nI don't recall anything that I would consider object-oriented in J, though I don't consider that a problem. The locales seemed to be more a module or namespace feature. -- [[Ward Cunningham]]",
      "id": "a0aaa48f0d28e6b6c8c28cd2a9391e93"
    },
    {
      "type": "html",
      "text": "<i>The documentation for some recent features (OO, sparse arrays, memory mapped nouns) has not made it to the manuals and help files. Instead, Lab session scripts (which provide interactive tutorials) are included, but they are not fully meaningful outside of a J Session. J's OO abilities are implemented using locales. It's worth downloading a trial copy just to go through the labs. -- [[Jim Russell]]</i>",
      "id": "8862d306d79725e46f1408929667abc2"
    },
    {
      "type": "html",
      "text": "\nDon't know if it's of any help, but I've been playing with a simple OOP example in a number of different languages  - mostly for recreational reasons ( see [http://w3.one.net/~jweirich/oostuff/ w3.one.net] ).  I've completed the example for the J language (as well as a couple of others) which can be found at [http://www.angelfire.com/tx4/cus/shapes/index.html www.angelfire.com] .  -- [[Chris Rathman]]",
      "id": "69f34309244048b0246c083b4ebab86b"
    },
    {
      "type": "html",
      "text": "[2001/08] A HTML Manual is installed together with the software, which is more up-do-date than the PDFs on the download page. In the manual for the free edition for windows I found a chapter on OOP. Its path is <j406d_root_folder>\\system\\extras\\help\\learning\\25.htm",
      "id": "7729dd622a4ca5614e83145c2049531e"
    },
    {
      "type": "html",
      "text": "\n[http://www.jsoftware.com/download/download.htm www.jsoftware.com]",
      "id": "55b6be337441dc3f2fb2a83a2cfc44a2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "<b>[C++]</b>",
      "id": "2388429e16fdb99888a7b7f3053df505"
    },
    {
      "type": "html",
      "text": "\nYou can get currying in native [[Cee Plus Plus]] using Templates. And a form of lambda functions are also possible.\nSee",
      "id": "10f996a78e6b774a92861365e431cae8"
    },
    {
      "type": "html",
      "text": " [[Boost Lambda Library]] - part of the [[Boost Libraries]]",
      "id": "1a5e3bd26c71bbd66fb550d134ed1c29"
    },
    {
      "type": "html",
      "text": " [http://www.fz-juelich.de/zam/FACT www.fz-juelich.de]",
      "id": "fb1d9b62ffcde44c59ddaa43f9bc309e"
    },
    {
      "type": "html",
      "text": " [[Functoids In Cpp]] ([http://www.cc.gatech.edu/~yannis/fc++/ www.cc.gatech.edu])",
      "id": "3e7984a80c90de2b2ddc9cc4429f0ee1"
    },
    {
      "type": "html",
      "text": "\nSee also [[Functional Programming In Cpp]].",
      "id": "7566d659b4b1ae4b39d89feaf97af605"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "<b>[PHP]</b>",
      "id": "fa6ec10afbdb3bd16824a47d11783bbd"
    },
    {
      "type": "html",
      "text": "\nPHP programmers may want to check out this library that adds some functional programming abilities to PHP4.\nSee",
      "id": "324741d9e6770dafbc1efa58adc04faa"
    },
    {
      "type": "html",
      "text": " [http://functional-php.sourceforge.net/ functional-php.sourceforge.net]",
      "id": "198e20e010815e4aab824bb951e86582"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "<b>[[[Aleph Language]]]</b> (See [http://www.aleph-lang.org/ www.aleph-lang.org]). From the website:",
      "id": "51a2a99050f9b35da1f49a672fb26f3d"
    },
    {
      "type": "html",
      "text": "\"Aleph is a multi-threaded functional programming language with dynamic symbol bindings that support the object oriented paradigm. Aleph features a state of the art runtime engine that supports both 32 and 64 bits platforms. Aleph comes with a rich set of libraries that are designed to be platform independent\"",
      "id": "4e10c0adfe6d5f4685b7b345d5985bb7"
    },
    {
      "type": "html",
      "text": "\nThe last release is from mid-2001 but the language is kinda interesting, and the compiler is really cool (written in C++, it compiled without errors on gcc 2.96.x and just two unprotected #define's in a couple of header files in gcc-3.2. No warnings.",
      "id": "fe1de1f787fc374bca69fcfae7636a0c"
    },
    {
      "type": "html",
      "text": "\nIt's a shame they don't seem to be developing/supporting it further. Maybe it can be saved if we manage to get a community effort (licenses providing, the compiler was [[Free Software]]).",
      "id": "56abea8977776d9113bcd2726093c145"
    },
    {
      "type": "html",
      "text": " <i>(Update: I have managed to get in touch with Aleph author, [[Amaury Darsch]], and he's indeed silently working on version 0.9.0, with updates on the web site coming soon. Joy!)</i>",
      "id": "3115c00693fa2096a62d5e32802a7bac"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "[[Christophe Poucet]] asks [[Which Functional Language To Learn]].",
      "id": "d783459aeef7208120004784a329fa70"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "20081106 -- [[Chris Garrod]] asks would it be ok to alphebetize the languages on this page? ",
      "id": "31fe496ee08fe963dd72f02994683d81"
    },
    {
      "type": "html",
      "text": "\nThat would be reasonable, but I would consider ensuring there is a list naming the most 'mainstream' FPLs at the top (Haskell, ML, Erlang). Other orders that are okay would be order of creation.",
      "id": "95265cb2aa4c43f86d2252124e919637"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "April 2010\nWhat kind of programs do you think are written more easily in FP languages? Specifically for people who use FP and non-FP languages - what situations do you find yourself using FP languages for? For example, I'm an aspring academic. Are they especially suited to mathematical and/or logical thinking? Number crunching? ",
      "id": "c263036f7d1e4d52cc791d0bbc93fc95"
    },
    {
      "type": "html",
      "text": "--[[Jason Espinosa]]",
      "id": "34933f7e2a2fe7b109003176085acd65"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "Is [[Lua Language]] a functional programming language?  \nI was just debating this with someone who claims it is not.  But if not, what disqualifies it (that does not also disqualify [[Scheme Language]]?)",
      "id": "c6481ba853f40b6f5d592ae439ec18d2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "[[Why Functional Programming Languages Arent Mainstream]]",
      "id": "d31cc62aa0d0f4d625aab14723071c9f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "45cefdb5a761cc95b9cf4471e946e3f2"
    },
    {
      "type": "html",
      "text": "[[Category Functional Programming]]",
      "id": "1c9dd4b02873b76968f7c180fb63c476"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?FunctionalProgrammingLanguage c2.com]",
      "id": "492ad23e798b58385e19df290b60a0c5"
    }
  ],
  "journal": [
    {
      "date": 1385263147000,
      "id": "dcc520a50c7cc8fbc270e36d50aed88a",
      "type": "create",
      "item": {
        "title": "Functional Programming Language",
        "story": [
          {
            "type": "html",
            "text": "A [[Programming Language]] is called functional if it supports and/or encourages [[Functional Programming]]. <i>Dysfunctional otherwise. *Arr arr arr*</i>",
            "id": "67ecd5e4d1636877a2c4ce61f31333c3"
          },
          {
            "type": "html",
            "text": "\nA list of [[Functional Programming Language]] descriptions and links:",
            "id": "0c2915df2ba089d2a18f8a8b4fbe5da5"
          },
          {
            "type": "html",
            "text": " Haskell [[[Haskell Language]]] - the archetypal FPL in the 1990s, it is lazily evaluated (as opposed to strictly or eagerly evaluated, see [[Lazy Evaluation]]), [[Statically Typed]] and supports input/output, GUIs, animation, databases, COM and ActiveX, etc. I.e. all the usual \"side effects\" that are not usually considered to be practical in functional programming are practical in Haskell with [[Referential Transparency]] (See [[On Monads]]). There are several open source systems. See also [[Template Haskell]].",
            "id": "89653f876f1d5f336192bcc75217514e"
          },
          {
            "type": "html",
            "text": " Erlang [[[Erlang Language]]] - the champion FPL in the 1990s, it is [[Dynamically Typed]], mostly functional (i.e. supports some imperative side effects that break [[Referential Transparency]]). Erlang applications are composed from [[Communicating Sequential Processes]] (shared nothing message passing). This is the champion FPL for the 1990s because was developed by Ericsson and is used in several released products (switches, etc.) for soft real time distributed telecommunications. There is one open source system that includes a CORBA ORB, Naming service, Event service, a distributed soft real time database with nested transactions, replication, and a query language, among other goodies like SNMP, HTTP, etc.",
            "id": "529a0e387fee6e005c8344df242181de"
          },
          {
            "type": "html",
            "text": " ML [[[Ml Language]]] e.g., SML [Standard ML, [[Sml Language]]], SML/NJ, CAML, CAML-light, [[Objective Caml]], [[Alice Language]], [[Fsharp Language]], etc. Statically typed, eagerly evaluated, etc.  Interesting ways of combining source code based on \"functors\" (basically, mappings from collections of functions to collections of functions).",
            "id": "8150e3ed153530cc58aa75ffcf342ad8"
          },
          {
            "type": "html",
            "text": " [[Common Lisp]] (and others)-- though impurely, and as only one of the many paradigms supported",
            "id": "3c78911770843a8e550b48f25fe371df"
          },
          {
            "type": "html",
            "text": " Scheme [[[Scheme Language]]] (and variants)-- though impurely, and as only one of the many paradigms supported",
            "id": "02e0285d84edc19ba9775314fca7b3d5"
          },
          {
            "type": "html",
            "text": " m4 (the macro processor), which is available in almost any [[Unix Like]] environment, is largely functional even though it supports imperative features.  It has an exotic [[Level Of Quoting]] concept, and allows all kinds of quirks by being ultimately text-based.  Implementations often have undocumented limitations which causes your macro expansion to fail in spectacularly bamboozling ways.",
            "id": "7d8c484cf1ff1001e6d281618bdfb70f"
          },
          {
            "type": "html",
            "text": " FP - an interesting twist on functional languages -- no variables! You write programs by composing functions into new functions.  Mostly a proof-of-concept language, little real use, but interesting to play with. It is described in [[John Backus]]' ACM [[Turing Award Lecture]] \"[[Can Programming Be Liberated From The Von Neumann Style]]\" (1977).  This is the functional language that made functional programming an (academically) household name.  Succeeded by FL.",
            "id": "92768f78e06caa6b2645307ff27bdb21"
          },
          {
            "type": "html",
            "text": " FL - As with FP in nearly every respect, it remained a research vehicle at IBM, ultimately providing a foundation on which Iverson's [[Apl Language]] and [[Jay Language]] builds on.",
            "id": "6bc3add836eb72f2889f560baae8688e"
          },
          {
            "type": "html",
            "text": " [[Cindy Script]] the functional scripting language of Cinderella",
            "id": "d68f581c2a70d337a3942d2518dabdce"
          },
          {
            "type": "html",
            "text": " Clean [[[Clean Language]]]",
            "id": "45511076833e72a1f74b74ff1f748a97"
          },
          {
            "type": "html",
            "text": " Clojure [[[Clojure Language]]] A lisp variant that emphasizes functional programming more than other dialects (and more than other paradigms). ",
            "id": "1f5ccab79dacefde48a674416a823884"
          },
          {
            "type": "html",
            "text": " Gofer [[[Gofer Language]]]",
            "id": "482af96805a88ea7b0d2db6607a52661"
          },
          {
            "type": "html",
            "text": " Miranda [[[Miranda Language]]] - a language designed during the 80's that was a precursor to Haskell, using a very similar syntax. (A short introduction is at [http://blackcat.brynmawr.edu/~kimberly/Miranda.html blackcat.brynmawr.edu]).",
            "id": "6c1551611a85d53abfd11c3c9e0c8c42"
          },
          {
            "type": "html",
            "text": " J [[[Jay Language]]]",
            "id": "ca500af64c245fc34b363843cfe62164"
          },
          {
            "type": "html",
            "text": " Joy [[[Joy Language]]] - a purely functional language based on the composition of functions",
            "id": "214835a405b60f766847ff72e7711388"
          },
          {
            "type": "html",
            "text": " Pizza [[[Pizza Language]]] -  Extension of Java with [[Parametric Polymorphism]], [[Higher Order Function]]s and [[Algebraic Type]]s.",
            "id": "e1451e47b56a1a77f5693aed8ccd92ce"
          },
          {
            "type": "html",
            "text": " Nemerle [[[Nemerle Language]]] - an OO/functional language for the [[Common Language Infrastructure]] with hygienic code generating macros, algebraic datatypes and matching, higher order functions, lexical closures, and partial type inference (types are only inferred within methods, in order to avoid accidental changes to class interfaces). Syntax is superficially similar to C#, but the language is semantically more similar to [[Ml Language]] and descendants.",
            "id": "19ff1ce71fc752a0e9335991f74a58c8"
          },
          {
            "type": "html",
            "text": " Mercury - The [[Mercury Language]] is a new logic/functional programming language, which combines the clarity and expressiveness of declarative programming with advanced static analysis and error detection features. Its highly optimized execution algorithm delivers efficiency far in excess of existing logic programming systems, and close to conventional programming systems. Mercury addresses the problems of large-scale program development, allowing modularity, separate compilation, and numerous optimization/time trade-offs.",
            "id": "2077b5114fa67bf0b5752f1a75e8f5eb"
          },
          {
            "type": "html",
            "text": " Pure [[[Pure Language]]] - Term-rewriting language. [http://code.google.com/p/pure-lang/ code.google.com]",
            "id": "590a08b3c1e2c8a1bfb2674b7e103abd"
          },
          {
            "type": "html",
            "text": " The [[Un Lambda Language]] has only functions.  <i>(But it's probably of theoretical interest only.)</i> It's an [[Esoteric Programming Language]].",
            "id": "7c7633c0c1688d8c1d8a0899c8561a49"
          },
          {
            "type": "html",
            "text": " There is also another (purer) functional [[Esoteric Programming Language]]:<br>Lazy-K.",
            "id": "c37ff4d98cf55126f6f296da2adb2fe7"
          },
          {
            "type": "html",
            "text": " Opal -- [http://uebb.cs.tu-berlin.de/~opal/opal-language.html uebb.cs.tu-berlin.de]",
            "id": "37d59d419998673d560784ff0f1ff51a"
          },
          {
            "type": "html",
            "text": " Refal [[[Refal Language]]]",
            "id": "bf176dab5c0eb9022299d79f61be381a"
          },
          {
            "type": "html",
            "text": " Dylan [[[Dylan Language]]] -- allows functional programming style, but also imperative/o-o style",
            "id": "25bd8c8c3f479c288cc4a5083679526a"
          },
          {
            "type": "html",
            "text": " Needle [[[Needle Language]]] -- similar to Dylan, but leans more towards the statically-typed side",
            "id": "d3f6826585bb3b86405cadaa353a3022"
          },
          {
            "type": "html",
            "text": " Goo [[[Goo Language]]] -- Scheme with some concepts (notable [[Generic Function]]s) borrowed from Dylan.",
            "id": "658897428ad21e4b5f9c6fae43119923"
          },
          {
            "type": "html",
            "text": " Mathematica [[[Mathematica Language]]] -- the crux of the [[Mathematica Package]]  produced by [[Wolfram Research]]",
            "id": "352c0ed868f703e864006ed48b83c7ee"
          },
          {
            "type": "html",
            "text": " XSLT [[[Xslt Language]]] -- \"The Functional Programming Language XSLT - A proof through examples\" [http://www.topxml.com/xsl/articles/fp/ www.topxml.com]",
            "id": "409e26e337e0fccb573a612bd00f370d"
          },
          {
            "type": "html",
            "text": " Scala [[[Scala Language]]]",
            "id": "b8cb007cbb41af612b5532516cb1af83"
          },
          {
            "type": "html",
            "text": " Ruby [[[Ruby Language]]] -- pretty mix of functional and object oriented",
            "id": "dea99ddc0a7d8b0d3490fcf191292131"
          },
          {
            "type": "html",
            "text": " Pick language and derivatives - [[Open Insight]], [[Advanced Revelation]], Universe, Unidata, Maverick, Jbase and many others.",
            "id": "8e8f87208b853f6ce5ddba203616ebb1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "<i>What are the criteria for inclusion above?</i>",
            "id": "008b6447fedf43f6fda0fab793a6c934"
          },
          {
            "type": "html",
            "text": "\nThere will be different opinions. I would include any language that\t\nencourages a functional style of programming. So ML and [[Common Lisp]] and \nScheme could be in this list.",
            "id": "7c75001e651564ba2ba4930c36518441"
          },
          {
            "type": "html",
            "text": "<i>What about Lisp? Too old? Too many side effects? Too many dialects?</i>",
            "id": "20de19b0402ec69f43f0cbe67fb0391b"
          },
          {
            "type": "html",
            "text": "\nEach Lisp should be listed on its own since they are so different especially\nin how they encourage functional programming. Clojure is the most \"functional purist\" of them, followed by Scheme and Common Lisp (in that order), which like to think of themselves as being multi-paradigm.",
            "id": "a283584b7beefcac091a98891f0c6757"
          },
          {
            "type": "html",
            "text": "<i>What about Pizza? Too young? Too short-lived? Too close to Java?</i>",
            "id": "3ac5461e58876b7062a3d1378ff9a883"
          },
          {
            "type": "html",
            "text": "\nI would include Pizza since it extends Java by adding first-class functions,\nand so encourages a functional style of programming. Much more so than the\nanonymous classes of Java.",
            "id": "9622b8bcbb29dc21aaaee4ace48634d3"
          },
          {
            "type": "html",
            "text": "<i>What about Prolog?  Too old, too academic?</i>",
            "id": "4752167c7ee2240e775571908ca166ab"
          },
          {
            "type": "html",
            "text": "\nYou cannot define a function in the [[Prolog Language]], or apply a function to its arguments. Prolog is not about functions, it is about predicates; it is a [[Logic Programming Language]].  However, both Erlang and Mercury were developed from Prolog.",
            "id": "89a55ce171b7d5132bd56711a9c6f490"
          },
          {
            "type": "html",
            "text": "<i>What about [[Python Language]]?...</i>",
            "id": "240b2950b65a97c2bf66ba55fdb59ec0"
          },
          {
            "type": "html",
            "text": "\nGuido seems to have spent a lot of breath convincing us that Python is <i>not</i> a functional programming language.  Guido even wanted to remove lambdas; however, public outcry ultimately forced him to keep lambdas in the language.",
            "id": "8135eca847cba432eccb6b5ea0e2912c"
          },
          {
            "type": "html",
            "text": "<i>Guido wanted to remove lambdas in the belief that named functions are easier to read, not out of any particular dislike for functional programming. Python contains functional features adopted from many other languages, such as Haskell's list comprehensions and LISP's map/filter/reduce (= Haskell foldl). Use of first-class functions is common in the standard library's API.</i>",
            "id": "ae22b2e4985961f4488fddf89b01c381"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "There is some discussion about the relative advantages and disadvantages of [[Functional Programming]] and [[Object Oriented Programming]] and about the degree that [[Functional Programming]] and [[Object Oriented Programming]] can be used in the same language. See [[Fp Vs Oo]], [[Oo Vs Functional]], [[Closures And Objects Are Equivalent]].",
            "id": "54b548639802708d32f1d6602cdbeaca"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "<i>What about [[Cee Omega]] and C# 3.0? They have a hybrid mix of imperative and functional paradigms.</i>",
            "id": "170b86f207239586234b9cb7cc315297"
          },
          {
            "type": "html",
            "text": "\nThose are basically vaporware at the moment, aren't they? If so, then who knows what directions they may take in the future.",
            "id": "483ddc41e929e3e2e6ab318093ae192e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "Most newer [[Functional Programming Language]]s support static type-checking, so if you have a function f of type A->B i.e. f takes an arg of type A and returns a result of type B, and an expression x of type A then you can apply f to x to get something of type B.\nSince functions are first class citizens the x could it self be a function. E.g. suppose I want a function dot which takes two functions and returns a function which applies the second fn then the first fn , its type would be:-",
            "id": "614d4dff7d499f0e659ab458cfaf393d"
          },
          {
            "type": "html",
            "text": "dot ::<br>(b -> c) -> (a -> b) -> (a -> c)",
            "id": "8b89f2fe9019f486a27fdb2cc2a6a381"
          },
          {
            "type": "html",
            "text": "(using Haskell syntax - x :: T means x is of type T. Identifiers in types starting with lower case are [[Type Variable]]s and denote arbitrary type. That is called [[Parametric Polymorphism]]). It could be defined as:-",
            "id": "2ae8901c2e42f2e70cf5a4a792434e6b"
          },
          {
            "type": "code",
            "text": "  dot f g = \\x -> f (g x)",
            "id": "a437222cd94d41b7bbd0d1b065a21714"
          },
          {
            "type": "html",
            "text": "(The \"\\x -> ..\" part is an [[Anonymous Function]].) This would be another way of defining dot:-",
            "id": "328bc96d12a6f81158b790faf51b2d0b"
          },
          {
            "type": "code",
            "text": "  dot f g x = f (g x)",
            "id": "1f2bb2fce2cfdb648578dd7dbf6abb68"
          },
          {
            "type": "html",
            "text": "(The dot function is actually defined as an infix \".\" operator in [[Haskell Language]])\nAnother example is the curry function from the Haskell prelude :-",
            "id": "faadda71e9b62ce1ebb198aac3651ed8"
          },
          {
            "type": "html",
            "text": "curry\t  ::<br>((a,b) -> c) -> (a -> b -> c)",
            "id": "238c8193e7886e73c896c8c19ee531c1"
          },
          {
            "type": "code",
            "text": "  curry f x y  = f (x,y)",
            "id": "b3b9b96a4e5fd461f40c7f41d91c180d"
          },
          {
            "type": "html",
            "text": "\ni.e. it takes a function which takes it arguments as a pair and returns an equivalent function which takes it arguments in a curried form. (See [[Currying Schonfinkelling]].)",
            "id": "be949f0b8f22b7f3d4f5a66abe40dea0"
          },
          {
            "type": "html",
            "text": "\nHence functions can be manipulated in a quite sophisticated fashion. Try to do this in C++/Java and you will probably have to write an FP interpreter. -- [[Jon Hanson]]",
            "id": "d2df5e1dd9c05dbf0a6224342980a32d"
          },
          {
            "type": "html",
            "text": "\nI wonder if you could write an [[Fp Interpreter Using Templates]]?",
            "id": "351018ab24ab0f8d0182b7a70bb8f3d1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "<b>[[[Clean Language]]]</b>",
            "id": "7c9c3eb008fde0ef72a688ce360182c7"
          },
          {
            "type": "html",
            "text": "\nTo do I/O in Clean in a functional way, you pass the world around, and compute new values of the world. Because Clean has [[Unique Type]]s, the Clean compiler can guarantee that there is always only one live copy of the world around. Therefore, it can mutate the world in-place, rather than having to copy it entirely, which would be computationally costly, to say the least. ;-)",
            "id": "2ee41098072c8f592267c73ec9cc1841"
          },
          {
            "type": "html",
            "text": "\nHaskell doesn't have [[Unique Type]]s, so it cannot take this approach.\nTherefore it uses monads. ",
            "id": "71d346e61e2c994f9040b19f7f3d46b4"
          },
          {
            "type": "html",
            "text": "<i>This is a subject of [[Holy War]]s, but </i>I<i> prefer using monads to [[Unique Type]]s. Monads are at least native functional constructs and don't need specific language support. Besides, you get rid of the explicit passing of world - which has no benefit anyway, because you can't copy the world.</i>",
            "id": "abb35539acba2e26d55091faf633130c"
          },
          {
            "type": "html",
            "text": "\n[[Unique Type]]s aren't used just for IO, other uses include arrays with destructive updating. Also [[Unique Type]]s are easier to use when you want to write code that has two kinds of effects (e.g. read a file and put the contents in an imperative array). In Clean you can freely mix the two kinds of [[Unique Type]]s where in Haskell you need to write some specific monad transformer to let you mix IO and State monads. Also you can have monads (modulo syntatic sugar like [[Do Notation]]) in Clean, but the inverse isn't possible in Haskell. Saying that [[Unique Type]]s can be very hard to grok.",
            "id": "a67bd4326eacf06de7a68a9234a81baf"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "<b>[[[Jay Language]]]</b>",
            "id": "3685eacb43e7221e97936dc6ad6459a5"
          },
          {
            "type": "html",
            "text": "\nI've been peeking at J, from [http://www.jsoftware.com/ www.jsoftware.com], and see the ad phrase that says \"OOP is easy with J4!\".  But reading the documentation, I can't see that \"locales\" can be constructed as variables, so I can't see how to implement polymorphism or inheritance.  Anyone got a clue?  --[[Alistair Cockburn]], 7/99",
            "id": "2c2d592e9a16ca837a71f8adeff16b4e"
          },
          {
            "type": "html",
            "text": "<i>[I believe the \"J4 makes OOP easy!\" statement was some part fluff, in response, after OO abilities were added, to many previous \"Does J do OOP?\" questions.]</i>",
            "id": "1062de5eb721157fbc8c1f44eb9ad516"
          },
          {
            "type": "html",
            "text": "\nIt doesn't look OO at all to me, it looks like Backus's FP revived.\nWhere does it say that OOP is easy with J4?\nI think I am too old to decipher line noise any more. --[[John Farrell]]",
            "id": "b915ffadd8e8fc92dd4f8e36902b193b"
          },
          {
            "type": "html",
            "text": "\nIt says, \"J4 makes OOP easy! \nNew language extensions include hierarchical paths and object locales that can be dynamically created and referenced. The underlying primitives allow you to follow the OOP model exactly. The new facilities are of general applicability, and so powerful and easy to use that they should dramatically improve the way we build systems in J. \" from the j download page.",
            "id": "d3448283197642ea5a7c9148cbbe7036"
          },
          {
            "type": "html",
            "text": "\n[http://www.jsoftware.com/download/download.htm www.jsoftware.com] ?\nMaybe the page has changed. The site now talks about J403. <i>[J4 refers to all releases numbered J4xx; J403 is the 3rd revision of J4.]</i>",
            "id": "d21581ffbb970d612806f62e8497b00b"
          },
          {
            "type": "html",
            "text": "\nI don't recall anything that I would consider object-oriented in J, though I don't consider that a problem. The locales seemed to be more a module or namespace feature. -- [[Ward Cunningham]]",
            "id": "a0aaa48f0d28e6b6c8c28cd2a9391e93"
          },
          {
            "type": "html",
            "text": "<i>The documentation for some recent features (OO, sparse arrays, memory mapped nouns) has not made it to the manuals and help files. Instead, Lab session scripts (which provide interactive tutorials) are included, but they are not fully meaningful outside of a J Session. J's OO abilities are implemented using locales. It's worth downloading a trial copy just to go through the labs. -- [[Jim Russell]]</i>",
            "id": "8862d306d79725e46f1408929667abc2"
          },
          {
            "type": "html",
            "text": "\nDon't know if it's of any help, but I've been playing with a simple OOP example in a number of different languages  - mostly for recreational reasons ( see [http://w3.one.net/~jweirich/oostuff/ w3.one.net] ).  I've completed the example for the J language (as well as a couple of others) which can be found at [http://www.angelfire.com/tx4/cus/shapes/index.html www.angelfire.com] .  -- [[Chris Rathman]]",
            "id": "69f34309244048b0246c083b4ebab86b"
          },
          {
            "type": "html",
            "text": "[2001/08] A HTML Manual is installed together with the software, which is more up-do-date than the PDFs on the download page. In the manual for the free edition for windows I found a chapter on OOP. Its path is <j406d_root_folder>\\system\\extras\\help\\learning\\25.htm",
            "id": "7729dd622a4ca5614e83145c2049531e"
          },
          {
            "type": "html",
            "text": "\n[http://www.jsoftware.com/download/download.htm www.jsoftware.com]",
            "id": "55b6be337441dc3f2fb2a83a2cfc44a2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "<b>[C++]</b>",
            "id": "2388429e16fdb99888a7b7f3053df505"
          },
          {
            "type": "html",
            "text": "\nYou can get currying in native [[Cee Plus Plus]] using Templates. And a form of lambda functions are also possible.\nSee",
            "id": "10f996a78e6b774a92861365e431cae8"
          },
          {
            "type": "html",
            "text": " [[Boost Lambda Library]] - part of the [[Boost Libraries]]",
            "id": "1a5e3bd26c71bbd66fb550d134ed1c29"
          },
          {
            "type": "html",
            "text": " [http://www.fz-juelich.de/zam/FACT www.fz-juelich.de]",
            "id": "fb1d9b62ffcde44c59ddaa43f9bc309e"
          },
          {
            "type": "html",
            "text": " [[Functoids In Cpp]] ([http://www.cc.gatech.edu/~yannis/fc++/ www.cc.gatech.edu])",
            "id": "3e7984a80c90de2b2ddc9cc4429f0ee1"
          },
          {
            "type": "html",
            "text": "\nSee also [[Functional Programming In Cpp]].",
            "id": "7566d659b4b1ae4b39d89feaf97af605"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "<b>[PHP]</b>",
            "id": "fa6ec10afbdb3bd16824a47d11783bbd"
          },
          {
            "type": "html",
            "text": "\nPHP programmers may want to check out this library that adds some functional programming abilities to PHP4.\nSee",
            "id": "324741d9e6770dafbc1efa58adc04faa"
          },
          {
            "type": "html",
            "text": " [http://functional-php.sourceforge.net/ functional-php.sourceforge.net]",
            "id": "198e20e010815e4aab824bb951e86582"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "<b>[[[Aleph Language]]]</b> (See [http://www.aleph-lang.org/ www.aleph-lang.org]). From the website:",
            "id": "51a2a99050f9b35da1f49a672fb26f3d"
          },
          {
            "type": "html",
            "text": "\"Aleph is a multi-threaded functional programming language with dynamic symbol bindings that support the object oriented paradigm. Aleph features a state of the art runtime engine that supports both 32 and 64 bits platforms. Aleph comes with a rich set of libraries that are designed to be platform independent\"",
            "id": "4e10c0adfe6d5f4685b7b345d5985bb7"
          },
          {
            "type": "html",
            "text": "\nThe last release is from mid-2001 but the language is kinda interesting, and the compiler is really cool (written in C++, it compiled without errors on gcc 2.96.x and just two unprotected #define's in a couple of header files in gcc-3.2. No warnings.",
            "id": "fe1de1f787fc374bca69fcfae7636a0c"
          },
          {
            "type": "html",
            "text": "\nIt's a shame they don't seem to be developing/supporting it further. Maybe it can be saved if we manage to get a community effort (licenses providing, the compiler was [[Free Software]]).",
            "id": "56abea8977776d9113bcd2726093c145"
          },
          {
            "type": "html",
            "text": " <i>(Update: I have managed to get in touch with Aleph author, [[Amaury Darsch]], and he's indeed silently working on version 0.9.0, with updates on the web site coming soon. Joy!)</i>",
            "id": "3115c00693fa2096a62d5e32802a7bac"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "[[Christophe Poucet]] asks [[Which Functional Language To Learn]].",
            "id": "d783459aeef7208120004784a329fa70"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "20081106 -- [[Chris Garrod]] asks would it be ok to alphebetize the languages on this page? ",
            "id": "31fe496ee08fe963dd72f02994683d81"
          },
          {
            "type": "html",
            "text": "\nThat would be reasonable, but I would consider ensuring there is a list naming the most 'mainstream' FPLs at the top (Haskell, ML, Erlang). Other orders that are okay would be order of creation.",
            "id": "95265cb2aa4c43f86d2252124e919637"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "April 2010\nWhat kind of programs do you think are written more easily in FP languages? Specifically for people who use FP and non-FP languages - what situations do you find yourself using FP languages for? For example, I'm an aspring academic. Are they especially suited to mathematical and/or logical thinking? Number crunching? ",
            "id": "c263036f7d1e4d52cc791d0bbc93fc95"
          },
          {
            "type": "html",
            "text": "--[[Jason Espinosa]]",
            "id": "34933f7e2a2fe7b109003176085acd65"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "Is [[Lua Language]] a functional programming language?  \nI was just debating this with someone who claims it is not.  But if not, what disqualifies it (that does not also disqualify [[Scheme Language]]?)",
            "id": "c6481ba853f40b6f5d592ae439ec18d2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "[[Why Functional Programming Languages Arent Mainstream]]",
            "id": "d31cc62aa0d0f4d625aab14723071c9f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "45cefdb5a761cc95b9cf4471e946e3f2"
          },
          {
            "type": "html",
            "text": "[[Category Functional Programming]]",
            "id": "1c9dd4b02873b76968f7c180fb63c476"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?FunctionalProgrammingLanguage c2.com]",
            "id": "492ad23e798b58385e19df290b60a0c5"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com"
    },
    {
      "type": "edit",
      "id": "2c2d592e9a16ca837a71f8adeff16b4e",
      "item": {
        "type": "html",
        "text": "I've been peeking at J, from [http://www.jsoftware.com/ www.jsoftware.com], and see the ad phrase that says \"OOP is easy with J4!\".  But reading the documentation, I can't see that \"locales\" can be constructed as variables, so I can't see how to implement polymorphism or inheritance.  Anyone got a clue?  --[[Alistair Cockburn]], 7/99",
        "id": "2c2d592e9a16ca837a71f8adeff16b4e"
      },
      "date": 1597120174656
    },
    {
      "type": "fork",
      "site": "wellspring.fed.wiki",
      "date": 1644990998661
    }
  ]
}