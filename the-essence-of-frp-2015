{
  "title": "The Essence of FRP 2015",
  "story": [
    {
      "type": "paragraph",
      "id": "88aa9ec3c9555e1e",
      "text": "The Essence of FRP by Jozsef Hegedus at Helsinki FRP Meetup April 1, 2015 - YouTube (2015). Online verf端gbar unter https://www.youtube.com/watch?v=CjEDmJMLEGE&t=303s, zuletzt aktualisiert am 20.11.2020, zuletzt gepr端ft am 20.11.2020."
    },
    {
      "type": "video",
      "id": "206a2e6a0387cc11",
      "text": "YOUTUBE CjEDmJMLEGE"
    },
    {
      "type": "paragraph",
      "id": "b548a4380bcbe376",
      "text": "you can you can really relax now because this is gonna be very very relaxing so while you already read it so who knows about this [[Sodium]] aha okay - but the nice nice thing is that you will be able to program in it after this talk if you want to in these languages"
    },
    {
      "type": "paragraph",
      "id": "49d38bc895fb57f8",
      "text": "this book is really nice it's being written and it describes in detail the library it has two classes or data types which are basically the same that Gary mentioned no surprise and 9:9 functions so if you know this then you know everything in Haskell this is one thousand lines of code or something one of their classes or data types is stream called which is the same as event and it has no memory it forgets everything and the other one has memory it can remember here you can see that nine functions then if you understand these nine functions you really understand everything let's see how you can you can write your FIP program tomorrow if you want to they were your program wants to communicate to the world so you want to take inputs from the world like Mouse or whatever and put something to the world but in that inside there is this engine that does all the interesting computations and it represents the the input so it somehow has a kind of representation of the world which comes from the input and it also has a representation that should go to the output but in between there is logic I will show you that very nice how has ink a application that is used in this way let's see it cannot run is it dark dark ish okay so we got it and called a little bit yes so we stop and go back well this hello Helsinki application has exactly this structure here it has a world the keyboard and also the output screen and I can show you how the structure in this program looks like this structure first you create the engine and in the engine you create the three core parts which are their input logic you connect the input to the logic and you get the output and then you connect to the engine into the world first you connect the output by listening to that stream and doing something with it with the value that you get the X and then you take care of the input from the world and you send those inputs to the input layer of the engine so what you seen before was the map operation and you can represent this map operation in a graphical way by by this rectangle and the stream is representing just by an arrow so you can make use of your GPU in your head when you are writing software the next example is going to be the filter just to keep it simple it takes a stream and predicate and if the predicate is true and the output stream is going to fire it is may be interesting to mention here that you know in a sense you can think about a stream that it's it's a continuous function of time that's one way to represent it and everywhere when it does not fire it has a bottom or undefined so in this way this filter is a true function a mathematical function that takes a value and if the predicate is not true then it outputs a bottom anyway I will come back to this a little bit later you can see it might be a little bit important so this is how it looks like this is a stream this is a filter as in electronics this tilde and it goes through the event if we have an apple in our stream and then we transform this and we put it to the output and let's see how this looks like in this simple application just that we see something in action and why I write banana nothing happens but if I write Apple I get a sweet apple okay so let's see what we have here the next one is the snapshot and hold that Gary also mentioned let's see what they do the the upper branch we create our cell by the hold function and the the value that this takes is is the initial value and this here represents that the snapshot represented by this shape takes the output cell as our parameter but this does not represent any real stream this is just a way to show that this is a parameter to this function so let's see what this does when you when you kind of run it he's going to do exactly what you think it does we get an update of the first event or value so we don't miss it and if it's a natural number that we put in then the output cell has changed and we see it because we are listening to this output cell here but we can also read it out so this is outputs that cell has a memory it remembers what was in it so we want to make a snapshot of the of this output cell and it remembers the value so if I put in 20 then we get this so this is very nice and simple but let's see how can we make this even more simple because we want to count something for example how many times you press a button or something and then you need a loop and somehow you would like to think that this is the old value of the counter and oh I just pressed it sorry let's go back so this is the old value of the counter and every time we increment every time we send this command here to the input stream then this even goes true and this snapshot is going to take our basically it's going to take this value from the counter and produce a new stream that will be the counter which is updated so and then this hold is going to hold a new stream but this is somehow strange because this is circular so so this this is not really good but instead this is just a technical kind of issue but in in sodium you you have to write this extra and basically that's it that's how you do it in sodium this is a technical issue do not worry about it I don't and just to see what happens we can also take our snapshot and it's interesting because we can also take a snapshot and increment the counter at the same time so that's also interesting what happens then so let's go into detail we are listening on this counter so that we know what we're use it taking and you can already see what's going to happen here and I I could run this program but it's it's more visual this way so when you start the program you get the first value at tau zero and this tau is important that it is larger than T 0 it will be important later and then we take a snapshot and then we get what we expect because we subscribed to this snapshot stream so we have it on the output and at this point we sent the command increment counter to the input stream and that is going to go through here and it's going to increment our counter and we get an update of the counter but it's important to say that it also happens at tau 2 which is a little bit larger than this t 2 conceptually it's not the same time and now we come to the interesting part what happens here and why we need the difference between tau and B this is one and that is surprising in a way but it explained because they happen at the same time so that's why it is the same value so it hasn't been sort of incremented yet so the the the new value is always seen just after all the event propagation kind of was taken care of and then you see the simple part and you take another final snapshot and you see that you get the value that you expect okay so let's simplify things by going up out of this place we are here and we go up and up and you look at FIP from the sky but before we do that we need to look a little bit closer and really see what these little things do here what these little streams do so we listen to all of them so that we know what what the value is and we go back to the same example because we are going to do a simple transformation of the of the code you know in a more sort of denotational or mathematical way so when we well I also shortened this snap and ink so that it fits on the slide when you write that you get this so this is the input stream and it goes through here so you get these new output nothing surprising and that is our mathematical description of the of the program so here it is important to think about that this h3 is this filter and it's it can be a mathematical function if you think that this value is undefined then this value is also undefined so if this is not firing then this is also not firing but if this is firing and it doesn't have this snap command in it and this is not gonna fire and it's gonna be undefined so that's one way to think about it and this depends on cell this is a snapshot and it gives us this output value it's not very complicated it just takes the value and throws away this part but it doesn't have to prove a it can it can somehow combine it like like it combines it here okay so now that we know how this mathematical formulation looks like let's look at what happens here and this is the interesting part because this tau 2 is conceptually different from T 2 and the question is why it is different because tau 2 and T 3 are equal so for example you can see here that tau 2 and T 3 so if you if you take this function this function is constant at this at this point and it always jumps in this way so with a little bit of epsilon delay it changes so this is kind of the conceptual model and well this is this is good to even even though that that you get this on the screen and you put this command in together with these other outputs this is this is conceptually different so what happens if we do that two things at the same time this is what we get and you see that we get this behavior this contrasting behavior again so this is the reason why we we need to differentiate between these two they are not the same even though they happen at the same time when it when you type it in that's the reason why there is tau and T and here is the mathematical way to describe this this system here and this is pretty much the same what you have seen so far and the last one is just a simple snap and we get what you expect this is the updated value and and this is just the same mathematical thing so I am 11 seconds over time and I have only one slide left so let's see what it is now the question is can you can you somehow simplify this when you look at this like like how can you simplify these kind of equations because we want to look at it from a very high point somehow from the from the from the sky okay so one one way to simplifies to see that here are these indices so we wanna have this vector representation for everything with these indices and also for the H and for the C as well and then you see that this is the equation that you get so this is this is your program part of your program that you write in sodium but this is this is not kind of functional reactive programming yet because it forgets everything there is this you cannot describe anything time-dependent in this one there is no time evolution here because the slices of time are always different so p1 is not connected to t2 in any way but the next equation which is this is going to connect two slices in the time and this is what really makes in my understanding FRP what is FRP is and this is this plus one here because in this equation you have two different times so two times are connected the first equation is just just functional programming it's our core graph here really but the second one is functional reactive programming because you step from one time to the next time and so on so we can we can burn this now because this is enough to describe and one final question remains so varies varies displacement coming from well where is this essence of FRP coming from because if because if there is no plus one then we are doing functional programming but if there is plus one then we do FRP and it comes from the hold because that's that's what creates a cell and that is the one that can remember something so you can connect the past to the present the present to the future okay so so this is the talk I am three minutes over time sorry about that I thank you very much for for for react or to providing this really really nice place and you guys attending this and I have"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "The Essence of FRP 2015",
        "story": []
      },
      "date": 1712070438549
    },
    {
      "item": {
        "type": "factory",
        "id": "88aa9ec3c9555e1e"
      },
      "id": "88aa9ec3c9555e1e",
      "type": "add",
      "date": 1712070440126
    },
    {
      "type": "edit",
      "id": "88aa9ec3c9555e1e",
      "item": {
        "type": "paragraph",
        "id": "88aa9ec3c9555e1e",
        "text": "The Essence of FRP by Jozsef Hegedus at Helsinki FRP Meetup April 1, 2015 - YouTube (2015). Online verf端gbar unter https://www.youtube.com/watch?v=CjEDmJMLEGE&t=303s, zuletzt aktualisiert am 20.11.2020, zuletzt gepr端ft am 20.11.2020."
      },
      "date": 1712070451244
    },
    {
      "item": {
        "type": "factory",
        "id": "206a2e6a0387cc11"
      },
      "id": "206a2e6a0387cc11",
      "type": "add",
      "after": "88aa9ec3c9555e1e",
      "date": 1712070453263
    },
    {
      "type": "edit",
      "id": "206a2e6a0387cc11",
      "item": {
        "type": "video",
        "id": "206a2e6a0387cc11",
        "text": "YOUTUBE CjEDmJMLEGE"
      },
      "date": 1712070458862
    },
    {
      "item": {
        "type": "factory",
        "id": "b548a4380bcbe376"
      },
      "id": "b548a4380bcbe376",
      "type": "add",
      "after": "206a2e6a0387cc11",
      "date": 1712070658736
    },
    {
      "type": "edit",
      "id": "b548a4380bcbe376",
      "item": {
        "type": "paragraph",
        "id": "b548a4380bcbe376",
        "text": "you can you can really relax now because this is gonna be very very relaxing so while you already read it so who knows about this sodium aha okay - but the nice nice thing is that you will be able to program in it after this talk if you want to in these languages this book is really nice it's being written and it describes in detail the library it has two classes or data types which are basically the same that Gary mentioned no surprise and 9:9 functions so if you know this then you know everything in Haskell this is one thousand lines of code or something one of their classes or data types is stream called which is the same as event and it has no memory it forgets everything and the other one has memory it can remember here you can see that nine functions then if you understand these nine functions you really understand everything let's see how you can you can write your FIP program tomorrow if you want to they were your program wants to communicate to the world so you want to take inputs from the world like Mouse or whatever and put something to the world but in that inside there is this engine that does all the interesting computations and it represents the the input so it somehow has a kind of representation of the world which comes from the input and it also has a representation that should go to the output but in between there is logic I will show you that very nice how has ink a application that is used in this way let's see it cannot run is it dark dark ish okay so we got it and called a little bit yes so we stop and go back well this hello Helsinki application has exactly this structure here it has a world the keyboard and also the output screen and I can show you how the structure in this program looks like this structure first you create the engine and in the engine you create the three core parts which are their input logic you connect the input to the logic and you get the output and then you connect to the engine into the world first you connect the output by listening to that stream and doing something with it with the value that you get the X and then you take care of the input from the world and you send those inputs to the input layer of the engine so what you seen before was the map operation and you can represent this map operation in a graphical way by by this rectangle and the stream is representing just by an arrow so you can make use of your GPU in your head when you are writing software the next example is going to be the filter just to keep it simple it takes a stream and predicate and if the predicate is true and the output stream is going to fire it is may be interesting to mention here that you know in a sense you can think about a stream that it's it's a continuous function of time that's one way to represent it and everywhere when it does not fire it has a bottom or undefined so in this way this filter is a true function a mathematical function that takes a value and if the predicate is not true then it outputs a bottom anyway I will come back to this a little bit later you can see it might be a little bit important so this is how it looks like this is a stream this is a filter as in electronics this tilde and it goes through the event if we have an apple in our stream and then we transform this and we put it to the output and let's see how this looks like in this simple application just that we see something in action and why I write banana nothing happens but if I write Apple I get a sweet apple okay so let's see what we have here the next one is the snapshot and hold that Gary also mentioned let's see what they do the the upper branch we create our cell by the hold function and the the value that this takes is is the initial value and this here represents that the snapshot represented by this shape takes the output cell as our parameter but this does not represent any real stream this is just a way to show that this is a parameter to this function so let's see what this does when you when you kind of run it he's going to do exactly what you think it does we get an update of the first event or value so we don't miss it and if it's a natural number that we put in then the output cell has changed and we see it because we are listening to this output cell here but we can also read it out so this is outputs that cell has a memory it remembers what was in it so we want to make a snapshot of the of this output cell and it remembers the value so if I put in 20 then we get this so this is very nice and simple but let's see how can we make this even more simple because we want to count something for example how many times you press a button or something and then you need a loop and somehow you would like to think that this is the old value of the counter and oh I just pressed it sorry let's go back so this is the old value of the counter and every time we increment every time we send this command here to the input stream then this even goes true and this snapshot is going to take our basically it's going to take this value from the counter and produce a new stream that will be the counter which is updated so and then this hold is going to hold a new stream but this is somehow strange because this is circular so so this this is not really good but instead this is just a technical kind of issue but in in sodium you you have to write this extra and basically that's it that's how you do it in sodium this is a technical issue do not worry about it I don't and just to see what happens we can also take our snapshot and it's interesting because we can also take a snapshot and increment the counter at the same time so that's also interesting what happens then so let's go into detail we are listening on this counter so that we know what we're use it taking and you can already see what's going to happen here and I I could run this program but it's it's more visual this way so when you start the program you get the first value at tau zero and this tau is important that it is larger than T 0 it will be important later and then we take a snapshot and then we get what we expect because we subscribed to this snapshot stream so we have it on the output and at this point we sent the command increment counter to the input stream and that is going to go through here and it's going to increment our counter and we get an update of the counter but it's important to say that it also happens at tau 2 which is a little bit larger than this t 2 conceptually it's not the same time and now we come to the interesting part what happens here and why we need the difference between tau and B this is one and that is surprising in a way but it explained because they happen at the same time so that's why it is the same value so it hasn't been sort of incremented yet so the the the new value is always seen just after all the event propagation kind of was taken care of and then you see the simple part and you take another final snapshot and you see that you get the value that you expect okay so let's simplify things by going up out of this place we are here and we go up and up and you look at FIP from the sky but before we do that we need to look a little bit closer and really see what these little things do here what these little streams do so we listen to all of them so that we know what what the value is and we go back to the same example because we are going to do a simple transformation of the of the code you know in a more sort of denotational or mathematical way so when we well I also shortened this snap and ink so that it fits on the slide when you write that you get this so this is the input stream and it goes through here so you get these new output nothing surprising and that is our mathematical description of the of the program so here it is important to think about that this h3 is this filter and it's it can be a mathematical function if you think that this value is undefined then this value is also undefined so if this is not firing then this is also not firing but if this is firing and it doesn't have this snap command in it and this is not gonna fire and it's gonna be undefined so that's one way to think about it and this depends on cell this is a snapshot and it gives us this output value it's not very complicated it just takes the value and throws away this part but it doesn't have to prove a it can it can somehow combine it like like it combines it here okay so now that we know how this mathematical formulation looks like let's look at what happens here and this is the interesting part because this tau 2 is conceptually different from T 2 and the question is why it is different because tau 2 and T 3 are equal so for example you can see here that tau 2 and T 3 so if you if you take this function this function is constant at this at this point and it always jumps in this way so with a little bit of epsilon delay it changes so this is kind of the conceptual model and well this is this is good to even even though that that you get this on the screen and you put this command in together with these other outputs this is this is conceptually different so what happens if we do that two things at the same time this is what we get and you see that we get this behavior this contrasting behavior again so this is the reason why we we need to differentiate between these two they are not the same even though they happen at the same time when it when you type it in that's the reason why there is tau and T and here is the mathematical way to describe this this system here and this is pretty much the same what you have seen so far and the last one is just a simple snap and we get what you expect this is the updated value and and this is just the same mathematical thing so I am 11 seconds over time and I have only one slide left so let's see what it is now the question is can you can you somehow simplify this when you look at this like like how can you simplify these kind of equations because we want to look at it from a very high point somehow from the from the from the sky okay so one one way to simplifies to see that here are these indices so we wanna have this vector representation for everything with these indices and also for the H and for the C as well and then you see that this is the equation that you get so this is this is your program part of your program that you write in sodium but this is this is not kind of functional reactive programming yet because it forgets everything there is this you cannot describe anything time-dependent in this one there is no time evolution here because the slices of time are always different so p1 is not connected to t2 in any way but the next equation which is this is going to connect two slices in the time and this is what really makes in my understanding FRP what is FRP is and this is this plus one here because in this equation you have two different times so two times are connected the first equation is just just functional programming it's our core graph here really but the second one is functional reactive programming because you step from one time to the next time and so on so we can we can burn this now because this is enough to describe and one final question remains so varies varies displacement coming from well where is this essence of FRP coming from because if because if there is no plus one then we are doing functional programming but if there is plus one then we do FRP and it comes from the hold because that's that's what creates a cell and that is the one that can remember something so you can connect the past to the present the present to the future okay so so this is the talk I am three minutes over time sorry about that I thank you very much for for for react or to providing this really really nice place and you guys attending this and I have"
      },
      "date": 1712070669424
    },
    {
      "type": "edit",
      "id": "b548a4380bcbe376",
      "item": {
        "type": "paragraph",
        "id": "b548a4380bcbe376",
        "text": "you can you can really relax now because this is gonna be very very relaxing so while you already read it so who knows about this sodium aha okay - but the nice nice thing is that you will be able to program in it after this talk if you want to in these languages"
      },
      "date": 1712070711324
    },
    {
      "type": "add",
      "id": "49d38bc895fb57f8",
      "item": {
        "type": "paragraph",
        "id": "49d38bc895fb57f8",
        "text": "this book is really nice it's being written and it describes in detail the library it has two classes or data types which are basically the same that Gary mentioned no surprise and 9:9 functions so if you know this then you know everything in Haskell this is one thousand lines of code or something one of their classes or data types is stream called which is the same as event and it has no memory it forgets everything and the other one has memory it can remember here you can see that nine functions then if you understand these nine functions you really understand everything let's see how you can you can write your FIP program tomorrow if you want to they were your program wants to communicate to the world so you want to take inputs from the world like Mouse or whatever and put something to the world but in that inside there is this engine that does all the interesting computations and it represents the the input so it somehow has a kind of representation of the world which comes from the input and it also has a representation that should go to the output but in between there is logic I will show you that very nice how has ink a application that is used in this way let's see it cannot run is it dark dark ish okay so we got it and called a little bit yes so we stop and go back well this hello Helsinki application has exactly this structure here it has a world the keyboard and also the output screen and I can show you how the structure in this program looks like this structure first you create the engine and in the engine you create the three core parts which are their input logic you connect the input to the logic and you get the output and then you connect to the engine into the world first you connect the output by listening to that stream and doing something with it with the value that you get the X and then you take care of the input from the world and you send those inputs to the input layer of the engine so what you seen before was the map operation and you can represent this map operation in a graphical way by by this rectangle and the stream is representing just by an arrow so you can make use of your GPU in your head when you are writing software the next example is going to be the filter just to keep it simple it takes a stream and predicate and if the predicate is true and the output stream is going to fire it is may be interesting to mention here that you know in a sense you can think about a stream that it's it's a continuous function of time that's one way to represent it and everywhere when it does not fire it has a bottom or undefined so in this way this filter is a true function a mathematical function that takes a value and if the predicate is not true then it outputs a bottom anyway I will come back to this a little bit later you can see it might be a little bit important so this is how it looks like this is a stream this is a filter as in electronics this tilde and it goes through the event if we have an apple in our stream and then we transform this and we put it to the output and let's see how this looks like in this simple application just that we see something in action and why I write banana nothing happens but if I write Apple I get a sweet apple okay so let's see what we have here the next one is the snapshot and hold that Gary also mentioned let's see what they do the the upper branch we create our cell by the hold function and the the value that this takes is is the initial value and this here represents that the snapshot represented by this shape takes the output cell as our parameter but this does not represent any real stream this is just a way to show that this is a parameter to this function so let's see what this does when you when you kind of run it he's going to do exactly what you think it does we get an update of the first event or value so we don't miss it and if it's a natural number that we put in then the output cell has changed and we see it because we are listening to this output cell here but we can also read it out so this is outputs that cell has a memory it remembers what was in it so we want to make a snapshot of the of this output cell and it remembers the value so if I put in 20 then we get this so this is very nice and simple but let's see how can we make this even more simple because we want to count something for example how many times you press a button or something and then you need a loop and somehow you would like to think that this is the old value of the counter and oh I just pressed it sorry let's go back so this is the old value of the counter and every time we increment every time we send this command here to the input stream then this even goes true and this snapshot is going to take our basically it's going to take this value from the counter and produce a new stream that will be the counter which is updated so and then this hold is going to hold a new stream but this is somehow strange because this is circular so so this this is not really good but instead this is just a technical kind of issue but in in sodium you you have to write this extra and basically that's it that's how you do it in sodium this is a technical issue do not worry about it I don't and just to see what happens we can also take our snapshot and it's interesting because we can also take a snapshot and increment the counter at the same time so that's also interesting what happens then so let's go into detail we are listening on this counter so that we know what we're use it taking and you can already see what's going to happen here and I I could run this program but it's it's more visual this way so when you start the program you get the first value at tau zero and this tau is important that it is larger than T 0 it will be important later and then we take a snapshot and then we get what we expect because we subscribed to this snapshot stream so we have it on the output and at this point we sent the command increment counter to the input stream and that is going to go through here and it's going to increment our counter and we get an update of the counter but it's important to say that it also happens at tau 2 which is a little bit larger than this t 2 conceptually it's not the same time and now we come to the interesting part what happens here and why we need the difference between tau and B this is one and that is surprising in a way but it explained because they happen at the same time so that's why it is the same value so it hasn't been sort of incremented yet so the the the new value is always seen just after all the event propagation kind of was taken care of and then you see the simple part and you take another final snapshot and you see that you get the value that you expect okay so let's simplify things by going up out of this place we are here and we go up and up and you look at FIP from the sky but before we do that we need to look a little bit closer and really see what these little things do here what these little streams do so we listen to all of them so that we know what what the value is and we go back to the same example because we are going to do a simple transformation of the of the code you know in a more sort of denotational or mathematical way so when we well I also shortened this snap and ink so that it fits on the slide when you write that you get this so this is the input stream and it goes through here so you get these new output nothing surprising and that is our mathematical description of the of the program so here it is important to think about that this h3 is this filter and it's it can be a mathematical function if you think that this value is undefined then this value is also undefined so if this is not firing then this is also not firing but if this is firing and it doesn't have this snap command in it and this is not gonna fire and it's gonna be undefined so that's one way to think about it and this depends on cell this is a snapshot and it gives us this output value it's not very complicated it just takes the value and throws away this part but it doesn't have to prove a it can it can somehow combine it like like it combines it here okay so now that we know how this mathematical formulation looks like let's look at what happens here and this is the interesting part because this tau 2 is conceptually different from T 2 and the question is why it is different because tau 2 and T 3 are equal so for example you can see here that tau 2 and T 3 so if you if you take this function this function is constant at this at this point and it always jumps in this way so with a little bit of epsilon delay it changes so this is kind of the conceptual model and well this is this is good to even even though that that you get this on the screen and you put this command in together with these other outputs this is this is conceptually different so what happens if we do that two things at the same time this is what we get and you see that we get this behavior this contrasting behavior again so this is the reason why we we need to differentiate between these two they are not the same even though they happen at the same time when it when you type it in that's the reason why there is tau and T and here is the mathematical way to describe this this system here and this is pretty much the same what you have seen so far and the last one is just a simple snap and we get what you expect this is the updated value and and this is just the same mathematical thing so I am 11 seconds over time and I have only one slide left so let's see what it is now the question is can you can you somehow simplify this when you look at this like like how can you simplify these kind of equations because we want to look at it from a very high point somehow from the from the from the sky okay so one one way to simplifies to see that here are these indices so we wanna have this vector representation for everything with these indices and also for the H and for the C as well and then you see that this is the equation that you get so this is this is your program part of your program that you write in sodium but this is this is not kind of functional reactive programming yet because it forgets everything there is this you cannot describe anything time-dependent in this one there is no time evolution here because the slices of time are always different so p1 is not connected to t2 in any way but the next equation which is this is going to connect two slices in the time and this is what really makes in my understanding FRP what is FRP is and this is this plus one here because in this equation you have two different times so two times are connected the first equation is just just functional programming it's our core graph here really but the second one is functional reactive programming because you step from one time to the next time and so on so we can we can burn this now because this is enough to describe and one final question remains so varies varies displacement coming from well where is this essence of FRP coming from because if because if there is no plus one then we are doing functional programming but if there is plus one then we do FRP and it comes from the hold because that's that's what creates a cell and that is the one that can remember something so you can connect the past to the present the present to the future okay so so this is the talk I am three minutes over time sorry about that I thank you very much for for for react or to providing this really really nice place and you guys attending this and I have"
      },
      "after": "b548a4380bcbe376",
      "date": 1712070713684
    },
    {
      "type": "edit",
      "id": "b548a4380bcbe376",
      "item": {
        "type": "paragraph",
        "id": "b548a4380bcbe376",
        "text": "you can you can really relax now because this is gonna be very very relaxing so while you already read it so who knows about this [[Sodium]] aha okay - but the nice nice thing is that you will be able to program in it after this talk if you want to in these languages"
      },
      "date": 1712070741810
    }
  ]
}