{
  "title": "High Level Language",
  "story": [
    {
      "type": "html",
      "text": "A [[High Level Language]] is a [[Programming Language]] that supports system development at a high [[Level Of Abstraction]], thereby freeing the developer from keeping in his head lots of details that are irrelevant to the problem at hand.",
      "id": "c743c259ca036f3f5da546861ee22179"
    },
    {
      "type": "html",
      "text": "\nWhere the programmer has a free choice, starting a development effort at a high level of abstraction often leads to shorter development time since it retains opportunities to specialize the design, e.g. to adapt it to unforeseen insights into the [[Application Domain]] or to incorporate changing requirements. It is usually harder to generalize a specific design than to specialize or extend the design, since unanticipated generalization may force the re-examination of many existing relations between the constituents of the system to identify hard-coded design decisions that may have been invalidated. However, see [[Premature Generalization]].",
      "id": "ddf3afff30ddcf998e736bb6dc674222"
    },
    {
      "type": "html",
      "text": "\nStarting a development effort at a low level of abstraction often leads to [[Premature Optimization]]. Also see [[Top Down Programming]] and [[Bottom Up Programming]]. However, some [[Low Level Language]]s can be considered [[Domain Specific Languages]] for tasks such as [[Embedded Software]]: they are not all merely survivors of an earlier age.",
      "id": "6bab733733796c3e2a35f32c04d83116"
    },
    {
      "type": "html",
      "text": "\nWorking at a high level of abstraction does not necessarily preclude runtime efficiency of the implementation. Many modern languages (e.g. [[Cee Plus Plus]], [[Common Lisp]], [[Ada Language]]) aim to provide access to low level elements of the implementation while retaining means to develop at a high level of abstraction. Most language implementations allow to <i>drop out</i> to a different language to implement specific parts of a system at a lower level of abstraction.",
      "id": "2daca6fde43e5dd9edebfdca745c7575"
    },
    {
      "type": "html",
      "text": "\nThe term \"High Level Language\" was originally used to distinguish things like [[Fortran Language]] from things like assembly language. Therefore, originally \"high level language\" very much included Fortran, Basic, COBOL, PL/I, and a little later, C.",
      "id": "654205c72c1e9bf9b53a56b4a74b052e"
    },
    {
      "type": "html",
      "text": "\nObserving that such languages are not <b>very</b> high level compared with e.g. Prolog, YACC, Lex, ML, Haskell, etc, some people started calling the older high-level languages \"low-level languages\", or qualifying them as \"high<b>er</b> level languages\", etc. This is often erroneously thought to be revisionism, but is the very basis of much of Computer Science, and such terminology while not universally accepted among all programmers, is at least understood by those with a broad understanding of the relevant foundations of the topic at hand.",
      "id": "76ecf7c9e670f4dc6f4b5910ac55c1c1"
    },
    {
      "type": "html",
      "text": "\nA more diplomatic approach to the topic, while sacrificing accuracy to appeal to the less-disciplined mind, would be to simply call more sophisticated languages \"very high level languages\", if a distinction is needed, rather than trying to snidely imply (or state outright) that there's no difference between assembler and Fortran, Basic, COBOL, PL/I, C etc.",
      "id": "b801afa1182ea0aba3b7753565aa9cc3"
    },
    {
      "type": "html",
      "text": "\nNo one who has done extensive programming in assembler would ever make the mistake of calling such things \"low level languages\"; there is a very sharp and painful difference.",
      "id": "3a7fd2a712f39349ddb7924a5c73a338"
    },
    {
      "type": "html",
      "text": "\nSee Also [[Alternate Hard And Soft Layers]], [[Cee As An Intermediate Language]], [[Nth Generation Language]], [[Domain Specific Language]].",
      "id": "4e67e3e3cdbfff7951fb715aba72948d"
    },
    {
      "type": "html",
      "text": "\nContrast with [[Low Level Language]]s like [[Assembly Language]].",
      "id": "3d1a7fb55f93a251c8848e1e28fb78b8"
    },
    {
      "type": "html",
      "text": "[[[Edit Hint]]: the bottom area needs a re-arrangement]",
      "id": "443c104f819d61fc7870f31218bae202"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "55175bbfb8735f13902276759ed58dcb"
    },
    {
      "type": "html",
      "text": "Some [[Programming Paradigm]]s appear to be at an intrinsically higher level of abstraction than others (compare [[Declarative Programming]] with [[Imperative Programming]]). See [[Measuring Abstraction]], and [[Language Oriented Programming]].",
      "id": "20073d2a347b00ad6b9818df70c95e06"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "55175bbfb8735f13902276759ed58dcb"
    },
    {
      "type": "html",
      "text": "Perhaps some languages, like [[Lisp Language]] and [[Forth Language]], should be given the class of [[Vari Level Language]], since the level of abstractions offered by the language depends directly on how much you've altered the language to suit your problem domain? -- [[Samuel Falvo]]",
      "id": "9d702e2c84178aba91ca3db2e5dfd79a"
    },
    {
      "type": "html",
      "text": "\nI prefer '[[Meta Language]]' for languages that allow you alter the language or create DSLs.",
      "id": "d548f310eb38bc6a0fea3410e956ed6e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "55175bbfb8735f13902276759ed58dcb"
    },
    {
      "type": "html",
      "text": "[[Category Abstraction]] [[Category Programming Language]]",
      "id": "5651954003a5e680c170e617c8ecbadb"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?HighLevelLanguage c2.com]",
      "id": "06c9a497f769f560ccd271b0c2a54457"
    }
  ],
  "journal": [
    {
      "date": 1414484701000,
      "id": "6c85b35caf68fab92ddad652fe9f0707",
      "type": "create",
      "item": {
        "title": "High Level Language",
        "story": [
          {
            "type": "html",
            "text": "A [[High Level Language]] is a [[Programming Language]] that supports system development at a high [[Level Of Abstraction]], thereby freeing the developer from keeping in his head lots of details that are irrelevant to the problem at hand.",
            "id": "c743c259ca036f3f5da546861ee22179"
          },
          {
            "type": "html",
            "text": "\nWhere the programmer has a free choice, starting a development effort at a high level of abstraction often leads to shorter development time since it retains opportunities to specialize the design, e.g. to adapt it to unforeseen insights into the [[Application Domain]] or to incorporate changing requirements. It is usually harder to generalize a specific design than to specialize or extend the design, since unanticipated generalization may force the re-examination of many existing relations between the constituents of the system to identify hard-coded design decisions that may have been invalidated. However, see [[Premature Generalization]].",
            "id": "ddf3afff30ddcf998e736bb6dc674222"
          },
          {
            "type": "html",
            "text": "\nStarting a development effort at a low level of abstraction often leads to [[Premature Optimization]]. Also see [[Top Down Programming]] and [[Bottom Up Programming]]. However, some [[Low Level Language]]s can be considered [[Domain Specific Languages]] for tasks such as [[Embedded Software]]: they are not all merely survivors of an earlier age.",
            "id": "6bab733733796c3e2a35f32c04d83116"
          },
          {
            "type": "html",
            "text": "\nWorking at a high level of abstraction does not necessarily preclude runtime efficiency of the implementation. Many modern languages (e.g. [[Cee Plus Plus]], [[Common Lisp]], [[Ada Language]]) aim to provide access to low level elements of the implementation while retaining means to develop at a high level of abstraction. Most language implementations allow to <i>drop out</i> to a different language to implement specific parts of a system at a lower level of abstraction.",
            "id": "2daca6fde43e5dd9edebfdca745c7575"
          },
          {
            "type": "html",
            "text": "\nThe term \"High Level Language\" was originally used to distinguish things like [[Fortran Language]] from things like assembly language. Therefore, originally \"high level language\" very much included Fortran, Basic, COBOL, PL/I, and a little later, C.",
            "id": "654205c72c1e9bf9b53a56b4a74b052e"
          },
          {
            "type": "html",
            "text": "\nObserving that such languages are not <b>very</b> high level compared with e.g. Prolog, YACC, Lex, ML, Haskell, etc, some people started calling the older high-level languages \"low-level languages\", or qualifying them as \"high<b>er</b> level languages\", etc. This is often erroneously thought to be revisionism, but is the very basis of much of Computer Science, and such terminology while not universally accepted among all programmers, is at least understood by those with a broad understanding of the relevant foundations of the topic at hand.",
            "id": "76ecf7c9e670f4dc6f4b5910ac55c1c1"
          },
          {
            "type": "html",
            "text": "\nA more diplomatic approach to the topic, while sacrificing accuracy to appeal to the less-disciplined mind, would be to simply call more sophisticated languages \"very high level languages\", if a distinction is needed, rather than trying to snidely imply (or state outright) that there's no difference between assembler and Fortran, Basic, COBOL, PL/I, C etc.",
            "id": "b801afa1182ea0aba3b7753565aa9cc3"
          },
          {
            "type": "html",
            "text": "\nNo one who has done extensive programming in assembler would ever make the mistake of calling such things \"low level languages\"; there is a very sharp and painful difference.",
            "id": "3a7fd2a712f39349ddb7924a5c73a338"
          },
          {
            "type": "html",
            "text": "\nSee Also [[Alternate Hard And Soft Layers]], [[Cee As An Intermediate Language]], [[Nth Generation Language]], [[Domain Specific Language]].",
            "id": "4e67e3e3cdbfff7951fb715aba72948d"
          },
          {
            "type": "html",
            "text": "\nContrast with [[Low Level Language]]s like [[Assembly Language]].",
            "id": "3d1a7fb55f93a251c8848e1e28fb78b8"
          },
          {
            "type": "html",
            "text": "[[[Edit Hint]]: the bottom area needs a re-arrangement]",
            "id": "443c104f819d61fc7870f31218bae202"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "55175bbfb8735f13902276759ed58dcb"
          },
          {
            "type": "html",
            "text": "Some [[Programming Paradigm]]s appear to be at an intrinsically higher level of abstraction than others (compare [[Declarative Programming]] with [[Imperative Programming]]). See [[Measuring Abstraction]], and [[Language Oriented Programming]].",
            "id": "20073d2a347b00ad6b9818df70c95e06"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "55175bbfb8735f13902276759ed58dcb"
          },
          {
            "type": "html",
            "text": "Perhaps some languages, like [[Lisp Language]] and [[Forth Language]], should be given the class of [[Vari Level Language]], since the level of abstractions offered by the language depends directly on how much you've altered the language to suit your problem domain? -- [[Samuel Falvo]]",
            "id": "9d702e2c84178aba91ca3db2e5dfd79a"
          },
          {
            "type": "html",
            "text": "\nI prefer '[[Meta Language]]' for languages that allow you alter the language or create DSLs.",
            "id": "d548f310eb38bc6a0fea3410e956ed6e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "55175bbfb8735f13902276759ed58dcb"
          },
          {
            "type": "html",
            "text": "[[Category Abstraction]] [[Category Programming Language]]",
            "id": "5651954003a5e680c170e617c8ecbadb"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?HighLevelLanguage c2.com]",
            "id": "06c9a497f769f560ccd271b0c2a54457"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1708035587576
    }
  ]
}