{
  "title": "Investigate the Problem Dyck(s) Of Checking Matching Parentheses",
  "story": [
    {
      "type": "paragraph",
      "id": "99734532eea9458f",
      "text": "Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of [[Parenthesis]]."
    },
    {
      "type": "paragraph",
      "id": "509a4ff765d64d74",
      "text": "We present a one-pass randomized streaming algorithm for Dyck(2) with space O(√ n log(n)) bits, time per letter polylog(n), and one-sided error."
    },
    {
      "type": "paragraph",
      "id": "17ccd5ac0aa9e94b",
      "text": "We prove that this one-pass algorithm is optimal, up to a log(n) factor, even when two-sided error is allowed, and conjecture that a similar bound holds for any constant number of passes over the input."
    },
    {
      "type": "paragraph",
      "id": "05300406cf8f2abd",
      "text": "Surprisingly, the space requirement shrinks drastically if we have access to the input stream “in reverse”. [⇐ [[Track in Reverse Order]]]"
    },
    {
      "type": "paragraph",
      "id": "2cef6def6b74c2d2",
      "text": "We present a two-pass randomized streaming algorithm for Dyck(2) with space O((log n)2), time polylog(n) and one-sided error, where the second pass is in the reverse direction."
    },
    {
      "type": "paragraph",
      "id": "814411dde5ac1b84",
      "text": "Both algorithms can be extended to Dyck(s) since this problem is reducible to Dyck(2) for a suitable notion of reduction in the streaming model. Except for an extra O(√ log(s)) multiplicative overhead in the space required in the one-pass algorithm, the resource requirements are of the same order. For the lower bound, we exhibit hard instances Ascension(m) of Dyck(2) with length Θ(mn)."
    },
    {
      "type": "paragraph",
      "id": "bce078d43c4b2b31",
      "text": "We embed these in what we call a “one-pass” communication problem with 2m-players, where m=~O(n). To establish the hardness of Ascension(m), we prove a direct sum result by following the “information cost” approach, but with a few twists. Indeed, we play a subtle game between public and private coins for Mountain, which corresponds to a primitive instance Ascension(1). This mixture between public and private coins for m results from a balancing act between the direct sum result and a combinatorial lower bound for m."
    },
    {
      "type": "pagefold",
      "id": "5445130fd162e4b7",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "81551d17a9fb92e8",
      "text": "MAGNIEZ, Frédéric, MATHIEU, Claire and NAYAK, Ashwin, 2010. Recognizing well-parenthesized expressions in the streaming model. In: Proceedings of the forty-second ACM symposium on Theory of computing. Online. New York, NY, USA: Association for Computing Machinery. 5 June 2010. p. 261–270. [Accessed 22 September 2023]. STOC ’10. ISBN 978-1-4503-0050-6. DOI 10.1145/1806689.1806727."
    },
    {
      "type": "reference",
      "id": "6466fee79e097bb8",
      "site": "wiki.ralfbarkow.ch",
      "slug": "track-in-reverse-order",
      "title": "Track in Reverse Order",
      "text": "Notice that the statements are tracked in reverse as we [[Loop]], and we reorder them only once we are Done. This is a very common pattern with loop! [https://package.elm-lang.org/packages/elm/parser/latest/Parser#loop page]"
    },
    {
      "type": "paragraph",
      "id": "2439f1546410a02d",
      "text": "The area of streaming algorithms has experienced tremendous growth over the last decade in many applications. Streaming algorithms sequentially scan the whole input piece by piece in one pass, or in a small number of passes (i.e., they do not have random access to the input), while using sublinear memory space, ideally polylogarithmic in the size of the input. The design of streaming algorithms is motivated by the explosion in the size of the data that algorithms are called upon to process in everyday real-time applications. Examples of such applications occur in bioinformatics for genome decoding, in Web databases for the search of documents, or in network monitoring. The analysis of Internet traffic [2], in which traffic logs are queried, was one of the first applications of this kind of algorithm. Few studies have been made in the context of formal languages, although these would have ramifications for massive data such as DNA sequences and large XML files. For instance, in the context of databases, properties decidable by streaming algorithm have been studied [21, 20], but only in the restricted case of deterministic and constant memory space algorithms."
    },
    {
      "type": "paragraph",
      "id": "f513e8efffaa5e84",
      "text": "Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of parenthesis. Regular languages are by definition decidable by deterministic streaming algorithms with constant space. The Dyck languages are some of the simplest context-free languages and yet already powerful. These languages play a central role in the theory of context-free languages, since every context-free language L can be mapped to a subset of Dyck(s) [8], for some s. In addition to its theoretical importance, the problem of checking matching parentheses is enountered frequently in database applications, for instance in verifying that an XML file is well-formed."
    },
    {
      "type": "paragraph",
      "id": "cb1ee6b8bf93c807",
      "text": "Deciding membership in Dyck(s) has already been addressed in the massive data setting, more precisely through property testing algorithms. An ε-property tester [5, 6, 11] for a language L accepts all strings of L and rejects all strings which are ε-far from strings in L, for the normalized Hamming distance. For every fixed ε > 0, Dyck(1) is ε-testable in constant time [1], whereas in general Dyck(s) are ε-testable in time  ̃ O(n2/3), with a lower bound of  ̃ Ω(n1/11) [18]. In [10], a comparison between property testers and streaming algorithms has been made. Streaming algorithms have the advantage of access to the entire string, albeit not in a random access fashion."
    },
    {
      "type": "paragraph",
      "id": "54f0157a25335c50",
      "text": "With random access to the input, context-free languages are known to be recognizable in space O((log n)2) [12]. In the special case of Dyck(s), logarithmic space is sufficient, as we may run through all possible heights, and check parentheses at the same height. This scheme does not seem to easily translate to streaming algorithms, even with a small number of passes over the input."
    },
    {
      "type": "paragraph",
      "id": "d75c8d114646334f",
      "text": "In the streaming model, Dyck(1) has a one-pass streaming algorithm with logarithmic space, using a height counter. Using a straightforward one-way communication complexity argument for Equality, we can deduce that Dyck(2) requires linear space for deterministic one-pass streaming algorithms. A relaxation of Dyck(s) is Identity(s) in the free group with s generators, where local simplifications aa = \u000f are allowed in addition to aa = \u000f, for every type of parenthesis (a, a). There is a logarithmic space algorithm for recognizing the language Identity(s) [15] that can easily be massaged into a one-pass streaming algorithm with polylogarithmic space. Again, this algorithm does not extend to Dyck(s)."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Investigate the Problem Dyck(s) Of Checking Matching Parentheses",
        "story": []
      },
      "date": 1695377853150
    },
    {
      "id": "81551d17a9fb92e8",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "81551d17a9fb92e8",
        "text": "MAGNIEZ, Frédéric, MATHIEU, Claire and NAYAK, Ashwin, 2010. Recognizing well-parenthesized expressions in the streaming model. In: Proceedings of the forty-second ACM symposium on Theory of computing. Online. New York, NY, USA: Association for Computing Machinery. 5 June 2010. p. 261–270. [Accessed 22 September 2023]. STOC ’10. ISBN 978-1-4503-0050-6. DOI 10.1145/1806689.1806727. Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of parenthesis. We present a one-pass randomized streaming algorithm for Dyck(2) with space O(√ n log(n)) bits, time per letter polylog(n), and one-sided error. We prove that this one-pass algorithm is optimal, up to a log(n) factor, even when two-sided error is allowed, and conjecture that a similar bound holds for any constant number of passes over the input. Surprisingly, the space requirement shrinks drastically if we have access to the input stream “in reverse”. We present a two-pass randomized streaming algorithm for Dyck(2) with space O((log n)2), time polylog(n) and one-sided error, where the second pass is in the reverse direction. Both algorithms can be extended to Dyck(s) since this problem is reducible to Dyck(2) for a suitable notion of reduction in the streaming model. Except for an extra O(√ log(s)) multiplicative overhead in the space required in the one-pass algorithm, the resource requirements are of the same order. For the lower bound, we exhibit hard instances Ascension(m) of Dyck(2) with length Θ(mn). We embed these in what we call a “one-pass” communication problem with 2m-players, where m=~O(n). To establish the hardness of Ascension(m), we prove a direct sum result by following the “information cost” approach, but with a few twists. Indeed, we play a subtle game between public and private coins for Mountain, which corresponds to a primitive instance Ascension(1). This mixture between public and private coins for m results from a balancing act between the direct sum result and a combinatorial lower bound for m.\n"
      },
      "attribution": {
        "page": "2023-09-22"
      },
      "date": 1695377875452
    },
    {
      "type": "edit",
      "id": "81551d17a9fb92e8",
      "item": {
        "type": "paragraph",
        "id": "81551d17a9fb92e8",
        "text": "MAGNIEZ, Frédéric, MATHIEU, Claire and NAYAK, Ashwin, 2010. Recognizing well-parenthesized expressions in the streaming model. In: Proceedings of the forty-second ACM symposium on Theory of computing. Online. New York, NY, USA: Association for Computing Machinery. 5 June 2010. p. 261–270. [Accessed 22 September 2023]. STOC ’10. ISBN 978-1-4503-0050-6. DOI 10.1145/1806689.1806727."
      },
      "date": 1695377898155
    },
    {
      "type": "add",
      "id": "99734532eea9458f",
      "item": {
        "type": "paragraph",
        "id": "99734532eea9458f",
        "text": "Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of parenthesis. We present a one-pass randomized streaming algorithm for Dyck(2) with space O(√ n log(n)) bits, time per letter polylog(n), and one-sided error. We prove that this one-pass algorithm is optimal, up to a log(n) factor, even when two-sided error is allowed, and conjecture that a similar bound holds for any constant number of passes over the input. Surprisingly, the space requirement shrinks drastically if we have access to the input stream “in reverse”. We present a two-pass randomized streaming algorithm for Dyck(2) with space O((log n)2), time polylog(n) and one-sided error, where the second pass is in the reverse direction. Both algorithms can be extended to Dyck(s) since this problem is reducible to Dyck(2) for a suitable notion of reduction in the streaming model. Except for an extra O(√ log(s)) multiplicative overhead in the space required in the one-pass algorithm, the resource requirements are of the same order. For the lower bound, we exhibit hard instances Ascension(m) of Dyck(2) with length Θ(mn). We embed these in what we call a “one-pass” communication problem with 2m-players, where m=~O(n). To establish the hardness of Ascension(m), we prove a direct sum result by following the “information cost” approach, but with a few twists. Indeed, we play a subtle game between public and private coins for Mountain, which corresponds to a primitive instance Ascension(1). This mixture between public and private coins for m results from a balancing act between the direct sum result and a combinatorial lower bound for m."
      },
      "after": "81551d17a9fb92e8",
      "date": 1695377899218
    },
    {
      "id": "99734532eea9458f",
      "type": "move",
      "order": [
        "99734532eea9458f",
        "81551d17a9fb92e8"
      ],
      "date": 1695377902054
    },
    {
      "item": {
        "type": "factory",
        "id": "5445130fd162e4b7"
      },
      "id": "5445130fd162e4b7",
      "type": "add",
      "after": "81551d17a9fb92e8",
      "date": 1695377904519
    },
    {
      "id": "5445130fd162e4b7",
      "type": "move",
      "order": [
        "99734532eea9458f",
        "5445130fd162e4b7",
        "81551d17a9fb92e8"
      ],
      "date": 1695377905985
    },
    {
      "type": "edit",
      "id": "5445130fd162e4b7",
      "item": {
        "type": "pagefold",
        "id": "5445130fd162e4b7",
        "text": "~"
      },
      "date": 1695377908537
    },
    {
      "type": "edit",
      "id": "99734532eea9458f",
      "item": {
        "type": "paragraph",
        "id": "99734532eea9458f",
        "text": "Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of parenthesis."
      },
      "date": 1695377937823
    },
    {
      "type": "add",
      "id": "509a4ff765d64d74",
      "item": {
        "type": "paragraph",
        "id": "509a4ff765d64d74",
        "text": "We present a one-pass randomized streaming algorithm for Dyck(2) with space O(√ n log(n)) bits, time per letter polylog(n), and one-sided error."
      },
      "after": "99734532eea9458f",
      "date": 1695377948857
    },
    {
      "type": "add",
      "id": "17ccd5ac0aa9e94b",
      "item": {
        "type": "paragraph",
        "id": "17ccd5ac0aa9e94b",
        "text": "We prove that this one-pass algorithm is optimal, up to a log(n) factor, even when two-sided error is allowed, and conjecture that a similar bound holds for any constant number of passes over the input."
      },
      "after": "509a4ff765d64d74",
      "date": 1695377964099
    },
    {
      "type": "add",
      "id": "05300406cf8f2abd",
      "item": {
        "type": "paragraph",
        "id": "05300406cf8f2abd",
        "text": "Surprisingly, the space requirement shrinks drastically if we have access to the input stream “in reverse”."
      },
      "after": "17ccd5ac0aa9e94b",
      "date": 1695377973418
    },
    {
      "type": "add",
      "id": "2cef6def6b74c2d2",
      "item": {
        "type": "paragraph",
        "id": "2cef6def6b74c2d2",
        "text": "We present a two-pass randomized streaming algorithm for Dyck(2) with space O((log n)2), time polylog(n) and one-sided error, where the second pass is in the reverse direction."
      },
      "after": "05300406cf8f2abd",
      "date": 1695377991929
    },
    {
      "type": "add",
      "id": "814411dde5ac1b84",
      "item": {
        "type": "paragraph",
        "id": "814411dde5ac1b84",
        "text": "Both algorithms can be extended to Dyck(s) since this problem is reducible to Dyck(2) for a suitable notion of reduction in the streaming model. Except for an extra O(√ log(s)) multiplicative overhead in the space required in the one-pass algorithm, the resource requirements are of the same order. For the lower bound, we exhibit hard instances Ascension(m) of Dyck(2) with length Θ(mn)."
      },
      "after": "2cef6def6b74c2d2",
      "date": 1695378035561
    },
    {
      "type": "add",
      "id": "bce078d43c4b2b31",
      "item": {
        "type": "paragraph",
        "id": "bce078d43c4b2b31",
        "text": "We embed these in what we call a “one-pass” communication problem with 2m-players, where m=~O(n). To establish the hardness of Ascension(m), we prove a direct sum result by following the “information cost” approach, but with a few twists. Indeed, we play a subtle game between public and private coins for Mountain, which corresponds to a primitive instance Ascension(1). This mixture between public and private coins for m results from a balancing act between the direct sum result and a combinatorial lower bound for m."
      },
      "after": "814411dde5ac1b84",
      "date": 1695378081135
    },
    {
      "item": {
        "type": "factory",
        "id": "6466fee79e097bb8"
      },
      "id": "6466fee79e097bb8",
      "type": "add",
      "after": "81551d17a9fb92e8",
      "date": 1695378105721
    },
    {
      "type": "edit",
      "id": "6466fee79e097bb8",
      "item": {
        "type": "reference",
        "id": "6466fee79e097bb8",
        "site": "wiki.ralfbarkow.ch",
        "slug": "track-in-reverse-order",
        "title": "Track in Reverse Order",
        "text": "Notice that the statements are tracked in reverse as we [[Loop]], and we reorder them only once we are Done. This is a very common pattern with loop! [https://package.elm-lang.org/packages/elm/parser/latest/Parser#loop page]"
      },
      "date": 1695378108330
    },
    {
      "type": "edit",
      "id": "05300406cf8f2abd",
      "item": {
        "type": "paragraph",
        "id": "05300406cf8f2abd",
        "text": "Surprisingly, the space requirement shrinks drastically if we have access to the input stream “in reverse”. [⇐ [[Track in Reverse Order]]"
      },
      "date": 1695378139477
    },
    {
      "type": "edit",
      "id": "05300406cf8f2abd",
      "item": {
        "type": "paragraph",
        "id": "05300406cf8f2abd",
        "text": "Surprisingly, the space requirement shrinks drastically if we have access to the input stream “in reverse”. [⇐ [[Track in Reverse Order]]]"
      },
      "date": 1695378145754
    },
    {
      "type": "edit",
      "id": "99734532eea9458f",
      "item": {
        "type": "paragraph",
        "id": "99734532eea9458f",
        "text": "Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of [[Parenthesis]]."
      },
      "date": 1695378404557
    },
    {
      "item": {
        "type": "factory",
        "id": "2439f1546410a02d"
      },
      "id": "2439f1546410a02d",
      "type": "add",
      "after": "6466fee79e097bb8",
      "date": 1695410241461
    },
    {
      "type": "edit",
      "id": "2439f1546410a02d",
      "item": {
        "type": "paragraph",
        "id": "2439f1546410a02d",
        "text": "The area of streaming algorithms has experienced tremendous growth over the last decade in many applications. Streaming algorithms sequentially scan the whole input piece by piece in one pass, or in a small number of passes (i.e., they do not have random access to the input), while using sublinear memory space, ideally polylogarithmic in the size of the input. The design of streaming algorithms is motivated by the explosion in the size of the data that algorithms are called upon to process in everyday real-time applications. Examples of such applications occur in bioinformatics for genome decoding, in Web databases for the search of documents, or in network monitoring. The analysis of Internet traffic [2], in which traffic logs are queried, was one of the first applications of this kind of algorithm. Few studies have been made in the context of formal languages, although these would have ramifications for massive data such as DNA sequences and large XML files. For instance, in the context of databases, properties decidable by streaming algorithm have been studied [21, 20], but only in the restricted case of deterministic and constant memory space algorithms."
      },
      "date": 1695410244001
    },
    {
      "type": "add",
      "id": "f513e8efffaa5e84",
      "item": {
        "type": "paragraph",
        "id": "f513e8efffaa5e84",
        "text": "Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of"
      },
      "after": "2439f1546410a02d",
      "date": 1695410361624
    },
    {
      "type": "edit",
      "id": "f513e8efffaa5e84",
      "item": {
        "type": "paragraph",
        "id": "f513e8efffaa5e84",
        "text": "Motivated by a concrete problem and with the goal of understanding the relationship between the complexity of streaming algorithms and the computational complexity of formal languages, we investigate the problem Dyck(s) of checking matching parentheses, with s different types of parenthesis. Regular languages are by definition decidable by deterministic streaming algorithms with constant space. The Dyck languages are some of the simplest context-free languages and yet already powerful. These languages play a central role in the theory of context-free languages, since every context-free language L can be mapped to a subset of Dyck(s) [8], for some s. In addition to its theoretical importance, the problem of checking matching parentheses is enountered frequently in database applications, for instance in verifying that an XML file is well-formed."
      },
      "date": 1695410383185
    },
    {
      "type": "add",
      "id": "cb1ee6b8bf93c807",
      "item": {
        "type": "paragraph",
        "id": "cb1ee6b8bf93c807",
        "text": "Deciding membership in Dyck(s) has already been addressed in the massive data setting, more precisely through property testing algorithms. An ε-property tester [5, 6, 11] for a language L accepts all strings of L and rejects all strings which are ε-far from strings in L, for the normalized Hamming distance. For every fixed ε > 0, Dyck(1) is ε-testable in constant time [1], whereas in general Dyck(s) are ε-testable in time  ̃ O(n2/3), with a lower bound of  ̃ Ω(n1/11) [18]. In [10], a comparison between property testers and streaming algorithms has been made. Streaming algorithms have the advantage of access to the entire string, albeit not in a random access fashion."
      },
      "after": "f513e8efffaa5e84",
      "date": 1695410425279
    },
    {
      "type": "add",
      "id": "54f0157a25335c50",
      "item": {
        "type": "paragraph",
        "id": "54f0157a25335c50",
        "text": "With random access to the input, context-free languages are known to be recognizable in space O((log n)2) [12]. In the special case of Dyck(s), logarithmic space is sufficient, as we may run through all possible heights, and check parentheses at the same height. This scheme does not seem to easily translate to streaming algorithms, even with a small number of passes over the input."
      },
      "after": "cb1ee6b8bf93c807",
      "date": 1695410554168
    },
    {
      "type": "add",
      "id": "d75c8d114646334f",
      "item": {
        "type": "paragraph",
        "id": "d75c8d114646334f",
        "text": "In the streaming model, Dyck(1) has a one-pass streaming algorithm with logarithmic space, using a height counter. Using a straightforward one-way communication complexity argument for Equality, we can deduce that Dyck(2) requires linear space for deterministic one-pass streaming algorithms. A relaxation of Dyck(s) is Identity(s) in the free group with s generators, where local simplifications aa = \u000f are allowed in addition to aa = \u000f, for every type of parenthesis (a, a). There is a logarithmic space algorithm for recognizing the language Identity(s) [15] that can easily be massaged into a one-pass streaming algorithm with polylogarithmic space. Again, this algorithm does not extend to Dyck(s)."
      },
      "after": "54f0157a25335c50",
      "date": 1695410581779
    }
  ]
}