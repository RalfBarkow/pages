{
  "title": "Toby Schachman",
  "story": [
    {
      "type": "paragraph",
      "id": "3ee20102fdbe0e2c",
      "text": "is an artist and interaction designer interested in new ways of seeing. He currently is a researcher in the [[Communications Design Group]] working on alternative interfaces for programming. He holds a master’s degree from the Interactive Telecommunications Program at NYU and a bachelor’s degree from MIT. He is a previous Eyebeam fellow."
    },
    {
      "type": "video",
      "id": "1ffe6e5a390a0606",
      "text": "YOUTUBE i3Xack9ufYk\n[[Apparatus]]: A Hybrid Graphics Editor / Programming Environment"
    },
    {
      "type": "paragraph",
      "id": "d7232190007f0f23",
      "text": "all right so how do we Munich eight mental models so if I have an understanding of some system how do I communicate that understanding to other people well we have various forms of media for doing this you can write an article draw a picture give a presentation make a physical model write a computer program all of these communication media are also thinking media so I can use these media to communicate with myself so the process of making any one of these things develops my own understanding further lately I've been really interested in an emerging medium of interactive diagrams interactive diagrams are pictures that move pictures that respond to a view of viewers interactions and I like these because they can help you develop a geometric intuition for the system that you're studying they can help you explore a parameter space interactive diagrams can help you understand causality in a system they can help you understand relationships within a system how does one part affect another part if I change one thing how does that affect all the other things interactive diagrams can explain a process and interactive diagrams can help you see connections between multiple ways of looking at a system today people create interactive diagrams by writing code I claim that this is problematic for several reasons first of all there's contact switching so when I'm writing code I'm thinking symbolically but when I'm designing a diagram when I'm sketching it on paper when I'm playing with the diagram I've made to see if it looks the way I want it to look what figure out what I need to change all of this all of the design of the diagram I'm thinking spatially so in this process you're constantly switching back and forth between thinking symbolically and then looking at your diagram in thinking spatially and I think this context switching could be better supported second there's a big disconnect between viewing and authoring so if I find a static picture that I like and I want to modify it or build off of it it's easy for me to draw on top of it or collage it in Photoshop and make a new picture out of it but if I find an interactive diagram on the web that I like well maybe I can download the source code but now I'm faced with this huge obstacle of understanding the source code and finally writing code is difficult and it takes a very long time often hours or days so in this talk I will be presenting some new work apparatus apparatus is a hybrid direct manipulation graphics editor combined with a dataflow programming environment and in this combination apparatus supports both spatial thinking and symbolic thinking and it also helps both of these modes of thought support each other there's a gradient between viewing and authoring the interactions that you use as viewer interacting with the diagram drag-and-drop are the same as the interactions you use as an author editing a diagram also drag and drop and finally apparatus aims to bring the time scale for creating these interactive diagrams down to minutes rather than hours so here I have apparatus it's a direct ment of English and graphics editor so I can have shapes and move them around resize them the shape that's selected I have an inspector that shows me all of the attributes of this shape and I can change these manually within the inspector and I can also write expressions in here so I can say 1 plus 1 and then apparatus says that's 2 and it makes the scalex of the circle two expressions can also reference other attributes so I can say 1 plus scale Y and now when I change scale Y scale X changes accordingly these references can go across shapes so I can take this rectangle and say I want scale Y to control the rotation so I change scale Y the rectangle will rotate so this is data flow it's like a spreadsheet and like a spreadsheet it has to two really nice properties for one there is no hidden state so all of the state is there it's always visible and second this editor is live meaning that there's no separate edit mode versus run mode there's no compile button there's no play button you're always both editing and playing and if you think about it a graphics editor also has these two properties there is no hidden state and there are no separate edit mode versus run good so I'll do an example so I've drawn this this face and this this outline shows me all of my shapes I can label them and reorder them things like that so we've seen how shapes have these attributes we can also create custom attributes these are called variables so I'll make a variable called surprise and I'll use that to control the mouth scale Y and let's also have that control the size of the eyes so what we've done here is essentially created a program that's procedurally drawing a picture and it's drawing it based on this parameterization of this this variable called surprise incidentally this is a structured editor so there's you can for example rename any of these variables and everything else just renames accordingly in a text editor of course you'd have to manually somehow change all these references so we've seen how to procedurally draw a picture now how do we add interactivity to the picture well the picture is already sort of interactive in the editor in the sense that if I - if I were to click and drag on a shape it moves around so that's a form of interactivity but this this is just the default interaction so you'll notice when I put my mouse over the shape the the X&Y attributes are highlighted in red because it says these are the attributes that are going to change when I start dragging what I can do is click on this control circle and now when I highlight over the mouth this wow variable is highlighted in red and when I drag on the mouth that variable will change so this control mechanism is very flexible so here I have an example that has three variables that are controlling the shoulder elbow and wrist joints of this arm linkage and I can select the hand and then have it control any of these variables so I can make control wrist and then when I drag it wrist will change or I can make a control elbow when I drag it the elbow variable changes our shoulder or it can make it control all three of these so what apparatus is doing to the way that this is implemented is with numerical minimization essentially when I click and drag on a shape apparatus says okay I'm allowed to change these three numbers how can I change them so as to minimize the distance from the current Mouse position to the shape that's being dragged so as I drag it's solving this minimization problem and then adjusting the attributes so this is very flexible for example I can make all of these variables have the same value and then when I drag the solver just knows what to do so next I'm going to talk about reuse so in code we we can reuse a chunk of code by wrapping it in a function and then calling that function in other places or we can use like objects and classes so we can put a method on a class and then all of the objects will inherit that class so this is how you do that kind of reuse in apparatus so you'll notice that all the diagrams we create there's a little icon in the create panel that's made for every diagram so if I make a new diagram to reuse this face I can just drag it right out and each of these instances is it's sort of like a copy of this master shape the instances don't affect each other so I can change the surprise of one and it won't affect the other one and they also don't affect the master I can even open these up so I can take this face and open it up and see maybe I'll change the the head the color of it and I'll make it like that so so light copies you can change anything about them it's like you copy and pasted some code however it changes to the master get inherited by the instances so if I go back to the master and I take the these eyes and I make them white instead of gray then the instances inherit that change structural changes get inherited as well so I can add some more shapes I'll make some pupils for the eyes and then both of all those changes get inherited by the by the instances changes don't get inherited if they're essentially overwritten so it's like prototypal inheritance so if I change the the surprise of the master then that's that's not going to affect the instances because I've overwritten surprise in each of the instances likewise if I change the color if I change the color of the master well then this one inherits that change because I haven't overwritten the color but but this one keeps its color because I have overwritten the color so this this form of reuse is very handy for creating like reusable widgets so if I wanted to make like a slider well a slider is just a there's like a track and a handle and the slider has a has a parameter that's its value so I'll set the handles exposition to be that value and it'll make the handle a controller for value so now I can drag the handle back and forth and the value will change and then I can reuse that slider so I'll put three of them out here and I'll make a I'll make a color picker so a color picker just has three sliders it has a red slider green and blue and it has a swatch that's going to show the current color it has a variable called color that's an RGB a value of red green blue alpha component of one and now I'll use that color for the fill of the swatch and now I have a color picker so then I can use these anywhere I want so maybe I'll bring a slider out and have it control the surprise of the faces maybe I want one face to be surprised and the other one not to be surprised so I'll do one - can bring out a color picker and use it for use it to change the fill color and then a color picker for for that face over there so sort of a future trajectory I think of apparatus is moving towards sort of bootstrapping the editor within itself so this this drag-and-drop you know I've you can make you can make sliders which control you know maybe this is a thing that's for interacting with the diagram as a viewer of it but but these things are also useful as an author of the diagram I can I can use I can use these interactive widgets to edit the diagram itself so there's this is what I'm talking about it's there's no separation between the viewing experience and the authoring experience there's a gradient between viewing and authoring viewing is just dragging fewer things than authoring all right so now I'm gonna talk about looping looping and apparatus so if I have a rectangle here I've got these attributes that I can change and attributes can be singular values like zero or they can be they can be spreads and so I'll show you what a spread is if I say spread zero to ten what this does is it makes on essentially ten different values so rather than X being just one value X is now simultaneously zero one two three four up to nine and apparatus will draw the square for each of these things so then I can reuse that so I take this X and I'll make it control the scale Y and then you get something that looks like that right so they're ten X values and ten scale Y values that are that come in pairs you can say x times two and it'll do what you expect or sine of X spread also has an increment optional third parameter so I can say spread zero to ten by 0.5 and then that'll say zero zero point five 11.5 etc I'm going to break out that increment variable and I'll set the scale x2 it so this is how you'd make a bar chart an interesting thing about spreads is is how they combine so so I've used one spread and I'm using that to control the the X of the rectangle and also the scale Y so it's essentially there's one four loop you could say that's controlling both X and scale Y if I write in another spread so if I say I want Y to be spread zero to four this will do the cross product of the spreads so you can think of it like two nested for-loops so that means that there's a difference between referencing a spread and creating a new spread so for example if I have if I want to make a grid I can say spread zero to five and that'll make my rows and then I can say spread zero to five for y also and so that makes a grid right but that's that's different having these two separate spreads it's different than reusing that spread right because then this will do sort of the component-wise version of it so spreads were created to answer this question of you know you sometimes you have some variable and you scrub it and you say oh that's really interesting it's really interesting how the picture changes as I move that variable around and you want to see all of the versions of that so so you just take that variable and you say spread and then you can see multiple versions of it so it's sort of implicit looping and spreads can also be used to plot functions so this rectangle if I open it up I can see that it's actually made up of four anchor points that I can move around so so really rectangle is just a it's just a path of anchor points so I can delete those and I have a triangle so if I want to graph a function I can use spreads essentially what I'm gonna do is I'm just gonna spread an anchor point so I'll take this anchor point and I'll say I want the X to be spread 0 to 10 and so that's gonna make 10 anchor points and then I'm gonna set the Y to be sine of X right so then this is taking the 10 anchor points that are distributed along the x axis and moving them to be sine of that value I can turn off closed path and get rid of the fill let me make it a little thicker and then if I want more precision I just put in an increment write that so then so now I have a hundred anchor points going from zero to ten that are graphing this function so that's how you would do a Cartesian graph in apparatus so those are the the fundamental features of apparatus now I'd like to show some examples that were created in apparatus so last week at my lab we had a little micro Jam we had got her bow doesn't have a sat around a table for two hours and played with apparatus and you know to see what we could make so I'm just going to show a few of the things that came out of that that session so Brett Victor made made this one I think it shows sort of the expressivity you can get out of apparatus if that's what you're going for Josh Horowitz made this diagram of a cycloid do you know to cycloid is so if you take like a a bicycle wheel and you put attach an LED to one of the edges and then you roll the bicycle wheel then the LED will will trace this path so I like this one because I think it's a really good example of how spreads can be used so so Josh had started with with with this diagram that just does that and then he said well I want I want to see what happens when that gets traced so the answer is well you just use a spread so you take that progress and say will spread zero to ten so now I can see ten different values of that and change the increment and so the few modifications and you and you get it to to this Paulette Abe made this diagram of a bike and you can pedal it and it moves you can also change the gear ratio so you can change the size of the gears and then as you pedal it it'll move differently so Paula made this and then Josh saw it and he said oh that reminds me of a puzzle so this is the puzzle so you you have a bike you you tie a string to the pedal like this right and now you're gonna pull on the string you're gonna pull backwards on the string and the question is does the bike move backwards or doesn't move forwards so I'll give you a moment to think about it all right so the options are it moves backwards and moves forwards or it doesn't move at all so how many people think it moves backwards all right how many people thinks it think it moves forwards and how many people think it doesn't move all right so a range of responses most people think it moves forwards so we decided to try it out with our model so we made the pedal a controller so now I can take it and I can drag it backwards and the bike moves backwards I'll do it again so take the pedal drag it backwards and the bike moves backwards if you're not convinced I encourage you to try it with a real bike which is what we did at the lab there's also this video right so so it's sort of this this balance of forces like you know you think that you're pedaling the bike clockwise so you think that that's you know really go forward when you do that but but the bike also you're also pulling the bike backwards so which which of these two forces is acting in a stronger way it turns out that the gear ratio is actually important for this problem if you're in an extremely low gear like you're going up a really steep mountain then when you pull the pedal backwards the bike actually moves forwards so it snaps around because the numerical solver is finding solutions over there but anyway you can you can do this and it turns out that that what matters is the the gear ratio on the bike compared to the ratio of the wheel versus the pedal so the radius the radius of the wheel compared to the radius of the pedal and so when the gear ratio exceeds that other ratio it the bike gets pulled backwards otherwise it goes forwards so we can actually see that happening so I made this other model where I just took the bike diagram I made a spread of it so I've got I've got six bikes here and you'll notice that this that gears getting bigger and bigger as I go down so I'm testing out a bunch of gear ratios all at once I can pedal them all simultaneously so you'll see that the bicycle is with the higher gear ratio move forward more with the same amount of pedaling and I've I've drawn this red reference line here that shows the starting position of all the of the pedals and then what happens is if I if I drag this of just a little bit so if I just pedal just a tiny bit you can see that the bikes in the lower gear the pedal is now behind that original starting place whereas the bikes and the higher gear the pedal moves forward more so they all started here and then the the lower gear once they move behind the one at point five that's that's where the the ratio of the pedal to the wheel is exactly equal to the gear ratio in that case the the pedal moves straight up so in this one the pedal moves straight up on the on the initial pedaling so to sum up apparatus is a graphics editor combined with a programming environment you use the dataflow programming environment of it to procedurally draw the picture so that's a case of the symbolic thinking controlling the spatial thinking so you're using algebra to drive geometry then you also set up these controllers where you can now drag a shape and then that moves moves your diagram so if the algebra is setting up the state space of your diagram its setting up all of the possible states that your diagram could be in then when you drag the geometry it's moving through that state space so that's geometry driving algebra and this is how it unifies the symbolic and the spatial way of working you can do reuse I guess I didn't mention that this is this form of reuse is coming from Jonathan Edwards sub-regional subtext paper and I think it's called call by copying in the paper and it's really nice because it's is essentially like you're copying and pasting right you can change anything that you want about the instance but it's still inherits changes you make to the master and you can't do that with textual programming languages you really need a structured editor so imagine if you had you know your code and you you copy and pasted one bit of code and put it somewhere else and you made some modifications to it and then you changed your original code there's it would be really messy to try to automatically propagate those changes to to your instances right to the to the version that you pasted but you can do it if the editor is sufficiently aware of the structure of your program and then this reuse enables you to make all these widgets that you can reuse and you create this working environment where it's the same viewing the diagram feels the same as authoring the diagram so this is just a gradient between viewing and authoring for looping we use spreads which enable us to see any given variable or attribute across a range of values and finally I showed some examples which I think demonstrate that apparatus is not only a communication tool but it's also a thinking tool so you can use apparatus to to simulate systems you can perform experiments in it apparatus not only is useful for communicating the answer to a problem but it's also useful for generating questions as we did with the bike diagram so apparatus is free open source it is on the web as of late last night it's on github I would sew sew apparatus has gone through many iterations over the past year or so so I'm really excited to finally be releasing it publicly I'd love to hear your thoughts on it I'd love to see diagrams that you create in it there's a there's a mailing list there's a Google group for it and if you're interested in working on the editor I would love to collaborate on github thank you you"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Toby Schachman",
        "story": []
      },
      "date": 1650439947442
    },
    {
      "item": {
        "type": "factory",
        "id": "38f0732ef419e76a"
      },
      "id": "38f0732ef419e76a",
      "type": "add",
      "date": 1650439952254
    },
    {
      "type": "edit",
      "id": "38f0732ef419e76a",
      "item": {
        "type": "paragraph",
        "id": "38f0732ef419e76a",
        "text": "An interactive diagram can be an effective way to communicate a mental model, because it can convey a way of seeing a problem or system. Currently, to create an interactive diagram one must write code to procedurally draw the diagram and respond appropriately to user input. Writing this code can take hours or days. Apparatus aims to reduce the time to create an interactive diagram from hours to minutes.\n\nApparatus combines the direct manipulation capabilities of a vector graphics editor with the dataflow capabilities of a spreadsheet. Through this hybridization, Apparatus supports both spatial and symbolic ways of working in tandem. Dataflow defines the state space of a diagram, algebra driving geometry. Dragging shapes moves through this state space, geometry driving algebra. Instead of function calls or object-oriented inheritance, Apparatus uses a \"call by copying\" pattern for diagram reuse. Reused diagrams do not need to be explicitly parameterized. Instead of loops, Apparatus uses spreads which allow any value to exist in a \"superposition\". This allows shapes to be looped over implicitly. By decomposing shapes into paths of points, it also enables Apparatus to plot curves.\n\nToby Schachman\nCOMMUNICATIONS DESIGN GROUP\n\nToby Schachman is an artist and interaction designer interested in new ways of seeing. He currently is a researcher in the Communications Design Group working on alternative interfaces for programming. He holds a master’s degree from the Interactive Telecommunications Program at NYU and a bachelor’s degree from MIT. He is a previous Eyebeam fellow."
      },
      "date": 1650439954213
    },
    {
      "type": "edit",
      "id": "38f0732ef419e76a",
      "item": {
        "type": "paragraph",
        "id": "38f0732ef419e76a",
        "text": "An interactive diagram can be an effective way to communicate a mental model, because it can convey a way of seeing a problem or system. Currently, to create an interactive diagram one must write code to procedurally draw the diagram and respond appropriately to user input. Writing this code can take hours or days. Apparatus aims to reduce the time to create an interactive diagram from hours to minutes.\n\nApparatus combines the direct manipulation capabilities of a vector graphics editor with the dataflow capabilities of a spreadsheet. Through this hybridization, Apparatus supports both spatial and symbolic ways of working in tandem. Dataflow defines the state space of a diagram, algebra driving geometry. Dragging shapes moves through this state space, geometry driving algebra. Instead of function calls or object-oriented inheritance, Apparatus uses a \"call by copying\" pattern for diagram reuse. Reused diagrams do not need to be explicitly parameterized. Instead of loops, Apparatus uses spreads which allow any value to exist in a \"superposition\". This allows shapes to be looped over implicitly. By decomposing shapes into paths of points, it also enables Apparatus to plot curves.\n\nToby Schachman\nCOMMUNICATIONS DESIGN GROUP\n\n"
      },
      "date": 1650439968678
    },
    {
      "type": "add",
      "id": "3ee20102fdbe0e2c",
      "item": {
        "type": "paragraph",
        "id": "3ee20102fdbe0e2c",
        "text": "Toby Schachman is an artist and interaction designer interested in new ways of seeing. He currently is a researcher in the Communications Design Group working on alternative interfaces for programming. He holds a master’s degree from the Interactive Telecommunications Program at NYU and a bachelor’s degree from MIT. He is a previous Eyebeam fellow."
      },
      "after": "38f0732ef419e76a",
      "date": 1650439969670
    },
    {
      "id": "3ee20102fdbe0e2c",
      "type": "move",
      "order": [
        "3ee20102fdbe0e2c",
        "38f0732ef419e76a"
      ],
      "date": 1650439972338
    },
    {
      "type": "edit",
      "id": "3ee20102fdbe0e2c",
      "item": {
        "type": "paragraph",
        "id": "3ee20102fdbe0e2c",
        "text": "[[Toby Schachman]] is an artist and interaction designer interested in new ways of seeing. He currently is a researcher in the Communications Design Group working on alternative interfaces for programming. He holds a master’s degree from the Interactive Telecommunications Program at NYU and a bachelor’s degree from MIT. He is a previous Eyebeam fellow."
      },
      "date": 1650439983849
    },
    {
      "id": "38f0732ef419e76a",
      "type": "remove",
      "date": 1650440023498
    },
    {
      "type": "edit",
      "id": "3ee20102fdbe0e2c",
      "item": {
        "type": "paragraph",
        "id": "3ee20102fdbe0e2c",
        "text": "[[Toby Schachman]] is an artist and interaction designer interested in new ways of seeing. He currently is a researcher in the [[Communications Design Group]] working on alternative interfaces for programming. He holds a master’s degree from the Interactive Telecommunications Program at NYU and a bachelor’s degree from MIT. He is a previous Eyebeam fellow."
      },
      "date": 1650440113779
    },
    {
      "type": "edit",
      "id": "3ee20102fdbe0e2c",
      "item": {
        "type": "paragraph",
        "id": "3ee20102fdbe0e2c",
        "text": "is an artist and interaction designer interested in new ways of seeing. He currently is a researcher in the [[Communications Design Group]] working on alternative interfaces for programming. He holds a master’s degree from the Interactive Telecommunications Program at NYU and a bachelor’s degree from MIT. He is a previous Eyebeam fellow."
      },
      "date": 1697026278502
    },
    {
      "item": {
        "type": "factory",
        "id": "1ffe6e5a390a0606"
      },
      "id": "1ffe6e5a390a0606",
      "type": "add",
      "after": "3ee20102fdbe0e2c",
      "date": 1697026347196
    },
    {
      "type": "edit",
      "id": "1ffe6e5a390a0606",
      "item": {
        "type": "video",
        "id": "1ffe6e5a390a0606",
        "text": "YOUTUBE i3Xack9ufYk"
      },
      "date": 1697026360754
    },
    {
      "type": "edit",
      "id": "1ffe6e5a390a0606",
      "item": {
        "type": "video",
        "id": "1ffe6e5a390a0606",
        "text": "YOUTUBE i3Xack9ufYk\nApparatus: A Hybrid Graphics Editor / Programming Environment"
      },
      "date": 1697026380498
    },
    {
      "type": "edit",
      "id": "1ffe6e5a390a0606",
      "item": {
        "type": "video",
        "id": "1ffe6e5a390a0606",
        "text": "YOUTUBE i3Xack9ufYk\n[[Apparatus]]: A Hybrid Graphics Editor / Programming Environment"
      },
      "date": 1697026391141
    },
    {
      "item": {
        "type": "factory",
        "id": "d7232190007f0f23"
      },
      "id": "d7232190007f0f23",
      "type": "add",
      "after": "1ffe6e5a390a0606",
      "date": 1697026469485
    },
    {
      "type": "edit",
      "id": "d7232190007f0f23",
      "item": {
        "type": "paragraph",
        "id": "d7232190007f0f23",
        "text": "all right so how do we Munich eight mental models so if I have an understanding of some system how do I communicate that understanding to other people well we have various forms of media for doing this you can write an article draw a picture give a presentation make a physical model write a computer program all of these communication media are also thinking media so I can use these media to communicate with myself so the process of making any one of these things develops my own understanding further lately I've been really interested in an emerging medium of interactive diagrams interactive diagrams are pictures that move pictures that respond to a view of viewers interactions and I like these because they can help you develop a geometric intuition for the system that you're studying they can help you explore a parameter space interactive diagrams can help you understand causality in a system they can help you understand relationships within a system how does one part affect another part if I change one thing how does that affect all the other things interactive diagrams can explain a process and interactive diagrams can help you see connections between multiple ways of looking at a system today people create interactive diagrams by writing code I claim that this is problematic for several reasons first of all there's contact switching so when I'm writing code I'm thinking symbolically but when I'm designing a diagram when I'm sketching it on paper when I'm playing with the diagram I've made to see if it looks the way I want it to look what figure out what I need to change all of this all of the design of the diagram I'm thinking spatially so in this process you're constantly switching back and forth between thinking symbolically and then looking at your diagram in thinking spatially and I think this context switching could be better supported second there's a big disconnect between viewing and authoring so if I find a static picture that I like and I want to modify it or build off of it it's easy for me to draw on top of it or collage it in Photoshop and make a new picture out of it but if I find an interactive diagram on the web that I like well maybe I can download the source code but now I'm faced with this huge obstacle of understanding the source code and finally writing code is difficult and it takes a very long time often hours or days so in this talk I will be presenting some new work apparatus apparatus is a hybrid direct manipulation graphics editor combined with a dataflow programming environment and in this combination apparatus supports both spatial thinking and symbolic thinking and it also helps both of these modes of thought support each other there's a gradient between viewing and authoring the interactions that you use as viewer interacting with the diagram drag-and-drop are the same as the interactions you use as an author editing a diagram also drag and drop and finally apparatus aims to bring the time scale for creating these interactive diagrams down to minutes rather than hours so here I have apparatus it's a direct ment of English and graphics editor so I can have shapes and move them around resize them the shape that's selected I have an inspector that shows me all of the attributes of this shape and I can change these manually within the inspector and I can also write expressions in here so I can say 1 plus 1 and then apparatus says that's 2 and it makes the scalex of the circle two expressions can also reference other attributes so I can say 1 plus scale Y and now when I change scale Y scale X changes accordingly these references can go across shapes so I can take this rectangle and say I want scale Y to control the rotation so I change scale Y the rectangle will rotate so this is data flow it's like a spreadsheet and like a spreadsheet it has to two really nice properties for one there is no hidden state so all of the state is there it's always visible and second this editor is live meaning that there's no separate edit mode versus run mode there's no compile button there's no play button you're always both editing and playing and if you think about it a graphics editor also has these two properties there is no hidden state and there are no separate edit mode versus run good so I'll do an example so I've drawn this this face and this this outline shows me all of my shapes I can label them and reorder them things like that so we've seen how shapes have these attributes we can also create custom attributes these are called variables so I'll make a variable called surprise and I'll use that to control the mouth scale Y and let's also have that control the size of the eyes so what we've done here is essentially created a program that's procedurally drawing a picture and it's drawing it based on this parameterization of this this variable called surprise incidentally this is a structured editor so there's you can for example rename any of these variables and everything else just renames accordingly in a text editor of course you'd have to manually somehow change all these references so we've seen how to procedurally draw a picture now how do we add interactivity to the picture well the picture is already sort of interactive in the editor in the sense that if I - if I were to click and drag on a shape it moves around so that's a form of interactivity but this this is just the default interaction so you'll notice when I put my mouse over the shape the the X&Y attributes are highlighted in red because it says these are the attributes that are going to change when I start dragging what I can do is click on this control circle and now when I highlight over the mouth this wow variable is highlighted in red and when I drag on the mouth that variable will change so this control mechanism is very flexible so here I have an example that has three variables that are controlling the shoulder elbow and wrist joints of this arm linkage and I can select the hand and then have it control any of these variables so I can make control wrist and then when I drag it wrist will change or I can make a control elbow when I drag it the elbow variable changes our shoulder or it can make it control all three of these so what apparatus is doing to the way that this is implemented is with numerical minimization essentially when I click and drag on a shape apparatus says okay I'm allowed to change these three numbers how can I change them so as to minimize the distance from the current Mouse position to the shape that's being dragged so as I drag it's solving this minimization problem and then adjusting the attributes so this is very flexible for example I can make all of these variables have the same value and then when I drag the solver just knows what to do so next I'm going to talk about reuse so in code we we can reuse a chunk of code by wrapping it in a function and then calling that function in other places or we can use like objects and classes so we can put a method on a class and then all of the objects will inherit that class so this is how you do that kind of reuse in apparatus so you'll notice that all the diagrams we create there's a little icon in the create panel that's made for every diagram so if I make a new diagram to reuse this face I can just drag it right out and each of these instances is it's sort of like a copy of this master shape the instances don't affect each other so I can change the surprise of one and it won't affect the other one and they also don't affect the master I can even open these up so I can take this face and open it up and see maybe I'll change the the head the color of it and I'll make it like that so so light copies you can change anything about them it's like you copy and pasted some code however it changes to the master get inherited by the instances so if I go back to the master and I take the these eyes and I make them white instead of gray then the instances inherit that change structural changes get inherited as well so I can add some more shapes I'll make some pupils for the eyes and then both of all those changes get inherited by the by the instances changes don't get inherited if they're essentially overwritten so it's like prototypal inheritance so if I change the the surprise of the master then that's that's not going to affect the instances because I've overwritten surprise in each of the instances likewise if I change the color if I change the color of the master well then this one inherits that change because I haven't overwritten the color but but this one keeps its color because I have overwritten the color so this this form of reuse is very handy for creating like reusable widgets so if I wanted to make like a slider well a slider is just a there's like a track and a handle and the slider has a has a parameter that's its value so I'll set the handles exposition to be that value and it'll make the handle a controller for value so now I can drag the handle back and forth and the value will change and then I can reuse that slider so I'll put three of them out here and I'll make a I'll make a color picker so a color picker just has three sliders it has a red slider green and blue and it has a swatch that's going to show the current color it has a variable called color that's an RGB a value of red green blue alpha component of one and now I'll use that color for the fill of the swatch and now I have a color picker so then I can use these anywhere I want so maybe I'll bring a slider out and have it control the surprise of the faces maybe I want one face to be surprised and the other one not to be surprised so I'll do one - can bring out a color picker and use it for use it to change the fill color and then a color picker for for that face over there so sort of a future trajectory I think of apparatus is moving towards sort of bootstrapping the editor within itself so this this drag-and-drop you know I've you can make you can make sliders which control you know maybe this is a thing that's for interacting with the diagram as a viewer of it but but these things are also useful as an author of the diagram I can I can use I can use these interactive widgets to edit the diagram itself so there's this is what I'm talking about it's there's no separation between the viewing experience and the authoring experience there's a gradient between viewing and authoring viewing is just dragging fewer things than authoring all right so now I'm gonna talk about looping looping and apparatus so if I have a rectangle here I've got these attributes that I can change and attributes can be singular values like zero or they can be they can be spreads and so I'll show you what a spread is if I say spread zero to ten what this does is it makes on essentially ten different values so rather than X being just one value X is now simultaneously zero one two three four up to nine and apparatus will draw the square for each of these things so then I can reuse that so I take this X and I'll make it control the scale Y and then you get something that looks like that right so they're ten X values and ten scale Y values that are that come in pairs you can say x times two and it'll do what you expect or sine of X spread also has an increment optional third parameter so I can say spread zero to ten by 0.5 and then that'll say zero zero point five 11.5 etc I'm going to break out that increment variable and I'll set the scale x2 it so this is how you'd make a bar chart an interesting thing about spreads is is how they combine so so I've used one spread and I'm using that to control the the X of the rectangle and also the scale Y so it's essentially there's one four loop you could say that's controlling both X and scale Y if I write in another spread so if I say I want Y to be spread zero to four this will do the cross product of the spreads so you can think of it like two nested for-loops so that means that there's a difference between referencing a spread and creating a new spread so for example if I have if I want to make a grid I can say spread zero to five and that'll make my rows and then I can say spread zero to five for y also and so that makes a grid right but that's that's different having these two separate spreads it's different than reusing that spread right because then this will do sort of the component-wise version of it so spreads were created to answer this question of you know you sometimes you have some variable and you scrub it and you say oh that's really interesting it's really interesting how the picture changes as I move that variable around and you want to see all of the versions of that so so you just take that variable and you say spread and then you can see multiple versions of it so it's sort of implicit looping and spreads can also be used to plot functions so this rectangle if I open it up I can see that it's actually made up of four anchor points that I can move around so so really rectangle is just a it's just a path of anchor points so I can delete those and I have a triangle so if I want to graph a function I can use spreads essentially what I'm gonna do is I'm just gonna spread an anchor point so I'll take this anchor point and I'll say I want the X to be spread 0 to 10 and so that's gonna make 10 anchor points and then I'm gonna set the Y to be sine of X right so then this is taking the 10 anchor points that are distributed along the x axis and moving them to be sine of that value I can turn off closed path and get rid of the fill let me make it a little thicker and then if I want more precision I just put in an increment write that so then so now I have a hundred anchor points going from zero to ten that are graphing this function so that's how you would do a Cartesian graph in apparatus so those are the the fundamental features of apparatus now I'd like to show some examples that were created in apparatus so last week at my lab we had a little micro Jam we had got her bow doesn't have a sat around a table for two hours and played with apparatus and you know to see what we could make so I'm just going to show a few of the things that came out of that that session so Brett Victor made made this one I think it shows sort of the expressivity you can get out of apparatus if that's what you're going for Josh Horowitz made this diagram of a cycloid do you know to cycloid is so if you take like a a bicycle wheel and you put attach an LED to one of the edges and then you roll the bicycle wheel then the LED will will trace this path so I like this one because I think it's a really good example of how spreads can be used so so Josh had started with with with this diagram that just does that and then he said well I want I want to see what happens when that gets traced so the answer is well you just use a spread so you take that progress and say will spread zero to ten so now I can see ten different values of that and change the increment and so the few modifications and you and you get it to to this Paulette Abe made this diagram of a bike and you can pedal it and it moves you can also change the gear ratio so you can change the size of the gears and then as you pedal it it'll move differently so Paula made this and then Josh saw it and he said oh that reminds me of a puzzle so this is the puzzle so you you have a bike you you tie a string to the pedal like this right and now you're gonna pull on the string you're gonna pull backwards on the string and the question is does the bike move backwards or doesn't move forwards so I'll give you a moment to think about it all right so the options are it moves backwards and moves forwards or it doesn't move at all so how many people think it moves backwards all right how many people thinks it think it moves forwards and how many people think it doesn't move all right so a range of responses most people think it moves forwards so we decided to try it out with our model so we made the pedal a controller so now I can take it and I can drag it backwards and the bike moves backwards I'll do it again so take the pedal drag it backwards and the bike moves backwards if you're not convinced I encourage you to try it with a real bike which is what we did at the lab there's also this video right so so it's sort of this this balance of forces like you know you think that you're pedaling the bike clockwise so you think that that's you know really go forward when you do that but but the bike also you're also pulling the bike backwards so which which of these two forces is acting in a stronger way it turns out that the gear ratio is actually important for this problem if you're in an extremely low gear like you're going up a really steep mountain then when you pull the pedal backwards the bike actually moves forwards so it snaps around because the numerical solver is finding solutions over there but anyway you can you can do this and it turns out that that what matters is the the gear ratio on the bike compared to the ratio of the wheel versus the pedal so the radius the radius of the wheel compared to the radius of the pedal and so when the gear ratio exceeds that other ratio it the bike gets pulled backwards otherwise it goes forwards so we can actually see that happening so I made this other model where I just took the bike diagram I made a spread of it so I've got I've got six bikes here and you'll notice that this that gears getting bigger and bigger as I go down so I'm testing out a bunch of gear ratios all at once I can pedal them all simultaneously so you'll see that the bicycle is with the higher gear ratio move forward more with the same amount of pedaling and I've I've drawn this red reference line here that shows the starting position of all the of the pedals and then what happens is if I if I drag this of just a little bit so if I just pedal just a tiny bit you can see that the bikes in the lower gear the pedal is now behind that original starting place whereas the bikes and the higher gear the pedal moves forward more so they all started here and then the the lower gear once they move behind the one at point five that's that's where the the ratio of the pedal to the wheel is exactly equal to the gear ratio in that case the the pedal moves straight up so in this one the pedal moves straight up on the on the initial pedaling so to sum up apparatus is a graphics editor combined with a programming environment you use the dataflow programming environment of it to procedurally draw the picture so that's a case of the symbolic thinking controlling the spatial thinking so you're using algebra to drive geometry then you also set up these controllers where you can now drag a shape and then that moves moves your diagram so if the algebra is setting up the state space of your diagram its setting up all of the possible states that your diagram could be in then when you drag the geometry it's moving through that state space so that's geometry driving algebra and this is how it unifies the symbolic and the spatial way of working you can do reuse I guess I didn't mention that this is this form of reuse is coming from Jonathan Edwards sub-regional subtext paper and I think it's called call by copying in the paper and it's really nice because it's is essentially like you're copying and pasting right you can change anything that you want about the instance but it's still inherits changes you make to the master and you can't do that with textual programming languages you really need a structured editor so imagine if you had you know your code and you you copy and pasted one bit of code and put it somewhere else and you made some modifications to it and then you changed your original code there's it would be really messy to try to automatically propagate those changes to to your instances right to the to the version that you pasted but you can do it if the editor is sufficiently aware of the structure of your program and then this reuse enables you to make all these widgets that you can reuse and you create this working environment where it's the same viewing the diagram feels the same as authoring the diagram so this is just a gradient between viewing and authoring for looping we use spreads which enable us to see any given variable or attribute across a range of values and finally I showed some examples which I think demonstrate that apparatus is not only a communication tool but it's also a thinking tool so you can use apparatus to to simulate systems you can perform experiments in it apparatus not only is useful for communicating the answer to a problem but it's also useful for generating questions as we did with the bike diagram so apparatus is free open source it is on the web as of late last night it's on github I would sew sew apparatus has gone through many iterations over the past year or so so I'm really excited to finally be releasing it publicly I'd love to hear your thoughts on it I'd love to see diagrams that you create in it there's a there's a mailing list there's a Google group for it and if you're interested in working on the editor I would love to collaborate on github thank you you"
      },
      "date": 1697026471241
    }
  ]
}