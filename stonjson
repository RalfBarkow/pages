{
  "title": "STONJSON",
  "story": [
    {
      "type": "markdown",
      "id": "647f2a37773dc5e2",
      "text": "I am STONJSON, a class side facade to use STON as a simple JSON parser/writer.\n\nSTON is more or less a superset of JSON and is backwards compatible with JSON while parsing, and can be compatible with it while writing. The important differences (and the whole reason why STON exists in the first place) are \n\n  - class information (except for lists (Array) and maps (Dictionary))\n  - proper handling of shared and circular references\n  - more Smalltalk like syntax (Symbols with #, single quoted Strings, nil instead of null)\n  - more defined special types (Date, Time, DataAndTime, ByteArray, Point)\n\nParsing JSON is done using\n\n  #fromString:\n  #fromStream: \n\nwith the results being composed of Arrays and Dictionaries.\n\nWriting objects as JSON is done using\n\n  #toString[Pretty]:\n  #put:onStream[Pretty]:\n\nNote that you can only write Arrays and Dictionaries ! Shared and circular references will be noted and signalled using an exception.\n\nE x a m p l e s\n\n  STONJSON toString: { 1. -1. Float pi. true. 'JSON' }.\n  STONJSON fromString: '[1,-1,3.141592653589793,true,\"JSON\"]'.\n\n  STONJSON toStringPretty: { #foo->1. #bar->2 } asDictionary.\n  STONJSON fromString: '{\"foo\":1,\"bar\":2,\"sub\":{\"a\":true,\"b\":false},\"flags\":[1,8,32]}'.\n \n\n"
    },
    {
      "type": "markdown",
      "id": "f8ec8894f5406256",
      "text": "For a much more sophisticated JSON parser/writer implementation, have a look at [[NeoJSON]]."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "STONJSON",
        "story": []
      },
      "date": 1656084988944
    },
    {
      "item": {
        "type": "factory",
        "id": "647f2a37773dc5e2"
      },
      "id": "647f2a37773dc5e2",
      "type": "add",
      "date": 1656084994017
    },
    {
      "type": "edit",
      "id": "647f2a37773dc5e2",
      "item": {
        "type": "markdown",
        "id": "647f2a37773dc5e2",
        "text": "I am STONJSON, a class side facade to use STON as a simple JSON parser/writer.\n\nSTON is more or less a superset of JSON and is backwards compatible with JSON while parsing, and can be compatible with it while writing. The important differences (and the whole reason why STON exists in the first place) are \n\n  - class information (except for lists (Array) and maps (Dictionary))\n  - proper handling of shared and circular references\n  - more Smalltalk like syntax (Symbols with #, single quoted Strings, nil instead of null)\n  - more defined special types (Date, Time, DataAndTime, ByteArray, Point)\n\nParsing JSON is done using\n\n  #fromString:\n  #fromStream: \n\nwith the results being composed of Arrays and Dictionaries.\n\nWriting objects as JSON is done using\n\n  #toString[Pretty]:\n  #put:onStream[Pretty]:\n\nNote that you can only write Arrays and Dictionaries ! Shared and circular references will be noted and signalled using an exception.\n\nE x a m p l e s\n\n  STONJSON toString: { 1. -1. Float pi. true. 'JSON' }.\n  STONJSON fromString: '[1,-1,3.141592653589793,true,\"JSON\"]'.\n\n  STONJSON toStringPretty: { #foo->1. #bar->2 } asDictionary.\n  STONJSON fromString: '{\"foo\":1,\"bar\":2,\"sub\":{\"a\":true,\"b\":false},\"flags\":[1,8,32]}'.\n \nFor a much more sophisticated JSON parser/writer implementation, have a look at NeoJSON."
      },
      "date": 1656084996883
    },
    {
      "type": "edit",
      "id": "647f2a37773dc5e2",
      "item": {
        "type": "markdown",
        "id": "647f2a37773dc5e2",
        "text": "I am STONJSON, a class side facade to use STON as a simple JSON parser/writer.\n\nSTON is more or less a superset of JSON and is backwards compatible with JSON while parsing, and can be compatible with it while writing. The important differences (and the whole reason why STON exists in the first place) are \n\n  - class information (except for lists (Array) and maps (Dictionary))\n  - proper handling of shared and circular references\n  - more Smalltalk like syntax (Symbols with #, single quoted Strings, nil instead of null)\n  - more defined special types (Date, Time, DataAndTime, ByteArray, Point)\n\nParsing JSON is done using\n\n  #fromString:\n  #fromStream: \n\nwith the results being composed of Arrays and Dictionaries.\n\nWriting objects as JSON is done using\n\n  #toString[Pretty]:\n  #put:onStream[Pretty]:\n\nNote that you can only write Arrays and Dictionaries ! Shared and circular references will be noted and signalled using an exception.\n\nE x a m p l e s\n\n  STONJSON toString: { 1. -1. Float pi. true. 'JSON' }.\n  STONJSON fromString: '[1,-1,3.141592653589793,true,\"JSON\"]'.\n\n  STONJSON toStringPretty: { #foo->1. #bar->2 } asDictionary.\n  STONJSON fromString: '{\"foo\":1,\"bar\":2,\"sub\":{\"a\":true,\"b\":false},\"flags\":[1,8,32]}'.\n \n\n"
      },
      "date": 1656085060632
    },
    {
      "type": "add",
      "id": "f8ec8894f5406256",
      "item": {
        "type": "markdown",
        "id": "f8ec8894f5406256",
        "text": "For a much more sophisticated JSON parser/writer implementation, have a look at [[NeoJSON]]."
      },
      "after": "647f2a37773dc5e2",
      "date": 1656085068753
    }
  ]
}