{
  "title": "Benefits Of Oo",
  "story": [
    {
      "type": "html",
      "text": "[[Object Oriented Programming]] provides a different view of programming than [[Procedural Programming]] or [[Functional Programming]].  On the one hand it's about bundling the state and behavior together, but in a larger sense it's about a mindset--a way of looking at programming.",
      "id": "bef6c97403c9bb8fff32fe1ed89702fe"
    },
    {
      "type": "html",
      "text": "\nBelow is a list of benefits often assigned to or claimed about OO. If you know of any evidence or detailed argument for any of these, feel free to link them in. Please use the discussion area below the list for long content.",
      "id": "01da5e5d5f697301e47b55292131afce"
    },
    {
      "type": "html",
      "text": " Reuse. (But see [[Reuse Has Failed]].)",
      "id": "dd65c715e4ee639cae139c86af14d331"
    },
    {
      "type": "html",
      "text": " [[Configurable Modularity]] at Runtime (improved over most procedural languages, which offer [[Configurable Modularity]] only at code-time)",
      "id": "34e358e29384d5b4b78291c749d23233"
    },
    {
      "type": "html",
      "text": " [[Gate Keeper]] / [[Capability Security Model]].",
      "id": "363e2b361f615929984ff147c5cdea1f"
    },
    {
      "type": "html",
      "text": " [[Poly Morphism]] increases expressiveness.",
      "id": "09d21e6264d6d9281ec6f5ed875ec354"
    },
    {
      "type": "html",
      "text": " Better models the real world (or at least better matches a useful model of the real world)",
      "id": "1bbef39785758467f680c4be0658eb7b"
    },
    {
      "type": "html",
      "text": " Better models human thought processes. <i>Hotly contended because heavily tied to psychology theories and personal differences.</i> ",
      "id": "b7f062f8edeb8b7a5f89185ad3da6989"
    },
    {
      "type": "html",
      "text": " There is a fallacy involved in this assertion. Humans may abstract and model world as objects (soft reflective abstraction), but OOP constructs world via objects (hard projective abstraction). Those are opposite behaviors, but the surface similarities may lead one to believe that OOP better models human thought. See also: [[Object Vs Model]], [[Oop Not For Domain Modeling]].",
      "id": "4d790beb4abb86a9fe3bb6d6c688f12d"
    },
    {
      "type": "html",
      "text": " <i>Basically, humans easily hold multiple views of things - recognizing multiple patterns - whereas OOP often forces us to pick one view and entrench it in our code.</i>",
      "id": "58e3b83e9c006a106336245565eb53ea"
    },
    {
      "type": "html",
      "text": " I'd be hesitant to make blanket statements about human [[Wet Ware]] outside of my own. People are different. Some are more comfortable with [[Everything Isa]].",
      "id": "3d038a222af092bbb7154fa447cfb7c1"
    },
    {
      "type": "html",
      "text": " <i>Looking at \"comfort\" level is a terrible way to measure whether something is related to \"human thought processes\" because it depends heavily upon other factors, such as familiarity. What the body of hard psychological evidence tells us is that all people (barring genetic defect, brain damage, or psychoactive drugs) perform the same cognitive functions, learn and think and recognize and pattern match by the same mechanisms. Humans are not </i>that<i> different.</i>",
      "id": "4ba9b6606c1e4ed8f873b390618e297c"
    },
    {
      "type": "html",
      "text": " <i>Besides that, you probably are not qualified to make statements about even your own [[Wet Ware]]. Very few people keep careful tabs and make objective judgements about their own behavior and thought patterns. If you think you're one of the few exceptions, you are almost certainly deluding yourself (which is a rather common pattern in human behavior).</i> ",
      "id": "12c3e3eff7f97d1260fa69f7f4905274"
    },
    {
      "type": "html",
      "text": " Compared to others, I believe I am pretty good at explaining my mental steps to come to a judgment or model if I think about it enough. This is with the exception of remembering specific events that add up to summary judgments about frequencies. I don't have a photographic memory. But perhaps we should take this discussion to another topic. ",
      "id": "cd7f3b4356476c8fe9b0084dc8677367"
    },
    {
      "type": "html",
      "text": " <i>You should look up the term 'confabulation', learn what it means, and apply it to your daily life.</i>",
      "id": "9997968303ab5bccde6c2d45ce8b9fea"
    },
    {
      "type": "html",
      "text": " Do you mean my claims to about my ability to turn my mental models into something clear or concrete, or the accuracy of these models as far as predicting activity in the real world? The sub-topic is modeling the human mind, not modeling the \"actual\" world accurately. It's merely a claim of an ability at introspection of thought processes sufficient enough to replicate much of it on paper or an algorithm.",
      "id": "08febba32cd8252ddff0706c5ff3e4b7"
    },
    {
      "type": "html",
      "text": " <i>I'm calling you human. [[Humans Are Lousy At Self Evaluation]]. Confabulation is also common; I do it all the time, but I'm aware of the possibility so I can correct for it by establishing processes and habits. The problem is, human, that you're super-arrogant and think yourself above these issues. Regarding the rest, here's a piece of common sense that you apparently failed to learn: If one person calls you an ass, that's his problem. If many people call you an ass, that's your problem.</i>",
      "id": "60c0f40d5887c60c11717cd7119a7280"
    },
    {
      "type": "html",
      "text": " I see a lot of projecting going on there. And because the person/people who personally insult me rarely use handles, it could be one or a hundred and so I cannot make any reliable assessment of popularity. Further, argument-by-popularity is generally a weak argument. You can't make the world flat by voting it flat. Enough about how much we hate each other. Let's get back to the topic.",
      "id": "936c46d7fe02a58311b3d07436e0660e"
    },
    {
      "type": "html",
      "text": " <i>Perhaps I over-personalized your statement. Anyhow, the interaction between programming paradigms and the human mind is a complex and difficult-to-test subject. For more, please see [[Oop And Human Thought Process]]. </i>",
      "id": "6cafc5a5b908f067acb22023d956a56d"
    },
    {
      "type": "html",
      "text": " Reduces the impact of requirement changes on code.",
      "id": "beb732616043465e5e0524af664badde"
    },
    {
      "type": "html",
      "text": " [[Delta Isolation]] (group by differences)",
      "id": "3e7c3c689b69235ec54ed708cca962bb"
    },
    {
      "type": "html",
      "text": " I'm curious about this claim - [[Delta Isolation]] of what? For data, the 'best' I've seen is [[Functional Reactive Programming]].",
      "id": "31b2dbc361a5a3bdebf445d341a15194"
    },
    {
      "type": "html",
      "text": " <i>Sub-classing can potentially allow one to take an existing class (model) and only implement the differences from the \"parent\" class. A typical \"training\" example: A toad is like a frog except for these differences: \"overridden\" behavior.</i>",
      "id": "2bd3c5f91d4b73b65648897abbfa9978"
    },
    {
      "type": "html",
      "text": " Makes software simpler (less code?) - (Next several are my expansions on this)",
      "id": "120861d0f498471a8086528a376fac08"
    },
    {
      "type": "html",
      "text": " Provides a reasonable set of organizational rules for software. <i>And other paradigms don't? | Not necessarily... but it general, that's correct {???}</i>",
      "id": "2650471f261d2117c81220e3d0c0f346"
    },
    {
      "type": "html",
      "text": " Reduces method length.",
      "id": "0b89be9ee57b96c7db07abaab164aa82"
    },
    {
      "type": "html",
      "text": " Reduces coupling <i>([[Measuring Coupling]], see [[Coupling And Cohesion]])</i>",
      "id": "5bb8daf3795945673bb296ff7b687350"
    },
    {
      "type": "html",
      "text": " This one by no means happens automatically! It takes a very good [[Dependency Injection]] framework, such as polymorphic constructors (related: [[New Considered Harmful]]). In most OOP languages, reducing coupling takes a great deal of [[Self Discipline]], which ranks this rather low in the [[Four Levels Of Feature]]. (That said, \"reduces coupling\" is relative. By comparison, ye'old imperative languages like C ([[Cee Is Not The Pinnacle Of Procedural]]) rank down nearabouts [[Turing Tarpit]] for reducing coupling.)",
      "id": "bdbfa45df7c3b6dd03cd7b8acb504d04"
    },
    {
      "type": "html",
      "text": " Increases cohesion <i>([[Measuring Cohesion]])</i>",
      "id": "5ed05ffb9eba175a85977c6eae75749a"
    },
    {
      "type": "html",
      "text": " Drives certain dogmatic [[Relational Weenie]]s nuts when it actually solves the problem at hand. <i>Even the lamest of paradigms sometimes work.</i>",
      "id": "57d411a45bb22a05ea376efe7aa64d2b"
    },
    {
      "type": "html",
      "text": " Provides better source code structure than procedural programming. <i>Please elaborate on \"better\".</i>",
      "id": "92a4320559fafe2a3e51467248b67d58"
    },
    {
      "type": "html",
      "text": " If you only use the OO model, you can't do anything wrong with the internal state, so claims a statement in [[Database Not More Global Than Classes]].",
      "id": "01683cea68d9b2caa58ec62fb10579b6"
    },
    {
      "type": "html",
      "text": " [[Oo Makes Testing Easier]] - <i>Discussion below</i>",
      "id": "0bc4f161de7708a7eccd8f5b28b530ba"
    },
    {
      "type": "html",
      "text": " Encapsulation provides method (function) name-space management features that other paradigms either don't have, or is language-specific within those paradigms.",
      "id": "c55fa7a2b9d05e568fa597be511aad1a"
    },
    {
      "type": "html",
      "text": " Provides one approach to building custom (domain-defined) mini-languages that may rely heavily on nested expressions without having to extend the application language itself. See [[Expression Api Complaints]] for examples.",
      "id": "dd74f090755bfc1357cc69f18baf925e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "[[Edit Hint]]: It would be good to list <b>how</b> you can achieve these benefits using OO.  Certainly you don't get beneficial effects magically, but by doing good work with the technique.",
      "id": "73e1dbbc416ed99fc0e5ebf8519be97e"
    },
    {
      "type": "html",
      "text": "<i>It has resisted \"external\" analysis. It seems [[Programming Is In The Mind]] and the benefits may depend on the individual doing the thinking about the program.</i>",
      "id": "b137435e31972fd5c26dbe37e975dae5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "[[Edit Hint]]: There's still plenty of material to mine from [[Benefits Of Oo Original Discussion]]",
      "id": "380e0e57caa6faf0af89681635eb6c96"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "\nHere is an \"anecdotes are good enough\" viewpoint:",
      "id": "47a88bfb8bc2f5a12ad46fdd56199711"
    },
    {
      "type": "html",
      "text": "\n[http://lambda-the-ultimate.org/node/view/893?from=200&comments_per_page=200 lambda-the-ultimate.org]",
      "id": "439998f846e5108e8eb06dc6509801f6"
    },
    {
      "type": "html",
      "text": "\nThose of us who criticize OOP do not necessarily disagree with personal or subjective benefits; it is the extrapolation assumption that they are universal or \"best practices\" which is the real problem. The article also suggests that OO better models the real world, but this does not seem to be a universal primary claim even among OO proponents. [insert link to existing real-world debate when found]",
      "id": "02558deacfc538d25708e8036aa3b572"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "\nOO is good because it makes <b>testing</b> easier.",
      "id": "9df94d334fbdd8b7cd749f0c07e1aa8b"
    },
    {
      "type": "html",
      "text": "<i>Example?</i>",
      "id": "4c59954448d7395d8f4bb314a17b55f1"
    },
    {
      "type": "html",
      "text": "\nYou can often test each class in isolation.",
      "id": "4e543fc135d9599001b04b3eca8a771c"
    },
    {
      "type": "html",
      "text": "<i>Same with modules.</i>",
      "id": "e96b32a21a73860fb6848a52c9d59269"
    },
    {
      "type": "html",
      "text": "[I'd go further and say that it's no more true for classes than for other units of code organization. Classes that don't depend on any others are in the minority, and often not very interesting.]",
      "id": "677211f8082e1963f4a4db9b01639685"
    },
    {
      "type": "html",
      "text": "\nFalse for any kind of modular language I can think of (C, which lacks a formal model of modules, still falls into this category, but so does Oberon(-2).  Not sure about Modula-2, but I'm pretty sure it also suffers the same problems).  In my OpenAX.25 C project, I was unable to test a module that used the BSD sockets API because, obviously, it would attempt to link against the BSD sockets library.  I couldn't create my own module which defined the sockets API myself because of duplicate symbol definition errors.  I had to resort to creating a thunk module called IPC, that defined IPC_recv(), IPC_select(), etc.  These functions added a layer of indirection which allowed my test code to not only isolate the module under test, but also alter the implementations of the respective IPC functions depending on the expected state of the application ([[State Pattern]]).  This made unit testing much easier, but at the rather significant cost of many lines of pointless code.",
      "id": "a146f943eba29ed976d5509a639da864"
    },
    {
      "type": "html",
      "text": "\nIn an object oriented (or, more accurately, polymorphically-oriented, which OO definitely is), this problem simply doesn't arise.  I can mock/stub out the IPC objects as I see fit in my unit test code trivially.",
      "id": "bef5fb1c201b605efff208b27db654dc"
    },
    {
      "type": "html",
      "text": "\nTo get this same convenience in a modular language, your language simply <i>must</i> implement run-time-dispatched generic functions at the very least.  Only CLOS implements this to the best of my knowledge.  But, then again, it isn't called the Common Lisp <i>Object</i> System for nothing.",
      "id": "178bc2ca0e8925dc67ac6531cef9fb46"
    },
    {
      "type": "html",
      "text": "\nIn languages that support [[Hyper Static Global Environment]]s, such as Forth, you can \"fake\" run-time rebinding of module interfaces by simply loading/compiling the mock/stub module before compiling the tests.  This wastes a bit of RAM, but since the tests occupy RAM only transiently, it shouldn't prove to be a burden.  The only thing that would happen is it'll somewhat lengthen the time it takes to compile and run the unit tests.",
      "id": "e9f654bf0c4566d3928d1c3257a9d5b8"
    },
    {
      "type": "html",
      "text": "<i>This seems a very language-specific thing. [[Cee Is Not The Pinnacle Of Procedural]]. I agree that introducing OO into a language probably gives one more name-space management options, but this is simply because the more paradigms you have, the more options you have. But, paradigm potpourri has its own downsides. </i>",
      "id": "ec4e3e16c9def95883454c9056693bd2"
    },
    {
      "type": "html",
      "text": "\nWhether C is a pinnacle or not is utterly irrelavent (please re-read where I also said the problem applies to every other modular language I am personally aware of, including Oberon, Python, Haskell, etc.)  Show me even <i>one</i> modular programming language that exercises late-binding at the <i>module level.</i>  It can't be done; as soon as you do, you all but <i>by definition</i> have an object system. --[[Samuel Falvo]]",
      "id": "d92410ce0effc8ff0e4e6d02ecad608f"
    },
    {
      "type": "html",
      "text": "<i>I first need to see if you are claiming that non-OO paradigms will *always* prevent the implementation of such a feature, or merely that it is not common in practice. For example, very few procedural languages I've encountered support nested subroutines (along with nested scope). Only Pascal. But, this is not a fault of the procedural paradigm. It is some kind of industry habit formed by who-knows-what, for I found nested routines and scope to be useful.</i>",
      "id": "d8ae02c18e7b165a3a6dd2f8ef71630c"
    },
    {
      "type": "html",
      "text": "\nLet me attempt to explain it via a bullet list to document my thought pattern.  Maybe then my reasoning will become clear.",
      "id": "13567e07bf4b333485d90b4c51ca680d"
    },
    {
      "type": "html",
      "text": " I think we can agree that entities which we call \"modules\" are statically linked units of compilation <i>at run-time.</i>",
      "id": "d1bb1726a3b30e8987716153f3088cd8"
    },
    {
      "type": "html",
      "text": " Although they may be <i>dynamically loaded,</i> their linkage occurs statically at the assembly language level once the loader performs address fixups.",
      "id": "fd5dd1d17234847bd4156c6f1b3ff0e9"
    },
    {
      "type": "html",
      "text": " It is possible to have two modules Y and Z such that they expose exactly the same interface.",
      "id": "58f745c0c091fa9838fffc24c98f376e"
    },
    {
      "type": "html",
      "text": " It is not possible for a module X which uses module Y's interface to, for the purposes of unit testing, suddenly use module Z, <i>without creating a whole new executable that is statically linked and loaded.</i>",
      "id": "045d5315c39dd2dfc3c176d031faaf16"
    },
    {
      "type": "html",
      "text": " The reason you need statically loaded binaries here is because without it, the system's loader may still inadvertently load module Y.",
      "id": "2d8557d6fb1dc94ef877c2a5d3a80119"
    },
    {
      "type": "html",
      "text": " When running unit tests, many different kinds of mocks may be necessary to thoroughly test module-level interfaces.",
      "id": "23c34cc40b736f51e45dc45e3517e105"
    },
    {
      "type": "html",
      "text": " Mocking the BSD sockets library for testing a new server daemon's ability to handle various kinds of malicious input, for example.",
      "id": "ced6257e97894a3fa411894c3d52f2d1"
    },
    {
      "type": "html",
      "text": " Each kind of malicious input represents a different set of state machines; hence a <i>[[State Pattern]]</i> is strongly desirable here.",
      "id": "9bdbb12885bdf2b3cc538430c2352d1e"
    },
    {
      "type": "html",
      "text": " However, the module under test has no idea that you're trying to mock sockets.",
      "id": "6d505bbd445097048578a428dc63262b"
    },
    {
      "type": "html",
      "text": " Therefore, there are only two solutions to follow:",
      "id": "b2099e65864e475fba8bfb99ffcd58ce"
    },
    {
      "type": "html",
      "text": " make a new module W, which serves as an abstraction of Y and Z, such that:",
      "id": "6ca7d5206b122feadb96f59dc8aea4a7"
    },
    {
      "type": "html",
      "text": " production logic invokes a function in W that configures its interface to respond to module Y.",
      "id": "d52edf9a57f5c111af26ac81489c9e53"
    },
    {
      "type": "html",
      "text": " test logic invokes a function in W that configures its interface to respond to module Z.",
      "id": "96ffb37255c81e797f30bb48f0f743b3"
    },
    {
      "type": "html",
      "text": " Module W must use function pointers or their equivalent to implement the redirection.",
      "id": "b45d0df91b5bc78971dc19f3bc2168d6"
    },
    {
      "type": "html",
      "text": " Thus, module W is an instance of the [[Bridge Pattern]], but at the module level.",
      "id": "18edd02f7a4b669c7b561e24465e077b"
    },
    {
      "type": "html",
      "text": " leave your module alone, don't bother with W at all, and turn what <i>should</i> be a unit test into an integration/acceptance test instead.",
      "id": "df3b10851b3d8d7a7ff0f155e65188aa"
    },
    {
      "type": "html",
      "text": " This is an [[Impedance Mismatch]].",
      "id": "8e1d0d62890a9d1566af7f4da73c366d"
    },
    {
      "type": "html",
      "text": " This can cause problems later on if tests are found to take up too much time.",
      "id": "f7fae851901ed65d838b6349ed0cfa38"
    },
    {
      "type": "html",
      "text": " This tends to be more difficult than necessary to automate.",
      "id": "a4633a9d4cff7f145fe5b475ffec18a8"
    },
    {
      "type": "html",
      "text": "\nA module, by all definitions currently known to me, is a static entity: it is, from the point of view of the CPU actually doing the job of running the code, just a chunk of code.  CALLs made to it are done with absolute, or at the very least, jump-tables with absolute, addresses.  Everything else, such as ensuring the module's interface matches your expectations prior to compiling, is a compiler-offered feature that has no concrete run-time representation, and even if it did (e.g., in the form of in-core type descriptors), it'd have no bearing on actual <i>execution</i> of code.  Once the binary image is loaded into memory, it's fixed.",
      "id": "eb61d91f49b0186905f43b7e88db6130"
    },
    {
      "type": "html",
      "text": "\nAs soon as you say, \"OK, this is stupid, let's add support for polymorphic module interfaces,\" well, you've basically re-invented object oriented architecture.  More precisely, you've reinvented <i>interfaces,</i> a feature that basically turns your module into a kind of <i>class,</i> because now you've introduced the ability to have multiple <i>concurrent</i> instances of your \"module\" co-resident with each other, each offering their services to objects that they own.",
      "id": "792a3cf2e964e016e104c8ef8d0d35da"
    },
    {
      "type": "html",
      "text": "\nLanguages which I know for a fact require the \"modules are static entities\" invariant to hold:",
      "id": "16d2f463947428ed353deccb4cd2cf2e"
    },
    {
      "type": "html",
      "text": " Haskell",
      "id": "ba80fe480601f42c5bc738766dc4ac22"
    },
    {
      "type": "html",
      "text": " Oberon(-2)",
      "id": "393f0cdd4d80bc3b85ab2bdeddf0eb0a"
    },
    {
      "type": "html",
      "text": " Modula-2",
      "id": "4d2e565fab581cc27cb3c2ebf0435790"
    },
    {
      "type": "html",
      "text": " Python (without resorting to unscrupulous manipulation of internal structures)",
      "id": "753da010849d2cf721a88ff146409c39"
    },
    {
      "type": "html",
      "text": " C/C++",
      "id": "ebb0420d5ba205ae4ca36a6b894cd5aa"
    },
    {
      "type": "html",
      "text": " Forth",
      "id": "7019358d91804ec06c9c6f2dc805afdd"
    },
    {
      "type": "html",
      "text": " OCaml",
      "id": "079ebed09446ef4c864dfd52f8a29b52"
    },
    {
      "type": "html",
      "text": " Java (Yes, a class file is also a module file; \"module-scope\" entities are things like static class methods and the like.)",
      "id": "0178994e2667af482b3fdcad9a7a6f10"
    },
    {
      "type": "html",
      "text": "\nLanguages where this is not the case:",
      "id": "4634421d1e86279ba63c4c1c6b22eea0"
    },
    {
      "type": "html",
      "text": " [[Common Lisp]] (you can redefine any existing procedure, or use (defmethod) to create a wrapper around existing procedures; this appears to be a practice that is <i>strongly</i> discouraged though)",
      "id": "97780e86584dae5e46d41ab163a3918e"
    },
    {
      "type": "html",
      "text": " Scheme (similar to CL, you can redefine a global name to mean something else)",
      "id": "825bf59419a45fb8de41d0f55de1a465"
    },
    {
      "type": "html",
      "text": "\nI just can't think of <i>any</i> other languages in mainstream use that offers comparable capabilities, from the sole point of view of unit testing alone, as what OO provides.",
      "id": "5ee57114de0e4758773b2b808ed3b74b"
    },
    {
      "type": "html",
      "text": "\nIf someone can prove me wrong, I'd love to hear from you.  :)  --[[Samuel Falvo]]",
      "id": "c40ce430558042d0c8d1a5e301e07aea"
    },
    {
      "type": "html",
      "text": "<i>I'll have to think about this more from a compiler/interpreter perspective. But generally even IF this was an inherent flaw of procedural, one still has two options:</i>",
      "id": "5cf30cf24daa63f6e54a386b0e4301c5"
    },
    {
      "type": "html",
      "text": " <i>Wrap the low-level services with your own routines with a name that does not overlap with the built-in libraries.</i>",
      "id": "20953661fa47514350251c58bee48933"
    },
    {
      "type": "html",
      "text": " <i>Use the low-level service itself to test. In other words, rather than make a dummy socket, use a *real* socket to a \"live\" test service. <b>This may be a better test anyhow</b> because you are using the real deal.</i>",
      "id": "a36cdad859dbd450c927ff03fc74d585"
    },
    {
      "type": "html",
      "text": " Not if you are <i>unit</i> testing, the whole purpose of which is to test code <i>in isolation.</i>  To do this, you have zero choices available: write a wrapper around the module in question, which is precisely what I did for the sockets API.  But, now, the code is linked against the wrapper permanently, even in shipping code.  Thankfully, the indirection doesn't add noticable overhead.",
      "id": "8a12df0dc77af613400427d2f0f3f593"
    },
    {
      "type": "html",
      "text": " <i>It may all depend on how flexible the name-space management is in a given language. I see nothing that inherently prevents a substitute of API mapping for unit tests in say procedural or functional programming even if specific languages suffer from related problems. However, I suppose you could argue that having OOP at least supplies one guaranteed way to do it: polymorphically. But this makes me want to focus on features at the feature level rather than at a paradigm level.</i>",
      "id": "2dbcc61a94b2607e752a44a10e792440"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "\nRE: <i>As soon as you say, \"OK, this is stupid, let's add support for polymorphic module interfaces,\" well, you've basically re-invented object oriented architecture.  More precisely, you've reinvented </i>interfaces,<i> a feature that basically turns your module into a kind of </i>class,<i> because now you've introduced the ability to have multiple </i>concurrent<i> instances of your \"module\" co-resident with each other, each offering their services to objects that they own. -- [[Samuel Falvo]]</i>",
      "id": "fd0cb6211a36c7339448847da445acb8"
    },
    {
      "type": "html",
      "text": "\nIs this truly object-<b>oriented</b>?  as in: results in [[Object Oriented Programming]]?  In my own experience, if you squint hard enough, anything is an object: functions in funtional programming, whole processes in operating-system programming, whole operating-systems in distributed systems programming, etcetera.  DLLs are objects to the dynamic link-loader.  It doesn't surprise me that you can consider parameterized modules and such to be objects.  Of better question is whether that view is <i>sufficient</i> to make the programming object-<b>oriented</b>. I'm not particularly keen on trying to answer this question.  (To me, [[There Are Exactly Three Paradigms]] in use that are truly 'meaningful', and 'object-oriented' is not among them.)  But I do note that mere support for parameterized modules would not meet [[Alan Kays Definition Of Object Oriented]], would not meet the [[Nygaard Classification]] for [[Object Oriented]], does not imply <i>inheritance</i> or any sort of implicit support for <i>delegation</i> (for [[Polymorphism Encapsulation Inheritance]]), and fails many other various [[Definitions For Oo]].  Of course, [[Nobody Agrees On What Oo Is]], so perhaps [[Samuel Falvo]]'s definition is as good as any other.",
      "id": "948d89010f58d70aa996ccacd21919d7"
    },
    {
      "type": "html",
      "text": "\nThere are languages that provide parameterized and abstract modules with concurrent existence.  Consider: if a programming language is modular with neat, polymorphic, parameterized modules and such, but did not provide modules as <i>first-class</i> entities that can be produced or replaced on-the-fly from within a language, would this really benefit testing?  Perhaps it is having 'first-class' component-configurations that is most relevant to making units easier to test.  Component configurations are necessary when dependencies go two directions (i.e. component A depends on something from component B, like a callback, and component B depends on something in component A, like a call.)",
      "id": "1cd1b8b89ece8d1c92b653008ad5c973"
    },
    {
      "type": "html",
      "text": "\nWhat means \"module\" in a programming language depends really upon how processes are glued together from constituent parts.  Merely having \"modular\" components, be they parameterized or polymorphic or not, doesn't make easy the task of configuring these components.",
      "id": "b4df4a987b101220be8ee955517e4b26"
    },
    {
      "type": "html",
      "text": "\n[[Samuel Falvo]] says: This is what I am talking about.  You can have support for parameterized modules, but the fact is, you're still invoking <i>that module,</i> not <i>your mock</i> module.  [[Ml Language]] supports parameterized modules, for example, but they're utterly useless from a unit testing perspective.",
      "id": "eef4d49b2798784ea0369a87af7c4515"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "<b>Structures and State</b>",
      "id": "e441c1314f114f96bb4e27f8b3ee10a0"
    },
    {
      "type": "html",
      "text": "<i>Moved from [[Object Oriented Design Is Difficult]]</i>",
      "id": "79380f0e8263b252b503b80601c0c8ea"
    },
    {
      "type": "html",
      "text": "\nSome opinions on OOP from a structured programming perspective (not using a true OO language):",
      "id": "1bc9ba8e98d30f834eea6a29e1cc07c2"
    },
    {
      "type": "html",
      "text": "\nAlthough some of us hate the hype behind OOP, we have found some ideas from OOP to be very useful in structured programming. OOP techniques can save typing, shorten the code, reduce copy and pasting or include file tricks, can make code more readable and less error prone. However, the opposite is also true: when not used carefully, OOP can bloat up code, overly complicate code, cause more errors (especially if dangling objects exist), cause a lot of uneeded line noise (free/create/new/destroy, etc). This is why some prefer to use the stack, along with modules, and not just objects. Some are not fond of purely heap based OOP languages.",
      "id": "9c858424425260be8c3060cd6cd3c172"
    },
    {
      "type": "html",
      "text": "\nConsider a case where some OOP techniques are useful: you have a struct/record that you wish to fool with. Say you need a new experimental structure based on an old one. You could copy and paste this old structure into a new file and play with it, or you could cast the struct/record using aligment tricks in C/Pascal. With old procedural coding you end up having to do these dangerous tricks, or copy and pasting to reuse that old structure. Sometimes you can write some procedures to wrap the old struct/record - but then you end up reinventing inheritance and writing boiler plate code! With OOP it hides this boiler plate code, it hides the \"self\" or \"this\" or \"me\" parameter you would have otherwise sent in to the procedures as a pointer or VAR param. In OOP you can safely inherit and play with a struct/record (class) without copy and pasting the old one, or without writing procedural wrappers which emulate inheritance!",
      "id": "656abcbb6735172ec603ad15d9a7a702"
    },
    {
      "type": "html",
      "text": "<i>[[Cee Is Not The Pinnacle Of Procedural]], nor is Pascal. For one, their structures are static at run-time. If they were based on [[Set Theory]], then one could use set operations to add or remove elements from an existing set of fields. <b>Set theory is far more flexible for managing variations-on-a-theme than sub-typing.</b> If you don't understand why this is so, we will never agree. [[Limits Of Hierarchies]] gives some examples. Without more details about what actually you are trying to acheive (business case), I cannot suggest an alternative language or solution. Related: [[Delta Isolation]].) --top</i>",
      "id": "03e6fc40017ae791b3fd6b66733b1d6b"
    },
    {
      "type": "html",
      "text": "\nWhat? Of course you can create dynamic structures at run time in Cee or Pascal. You just can't query them using a relational language so easily. But it could be done using parameter tricks, or a macro preprocessor. Consider an Array of Records or an Array of Structs. You can add and delete items from the array. A record or struct is in fact a Tuple in disguise. An array cannot be queried easily, but one could do it using tricks. Items in an array or list can indeed be inserted and deleted - at run time.  Arrays or lists can expand and be saved and loaded from a storage medium too (usually via files, but we don't have to see them as just files.. they could be relationally stored in several different files, split up for optimization - that's the physical issues we shouldn't worry about). The values of arrays or lists can be changed at run time. The trick would be making the items in the array <b>more query-able</b> then what is currently offered, perhaps reinventing [[Rel Project]] or TQL ideas. Lists and arrays usually only offer <b>ridiculously simple operations</b> such as remove, delete, append, insert, etc. There is <b>no query language available</b> for the <b>array</b>, or <b>list</b>. Databases are actually <b>a lot about queries</b> more so than people realize. <b>What's missing in Objects, Structs, Records - are queries.</b> ",
      "id": "8bf49edcba575fed97072eec13277836"
    },
    {
      "type": "html",
      "text": "\nAs for requiring Business Cases, I've provided plenty that you've missed. More concretely, consider a GUI button widget where one wishes to modify the button to have a border around it. Inheriting the button without damaging the old code or using copy and pasting allows us to muck around with a new button. The button does not need to be stored relationally - are you going to store the button's' caption and click behavior in a table? And how are you going to inherit this button without resorting to WinAPI style coding using procedural code, if not using relations?",
      "id": "3ed890463a471d76593dd7439231be4c"
    },
    {
      "type": "html",
      "text": "<i>If you don't mind, I'd like to stay away from GUI engine design here and focus on biz domain objects (customers, accounts, invoices, etc.). For one, most custom app developers do not develop GUI widgets from scratch. Second, GUI's are a very long and involved topic. The answer to the above would likely depend on the details of a specific GUI engine: one GUI engine may have a difficult spot where another doesn't and vise verse. (A set-friendly GUI engine would generally start out widgets with all possible behavior and features and filter-based \"elimination\" would be used to exclude a border from a button, not the other way around as often found in tree-oriented thinking.) I'd suggest you visit [[Programming Language Neutral Gui]] if you are interested in such. </i>",
      "id": "8b4a584d0c4e004bbf7528f7872a2587"
    },
    {
      "type": "html",
      "text": "\nMoved response to [[Domain Niche Discussion]].",
      "id": "91e50c951a6321e75db9dd98bc1493e2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "\nOne problem with OOP is that the algorithms become welded into the class, even though we aren't sure that algorithm will only need to be part of that class! This leads to messes such as multiple inheritance and overly complex solutions (IMO). Some algorithms simply need not be welded to a class and we can't decide on this up front immediately! As a structured programmer speaking here, I therefore do not use pure OOP languages or any language that tries to be pure (Java, etc). However, even in these so called pure languages - one can escape the object system by using the global class (i.e. in Ruby one can DEF a procedure without it being tied to a specific class). Many so called pure languages still have ways that you can escape the OOP model when you need to.",
      "id": "1e231acea9a4a5dbc157f288fe25a8cd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "<i>From [[Aspect Oriented Programming]]</i>",
      "id": "d0cd72b7448a3cf11290d6459f992a83"
    },
    {
      "type": "html",
      "text": "\nIf we look back, using POP (Procedure-Oriented Programming), we must deal with all the concerns in a line. Though we can outsource the code into different functions, the main stream still controls all the process. This is the linear model. When OOP is introduced, we can present the world in a more natural way by describing different objects and their functions. Connections between different objects form a network, a matrix of type vs. behavior. This can be called the two-dimensional model.",
      "id": "16182d284a3881170d4dd40e0698a5e6"
    },
    {
      "type": "html",
      "text": "<i>How is \"natural\" being measured here? I am bothered by that claim.</i>",
      "id": "a68f0cc6fcf74650d3cf765b0bfbd125"
    },
    {
      "type": "html",
      "text": "\"Natural\" is somewhat informal, but the improvement mentioned above could be measured in terms of the degree to which unrelated concerns can be expressed (and developed & tested) independently of one another. OOP, when introduced, was a step up from POP languages of the same era due to the indirection from interface to implementation (message passing or virtual functions). One may encapsulate unrelated concerns in different objects, and these objects may then interact blissfully ignorant of the concerns encapsulated by their companions. Compare POP, in which the calling procedure must be aware of and test for 'unrelated' concerns so that it can properly select a procedure to call, forcing the system to be coded with a much more 'global' policy and more 'global' data available to procedures. ",
      "id": "4f2baeda931dec3513bf1bb37dca0619"
    },
    {
      "type": "html",
      "text": "\nOf course, OOP still fails grievously when dealing with <i>related</i> concerns such as concurrency management, persistence, logging, optimization decisions, memory management, etc. As a class, these are called [[Cross Cutting Concern]]s.  If OOP succeeded at these, there would be no need for AOP. Similarly, OOP also runs into the [[Expression Problem]] - adding new 'verbs' to an interface requires touching every class in the project.",
      "id": "136d929956750ca517e081fb6099cd85"
    },
    {
      "type": "html",
      "text": "<b>Re:</b> expressed (and developed & tested) independently ... step up from POP languages of the same era ... ",
      "id": "40af3ec3b53d88c835c6b9bc608ed3fe"
    },
    {
      "type": "html",
      "text": "<i>I'm skeptical. I'd like to see semi-realistic coded examples.</i>",
      "id": "71b6b2f203f3c75c6c0e62010ec09325"
    },
    {
      "type": "html",
      "text": "\nThe simplest examples are available in procedures containing things such as 'baker.bake(ingredients)'. In procedural, the calling procedure must contain the information to locate the correct bake method, such as 'if isBreadBaker(baker) then bakeBread(ingredients) else if isPieBaker(baker) then bakePie(ingredients)'. ",
      "id": "d3f000fd2708682996288d64d61cad4a"
    },
    {
      "type": "html",
      "text": " This is covered in [[Switch Statements Smell]]. Your example assumes a hierarchical subtype-based model of domain nouns. However, in practice variations-on-themes are best modeled with sets (buffet of semi-independent features), not hierarchies. -- top",
      "id": "03d0802c9048cae93cf66d86fe87869c"
    },
    {
      "type": "html",
      "text": " You are in error to claim the example has anything to do with a \"hierarchical subtype-based model of domain nouns\" - it doesn't matter whether or not there is a 'Baker' class, only whether the object currently called 'baker' can accept the 'bake (ingredients)' message. OOP does not <i>necessarily</i> imply hierarchical classification schemes. ",
      "id": "f50cd7aaa1b887127d304ccf605be4dc"
    },
    {
      "type": "html",
      "text": " Also, 'doer.do(parameters)' is a pattern that applies to [[Functor Object]]s in general, and is generally <i>not</i> applied to [[Domain Object]]s. I'm not particularly fond of [[Domain Object]]s, and I agree that your \"buffet of semi-independent features\" ([[Feature Buffet Model]]) will often be better for modeling them. OTOH, neither procedural nor OO are particularly adept at handling [[Feature Buffet Model]] - better, I expect, would be a rules based approach.",
      "id": "e78395af808210606dc248f2434ec9d8"
    },
    {
      "type": "html",
      "text": " Traditional OO polymorphism works well with \"toy\" examples, but not with realistic ones, at least in my domain. OO does not natively handle sets and many-to-many relationships, let alone the ability to query complex objects ad-hoc, and I consider these a flaw with it. <b>Most of the claims on this page would melt away under the scrutinty of more realistic examples</b> (at least for some domains). --top",
      "id": "092e2dd96523d650bb697174be54aaf9"
    },
    {
      "type": "html",
      "text": " I agree that OO does not effectively handle many-to-many relationships, multiple dispatch, fine-grained specialization, 'open' specialization, or complex queries. OTOH, neither does procedural, which was OO's main competitor at the time these claims were made. ",
      "id": "c541d78ddc41d9e635dea1296d82d01f"
    },
    {
      "type": "html",
      "text": " <i>Please clarify. OO's competitor is both procedural and relational. They compete with different aspects of OO. I agree that if by gun-point I was not allowed to use relational or databases, I'd probably prefer some OOP over just procedural. Limiting the discussion from powerful combo's would not be very useful, unless we want to pretend we're in the disco era. Procedural and relational compliment each other well without having similar territory to fight over. OOP half invents a database, but leaves out too much. --top</i>",
      "id": "7669a1439f2899316e565dd30563b420"
    },
    {
      "type": "html",
      "text": " Hmmm... I can see how my statements would be confusing. There are OO databases (OODBMS), which compete with relational, and then there is [[Object Oriented Programming]] (OOP), which does not compete with relational. The two don't coincide or compete except when programmers start [[Reinventing The Database In Application]] (which does happen, but is not a practice I recommend). In general, these applications of 'OO' should be evaluated separately. My statements above were made in reference to OOP, not OODBMS.",
      "id": "f00a4396e78738187107ec4c676f8fec"
    },
    {
      "type": "html",
      "text": " <i>Again, I disagree about OO not competing with relational. The [[Visitor Pattern]] is a prime example of something that relational would do differently. When you make a choice to use visitor, you are un-choosing a relational solution. As far as OODBMS, some say there is no such thing because OODBMS do not have any real encapsulation. They only share OO's navigational structuring (that is, a mass wad of pointers with a dab of tree-ness), which almost nobody would promote if OO didn't do it. --top</i>",
      "id": "7f921907546f7f0d89f257ff9eaca178"
    },
    {
      "type": "html",
      "text": " How does use of [[Visitor Pattern]] \"un-choose\" a relational solution? Explain this to me in logical terms. ",
      "id": "a9a2acf1163f3e93d8a22ce03bff353c"
    },
    {
      "type": "html",
      "text": " <i>A given solution cannot be both at the same time (at least not without making a mess). Therefore, it must either be an OO solution or a relational solution.</i>",
      "id": "89d3b49209f7bec2b10ed57b93053c12"
    },
    {
      "type": "html",
      "text": " [What do you mean by this?  OO and relational approaches are complementary rather than competing.]",
      "id": "8e750ca86f0353d5cdc40800f9d47fe9"
    },
    {
      "type": "html",
      "text": " Agreed. I feel [[Top Mind]] is assuming the consequent here.",
      "id": "d806dd7d265d2c94923d1a3b51a0c641"
    },
    {
      "type": "html",
      "text": " <i>I don't understand why this isn't more obvious. There's some kind of translation/communication block going on. Take the [[Double Dispatch Example]]. The solution is pretty much going to be either OOP, relational, or some other paradigm. --top</i>",
      "id": "6551421ec047584a474319e2d5c456b2"
    },
    {
      "type": "html",
      "text": " In [[Double Dispatch Example]], your 'relational weenie' example implements OOP techniques and stores (or references) the scripts/functions for each 'printer object' within the RDBMS. Refer back to page anchor OOP_tehniques_impl. ",
      "id": "6f9ae65768e73bccbeed24701a13f1bd"
    },
    {
      "type": "html",
      "text": " <i>You mean code or references to code in data structures? OO has no monopoly on that. Lisp was doing it about 7 years before the first OOP language. I'm not sure what paradigm we should give that credit to. Perhaps none owns it. It was easy to do in machine language. Later languages made the technique more difficult, subtracting that ability, perhaps fearing it made programs less predictable. See [[History Of Code In Structures]].</i>",
      "id": "ebf0f3949e4931385befaa7fa7925d12"
    },
    {
      "type": "html",
      "text": " (page anchor not-just-code-in-structures) I mean dispatch based on associating 'objects' (printers) with 'code' (scripts) to process certain 'commands' (printing shapes) into which you'll need to feed both other data about that object (so that the script can print the shape to the right printer) and other data about that command (so that the script can print the shape with the correct size and position). And hand-implementation is the early stage in the life cycle for nearly all programming language methodologies and techniques - that doesn't make them any less OOP <b>techniques</b>, it only makes them less OOP <b>languages</b>.",
      "id": "0af41d67f9d84c4e7360dd8d887e3b8b"
    },
    {
      "type": "html",
      "text": " <i>Records = objects is too much word-play in my opinion.</i>",
      "id": "fb9af5ceeb4f707b5c940b97d9408455"
    },
    {
      "type": "html",
      "text": " Funny. I never suggested 'records = objects'. It is [[Object Identity]], and the ability to associate attributes with such an identity, that makes an object.",
      "id": "750a96e9c1315d560c9a6fb5946ce596"
    },
    {
      "type": "html",
      "text": " <i>But anyhow, both approaches \"put code in data structures\" (or code references). In that aspect, they both use a similar technique, and I don't give OO credit for inventing that technique as described in [[History Of Code In Structures]]. Merely using a common technique does not break my overlap claim any more than both using [[Quick Sort]] makes them non-overlapping. In one, the structure is objects tied together via references, in the other the structe is a RDBMS table.</i>",
      "id": "4f01aca2ff8ac4455719bec8e6f593c3"
    },
    {
      "type": "html",
      "text": " History is irrelevant. Credit for the technique is irrelevant. That one has \"put code in data structures\" is, guess what? That's irrelevant too. OOP is not about 'code in data structures' (and many implementations do not put the dispatch code into the data structures). OOP is about dispatching messages and commands to things associated with object identity. ",
      "id": "2b5995ca83ed9975ece8671d0b963156"
    },
    {
      "type": "html",
      "text": " Regardless, your [[Double Dispatch Example]] is a poor example if your goal is to demonstrate relational and OO not working together, even though I don't believe it a good example of them working together. Relational and OO are readily integrated by using OO to, according to database provided configurations, construct programs on the fly for processing 'inputs'... which may also come from the database. As noted elsewhere, the only thing RDBMS is missing to make this complementary union nearly perfect is the ability to 'subscribe' to queries with [[Delta Isolation]] (e.g. via dynamic insert/update/delete events on the 'view' so subscribed).",
      "id": "7bb71daa9399e2472bd16dc94007f3ad"
    },
    {
      "type": "html",
      "text": " <i>The last 2 paragraphs are not clear. One is putting the code references in tables *or* they are putting them in objects/classes. It's a pretty strong dichotomy. They *are* fighting over territory. It's hard to be much clearer. You either put \"the stuff\" in tables, or you put \"the stuff\" in objects. --top</i>",
      "id": "35980a77649ea4e8ec950524a60f4a93"
    },
    {
      "type": "html",
      "text": " Your assertions are clear, Top. They're just wrong. OOP can be implemented using tables, at which point putting code references into objects/classes and putting them into tables will happily coincide.  And <i>that</i> (hand-implementing OOP techniques using tables) is exactly what your [[Double Dispatch Example]] does. ",
      "id": "190c29d10478851f2fe400585a797235"
    },
    {
      "type": "html",
      "text": " <i>They are not wrong. If so, please re-word as formal logic. code-in-structures is NOT unique to OOP as already described. That is a fact. It's like saying that inheritance provide defaults by having the default behavior in the parent class; therefore, anything with defaults is \"OO\".</i>",
      "id": "640420f47237c35629576f05a1aa633f"
    },
    {
      "type": "html",
      "text": " As formal logic: (A) OOP may be implemented using tables by associating object identity with properties (attributes, behavior descriptions). (B) If OOP can be implemented using tables, one will necessarily be putting the code references in tables *and* putting them in objects/classes. (C) Following from A & B, one can put code references into objects/classes and tables at the same time. (D) Therefore, your assertion to the contrary (that this \"is a pretty strong dichotomy\", exclusive \"either/or\") is in error. ",
      "id": "11a85f52a1ced15ee58eb851e796e96c"
    },
    {
      "type": "html",
      "text": " <i>You seem to be assuming that emulation is equivalence. Relational tables can be used to emulate OO (if that's what is happening) because tables are flexible and powerful, NOT because they \"are\" OO. OO can also emulate tables. [[Turing Equivalency]]. If I emulate [[Small Talk]] in Java, does that mean that Java *is* [[Small Talk]]?</i>",
      "id": "7f7dfa713794cf7a7188e85064d6f86e"
    },
    {
      "type": "html",
      "text": " No, I'm only assuming that emulation is \"implementation\".",
      "id": "e77c481fa953961b90093a29a589d963"
    },
    {
      "type": "html",
      "text": " Regarding your \"code-in-structures\" statement: I agree, 'code-in-structures' is not OO. But your [[Double Dispatch Example]], as I <i>have already explained</i> (at page anchor not-just-code-in-structures), is much more than 'code-in-structures'. Your [[Double Dispatch Example]] also has the following traits: [[Object Identity]] (foreign keys to printers), and dispatch to determine behavior based on recipient of request/command message (printer reference and shape identifier determines shape script... same as printer.drawCircle(), printer.drawRectangle()). [[Object Identity]] and virtual message dispatch are among the strongest defining traits of OO, being about the only features common to all OO languages (many of which lack classes and referential inheritance). Your [[Double Dispatch Example]] is a very clear implementation of OOP techniques, but using tables because you're a [[Relational Weenie]] and wanted to find a way to include tables.",
      "id": "3321cf2494abe5883ad4ab65031a0bc2"
    },
    {
      "type": "html",
      "text": " <i>This seems to get into [[Definitions For Oo]]. I disagree with your definition, but I will not take that up here. Further, \"message passing\" is rather open-ended. A function call is message passing. So is HTTP.</i>",
      "id": "20c8afdb689973ea97b282ee341bb125"
    },
    {
      "type": "html",
      "text": " Indeed. But OO is not <i>just</i> message passing, either. It is message passing with certain properties: message passing to things with '[[Object Identity]]' such that how the message is processed depends on the callee.  It seems you're sticking your eye up right against the bark and saying that you can't see the tree.",
      "id": "d4da05f1aa4240f5e3f9c671ce228c18"
    },
    {
      "type": "html",
      "text": " <i>Overall, if we back up away from definition-of-OO issues, one is still faced with the implementation dichotomy of putting code (or code references) in table *or* in language classes. Thus, at least the OOPL (app language) is \"fighting over territory\" with the RDBMS. Do you at least agree with this? --top</i>",
      "id": "1f550b7eeffc2e740c850b727c79cbf8"
    },
    {
      "type": "html",
      "text": " I do not agree with that.  Your [[Double Dispatch Example]] is proof that there is no implementation dichotomy. And, even if you put aside the fact that your [[Double Dispatch Example]] is implementing OO between its relational storage of [[Domain Object]] print drivers and procedural driven dispatch, that example does not serve as an argument (or even as evidence) that OO and relational are somehow \"fighting over territory\". All it shows is that you can use relational to implement OO.",
      "id": "2f950490a16a2bdffd165e76051a153e"
    },
    {
      "type": "html",
      "text": " And there are OODBMSs - even encapsulation may be included by supporting getters and setters - but I happen to agree that the design is fundamentally flawed because it enforces a model on data. I'm a person who favors 'thin table' relational solutions and rejects even the [[Entity Relationship Modeling]] as a basis for organizing data in an RDBMS. ",
      "id": "69b2fa492030265d86acde75aa9203d0"
    },
    {
      "type": "html",
      "text": " <i>If it includes [[Turing Complete]] setter/getter's, then it could be classified as an OOP programming language that removes the distinction between RAM and disk. However, I will agree that the distinction could be fuzzy. The [[Small Talk]] environment could potentially be considered a (non-relational) database, for example.</i>",
      "id": "ceb8b2b30d286137410a4d8da1c1dfb1"
    },
    {
      "type": "html",
      "text": " A programming system can be achieved by allowing communication to be triggered by update events in a database, but doing so is more [[Functional Reactive Programming]] than [[Object Oriented Programming]]. And the '[[Turing Complete]]' issue is not a distinction with which I'd agree: (while there are advantages of such a restriction, there is nothing in RDBMS or OODBMS that <i>requires</i> avoiding [[Turing Complete]] views, updateable views, updates, and queries of data). The important distinction is on 'data' from <b>outside</b> the system vs. 'objects' built <b>inside</b> the programming system. Related: [[Object Vs Model]].",
      "id": "6e3f1e19033db4ea675c47191fe27987"
    },
    {
      "type": "html",
      "text": " <i>The outside/inside dichotomy can be weak or fuzzy. A [[Control Table]] (or parts of it) may be very app-specific, for example, yet is as much part of the database as any other table. In my opinion, the definition of \"database\" is kind of like the [[Definition Of Life]]: there is no one trait that makes it a database (or database-ish), but rather a multiple factors.  --top</i>",
      "id": "3ceb854414989f4bf7c4264af1de7c5d"
    },
    {
      "type": "html",
      "text": " Hmmm? It isn't so weak or fuzzy as you believe. Programs have inputs, and inputs are clearly from 'outside' the system. If you're confused, I did mean (and say) 'from' outside vs. inside, as opposed to currently stored there. Things like [[Control Table]] and other forms of configuration data and configuration management data tend to also be 'inputs' to manipulate a program - they're from the outside even if they are very app-specific. And while 'database' tends to refer to a persistent collection of data as opposed to the management system, I don't really see what the issue of database definitions has to do with the above (perhaps a miscommunication?).",
      "id": "bdb892afd2264ddc486029d267add2fc"
    },
    {
      "type": "html",
      "text": " <i>I've converted [[Control Tables]] into arrays or function calls back and forth for performance or scaling or shop-style-preference reasons. The solution design is pretty much conceptually the same. It is mostly an <b>implementation detail</b> whether I put such info in a non-code table or in say arrays with hard-coded constants.</i> --top",
      "id": "11489fdf11cda98e01afaa2b13b3522c"
    },
    {
      "type": "html",
      "text": "  Indeed, whether you store code in an object file, script files, or a database, is an implementation detail. [[Data And Code Are The Same Thing]], and [[Logic Programming]] fully embraces this fact. What matters is <b>communication</b> between systems. In terms of data, it matters whether the code/data comes from <i>outside</i> a given computation system (i.e. is subject to external manipulation by users or environment) or is <i>internal</i> to the system. ",
      "id": "69d268b86a5503be92a28eb1cf03e45c"
    },
    {
      "type": "html",
      "text": " <i>Please clarify. \"Outside\" is a matter of perspective. [[Cold Fusion]] has its own internal SQL processing engine and internal tables. It is not \"outside\". Moving the same table to a non-[[Cold Fusion]] RDBMS does not change the basic nature of the design. (CF's internal tabling has some big flaws, but irrelevant to this.)</i>",
      "id": "88ed8040461f4b04cf275e26b1709188"
    },
    {
      "type": "html",
      "text": " \"Outside a given computation system\" is a matter of topography and is well defined for any given computation system. And to help clarify: really doesn't matter where you store or process the data, only matters whether the data is under control of the computation system or its environment.  ",
      "id": "7620af85db4b883dcd00b86263d384ca"
    },
    {
      "type": "html",
      "text": " <i>If only the app has the password to a given RDBMS table, then only the app \"has control\". Again, that seems a very minor thing to pivot big distinctions on.</i>",
      "id": "fff3d131d37701fd8b6119a4af4b9ac2"
    },
    {
      "type": "html",
      "text": " Control within a computation system is not at all a minor thing, though your lack of [[System Programming]] and [[Programming Language Theory]] background might lead you to believe otherwise. But, while security measures like passwords support distinguishing control, they don't matter nearly so much as the control itself, which really comes down to service contracts. For example, the application also has control over that table if others are simply not allowed to touch it and the application itself is allowed to fail if anyone else touches it. If the application is required to accommodate changes to the [[Control Table]], and things outside that application are allowed to change that [[Control Table]], then control is clearly outside the application, and the current state of the [[Control Table]] must be considered by programmers an input to the application (something that cannot be wholly anticipated, certainly cannot be compiled into the program via [[Compile Time Resolution]] and subjected to [[Partial Evaluation]], probably needs documented like other application inputs, must be maintained for backwards compatibility, etc.), and must further be considered by users as a configuration for the application (something that can be tweaked, and that will need to be versioned and managed carefully). It's a big thing, and so big distinctions pivot on it.",
      "id": "a657c354255bb8a303b4dbffa25d7d66"
    },
    {
      "type": "html",
      "text": " <i>We'll just have to [[Agree To Disagree]]. I view it as an implementation detail. It can be swapped back and forth without changing the basic nature of the design. In my opinion you are over-interpreting or over-magnifying side issues.</i>",
      "id": "3af4a3e7a4ec38b48cd22481279e6553"
    },
    {
      "type": "html",
      "text": " I've the impression that we're talking past each other. I agree that <i>\"where the [[Control Table]] is stored\"</i> is an \"implementation detail\". What you don't seem to grok is that <i>\"where the [[Control Table]] is stored\"</i> does NOT determine <i>\"who controls the [[Control Table]]\"</i> (this being the logical consequence of service contracts determining control). I think you assume that I would find error in your implementing a [[Control Table]] in an external RDBMS and calling it an 'implementation detail' of the application. But I don't have a problem with you doing that... with some exceptions. As I understand it, an 'implementation detail' is something that is 'encapsulated' in the 'implementation' and may be changed without breaking client code. If you allow clients of your application to tweak and re-configure that [[Control Table]], to maintain configurations, and to treat the [[Control Table]] as an interface to the application, it is no longer an 'implementation detail'. (The importance of the distinction becomes much more obvious to programmers that have <i>more than one client</i> for a given unit of software.)",
      "id": "caefce5e772c86b20b4db3627fa9e363"
    },
    {
      "type": "html",
      "text": " Regardless, I do agree that we're falling away from the topic subject, and that this conversation can be tabled.",
      "id": "3fee3cdf899d980d7acd3352cbf9bde4"
    },
    {
      "type": "html",
      "text": " <i>Could you please make changes to [[Are Oo And Relational Orthogonal Discussion Three]]? I was in the process of moving your changes over, but they happened faster than I could keep up. Thus, I'll let you do the final appendings. Thanks.</i>",
      "id": "a57202f74a53a2f8649ae389d89a6fc6"
    },
    {
      "type": "html",
      "text": "\nIn a unit testing framework, or in independent development, it would be easy to create a 'mock' baker that can report which ingredients it has baked. This mock baker could be queried after tests to ensure the caller is working correctly. These tests, and the mock baker, would be able to coexist with the final application code. In the procedural methodologies, independent testing would require mock-implementations of 'bakeBread' and 'bakePie' and so on, and the testing framework would need to be built and maintained independently of the application.",
      "id": "da2ed70d53e26a8d9083a51b84b7ea7e"
    },
    {
      "type": "html",
      "text": "\nAnd to stem a likely objection: I fully agree that one could use [[Object Oriented]] techniques even in a [[Procedural Programming Language]]. One is free to call a 'bake' script or 'bakefn' function associated with the baker. One could even put such a script into a database. But most people would just say you're reinventing OO. [[Object Oriented]] programming languages only aim to make it easier and sometimes safer (than in procedural languages) to use these techniques. (page anchor OOP_techniques_impl) {My objection is near that anchor also.}",
      "id": "62836f885470fa2bbb0012500af19bfd"
    },
    {
      "type": "html",
      "text": "<i>That's reinventing Lisp, not OOP. And, it only \"makes it easier\" in simplistic textbook examples or device drivers, not production design.</i>",
      "id": "b2e835686eaf3c5b3d93d6cf2c7f5ae5"
    },
    {
      "type": "html",
      "text": "\nIt is OOP, which was later reinvented in Lisp as CLOS. And read the above again: \"make it easier\" refers to the use of OOP techniques in OO languages (relative to the use of OOP techniques in procedural languages) - it isn't something I'd expect you to contest.  Refer to prior sections of the page if you wish to contest claims about the OOP techniques themselves providing benefits over procedural methodologies.",
      "id": "e41bedfaf6e10b9d31f926fa415adf75"
    },
    {
      "type": "html",
      "text": "<i>I don't believe this is correct. That ability existed in early Lisp.</i>",
      "id": "6ae4319268e645d787fcac4d80213d56"
    },
    {
      "type": "html",
      "text": "[Object orientation (in Simula I) dates from 1962, which is roughly five years after the invention of LISP, but CLOS and its direct predecessors date from the 1980s.]   ",
      "id": "180fd698ad5eedcfecfdcf0a1aa549dc"
    },
    {
      "type": "html",
      "text": "\nThe ability to implement CLOS existed in early Lisp, if that is what you mean, [[Top Mind]]. But, by that reasoning, even [[Snusp Language]] is OOP. Please don't appeal to the lowest of the [[Four Levels Of Feature]].",
      "id": "abdf4e9eefba287e2128aa0bde37dfad"
    },
    {
      "type": "html",
      "text": "\nNo real effort to support for [[Object Oriented]] programming techniques in Lisp existed until the late 70s, well after [[Smalltalk Language]] and [[Simula Language]] had some time to gestate among the people at MIT. (Well, there was at least one other effort, LOOP. Not sure when that one started, or what happened to it.) Anyhow, CLOS is another case of building one language inside another - a rather well developed feature of Lisp.",
      "id": "c2ec2f6b71f6a14c100fbb71c5a3f5c4"
    },
    {
      "type": "html",
      "text": "<i>I thought it was Simula II that introduced the OO features, not Simula I. Anyhow, since Lisp makes it easy to mix data and code, any data structure can also contain code. Thus, it may have:</i>",
      "id": "3a28b63e02f29172560b168993505f37"
    },
    {
      "type": "code",
      "text": " (bakers\n    (baker01 (attributes...) (code for baker01...))     \n    (baker02 (attributes...) (code for baker02...))     \n    (baker03 (attributes...) (code for baker03...))     \n    Etc...\n  )",
      "id": "68cf2c8d851815e78a4c0236d326ad77"
    },
    {
      "type": "html",
      "text": "<i>Although I agree such may be an \"OOP concept\", it was not \"invented\" by OOP nor is it exclusive to OOP. Other paradigms may rightfully claim it as one of their techniques.</i>",
      "id": "a328f5d2b037010a01b7e4968a8cbe3b"
    },
    {
      "type": "html",
      "text": "\nCode in structures without any extra support is [[Functional Programming]]. It doesn't help with constructors or inheritance, with automatic 'self' reference, with dispatch, etc. ",
      "id": "c95d1e845586321d0f7395873b7a9d81"
    },
    {
      "type": "html",
      "text": "<i>Constructors could also be considered a form of [[Event Driven Programming]]. It's an \"on-create\" event. Again, it's a \"shared feature\". The others may be also upon further analysis.</i>",
      "id": "78daa6951a66d54b329da4148000522f"
    },
    {
      "type": "html",
      "text": "\nAh! I think I understand. You're objecting to the idea that OOP perhaps \"owns\" certain ways-of-organizing-code, and they can't exist within other orientations or designs. Who is promoting this idea to which you are objecting? ",
      "id": "357f689cecf9f3c4b2beea06c0a00465"
    },
    {
      "type": "html",
      "text": "\nI suspect you'd find many that people do, in fact, believe in the existence of [[Multi Paradigm Programming Language]]s. I certainly do. Since I believe in [[Multi Paradigm Programming Language]]s, I don't consider features to be \"owned\" by paradigms/orientations; rather, I say that features are \"necessary\" to paradigms/orientations, or that a paradigm/orientation is \"supported\" by a language having a certain non-exclusive sets of [[Key Language Feature]]s. Any given language feature might be necessary to supporting many paradigms.",
      "id": "f7b4e6051366e3311f457659610fe072"
    },
    {
      "type": "html",
      "text": "<i>Actually, mixing data and programming code was more or less how things started out in computers. They were separated to help manage code, ironically. Now we are shifting back that way as modern techniques allow the power of combining but hopefully without most the original downsides that made it frowned upon.</i>",
      "id": "2a77567a9e6275c6deffd1d8d966ef1f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "Re: <b>Reduces method length</b>",
      "id": "ac64cb267ead10c7882705e7779e0206"
    },
    {
      "type": "html",
      "text": "\nI'd like to see a demonstration. The only example I can think of that made such claim is related to the controversial [[Switch Statements Smell]]. ",
      "id": "81af806d42a0dd7cdabd7cd80c842448"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "\nRe: <b>Reduces the impact of requirement changes on code.</b> ",
      "id": "7f012ec5c289aee692926b6504c79994"
    },
    {
      "type": "html",
      "text": "\nMoved discussion to [[Oop And Change Impact]].",
      "id": "300be4be2cf401fcb7ff6a61e1d221f8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "Contrast [[Arguments Against Oop]]",
      "id": "2e9bc0a87ce5cfff27885a05172a6fc9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "60be78920ba179cb086904ece75ee9ae"
    },
    {
      "type": "html",
      "text": "[[Category Object Orientation]]",
      "id": "ac1bef18b1f5dbecddf649ed3a574d5b"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?BenefitsOfOo c2.com]",
      "id": "dd2f0f66aefcfc6569211cfd9a6f96ee"
    }
  ],
  "journal": [
    {
      "date": 1355639982000,
      "id": "1d9bb497159648be3bdaa3f4c224abe4",
      "type": "create",
      "item": {
        "title": "Benefits Of Oo",
        "story": [
          {
            "type": "html",
            "text": "[[Object Oriented Programming]] provides a different view of programming than [[Procedural Programming]] or [[Functional Programming]].  On the one hand it's about bundling the state and behavior together, but in a larger sense it's about a mindset--a way of looking at programming.",
            "id": "bef6c97403c9bb8fff32fe1ed89702fe"
          },
          {
            "type": "html",
            "text": "\nBelow is a list of benefits often assigned to or claimed about OO. If you know of any evidence or detailed argument for any of these, feel free to link them in. Please use the discussion area below the list for long content.",
            "id": "01da5e5d5f697301e47b55292131afce"
          },
          {
            "type": "html",
            "text": " Reuse. (But see [[Reuse Has Failed]].)",
            "id": "dd65c715e4ee639cae139c86af14d331"
          },
          {
            "type": "html",
            "text": " [[Configurable Modularity]] at Runtime (improved over most procedural languages, which offer [[Configurable Modularity]] only at code-time)",
            "id": "34e358e29384d5b4b78291c749d23233"
          },
          {
            "type": "html",
            "text": " [[Gate Keeper]] / [[Capability Security Model]].",
            "id": "363e2b361f615929984ff147c5cdea1f"
          },
          {
            "type": "html",
            "text": " [[Poly Morphism]] increases expressiveness.",
            "id": "09d21e6264d6d9281ec6f5ed875ec354"
          },
          {
            "type": "html",
            "text": " Better models the real world (or at least better matches a useful model of the real world)",
            "id": "1bbef39785758467f680c4be0658eb7b"
          },
          {
            "type": "html",
            "text": " Better models human thought processes. <i>Hotly contended because heavily tied to psychology theories and personal differences.</i> ",
            "id": "b7f062f8edeb8b7a5f89185ad3da6989"
          },
          {
            "type": "html",
            "text": " There is a fallacy involved in this assertion. Humans may abstract and model world as objects (soft reflective abstraction), but OOP constructs world via objects (hard projective abstraction). Those are opposite behaviors, but the surface similarities may lead one to believe that OOP better models human thought. See also: [[Object Vs Model]], [[Oop Not For Domain Modeling]].",
            "id": "4d790beb4abb86a9fe3bb6d6c688f12d"
          },
          {
            "type": "html",
            "text": " <i>Basically, humans easily hold multiple views of things - recognizing multiple patterns - whereas OOP often forces us to pick one view and entrench it in our code.</i>",
            "id": "58e3b83e9c006a106336245565eb53ea"
          },
          {
            "type": "html",
            "text": " I'd be hesitant to make blanket statements about human [[Wet Ware]] outside of my own. People are different. Some are more comfortable with [[Everything Isa]].",
            "id": "3d038a222af092bbb7154fa447cfb7c1"
          },
          {
            "type": "html",
            "text": " <i>Looking at \"comfort\" level is a terrible way to measure whether something is related to \"human thought processes\" because it depends heavily upon other factors, such as familiarity. What the body of hard psychological evidence tells us is that all people (barring genetic defect, brain damage, or psychoactive drugs) perform the same cognitive functions, learn and think and recognize and pattern match by the same mechanisms. Humans are not </i>that<i> different.</i>",
            "id": "4ba9b6606c1e4ed8f873b390618e297c"
          },
          {
            "type": "html",
            "text": " <i>Besides that, you probably are not qualified to make statements about even your own [[Wet Ware]]. Very few people keep careful tabs and make objective judgements about their own behavior and thought patterns. If you think you're one of the few exceptions, you are almost certainly deluding yourself (which is a rather common pattern in human behavior).</i> ",
            "id": "12c3e3eff7f97d1260fa69f7f4905274"
          },
          {
            "type": "html",
            "text": " Compared to others, I believe I am pretty good at explaining my mental steps to come to a judgment or model if I think about it enough. This is with the exception of remembering specific events that add up to summary judgments about frequencies. I don't have a photographic memory. But perhaps we should take this discussion to another topic. ",
            "id": "cd7f3b4356476c8fe9b0084dc8677367"
          },
          {
            "type": "html",
            "text": " <i>You should look up the term 'confabulation', learn what it means, and apply it to your daily life.</i>",
            "id": "9997968303ab5bccde6c2d45ce8b9fea"
          },
          {
            "type": "html",
            "text": " Do you mean my claims to about my ability to turn my mental models into something clear or concrete, or the accuracy of these models as far as predicting activity in the real world? The sub-topic is modeling the human mind, not modeling the \"actual\" world accurately. It's merely a claim of an ability at introspection of thought processes sufficient enough to replicate much of it on paper or an algorithm.",
            "id": "08febba32cd8252ddff0706c5ff3e4b7"
          },
          {
            "type": "html",
            "text": " <i>I'm calling you human. [[Humans Are Lousy At Self Evaluation]]. Confabulation is also common; I do it all the time, but I'm aware of the possibility so I can correct for it by establishing processes and habits. The problem is, human, that you're super-arrogant and think yourself above these issues. Regarding the rest, here's a piece of common sense that you apparently failed to learn: If one person calls you an ass, that's his problem. If many people call you an ass, that's your problem.</i>",
            "id": "60c0f40d5887c60c11717cd7119a7280"
          },
          {
            "type": "html",
            "text": " I see a lot of projecting going on there. And because the person/people who personally insult me rarely use handles, it could be one or a hundred and so I cannot make any reliable assessment of popularity. Further, argument-by-popularity is generally a weak argument. You can't make the world flat by voting it flat. Enough about how much we hate each other. Let's get back to the topic.",
            "id": "936c46d7fe02a58311b3d07436e0660e"
          },
          {
            "type": "html",
            "text": " <i>Perhaps I over-personalized your statement. Anyhow, the interaction between programming paradigms and the human mind is a complex and difficult-to-test subject. For more, please see [[Oop And Human Thought Process]]. </i>",
            "id": "6cafc5a5b908f067acb22023d956a56d"
          },
          {
            "type": "html",
            "text": " Reduces the impact of requirement changes on code.",
            "id": "beb732616043465e5e0524af664badde"
          },
          {
            "type": "html",
            "text": " [[Delta Isolation]] (group by differences)",
            "id": "3e7c3c689b69235ec54ed708cca962bb"
          },
          {
            "type": "html",
            "text": " I'm curious about this claim - [[Delta Isolation]] of what? For data, the 'best' I've seen is [[Functional Reactive Programming]].",
            "id": "31b2dbc361a5a3bdebf445d341a15194"
          },
          {
            "type": "html",
            "text": " <i>Sub-classing can potentially allow one to take an existing class (model) and only implement the differences from the \"parent\" class. A typical \"training\" example: A toad is like a frog except for these differences: \"overridden\" behavior.</i>",
            "id": "2bd3c5f91d4b73b65648897abbfa9978"
          },
          {
            "type": "html",
            "text": " Makes software simpler (less code?) - (Next several are my expansions on this)",
            "id": "120861d0f498471a8086528a376fac08"
          },
          {
            "type": "html",
            "text": " Provides a reasonable set of organizational rules for software. <i>And other paradigms don't? | Not necessarily... but it general, that's correct {???}</i>",
            "id": "2650471f261d2117c81220e3d0c0f346"
          },
          {
            "type": "html",
            "text": " Reduces method length.",
            "id": "0b89be9ee57b96c7db07abaab164aa82"
          },
          {
            "type": "html",
            "text": " Reduces coupling <i>([[Measuring Coupling]], see [[Coupling And Cohesion]])</i>",
            "id": "5bb8daf3795945673bb296ff7b687350"
          },
          {
            "type": "html",
            "text": " This one by no means happens automatically! It takes a very good [[Dependency Injection]] framework, such as polymorphic constructors (related: [[New Considered Harmful]]). In most OOP languages, reducing coupling takes a great deal of [[Self Discipline]], which ranks this rather low in the [[Four Levels Of Feature]]. (That said, \"reduces coupling\" is relative. By comparison, ye'old imperative languages like C ([[Cee Is Not The Pinnacle Of Procedural]]) rank down nearabouts [[Turing Tarpit]] for reducing coupling.)",
            "id": "bdbfa45df7c3b6dd03cd7b8acb504d04"
          },
          {
            "type": "html",
            "text": " Increases cohesion <i>([[Measuring Cohesion]])</i>",
            "id": "5ed05ffb9eba175a85977c6eae75749a"
          },
          {
            "type": "html",
            "text": " Drives certain dogmatic [[Relational Weenie]]s nuts when it actually solves the problem at hand. <i>Even the lamest of paradigms sometimes work.</i>",
            "id": "57d411a45bb22a05ea376efe7aa64d2b"
          },
          {
            "type": "html",
            "text": " Provides better source code structure than procedural programming. <i>Please elaborate on \"better\".</i>",
            "id": "92a4320559fafe2a3e51467248b67d58"
          },
          {
            "type": "html",
            "text": " If you only use the OO model, you can't do anything wrong with the internal state, so claims a statement in [[Database Not More Global Than Classes]].",
            "id": "01683cea68d9b2caa58ec62fb10579b6"
          },
          {
            "type": "html",
            "text": " [[Oo Makes Testing Easier]] - <i>Discussion below</i>",
            "id": "0bc4f161de7708a7eccd8f5b28b530ba"
          },
          {
            "type": "html",
            "text": " Encapsulation provides method (function) name-space management features that other paradigms either don't have, or is language-specific within those paradigms.",
            "id": "c55fa7a2b9d05e568fa597be511aad1a"
          },
          {
            "type": "html",
            "text": " Provides one approach to building custom (domain-defined) mini-languages that may rely heavily on nested expressions without having to extend the application language itself. See [[Expression Api Complaints]] for examples.",
            "id": "dd74f090755bfc1357cc69f18baf925e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "[[Edit Hint]]: It would be good to list <b>how</b> you can achieve these benefits using OO.  Certainly you don't get beneficial effects magically, but by doing good work with the technique.",
            "id": "73e1dbbc416ed99fc0e5ebf8519be97e"
          },
          {
            "type": "html",
            "text": "<i>It has resisted \"external\" analysis. It seems [[Programming Is In The Mind]] and the benefits may depend on the individual doing the thinking about the program.</i>",
            "id": "b137435e31972fd5c26dbe37e975dae5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "[[Edit Hint]]: There's still plenty of material to mine from [[Benefits Of Oo Original Discussion]]",
            "id": "380e0e57caa6faf0af89681635eb6c96"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "\nHere is an \"anecdotes are good enough\" viewpoint:",
            "id": "47a88bfb8bc2f5a12ad46fdd56199711"
          },
          {
            "type": "html",
            "text": "\n[http://lambda-the-ultimate.org/node/view/893?from=200&comments_per_page=200 lambda-the-ultimate.org]",
            "id": "439998f846e5108e8eb06dc6509801f6"
          },
          {
            "type": "html",
            "text": "\nThose of us who criticize OOP do not necessarily disagree with personal or subjective benefits; it is the extrapolation assumption that they are universal or \"best practices\" which is the real problem. The article also suggests that OO better models the real world, but this does not seem to be a universal primary claim even among OO proponents. [insert link to existing real-world debate when found]",
            "id": "02558deacfc538d25708e8036aa3b572"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "\nOO is good because it makes <b>testing</b> easier.",
            "id": "9df94d334fbdd8b7cd749f0c07e1aa8b"
          },
          {
            "type": "html",
            "text": "<i>Example?</i>",
            "id": "4c59954448d7395d8f4bb314a17b55f1"
          },
          {
            "type": "html",
            "text": "\nYou can often test each class in isolation.",
            "id": "4e543fc135d9599001b04b3eca8a771c"
          },
          {
            "type": "html",
            "text": "<i>Same with modules.</i>",
            "id": "e96b32a21a73860fb6848a52c9d59269"
          },
          {
            "type": "html",
            "text": "[I'd go further and say that it's no more true for classes than for other units of code organization. Classes that don't depend on any others are in the minority, and often not very interesting.]",
            "id": "677211f8082e1963f4a4db9b01639685"
          },
          {
            "type": "html",
            "text": "\nFalse for any kind of modular language I can think of (C, which lacks a formal model of modules, still falls into this category, but so does Oberon(-2).  Not sure about Modula-2, but I'm pretty sure it also suffers the same problems).  In my OpenAX.25 C project, I was unable to test a module that used the BSD sockets API because, obviously, it would attempt to link against the BSD sockets library.  I couldn't create my own module which defined the sockets API myself because of duplicate symbol definition errors.  I had to resort to creating a thunk module called IPC, that defined IPC_recv(), IPC_select(), etc.  These functions added a layer of indirection which allowed my test code to not only isolate the module under test, but also alter the implementations of the respective IPC functions depending on the expected state of the application ([[State Pattern]]).  This made unit testing much easier, but at the rather significant cost of many lines of pointless code.",
            "id": "a146f943eba29ed976d5509a639da864"
          },
          {
            "type": "html",
            "text": "\nIn an object oriented (or, more accurately, polymorphically-oriented, which OO definitely is), this problem simply doesn't arise.  I can mock/stub out the IPC objects as I see fit in my unit test code trivially.",
            "id": "bef5fb1c201b605efff208b27db654dc"
          },
          {
            "type": "html",
            "text": "\nTo get this same convenience in a modular language, your language simply <i>must</i> implement run-time-dispatched generic functions at the very least.  Only CLOS implements this to the best of my knowledge.  But, then again, it isn't called the Common Lisp <i>Object</i> System for nothing.",
            "id": "178bc2ca0e8925dc67ac6531cef9fb46"
          },
          {
            "type": "html",
            "text": "\nIn languages that support [[Hyper Static Global Environment]]s, such as Forth, you can \"fake\" run-time rebinding of module interfaces by simply loading/compiling the mock/stub module before compiling the tests.  This wastes a bit of RAM, but since the tests occupy RAM only transiently, it shouldn't prove to be a burden.  The only thing that would happen is it'll somewhat lengthen the time it takes to compile and run the unit tests.",
            "id": "e9f654bf0c4566d3928d1c3257a9d5b8"
          },
          {
            "type": "html",
            "text": "<i>This seems a very language-specific thing. [[Cee Is Not The Pinnacle Of Procedural]]. I agree that introducing OO into a language probably gives one more name-space management options, but this is simply because the more paradigms you have, the more options you have. But, paradigm potpourri has its own downsides. </i>",
            "id": "ec4e3e16c9def95883454c9056693bd2"
          },
          {
            "type": "html",
            "text": "\nWhether C is a pinnacle or not is utterly irrelavent (please re-read where I also said the problem applies to every other modular language I am personally aware of, including Oberon, Python, Haskell, etc.)  Show me even <i>one</i> modular programming language that exercises late-binding at the <i>module level.</i>  It can't be done; as soon as you do, you all but <i>by definition</i> have an object system. --[[Samuel Falvo]]",
            "id": "d92410ce0effc8ff0e4e6d02ecad608f"
          },
          {
            "type": "html",
            "text": "<i>I first need to see if you are claiming that non-OO paradigms will *always* prevent the implementation of such a feature, or merely that it is not common in practice. For example, very few procedural languages I've encountered support nested subroutines (along with nested scope). Only Pascal. But, this is not a fault of the procedural paradigm. It is some kind of industry habit formed by who-knows-what, for I found nested routines and scope to be useful.</i>",
            "id": "d8ae02c18e7b165a3a6dd2f8ef71630c"
          },
          {
            "type": "html",
            "text": "\nLet me attempt to explain it via a bullet list to document my thought pattern.  Maybe then my reasoning will become clear.",
            "id": "13567e07bf4b333485d90b4c51ca680d"
          },
          {
            "type": "html",
            "text": " I think we can agree that entities which we call \"modules\" are statically linked units of compilation <i>at run-time.</i>",
            "id": "d1bb1726a3b30e8987716153f3088cd8"
          },
          {
            "type": "html",
            "text": " Although they may be <i>dynamically loaded,</i> their linkage occurs statically at the assembly language level once the loader performs address fixups.",
            "id": "fd5dd1d17234847bd4156c6f1b3ff0e9"
          },
          {
            "type": "html",
            "text": " It is possible to have two modules Y and Z such that they expose exactly the same interface.",
            "id": "58f745c0c091fa9838fffc24c98f376e"
          },
          {
            "type": "html",
            "text": " It is not possible for a module X which uses module Y's interface to, for the purposes of unit testing, suddenly use module Z, <i>without creating a whole new executable that is statically linked and loaded.</i>",
            "id": "045d5315c39dd2dfc3c176d031faaf16"
          },
          {
            "type": "html",
            "text": " The reason you need statically loaded binaries here is because without it, the system's loader may still inadvertently load module Y.",
            "id": "2d8557d6fb1dc94ef877c2a5d3a80119"
          },
          {
            "type": "html",
            "text": " When running unit tests, many different kinds of mocks may be necessary to thoroughly test module-level interfaces.",
            "id": "23c34cc40b736f51e45dc45e3517e105"
          },
          {
            "type": "html",
            "text": " Mocking the BSD sockets library for testing a new server daemon's ability to handle various kinds of malicious input, for example.",
            "id": "ced6257e97894a3fa411894c3d52f2d1"
          },
          {
            "type": "html",
            "text": " Each kind of malicious input represents a different set of state machines; hence a <i>[[State Pattern]]</i> is strongly desirable here.",
            "id": "9bdbb12885bdf2b3cc538430c2352d1e"
          },
          {
            "type": "html",
            "text": " However, the module under test has no idea that you're trying to mock sockets.",
            "id": "6d505bbd445097048578a428dc63262b"
          },
          {
            "type": "html",
            "text": " Therefore, there are only two solutions to follow:",
            "id": "b2099e65864e475fba8bfb99ffcd58ce"
          },
          {
            "type": "html",
            "text": " make a new module W, which serves as an abstraction of Y and Z, such that:",
            "id": "6ca7d5206b122feadb96f59dc8aea4a7"
          },
          {
            "type": "html",
            "text": " production logic invokes a function in W that configures its interface to respond to module Y.",
            "id": "d52edf9a57f5c111af26ac81489c9e53"
          },
          {
            "type": "html",
            "text": " test logic invokes a function in W that configures its interface to respond to module Z.",
            "id": "96ffb37255c81e797f30bb48f0f743b3"
          },
          {
            "type": "html",
            "text": " Module W must use function pointers or their equivalent to implement the redirection.",
            "id": "b45d0df91b5bc78971dc19f3bc2168d6"
          },
          {
            "type": "html",
            "text": " Thus, module W is an instance of the [[Bridge Pattern]], but at the module level.",
            "id": "18edd02f7a4b669c7b561e24465e077b"
          },
          {
            "type": "html",
            "text": " leave your module alone, don't bother with W at all, and turn what <i>should</i> be a unit test into an integration/acceptance test instead.",
            "id": "df3b10851b3d8d7a7ff0f155e65188aa"
          },
          {
            "type": "html",
            "text": " This is an [[Impedance Mismatch]].",
            "id": "8e1d0d62890a9d1566af7f4da73c366d"
          },
          {
            "type": "html",
            "text": " This can cause problems later on if tests are found to take up too much time.",
            "id": "f7fae851901ed65d838b6349ed0cfa38"
          },
          {
            "type": "html",
            "text": " This tends to be more difficult than necessary to automate.",
            "id": "a4633a9d4cff7f145fe5b475ffec18a8"
          },
          {
            "type": "html",
            "text": "\nA module, by all definitions currently known to me, is a static entity: it is, from the point of view of the CPU actually doing the job of running the code, just a chunk of code.  CALLs made to it are done with absolute, or at the very least, jump-tables with absolute, addresses.  Everything else, such as ensuring the module's interface matches your expectations prior to compiling, is a compiler-offered feature that has no concrete run-time representation, and even if it did (e.g., in the form of in-core type descriptors), it'd have no bearing on actual <i>execution</i> of code.  Once the binary image is loaded into memory, it's fixed.",
            "id": "eb61d91f49b0186905f43b7e88db6130"
          },
          {
            "type": "html",
            "text": "\nAs soon as you say, \"OK, this is stupid, let's add support for polymorphic module interfaces,\" well, you've basically re-invented object oriented architecture.  More precisely, you've reinvented <i>interfaces,</i> a feature that basically turns your module into a kind of <i>class,</i> because now you've introduced the ability to have multiple <i>concurrent</i> instances of your \"module\" co-resident with each other, each offering their services to objects that they own.",
            "id": "792a3cf2e964e016e104c8ef8d0d35da"
          },
          {
            "type": "html",
            "text": "\nLanguages which I know for a fact require the \"modules are static entities\" invariant to hold:",
            "id": "16d2f463947428ed353deccb4cd2cf2e"
          },
          {
            "type": "html",
            "text": " Haskell",
            "id": "ba80fe480601f42c5bc738766dc4ac22"
          },
          {
            "type": "html",
            "text": " Oberon(-2)",
            "id": "393f0cdd4d80bc3b85ab2bdeddf0eb0a"
          },
          {
            "type": "html",
            "text": " Modula-2",
            "id": "4d2e565fab581cc27cb3c2ebf0435790"
          },
          {
            "type": "html",
            "text": " Python (without resorting to unscrupulous manipulation of internal structures)",
            "id": "753da010849d2cf721a88ff146409c39"
          },
          {
            "type": "html",
            "text": " C/C++",
            "id": "ebb0420d5ba205ae4ca36a6b894cd5aa"
          },
          {
            "type": "html",
            "text": " Forth",
            "id": "7019358d91804ec06c9c6f2dc805afdd"
          },
          {
            "type": "html",
            "text": " OCaml",
            "id": "079ebed09446ef4c864dfd52f8a29b52"
          },
          {
            "type": "html",
            "text": " Java (Yes, a class file is also a module file; \"module-scope\" entities are things like static class methods and the like.)",
            "id": "0178994e2667af482b3fdcad9a7a6f10"
          },
          {
            "type": "html",
            "text": "\nLanguages where this is not the case:",
            "id": "4634421d1e86279ba63c4c1c6b22eea0"
          },
          {
            "type": "html",
            "text": " [[Common Lisp]] (you can redefine any existing procedure, or use (defmethod) to create a wrapper around existing procedures; this appears to be a practice that is <i>strongly</i> discouraged though)",
            "id": "97780e86584dae5e46d41ab163a3918e"
          },
          {
            "type": "html",
            "text": " Scheme (similar to CL, you can redefine a global name to mean something else)",
            "id": "825bf59419a45fb8de41d0f55de1a465"
          },
          {
            "type": "html",
            "text": "\nI just can't think of <i>any</i> other languages in mainstream use that offers comparable capabilities, from the sole point of view of unit testing alone, as what OO provides.",
            "id": "5ee57114de0e4758773b2b808ed3b74b"
          },
          {
            "type": "html",
            "text": "\nIf someone can prove me wrong, I'd love to hear from you.  :)  --[[Samuel Falvo]]",
            "id": "c40ce430558042d0c8d1a5e301e07aea"
          },
          {
            "type": "html",
            "text": "<i>I'll have to think about this more from a compiler/interpreter perspective. But generally even IF this was an inherent flaw of procedural, one still has two options:</i>",
            "id": "5cf30cf24daa63f6e54a386b0e4301c5"
          },
          {
            "type": "html",
            "text": " <i>Wrap the low-level services with your own routines with a name that does not overlap with the built-in libraries.</i>",
            "id": "20953661fa47514350251c58bee48933"
          },
          {
            "type": "html",
            "text": " <i>Use the low-level service itself to test. In other words, rather than make a dummy socket, use a *real* socket to a \"live\" test service. <b>This may be a better test anyhow</b> because you are using the real deal.</i>",
            "id": "a36cdad859dbd450c927ff03fc74d585"
          },
          {
            "type": "html",
            "text": " Not if you are <i>unit</i> testing, the whole purpose of which is to test code <i>in isolation.</i>  To do this, you have zero choices available: write a wrapper around the module in question, which is precisely what I did for the sockets API.  But, now, the code is linked against the wrapper permanently, even in shipping code.  Thankfully, the indirection doesn't add noticable overhead.",
            "id": "8a12df0dc77af613400427d2f0f3f593"
          },
          {
            "type": "html",
            "text": " <i>It may all depend on how flexible the name-space management is in a given language. I see nothing that inherently prevents a substitute of API mapping for unit tests in say procedural or functional programming even if specific languages suffer from related problems. However, I suppose you could argue that having OOP at least supplies one guaranteed way to do it: polymorphically. But this makes me want to focus on features at the feature level rather than at a paradigm level.</i>",
            "id": "2dbcc61a94b2607e752a44a10e792440"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "\nRE: <i>As soon as you say, \"OK, this is stupid, let's add support for polymorphic module interfaces,\" well, you've basically re-invented object oriented architecture.  More precisely, you've reinvented </i>interfaces,<i> a feature that basically turns your module into a kind of </i>class,<i> because now you've introduced the ability to have multiple </i>concurrent<i> instances of your \"module\" co-resident with each other, each offering their services to objects that they own. -- [[Samuel Falvo]]</i>",
            "id": "fd0cb6211a36c7339448847da445acb8"
          },
          {
            "type": "html",
            "text": "\nIs this truly object-<b>oriented</b>?  as in: results in [[Object Oriented Programming]]?  In my own experience, if you squint hard enough, anything is an object: functions in funtional programming, whole processes in operating-system programming, whole operating-systems in distributed systems programming, etcetera.  DLLs are objects to the dynamic link-loader.  It doesn't surprise me that you can consider parameterized modules and such to be objects.  Of better question is whether that view is <i>sufficient</i> to make the programming object-<b>oriented</b>. I'm not particularly keen on trying to answer this question.  (To me, [[There Are Exactly Three Paradigms]] in use that are truly 'meaningful', and 'object-oriented' is not among them.)  But I do note that mere support for parameterized modules would not meet [[Alan Kays Definition Of Object Oriented]], would not meet the [[Nygaard Classification]] for [[Object Oriented]], does not imply <i>inheritance</i> or any sort of implicit support for <i>delegation</i> (for [[Polymorphism Encapsulation Inheritance]]), and fails many other various [[Definitions For Oo]].  Of course, [[Nobody Agrees On What Oo Is]], so perhaps [[Samuel Falvo]]'s definition is as good as any other.",
            "id": "948d89010f58d70aa996ccacd21919d7"
          },
          {
            "type": "html",
            "text": "\nThere are languages that provide parameterized and abstract modules with concurrent existence.  Consider: if a programming language is modular with neat, polymorphic, parameterized modules and such, but did not provide modules as <i>first-class</i> entities that can be produced or replaced on-the-fly from within a language, would this really benefit testing?  Perhaps it is having 'first-class' component-configurations that is most relevant to making units easier to test.  Component configurations are necessary when dependencies go two directions (i.e. component A depends on something from component B, like a callback, and component B depends on something in component A, like a call.)",
            "id": "1cd1b8b89ece8d1c92b653008ad5c973"
          },
          {
            "type": "html",
            "text": "\nWhat means \"module\" in a programming language depends really upon how processes are glued together from constituent parts.  Merely having \"modular\" components, be they parameterized or polymorphic or not, doesn't make easy the task of configuring these components.",
            "id": "b4df4a987b101220be8ee955517e4b26"
          },
          {
            "type": "html",
            "text": "\n[[Samuel Falvo]] says: This is what I am talking about.  You can have support for parameterized modules, but the fact is, you're still invoking <i>that module,</i> not <i>your mock</i> module.  [[Ml Language]] supports parameterized modules, for example, but they're utterly useless from a unit testing perspective.",
            "id": "eef4d49b2798784ea0369a87af7c4515"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "<b>Structures and State</b>",
            "id": "e441c1314f114f96bb4e27f8b3ee10a0"
          },
          {
            "type": "html",
            "text": "<i>Moved from [[Object Oriented Design Is Difficult]]</i>",
            "id": "79380f0e8263b252b503b80601c0c8ea"
          },
          {
            "type": "html",
            "text": "\nSome opinions on OOP from a structured programming perspective (not using a true OO language):",
            "id": "1bc9ba8e98d30f834eea6a29e1cc07c2"
          },
          {
            "type": "html",
            "text": "\nAlthough some of us hate the hype behind OOP, we have found some ideas from OOP to be very useful in structured programming. OOP techniques can save typing, shorten the code, reduce copy and pasting or include file tricks, can make code more readable and less error prone. However, the opposite is also true: when not used carefully, OOP can bloat up code, overly complicate code, cause more errors (especially if dangling objects exist), cause a lot of uneeded line noise (free/create/new/destroy, etc). This is why some prefer to use the stack, along with modules, and not just objects. Some are not fond of purely heap based OOP languages.",
            "id": "9c858424425260be8c3060cd6cd3c172"
          },
          {
            "type": "html",
            "text": "\nConsider a case where some OOP techniques are useful: you have a struct/record that you wish to fool with. Say you need a new experimental structure based on an old one. You could copy and paste this old structure into a new file and play with it, or you could cast the struct/record using aligment tricks in C/Pascal. With old procedural coding you end up having to do these dangerous tricks, or copy and pasting to reuse that old structure. Sometimes you can write some procedures to wrap the old struct/record - but then you end up reinventing inheritance and writing boiler plate code! With OOP it hides this boiler plate code, it hides the \"self\" or \"this\" or \"me\" parameter you would have otherwise sent in to the procedures as a pointer or VAR param. In OOP you can safely inherit and play with a struct/record (class) without copy and pasting the old one, or without writing procedural wrappers which emulate inheritance!",
            "id": "656abcbb6735172ec603ad15d9a7a702"
          },
          {
            "type": "html",
            "text": "<i>[[Cee Is Not The Pinnacle Of Procedural]], nor is Pascal. For one, their structures are static at run-time. If they were based on [[Set Theory]], then one could use set operations to add or remove elements from an existing set of fields. <b>Set theory is far more flexible for managing variations-on-a-theme than sub-typing.</b> If you don't understand why this is so, we will never agree. [[Limits Of Hierarchies]] gives some examples. Without more details about what actually you are trying to acheive (business case), I cannot suggest an alternative language or solution. Related: [[Delta Isolation]].) --top</i>",
            "id": "03e6fc40017ae791b3fd6b66733b1d6b"
          },
          {
            "type": "html",
            "text": "\nWhat? Of course you can create dynamic structures at run time in Cee or Pascal. You just can't query them using a relational language so easily. But it could be done using parameter tricks, or a macro preprocessor. Consider an Array of Records or an Array of Structs. You can add and delete items from the array. A record or struct is in fact a Tuple in disguise. An array cannot be queried easily, but one could do it using tricks. Items in an array or list can indeed be inserted and deleted - at run time.  Arrays or lists can expand and be saved and loaded from a storage medium too (usually via files, but we don't have to see them as just files.. they could be relationally stored in several different files, split up for optimization - that's the physical issues we shouldn't worry about). The values of arrays or lists can be changed at run time. The trick would be making the items in the array <b>more query-able</b> then what is currently offered, perhaps reinventing [[Rel Project]] or TQL ideas. Lists and arrays usually only offer <b>ridiculously simple operations</b> such as remove, delete, append, insert, etc. There is <b>no query language available</b> for the <b>array</b>, or <b>list</b>. Databases are actually <b>a lot about queries</b> more so than people realize. <b>What's missing in Objects, Structs, Records - are queries.</b> ",
            "id": "8bf49edcba575fed97072eec13277836"
          },
          {
            "type": "html",
            "text": "\nAs for requiring Business Cases, I've provided plenty that you've missed. More concretely, consider a GUI button widget where one wishes to modify the button to have a border around it. Inheriting the button without damaging the old code or using copy and pasting allows us to muck around with a new button. The button does not need to be stored relationally - are you going to store the button's' caption and click behavior in a table? And how are you going to inherit this button without resorting to WinAPI style coding using procedural code, if not using relations?",
            "id": "3ed890463a471d76593dd7439231be4c"
          },
          {
            "type": "html",
            "text": "<i>If you don't mind, I'd like to stay away from GUI engine design here and focus on biz domain objects (customers, accounts, invoices, etc.). For one, most custom app developers do not develop GUI widgets from scratch. Second, GUI's are a very long and involved topic. The answer to the above would likely depend on the details of a specific GUI engine: one GUI engine may have a difficult spot where another doesn't and vise verse. (A set-friendly GUI engine would generally start out widgets with all possible behavior and features and filter-based \"elimination\" would be used to exclude a border from a button, not the other way around as often found in tree-oriented thinking.) I'd suggest you visit [[Programming Language Neutral Gui]] if you are interested in such. </i>",
            "id": "8b4a584d0c4e004bbf7528f7872a2587"
          },
          {
            "type": "html",
            "text": "\nMoved response to [[Domain Niche Discussion]].",
            "id": "91e50c951a6321e75db9dd98bc1493e2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "\nOne problem with OOP is that the algorithms become welded into the class, even though we aren't sure that algorithm will only need to be part of that class! This leads to messes such as multiple inheritance and overly complex solutions (IMO). Some algorithms simply need not be welded to a class and we can't decide on this up front immediately! As a structured programmer speaking here, I therefore do not use pure OOP languages or any language that tries to be pure (Java, etc). However, even in these so called pure languages - one can escape the object system by using the global class (i.e. in Ruby one can DEF a procedure without it being tied to a specific class). Many so called pure languages still have ways that you can escape the OOP model when you need to.",
            "id": "1e231acea9a4a5dbc157f288fe25a8cd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "<i>From [[Aspect Oriented Programming]]</i>",
            "id": "d0cd72b7448a3cf11290d6459f992a83"
          },
          {
            "type": "html",
            "text": "\nIf we look back, using POP (Procedure-Oriented Programming), we must deal with all the concerns in a line. Though we can outsource the code into different functions, the main stream still controls all the process. This is the linear model. When OOP is introduced, we can present the world in a more natural way by describing different objects and their functions. Connections between different objects form a network, a matrix of type vs. behavior. This can be called the two-dimensional model.",
            "id": "16182d284a3881170d4dd40e0698a5e6"
          },
          {
            "type": "html",
            "text": "<i>How is \"natural\" being measured here? I am bothered by that claim.</i>",
            "id": "a68f0cc6fcf74650d3cf765b0bfbd125"
          },
          {
            "type": "html",
            "text": "\"Natural\" is somewhat informal, but the improvement mentioned above could be measured in terms of the degree to which unrelated concerns can be expressed (and developed & tested) independently of one another. OOP, when introduced, was a step up from POP languages of the same era due to the indirection from interface to implementation (message passing or virtual functions). One may encapsulate unrelated concerns in different objects, and these objects may then interact blissfully ignorant of the concerns encapsulated by their companions. Compare POP, in which the calling procedure must be aware of and test for 'unrelated' concerns so that it can properly select a procedure to call, forcing the system to be coded with a much more 'global' policy and more 'global' data available to procedures. ",
            "id": "4f2baeda931dec3513bf1bb37dca0619"
          },
          {
            "type": "html",
            "text": "\nOf course, OOP still fails grievously when dealing with <i>related</i> concerns such as concurrency management, persistence, logging, optimization decisions, memory management, etc. As a class, these are called [[Cross Cutting Concern]]s.  If OOP succeeded at these, there would be no need for AOP. Similarly, OOP also runs into the [[Expression Problem]] - adding new 'verbs' to an interface requires touching every class in the project.",
            "id": "136d929956750ca517e081fb6099cd85"
          },
          {
            "type": "html",
            "text": "<b>Re:</b> expressed (and developed & tested) independently ... step up from POP languages of the same era ... ",
            "id": "40af3ec3b53d88c835c6b9bc608ed3fe"
          },
          {
            "type": "html",
            "text": "<i>I'm skeptical. I'd like to see semi-realistic coded examples.</i>",
            "id": "71b6b2f203f3c75c6c0e62010ec09325"
          },
          {
            "type": "html",
            "text": "\nThe simplest examples are available in procedures containing things such as 'baker.bake(ingredients)'. In procedural, the calling procedure must contain the information to locate the correct bake method, such as 'if isBreadBaker(baker) then bakeBread(ingredients) else if isPieBaker(baker) then bakePie(ingredients)'. ",
            "id": "d3f000fd2708682996288d64d61cad4a"
          },
          {
            "type": "html",
            "text": " This is covered in [[Switch Statements Smell]]. Your example assumes a hierarchical subtype-based model of domain nouns. However, in practice variations-on-themes are best modeled with sets (buffet of semi-independent features), not hierarchies. -- top",
            "id": "03d0802c9048cae93cf66d86fe87869c"
          },
          {
            "type": "html",
            "text": " You are in error to claim the example has anything to do with a \"hierarchical subtype-based model of domain nouns\" - it doesn't matter whether or not there is a 'Baker' class, only whether the object currently called 'baker' can accept the 'bake (ingredients)' message. OOP does not <i>necessarily</i> imply hierarchical classification schemes. ",
            "id": "f50cd7aaa1b887127d304ccf605be4dc"
          },
          {
            "type": "html",
            "text": " Also, 'doer.do(parameters)' is a pattern that applies to [[Functor Object]]s in general, and is generally <i>not</i> applied to [[Domain Object]]s. I'm not particularly fond of [[Domain Object]]s, and I agree that your \"buffet of semi-independent features\" ([[Feature Buffet Model]]) will often be better for modeling them. OTOH, neither procedural nor OO are particularly adept at handling [[Feature Buffet Model]] - better, I expect, would be a rules based approach.",
            "id": "e78395af808210606dc248f2434ec9d8"
          },
          {
            "type": "html",
            "text": " Traditional OO polymorphism works well with \"toy\" examples, but not with realistic ones, at least in my domain. OO does not natively handle sets and many-to-many relationships, let alone the ability to query complex objects ad-hoc, and I consider these a flaw with it. <b>Most of the claims on this page would melt away under the scrutinty of more realistic examples</b> (at least for some domains). --top",
            "id": "092e2dd96523d650bb697174be54aaf9"
          },
          {
            "type": "html",
            "text": " I agree that OO does not effectively handle many-to-many relationships, multiple dispatch, fine-grained specialization, 'open' specialization, or complex queries. OTOH, neither does procedural, which was OO's main competitor at the time these claims were made. ",
            "id": "c541d78ddc41d9e635dea1296d82d01f"
          },
          {
            "type": "html",
            "text": " <i>Please clarify. OO's competitor is both procedural and relational. They compete with different aspects of OO. I agree that if by gun-point I was not allowed to use relational or databases, I'd probably prefer some OOP over just procedural. Limiting the discussion from powerful combo's would not be very useful, unless we want to pretend we're in the disco era. Procedural and relational compliment each other well without having similar territory to fight over. OOP half invents a database, but leaves out too much. --top</i>",
            "id": "7669a1439f2899316e565dd30563b420"
          },
          {
            "type": "html",
            "text": " Hmmm... I can see how my statements would be confusing. There are OO databases (OODBMS), which compete with relational, and then there is [[Object Oriented Programming]] (OOP), which does not compete with relational. The two don't coincide or compete except when programmers start [[Reinventing The Database In Application]] (which does happen, but is not a practice I recommend). In general, these applications of 'OO' should be evaluated separately. My statements above were made in reference to OOP, not OODBMS.",
            "id": "f00a4396e78738187107ec4c676f8fec"
          },
          {
            "type": "html",
            "text": " <i>Again, I disagree about OO not competing with relational. The [[Visitor Pattern]] is a prime example of something that relational would do differently. When you make a choice to use visitor, you are un-choosing a relational solution. As far as OODBMS, some say there is no such thing because OODBMS do not have any real encapsulation. They only share OO's navigational structuring (that is, a mass wad of pointers with a dab of tree-ness), which almost nobody would promote if OO didn't do it. --top</i>",
            "id": "7f921907546f7f0d89f257ff9eaca178"
          },
          {
            "type": "html",
            "text": " How does use of [[Visitor Pattern]] \"un-choose\" a relational solution? Explain this to me in logical terms. ",
            "id": "a9a2acf1163f3e93d8a22ce03bff353c"
          },
          {
            "type": "html",
            "text": " <i>A given solution cannot be both at the same time (at least not without making a mess). Therefore, it must either be an OO solution or a relational solution.</i>",
            "id": "89d3b49209f7bec2b10ed57b93053c12"
          },
          {
            "type": "html",
            "text": " [What do you mean by this?  OO and relational approaches are complementary rather than competing.]",
            "id": "8e750ca86f0353d5cdc40800f9d47fe9"
          },
          {
            "type": "html",
            "text": " Agreed. I feel [[Top Mind]] is assuming the consequent here.",
            "id": "d806dd7d265d2c94923d1a3b51a0c641"
          },
          {
            "type": "html",
            "text": " <i>I don't understand why this isn't more obvious. There's some kind of translation/communication block going on. Take the [[Double Dispatch Example]]. The solution is pretty much going to be either OOP, relational, or some other paradigm. --top</i>",
            "id": "6551421ec047584a474319e2d5c456b2"
          },
          {
            "type": "html",
            "text": " In [[Double Dispatch Example]], your 'relational weenie' example implements OOP techniques and stores (or references) the scripts/functions for each 'printer object' within the RDBMS. Refer back to page anchor OOP_tehniques_impl. ",
            "id": "6f9ae65768e73bccbeed24701a13f1bd"
          },
          {
            "type": "html",
            "text": " <i>You mean code or references to code in data structures? OO has no monopoly on that. Lisp was doing it about 7 years before the first OOP language. I'm not sure what paradigm we should give that credit to. Perhaps none owns it. It was easy to do in machine language. Later languages made the technique more difficult, subtracting that ability, perhaps fearing it made programs less predictable. See [[History Of Code In Structures]].</i>",
            "id": "ebf0f3949e4931385befaa7fa7925d12"
          },
          {
            "type": "html",
            "text": " (page anchor not-just-code-in-structures) I mean dispatch based on associating 'objects' (printers) with 'code' (scripts) to process certain 'commands' (printing shapes) into which you'll need to feed both other data about that object (so that the script can print the shape to the right printer) and other data about that command (so that the script can print the shape with the correct size and position). And hand-implementation is the early stage in the life cycle for nearly all programming language methodologies and techniques - that doesn't make them any less OOP <b>techniques</b>, it only makes them less OOP <b>languages</b>.",
            "id": "0af41d67f9d84c4e7360dd8d887e3b8b"
          },
          {
            "type": "html",
            "text": " <i>Records = objects is too much word-play in my opinion.</i>",
            "id": "fb9af5ceeb4f707b5c940b97d9408455"
          },
          {
            "type": "html",
            "text": " Funny. I never suggested 'records = objects'. It is [[Object Identity]], and the ability to associate attributes with such an identity, that makes an object.",
            "id": "750a96e9c1315d560c9a6fb5946ce596"
          },
          {
            "type": "html",
            "text": " <i>But anyhow, both approaches \"put code in data structures\" (or code references). In that aspect, they both use a similar technique, and I don't give OO credit for inventing that technique as described in [[History Of Code In Structures]]. Merely using a common technique does not break my overlap claim any more than both using [[Quick Sort]] makes them non-overlapping. In one, the structure is objects tied together via references, in the other the structe is a RDBMS table.</i>",
            "id": "4f01aca2ff8ac4455719bec8e6f593c3"
          },
          {
            "type": "html",
            "text": " History is irrelevant. Credit for the technique is irrelevant. That one has \"put code in data structures\" is, guess what? That's irrelevant too. OOP is not about 'code in data structures' (and many implementations do not put the dispatch code into the data structures). OOP is about dispatching messages and commands to things associated with object identity. ",
            "id": "2b5995ca83ed9975ece8671d0b963156"
          },
          {
            "type": "html",
            "text": " Regardless, your [[Double Dispatch Example]] is a poor example if your goal is to demonstrate relational and OO not working together, even though I don't believe it a good example of them working together. Relational and OO are readily integrated by using OO to, according to database provided configurations, construct programs on the fly for processing 'inputs'... which may also come from the database. As noted elsewhere, the only thing RDBMS is missing to make this complementary union nearly perfect is the ability to 'subscribe' to queries with [[Delta Isolation]] (e.g. via dynamic insert/update/delete events on the 'view' so subscribed).",
            "id": "7bb71daa9399e2472bd16dc94007f3ad"
          },
          {
            "type": "html",
            "text": " <i>The last 2 paragraphs are not clear. One is putting the code references in tables *or* they are putting them in objects/classes. It's a pretty strong dichotomy. They *are* fighting over territory. It's hard to be much clearer. You either put \"the stuff\" in tables, or you put \"the stuff\" in objects. --top</i>",
            "id": "35980a77649ea4e8ec950524a60f4a93"
          },
          {
            "type": "html",
            "text": " Your assertions are clear, Top. They're just wrong. OOP can be implemented using tables, at which point putting code references into objects/classes and putting them into tables will happily coincide.  And <i>that</i> (hand-implementing OOP techniques using tables) is exactly what your [[Double Dispatch Example]] does. ",
            "id": "190c29d10478851f2fe400585a797235"
          },
          {
            "type": "html",
            "text": " <i>They are not wrong. If so, please re-word as formal logic. code-in-structures is NOT unique to OOP as already described. That is a fact. It's like saying that inheritance provide defaults by having the default behavior in the parent class; therefore, anything with defaults is \"OO\".</i>",
            "id": "640420f47237c35629576f05a1aa633f"
          },
          {
            "type": "html",
            "text": " As formal logic: (A) OOP may be implemented using tables by associating object identity with properties (attributes, behavior descriptions). (B) If OOP can be implemented using tables, one will necessarily be putting the code references in tables *and* putting them in objects/classes. (C) Following from A & B, one can put code references into objects/classes and tables at the same time. (D) Therefore, your assertion to the contrary (that this \"is a pretty strong dichotomy\", exclusive \"either/or\") is in error. ",
            "id": "11a85f52a1ced15ee58eb851e796e96c"
          },
          {
            "type": "html",
            "text": " <i>You seem to be assuming that emulation is equivalence. Relational tables can be used to emulate OO (if that's what is happening) because tables are flexible and powerful, NOT because they \"are\" OO. OO can also emulate tables. [[Turing Equivalency]]. If I emulate [[Small Talk]] in Java, does that mean that Java *is* [[Small Talk]]?</i>",
            "id": "7f7dfa713794cf7a7188e85064d6f86e"
          },
          {
            "type": "html",
            "text": " No, I'm only assuming that emulation is \"implementation\".",
            "id": "e77c481fa953961b90093a29a589d963"
          },
          {
            "type": "html",
            "text": " Regarding your \"code-in-structures\" statement: I agree, 'code-in-structures' is not OO. But your [[Double Dispatch Example]], as I <i>have already explained</i> (at page anchor not-just-code-in-structures), is much more than 'code-in-structures'. Your [[Double Dispatch Example]] also has the following traits: [[Object Identity]] (foreign keys to printers), and dispatch to determine behavior based on recipient of request/command message (printer reference and shape identifier determines shape script... same as printer.drawCircle(), printer.drawRectangle()). [[Object Identity]] and virtual message dispatch are among the strongest defining traits of OO, being about the only features common to all OO languages (many of which lack classes and referential inheritance). Your [[Double Dispatch Example]] is a very clear implementation of OOP techniques, but using tables because you're a [[Relational Weenie]] and wanted to find a way to include tables.",
            "id": "3321cf2494abe5883ad4ab65031a0bc2"
          },
          {
            "type": "html",
            "text": " <i>This seems to get into [[Definitions For Oo]]. I disagree with your definition, but I will not take that up here. Further, \"message passing\" is rather open-ended. A function call is message passing. So is HTTP.</i>",
            "id": "20c8afdb689973ea97b282ee341bb125"
          },
          {
            "type": "html",
            "text": " Indeed. But OO is not <i>just</i> message passing, either. It is message passing with certain properties: message passing to things with '[[Object Identity]]' such that how the message is processed depends on the callee.  It seems you're sticking your eye up right against the bark and saying that you can't see the tree.",
            "id": "d4da05f1aa4240f5e3f9c671ce228c18"
          },
          {
            "type": "html",
            "text": " <i>Overall, if we back up away from definition-of-OO issues, one is still faced with the implementation dichotomy of putting code (or code references) in table *or* in language classes. Thus, at least the OOPL (app language) is \"fighting over territory\" with the RDBMS. Do you at least agree with this? --top</i>",
            "id": "1f550b7eeffc2e740c850b727c79cbf8"
          },
          {
            "type": "html",
            "text": " I do not agree with that.  Your [[Double Dispatch Example]] is proof that there is no implementation dichotomy. And, even if you put aside the fact that your [[Double Dispatch Example]] is implementing OO between its relational storage of [[Domain Object]] print drivers and procedural driven dispatch, that example does not serve as an argument (or even as evidence) that OO and relational are somehow \"fighting over territory\". All it shows is that you can use relational to implement OO.",
            "id": "2f950490a16a2bdffd165e76051a153e"
          },
          {
            "type": "html",
            "text": " And there are OODBMSs - even encapsulation may be included by supporting getters and setters - but I happen to agree that the design is fundamentally flawed because it enforces a model on data. I'm a person who favors 'thin table' relational solutions and rejects even the [[Entity Relationship Modeling]] as a basis for organizing data in an RDBMS. ",
            "id": "69b2fa492030265d86acde75aa9203d0"
          },
          {
            "type": "html",
            "text": " <i>If it includes [[Turing Complete]] setter/getter's, then it could be classified as an OOP programming language that removes the distinction between RAM and disk. However, I will agree that the distinction could be fuzzy. The [[Small Talk]] environment could potentially be considered a (non-relational) database, for example.</i>",
            "id": "ceb8b2b30d286137410a4d8da1c1dfb1"
          },
          {
            "type": "html",
            "text": " A programming system can be achieved by allowing communication to be triggered by update events in a database, but doing so is more [[Functional Reactive Programming]] than [[Object Oriented Programming]]. And the '[[Turing Complete]]' issue is not a distinction with which I'd agree: (while there are advantages of such a restriction, there is nothing in RDBMS or OODBMS that <i>requires</i> avoiding [[Turing Complete]] views, updateable views, updates, and queries of data). The important distinction is on 'data' from <b>outside</b> the system vs. 'objects' built <b>inside</b> the programming system. Related: [[Object Vs Model]].",
            "id": "6e3f1e19033db4ea675c47191fe27987"
          },
          {
            "type": "html",
            "text": " <i>The outside/inside dichotomy can be weak or fuzzy. A [[Control Table]] (or parts of it) may be very app-specific, for example, yet is as much part of the database as any other table. In my opinion, the definition of \"database\" is kind of like the [[Definition Of Life]]: there is no one trait that makes it a database (or database-ish), but rather a multiple factors.  --top</i>",
            "id": "3ceb854414989f4bf7c4264af1de7c5d"
          },
          {
            "type": "html",
            "text": " Hmmm? It isn't so weak or fuzzy as you believe. Programs have inputs, and inputs are clearly from 'outside' the system. If you're confused, I did mean (and say) 'from' outside vs. inside, as opposed to currently stored there. Things like [[Control Table]] and other forms of configuration data and configuration management data tend to also be 'inputs' to manipulate a program - they're from the outside even if they are very app-specific. And while 'database' tends to refer to a persistent collection of data as opposed to the management system, I don't really see what the issue of database definitions has to do with the above (perhaps a miscommunication?).",
            "id": "bdb892afd2264ddc486029d267add2fc"
          },
          {
            "type": "html",
            "text": " <i>I've converted [[Control Tables]] into arrays or function calls back and forth for performance or scaling or shop-style-preference reasons. The solution design is pretty much conceptually the same. It is mostly an <b>implementation detail</b> whether I put such info in a non-code table or in say arrays with hard-coded constants.</i> --top",
            "id": "11489fdf11cda98e01afaa2b13b3522c"
          },
          {
            "type": "html",
            "text": "  Indeed, whether you store code in an object file, script files, or a database, is an implementation detail. [[Data And Code Are The Same Thing]], and [[Logic Programming]] fully embraces this fact. What matters is <b>communication</b> between systems. In terms of data, it matters whether the code/data comes from <i>outside</i> a given computation system (i.e. is subject to external manipulation by users or environment) or is <i>internal</i> to the system. ",
            "id": "69d268b86a5503be92a28eb1cf03e45c"
          },
          {
            "type": "html",
            "text": " <i>Please clarify. \"Outside\" is a matter of perspective. [[Cold Fusion]] has its own internal SQL processing engine and internal tables. It is not \"outside\". Moving the same table to a non-[[Cold Fusion]] RDBMS does not change the basic nature of the design. (CF's internal tabling has some big flaws, but irrelevant to this.)</i>",
            "id": "88ed8040461f4b04cf275e26b1709188"
          },
          {
            "type": "html",
            "text": " \"Outside a given computation system\" is a matter of topography and is well defined for any given computation system. And to help clarify: really doesn't matter where you store or process the data, only matters whether the data is under control of the computation system or its environment.  ",
            "id": "7620af85db4b883dcd00b86263d384ca"
          },
          {
            "type": "html",
            "text": " <i>If only the app has the password to a given RDBMS table, then only the app \"has control\". Again, that seems a very minor thing to pivot big distinctions on.</i>",
            "id": "fff3d131d37701fd8b6119a4af4b9ac2"
          },
          {
            "type": "html",
            "text": " Control within a computation system is not at all a minor thing, though your lack of [[System Programming]] and [[Programming Language Theory]] background might lead you to believe otherwise. But, while security measures like passwords support distinguishing control, they don't matter nearly so much as the control itself, which really comes down to service contracts. For example, the application also has control over that table if others are simply not allowed to touch it and the application itself is allowed to fail if anyone else touches it. If the application is required to accommodate changes to the [[Control Table]], and things outside that application are allowed to change that [[Control Table]], then control is clearly outside the application, and the current state of the [[Control Table]] must be considered by programmers an input to the application (something that cannot be wholly anticipated, certainly cannot be compiled into the program via [[Compile Time Resolution]] and subjected to [[Partial Evaluation]], probably needs documented like other application inputs, must be maintained for backwards compatibility, etc.), and must further be considered by users as a configuration for the application (something that can be tweaked, and that will need to be versioned and managed carefully). It's a big thing, and so big distinctions pivot on it.",
            "id": "a657c354255bb8a303b4dbffa25d7d66"
          },
          {
            "type": "html",
            "text": " <i>We'll just have to [[Agree To Disagree]]. I view it as an implementation detail. It can be swapped back and forth without changing the basic nature of the design. In my opinion you are over-interpreting or over-magnifying side issues.</i>",
            "id": "3af4a3e7a4ec38b48cd22481279e6553"
          },
          {
            "type": "html",
            "text": " I've the impression that we're talking past each other. I agree that <i>\"where the [[Control Table]] is stored\"</i> is an \"implementation detail\". What you don't seem to grok is that <i>\"where the [[Control Table]] is stored\"</i> does NOT determine <i>\"who controls the [[Control Table]]\"</i> (this being the logical consequence of service contracts determining control). I think you assume that I would find error in your implementing a [[Control Table]] in an external RDBMS and calling it an 'implementation detail' of the application. But I don't have a problem with you doing that... with some exceptions. As I understand it, an 'implementation detail' is something that is 'encapsulated' in the 'implementation' and may be changed without breaking client code. If you allow clients of your application to tweak and re-configure that [[Control Table]], to maintain configurations, and to treat the [[Control Table]] as an interface to the application, it is no longer an 'implementation detail'. (The importance of the distinction becomes much more obvious to programmers that have <i>more than one client</i> for a given unit of software.)",
            "id": "caefce5e772c86b20b4db3627fa9e363"
          },
          {
            "type": "html",
            "text": " Regardless, I do agree that we're falling away from the topic subject, and that this conversation can be tabled.",
            "id": "3fee3cdf899d980d7acd3352cbf9bde4"
          },
          {
            "type": "html",
            "text": " <i>Could you please make changes to [[Are Oo And Relational Orthogonal Discussion Three]]? I was in the process of moving your changes over, but they happened faster than I could keep up. Thus, I'll let you do the final appendings. Thanks.</i>",
            "id": "a57202f74a53a2f8649ae389d89a6fc6"
          },
          {
            "type": "html",
            "text": "\nIn a unit testing framework, or in independent development, it would be easy to create a 'mock' baker that can report which ingredients it has baked. This mock baker could be queried after tests to ensure the caller is working correctly. These tests, and the mock baker, would be able to coexist with the final application code. In the procedural methodologies, independent testing would require mock-implementations of 'bakeBread' and 'bakePie' and so on, and the testing framework would need to be built and maintained independently of the application.",
            "id": "da2ed70d53e26a8d9083a51b84b7ea7e"
          },
          {
            "type": "html",
            "text": "\nAnd to stem a likely objection: I fully agree that one could use [[Object Oriented]] techniques even in a [[Procedural Programming Language]]. One is free to call a 'bake' script or 'bakefn' function associated with the baker. One could even put such a script into a database. But most people would just say you're reinventing OO. [[Object Oriented]] programming languages only aim to make it easier and sometimes safer (than in procedural languages) to use these techniques. (page anchor OOP_techniques_impl) {My objection is near that anchor also.}",
            "id": "62836f885470fa2bbb0012500af19bfd"
          },
          {
            "type": "html",
            "text": "<i>That's reinventing Lisp, not OOP. And, it only \"makes it easier\" in simplistic textbook examples or device drivers, not production design.</i>",
            "id": "b2e835686eaf3c5b3d93d6cf2c7f5ae5"
          },
          {
            "type": "html",
            "text": "\nIt is OOP, which was later reinvented in Lisp as CLOS. And read the above again: \"make it easier\" refers to the use of OOP techniques in OO languages (relative to the use of OOP techniques in procedural languages) - it isn't something I'd expect you to contest.  Refer to prior sections of the page if you wish to contest claims about the OOP techniques themselves providing benefits over procedural methodologies.",
            "id": "e41bedfaf6e10b9d31f926fa415adf75"
          },
          {
            "type": "html",
            "text": "<i>I don't believe this is correct. That ability existed in early Lisp.</i>",
            "id": "6ae4319268e645d787fcac4d80213d56"
          },
          {
            "type": "html",
            "text": "[Object orientation (in Simula I) dates from 1962, which is roughly five years after the invention of LISP, but CLOS and its direct predecessors date from the 1980s.]   ",
            "id": "180fd698ad5eedcfecfdcf0a1aa549dc"
          },
          {
            "type": "html",
            "text": "\nThe ability to implement CLOS existed in early Lisp, if that is what you mean, [[Top Mind]]. But, by that reasoning, even [[Snusp Language]] is OOP. Please don't appeal to the lowest of the [[Four Levels Of Feature]].",
            "id": "abdf4e9eefba287e2128aa0bde37dfad"
          },
          {
            "type": "html",
            "text": "\nNo real effort to support for [[Object Oriented]] programming techniques in Lisp existed until the late 70s, well after [[Smalltalk Language]] and [[Simula Language]] had some time to gestate among the people at MIT. (Well, there was at least one other effort, LOOP. Not sure when that one started, or what happened to it.) Anyhow, CLOS is another case of building one language inside another - a rather well developed feature of Lisp.",
            "id": "c2ec2f6b71f6a14c100fbb71c5a3f5c4"
          },
          {
            "type": "html",
            "text": "<i>I thought it was Simula II that introduced the OO features, not Simula I. Anyhow, since Lisp makes it easy to mix data and code, any data structure can also contain code. Thus, it may have:</i>",
            "id": "3a28b63e02f29172560b168993505f37"
          },
          {
            "type": "code",
            "text": " (bakers\n    (baker01 (attributes...) (code for baker01...))     \n    (baker02 (attributes...) (code for baker02...))     \n    (baker03 (attributes...) (code for baker03...))     \n    Etc...\n  )",
            "id": "68cf2c8d851815e78a4c0236d326ad77"
          },
          {
            "type": "html",
            "text": "<i>Although I agree such may be an \"OOP concept\", it was not \"invented\" by OOP nor is it exclusive to OOP. Other paradigms may rightfully claim it as one of their techniques.</i>",
            "id": "a328f5d2b037010a01b7e4968a8cbe3b"
          },
          {
            "type": "html",
            "text": "\nCode in structures without any extra support is [[Functional Programming]]. It doesn't help with constructors or inheritance, with automatic 'self' reference, with dispatch, etc. ",
            "id": "c95d1e845586321d0f7395873b7a9d81"
          },
          {
            "type": "html",
            "text": "<i>Constructors could also be considered a form of [[Event Driven Programming]]. It's an \"on-create\" event. Again, it's a \"shared feature\". The others may be also upon further analysis.</i>",
            "id": "78daa6951a66d54b329da4148000522f"
          },
          {
            "type": "html",
            "text": "\nAh! I think I understand. You're objecting to the idea that OOP perhaps \"owns\" certain ways-of-organizing-code, and they can't exist within other orientations or designs. Who is promoting this idea to which you are objecting? ",
            "id": "357f689cecf9f3c4b2beea06c0a00465"
          },
          {
            "type": "html",
            "text": "\nI suspect you'd find many that people do, in fact, believe in the existence of [[Multi Paradigm Programming Language]]s. I certainly do. Since I believe in [[Multi Paradigm Programming Language]]s, I don't consider features to be \"owned\" by paradigms/orientations; rather, I say that features are \"necessary\" to paradigms/orientations, or that a paradigm/orientation is \"supported\" by a language having a certain non-exclusive sets of [[Key Language Feature]]s. Any given language feature might be necessary to supporting many paradigms.",
            "id": "f7b4e6051366e3311f457659610fe072"
          },
          {
            "type": "html",
            "text": "<i>Actually, mixing data and programming code was more or less how things started out in computers. They were separated to help manage code, ironically. Now we are shifting back that way as modern techniques allow the power of combining but hopefully without most the original downsides that made it frowned upon.</i>",
            "id": "2a77567a9e6275c6deffd1d8d966ef1f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "Re: <b>Reduces method length</b>",
            "id": "ac64cb267ead10c7882705e7779e0206"
          },
          {
            "type": "html",
            "text": "\nI'd like to see a demonstration. The only example I can think of that made such claim is related to the controversial [[Switch Statements Smell]]. ",
            "id": "81af806d42a0dd7cdabd7cd80c842448"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "\nRe: <b>Reduces the impact of requirement changes on code.</b> ",
            "id": "7f012ec5c289aee692926b6504c79994"
          },
          {
            "type": "html",
            "text": "\nMoved discussion to [[Oop And Change Impact]].",
            "id": "300be4be2cf401fcb7ff6a61e1d221f8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "Contrast [[Arguments Against Oop]]",
            "id": "2e9bc0a87ce5cfff27885a05172a6fc9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "60be78920ba179cb086904ece75ee9ae"
          },
          {
            "type": "html",
            "text": "[[Category Object Orientation]]",
            "id": "ac1bef18b1f5dbecddf649ed3a574d5b"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?BenefitsOfOo c2.com]",
            "id": "dd2f0f66aefcfc6569211cfd9a6f96ee"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1707907409472
    }
  ]
}