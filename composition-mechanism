{
  "title": "Composition Mechanism",
  "story": [
    {
      "type": "reference",
      "id": "959ace7ccfbba8b1",
      "site": "wiki.ralfbarkow.ch",
      "slug": "trait-composition-mechanism",
      "title": "Trait Composition Mechanism",
      "text": "[https://wiki.ralfbarkow.ch/view/properties-of-parallel-distributed-models/view/representation/view/generalization/view/learn/view/slot/view/fact-modeling/view/network/view/code/view/pattern/view/cancel lineup] ⇒ [[Slot]]"
    },
    {
      "type": "paragraph",
      "id": "44c90005818897c3",
      "text": "Recent years saw the development of a composition mechanism called [[Traits]]. Traits are pure units of behavior that can be composed to form classes or other traits. The trait composition mechanism is an alternative to multiple or mixin inheritance in which the composer has full control over the trait composition. "
    },
    {
      "type": "paragraph",
      "id": "19ea5662fb41177e",
      "text": "To evaluate the expressiveness of traits, some hierarchies were refactored, showing [[Code Reuse]]. However, such large refactorings, while valuable, may not exhibit all possible composition problems, since the hierarchies were previously expressed using single inheritance and following certain patterns. "
    },
    {
      "type": "paragraph",
      "id": "cef5e8770986eaac",
      "text": "This paper presents our work on designing and implementing a new trait-based stream library named Nile. It evaluates how far traits enable reuse, what problems can be encountered when building a library using traits from scratch and compares the traits solution to alternative composition mechanisms. Nile’s core allows the definition of compact collection and file streaming libraries as well as the implementation of a backward-compatible new stream library. Nile method size shows a reduction of 40% compared to the Squeak equivalent. The possibility to reuse the same set of traits to implement two distinct libraries is a concrete illustration of trait reuse capability.\n"
    },
    {
      "type": "pagefold",
      "id": "2ea0ec1badbf2539",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "0a00d191ed9635eb",
      "text": "\nCASSOU, Damien, DUCASSE, Stéphane and WUYTS, Roel, 2009. Traits at work: The design of a new trait-based stream library. Computer Languages, Systems & Structures. 1 April 2009. Vol. 35, no. 1, p. 2–20. DOI 10.1016/j.cl.2008.05.004. "
    },
    {
      "type": "paragraph",
      "id": "bddcfa2ba0081f14",
      "text": "Note: We're not so much interested in [[Code Reuse]] as we are in modeling [[Concept]]s."
    },
    {
      "type": "pagefold",
      "id": "afc2da8bdc281db6",
      "text": "~"
    },
    {
      "type": "reference",
      "id": "02fc5bc1fad6b7b8",
      "site": "wiki.ralfbarkow.ch",
      "slug": "generalization",
      "title": "Generalization",
      "text": "The third property results in spontaneous generalization. Knowl­edge about an item is automatically generalized to all other items, to the [[Degree]] that they are similar to that item. As long as the input situ­ations consist of familiar elements, the system can perform reasonably well in new situations."
    },
    {
      "type": "reference",
      "id": "3720cb92653597a4",
      "site": "wiki.ralfbarkow.ch",
      "slug": "prospects-for-scenario-modelling-urban-design-methodologies",
      "title": "Prospects for Scenario-Modelling Urban Design Methodologies",
      "text": "We summarize research demonstrating that variables of urban morphology, taken together, play a significant, possibly very large (and still poorly understood) role in the generation of greenhouse gas (GHG) emissions."
    },
    {
      "type": "reference",
      "id": "c6b2b687f01e9d53",
      "site": "wiki.ralfbarkow.ch",
      "slug": "simulation-type-programming",
      "title": "Simulation-Type Programming",
      "text": "Kay, looking at [[Smalltalk-80]], said, “It’s terrible that it can’t be used by children, since that’s who Smalltalk was intended for. It fell back into data-structure-type programming instead of simulation-type programming.”"
    },
    {
      "type": "paragraph",
      "id": "ea47038d1e577611",
      "text": "⇒ [[Multiple Inheritance]]"
    },
    {
      "type": "paragraph",
      "id": "3263abfcb863ee52",
      "text": "Multiple inheritance has been the focus of a large amount of work and research efforts. Recently, traits proposed a solution in which the composite entity has the control and which can be flattened away, i.e., traits do not affect the runtime semantics [1,2]. Traits are fine-grained units that can be used to compose classes. Like any solution to multiple inheritance, the design of traits is the result of a set of trade-offs. Traits favor simplicity and fine-grained composition. Traits are meant for single inheritance languages. Trait composition conflicts are automatically detected and the composer is empowered to resolve these conflicts explicitly. Traits claim to avoid many of the problems of multiple inheritance and mixin-based approaches that mainly favor linearization where conflicts never arise explicitly and are solved implicitly by ordering."
    },
    {
      "type": "paragraph",
      "id": "21bcb6fe89497a54",
      "text": "⇒ [[Trait Models]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Composition Mechanism",
        "story": []
      },
      "date": 1673882093257
    },
    {
      "item": {
        "type": "factory",
        "id": "959ace7ccfbba8b1"
      },
      "id": "959ace7ccfbba8b1",
      "type": "add",
      "date": 1673882095542
    },
    {
      "type": "edit",
      "id": "959ace7ccfbba8b1",
      "item": {
        "type": "reference",
        "id": "959ace7ccfbba8b1",
        "site": "wiki.ralfbarkow.ch",
        "slug": "trait-composition-mechanism",
        "title": "Trait Composition Mechanism",
        "text": "[https://wiki.ralfbarkow.ch/view/properties-of-parallel-distributed-models/view/representation/view/generalization/view/learn/view/slot/view/fact-modeling/view/network/view/code/view/pattern/view/cancel lineup] ⇒ [[Slot]]"
      },
      "date": 1673882100480
    },
    {
      "item": {
        "type": "factory",
        "id": "44c90005818897c3"
      },
      "id": "44c90005818897c3",
      "type": "add",
      "after": "959ace7ccfbba8b1",
      "date": 1673882110256
    },
    {
      "type": "edit",
      "id": "44c90005818897c3",
      "item": {
        "type": "paragraph",
        "id": "44c90005818897c3",
        "text": "Recent years saw the development of a composition mechanism called traits. Traits are pure units of behavior that can be composed to form classes or other traits. The trait composition mechanism is an alternative to multiple or mixin inheritance in which the composer has full control over the trait composition."
      },
      "date": 1673882112193
    },
    {
      "type": "edit",
      "id": "44c90005818897c3",
      "item": {
        "type": "paragraph",
        "id": "44c90005818897c3",
        "text": "Recent years saw the development of a composition mechanism called [[Traits]]. Traits are pure units of behavior that can be composed to form classes or other traits. The trait composition mechanism is an alternative to multiple or mixin inheritance in which the composer has full control over the trait composition."
      },
      "date": 1673882122528
    },
    {
      "item": {
        "type": "factory",
        "id": "2ea0ec1badbf2539"
      },
      "id": "2ea0ec1badbf2539",
      "type": "add",
      "after": "44c90005818897c3",
      "date": 1673882138250
    },
    {
      "type": "edit",
      "id": "2ea0ec1badbf2539",
      "item": {
        "type": "pagefold",
        "id": "2ea0ec1badbf2539",
        "text": "~"
      },
      "date": 1673882140859
    },
    {
      "item": {
        "type": "factory",
        "id": "0a00d191ed9635eb"
      },
      "id": "0a00d191ed9635eb",
      "type": "add",
      "after": "2ea0ec1badbf2539",
      "date": 1673882142055
    },
    {
      "type": "edit",
      "id": "0a00d191ed9635eb",
      "item": {
        "type": "paragraph",
        "id": "0a00d191ed9635eb",
        "text": "\nCASSOU, Damien, DUCASSE, Stéphane and WUYTS, Roel, 2009. Traits at work: The design of a new trait-based stream library. Computer Languages, Systems & Structures. 1 April 2009. Vol. 35, no. 1, p. 2–20. DOI 10.1016/j.cl.2008.05.004. "
      },
      "date": 1673882149824
    },
    {
      "type": "edit",
      "id": "44c90005818897c3",
      "item": {
        "type": "paragraph",
        "id": "44c90005818897c3",
        "text": "Recent years saw the development of a composition mechanism called traits. Traits are pure units of behavior that can be composed to form classes or other traits. The trait composition mechanism is an alternative to multiple or mixin inheritance in which the composer has full control over the trait composition. To evaluate the expressiveness of traits, some hierarchies were refactored, showing code reuse. However, such large refactorings, while valuable, may not exhibit all possible composition problems, since the hierarchies were previously expressed using single inheritance and following certain patterns. This paper presents our work on designing and implementing a new trait-based stream library named Nile. It evaluates how far traits enable reuse, what problems can be encountered when building a library using traits from scratch and compares the traits solution to alternative composition mechanisms. Nile’s core allows the definition of compact collection and file streaming libraries as well as the implementation of a backward-compatible new stream library. Nile method size shows a reduction of 40% compared to the Squeak equivalent. The possibility to reuse the same set of traits to implement two distinct libraries is a concrete illustration of trait reuse capability.\n"
      },
      "date": 1673882150891
    },
    {
      "type": "edit",
      "id": "44c90005818897c3",
      "item": {
        "type": "paragraph",
        "id": "44c90005818897c3",
        "text": "Recent years saw the development of a composition mechanism called [[Traits]]. Traits are pure units of behavior that can be composed to form classes or other traits. The trait composition mechanism is an alternative to multiple or mixin inheritance in which the composer has full control over the trait composition. To evaluate the expressiveness of traits, some hierarchies were refactored, showing code reuse. However, such large refactorings, while valuable, may not exhibit all possible composition problems, since the hierarchies were previously expressed using single inheritance and following certain patterns. This paper presents our work on designing and implementing a new trait-based stream library named Nile. It evaluates how far traits enable reuse, what problems can be encountered when building a library using traits from scratch and compares the traits solution to alternative composition mechanisms. Nile’s core allows the definition of compact collection and file streaming libraries as well as the implementation of a backward-compatible new stream library. Nile method size shows a reduction of 40% compared to the Squeak equivalent. The possibility to reuse the same set of traits to implement two distinct libraries is a concrete illustration of trait reuse capability.\n"
      },
      "date": 1673882162209
    },
    {
      "type": "edit",
      "id": "44c90005818897c3",
      "item": {
        "type": "paragraph",
        "id": "44c90005818897c3",
        "text": "Recent years saw the development of a composition mechanism called [[Traits]]. Traits are pure units of behavior that can be composed to form classes or other traits. The trait composition mechanism is an alternative to multiple or mixin inheritance in which the composer has full control over the trait composition. "
      },
      "date": 1673882183698
    },
    {
      "type": "add",
      "id": "19ea5662fb41177e",
      "item": {
        "type": "paragraph",
        "id": "19ea5662fb41177e",
        "text": "To evaluate the expressiveness of traits, some hierarchies were refactored, showing code reuse. However, such large refactorings, while valuable, may not exhibit all possible composition problems, since the hierarchies were previously expressed using single inheritance and following certain patterns. This paper presents our work on designing and implementing a new trait-based stream library named Nile. It evaluates how far traits enable reuse, what problems can be encountered when building a library using traits from scratch and compares the traits solution to alternative composition mechanisms. Nile’s core allows the definition of compact collection and file streaming libraries as well as the implementation of a backward-compatible new stream library. Nile method size shows a reduction of 40% compared to the Squeak equivalent. The possibility to reuse the same set of traits to implement two distinct libraries is a concrete illustration of trait reuse capability.\n"
      },
      "after": "44c90005818897c3",
      "date": 1673882185259
    },
    {
      "type": "edit",
      "id": "19ea5662fb41177e",
      "item": {
        "type": "paragraph",
        "id": "19ea5662fb41177e",
        "text": "To evaluate the expressiveness of traits, some hierarchies were refactored, showing code reuse. However, such large refactorings, while valuable, may not exhibit all possible composition problems, since the hierarchies were previously expressed using single inheritance and following certain patterns. "
      },
      "date": 1673882201018
    },
    {
      "type": "add",
      "id": "cef5e8770986eaac",
      "item": {
        "type": "paragraph",
        "id": "cef5e8770986eaac",
        "text": "This paper presents our work on designing and implementing a new trait-based stream library named Nile. It evaluates how far traits enable reuse, what problems can be encountered when building a library using traits from scratch and compares the traits solution to alternative composition mechanisms. Nile’s core allows the definition of compact collection and file streaming libraries as well as the implementation of a backward-compatible new stream library. Nile method size shows a reduction of 40% compared to the Squeak equivalent. The possibility to reuse the same set of traits to implement two distinct libraries is a concrete illustration of trait reuse capability.\n"
      },
      "after": "19ea5662fb41177e",
      "date": 1673882201852
    },
    {
      "type": "edit",
      "id": "19ea5662fb41177e",
      "item": {
        "type": "paragraph",
        "id": "19ea5662fb41177e",
        "text": "To evaluate the expressiveness of traits, some hierarchies were refactored, showing [[Code Reuse]]. However, such large refactorings, while valuable, may not exhibit all possible composition problems, since the hierarchies were previously expressed using single inheritance and following certain patterns. "
      },
      "date": 1673882219947
    },
    {
      "item": {
        "type": "factory",
        "id": "bddcfa2ba0081f14"
      },
      "id": "bddcfa2ba0081f14",
      "type": "add",
      "after": "0a00d191ed9635eb",
      "date": 1673882286048
    },
    {
      "type": "edit",
      "id": "bddcfa2ba0081f14",
      "item": {
        "type": "paragraph",
        "id": "bddcfa2ba0081f14",
        "text": "We are interesset not so much in code reuse but in concept modelling."
      },
      "date": 1673882309241
    },
    {
      "type": "edit",
      "id": "bddcfa2ba0081f14",
      "item": {
        "type": "paragraph",
        "id": "bddcfa2ba0081f14",
        "text": "Note: We're not so much interested in code reuse as we are in modeling concepts."
      },
      "date": 1673882331348
    },
    {
      "type": "edit",
      "id": "bddcfa2ba0081f14",
      "item": {
        "type": "paragraph",
        "id": "bddcfa2ba0081f14",
        "text": "Note: We're not so much interested in [[Code Reuse]] as we are in modeling concepts."
      },
      "date": 1673882425013
    },
    {
      "item": {
        "type": "factory",
        "id": "afc2da8bdc281db6"
      },
      "id": "afc2da8bdc281db6",
      "type": "add",
      "after": "bddcfa2ba0081f14",
      "date": 1673882462510
    },
    {
      "item": {
        "type": "factory",
        "id": "3720cb92653597a4"
      },
      "id": "3720cb92653597a4",
      "type": "add",
      "after": "afc2da8bdc281db6",
      "date": 1673882468738
    },
    {
      "type": "edit",
      "id": "3720cb92653597a4",
      "item": {
        "type": "reference",
        "id": "3720cb92653597a4",
        "site": "wiki.ralfbarkow.ch",
        "slug": "prospects-for-scenario-modelling-urban-design-methodologies",
        "title": "Prospects for Scenario-Modelling Urban Design Methodologies",
        "text": "We summarize research demonstrating that variables of urban morphology, taken together, play a significant, possibly very large (and still poorly understood) role in the generation of greenhouse gas (GHG) emissions."
      },
      "date": 1673882473524
    },
    {
      "type": "edit",
      "id": "afc2da8bdc281db6",
      "item": {
        "type": "pagefold",
        "id": "afc2da8bdc281db6",
        "text": "~"
      },
      "date": 1673882477327
    },
    {
      "type": "edit",
      "id": "bddcfa2ba0081f14",
      "item": {
        "type": "paragraph",
        "id": "bddcfa2ba0081f14",
        "text": "Note: We're not so much interested in [[Code Reuse]] as we are in modeling [[Concept]]s."
      },
      "date": 1673882515751
    },
    {
      "item": {
        "type": "factory",
        "id": "c6b2b687f01e9d53"
      },
      "id": "c6b2b687f01e9d53",
      "type": "add",
      "after": "3720cb92653597a4",
      "date": 1673882578656
    },
    {
      "type": "edit",
      "id": "c6b2b687f01e9d53",
      "item": {
        "type": "reference",
        "id": "c6b2b687f01e9d53",
        "site": "wiki.ralfbarkow.ch",
        "slug": "simulation-type-programming",
        "title": "Simulation-Type Programming",
        "text": "Kay, looking at [[Smalltalk-80]], said, “It’s terrible that it can’t be used by children, since that’s who Smalltalk was intended for. It fell back into data-structure-type programming instead of simulation-type programming.”"
      },
      "date": 1673882599911
    },
    {
      "item": {
        "type": "factory",
        "id": "02fc5bc1fad6b7b8"
      },
      "id": "02fc5bc1fad6b7b8",
      "type": "add",
      "after": "c6b2b687f01e9d53",
      "date": 1673882683489
    },
    {
      "type": "edit",
      "id": "02fc5bc1fad6b7b8",
      "item": {
        "type": "reference",
        "id": "02fc5bc1fad6b7b8",
        "site": "wiki.ralfbarkow.ch",
        "slug": "generalization",
        "title": "Generalization",
        "text": "The third property results in spontaneous generalization. Knowl­edge about an item is automatically generalized to all other items, to the [[Degree]] that they are similar to that item. As long as the input situ­ations consist of familiar elements, the system can perform reasonably well in new situations."
      },
      "date": 1673882768917
    },
    {
      "id": "02fc5bc1fad6b7b8",
      "type": "move",
      "order": [
        "959ace7ccfbba8b1",
        "44c90005818897c3",
        "19ea5662fb41177e",
        "cef5e8770986eaac",
        "2ea0ec1badbf2539",
        "0a00d191ed9635eb",
        "bddcfa2ba0081f14",
        "afc2da8bdc281db6",
        "02fc5bc1fad6b7b8",
        "3720cb92653597a4",
        "c6b2b687f01e9d53"
      ],
      "date": 1673882771740
    },
    {
      "item": {
        "type": "factory",
        "id": "ea47038d1e577611"
      },
      "id": "ea47038d1e577611",
      "type": "add",
      "after": "c6b2b687f01e9d53",
      "date": 1673882840986
    },
    {
      "type": "edit",
      "id": "ea47038d1e577611",
      "item": {
        "type": "paragraph",
        "id": "ea47038d1e577611",
        "text": "⇒ [[Multiple Inheritance]]"
      },
      "date": 1673882852587
    },
    {
      "item": {
        "type": "factory",
        "id": "3263abfcb863ee52"
      },
      "id": "3263abfcb863ee52",
      "type": "add",
      "after": "ea47038d1e577611",
      "date": 1673882864142
    },
    {
      "type": "edit",
      "id": "3263abfcb863ee52",
      "item": {
        "type": "paragraph",
        "id": "3263abfcb863ee52",
        "text": "Multiple inheritance has been the focus of a large amount of work and research efforts. Recently, traits proposed a solution in which the composite entity has the control and which can be flattened away, i.e., traits do not affect the runtime semantics [1,2]. Traits are fine-grained units that can be used to compose classes. Like any solution to multiple inheritance, the design of traits is the result of a set of trade-offs. Traits favor simplicity and fine-grained composition. Traits are meant for single inheritance languages. Trait composition conflicts are automatically detected and the composer is empowered to resolve these conflicts explicitly. Traits claim to avoid many of the problems of multiple inheritance and mixin-based approaches that mainly favor linearization where conflicts never arise explicitly and are solved implicitly by ordering."
      },
      "date": 1673882865763
    },
    {
      "item": {
        "type": "factory",
        "id": "21bcb6fe89497a54"
      },
      "id": "21bcb6fe89497a54",
      "type": "add",
      "after": "3263abfcb863ee52",
      "date": 1673882921875
    },
    {
      "type": "edit",
      "id": "21bcb6fe89497a54",
      "item": {
        "type": "paragraph",
        "id": "21bcb6fe89497a54",
        "text": "⇒ [[Note that there exist different trait models. In the original trait model, Stateless traits [1,2], traits only define methods, but not instance variables. Stateful traits [3] extends this model and lets traits define state. Freezable traits [4] extend stateless traits with a visibility mechanism. In the context of this paper when we use trait we mean Stateless trait. The reader unfamiliar with traits may read Appendix A for a rapid introduction to stateless traits."
      },
      "date": 1673882938058
    },
    {
      "type": "edit",
      "id": "21bcb6fe89497a54",
      "item": {
        "type": "paragraph",
        "id": "21bcb6fe89497a54",
        "text": "⇒ [[Trait Models]]"
      },
      "date": 1673882946410
    },
    {
      "type": "add",
      "id": "de831551336b7759",
      "item": {
        "type": "paragraph",
        "id": "de831551336b7759",
        "text": "Note that there exist different trait models. In the original trait model, Stateless traits [1,2], traits only define methods, but not instance variables. Stateful traits [3] extends this model and lets traits define state. Freezable traits [4] extend stateless traits with a visibility mechanism. In the context of this paper when we use trait we mean Stateless trait. The reader unfamiliar with traits may read Appendix A for a rapid introduction to stateless traits."
      },
      "after": "21bcb6fe89497a54",
      "date": 1673882947937
    },
    {
      "id": "de831551336b7759",
      "type": "remove",
      "date": 1673882955660
    }
  ]
}