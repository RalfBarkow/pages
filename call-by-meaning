{
  "title": "Call by Meaning",
  "story": [
    {
      "type": "markdown",
      "id": "5b2ba6281dbbdde6",
      "text": "[[Konrad Hinsen]] via [https://discord.com/channels/729445214812504107/737255889517543545/971051856287662170 discord] — \nI see your point but disagree: more frequent releases make the problem more visible, but not more serious. There is no way to have a generic algorithm that can decide how tight a version constraint can be. Two pieces of software are either exactly equal, or not exactly equal. There is no \"approximately equal\". There are people thinking about this (example; http://dl.acm.org/citation.cfm?doid=2661136.2661152), but I am not aware of any approach tested in practice.\n"
    },
    {
      "type": "markdown",
      "id": "6c2f0d776b2d81a5",
      "text": "SAMIMI, Hesam, DEATON, Chris, OHSHIMA, Yoshiki, WARTH, Alessandro and MILLSTEIN, Todd, 2014. Call by Meaning. In: Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming & Software. Online. New York, NY, USA: Association for Computing Machinery. 14 October 2014. p. 11–28. [Accessed 4 May 2022]. Onward! 2014. ISBN 978-1-4503-3210-1. DOI 10.1145/2661136.2661152. "
    },
    {
      "type": "paragraph",
      "id": "9767c4a1a67ad3ef",
      "text": "ABSTRACT\n\nSoftware development involves stitching existing components together. These data/service components are usually not well understood, as they are made by others and often obtained from somewhere on the Internet. This makes software development a daunting challenge, requiring programmers to manually discover the resources they need, understand their capabilities, adapt these resources to their needs, and update the system as external components change.\n\nSoftware researchers have long realized the problem why automation seems impossible: the lack of semantic \"understanding\" on the part of the machine about those components. A multitude of solutions have been proposed under the umbrella term Semantic Web (SW), in which semantic markup of the components with concepts from semantic ontologies and the ability to invoke queries over those concepts enables a form of automated discovery and mediation among software services.\n\nOn another front, programming languages rarely provide mechanisms for anchoring objects/data to real-world concepts. Inspired by the aspirations of SW, in this paper we reformulate its visions from the perspective of a programming model, i.e., that components themselves should be able to interact using semantic ontologies, rather than having a separate markup language and composition platform. In the vision, a rich specification language and common sense knowledge base over real-world concepts serves as a lingua franca to describe software components. Components can query the system to automatically (1) discover other components that provide needed functionality/data (2) discover the appropriate API within that component in order to obtain what is intended, and even (3) implicitly interpret the provided data in the desired form independent of the form originally presented by the provider component.\n\nBy demonstrating a successful case of realization of this vision on a microexample, we hope to show how a programming languages (PL) approach to SW can be superior to existing engineered solutions, since the generality and expressiveness in the language can be harnessed, and encourage PL researchers to jump on the SW bandwagon.\n"
    },
    {
      "type": "paragraph",
      "id": "674a8c552c0c28d6",
      "text": "Next: [[Common Sense Reasoning]]"
    },
    {
      "type": "graphviz",
      "id": "e8da670026b6f72b",
      "text": "DOT strict digraph\n  \nrankdir=LR\n\n  node [style=filled fillcolor=lightyellow penwidth=3 color=black fontname=\"Helvetica\"]\n  HERE NODE\n\n    node [style=filled fillcolor=lightblue]\n    WHERE /^Next/\n      LINKS HERE -> NODE\n          node [style=filled fillcolor=white]\n          HERE NODE\n            WHERE /^Next/\n              LINKS HERE -> NODE\n\n    node [style=filled fillcolor=white penwidth=3 color=black]\n    LINKS HERE -> NODE\n       node [style=filled fillcolor=white penwidth=1 color=black]\n       HERE NODE\n         LINKS HERE -> NODE\n\n   node [style=\"filled,rounded,dotted\" fillcolor=white]\n   edge [style=dotted]\n   HERE NODE\n      BACKLINKS NODE -> HERE"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Call by Meaning",
        "story": []
      },
      "date": 1651654230450
    },
    {
      "item": {
        "type": "factory",
        "id": "9767c4a1a67ad3ef"
      },
      "id": "9767c4a1a67ad3ef",
      "type": "add",
      "date": 1651654256731
    },
    {
      "type": "edit",
      "id": "9767c4a1a67ad3ef",
      "item": {
        "type": "paragraph",
        "id": "9767c4a1a67ad3ef",
        "text": "ABSTRACT\n\nSoftware development involves stitching existing components together. These data/service components are usually not well understood, as they are made by others and often obtained from somewhere on the Internet. This makes software development a daunting challenge, requiring programmers to manually discover the resources they need, understand their capabilities, adapt these resources to their needs, and update the system as external components change.\n\nSoftware researchers have long realized the problem why automation seems impossible: the lack of semantic \"understanding\" on the part of the machine about those components. A multitude of solutions have been proposed under the umbrella term Semantic Web (SW), in which semantic markup of the components with concepts from semantic ontologies and the ability to invoke queries over those concepts enables a form of automated discovery and mediation among software services.\n\nOn another front, programming languages rarely provide mechanisms for anchoring objects/data to real-world concepts. Inspired by the aspirations of SW, in this paper we reformulate its visions from the perspective of a programming model, i.e., that components themselves should be able to interact using semantic ontologies, rather than having a separate markup language and composition platform. In the vision, a rich specification language and common sense knowledge base over real-world concepts serves as a lingua franca to describe software components. Components can query the system to automatically (1) discover other components that provide needed functionality/data (2) discover the appropriate API within that component in order to obtain what is intended, and even (3) implicitly interpret the provided data in the desired form independent of the form originally presented by the provider component.\n\nBy demonstrating a successful case of realization of this vision on a microexample, we hope to show how a programming languages (PL) approach to SW can be superior to existing engineered solutions, since the generality and expressiveness in the language can be harnessed, and encourage PL researchers to jump on the SW bandwagon.\n"
      },
      "date": 1651654258360
    },
    {
      "item": {
        "type": "factory",
        "id": "5b2ba6281dbbdde6"
      },
      "id": "5b2ba6281dbbdde6",
      "type": "add",
      "after": "9767c4a1a67ad3ef",
      "date": 1651654321766
    },
    {
      "type": "edit",
      "id": "5b2ba6281dbbdde6",
      "item": {
        "type": "paragraph",
        "id": "5b2ba6281dbbdde6",
        "text": "Konrad Hinsen — gestern um 16:13 Uhr\nI see your point but disagree: more frequent releases make the problem more visible, but not more serious. There is no way to have a generic algorithm that can decide how tight a version constraint can be. Two pieces of software are either exactly equal, or not exactly equal. There is no \"approximately equal\". There are people thinking about this (example; http://dl.acm.org/citation.cfm?doid=2661136.2661152), but I am not aware of any approach tested in practice."
      },
      "date": 1651654323344
    },
    {
      "id": "5b2ba6281dbbdde6",
      "type": "move",
      "order": [
        "5b2ba6281dbbdde6",
        "9767c4a1a67ad3ef"
      ],
      "date": 1651654331044
    },
    {
      "type": "edit",
      "id": "5b2ba6281dbbdde6",
      "item": {
        "type": "paragraph",
        "id": "5b2ba6281dbbdde6",
        "text": "[[Konrad Hinsen]] — gestern um 16:13 Uhr\nI see your point but disagree: more frequent releases make the problem more visible, but not more serious. There is no way to have a generic algorithm that can decide how tight a version constraint can be. Two pieces of software are either exactly equal, or not exactly equal. There is no \"approximately equal\". There are people thinking about this (example; http://dl.acm.org/citation.cfm?doid=2661136.2661152), but I am not aware of any approach tested in practice."
      },
      "date": 1651654343337
    },
    {
      "type": "edit",
      "id": "5b2ba6281dbbdde6",
      "item": {
        "type": "paragraph",
        "id": "5b2ba6281dbbdde6",
        "text": "[[Konrad Hinsen]] via [https://discord.com/channels/729445214812504107/737255889517543545/971051856287662170 discord] — \nI see your point but disagree: more frequent releases make the problem more visible, but not more serious. There is no way to have a generic algorithm that can decide how tight a version constraint can be. Two pieces of software are either exactly equal, or not exactly equal. There is no \"approximately equal\". There are people thinking about this (example; http://dl.acm.org/citation.cfm?doid=2661136.2661152), but I am not aware of any approach tested in practice."
      },
      "date": 1651654367293
    },
    {
      "type": "edit",
      "id": "5b2ba6281dbbdde6",
      "item": {
        "type": "markdown",
        "id": "5b2ba6281dbbdde6",
        "text": "[[Konrad Hinsen]] via [https://discord.com/channels/729445214812504107/737255889517543545/971051856287662170 discord] — \nI see your point but disagree: more frequent releases make the problem more visible, but not more serious. There is no way to have a generic algorithm that can decide how tight a version constraint can be. Two pieces of software are either exactly equal, or not exactly equal. There is no \"approximately equal\". There are people thinking about this (example; http://dl.acm.org/citation.cfm?doid=2661136.2661152), but I am not aware of any approach tested in practice."
      },
      "date": 1651654388310
    },
    {
      "type": "edit",
      "id": "5b2ba6281dbbdde6",
      "item": {
        "type": "markdown",
        "id": "5b2ba6281dbbdde6",
        "text": "[[Konrad Hinsen]] via [https://discord.com/channels/729445214812504107/737255889517543545/971051856287662170 discord] — \nI see your point but disagree: more frequent releases make the problem more visible, but not more serious. There is no way to have a generic algorithm that can decide how tight a version constraint can be. Two pieces of software are either exactly equal, or not exactly equal. There is no \"approximately equal\". There are people thinking about this (example; http://dl.acm.org/citation.cfm?doid=2661136.2661152), but I am not aware of any approach tested in practice.\n"
      },
      "date": 1651654411197
    },
    {
      "type": "add",
      "id": "6c2f0d776b2d81a5",
      "item": {
        "type": "markdown",
        "id": "6c2f0d776b2d81a5",
        "text": "\nSAMIMI, Hesam, DEATON, Chris, OHSHIMA, Yoshiki, WARTH, Alessandro and MILLSTEIN, Todd, 2014. Call by Meaning. In: Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming & Software. Online. New York, NY, USA: Association for Computing Machinery. 14 October 2014. p. 11–28. [Accessed 4 May 2022]. Onward! 2014. ISBN 978-1-4503-3210-1. DOI 10.1145/2661136.2661152. Software development involves stitching existing components together. These data/service components are usually not well understood, as they are made by others and often obtained from somewhere on the Internet. This makes software development a daunting challenge, requiring programmers to manually discover the resources they need, understand their capabilities, adapt these resources to their needs, and update the system as external components change. Software researchers have long realized the problem why automation seems impossible: the lack of semantic “understanding” on the part of the machine about those components. A multitude of solutions have been proposed under the umbrella term Semantic Web (SW), in which semantic markup of the components with concepts from semantic ontologies and the ability to invoke queries over those concepts enables a form of automated discovery and mediation among software services. On another front, programming languages rarely provide mechanisms for anchoring objects/data to real-world concepts. Inspired by the aspirations of SW, in this paper we reformulate its visions from the perspective of a programming model, i.e., that components themselves should be able to interact using semantic ontologies, rather than having a separate markup language and composition platform. In the vision, a rich specification language and common sense knowledge base over real-world concepts serves as a lingua franca to describe software components. Components can query the system to automatically (1) discover other components that provide needed functionality/data (2) discover the appropriate API within that component in order to obtain what is intended, and even (3) implicitly interpret the provided data in the desired form independent of the form originally presented by the provider component. By demonstrating a successful case of realization of this vision on a microexample, we hope to show how a programming languages (PL) approach to SW can be superior to existing engineered solutions, since the generality and expressiveness in the language can be harnessed, and encourage PL researchers to jump on the SW bandwagon.\n"
      },
      "after": "5b2ba6281dbbdde6",
      "date": 1651654412026
    },
    {
      "type": "edit",
      "id": "6c2f0d776b2d81a5",
      "item": {
        "type": "markdown",
        "id": "6c2f0d776b2d81a5",
        "text": "SAMIMI, Hesam, DEATON, Chris, OHSHIMA, Yoshiki, WARTH, Alessandro and MILLSTEIN, Todd, 2014. Call by Meaning. In: Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming & Software. Online. New York, NY, USA: Association for Computing Machinery. 14 October 2014. p. 11–28. [Accessed 4 May 2022]. Onward! 2014. ISBN 978-1-4503-3210-1. DOI 10.1145/2661136.2661152. "
      },
      "date": 1651654431399
    },
    {
      "item": {
        "type": "factory",
        "id": "674a8c552c0c28d6"
      },
      "id": "674a8c552c0c28d6",
      "type": "add",
      "after": "9767c4a1a67ad3ef",
      "date": 1651654531948
    },
    {
      "type": "edit",
      "id": "674a8c552c0c28d6",
      "item": {
        "type": "paragraph",
        "id": "674a8c552c0c28d6",
        "text": "Next: [[Common Sense Reasoning]]"
      },
      "date": 1651654539989
    },
    {
      "item": {
        "type": "factory",
        "id": "e8da670026b6f72b"
      },
      "id": "e8da670026b6f72b",
      "type": "add",
      "after": "674a8c552c0c28d6",
      "date": 1651654563920
    },
    {
      "type": "edit",
      "id": "e8da670026b6f72b",
      "item": {
        "type": "graphviz",
        "id": "e8da670026b6f72b",
        "text": "DOT strict digraph\n  \nrankdir=LR\n\n  node [style=filled fillcolor=lightyellow penwidth=3 color=black fontname=\"Helvetica\"]\n  HERE NODE\n\n    node [style=filled fillcolor=lightblue]\n    WHERE /^Next/\n      LINKS HERE -> NODE\n          node [style=filled fillcolor=white]\n          HERE NODE\n            WHERE /^Next/\n              LINKS HERE -> NODE\n\n    node [style=filled fillcolor=white penwidth=3 color=black]\n    LINKS HERE -> NODE\n       node [style=filled fillcolor=white penwidth=1 color=black]\n       HERE NODE\n         LINKS HERE -> NODE\n\n   node [style=\"filled,rounded,dotted\" fillcolor=white]\n   edge [style=dotted]\n   HERE NODE\n      BACKLINKS NODE -> HERE"
      },
      "date": 1651654566960
    }
  ]
}