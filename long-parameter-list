{
  "title": "Long Parameter List",
  "story": [
    {
      "type": "html",
      "text": "Long parameter lists should be considered a [[Good Thing]] (TM). They are essentials in building powerful libraries and reusable frameworks. And we have a long list of empirical evidence that [[Long Parameter List]]s are essential and unavoidable",
      "id": "9857de540c7fe848829df7cbd45524ac"
    },
    {
      "type": "html",
      "text": "\nTake any Unix command at random, even the simplest one, and run  command --help or man command. For example: <i>cp --help</i>. On linux it shows two screens full of options:",
      "id": "6d606fd02a180887682c0237cfaf9403"
    },
    {
      "type": "html",
      "text": "Usage:<br>cp [OPTION]... SOURCE DEST",
      "id": "14d13308fd070376072552ab14e47ce9"
    },
    {
      "type": "html",
      "text": "or:<br>cp [OPTION]... SOURCE... DIRECTORY",
      "id": "4505230af8b084db13120ab6f3cfb3cf"
    },
    {
      "type": "html",
      "text": "or:<br>cp [OPTION]... --target-directory=DIRECTORY SOURCE...",
      "id": "7fe007ebed499625084617bc6328cfa5"
    },
    {
      "type": "code",
      "text": " Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.",
      "id": "272a9dd0733444762328ef0049085908"
    },
    {
      "type": "code",
      "text": "  -a, --archive                same as -dpR\n      --backup[=CONTROL]       make a backup of each existing destination file\n  -b                           like --backup but does not accept an argument\n  -d, --no-dereference         never follow symbolic links\n  -f, --force                  if an existing destination file cannot be\n                                   opened, remove it and try again\n  -i, --interactive            prompt before overwrite\n  -H                           follow command-line symbolic links\n  -l, --link                   link files instead of copying\n  -L, --dereference            always follow symbolic links\n  -p, --preserve               preserve file attributes if possible\n      --parents                append source path to DIRECTORY\n  -P                           same as `--parents' for now; soon to change to\n                                 `--no-dereference' to conform to POSIX\n  -r                           copy recursively, non-directories as files\n                                 WARNING: use -R instead when you might copy\n                                 special files like FIFOs or /dev/zero\n      --remove-destination     remove each existing destination file before\n                                 attempting to open it (contrast with --force)\n      --sparse=WHEN            control creation of sparse files\n  -R, --recursive              copy directories recursively\n      --strip-trailing-slashes remove any trailing slashes from each SOURCE\n                                 argument\n  -s, --symbolic-link          make symbolic links instead of copying\n  -S, --suffix=SUFFIX          override the usual backup suffix\n      --target-directory=DIRECTORY  move all SOURCE arguments into DIRECTORY\n  -u, --update                 copy only when the SOURCE file is newer\n                                 than the destination file or when the\n                                 destination file is missing\n  -v, --verbose                explain what is being done\n  -x, --one-file-system        stay on this file system\n      --help                   display this help and exit\n      --version                output version information and exit",
      "id": "346744d1d20081fdeb191518e5e7589a"
    },
    {
      "type": "code",
      "text": " By default, sparse SOURCE files are detected by a crude heuristic and the\n corresponding DEST file is made sparse as well.  That is the behavior\n selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n file whenever the SOURCE file contains a long enough sequence of zero bytes.\n Use --sparse=never to inhibit creation of sparse files.",
      "id": "00176c8810d23bfad2404fc7d24c3a1f"
    },
    {
      "type": "html",
      "text": "\nVery powerful, flexible, and strictly necessary.",
      "id": "c8eab45d907c3735bf3272e523a5f455"
    },
    {
      "type": "html",
      "text": "In OO frameworks, take for example the [[ACE]] C++ framework from [[Doug Schmidt]]. You'll see many constructors in there that have more than six parameters. Or take the [[Smart Pointer]] class from [[Modern Cee Plus Plus Design]]. It has four templatized arguments. Basically for a smart pointer which is one of the smallest interfaces you can have in C++.",
      "id": "81a6f0c9320cbe42ba7599cc0b31e062"
    },
    {
      "type": "html",
      "text": "\nThat is so because the more abstract, the more usable a piece of code is, the more likely it is that it will need to be adapted to various local situations. In order to factor out commonalities, but still allow it to be used in exceptional cases, you create a [[Long Parameter List]] that allows the caller to adapt the abstraction to its local needs.",
      "id": "c74064b548eef7311c43523d8ce4c4e8"
    },
    {
      "type": "html",
      "text": "\nWhen people complain that this puts too much of a burden on the caller, it shows that people haven't programmed too much in advanced languages like [[Visual Basic]], [[Modula Three]], Perl or Unix shells. Basically that's a non-issue: you combine parameter passing by name and provide sensible default values for most of them, so that client code that doesn't need fine tuning doesn't need to suffer the penalty either. Or clients that need fine tuning in one aspect but not all the aspects can set only those parameters that are important for them.",
      "id": "1d5e6a8314d0f4b6d450a7bda08ab10d"
    },
    {
      "type": "html",
      "text": "\nFor example:",
      "id": "2a51ee7f45d8802f27906428526bd848"
    },
    {
      "type": "code",
      "text": "    cp source target\n    cp --recursive source target\n    cp --recursive --dereference --one-file-system source target",
      "id": "ee84d9ec8365b10c10bf637e5916eebb"
    },
    {
      "type": "html",
      "text": "\nIn a statically typed language the last one would look like:",
      "id": "2aa750503a858fe856daf7451f0d538c"
    },
    {
      "type": "code",
      "text": "   copy ( sourcedir='source', targetdir='target', recursive=true, dereference=true, stayInOneFS=true);",
      "id": "66e4ef5f951a39b206aec42adfe71460"
    },
    {
      "type": "html",
      "text": "\nNow I know that [[Long Parameter List]] hurts in Java, [[Cee Plus Plus]] (less than in Java) and the likes. But that is a language design deficiency, and can be solved (albeit with a bit more effort) by doing what I call [[Emulate Keyword And Default Parameters]]:",
      "id": "e38bbf737c254316abf585f351b91752"
    },
    {
      "type": "code",
      "text": "    new CopyOperation(source,target)\n          .recursive(true)\n          .dereference(true)\n          .stayInOneFs(true)\n          .execute();",
      "id": "76a8518a36cd6da9560ea91d95ba1b66"
    },
    {
      "type": "html",
      "text": "\nIt almost looks as good as in [[Visual Basic]], except it goes against the [[Grain Of The Language]], but then that language doesn't have a lot of grain, anyways.",
      "id": "b4210bdcd9ce6757f56390d50abfb8cc"
    },
    {
      "type": "html",
      "text": "-- [[Costin Cozianu]]",
      "id": "fcc497708bc078b212915c89a1cc35e5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "857ee3b5e37d702e98e80817a5214e9f"
    },
    {
      "type": "html",
      "text": "\nOne of the [[Code Smell]]s described in [[Refactoring Improving The Design Of Existing Code]]. A method that has too many parameters is asking to be refactored.",
      "id": "b2b460d0e64be817605b8838bfd75731"
    },
    {
      "type": "html",
      "text": "\nOne reason is that a [[Long Parameter List]] increases the likelihood that two or more parameters will be of the same type/class, which may lead to coding of invalid calls.",
      "id": "be6dca298cd1813cec0fc4b757175458"
    },
    {
      "type": "html",
      "text": "\nSee also: [[Keyword Parameter Passing]]",
      "id": "e8844669cbbb94d56a0f7b87208e3115"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "857ee3b5e37d702e98e80817a5214e9f"
    },
    {
      "type": "html",
      "text": "\nThis smell is quite unpleasant.  -- [[Been There Done That]]",
      "id": "452b8e0d618d3d17f68252bd73a27cb4"
    },
    {
      "type": "html",
      "text": " All you can read from the method's signature is \"this is complicated\".",
      "id": "3631a874d66450daf95697881a92e982"
    },
    {
      "type": "html",
      "text": " It's infectious too.  You're probably calling other methods from this one, and they need several of the parameters too.",
      "id": "b6717f5142e5e7728bfe5d57c0be79cc"
    },
    {
      "type": "html",
      "text": " It's worse when you have to add another parameter.  You're going to pile it into the existing method and go round editing all calls to this, or you're going to copy the method under the new signature and make things even more complicated.",
      "id": "4f46a2a51df7abb62472a28515908a2e"
    },
    {
      "type": "html",
      "text": " Sometimes you need to pass \"null\" or \"undef\" into some of the parameters, because they aren't relevant in the mode you intend the method call.",
      "id": "69c6460f35813949b791000115c63dcf"
    },
    {
      "type": "html",
      "text": "\nFixing it will depend on how the parameters can be clustered together, but it's quite likely that you can separate them into two or three logical groups.  Make a class that represents each group, or at least a struct.",
      "id": "300695e577cc6627a30548fa5a7ee80c"
    },
    {
      "type": "html",
      "text": " [[Big Bang Refactoring]] to tear everything apart and put it back together the new way.  You will [[Fear No Code]] if you have the [[Unit Test]]s.",
      "id": "1b7aadfd70b0cf7c3a18155bdd41ff72"
    },
    {
      "type": "html",
      "text": " Doing it more gradually is less fun.",
      "id": "581bfe7b7ee4e56951d61e943b8edcf0"
    },
    {
      "type": "html",
      "text": " Make yet another new method, which takes the new objects and calls the old methods.",
      "id": "3bb0191ce784002c958102fba40a3154"
    },
    {
      "type": "html",
      "text": " You now have backwards compatibility, and therefore breathing space.",
      "id": "c1fcee68ae6fb13a1b4acb7dedc2376b"
    },
    {
      "type": "html",
      "text": " Go round deprecating or changing calls until they're all gone.",
      "id": "887f756500be62f2746e43acc47130fd"
    },
    {
      "type": "html",
      "text": "\nLong parameter lists look like this:\n[http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/windowing/windows/windowreference/windowfunctions/createwindow.asp msdn.microsoft.com]",
      "id": "0199f3c3478465ed37ccc2d6ca360621"
    },
    {
      "type": "html",
      "text": "\nAt least the parameter types in this sample have comprehensible and easily pronounced names like \"LPCTSTR\".",
      "id": "364d16bc1374f3cb26812192ceffed36"
    },
    {
      "type": "html",
      "text": "\nOpinions on LPLs differ, obviously, but sane people agree that they are Pure Evil(tm). ",
      "id": "adf04e2666b1ee0a444e3844fdb933ba"
    },
    {
      "type": "html",
      "text": " It's actually those who do not know what they're talking about.",
      "id": "223a4d01ebfd5f18b5eb29b558b0963a"
    },
    {
      "type": "html",
      "text": "\nNaming parameters in a call only solves one problem with LPLs, namely, that the function call would become unreadable. In combination with [[Default Value]]s for parameters it also solves a second problem, namely, that the caller has to specify every parameter even if sensible defaults would do. Most fundamental problems with LPLs cannot be cured this way, though:",
      "id": "94eb22f93be8a87777884580f115a583"
    },
    {
      "type": "html",
      "text": " A function that just <i>delegates</i> a call has to accept and pass on all parameters explicitely:",
      "id": "9431820cd2e32ff2ee8f882ffb883331"
    },
    {
      "type": "code",
      "text": " void Master::doSomething(int a, int b, Foo foo, Bar bar, Moo moo, Meow meow) {\n   slave.doSomething(a, b, foo, bar, moo, meow);\n }",
      "id": "6506ff4c2d423321542365cef1d4c0c8"
    },
    {
      "type": "html",
      "text": " This also means that a delegating function will break every time the signature is changed.",
      "id": "0a143283c6f3aa02bceba6d9d6e8c0d6"
    },
    {
      "type": "html",
      "text": " When [[Runtime Polymorphism]] or [[Compiletime Polymorphism]] is used, a method needs to know about and accept all parameters explicitely even if it uses only some.",
      "id": "aad70ab0f53fe3f08411167dae549851"
    },
    {
      "type": "html",
      "text": " It will also break every time the signature is changed.",
      "id": "8bfdd2c74910d02c9133d6336a266b9b"
    },
    {
      "type": "html",
      "text": "\nWhile breakage can occur when shorter function signatures are used, the problem tends to be most rampant the longer signatures get. This is because longer signatures are often used when [[Signature Entropy]] is high. All of the above problems can be solved nicely using [[Parameter Object]]s. Their usage typically does not guarantee [[Binary Compatibility]], but it does help a lot in maintaining [[Source Compatibility]].",
      "id": "6ea03d66bd6da6e57d940e030979b21a"
    },
    {
      "type": "html",
      "text": "\nThis piece of immature wise-cracking was brought to you by [[Arne Vogel]].",
      "id": "b41b5cacfcdaf5da61b9b52b7151843c"
    },
    {
      "type": "html",
      "text": "<i>I can see a lot of handwaving in the above. Incidentally the piece of code that you refer to has kept [[Binary Compatibility]] for over a decade now, so it is a rather spectacular example of how a well designed API for a rather complex domain can make use of [[Long Parameter List]] and provide an impressive array of power and functionality while keeping it stable for over a decade. Try to find a contemporary Linux distro out there that runs binaries from a decade ago, and good luck. Or how about if you find a device driver for Linux written in 2000 that runs on current kernel. Folks can bitch all they want about Windows, but if you look objectively it is an impressive engineering achievement.</i>",
      "id": "727cdf759207964ed5eb341a2fc1b01e"
    },
    {
      "type": "html",
      "text": "<i> [[Parameter Object]]s don't solve anything, they just move complexity some place else, while adding unnecessary entities to the system. You can group stuff that belongs together in parameter object, but not all parameters in a [[Long Parameter List]] can be sensibly crammed together in parameter objects. If you want to make your case you can show us how you'd design a better public interface for the </i>cp<i> command in Unix, or a better interface for the Create<b></b>Window function under windows, and then we'll see. --[[Costin Cozianu]]</i>",
      "id": "4a77a8dfb1eef91dd9970bf374b08db3"
    },
    {
      "type": "html",
      "text": "\nHmmm...\nIn [[Create Window]],",
      "id": "f1ced3365f788078dce1bcc32906f099"
    },
    {
      "type": "code",
      "text": "    int x,\n    int y,\n    int nWidth,\n    int nHeight,",
      "id": "7debe8a8f16112e70d22d5d47c10ddea"
    },
    {
      "type": "html",
      "text": "looks like a \"Rectangle\" to me.",
      "id": "a067e6898c975f4fdc0f6dac830eab47"
    },
    {
      "type": "html",
      "text": "<i>Ok, so now I as a programmer I'd have to replace</i>",
      "id": "cbdcb67da6575c72ce1d74792ee4fb30"
    },
    {
      "type": "code",
      "text": "  CreateWindow ( ..., 100,100, 300, 200, ...) ",
      "id": "a6828e55d5ee6a69fb73583fe4ef11a8"
    },
    {
      "type": "html",
      "text": "<i>with</i>",
      "id": "5ea6b59022bedf33970e5e5756a12e76"
    },
    {
      "type": "code",
      "text": "  struct Rect r;\n  r.x= 100;\n  r.y= 100;\n  r.nWidth= 300;\n  r.nHeight= 400;\n  CreateWindow( ..., &r, ...);",
      "id": "f372c2793e6e121b8fea9b8c68446828"
    },
    {
      "type": "html",
      "text": "<i>I don't know if I'm so happy with the later.It's true that the Rectangle case can go either way. If you already had a rectangle in the calling context, you can pass it more easily. Rectangles can also be subject to geometrical transformations as one object, far easier than 4 separate variables. On the other hand, if you had 4 separate variables or constants like the above, or if you cared about performance, say you wanted to draw tons of rectangles in a game, than the unfolded variables may be arguably better. Some frameworks choose to provide all options in one overloaded function where the language supports that, while Microsoft SDK goes consistently with the unfolded four variables also in part because the language is C and because folks who need the folded version can easily work around the unfolded design, while the other way around does not work. </i>",
      "id": "c7f12fdd714fbaa2769a66a7fc427caa"
    },
    {
      "type": "html",
      "text": "<i>It's not clear cut, but even with the folded rectangle, [[Create Window]] would still have 8 parameters while [[Create Window Ex]] would have 9. </i>",
      "id": "6bb71898bba1df1ebadd0b542fa810be"
    },
    {
      "type": "html",
      "text": "\nMicrosoft APIs are rarely that consistent (the Win32 API was formed by accretion more than by design). [??? -- rather dubious claim]",
      "id": "ba6145ea388d02c56b0d7485078dfa46"
    },
    {
      "type": "html",
      "text": "\nFor every function like [[Create Window]] that has a long hairy parameter list, I can think of another function that takes a single (hairy) struct.  Sometimes this is because the call ends up going through the narrow [[Send Message]] pipe where you are only allowed a couple of parameters.",
      "id": "8fdabd0072639c3f61f371f105e6d292"
    },
    {
      "type": "html",
      "text": "\nAlso, if using [[Cee Plus Plus]], you could choose to create the rectangle structure automatically using a convenience constructor if that is more concise:",
      "id": "69993724e147d4b71b92f59780a68a36"
    },
    {
      "type": "code",
      "text": " CreateWindow( ..., CRect(100,100,300,400), ...);",
      "id": "f15951bcc7dc2faf5eeea4329402efb1"
    },
    {
      "type": "html",
      "text": "<i>So what would the inner CRect(100,100,300,400) accomplish ? I am affraid that not much.</i>",
      "id": "3f103114ec6ec02dfb20ff5a9979c789"
    },
    {
      "type": "html",
      "text": "[It tells the compiler, as well as future maintainers, what those 4 numbers sandwiched in there stand for.]",
      "id": "4b991ee89a4fd39e6f49c6cd0b3c64f9"
    },
    {
      "type": "html",
      "text": " It tells the compiler but the compiler isn't happy to hear that. As for the proverbial maintainer, he either has to know the [[Create Window]] signature, or the [[Create Window]] and CRect signature. But anyways, that is small potatoes we are talking about. Even with the 4 sandwiched inside CRect, the function still has 8 parameters.",
      "id": "a232c0645660168c0d648e7cac794a2a"
    },
    {
      "type": "html",
      "text": "<i>Replacing a [[Long Parameter List]] with an equally complex [[Parameter Object]] is something I would definitely recommend against, unless it is part of [[Emulate Keyword And Default Parameters]], in which case we're still talking in essence of a [[Long Parameters List]] but with a workaround to language limitations. One needs to decouple the technical details related to [[Program Intoa Language]], from what is really happening. Even with parameter objects, we're still talking about one logical operation (like creating a window) that depends on a long list of variables, because it needs to be adapted to a wide variety of contexts.</i>",
      "id": "9cb2527fdae1cfe0fea9094f94b5ac69"
    },
    {
      "type": "html",
      "text": "<i>But with keyword and default parameters (either for real or emulated), I contend that [[Long Parameter List]] are often times needed to create powerful and reusable abstractions. --[[Costin Cozianu]]</i>",
      "id": "20ddf782147ca62157251accc268ac85"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "857ee3b5e37d702e98e80817a5214e9f"
    },
    {
      "type": "html",
      "text": "Maybe this \"window\" thing, and GUI's in general, are better served with a markup language akin to HTML. Markup seems to do \"mass attributes\" better than most existing imperative languages. -t",
      "id": "49a5ffb1fe8d852dbdd7f8ca65597488"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "857ee3b5e37d702e98e80817a5214e9f"
    },
    {
      "type": "html",
      "text": "See also [[Too Many Parameters]], [[Too Much Gui Code]]",
      "id": "528f393d0d684d602fb39695640d1658"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?LongParameterList c2.com]",
      "id": "5765593f45e03ce0556dfe72441f894e"
    }
  ],
  "journal": [
    {
      "date": 1392937940000,
      "id": "45dd8aa9362be539151c74a4c4ece058",
      "type": "create",
      "item": {
        "title": "Long Parameter List",
        "story": [
          {
            "type": "html",
            "text": "Long parameter lists should be considered a [[Good Thing]] (TM). They are essentials in building powerful libraries and reusable frameworks. And we have a long list of empirical evidence that [[Long Parameter List]]s are essential and unavoidable",
            "id": "9857de540c7fe848829df7cbd45524ac"
          },
          {
            "type": "html",
            "text": "\nTake any Unix command at random, even the simplest one, and run  command --help or man command. For example: <i>cp --help</i>. On linux it shows two screens full of options:",
            "id": "6d606fd02a180887682c0237cfaf9403"
          },
          {
            "type": "html",
            "text": "Usage:<br>cp [OPTION]... SOURCE DEST",
            "id": "14d13308fd070376072552ab14e47ce9"
          },
          {
            "type": "html",
            "text": "or:<br>cp [OPTION]... SOURCE... DIRECTORY",
            "id": "4505230af8b084db13120ab6f3cfb3cf"
          },
          {
            "type": "html",
            "text": "or:<br>cp [OPTION]... --target-directory=DIRECTORY SOURCE...",
            "id": "7fe007ebed499625084617bc6328cfa5"
          },
          {
            "type": "code",
            "text": " Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.",
            "id": "272a9dd0733444762328ef0049085908"
          },
          {
            "type": "code",
            "text": "  -a, --archive                same as -dpR\n      --backup[=CONTROL]       make a backup of each existing destination file\n  -b                           like --backup but does not accept an argument\n  -d, --no-dereference         never follow symbolic links\n  -f, --force                  if an existing destination file cannot be\n                                   opened, remove it and try again\n  -i, --interactive            prompt before overwrite\n  -H                           follow command-line symbolic links\n  -l, --link                   link files instead of copying\n  -L, --dereference            always follow symbolic links\n  -p, --preserve               preserve file attributes if possible\n      --parents                append source path to DIRECTORY\n  -P                           same as `--parents' for now; soon to change to\n                                 `--no-dereference' to conform to POSIX\n  -r                           copy recursively, non-directories as files\n                                 WARNING: use -R instead when you might copy\n                                 special files like FIFOs or /dev/zero\n      --remove-destination     remove each existing destination file before\n                                 attempting to open it (contrast with --force)\n      --sparse=WHEN            control creation of sparse files\n  -R, --recursive              copy directories recursively\n      --strip-trailing-slashes remove any trailing slashes from each SOURCE\n                                 argument\n  -s, --symbolic-link          make symbolic links instead of copying\n  -S, --suffix=SUFFIX          override the usual backup suffix\n      --target-directory=DIRECTORY  move all SOURCE arguments into DIRECTORY\n  -u, --update                 copy only when the SOURCE file is newer\n                                 than the destination file or when the\n                                 destination file is missing\n  -v, --verbose                explain what is being done\n  -x, --one-file-system        stay on this file system\n      --help                   display this help and exit\n      --version                output version information and exit",
            "id": "346744d1d20081fdeb191518e5e7589a"
          },
          {
            "type": "code",
            "text": " By default, sparse SOURCE files are detected by a crude heuristic and the\n corresponding DEST file is made sparse as well.  That is the behavior\n selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n file whenever the SOURCE file contains a long enough sequence of zero bytes.\n Use --sparse=never to inhibit creation of sparse files.",
            "id": "00176c8810d23bfad2404fc7d24c3a1f"
          },
          {
            "type": "html",
            "text": "\nVery powerful, flexible, and strictly necessary.",
            "id": "c8eab45d907c3735bf3272e523a5f455"
          },
          {
            "type": "html",
            "text": "\nIn OO frameworks, take for example the ACE C++ framework from [[Doug Schmidt]]. You'll see many constructors in there that have more than six parameters. Or take the [[Smart Pointer]] class from [[Modern Cee Plus Plus Design]]. It has four templatized arguments. Basically for a smart pointer which is one of the smallest interfaces you can have in C++.",
            "id": "81a6f0c9320cbe42ba7599cc0b31e062"
          },
          {
            "type": "html",
            "text": "\nThat is so because the more abstract, the more usable a piece of code is, the more likely it is that it will need to be adapted to various local situations. In order to factor out commonalities, but still allow it to be used in exceptional cases, you create a [[Long Parameter List]] that allows the caller to adapt the abstraction to its local needs.",
            "id": "c74064b548eef7311c43523d8ce4c4e8"
          },
          {
            "type": "html",
            "text": "\nWhen people complain that this puts too much of a burden on the caller, it shows that people haven't programmed too much in advanced languages like [[Visual Basic]], [[Modula Three]], Perl or Unix shells. Basically that's a non-issue: you combine parameter passing by name and provide sensible default values for most of them, so that client code that doesn't need fine tuning doesn't need to suffer the penalty either. Or clients that need fine tuning in one aspect but not all the aspects can set only those parameters that are important for them.",
            "id": "1d5e6a8314d0f4b6d450a7bda08ab10d"
          },
          {
            "type": "html",
            "text": "\nFor example:",
            "id": "2a51ee7f45d8802f27906428526bd848"
          },
          {
            "type": "code",
            "text": "    cp source target\n    cp --recursive source target\n    cp --recursive --dereference --one-file-system source target",
            "id": "ee84d9ec8365b10c10bf637e5916eebb"
          },
          {
            "type": "html",
            "text": "\nIn a statically typed language the last one would look like:",
            "id": "2aa750503a858fe856daf7451f0d538c"
          },
          {
            "type": "code",
            "text": "   copy ( sourcedir='source', targetdir='target', recursive=true, dereference=true, stayInOneFS=true);",
            "id": "66e4ef5f951a39b206aec42adfe71460"
          },
          {
            "type": "html",
            "text": "\nNow I know that [[Long Parameter List]] hurts in Java, [[Cee Plus Plus]] (less than in Java) and the likes. But that is a language design deficiency, and can be solved (albeit with a bit more effort) by doing what I call [[Emulate Keyword And Default Parameters]]:",
            "id": "e38bbf737c254316abf585f351b91752"
          },
          {
            "type": "code",
            "text": "    new CopyOperation(source,target)\n          .recursive(true)\n          .dereference(true)\n          .stayInOneFs(true)\n          .execute();",
            "id": "76a8518a36cd6da9560ea91d95ba1b66"
          },
          {
            "type": "html",
            "text": "\nIt almost looks as good as in [[Visual Basic]], except it goes against the [[Grain Of The Language]], but then that language doesn't have a lot of grain, anyways.",
            "id": "b4210bdcd9ce6757f56390d50abfb8cc"
          },
          {
            "type": "html",
            "text": "-- [[Costin Cozianu]]",
            "id": "fcc497708bc078b212915c89a1cc35e5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "857ee3b5e37d702e98e80817a5214e9f"
          },
          {
            "type": "html",
            "text": "\nOne of the [[Code Smell]]s described in [[Refactoring Improving The Design Of Existing Code]]. A method that has too many parameters is asking to be refactored.",
            "id": "b2b460d0e64be817605b8838bfd75731"
          },
          {
            "type": "html",
            "text": "\nOne reason is that a [[Long Parameter List]] increases the likelihood that two or more parameters will be of the same type/class, which may lead to coding of invalid calls.",
            "id": "be6dca298cd1813cec0fc4b757175458"
          },
          {
            "type": "html",
            "text": "\nSee also: [[Keyword Parameter Passing]]",
            "id": "e8844669cbbb94d56a0f7b87208e3115"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "857ee3b5e37d702e98e80817a5214e9f"
          },
          {
            "type": "html",
            "text": "\nThis smell is quite unpleasant.  -- [[Been There Done That]]",
            "id": "452b8e0d618d3d17f68252bd73a27cb4"
          },
          {
            "type": "html",
            "text": " All you can read from the method's signature is \"this is complicated\".",
            "id": "3631a874d66450daf95697881a92e982"
          },
          {
            "type": "html",
            "text": " It's infectious too.  You're probably calling other methods from this one, and they need several of the parameters too.",
            "id": "b6717f5142e5e7728bfe5d57c0be79cc"
          },
          {
            "type": "html",
            "text": " It's worse when you have to add another parameter.  You're going to pile it into the existing method and go round editing all calls to this, or you're going to copy the method under the new signature and make things even more complicated.",
            "id": "4f46a2a51df7abb62472a28515908a2e"
          },
          {
            "type": "html",
            "text": " Sometimes you need to pass \"null\" or \"undef\" into some of the parameters, because they aren't relevant in the mode you intend the method call.",
            "id": "69c6460f35813949b791000115c63dcf"
          },
          {
            "type": "html",
            "text": "\nFixing it will depend on how the parameters can be clustered together, but it's quite likely that you can separate them into two or three logical groups.  Make a class that represents each group, or at least a struct.",
            "id": "300695e577cc6627a30548fa5a7ee80c"
          },
          {
            "type": "html",
            "text": " [[Big Bang Refactoring]] to tear everything apart and put it back together the new way.  You will [[Fear No Code]] if you have the [[Unit Test]]s.",
            "id": "1b7aadfd70b0cf7c3a18155bdd41ff72"
          },
          {
            "type": "html",
            "text": " Doing it more gradually is less fun.",
            "id": "581bfe7b7ee4e56951d61e943b8edcf0"
          },
          {
            "type": "html",
            "text": " Make yet another new method, which takes the new objects and calls the old methods.",
            "id": "3bb0191ce784002c958102fba40a3154"
          },
          {
            "type": "html",
            "text": " You now have backwards compatibility, and therefore breathing space.",
            "id": "c1fcee68ae6fb13a1b4acb7dedc2376b"
          },
          {
            "type": "html",
            "text": " Go round deprecating or changing calls until they're all gone.",
            "id": "887f756500be62f2746e43acc47130fd"
          },
          {
            "type": "html",
            "text": "\nLong parameter lists look like this:\n[http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/windowing/windows/windowreference/windowfunctions/createwindow.asp msdn.microsoft.com]",
            "id": "0199f3c3478465ed37ccc2d6ca360621"
          },
          {
            "type": "html",
            "text": "\nAt least the parameter types in this sample have comprehensible and easily pronounced names like \"LPCTSTR\".",
            "id": "364d16bc1374f3cb26812192ceffed36"
          },
          {
            "type": "html",
            "text": "\nOpinions on LPLs differ, obviously, but sane people agree that they are Pure Evil(tm). ",
            "id": "adf04e2666b1ee0a444e3844fdb933ba"
          },
          {
            "type": "html",
            "text": " It's actually those who do not know what they're talking about.",
            "id": "223a4d01ebfd5f18b5eb29b558b0963a"
          },
          {
            "type": "html",
            "text": "\nNaming parameters in a call only solves one problem with LPLs, namely, that the function call would become unreadable. In combination with [[Default Value]]s for parameters it also solves a second problem, namely, that the caller has to specify every parameter even if sensible defaults would do. Most fundamental problems with LPLs cannot be cured this way, though:",
            "id": "94eb22f93be8a87777884580f115a583"
          },
          {
            "type": "html",
            "text": " A function that just <i>delegates</i> a call has to accept and pass on all parameters explicitely:",
            "id": "9431820cd2e32ff2ee8f882ffb883331"
          },
          {
            "type": "code",
            "text": " void Master::doSomething(int a, int b, Foo foo, Bar bar, Moo moo, Meow meow) {\n   slave.doSomething(a, b, foo, bar, moo, meow);\n }",
            "id": "6506ff4c2d423321542365cef1d4c0c8"
          },
          {
            "type": "html",
            "text": " This also means that a delegating function will break every time the signature is changed.",
            "id": "0a143283c6f3aa02bceba6d9d6e8c0d6"
          },
          {
            "type": "html",
            "text": " When [[Runtime Polymorphism]] or [[Compiletime Polymorphism]] is used, a method needs to know about and accept all parameters explicitely even if it uses only some.",
            "id": "aad70ab0f53fe3f08411167dae549851"
          },
          {
            "type": "html",
            "text": " It will also break every time the signature is changed.",
            "id": "8bfdd2c74910d02c9133d6336a266b9b"
          },
          {
            "type": "html",
            "text": "\nWhile breakage can occur when shorter function signatures are used, the problem tends to be most rampant the longer signatures get. This is because longer signatures are often used when [[Signature Entropy]] is high. All of the above problems can be solved nicely using [[Parameter Object]]s. Their usage typically does not guarantee [[Binary Compatibility]], but it does help a lot in maintaining [[Source Compatibility]].",
            "id": "6ea03d66bd6da6e57d940e030979b21a"
          },
          {
            "type": "html",
            "text": "\nThis piece of immature wise-cracking was brought to you by [[Arne Vogel]].",
            "id": "b41b5cacfcdaf5da61b9b52b7151843c"
          },
          {
            "type": "html",
            "text": "<i>I can see a lot of handwaving in the above. Incidentally the piece of code that you refer to has kept [[Binary Compatibility]] for over a decade now, so it is a rather spectacular example of how a well designed API for a rather complex domain can make use of [[Long Parameter List]] and provide an impressive array of power and functionality while keeping it stable for over a decade. Try to find a contemporary Linux distro out there that runs binaries from a decade ago, and good luck. Or how about if you find a device driver for Linux written in 2000 that runs on current kernel. Folks can bitch all they want about Windows, but if you look objectively it is an impressive engineering achievement.</i>",
            "id": "727cdf759207964ed5eb341a2fc1b01e"
          },
          {
            "type": "html",
            "text": "<i> [[Parameter Object]]s don't solve anything, they just move complexity some place else, while adding unnecessary entities to the system. You can group stuff that belongs together in parameter object, but not all parameters in a [[Long Parameter List]] can be sensibly crammed together in parameter objects. If you want to make your case you can show us how you'd design a better public interface for the </i>cp<i> command in Unix, or a better interface for the Create<b></b>Window function under windows, and then we'll see. --[[Costin Cozianu]]</i>",
            "id": "4a77a8dfb1eef91dd9970bf374b08db3"
          },
          {
            "type": "html",
            "text": "\nHmmm...\nIn [[Create Window]],",
            "id": "f1ced3365f788078dce1bcc32906f099"
          },
          {
            "type": "code",
            "text": "    int x,\n    int y,\n    int nWidth,\n    int nHeight,",
            "id": "7debe8a8f16112e70d22d5d47c10ddea"
          },
          {
            "type": "html",
            "text": "looks like a \"Rectangle\" to me.",
            "id": "a067e6898c975f4fdc0f6dac830eab47"
          },
          {
            "type": "html",
            "text": "<i>Ok, so now I as a programmer I'd have to replace</i>",
            "id": "cbdcb67da6575c72ce1d74792ee4fb30"
          },
          {
            "type": "code",
            "text": "  CreateWindow ( ..., 100,100, 300, 200, ...) ",
            "id": "a6828e55d5ee6a69fb73583fe4ef11a8"
          },
          {
            "type": "html",
            "text": "<i>with</i>",
            "id": "5ea6b59022bedf33970e5e5756a12e76"
          },
          {
            "type": "code",
            "text": "  struct Rect r;\n  r.x= 100;\n  r.y= 100;\n  r.nWidth= 300;\n  r.nHeight= 400;\n  CreateWindow( ..., &r, ...);",
            "id": "f372c2793e6e121b8fea9b8c68446828"
          },
          {
            "type": "html",
            "text": "<i>I don't know if I'm so happy with the later.It's true that the Rectangle case can go either way. If you already had a rectangle in the calling context, you can pass it more easily. Rectangles can also be subject to geometrical transformations as one object, far easier than 4 separate variables. On the other hand, if you had 4 separate variables or constants like the above, or if you cared about performance, say you wanted to draw tons of rectangles in a game, than the unfolded variables may be arguably better. Some frameworks choose to provide all options in one overloaded function where the language supports that, while Microsoft SDK goes consistently with the unfolded four variables also in part because the language is C and because folks who need the folded version can easily work around the unfolded design, while the other way around does not work. </i>",
            "id": "c7f12fdd714fbaa2769a66a7fc427caa"
          },
          {
            "type": "html",
            "text": "<i>It's not clear cut, but even with the folded rectangle, [[Create Window]] would still have 8 parameters while [[Create Window Ex]] would have 9. </i>",
            "id": "6bb71898bba1df1ebadd0b542fa810be"
          },
          {
            "type": "html",
            "text": "\nMicrosoft APIs are rarely that consistent (the Win32 API was formed by accretion more than by design). [??? -- rather dubious claim]",
            "id": "ba6145ea388d02c56b0d7485078dfa46"
          },
          {
            "type": "html",
            "text": "\nFor every function like [[Create Window]] that has a long hairy parameter list, I can think of another function that takes a single (hairy) struct.  Sometimes this is because the call ends up going through the narrow [[Send Message]] pipe where you are only allowed a couple of parameters.",
            "id": "8fdabd0072639c3f61f371f105e6d292"
          },
          {
            "type": "html",
            "text": "\nAlso, if using [[Cee Plus Plus]], you could choose to create the rectangle structure automatically using a convenience constructor if that is more concise:",
            "id": "69993724e147d4b71b92f59780a68a36"
          },
          {
            "type": "code",
            "text": " CreateWindow( ..., CRect(100,100,300,400), ...);",
            "id": "f15951bcc7dc2faf5eeea4329402efb1"
          },
          {
            "type": "html",
            "text": "<i>So what would the inner CRect(100,100,300,400) accomplish ? I am affraid that not much.</i>",
            "id": "3f103114ec6ec02dfb20ff5a9979c789"
          },
          {
            "type": "html",
            "text": "[It tells the compiler, as well as future maintainers, what those 4 numbers sandwiched in there stand for.]",
            "id": "4b991ee89a4fd39e6f49c6cd0b3c64f9"
          },
          {
            "type": "html",
            "text": " It tells the compiler but the compiler isn't happy to hear that. As for the proverbial maintainer, he either has to know the [[Create Window]] signature, or the [[Create Window]] and CRect signature. But anyways, that is small potatoes we are talking about. Even with the 4 sandwiched inside CRect, the function still has 8 parameters.",
            "id": "a232c0645660168c0d648e7cac794a2a"
          },
          {
            "type": "html",
            "text": "<i>Replacing a [[Long Parameter List]] with an equally complex [[Parameter Object]] is something I would definitely recommend against, unless it is part of [[Emulate Keyword And Default Parameters]], in which case we're still talking in essence of a [[Long Parameters List]] but with a workaround to language limitations. One needs to decouple the technical details related to [[Program Intoa Language]], from what is really happening. Even with parameter objects, we're still talking about one logical operation (like creating a window) that depends on a long list of variables, because it needs to be adapted to a wide variety of contexts.</i>",
            "id": "9cb2527fdae1cfe0fea9094f94b5ac69"
          },
          {
            "type": "html",
            "text": "<i>But with keyword and default parameters (either for real or emulated), I contend that [[Long Parameter List]] are often times needed to create powerful and reusable abstractions. --[[Costin Cozianu]]</i>",
            "id": "20ddf782147ca62157251accc268ac85"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "857ee3b5e37d702e98e80817a5214e9f"
          },
          {
            "type": "html",
            "text": "Maybe this \"window\" thing, and GUI's in general, are better served with a markup language akin to HTML. Markup seems to do \"mass attributes\" better than most existing imperative languages. -t",
            "id": "49a5ffb1fe8d852dbdd7f8ca65597488"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "857ee3b5e37d702e98e80817a5214e9f"
          },
          {
            "type": "html",
            "text": "See also [[Too Many Parameters]], [[Too Much Gui Code]]",
            "id": "528f393d0d684d602fb39695640d1658"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?LongParameterList c2.com]",
            "id": "5765593f45e03ce0556dfe72441f894e"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1628112169376
    },
    {
      "type": "edit",
      "id": "81a6f0c9320cbe42ba7599cc0b31e062",
      "item": {
        "type": "html",
        "text": "In OO frameworks, take for example the [[ACE]] C++ framework from [[Doug Schmidt]]. You'll see many constructors in there that have more than six parameters. Or take the [[Smart Pointer]] class from [[Modern Cee Plus Plus Design]]. It has four templatized arguments. Basically for a smart pointer which is one of the smallest interfaces you can have in C++.",
        "id": "81a6f0c9320cbe42ba7599cc0b31e062"
      },
      "date": 1628112396897
    }
  ]
}