{
  "title": "Observer Pattern",
  "story": [
    {
      "type": "html",
      "text": "<b>Name:</b> Observer Pattern ",
      "id": "08a74bc5c77dc1f61892fbb4566ae8a9"
    },
    {
      "type": "html",
      "text": "<b>Alias:</b> Subject Observer, Publish Subscribe, Callback.",
      "id": "e7bb24c437009ca045fcae0ff194a11c"
    },
    {
      "type": "html",
      "text": "<b>Intent:</b> Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.",
      "id": "2e2d3b35abfff7dafb3e60c707c1b539"
    },
    {
      "type": "html",
      "text": "<b>See:</b>",
      "id": "43d2fe5634650bcb83c9af15f918ec04"
    },
    {
      "type": "html",
      "text": " [[Observers And Rmi]] -- to enable caching of data on the client side of [[Java Remote Method Invocation]] calls.",
      "id": "7377c040f33c9510b632479117504c0d"
    },
    {
      "type": "html",
      "text": " [[Connection Observer]]",
      "id": "228f093ec686e0c88bcaf905f4c9aa05"
    },
    {
      "type": "html",
      "text": " [[Multi Caster]], [[Event Notifier]] - heavier alternative",
      "id": "33ee0fdd15dca05314bfee7cda2d45c9"
    },
    {
      "type": "html",
      "text": " [[Extended Observer]] - to delay notification to a more convenient time.",
      "id": "08f11d4431abffac5df7245ca1ef1c24"
    },
    {
      "type": "html",
      "text": " [[Publish Subscribe Model]]",
      "id": "3b115395fef1dd28691bcd6f8602158f"
    },
    {
      "type": "html",
      "text": " [[Callback Authorization]]",
      "id": "b7e627e5754cffac17ffddde1ada429b"
    },
    {
      "type": "html",
      "text": "\nOn [[Exception Handling]]:",
      "id": "dbf05a5899e2f1235a6aac58b2155730"
    },
    {
      "type": "html",
      "text": " [[Observers And Exceptions]]",
      "id": "bd5f0328550ec343200c19bea1bc9d94"
    },
    {
      "type": "html",
      "text": " [[Observers Should Never Throw Exceptions]]",
      "id": "22989078788267e9ae45ecd92a44ccce"
    },
    {
      "type": "html",
      "text": " [[Observables Need To Be Consistent]]",
      "id": "353b064dd25119068db9370bf6ad963b"
    },
    {
      "type": "html",
      "text": "\nJava Implementation:",
      "id": "b526b2e1db9e1b51a339063dbaa27e46"
    },
    {
      "type": "html",
      "text": " [[Observer Observable]]",
      "id": "76f922fbd2c55e22d424e7d13a5dd0c2"
    },
    {
      "type": "html",
      "text": " [[Beans Not Observer Observable]]",
      "id": "7d4c3cbaa16a02bd0e32c539c95c017c"
    },
    {
      "type": "html",
      "text": "\n[[Cee Plus Plus]] Implementation",
      "id": "bcf190f7125bb192dce20361a9605d32"
    },
    {
      "type": "html",
      "text": " [[Observer Pattern In Cee Plus Plus]]",
      "id": "ab3a7f092aeb9dbaafaca2c9d8799e96"
    },
    {
      "type": "html",
      "text": "\n[[Scala Language]] Paper",
      "id": "af10a919600bb9ceeb555a5c835ba858"
    },
    {
      "type": "html",
      "text": " [[Deprecating The Observer Pattern]]",
      "id": "158b521986e29ef214f0f2beb4c16cc7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9d0f80052a49f94bf5fddf1a60653a4e"
    },
    {
      "type": "html",
      "text": "The two basic styles of notification: [[Push Model]] and [[Pull Model]]. If the observed object does not have the necessary hooks for observers, the observers must rely on repeatedly polling the observed to note the changes. This is a \"pull\" versus a \"push\" type of pattern. Quite appropriate for certain applications.",
      "id": "3cef62627693c0b8b0e6e70dcc9c6af0"
    },
    {
      "type": "html",
      "text": "\nA key tenet is that the observed does not know anything about the observers. It \"publishes\" a change and the observers get notified of the change.",
      "id": "aeb0200ba7db57b19f5035979feb1140"
    },
    {
      "type": "html",
      "text": "\nThe [[Observer Pattern]] is useful mostly for <i>dynamic</i> relationships between objects: you can hook up a new observer to an observable while the program is running (e.g. hook up a newly-opened viewing window to a domain object), then unhook it later (e.g. remove the window from the list of observers when the user closes it).",
      "id": "a072c21a803728628d65804d261ed93d"
    },
    {
      "type": "html",
      "text": "\n[[Observer Pattern]] is pretty low-level, and appears in its entirety as part of other important patterns (e.g. [[Model View Controller]]).",
      "id": "f54bd4f4375800863af2e9547eaab1f1"
    },
    {
      "type": "html",
      "text": "\nIt is also the basis for publish-subscribe messaging architectures.",
      "id": "44282b9a764484866cda8b398aecb5e6"
    },
    {
      "type": "html",
      "text": "\nAdditionally, [[Observer Must Not Change Observable]].",
      "id": "5a7a12ea25d7585b0a95bb58719c59b2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9d0f80052a49f94bf5fddf1a60653a4e"
    },
    {
      "type": "html",
      "text": "I have thought about this some in the Publisher/Subscriber version, as follows:",
      "id": "e965245a15009243b1b519bacf56bb5f"
    },
    {
      "type": "html",
      "text": "\nSuppose the system has an [[Event Handler]] that wants to send out Notification X whenever this event occurs. You have a priority component, Component A, which is (probably) there all the time and may have to see this message right away. You also have a bunch of dynamic secondary components (B, C, and D) which may be there or not. They all have to receive the message sooner or later. Let's look at some possible scenarios:",
      "id": "b977b59f865765ab1311a48094548d3f"
    },
    {
      "type": "html",
      "text": " Nothing is very time critical. Publisher sends out Note X to A, B, C, D...ad nauseum. B, C, and D all begin reacting to X. In the mean time, A gets all panicky and generates event Y. Notification Y (effectively a Cancel X)  goes out to B, C, et al, and these components all roll their eyes, mutter something about these kids not being able to make up their minds, and toss the work they did to process the X note. Done.",
      "id": "e054354ac2d37ae82dca1886a151fd5c"
    },
    {
      "type": "html",
      "text": " Some things are time critical. X goes out as a conditional X. This means that a follow-up message will come out within a certain maximum time to confirm or cancel the X event. A gets a chance to chew on the X note and then generate a Confirm or Cancel. B, C, and D can all get their house in order in case this is the real thing. If they get a Confirm follow-up they complete the processing of X. Otherwise they get a Cancel and they can drop the whole thing. That finishes that.",
      "id": "5f14d2211b3c2b85d056c88bc4e30715"
    },
    {
      "type": "html",
      "text": " The worst case is where A is dynamic as well as the rest of the subscribers and time is critical. Without A in the picture Note X just goes out to whoever else is there. When A comes into the picture it has to register with the X [[Event Handler]]. Then the X handler sends a conditional X notification. The business with the Confirm or Cancel still applies.",
      "id": "de65456cba9a0d04d2066bb04388f297"
    },
    {
      "type": "html",
      "text": "\nAdditionally, the Publisher can use a \"Stay Current\" mechanism to interrogate the Subscribers and find out if they are still there. If any subscriber disappears the Publisher drops him from the distribution list. There are many other permutations to this pattern.",
      "id": "b11d4cb15a1e85aa66ebee0931f99b6f"
    },
    {
      "type": "html",
      "text": "-- [[Marty Schrader]]",
      "id": "c6058f67390a393618c09224ba188127"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9d0f80052a49f94bf5fddf1a60653a4e"
    },
    {
      "type": "html",
      "text": "Other reference sources:",
      "id": "e54df334d9a03e03ba089cc5a723e764"
    },
    {
      "type": "html",
      "text": " [http://home.earthlink.net/~huston2/dp/observer.html home.earthlink.net]",
      "id": "98cd7cd56b1d8ae7c2e80e78ba7f11f6"
    },
    {
      "type": "html",
      "text": " [http://wiki.cs.uiuc.edu/patternStories/ObserverPattern wiki.cs.uiuc.edu]",
      "id": "fede09540cc2db8343665bc014b14917"
    },
    {
      "type": "html",
      "text": " [http://sern.ucalgary.ca/courses/SENG/609.04/W98/lamsh/observerLib.html sern.ucalgary.ca]",
      "id": "a7a8df1b466b6479a5d343908f526a5c"
    },
    {
      "type": "html",
      "text": " [http://api.rubyonrails.org/classes/ActiveRecord/Observer.html api.rubyonrails.org]",
      "id": "fea0be8e4ba8feb8758f5326b7e47bcd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9d0f80052a49f94bf5fddf1a60653a4e"
    },
    {
      "type": "html",
      "text": "Contributors: [[Manuel Simoni]], [[Marty Schrader]], [[Robby Russell]]",
      "id": "ab8d994c25a9cc258369ee6b0e4c3e22"
    },
    {
      "type": "html",
      "text": "\n[[Category Pattern]]",
      "id": "6a0d4340bdfb906a766fec906d655b41"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ObserverPattern c2.com]",
      "id": "fa69e42860a5b38d7bc2570f490d03a2"
    }
  ],
  "journal": [
    {
      "date": 1287250823000,
      "id": "b1f0b49691346a0e4623d12336d4911d",
      "type": "create",
      "item": {
        "title": "Observer Pattern",
        "story": [
          {
            "type": "html",
            "text": "<b>Name:</b> Observer Pattern ",
            "id": "08a74bc5c77dc1f61892fbb4566ae8a9"
          },
          {
            "type": "html",
            "text": "<b>Alias:</b> Subject Observer, Publish Subscribe, Callback.",
            "id": "e7bb24c437009ca045fcae0ff194a11c"
          },
          {
            "type": "html",
            "text": "<b>Intent:</b> Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.",
            "id": "2e2d3b35abfff7dafb3e60c707c1b539"
          },
          {
            "type": "html",
            "text": "<b>See:</b>",
            "id": "43d2fe5634650bcb83c9af15f918ec04"
          },
          {
            "type": "html",
            "text": " [[Observers And Rmi]] -- to enable caching of data on the client side of [[Java Remote Method Invocation]] calls.",
            "id": "7377c040f33c9510b632479117504c0d"
          },
          {
            "type": "html",
            "text": " [[Connection Observer]]",
            "id": "228f093ec686e0c88bcaf905f4c9aa05"
          },
          {
            "type": "html",
            "text": " [[Multi Caster]], [[Event Notifier]] - heavier alternative",
            "id": "33ee0fdd15dca05314bfee7cda2d45c9"
          },
          {
            "type": "html",
            "text": " [[Extended Observer]] - to delay notification to a more convenient time.",
            "id": "08f11d4431abffac5df7245ca1ef1c24"
          },
          {
            "type": "html",
            "text": " [[Publish Subscribe Model]]",
            "id": "3b115395fef1dd28691bcd6f8602158f"
          },
          {
            "type": "html",
            "text": " [[Callback Authorization]]",
            "id": "b7e627e5754cffac17ffddde1ada429b"
          },
          {
            "type": "html",
            "text": "\nOn [[Exception Handling]]:",
            "id": "dbf05a5899e2f1235a6aac58b2155730"
          },
          {
            "type": "html",
            "text": " [[Observers And Exceptions]]",
            "id": "bd5f0328550ec343200c19bea1bc9d94"
          },
          {
            "type": "html",
            "text": " [[Observers Should Never Throw Exceptions]]",
            "id": "22989078788267e9ae45ecd92a44ccce"
          },
          {
            "type": "html",
            "text": " [[Observables Need To Be Consistent]]",
            "id": "353b064dd25119068db9370bf6ad963b"
          },
          {
            "type": "html",
            "text": "\nJava Implementation:",
            "id": "b526b2e1db9e1b51a339063dbaa27e46"
          },
          {
            "type": "html",
            "text": " [[Observer Observable]]",
            "id": "76f922fbd2c55e22d424e7d13a5dd0c2"
          },
          {
            "type": "html",
            "text": " [[Beans Not Observer Observable]]",
            "id": "7d4c3cbaa16a02bd0e32c539c95c017c"
          },
          {
            "type": "html",
            "text": "\n[[Cee Plus Plus]] Implementation",
            "id": "bcf190f7125bb192dce20361a9605d32"
          },
          {
            "type": "html",
            "text": " [[Observer Pattern In Cee Plus Plus]]",
            "id": "ab3a7f092aeb9dbaafaca2c9d8799e96"
          },
          {
            "type": "html",
            "text": "\n[[Scala Language]] Paper",
            "id": "af10a919600bb9ceeb555a5c835ba858"
          },
          {
            "type": "html",
            "text": " [[Deprecating The Observer Pattern]]",
            "id": "158b521986e29ef214f0f2beb4c16cc7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9d0f80052a49f94bf5fddf1a60653a4e"
          },
          {
            "type": "html",
            "text": "The two basic styles of notification: [[Push Model]] and [[Pull Model]]. If the observed object does not have the necessary hooks for observers, the observers must rely on repeatedly polling the observed to note the changes. This is a \"pull\" versus a \"push\" type of pattern. Quite appropriate for certain applications.",
            "id": "3cef62627693c0b8b0e6e70dcc9c6af0"
          },
          {
            "type": "html",
            "text": "\nA key tenet is that the observed does not know anything about the observers. It \"publishes\" a change and the observers get notified of the change.",
            "id": "aeb0200ba7db57b19f5035979feb1140"
          },
          {
            "type": "html",
            "text": "\nThe [[Observer Pattern]] is useful mostly for <i>dynamic</i> relationships between objects: you can hook up a new observer to an observable while the program is running (e.g. hook up a newly-opened viewing window to a domain object), then unhook it later (e.g. remove the window from the list of observers when the user closes it).",
            "id": "a072c21a803728628d65804d261ed93d"
          },
          {
            "type": "html",
            "text": "\n[[Observer Pattern]] is pretty low-level, and appears in its entirety as part of other important patterns (e.g. [[Model View Controller]]).",
            "id": "f54bd4f4375800863af2e9547eaab1f1"
          },
          {
            "type": "html",
            "text": "\nIt is also the basis for publish-subscribe messaging architectures.",
            "id": "44282b9a764484866cda8b398aecb5e6"
          },
          {
            "type": "html",
            "text": "\nAdditionally, [[Observer Must Not Change Observable]].",
            "id": "5a7a12ea25d7585b0a95bb58719c59b2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9d0f80052a49f94bf5fddf1a60653a4e"
          },
          {
            "type": "html",
            "text": "I have thought about this some in the Publisher/Subscriber version, as follows:",
            "id": "e965245a15009243b1b519bacf56bb5f"
          },
          {
            "type": "html",
            "text": "\nSuppose the system has an [[Event Handler]] that wants to send out Notification X whenever this event occurs. You have a priority component, Component A, which is (probably) there all the time and may have to see this message right away. You also have a bunch of dynamic secondary components (B, C, and D) which may be there or not. They all have to receive the message sooner or later. Let's look at some possible scenarios:",
            "id": "b977b59f865765ab1311a48094548d3f"
          },
          {
            "type": "html",
            "text": " Nothing is very time critical. Publisher sends out Note X to A, B, C, D...ad nauseum. B, C, and D all begin reacting to X. In the mean time, A gets all panicky and generates event Y. Notification Y (effectively a Cancel X)  goes out to B, C, et al, and these components all roll their eyes, mutter something about these kids not being able to make up their minds, and toss the work they did to process the X note. Done.",
            "id": "e054354ac2d37ae82dca1886a151fd5c"
          },
          {
            "type": "html",
            "text": " Some things are time critical. X goes out as a conditional X. This means that a follow-up message will come out within a certain maximum time to confirm or cancel the X event. A gets a chance to chew on the X note and then generate a Confirm or Cancel. B, C, and D can all get their house in order in case this is the real thing. If they get a Confirm follow-up they complete the processing of X. Otherwise they get a Cancel and they can drop the whole thing. That finishes that.",
            "id": "5f14d2211b3c2b85d056c88bc4e30715"
          },
          {
            "type": "html",
            "text": " The worst case is where A is dynamic as well as the rest of the subscribers and time is critical. Without A in the picture Note X just goes out to whoever else is there. When A comes into the picture it has to register with the X [[Event Handler]]. Then the X handler sends a conditional X notification. The business with the Confirm or Cancel still applies.",
            "id": "de65456cba9a0d04d2066bb04388f297"
          },
          {
            "type": "html",
            "text": "\nAdditionally, the Publisher can use a \"Stay Current\" mechanism to interrogate the Subscribers and find out if they are still there. If any subscriber disappears the Publisher drops him from the distribution list. There are many other permutations to this pattern.",
            "id": "b11d4cb15a1e85aa66ebee0931f99b6f"
          },
          {
            "type": "html",
            "text": "-- [[Marty Schrader]]",
            "id": "c6058f67390a393618c09224ba188127"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9d0f80052a49f94bf5fddf1a60653a4e"
          },
          {
            "type": "html",
            "text": "Other reference sources:",
            "id": "e54df334d9a03e03ba089cc5a723e764"
          },
          {
            "type": "html",
            "text": " [http://home.earthlink.net/~huston2/dp/observer.html home.earthlink.net]",
            "id": "98cd7cd56b1d8ae7c2e80e78ba7f11f6"
          },
          {
            "type": "html",
            "text": " [http://wiki.cs.uiuc.edu/patternStories/ObserverPattern wiki.cs.uiuc.edu]",
            "id": "fede09540cc2db8343665bc014b14917"
          },
          {
            "type": "html",
            "text": " [http://sern.ucalgary.ca/courses/SENG/609.04/W98/lamsh/observerLib.html sern.ucalgary.ca]",
            "id": "a7a8df1b466b6479a5d343908f526a5c"
          },
          {
            "type": "html",
            "text": " [http://api.rubyonrails.org/classes/ActiveRecord/Observer.html api.rubyonrails.org]",
            "id": "fea0be8e4ba8feb8758f5326b7e47bcd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9d0f80052a49f94bf5fddf1a60653a4e"
          },
          {
            "type": "html",
            "text": "Contributors: [[Manuel Simoni]], [[Marty Schrader]], [[Robby Russell]]",
            "id": "ab8d994c25a9cc258369ee6b0e4c3e22"
          },
          {
            "type": "html",
            "text": "\n[[Category Pattern]]",
            "id": "6a0d4340bdfb906a766fec906d655b41"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ObserverPattern c2.com]",
            "id": "fa69e42860a5b38d7bc2570f490d03a2"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1649825796850
    }
  ]
}