{
  "title": "Analyzing Self-Aware Eternal Systems",
  "story": [
    {
      "type": "markdown",
      "id": "329cf967b45e9415",
      "text": "To change a system we must first understand the system and the consequences of change. Since change inevitably causes the system to drift from its initial documentation, the most reliable source of information is the system itself. However, documentation will not only be provided in form of documents, but also in various other forms like online discussions, bug reports, and description of the changes [6]. Therefore, software analysis tools for reverse engineering are central to support software evolution [7]. A self-aware system can reflect on its own specification, which is an aid to static analysis. But the run-time architecture and other emergent properties can only be monitored with the help of dynamic analysis [8]. A self-aware, eternal system must be capable of tracing and analyzing its run-time behaviour while it is online, much like garbage collectors are always active in modern virtual machines.\n"
    },
    {
      "type": "markdown",
      "id": "888a2b9ea30ddf8a",
      "text": "In eternal software systems, the changes to the static parts are directly accessible as first class entities. As such, in eternal software systems, not only the run-time is dynamic, but also the static part is dynamic when seen from a historical perspective. Treating history as a first-class entity enables analyses of the evolution of software artifacts [9].\nGiven the size of eternal systems, they will not be developed by an isolated team, but rather by several teams that are physically distributed. In this context, the social aspect of the development will become increasingly important [10]. Thus, analysis will also consist of reasoning about how developers collaborate.\n"
    },
    {
      "type": "markdown",
      "id": "3e2b4214bffa779e",
      "text": "Yet another complicating factor is the use of different languages and media within the same system. Furthermore, some of the languages used will be either legacy languages or dialects. For this reason, post-hoc parsing of components built with these languages will be difficult and error-prone. Thus, a software eternal software can be seen as a multi-dimensional space of data that needs to be continuously analyzed."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Analyzing Self-Aware Eternal Systems",
        "story": []
      },
      "date": 1633671266180
    },
    {
      "item": {
        "type": "factory",
        "id": "329cf967b45e9415"
      },
      "id": "329cf967b45e9415",
      "type": "add",
      "date": 1633671273319
    },
    {
      "type": "edit",
      "id": "329cf967b45e9415",
      "item": {
        "type": "markdown",
        "id": "329cf967b45e9415",
        "text": "\nTo change a system we must first understand the system and the conse- quences of change. Since change inevitably causes the system to drift from its initial documentation, the most reliable source of information is the system itself. However, documentation will not only be provided in form of documents, but also in various other forms like online discussions, bug reports, and description of the changes [6]. Therefore, software analysis tools for reverse engineering are central to support software evolution [7]. A self-aware system can reflect on its own specification, which is an aid to static analysis. But the run-time architecture and other emergent prop- erties can only be monitored with the help of dynamic analysis [8]. A self-aware, eternal system must be capable of tracing and analyzing its run-time behaviour while it is online, much like garbage collectors are al- ways active in modern virtual machines.\nIn eternal software systems, the changes to the static parts are directly accessible as first class entities. As such, in eternal software systems, not only the run-time is dynamic, but also the static part is dynamic when seen from a historical perspective. Treating history as a first-class entity enables analyses of the evolution of software artifacts [9].\nGiven the size of eternal systems, they will not be developed by an isolated team, but rather by several teams that are physically distributed. In this context, the social aspect of the development will become increasingly important [10]. Thus, analysis will also consist of reasoning about how developers collaborate.\nYet another complicating factor is the use of different languages and media within the same system. Furthermore, some of the languages used will be either legacy languages or dialects. For this reason, post-hoc parsing of components built with these languages will be difficult and error-prone. Thus, a software eternal software can be seen as a multi-dimensional space of data that needs to be continuously analyzed."
      },
      "date": 1633671275741
    },
    {
      "type": "edit",
      "id": "329cf967b45e9415",
      "item": {
        "type": "markdown",
        "id": "329cf967b45e9415",
        "text": "To change a system we must first understand the system and the consequences of change. Since change inevitably causes the system to drift from its initial documentation, the most reliable source of information is the system itself. However, documentation will not only be provided in form of documents, but also in various other forms like online discussions, bug reports, and description of the changes [6]. Therefore, software analysis tools for reverse engineering are central to support software evolution [7]. A self-aware system can reflect on its own specification, which is an aid to static analysis. But the run-time architecture and other emergent properties can only be monitored with the help of dynamic analysis [8]. A self-aware, eternal system must be capable of tracing and analyzing its run-time behaviour while it is online, much like garbage collectors are always active in modern virtual machines.\n"
      },
      "date": 1633671328189
    },
    {
      "type": "add",
      "id": "888a2b9ea30ddf8a",
      "item": {
        "type": "markdown",
        "id": "888a2b9ea30ddf8a",
        "text": "In eternal software systems, the changes to the static parts are directly accessible as first class entities. As such, in eternal software systems, not only the run-time is dynamic, but also the static part is dynamic when seen from a historical perspective. Treating history as a first-class entity enables analyses of the evolution of software artifacts [9].\nGiven the size of eternal systems, they will not be developed by an isolated team, but rather by several teams that are physically distributed. In this context, the social aspect of the development will become increasingly important [10]. Thus, analysis will also consist of reasoning about how developers collaborate.\n"
      },
      "after": "329cf967b45e9415",
      "date": 1633671339204
    },
    {
      "type": "add",
      "id": "3e2b4214bffa779e",
      "item": {
        "type": "markdown",
        "id": "3e2b4214bffa779e",
        "text": "Yet another complicating factor is the use of different languages and media within the same system. Furthermore, some of the languages used will be either legacy languages or dialects. For this reason, post-hoc parsing of components built with these languages will be difficult and error-prone. Thus, a software eternal software can be seen as a multi-dimensional space of data that needs to be continuously analyzed."
      },
      "after": "888a2b9ea30ddf8a",
      "date": 1633671344480
    }
  ]
}