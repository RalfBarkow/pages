{
  "title": "2024-03-22",
  "story": [
    {
      "type": "paragraph",
      "id": "f25e428c4ee6f31e",
      "text": "⇐ [[Roster]] ⇒ [[Find Each Other]]"
    },
    {
      "type": "paragraph",
      "id": "3ec24b303cf7f314",
      "text": "Online help in the form of ghost pages. For example, if we click on \"wiki\" in a read-only wiki configuration, the check mark should not be set, as shown in the following figure."
    },
    {
      "type": "image",
      "id": "72f5db823924ce19",
      "text": "New wiki with write access?",
      "size": "wide",
      "width": 419,
      "height": 35,
      "url": "/assets/plugins/image/eba557d2b996973024685c49afcbd549.jpg"
    },
    {
      "type": "paragraph",
      "id": "7532d8ce287a4211",
      "text": "Using [[Default Security]] – Wiki will be read-only"
    },
    {
      "type": "paragraph",
      "id": "2613b11e3c231185",
      "text": "and rejecting /page/welcome-visitors/action"
    },
    {
      "type": "paragraph",
      "id": "aa7529cc0e6330d9",
      "text": "See also [[Default security module]]"
    },
    {
      "type": "paragraph",
      "id": "f8c3d7f8fdc7bc45",
      "text": "⇒ [[Goobi]]"
    },
    {
      "type": "image",
      "id": "ed83a130c24c571e",
      "text": "Goobi workflow",
      "size": "wide",
      "width": 419,
      "height": 223,
      "url": "/assets/plugins/image/b8f1ae1d3f9325b1c5c5621cfb7121e2.jpg"
    },
    {
      "type": "paragraph",
      "id": "8ec693fcee1bd011",
      "text": "~/Projects/RalfBarkow/goobi-workflow"
    },
    {
      "type": "pagefold",
      "id": "df6acc89e78196c1",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "17c7765c3911a576",
      "text": "⇒ [[Ubuntu]]"
    },
    {
      "type": "paragraph",
      "id": "4bb6465ef2802da0",
      "text": "Unable to update \"[[Snap Store]]\": cannot refresh \"snap-store\": snap \"snap-store\" has running apps (ubuntu-software) [https://askubuntu.com/questions/1411104/unable-to-update-snap-store-cannot-refresh-snap-store-snap-snap-store-ha page]"
    },
    {
      "type": "paragraph",
      "id": "cccfaa77b3b7c363",
      "text": "Learn more about the Ubuntu Pro [[Subscription]]. [https://ubuntu.com/pro page]"
    },
    {
      "type": "reference",
      "id": "615b4f719272a754",
      "site": "wiki.ralfbarkow.ch",
      "slug": "runtime",
      "title": "Runtime",
      "text": "[[Elm]] Runtime"
    },
    {
      "type": "reference",
      "id": "9424ccfeafe99d38",
      "site": "eric.dojo.fed.wiki",
      "slug": "why-containers-work",
      "title": "Why Containers Work",
      "text": "Consistency.  And separation of concerns between configuration-time and run-time."
    },
    {
      "type": "paragraph",
      "id": "e63dfe135d6ea440",
      "text": "[[Docker]]"
    },
    {
      "type": "paragraph",
      "id": "ad5250b0a474f2e8",
      "text": "[[WebSocket]] [https://developer.mozilla.org/en-US/docs/Web/API/WebSocket msn]"
    },
    {
      "type": "paragraph",
      "id": "8f2e5d09aeb5cf59",
      "text": "isomorphic-ws [https://www.npmjs.com/package/isomorphic-ws npm]"
    },
    {
      "type": "paragraph",
      "id": "4a287d7868d8075a",
      "text": "⇒ [[Lit]]"
    },
    {
      "type": "video",
      "id": "b9bbd8ddc8027964",
      "text": "YOUTUBE cttpgBg6pDQ\nVanilla Web: Der Frontend-Trend für 2024?"
    },
    {
      "type": "paragraph",
      "id": "7f50ba6ab9897efb",
      "text": "stell dir vor du planst die Entwicklung einer neuen Web oder Cloud basierten Software und im Backend hast du alle zu verwendenen Technologien bereits entschieden nur im Frontend bist du dir noch nicht so ganz sicher solltest du eher auf einen der etablierten Platzhirsche setzen also auf ein Framework wie react angular oder vielleicht auch view oder solltest du dich eher für eines der neueren und kleineren Frameworks entscheiden wie z.B swelt oder solid JS und diese Frage die ist nicht nur nicht neu diese Frage Frage kennt vor allem auch keine richtige Antwort denn völlig egal für welches Framework du dich letztlich entscheidest du bindest dich immer das heißt du handelst dir immer einen vendor lockin ein und du hast zugleich aber nie die Garantie dass es das jeweilige Framework in ein paar Jahren auch tatsächlich noch geben wird dass es noch weiterentwickelt werden wird dass es noch gepflegt werden wird und so weiter"
    },
    {
      "type": "paragraph",
      "id": "6c9f33b1df1dc362",
      "text": "und ein Königsweg wie man das Thema Web UI Entwicklung überhaupt angeht den scheint es auch nicht so wirklich zu geben denn sonst würde nicht gefühlt alle paar Wochen in komplett komplett neues Framework erscheinen und leider geht ja das nicht nur beim Framework so hinzu kommt nämlich noch eine ganze Reihe an Werkzeugen die du auch noch benötigst angefangen beim typescript Compiler über einen precompiler für SAS oder L in Verbindung mit einem Package Manager wie NPM oder yarn ein Bildtool wie z.B wieed vielleicht noch ein gesonderter Bandler und so weiter und so fort und wenn es dir dir da geht wie mir dann hast du auf diese Art der Webentwicklung schon lange keine Lust mehr und das alles wird gefühlt nicht besser sondern immer nur noch schlimmer"
    },
    {
      "type": "paragraph",
      "id": "27734aea21cca5e3",
      "text": "Ständig kommen neue Werkzeuge hinzu und die ganze [[Leichtigkeit]] die vor vielen Jahren mal typisch für die Webentwicklung war das ist leider inzwischen echt lange her und da stellt sich dann die Frage wo soll das denn alles noch hinführen wäre es nicht längst überfällig da mal inne zu halten und sich mal zu fragen ob wir nicht seit Jahren in eine gänzlich falsche Richtung laufen und wie man das ganze nicht vielleicht deutlich besser machen könnte und genau darum geht es heute in diesem Video in diesem Sinne hallo und herzlich willkommen zu unserem neuen weekly und by the way ein schönes und frohes neues Jahr"
    },
    {
      "type": "paragraph",
      "id": "218e4cb625b80184",
      "text": "ja und ich habe es gerade schon angesprochen Webentwicklung war mal anders Webentwicklung war mal leichtgewichtig da hat es genügt in dem Texteditor ein paar Zeichen zu ändern zu speichern im Webbrowser einmal neu zu laden und das war's und da war es völlig egal ob man da gerade HTML oder CSS oder Javascript bearbeitet hat alle drei Sprachen kamen ohne ein [[Compiler]] und ohne gesondertes tooling aus und das war damals so vor ungefähr 25 Jahren der große Unterschied zur desktopentwicklung wo man immer auf einen Compiler angewiesen war und daher auch immer entsprechend warten musste bevor man die Änderungen am Quellcode dann auch tatsächlich ausprobieren konnte und das war mal einer der Punkte die mich von Anfang an am Web fasziniert hatten diese auf das Wesentliche reduzierte Einfachheit und wenn ich mir das jetzt im Vergleich zu heute anschaue dann macht das inzwischen über überhaupt keinen Spaß mehr da kann man nicht einfach mal ein bisschen HTML schreiben sondern man braucht direkt jsx oder irgendeine andere Abstraktion für die man dann ein dedizierten precompiler benötigt der über NPM installiert werden muss wofür man dann wiederum noe braucht was man an seinerseits wiederum über den noe Version Manager NVM installieren sollte und das sind jetzt schon vier Technologien die man letztlich aber nur dafür braucht um HTML schreiben zu können und da haben wir noch nicht über CSS oder geschweige den JavaScript gesprochen und auch noch noch nicht über das ganze umgebende Ökosystem mit linting mit formatting mit testing und so weiter und um es kurz zu machen Frontend Web Entwicklung macht zumindest mir persönlich keinen wirklichen Spaß mehr ja und das traurige ist ganz vieles von dem was wir da heute alles veranstalten das wäre überhaupt nicht mehr notwendig weil das Web bzw die Webbrowser das meiste inzwischen nativ beherrschen wir haben und das ist eine echt bittere Erkenntnis in den vergangenen Jahren und Jahrzehnten vollkommen aus den Augen verloren warum wir all diese Frameworks und Werkzeuge überhaupt einsetzen und wir haben uns so sehr an die Tatsache gewöhnt dass wir sie einsetzen dass wir immer nur hinterfragen ob das gewählte Tool ob die gewählte Bibliothek ob das das richtige ist aber nie ob wir das Tool oder die Bibliothek an sich überhaupt noch brauchen und das ändert sich gerade bzw ich persönlich habe den Eindruck dass jetzt im Jahr 2024 genug momentum in diese Frage kommt dass sich weblung an Webentwicklung an sich in den nächsten 12 Monaten durchaus grundlegend verändern könnte und das Ergebnis davon könnte sein dass wir mit einem deutlich stabileren und vor allem langfristig auch mit einem deutlich verlässlicheren technologiestck aus der ganzen Sache hinausgehen können und wie das aussehen könnte das möchte ich Dir jetzt im Folgenden mal kurz skizzieren"
    },
    {
      "type": "paragraph",
      "id": "972e1532c0e21583",
      "text": "wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements. Ein [[Custom Element]] ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML [[Komponente]] zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus"
    },
    {
      "type": "paragraph",
      "id": "7c2ec33f52ce20ba",
      "text": "nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann [[Shadow Dom]] und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS"
    },
    {
      "type": "paragraph",
      "id": "5459837d9468165c",
      "text": "und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
    },
    {
      "type": "paragraph",
      "id": "1f733ef5ef47e3ac",
      "text": "aber zum Glück gibt es für webcomponents ganz gute Abstraktionen die das ganze deutlich zugänglicher machen und da fällt mir persönlich z.B das Framework [[Lit]] ein das wir auch schon einmal in einem unserer Livestreams in Aktion erlebt haben und falls du den damals nicht gesehen hast dann findest du den Link dorthin noch einmal hier oben in der infocard da magst Du natürlich nun auch einwenden dass das doch irgendwie nicht der Sinn der Sache sei weil man damit ja doch wieder auf ein Framework setzen würde und das ist auch erstmal durchaus richtig aber anders als bei react angular und Co schreibt man mit Lid eben keine Komponenten die dann wieder nur mit dem jeweiligen Framework funktionieren sondern man schafft eine algemeingültige Komponente die mit allen Frameworks oder eben auch ganz ohne Framework Lauf ist weil sie nativ im Browser läuft und das finde ich persönlich schon mal deutlich besser"
    },
    {
      "type": "paragraph",
      "id": "b6c1d281ef1be985",
      "text": "nun hatte ich ja anfangs erwähnt dass mich der bildschritt stört und wenn wir nun auf LD als Framework setzen dann haben wir natürlich wieder einen bildschritt das ist das zumindest was ich bis vor kurzem gedacht habe aber dem ist gar nicht so LD kann nämlich komplett zur Laufzeit ausgeführt werden das heißt ich muss keinen Compiler benutzen und das macht das Ganze direkt viel angenehmer noch angenehmer wird es übrigens wenn man feststellt dass man LD dazu noch nicht mal über NPM installieren muss sondern das einfach per Import aus einem CDN laden kann und wenn du da nun wiederum sagst das sei doch blöd weil man dann wieder überall von Versionsnummern in der Import URL Abhänge dann stimmt das außer du verwendest eine sogenannte [[Import Map]] [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap mdn] was übrigens ein weiteres Feature von modernen Browsern ist was einfach so da ist"
    },
    {
      "type": "paragraph",
      "id": "f8ae32a5bb00243a",
      "text": "mit so einer Import Map kannst du nämlich ein einziges Mal zentral festlegen dass es z.B einen Import namens lit geben soll und auf welche URL der dann aufgelöst werden soll und danach arbeitest du einfach in jedem deiner Skripte mit LD als wäre es lokal über NPM installiert und die Version kontrollierst du zentral über die Import Map Problem gelöst komplett ohne NPM und vor allem ohne bildschritt"
    },
    {
      "type": "paragraph",
      "id": "3504fee699197195",
      "text": "und das ganze funktioniert dank der Möglichkeit seit ein paar Jahren Javascript Code dynamisch zur Laufzeit als cmascriptmodul einfach so Nachladen zu können und da kann man natürlich auch wieder sagen das ist doch aber völlig unpraktikabel denn dann besteht meine Anwendung ja nachher aus zahlreichen ganz vielen kleinen einzelnen Dateien und das produziert ganz viel HTTP Overhead beim Laden und auch da stimme ich Dir grundsätzlich zu aber die Frage ist doch wie schlimm ist das denn wirklich also kommt es bei der Webseite od der Webanwendung die du baust wirklich auf jede nano oder Millisekunde an oder ist das eigentlich eher egal"
    },
    {
      "type": "paragraph",
      "id": "13ac183afc4af3d9",
      "text": "und da wird es sicherlich Fälle geben in denen das z.B wegen SEO ultra wichtig ist das mit wenigen requests alles möglichst schnell geladen wird es wird aber auch Fälle geben in denen das völlig egal ist weil die Anwendung z.B gar nicht public facing sind sondern ohnehin nur in einer privaten Gruppe privaten Anwenderinnen und Anwendern zur Verfügung gestellt werden wo das Ganze gar nicht so entscheidend ist z.B im Intranet zumindest könnte man über diese Unterscheidung ja mal nachdenken"
    },
    {
      "type": "paragraph",
      "id": "88cc6898ec799b55",
      "text": "das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt"
    },
    {
      "type": "paragraph",
      "id": "facffd63e90775e9",
      "text": "was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules"
    },
    {
      "type": "paragraph",
      "id": "94f370d9b7876fda",
      "text": "vermutlich hast du von [[CSS Module Scripts]] noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können"
    },
    {
      "type": "paragraph",
      "id": "c9d481a06561f819",
      "text": "und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildless aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von [[Vanilla Web]] zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird"
    },
    {
      "type": "paragraph",
      "id": "6d342443d18e4d9e",
      "text": "ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind"
    },
    {
      "type": "paragraph",
      "id": "3a7d65cb666b09d7",
      "text": "und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE"
    },
    {
      "type": "paragraph",
      "id": "9122d68c246bedc4",
      "text": "und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird"
    },
    {
      "type": "paragraph",
      "id": "c6c295fc09866cb9",
      "text": "und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns [https://www.thenativeweb.io/ www.thenativeweb.io] und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
    },
    {
      "type": "factory",
      "id": "7f2de72fe354544f"
    },
    {
      "type": "paragraph",
      "id": "3b5774f07ca524d2",
      "text": "dreyeck "
    },
    {
      "type": "code",
      "id": "29b04d259511d8d5",
      "text": "~/.wiki/hive.dreyeck.ch/pages"
    },
    {
      "type": "paragraph",
      "id": "5eae7588ecd77b81",
      "text": "is on branch main and up to date with 'origin/host', the branch I use on wiki.ralfbarkow.ch."
    },
    {
      "type": "markdown",
      "id": "90917c6f2482286c",
      "text": "`git push` gives us: The upstream branch of your current branch does not match the name of your current branch.  To push to the upstream branch on the remote, use\n\n    git push origin HEAD:host\n\nTo push to the branch of the same name on the remote, use\n\n    git push origin HEAD\n\nTo choose either option permanently, see push.default in 'git help config'.\n\nTo avoid automatically configuring upstream branches when their name doesn't match the local branch, see option 'simple' of branch.autoSetupMerge\nin 'git help config'."
    },
    {
      "type": "paragraph",
      "id": "acc9e6cea97b50b8",
      "text": "I used:"
    },
    {
      "type": "code",
      "id": "b23131b0b5f57ab3",
      "text": "git push origin HEAD"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2024-03-22",
        "story": []
      },
      "date": 1711093293744
    },
    {
      "item": {
        "type": "factory",
        "id": "f25e428c4ee6f31e"
      },
      "id": "f25e428c4ee6f31e",
      "type": "add",
      "date": 1711093296600
    },
    {
      "type": "edit",
      "id": "f25e428c4ee6f31e",
      "item": {
        "type": "paragraph",
        "id": "f25e428c4ee6f31e",
        "text": "[[Roster]]"
      },
      "date": 1711093304513
    },
    {
      "type": "edit",
      "id": "f25e428c4ee6f31e",
      "item": {
        "type": "paragraph",
        "id": "f25e428c4ee6f31e",
        "text": "⇐ [[Roster]] ⇒ [[Find Each Other]]"
      },
      "date": 1711093372430
    },
    {
      "item": {
        "type": "factory",
        "id": "72f5db823924ce19"
      },
      "id": "72f5db823924ce19",
      "type": "add",
      "after": "f25e428c4ee6f31e",
      "date": 1711093733013
    },
    {
      "type": "edit",
      "id": "72f5db823924ce19",
      "item": {
        "type": "image",
        "id": "72f5db823924ce19",
        "text": "New wiki with write access",
        "size": "wide",
        "width": 419,
        "height": 35,
        "url": "/assets/plugins/image/eba557d2b996973024685c49afcbd549.jpg"
      },
      "date": 1711093889915
    },
    {
      "item": {
        "type": "factory",
        "id": "ed83a130c24c571e"
      },
      "id": "ed83a130c24c571e",
      "type": "add",
      "after": "72f5db823924ce19",
      "date": 1711093930708
    },
    {
      "type": "edit",
      "id": "ed83a130c24c571e",
      "item": {
        "type": "image",
        "id": "ed83a130c24c571e",
        "text": "Uploaded image",
        "size": "wide",
        "width": 419,
        "height": 223,
        "url": "/assets/plugins/image/b8f1ae1d3f9325b1c5c5621cfb7121e2.jpg"
      },
      "date": 1711093956132
    },
    {
      "type": "edit",
      "id": "ed83a130c24c571e",
      "item": {
        "type": "image",
        "id": "ed83a130c24c571e",
        "text": "Goobi workflow",
        "size": "wide",
        "width": 419,
        "height": 223,
        "url": "/assets/plugins/image/b8f1ae1d3f9325b1c5c5621cfb7121e2.jpg"
      },
      "date": 1711093971060
    },
    {
      "item": {
        "type": "factory",
        "id": "f8c3d7f8fdc7bc45"
      },
      "id": "f8c3d7f8fdc7bc45",
      "type": "add",
      "after": "ed83a130c24c571e",
      "date": 1711093980703
    },
    {
      "type": "edit",
      "id": "f8c3d7f8fdc7bc45",
      "item": {
        "type": "paragraph",
        "id": "f8c3d7f8fdc7bc45",
        "text": "Goobi"
      },
      "date": 1711093982265
    },
    {
      "id": "f8c3d7f8fdc7bc45",
      "type": "move",
      "order": [
        "f25e428c4ee6f31e",
        "72f5db823924ce19",
        "f8c3d7f8fdc7bc45",
        "ed83a130c24c571e"
      ],
      "date": 1711093984710
    },
    {
      "type": "edit",
      "id": "f8c3d7f8fdc7bc45",
      "item": {
        "type": "paragraph",
        "id": "f8c3d7f8fdc7bc45",
        "text": "⇒ [[Goobi]]"
      },
      "date": 1711093997417
    },
    {
      "item": {
        "type": "factory",
        "id": "8ec693fcee1bd011"
      },
      "id": "8ec693fcee1bd011",
      "type": "add",
      "after": "ed83a130c24c571e",
      "date": 1711094019088
    },
    {
      "type": "edit",
      "id": "8ec693fcee1bd011",
      "item": {
        "type": "paragraph",
        "id": "8ec693fcee1bd011",
        "text": "~/Projects/RalfBarkow/goobi-workflow"
      },
      "date": 1711094020729
    },
    {
      "item": {
        "type": "factory",
        "id": "b95f5b101b77460c"
      },
      "id": "b95f5b101b77460c",
      "type": "add",
      "after": "8ec693fcee1bd011",
      "date": 1711095648102
    },
    {
      "type": "remove",
      "id": "b95f5b101b77460c",
      "date": 1711095656521
    },
    {
      "item": {
        "type": "factory",
        "id": "7532d8ce287a4211"
      },
      "id": "7532d8ce287a4211",
      "type": "add",
      "after": "8ec693fcee1bd011",
      "date": 1711095665909
    },
    {
      "id": "7532d8ce287a4211",
      "type": "move",
      "order": [
        "f25e428c4ee6f31e",
        "72f5db823924ce19",
        "7532d8ce287a4211",
        "f8c3d7f8fdc7bc45",
        "ed83a130c24c571e",
        "8ec693fcee1bd011"
      ],
      "date": 1711095670141
    },
    {
      "type": "edit",
      "id": "7532d8ce287a4211",
      "item": {
        "type": "paragraph",
        "id": "7532d8ce287a4211",
        "text": "Using default security - Wiki will be read-only"
      },
      "date": 1711096349459
    },
    {
      "type": "add",
      "id": "2613b11e3c231185",
      "item": {
        "type": "paragraph",
        "id": "2613b11e3c231185",
        "text": "and rejecting /page/welcome-visitors/action"
      },
      "after": "7532d8ce287a4211",
      "date": 1711096360032
    },
    {
      "type": "edit",
      "id": "72f5db823924ce19",
      "item": {
        "type": "image",
        "id": "72f5db823924ce19",
        "text": "New wiki with write access?",
        "size": "wide",
        "width": 419,
        "height": 35,
        "url": "/assets/plugins/image/eba557d2b996973024685c49afcbd549.jpg"
      },
      "date": 1711096374816
    },
    {
      "type": "edit",
      "id": "7532d8ce287a4211",
      "item": {
        "type": "paragraph",
        "id": "7532d8ce287a4211",
        "text": "Using default security – Wiki will be read-only"
      },
      "date": 1711096403909
    },
    {
      "type": "edit",
      "id": "7532d8ce287a4211",
      "item": {
        "type": "paragraph",
        "id": "7532d8ce287a4211",
        "text": "Using [[Default Security]] – Wiki will be read-only"
      },
      "date": 1711096469642
    },
    {
      "type": "add",
      "id": "3ec24b303cf7f314",
      "item": {
        "type": "paragraph",
        "id": "3ec24b303cf7f314",
        "text": "Online help in form of ghost pages. For example, if we click on wiki in case of a read-only wiki configuration, we should not get the checkmark set."
      },
      "after": "2613b11e3c231185",
      "date": 1711096640300
    },
    {
      "type": "edit",
      "id": "3ec24b303cf7f314",
      "item": {
        "type": "paragraph",
        "id": "3ec24b303cf7f314",
        "text": "Online help in the form of ghost pages. For example, if we click on wiki in a read-only wiki configuration, the checkmark should not be set."
      },
      "date": 1711096702161
    },
    {
      "type": "edit",
      "id": "3ec24b303cf7f314",
      "item": {
        "type": "paragraph",
        "id": "3ec24b303cf7f314",
        "text": "Online help in the form of ghost pages. For example, if we click on \"wiki\" in a read-only wiki configuration, the check mark should not be set, as shown in the following figure."
      },
      "date": 1711096750759
    },
    {
      "id": "3ec24b303cf7f314",
      "type": "move",
      "order": [
        "f25e428c4ee6f31e",
        "3ec24b303cf7f314",
        "72f5db823924ce19",
        "7532d8ce287a4211",
        "2613b11e3c231185",
        "f8c3d7f8fdc7bc45",
        "ed83a130c24c571e",
        "8ec693fcee1bd011"
      ],
      "date": 1711096752843
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1711097580849
    },
    {
      "type": "add",
      "id": "aa7529cc0e6330d9",
      "item": {
        "type": "paragraph",
        "id": "aa7529cc0e6330d9",
        "text": "See also [[Default security module]]"
      },
      "after": "2613b11e3c231185",
      "date": 1711098081962
    },
    {
      "item": {
        "type": "factory",
        "id": "df6acc89e78196c1"
      },
      "id": "df6acc89e78196c1",
      "type": "add",
      "after": "8ec693fcee1bd011",
      "date": 1711098271092
    },
    {
      "type": "edit",
      "id": "17c7765c3911a576",
      "item": {
        "type": "paragraph",
        "id": "17c7765c3911a576",
        "text": "Unable to update \"Snap Store\": cannot refresh \"snap-store\": snap \"snap-store\" has running apps (ubuntu-software)"
      },
      "date": 1711098280943
    },
    {
      "type": "edit",
      "id": "17c7765c3911a576",
      "item": {
        "type": "paragraph",
        "id": "17c7765c3911a576",
        "text": "Unable to update \"Snap Store\": cannot refresh \"snap-store\": snap \"snap-store\" has running apps (ubuntu-software) [https://askubuntu.com/questions/1411104/unable-to-update-snap-store-cannot-refresh-snap-store-snap-snap-store-ha page]"
      },
      "date": 1711098294082
    },
    {
      "type": "edit",
      "id": "17c7765c3911a576",
      "item": {
        "type": "paragraph",
        "id": "17c7765c3911a576",
        "text": "[[Ubuntu]]"
      },
      "date": 1711098309577
    },
    {
      "type": "add",
      "id": "4bb6465ef2802da0",
      "item": {
        "type": "paragraph",
        "id": "4bb6465ef2802da0",
        "text": "Unable to update \"Snap Store\": cannot refresh \"snap-store\": snap \"snap-store\" has running apps (ubuntu-software) [https://askubuntu.com/questions/1411104/unable-to-update-snap-store-cannot-refresh-snap-store-snap-snap-store-ha page]"
      },
      "after": "17c7765c3911a576",
      "date": 1711098313128
    },
    {
      "type": "edit",
      "id": "17c7765c3911a576",
      "item": {
        "type": "paragraph",
        "id": "17c7765c3911a576",
        "text": "⇒ [[Ubuntu]]"
      },
      "date": 1711098344023
    },
    {
      "type": "edit",
      "id": "4bb6465ef2802da0",
      "item": {
        "type": "paragraph",
        "id": "4bb6465ef2802da0",
        "text": "Unable to update \"[[Snap Store]]\": cannot refresh \"snap-store\": snap \"snap-store\" has running apps (ubuntu-software) [https://askubuntu.com/questions/1411104/unable-to-update-snap-store-cannot-refresh-snap-store-snap-snap-store-ha page]"
      },
      "date": 1711098361918
    },
    {
      "item": {
        "type": "factory",
        "id": "cccfaa77b3b7c363"
      },
      "id": "cccfaa77b3b7c363",
      "type": "add",
      "after": "4bb6465ef2802da0",
      "date": 1711098467088
    },
    {
      "type": "edit",
      "id": "cccfaa77b3b7c363",
      "item": {
        "type": "paragraph",
        "id": "cccfaa77b3b7c363",
        "text": "Learn more about Ubuntu Pro [https://ubuntu.com/pro page]"
      },
      "date": 1711098485536
    },
    {
      "type": "edit",
      "id": "cccfaa77b3b7c363",
      "item": {
        "type": "paragraph",
        "id": "cccfaa77b3b7c363",
        "text": "Learn more about Ubuntu Pro subscription [https://ubuntu.com/pro page]"
      },
      "date": 1711098527857
    },
    {
      "type": "edit",
      "id": "cccfaa77b3b7c363",
      "item": {
        "type": "paragraph",
        "id": "cccfaa77b3b7c363",
        "text": "Learn more about the Ubuntu Pro subscription. [https://ubuntu.com/pro page]"
      },
      "date": 1711098542555
    },
    {
      "type": "edit",
      "id": "cccfaa77b3b7c363",
      "item": {
        "type": "paragraph",
        "id": "cccfaa77b3b7c363",
        "text": "Learn more about the Ubuntu Pro [[Subscription]]. [https://ubuntu.com/pro page]"
      },
      "date": 1711098586723
    },
    {
      "item": {
        "type": "factory",
        "id": "615b4f719272a754"
      },
      "id": "615b4f719272a754",
      "type": "add",
      "after": "cccfaa77b3b7c363",
      "date": 1711098915000
    },
    {
      "type": "edit",
      "id": "615b4f719272a754",
      "item": {
        "type": "reference",
        "id": "615b4f719272a754",
        "site": "wiki.ralfbarkow.ch",
        "slug": "runtime",
        "title": "Runtime",
        "text": "[[Elm]] Runtime"
      },
      "date": 1711098922367
    },
    {
      "item": {
        "type": "factory",
        "id": "9424ccfeafe99d38"
      },
      "id": "9424ccfeafe99d38",
      "type": "add",
      "after": "615b4f719272a754",
      "date": 1711098925560
    },
    {
      "type": "edit",
      "id": "9424ccfeafe99d38",
      "item": {
        "type": "reference",
        "id": "9424ccfeafe99d38",
        "site": "eric.dojo.fed.wiki",
        "slug": "why-containers-work",
        "title": "Why Containers Work",
        "text": "Consistency.  And separation of concerns between configuration-time and run-time."
      },
      "date": 1711098965132
    },
    {
      "item": {
        "type": "factory",
        "id": "ad5250b0a474f2e8"
      },
      "id": "ad5250b0a474f2e8",
      "type": "add",
      "after": "9424ccfeafe99d38",
      "date": 1711098984006
    },
    {
      "item": {
        "type": "factory",
        "id": "e63dfe135d6ea440"
      },
      "id": "e63dfe135d6ea440",
      "type": "add",
      "after": "ad5250b0a474f2e8",
      "date": 1711098989929
    },
    {
      "type": "edit",
      "id": "e63dfe135d6ea440",
      "item": {
        "type": "paragraph",
        "id": "e63dfe135d6ea440",
        "text": "[[Docker]]"
      },
      "date": 1711098995392
    },
    {
      "type": "fork",
      "date": 1711099626351
    },
    {
      "type": "edit",
      "id": "df6acc89e78196c1",
      "item": {
        "type": "pagefold",
        "id": "df6acc89e78196c1",
        "text": "~"
      },
      "date": 1711099651973
    },
    {
      "id": "ad5250b0a474f2e8",
      "type": "move",
      "order": [
        "f25e428c4ee6f31e",
        "3ec24b303cf7f314",
        "72f5db823924ce19",
        "7532d8ce287a4211",
        "2613b11e3c231185",
        "aa7529cc0e6330d9",
        "f8c3d7f8fdc7bc45",
        "ed83a130c24c571e",
        "8ec693fcee1bd011",
        "df6acc89e78196c1",
        "17c7765c3911a576",
        "4bb6465ef2802da0",
        "cccfaa77b3b7c363",
        "615b4f719272a754",
        "9424ccfeafe99d38",
        "e63dfe135d6ea440",
        "ad5250b0a474f2e8"
      ],
      "date": 1711099661286
    },
    {
      "type": "edit",
      "id": "ad5250b0a474f2e8",
      "item": {
        "type": "paragraph",
        "id": "ad5250b0a474f2e8",
        "text": "[[WebSocket]]"
      },
      "date": 1711101470129
    },
    {
      "type": "edit",
      "id": "ad5250b0a474f2e8",
      "item": {
        "type": "paragraph",
        "id": "ad5250b0a474f2e8",
        "text": "[[WebSocket]] []"
      },
      "date": 1711101532984
    },
    {
      "type": "edit",
      "id": "ad5250b0a474f2e8",
      "item": {
        "type": "paragraph",
        "id": "ad5250b0a474f2e8",
        "text": "[[WebSocket]] [https://developer.mozilla.org/en-US/docs/Web/API/WebSocket msn]"
      },
      "date": 1711101555863
    },
    {
      "type": "add",
      "id": "8f2e5d09aeb5cf59",
      "item": {
        "type": "paragraph",
        "id": "8f2e5d09aeb5cf59",
        "text": "isomorphic-ws"
      },
      "after": "ad5250b0a474f2e8",
      "date": 1711101640884
    },
    {
      "type": "edit",
      "id": "8f2e5d09aeb5cf59",
      "item": {
        "type": "paragraph",
        "id": "8f2e5d09aeb5cf59",
        "text": "isomorphic-ws [https://www.npmjs.com/package/isomorphic-ws npm]"
      },
      "date": 1711101649467
    },
    {
      "type": "fork",
      "site": "wiki.ralfbarkow.ch",
      "date": 1711104729920
    },
    {
      "item": {
        "type": "factory",
        "id": "4a287d7868d8075a"
      },
      "id": "4a287d7868d8075a",
      "type": "add",
      "after": "8f2e5d09aeb5cf59",
      "date": 1711104729921
    },
    {
      "type": "edit",
      "id": "4a287d7868d8075a",
      "item": {
        "type": "paragraph",
        "id": "4a287d7868d8075a",
        "text": "[[Lit]]"
      },
      "date": 1711104735373
    },
    {
      "item": {
        "type": "factory",
        "id": "b9bbd8ddc8027964"
      },
      "id": "b9bbd8ddc8027964",
      "type": "add",
      "after": "4a287d7868d8075a",
      "date": 1711115450005
    },
    {
      "type": "edit",
      "id": "b9bbd8ddc8027964",
      "item": {
        "type": "video",
        "id": "b9bbd8ddc8027964",
        "text": "YOUTUBE https://youtu.be/cttpgBg6pDQ"
      },
      "date": 1711115463993
    },
    {
      "type": "edit",
      "id": "b9bbd8ddc8027964",
      "item": {
        "type": "video",
        "id": "b9bbd8ddc8027964",
        "text": "YOUTUBE cttpgBg6pDQ"
      },
      "date": 1711115525498
    },
    {
      "item": {
        "type": "factory",
        "id": "7f50ba6ab9897efb"
      },
      "id": "7f50ba6ab9897efb",
      "type": "add",
      "after": "b9bbd8ddc8027964",
      "date": 1711115567385
    },
    {
      "type": "edit",
      "id": "7f50ba6ab9897efb",
      "item": {
        "type": "paragraph",
        "id": "7f50ba6ab9897efb",
        "text": "stell dir vor du planst die Entwicklung einer neuen Web oder Cloud basierten Software und im Backend hast du alle zu verwendenen Technologien bereits entschieden nur im Frontend bist du dir noch nicht so ganz sicher solltest du eher auf einen der etablierten Platzhirsche setzen also auf ein Framework wie react angular oder vielleicht auch view oder solltest du dich eher für eines der neueren und kleineren Frameworks entscheiden wie z.B swelt oder solid JS und diese Frage die ist nicht nur nicht neu diese Frage Frage kennt vor allem auch keine richtige Antwort denn völlig egal für welches Framework du dich letztlich entscheidest du bindest dich immer das heißt du handelst dir immer einen vendor lockin ein und du hast zugleich aber nie die Garantie dass es das jeweilige Framework in ein paar Jahren auch tatsächlich noch geben wird dass es noch weiterentwickelt werden wird dass es noch gepflegt werden wird und so weiter und ein Königsweg wie man das Thema Web UI Entwicklung überhaupt angeht den scheint es auch nicht so wirklich zu geben denn sonst würde nicht gefühlt alle paar Wochen in komplett komplett neues Framework erscheinen und leider geht ja das nicht nur beim Framework so hinzu kommt nämlich noch eine ganze Reihe an Werkzeugen die du auch noch benötigst angefangen beim typescript Compiler über einen precompiler für SAS oder L in Verbindung mit einem Package Manager wie NPM oder yarn ein Bildtool wie z.B wieed vielleicht noch ein gesonderter Bandler und so weiter und so fort und wenn es dir dir da geht wie mir dann hast du auf diese Art der Webentwicklung schon lange keine Lust mehr und das alles wird gefühlt nicht besser sondern immer nur noch schlimmer ständig kommen neue Werkzeuge hinzu und die ganze Leichtigkeit die vor vielen Jahren mal typisch für die Webentwicklung war das ist leider inzwischen echt lange her und da stellt sich dann die Frage wo soll das denn alles noch hinführen wäre es nicht längst überfällig da mal inne zu halten und sich mal zu fragen ob wir nicht seit Jahren in eine gänzlich falsche Richtung laufen und wie man das ganze nicht vielleicht deutlich besser machen könnte und genau darum geht es heute in diesem Video in diesem Sinne hallo und herzlich willkommen zu unserem neuen weekly und by the way ein schönes und frohes neues Jahr ja und ich habe es gerade schon angesprochen Webentwicklung war mal anders Webentwicklung war mal leichtgewichtig da hat es genügt in dem Texteditor ein paar Zeichen zu ändern zu speichern im Webbrowser einmal neu zu laden und das war's und da war es völlig egal ob man da gerade HTML oder CSS oder Javascript bearbeitet hat alle drei Sprachen kamen ohne ein Compiler und ohne gesondertes tooling aus und das war damals so vor ungefähr 25 Jahren der große Unterschied zur desktopentwicklung wo man immer auf einen Compiler angewiesen war und daher auch immer entsprechend warten musste bevor man die Änderungen am Quellcode dann auch tatsächlich ausprobieren konnte und das war mal einer der Punkte die mich von Anfang an am Web fasziniert hatten diese auf das Wesentliche reduzierte Einfachheit und wenn ich mir das jetzt im Vergleich zu heute anschaue dann macht das inzwischen über überhaupt keinen Spaß mehr da kann man nicht einfach mal ein bisschen HTML schreiben sondern man braucht direkt jsx oder irgendeine andere Abstraktion für die man dann ein dedizierten precompiler benötigt der über NPM installiert werden muss wofür man dann wiederum noe braucht was man an seinerseits wiederum über den noe Version Manager NVM installieren sollte und das sind jetzt schon vier Technologien die man letztlich aber nur dafür braucht um HTML schreiben zu können und da haben wir noch nicht über CSS oder geschweige den JavaScript gesprochen und auch noch noch nicht über das ganze umgebende Ökosystem mit linting mit formatting mit testing und so weiter und um es kurz zu machen Frontend Web Entwicklung macht zumindest mir persönlich keinen wirklichen Spaß mehr ja und das traurige ist ganz vieles von dem was wir da heute alles veranstalten das wäre überhaupt nicht mehr notwendig weil das Web bzw die Webbrowser das meiste inzwischen nativ beherrschen wir haben und das ist eine echt bittere Erkenntnis in den vergangenen Jahren und Jahrzehnten vollkommen aus den Augen verloren warum wir all diese Frameworks und Werkzeuge überhaupt einsetzen und wir haben uns so sehr an die Tatsache gewöhnt dass wir sie einsetzen dass wir immer nur hinterfragen ob das gewählte Tool ob die gewählte Bibliothek ob das das richtige ist aber nie ob wir das Tool oder die Bibliothek an sich überhaupt noch brauchen und das ändert sich gerade bzw ich persönlich habe den Eindruck dass jetzt im Jahr 2024 genug momentum in diese Frage kommt dass sich weblung an Webentwicklung an sich in den nächsten 12 Monaten durchaus grundlegend verändern könnte und das Ergebnis davon könnte sein dass wir mit einem deutlich stabileren und vor allem langfristig auch mit einem deutlich verlässlicheren technologiestck aus der ganzen Sache hinausgehen können und wie das aussehen könnte das möchte ich Dir jetzt im Folgenden mal kurz skizzieren wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements ein Custom Element ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML Komponente zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann Shadow Dom und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS na ja und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir aber zum Glück gibt es für webcomponents ganz gute Abstraktionen die das ganze deutlich zugänglicher machen und da fällt mir persönlich z.B das Framework lit ein das wir auch schon einmal in einem unserer Livestreams in Aktion erlebt haben und falls du den damals nicht gesehen hast dann findest du den Link dorthin noch einmal hier oben in der infocard da magst Du natürlich nun auch einwenden dass das doch irgendwie nicht der Sinn der Sache sei weil man damit ja doch wieder auf ein Framework setzen würde und das ist auch erstmal durchaus richtig aber anders als bei react angular und Co schreibt man mit Lid eben keine Komponenten die dann wieder nur mit dem jeweiligen Framework funktionieren sondern man schafft eine algemeingültige Komponente die mit allen Frameworks oder eben auch ganz ohne Framework Lauf ist weil sie nativ im Browser läuft und das finde ich persönlich schon mal deutlich besser nun hatte ich ja anfangs erwähnt dass mich der bildschritt stört und wenn wir nun auf LD als Framework setzen dann haben wir natürlich wieder einen bildschritt das ist das zumindest was ich bis vor kurzem gedacht habe aber dem ist gar nicht so LD kann nämlich komplett zur Laufzeit ausgeführt werden das heißt ich muss keinen Compiler benutzen und das macht das Ganze direkt viel angenehmer noch angenehmer wird es übrigens wenn man feststellt dass man LD dazu noch nicht mal über NPM installieren muss sondern das einfach per Import aus einem CDN laden kann und wenn du da nun wiederum sagst das sei doch blöd weil man dann wieder überall von Versionsnummern in der Import URL Abhänge dann stimmt das außer du verwendest eine sogenannte Import map was übrigens ein weiteres Feature von modernen Browsern ist was einfach so da ist mit so einer Import Map kannst du nämlich ein einziges Mal zentral festlegen dass es z.B einen Import namens lit geben soll und auf welche URL der dann aufgelöst werden soll und danach arbeitest du einfach in jedem deiner Skripte mit LD als wäre es lokal über NPM installiert und die Version kontrollierst du zentral über die Import Map Problem gelöst komplett ohne NPM und vor allem ohne bildschritt und das ganze funktioniert dank der Möglichkeit seit ein paar Jahren Javascript Code dynamisch zur Laufzeit als cmascriptmodul einfach so Nachladen zu können und da kann man natürlich auch wieder sagen das ist doch aber völlig unpraktikabel denn dann besteht meine Anwendung ja nachher aus zahlreichen ganz vielen kleinen einzelnen Dateien und das produziert ganz viel HTTP Overhead beim Laden und auch da stimme ich Dir grundsätzlich zu aber die Frage ist doch wie schlimm ist das denn wirklich also kommt es bei der Webseite od der Webanwendung die du baust wirklich auf jede nano oder Millisekunde an oder ist das eigentlich eher egal und da wird es sicherlich Fälle geben in denen das z.B wegen SEO ultra wichtig ist das mit wenigen requests alles möglichst schnell geladen wird es wird aber auch Fälle geben in denen das völlig egal ist weil die Anwendung z.B gar nicht public facing sind sondern ohnehin nur in einer privaten Gruppe privaten Anwenderinnen und Anwendern zur Verfügung gestellt werden wo das Ganze gar nicht so entscheidend ist z.B im Intranet zumindest könnte man über diese Unterscheidung ja mal nachdenken das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das Sch ist das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules vermutlich hast du von CSS Module Scripts noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "date": 1711115570826
    },
    {
      "type": "edit",
      "id": "b9bbd8ddc8027964",
      "item": {
        "type": "video",
        "id": "b9bbd8ddc8027964",
        "text": "YOUTUBE cttpgBg6pDQ\nVanilla Web: Der Frontend-Trend für 2024?"
      },
      "date": 1711115595225
    },
    {
      "type": "edit",
      "id": "7f50ba6ab9897efb",
      "item": {
        "type": "paragraph",
        "id": "7f50ba6ab9897efb",
        "text": "stell dir vor du planst die Entwicklung einer neuen Web oder Cloud basierten Software und im Backend hast du alle zu verwendenen Technologien bereits entschieden nur im Frontend bist du dir noch nicht so ganz sicher solltest du eher auf einen der etablierten Platzhirsche setzen also auf ein Framework wie react angular oder vielleicht auch view oder solltest du dich eher für eines der neueren und kleineren Frameworks entscheiden wie z.B swelt oder solid JS und diese Frage die ist nicht nur nicht neu diese Frage Frage kennt vor allem auch keine richtige Antwort denn völlig egal für welches Framework du dich letztlich entscheidest du bindest dich immer das heißt du handelst dir immer einen vendor lockin ein und du hast zugleich aber nie die Garantie dass es das jeweilige Framework in ein paar Jahren auch tatsächlich noch geben wird dass es noch weiterentwickelt werden wird dass es noch gepflegt werden wird und so weiter und ein Königsweg wie man das Thema Web UI Entwicklung überhaupt angeht den scheint es auch nicht so wirklich zu geben denn sonst würde nicht gefühlt alle paar Wochen in komplett komplett neues Framework erscheinen und leider geht ja das nicht nur beim Framework so hinzu kommt nämlich noch eine ganze Reihe an Werkzeugen die du auch noch benötigst angefangen beim typescript Compiler über einen precompiler für SAS oder L in Verbindung mit einem Package Manager wie NPM oder yarn ein Bildtool wie z.B wieed vielleicht noch ein gesonderter Bandler und so weiter und so fort und wenn es dir dir da geht wie mir dann hast du auf diese Art der Webentwicklung schon lange keine Lust mehr und das alles wird gefühlt nicht besser sondern immer nur noch schlimmer ständig kommen neue Werkzeuge hinzu und die ganze Leichtigkeit die vor vielen Jahren mal typisch für die Webentwicklung war das ist leider inzwischen echt lange her und da stellt sich dann die Frage wo soll das denn alles noch hinführen wäre es nicht längst überfällig da mal inne zu halten und sich mal zu fragen ob wir nicht seit Jahren in eine gänzlich falsche Richtung laufen und wie man das ganze nicht vielleicht deutlich besser machen könnte und genau darum geht es heute in diesem Video in diesem Sinne hallo und herzlich willkommen zu unserem neuen weekly und by the way ein schönes und frohes neues Jahr ja und ich habe es gerade schon angesprochen Webentwicklung war mal anders Webentwicklung war mal leichtgewichtig da hat es genügt in dem Texteditor ein paar Zeichen zu ändern zu speichern im Webbrowser einmal neu zu laden und das war's und da war es völlig egal ob man da gerade HTML oder CSS oder Javascript bearbeitet hat alle drei Sprachen kamen ohne ein Compiler und ohne gesondertes tooling aus und das war damals so vor ungefähr 25 Jahren der große Unterschied zur desktopentwicklung wo man immer auf einen Compiler angewiesen war und daher auch immer entsprechend warten musste bevor man die Änderungen am Quellcode dann auch tatsächlich ausprobieren konnte und das war mal einer der Punkte die mich von Anfang an am Web fasziniert hatten diese auf das Wesentliche reduzierte Einfachheit und wenn ich mir das jetzt im Vergleich zu heute anschaue dann macht das inzwischen über überhaupt keinen Spaß mehr da kann man nicht einfach mal ein bisschen HTML schreiben sondern man braucht direkt jsx oder irgendeine andere Abstraktion für die man dann ein dedizierten precompiler benötigt der über NPM installiert werden muss wofür man dann wiederum noe braucht was man an seinerseits wiederum über den noe Version Manager NVM installieren sollte und das sind jetzt schon vier Technologien die man letztlich aber nur dafür braucht um HTML schreiben zu können und da haben wir noch nicht über CSS oder geschweige den JavaScript gesprochen und auch noch noch nicht über das ganze umgebende Ökosystem mit linting mit formatting mit testing und so weiter und um es kurz zu machen Frontend Web Entwicklung macht zumindest mir persönlich keinen wirklichen Spaß mehr ja und das traurige ist ganz vieles von dem was wir da heute alles veranstalten das wäre überhaupt nicht mehr notwendig weil das Web bzw die Webbrowser das meiste inzwischen nativ beherrschen wir haben und das ist eine echt bittere Erkenntnis in den vergangenen Jahren und Jahrzehnten vollkommen aus den Augen verloren warum wir all diese Frameworks und Werkzeuge überhaupt einsetzen und wir haben uns so sehr an die Tatsache gewöhnt dass wir sie einsetzen dass wir immer nur hinterfragen ob das gewählte Tool ob die gewählte Bibliothek ob das das richtige ist aber nie ob wir das Tool oder die Bibliothek an sich überhaupt noch brauchen und das ändert sich gerade bzw ich persönlich habe den Eindruck dass jetzt im Jahr 2024 genug momentum in diese Frage kommt dass sich weblung an Webentwicklung an sich in den nächsten 12 Monaten durchaus grundlegend verändern könnte und das Ergebnis davon könnte sein dass wir mit einem deutlich stabileren und vor allem langfristig auch mit einem deutlich verlässlicheren technologiestck aus der ganzen Sache hinausgehen können und wie das aussehen könnte das möchte ich Dir jetzt im Folgenden mal kurz skizzieren wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements ein Custom Element ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML Komponente zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann Shadow Dom und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS na ja und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "date": 1711115747919
    },
    {
      "type": "add",
      "id": "1f733ef5ef47e3ac",
      "item": {
        "type": "paragraph",
        "id": "1f733ef5ef47e3ac",
        "text": "aber zum Glück gibt es für webcomponents ganz gute Abstraktionen die das ganze deutlich zugänglicher machen und da fällt mir persönlich z.B das Framework lit ein das wir auch schon einmal in einem unserer Livestreams in Aktion erlebt haben und falls du den damals nicht gesehen hast dann findest du den Link dorthin noch einmal hier oben in der infocard da magst Du natürlich nun auch einwenden dass das doch irgendwie nicht der Sinn der Sache sei weil man damit ja doch wieder auf ein Framework setzen würde und das ist auch erstmal durchaus richtig aber anders als bei react angular und Co schreibt man mit Lid eben keine Komponenten die dann wieder nur mit dem jeweiligen Framework funktionieren sondern man schafft eine algemeingültige Komponente die mit allen Frameworks oder eben auch ganz ohne Framework Lauf ist weil sie nativ im Browser läuft und das finde ich persönlich schon mal deutlich besser nun hatte ich ja anfangs erwähnt dass mich der bildschritt stört und wenn wir nun auf LD als Framework setzen dann haben wir natürlich wieder einen bildschritt das ist das zumindest was ich bis vor kurzem gedacht habe aber dem ist gar nicht so LD kann nämlich komplett zur Laufzeit ausgeführt werden das heißt ich muss keinen Compiler benutzen und das macht das Ganze direkt viel angenehmer noch angenehmer wird es übrigens wenn man feststellt dass man LD dazu noch nicht mal über NPM installieren muss sondern das einfach per Import aus einem CDN laden kann und wenn du da nun wiederum sagst das sei doch blöd weil man dann wieder überall von Versionsnummern in der Import URL Abhänge dann stimmt das außer du verwendest eine sogenannte Import map was übrigens ein weiteres Feature von modernen Browsern ist was einfach so da ist mit so einer Import Map kannst du nämlich ein einziges Mal zentral festlegen dass es z.B einen Import namens lit geben soll und auf welche URL der dann aufgelöst werden soll und danach arbeitest du einfach in jedem deiner Skripte mit LD als wäre es lokal über NPM installiert und die Version kontrollierst du zentral über die Import Map Problem gelöst komplett ohne NPM und vor allem ohne bildschritt und das ganze funktioniert dank der Möglichkeit seit ein paar Jahren Javascript Code dynamisch zur Laufzeit als cmascriptmodul einfach so Nachladen zu können und da kann man natürlich auch wieder sagen das ist doch aber völlig unpraktikabel denn dann besteht meine Anwendung ja nachher aus zahlreichen ganz vielen kleinen einzelnen Dateien und das produziert ganz viel HTTP Overhead beim Laden und auch da stimme ich Dir grundsätzlich zu aber die Frage ist doch wie schlimm ist das denn wirklich also kommt es bei der Webseite od der Webanwendung die du baust wirklich auf jede nano oder Millisekunde an oder ist das eigentlich eher egal und da wird es sicherlich Fälle geben in denen das z.B wegen SEO ultra wichtig ist das mit wenigen requests alles möglichst schnell geladen wird es wird aber auch Fälle geben in denen das völlig egal ist weil die Anwendung z.B gar nicht public facing sind sondern ohnehin nur in einer privaten Gruppe privaten Anwenderinnen und Anwendern zur Verfügung gestellt werden wo das Ganze gar nicht so entscheidend ist z.B im Intranet zumindest könnte man über diese Unterscheidung ja mal nachdenken das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das Sch ist das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules vermutlich hast du von CSS Module Scripts noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "7f50ba6ab9897efb",
      "date": 1711115757074
    },
    {
      "type": "edit",
      "id": "7f50ba6ab9897efb",
      "item": {
        "type": "paragraph",
        "id": "7f50ba6ab9897efb",
        "text": "stell dir vor du planst die Entwicklung einer neuen Web oder Cloud basierten Software und im Backend hast du alle zu verwendenen Technologien bereits entschieden nur im Frontend bist du dir noch nicht so ganz sicher solltest du eher auf einen der etablierten Platzhirsche setzen also auf ein Framework wie react angular oder vielleicht auch view oder solltest du dich eher für eines der neueren und kleineren Frameworks entscheiden wie z.B swelt oder solid JS und diese Frage die ist nicht nur nicht neu diese Frage Frage kennt vor allem auch keine richtige Antwort denn völlig egal für welches Framework du dich letztlich entscheidest du bindest dich immer das heißt du handelst dir immer einen vendor lockin ein und du hast zugleich aber nie die Garantie dass es das jeweilige Framework in ein paar Jahren auch tatsächlich noch geben wird dass es noch weiterentwickelt werden wird dass es noch gepflegt werden wird und so weiter"
      },
      "date": 1711116021371
    },
    {
      "type": "add",
      "id": "6c9f33b1df1dc362",
      "item": {
        "type": "paragraph",
        "id": "6c9f33b1df1dc362",
        "text": "und ein Königsweg wie man das Thema Web UI Entwicklung überhaupt angeht den scheint es auch nicht so wirklich zu geben denn sonst würde nicht gefühlt alle paar Wochen in komplett komplett neues Framework erscheinen und leider geht ja das nicht nur beim Framework so hinzu kommt nämlich noch eine ganze Reihe an Werkzeugen die du auch noch benötigst angefangen beim typescript Compiler über einen precompiler für SAS oder L in Verbindung mit einem Package Manager wie NPM oder yarn ein Bildtool wie z.B wieed vielleicht noch ein gesonderter Bandler und so weiter und so fort und wenn es dir dir da geht wie mir dann hast du auf diese Art der Webentwicklung schon lange keine Lust mehr und das alles wird gefühlt nicht besser sondern immer nur noch schlimmer ständig kommen neue Werkzeuge hinzu und die ganze Leichtigkeit die vor vielen Jahren mal typisch für die Webentwicklung war das ist leider inzwischen echt lange her und da stellt sich dann die Frage wo soll das denn alles noch hinführen wäre es nicht längst überfällig da mal inne zu halten und sich mal zu fragen ob wir nicht seit Jahren in eine gänzlich falsche Richtung laufen und wie man das ganze nicht vielleicht deutlich besser machen könnte und genau darum geht es heute in diesem Video in diesem Sinne hallo und herzlich willkommen zu unserem neuen weekly und by the way ein schönes und frohes neues Jahr ja und ich habe es gerade schon angesprochen Webentwicklung war mal anders Webentwicklung war mal leichtgewichtig da hat es genügt in dem Texteditor ein paar Zeichen zu ändern zu speichern im Webbrowser einmal neu zu laden und das war's und da war es völlig egal ob man da gerade HTML oder CSS oder Javascript bearbeitet hat alle drei Sprachen kamen ohne ein Compiler und ohne gesondertes tooling aus und das war damals so vor ungefähr 25 Jahren der große Unterschied zur desktopentwicklung wo man immer auf einen Compiler angewiesen war und daher auch immer entsprechend warten musste bevor man die Änderungen am Quellcode dann auch tatsächlich ausprobieren konnte und das war mal einer der Punkte die mich von Anfang an am Web fasziniert hatten diese auf das Wesentliche reduzierte Einfachheit und wenn ich mir das jetzt im Vergleich zu heute anschaue dann macht das inzwischen über überhaupt keinen Spaß mehr da kann man nicht einfach mal ein bisschen HTML schreiben sondern man braucht direkt jsx oder irgendeine andere Abstraktion für die man dann ein dedizierten precompiler benötigt der über NPM installiert werden muss wofür man dann wiederum noe braucht was man an seinerseits wiederum über den noe Version Manager NVM installieren sollte und das sind jetzt schon vier Technologien die man letztlich aber nur dafür braucht um HTML schreiben zu können und da haben wir noch nicht über CSS oder geschweige den JavaScript gesprochen und auch noch noch nicht über das ganze umgebende Ökosystem mit linting mit formatting mit testing und so weiter und um es kurz zu machen Frontend Web Entwicklung macht zumindest mir persönlich keinen wirklichen Spaß mehr ja und das traurige ist ganz vieles von dem was wir da heute alles veranstalten das wäre überhaupt nicht mehr notwendig weil das Web bzw die Webbrowser das meiste inzwischen nativ beherrschen wir haben und das ist eine echt bittere Erkenntnis in den vergangenen Jahren und Jahrzehnten vollkommen aus den Augen verloren warum wir all diese Frameworks und Werkzeuge überhaupt einsetzen und wir haben uns so sehr an die Tatsache gewöhnt dass wir sie einsetzen dass wir immer nur hinterfragen ob das gewählte Tool ob die gewählte Bibliothek ob das das richtige ist aber nie ob wir das Tool oder die Bibliothek an sich überhaupt noch brauchen und das ändert sich gerade bzw ich persönlich habe den Eindruck dass jetzt im Jahr 2024 genug momentum in diese Frage kommt dass sich weblung an Webentwicklung an sich in den nächsten 12 Monaten durchaus grundlegend verändern könnte und das Ergebnis davon könnte sein dass wir mit einem deutlich stabileren und vor allem langfristig auch mit einem deutlich verlässlicheren technologiestck aus der ganzen Sache hinausgehen können und wie das aussehen könnte das möchte ich Dir jetzt im Folgenden mal kurz skizzieren wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements ein Custom Element ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML Komponente zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann Shadow Dom und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS na ja und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "after": "7f50ba6ab9897efb",
      "date": 1711116022510
    },
    {
      "type": "edit",
      "id": "6c9f33b1df1dc362",
      "item": {
        "type": "paragraph",
        "id": "6c9f33b1df1dc362",
        "text": "und ein Königsweg wie man das Thema Web UI Entwicklung überhaupt angeht den scheint es auch nicht so wirklich zu geben denn sonst würde nicht gefühlt alle paar Wochen in komplett komplett neues Framework erscheinen und leider geht ja das nicht nur beim Framework so hinzu kommt nämlich noch eine ganze Reihe an Werkzeugen die du auch noch benötigst angefangen beim typescript Compiler über einen precompiler für SAS oder L in Verbindung mit einem Package Manager wie NPM oder yarn ein Bildtool wie z.B wieed vielleicht noch ein gesonderter Bandler und so weiter und so fort und wenn es dir dir da geht wie mir dann hast du auf diese Art der Webentwicklung schon lange keine Lust mehr und das alles wird gefühlt nicht besser sondern immer nur noch schlimmer ständig kommen neue Werkzeuge hinzu und die ganze [[Leichtigkeit]] die vor vielen Jahren mal typisch für die Webentwicklung war das ist leider inzwischen echt lange her und da stellt sich dann die Frage wo soll das denn alles noch hinführen wäre es nicht längst überfällig da mal inne zu halten und sich mal zu fragen ob wir nicht seit Jahren in eine gänzlich falsche Richtung laufen und wie man das ganze nicht vielleicht deutlich besser machen könnte und genau darum geht es heute in diesem Video in diesem Sinne hallo und herzlich willkommen zu unserem neuen weekly und by the way ein schönes und frohes neues Jahr ja und ich habe es gerade schon angesprochen Webentwicklung war mal anders Webentwicklung war mal leichtgewichtig da hat es genügt in dem Texteditor ein paar Zeichen zu ändern zu speichern im Webbrowser einmal neu zu laden und das war's und da war es völlig egal ob man da gerade HTML oder CSS oder Javascript bearbeitet hat alle drei Sprachen kamen ohne ein Compiler und ohne gesondertes tooling aus und das war damals so vor ungefähr 25 Jahren der große Unterschied zur desktopentwicklung wo man immer auf einen Compiler angewiesen war und daher auch immer entsprechend warten musste bevor man die Änderungen am Quellcode dann auch tatsächlich ausprobieren konnte und das war mal einer der Punkte die mich von Anfang an am Web fasziniert hatten diese auf das Wesentliche reduzierte Einfachheit und wenn ich mir das jetzt im Vergleich zu heute anschaue dann macht das inzwischen über überhaupt keinen Spaß mehr da kann man nicht einfach mal ein bisschen HTML schreiben sondern man braucht direkt jsx oder irgendeine andere Abstraktion für die man dann ein dedizierten precompiler benötigt der über NPM installiert werden muss wofür man dann wiederum noe braucht was man an seinerseits wiederum über den noe Version Manager NVM installieren sollte und das sind jetzt schon vier Technologien die man letztlich aber nur dafür braucht um HTML schreiben zu können und da haben wir noch nicht über CSS oder geschweige den JavaScript gesprochen und auch noch noch nicht über das ganze umgebende Ökosystem mit linting mit formatting mit testing und so weiter und um es kurz zu machen Frontend Web Entwicklung macht zumindest mir persönlich keinen wirklichen Spaß mehr ja und das traurige ist ganz vieles von dem was wir da heute alles veranstalten das wäre überhaupt nicht mehr notwendig weil das Web bzw die Webbrowser das meiste inzwischen nativ beherrschen wir haben und das ist eine echt bittere Erkenntnis in den vergangenen Jahren und Jahrzehnten vollkommen aus den Augen verloren warum wir all diese Frameworks und Werkzeuge überhaupt einsetzen und wir haben uns so sehr an die Tatsache gewöhnt dass wir sie einsetzen dass wir immer nur hinterfragen ob das gewählte Tool ob die gewählte Bibliothek ob das das richtige ist aber nie ob wir das Tool oder die Bibliothek an sich überhaupt noch brauchen und das ändert sich gerade bzw ich persönlich habe den Eindruck dass jetzt im Jahr 2024 genug momentum in diese Frage kommt dass sich weblung an Webentwicklung an sich in den nächsten 12 Monaten durchaus grundlegend verändern könnte und das Ergebnis davon könnte sein dass wir mit einem deutlich stabileren und vor allem langfristig auch mit einem deutlich verlässlicheren technologiestck aus der ganzen Sache hinausgehen können und wie das aussehen könnte das möchte ich Dir jetzt im Folgenden mal kurz skizzieren wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements ein Custom Element ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML Komponente zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann Shadow Dom und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS na ja und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "date": 1711116089129
    },
    {
      "type": "edit",
      "id": "6c9f33b1df1dc362",
      "item": {
        "type": "paragraph",
        "id": "6c9f33b1df1dc362",
        "text": "und ein Königsweg wie man das Thema Web UI Entwicklung überhaupt angeht den scheint es auch nicht so wirklich zu geben denn sonst würde nicht gefühlt alle paar Wochen in komplett komplett neues Framework erscheinen und leider geht ja das nicht nur beim Framework so hinzu kommt nämlich noch eine ganze Reihe an Werkzeugen die du auch noch benötigst angefangen beim typescript Compiler über einen precompiler für SAS oder L in Verbindung mit einem Package Manager wie NPM oder yarn ein Bildtool wie z.B wieed vielleicht noch ein gesonderter Bandler und so weiter und so fort und wenn es dir dir da geht wie mir dann hast du auf diese Art der Webentwicklung schon lange keine Lust mehr und das alles wird gefühlt nicht besser sondern immer nur noch schlimmer ständig kommen neue Werkzeuge hinzu und die ganze [[Leichtigkeit]] die vor vielen Jahren mal typisch für die Webentwicklung war das ist leider inzwischen echt lange her und da stellt sich dann die Frage wo soll das denn alles noch hinführen wäre es nicht längst überfällig da mal inne zu halten und sich mal zu fragen ob wir nicht seit Jahren in eine gänzlich falsche Richtung laufen und wie man das ganze nicht vielleicht deutlich besser machen könnte und genau darum geht es heute in diesem Video in diesem Sinne hallo und herzlich willkommen zu unserem neuen weekly und by the way ein schönes und frohes neues Jahr"
      },
      "date": 1711116128132
    },
    {
      "type": "add",
      "id": "218e4cb625b80184",
      "item": {
        "type": "paragraph",
        "id": "218e4cb625b80184",
        "text": "ja und ich habe es gerade schon angesprochen Webentwicklung war mal anders Webentwicklung war mal leichtgewichtig da hat es genügt in dem Texteditor ein paar Zeichen zu ändern zu speichern im Webbrowser einmal neu zu laden und das war's und da war es völlig egal ob man da gerade HTML oder CSS oder Javascript bearbeitet hat alle drei Sprachen kamen ohne ein Compiler und ohne gesondertes tooling aus und das war damals so vor ungefähr 25 Jahren der große Unterschied zur desktopentwicklung wo man immer auf einen Compiler angewiesen war und daher auch immer entsprechend warten musste bevor man die Änderungen am Quellcode dann auch tatsächlich ausprobieren konnte und das war mal einer der Punkte die mich von Anfang an am Web fasziniert hatten diese auf das Wesentliche reduzierte Einfachheit und wenn ich mir das jetzt im Vergleich zu heute anschaue dann macht das inzwischen über überhaupt keinen Spaß mehr da kann man nicht einfach mal ein bisschen HTML schreiben sondern man braucht direkt jsx oder irgendeine andere Abstraktion für die man dann ein dedizierten precompiler benötigt der über NPM installiert werden muss wofür man dann wiederum noe braucht was man an seinerseits wiederum über den noe Version Manager NVM installieren sollte und das sind jetzt schon vier Technologien die man letztlich aber nur dafür braucht um HTML schreiben zu können und da haben wir noch nicht über CSS oder geschweige den JavaScript gesprochen und auch noch noch nicht über das ganze umgebende Ökosystem mit linting mit formatting mit testing und so weiter und um es kurz zu machen Frontend Web Entwicklung macht zumindest mir persönlich keinen wirklichen Spaß mehr ja und das traurige ist ganz vieles von dem was wir da heute alles veranstalten das wäre überhaupt nicht mehr notwendig weil das Web bzw die Webbrowser das meiste inzwischen nativ beherrschen wir haben und das ist eine echt bittere Erkenntnis in den vergangenen Jahren und Jahrzehnten vollkommen aus den Augen verloren warum wir all diese Frameworks und Werkzeuge überhaupt einsetzen und wir haben uns so sehr an die Tatsache gewöhnt dass wir sie einsetzen dass wir immer nur hinterfragen ob das gewählte Tool ob die gewählte Bibliothek ob das das richtige ist aber nie ob wir das Tool oder die Bibliothek an sich überhaupt noch brauchen und das ändert sich gerade bzw ich persönlich habe den Eindruck dass jetzt im Jahr 2024 genug momentum in diese Frage kommt dass sich weblung an Webentwicklung an sich in den nächsten 12 Monaten durchaus grundlegend verändern könnte und das Ergebnis davon könnte sein dass wir mit einem deutlich stabileren und vor allem langfristig auch mit einem deutlich verlässlicheren technologiestck aus der ganzen Sache hinausgehen können und wie das aussehen könnte das möchte ich Dir jetzt im Folgenden mal kurz skizzieren wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements ein Custom Element ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML Komponente zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann Shadow Dom und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS na ja und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "after": "6c9f33b1df1dc362",
      "date": 1711116128778
    },
    {
      "type": "edit",
      "id": "218e4cb625b80184",
      "item": {
        "type": "paragraph",
        "id": "218e4cb625b80184",
        "text": "ja und ich habe es gerade schon angesprochen Webentwicklung war mal anders Webentwicklung war mal leichtgewichtig da hat es genügt in dem Texteditor ein paar Zeichen zu ändern zu speichern im Webbrowser einmal neu zu laden und das war's und da war es völlig egal ob man da gerade HTML oder CSS oder Javascript bearbeitet hat alle drei Sprachen kamen ohne ein [[Compiler]] und ohne gesondertes tooling aus und das war damals so vor ungefähr 25 Jahren der große Unterschied zur desktopentwicklung wo man immer auf einen Compiler angewiesen war und daher auch immer entsprechend warten musste bevor man die Änderungen am Quellcode dann auch tatsächlich ausprobieren konnte und das war mal einer der Punkte die mich von Anfang an am Web fasziniert hatten diese auf das Wesentliche reduzierte Einfachheit und wenn ich mir das jetzt im Vergleich zu heute anschaue dann macht das inzwischen über überhaupt keinen Spaß mehr da kann man nicht einfach mal ein bisschen HTML schreiben sondern man braucht direkt jsx oder irgendeine andere Abstraktion für die man dann ein dedizierten precompiler benötigt der über NPM installiert werden muss wofür man dann wiederum noe braucht was man an seinerseits wiederum über den noe Version Manager NVM installieren sollte und das sind jetzt schon vier Technologien die man letztlich aber nur dafür braucht um HTML schreiben zu können und da haben wir noch nicht über CSS oder geschweige den JavaScript gesprochen und auch noch noch nicht über das ganze umgebende Ökosystem mit linting mit formatting mit testing und so weiter und um es kurz zu machen Frontend Web Entwicklung macht zumindest mir persönlich keinen wirklichen Spaß mehr ja und das traurige ist ganz vieles von dem was wir da heute alles veranstalten das wäre überhaupt nicht mehr notwendig weil das Web bzw die Webbrowser das meiste inzwischen nativ beherrschen wir haben und das ist eine echt bittere Erkenntnis in den vergangenen Jahren und Jahrzehnten vollkommen aus den Augen verloren warum wir all diese Frameworks und Werkzeuge überhaupt einsetzen und wir haben uns so sehr an die Tatsache gewöhnt dass wir sie einsetzen dass wir immer nur hinterfragen ob das gewählte Tool ob die gewählte Bibliothek ob das das richtige ist aber nie ob wir das Tool oder die Bibliothek an sich überhaupt noch brauchen und das ändert sich gerade bzw ich persönlich habe den Eindruck dass jetzt im Jahr 2024 genug momentum in diese Frage kommt dass sich weblung an Webentwicklung an sich in den nächsten 12 Monaten durchaus grundlegend verändern könnte und das Ergebnis davon könnte sein dass wir mit einem deutlich stabileren und vor allem langfristig auch mit einem deutlich verlässlicheren technologiestck aus der ganzen Sache hinausgehen können und wie das aussehen könnte das möchte ich Dir jetzt im Folgenden mal kurz skizzieren wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements ein Custom Element ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML Komponente zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann Shadow Dom und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS na ja und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "date": 1711116261700
    },
    {
      "type": "edit",
      "id": "218e4cb625b80184",
      "item": {
        "type": "paragraph",
        "id": "218e4cb625b80184",
        "text": "ja und ich habe es gerade schon angesprochen Webentwicklung war mal anders Webentwicklung war mal leichtgewichtig da hat es genügt in dem Texteditor ein paar Zeichen zu ändern zu speichern im Webbrowser einmal neu zu laden und das war's und da war es völlig egal ob man da gerade HTML oder CSS oder Javascript bearbeitet hat alle drei Sprachen kamen ohne ein [[Compiler]] und ohne gesondertes tooling aus und das war damals so vor ungefähr 25 Jahren der große Unterschied zur desktopentwicklung wo man immer auf einen Compiler angewiesen war und daher auch immer entsprechend warten musste bevor man die Änderungen am Quellcode dann auch tatsächlich ausprobieren konnte und das war mal einer der Punkte die mich von Anfang an am Web fasziniert hatten diese auf das Wesentliche reduzierte Einfachheit und wenn ich mir das jetzt im Vergleich zu heute anschaue dann macht das inzwischen über überhaupt keinen Spaß mehr da kann man nicht einfach mal ein bisschen HTML schreiben sondern man braucht direkt jsx oder irgendeine andere Abstraktion für die man dann ein dedizierten precompiler benötigt der über NPM installiert werden muss wofür man dann wiederum noe braucht was man an seinerseits wiederum über den noe Version Manager NVM installieren sollte und das sind jetzt schon vier Technologien die man letztlich aber nur dafür braucht um HTML schreiben zu können und da haben wir noch nicht über CSS oder geschweige den JavaScript gesprochen und auch noch noch nicht über das ganze umgebende Ökosystem mit linting mit formatting mit testing und so weiter und um es kurz zu machen Frontend Web Entwicklung macht zumindest mir persönlich keinen wirklichen Spaß mehr ja und das traurige ist ganz vieles von dem was wir da heute alles veranstalten das wäre überhaupt nicht mehr notwendig weil das Web bzw die Webbrowser das meiste inzwischen nativ beherrschen wir haben und das ist eine echt bittere Erkenntnis in den vergangenen Jahren und Jahrzehnten vollkommen aus den Augen verloren warum wir all diese Frameworks und Werkzeuge überhaupt einsetzen und wir haben uns so sehr an die Tatsache gewöhnt dass wir sie einsetzen dass wir immer nur hinterfragen ob das gewählte Tool ob die gewählte Bibliothek ob das das richtige ist aber nie ob wir das Tool oder die Bibliothek an sich überhaupt noch brauchen und das ändert sich gerade bzw ich persönlich habe den Eindruck dass jetzt im Jahr 2024 genug momentum in diese Frage kommt dass sich weblung an Webentwicklung an sich in den nächsten 12 Monaten durchaus grundlegend verändern könnte und das Ergebnis davon könnte sein dass wir mit einem deutlich stabileren und vor allem langfristig auch mit einem deutlich verlässlicheren technologiestck aus der ganzen Sache hinausgehen können und wie das aussehen könnte das möchte ich Dir jetzt im Folgenden mal kurz skizzieren"
      },
      "date": 1711116311716
    },
    {
      "type": "add",
      "id": "972e1532c0e21583",
      "item": {
        "type": "paragraph",
        "id": "972e1532c0e21583",
        "text": "wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements ein Custom Element ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML Komponente zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann Shadow Dom und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS na ja und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "after": "218e4cb625b80184",
      "date": 1711116312752
    },
    {
      "type": "edit",
      "id": "972e1532c0e21583",
      "item": {
        "type": "paragraph",
        "id": "972e1532c0e21583",
        "text": "wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements ein Custom Element ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML [[Komponente]] zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann Shadow Dom und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS na ja und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "date": 1711116372872
    },
    {
      "type": "edit",
      "id": "972e1532c0e21583",
      "item": {
        "type": "paragraph",
        "id": "972e1532c0e21583",
        "text": "wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements ein [[Custom Element]] ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML [[Komponente]] zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann Shadow Dom und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS na ja und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "date": 1711116403613
    },
    {
      "type": "edit",
      "id": "972e1532c0e21583",
      "item": {
        "type": "paragraph",
        "id": "972e1532c0e21583",
        "text": "wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements ein [[Custom Element]] ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML [[Komponente]] zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus"
      },
      "date": 1711116433260
    },
    {
      "type": "add",
      "id": "7c2ec33f52ce20ba",
      "item": {
        "type": "paragraph",
        "id": "7c2ec33f52ce20ba",
        "text": "nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann Shadow Dom und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS na ja und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "after": "972e1532c0e21583",
      "date": 1711116433993
    },
    {
      "type": "edit",
      "id": "7c2ec33f52ce20ba",
      "item": {
        "type": "paragraph",
        "id": "7c2ec33f52ce20ba",
        "text": "nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann [[Shadow Dom]] und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS na ja und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "date": 1711116475022
    },
    {
      "type": "edit",
      "id": "972e1532c0e21583",
      "item": {
        "type": "paragraph",
        "id": "972e1532c0e21583",
        "text": "wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements. Ein [[Custom Element]] ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML [[Komponente]] zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus"
      },
      "date": 1711116524139
    },
    {
      "type": "edit",
      "id": "7c2ec33f52ce20ba",
      "item": {
        "type": "paragraph",
        "id": "7c2ec33f52ce20ba",
        "text": "nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann [[Shadow Dom]] und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS"
      },
      "date": 1711116563452
    },
    {
      "type": "add",
      "id": "5459837d9468165c",
      "item": {
        "type": "paragraph",
        "id": "5459837d9468165c",
        "text": "und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "after": "7c2ec33f52ce20ba",
      "date": 1711116567168
    },
    {
      "type": "edit",
      "id": "1f733ef5ef47e3ac",
      "item": {
        "type": "paragraph",
        "id": "1f733ef5ef47e3ac",
        "text": "aber zum Glück gibt es für webcomponents ganz gute Abstraktionen die das ganze deutlich zugänglicher machen und da fällt mir persönlich z.B das Framework [[Lit]] ein das wir auch schon einmal in einem unserer Livestreams in Aktion erlebt haben und falls du den damals nicht gesehen hast dann findest du den Link dorthin noch einmal hier oben in der infocard da magst Du natürlich nun auch einwenden dass das doch irgendwie nicht der Sinn der Sache sei weil man damit ja doch wieder auf ein Framework setzen würde und das ist auch erstmal durchaus richtig aber anders als bei react angular und Co schreibt man mit Lid eben keine Komponenten die dann wieder nur mit dem jeweiligen Framework funktionieren sondern man schafft eine algemeingültige Komponente die mit allen Frameworks oder eben auch ganz ohne Framework Lauf ist weil sie nativ im Browser läuft und das finde ich persönlich schon mal deutlich besser nun hatte ich ja anfangs erwähnt dass mich der bildschritt stört und wenn wir nun auf LD als Framework setzen dann haben wir natürlich wieder einen bildschritt das ist das zumindest was ich bis vor kurzem gedacht habe aber dem ist gar nicht so LD kann nämlich komplett zur Laufzeit ausgeführt werden das heißt ich muss keinen Compiler benutzen und das macht das Ganze direkt viel angenehmer noch angenehmer wird es übrigens wenn man feststellt dass man LD dazu noch nicht mal über NPM installieren muss sondern das einfach per Import aus einem CDN laden kann und wenn du da nun wiederum sagst das sei doch blöd weil man dann wieder überall von Versionsnummern in der Import URL Abhänge dann stimmt das außer du verwendest eine sogenannte Import map was übrigens ein weiteres Feature von modernen Browsern ist was einfach so da ist mit so einer Import Map kannst du nämlich ein einziges Mal zentral festlegen dass es z.B einen Import namens lit geben soll und auf welche URL der dann aufgelöst werden soll und danach arbeitest du einfach in jedem deiner Skripte mit LD als wäre es lokal über NPM installiert und die Version kontrollierst du zentral über die Import Map Problem gelöst komplett ohne NPM und vor allem ohne bildschritt und das ganze funktioniert dank der Möglichkeit seit ein paar Jahren Javascript Code dynamisch zur Laufzeit als cmascriptmodul einfach so Nachladen zu können und da kann man natürlich auch wieder sagen das ist doch aber völlig unpraktikabel denn dann besteht meine Anwendung ja nachher aus zahlreichen ganz vielen kleinen einzelnen Dateien und das produziert ganz viel HTTP Overhead beim Laden und auch da stimme ich Dir grundsätzlich zu aber die Frage ist doch wie schlimm ist das denn wirklich also kommt es bei der Webseite od der Webanwendung die du baust wirklich auf jede nano oder Millisekunde an oder ist das eigentlich eher egal und da wird es sicherlich Fälle geben in denen das z.B wegen SEO ultra wichtig ist das mit wenigen requests alles möglichst schnell geladen wird es wird aber auch Fälle geben in denen das völlig egal ist weil die Anwendung z.B gar nicht public facing sind sondern ohnehin nur in einer privaten Gruppe privaten Anwenderinnen und Anwendern zur Verfügung gestellt werden wo das Ganze gar nicht so entscheidend ist z.B im Intranet zumindest könnte man über diese Unterscheidung ja mal nachdenken das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das Sch ist das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules vermutlich hast du von CSS Module Scripts noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "date": 1711116606775
    },
    {
      "type": "edit",
      "id": "1f733ef5ef47e3ac",
      "item": {
        "type": "paragraph",
        "id": "1f733ef5ef47e3ac",
        "text": "aber zum Glück gibt es für webcomponents ganz gute Abstraktionen die das ganze deutlich zugänglicher machen und da fällt mir persönlich z.B das Framework [[Lit]] ein das wir auch schon einmal in einem unserer Livestreams in Aktion erlebt haben und falls du den damals nicht gesehen hast dann findest du den Link dorthin noch einmal hier oben in der infocard da magst Du natürlich nun auch einwenden dass das doch irgendwie nicht der Sinn der Sache sei weil man damit ja doch wieder auf ein Framework setzen würde und das ist auch erstmal durchaus richtig aber anders als bei react angular und Co schreibt man mit Lid eben keine Komponenten die dann wieder nur mit dem jeweiligen Framework funktionieren sondern man schafft eine algemeingültige Komponente die mit allen Frameworks oder eben auch ganz ohne Framework Lauf ist weil sie nativ im Browser läuft und das finde ich persönlich schon mal deutlich besser"
      },
      "date": 1711116670310
    },
    {
      "type": "add",
      "id": "b6c1d281ef1be985",
      "item": {
        "type": "paragraph",
        "id": "b6c1d281ef1be985",
        "text": "nun hatte ich ja anfangs erwähnt dass mich der bildschritt stört und wenn wir nun auf LD als Framework setzen dann haben wir natürlich wieder einen bildschritt das ist das zumindest was ich bis vor kurzem gedacht habe aber dem ist gar nicht so LD kann nämlich komplett zur Laufzeit ausgeführt werden das heißt ich muss keinen Compiler benutzen und das macht das Ganze direkt viel angenehmer noch angenehmer wird es übrigens wenn man feststellt dass man LD dazu noch nicht mal über NPM installieren muss sondern das einfach per Import aus einem CDN laden kann und wenn du da nun wiederum sagst das sei doch blöd weil man dann wieder überall von Versionsnummern in der Import URL Abhänge dann stimmt das außer du verwendest eine sogenannte Import map was übrigens ein weiteres Feature von modernen Browsern ist was einfach so da ist mit so einer Import Map kannst du nämlich ein einziges Mal zentral festlegen dass es z.B einen Import namens lit geben soll und auf welche URL der dann aufgelöst werden soll und danach arbeitest du einfach in jedem deiner Skripte mit LD als wäre es lokal über NPM installiert und die Version kontrollierst du zentral über die Import Map Problem gelöst komplett ohne NPM und vor allem ohne bildschritt und das ganze funktioniert dank der Möglichkeit seit ein paar Jahren Javascript Code dynamisch zur Laufzeit als cmascriptmodul einfach so Nachladen zu können und da kann man natürlich auch wieder sagen das ist doch aber völlig unpraktikabel denn dann besteht meine Anwendung ja nachher aus zahlreichen ganz vielen kleinen einzelnen Dateien und das produziert ganz viel HTTP Overhead beim Laden und auch da stimme ich Dir grundsätzlich zu aber die Frage ist doch wie schlimm ist das denn wirklich also kommt es bei der Webseite od der Webanwendung die du baust wirklich auf jede nano oder Millisekunde an oder ist das eigentlich eher egal und da wird es sicherlich Fälle geben in denen das z.B wegen SEO ultra wichtig ist das mit wenigen requests alles möglichst schnell geladen wird es wird aber auch Fälle geben in denen das völlig egal ist weil die Anwendung z.B gar nicht public facing sind sondern ohnehin nur in einer privaten Gruppe privaten Anwenderinnen und Anwendern zur Verfügung gestellt werden wo das Ganze gar nicht so entscheidend ist z.B im Intranet zumindest könnte man über diese Unterscheidung ja mal nachdenken das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das Sch ist das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules vermutlich hast du von CSS Module Scripts noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "1f733ef5ef47e3ac",
      "date": 1711116671567
    },
    {
      "type": "edit",
      "id": "b6c1d281ef1be985",
      "item": {
        "type": "paragraph",
        "id": "b6c1d281ef1be985",
        "text": "nun hatte ich ja anfangs erwähnt dass mich der bildschritt stört und wenn wir nun auf LD als Framework setzen dann haben wir natürlich wieder einen bildschritt das ist das zumindest was ich bis vor kurzem gedacht habe aber dem ist gar nicht so LD kann nämlich komplett zur Laufzeit ausgeführt werden das heißt ich muss keinen Compiler benutzen und das macht das Ganze direkt viel angenehmer noch angenehmer wird es übrigens wenn man feststellt dass man LD dazu noch nicht mal über NPM installieren muss sondern das einfach per Import aus einem CDN laden kann und wenn du da nun wiederum sagst das sei doch blöd weil man dann wieder überall von Versionsnummern in der Import URL Abhänge dann stimmt das außer du verwendest eine sogenannte [[Import Map]] [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap mdn] was übrigens ein weiteres Feature von modernen Browsern ist was einfach so da ist mit so einer Import Map kannst du nämlich ein einziges Mal zentral festlegen dass es z.B einen Import namens lit geben soll und auf welche URL der dann aufgelöst werden soll und danach arbeitest du einfach in jedem deiner Skripte mit LD als wäre es lokal über NPM installiert und die Version kontrollierst du zentral über die Import Map Problem gelöst komplett ohne NPM und vor allem ohne bildschritt und das ganze funktioniert dank der Möglichkeit seit ein paar Jahren Javascript Code dynamisch zur Laufzeit als cmascriptmodul einfach so Nachladen zu können und da kann man natürlich auch wieder sagen das ist doch aber völlig unpraktikabel denn dann besteht meine Anwendung ja nachher aus zahlreichen ganz vielen kleinen einzelnen Dateien und das produziert ganz viel HTTP Overhead beim Laden und auch da stimme ich Dir grundsätzlich zu aber die Frage ist doch wie schlimm ist das denn wirklich also kommt es bei der Webseite od der Webanwendung die du baust wirklich auf jede nano oder Millisekunde an oder ist das eigentlich eher egal und da wird es sicherlich Fälle geben in denen das z.B wegen SEO ultra wichtig ist das mit wenigen requests alles möglichst schnell geladen wird es wird aber auch Fälle geben in denen das völlig egal ist weil die Anwendung z.B gar nicht public facing sind sondern ohnehin nur in einer privaten Gruppe privaten Anwenderinnen und Anwendern zur Verfügung gestellt werden wo das Ganze gar nicht so entscheidend ist z.B im Intranet zumindest könnte man über diese Unterscheidung ja mal nachdenken das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das Sch ist das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules vermutlich hast du von CSS Module Scripts noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "date": 1711116795219
    },
    {
      "type": "edit",
      "id": "b6c1d281ef1be985",
      "item": {
        "type": "paragraph",
        "id": "b6c1d281ef1be985",
        "text": "nun hatte ich ja anfangs erwähnt dass mich der bildschritt stört und wenn wir nun auf LD als Framework setzen dann haben wir natürlich wieder einen bildschritt das ist das zumindest was ich bis vor kurzem gedacht habe aber dem ist gar nicht so LD kann nämlich komplett zur Laufzeit ausgeführt werden das heißt ich muss keinen Compiler benutzen und das macht das Ganze direkt viel angenehmer noch angenehmer wird es übrigens wenn man feststellt dass man LD dazu noch nicht mal über NPM installieren muss sondern das einfach per Import aus einem CDN laden kann und wenn du da nun wiederum sagst das sei doch blöd weil man dann wieder überall von Versionsnummern in der Import URL Abhänge dann stimmt das außer du verwendest eine sogenannte [[Import Map]] [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap mdn] was übrigens ein weiteres Feature von modernen Browsern ist was einfach so da ist"
      },
      "date": 1711116840157
    },
    {
      "type": "add",
      "id": "f8ae32a5bb00243a",
      "item": {
        "type": "paragraph",
        "id": "f8ae32a5bb00243a",
        "text": "mit so einer Import Map kannst du nämlich ein einziges Mal zentral festlegen dass es z.B einen Import namens lit geben soll und auf welche URL der dann aufgelöst werden soll und danach arbeitest du einfach in jedem deiner Skripte mit LD als wäre es lokal über NPM installiert und die Version kontrollierst du zentral über die Import Map Problem gelöst komplett ohne NPM und vor allem ohne bildschritt und das ganze funktioniert dank der Möglichkeit seit ein paar Jahren Javascript Code dynamisch zur Laufzeit als cmascriptmodul einfach so Nachladen zu können und da kann man natürlich auch wieder sagen das ist doch aber völlig unpraktikabel denn dann besteht meine Anwendung ja nachher aus zahlreichen ganz vielen kleinen einzelnen Dateien und das produziert ganz viel HTTP Overhead beim Laden und auch da stimme ich Dir grundsätzlich zu aber die Frage ist doch wie schlimm ist das denn wirklich also kommt es bei der Webseite od der Webanwendung die du baust wirklich auf jede nano oder Millisekunde an oder ist das eigentlich eher egal und da wird es sicherlich Fälle geben in denen das z.B wegen SEO ultra wichtig ist das mit wenigen requests alles möglichst schnell geladen wird es wird aber auch Fälle geben in denen das völlig egal ist weil die Anwendung z.B gar nicht public facing sind sondern ohnehin nur in einer privaten Gruppe privaten Anwenderinnen und Anwendern zur Verfügung gestellt werden wo das Ganze gar nicht so entscheidend ist z.B im Intranet zumindest könnte man über diese Unterscheidung ja mal nachdenken das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das Sch ist das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules vermutlich hast du von CSS Module Scripts noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "b6c1d281ef1be985",
      "date": 1711116845202
    },
    {
      "type": "edit",
      "id": "f8ae32a5bb00243a",
      "item": {
        "type": "paragraph",
        "id": "f8ae32a5bb00243a",
        "text": "mit so einer Import Map kannst du nämlich ein einziges Mal zentral festlegen dass es z.B einen Import namens lit geben soll und auf welche URL der dann aufgelöst werden soll und danach arbeitest du einfach in jedem deiner Skripte mit LD als wäre es lokal über NPM installiert und die Version kontrollierst du zentral über die Import Map Problem gelöst komplett ohne NPM und vor allem ohne bildschritt"
      },
      "date": 1711116863423
    },
    {
      "type": "add",
      "id": "3504fee699197195",
      "item": {
        "type": "paragraph",
        "id": "3504fee699197195",
        "text": "und das ganze funktioniert dank der Möglichkeit seit ein paar Jahren Javascript Code dynamisch zur Laufzeit als cmascriptmodul einfach so Nachladen zu können und da kann man natürlich auch wieder sagen das ist doch aber völlig unpraktikabel denn dann besteht meine Anwendung ja nachher aus zahlreichen ganz vielen kleinen einzelnen Dateien und das produziert ganz viel HTTP Overhead beim Laden und auch da stimme ich Dir grundsätzlich zu aber die Frage ist doch wie schlimm ist das denn wirklich also kommt es bei der Webseite od der Webanwendung die du baust wirklich auf jede nano oder Millisekunde an oder ist das eigentlich eher egal und da wird es sicherlich Fälle geben in denen das z.B wegen SEO ultra wichtig ist das mit wenigen requests alles möglichst schnell geladen wird es wird aber auch Fälle geben in denen das völlig egal ist weil die Anwendung z.B gar nicht public facing sind sondern ohnehin nur in einer privaten Gruppe privaten Anwenderinnen und Anwendern zur Verfügung gestellt werden wo das Ganze gar nicht so entscheidend ist z.B im Intranet zumindest könnte man über diese Unterscheidung ja mal nachdenken das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das Sch ist das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules vermutlich hast du von CSS Module Scripts noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "f8ae32a5bb00243a",
      "date": 1711116864689
    },
    {
      "type": "edit",
      "id": "3504fee699197195",
      "item": {
        "type": "paragraph",
        "id": "3504fee699197195",
        "text": "und das ganze funktioniert dank der Möglichkeit seit ein paar Jahren Javascript Code dynamisch zur Laufzeit als cmascriptmodul einfach so Nachladen zu können und da kann man natürlich auch wieder sagen das ist doch aber völlig unpraktikabel denn dann besteht meine Anwendung ja nachher aus zahlreichen ganz vielen kleinen einzelnen Dateien und das produziert ganz viel HTTP Overhead beim Laden und auch da stimme ich Dir grundsätzlich zu aber die Frage ist doch wie schlimm ist das denn wirklich also kommt es bei der Webseite od der Webanwendung die du baust wirklich auf jede nano oder Millisekunde an oder ist das eigentlich eher egal"
      },
      "date": 1711116908306
    },
    {
      "type": "add",
      "id": "13ac183afc4af3d9",
      "item": {
        "type": "paragraph",
        "id": "13ac183afc4af3d9",
        "text": "und da wird es sicherlich Fälle geben in denen das z.B wegen SEO ultra wichtig ist das mit wenigen requests alles möglichst schnell geladen wird es wird aber auch Fälle geben in denen das völlig egal ist weil die Anwendung z.B gar nicht public facing sind sondern ohnehin nur in einer privaten Gruppe privaten Anwenderinnen und Anwendern zur Verfügung gestellt werden wo das Ganze gar nicht so entscheidend ist z.B im Intranet zumindest könnte man über diese Unterscheidung ja mal nachdenken das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das Sch ist das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules vermutlich hast du von CSS Module Scripts noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "3504fee699197195",
      "date": 1711116909372
    },
    {
      "type": "edit",
      "id": "13ac183afc4af3d9",
      "item": {
        "type": "paragraph",
        "id": "13ac183afc4af3d9",
        "text": "und da wird es sicherlich Fälle geben in denen das z.B wegen SEO ultra wichtig ist das mit wenigen requests alles möglichst schnell geladen wird es wird aber auch Fälle geben in denen das völlig egal ist weil die Anwendung z.B gar nicht public facing sind sondern ohnehin nur in einer privaten Gruppe privaten Anwenderinnen und Anwendern zur Verfügung gestellt werden wo das Ganze gar nicht so entscheidend ist z.B im Intranet zumindest könnte man über diese Unterscheidung ja mal nachdenken"
      },
      "date": 1711116927168
    },
    {
      "type": "add",
      "id": "88cc6898ec799b55",
      "item": {
        "type": "paragraph",
        "id": "88cc6898ec799b55",
        "text": "das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das Sch ist das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules vermutlich hast du von CSS Module Scripts noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "13ac183afc4af3d9",
      "date": 1711116927668
    },
    {
      "type": "edit",
      "id": "88cc6898ec799b55",
      "item": {
        "type": "paragraph",
        "id": "88cc6898ec799b55",
        "text": "das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt"
      },
      "date": 1711116941556
    },
    {
      "type": "add",
      "id": "facffd63e90775e9",
      "item": {
        "type": "paragraph",
        "id": "facffd63e90775e9",
        "text": "was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das Sch ist das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules vermutlich hast du von CSS Module Scripts noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "88cc6898ec799b55",
      "date": 1711116942620
    },
    {
      "type": "edit",
      "id": "facffd63e90775e9",
      "item": {
        "type": "paragraph",
        "id": "facffd63e90775e9",
        "text": "was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules"
      },
      "date": 1711116995806
    },
    {
      "type": "add",
      "id": "94f370d9b7876fda",
      "item": {
        "type": "paragraph",
        "id": "94f370d9b7876fda",
        "text": "vermutlich hast du von [[CSS Module Scripts]] noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "facffd63e90775e9",
      "date": 1711116996384
    },
    {
      "type": "edit",
      "id": "94f370d9b7876fda",
      "item": {
        "type": "paragraph",
        "id": "94f370d9b7876fda",
        "text": "vermutlich hast du von [[CSS Module Scripts]] noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können"
      },
      "date": 1711117030656
    },
    {
      "type": "add",
      "id": "c9d481a06561f819",
      "item": {
        "type": "paragraph",
        "id": "c9d481a06561f819",
        "text": "und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildl aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von Vanilla Web zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "94f370d9b7876fda",
      "date": 1711117031232
    },
    {
      "type": "edit",
      "id": "c9d481a06561f819",
      "item": {
        "type": "paragraph",
        "id": "c9d481a06561f819",
        "text": "und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildless aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von [[Vanilla Web]] zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "date": 1711117088352
    },
    {
      "type": "edit",
      "id": "c9d481a06561f819",
      "item": {
        "type": "paragraph",
        "id": "c9d481a06561f819",
        "text": "und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildless aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von [[Vanilla Web]] zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird"
      },
      "date": 1711117113931
    },
    {
      "type": "add",
      "id": "6d342443d18e4d9e",
      "item": {
        "type": "paragraph",
        "id": "6d342443d18e4d9e",
        "text": "ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "c9d481a06561f819",
      "date": 1711117114317
    },
    {
      "type": "edit",
      "id": "6d342443d18e4d9e",
      "item": {
        "type": "paragraph",
        "id": "6d342443d18e4d9e",
        "text": "ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind"
      },
      "date": 1711117176148
    },
    {
      "type": "add",
      "id": "3a7d65cb666b09d7",
      "item": {
        "type": "paragraph",
        "id": "3a7d65cb666b09d7",
        "text": "und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "6d342443d18e4d9e",
      "date": 1711117177124
    },
    {
      "type": "edit",
      "id": "3a7d65cb666b09d7",
      "item": {
        "type": "paragraph",
        "id": "3a7d65cb666b09d7",
        "text": "und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE"
      },
      "date": 1711117218690
    },
    {
      "type": "add",
      "id": "9122d68c246bedc4",
      "item": {
        "type": "paragraph",
        "id": "9122d68c246bedc4",
        "text": "und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird ja und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "3a7d65cb666b09d7",
      "date": 1711117219088
    },
    {
      "type": "edit",
      "id": "9122d68c246bedc4",
      "item": {
        "type": "paragraph",
        "id": "9122d68c246bedc4",
        "text": "und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird"
      },
      "date": 1711117233865
    },
    {
      "type": "add",
      "id": "c6c295fc09866cb9",
      "item": {
        "type": "paragraph",
        "id": "c6c295fc09866cb9",
        "text": "und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns www.thenativeweb.io und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "9122d68c246bedc4",
      "date": 1711117237614
    },
    {
      "type": "edit",
      "id": "c6c295fc09866cb9",
      "item": {
        "type": "paragraph",
        "id": "c6c295fc09866cb9",
        "text": "und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns [https://www.thenativeweb.io/ www.thenativeweb.io] und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "date": 1711117298895
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1711117356690
    },
    {
      "type": "edit",
      "id": "4a287d7868d8075a",
      "item": {
        "type": "paragraph",
        "id": "4a287d7868d8075a",
        "text": "⇒ [[Lit]]"
      },
      "date": 1711117372562
    },
    {
      "type": "edit",
      "id": "6c9f33b1df1dc362",
      "item": {
        "type": "paragraph",
        "id": "6c9f33b1df1dc362",
        "text": "und ein Königsweg wie man das Thema Web UI Entwicklung überhaupt angeht den scheint es auch nicht so wirklich zu geben denn sonst würde nicht gefühlt alle paar Wochen in komplett komplett neues Framework erscheinen und leider geht ja das nicht nur beim Framework so hinzu kommt nämlich noch eine ganze Reihe an Werkzeugen die du auch noch benötigst angefangen beim typescript Compiler über einen precompiler für SAS oder L in Verbindung mit einem Package Manager wie NPM oder yarn ein Bildtool wie z.B wieed vielleicht noch ein gesonderter Bandler und so weiter und so fort und wenn es dir dir da geht wie mir dann hast du auf diese Art der Webentwicklung schon lange keine Lust mehr und das alles wird gefühlt nicht besser sondern immer nur noch schlimmer"
      },
      "date": 1711118133073
    },
    {
      "type": "add",
      "id": "27734aea21cca5e3",
      "item": {
        "type": "paragraph",
        "id": "27734aea21cca5e3",
        "text": "Ständig kommen neue Werkzeuge hinzu und die ganze [[Leichtigkeit]] die vor vielen Jahren mal typisch für die Webentwicklung war das ist leider inzwischen echt lange her und da stellt sich dann die Frage wo soll das denn alles noch hinführen wäre es nicht längst überfällig da mal inne zu halten und sich mal zu fragen ob wir nicht seit Jahren in eine gänzlich falsche Richtung laufen und wie man das ganze nicht vielleicht deutlich besser machen könnte und genau darum geht es heute in diesem Video in diesem Sinne hallo und herzlich willkommen zu unserem neuen weekly und by the way ein schönes und frohes neues Jahr"
      },
      "after": "6c9f33b1df1dc362",
      "date": 1711118135230
    },
    {
      "type": "fork",
      "site": "wiki.ralfbarkow.ch",
      "date": 1711118195084
    },
    {
      "item": {
        "type": "factory",
        "id": "7f2de72fe354544f"
      },
      "id": "7f2de72fe354544f",
      "type": "add",
      "after": "c6c295fc09866cb9",
      "date": 1711120617441
    },
    {
      "item": {
        "type": "factory",
        "id": "3b5774f07ca524d2"
      },
      "id": "3b5774f07ca524d2",
      "type": "add",
      "after": "7f2de72fe354544f",
      "date": 1711120622248
    },
    {
      "type": "edit",
      "id": "3b5774f07ca524d2",
      "item": {
        "type": "paragraph",
        "id": "3b5774f07ca524d2",
        "text": "dreyeck "
      },
      "date": 1711120632556
    },
    {
      "item": {
        "type": "factory",
        "id": "29b04d259511d8d5"
      },
      "id": "29b04d259511d8d5",
      "type": "add",
      "after": "3b5774f07ca524d2",
      "date": 1711120649748
    },
    {
      "type": "edit",
      "id": "29b04d259511d8d5",
      "item": {
        "type": "code",
        "id": "29b04d259511d8d5",
        "text": "~/.wiki/hive.dreyeck.ch/pages]"
      },
      "date": 1711120652206
    },
    {
      "item": {
        "type": "factory",
        "id": "5eae7588ecd77b81"
      },
      "id": "5eae7588ecd77b81",
      "type": "add",
      "after": "29b04d259511d8d5",
      "date": 1711120657361
    },
    {
      "type": "edit",
      "id": "5eae7588ecd77b81",
      "item": {
        "type": "paragraph",
        "id": "5eae7588ecd77b81",
        "text": "is on branch main."
      },
      "date": 1711120666734
    },
    {
      "type": "edit",
      "id": "5eae7588ecd77b81",
      "item": {
        "type": "paragraph",
        "id": "5eae7588ecd77b81",
        "text": "is on branch main and up to date with 'origin/host'."
      },
      "date": 1711120692341
    },
    {
      "item": {
        "type": "factory",
        "id": "90917c6f2482286c"
      },
      "id": "90917c6f2482286c",
      "type": "add",
      "after": "5eae7588ecd77b81",
      "date": 1711120711811
    },
    {
      "type": "edit",
      "id": "90917c6f2482286c",
      "item": {
        "type": "markdown",
        "id": "90917c6f2482286c",
        "text": "git push\nfatal: The upstream branch of your current branch does not match\nthe name of your current branch.  To push to the upstream branch\non the remote, use\n\n    git push origin HEAD:host\n\nTo push to the branch of the same name on the remote, use\n\n    git push origin HEAD\n\nTo choose either option permanently, see push.default in 'git help config'.\n\nTo avoid automatically configuring upstream branches when their name\ndoesn't match the local branch, see option 'simple' of branch.autoSetupMerge\nin 'git help config'."
      },
      "date": 1711120713959
    },
    {
      "type": "edit",
      "id": "90917c6f2482286c",
      "item": {
        "type": "markdown",
        "id": "90917c6f2482286c",
        "text": "git push\nfatal: The upstream branch of your current branch does not match the name of your current branch.  To push to the upstream branch\non the remote, use\n\n    git push origin HEAD:host\n\nTo push to the branch of the same name on the remote, use\n\n    git push origin HEAD\n\nTo choose either option permanently, see push.default in 'git help config'.\n\nTo avoid automatically configuring upstream branches when their name doesn't match the local branch, see option 'simple' of branch.autoSetupMerge\nin 'git help config'."
      },
      "date": 1711120738303
    },
    {
      "type": "edit",
      "id": "90917c6f2482286c",
      "item": {
        "type": "markdown",
        "id": "90917c6f2482286c",
        "text": "`git push` gives us: The upstream branch of your current branch does not match the name of your current branch.  To push to the upstream branch on the remote, use\n\n    git push origin HEAD:host\n\nTo push to the branch of the same name on the remote, use\n\n    git push origin HEAD\n\nTo choose either option permanently, see push.default in 'git help config'.\n\nTo avoid automatically configuring upstream branches when their name doesn't match the local branch, see option 'simple' of branch.autoSetupMerge\nin 'git help config'."
      },
      "date": 1711120775655
    },
    {
      "item": {
        "type": "factory",
        "id": "acc9e6cea97b50b8"
      },
      "id": "acc9e6cea97b50b8",
      "type": "add",
      "after": "90917c6f2482286c",
      "date": 1711120826179
    },
    {
      "type": "edit",
      "id": "acc9e6cea97b50b8",
      "item": {
        "type": "paragraph",
        "id": "acc9e6cea97b50b8",
        "text": "I used:"
      },
      "date": 1711120833328
    },
    {
      "item": {
        "type": "factory",
        "id": "b23131b0b5f57ab3"
      },
      "id": "b23131b0b5f57ab3",
      "type": "add",
      "after": "acc9e6cea97b50b8",
      "date": 1711120834779
    },
    {
      "type": "edit",
      "id": "b23131b0b5f57ab3",
      "item": {
        "type": "code",
        "id": "b23131b0b5f57ab3",
        "text": "git push origin HEAD"
      },
      "date": 1711120836865
    },
    {
      "type": "edit",
      "id": "29b04d259511d8d5",
      "item": {
        "type": "code",
        "id": "29b04d259511d8d5",
        "text": "~/.wiki/hive.dreyeck.ch/pages"
      },
      "date": 1711120850419
    },
    {
      "type": "edit",
      "id": "5eae7588ecd77b81",
      "item": {
        "type": "paragraph",
        "id": "5eae7588ecd77b81",
        "text": "is on branch main and up to date with 'origin/host', the branch is use on wiki.ralfbarkow.ch."
      },
      "date": 1711120904584
    },
    {
      "type": "edit",
      "id": "5eae7588ecd77b81",
      "item": {
        "type": "paragraph",
        "id": "5eae7588ecd77b81",
        "text": "is on branch main and up to date with 'origin/host', the branch I use on wiki.ralfbarkow.ch."
      },
      "date": 1711120907402
    }
  ]
}