{
  "title": "Procedure With No Arguments",
  "story": [
    {
      "type": "html",
      "text": "A technical answer to the question \"[[What Isa Thunk]]?\" is that it is a procedure that has no arguments.\nIt is a function with no parameters and no return value.",
      "id": "261268cd44e1c51a8746cefa491dde93"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "518d1059c179fbe32a375b73305f1ba5"
    },
    {
      "type": "html",
      "text": "\nA thunk is a procedure with no arguments.",
      "id": "c77086049a9d70005c1546aef213963a"
    },
    {
      "type": "html",
      "text": "\nThat is, a thunk is a subroutine with no arguments and no return value. In C, this would look like:",
      "id": "0944aa76bd62b7f051ab3636fbe95ac9"
    },
    {
      "type": "code",
      "text": "    void Thunk( void );",
      "id": "56dd337a047a2972f719e9b527a8996d"
    },
    {
      "type": "html",
      "text": "\nIt's arguable whether or not this is a thunk:",
      "id": "e084c6727c0ef571f57445d720f86cb8"
    },
    {
      "type": "code",
      "text": "    void Some''''''Class::Thunk''''''Method( void );",
      "id": "feec8b43465209a97871e44d15797eab"
    },
    {
      "type": "html",
      "text": "\nbecause Thunk<b></b>Method has access to the member variables of [[Some Class]] (if it isn't a static method). However, Thunk, above, also has access to global variables.",
      "id": "61b3eba434093cd17b09aed25bf3113c"
    },
    {
      "type": "html",
      "text": "\nThunks are used primarily for their side effects. They are called like so:",
      "id": "4fecf859d0cf44383fb2279cb564b883"
    },
    {
      "type": "code",
      "text": "  Thunk();\n  anInstance.ThunkMethod();",
      "id": "1fe93c660278b11712eca658c4099df8"
    },
    {
      "type": "html",
      "text": "\nIn [[Functional Programming Language]]s, thunks generally break the whole functional paradigm because functions aren't supposed to have side effects. However, in the [[Scheme Language]]/[[Lisp Language]]/etc. they are sometimes used for either program output or for set! side effects. Note: program output violates the functional paradigm too because it has temporal context (i.e. one line is displayed after another).",
      "id": "d99702cb5342d704d080af247bd5c03c"
    },
    {
      "type": "html",
      "text": "<i>That's my best effort. Any comments, folks? Especially on method thunks. -- [[Sunir Shah]]</i>",
      "id": "8488a3758ba6ed9739a1df84ccfe82b1"
    },
    {
      "type": "html",
      "text": "\nIf you use \"thunk\" in the Scheme sense, then it is a function that returns no arguments but <i>does</i> return a value. A thunk is used to fake [[Lazy Evaluation]] in languages that don't provide it natively. -- [[Stephan Houben]]",
      "id": "0382360eeb4afc9aa717360fb42a29ad"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "518d1059c179fbe32a375b73305f1ba5"
    },
    {
      "type": "html",
      "text": "\nIn other words, it's a function that's \"called for its side effects.\"",
      "id": "b7267bb58ae5627c88b2af93af29b5e0"
    },
    {
      "type": "html",
      "text": "\nThis is not compatible with [[Functional Programming]], and may be a bad idea if done carelessly. If you see lots of these, someone is probably using too many global variables.",
      "id": "599ecc8705b36834e0f1af49708833bb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "518d1059c179fbe32a375b73305f1ba5"
    },
    {
      "type": "html",
      "text": "If the thunk is defined inside another function and closes over some of its parent's variables, it may do useful things without involving global variables. I agree that this is still not [[Functional Programming]]. -- [[Dan Barlow]]",
      "id": "2308d03ff056ca8016c26762401f1384"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "518d1059c179fbe32a375b73305f1ba5"
    },
    {
      "type": "html",
      "text": "In [[Common Lisp]], thunks are often closures which are used as [[Call Backs]].\nThus, one will write",
      "id": "9135c7dabbc8576f5938a7d6879ddb6e"
    },
    {
      "type": "code",
      "text": "   (register-with-some-server #'(lambda () ; no args -- a thunk\n                                    (foo my-lexical-variable-some-time-later)))",
      "id": "4390b49975caa93a460d56de97b56622"
    },
    {
      "type": "html",
      "text": "and the thunk will be called by some server when some condition occurs at some point in the future (when foo needs to be called, presumably).",
      "id": "39947d667354305d38d67f200592fd8f"
    },
    {
      "type": "html",
      "text": "-- [[Alain Picard]]",
      "id": "b07d87a7620598452461cbe8e59c8582"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "518d1059c179fbe32a375b73305f1ba5"
    },
    {
      "type": "html",
      "text": "In the [[Ocaml Language]] (and other [[Ml Language]]) type system, every \"function\" has exactly one argument (functions with multiple arguments are curried ([[Currying Schonfinkelling]]) into functions with one argument that return a function, etc.).  If you don't specify any arguments, according to the syntax you would be defining a constant, whose body is to be evaluated immediately (since ML is a [[Strict Language]]).  Since the purpose of a function of no arguments is typically to perform side effects, you (1) might not want to evaluate it immediately, and (2) might want to evaluate it more than once.  So when we need something like a function with no arguments, we give it an argument of type unit, written as \"()\", the empty tuple, which is like void in C -- a type which carries no information.",
      "id": "e3224a9b85830cd9479c833421b2bd9f"
    },
    {
      "type": "html",
      "text": "\nIn [[Haskell Language]], the above is not an issue, because Haskell is [[Purely Functional]], so there is no point in having a regular function of no arguments (it would be equivalent to a constant because of [[Referential Transparency]]).  Computations with [[Side Effect]] are abstracted in Haskell as values called [[On Monads]] (the IO and other monads), and so are not performed directly anyway.  You can join computations together in the exact order you want, and you can join the same computation multiple times.  So instead of a function of no arguments, you would typically instead define a value, which is typed in the IO monad, and the value would equal a joining together of of the computations that you want to do in the function, either with the (>>=) join operator, or with the \"do\" notation.  One example of this is the \"main function\" in a Haskell program, which is declared like  \"main :: IO ()\"; i.e. \"main\" is a value that represents a computation that returns \"()\" (nothing).",
      "id": "805a0fdd01584f5d2705328df85a0534"
    },
    {
      "type": "html",
      "text": "<i>Personally, I think that the [[Ideal Programming Language]] would enforce this: there is no such thing as \"a procedure with arguments\"; instead there are referentially transparent functions that take arguments and return procedures. Any procedure, having no arguments, can be executed any number of times. (However, a procedure might still have a few implicit arguments such as context ([[Explicit Management Of Implicit Context]]) and continuation ([[Continuation Passing Style]]).) The procedure itself might be a data object subject to analysis; the use of the Haskell IO monad is rather distasteful IMO due to the difficulty involved in decomposing or recomposing the resulting monad structure.</i>",
      "id": "5068d4168cfb09ecaf102f9cb45dc2da"
    },
    {
      "type": "html",
      "text": "\nYou claim that Haskell IO monads (and, presumably by extension, all monads) are distasteful for various compositional reasons; then, you advocate a system which is <i>precisely</i> what monads in Haskell <i>actually do right now.</i>",
      "id": "a04ecd163b4a21e1716a78c7414f4222"
    },
    {
      "type": "html",
      "text": "<i>I stated 'decomposition', not 'composition'. Haskell provides no support for decomposing functions and thus treating them as \"data objects subject to analysis\". Some monads are subject to decomposition, but each one requires a specialized set of operators and thus decomposition support cannot be centralized to any one library: one would have great difficulty with, say, generalized serialization or persisting these monad structures to run them later on different machines, or providing tools that can analyze a procedure and tell you about its properties. What I proposed in relation to the comment disparaging Haskell (that the procedure itself be a data object - and not just any data object, but a data object subject to analysis) would require that the data object be standard such that it can be analyzed by a common set of tools... which would allow it to be decomposed, recomposed, serialized, persisted, loaded, etc. Beyond a few other significant and relevant differences that derive from having procedures be analyzable data objects (e.g. 'standardized' support for exceptions and STM and concurrency and workflows and implicit context... rather than whatever the programmer dreams up), I do agree that the [[Ideal Programming Language]] I described has a great deal in common with what Haskell does right now. If you're abstracting enough that what I said looks </i>precisely<i> the same as Haskell monads, I imagine it will be very difficult to see the relevant differences.</i>",
      "id": "de4dae5a376e7d4c13d5ef59a705250d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "518d1059c179fbe32a375b73305f1ba5"
    },
    {
      "type": "html",
      "text": "\nThis is the first time I've heard of this definition (parameterless, valueless procedure).  The only definition I've ever been exposed to over the years is of a procedure whose purpose is to couple one language's calling conventions to another.  For example, in [[Component Object Model]], you use thunks to couple C++ to, e.g., [[Visual Basic]].  Or, in [[Amiga Os]], you use what it called <i>stubs</i> to couple C into the ABI model for calling generic library procedures, like so:",
      "id": "9a3fce6132dd196ec6999413a9114d4c"
    },
    {
      "type": "code",
      "text": " XREF myLibraryBase\n XDEF _someLibraryProcedure\n _someLibraryProcedure:\n     move.l a6,-(a7)\n     move.l myLibraryBase,a6",
      "id": "4f40f0b21781d11cc93c60fad860419e"
    },
    {
      "type": "code",
      "text": "     move.l 8(a7),d0\n     move.l 12(a7),d1\n     move.l 16(a7),a0\n     move.l 20(a7),a1\n     jsr    _LVOsomeLibraryProcedure(a6)\n     move.l (a7)+,a6\n     rts",
      "id": "8b90a74a32210a8cb83fb0ce8ba712f9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "518d1059c179fbe32a375b73305f1ba5"
    },
    {
      "type": "html",
      "text": "How is this officially implemented in \"proper\" FP?:",
      "id": "188b0532b7121cddb1703eec04beebe9"
    },
    {
      "type": "code",
      "text": "  destroyWorld();",
      "id": "2c6735a326ab7d01c61efdeae47a6eb3"
    },
    {
      "type": "html",
      "text": "Would it be:",
      "id": "d20848b217b85c13db800ff1db8d9a68"
    },
    {
      "type": "code",
      "text": "  brokenWorld = destroy(goodWorld);",
      "id": "f839e943a58f461560b768ba5a0aa3a0"
    },
    {
      "type": "html",
      "text": "?",
      "id": "44ebf18e0ed573b0d8a49aae5aee4938"
    },
    {
      "type": "html",
      "text": "<i>Yes.  Of course, within [[Haskell Language]] you could use the special monad syntax to hide the explicit passing of the goodWorld.</i> ",
      "id": "03a8300e0d027b2c4c20f0925ee2bde4"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ProcedureWithNoArguments c2.com]",
      "id": "cada1312a4bd8afcc40b09c5c44a15b3"
    }
  ],
  "journal": [
    {
      "date": 1225728917000,
      "id": "2a38b470cbc585e63070001ce22c28e4",
      "type": "create",
      "item": {
        "title": "Procedure With No Arguments",
        "story": [
          {
            "type": "html",
            "text": "A technical answer to the question \"[[What Isa Thunk]]?\" is that it is a procedure that has no arguments.\nIt is a function with no parameters and no return value.",
            "id": "261268cd44e1c51a8746cefa491dde93"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "518d1059c179fbe32a375b73305f1ba5"
          },
          {
            "type": "html",
            "text": "\nA thunk is a procedure with no arguments.",
            "id": "c77086049a9d70005c1546aef213963a"
          },
          {
            "type": "html",
            "text": "\nThat is, a thunk is a subroutine with no arguments and no return value. In C, this would look like:",
            "id": "0944aa76bd62b7f051ab3636fbe95ac9"
          },
          {
            "type": "code",
            "text": "    void Thunk( void );",
            "id": "56dd337a047a2972f719e9b527a8996d"
          },
          {
            "type": "html",
            "text": "\nIt's arguable whether or not this is a thunk:",
            "id": "e084c6727c0ef571f57445d720f86cb8"
          },
          {
            "type": "code",
            "text": "    void Some''''''Class::Thunk''''''Method( void );",
            "id": "feec8b43465209a97871e44d15797eab"
          },
          {
            "type": "html",
            "text": "\nbecause Thunk<b></b>Method has access to the member variables of [[Some Class]] (if it isn't a static method). However, Thunk, above, also has access to global variables.",
            "id": "61b3eba434093cd17b09aed25bf3113c"
          },
          {
            "type": "html",
            "text": "\nThunks are used primarily for their side effects. They are called like so:",
            "id": "4fecf859d0cf44383fb2279cb564b883"
          },
          {
            "type": "code",
            "text": "  Thunk();\n  anInstance.ThunkMethod();",
            "id": "1fe93c660278b11712eca658c4099df8"
          },
          {
            "type": "html",
            "text": "\nIn [[Functional Programming Language]]s, thunks generally break the whole functional paradigm because functions aren't supposed to have side effects. However, in the [[Scheme Language]]/[[Lisp Language]]/etc. they are sometimes used for either program output or for set! side effects. Note: program output violates the functional paradigm too because it has temporal context (i.e. one line is displayed after another).",
            "id": "d99702cb5342d704d080af247bd5c03c"
          },
          {
            "type": "html",
            "text": "<i>That's my best effort. Any comments, folks? Especially on method thunks. -- [[Sunir Shah]]</i>",
            "id": "8488a3758ba6ed9739a1df84ccfe82b1"
          },
          {
            "type": "html",
            "text": "\nIf you use \"thunk\" in the Scheme sense, then it is a function that returns no arguments but <i>does</i> return a value. A thunk is used to fake [[Lazy Evaluation]] in languages that don't provide it natively. -- [[Stephan Houben]]",
            "id": "0382360eeb4afc9aa717360fb42a29ad"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "518d1059c179fbe32a375b73305f1ba5"
          },
          {
            "type": "html",
            "text": "\nIn other words, it's a function that's \"called for its side effects.\"",
            "id": "b7267bb58ae5627c88b2af93af29b5e0"
          },
          {
            "type": "html",
            "text": "\nThis is not compatible with [[Functional Programming]], and may be a bad idea if done carelessly. If you see lots of these, someone is probably using too many global variables.",
            "id": "599ecc8705b36834e0f1af49708833bb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "518d1059c179fbe32a375b73305f1ba5"
          },
          {
            "type": "html",
            "text": "If the thunk is defined inside another function and closes over some of its parent's variables, it may do useful things without involving global variables. I agree that this is still not [[Functional Programming]]. -- [[Dan Barlow]]",
            "id": "2308d03ff056ca8016c26762401f1384"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "518d1059c179fbe32a375b73305f1ba5"
          },
          {
            "type": "html",
            "text": "In [[Common Lisp]], thunks are often closures which are used as [[Call Backs]].\nThus, one will write",
            "id": "9135c7dabbc8576f5938a7d6879ddb6e"
          },
          {
            "type": "code",
            "text": "   (register-with-some-server #'(lambda () ; no args -- a thunk\n                                    (foo my-lexical-variable-some-time-later)))",
            "id": "4390b49975caa93a460d56de97b56622"
          },
          {
            "type": "html",
            "text": "and the thunk will be called by some server when some condition occurs at some point in the future (when foo needs to be called, presumably).",
            "id": "39947d667354305d38d67f200592fd8f"
          },
          {
            "type": "html",
            "text": "-- [[Alain Picard]]",
            "id": "b07d87a7620598452461cbe8e59c8582"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "518d1059c179fbe32a375b73305f1ba5"
          },
          {
            "type": "html",
            "text": "In the [[Ocaml Language]] (and other [[Ml Language]]) type system, every \"function\" has exactly one argument (functions with multiple arguments are curried ([[Currying Schonfinkelling]]) into functions with one argument that return a function, etc.).  If you don't specify any arguments, according to the syntax you would be defining a constant, whose body is to be evaluated immediately (since ML is a [[Strict Language]]).  Since the purpose of a function of no arguments is typically to perform side effects, you (1) might not want to evaluate it immediately, and (2) might want to evaluate it more than once.  So when we need something like a function with no arguments, we give it an argument of type unit, written as \"()\", the empty tuple, which is like void in C -- a type which carries no information.",
            "id": "e3224a9b85830cd9479c833421b2bd9f"
          },
          {
            "type": "html",
            "text": "\nIn [[Haskell Language]], the above is not an issue, because Haskell is [[Purely Functional]], so there is no point in having a regular function of no arguments (it would be equivalent to a constant because of [[Referential Transparency]]).  Computations with [[Side Effect]] are abstracted in Haskell as values called [[On Monads]] (the IO and other monads), and so are not performed directly anyway.  You can join computations together in the exact order you want, and you can join the same computation multiple times.  So instead of a function of no arguments, you would typically instead define a value, which is typed in the IO monad, and the value would equal a joining together of of the computations that you want to do in the function, either with the (>>=) join operator, or with the \"do\" notation.  One example of this is the \"main function\" in a Haskell program, which is declared like  \"main :: IO ()\"; i.e. \"main\" is a value that represents a computation that returns \"()\" (nothing).",
            "id": "805a0fdd01584f5d2705328df85a0534"
          },
          {
            "type": "html",
            "text": "<i>Personally, I think that the [[Ideal Programming Language]] would enforce this: there is no such thing as \"a procedure with arguments\"; instead there are referentially transparent functions that take arguments and return procedures. Any procedure, having no arguments, can be executed any number of times. (However, a procedure might still have a few implicit arguments such as context ([[Explicit Management Of Implicit Context]]) and continuation ([[Continuation Passing Style]]).) The procedure itself might be a data object subject to analysis; the use of the Haskell IO monad is rather distasteful IMO due to the difficulty involved in decomposing or recomposing the resulting monad structure.</i>",
            "id": "5068d4168cfb09ecaf102f9cb45dc2da"
          },
          {
            "type": "html",
            "text": "\nYou claim that Haskell IO monads (and, presumably by extension, all monads) are distasteful for various compositional reasons; then, you advocate a system which is <i>precisely</i> what monads in Haskell <i>actually do right now.</i>",
            "id": "a04ecd163b4a21e1716a78c7414f4222"
          },
          {
            "type": "html",
            "text": "<i>I stated 'decomposition', not 'composition'. Haskell provides no support for decomposing functions and thus treating them as \"data objects subject to analysis\". Some monads are subject to decomposition, but each one requires a specialized set of operators and thus decomposition support cannot be centralized to any one library: one would have great difficulty with, say, generalized serialization or persisting these monad structures to run them later on different machines, or providing tools that can analyze a procedure and tell you about its properties. What I proposed in relation to the comment disparaging Haskell (that the procedure itself be a data object - and not just any data object, but a data object subject to analysis) would require that the data object be standard such that it can be analyzed by a common set of tools... which would allow it to be decomposed, recomposed, serialized, persisted, loaded, etc. Beyond a few other significant and relevant differences that derive from having procedures be analyzable data objects (e.g. 'standardized' support for exceptions and STM and concurrency and workflows and implicit context... rather than whatever the programmer dreams up), I do agree that the [[Ideal Programming Language]] I described has a great deal in common with what Haskell does right now. If you're abstracting enough that what I said looks </i>precisely<i> the same as Haskell monads, I imagine it will be very difficult to see the relevant differences.</i>",
            "id": "de4dae5a376e7d4c13d5ef59a705250d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "518d1059c179fbe32a375b73305f1ba5"
          },
          {
            "type": "html",
            "text": "\nThis is the first time I've heard of this definition (parameterless, valueless procedure).  The only definition I've ever been exposed to over the years is of a procedure whose purpose is to couple one language's calling conventions to another.  For example, in [[Component Object Model]], you use thunks to couple C++ to, e.g., [[Visual Basic]].  Or, in [[Amiga Os]], you use what it called <i>stubs</i> to couple C into the ABI model for calling generic library procedures, like so:",
            "id": "9a3fce6132dd196ec6999413a9114d4c"
          },
          {
            "type": "code",
            "text": " XREF myLibraryBase\n XDEF _someLibraryProcedure\n _someLibraryProcedure:\n     move.l a6,-(a7)\n     move.l myLibraryBase,a6",
            "id": "4f40f0b21781d11cc93c60fad860419e"
          },
          {
            "type": "code",
            "text": "     move.l 8(a7),d0\n     move.l 12(a7),d1\n     move.l 16(a7),a0\n     move.l 20(a7),a1\n     jsr    _LVOsomeLibraryProcedure(a6)\n     move.l (a7)+,a6\n     rts",
            "id": "8b90a74a32210a8cb83fb0ce8ba712f9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "518d1059c179fbe32a375b73305f1ba5"
          },
          {
            "type": "html",
            "text": "How is this officially implemented in \"proper\" FP?:",
            "id": "188b0532b7121cddb1703eec04beebe9"
          },
          {
            "type": "code",
            "text": "  destroyWorld();",
            "id": "2c6735a326ab7d01c61efdeae47a6eb3"
          },
          {
            "type": "html",
            "text": "Would it be:",
            "id": "d20848b217b85c13db800ff1db8d9a68"
          },
          {
            "type": "code",
            "text": "  brokenWorld = destroy(goodWorld);",
            "id": "f839e943a58f461560b768ba5a0aa3a0"
          },
          {
            "type": "html",
            "text": "?",
            "id": "44ebf18e0ed573b0d8a49aae5aee4938"
          },
          {
            "type": "html",
            "text": "<i>Yes.  Of course, within [[Haskell Language]] you could use the special monad syntax to hide the explicit passing of the goodWorld.</i> ",
            "id": "03a8300e0d027b2c4c20f0925ee2bde4"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ProcedureWithNoArguments c2.com]",
            "id": "cada1312a4bd8afcc40b09c5c44a15b3"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1644989204495
    }
  ]
}