{
  "title": "Navigational Database",
  "story": [
    {
      "type": "html",
      "text": "A term sometimes used to describe [[Network Database]] (a.k.a. \"Codasyl database) and [[Hierarchical Database]] systems and techniques. This is because one often has to \"navigate\" from node to node (object-to-object or record-to-record) by \"pointer hopping\" or \"reference hopping\". The navigation is characterized by:",
      "id": "66712351b0351845b153865f54094479"
    },
    {
      "type": "html",
      "text": " Explicit directional instructions like \"next\", \"previous\", \"nextChild\", \"toParent\", etc., ",
      "id": "e6e0d2b32344641ecf749ab2616acbc3"
    },
    {
      "type": "html",
      "text": " Paths (like file paths)",
      "id": "2c4cc3af99ba50b7235870152d2e4946"
    },
    {
      "type": "html",
      "text": " Common use of explicit (imperative) loops to traverse the structure(s) for aggregate calculations or finding/filtering.",
      "id": "325553990d15f6a7739ba4250963e614"
    },
    {
      "type": "html",
      "text": "\nThis is in contrast to [[Relational Database]] techniques which tend to use set notation, [[Logic Programming]]-like or [[Functional Programming]]-like techniques, and the concept of a \"table\" to logically describe what you want rather than how to navigate to get it. In other words, \"give me results which satisfy the following expressions(s) or condition(s)\". Although this may be possible with navigational \"records\", a navigational database's lack of \"table constraints\" makes it more difficult.",
      "id": "55fcccd705ee8e704c49eec9ea1ef13a"
    },
    {
      "type": "html",
      "text": "\nSee comparisons at [http://unixspace.com/context/databases.html unixspace.com]",
      "id": "5210742b9fd6819ac1005257aa375fbd"
    },
    {
      "type": "html",
      "text": "(Perhaps this should be called [[Navigational Structures]], because code-centric techniques can also resemble [[Navigational Database]]s.)",
      "id": "6529f9c7331ff292bbffe41cda19c009"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "206b55aa46650565e973f0962f62f3bb"
    },
    {
      "type": "html",
      "text": "\nFans of relational technology use this term pejoratively to describe any non-relational means of data organization or persistence.",
      "id": "ea8b416225b090552d9b3bd1a358540e"
    },
    {
      "type": "html",
      "text": "\nsee [[Navigational Database Codeword]]",
      "id": "38a92563d82ba7cc7bfb03db0eae4bd5"
    },
    {
      "type": "html",
      "text": "<i>Why does it have to be pejorative? If you like navigational techniques, then wear it as a badge of honor. I would be interested to see it defended. -- A [[Relational Weenie]]</i>",
      "id": "ae58d0254e5fd5e9c83e23c1e36c2699"
    },
    {
      "type": "html",
      "text": "\nIt's not just a matter of subjective preference - both approaches have distinct advantages and disadvantages. And the term \"navigational\" is used pejoratively with the relational crowd because in the \"classical\" domain of databases - long-term storage of enterprise data, used by many applications - navigational databases are a kind of \"proven antipattern\". They tie the application-independent, long-lived core data too closely to application-dependent, shorter-lived navigational patterns. See [[Decouple Data And Navigational Information]].",
      "id": "55c0709f1911d22cf9a15e5206385c11"
    },
    {
      "type": "html",
      "text": " The problem, of course, is this negative connotation is extrapolated <i>beyond</i> the realm of enterprise data to other areas, where navagational data structures (one can, of course, have both navigational and relational sturctures independent of a database) are entirely appropriate.",
      "id": "9958eed1b8fc848da52b3df7cdf1c88c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "206b55aa46650565e973f0962f62f3bb"
    },
    {
      "type": "html",
      "text": "\nSome stuff moved to [[Navigational Vs Relational]]",
      "id": "542af5829a33188fc66bc919604bb018"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "206b55aa46650565e973f0962f62f3bb"
    },
    {
      "type": "html",
      "text": "<b>Text Indexing</b>",
      "id": "0225d87baad5deafffffbf3922a48fd4"
    },
    {
      "type": "html",
      "text": "\n[[Wiki Wiki]] is a [[Navigational Database]] of sorts. Sort of. There are certain commonalities between each \"record\" (topic) such as the reverse index when you click the title, and most information retrieval is done by hopping across links.",
      "id": "2a59cae73755dcab37b6c12a32f94016"
    },
    {
      "type": "html",
      "text": "\nIf you tried to do Wiki relationally, you'd wind up storing the \"reverse index\" and then piecing the results together on each hit. For performance, you'd probably tell your RDBMS to keep an index, which is itself a hidden secret navigational database.",
      "id": "0af514887da273cb92200e408370a495"
    },
    {
      "type": "html",
      "text": "<i>I will agree that most RDBMS engines are not very efficient at indexing text. However, that is mostly an implementation issue. Note that if I redid Wiki the way I wanted it, it would use more relational-friendly features. I could perhaps use a separate text indexing tool for non-topic text searches. How relational fits in with text queries is an interesting topic to ponder.</i>",
      "id": "7606b349bf71e0a8cb56c93b091311f4"
    },
    {
      "type": "html",
      "text": "\nRe: <i>an index, which is itself a hidden secret navigational database</i>",
      "id": "3fd377f1f4da6e00842dff28bca93a7a"
    },
    {
      "type": "html",
      "text": "\nTrue, but that is a low-level implementation detail to most application developers. It also uses 1's and 0's, but that does not mean that humans should also. We use low level things like binary and navigational structures to build higher-level things, like relational protocols. (I know, a [[My Abstraction Is Higher Than Yours]] [[Holy War]].)",
      "id": "c5185f859cf56970e8b3f5fdfa77845f"
    },
    {
      "type": "html",
      "text": "<i>Plus, it's functionally transparent. You can add or remove indexes from a relational database, and the applications that use the database will still work (just with different performance characteristics). The same is not true for navigational databases - remove a navigational structure from the database, and the applications that use it will break. Want to write a new application that traverses the data in a different way? With navigational databases, you have to touch the database, with relational databases, you don't.</i>",
      "id": "a0fb12aead3be1733aced023eed65364"
    },
    {
      "type": "html",
      "text": "\nIMHO, and as far as I understand the conversation here navigational databases are more apt for certain purposes (such as directories with hierarchical natures (LDAP, etc)). So, a new application that traverses data stored in a navigational database in a new manner in fact needs a new database altogether, and is in fact a whole different app from the original. If it were on a relational database, yes, you wouldn't need to touch the database, but that would be in fact kludging the data for a new purpose. But why would you want to, say rewrite the telephone directory? Unless you understand the purpose of the data in the first place, you should use the proper tool. Relational databases are for data that have intrinsic relations, while navigational databases are for data with intrinsic structure. So, don't kludge a hierarchical directory into a relational db nor kludge something like a purchasing, sales, inventory system into a hierarchical db.",
      "id": "8417113b449749db33db57a397dd1a72"
    },
    {
      "type": "html",
      "text": "(Of course, I might be <i>completely</i> wrong on this point. My two cents, correct me if I'm wrong) -[[Jm Ibanez]]",
      "id": "52d2ea72c2f30f8af790e8834f9a515e"
    },
    {
      "type": "html",
      "text": "<i>What's the difference beteween data with \"intrinsic structure\" and data with \"intrinsic relations\"?  Is there some objective standard that one can use to tell the difference?</i>",
      "id": "878bbdf861e86070595e9b8cad5d3a1a"
    },
    {
      "type": "html",
      "text": "\nMy experience is that relational databases are the best solution for fast ad hoc queries.  If you know that you don't know all of the ways data will be queried, use a relational database as soon as possible.  Navigational databases can be faster, but you need to know how the data will be queried up front. -- [[Eric Hodges]]",
      "id": "62508db5b7b920df38c35e0f86b1b0f9"
    },
    {
      "type": "html",
      "text": "\n[[Are Rdbms Slow]]",
      "id": "012c2bc716f441e17599d108d6b1be84"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "206b55aa46650565e973f0962f62f3bb"
    },
    {
      "type": "html",
      "text": "\nSome databases labeled as [[Navigational Database]]s actually are not pure navigational. IBM's IMS database had \"segments\", which are sort of a primitive type of table structure, and within a segment you could issue constraint-based ([[Where And And]]) queries roughly resembling \"Amount greater than 40 and state is Arizona\". It thus had a foot in the relatioinal door. I wonder if this influenced [[Dr Codd]]?",
      "id": "c3fabc41b0adddba067ad996e40ad8f1"
    },
    {
      "type": "html",
      "text": "\nI think the \"segments\" are based on the punched card concept. You have fixed-sized columns and hoped that the cards you used fit the column convention you needed.  ",
      "id": "fad3b3728185fa424952470df8ceb619"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "206b55aa46650565e973f0962f62f3bb"
    },
    {
      "type": "html",
      "text": "\nIt is possible that the term \"navigational database\" originated in speeches given by Dr. Bachman, a competitor to [[Dr Codd]]<i></i>'s ideas. A quote from [[Modern Dinosaur]]:",
      "id": "463c27c501d47966e584d08dbc3e7cf2"
    },
    {
      "type": "html",
      "text": "<i>\"Bachman talked about \"programmer as navigator\" in the sense that database accesses is essentially navigation from one record to another along the edges of the Network or Hierarchical data model\"</i>",
      "id": "c742a8698a56ea324cb687e823a4e3a5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "206b55aa46650565e973f0962f62f3bb"
    },
    {
      "type": "html",
      "text": "\n[[Document Object Model]] (DOM) is a smaller example of a [[Navigational Database]]. DOM is mostly, but not entirely a [[Hierarchical Database]], since lower leaves can reference higher leaves. It would be interesting to contrast it to a relational version ([[Non Oop Gui Methodologies]]). ",
      "id": "8ecc417a90933ba1ee906dcdc4c1ea1e"
    },
    {
      "type": "html",
      "text": "<i>[[Document Object Model]] (DOM) and XML remind me of IMS the proprietary hierarchical IBM database. ??</i>",
      "id": "93eb3a2c11c8c647255813f87af80caa"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "206b55aa46650565e973f0962f62f3bb"
    },
    {
      "type": "html",
      "text": "\nThese sorts of contrasts have been made, altough only informally, as in this very page. In general, socalled \"semi-structured\" data seems to be best served with a navigational model.",
      "id": "2538ad5225c78452ecd020cd151eda01"
    },
    {
      "type": "html",
      "text": "\nI'm in the process of creating bases for a formal analysis of this issue, see the [[Untyped Network Hypothesis]].",
      "id": "ed92208f40f9ad03d5b87bf109cc89b0"
    },
    {
      "type": "html",
      "text": "--[[Marius Amado Alves]]",
      "id": "3dfab122927ca4967ddc964ca4b4cc20"
    },
    {
      "type": "html",
      "text": "<i>I am curious to see your opinion on \"dynamic relational\", as described in [[Multi Paradigm Database]].</i>",
      "id": "369da6b76ebdd44ea0a011d0bf7a9dad"
    },
    {
      "type": "html",
      "text": "\"dynamic relational\" not found there.--[[Marius Amado Alves]]",
      "id": "68847f0a92023b479bcde723597c7ae5"
    },
    {
      "type": "html",
      "text": "\nIt is an alias for what is being described there.",
      "id": "fe56f02a43acd03c1433fba0a09385e8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "206b55aa46650565e973f0962f62f3bb"
    },
    {
      "type": "html",
      "text": "\nI have generally concluded that navigational structures are essentially webs of dictionary arrays (maps) with pointers to other maps. Perhaps they should be called \"map-based databases\". -- top",
      "id": "2d7c5d2eb3bd558b557c2b3ab1b95ac2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "206b55aa46650565e973f0962f62f3bb"
    },
    {
      "type": "html",
      "text": "\nI think of navigational databases (and I like top's \"map-based databases\") for [[Semi Structured Data]] collections, where you don't really know, beforehand, what it's shape is going to be, or what you're going to need.",
      "id": "4b87636d39f41e8a7990b7cf141f2ac5"
    },
    {
      "type": "html",
      "text": "\nIf I was going to model my understanding of the world, I'd do it with a [[Navigational Database]].",
      "id": "01289cd8d03cc85cc25dab045f8b2820"
    },
    {
      "type": "html",
      "text": "\nA [[Relational Database]], on the other hand, strikes me as appropriate for <i>large collections</i> of <i>regular data</i> that you have a pretty good idea of how you're structuring it, for efficient retrieval.",
      "id": "9c6d7ee7ebcb505a8f32c783fbdf6a17"
    },
    {
      "type": "html",
      "text": "\nI can see situations where I would take something that was semi-structured, and, as the data in it began to take on a uniform form, turn it into structured, relational data.",
      "id": "5cabd29820b0aba86027b2b406603a34"
    },
    {
      "type": "html",
      "text": "\nWhen I think of the [[Semantic Web]], I envision it as a mixture of the loose semi-structured data (navigational based) and large blocks of relational data.",
      "id": "8ffc234de4bf33046529f68c6a068dc2"
    },
    {
      "type": "html",
      "text": "\nIf I were to remake the [[Resource Description Framework]] (RDF) in light of this thought, I'd have two basic forms:  tabular, and nodal -- and I would consider a sort of glue for connecting them together, across the network, as [[Networked Data]] / [[Linked Data]].",
      "id": "4e2c9b98a334d830e94eb7ef2233bac3"
    },
    {
      "type": "html",
      "text": "-- [[Lion Kimbro]]",
      "id": "563e7e76f04f3eeb8607d7c90d576ab1"
    },
    {
      "type": "html",
      "text": "\nMy preference of tools would look something like this:",
      "id": "ed68ba839f0af808891795ef5c2d0704"
    },
    {
      "type": "html",
      "text": " Unstructured - [[Multi Paradigm Database]]",
      "id": "db6c1e0d6fdf3b192f2b68ff45ab17a4"
    },
    {
      "type": "html",
      "text": " Semi-Structured - [[Dynamic Relational]]",
      "id": "05e2703fc127550c241c12c9705987e1"
    },
    {
      "type": "html",
      "text": " Structured - \"Typical\" RDBMS",
      "id": "0889349073d5754521bd701c99d00f7d"
    },
    {
      "type": "html",
      "text": "\nAs we go down the list, more constraints are added. But, the one thing that may be the dividing line between \"navigational\" and \"relational\" is the requirement that each row belong to one and only one \"table\" and that there be multiple tables. This makes sense because \"relational\" is a mathematical term for \"table\" (and not \"key links\", as is a common misconception). In the [[Multi Paradigm Database]], tables (entities) are optional, so out-of-the-box it is \"navigational\".",
      "id": "a56c0a166f1a4b87f758e0bd90483b46"
    },
    {
      "type": "html",
      "text": "\nBut, what separates [[Multi Paradigm Database]] from many navigational databases is that one can do predicate filtering (WHERE clause) on the rows (maps) instead of having to just follow pointers. I am not sure whether predicate filtering affects the classification of a database. Perhaps we need a more sophisticated DB classification system. Predicates and one-table-per-node may be orthogonal features. But then again, I've never seen a non-predicate one-table-per-node database. Whether this is just a historical habit or there is some natural relationship between the two requires more pondering.",
      "id": "9d446ca2ace6e069b23e08c1eeca3504"
    },
    {
      "type": "html",
      "text": "-top",
      "id": "10a9fc7b0dc26776a48bf9fa07ba9a93"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "206b55aa46650565e973f0962f62f3bb"
    },
    {
      "type": "html",
      "text": "\nSee Also: [[Multi Paradigm Database]], [[Oo Lacks Math Argument]], [[Decouple Data And Navigational Information]]",
      "id": "0693d3825dd502aee5794013ba7a41fd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "206b55aa46650565e973f0962f62f3bb"
    },
    {
      "type": "html",
      "text": "[[Category Classification]], [[Category Data Structure]]",
      "id": "c6f0ee48e292dc1a610ddcda653c663b"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?NavigationalDatabase c2.com]",
      "id": "6601990eeb423a576f816554e4c71208"
    }
  ],
  "journal": [
    {
      "date": 1300911201000,
      "id": "afa4a74551a20a9a1b0414c3350f009d",
      "type": "create",
      "item": {
        "title": "Navigational Database",
        "story": [
          {
            "type": "html",
            "text": "A term sometimes used to describe [[Network Database]] (a.k.a. \"Codasyl database) and [[Hierarchical Database]] systems and techniques. This is because one often has to \"navigate\" from node to node (object-to-object or record-to-record) by \"pointer hopping\" or \"reference hopping\". The navigation is characterized by:",
            "id": "66712351b0351845b153865f54094479"
          },
          {
            "type": "html",
            "text": " Explicit directional instructions like \"next\", \"previous\", \"nextChild\", \"toParent\", etc., ",
            "id": "e6e0d2b32344641ecf749ab2616acbc3"
          },
          {
            "type": "html",
            "text": " Paths (like file paths)",
            "id": "2c4cc3af99ba50b7235870152d2e4946"
          },
          {
            "type": "html",
            "text": " Common use of explicit (imperative) loops to traverse the structure(s) for aggregate calculations or finding/filtering.",
            "id": "325553990d15f6a7739ba4250963e614"
          },
          {
            "type": "html",
            "text": "\nThis is in contrast to [[Relational Database]] techniques which tend to use set notation, [[Logic Programming]]-like or [[Functional Programming]]-like techniques, and the concept of a \"table\" to logically describe what you want rather than how to navigate to get it. In other words, \"give me results which satisfy the following expressions(s) or condition(s)\". Although this may be possible with navigational \"records\", a navigational database's lack of \"table constraints\" makes it more difficult.",
            "id": "55fcccd705ee8e704c49eec9ea1ef13a"
          },
          {
            "type": "html",
            "text": "\nSee comparisons at [http://unixspace.com/context/databases.html unixspace.com]",
            "id": "5210742b9fd6819ac1005257aa375fbd"
          },
          {
            "type": "html",
            "text": "(Perhaps this should be called [[Navigational Structures]], because code-centric techniques can also resemble [[Navigational Database]]s.)",
            "id": "6529f9c7331ff292bbffe41cda19c009"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "206b55aa46650565e973f0962f62f3bb"
          },
          {
            "type": "html",
            "text": "\nFans of relational technology use this term pejoratively to describe any non-relational means of data organization or persistence.",
            "id": "ea8b416225b090552d9b3bd1a358540e"
          },
          {
            "type": "html",
            "text": "\nsee [[Navigational Database Codeword]]",
            "id": "38a92563d82ba7cc7bfb03db0eae4bd5"
          },
          {
            "type": "html",
            "text": "<i>Why does it have to be pejorative? If you like navigational techniques, then wear it as a badge of honor. I would be interested to see it defended. -- A [[Relational Weenie]]</i>",
            "id": "ae58d0254e5fd5e9c83e23c1e36c2699"
          },
          {
            "type": "html",
            "text": "\nIt's not just a matter of subjective preference - both approaches have distinct advantages and disadvantages. And the term \"navigational\" is used pejoratively with the relational crowd because in the \"classical\" domain of databases - long-term storage of enterprise data, used by many applications - navigational databases are a kind of \"proven antipattern\". They tie the application-independent, long-lived core data too closely to application-dependent, shorter-lived navigational patterns. See [[Decouple Data And Navigational Information]].",
            "id": "55c0709f1911d22cf9a15e5206385c11"
          },
          {
            "type": "html",
            "text": " The problem, of course, is this negative connotation is extrapolated <i>beyond</i> the realm of enterprise data to other areas, where navagational data structures (one can, of course, have both navigational and relational sturctures independent of a database) are entirely appropriate.",
            "id": "9958eed1b8fc848da52b3df7cdf1c88c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "206b55aa46650565e973f0962f62f3bb"
          },
          {
            "type": "html",
            "text": "\nSome stuff moved to [[Navigational Vs Relational]]",
            "id": "542af5829a33188fc66bc919604bb018"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "206b55aa46650565e973f0962f62f3bb"
          },
          {
            "type": "html",
            "text": "<b>Text Indexing</b>",
            "id": "0225d87baad5deafffffbf3922a48fd4"
          },
          {
            "type": "html",
            "text": "\n[[Wiki Wiki]] is a [[Navigational Database]] of sorts. Sort of. There are certain commonalities between each \"record\" (topic) such as the reverse index when you click the title, and most information retrieval is done by hopping across links.",
            "id": "2a59cae73755dcab37b6c12a32f94016"
          },
          {
            "type": "html",
            "text": "\nIf you tried to do Wiki relationally, you'd wind up storing the \"reverse index\" and then piecing the results together on each hit. For performance, you'd probably tell your RDBMS to keep an index, which is itself a hidden secret navigational database.",
            "id": "0af514887da273cb92200e408370a495"
          },
          {
            "type": "html",
            "text": "<i>I will agree that most RDBMS engines are not very efficient at indexing text. However, that is mostly an implementation issue. Note that if I redid Wiki the way I wanted it, it would use more relational-friendly features. I could perhaps use a separate text indexing tool for non-topic text searches. How relational fits in with text queries is an interesting topic to ponder.</i>",
            "id": "7606b349bf71e0a8cb56c93b091311f4"
          },
          {
            "type": "html",
            "text": "\nRe: <i>an index, which is itself a hidden secret navigational database</i>",
            "id": "3fd377f1f4da6e00842dff28bca93a7a"
          },
          {
            "type": "html",
            "text": "\nTrue, but that is a low-level implementation detail to most application developers. It also uses 1's and 0's, but that does not mean that humans should also. We use low level things like binary and navigational structures to build higher-level things, like relational protocols. (I know, a [[My Abstraction Is Higher Than Yours]] [[Holy War]].)",
            "id": "c5185f859cf56970e8b3f5fdfa77845f"
          },
          {
            "type": "html",
            "text": "<i>Plus, it's functionally transparent. You can add or remove indexes from a relational database, and the applications that use the database will still work (just with different performance characteristics). The same is not true for navigational databases - remove a navigational structure from the database, and the applications that use it will break. Want to write a new application that traverses the data in a different way? With navigational databases, you have to touch the database, with relational databases, you don't.</i>",
            "id": "a0fb12aead3be1733aced023eed65364"
          },
          {
            "type": "html",
            "text": "\nIMHO, and as far as I understand the conversation here navigational databases are more apt for certain purposes (such as directories with hierarchical natures (LDAP, etc)). So, a new application that traverses data stored in a navigational database in a new manner in fact needs a new database altogether, and is in fact a whole different app from the original. If it were on a relational database, yes, you wouldn't need to touch the database, but that would be in fact kludging the data for a new purpose. But why would you want to, say rewrite the telephone directory? Unless you understand the purpose of the data in the first place, you should use the proper tool. Relational databases are for data that have intrinsic relations, while navigational databases are for data with intrinsic structure. So, don't kludge a hierarchical directory into a relational db nor kludge something like a purchasing, sales, inventory system into a hierarchical db.",
            "id": "8417113b449749db33db57a397dd1a72"
          },
          {
            "type": "html",
            "text": "(Of course, I might be <i>completely</i> wrong on this point. My two cents, correct me if I'm wrong) -[[Jm Ibanez]]",
            "id": "52d2ea72c2f30f8af790e8834f9a515e"
          },
          {
            "type": "html",
            "text": "<i>What's the difference beteween data with \"intrinsic structure\" and data with \"intrinsic relations\"?  Is there some objective standard that one can use to tell the difference?</i>",
            "id": "878bbdf861e86070595e9b8cad5d3a1a"
          },
          {
            "type": "html",
            "text": "\nMy experience is that relational databases are the best solution for fast ad hoc queries.  If you know that you don't know all of the ways data will be queried, use a relational database as soon as possible.  Navigational databases can be faster, but you need to know how the data will be queried up front. -- [[Eric Hodges]]",
            "id": "62508db5b7b920df38c35e0f86b1b0f9"
          },
          {
            "type": "html",
            "text": "\n[[Are Rdbms Slow]]",
            "id": "012c2bc716f441e17599d108d6b1be84"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "206b55aa46650565e973f0962f62f3bb"
          },
          {
            "type": "html",
            "text": "\nSome databases labeled as [[Navigational Database]]s actually are not pure navigational. IBM's IMS database had \"segments\", which are sort of a primitive type of table structure, and within a segment you could issue constraint-based ([[Where And And]]) queries roughly resembling \"Amount greater than 40 and state is Arizona\". It thus had a foot in the relatioinal door. I wonder if this influenced [[Dr Codd]]?",
            "id": "c3fabc41b0adddba067ad996e40ad8f1"
          },
          {
            "type": "html",
            "text": "\nI think the \"segments\" are based on the punched card concept. You have fixed-sized columns and hoped that the cards you used fit the column convention you needed.  ",
            "id": "fad3b3728185fa424952470df8ceb619"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "206b55aa46650565e973f0962f62f3bb"
          },
          {
            "type": "html",
            "text": "\nIt is possible that the term \"navigational database\" originated in speeches given by Dr. Bachman, a competitor to [[Dr Codd]]<i></i>'s ideas. A quote from [[Modern Dinosaur]]:",
            "id": "463c27c501d47966e584d08dbc3e7cf2"
          },
          {
            "type": "html",
            "text": "<i>\"Bachman talked about \"programmer as navigator\" in the sense that database accesses is essentially navigation from one record to another along the edges of the Network or Hierarchical data model\"</i>",
            "id": "c742a8698a56ea324cb687e823a4e3a5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "206b55aa46650565e973f0962f62f3bb"
          },
          {
            "type": "html",
            "text": "\n[[Document Object Model]] (DOM) is a smaller example of a [[Navigational Database]]. DOM is mostly, but not entirely a [[Hierarchical Database]], since lower leaves can reference higher leaves. It would be interesting to contrast it to a relational version ([[Non Oop Gui Methodologies]]). ",
            "id": "8ecc417a90933ba1ee906dcdc4c1ea1e"
          },
          {
            "type": "html",
            "text": "<i>[[Document Object Model]] (DOM) and XML remind me of IMS the proprietary hierarchical IBM database. ??</i>",
            "id": "93eb3a2c11c8c647255813f87af80caa"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "206b55aa46650565e973f0962f62f3bb"
          },
          {
            "type": "html",
            "text": "\nThese sorts of contrasts have been made, altough only informally, as in this very page. In general, socalled \"semi-structured\" data seems to be best served with a navigational model.",
            "id": "2538ad5225c78452ecd020cd151eda01"
          },
          {
            "type": "html",
            "text": "\nI'm in the process of creating bases for a formal analysis of this issue, see the [[Untyped Network Hypothesis]].",
            "id": "ed92208f40f9ad03d5b87bf109cc89b0"
          },
          {
            "type": "html",
            "text": "--[[Marius Amado Alves]]",
            "id": "3dfab122927ca4967ddc964ca4b4cc20"
          },
          {
            "type": "html",
            "text": "<i>I am curious to see your opinion on \"dynamic relational\", as described in [[Multi Paradigm Database]].</i>",
            "id": "369da6b76ebdd44ea0a011d0bf7a9dad"
          },
          {
            "type": "html",
            "text": "\"dynamic relational\" not found there.--[[Marius Amado Alves]]",
            "id": "68847f0a92023b479bcde723597c7ae5"
          },
          {
            "type": "html",
            "text": "\nIt is an alias for what is being described there.",
            "id": "fe56f02a43acd03c1433fba0a09385e8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "206b55aa46650565e973f0962f62f3bb"
          },
          {
            "type": "html",
            "text": "\nI have generally concluded that navigational structures are essentially webs of dictionary arrays (maps) with pointers to other maps. Perhaps they should be called \"map-based databases\". -- top",
            "id": "2d7c5d2eb3bd558b557c2b3ab1b95ac2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "206b55aa46650565e973f0962f62f3bb"
          },
          {
            "type": "html",
            "text": "\nI think of navigational databases (and I like top's \"map-based databases\") for [[Semi Structured Data]] collections, where you don't really know, beforehand, what it's shape is going to be, or what you're going to need.",
            "id": "4b87636d39f41e8a7990b7cf141f2ac5"
          },
          {
            "type": "html",
            "text": "\nIf I was going to model my understanding of the world, I'd do it with a [[Navigational Database]].",
            "id": "01289cd8d03cc85cc25dab045f8b2820"
          },
          {
            "type": "html",
            "text": "\nA [[Relational Database]], on the other hand, strikes me as appropriate for <i>large collections</i> of <i>regular data</i> that you have a pretty good idea of how you're structuring it, for efficient retrieval.",
            "id": "9c6d7ee7ebcb505a8f32c783fbdf6a17"
          },
          {
            "type": "html",
            "text": "\nI can see situations where I would take something that was semi-structured, and, as the data in it began to take on a uniform form, turn it into structured, relational data.",
            "id": "5cabd29820b0aba86027b2b406603a34"
          },
          {
            "type": "html",
            "text": "\nWhen I think of the [[Semantic Web]], I envision it as a mixture of the loose semi-structured data (navigational based) and large blocks of relational data.",
            "id": "8ffc234de4bf33046529f68c6a068dc2"
          },
          {
            "type": "html",
            "text": "\nIf I were to remake the [[Resource Description Framework]] (RDF) in light of this thought, I'd have two basic forms:  tabular, and nodal -- and I would consider a sort of glue for connecting them together, across the network, as [[Networked Data]] / [[Linked Data]].",
            "id": "4e2c9b98a334d830e94eb7ef2233bac3"
          },
          {
            "type": "html",
            "text": "-- [[Lion Kimbro]]",
            "id": "563e7e76f04f3eeb8607d7c90d576ab1"
          },
          {
            "type": "html",
            "text": "\nMy preference of tools would look something like this:",
            "id": "ed68ba839f0af808891795ef5c2d0704"
          },
          {
            "type": "html",
            "text": " Unstructured - [[Multi Paradigm Database]]",
            "id": "db6c1e0d6fdf3b192f2b68ff45ab17a4"
          },
          {
            "type": "html",
            "text": " Semi-Structured - [[Dynamic Relational]]",
            "id": "05e2703fc127550c241c12c9705987e1"
          },
          {
            "type": "html",
            "text": " Structured - \"Typical\" RDBMS",
            "id": "0889349073d5754521bd701c99d00f7d"
          },
          {
            "type": "html",
            "text": "\nAs we go down the list, more constraints are added. But, the one thing that may be the dividing line between \"navigational\" and \"relational\" is the requirement that each row belong to one and only one \"table\" and that there be multiple tables. This makes sense because \"relational\" is a mathematical term for \"table\" (and not \"key links\", as is a common misconception). In the [[Multi Paradigm Database]], tables (entities) are optional, so out-of-the-box it is \"navigational\".",
            "id": "a56c0a166f1a4b87f758e0bd90483b46"
          },
          {
            "type": "html",
            "text": "\nBut, what separates [[Multi Paradigm Database]] from many navigational databases is that one can do predicate filtering (WHERE clause) on the rows (maps) instead of having to just follow pointers. I am not sure whether predicate filtering affects the classification of a database. Perhaps we need a more sophisticated DB classification system. Predicates and one-table-per-node may be orthogonal features. But then again, I've never seen a non-predicate one-table-per-node database. Whether this is just a historical habit or there is some natural relationship between the two requires more pondering.",
            "id": "9d446ca2ace6e069b23e08c1eeca3504"
          },
          {
            "type": "html",
            "text": "-top",
            "id": "10a9fc7b0dc26776a48bf9fa07ba9a93"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "206b55aa46650565e973f0962f62f3bb"
          },
          {
            "type": "html",
            "text": "\nSee Also: [[Multi Paradigm Database]], [[Oo Lacks Math Argument]], [[Decouple Data And Navigational Information]]",
            "id": "0693d3825dd502aee5794013ba7a41fd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "206b55aa46650565e973f0962f62f3bb"
          },
          {
            "type": "html",
            "text": "[[Category Classification]], [[Category Data Structure]]",
            "id": "c6f0ee48e292dc1a610ddcda653c663b"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?NavigationalDatabase c2.com]",
            "id": "6601990eeb423a576f816554e4c71208"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1708264864357
    }
  ]
}