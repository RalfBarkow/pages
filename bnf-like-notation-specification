{
  "title": "BNF-like Notation Specification",
  "story": [
    {
      "type": "paragraph",
      "id": "9991c87f84f974eb",
      "text": "\nQUESADA, Luis, BERZAL, Fernando and CUBERO, Juan-Carlos, 2011. A Language Specification Tool for Model-Based Parsing. In: YIN, Hujun, WANG, Wenjia and RAYWARD-SMITH, Victor (eds.), Intelligent Data Engineering and Automated Learning - IDEAL 2011. Berlin, Heidelberg: Springer. 2011. p. 50–57. Lecture Notes in Computer Science. ISBN 978-3-642-23878-9. DOI 10.1007/978-3-642-23878-9_7. "
    },
    {
      "type": "markdown",
      "id": "6f288cdd276331f5",
      "text": "> Typically, formal languages are described by providing a textual BNF-like notation specification, which is then manually annotated for syntax-directed translation. When the use of an explicit model is required, its implementation requires the development of the conversion steps between the model and the grammar, and between the parse tree and the model instance. Whenever the language specification is modified, the developer has to manually propagate changes throughout the entire language processor pipeline. These updates are time-consuming, tedious, and error-prone. Besides, in the case that different applications use the same language, the developer has to maintain several copies of the same language specification. In this paper, we introduce a model-based parser generator that decouples language specification from language processing, hence avoiding many of the problems caused by grammar-driven parsers and parser generators.\n"
    },
    {
      "type": "paragraph",
      "id": "ae4af6713ae1776a",
      "text": "Formal languages allow the expression of information in the form of symbol sequences [3]. A formal language consists of an alphabet, which describes the basic symbol or character set of the language, and a grammar, which describes how to form valid sentences in the language. In Computer Science, formal languages are used for the precise definition of the syntax of data formats and programming languages, among other things."
    },
    {
      "type": "paragraph",
      "id": "dd0ece126815f3bb",
      "text": "3. Chomsky, N.: Three models for the description of language. IRE Transactions on Information Theory 2, 113–123 (1956)"
    },
    {
      "type": "paragraph",
      "id": "cdfea476dbf18129",
      "text": "Most existing language specification techniques [2] require the developer to provide a textual specification of the language grammar. The proper specification of such a grammar is a nontrivial process that depends on the lexical and syntactic analysis techniques to be used, since each kind of technique requires the grammar to comply with different restrictions."
    },
    {
      "type": "paragraph",
      "id": "17d9a478fd867517",
      "text": "2. Aho, A.V., Ullman, J.D.: The Theory of Parsing, Translation, and Compiling, Volume I: Parsing & Volume II: Compiling. Prentice Hall, Englewood Cliffs (1972)"
    },
    {
      "type": "paragraph",
      "id": "2a1577321850f62f",
      "text": "When the use of an explicit model is required, its implementation requires the development of the conversion steps between the model and the grammar, and between the parse tree and the model instance. Thus, in this case, the implementation of the language processor becomes harder."
    },
    {
      "type": "paragraph",
      "id": "32c5adabcf673eb1",
      "text": "Whenever the language specification is modified, the developer has to manually propagate changes throughout the entire language processor pipeline. These updates are time-consuming, tedious, and error-prone. This hampers the maintainability and evolution of the language [11]."
    },
    {
      "type": "paragraph",
      "id": "a0de7562241bf5c7",
      "text": "11. Kats, L.C.L., Visser, E., Wachsmuth, G.: Pure and declarative syntax definition: paradise lost and regained. In: Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA 2010), pp. 918–932 (2010)"
    },
    {
      "type": "paragraph",
      "id": "4cd513181e924e7b",
      "text": "Typically, different applications that use the same language are developed. For example, the compiler, different code generators, and the tools within the IDE, such as the editor or the debugger. The traditional language processor development procedure enforces the maintenance of several copies of the same language specification in sync."
    },
    {
      "type": "paragraph",
      "id": "23710172f7123a44",
      "text": "In contrast, generating a model-based language specification is performed visually and does not require the development of any conversion steps. By following this approach, the model can be modified as needed without having to worry about the language processor, which will be automatically updated accordingly. Also, as the software code can be combined with the model in a clean fashion, there is no embedding or mixing with the language processor. Finally, as the model is not bound to a specific analysis technique, it is possible to evaluate the alternative or complementary techniques that fit a specific problem, without propagating the restrictions of the used analysis technique into the model."
    },
    {
      "type": "paragraph",
      "id": "85e4438385cc7b05",
      "text": "Our approach to model-based language specification has direct applications in the following fields:"
    },
    {
      "type": "markdown",
      "id": "229a8c215b9430ce",
      "text": "* The generation of language processors (compilers and interpreters) [1]. \n* The specification of domain-specific languages (DSLs), which are languages oriented to the domain of a particular problem, its representation, or the representation of a specific technique to solve it [7,8,17]. \n* The development of Model-Driven Software Development (MDSD) tools [21]. \n* Data integration, as part of the preprocessing process in data mining [22]. \n* Text mining applications [23,4], in order to extract high quality information from the analysis of huge text data bases. \n* Natural language processing [9] in restricted lexical and syntactic domains. \n* The corpus-based induction of models [12]."
    },
    {
      "type": "paragraph",
      "id": "060ff80a28710745",
      "text": "Although there are tools that generate language processors from graphical language specifications [19,6], to the best of our knowledge, no existing tool follows the approach we describe in this paper."
    },
    {
      "type": "paragraph",
      "id": "2c5224ea331ad80c",
      "text": "⇒ [[ModelCC]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "BNF-like Notation Specification",
        "story": []
      },
      "date": 1656004377692
    },
    {
      "id": "9991c87f84f974eb",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "9991c87f84f974eb",
        "text": "\nQUESADA, Luis, BERZAL, Fernando and CUBERO, Juan-Carlos, 2011. A Language Specification Tool for Model-Based Parsing. In: YIN, Hujun, WANG, Wenjia and RAYWARD-SMITH, Victor (eds.), Intelligent Data Engineering and Automated Learning - IDEAL 2011. Berlin, Heidelberg: Springer. 2011. p. 50–57. Lecture Notes in Computer Science. ISBN 978-3-642-23878-9. DOI 10.1007/978-3-642-23878-9_7. "
      },
      "date": 1656004391348
    },
    {
      "id": "6f288cdd276331f5",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "6f288cdd276331f5",
        "text": "> Typically, formal languages are described by providing a textual BNF-like notation specification, which is then manually annotated for syntax-directed translation. When the use of an explicit model is required, its implementation requires the development of the conversion steps between the model and the grammar, and between the parse tree and the model instance. Whenever the language specification is modified, the developer has to manually propagate changes throughout the entire language processor pipeline. These updates are time-consuming, tedious, and error-prone. Besides, in the case that different applications use the same language, the developer has to maintain several copies of the same language specification. In this paper, we introduce a model-based parser generator that decouples language specification from language processing, hence avoiding many of the problems caused by grammar-driven parsers and parser generators.\n"
      },
      "after": "9991c87f84f974eb",
      "date": 1656004396527
    },
    {
      "item": {
        "type": "factory",
        "id": "ae4af6713ae1776a"
      },
      "id": "ae4af6713ae1776a",
      "type": "add",
      "after": "6f288cdd276331f5",
      "date": 1656004458733
    },
    {
      "type": "edit",
      "id": "ae4af6713ae1776a",
      "item": {
        "type": "paragraph",
        "id": "ae4af6713ae1776a",
        "text": "Formal languages allow the expression of information in the form of symbol sequences [3]. A formal language consists of an alphabet, which describes the basic symbol or character set of the language, and a grammar, which describes how to form valid sentences in the language. In Computer Science, formal languages are used for the precise definition of the syntax of data formats and programming languages, among other things."
      },
      "date": 1656004460340
    },
    {
      "item": {
        "type": "factory",
        "id": "dd0ece126815f3bb"
      },
      "id": "dd0ece126815f3bb",
      "type": "add",
      "after": "ae4af6713ae1776a",
      "date": 1656004492960
    },
    {
      "type": "edit",
      "id": "dd0ece126815f3bb",
      "item": {
        "type": "paragraph",
        "id": "dd0ece126815f3bb",
        "text": "3. Chomsky, N.: Three models for the description of language. IRE Transactions on Information Theory 2, 113–123 (1956)"
      },
      "date": 1656004495286
    },
    {
      "item": {
        "type": "factory",
        "id": "cdfea476dbf18129"
      },
      "id": "cdfea476dbf18129",
      "type": "add",
      "after": "dd0ece126815f3bb",
      "date": 1656004573127
    },
    {
      "type": "edit",
      "id": "cdfea476dbf18129",
      "item": {
        "type": "paragraph",
        "id": "cdfea476dbf18129",
        "text": "Most existing language specification techniques [2] require the developer to provide a textual specification of the language grammar. The proper specification of such a grammar is a nontrivial process that depends on the lexical and syntactic analysis techniques to be used, since each kind of technique requires the grammar to comply with different restrictions."
      },
      "date": 1656004588117
    },
    {
      "item": {
        "type": "factory",
        "id": "17d9a478fd867517"
      },
      "id": "17d9a478fd867517",
      "type": "add",
      "after": "cdfea476dbf18129",
      "date": 1656004612872
    },
    {
      "type": "edit",
      "id": "17d9a478fd867517",
      "item": {
        "type": "paragraph",
        "id": "17d9a478fd867517",
        "text": "2. Aho, A.V., Ullman, J.D.: The Theory of Parsing, Translation, and Compiling, Volume I: Parsing & Volume II: Compiling. Prentice Hall, Englewood Cliffs (1972)"
      },
      "date": 1656004615591
    },
    {
      "item": {
        "type": "factory",
        "id": "2a1577321850f62f"
      },
      "id": "2a1577321850f62f",
      "type": "add",
      "after": "17d9a478fd867517",
      "date": 1656004650252
    },
    {
      "type": "edit",
      "id": "2a1577321850f62f",
      "item": {
        "type": "paragraph",
        "id": "2a1577321850f62f",
        "text": "When the use of an explicit model is required, its implementation requires the development of the conversion steps between the model and the grammar, and between the parse tree and the model instance. Thus, in this case, the implementation of the language processor becomes harder."
      },
      "date": 1656004653037
    },
    {
      "item": {
        "type": "factory",
        "id": "32c5adabcf673eb1"
      },
      "id": "32c5adabcf673eb1",
      "type": "add",
      "after": "2a1577321850f62f",
      "date": 1656004695197
    },
    {
      "type": "edit",
      "id": "32c5adabcf673eb1",
      "item": {
        "type": "paragraph",
        "id": "32c5adabcf673eb1",
        "text": "Whenever the language specification is modified, the developer has to manually propagate changes throughout the entire language processor pipeline. These updates are time-consuming, tedious, and error-prone. This hampers the maintainability and evolution of the language [11]."
      },
      "date": 1656004697771
    },
    {
      "item": {
        "type": "factory",
        "id": "a0de7562241bf5c7"
      },
      "id": "a0de7562241bf5c7",
      "type": "add",
      "after": "32c5adabcf673eb1",
      "date": 1656004721591
    },
    {
      "type": "edit",
      "id": "a0de7562241bf5c7",
      "item": {
        "type": "paragraph",
        "id": "a0de7562241bf5c7",
        "text": "11. Kats, L.C.L., Visser, E., Wachsmuth, G.: Pure and declarative syntax definition: paradise lost and regained. In: Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA 2010), pp. 918–932 (2010)"
      },
      "date": 1656004723637
    },
    {
      "item": {
        "type": "factory",
        "id": "4cd513181e924e7b"
      },
      "id": "4cd513181e924e7b",
      "type": "add",
      "after": "a0de7562241bf5c7",
      "date": 1656004756930
    },
    {
      "type": "edit",
      "id": "4cd513181e924e7b",
      "item": {
        "type": "paragraph",
        "id": "4cd513181e924e7b",
        "text": "Typically, different applications that use the same language are developed. For example, the compiler, different code generators, and the tools within the IDE, such as the editor or the debugger. The traditional language processor development procedure enforces the maintenance of several copies of the same language specification in sync."
      },
      "date": 1656004759019
    },
    {
      "item": {
        "type": "factory",
        "id": "23710172f7123a44"
      },
      "id": "23710172f7123a44",
      "type": "add",
      "after": "4cd513181e924e7b",
      "date": 1656004780750
    },
    {
      "type": "edit",
      "id": "23710172f7123a44",
      "item": {
        "type": "paragraph",
        "id": "23710172f7123a44",
        "text": "In contrast, generating a model-based language specification is performed visually and does not require the development of any conversion steps. By following this approach, the model can be modified as needed without having to worry about the language processor, which will be automatically updated accordingly. Also, as the software code can be combined with the model in a clean fashion, there is no embedding or mixing with the language processor. Finally, as the model is not bound to a specific analysis technique, it is possible to evaluate the alternative or complementary techniques that fit a specific problem, without propagating the restrictions of the used analysis technique into the model."
      },
      "date": 1656004782524
    },
    {
      "item": {
        "type": "factory",
        "id": "85e4438385cc7b05"
      },
      "id": "85e4438385cc7b05",
      "type": "add",
      "after": "23710172f7123a44",
      "date": 1656004815741
    },
    {
      "type": "edit",
      "id": "85e4438385cc7b05",
      "item": {
        "type": "paragraph",
        "id": "85e4438385cc7b05",
        "text": "Our approach to model-based language specification has direct applications in the following fields:"
      },
      "date": 1656004817403
    },
    {
      "item": {
        "type": "factory",
        "id": "229a8c215b9430ce"
      },
      "id": "229a8c215b9430ce",
      "type": "add",
      "after": "85e4438385cc7b05",
      "date": 1656004827588
    },
    {
      "type": "edit",
      "id": "229a8c215b9430ce",
      "item": {
        "type": "markdown",
        "id": "229a8c215b9430ce",
        "text": "– The generation of language processors (compilers and interpreters) [1]. – The specification of domain-specific languages (DSLs), which are languages oriented to the domain of a particular problem, its representation, or the representation of a specific technique to solve it [7,8,17]. – The development of Model-Driven Software Development (MDSD) tools [21]. – Data integration, as part of the preprocessing process in data mining [22]. – Text mining applications [23,4], in order to extract high quality information from the analysis of huge text data bases. – Natural language processing [9] in restricted lexical and syntactic domains. – The corpus-based induction of models [12]."
      },
      "date": 1656004829592
    },
    {
      "type": "edit",
      "id": "229a8c215b9430ce",
      "item": {
        "type": "markdown",
        "id": "229a8c215b9430ce",
        "text": "– The generation of language processors (compilers and interpreters) [1]. \n– The specification of domain-specific languages (DSLs), which are languages oriented to the domain of a particular problem, its representation, or the representation of a specific technique to solve it [7,8,17]. – The development of Model-Driven Software Development (MDSD) tools [21]. – Data integration, as part of the preprocessing process in data mining [22]. – Text mining applications [23,4], in order to extract high quality information from the analysis of huge text data bases. – Natural language processing [9] in restricted lexical and syntactic domains. – The corpus-based induction of models [12]."
      },
      "date": 1656004833953
    },
    {
      "type": "edit",
      "id": "229a8c215b9430ce",
      "item": {
        "type": "markdown",
        "id": "229a8c215b9430ce",
        "text": "– The generation of language processors (compilers and interpreters) [1]. \n– The specification of domain-specific languages (DSLs), which are languages oriented to the domain of a particular problem, its representation, or the representation of a specific technique to solve it [7,8,17]. \n– The development of Model-Driven Software Development (MDSD) tools [21]. "
      },
      "date": 1656004853761
    },
    {
      "type": "edit",
      "id": "229a8c215b9430ce",
      "item": {
        "type": "markdown",
        "id": "229a8c215b9430ce",
        "text": "– The generation of language processors (compilers and interpreters) [1]. \n– The specification of domain-specific languages (DSLs), which are languages oriented to the domain of a particular problem, its representation, or the representation of a specific technique to solve it [7,8,17]. \n– The development of Model-Driven Software Development (MDSD) tools [21]. \n– Data integration, as part of the preprocessing process in data mining [22]. \n– Text mining applications [23,4], in order to extract high quality information from the analysis of huge text data bases. \n– Natural language processing [9] in restricted lexical and syntactic domains. \n– The corpus-based induction of models [12]."
      },
      "date": 1656004870944
    },
    {
      "type": "edit",
      "id": "229a8c215b9430ce",
      "item": {
        "type": "markdown",
        "id": "229a8c215b9430ce",
        "text": "*The generation of language processors (compilers and interpreters) [1]. \n– The specification of domain-specific languages (DSLs), which are languages oriented to the domain of a particular problem, its representation, or the representation of a specific technique to solve it [7,8,17]. \n– The development of Model-Driven Software Development (MDSD) tools [21]. \n– Data integration, as part of the preprocessing process in data mining [22]. \n– Text mining applications [23,4], in order to extract high quality information from the analysis of huge text data bases. \n– Natural language processing [9] in restricted lexical and syntactic domains. \n– The corpus-based induction of models [12]."
      },
      "date": 1656004878714
    },
    {
      "type": "edit",
      "id": "229a8c215b9430ce",
      "item": {
        "type": "markdown",
        "id": "229a8c215b9430ce",
        "text": "* The generation of language processors (compilers and interpreters) [1]. \n– The specification of domain-specific languages (DSLs), which are languages oriented to the domain of a particular problem, its representation, or the representation of a specific technique to solve it [7,8,17]. \n– The development of Model-Driven Software Development (MDSD) tools [21]. \n– Data integration, as part of the preprocessing process in data mining [22]. \n– Text mining applications [23,4], in order to extract high quality information from the analysis of huge text data bases. \n– Natural language processing [9] in restricted lexical and syntactic domains. \n– The corpus-based induction of models [12]."
      },
      "date": 1656004881665
    },
    {
      "type": "edit",
      "id": "229a8c215b9430ce",
      "item": {
        "type": "markdown",
        "id": "229a8c215b9430ce",
        "text": "* The generation of language processors (compilers and interpreters) [1]. \n* The specification of domain-specific languages (DSLs), which are languages oriented to the domain of a particular problem, its representation, or the representation of a specific technique to solve it [7,8,17]. \n* The development of Model-Driven Software Development (MDSD) tools [21]. \n* Data integration, as part of the preprocessing process in data mining [22]. \n* Text mining applications [23,4], in order to extract high quality information from the analysis of huge text data bases. \n* Natural language processing [9] in restricted lexical and syntactic domains. \n* The corpus-based induction of models [12]."
      },
      "date": 1656004902796
    },
    {
      "item": {
        "type": "factory",
        "id": "060ff80a28710745"
      },
      "id": "060ff80a28710745",
      "type": "add",
      "after": "229a8c215b9430ce",
      "date": 1656004928816
    },
    {
      "type": "edit",
      "id": "060ff80a28710745",
      "item": {
        "type": "paragraph",
        "id": "060ff80a28710745",
        "text": "Although there are tools that generate language processors from graphical language specifications [19,6], to the best of our knowledge, no existing tool follows the approach we describe in this paper."
      },
      "date": 1656004930740
    },
    {
      "item": {
        "type": "factory",
        "id": "4f486ad32b1c2439"
      },
      "id": "4f486ad32b1c2439",
      "type": "add",
      "after": "060ff80a28710745",
      "date": 1656004949348
    },
    {
      "type": "edit",
      "id": "4f486ad32b1c2439",
      "item": {
        "type": "paragraph",
        "id": "4f486ad32b1c2439",
        "text": "In this paper, we introduce [[ModelCC]], a model-based tool for language specification. ModelCC acts as a parser generator that decouples language specification from language processing, hence avoiding many of the problems caused by grammar-driven parsers and parser generators."
      },
      "date": 1656004957269
    },
    {
      "item": {
        "type": "factory",
        "id": "2c5224ea331ad80c"
      },
      "id": "2c5224ea331ad80c",
      "type": "add",
      "after": "4f486ad32b1c2439",
      "date": 1656004966008
    },
    {
      "type": "edit",
      "id": "2c5224ea331ad80c",
      "item": {
        "type": "paragraph",
        "id": "2c5224ea331ad80c",
        "text": "⇒"
      },
      "date": 1656004969573
    },
    {
      "id": "4f486ad32b1c2439",
      "type": "remove",
      "date": 1656004973469
    },
    {
      "type": "edit",
      "id": "2c5224ea331ad80c",
      "item": {
        "type": "paragraph",
        "id": "2c5224ea331ad80c",
        "text": "⇒ [[ModelCC]]"
      },
      "date": 1656004986139
    }
  ]
}