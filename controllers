{
  "title": "Controllers",
  "story": [
    {
      "type": "paragraph",
      "id": "4b01796f6d3fb0a5",
      "text": "[[Controllers]] contain routines for sensing and handling user inputs such as; [[Mouse]] movement, keypresses and button clicks. The controllers are constantly polling for input using these routines. When some event occurs, the controller must determine its context (e.g., a shifted mouse button down event may be different then an unshifted one) and do the appropriate action. This approach has two major problems, [[Polling]] and lack of modularity."
    },
    {
      "type": "paragraph",
      "id": "44ff01d5e45f63ee",
      "text": "⇒ [[Polling]]"
    },
    {
      "type": "paragraph",
      "id": "83eafcaf6dc6a2bc",
      "text": "Since each type of view has its own input requirements and set of valid user interactions, each view has an associated controller which handles user input. In a typical system there are several different types of view and thus several different types of controller. These view/controller pairs normally fall into one of four broad groups; those dealing with text, lists or graphics and those dealing with aggregates of the above three."
    },
    {
      "type": "pagefold",
      "id": "fd5d51ee85747cdf",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "064d8725833ae553",
      "text": "See \"an [[Actor]]/Pawn pair\" ⇒ [[World Core Tutorial 1]]"
    },
    {
      "type": "pagefold",
      "id": "deac4bdef9f87584",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "83747542645e3ddf",
      "text": "Within a particular view/controller pair the code is modular, however the same is not true of the system as a whole. In each group, the view/controller pairs are organized hierarchically with subclasses differing only slightly from their superclasses and sharing most of their code. Because polling code tests a particular set of inputs, if a subclass recognizes one different input then it must reimplement the polling loop. This leads to a great deal of duplicate code and confuses the flow of control."
    },
    {
      "type": "paragraph",
      "id": "1a13c1a598e76356",
      "text": "To illustrate some of these problems, consider the Smalltalk user who wishes to monitor all incoming data on a serial line and who does not want to create a separate task to manage this data. It is straightforward to create a text view which takes its input from the serial port. The problem is that its controller will only be active when the view is the active view. Using Smalltalk for anything else will prevent the controller's polling loop (the one that tests the serial port) from running. Solving this problem requires changing all of the polling loops in the system to include the serial port as one of the inputs."
    },
    {
      "type": "pagefold",
      "id": "7b6576aa671e2b27",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "d4dd2ddf1ee12cbb",
      "text": "⇒ [[GtDrawExample]]"
    },
    {
      "type": "markdown",
      "id": "f0d935a03a2562e8",
      "text": "> After inspecting the code, draw away on the `BlElement` created by dragging (clicking + moving mouse) **or using another input device**.\n"
    },
    {
      "type": "pagefold",
      "id": "9ce1e7c5af20ae7e",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "656251e4ee97f275",
      "text": "Construction of new Model/View/Controller triads is complex and cumbersome despite the existence of tools such as Glazier [Alexander, 1987]. Views frequently interact with others in subtle ways causing one controller to retain control of the processor and lockup the system."
    },
    {
      "type": "paragraph",
      "id": "c648dd0bca918da2",
      "text": "Typical implementations of Smalltalk do not use MVC for everything. This leads to confusion about what particular objects should be doing. For example, most controllers have processes associated with them. The code which handles user input for popup menus does not. In fact, this code, which plays the role of a controller, is not implemented as a controller. This inconsistency increases complexity and reduces compatibility between systems and between components within systems."
    },
    {
      "type": "markdown",
      "id": "0130ffb885430758",
      "text": "MVC in Smalltalk uses the dependents mechanism to maintain the correspondence between model and view. Objects can *depend* on one another such that when one is changed, all those who depend on it will be notified. This scheme is reasonable for simple applications but it allows only a single path between dependents (i.e., the changed: and update: messages). Unfortunately, an object’s dependents rely on the object to decide when to send the changed: message and the dependents who receive the update: message must determine whether or not they are interested in the change."
    },
    {
      "type": "pagefold",
      "id": "9ad64877e2afc3dd",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "3bf12fa986bbc1ea",
      "text": "For example:  Instance of LeConnectorPageContainerElement did not understand #onContentChanged\n"
    },
    {
      "type": "code",
      "id": "000896246b3f4d4d",
      "text": "LeContentElement>>#onContentChanged\n#+begin_src\nonContentChanged\n\t\"Subclasses can react to content (page and block) changes\"\n\t\n\tself deprecated: 'Use #onContentUIModelChanged instead'.\n\tself halt\n#+end_src\n"
    },
    {
      "type": "pagefold",
      "id": "733c5333c9eea111",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "1a60ae76039ac81e",
      "text": "⇒ [[Eva and NeWS]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Controllers",
        "story": []
      },
      "date": 1655960889024
    },
    {
      "id": "4b01796f6d3fb0a5",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "4b01796f6d3fb0a5",
        "text": "[[Controllers]] contain routines for sensing and handling user inputs such as; mouse movement, keypresses and button clicks. The controllers are constantly polling for input using these routines. When some event occurs, the controller must determine its context (e.g., a shifted mouse button down event may be different then an unshifted one) and do the appropriate action. This approach has two major problems, polling and lack of modularity."
      },
      "date": 1655960904637
    },
    {
      "type": "edit",
      "id": "4b01796f6d3fb0a5",
      "item": {
        "type": "paragraph",
        "id": "4b01796f6d3fb0a5",
        "text": "[[Controllers]] contain routines for sensing and handling user inputs such as; [[Mouse]] movement, keypresses and button clicks. The controllers are constantly polling for input using these routines. When some event occurs, the controller must determine its context (e.g., a shifted mouse button down event may be different then an unshifted one) and do the appropriate action. This approach has two major problems, polling and lack of modularity."
      },
      "date": 1655960954323
    },
    {
      "type": "edit",
      "id": "4b01796f6d3fb0a5",
      "item": {
        "type": "paragraph",
        "id": "4b01796f6d3fb0a5",
        "text": "[[Controllers]] contain routines for sensing and handling user inputs such as; [[Mouse]] movement, keypresses and button clicks. The controllers are constantly polling for input using these routines. When some event occurs, the controller must determine its context (e.g., a shifted mouse button down event may be different then an unshifted one) and do the appropriate action. This approach has two major problems, [[Polling]] and lack of modularity."
      },
      "date": 1655960994826
    },
    {
      "item": {
        "type": "factory",
        "id": "44ff01d5e45f63ee"
      },
      "id": "44ff01d5e45f63ee",
      "type": "add",
      "after": "4b01796f6d3fb0a5",
      "date": 1655961000168
    },
    {
      "type": "edit",
      "id": "44ff01d5e45f63ee",
      "item": {
        "type": "paragraph",
        "id": "44ff01d5e45f63ee",
        "text": "⇒ [[Polling]]"
      },
      "date": 1655961007670
    },
    {
      "id": "83eafcaf6dc6a2bc",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "83eafcaf6dc6a2bc",
        "text": "Since each type of view has its own input requirements and set of valid user interactions, each view has an associated controller which handles user input. In a typical system there are several different types of view and thus several different types of controller. These view/controller pairs normally fall into one of four broad groups; those dealing with text, lists or graphics and those dealing with aggregates of the above three."
      },
      "after": "44ff01d5e45f63ee",
      "date": 1655961160601
    },
    {
      "item": {
        "type": "factory",
        "id": "fd5d51ee85747cdf"
      },
      "id": "fd5d51ee85747cdf",
      "type": "add",
      "after": "83eafcaf6dc6a2bc",
      "date": 1655961519211
    },
    {
      "id": "064d8725833ae553",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "064d8725833ae553",
        "text": "See \"an [[Actor]]/Pawn pair\" ⇒ [[World Core Tutorial 1]]"
      },
      "after": "83eafcaf6dc6a2bc",
      "date": 1655961522687
    },
    {
      "type": "edit",
      "id": "fd5d51ee85747cdf",
      "item": {
        "type": "pagefold",
        "id": "fd5d51ee85747cdf",
        "text": "~"
      },
      "date": 1655961561772
    },
    {
      "id": "fd5d51ee85747cdf",
      "type": "move",
      "order": [
        "4b01796f6d3fb0a5",
        "44ff01d5e45f63ee",
        "83eafcaf6dc6a2bc",
        "fd5d51ee85747cdf",
        "064d8725833ae553"
      ],
      "date": 1655961564322
    },
    {
      "item": {
        "type": "factory",
        "id": "deac4bdef9f87584"
      },
      "id": "deac4bdef9f87584",
      "type": "add",
      "after": "064d8725833ae553",
      "date": 1655961566662
    },
    {
      "type": "edit",
      "id": "deac4bdef9f87584",
      "item": {
        "type": "pagefold",
        "id": "deac4bdef9f87584",
        "text": "~"
      },
      "date": 1655961569786
    },
    {
      "item": {
        "type": "factory",
        "id": "83747542645e3ddf"
      },
      "id": "83747542645e3ddf",
      "type": "add",
      "after": "deac4bdef9f87584",
      "date": 1655961592988
    },
    {
      "type": "edit",
      "id": "83747542645e3ddf",
      "item": {
        "type": "paragraph",
        "id": "83747542645e3ddf",
        "text": "Within a particular view/controller pair the code is modular, however the same is not true of the system as a whole. In each group, the view/controller pairs are organized hierarchically with subclasses differing only slightly from their superclasses and sharing most of their code. Because polling code tests a particular set of inputs, if a subclass recognizes one different input then it must reimplement the polling loop. This leads to a great deal of duplicate code and confuses the flow of control."
      },
      "date": 1655961594332
    },
    {
      "item": {
        "type": "factory",
        "id": "1a13c1a598e76356"
      },
      "id": "1a13c1a598e76356",
      "type": "add",
      "after": "83747542645e3ddf",
      "date": 1655961626937
    },
    {
      "type": "edit",
      "id": "1a13c1a598e76356",
      "item": {
        "type": "paragraph",
        "id": "1a13c1a598e76356",
        "text": "To illustrate some of these problems, consider the Smalltalk user who wishes to monitor all incoming data on a serial line and who does not want to create a separate task to manage this data. It is straightforward to create a text view which takes its input from the serial port. The problem is that its controller will only be active when the view is the active view. Using Smalltalk for anything else will prevent the controller's polling loop (the one that tests the serial port) from running. Solving this problem requires changing all of the polling loops in the system to include the serial port as one of the inputs."
      },
      "date": 1655961628297
    },
    {
      "item": {
        "type": "factory",
        "id": "d4dd2ddf1ee12cbb"
      },
      "id": "d4dd2ddf1ee12cbb",
      "type": "add",
      "after": "1a13c1a598e76356",
      "date": 1655961846792
    },
    {
      "type": "edit",
      "id": "d4dd2ddf1ee12cbb",
      "item": {
        "type": "paragraph",
        "id": "d4dd2ddf1ee12cbb",
        "text": "GtDrawExample"
      },
      "date": 1655961856291
    },
    {
      "type": "edit",
      "id": "d4dd2ddf1ee12cbb",
      "item": {
        "type": "paragraph",
        "id": "d4dd2ddf1ee12cbb",
        "text": "⇒ [[GtDrawExample]]"
      },
      "date": 1655961865452
    },
    {
      "id": "f0d935a03a2562e8",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "f0d935a03a2562e8",
        "text": "After inspecting the code, draw away on the `BlElement` created by dragging (clicking + moving mouse) or using another input device.\n"
      },
      "after": "d4dd2ddf1ee12cbb",
      "date": 1655961877347
    },
    {
      "type": "edit",
      "id": "f0d935a03a2562e8",
      "item": {
        "type": "markdown",
        "id": "f0d935a03a2562e8",
        "text": "> After inspecting the code, draw away on the `BlElement` created by dragging (clicking + moving mouse) or using another input device.\n"
      },
      "date": 1655961890449
    },
    {
      "item": {
        "type": "factory",
        "id": "9ce1e7c5af20ae7e"
      },
      "id": "9ce1e7c5af20ae7e",
      "type": "add",
      "after": "f0d935a03a2562e8",
      "date": 1655961892916
    },
    {
      "type": "edit",
      "id": "9ce1e7c5af20ae7e",
      "item": {
        "type": "pagefold",
        "id": "9ce1e7c5af20ae7e",
        "text": "~"
      },
      "date": 1655961896187
    },
    {
      "item": {
        "type": "factory",
        "id": "7b6576aa671e2b27"
      },
      "id": "7b6576aa671e2b27",
      "type": "add",
      "after": "9ce1e7c5af20ae7e",
      "date": 1655961899576
    },
    {
      "type": "edit",
      "id": "7b6576aa671e2b27",
      "item": {
        "type": "pagefold",
        "id": "7b6576aa671e2b27",
        "text": "~"
      },
      "date": 1655961902804
    },
    {
      "id": "7b6576aa671e2b27",
      "type": "move",
      "order": [
        "4b01796f6d3fb0a5",
        "44ff01d5e45f63ee",
        "83eafcaf6dc6a2bc",
        "fd5d51ee85747cdf",
        "064d8725833ae553",
        "deac4bdef9f87584",
        "83747542645e3ddf",
        "1a13c1a598e76356",
        "7b6576aa671e2b27",
        "d4dd2ddf1ee12cbb",
        "f0d935a03a2562e8",
        "9ce1e7c5af20ae7e"
      ],
      "date": 1655961904999
    },
    {
      "type": "edit",
      "id": "f0d935a03a2562e8",
      "item": {
        "type": "markdown",
        "id": "f0d935a03a2562e8",
        "text": "> After inspecting the code, draw away on the `BlElement` created by dragging (clicking + moving mouse) **or using another input device**.\n"
      },
      "date": 1655961942937
    },
    {
      "item": {
        "type": "factory",
        "id": "656251e4ee97f275"
      },
      "id": "656251e4ee97f275",
      "type": "add",
      "after": "9ce1e7c5af20ae7e",
      "date": 1655961954700
    },
    {
      "type": "edit",
      "id": "656251e4ee97f275",
      "item": {
        "type": "paragraph",
        "id": "656251e4ee97f275",
        "text": "Construction of new Model/View/Controller triads is complex and cumbersome despite the existence of tools such as Glazier | Alexander, 1987J. Views frequently interact with others in subtle ways causing one controller to retain control of the processor and lockup the system."
      },
      "date": 1655961956186
    },
    {
      "type": "edit",
      "id": "656251e4ee97f275",
      "item": {
        "type": "paragraph",
        "id": "656251e4ee97f275",
        "text": "Construction of new Model/View/Controller triads is complex and cumbersome despite the existence of tools such as Glazier [Alexander, 1987]. Views frequently interact with others in subtle ways causing one controller to retain control of the processor and lockup the system."
      },
      "date": 1655961976502
    },
    {
      "item": {
        "type": "factory",
        "id": "c648dd0bca918da2"
      },
      "id": "c648dd0bca918da2",
      "type": "add",
      "after": "656251e4ee97f275",
      "date": 1655961994552
    },
    {
      "type": "edit",
      "id": "c648dd0bca918da2",
      "item": {
        "type": "paragraph",
        "id": "c648dd0bca918da2",
        "text": "Typical implementations of Smalltalk do not use MVC for everything. This leads to confusion about what particular objects should be doing. For example, most controllers have processes associated with them. The code which handles user input for popup menus docs not. In fact, this code, which plays the role of a controller, is not implemented as a controller. This inconsistency increases complexity and"
      },
      "date": 1655961996466
    },
    {
      "type": "edit",
      "id": "c648dd0bca918da2",
      "item": {
        "type": "paragraph",
        "id": "c648dd0bca918da2",
        "text": "Typical implementations of Smalltalk do not use MVC for everything. This leads to confusion about what particular objects should be doing. For example, most controllers have processes associated with them. The code which handles user input for popup menus does not. In fact, this code, which plays the role of a controller, is not implemented as a controller. This inconsistency increases complexity and"
      },
      "date": 1655962020895
    },
    {
      "type": "edit",
      "id": "c648dd0bca918da2",
      "item": {
        "type": "paragraph",
        "id": "c648dd0bca918da2",
        "text": "Typical implementations of Smalltalk do not use MVC for everything. This leads to confusion about what particular objects should be doing. For example, most controllers have processes associated with them. The code which handles user input for popup menus does not. In fact, this code, which plays the role of a controller, is not implemented as a controller. This inconsistency increases complexity and reduces compatibility between systems and between components within systems."
      },
      "date": 1655962039657
    },
    {
      "item": {
        "type": "factory",
        "id": "0130ffb885430758"
      },
      "id": "0130ffb885430758",
      "type": "add",
      "after": "c648dd0bca918da2",
      "date": 1655962061771
    },
    {
      "type": "edit",
      "id": "0130ffb885430758",
      "item": {
        "type": "paragraph",
        "id": "0130ffb885430758",
        "text": "MVC in Smalltalk uses the dependents mechanism to maintain the correspondence between model and view. Objects can depend on one another such that when one is changed, all those who depend on it will be notified. This scheme is reasonable for simple applications but it allows only a single path between dependents (i.e., the changed: and update: messages). Unfortunately, an object’s dependents rely on the object to decide when to send the changed: message and the dependents who receive the update: message must determine whether or not they are interested in the change."
      },
      "date": 1655962063156
    },
    {
      "type": "edit",
      "id": "0130ffb885430758",
      "item": {
        "type": "paragraph",
        "id": "0130ffb885430758",
        "text": "MVC in Smalltalk uses the dependents mechanism to maintain the correspondence between model and view. Objects can `depend` on one another such that when one is changed, all those who depend on it will be notified. This scheme is reasonable for simple applications but it allows only a single path between dependents (i.e., the changed: and update: messages). Unfortunately, an object’s dependents rely on the object to decide when to send the changed: message and the dependents who receive the update: message must determine whether or not they are interested in the change."
      },
      "date": 1655962086934
    },
    {
      "type": "edit",
      "id": "0130ffb885430758",
      "item": {
        "type": "markdown",
        "id": "0130ffb885430758",
        "text": "MVC in Smalltalk uses the dependents mechanism to maintain the correspondence between model and view. Objects can `depend` on one another such that when one is changed, all those who depend on it will be notified. This scheme is reasonable for simple applications but it allows only a single path between dependents (i.e., the changed: and update: messages). Unfortunately, an object’s dependents rely on the object to decide when to send the changed: message and the dependents who receive the update: message must determine whether or not they are interested in the change."
      },
      "date": 1655962089019
    },
    {
      "type": "edit",
      "id": "0130ffb885430758",
      "item": {
        "type": "markdown",
        "id": "0130ffb885430758",
        "text": "MVC in Smalltalk uses the dependents mechanism to maintain the correspondence between model and view. Objects can *depend* on one another such that when one is changed, all those who depend on it will be notified. This scheme is reasonable for simple applications but it allows only a single path between dependents (i.e., the changed: and update: messages). Unfortunately, an object’s dependents rely on the object to decide when to send the changed: message and the dependents who receive the update: message must determine whether or not they are interested in the change."
      },
      "date": 1655962096417
    },
    {
      "item": {
        "type": "factory",
        "id": "9ad64877e2afc3dd"
      },
      "id": "9ad64877e2afc3dd",
      "type": "add",
      "after": "0130ffb885430758",
      "date": 1655962196603
    },
    {
      "type": "edit",
      "id": "9ad64877e2afc3dd",
      "item": {
        "type": "pagefold",
        "id": "9ad64877e2afc3dd",
        "text": "~"
      },
      "date": 1655962201525
    },
    {
      "item": {
        "type": "factory",
        "id": "3bf12fa986bbc1ea"
      },
      "id": "3bf12fa986bbc1ea",
      "type": "add",
      "after": "9ad64877e2afc3dd",
      "date": 1655962203026
    },
    {
      "type": "edit",
      "id": "3bf12fa986bbc1ea",
      "item": {
        "type": "paragraph",
        "id": "3bf12fa986bbc1ea",
        "text": "For example:  Instance of LeConnectorPageContainerElement did not understand #onContentChanged\n"
      },
      "date": 1655962210317
    },
    {
      "item": {
        "type": "factory",
        "id": "000896246b3f4d4d"
      },
      "id": "000896246b3f4d4d",
      "type": "add",
      "after": "3bf12fa986bbc1ea",
      "date": 1655962219361
    },
    {
      "type": "edit",
      "id": "000896246b3f4d4d",
      "item": {
        "type": "code",
        "id": "000896246b3f4d4d",
        "text": "LeContentElement>>#onContentChanged\n#+begin_src\nonContentChanged\n\t\"Subclasses can react to content (page and block) changes\"\n\t\n\tself deprecated: 'Use #onContentUIModelChanged instead'.\n\tself halt\n#+end_src\n"
      },
      "date": 1655962221768
    },
    {
      "item": {
        "type": "factory",
        "id": "733c5333c9eea111"
      },
      "id": "733c5333c9eea111",
      "type": "add",
      "after": "000896246b3f4d4d",
      "date": 1655962250783
    },
    {
      "type": "edit",
      "id": "733c5333c9eea111",
      "item": {
        "type": "pagefold",
        "id": "733c5333c9eea111",
        "text": "~"
      },
      "date": 1655962253938
    },
    {
      "item": {
        "type": "factory",
        "id": "1a60ae76039ac81e"
      },
      "id": "1a60ae76039ac81e",
      "type": "add",
      "after": "733c5333c9eea111",
      "date": 1655962301576
    },
    {
      "type": "edit",
      "id": "1a60ae76039ac81e",
      "item": {
        "type": "paragraph",
        "id": "1a60ae76039ac81e",
        "text": "⇒ [[Eva and NeWS]]"
      },
      "date": 1655962314713
    }
  ]
}