{
  "title": "Class Based Characters",
  "story": [
    {
      "type": "paragraph",
      "id": "766ec8b8fb258e15",
      "text": "[…]"
    },
    {
      "type": "paragraph",
      "id": "9858ca13f14e5f6d",
      "text": "Unfortunately, enumeration also means we will have to create 256 character classes to implement it. Maintenance of 256 classes without tools is not going  to be a lot of fun. Moreover, a subtle side effect is that so many classes might overflow VisualWorks’ virtual machine caches, so performance could be lower than with condensed class based characters."
    },
    {
      "type": "markdown",
      "id": "0fa804caea266202",
      "text": "> And 64k classes for Unicode."
    },
    {
      "type": "paragraph",
      "id": "8a8ea295d560e9cd",
      "text": "A message that has only one implementation is said to be monomorphic. When a message has multiple implementations it is called polymorphic. If a message has more than just a few implementations, it is considered to be megamorphic. At first, virtual machines were given inline caches (ICs) that kept track of the compiled method for a particular class and selector combination. This saves time because when the information in the IC applies to the message that is about to be sent, then no message lookups are necessary. For polymorphic messages, however, ICs would be reset all the time leading to thrasing. Hence, ICs were extended to hold more than one entry, and thus became polymorphic inline caches, or PICs for short. [[Eliot Miranda]], VisualWorks’ virtual machine guru for many years, described ICs tendency to thrash as “a catastrophe of PIC proportions”. In particular, VisualWorks’ polymorphic inline caches hold “only” 8 entries."
    },
    {
      "type": "paragraph",
      "id": "fed523df45ed0fb1",
      "text": "[…]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Class Based Characters",
        "story": []
      },
      "date": 1660823473077
    },
    {
      "item": {
        "type": "factory",
        "id": "766ec8b8fb258e15"
      },
      "id": "766ec8b8fb258e15",
      "type": "add",
      "date": 1660823476150
    },
    {
      "type": "edit",
      "id": "766ec8b8fb258e15",
      "item": {
        "type": "paragraph",
        "id": "766ec8b8fb258e15",
        "text": "[…]"
      },
      "date": 1660823479060
    },
    {
      "type": "add",
      "id": "9858ca13f14e5f6d",
      "item": {
        "type": "paragraph",
        "id": "9858ca13f14e5f6d",
        "text": "Unfortunately, enumeration also means we will have to create 256 character classes to implement it. Maintenance of 256 classes without tools is not going  to be a lot of fun. Moreover, a subtle side effect is that so many classes might overflow VisualWorks’ virtual machine caches15, so performance could be lower than with condensed class based characters."
      },
      "after": "766ec8b8fb258e15",
      "date": 1660823489626
    },
    {
      "type": "add",
      "id": "0fa804caea266202",
      "item": {
        "type": "paragraph",
        "id": "0fa804caea266202",
        "text": "> And 64k classes for Unicode."
      },
      "after": "9858ca13f14e5f6d",
      "date": 1660823504041
    },
    {
      "type": "edit",
      "id": "0fa804caea266202",
      "item": {
        "type": "markdown",
        "id": "0fa804caea266202",
        "text": "> And 64k classes for Unicode."
      },
      "date": 1660823506025
    },
    {
      "item": {
        "type": "factory",
        "id": "8a8ea295d560e9cd"
      },
      "id": "8a8ea295d560e9cd",
      "type": "add",
      "after": "0fa804caea266202",
      "date": 1660823549016
    },
    {
      "type": "edit",
      "id": "9858ca13f14e5f6d",
      "item": {
        "type": "paragraph",
        "id": "9858ca13f14e5f6d",
        "text": "Unfortunately, enumeration also means we will have to create 256 character classes to implement it. Maintenance of 256 classes without tools is not going  to be a lot of fun. Moreover, a subtle side effect is that so many classes might overflow VisualWorks’ virtual machine caches, so performance could be lower than with condensed class based characters."
      },
      "date": 1660823550016
    },
    {
      "type": "edit",
      "id": "8a8ea295d560e9cd",
      "item": {
        "type": "paragraph",
        "id": "8a8ea295d560e9cd",
        "text": "A message that has only one implementation is said to be monomorphic. When a message has multiple implementations it is called polymorphic. If a message has more than just a few implementations, it is considered to be megamorphic. At first, virtual machines were given inline caches (ICs) that kept track of the compiled method for a particular class and selector combination. This saves time because when the information in the IC applies to the message that is about to be sent, then no message lookups are necessary. For polymorphic messages, however, ICs would be reset all the time leading to thrasing. Hence, ICs were extended to hold more than one entry, and thus became polymorphic inline caches, or PICs for short. Eliot Miranda, VisualWorks’ virtual machine guru for many years, described ICs tendency to thrash as “a catastrophe of PIC proportions”. In particular, VisualWorks’ polymorphic inline caches hold “only” 8 entries."
      },
      "date": 1660823550748
    },
    {
      "type": "add",
      "id": "fed523df45ed0fb1",
      "item": {
        "type": "paragraph",
        "id": "fed523df45ed0fb1",
        "text": "[…]"
      },
      "after": "8a8ea295d560e9cd",
      "date": 1660823559422
    },
    {
      "type": "edit",
      "id": "8a8ea295d560e9cd",
      "item": {
        "type": "paragraph",
        "id": "8a8ea295d560e9cd",
        "text": "A message that has only one implementation is said to be monomorphic. When a message has multiple implementations it is called polymorphic. If a message has more than just a few implementations, it is considered to be megamorphic. At first, virtual machines were given inline caches (ICs) that kept track of the compiled method for a particular class and selector combination. This saves time because when the information in the IC applies to the message that is about to be sent, then no message lookups are necessary. For polymorphic messages, however, ICs would be reset all the time leading to thrasing. Hence, ICs were extended to hold more than one entry, and thus became polymorphic inline caches, or PICs for short. [[Eliot Miranda]], VisualWorks’ virtual machine guru for many years, described ICs tendency to thrash as “a catastrophe of PIC proportions”. In particular, VisualWorks’ polymorphic inline caches hold “only” 8 entries."
      },
      "date": 1660823621106
    }
  ]
}