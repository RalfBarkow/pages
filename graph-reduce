{
  "title": "Graph Reduce",
  "story": [
    {
      "type": "paragraph",
      "id": "117fc0f631d9168c",
      "text": "Recent work on graph analytics has sought to leverage the high performance offered by GPU devices, but challenges remain due to the inherent irregularity of graph algorithm and limitations in GPU-resident memory for storing large graphs. "
    },
    {
      "type": "paragraph",
      "id": "ea633fddf317c493",
      "text": "The Graph Reduce methods presented in this paper [https://ieeexplore.ieee.org/abstract/document/7284365 ieee] permit a GPU-based accelerator to operate on graphs that exceed its internal memory capacity. Graph Reduce operates with a combination of both edge- and vertex-centric implementations of the Gather-Apply-Scatter programming model, to achieve high degrees of parallelism supported by methods that partition graphs across GPU and host memories and efficiently move graph data between both. "
    },
    {
      "type": "paragraph",
      "id": "fa4c43cfdaa6ff89",
      "text": "Graph Reduce-based programming is performed via device functions that include gather map, gather reduce, apply, and scatter, implemented by programmers for the graph algorithms they wish to realize. Experimental evaluations for a wide variety of graph inputs, algorithms, and system configuration demonstrate that Graph Reduce outperforms other competing approaches."
    },
    {
      "type": "paragraph",
      "id": "070a3188576895e4",
      "text": "GraphReduce: Large-Scale Graph Analytics on Accelerator-Based HPC Systems [https://ieeexplore.ieee.org/abstract/document/7284365 ieee]"
    },
    {
      "type": "paragraph",
      "id": "edc353391dd3dc08",
      "text": "We now briefly introduce the state-of-the-art computational models for expressing graphs. Let’s first define the problem. The problem is described as a directed (sparse) graph, G = (V, E). A value is associated with each vertex and each edge . We label the vertices from 1 to . Given a directed edge , we refer to e as vertex in-edge, and as vertex out-edge."
    },
    {
      "type": "paragraph",
      "id": "130c70fb95d29f95",
      "text": "GraphLab[9] has proposed the Gather-Apply-Scatter (GAS) abstraction to express how to update the elements in a graph. A graph algorithm can be expressed as a series of operations performed at each vertex. The operations occur in three phases: "
    },
    {
      "type": "markdown",
      "id": "14e690559b14ccc4",
      "text": "1. Gather phase: each vertex aggregates values associated with its incoming edges and source vertices\n2. Apply phase: each vertex updates its state using the gather result \n3. Scatter phase: each vertex updates the state of every outgoing edge."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Graph Reduce",
        "story": []
      },
      "date": 1673696363522
    },
    {
      "item": {
        "type": "factory",
        "id": "070a3188576895e4"
      },
      "id": "070a3188576895e4",
      "type": "add",
      "date": 1673696374990
    },
    {
      "type": "edit",
      "id": "070a3188576895e4",
      "item": {
        "type": "paragraph",
        "id": "070a3188576895e4",
        "text": "GraphReduce: Large-Scale Graph Analytics on Accelerator-Based HPC Systems"
      },
      "date": 1673696377373
    },
    {
      "type": "edit",
      "id": "070a3188576895e4",
      "item": {
        "type": "paragraph",
        "id": "070a3188576895e4",
        "text": "GraphReduce: Large-Scale Graph Analytics on Accelerator-Based HPC Systems [https://ieeexplore.ieee.org/abstract/document/7284365 ieee]"
      },
      "date": 1673696388338
    },
    {
      "item": {
        "type": "factory",
        "id": "117fc0f631d9168c"
      },
      "id": "117fc0f631d9168c",
      "type": "add",
      "after": "070a3188576895e4",
      "date": 1673696450388
    },
    {
      "type": "edit",
      "id": "117fc0f631d9168c",
      "item": {
        "type": "paragraph",
        "id": "117fc0f631d9168c",
        "text": "Recent work on graph analytics has sought to leverage the high performance offered by GPU devices, but challenges remain due to the inherent irregularity of graph algorithm and limitations in GPU-resident memory for storing large graphs. The Graph Reduce methods presented in this paper permit a GPU-based accelerator to operate on graphs that exceed its internal memory capacity. Graph Reduce operates with a combination of both edge- and vertex-centric implementations of the Gather-Apply-Scatter programming model, to achieve high degrees of parallelism supported by methods that partition graphs across GPU and host memories and efficiently move graph data between both. Graph Reduce-based programming is performed via device functions that include gather map, gather reduce, apply, and scatter, implemented by programmers for the graph algorithms they wish to realize. Experimental evaluations for a wide variety of graph inputs, algorithms, and system configuration demonstrate that Graph Reduce outperforms other competing approaches."
      },
      "date": 1673696454678
    },
    {
      "id": "117fc0f631d9168c",
      "type": "move",
      "order": [
        "117fc0f631d9168c",
        "070a3188576895e4"
      ],
      "date": 1673696456599
    },
    {
      "type": "edit",
      "id": "117fc0f631d9168c",
      "item": {
        "type": "paragraph",
        "id": "117fc0f631d9168c",
        "text": "Recent work on graph analytics has sought to leverage the high performance offered by GPU devices, but challenges remain due to the inherent irregularity of graph algorithm and limitations in GPU-resident memory for storing large graphs. "
      },
      "date": 1673696469324
    },
    {
      "type": "add",
      "id": "ea633fddf317c493",
      "item": {
        "type": "paragraph",
        "id": "ea633fddf317c493",
        "text": "The Graph Reduce methods presented in this paper permit a GPU-based accelerator to operate on graphs that exceed its internal memory capacity. Graph Reduce operates with a combination of both edge- and vertex-centric implementations of the Gather-Apply-Scatter programming model, to achieve high degrees of parallelism supported by methods that partition graphs across GPU and host memories and efficiently move graph data between both. Graph Reduce-based programming is performed via device functions that include gather map, gather reduce, apply, and scatter, implemented by programmers for the graph algorithms they wish to realize. Experimental evaluations for a wide variety of graph inputs, algorithms, and system configuration demonstrate that Graph Reduce outperforms other competing approaches."
      },
      "after": "117fc0f631d9168c",
      "date": 1673696471105
    },
    {
      "type": "edit",
      "id": "ea633fddf317c493",
      "item": {
        "type": "paragraph",
        "id": "ea633fddf317c493",
        "text": "The Graph Reduce methods presented in this paper [https://ieeexplore.ieee.org/abstract/document/7284365 ieee] permit a GPU-based accelerator to operate on graphs that exceed its internal memory capacity. Graph Reduce operates with a combination of both edge- and vertex-centric implementations of the Gather-Apply-Scatter programming model, to achieve high degrees of parallelism supported by methods that partition graphs across GPU and host memories and efficiently move graph data between both. Graph Reduce-based programming is performed via device functions that include gather map, gather reduce, apply, and scatter, implemented by programmers for the graph algorithms they wish to realize. Experimental evaluations for a wide variety of graph inputs, algorithms, and system configuration demonstrate that Graph Reduce outperforms other competing approaches."
      },
      "date": 1673696484774
    },
    {
      "item": {
        "type": "factory",
        "id": "edc353391dd3dc08"
      },
      "id": "edc353391dd3dc08",
      "type": "add",
      "after": "070a3188576895e4",
      "date": 1673696612574
    },
    {
      "type": "edit",
      "id": "edc353391dd3dc08",
      "item": {
        "type": "paragraph",
        "id": "edc353391dd3dc08",
        "text": "We now briefly introduce the state-of-the-art computational models for expressing graphs. Let’s first define the problem. The problem is described as a directed (sparse) graph, G = (V, E). A value is associated with each vertex and each edge . We label the vertices from 1 to . Given a directed edge , we refer to as vertex in-edge, and as vertex out-edge."
      },
      "date": 1673696614142
    },
    {
      "item": {
        "type": "factory",
        "id": "130c70fb95d29f95"
      },
      "id": "130c70fb95d29f95",
      "type": "add",
      "after": "edc353391dd3dc08",
      "date": 1673696680948
    },
    {
      "type": "edit",
      "id": "130c70fb95d29f95",
      "item": {
        "type": "paragraph",
        "id": "130c70fb95d29f95",
        "text": "GraphLab[9] has proposed the Gather-Apply-Scatter (GAS) abstraction to express how to update the elements in a graph. A graph algorithm can be expressed as a series of operations performed at each vertex. The operations occur in three phases: "
      },
      "date": 1673696687081
    },
    {
      "type": "add",
      "id": "14e690559b14ccc4",
      "item": {
        "type": "paragraph",
        "id": "14e690559b14ccc4",
        "text": "1. Gather phase: each vertex aggregates values associated with its incoming edges and source vertices 2. Apply phase: each vertex updates its state using the gather result 3. Scatter phase: each vertex updates the state of every outgoing edge."
      },
      "after": "130c70fb95d29f95",
      "date": 1673696687825
    },
    {
      "type": "edit",
      "id": "14e690559b14ccc4",
      "item": {
        "type": "markdown",
        "id": "14e690559b14ccc4",
        "text": "1. Gather phase: each vertex aggregates values associated with its incoming edges and source vertices 2. Apply phase: each vertex updates its state using the gather result 3. Scatter phase: each vertex updates the state of every outgoing edge."
      },
      "date": 1673696688876
    },
    {
      "type": "edit",
      "id": "14e690559b14ccc4",
      "item": {
        "type": "markdown",
        "id": "14e690559b14ccc4",
        "text": "1. Gather phase: each vertex aggregates values associated with its incoming edges and source vertices\n2. Apply phase: each vertex updates its state using the gather result \n3. Scatter phase: each vertex updates the state of every outgoing edge."
      },
      "date": 1673696702410
    },
    {
      "type": "edit",
      "id": "ea633fddf317c493",
      "item": {
        "type": "paragraph",
        "id": "ea633fddf317c493",
        "text": "The Graph Reduce methods presented in this paper [https://ieeexplore.ieee.org/abstract/document/7284365 ieee] permit a GPU-based accelerator to operate on graphs that exceed its internal memory capacity. Graph Reduce operates with a combination of both edge- and vertex-centric implementations of the Gather-Apply-Scatter programming model, to achieve high degrees of parallelism supported by methods that partition graphs across GPU and host memories and efficiently move graph data between both. "
      },
      "date": 1673696852455
    },
    {
      "type": "add",
      "id": "fa4c43cfdaa6ff89",
      "item": {
        "type": "paragraph",
        "id": "fa4c43cfdaa6ff89",
        "text": "Graph Reduce-based programming is performed via device functions that include gather map, gather reduce, apply, and scatter, implemented by programmers for the graph algorithms they wish to realize. Experimental evaluations for a wide variety of graph inputs, algorithms, and system configuration demonstrate that Graph Reduce outperforms other competing approaches."
      },
      "after": "ea633fddf317c493",
      "date": 1673696853583
    },
    {
      "type": "edit",
      "id": "edc353391dd3dc08",
      "item": {
        "type": "paragraph",
        "id": "edc353391dd3dc08",
        "text": "We now briefly introduce the state-of-the-art computational models for expressing graphs. Let’s first define the problem. The problem is described as a directed (sparse) graph, G = (V, E). A value is associated with each vertex and each edge . We label the vertices from 1 to . Given a directed edge , we refer to e as vertex in-edge, and as vertex out-edge."
      },
      "date": 1673696914619
    },
    {
      "type": "edit",
      "id": "edc353391dd3dc08",
      "item": {
        "type": "paragraph",
        "id": "edc353391dd3dc08",
        "text": "We now briefly introduce the state-of-the-art computational models for expressing graphs. Let’s first define the problem. The problem is described as a directed (sparse) graph, G = (V, E). A value is associated with each vertex and each edge . We label the vertices from 1 to . Given a directed edge , we refer to e as vertex v's in-edge, and as vertex out-edge."
      },
      "date": 1673696937268
    },
    {
      "type": "edit",
      "id": "edc353391dd3dc08",
      "item": {
        "type": "paragraph",
        "id": "edc353391dd3dc08",
        "text": "We now briefly introduce the state-of-the-art computational models for expressing graphs. Let’s first define the problem. The problem is described as a directed (sparse) graph, G = (V, E). A value is associated with each vertex and each edge . We label the vertices from 1 to . Given a directed edge , we refer to e as vertex in-edge, and as vertex out-edge."
      },
      "date": 1673696959242
    }
  ]
}