{
  "title": "OrderedCollection",
  "story": [
    {
      "type": "markdown",
      "id": "a2f9d72295626a70",
      "text": "I am one of the most common collection. I can grow, and elements can be added sequentially by the user.  \nI am more general than Array; my size grows on demand. I store data inside an Array and remember the first and last index. If I need, I can replace this Array by a larger one.\n\nI am usually used to store an unknown amount of objects. When my contents size will not move, one can send me the #asArray message to get better performances, but I cannot grow anymore (add: and remove: are not supported on Array).\n\n### Public API and Key Messages\n\n- #new / #withAll: aCollection / #with: anObject \tare common constructors\n- #add: anObject / #at: anIndex put: anObject / #at: anIndex ifAbsentPut: anObject \tallow to add new elements to myself.\n- #remove: anObject / #removeIndex: anIndex \tallow to remove an element.\n- #do: aBlock / #collect: aBlock / #select: aBlock / #reject: aBlock \tare common iterators.\n\n### Examples\t\n\n```\t\n\t\"There is many ways to create an OrderedCollection, here are some:\"\n\tordCol := OrderedCollection new.\n\tordCol\n\t\tadd: 'one';\n\t\tadd: 'two';\n\t\taddFirst: 'zero';\n\t\taddLast: 'three'.\n\tordCol.\t\t\"returns: an OrderedCollection('zero' 'one' 'two' 'three')\"\n\n\t\"or\"\n\tordCol := OrderedCollection with: 'one' with: 'two' with: 'three'.\n\tordCol.\t\t\"returns: an OrderedCollection('one' 'two' 'three')\"\n\n\t\"or from an other collection\"\n\tordCol := OrderedCollection withAll: #('one' 'two' 'three').\n\tordCol.\t\t\"returns: an OrderedCollection('one' 'two' 'three')\"\n\n\t\"or\"\n\t#('one' 'two' 'three') asOrderedCollection.\n\n\t\"Some manipulations\"\n\tordCol := OrderedCollection ofSize: 2.\n\tordCol\n\t\tat: 1 put: 'one';\n\t\tat: 2 put: 'two';\n\t\tat: 2 ifAbsentPut: 'three'.\n\tordCol.\t\t\"returns: an OrderedCollection('one' 'two')\"\n\tordCol\n\t\tremove: 'two';\n\t\tremoveIndex: 1.\n\tordCol.\t\t\"returns:  an OrderedCollection()\"\n\n\t\"A last one\"\n\tordCol := OrderedCollection with: $b with: $c with: $a.\n\tordCol sort: [ :first :second | first < second ].\t\t\"returns: an OrderedCollection($a $b $c)\"\n\tordCol collect: [ :element | element asUppercase ].\t\t\"returns:  an OrderedCollection($A $B $C)\"\n\tordCol select: [ :element | element >= $b ].\t\t\"returns:  an OrderedCollection($b $c)\"\n\tordCol do: [ :element | element inspect ].\n\tordCol asArray\t\t\"returns: #($a $b $c)\"\n``` \n\n### Internal Representation and Key Implementation Points.\nInstance Variables\n- array:\t\t\t<Array> \t\tAn Array where I store my elements. If I need a bigger one I can remove this one and create a new one.\n- firstIndex:\t\t<Integer> \tThe index of my first element.\n- lastIndex:\t\t<Integer> \tThe index of my last element.\n\nI store my elements inside an array. This array is AT LEAST of the size of my elements. If someone adds an element and my array is not large enough, I remove it and I create a new one larger with the same elements (usually, the size double)."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "OrderedCollection",
        "story": []
      },
      "date": 1649855540913
    },
    {
      "item": {
        "type": "factory",
        "id": "a2f9d72295626a70"
      },
      "id": "a2f9d72295626a70",
      "type": "add",
      "date": 1649855542105
    },
    {
      "type": "edit",
      "id": "a2f9d72295626a70",
      "item": {
        "type": "markdown",
        "id": "a2f9d72295626a70",
        "text": "OrderedCollection"
      },
      "date": 1649855546178
    },
    {
      "type": "edit",
      "id": "a2f9d72295626a70",
      "item": {
        "type": "markdown",
        "id": "a2f9d72295626a70",
        "text": "I am one of the most common collection. I can grow, and elements can be added sequentially by the user.  \nI am more general than Array; my size grows on demand. I store data inside an Array and remember the first and last index. If I need, I can replace this Array by a larger one.\n\nI am usually used to store an unknown amount of objects. When my contents size will not move, one can send me the #asArray message to get better performances, but I cannot grow anymore (add: and remove: are not supported on Array).\n\n### Public API and Key Messages\n\n- #new / #withAll: aCollection / #with: anObject \tare common constructors\n- #add: anObject / #at: anIndex put: anObject / #at: anIndex ifAbsentPut: anObject \tallow to add new elements to myself.\n- #remove: anObject / #removeIndex: anIndex \tallow to remove an element.\n- #do: aBlock / #collect: aBlock / #select: aBlock / #reject: aBlock \tare common iterators.\n\n### Examples\t\n\n```\t\n\t\"There is many ways to create an OrderedCollection, here are some:\"\n\tordCol := OrderedCollection new.\n\tordCol\n\t\tadd: 'one';\n\t\tadd: 'two';\n\t\taddFirst: 'zero';\n\t\taddLast: 'three'.\n\tordCol.\t\t\"returns: an OrderedCollection('zero' 'one' 'two' 'three')\"\n\n\t\"or\"\n\tordCol := OrderedCollection with: 'one' with: 'two' with: 'three'.\n\tordCol.\t\t\"returns: an OrderedCollection('one' 'two' 'three')\"\n\n\t\"or from an other collection\"\n\tordCol := OrderedCollection withAll: #('one' 'two' 'three').\n\tordCol.\t\t\"returns: an OrderedCollection('one' 'two' 'three')\"\n\n\t\"or\"\n\t#('one' 'two' 'three') asOrderedCollection.\n\n\t\"Some manipulations\"\n\tordCol := OrderedCollection ofSize: 2.\n\tordCol\n\t\tat: 1 put: 'one';\n\t\tat: 2 put: 'two';\n\t\tat: 2 ifAbsentPut: 'three'.\n\tordCol.\t\t\"returns: an OrderedCollection('one' 'two')\"\n\tordCol\n\t\tremove: 'two';\n\t\tremoveIndex: 1.\n\tordCol.\t\t\"returns:  an OrderedCollection()\"\n\n\t\"A last one\"\n\tordCol := OrderedCollection with: $b with: $c with: $a.\n\tordCol sort: [ :first :second | first < second ].\t\t\"returns: an OrderedCollection($a $b $c)\"\n\tordCol collect: [ :element | element asUppercase ].\t\t\"returns:  an OrderedCollection($A $B $C)\"\n\tordCol select: [ :element | element >= $b ].\t\t\"returns:  an OrderedCollection($b $c)\"\n\tordCol do: [ :element | element inspect ].\n\tordCol asArray\t\t\"returns: #($a $b $c)\"\n``` \n\n###Internal Representation and Key Implementation Points.\nInstance Variables\n- array:\t\t\t<Array> \t\tAn Array where I store my elements. If I need a bigger one I can remove this one and create a new one.\n- firstIndex:\t\t<Integer> \tThe index of my first element.\n- lastIndex:\t\t<Integer> \tThe index of my last element.\n\nI store my elements inside an array. This array is AT LEAST of the size of my elements. If someone adds an element and my array is not large enough, I remove it and I create a new one larger with the same elements (usually, the size double)."
      },
      "date": 1649855553903
    },
    {
      "type": "edit",
      "id": "a2f9d72295626a70",
      "item": {
        "type": "markdown",
        "id": "a2f9d72295626a70",
        "text": "I am one of the most common collection. I can grow, and elements can be added sequentially by the user.  \nI am more general than Array; my size grows on demand. I store data inside an Array and remember the first and last index. If I need, I can replace this Array by a larger one.\n\nI am usually used to store an unknown amount of objects. When my contents size will not move, one can send me the #asArray message to get better performances, but I cannot grow anymore (add: and remove: are not supported on Array).\n\n### Public API and Key Messages\n\n- #new / #withAll: aCollection / #with: anObject \tare common constructors\n- #add: anObject / #at: anIndex put: anObject / #at: anIndex ifAbsentPut: anObject \tallow to add new elements to myself.\n- #remove: anObject / #removeIndex: anIndex \tallow to remove an element.\n- #do: aBlock / #collect: aBlock / #select: aBlock / #reject: aBlock \tare common iterators.\n\n### Examples\t\n\n```\t\n\t\"There is many ways to create an OrderedCollection, here are some:\"\n\tordCol := OrderedCollection new.\n\tordCol\n\t\tadd: 'one';\n\t\tadd: 'two';\n\t\taddFirst: 'zero';\n\t\taddLast: 'three'.\n\tordCol.\t\t\"returns: an OrderedCollection('zero' 'one' 'two' 'three')\"\n\n\t\"or\"\n\tordCol := OrderedCollection with: 'one' with: 'two' with: 'three'.\n\tordCol.\t\t\"returns: an OrderedCollection('one' 'two' 'three')\"\n\n\t\"or from an other collection\"\n\tordCol := OrderedCollection withAll: #('one' 'two' 'three').\n\tordCol.\t\t\"returns: an OrderedCollection('one' 'two' 'three')\"\n\n\t\"or\"\n\t#('one' 'two' 'three') asOrderedCollection.\n\n\t\"Some manipulations\"\n\tordCol := OrderedCollection ofSize: 2.\n\tordCol\n\t\tat: 1 put: 'one';\n\t\tat: 2 put: 'two';\n\t\tat: 2 ifAbsentPut: 'three'.\n\tordCol.\t\t\"returns: an OrderedCollection('one' 'two')\"\n\tordCol\n\t\tremove: 'two';\n\t\tremoveIndex: 1.\n\tordCol.\t\t\"returns:  an OrderedCollection()\"\n\n\t\"A last one\"\n\tordCol := OrderedCollection with: $b with: $c with: $a.\n\tordCol sort: [ :first :second | first < second ].\t\t\"returns: an OrderedCollection($a $b $c)\"\n\tordCol collect: [ :element | element asUppercase ].\t\t\"returns:  an OrderedCollection($A $B $C)\"\n\tordCol select: [ :element | element >= $b ].\t\t\"returns:  an OrderedCollection($b $c)\"\n\tordCol do: [ :element | element inspect ].\n\tordCol asArray\t\t\"returns: #($a $b $c)\"\n``` \n\n### Internal Representation and Key Implementation Points.\nInstance Variables\n- array:\t\t\t<Array> \t\tAn Array where I store my elements. If I need a bigger one I can remove this one and create a new one.\n- firstIndex:\t\t<Integer> \tThe index of my first element.\n- lastIndex:\t\t<Integer> \tThe index of my last element.\n\nI store my elements inside an array. This array is AT LEAST of the size of my elements. If someone adds an element and my array is not large enough, I remove it and I create a new one larger with the same elements (usually, the size double)."
      },
      "date": 1649855855823
    }
  ]
}