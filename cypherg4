{
  "title": "Cypher.g4",
  "story": [
    {
      "type": "markdown",
      "id": "3b24d586f569bfed",
      "text": "– https://s3.amazonaws.com/artifacts.opencypher.org/Cypher.g4"
    },
    {
      "type": "code",
      "id": "853ef88e2598d577",
      "text": "/**\n * Copyright (c) 2015-2020 \"Neo Technology,\"\n * Network Engine for Objects in Lund AB [http://neotechnology.com]\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * \n * Attribution Notice under the terms of the Apache License 2.0\n * \n * This work was created by the collective efforts of the openCypher community.\n * Without limiting the terms of Section 6, any Derivative Work that is not\n * approved by the public consensus process of the openCypher Implementers Group\n * should not be described as â€œCypherâ€ (and CypherÂ® is a registered trademark of\n * Neo4j Inc.) or as \"openCypher\". Extensions by implementers or prototypes or\n * proposals for change that have been documented or implemented should only be\n * described as \"implementation extensions to Cypher\" or as \"proposed changes to\n * Cypher that are not yet approved by the openCypher community\".\n */\ngrammar Cypher;\n\noC_Cypher\n      :  SP? oC_Statement ( SP? ';' )? SP? EOF ;\n\noC_Statement\n         :  oC_Query ;\n\noC_Query\n     :  oC_RegularQuery\n         | oC_StandaloneCall\n         ;\n\noC_RegularQuery\n            :  oC_SingleQuery ( SP? oC_Union )* ;\n\noC_Union\n     :  ( UNION SP ALL SP? oC_SingleQuery )\n         | ( UNION SP? oC_SingleQuery )\n         ;\n\nUNION : ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'I' | 'i' ) ( 'O' | 'o' ) ( 'N' | 'n' )  ;\n\nALL : ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'L' | 'l' )  ;\n\noC_SingleQuery\n           :  oC_SinglePartQuery\n               | oC_MultiPartQuery\n               ;\n\noC_SinglePartQuery\n               :  ( ( oC_ReadingClause SP? )* oC_Return )\n                   | ( ( oC_ReadingClause SP? )* oC_UpdatingClause ( SP? oC_UpdatingClause )* ( SP? oC_Return )? )\n                   ;\n\noC_MultiPartQuery\n              :  ( ( oC_ReadingClause SP? )* ( oC_UpdatingClause SP? )* oC_With SP? )+ oC_SinglePartQuery ;\n\noC_UpdatingClause\n              :  oC_Create\n                  | oC_Merge\n                  | oC_Delete\n                  | oC_Set\n                  | oC_Remove\n                  ;\n\noC_ReadingClause\n             :  oC_Match\n                 | oC_Unwind\n                 | oC_InQueryCall\n                 ;\n\noC_Match\n     :  ( OPTIONAL SP )? MATCH SP? oC_Pattern ( SP? oC_Where )? ;\n\nOPTIONAL : ( 'O' | 'o' ) ( 'P' | 'p' ) ( 'T' | 't' ) ( 'I' | 'i' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'A' | 'a' ) ( 'L' | 'l' )  ;\n\nMATCH : ( 'M' | 'm' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'C' | 'c' ) ( 'H' | 'h' )  ;\n\noC_Unwind\n      :  UNWIND SP? oC_Expression SP AS SP oC_Variable ;\n\nUNWIND : ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'W' | 'w' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'D' | 'd' )  ;\n\nAS : ( 'A' | 'a' ) ( 'S' | 's' )  ;\n\noC_Merge\n     :  MERGE SP? oC_PatternPart ( SP oC_MergeAction )* ;\n\nMERGE : ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'G' | 'g' ) ( 'E' | 'e' )  ;\n\noC_MergeAction\n           :  ( ON SP MATCH SP oC_Set )\n               | ( ON SP CREATE SP oC_Set )\n               ;\n\nON : ( 'O' | 'o' ) ( 'N' | 'n' )  ;\n\nCREATE : ( 'C' | 'c' ) ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'E' | 'e' )  ;\n\noC_Create\n      :  CREATE SP? oC_Pattern ;\n\noC_Set\n   :  SET SP? oC_SetItem ( ',' oC_SetItem )* ;\n\nSET : ( 'S' | 's' ) ( 'E' | 'e' ) ( 'T' | 't' )  ;\n\noC_SetItem\n       :  ( oC_PropertyExpression SP? '=' SP? oC_Expression )\n           | ( oC_Variable SP? '=' SP? oC_Expression )\n           | ( oC_Variable SP? '+=' SP? oC_Expression )\n           | ( oC_Variable SP? oC_NodeLabels )\n           ;\n\noC_Delete\n      :  ( DETACH SP )? DELETE SP? oC_Expression ( SP? ',' SP? oC_Expression )* ;\n\nDETACH : ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'C' | 'c' ) ( 'H' | 'h' )  ;\n\nDELETE : ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'E' | 'e' )  ;\n\noC_Remove\n      :  REMOVE SP oC_RemoveItem ( SP? ',' SP? oC_RemoveItem )* ;\n\nREMOVE : ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'M' | 'm' ) ( 'O' | 'o' ) ( 'V' | 'v' ) ( 'E' | 'e' )  ;\n\noC_RemoveItem\n          :  ( oC_Variable oC_NodeLabels )\n              | oC_PropertyExpression\n              ;\n\noC_InQueryCall\n           :  CALL SP oC_ExplicitProcedureInvocation ( SP? YIELD SP oC_YieldItems )? ;\n\nCALL : ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'L' | 'l' )  ;\n\nYIELD : ( 'Y' | 'y' ) ( 'I' | 'i' ) ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'D' | 'd' )  ;\n\noC_StandaloneCall\n              :  CALL SP ( oC_ExplicitProcedureInvocation | oC_ImplicitProcedureInvocation ) ( SP YIELD SP oC_YieldItems )? ;\n\noC_YieldItems\n          :  ( '*' | ( oC_YieldItem ( SP? ',' SP? oC_YieldItem )* ) ) ( SP? oC_Where )? ;\n\noC_YieldItem\n         :  ( oC_ProcedureResultField SP AS SP )? oC_Variable ;\n\noC_With\n    :  WITH oC_ProjectionBody ( SP? oC_Where )? ;\n\nWITH : ( 'W' | 'w' ) ( 'I' | 'i' ) ( 'T' | 't' ) ( 'H' | 'h' )  ;\n\noC_Return\n      :  RETURN oC_ProjectionBody ;\n\nRETURN : ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'N' | 'n' )  ;\n\noC_ProjectionBody\n              :  ( SP? DISTINCT )? SP oC_ProjectionItems ( SP oC_Order )? ( SP oC_Skip )? ( SP oC_Limit )? ;\n\nDISTINCT : ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'T' | 't' )  ;\n\noC_ProjectionItems\n               :  ( '*' ( SP? ',' SP? oC_ProjectionItem )* )\n                   | ( oC_ProjectionItem ( SP? ',' SP? oC_ProjectionItem )* )\n                   ;\n\noC_ProjectionItem\n              :  ( oC_Expression SP AS SP oC_Variable )\n                  | oC_Expression\n                  ;\n\noC_Order\n     :  ORDER SP BY SP oC_SortItem ( ',' SP? oC_SortItem )* ;\n\nORDER : ( 'O' | 'o' ) ( 'R' | 'r' ) ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'R' | 'r' )  ;\n\nBY : ( 'B' | 'b' ) ( 'Y' | 'y' )  ;\n\noC_Skip\n    :  L_SKIP SP oC_Expression ;\n\nL_SKIP : ( 'S' | 's' ) ( 'K' | 'k' ) ( 'I' | 'i' ) ( 'P' | 'p' )  ;\n\noC_Limit\n     :  LIMIT SP oC_Expression ;\n\nLIMIT : ( 'L' | 'l' ) ( 'I' | 'i' ) ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'T' | 't' )  ;\n\noC_SortItem\n        :  oC_Expression ( SP? ( ASCENDING | ASC | DESCENDING | DESC ) )? ;\n\nASCENDING : ( 'A' | 'a' ) ( 'S' | 's' ) ( 'C' | 'c' ) ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' )  ;\n\nASC : ( 'A' | 'a' ) ( 'S' | 's' ) ( 'C' | 'c' )  ;\n\nDESCENDING : ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' ) ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' )  ;\n\nDESC : ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' )  ;\n\noC_Where\n     :  WHERE SP oC_Expression ;\n\nWHERE : ( 'W' | 'w' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'E' | 'e' )  ;\n\noC_Pattern\n       :  oC_PatternPart ( SP? ',' SP? oC_PatternPart )* ;\n\noC_PatternPart\n           :  ( oC_Variable SP? '=' SP? oC_AnonymousPatternPart )\n               | oC_AnonymousPatternPart\n               ;\n\noC_AnonymousPatternPart\n                    :  oC_PatternElement ;\n\noC_PatternElement\n              :  ( oC_NodePattern ( SP? oC_PatternElementChain )* )\n                  | ( '(' oC_PatternElement ')' )\n                  ;\n\noC_NodePattern\n           :  '(' SP? ( oC_Variable SP? )? ( oC_NodeLabels SP? )? ( oC_Properties SP? )? ')' ;\n\noC_PatternElementChain\n                   :  oC_RelationshipPattern SP? oC_NodePattern ;\n\noC_RelationshipPattern\n                   :  ( oC_LeftArrowHead SP? oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash SP? oC_RightArrowHead )\n                       | ( oC_LeftArrowHead SP? oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash )\n                       | ( oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash SP? oC_RightArrowHead )\n                       | ( oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash )\n                       ;\n\noC_RelationshipDetail\n                  :  '[' SP? ( oC_Variable SP? )? ( oC_RelationshipTypes SP? )? oC_RangeLiteral? ( oC_Properties SP? )? ']' ;\n\noC_Properties\n          :  oC_MapLiteral\n              | oC_Parameter\n              ;\n\noC_RelationshipTypes\n                 :  ':' SP? oC_RelTypeName ( SP? '|' ':'? SP? oC_RelTypeName )* ;\n\noC_NodeLabels\n          :  oC_NodeLabel ( SP? oC_NodeLabel )* ;\n\noC_NodeLabel\n         :  ':' SP? oC_LabelName ;\n\noC_RangeLiteral\n            :  '*' SP? ( oC_IntegerLiteral SP? )? ( '..' SP? ( oC_IntegerLiteral SP? )? )? ;\n\noC_LabelName\n         :  oC_SchemaName ;\n\noC_RelTypeName\n           :  oC_SchemaName ;\n\noC_Expression\n          :  oC_OrExpression ;\n\noC_OrExpression\n            :  oC_XorExpression ( SP OR SP oC_XorExpression )* ;\n\nOR : ( 'O' | 'o' ) ( 'R' | 'r' )  ;\n\noC_XorExpression\n             :  oC_AndExpression ( SP XOR SP oC_AndExpression )* ;\n\nXOR : ( 'X' | 'x' ) ( 'O' | 'o' ) ( 'R' | 'r' )  ;\n\noC_AndExpression\n             :  oC_NotExpression ( SP AND SP oC_NotExpression )* ;\n\nAND : ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'D' | 'd' )  ;\n\noC_NotExpression\n             :  ( NOT SP? )* oC_ComparisonExpression ;\n\nNOT : ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'T' | 't' )  ;\n\noC_ComparisonExpression\n                    :  oC_AddOrSubtractExpression ( SP? oC_PartialComparisonExpression )* ;\n\noC_AddOrSubtractExpression\n                       :  oC_MultiplyDivideModuloExpression ( ( SP? '+' SP? oC_MultiplyDivideModuloExpression ) | ( SP? '-' SP? oC_MultiplyDivideModuloExpression ) )* ;\n\noC_MultiplyDivideModuloExpression\n                              :  oC_PowerOfExpression ( ( SP? '*' SP? oC_PowerOfExpression ) | ( SP? '/' SP? oC_PowerOfExpression ) | ( SP? '%' SP? oC_PowerOfExpression ) )* ;\n\noC_PowerOfExpression\n                 :  oC_UnaryAddOrSubtractExpression ( SP? '^' SP? oC_UnaryAddOrSubtractExpression )* ;\n\noC_UnaryAddOrSubtractExpression\n                            :  ( ( '+' | '-' ) SP? )* oC_StringListNullOperatorExpression ;\n\noC_StringListNullOperatorExpression\n                                :  oC_PropertyOrLabelsExpression ( oC_StringOperatorExpression | oC_ListOperatorExpression | oC_NullOperatorExpression )* ;\n\noC_ListOperatorExpression\n                      :  ( SP IN SP? oC_PropertyOrLabelsExpression )\n                          | ( SP? '[' oC_Expression ']' )\n                          | ( SP? '[' oC_Expression? '..' oC_Expression? ']' )\n                          ;\n\nIN : ( 'I' | 'i' ) ( 'N' | 'n' )  ;\n\noC_StringOperatorExpression\n                        :  ( ( SP STARTS SP WITH ) | ( SP ENDS SP WITH ) | ( SP CONTAINS ) ) SP? oC_PropertyOrLabelsExpression ;\n\nSTARTS : ( 'S' | 's' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'R' | 'r' ) ( 'T' | 't' ) ( 'S' | 's' )  ;\n\nENDS : ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'S' | 's' )  ;\n\nCONTAINS : ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'S' | 's' )  ;\n\noC_NullOperatorExpression\n                      :  ( SP IS SP NULL )\n                          | ( SP IS SP NOT SP NULL )\n                          ;\n\nIS : ( 'I' | 'i' ) ( 'S' | 's' )  ;\n\nNULL : ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'L' | 'l' ) ( 'L' | 'l' )  ;\n\noC_PropertyOrLabelsExpression\n                          :  oC_Atom ( SP? oC_PropertyLookup )* ( SP? oC_NodeLabels )? ;\n\noC_Atom\n    :  oC_Literal\n        | oC_Parameter\n        | oC_CaseExpression\n        | ( COUNT SP? '(' SP? '*' SP? ')' )\n        | oC_ListComprehension\n        | oC_PatternComprehension\n        | ( ALL SP? '(' SP? oC_FilterExpression SP? ')' )\n        | ( ANY SP? '(' SP? oC_FilterExpression SP? ')' )\n        | ( NONE SP? '(' SP? oC_FilterExpression SP? ')' )\n        | ( SINGLE SP? '(' SP? oC_FilterExpression SP? ')' )\n        | oC_RelationshipsPattern\n        | oC_ParenthesizedExpression\n        | oC_FunctionInvocation\n        | oC_Variable\n        ;\n\nCOUNT : ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'T' | 't' )  ;\n\nANY : ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'Y' | 'y' )  ;\n\nNONE : ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'E' | 'e' )  ;\n\nSINGLE : ( 'S' | 's' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' ) ( 'L' | 'l' ) ( 'E' | 'e' )  ;\n\noC_Literal\n       :  oC_NumberLiteral\n           | StringLiteral\n           | oC_BooleanLiteral\n           | NULL\n           | oC_MapLiteral\n           | oC_ListLiteral\n           ;\n\noC_BooleanLiteral\n              :  TRUE\n                  | FALSE\n                  ;\n\nTRUE : ( 'T' | 't' ) ( 'R' | 'r' ) ( 'U' | 'u' ) ( 'E' | 'e' )  ;\n\nFALSE : ( 'F' | 'f' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'S' | 's' ) ( 'E' | 'e' )  ;\n\noC_ListLiteral\n           :  '[' SP? ( oC_Expression SP? ( ',' SP? oC_Expression SP? )* )? ']' ;\n\noC_PartialComparisonExpression\n                           :  ( '=' SP? oC_AddOrSubtractExpression )\n                               | ( '<>' SP? oC_AddOrSubtractExpression )\n                               | ( '<' SP? oC_AddOrSubtractExpression )\n                               | ( '>' SP? oC_AddOrSubtractExpression )\n                               | ( '<=' SP? oC_AddOrSubtractExpression )\n                               | ( '>=' SP? oC_AddOrSubtractExpression )\n                               ;\n\noC_ParenthesizedExpression\n                       :  '(' SP? oC_Expression SP? ')' ;\n\noC_RelationshipsPattern\n                    :  oC_NodePattern ( SP? oC_PatternElementChain )+ ;\n\noC_FilterExpression\n                :  oC_IdInColl ( SP? oC_Where )? ;\n\noC_IdInColl\n        :  oC_Variable SP IN SP oC_Expression ;\n\noC_FunctionInvocation\n                  :  oC_FunctionName SP? '(' SP? ( DISTINCT SP? )? ( oC_Expression SP? ( ',' SP? oC_Expression SP? )* )? ')' ;\n\noC_FunctionName\n            :  ( oC_Namespace oC_SymbolicName )\n                | EXISTS\n                ;\n\nEXISTS : ( 'E' | 'e' ) ( 'X' | 'x' ) ( 'I' | 'i' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'S' | 's' )  ;\n\noC_ExplicitProcedureInvocation\n                           :  oC_ProcedureName SP? '(' SP? ( oC_Expression SP? ( ',' SP? oC_Expression SP? )* )? ')' ;\n\noC_ImplicitProcedureInvocation\n                           :  oC_ProcedureName ;\n\noC_ProcedureResultField\n                    :  oC_SymbolicName ;\n\noC_ProcedureName\n             :  oC_Namespace oC_SymbolicName ;\n\noC_Namespace\n         :  ( oC_SymbolicName '.' )* ;\n\noC_ListComprehension\n                 :  '[' SP? oC_FilterExpression ( SP? '|' SP? oC_Expression )? SP? ']' ;\n\noC_PatternComprehension\n                    :  '[' SP? ( oC_Variable SP? '=' SP? )? oC_RelationshipsPattern SP? ( WHERE SP? oC_Expression SP? )? '|' SP? oC_Expression SP? ']' ;\n\noC_PropertyLookup\n              :  '.' SP? ( oC_PropertyKeyName ) ;\n\noC_CaseExpression\n              :  ( ( CASE ( SP? oC_CaseAlternatives )+ ) | ( CASE SP? oC_Expression ( SP? oC_CaseAlternatives )+ ) ) ( SP? ELSE SP? oC_Expression )? SP? END ;\n\nCASE : ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'S' | 's' ) ( 'E' | 'e' )  ;\n\nELSE : ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'S' | 's' ) ( 'E' | 'e' )  ;\n\nEND : ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'D' | 'd' )  ;\n\noC_CaseAlternatives\n                :  WHEN SP? oC_Expression SP? THEN SP? oC_Expression ;\n\nWHEN : ( 'W' | 'w' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'N' | 'n' )  ;\n\nTHEN : ( 'T' | 't' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'N' | 'n' )  ;\n\noC_Variable\n        :  oC_SymbolicName ;\n\nStringLiteral\n             :  ( '\"' ( StringLiteral_0 | EscapedChar )* '\"' )\n                 | ( '\\'' ( StringLiteral_1 | EscapedChar )* '\\'' )\n                 ;\n\nEscapedChar\n           :  '\\\\' ( '\\\\' | '\\'' | '\"' | ( 'B' | 'b' ) | ( 'F' | 'f' ) | ( 'N' | 'n' ) | ( 'R' | 'r' ) | ( 'T' | 't' ) | ( ( 'U' | 'u' ) ( HexDigit HexDigit HexDigit HexDigit ) ) | ( ( 'U' | 'u' ) ( HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit ) ) ) ;\n\noC_NumberLiteral\n             :  oC_DoubleLiteral\n                 | oC_IntegerLiteral\n                 ;\n\noC_MapLiteral\n          :  '{' SP? ( oC_PropertyKeyName SP? ':' SP? oC_Expression SP? ( ',' SP? oC_PropertyKeyName SP? ':' SP? oC_Expression SP? )* )? '}' ;\n\noC_Parameter\n         :  '$' ( oC_SymbolicName | DecimalInteger ) ;\n\noC_PropertyExpression\n                  :  oC_Atom ( SP? oC_PropertyLookup )+ ;\n\noC_PropertyKeyName\n               :  oC_SchemaName ;\n\noC_IntegerLiteral\n              :  HexInteger\n                  | OctalInteger\n                  | DecimalInteger\n                  ;\n\nHexInteger\n          :  '0x' ( HexDigit )+ ;\n\nDecimalInteger\n              :  ZeroDigit\n                  | ( NonZeroDigit ( Digit )* )\n                  ;\n\nOctalInteger\n            :  ZeroDigit ( OctDigit )+ ;\n\nHexLetter\n         :  ( 'A' | 'a' )\n             | ( 'B' | 'b' )\n             | ( 'C' | 'c' )\n             | ( 'D' | 'd' )\n             | ( 'E' | 'e' )\n             | ( 'F' | 'f' )\n             ;\n\nHexDigit\n        :  Digit\n            | HexLetter\n            ;\n\nDigit\n     :  ZeroDigit\n         | NonZeroDigit\n         ;\n\nNonZeroDigit\n            :  NonZeroOctDigit\n                | '8'\n                | '9'\n                ;\n\nNonZeroOctDigit\n               :  '1'\n                   | '2'\n                   | '3'\n                   | '4'\n                   | '5'\n                   | '6'\n                   | '7'\n                   ;\n\nOctDigit\n        :  ZeroDigit\n            | NonZeroOctDigit\n            ;\n\nZeroDigit\n         :  '0' ;\n\noC_DoubleLiteral\n             :  ExponentDecimalReal\n                 | RegularDecimalReal\n                 ;\n\nExponentDecimalReal\n                   :  ( ( Digit )+ | ( ( Digit )+ '.' ( Digit )+ ) | ( '.' ( Digit )+ ) ) ( 'E' | 'e' ) '-'? ( Digit )+ ;\n\nRegularDecimalReal\n                  :  ( Digit )* '.' ( Digit )+ ;\n\noC_SchemaName\n          :  oC_SymbolicName\n              | oC_ReservedWord\n              ;\n\noC_ReservedWord\n            :  ALL\n                | ASC\n                | ASCENDING\n                | BY\n                | CREATE\n                | DELETE\n                | DESC\n                | DESCENDING\n                | DETACH\n                | EXISTS\n                | LIMIT\n                | MATCH\n                | MERGE\n                | ON\n                | OPTIONAL\n                | ORDER\n                | REMOVE\n                | RETURN\n                | SET\n                | L_SKIP\n                | WHERE\n                | WITH\n                | UNION\n                | UNWIND\n                | AND\n                | AS\n                | CONTAINS\n                | DISTINCT\n                | ENDS\n                | IN\n                | IS\n                | NOT\n                | OR\n                | STARTS\n                | XOR\n                | FALSE\n                | TRUE\n                | NULL\n                | CONSTRAINT\n                | DO\n                | FOR\n                | REQUIRE\n                | UNIQUE\n                | CASE\n                | WHEN\n                | THEN\n                | ELSE\n                | END\n                | MANDATORY\n                | SCALAR\n                | OF\n                | ADD\n                | DROP\n                ;\n\nCONSTRAINT : ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'T' | 't' )  ;\n\nDO : ( 'D' | 'd' ) ( 'O' | 'o' )  ;\n\nFOR : ( 'F' | 'f' ) ( 'O' | 'o' ) ( 'R' | 'r' )  ;\n\nREQUIRE : ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'Q' | 'q' ) ( 'U' | 'u' ) ( 'I' | 'i' ) ( 'R' | 'r' ) ( 'E' | 'e' )  ;\n\nUNIQUE : ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'I' | 'i' ) ( 'Q' | 'q' ) ( 'U' | 'u' ) ( 'E' | 'e' )  ;\n\nMANDATORY : ( 'M' | 'm' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'O' | 'o' ) ( 'R' | 'r' ) ( 'Y' | 'y' )  ;\n\nSCALAR : ( 'S' | 's' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'R' | 'r' )  ;\n\nOF : ( 'O' | 'o' ) ( 'F' | 'f' )  ;\n\nADD : ( 'A' | 'a' ) ( 'D' | 'd' ) ( 'D' | 'd' )  ;\n\nDROP : ( 'D' | 'd' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'P' | 'p' )  ;\n\noC_SymbolicName\n            :  UnescapedSymbolicName\n                | EscapedSymbolicName\n                | HexLetter\n                | COUNT\n                | FILTER\n                | EXTRACT\n                | ANY\n                | NONE\n                | SINGLE\n                ;\n\nFILTER : ( 'F' | 'f' ) ( 'I' | 'i' ) ( 'L' | 'l' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' )  ;\n\nEXTRACT : ( 'E' | 'e' ) ( 'X' | 'x' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'C' | 'c' ) ( 'T' | 't' )  ;\n\nUnescapedSymbolicName\n                     :  IdentifierStart ( IdentifierPart )* ;\n\n/**\n * Based on the unicode identifier and pattern syntax\n *   (http://www.unicode.org/reports/tr31/)\n * And extended with a few characters.\n */\nIdentifierStart\n               :  ID_Start\n                   | Pc\n                   ;\n\n/**\n * Based on the unicode identifier and pattern syntax\n *   (http://www.unicode.org/reports/tr31/)\n * And extended with a few characters.\n */\nIdentifierPart\n              :  ID_Continue\n                  | Sc\n                  ;\n\n/**\n * Any character except \"`\", enclosed within `backticks`. Backticks are escaped with double backticks.\n */\nEscapedSymbolicName\n                   :  ( '`' ( EscapedSymbolicName_0 )* '`' )+ ;\n\nSP\n  :  ( WHITESPACE )+ ;\n\nWHITESPACE\n          :  SPACE\n              | TAB\n              | LF\n              | VT\n              | FF\n              | CR\n              | FS\n              | GS\n              | RS\n              | US\n              | '\\u1680'\n              | '\\u180e'\n              | '\\u2000'\n              | '\\u2001'\n              | '\\u2002'\n              | '\\u2003'\n              | '\\u2004'\n              | '\\u2005'\n              | '\\u2006'\n              | '\\u2008'\n              | '\\u2009'\n              | '\\u200a'\n              | '\\u2028'\n              | '\\u2029'\n              | '\\u205f'\n              | '\\u3000'\n              | '\\u00a0'\n              | '\\u2007'\n              | '\\u202f'\n              | Comment\n              ;\n\nComment\n       :  ( '/*' ( Comment_1 | ( '*' Comment_2 ) )* '*/' )\n           | ( '//' ( Comment_3 )* CR? ( LF | EOF ) )\n           ;\n\noC_LeftArrowHead\n             :  '<'\n                 | '\\u27e8'\n                 | '\\u3008'\n                 | '\\ufe64'\n                 | '\\uff1c'\n                 ;\n\noC_RightArrowHead\n              :  '>'\n                  | '\\u27e9'\n                  | '\\u3009'\n                  | '\\ufe65'\n                  | '\\uff1e'\n                  ;\n\noC_Dash\n    :  '-'\n        | '\\u00ad'\n        | '\\u2010'\n        | '\\u2011'\n        | '\\u2012'\n        | '\\u2013'\n        | '\\u2014'\n        | '\\u2015'\n        | '\\u2212'\n        | '\\ufe58'\n        | '\\ufe63'\n        | '\\uff0d'\n        ;\n\nfragment FF : [\\f] ;\n\nfragment EscapedSymbolicName_0 : ~[`] ;\n\nfragment RS : [\\u001E] ;\n\nfragment ID_Continue : [\\p{ID_Continue}] ;\n\nfragment Comment_1 : ~[*] ;\n\nfragment StringLiteral_1 : ~['\\\\] ;\n\nfragment Comment_3 : ~[\\n\\r] ;\n\nfragment Comment_2 : ~[/] ;\n\nfragment GS : [\\u001D] ;\n\nfragment FS : [\\u001C] ;\n\nfragment CR : [\\r] ;\n\nfragment Sc : [\\p{Sc}] ;\n\nfragment SPACE : [ ] ;\n\nfragment Pc : [\\p{Pc}] ;\n\nfragment TAB : [\\t] ;\n\nfragment StringLiteral_0 : ~[\"\\\\] ;\n\nfragment LF : [\\n] ;\n\nfragment VT : [\\u000B] ;\n\nfragment US : [\\u001F] ;\n\nfragment ID_Start : [\\p{ID_Start}] ;\n\n"
    },
    {
      "type": "paragraph",
      "id": "abe58de55a7aa629",
      "text": "⇒ [[Cypher Grammar Doctor]] ⇒ [[Building a Parser from an ANTLR Grammar]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Cypher.g4",
        "story": []
      },
      "date": 1652767478623
    },
    {
      "item": {
        "type": "factory",
        "id": "3b24d586f569bfed"
      },
      "id": "3b24d586f569bfed",
      "type": "add",
      "date": 1652767489368
    },
    {
      "type": "edit",
      "id": "3b24d586f569bfed",
      "item": {
        "type": "paragraph",
        "id": "3b24d586f569bfed",
        "text": "– https://s3.amazonaws.com/artifacts.opencypher.org/Cypher.g4"
      },
      "date": 1652767492860
    },
    {
      "type": "edit",
      "id": "3b24d586f569bfed",
      "item": {
        "type": "markdown",
        "id": "3b24d586f569bfed",
        "text": "– https://s3.amazonaws.com/artifacts.opencypher.org/Cypher.g4"
      },
      "date": 1652767493885
    },
    {
      "item": {
        "type": "factory",
        "id": "853ef88e2598d577"
      },
      "id": "853ef88e2598d577",
      "type": "add",
      "after": "3b24d586f569bfed",
      "date": 1652767503722
    },
    {
      "type": "edit",
      "id": "853ef88e2598d577",
      "item": {
        "type": "code",
        "id": "853ef88e2598d577",
        "text": "/**\n * Copyright (c) 2015-2020 \"Neo Technology,\"\n * Network Engine for Objects in Lund AB [http://neotechnology.com]\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * \n * Attribution Notice under the terms of the Apache License 2.0\n * \n * This work was created by the collective efforts of the openCypher community.\n * Without limiting the terms of Section 6, any Derivative Work that is not\n * approved by the public consensus process of the openCypher Implementers Group\n * should not be described as â€œCypherâ€ (and CypherÂ® is a registered trademark of\n * Neo4j Inc.) or as \"openCypher\". Extensions by implementers or prototypes or\n * proposals for change that have been documented or implemented should only be\n * described as \"implementation extensions to Cypher\" or as \"proposed changes to\n * Cypher that are not yet approved by the openCypher community\".\n */\ngrammar Cypher;\n\noC_Cypher\n      :  SP? oC_Statement ( SP? ';' )? SP? EOF ;\n\noC_Statement\n         :  oC_Query ;\n\noC_Query\n     :  oC_RegularQuery\n         | oC_StandaloneCall\n         ;\n\noC_RegularQuery\n            :  oC_SingleQuery ( SP? oC_Union )* ;\n\noC_Union\n     :  ( UNION SP ALL SP? oC_SingleQuery )\n         | ( UNION SP? oC_SingleQuery )\n         ;\n\nUNION : ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'I' | 'i' ) ( 'O' | 'o' ) ( 'N' | 'n' )  ;\n\nALL : ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'L' | 'l' )  ;\n\noC_SingleQuery\n           :  oC_SinglePartQuery\n               | oC_MultiPartQuery\n               ;\n\noC_SinglePartQuery\n               :  ( ( oC_ReadingClause SP? )* oC_Return )\n                   | ( ( oC_ReadingClause SP? )* oC_UpdatingClause ( SP? oC_UpdatingClause )* ( SP? oC_Return )? )\n                   ;\n\noC_MultiPartQuery\n              :  ( ( oC_ReadingClause SP? )* ( oC_UpdatingClause SP? )* oC_With SP? )+ oC_SinglePartQuery ;\n\noC_UpdatingClause\n              :  oC_Create\n                  | oC_Merge\n                  | oC_Delete\n                  | oC_Set\n                  | oC_Remove\n                  ;\n\noC_ReadingClause\n             :  oC_Match\n                 | oC_Unwind\n                 | oC_InQueryCall\n                 ;\n\noC_Match\n     :  ( OPTIONAL SP )? MATCH SP? oC_Pattern ( SP? oC_Where )? ;\n\nOPTIONAL : ( 'O' | 'o' ) ( 'P' | 'p' ) ( 'T' | 't' ) ( 'I' | 'i' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'A' | 'a' ) ( 'L' | 'l' )  ;\n\nMATCH : ( 'M' | 'm' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'C' | 'c' ) ( 'H' | 'h' )  ;\n\noC_Unwind\n      :  UNWIND SP? oC_Expression SP AS SP oC_Variable ;\n\nUNWIND : ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'W' | 'w' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'D' | 'd' )  ;\n\nAS : ( 'A' | 'a' ) ( 'S' | 's' )  ;\n\noC_Merge\n     :  MERGE SP? oC_PatternPart ( SP oC_MergeAction )* ;\n\nMERGE : ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'G' | 'g' ) ( 'E' | 'e' )  ;\n\noC_MergeAction\n           :  ( ON SP MATCH SP oC_Set )\n               | ( ON SP CREATE SP oC_Set )\n               ;\n\nON : ( 'O' | 'o' ) ( 'N' | 'n' )  ;\n\nCREATE : ( 'C' | 'c' ) ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'E' | 'e' )  ;\n\noC_Create\n      :  CREATE SP? oC_Pattern ;\n\noC_Set\n   :  SET SP? oC_SetItem ( ',' oC_SetItem )* ;\n\nSET : ( 'S' | 's' ) ( 'E' | 'e' ) ( 'T' | 't' )  ;\n\noC_SetItem\n       :  ( oC_PropertyExpression SP? '=' SP? oC_Expression )\n           | ( oC_Variable SP? '=' SP? oC_Expression )\n           | ( oC_Variable SP? '+=' SP? oC_Expression )\n           | ( oC_Variable SP? oC_NodeLabels )\n           ;\n\noC_Delete\n      :  ( DETACH SP )? DELETE SP? oC_Expression ( SP? ',' SP? oC_Expression )* ;\n\nDETACH : ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'C' | 'c' ) ( 'H' | 'h' )  ;\n\nDELETE : ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'E' | 'e' )  ;\n\noC_Remove\n      :  REMOVE SP oC_RemoveItem ( SP? ',' SP? oC_RemoveItem )* ;\n\nREMOVE : ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'M' | 'm' ) ( 'O' | 'o' ) ( 'V' | 'v' ) ( 'E' | 'e' )  ;\n\noC_RemoveItem\n          :  ( oC_Variable oC_NodeLabels )\n              | oC_PropertyExpression\n              ;\n\noC_InQueryCall\n           :  CALL SP oC_ExplicitProcedureInvocation ( SP? YIELD SP oC_YieldItems )? ;\n\nCALL : ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'L' | 'l' )  ;\n\nYIELD : ( 'Y' | 'y' ) ( 'I' | 'i' ) ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'D' | 'd' )  ;\n\noC_StandaloneCall\n              :  CALL SP ( oC_ExplicitProcedureInvocation | oC_ImplicitProcedureInvocation ) ( SP YIELD SP oC_YieldItems )? ;\n\noC_YieldItems\n          :  ( '*' | ( oC_YieldItem ( SP? ',' SP? oC_YieldItem )* ) ) ( SP? oC_Where )? ;\n\noC_YieldItem\n         :  ( oC_ProcedureResultField SP AS SP )? oC_Variable ;\n\noC_With\n    :  WITH oC_ProjectionBody ( SP? oC_Where )? ;\n\nWITH : ( 'W' | 'w' ) ( 'I' | 'i' ) ( 'T' | 't' ) ( 'H' | 'h' )  ;\n\noC_Return\n      :  RETURN oC_ProjectionBody ;\n\nRETURN : ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'N' | 'n' )  ;\n\noC_ProjectionBody\n              :  ( SP? DISTINCT )? SP oC_ProjectionItems ( SP oC_Order )? ( SP oC_Skip )? ( SP oC_Limit )? ;\n\nDISTINCT : ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'T' | 't' )  ;\n\noC_ProjectionItems\n               :  ( '*' ( SP? ',' SP? oC_ProjectionItem )* )\n                   | ( oC_ProjectionItem ( SP? ',' SP? oC_ProjectionItem )* )\n                   ;\n\noC_ProjectionItem\n              :  ( oC_Expression SP AS SP oC_Variable )\n                  | oC_Expression\n                  ;\n\noC_Order\n     :  ORDER SP BY SP oC_SortItem ( ',' SP? oC_SortItem )* ;\n\nORDER : ( 'O' | 'o' ) ( 'R' | 'r' ) ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'R' | 'r' )  ;\n\nBY : ( 'B' | 'b' ) ( 'Y' | 'y' )  ;\n\noC_Skip\n    :  L_SKIP SP oC_Expression ;\n\nL_SKIP : ( 'S' | 's' ) ( 'K' | 'k' ) ( 'I' | 'i' ) ( 'P' | 'p' )  ;\n\noC_Limit\n     :  LIMIT SP oC_Expression ;\n\nLIMIT : ( 'L' | 'l' ) ( 'I' | 'i' ) ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'T' | 't' )  ;\n\noC_SortItem\n        :  oC_Expression ( SP? ( ASCENDING | ASC | DESCENDING | DESC ) )? ;\n\nASCENDING : ( 'A' | 'a' ) ( 'S' | 's' ) ( 'C' | 'c' ) ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' )  ;\n\nASC : ( 'A' | 'a' ) ( 'S' | 's' ) ( 'C' | 'c' )  ;\n\nDESCENDING : ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' ) ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' )  ;\n\nDESC : ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' )  ;\n\noC_Where\n     :  WHERE SP oC_Expression ;\n\nWHERE : ( 'W' | 'w' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'E' | 'e' )  ;\n\noC_Pattern\n       :  oC_PatternPart ( SP? ',' SP? oC_PatternPart )* ;\n\noC_PatternPart\n           :  ( oC_Variable SP? '=' SP? oC_AnonymousPatternPart )\n               | oC_AnonymousPatternPart\n               ;\n\noC_AnonymousPatternPart\n                    :  oC_PatternElement ;\n\noC_PatternElement\n              :  ( oC_NodePattern ( SP? oC_PatternElementChain )* )\n                  | ( '(' oC_PatternElement ')' )\n                  ;\n\noC_NodePattern\n           :  '(' SP? ( oC_Variable SP? )? ( oC_NodeLabels SP? )? ( oC_Properties SP? )? ')' ;\n\noC_PatternElementChain\n                   :  oC_RelationshipPattern SP? oC_NodePattern ;\n\noC_RelationshipPattern\n                   :  ( oC_LeftArrowHead SP? oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash SP? oC_RightArrowHead )\n                       | ( oC_LeftArrowHead SP? oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash )\n                       | ( oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash SP? oC_RightArrowHead )\n                       | ( oC_Dash SP? oC_RelationshipDetail? SP? oC_Dash )\n                       ;\n\noC_RelationshipDetail\n                  :  '[' SP? ( oC_Variable SP? )? ( oC_RelationshipTypes SP? )? oC_RangeLiteral? ( oC_Properties SP? )? ']' ;\n\noC_Properties\n          :  oC_MapLiteral\n              | oC_Parameter\n              ;\n\noC_RelationshipTypes\n                 :  ':' SP? oC_RelTypeName ( SP? '|' ':'? SP? oC_RelTypeName )* ;\n\noC_NodeLabels\n          :  oC_NodeLabel ( SP? oC_NodeLabel )* ;\n\noC_NodeLabel\n         :  ':' SP? oC_LabelName ;\n\noC_RangeLiteral\n            :  '*' SP? ( oC_IntegerLiteral SP? )? ( '..' SP? ( oC_IntegerLiteral SP? )? )? ;\n\noC_LabelName\n         :  oC_SchemaName ;\n\noC_RelTypeName\n           :  oC_SchemaName ;\n\noC_Expression\n          :  oC_OrExpression ;\n\noC_OrExpression\n            :  oC_XorExpression ( SP OR SP oC_XorExpression )* ;\n\nOR : ( 'O' | 'o' ) ( 'R' | 'r' )  ;\n\noC_XorExpression\n             :  oC_AndExpression ( SP XOR SP oC_AndExpression )* ;\n\nXOR : ( 'X' | 'x' ) ( 'O' | 'o' ) ( 'R' | 'r' )  ;\n\noC_AndExpression\n             :  oC_NotExpression ( SP AND SP oC_NotExpression )* ;\n\nAND : ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'D' | 'd' )  ;\n\noC_NotExpression\n             :  ( NOT SP? )* oC_ComparisonExpression ;\n\nNOT : ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'T' | 't' )  ;\n\noC_ComparisonExpression\n                    :  oC_AddOrSubtractExpression ( SP? oC_PartialComparisonExpression )* ;\n\noC_AddOrSubtractExpression\n                       :  oC_MultiplyDivideModuloExpression ( ( SP? '+' SP? oC_MultiplyDivideModuloExpression ) | ( SP? '-' SP? oC_MultiplyDivideModuloExpression ) )* ;\n\noC_MultiplyDivideModuloExpression\n                              :  oC_PowerOfExpression ( ( SP? '*' SP? oC_PowerOfExpression ) | ( SP? '/' SP? oC_PowerOfExpression ) | ( SP? '%' SP? oC_PowerOfExpression ) )* ;\n\noC_PowerOfExpression\n                 :  oC_UnaryAddOrSubtractExpression ( SP? '^' SP? oC_UnaryAddOrSubtractExpression )* ;\n\noC_UnaryAddOrSubtractExpression\n                            :  ( ( '+' | '-' ) SP? )* oC_StringListNullOperatorExpression ;\n\noC_StringListNullOperatorExpression\n                                :  oC_PropertyOrLabelsExpression ( oC_StringOperatorExpression | oC_ListOperatorExpression | oC_NullOperatorExpression )* ;\n\noC_ListOperatorExpression\n                      :  ( SP IN SP? oC_PropertyOrLabelsExpression )\n                          | ( SP? '[' oC_Expression ']' )\n                          | ( SP? '[' oC_Expression? '..' oC_Expression? ']' )\n                          ;\n\nIN : ( 'I' | 'i' ) ( 'N' | 'n' )  ;\n\noC_StringOperatorExpression\n                        :  ( ( SP STARTS SP WITH ) | ( SP ENDS SP WITH ) | ( SP CONTAINS ) ) SP? oC_PropertyOrLabelsExpression ;\n\nSTARTS : ( 'S' | 's' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'R' | 'r' ) ( 'T' | 't' ) ( 'S' | 's' )  ;\n\nENDS : ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'S' | 's' )  ;\n\nCONTAINS : ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'S' | 's' )  ;\n\noC_NullOperatorExpression\n                      :  ( SP IS SP NULL )\n                          | ( SP IS SP NOT SP NULL )\n                          ;\n\nIS : ( 'I' | 'i' ) ( 'S' | 's' )  ;\n\nNULL : ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'L' | 'l' ) ( 'L' | 'l' )  ;\n\noC_PropertyOrLabelsExpression\n                          :  oC_Atom ( SP? oC_PropertyLookup )* ( SP? oC_NodeLabels )? ;\n\noC_Atom\n    :  oC_Literal\n        | oC_Parameter\n        | oC_CaseExpression\n        | ( COUNT SP? '(' SP? '*' SP? ')' )\n        | oC_ListComprehension\n        | oC_PatternComprehension\n        | ( ALL SP? '(' SP? oC_FilterExpression SP? ')' )\n        | ( ANY SP? '(' SP? oC_FilterExpression SP? ')' )\n        | ( NONE SP? '(' SP? oC_FilterExpression SP? ')' )\n        | ( SINGLE SP? '(' SP? oC_FilterExpression SP? ')' )\n        | oC_RelationshipsPattern\n        | oC_ParenthesizedExpression\n        | oC_FunctionInvocation\n        | oC_Variable\n        ;\n\nCOUNT : ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'T' | 't' )  ;\n\nANY : ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'Y' | 'y' )  ;\n\nNONE : ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'E' | 'e' )  ;\n\nSINGLE : ( 'S' | 's' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' ) ( 'L' | 'l' ) ( 'E' | 'e' )  ;\n\noC_Literal\n       :  oC_NumberLiteral\n           | StringLiteral\n           | oC_BooleanLiteral\n           | NULL\n           | oC_MapLiteral\n           | oC_ListLiteral\n           ;\n\noC_BooleanLiteral\n              :  TRUE\n                  | FALSE\n                  ;\n\nTRUE : ( 'T' | 't' ) ( 'R' | 'r' ) ( 'U' | 'u' ) ( 'E' | 'e' )  ;\n\nFALSE : ( 'F' | 'f' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'S' | 's' ) ( 'E' | 'e' )  ;\n\noC_ListLiteral\n           :  '[' SP? ( oC_Expression SP? ( ',' SP? oC_Expression SP? )* )? ']' ;\n\noC_PartialComparisonExpression\n                           :  ( '=' SP? oC_AddOrSubtractExpression )\n                               | ( '<>' SP? oC_AddOrSubtractExpression )\n                               | ( '<' SP? oC_AddOrSubtractExpression )\n                               | ( '>' SP? oC_AddOrSubtractExpression )\n                               | ( '<=' SP? oC_AddOrSubtractExpression )\n                               | ( '>=' SP? oC_AddOrSubtractExpression )\n                               ;\n\noC_ParenthesizedExpression\n                       :  '(' SP? oC_Expression SP? ')' ;\n\noC_RelationshipsPattern\n                    :  oC_NodePattern ( SP? oC_PatternElementChain )+ ;\n\noC_FilterExpression\n                :  oC_IdInColl ( SP? oC_Where )? ;\n\noC_IdInColl\n        :  oC_Variable SP IN SP oC_Expression ;\n\noC_FunctionInvocation\n                  :  oC_FunctionName SP? '(' SP? ( DISTINCT SP? )? ( oC_Expression SP? ( ',' SP? oC_Expression SP? )* )? ')' ;\n\noC_FunctionName\n            :  ( oC_Namespace oC_SymbolicName )\n                | EXISTS\n                ;\n\nEXISTS : ( 'E' | 'e' ) ( 'X' | 'x' ) ( 'I' | 'i' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'S' | 's' )  ;\n\noC_ExplicitProcedureInvocation\n                           :  oC_ProcedureName SP? '(' SP? ( oC_Expression SP? ( ',' SP? oC_Expression SP? )* )? ')' ;\n\noC_ImplicitProcedureInvocation\n                           :  oC_ProcedureName ;\n\noC_ProcedureResultField\n                    :  oC_SymbolicName ;\n\noC_ProcedureName\n             :  oC_Namespace oC_SymbolicName ;\n\noC_Namespace\n         :  ( oC_SymbolicName '.' )* ;\n\noC_ListComprehension\n                 :  '[' SP? oC_FilterExpression ( SP? '|' SP? oC_Expression )? SP? ']' ;\n\noC_PatternComprehension\n                    :  '[' SP? ( oC_Variable SP? '=' SP? )? oC_RelationshipsPattern SP? ( WHERE SP? oC_Expression SP? )? '|' SP? oC_Expression SP? ']' ;\n\noC_PropertyLookup\n              :  '.' SP? ( oC_PropertyKeyName ) ;\n\noC_CaseExpression\n              :  ( ( CASE ( SP? oC_CaseAlternatives )+ ) | ( CASE SP? oC_Expression ( SP? oC_CaseAlternatives )+ ) ) ( SP? ELSE SP? oC_Expression )? SP? END ;\n\nCASE : ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'S' | 's' ) ( 'E' | 'e' )  ;\n\nELSE : ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'S' | 's' ) ( 'E' | 'e' )  ;\n\nEND : ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'D' | 'd' )  ;\n\noC_CaseAlternatives\n                :  WHEN SP? oC_Expression SP? THEN SP? oC_Expression ;\n\nWHEN : ( 'W' | 'w' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'N' | 'n' )  ;\n\nTHEN : ( 'T' | 't' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'N' | 'n' )  ;\n\noC_Variable\n        :  oC_SymbolicName ;\n\nStringLiteral\n             :  ( '\"' ( StringLiteral_0 | EscapedChar )* '\"' )\n                 | ( '\\'' ( StringLiteral_1 | EscapedChar )* '\\'' )\n                 ;\n\nEscapedChar\n           :  '\\\\' ( '\\\\' | '\\'' | '\"' | ( 'B' | 'b' ) | ( 'F' | 'f' ) | ( 'N' | 'n' ) | ( 'R' | 'r' ) | ( 'T' | 't' ) | ( ( 'U' | 'u' ) ( HexDigit HexDigit HexDigit HexDigit ) ) | ( ( 'U' | 'u' ) ( HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit ) ) ) ;\n\noC_NumberLiteral\n             :  oC_DoubleLiteral\n                 | oC_IntegerLiteral\n                 ;\n\noC_MapLiteral\n          :  '{' SP? ( oC_PropertyKeyName SP? ':' SP? oC_Expression SP? ( ',' SP? oC_PropertyKeyName SP? ':' SP? oC_Expression SP? )* )? '}' ;\n\noC_Parameter\n         :  '$' ( oC_SymbolicName | DecimalInteger ) ;\n\noC_PropertyExpression\n                  :  oC_Atom ( SP? oC_PropertyLookup )+ ;\n\noC_PropertyKeyName\n               :  oC_SchemaName ;\n\noC_IntegerLiteral\n              :  HexInteger\n                  | OctalInteger\n                  | DecimalInteger\n                  ;\n\nHexInteger\n          :  '0x' ( HexDigit )+ ;\n\nDecimalInteger\n              :  ZeroDigit\n                  | ( NonZeroDigit ( Digit )* )\n                  ;\n\nOctalInteger\n            :  ZeroDigit ( OctDigit )+ ;\n\nHexLetter\n         :  ( 'A' | 'a' )\n             | ( 'B' | 'b' )\n             | ( 'C' | 'c' )\n             | ( 'D' | 'd' )\n             | ( 'E' | 'e' )\n             | ( 'F' | 'f' )\n             ;\n\nHexDigit\n        :  Digit\n            | HexLetter\n            ;\n\nDigit\n     :  ZeroDigit\n         | NonZeroDigit\n         ;\n\nNonZeroDigit\n            :  NonZeroOctDigit\n                | '8'\n                | '9'\n                ;\n\nNonZeroOctDigit\n               :  '1'\n                   | '2'\n                   | '3'\n                   | '4'\n                   | '5'\n                   | '6'\n                   | '7'\n                   ;\n\nOctDigit\n        :  ZeroDigit\n            | NonZeroOctDigit\n            ;\n\nZeroDigit\n         :  '0' ;\n\noC_DoubleLiteral\n             :  ExponentDecimalReal\n                 | RegularDecimalReal\n                 ;\n\nExponentDecimalReal\n                   :  ( ( Digit )+ | ( ( Digit )+ '.' ( Digit )+ ) | ( '.' ( Digit )+ ) ) ( 'E' | 'e' ) '-'? ( Digit )+ ;\n\nRegularDecimalReal\n                  :  ( Digit )* '.' ( Digit )+ ;\n\noC_SchemaName\n          :  oC_SymbolicName\n              | oC_ReservedWord\n              ;\n\noC_ReservedWord\n            :  ALL\n                | ASC\n                | ASCENDING\n                | BY\n                | CREATE\n                | DELETE\n                | DESC\n                | DESCENDING\n                | DETACH\n                | EXISTS\n                | LIMIT\n                | MATCH\n                | MERGE\n                | ON\n                | OPTIONAL\n                | ORDER\n                | REMOVE\n                | RETURN\n                | SET\n                | L_SKIP\n                | WHERE\n                | WITH\n                | UNION\n                | UNWIND\n                | AND\n                | AS\n                | CONTAINS\n                | DISTINCT\n                | ENDS\n                | IN\n                | IS\n                | NOT\n                | OR\n                | STARTS\n                | XOR\n                | FALSE\n                | TRUE\n                | NULL\n                | CONSTRAINT\n                | DO\n                | FOR\n                | REQUIRE\n                | UNIQUE\n                | CASE\n                | WHEN\n                | THEN\n                | ELSE\n                | END\n                | MANDATORY\n                | SCALAR\n                | OF\n                | ADD\n                | DROP\n                ;\n\nCONSTRAINT : ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'T' | 't' )  ;\n\nDO : ( 'D' | 'd' ) ( 'O' | 'o' )  ;\n\nFOR : ( 'F' | 'f' ) ( 'O' | 'o' ) ( 'R' | 'r' )  ;\n\nREQUIRE : ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'Q' | 'q' ) ( 'U' | 'u' ) ( 'I' | 'i' ) ( 'R' | 'r' ) ( 'E' | 'e' )  ;\n\nUNIQUE : ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'I' | 'i' ) ( 'Q' | 'q' ) ( 'U' | 'u' ) ( 'E' | 'e' )  ;\n\nMANDATORY : ( 'M' | 'm' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'O' | 'o' ) ( 'R' | 'r' ) ( 'Y' | 'y' )  ;\n\nSCALAR : ( 'S' | 's' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'R' | 'r' )  ;\n\nOF : ( 'O' | 'o' ) ( 'F' | 'f' )  ;\n\nADD : ( 'A' | 'a' ) ( 'D' | 'd' ) ( 'D' | 'd' )  ;\n\nDROP : ( 'D' | 'd' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'P' | 'p' )  ;\n\noC_SymbolicName\n            :  UnescapedSymbolicName\n                | EscapedSymbolicName\n                | HexLetter\n                | COUNT\n                | FILTER\n                | EXTRACT\n                | ANY\n                | NONE\n                | SINGLE\n                ;\n\nFILTER : ( 'F' | 'f' ) ( 'I' | 'i' ) ( 'L' | 'l' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' )  ;\n\nEXTRACT : ( 'E' | 'e' ) ( 'X' | 'x' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'C' | 'c' ) ( 'T' | 't' )  ;\n\nUnescapedSymbolicName\n                     :  IdentifierStart ( IdentifierPart )* ;\n\n/**\n * Based on the unicode identifier and pattern syntax\n *   (http://www.unicode.org/reports/tr31/)\n * And extended with a few characters.\n */\nIdentifierStart\n               :  ID_Start\n                   | Pc\n                   ;\n\n/**\n * Based on the unicode identifier and pattern syntax\n *   (http://www.unicode.org/reports/tr31/)\n * And extended with a few characters.\n */\nIdentifierPart\n              :  ID_Continue\n                  | Sc\n                  ;\n\n/**\n * Any character except \"`\", enclosed within `backticks`. Backticks are escaped with double backticks.\n */\nEscapedSymbolicName\n                   :  ( '`' ( EscapedSymbolicName_0 )* '`' )+ ;\n\nSP\n  :  ( WHITESPACE )+ ;\n\nWHITESPACE\n          :  SPACE\n              | TAB\n              | LF\n              | VT\n              | FF\n              | CR\n              | FS\n              | GS\n              | RS\n              | US\n              | '\\u1680'\n              | '\\u180e'\n              | '\\u2000'\n              | '\\u2001'\n              | '\\u2002'\n              | '\\u2003'\n              | '\\u2004'\n              | '\\u2005'\n              | '\\u2006'\n              | '\\u2008'\n              | '\\u2009'\n              | '\\u200a'\n              | '\\u2028'\n              | '\\u2029'\n              | '\\u205f'\n              | '\\u3000'\n              | '\\u00a0'\n              | '\\u2007'\n              | '\\u202f'\n              | Comment\n              ;\n\nComment\n       :  ( '/*' ( Comment_1 | ( '*' Comment_2 ) )* '*/' )\n           | ( '//' ( Comment_3 )* CR? ( LF | EOF ) )\n           ;\n\noC_LeftArrowHead\n             :  '<'\n                 | '\\u27e8'\n                 | '\\u3008'\n                 | '\\ufe64'\n                 | '\\uff1c'\n                 ;\n\noC_RightArrowHead\n              :  '>'\n                  | '\\u27e9'\n                  | '\\u3009'\n                  | '\\ufe65'\n                  | '\\uff1e'\n                  ;\n\noC_Dash\n    :  '-'\n        | '\\u00ad'\n        | '\\u2010'\n        | '\\u2011'\n        | '\\u2012'\n        | '\\u2013'\n        | '\\u2014'\n        | '\\u2015'\n        | '\\u2212'\n        | '\\ufe58'\n        | '\\ufe63'\n        | '\\uff0d'\n        ;\n\nfragment FF : [\\f] ;\n\nfragment EscapedSymbolicName_0 : ~[`] ;\n\nfragment RS : [\\u001E] ;\n\nfragment ID_Continue : [\\p{ID_Continue}] ;\n\nfragment Comment_1 : ~[*] ;\n\nfragment StringLiteral_1 : ~['\\\\] ;\n\nfragment Comment_3 : ~[\\n\\r] ;\n\nfragment Comment_2 : ~[/] ;\n\nfragment GS : [\\u001D] ;\n\nfragment FS : [\\u001C] ;\n\nfragment CR : [\\r] ;\n\nfragment Sc : [\\p{Sc}] ;\n\nfragment SPACE : [ ] ;\n\nfragment Pc : [\\p{Pc}] ;\n\nfragment TAB : [\\t] ;\n\nfragment StringLiteral_0 : ~[\"\\\\] ;\n\nfragment LF : [\\n] ;\n\nfragment VT : [\\u000B] ;\n\nfragment US : [\\u001F] ;\n\nfragment ID_Start : [\\p{ID_Start}] ;\n\n"
      },
      "date": 1652767505648
    },
    {
      "item": {
        "type": "factory",
        "id": "abe58de55a7aa629"
      },
      "id": "abe58de55a7aa629",
      "type": "add",
      "after": "853ef88e2598d577",
      "date": 1652769131619
    },
    {
      "type": "edit",
      "id": "abe58de55a7aa629",
      "item": {
        "type": "paragraph",
        "id": "abe58de55a7aa629",
        "text": "⇒ [[Cypher Grammar Doctor]]"
      },
      "date": 1652769133434
    },
    {
      "type": "edit",
      "id": "abe58de55a7aa629",
      "item": {
        "type": "paragraph",
        "id": "abe58de55a7aa629",
        "text": "⇒ [[Cypher Grammar Doctor]] ⇒ [[Building a Parser from an ANTLR Grammar]]"
      },
      "date": 1652769843345
    }
  ]
}