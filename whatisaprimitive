{
  "title": "whatIsAPrimitive",
  "story": [
    {
      "type": "paragraph",
      "id": "e390a714ed473708",
      "text": "Some messages in the system are responded to primitively. A primitive   \n\tresponse is performed directly by the interpreter rather than by evaluating   \n\texpressions in a method. The methods for these messages indicate the   \n\tpresence of a primitive response by including <primitive: xx> or \n\t<primitive: 79 error: ec> before the first expression in the method.   \n\t\n\t"
    },
    {
      "type": "paragraph",
      "id": "4298a12963009643",
      "text": "In the second case, ec is a special temporary variable that holds an error code. \n\tIn the VM primitive, failure is indicated by a variable called primFailCode being \n\tnon-zero. On activating a method with a failing primitive, if the index is in \n\tbounds of the \tprimitiveFailCodes array in the VMspecialObjectsArray then the \n\tfailure code substitutes the symbol in the \tprimitiveFailCodes array, otherwise \n\tit supplies the integer value.\n\t  \n\t"
    },
    {
      "type": "paragraph",
      "id": "d638bd24a78c7efc",
      "text": "Primitives exist for several reasons. Certain basic or 'primitive' \n\toperations cannot be performed in any other way. Smalltalk without \n\tprimitives can move values from one variable to another, but cannot add two \n\tSmallIntegers together. Many methods for arithmetic and comparison \n\tbetween numbers are primitives. Some primitives allow Smalltalk to \n\tcommunicate with I/O devices such as the disk, the display, and the keyboard. \n\tSome primitives exist only to make the system run faster; each does the same \n\tthing as a certain Smalltalk method, and its implementation as a primitive is \n\toptional.  \n\t  \n\t"
    },
    {
      "type": "paragraph",
      "id": "c62af325b1fa6f10",
      "text": "When the Smalltalk interpreter begins to execute a method which specifies a \n\tprimitive response, it tries to perform the primitive action and to return a \n\tresult. If the routine in the interpreter for this primitive is successful, \n\tit will return a value and the expressions in the method will not be evaluated. \n\tIf the primitive routine is not successful, the primitive 'fails', and the \n\tSmalltalk expressions in the method are executed instead. These \n\texpressions are evaluated as though the primitive routine had not been \n\tcalled.  \n\t  \n\t"
    },
    {
      "type": "paragraph",
      "id": "2275adca17032f9a",
      "text": "The Smalltalk code that is evaluated when a primitive fails usually \n\tanticipates why that primitive might fail. If the primitive is optional, the \n\texpressions in the method do exactly what the primitive would have done (See \n\tNumber @). If the primitive only works on certain classes of arguments, the \n\tSmalltalk code tries to coerce the argument or appeals to a superclass to find \n\ta more general way of doing the operation (see SmallInteger +). If the \n\tprimitive is never supposed to fail, the expressions signal an error (see \n\tSmallInteger asFloat).  \n\t  \n\t"
    },
    {
      "type": "paragraph",
      "id": "e0471e6b02231893",
      "text": "Each method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\t"
    },
    {
      "type": "paragraph",
      "id": "11fa12511fafdb0f",
      "text": "If a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\t"
    },
    {
      "type": "paragraph",
      "id": "1a1158ba53869708",
      "text": "For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. "
    },
    {
      "type": "paragraph",
      "id": "eed8ff71467d0e58",
      "text": "For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\" [http://www.mirandabanda.org/bluebook/bluebook_chapter29.html page]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "whatIsAPrimitive",
        "story": []
      },
      "date": 1660117116242
    },
    {
      "item": {
        "type": "factory",
        "id": "e390a714ed473708"
      },
      "id": "e390a714ed473708",
      "type": "add",
      "date": 1660117130920
    },
    {
      "type": "edit",
      "id": "e390a714ed473708",
      "item": {
        "type": "paragraph",
        "id": "e390a714ed473708",
        "text": "whatIsAPrimitive\n\t\"Some messages in the system are responded to primitively. A primitive   \n\tresponse is performed directly by the interpreter rather than by evaluating   \n\texpressions in a method. The methods for these messages indicate the   \n\tpresence of a primitive response by including <primitive: xx> or \n\t<primitive: 79 error: ec>before the first expression in the method.   \n\t\n\tIn the second case, ec is a special temporary variable that holds an error code. \n\tIn the VM primitive, failure is indicated by a variable called primFailCode being \n\tnon-zero. On activating a method with a failing primitive, if the index is in \n\tbounds of the \tprimitiveFailCodes array in the VMspecialObjectsArray then the \n\tfailure code substitutes the symbol in the \tprimitiveFailCodes array, otherwise \n\tit supplies the integer value.\n\t  \n\tPrimitives exist for several reasons. Certain basic or 'primitive' \n\toperations cannot be performed in any other way. Smalltalk without \n\tprimitives can move values from one variable to another, but cannot add two \n\tSmallIntegers together. Many methods for arithmetic and comparison \n\tbetween numbers are primitives. Some primitives allow Smalltalk to \n\tcommunicate with I/O devices such as the disk, the display, and the keyboard. \n\tSome primitives exist only to make the system run faster; each does the same \n\tthing as a certain Smalltalk method, and its implementation as a primitive is \n\toptional.  \n\t  \n\tWhen the Smalltalk interpreter begins to execute a method which specifies a \n\tprimitive response, it tries to perform the primitive action and to return a \n\tresult. If the routine in the interpreter for this primitive is successful, \n\tit will return a value and the expressions in the method will not be evaluated. \n\tIf the primitive routine is not successful, the primitive 'fails', and the \n\tSmalltalk expressions in the method are executed instead. These \n\texpressions are evaluated as though the primitive routine had not been \n\tcalled.  \n\t  \n\tThe Smalltalk code that is evaluated when a primitive fails usually \n\tanticipates why that primitive might fail. If the primitive is optional, the \n\texpressions in the method do exactly what the primitive would have done (See \n\tNumber @). If the primitive only works on certain classes of arguments, the \n\tSmalltalk code tries to coerce the argument or appeals to a superclass to find \n\ta more general way of doing the operation (see SmallInteger +). If the \n\tprimitive is never supposed to fail, the expressions signal an error (see \n\tSmallInteger asFloat).  \n\t  \n\tEach method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\tIf a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\tFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\"\n\t\n\t\n\n\tself error: 'comment only'"
      },
      "date": 1660117133167
    },
    {
      "type": "edit",
      "id": "e390a714ed473708",
      "item": {
        "type": "paragraph",
        "id": "e390a714ed473708",
        "text": "Some messages in the system are responded to primitively. A primitive   \n\tresponse is performed directly by the interpreter rather than by evaluating   \n\texpressions in a method. The methods for these messages indicate the   \n\tpresence of a primitive response by including <primitive: xx> or \n\t<primitive: 79 error: ec>before the first expression in the method.   \n\t\n\tIn the second case, ec is a special temporary variable that holds an error code. \n\tIn the VM primitive, failure is indicated by a variable called primFailCode being \n\tnon-zero. On activating a method with a failing primitive, if the index is in \n\tbounds of the \tprimitiveFailCodes array in the VMspecialObjectsArray then the \n\tfailure code substitutes the symbol in the \tprimitiveFailCodes array, otherwise \n\tit supplies the integer value.\n\t  \n\tPrimitives exist for several reasons. Certain basic or 'primitive' \n\toperations cannot be performed in any other way. Smalltalk without \n\tprimitives can move values from one variable to another, but cannot add two \n\tSmallIntegers together. Many methods for arithmetic and comparison \n\tbetween numbers are primitives. Some primitives allow Smalltalk to \n\tcommunicate with I/O devices such as the disk, the display, and the keyboard. \n\tSome primitives exist only to make the system run faster; each does the same \n\tthing as a certain Smalltalk method, and its implementation as a primitive is \n\toptional.  \n\t  \n\tWhen the Smalltalk interpreter begins to execute a method which specifies a \n\tprimitive response, it tries to perform the primitive action and to return a \n\tresult. If the routine in the interpreter for this primitive is successful, \n\tit will return a value and the expressions in the method will not be evaluated. \n\tIf the primitive routine is not successful, the primitive 'fails', and the \n\tSmalltalk expressions in the method are executed instead. These \n\texpressions are evaluated as though the primitive routine had not been \n\tcalled.  \n\t  \n\tThe Smalltalk code that is evaluated when a primitive fails usually \n\tanticipates why that primitive might fail. If the primitive is optional, the \n\texpressions in the method do exactly what the primitive would have done (See \n\tNumber @). If the primitive only works on certain classes of arguments, the \n\tSmalltalk code tries to coerce the argument or appeals to a superclass to find \n\ta more general way of doing the operation (see SmallInteger +). If the \n\tprimitive is never supposed to fail, the expressions signal an error (see \n\tSmallInteger asFloat).  \n\t  \n\tEach method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\tIf a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\tFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\"\n\t\n\t\n\n\tself error: 'comment only'"
      },
      "date": 1660117145389
    },
    {
      "type": "edit",
      "id": "e390a714ed473708",
      "item": {
        "type": "paragraph",
        "id": "e390a714ed473708",
        "text": "Some messages in the system are responded to primitively. A primitive   \n\tresponse is performed directly by the interpreter rather than by evaluating   \n\texpressions in a method. The methods for these messages indicate the   \n\tpresence of a primitive response by including <primitive: xx> or \n\t<primitive: 79 error: ec>before the first expression in the method.   \n\t\n\t"
      },
      "date": 1660117196755
    },
    {
      "type": "add",
      "id": "4298a12963009643",
      "item": {
        "type": "paragraph",
        "id": "4298a12963009643",
        "text": "In the second case, ec is a special temporary variable that holds an error code. \n\tIn the VM primitive, failure is indicated by a variable called primFailCode being \n\tnon-zero. On activating a method with a failing primitive, if the index is in \n\tbounds of the \tprimitiveFailCodes array in the VMspecialObjectsArray then the \n\tfailure code substitutes the symbol in the \tprimitiveFailCodes array, otherwise \n\tit supplies the integer value.\n\t  \n\t"
      },
      "after": "e390a714ed473708",
      "date": 1660117202265
    },
    {
      "type": "add",
      "id": "d638bd24a78c7efc",
      "item": {
        "type": "paragraph",
        "id": "d638bd24a78c7efc",
        "text": "Primitives exist for several reasons. Certain basic or 'primitive' \n\toperations cannot be performed in any other way. Smalltalk without \n\tprimitives can move values from one variable to another, but cannot add two \n\tSmallIntegers together. Many methods for arithmetic and comparison \n\tbetween numbers are primitives. Some primitives allow Smalltalk to \n\tcommunicate with I/O devices such as the disk, the display, and the keyboard. \n\tSome primitives exist only to make the system run faster; each does the same \n\tthing as a certain Smalltalk method, and its implementation as a primitive is \n\toptional.  \n\t  \n\t"
      },
      "after": "4298a12963009643",
      "date": 1660117209859
    },
    {
      "type": "add",
      "id": "c62af325b1fa6f10",
      "item": {
        "type": "paragraph",
        "id": "c62af325b1fa6f10",
        "text": "When the Smalltalk interpreter begins to execute a method which specifies a \n\tprimitive response, it tries to perform the primitive action and to return a \n\tresult. If the routine in the interpreter for this primitive is successful, \n\tit will return a value and the expressions in the method will not be evaluated. \n\tIf the primitive routine is not successful, the primitive 'fails', and the \n\tSmalltalk expressions in the method are executed instead. These \n\texpressions are evaluated as though the primitive routine had not been \n\tcalled.  \n\t  \n\t"
      },
      "after": "d638bd24a78c7efc",
      "date": 1660117215639
    },
    {
      "type": "add",
      "id": "2275adca17032f9a",
      "item": {
        "type": "paragraph",
        "id": "2275adca17032f9a",
        "text": "The Smalltalk code that is evaluated when a primitive fails usually \n\tanticipates why that primitive might fail. If the primitive is optional, the \n\texpressions in the method do exactly what the primitive would have done (See \n\tNumber @). If the primitive only works on certain classes of arguments, the \n\tSmalltalk code tries to coerce the argument or appeals to a superclass to find \n\ta more general way of doing the operation (see SmallInteger +). If the \n\tprimitive is never supposed to fail, the expressions signal an error (see \n\tSmallInteger asFloat).  \n\t  \n\t"
      },
      "after": "c62af325b1fa6f10",
      "date": 1660117223589
    },
    {
      "type": "add",
      "id": "e0471e6b02231893",
      "item": {
        "type": "paragraph",
        "id": "e0471e6b02231893",
        "text": "Each method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\t"
      },
      "after": "2275adca17032f9a",
      "date": 1660117232536
    },
    {
      "type": "add",
      "id": "11fa12511fafdb0f",
      "item": {
        "type": "paragraph",
        "id": "11fa12511fafdb0f",
        "text": "If a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\t"
      },
      "after": "e0471e6b02231893",
      "date": 1660117238427
    },
    {
      "type": "add",
      "id": "1a1158ba53869708",
      "item": {
        "type": "paragraph",
        "id": "1a1158ba53869708",
        "text": "For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\""
      },
      "after": "11fa12511fafdb0f",
      "date": 1660117253079
    },
    {
      "type": "edit",
      "id": "e390a714ed473708",
      "item": {
        "type": "paragraph",
        "id": "e390a714ed473708",
        "text": "Some messages in the system are responded to primitively. A primitive   \n\tresponse is performed directly by the interpreter rather than by evaluating   \n\texpressions in a method. The methods for these messages indicate the   \n\tpresence of a primitive response by including <primitive: xx> or \n\t<primitive: 79 error: ec> before the first expression in the method.   \n\t\n\t"
      },
      "date": 1660117296506
    },
    {
      "type": "edit",
      "id": "1a1158ba53869708",
      "item": {
        "type": "paragraph",
        "id": "1a1158ba53869708",
        "text": "For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. "
      },
      "date": 1660117626858
    },
    {
      "type": "add",
      "id": "eed8ff71467d0e58",
      "item": {
        "type": "paragraph",
        "id": "eed8ff71467d0e58",
        "text": "For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\""
      },
      "after": "1a1158ba53869708",
      "date": 1660117627478
    },
    {
      "type": "edit",
      "id": "eed8ff71467d0e58",
      "item": {
        "type": "paragraph",
        "id": "eed8ff71467d0e58",
        "text": "For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\" [http://www.mirandabanda.org/bluebook/bluebook_chapter29.html page]"
      },
      "date": 1660118322176
    }
  ]
}