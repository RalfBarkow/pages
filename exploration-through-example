{
  "title": "Exploration Through Example",
  "story": [
    {
      "type": "paragraph",
      "id": "be2ff4f4667c5f9c",
      "text": "[[Exploration Through Example]] [http://www.exampler.com/old-blog/2004/08/11/index.html post]"
    },
    {
      "type": "paragraph",
      "id": "2701573113a6a676",
      "text": "Wed, 11 Aug 2004\n\nThe story of advancers\n\n    An author wrote a story for Better Software about the usefulness of complex tests. I was struck by a conversation I'd once had with Ward Cunningham about how his team came up with [[Advancers]]. I saw a nice way to complement a test design article with code design content. So I wrote a sidebar. In the event, it didn't get used, so I'm putting it here. \n\nComplex tests can find bugs in complex code. What then? Usually, the result is an unending struggle against entropy: a continuous effort to fix bugs in unyielding code, hoping that each fix doesn't generate another bug. Once upon a time, Ward Cunningham was mired in entropy, but what happened next makes an unusual story.\n\nHis team was working on a bond trading application. It was to have two advantages over its competition. First, input would be more pleasant. Second, users would be able to generate reports on a position (a collection of holdings) as of any date.\n\n"
    },
    {
      "type": "paragraph",
      "id": "53412a3e4b4b3768",
      "text": "The latter proved hard to do. Many bug fixes later, one method in particular was clearly a problem. It was the one that advanced a position to a new date by processing all related transactions. It had grown to a convoluted mess of code, one that proved remarkably hard to clean up."
    },
    {
      "type": "paragraph",
      "id": "734ab2d98acd392b",
      "text": "\nThe solution was to convert the method into a Method Object. You can find a fuller description of method objects in Martin Fowler's fine Refactoring, but the basic idea goes like this:\n\n    Suppose you have a big method that contains many interrelated temporary variables. You can't untangle it by extracting little methods because each little method would use temporaries also used in other little methods. The need to coordinate sharing of variables makes it too hard to see any underlying structure.\n\n    Therefore, turn the method into an object, one that has a single method - perhaps called compute. Code that used to call the original method will have to make one of the new objects and call its compute method.\n\n    What does this gain you? Now you can change temporary variables into instance variables of the object. Since these are automatically shared among any methods of the object, you can now extract little methods without worrying about coordination.\n\n    As the little methods get extracted, the object's structure and responsibilities become clearer. Clearer code means fewer bugs.\n\nIt's common to treat method objects as just a coding convenience. But Cunningham's team found themselves treating this one as a design tool. They gave it a name - Advancer - that sounded like one from the domain (though none of the domain experts had a corresponding notion). Once Advancers were part of their design vocabulary, thinking about how to satisfy a new requirement meant, in part, thinking about whether a special kind of Advancer might fit nicely. By changing the way they thought about the domain, the team was able to write better code faster.\n\nAdvancers later helped out in another way. The program calculated tax reports. What the government wanted was described in terms of positions and portfolios, so the calculations were implemented by Position and Portfolio objects. But there were always nagging bugs. Some time after Advancers came on the scene, the team realized they were the right place for the calculation: it happened that Advancers had instance variables that contained exactly the information needed. Switching to Advancers made tax reports tractable.\n\n"
    },
    {
      "type": "paragraph",
      "id": "9a85330787f22c3f",
      "text": "It was only in later years that Cunningham realized why tax calculations had been so troublesome. The government and traders had different interests. The traders cared most about their positions, whereas the government cared most about how traders came to have them. It's that latter idea that Advancers captured, but conversations with domain experts couldn't tease it out - even tax experts didn't know how to express it that way. It only came out through a conversation with the code.\n\nIn some circles, it's said that programmers + the code + rules for code cleanliness are smarter than programmers alone. That is, programmers who actively reshape or mold the code as it changes will cause new and unexpectedly powerful design concepts to emerge. The story of Advancers shows massaging the code as a learning tool.\n\n## Posted at 14:28 in category /coding [http://www.exampler.com/old-blog/2004/08/11/index.html#advancers permalink] [top] "
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Exploration Through Example",
        "story": []
      },
      "date": 1641301738322
    },
    {
      "item": {
        "type": "factory",
        "id": "be2ff4f4667c5f9c"
      },
      "id": "be2ff4f4667c5f9c",
      "type": "add",
      "date": 1641301739954
    },
    {
      "type": "edit",
      "id": "be2ff4f4667c5f9c",
      "item": {
        "type": "paragraph",
        "id": "be2ff4f4667c5f9c",
        "text": "[[Exploration Through Example]] [http://www.exampler.com/old-blog/2004/08/11/index.html post]"
      },
      "date": 1641301741532
    },
    {
      "item": {
        "type": "factory",
        "id": "2701573113a6a676"
      },
      "id": "2701573113a6a676",
      "type": "add",
      "after": "be2ff4f4667c5f9c",
      "date": 1641301759272
    },
    {
      "type": "edit",
      "id": "2701573113a6a676",
      "item": {
        "type": "paragraph",
        "id": "2701573113a6a676",
        "text": "Wed, 11 Aug 2004\n\nThe story of advancers\n\n    An author wrote a story for Better Software about the usefulness of complex tests. I was struck by a conversation I'd once had with Ward Cunningham about how his team came up with Advancers. I saw a nice way to complement a test design article with code design content. So I wrote a sidebar. In the event, it didn't get used, so I'm putting it here. \n\nComplex tests can find bugs in complex code. What then? Usually, the result is an unending struggle against entropy: a continuous effort to fix bugs in unyielding code, hoping that each fix doesn't generate another bug. Once upon a time, Ward Cunningham was mired in entropy, but what happened next makes an unusual story.\n\nHis team was working on a bond trading application. It was to have two advantages over its competition. First, input would be more pleasant. Second, users would be able to generate reports on a position (a collection of holdings) as of any date.\n\nThe latter proved hard to do. Many bug fixes later, one method in particular was clearly a problem. It was the one that advanced a position to a new date by processing all related transactions. It had grown to a convoluted mess of code, one that proved remarkably hard to clean up.\n\nThe solution was to convert the method into a Method Object. You can find a fuller description of method objects in Martin Fowler's fine Refactoring, but the basic idea goes like this:\n\n    Suppose you have a big method that contains many interrelated temporary variables. You can't untangle it by extracting little methods because each little method would use temporaries also used in other little methods. The need to coordinate sharing of variables makes it too hard to see any underlying structure.\n\n    Therefore, turn the method into an object, one that has a single method - perhaps called compute. Code that used to call the original method will have to make one of the new objects and call its compute method.\n\n    What does this gain you? Now you can change temporary variables into instance variables of the object. Since these are automatically shared among any methods of the object, you can now extract little methods without worrying about coordination.\n\n    As the little methods get extracted, the object's structure and responsibilities become clearer. Clearer code means fewer bugs.\n\nIt's common to treat method objects as just a coding convenience. But Cunningham's team found themselves treating this one as a design tool. They gave it a name - Advancer - that sounded like one from the domain (though none of the domain experts had a corresponding notion). Once Advancers were part of their design vocabulary, thinking about how to satisfy a new requirement meant, in part, thinking about whether a special kind of Advancer might fit nicely. By changing the way they thought about the domain, the team was able to write better code faster.\n\nAdvancers later helped out in another way. The program calculated tax reports. What the government wanted was described in terms of positions and portfolios, so the calculations were implemented by Position and Portfolio objects. But there were always nagging bugs. Some time after Advancers came on the scene, the team realized they were the right place for the calculation: it happened that Advancers had instance variables that contained exactly the information needed. Switching to Advancers made tax reports tractable.\n\nIt was only in later years that Cunningham realized why tax calculations had been so troublesome. The government and traders had different interests. The traders cared most about their positions, whereas the government cared most about how traders came to have them. It's that latter idea that Advancers captured, but conversations with domain experts couldn't tease it out - even tax experts didn't know how to express it that way. It only came out through a conversation with the code.\n\nIn some circles, it's said that programmers + the code + rules for code cleanliness are smarter than programmers alone. That is, programmers who actively reshape or mold the code as it changes will cause new and unexpectedly powerful design concepts to emerge. The story of Advancers shows massaging the code as a learning tool.\n\n## Posted at 14:28 in category /coding [permalink] [top] "
      },
      "date": 1641301761058
    },
    {
      "type": "edit",
      "id": "2701573113a6a676",
      "item": {
        "type": "paragraph",
        "id": "2701573113a6a676",
        "text": "Wed, 11 Aug 2004\n\nThe story of advancers\n\n    An author wrote a story for Better Software about the usefulness of complex tests. I was struck by a conversation I'd once had with Ward Cunningham about how his team came up with [[Advancers]]. I saw a nice way to complement a test design article with code design content. So I wrote a sidebar. In the event, it didn't get used, so I'm putting it here. \n\nComplex tests can find bugs in complex code. What then? Usually, the result is an unending struggle against entropy: a continuous effort to fix bugs in unyielding code, hoping that each fix doesn't generate another bug. Once upon a time, Ward Cunningham was mired in entropy, but what happened next makes an unusual story.\n\nHis team was working on a bond trading application. It was to have two advantages over its competition. First, input would be more pleasant. Second, users would be able to generate reports on a position (a collection of holdings) as of any date.\n\nThe latter proved hard to do. Many bug fixes later, one method in particular was clearly a problem. It was the one that advanced a position to a new date by processing all related transactions. It had grown to a convoluted mess of code, one that proved remarkably hard to clean up.\n\nThe solution was to convert the method into a Method Object. You can find a fuller description of method objects in Martin Fowler's fine Refactoring, but the basic idea goes like this:\n\n    Suppose you have a big method that contains many interrelated temporary variables. You can't untangle it by extracting little methods because each little method would use temporaries also used in other little methods. The need to coordinate sharing of variables makes it too hard to see any underlying structure.\n\n    Therefore, turn the method into an object, one that has a single method - perhaps called compute. Code that used to call the original method will have to make one of the new objects and call its compute method.\n\n    What does this gain you? Now you can change temporary variables into instance variables of the object. Since these are automatically shared among any methods of the object, you can now extract little methods without worrying about coordination.\n\n    As the little methods get extracted, the object's structure and responsibilities become clearer. Clearer code means fewer bugs.\n\nIt's common to treat method objects as just a coding convenience. But Cunningham's team found themselves treating this one as a design tool. They gave it a name - Advancer - that sounded like one from the domain (though none of the domain experts had a corresponding notion). Once Advancers were part of their design vocabulary, thinking about how to satisfy a new requirement meant, in part, thinking about whether a special kind of Advancer might fit nicely. By changing the way they thought about the domain, the team was able to write better code faster.\n\nAdvancers later helped out in another way. The program calculated tax reports. What the government wanted was described in terms of positions and portfolios, so the calculations were implemented by Position and Portfolio objects. But there were always nagging bugs. Some time after Advancers came on the scene, the team realized they were the right place for the calculation: it happened that Advancers had instance variables that contained exactly the information needed. Switching to Advancers made tax reports tractable.\n\nIt was only in later years that Cunningham realized why tax calculations had been so troublesome. The government and traders had different interests. The traders cared most about their positions, whereas the government cared most about how traders came to have them. It's that latter idea that Advancers captured, but conversations with domain experts couldn't tease it out - even tax experts didn't know how to express it that way. It only came out through a conversation with the code.\n\nIn some circles, it's said that programmers + the code + rules for code cleanliness are smarter than programmers alone. That is, programmers who actively reshape or mold the code as it changes will cause new and unexpectedly powerful design concepts to emerge. The story of Advancers shows massaging the code as a learning tool.\n\n## Posted at 14:28 in category /coding [permalink] [top] "
      },
      "date": 1641301785934
    },
    {
      "type": "edit",
      "id": "2701573113a6a676",
      "item": {
        "type": "paragraph",
        "id": "2701573113a6a676",
        "text": "Wed, 11 Aug 2004\n\nThe story of advancers\n\n    An author wrote a story for Better Software about the usefulness of complex tests. I was struck by a conversation I'd once had with Ward Cunningham about how his team came up with [[Advancers]]. I saw a nice way to complement a test design article with code design content. So I wrote a sidebar. In the event, it didn't get used, so I'm putting it here. \n\nComplex tests can find bugs in complex code. What then? Usually, the result is an unending struggle against entropy: a continuous effort to fix bugs in unyielding code, hoping that each fix doesn't generate another bug. Once upon a time, Ward Cunningham was mired in entropy, but what happened next makes an unusual story.\n\nHis team was working on a bond trading application. It was to have two advantages over its competition. First, input would be more pleasant. Second, users would be able to generate reports on a position (a collection of holdings) as of any date.\n\nThe latter proved hard to do. Many bug fixes later, one method in particular was clearly a problem. It was the one that advanced a position to a new date by processing all related transactions. It had grown to a convoluted mess of code, one that proved remarkably hard to clean up.\n\nThe solution was to convert the method into a Method Object. You can find a fuller description of method objects in Martin Fowler's fine Refactoring, but the basic idea goes like this:\n\n    Suppose you have a big method that contains many interrelated temporary variables. You can't untangle it by extracting little methods because each little method would use temporaries also used in other little methods. The need to coordinate sharing of variables makes it too hard to see any underlying structure.\n\n    Therefore, turn the method into an object, one that has a single method - perhaps called compute. Code that used to call the original method will have to make one of the new objects and call its compute method.\n\n    What does this gain you? Now you can change temporary variables into instance variables of the object. Since these are automatically shared among any methods of the object, you can now extract little methods without worrying about coordination.\n\n    As the little methods get extracted, the object's structure and responsibilities become clearer. Clearer code means fewer bugs.\n\nIt's common to treat method objects as just a coding convenience. But Cunningham's team found themselves treating this one as a design tool. They gave it a name - Advancer - that sounded like one from the domain (though none of the domain experts had a corresponding notion). Once Advancers were part of their design vocabulary, thinking about how to satisfy a new requirement meant, in part, thinking about whether a special kind of Advancer might fit nicely. By changing the way they thought about the domain, the team was able to write better code faster.\n\nAdvancers later helped out in another way. The program calculated tax reports. What the government wanted was described in terms of positions and portfolios, so the calculations were implemented by Position and Portfolio objects. But there were always nagging bugs. Some time after Advancers came on the scene, the team realized they were the right place for the calculation: it happened that Advancers had instance variables that contained exactly the information needed. Switching to Advancers made tax reports tractable.\n\n"
      },
      "date": 1641301854862
    },
    {
      "type": "add",
      "id": "9a85330787f22c3f",
      "item": {
        "type": "paragraph",
        "id": "9a85330787f22c3f",
        "text": "It was only in later years that Cunningham realized why tax calculations had been so troublesome. The government and traders had different interests. The traders cared most about their positions, whereas the government cared most about how traders came to have them. It's that latter idea that Advancers captured, but conversations with domain experts couldn't tease it out - even tax experts didn't know how to express it that way. It only came out through a conversation with the code.\n\nIn some circles, it's said that programmers + the code + rules for code cleanliness are smarter than programmers alone. That is, programmers who actively reshape or mold the code as it changes will cause new and unexpectedly powerful design concepts to emerge. The story of Advancers shows massaging the code as a learning tool.\n\n## Posted at 14:28 in category /coding [permalink] [top] "
      },
      "after": "2701573113a6a676",
      "date": 1641301866621
    },
    {
      "type": "edit",
      "id": "2701573113a6a676",
      "item": {
        "type": "paragraph",
        "id": "2701573113a6a676",
        "text": "Wed, 11 Aug 2004\n\nThe story of advancers\n\n    An author wrote a story for Better Software about the usefulness of complex tests. I was struck by a conversation I'd once had with Ward Cunningham about how his team came up with [[Advancers]]. I saw a nice way to complement a test design article with code design content. So I wrote a sidebar. In the event, it didn't get used, so I'm putting it here. \n\nComplex tests can find bugs in complex code. What then? Usually, the result is an unending struggle against entropy: a continuous effort to fix bugs in unyielding code, hoping that each fix doesn't generate another bug. Once upon a time, Ward Cunningham was mired in entropy, but what happened next makes an unusual story.\n\nHis team was working on a bond trading application. It was to have two advantages over its competition. First, input would be more pleasant. Second, users would be able to generate reports on a position (a collection of holdings) as of any date.\n\n"
      },
      "date": 1641301878414
    },
    {
      "type": "add",
      "id": "53412a3e4b4b3768",
      "item": {
        "type": "paragraph",
        "id": "53412a3e4b4b3768",
        "text": "The latter proved hard to do. Many bug fixes later, one method in particular was clearly a problem. It was the one that advanced a position to a new date by processing all related transactions. It had grown to a convoluted mess of code, one that proved remarkably hard to clean up."
      },
      "after": "2701573113a6a676",
      "date": 1641301882128
    },
    {
      "type": "add",
      "id": "734ab2d98acd392b",
      "item": {
        "type": "paragraph",
        "id": "734ab2d98acd392b",
        "text": "\nThe solution was to convert the method into a Method Object. You can find a fuller description of method objects in Martin Fowler's fine Refactoring, but the basic idea goes like this:\n\n    Suppose you have a big method that contains many interrelated temporary variables. You can't untangle it by extracting little methods because each little method would use temporaries also used in other little methods. The need to coordinate sharing of variables makes it too hard to see any underlying structure.\n\n    Therefore, turn the method into an object, one that has a single method - perhaps called compute. Code that used to call the original method will have to make one of the new objects and call its compute method.\n\n    What does this gain you? Now you can change temporary variables into instance variables of the object. Since these are automatically shared among any methods of the object, you can now extract little methods without worrying about coordination.\n\n    As the little methods get extracted, the object's structure and responsibilities become clearer. Clearer code means fewer bugs.\n\nIt's common to treat method objects as just a coding convenience. But Cunningham's team found themselves treating this one as a design tool. They gave it a name - Advancer - that sounded like one from the domain (though none of the domain experts had a corresponding notion). Once Advancers were part of their design vocabulary, thinking about how to satisfy a new requirement meant, in part, thinking about whether a special kind of Advancer might fit nicely. By changing the way they thought about the domain, the team was able to write better code faster.\n\nAdvancers later helped out in another way. The program calculated tax reports. What the government wanted was described in terms of positions and portfolios, so the calculations were implemented by Position and Portfolio objects. But there were always nagging bugs. Some time after Advancers came on the scene, the team realized they were the right place for the calculation: it happened that Advancers had instance variables that contained exactly the information needed. Switching to Advancers made tax reports tractable.\n\n"
      },
      "after": "53412a3e4b4b3768",
      "date": 1641301883853
    },
    {
      "type": "edit",
      "id": "9a85330787f22c3f",
      "item": {
        "type": "paragraph",
        "id": "9a85330787f22c3f",
        "text": "It was only in later years that Cunningham realized why tax calculations had been so troublesome. The government and traders had different interests. The traders cared most about their positions, whereas the government cared most about how traders came to have them. It's that latter idea that Advancers captured, but conversations with domain experts couldn't tease it out - even tax experts didn't know how to express it that way. It only came out through a conversation with the code.\n\nIn some circles, it's said that programmers + the code + rules for code cleanliness are smarter than programmers alone. That is, programmers who actively reshape or mold the code as it changes will cause new and unexpectedly powerful design concepts to emerge. The story of Advancers shows massaging the code as a learning tool.\n\n## Posted at 14:28 in category /coding [http://www.exampler.com/old-blog/2004/08/11/index.html#advancers permalink] [top] "
      },
      "date": 1641302129536
    }
  ]
}