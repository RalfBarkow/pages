{
  "title": "Merkle Trees and Build Systems",
  "story": [
    {
      "type": "markdown",
      "id": "fdc6263dd54b620f",
      "text": "https://lwn.net/Articles/821367/"
    },
    {
      "type": "markdown",
      "id": "088712d293b15641",
      "text": "In traditional build tools like Make, targets and dependencies are always files. Imagine if you could specify an entire tree (directory) as a dependency: You could exhaustively specify a \"build root\" filesystem containing the toolchain used for building some target as a dependency of that target. Similarly, a rule that creates that build root would have the tree as its target. Using Merkle trees as first-class citizens in a build system gives great flexibility and many optimization opportunities. In this article I'll explore this idea using [[OSTree]], Ninja, and Python."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Merkle Trees and Build Systems",
        "story": []
      },
      "date": 1635978141842
    },
    {
      "item": {
        "type": "factory",
        "id": "fdc6263dd54b620f"
      },
      "id": "fdc6263dd54b620f",
      "type": "add",
      "date": 1635978165625
    },
    {
      "type": "edit",
      "id": "fdc6263dd54b620f",
      "item": {
        "type": "markdown",
        "id": "fdc6263dd54b620f",
        "text": "https://lwn.net/Articles/821367/"
      },
      "date": 1635978169918
    },
    {
      "item": {
        "type": "factory",
        "id": "088712d293b15641"
      },
      "id": "088712d293b15641",
      "type": "add",
      "after": "fdc6263dd54b620f",
      "date": 1635978180811
    },
    {
      "type": "edit",
      "id": "088712d293b15641",
      "item": {
        "type": "markdown",
        "id": "088712d293b15641",
        "text": "In traditional build tools like Make, targets and dependencies are always files. Imagine if you could specify an entire tree (directory) as a dependency: You could exhaustively specify a \"build root\" filesystem containing the toolchain used for building some target as a dependency of that target. Similarly, a rule that creates that build root would have the tree as its target. Using Merkle trees as first-class citizens in a build system gives great flexibility and many optimization opportunities. In this article I'll explore this idea using OSTree, Ninja, and Python."
      },
      "date": 1635978182824
    },
    {
      "type": "edit",
      "id": "088712d293b15641",
      "item": {
        "type": "markdown",
        "id": "088712d293b15641",
        "text": "In traditional build tools like Make, targets and dependencies are always files. Imagine if you could specify an entire tree (directory) as a dependency: You could exhaustively specify a \"build root\" filesystem containing the toolchain used for building some target as a dependency of that target. Similarly, a rule that creates that build root would have the tree as its target. Using Merkle trees as first-class citizens in a build system gives great flexibility and many optimization opportunities. In this article I'll explore this idea using [[OSTree]], Ninja, and Python."
      },
      "date": 1635978202615
    }
  ]
}