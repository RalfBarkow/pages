{
  "title": "What Is Null",
  "story": [
    {
      "type": "html",
      "text": "<b><i>What is this thing called \"NULL\"?!?</b></i>",
      "id": "7443f5600bf3fe3f9d195b7de497836a"
    },
    {
      "type": "html",
      "text": "[[Null]] or Nil Characteristics:",
      "id": "f5dcb7be7f19fcd9179661cabd199242"
    },
    {
      "type": "html",
      "text": " Etymo: Latin nullus \"not any, none,\" from ne- \"not, no\" (see un-) + illus \"any,\" dim. of unus \"one.\"",
      "id": "9832d6ec26a1b1eb4a9810166ae63192"
    },
    {
      "type": "html",
      "text": " Semantically: Very difficult. In most cases, NULL or nil means \"no value\" or \"not applicable\". Sometimes (like, when passed to a routine as an argument) it means \"no explicit value\". In SQL, it often means \"not known\". Sometimes it might mean \"whatever\". Given this overloading of meanings, it is a little problematic - you sometimes encounter problems related to confusion about the meaning of NULL. Even so, it is a very useful concept - but heavy use of NULLs is often a sign that you should be using lists of values or tagged unions instead.",
      "id": "17814d0229d2ddaff461e9c5e1a4596f"
    },
    {
      "type": "html",
      "text": " Semantically: Very simple. It is the same as the Japanese character \"mu\" [Chinese \"wu\"; see [[Mu Answer]]]. It means \"no thing\". In logic it means \"neither yes nor no\" or \"dumb question\". <i>You call that simple? The character has at least four different readings in different languages. In addition, it has a native reading in [[Japanese Language]] of \"nai\" which means \"does not exist\" or \"there is no\". Depending on the context, this means at least six different things. Hell, that makes the computer nil concept seem pretty well-defined...</i> Yes, I call \"mu\" simple.",
      "id": "da2c32d0282086229f4972672a603fdd"
    },
    {
      "type": "html",
      "text": " [[Nil In Lisp]]: The [[Lisp Language]] defined <i>NIL</i> (and perhaps invented) the use of \"NIL\" as a special object that is both a Symbol and a List - it is the only such object. NIL is the same as (). () is the empty list. NIL is a constant that has NIL as its value. Lists in Lisp are built from [[Cons Cell]]s. Thus, if there is some list (1 2 3), the \"FIRST\" function answers the first element, which can be either a Atom or a list (in this case the number 1). The \"REST\" function answers \"the rest of the list\" (in this case, \"(2 3)\"). Every list has an implied \"NIL\" at the end, so that the \"REST\" of the list \"(3)\" is NIL. This use of NIL to terminate a list is reminiscent of the use of \"NULL\" to terminate a char array in [[Cee Language]] (which came later). It is also reminiscent of the use of [[The Nil Object]] in [[Smalltalk Language]] (not surprising, given [[Dan Bobrow]]'s influence on the [[Smalltalk Language]] team). The type of NIL is NULL. NULL is also a predicate that returns T when its argument is NIL. NIL is also (NOT T). It is also the only object that is (NOT T). So NIL serves as the value for logical false. NIL is also the empty datatype.",
      "id": "d45dce410fecfe8021535f41c662627a"
    },
    {
      "type": "html",
      "text": " [[Nil In Scheme]]: [[Scheme Language]] doesn't have a value named nil, but nil as generally taken to be the empty list (as in other Lisps). However, unlike [[Common Lisp]], the booleans in Scheme are #t and #f (instead of t and nil). The empty list is written as '(). Scheme advocates claim that this clarifies case expressions.",
      "id": "1f843c09631a3715234ba89409dfcd0d"
    },
    {
      "type": "html",
      "text": " <i>This is a strange position to take, given that the Lisp community has happily, and without any problems whatsoever, been punning on the multiple meanings of NIL for forty years. Perhaps the real problem lies elsewhere? -- [[Alain Picard]]</i>",
      "id": "b3cfc6f2a6f807e29db4fa62ecfbb552"
    },
    {
      "type": "html",
      "text": " It bugged enough Lispers that [[Scheme Language]] finally completely split the boolean concept and list concept. [rest of argument about different treatment of nil in [[Common Lisp]] and Scheme moved to [[Is Scheme Lisp]]]",
      "id": "e5828d798e2fa07934d5a913207a6043"
    },
    {
      "type": "html",
      "text": " [[Null Pointer]]: Pointers in some languages, like C, C++, and Pascal, can be given the value \"NULL,\" which indicates that this pointer does not currently point to a valid location in memory. Dereferencing a [[Null Pointer]] causes [[Undefined Behavior]]. [Often [[Null Pointer]] is declared as 0 (cast to the appropriate type), which causes some machines to generate a hardware interrupt when it is dereferenced. Usually the runtime (when configured to do so) catches this and throws an exception, often through a software interrupt. In older C implementations the results are undetermined - in other words, it blows up in your face.] NULL is commonly used to terminate lists and other complex structures, or to indicate that the given object is absent or unknown.",
      "id": "7e4f7fab9d63d6c46bac14c9e598a6d4"
    },
    {
      "type": "html",
      "text": " [[Nul Character]]: The NUL character, with code point 0 in most [[Coded Character Set]]s (ASCII, ISO-Latin-x, Unicode, etc.). This is <i>not</i> a pointer.",
      "id": "45da8d8bb8e31d7e334ab56152aee96b"
    },
    {
      "type": "html",
      "text": " [[Nul Code Unit]]: In some [[Character Encoding Format]]s, in general more than one [[Code Unit]] is used to represent a character. Nevertheless, the zero [[Code Unit]] is almost always reserved for terminating a string, and cannot occur in any character other than [[Nul Character]] (this also applies to [[Character Encoding Format]]s in which [[Code Unit]]s are more than 8 bits). It can therefore be used to terminate string representations (e.g. [[Char Star]] strings in C).",
      "id": "3f085d61d0a39d7028bd0aa73fa7a12f"
    },
    {
      "type": "html",
      "text": " [[Null String]]: The string containing no characters; [[Empty String]]. (This is typical usage for C, where some people call an empty \"C style\" string (\"\") a \"[[Null String]]\". Physically, it is a pointer to a character array that starts with a [[Nul Character]], '\\0'.)",
      "id": "bc43ffaf7310bfd813e6c3ebd0e91a04"
    },
    {
      "type": "html",
      "text": "<i>Is this standard terminology? In my C days, I thought of {char *s = NULL;} as a [[Null String]], and {char *s = \"\";} as an [[Empty String]].</i>\nYes, this is pretty standard.",
      "id": "d1a5106ee30046d42b268d925ae6e1ca"
    },
    {
      "type": "html",
      "text": " [[The Nil Object]]: The [[Smalltalk Language]] uses \"nil\" - a reference to a unique object ([[Singleton Pattern]]) of the class [[Undefined Object]]; used to represent the absence of an object.",
      "id": "cac76bf0ae514e8f95769ab663c96e69"
    },
    {
      "type": "html",
      "text": " None: [[Python Language]] uses \"None\" in much the same way that [[Smalltalk Language]] uses [[The Nil Object]]",
      "id": "465b7993c83f57c0dbac51ed15f0d5d5"
    },
    {
      "type": "html",
      "text": " Void:\tIn the [[Eiffel Language]], object references are initialized to Void. Void is a constant reference to a singleton object of a class that is derived from <i>all</i> other classes in the system (the [[Bottom Type]] in type theory). Therefore any reference can be assigned the value Void or tested for (in)equality to Void without breaking or complicating the type system. The Void reference does not implement any methods (Eiffel allows a derived class to undefine base class methods or hide methods from client objects).",
      "id": "fde8083c95ea3601f08a0fa831b6ea4a"
    },
    {
      "type": "html",
      "text": " [[Null Object]]: A design pattern ([[Category Pattern]]) for providing an object with \"do nothing\" functionality.",
      "id": "1c1ff239f93f863b5a9ee2668da7cfe5"
    },
    {
      "type": "html",
      "text": " [[Relational Null Value]]: The \"NULL\" value, as it's used in relational databases. The rules for using nulls appropriately are quite subtle, e.g. two different nulls are never equal. See [[Nulls And Relational Model]].",
      "id": "392c9a16e1cb8ba40f1868f68de2e7d6"
    },
    {
      "type": "html",
      "text": "[[Variant Null]]: The NULL type (value?) of [[Micro Soft]]'s [[Com Variant]] type. (Variants can hold values of several selected types, including integers, strings, and arrays.) In the case of a NULL [[Com Variant]], the vt member of the structure will be set to VT_NULL and will contain no <b>valid</b> data in the union member. Thus a [[Variant Null]] is primarily a type, not a value.",
      "id": "3633e1e4bdfddec04fc82a099ebf9b5f"
    },
    {
      "type": "html",
      "text": " Nothing: In [[Visual Basic]] - a [[Null Value]]. (Technically the variant type is 'vtObject' and the value is null. Is not the same thing as [[Variant Null]].)",
      "id": "72f568243b01434c848d7a9ca9515016"
    },
    {
      "type": "html",
      "text": " <i>Actually, I think it's closer to VB's [[Null Pointer]] equivalent. The keyword Null in VB is a [[Variant Null]].</i>",
      "id": "5c1f6801eef621ab8eae45fc06559857"
    },
    {
      "type": "html",
      "text": " [[Variant Empty]]: Used for \"clean\" newly initialized Variant variables that \"haven't yet been given a type or value.\" 'Empty' keyword in [[Visual Basic]]. '[[Var Type]](unintializedVariant) = vbEmpty'",
      "id": "f9bda1d395b8795c13fd5e5fe9078976"
    },
    {
      "type": "html",
      "text": " Missing: In [[Visual Basic]], 'Missing' is used for optional Variant parameters that have no default value. Missing is a particular value representing an error.",
      "id": "74c7f51f34bbe803d0d5684bf2704a32"
    },
    {
      "type": "html",
      "text": " [[Un Def]]:In [[Perl Language]], \"for functions that can be used in either a scalar or list context, nonabortive failure is generally indicated in a scalar context by returning the undefined value, and in a list context by returning the null list\", according to the <i>perlfunc</i> documentation. The undefine function - undef() - undefines a scalar variable, an array element or an entire array. ",
      "id": "c931f6927089a8ac28a3821ac34eb95d"
    },
    {
      "type": "html",
      "text": " Nothing: In [[Haskell Language]] the other possible value of the 'Maybe' datatype. If you type something as 'Maybe String' it can contain either 'Just textValue' or 'Nothing' where Just and Nothing are type discriminants to be used in typecase expressions (or pattern-matching). There's an equivalent type in [[Ocaml Language]], called option, instead of Maybe, and the cases are called None and Some instead of Nothing and Just. You can have several levels of 'maybeness' without losing type information, that is if you have a '[[Hash Table]] Int (Maybe String)' (a hash-table with Int keys and nullable String values) the lookup function has a correct type signature (via type inference): 'lookup :: [[Hash Table]] keyType valueType -> Maybe valueType', in this case the result is 'Maybe (Maybe String)'.",
      "id": "c298f3df9cd9fa927f4790adc3621559"
    },
    {
      "type": "html",
      "text": " [[Statistics Missing]]: In statistical programs such as Splus/R and SPSS there is a 'missing' value for each type of data, representing data that is unknown. (almost) Any operation applied to this value returns 'missing'. This has the effect that you need not take missings into account when transforming the data.",
      "id": "6ebfdcb937c7720dd6074e2a3391bb35"
    },
    {
      "type": "html",
      "text": " [[Failures In Icon]]: When an operation in Icon \"fails\" (but in an expected way, such as looking up an element in an array and finding it's not there) it returns a \"condition\". These can be used to cause backtracking (the <i>feature d'être</i> of [[Icon Language]]); but they are returned in contexts where Null might be used instead. Note that failures are different from exceptions.",
      "id": "937230411bddb61c107e6a7bbdad1529"
    },
    {
      "type": "html",
      "text": "---- \nA few other things that act like NULL in some contexts.",
      "id": "9235bcbb0042e1a51f745a22023eab6a"
    },
    {
      "type": "html",
      "text": " end():",
      "id": "a391bf8baf255b5563df7cc6669553ce"
    },
    {
      "type": "html",
      "text": " Not really NULL, but similar. [[Cee Plus Plus]] [[Standard Template Library]] containers all implement a method called end() which returns an [[External Iterator]] which points to one past the endof the container. (For vector<T>, this might actually be a pointer off the end of an array; for other containers it might be something else). Each container (and each instance of a container) has its own unique \"end\" iterator; but all of them have behavior similar to NULL. Such an iterator is not dereferenceable; trying to apply unary *, -> or [] usually (hopefully) throws an exception. One difference between end() iterators and NULL is that some pointer arithmetic on end() is meaningful; end()-- is a valid iterator (for bidirectional and random-access containers at least).",
      "id": "c550826d677a75de2b1c42af8323d9d3"
    },
    {
      "type": "html",
      "text": " <i>Uhh... I'm fairly certain that no iterator operation is allowed to throw - EVER. Could you imagine trying to make something exception-safe if you couldn't even count on being able to move around iterators? Also, that checking would impose overhead, which is unacceptable. In any case, proper use of STL algorithms will keep you from illegitimately using a past-the-end iterator, in the same way that [] is safe on built-in arrays if your for loop through the indexes is done right. (Note that none of what I just said applied to a debugging checked-STL, which everyone should at least be using if NDEBUG is undefined.)</i>",
      "id": "2fdac086570cc5a04376aec469f24302"
    },
    {
      "type": "html",
      "text": " [Dereferencing an end iterator has <i>undefined</i> behavior, which means that it certainly can throw an exception, or perhaps cause the Yosemite supervolcano to erupt. End iterators may be somewhat like NULL in that similar sorts of operations are defined or undefined on them; however, they're much more like past-the-end pointers when you consider the role some of them can play in arithmetic expressions.]",
      "id": "b543d7988785b7e1ae2af5846966dd69"
    },
    {
      "type": "html",
      "text": " EOF:",
      "id": "90fdb4bda66438a3dbcaddf0501595af"
    },
    {
      "type": "html",
      "text": " End-of-file macro in C/C++. Usually an integer value guaranteed not to be a valid value for a char type (since char is signed in some C/C++ compilers). If passed to a function expecting a char argument (which is really an int in C, but not C++, due to integer promotion rules), might have strange and wonderful effects.",
      "id": "49753a7b33db917f34380c2cf3628a17"
    },
    {
      "type": "html",
      "text": " nil:",
      "id": "8584888721778145d12e18797d90c1a0"
    },
    {
      "type": "html",
      "text": " Represents of lack of positive or negative value in a numeric field.",
      "id": "8c45ee2f7c11ec7a828a72b4790cbb1e"
    },
    {
      "type": "html",
      "text": " Self Reference",
      "id": "117d6d7ee2b331c53964cca3b21d4c5d"
    },
    {
      "type": "html",
      "text": " It is an old trick to use a self-reference (this == this.next) to terminate lists instead of a NULL pointer. <i>It may be an old trick, but I find it rather dubious. Not only it risks an infinite loop rather than [[Fail Fast]] on a badly written recursion or loop condition, but it also destroys the uniformity of representation: if you use this trick the empty list is a special case.</i> [More precisely, one <b>wants</b> the empty list (if allowed) to be a special case, but in a sensible, elegant way. It's ugly to use a trick which invites a coding error to show up as a non-ending loop rather than immediate failure.]",
      "id": "86b698e9ba7f3406e8fc6c659a77130c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "\nEDS had a \"OWL,\" a research language related to the [[Smalltalk Language]].\nIt supported several NULL-related concepts:",
      "id": "deaed9a8e8919e5ed0ec7fda6945210f"
    },
    {
      "type": "html",
      "text": " Similar to [[Smalltalk Language]] \"nil\". Normally used to represent relational database NULL values.",
      "id": "2723998806e5c5b275afeb8f45fc97cf"
    },
    {
      "type": "html",
      "text": " [[Not Set]]: Initial value for variables that had not been initialized. Often used to trigger lazy evaluation methods to go find an appropriate value.",
      "id": "6b82347ee7413b98f4093b1ebc240462"
    },
    {
      "type": "html",
      "text": " Unknown:\tAfter due consideration, the system has determined that it cannot find a value. Typically, after prompting the user, and finding that they don't know, this value would propagate to all dependent values.",
      "id": "cf28b8ae1a47989709f450321ce3abdf"
    },
    {
      "type": "html",
      "text": "<i>(I think there were two or three others too, but I no longer have access to the documentation.)</i>",
      "id": "2db52a9a0affb99fae4893967cddda40"
    },
    {
      "type": "html",
      "text": "\nI often found relational database [[Three Valued Logic]] to be annoying. This system's 5-value \"boolean\" logic could be really confusing... Like \"true and unknown ==> unknown\", \"true or unknown ==> true\". -- [[Jeff Grigg]]",
      "id": "e57df0a3ff2f7a0ee7ef07953eca1c56"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "\nYes. The problem of trying to add semantic to null is that the list goes on forever. [[Chris Date]] (from the database community) wrote a paper a few years ago that showed a huge number of possible meanings for null in a given context (e.g. not applicable, not known, not declared, and so on). If I remember, the essence of the article was that trying to enumerate different forms of null was basically impossible, since somebody will always come up with a new meaning. The way we went at AT&T (where I was working at the time) was to use different [[Null Object]] classes, each with different meanings. When an application needed a new meaning, we added a new [[Null Object]] class. So, there were no fixed semantics. -- [[Anthony Lauder]]",
      "id": "fc208619051c1a40ae9c2f05bcf598fd"
    },
    {
      "type": "html",
      "text": "[argument about different treatment of nil in Lisp and Scheme moved to [[Is Scheme Lisp]]]",
      "id": "0bf2d7d917274b44e179a7c3844d6288"
    },
    {
      "type": "html",
      "text": "\nWill it not always be the case that a separate return value is required to indicate \"not found\" in a hash lookup? [[Perl Language]] has \"exists\" as well as \"defined\". The instant one tries to allow storage of a value meaning \"does not exist\" (as opposed to merely \"undefined\") in the hash, you go back to needing another return value to distinguish the cases.",
      "id": "14a918eba710fc5a1fda80593c674e3a"
    },
    {
      "type": "html",
      "text": "\nIt is just the problem of [[Quoting Meta Characters]] all over again. -- [[Matthew Astley]]",
      "id": "22f2edc83638d10ca0ce5c4c18e5f825"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "<b>Null String and Null String Pointer a problem</b>",
      "id": "90dfe95db412a5cf1f2be6b4b0969624"
    },
    {
      "type": "html",
      "text": "\nOne of the problems with C/C++ type languages is that a Null String and a Null String pointer are handled inconsistently in libraries. Most take either as meaning \"no value\", but some require a [[Null String]] and fall over if passed a Null pointer or reference.",
      "id": "b353d77a3cb1b2406bff2f74d02c7df8"
    },
    {
      "type": "html",
      "text": "\nWith the addition of Unicode or STL strings this becomes even more confusing, where there are now three possible Null values:",
      "id": "17701971c8297841939aee48d542db36"
    },
    {
      "type": "html",
      "text": " A null string pointer or reference.",
      "id": "98c8b9d2ebf914a991836141ec5461c9"
    },
    {
      "type": "html",
      "text": " A zero length string",
      "id": "569b74c818f6ca1f7cb754f995acdb39"
    },
    {
      "type": "html",
      "text": " A string with a single NULL character.",
      "id": "447b850628a8ff9d09d7d4daffa97635"
    },
    {
      "type": "html",
      "text": "\nWhen calling system functions it is often necessary to convert the string to <i>old fashioned</i> [[Char Star]] strings, and the zero length string needs to be converted to one of the others, again inconsistently.",
      "id": "6ea4b68d9edb687849ffe4fe5ea737a5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "According to a recent interview with Joshua Bloch, Java 1.5's automatic unboxing will convert null to 0. Oh dear. There is some hope, though. It's not settled, and it could change to throwing an exception.",
      "id": "e5e1405299f73fd0b21274462f20617a"
    },
    {
      "type": "html",
      "text": "<i>After some discussion they decided to throw an exception instead. There's a mention about it at [[Lambda The Ultimate]].</i>",
      "id": "f1fd4216a51218a88d77cc871b039b32"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "In type theory, NIL/NULL/whathaveyou is usually handled in one of several ways:",
      "id": "59d40f08ffa45b56d2af2b5182ccd751"
    },
    {
      "type": "html",
      "text": " As a special unit type; thus a pointer or reference to T which can be NULL is really UNION (T, UNIT(NULL)). A dereference of such a pointer or reference involves (implicitly) checking which case of the union is active, and performing the cast if not NULL, doing something else (throwing an exception, one hopes) if it is NULL. Java references kinda act this way, even though Java doesn't have unions (typesafe or otherwise). Use of a distinguished address (like zero) which points to something that will cause a page fault if peeked/poked is a convenient optimization of this mechanism.",
      "id": "9fcae12c23f2690c19eb713a70edb183"
    },
    {
      "type": "html",
      "text": "\nor",
      "id": "988f1c1ecd8ddb3c44051ff220dee0cd"
    },
    {
      "type": "html",
      "text": " As the [[Bottom Type]] (an empty type which is the subtype of all other types). This is essentially what Eiffel does with its Void type.",
      "id": "a70269580cf1519cdf077260596e01f3"
    },
    {
      "type": "html",
      "text": "\nMyself, I prefer the former. For one, it allows multiple NULLs with different meanings; though I'm not aware of any languages which define multiple NULLs like that. For another, many [[Functional Programming Language]]s use the [[Bottom Type]] to indicate a raised exception (which I think is also braindead) or to indicate divergence (which kindasorta makes sense - \"returning\" a non-existent type to indicate a condition which, according to the [[Halting Problem]] Theorem, we cannot detect...) For a third reason, it allows us to define two types of references; those which can be NULL and those which can't. (C++ has this capability; though it's easily bypassed... a functional Java variant called Nice ([[Nice Language]]) also provides references which are guaranteed to not be NULL). If we use [[Bottom Type]] for NULL, then **ALL** objects in the system might possibly be NULL (including things like ints and bools where it doesn't make sense in most cases).",
      "id": "f94946f72e31880c1430c6c0fde06281"
    },
    {
      "type": "html",
      "text": "-- engineer_scotty ([[Scott Johnson]])",
      "id": "52b6ff6b3cc3deb6a8ad9df2284e748f"
    },
    {
      "type": "html",
      "text": "\nAlso see [[Null Considered Harmful]].",
      "id": "baa1a19a3c40df5eb307ce6d86f46d39"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "<i>What is NULL? Baby, don't hurt me...</i>",
      "id": "e3e81e125f0e78b032df505efbfa939d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "I've found this helpful. Given the other discussions on site about Null in databases, I thought I'd contribute several sections of definitions from ISO's evolving set of Geographic Information standards.",
      "id": "241d5836cc99697cd7c6fe178ef89101"
    },
    {
      "type": "html",
      "text": "<i>ISO/PDTS 19103 Conceptual Schema Language</i> (also in 19107 Spatial Schema):",
      "id": "34bae4603f1c157caf628bda7e3411a4"
    },
    {
      "type": "html",
      "text": "<i>NULL means that the value asked for is undefined. This Technical Specification assumes that all NULL values are equivalent. If a NULL is returned when an object has been requested, this means that no object matching the criteria specified exists. EMPTY refers to objects that can be interpreted as being sets that contain no elements. Unlike programming systems that provide strongly typed aggregates, this Technical Specification uses the mathematical tautology that there is one and only one empty set. Any object representing the empty set is equivalent to any other set that does the same. Other than being empty, such sets lack any inherent information, and so a NULL value is assumed equivalent to an EMPTY set in the appropriate context.</i>",
      "id": "83117280dca3197de1edda24b65b505f"
    },
    {
      "type": "html",
      "text": "\nBut <i>ISO/CD 19126 Geographic Markup Language</i> (an XML encoding) introduces a \"convenience type\" <i>gml::[[Null Type]]</i> which is a union of several enumerated values: inapplicable, missing, template (i.e. value will be available later), unknown, withheld and <i>anyURI</i> (for which the example is the lovely but non-existent [http://my.big.org/explanations/theDogAteIt my.big.org]. This allows much more clarity of meaning than merely allowing 'minOccurs=0'. We're investigating it for a large database model we're developing.",
      "id": "1fd5e36ad3d4ee2d464f5e5d8c6a7f8a"
    },
    {
      "type": "html",
      "text": "([[Peter Parslow]])",
      "id": "e4e908bf1e00f619fd5818b105e8332c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "The problem with NULL is that it is context-sensitive and each context can change the definition. To makes NULL consistent and remove context-sensitivity, you would need several types similar to NULL (uninitialized vars, pointer to nothing, empty object, empty var, etc). In Math it is even more of a problem since the possible meanings of NULL change the actual result. Does A+B+Null = A+B, or undefined, or null, or does it throw an error? This is confounding for developers and language designers, almost a [[Holy War]] (then again everything in language design is).",
      "id": "6afa3c2b60dc348d605a6bbef598d580"
    },
    {
      "type": "html",
      "text": " Does A + B + null = A + B? If a counter has the value of null, then the counter has not yet had anything placed in it, so its value is 0. So in that case, I would answer \"yes\". I can think of many situations where the assumption of 0 for null would be appropriate - for instance, for a stock quantity from a database. -- [[Peter Lynch]]",
      "id": "71e3a997f597669f3531330f081ef429"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "Donald Rumsfeld has a profound understanding of null -",
      "id": "cbdceb60a9eaf6a60c722d2660b3473d"
    },
    {
      "type": "html",
      "text": "\"There are known knowns. These are things we know that we know. There are known unknowns. That is to say, there are things that we know we don't know. But there are also unknown unknowns. There are things we don't know we don't know.\"",
      "id": "0008c00f8cda7d2b23f45875502886fc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "All of this, and nobody's mentioned NaN (in FP math)? (As of January 2007)",
      "id": "e3079f4dd2120e790a64aeb2eb276bd9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "Nice, schmice. You can have non-nullable references in stock Java now, with generics:",
      "id": "34f7922e9e7d973bb7d3f34a46c9ff3b"
    },
    {
      "type": "html",
      "text": "\npublic final class Ref<T> {",
      "id": "db2b708a914fcfe40b6f925cd89c4ff4"
    },
    {
      "type": "code",
      "text": "  T obj;\n  public Ref (T obj) {\n  set(obj);\n  }\n  public void set (T obj) {\n  if (obj == null) throw new NullPointerException();\n  this.obj = obj;\n  }\n  public T get () {\n  return obj;\n  }",
      "id": "f958fa404e93518af283b5c1a971d70b"
    },
    {
      "type": "html",
      "text": "}",
      "id": "9267d1c90da9533e6b62f1ad605a6547"
    },
    {
      "type": "html",
      "text": "\nFor an immutable version, just make the set method private.",
      "id": "8282ab378dda76e0e5246567413fd5d7"
    },
    {
      "type": "html",
      "text": "\nThe downside is that the way Java generics work, the Ref<T> may be more cumbersome to use than the T. For example, if Bar derives from Foo, you can assign a Bar to a reference of type Foo, but not a Ref<Bar> to a Ref<Foo>. So you need those variables to be of type Ref<? extends Foo>, which is [[Syntactic Salt]] at its finest. (This assignability rule is for a simple reason: otherwise you could assign a Ref<Bar> reference to a Ref<Foo> reference, use a Foo that is not a Bar in a set method invoked on the latter, and then pull a non-Bar out via the get method on the Bar reference. This does mean that you can't use the set method on a Ref<? extends Foo> though, although you can assign a new Ref object with a new referent.",
      "id": "19f04515c90c35923ab360cceca20409"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "[[What Is Null]] you ask?",
      "id": "7c956583503510b2ddf5e68baf65ef85"
    },
    {
      "type": "html",
      "text": " Null is what you thought your freed pointer was reset to.",
      "id": "00f30e7c31072e784f738855ba426a71"
    },
    {
      "type": "html",
      "text": " Null is what the function that -should- always return a valid pointer just gave you.",
      "id": "47f37639b68ea44089c8c78203d97339"
    },
    {
      "type": "html",
      "text": " Null is how much bureaucracy a system needs on top of \"nothing\".",
      "id": "9261e4f12f028f5ac9e3eb55406bcb53"
    },
    {
      "type": "html",
      "text": " Null is the alpha and the omega, everything begins as null, is initialized, then reset and reused as Null.",
      "id": "80251fc9dea93de5e7ed8fe9aee0e167"
    },
    {
      "type": "html",
      "text": " Null is the absence of a number. Some say Null is the absence of a zero.",
      "id": "d904b499024a7b760b47aca3a21cb986"
    },
    {
      "type": "html",
      "text": " The Null that can be named is not the true Null.",
      "id": "be341e05ae8ff5ecad6a421dca010eff"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": " Null is the value of x before and after it had a value.",
      "id": "9a21a02925d2d60dd81b73a0d2e52353"
    },
    {
      "type": "html",
      "text": " Because Null is the value of all things we do not yet know, Null's domain may be the largest domain.",
      "id": "605b658271b24615a0695392a4a9a957"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "\nIn some languages ([[Oz Language]] being an example) one may introduce a single-assignment variable without actually assigning it. You may then utilize this unassigned variable inside a data structure. One may <i>unify</i> two unassigned variables - i.e. asserting they are the same, such that if one is assigned, then so will be the other. Similarly, you may assign such a variable to a structure that contains yet more unassigned variables. All this is a weakly expressive form of [[Constraint Programming]]. More expressive [[Constraint Programming]] would allow you to restrict variables as well as assign them, i.e. to say that X > Y without knowing X or Y.  In a secure language, the authority to assign a variable or manipulate constraints may be separate from the ability to view the variable. [[Oz Language]] added security via 'X=!!Y', which says that X can view Y but cannot assign Y.",
      "id": "159aa777602e925edf9771ee77b47d2f"
    },
    {
      "type": "html",
      "text": "\nI've long believed that Nulls - at least in the context of data ([[Sql Null]]) - should really be identified by these sort of 'unassigned free variables'. This would allow us to make very interesting observations, the way we do with algebraic and geometric expressions in mathematics. It would be possible, for example, to perform proper joins between tables containing these free variables. If we were using a [[Table Browser]], one might distribute authority to assign these 'variables', such that one could meaningfully assign to a field that was previously unknown... and update the proper record.",
      "id": "043460d8da9eb50cb54755585c689c90"
    },
    {
      "type": "html",
      "text": "\nOf course, it would still lead to interesting issues, such as: the sum of 10+X+12 can only be reduced to 22+X, and a join between two tables limited by X>Y may return some interesting 'contingent' records.",
      "id": "fc546cb205ea649596faf818383a91f8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "See Also: [[Cant Hide From Nulls]]",
      "id": "c67c56934c2368f57e58c4fe9a09dd92"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "5ceedd6930b80f63b5672fc3033067fc"
    },
    {
      "type": "html",
      "text": "[[Category Null]] [[Category Definition]]",
      "id": "d1e4770ccfa9cd8fc19228720623d4c0"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?WhatIsNull c2.com]",
      "id": "3445d2f4d651a4a36a447a8ce243ef9f"
    }
  ],
  "journal": [
    {
      "date": 1281773349000,
      "id": "c6b643ed30f7a844bd91292b0e184f12",
      "type": "create",
      "item": {
        "title": "What Is Null",
        "story": [
          {
            "type": "html",
            "text": "<b><i>What is this thing called \"NULL\"?!?</b></i>",
            "id": "7443f5600bf3fe3f9d195b7de497836a"
          },
          {
            "type": "html",
            "text": "\nNull or Nil Characteristics:",
            "id": "f5dcb7be7f19fcd9179661cabd199242"
          },
          {
            "type": "html",
            "text": " Etymo: Latin nullus \"not any, none,\" from ne- \"not, no\" (see un-) + illus \"any,\" dim. of unus \"one.\"",
            "id": "9832d6ec26a1b1eb4a9810166ae63192"
          },
          {
            "type": "html",
            "text": " Semantically: Very difficult. In most cases, NULL or nil means \"no value\" or \"not applicable\". Sometimes (like, when passed to a routine as an argument) it means \"no explicit value\". In SQL, it often means \"not known\". Sometimes it might mean \"whatever\". Given this overloading of meanings, it is a little problematic - you sometimes encounter problems related to confusion about the meaning of NULL. Even so, it is a very useful concept - but heavy use of NULLs is often a sign that you should be using lists of values or tagged unions instead.",
            "id": "17814d0229d2ddaff461e9c5e1a4596f"
          },
          {
            "type": "html",
            "text": " Semantically: Very simple. It is the same as the Japanese character \"mu\" [Chinese \"wu\"; see [[Mu Answer]]]. It means \"no thing\". In logic it means \"neither yes nor no\" or \"dumb question\". <i>You call that simple? The character has at least four different readings in different languages. In addition, it has a native reading in [[Japanese Language]] of \"nai\" which means \"does not exist\" or \"there is no\". Depending on the context, this means at least six different things. Hell, that makes the computer nil concept seem pretty well-defined...</i> Yes, I call \"mu\" simple.",
            "id": "da2c32d0282086229f4972672a603fdd"
          },
          {
            "type": "html",
            "text": " [[Nil In Lisp]]: The [[Lisp Language]] defined <i>NIL</i> (and perhaps invented) the use of \"NIL\" as a special object that is both a Symbol and a List - it is the only such object. NIL is the same as (). () is the empty list. NIL is a constant that has NIL as its value. Lists in Lisp are built from [[Cons Cell]]s. Thus, if there is some list (1 2 3), the \"FIRST\" function answers the first element, which can be either a Atom or a list (in this case the number 1). The \"REST\" function answers \"the rest of the list\" (in this case, \"(2 3)\"). Every list has an implied \"NIL\" at the end, so that the \"REST\" of the list \"(3)\" is NIL. This use of NIL to terminate a list is reminiscent of the use of \"NULL\" to terminate a char array in [[Cee Language]] (which came later). It is also reminiscent of the use of [[The Nil Object]] in [[Smalltalk Language]] (not surprising, given [[Dan Bobrow]]'s influence on the [[Smalltalk Language]] team). The type of NIL is NULL. NULL is also a predicate that returns T when its argument is NIL. NIL is also (NOT T). It is also the only object that is (NOT T). So NIL serves as the value for logical false. NIL is also the empty datatype.",
            "id": "d45dce410fecfe8021535f41c662627a"
          },
          {
            "type": "html",
            "text": " [[Nil In Scheme]]: [[Scheme Language]] doesn't have a value named nil, but nil as generally taken to be the empty list (as in other Lisps). However, unlike [[Common Lisp]], the booleans in Scheme are #t and #f (instead of t and nil). The empty list is written as '(). Scheme advocates claim that this clarifies case expressions.",
            "id": "1f843c09631a3715234ba89409dfcd0d"
          },
          {
            "type": "html",
            "text": " <i>This is a strange position to take, given that the Lisp community has happily, and without any problems whatsoever, been punning on the multiple meanings of NIL for forty years. Perhaps the real problem lies elsewhere? -- [[Alain Picard]]</i>",
            "id": "b3cfc6f2a6f807e29db4fa62ecfbb552"
          },
          {
            "type": "html",
            "text": " It bugged enough Lispers that [[Scheme Language]] finally completely split the boolean concept and list concept. [rest of argument about different treatment of nil in [[Common Lisp]] and Scheme moved to [[Is Scheme Lisp]]]",
            "id": "e5828d798e2fa07934d5a913207a6043"
          },
          {
            "type": "html",
            "text": " [[Null Pointer]]: Pointers in some languages, like C, C++, and Pascal, can be given the value \"NULL,\" which indicates that this pointer does not currently point to a valid location in memory. Dereferencing a [[Null Pointer]] causes [[Undefined Behavior]]. [Often [[Null Pointer]] is declared as 0 (cast to the appropriate type), which causes some machines to generate a hardware interrupt when it is dereferenced. Usually the runtime (when configured to do so) catches this and throws an exception, often through a software interrupt. In older C implementations the results are undetermined - in other words, it blows up in your face.] NULL is commonly used to terminate lists and other complex structures, or to indicate that the given object is absent or unknown.",
            "id": "7e4f7fab9d63d6c46bac14c9e598a6d4"
          },
          {
            "type": "html",
            "text": " [[Nul Character]]: The NUL character, with code point 0 in most [[Coded Character Set]]s (ASCII, ISO-Latin-x, Unicode, etc.). This is <i>not</i> a pointer.",
            "id": "45da8d8bb8e31d7e334ab56152aee96b"
          },
          {
            "type": "html",
            "text": " [[Nul Code Unit]]: In some [[Character Encoding Format]]s, in general more than one [[Code Unit]] is used to represent a character. Nevertheless, the zero [[Code Unit]] is almost always reserved for terminating a string, and cannot occur in any character other than [[Nul Character]] (this also applies to [[Character Encoding Format]]s in which [[Code Unit]]s are more than 8 bits). It can therefore be used to terminate string representations (e.g. [[Char Star]] strings in C).",
            "id": "3f085d61d0a39d7028bd0aa73fa7a12f"
          },
          {
            "type": "html",
            "text": " [[Null String]]: The string containing no characters; [[Empty String]]. (This is typical usage for C, where some people call an empty \"C style\" string (\"\") a \"[[Null String]]\". Physically, it is a pointer to a character array that starts with a [[Nul Character]], '\\0'.)",
            "id": "bc43ffaf7310bfd813e6c3ebd0e91a04"
          },
          {
            "type": "html",
            "text": "<i>Is this standard terminology? In my C days, I thought of {char *s = NULL;} as a [[Null String]], and {char *s = \"\";} as an [[Empty String]].</i>\nYes, this is pretty standard.",
            "id": "d1a5106ee30046d42b268d925ae6e1ca"
          },
          {
            "type": "html",
            "text": " [[The Nil Object]]: The [[Smalltalk Language]] uses \"nil\" - a reference to a unique object ([[Singleton Pattern]]) of the class [[Undefined Object]]; used to represent the absence of an object.",
            "id": "cac76bf0ae514e8f95769ab663c96e69"
          },
          {
            "type": "html",
            "text": " None: [[Python Language]] uses \"None\" in much the same way that [[Smalltalk Language]] uses [[The Nil Object]]",
            "id": "465b7993c83f57c0dbac51ed15f0d5d5"
          },
          {
            "type": "html",
            "text": " Void:\tIn the [[Eiffel Language]], object references are initialized to Void. Void is a constant reference to a singleton object of a class that is derived from <i>all</i> other classes in the system (the [[Bottom Type]] in type theory). Therefore any reference can be assigned the value Void or tested for (in)equality to Void without breaking or complicating the type system. The Void reference does not implement any methods (Eiffel allows a derived class to undefine base class methods or hide methods from client objects).",
            "id": "fde8083c95ea3601f08a0fa831b6ea4a"
          },
          {
            "type": "html",
            "text": " [[Null Object]]: A design pattern ([[Category Pattern]]) for providing an object with \"do nothing\" functionality.",
            "id": "1c1ff239f93f863b5a9ee2668da7cfe5"
          },
          {
            "type": "html",
            "text": " [[Relational Null Value]]: The \"NULL\" value, as it's used in relational databases. The rules for using nulls appropriately are quite subtle, e.g. two different nulls are never equal. See [[Nulls And Relational Model]].",
            "id": "392c9a16e1cb8ba40f1868f68de2e7d6"
          },
          {
            "type": "html",
            "text": "[[Variant Null]]: The NULL type (value?) of [[Micro Soft]]'s [[Com Variant]] type. (Variants can hold values of several selected types, including integers, strings, and arrays.) In the case of a NULL [[Com Variant]], the vt member of the structure will be set to VT_NULL and will contain no <b>valid</b> data in the union member. Thus a [[Variant Null]] is primarily a type, not a value.",
            "id": "3633e1e4bdfddec04fc82a099ebf9b5f"
          },
          {
            "type": "html",
            "text": " Nothing: In [[Visual Basic]] - a [[Null Value]]. (Technically the variant type is 'vtObject' and the value is null. Is not the same thing as [[Variant Null]].)",
            "id": "72f568243b01434c848d7a9ca9515016"
          },
          {
            "type": "html",
            "text": " <i>Actually, I think it's closer to VB's [[Null Pointer]] equivalent. The keyword Null in VB is a [[Variant Null]].</i>",
            "id": "5c1f6801eef621ab8eae45fc06559857"
          },
          {
            "type": "html",
            "text": " [[Variant Empty]]: Used for \"clean\" newly initialized Variant variables that \"haven't yet been given a type or value.\" 'Empty' keyword in [[Visual Basic]]. '[[Var Type]](unintializedVariant) = vbEmpty'",
            "id": "f9bda1d395b8795c13fd5e5fe9078976"
          },
          {
            "type": "html",
            "text": " Missing: In [[Visual Basic]], 'Missing' is used for optional Variant parameters that have no default value. Missing is a particular value representing an error.",
            "id": "74c7f51f34bbe803d0d5684bf2704a32"
          },
          {
            "type": "html",
            "text": " [[Un Def]]:In [[Perl Language]], \"for functions that can be used in either a scalar or list context, nonabortive failure is generally indicated in a scalar context by returning the undefined value, and in a list context by returning the null list\", according to the <i>perlfunc</i> documentation. The undefine function - undef() - undefines a scalar variable, an array element or an entire array. ",
            "id": "c931f6927089a8ac28a3821ac34eb95d"
          },
          {
            "type": "html",
            "text": " Nothing: In [[Haskell Language]] the other possible value of the 'Maybe' datatype. If you type something as 'Maybe String' it can contain either 'Just textValue' or 'Nothing' where Just and Nothing are type discriminants to be used in typecase expressions (or pattern-matching). There's an equivalent type in [[Ocaml Language]], called option, instead of Maybe, and the cases are called None and Some instead of Nothing and Just. You can have several levels of 'maybeness' without losing type information, that is if you have a '[[Hash Table]] Int (Maybe String)' (a hash-table with Int keys and nullable String values) the lookup function has a correct type signature (via type inference): 'lookup :: [[Hash Table]] keyType valueType -> Maybe valueType', in this case the result is 'Maybe (Maybe String)'.",
            "id": "c298f3df9cd9fa927f4790adc3621559"
          },
          {
            "type": "html",
            "text": " [[Statistics Missing]]: In statistical programs such as Splus/R and SPSS there is a 'missing' value for each type of data, representing data that is unknown. (almost) Any operation applied to this value returns 'missing'. This has the effect that you need not take missings into account when transforming the data.",
            "id": "6ebfdcb937c7720dd6074e2a3391bb35"
          },
          {
            "type": "html",
            "text": " [[Failures In Icon]]: When an operation in Icon \"fails\" (but in an expected way, such as looking up an element in an array and finding it's not there) it returns a \"condition\". These can be used to cause backtracking (the <i>feature d'être</i> of [[Icon Language]]); but they are returned in contexts where Null might be used instead. Note that failures are different from exceptions.",
            "id": "937230411bddb61c107e6a7bbdad1529"
          },
          {
            "type": "html",
            "text": "---- \nA few other things that act like NULL in some contexts.",
            "id": "9235bcbb0042e1a51f745a22023eab6a"
          },
          {
            "type": "html",
            "text": " end():",
            "id": "a391bf8baf255b5563df7cc6669553ce"
          },
          {
            "type": "html",
            "text": " Not really NULL, but similar. [[Cee Plus Plus]] [[Standard Template Library]] containers all implement a method called end() which returns an [[External Iterator]] which points to one past the endof the container. (For vector<T>, this might actually be a pointer off the end of an array; for other containers it might be something else). Each container (and each instance of a container) has its own unique \"end\" iterator; but all of them have behavior similar to NULL. Such an iterator is not dereferenceable; trying to apply unary *, -> or [] usually (hopefully) throws an exception. One difference between end() iterators and NULL is that some pointer arithmetic on end() is meaningful; end()-- is a valid iterator (for bidirectional and random-access containers at least).",
            "id": "c550826d677a75de2b1c42af8323d9d3"
          },
          {
            "type": "html",
            "text": " <i>Uhh... I'm fairly certain that no iterator operation is allowed to throw - EVER. Could you imagine trying to make something exception-safe if you couldn't even count on being able to move around iterators? Also, that checking would impose overhead, which is unacceptable. In any case, proper use of STL algorithms will keep you from illegitimately using a past-the-end iterator, in the same way that [] is safe on built-in arrays if your for loop through the indexes is done right. (Note that none of what I just said applied to a debugging checked-STL, which everyone should at least be using if NDEBUG is undefined.)</i>",
            "id": "2fdac086570cc5a04376aec469f24302"
          },
          {
            "type": "html",
            "text": " [Dereferencing an end iterator has <i>undefined</i> behavior, which means that it certainly can throw an exception, or perhaps cause the Yosemite supervolcano to erupt. End iterators may be somewhat like NULL in that similar sorts of operations are defined or undefined on them; however, they're much more like past-the-end pointers when you consider the role some of them can play in arithmetic expressions.]",
            "id": "b543d7988785b7e1ae2af5846966dd69"
          },
          {
            "type": "html",
            "text": " EOF:",
            "id": "90fdb4bda66438a3dbcaddf0501595af"
          },
          {
            "type": "html",
            "text": " End-of-file macro in C/C++. Usually an integer value guaranteed not to be a valid value for a char type (since char is signed in some C/C++ compilers). If passed to a function expecting a char argument (which is really an int in C, but not C++, due to integer promotion rules), might have strange and wonderful effects.",
            "id": "49753a7b33db917f34380c2cf3628a17"
          },
          {
            "type": "html",
            "text": " nil:",
            "id": "8584888721778145d12e18797d90c1a0"
          },
          {
            "type": "html",
            "text": " Represents of lack of positive or negative value in a numeric field.",
            "id": "8c45ee2f7c11ec7a828a72b4790cbb1e"
          },
          {
            "type": "html",
            "text": " Self Reference",
            "id": "117d6d7ee2b331c53964cca3b21d4c5d"
          },
          {
            "type": "html",
            "text": " It is an old trick to use a self-reference (this == this.next) to terminate lists instead of a NULL pointer. <i>It may be an old trick, but I find it rather dubious. Not only it risks an infinite loop rather than [[Fail Fast]] on a badly written recursion or loop condition, but it also destroys the uniformity of representation: if you use this trick the empty list is a special case.</i> [More precisely, one <b>wants</b> the empty list (if allowed) to be a special case, but in a sensible, elegant way. It's ugly to use a trick which invites a coding error to show up as a non-ending loop rather than immediate failure.]",
            "id": "86b698e9ba7f3406e8fc6c659a77130c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "\nEDS had a \"OWL,\" a research language related to the [[Smalltalk Language]].\nIt supported several NULL-related concepts:",
            "id": "deaed9a8e8919e5ed0ec7fda6945210f"
          },
          {
            "type": "html",
            "text": " Similar to [[Smalltalk Language]] \"nil\". Normally used to represent relational database NULL values.",
            "id": "2723998806e5c5b275afeb8f45fc97cf"
          },
          {
            "type": "html",
            "text": " [[Not Set]]: Initial value for variables that had not been initialized. Often used to trigger lazy evaluation methods to go find an appropriate value.",
            "id": "6b82347ee7413b98f4093b1ebc240462"
          },
          {
            "type": "html",
            "text": " Unknown:\tAfter due consideration, the system has determined that it cannot find a value. Typically, after prompting the user, and finding that they don't know, this value would propagate to all dependent values.",
            "id": "cf28b8ae1a47989709f450321ce3abdf"
          },
          {
            "type": "html",
            "text": "<i>(I think there were two or three others too, but I no longer have access to the documentation.)</i>",
            "id": "2db52a9a0affb99fae4893967cddda40"
          },
          {
            "type": "html",
            "text": "\nI often found relational database [[Three Valued Logic]] to be annoying. This system's 5-value \"boolean\" logic could be really confusing... Like \"true and unknown ==> unknown\", \"true or unknown ==> true\". -- [[Jeff Grigg]]",
            "id": "e57df0a3ff2f7a0ee7ef07953eca1c56"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "\nYes. The problem of trying to add semantic to null is that the list goes on forever. [[Chris Date]] (from the database community) wrote a paper a few years ago that showed a huge number of possible meanings for null in a given context (e.g. not applicable, not known, not declared, and so on). If I remember, the essence of the article was that trying to enumerate different forms of null was basically impossible, since somebody will always come up with a new meaning. The way we went at AT&T (where I was working at the time) was to use different [[Null Object]] classes, each with different meanings. When an application needed a new meaning, we added a new [[Null Object]] class. So, there were no fixed semantics. -- [[Anthony Lauder]]",
            "id": "fc208619051c1a40ae9c2f05bcf598fd"
          },
          {
            "type": "html",
            "text": "[argument about different treatment of nil in Lisp and Scheme moved to [[Is Scheme Lisp]]]",
            "id": "0bf2d7d917274b44e179a7c3844d6288"
          },
          {
            "type": "html",
            "text": "\nWill it not always be the case that a separate return value is required to indicate \"not found\" in a hash lookup? [[Perl Language]] has \"exists\" as well as \"defined\". The instant one tries to allow storage of a value meaning \"does not exist\" (as opposed to merely \"undefined\") in the hash, you go back to needing another return value to distinguish the cases.",
            "id": "14a918eba710fc5a1fda80593c674e3a"
          },
          {
            "type": "html",
            "text": "\nIt is just the problem of [[Quoting Meta Characters]] all over again. -- [[Matthew Astley]]",
            "id": "22f2edc83638d10ca0ce5c4c18e5f825"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "<b>Null String and Null String Pointer a problem</b>",
            "id": "90dfe95db412a5cf1f2be6b4b0969624"
          },
          {
            "type": "html",
            "text": "\nOne of the problems with C/C++ type languages is that a Null String and a Null String pointer are handled inconsistently in libraries. Most take either as meaning \"no value\", but some require a [[Null String]] and fall over if passed a Null pointer or reference.",
            "id": "b353d77a3cb1b2406bff2f74d02c7df8"
          },
          {
            "type": "html",
            "text": "\nWith the addition of Unicode or STL strings this becomes even more confusing, where there are now three possible Null values:",
            "id": "17701971c8297841939aee48d542db36"
          },
          {
            "type": "html",
            "text": " A null string pointer or reference.",
            "id": "98c8b9d2ebf914a991836141ec5461c9"
          },
          {
            "type": "html",
            "text": " A zero length string",
            "id": "569b74c818f6ca1f7cb754f995acdb39"
          },
          {
            "type": "html",
            "text": " A string with a single NULL character.",
            "id": "447b850628a8ff9d09d7d4daffa97635"
          },
          {
            "type": "html",
            "text": "\nWhen calling system functions it is often necessary to convert the string to <i>old fashioned</i> [[Char Star]] strings, and the zero length string needs to be converted to one of the others, again inconsistently.",
            "id": "6ea4b68d9edb687849ffe4fe5ea737a5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "According to a recent interview with Joshua Bloch, Java 1.5's automatic unboxing will convert null to 0. Oh dear. There is some hope, though. It's not settled, and it could change to throwing an exception.",
            "id": "e5e1405299f73fd0b21274462f20617a"
          },
          {
            "type": "html",
            "text": "<i>After some discussion they decided to throw an exception instead. There's a mention about it at [[Lambda The Ultimate]].</i>",
            "id": "f1fd4216a51218a88d77cc871b039b32"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "In type theory, NIL/NULL/whathaveyou is usually handled in one of several ways:",
            "id": "59d40f08ffa45b56d2af2b5182ccd751"
          },
          {
            "type": "html",
            "text": " As a special unit type; thus a pointer or reference to T which can be NULL is really UNION (T, UNIT(NULL)). A dereference of such a pointer or reference involves (implicitly) checking which case of the union is active, and performing the cast if not NULL, doing something else (throwing an exception, one hopes) if it is NULL. Java references kinda act this way, even though Java doesn't have unions (typesafe or otherwise). Use of a distinguished address (like zero) which points to something that will cause a page fault if peeked/poked is a convenient optimization of this mechanism.",
            "id": "9fcae12c23f2690c19eb713a70edb183"
          },
          {
            "type": "html",
            "text": "\nor",
            "id": "988f1c1ecd8ddb3c44051ff220dee0cd"
          },
          {
            "type": "html",
            "text": " As the [[Bottom Type]] (an empty type which is the subtype of all other types). This is essentially what Eiffel does with its Void type.",
            "id": "a70269580cf1519cdf077260596e01f3"
          },
          {
            "type": "html",
            "text": "\nMyself, I prefer the former. For one, it allows multiple NULLs with different meanings; though I'm not aware of any languages which define multiple NULLs like that. For another, many [[Functional Programming Language]]s use the [[Bottom Type]] to indicate a raised exception (which I think is also braindead) or to indicate divergence (which kindasorta makes sense - \"returning\" a non-existent type to indicate a condition which, according to the [[Halting Problem]] Theorem, we cannot detect...) For a third reason, it allows us to define two types of references; those which can be NULL and those which can't. (C++ has this capability; though it's easily bypassed... a functional Java variant called Nice ([[Nice Language]]) also provides references which are guaranteed to not be NULL). If we use [[Bottom Type]] for NULL, then **ALL** objects in the system might possibly be NULL (including things like ints and bools where it doesn't make sense in most cases).",
            "id": "f94946f72e31880c1430c6c0fde06281"
          },
          {
            "type": "html",
            "text": "-- engineer_scotty ([[Scott Johnson]])",
            "id": "52b6ff6b3cc3deb6a8ad9df2284e748f"
          },
          {
            "type": "html",
            "text": "\nAlso see [[Null Considered Harmful]].",
            "id": "baa1a19a3c40df5eb307ce6d86f46d39"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "<i>What is NULL? Baby, don't hurt me...</i>",
            "id": "e3e81e125f0e78b032df505efbfa939d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "I've found this helpful. Given the other discussions on site about Null in databases, I thought I'd contribute several sections of definitions from ISO's evolving set of Geographic Information standards.",
            "id": "241d5836cc99697cd7c6fe178ef89101"
          },
          {
            "type": "html",
            "text": "<i>ISO/PDTS 19103 Conceptual Schema Language</i> (also in 19107 Spatial Schema):",
            "id": "34bae4603f1c157caf628bda7e3411a4"
          },
          {
            "type": "html",
            "text": "<i>NULL means that the value asked for is undefined. This Technical Specification assumes that all NULL values are equivalent. If a NULL is returned when an object has been requested, this means that no object matching the criteria specified exists. EMPTY refers to objects that can be interpreted as being sets that contain no elements. Unlike programming systems that provide strongly typed aggregates, this Technical Specification uses the mathematical tautology that there is one and only one empty set. Any object representing the empty set is equivalent to any other set that does the same. Other than being empty, such sets lack any inherent information, and so a NULL value is assumed equivalent to an EMPTY set in the appropriate context.</i>",
            "id": "83117280dca3197de1edda24b65b505f"
          },
          {
            "type": "html",
            "text": "\nBut <i>ISO/CD 19126 Geographic Markup Language</i> (an XML encoding) introduces a \"convenience type\" <i>gml::[[Null Type]]</i> which is a union of several enumerated values: inapplicable, missing, template (i.e. value will be available later), unknown, withheld and <i>anyURI</i> (for which the example is the lovely but non-existent [http://my.big.org/explanations/theDogAteIt my.big.org]. This allows much more clarity of meaning than merely allowing 'minOccurs=0'. We're investigating it for a large database model we're developing.",
            "id": "1fd5e36ad3d4ee2d464f5e5d8c6a7f8a"
          },
          {
            "type": "html",
            "text": "([[Peter Parslow]])",
            "id": "e4e908bf1e00f619fd5818b105e8332c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "The problem with NULL is that it is context-sensitive and each context can change the definition. To makes NULL consistent and remove context-sensitivity, you would need several types similar to NULL (uninitialized vars, pointer to nothing, empty object, empty var, etc). In Math it is even more of a problem since the possible meanings of NULL change the actual result. Does A+B+Null = A+B, or undefined, or null, or does it throw an error? This is confounding for developers and language designers, almost a [[Holy War]] (then again everything in language design is).",
            "id": "6afa3c2b60dc348d605a6bbef598d580"
          },
          {
            "type": "html",
            "text": " Does A + B + null = A + B? If a counter has the value of null, then the counter has not yet had anything placed in it, so its value is 0. So in that case, I would answer \"yes\". I can think of many situations where the assumption of 0 for null would be appropriate - for instance, for a stock quantity from a database. -- [[Peter Lynch]]",
            "id": "71e3a997f597669f3531330f081ef429"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "Donald Rumsfeld has a profound understanding of null -",
            "id": "cbdceb60a9eaf6a60c722d2660b3473d"
          },
          {
            "type": "html",
            "text": "\"There are known knowns. These are things we know that we know. There are known unknowns. That is to say, there are things that we know we don't know. But there are also unknown unknowns. There are things we don't know we don't know.\"",
            "id": "0008c00f8cda7d2b23f45875502886fc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "All of this, and nobody's mentioned NaN (in FP math)? (As of January 2007)",
            "id": "e3079f4dd2120e790a64aeb2eb276bd9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "Nice, schmice. You can have non-nullable references in stock Java now, with generics:",
            "id": "34f7922e9e7d973bb7d3f34a46c9ff3b"
          },
          {
            "type": "html",
            "text": "\npublic final class Ref<T> {",
            "id": "db2b708a914fcfe40b6f925cd89c4ff4"
          },
          {
            "type": "code",
            "text": "  T obj;\n  public Ref (T obj) {\n  set(obj);\n  }\n  public void set (T obj) {\n  if (obj == null) throw new NullPointerException();\n  this.obj = obj;\n  }\n  public T get () {\n  return obj;\n  }",
            "id": "f958fa404e93518af283b5c1a971d70b"
          },
          {
            "type": "html",
            "text": "}",
            "id": "9267d1c90da9533e6b62f1ad605a6547"
          },
          {
            "type": "html",
            "text": "\nFor an immutable version, just make the set method private.",
            "id": "8282ab378dda76e0e5246567413fd5d7"
          },
          {
            "type": "html",
            "text": "\nThe downside is that the way Java generics work, the Ref<T> may be more cumbersome to use than the T. For example, if Bar derives from Foo, you can assign a Bar to a reference of type Foo, but not a Ref<Bar> to a Ref<Foo>. So you need those variables to be of type Ref<? extends Foo>, which is [[Syntactic Salt]] at its finest. (This assignability rule is for a simple reason: otherwise you could assign a Ref<Bar> reference to a Ref<Foo> reference, use a Foo that is not a Bar in a set method invoked on the latter, and then pull a non-Bar out via the get method on the Bar reference. This does mean that you can't use the set method on a Ref<? extends Foo> though, although you can assign a new Ref object with a new referent.",
            "id": "19f04515c90c35923ab360cceca20409"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "[[What Is Null]] you ask?",
            "id": "7c956583503510b2ddf5e68baf65ef85"
          },
          {
            "type": "html",
            "text": " Null is what you thought your freed pointer was reset to.",
            "id": "00f30e7c31072e784f738855ba426a71"
          },
          {
            "type": "html",
            "text": " Null is what the function that -should- always return a valid pointer just gave you.",
            "id": "47f37639b68ea44089c8c78203d97339"
          },
          {
            "type": "html",
            "text": " Null is how much bureaucracy a system needs on top of \"nothing\".",
            "id": "9261e4f12f028f5ac9e3eb55406bcb53"
          },
          {
            "type": "html",
            "text": " Null is the alpha and the omega, everything begins as null, is initialized, then reset and reused as Null.",
            "id": "80251fc9dea93de5e7ed8fe9aee0e167"
          },
          {
            "type": "html",
            "text": " Null is the absence of a number. Some say Null is the absence of a zero.",
            "id": "d904b499024a7b760b47aca3a21cb986"
          },
          {
            "type": "html",
            "text": " The Null that can be named is not the true Null.",
            "id": "be341e05ae8ff5ecad6a421dca010eff"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": " Null is the value of x before and after it had a value.",
            "id": "9a21a02925d2d60dd81b73a0d2e52353"
          },
          {
            "type": "html",
            "text": " Because Null is the value of all things we do not yet know, Null's domain may be the largest domain.",
            "id": "605b658271b24615a0695392a4a9a957"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "\nIn some languages ([[Oz Language]] being an example) one may introduce a single-assignment variable without actually assigning it. You may then utilize this unassigned variable inside a data structure. One may <i>unify</i> two unassigned variables - i.e. asserting they are the same, such that if one is assigned, then so will be the other. Similarly, you may assign such a variable to a structure that contains yet more unassigned variables. All this is a weakly expressive form of [[Constraint Programming]]. More expressive [[Constraint Programming]] would allow you to restrict variables as well as assign them, i.e. to say that X > Y without knowing X or Y.  In a secure language, the authority to assign a variable or manipulate constraints may be separate from the ability to view the variable. [[Oz Language]] added security via 'X=!!Y', which says that X can view Y but cannot assign Y.",
            "id": "159aa777602e925edf9771ee77b47d2f"
          },
          {
            "type": "html",
            "text": "\nI've long believed that Nulls - at least in the context of data ([[Sql Null]]) - should really be identified by these sort of 'unassigned free variables'. This would allow us to make very interesting observations, the way we do with algebraic and geometric expressions in mathematics. It would be possible, for example, to perform proper joins between tables containing these free variables. If we were using a [[Table Browser]], one might distribute authority to assign these 'variables', such that one could meaningfully assign to a field that was previously unknown... and update the proper record.",
            "id": "043460d8da9eb50cb54755585c689c90"
          },
          {
            "type": "html",
            "text": "\nOf course, it would still lead to interesting issues, such as: the sum of 10+X+12 can only be reduced to 22+X, and a join between two tables limited by X>Y may return some interesting 'contingent' records.",
            "id": "fc546cb205ea649596faf818383a91f8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "See Also: [[Cant Hide From Nulls]]",
            "id": "c67c56934c2368f57e58c4fe9a09dd92"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "5ceedd6930b80f63b5672fc3033067fc"
          },
          {
            "type": "html",
            "text": "[[Category Null]] [[Category Definition]]",
            "id": "d1e4770ccfa9cd8fc19228720623d4c0"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?WhatIsNull c2.com]",
            "id": "3445d2f4d651a4a36a447a8ce243ef9f"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1627419354782
    },
    {
      "type": "edit",
      "id": "f5dcb7be7f19fcd9179661cabd199242",
      "item": {
        "type": "html",
        "text": "[[Null]] or Nil Characteristics:",
        "id": "f5dcb7be7f19fcd9179661cabd199242"
      },
      "date": 1652065732234
    }
  ]
}