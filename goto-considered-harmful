{
  "title": "Goto Considered Harmful",
  "story": [
    {
      "type": "html",
      "text": "<i>For those too young to remember the goto statement, it was used much as Exceptions are today, but had a more concise, elegant syntax #gotocph</i> --@bigballofmud [[Brian Foote]] ",
      "id": "e4223d3abac8ca02e8e7356a36c42973"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "\nIn 1978, Berkeley scientists did a study on the effects of [[Go To]] on rats. Twenty rats in a control group were fed a normal diet, while twenty other rats were forced to program in Apple BASIC. Their health was to be monitored for a month, but after two weeks all of the rats in the programming group had melted into a dense goo that tasted a little like quiche. ",
      "id": "4382e0be5720801d372d3b30d9adb63b"
    },
    {
      "type": "html",
      "text": "<i>But some rats learned to execute GOTO END_OF_MAZE, and finished in record time, while the nested block rats took too long to climb into and out of nested boxes to get to the end.</i>",
      "id": "87530d3c7082819da4ea415225fb64a2"
    },
    {
      "type": "html",
      "text": "\nSeriously, though, don't use [[Go To]] statements. Like any four letter words, they are not appropriate for polite company.",
      "id": "9d22f4580682df5df4141d2d476834e1"
    },
    {
      "type": "html",
      "text": "<i>Unless of course, failure to use goto results in the code being more buggy and unreadable. Also, there are the hidden <b>gotos</b> (in [[Cee Language]]) such as <b>continue</b>, <b>break</b>, or a mid-function <b>return</b> which the extremists generally lump in. Personally, I have seen code which introduced a number of extra <b>control</b> booleans, doubled the number of lines of code with a factor of ten indentation blocks (the stuff that wraps 3 times on an 80 column screen) to be <b>pure</b> and was not correct due to the twisted logic. In the end, there are those who write bad unreadable code no matter what constructs they limit themselves to, and those who write good/obvious code no matter what constructs they use. I like to ask about gotos during interviews to at least see whether the candidate has thought about the issues, or simply regurgitates the dogma.</i> - [[Chris Hyser]]",
      "id": "76a8246ad142f49fadd77c34422f2f5d"
    },
    {
      "type": "html",
      "text": "\nHere's a good rule of thumb: don't use <i>backward</i> [[Go To]] statements. Notice that <b>continue</b>, <b>break</b>, and mid-function <b>return</b> statements are all forward gotos (and switch is a computed forward goto). [[Ew Dijkstra]]'s argument does not apply to them. I have noticed subjectively that they aren't confusing, unless you jump into something else (like the middle of a loop - see [[Duffs Device]]). I don't think there's anything wrong with using <b>goto</b> to do, for example, a double break. Forward gotos are also useful for jumping to cleanup code after an error - they're often much more readable than doing your real work inside an if statement, and they're always more readable than doing your real work in a terraced landscape of nested if statements. ([[Syntax Matters]])",
      "id": "4f1da9caad297fef5d8dace579235ba4"
    },
    {
      "type": "html",
      "text": "\nBackward <b>gotos</b> could be <i>ok</i> when it makes sense that your error case would repeat the last iteration. I like to call it <i>rare looping.</i>\nA good example exists in beej's networking guide. [http://beej.us/guide/bgnet/ beej.us] See section 8. <b>Why does select() keep falling out on a signal?</b>",
      "id": "157dec282e9bbe4ac1ea8e1e2f5cea15"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "\n[[Ew Dijkstra]]'s original paper is here: [http://www.acm.org/classics/oct95/ www.acm.org]. One might find it rather hard to read, except the opening paragraph:",
      "id": "446ac5c6ee0a3f8d0460cc45c95a7e75"
    },
    {
      "type": "html",
      "text": "For a number of years I have been familiar with the observation that the quality of programmers is a decreasing function of the density of <i>go to</i> statements in the programs they produce.",
      "id": "411631ff7e1d9ea4eee0a98b7a395699"
    },
    {
      "type": "html",
      "text": "\nAlso see [[Peter Naur]]'s paper \"Go To Statements and Good ALGOL Style\" (1963).",
      "id": "60480e71135d95a32de9ef374b4fa6eb"
    },
    {
      "type": "html",
      "text": "\nAlso see Donald Knuth's <b>Structured Programming with go to Statements</b>\nDecember 1974\t\nACM Computing Surveys (CSUR), Volume 6 Issue 4 [http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf pplab.snu.ac.kr]",
      "id": "bcf50c95d8ecd245259fcd722b0494d8"
    },
    {
      "type": "html",
      "text": "\nIn this article he makes some compelling arguments for why GO TO (and its relatives) are useful. For example he demonstrates how a jump <i>into the middle of a loop</i> can be elegant (example 6c). The article also presents some constructs which could be considered a primitive form of exception handling. (He also mentions the [[Come From]] statement, BTW.)",
      "id": "6cd8ff0bd5f84e8d90f7f55048f6eb40"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "\nA summary of [[Ew Dijkstra]]'s original paper:",
      "id": "37f4ac968e7a0ba60f87764f8285236e"
    },
    {
      "type": "html",
      "text": "\nWe write programs as lines of text in a file. But our programs execute as microseconds of clock cycles in a machine. We as programmers think in terms of the lines of text, but what really matters is what happens during the microseconds of clock cycles. Therefore, we should make the relationship between the two as easy to understand as possible.",
      "id": "025d48970ca28e443bbc056fa2f275cb"
    },
    {
      "type": "html",
      "text": "\nDijkstra used a set of so-called coordinates to show how far along the program execution is at any given point. For a straight piece of code, we can simply cite the file and line number to show how far along the program execution is. For a function call, we provide a call stack. For a loop, we give the number of iterations so far executed in the loop. Dijkstra reasoned that if you can state a set of such coordinates at each point during the execution of the program, then it's clear enough how the lines of text map to the microseconds of clock cycles.",
      "id": "e27304107851ecb119179d0860619c3c"
    },
    {
      "type": "html",
      "text": "\nHe also reasoned that many uses of [[Go To]] break this understanding, because in [[Spaghetti Code]], it becomes impossible to state, at some points during the execution of the program, how far along the program is.",
      "id": "7e7a1e6593bb0fce03765c4ec60dc569"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "\nIt is important to understand that Dijkstra wrote his paper at a time when people used [[Programming Language]]s without [[Control Constructs]], and thus their programs were littered with gotos -- [[Spaghetti Code]]. It does not follow that a 10,000 line C program is poisoned by one goto; leaping to that conclusion is an example of [[Thinking In Cliches]].",
      "id": "db43334370f01cb54965a4077946af7d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "\nThere are two major approaches to programming: <i>[is there a page that covers this? there should be]</i>",
      "id": "20da3290f6a3879cfda36abb09c9b0b1"
    },
    {
      "type": "html",
      "text": " Pragmatic:<br>[[Code Smell]]s should be considered on a case by case basis",
      "id": "ddd97a5ecbc207635ca54e8c655f3722"
    },
    {
      "type": "html",
      "text": " Purist:<br>all [[Code Smell]]s should be avoided, no exceptions",
      "id": "063423851f4237bc565e74a43ef389ff"
    },
    {
      "type": "html",
      "text": "...And therefore a [[Code Smell]] is a hint of possible bad practice to a pragmatist, but a sure sign of bad practice to a purist.",
      "id": "439ed5593aaa40b43904ffbf20985eb7"
    },
    {
      "type": "html",
      "text": "\nFor purists, the rule is simple: don't use GOTOs. This is not hard in any language. Even in assembler, one can write macros that simulate structured control constructs.",
      "id": "71152da3e23c06e0ef10b166479a24cd"
    },
    {
      "type": "html",
      "text": "\nFor pragmatists, I think it's important to notice that even Dijkstra(as I recall) and Wirth (definitely) admit that there are certain circumstances when GOTOs are best practice: to exit deeply nested structures (of IFs/FORs/WHILEs) in case of unrecoverable error, because doing so with a goto results in far more readable code than does the same code rewritten to test for FATAL_ERROR everywhere. E.g.",
      "id": "d7c3320b5f0f85d4c16e4c81c5c0618e"
    },
    {
      "type": "code",
      "text": "  for (i=0; i<10; i++) {\n    for (j=0; j<10; j++) {\n       for (k=0; k<10; k++) {\n          if (NOT_FOUND == find(i, j, k))\n            goto error;\n          func1(i, j, k);\n       }\n       func2(i, j, k);\n    }\n    func3(i, j, k);\n  }",
      "id": "62c14f9c99e22199811f65a141007920"
    },
    {
      "type": "html",
      "text": "error:",
      "id": "b6b6f99c9994601557c8d17c23ad1efc"
    },
    {
      "type": "code",
      "text": "  ;",
      "id": "e39287881e81f92dc0edb9a656590f67"
    },
    {
      "type": "html",
      "text": "Compared with",
      "id": "c76dd2324ff3c203ac47307379d8b324"
    },
    {
      "type": "code",
      "text": "  FATAL_ERROR = 0;\n  for (i=0; i<10 && !FATAL_ERROR; i++) {\n    for (j=0; j<10 && !FATAL_ERROR; j++) {\n       for (k=0; k<10 && !FATAL_ERROR; k++) {\n          if (NOT_FOUND == find(i, j, k))\n            FATAL_ERROR = 1;\n          if (!FATAL_ERROR)\n            func1(i, j, k);\n       }\n       if (!FATAL_ERROR)\n         func2(i, j, k);\n    }\n    if (!FATAL_ERROR)\n      func3(i, j, k);\n  }",
      "id": "1553ee6140ec3c21a2620bf86b565201"
    },
    {
      "type": "html",
      "text": "...where you can hardly see the code amidst the references to FATAL_ERROR.",
      "id": "f742d6c0c95336777453dd85ce686124"
    },
    {
      "type": "html",
      "text": "\nABOUT THE CODE ABOVE: I would say all this code is wrong. The call of func2 cannot be outside k loop. func3 cannot be outside j loop. using the goto construct clearly shows that this code is designed wrongly. A better designed code would automatically lead to code without goto statements. Yes, (as below) this code really SMELLS, or even better the design SMELLS. Deaply nested structures are also mostly bad code design (also below). Clearly you don't understand Dijkstra by making such claims. Not fixing SMELLY code leads to high cost in maintenance and updates of the code. So tolerating bad code (as below) is a bad management decision.",
      "id": "2c6d0eac63db048bdbab1ad5197e77d9"
    },
    {
      "type": "html",
      "text": " Let's say, just for the sake of argument, that func2 and func3 are not really functions on (i,j,k) but just some series of statements that happen after the nested for, which was clearly the point of the example. And as for \"designed wrongly\", how do you know that without any context? What if you're doing multiplication or other operations on matrices? Just try avoiding nested loops.",
      "id": "59a2f3cad791b22a59e484be003065b2"
    },
    {
      "type": "html",
      "text": "<i>If I recall correctly, this is was part of the reason (was it [[Kent Beck]] or [[Martin Fowler]]) chose that name for the term. They wanted to emphasize the pragrammatic view of [[Code Smell]]s by the connotation of the word \"smell\". If something smells, it definitely needs to be checked out, but it may not actually need fixing or might have to just be tolerated.</i>",
      "id": "aa22ed816c914a3493fdb2eb593bf920"
    },
    {
      "type": "html",
      "text": "<i>Deeply nested structures themselves are a [[Code Smell]] (cf. [[Arrow Anti Pattern]]), but yeah, sometimes they are indeed unavoidable.</i> ",
      "id": "3d908a6df23498ad3f7b6fe3b2441f68"
    },
    {
      "type": "html",
      "text": "\nFor simple cases, it is generally preferable to use \"return\" rather than \"goto\". It can be considered to be a form of goto, and some dislike it more than GOTOs (it violates the single entry/single exit condition for functions), but others prefer it:",
      "id": "6ad13f14fc93b6326480d8ee95ec6212"
    },
    {
      "type": "code",
      "text": "  for (i=0; i<10; i++) {\n    for (j=0; j<10; j++) {\n       for (k=0; k<10; k++) {\n          if (NOT_FOUND == find(i, j, k)) {\n            complain(NOT_FOUND);\n            return;\n          }\n          func1(i, j, k);\n       }\n       func2(i, j, k);\n    }\n    func3(i, j, k);\n  }",
      "id": "7436b05231cbd2cbcd243bb15169edf5"
    },
    {
      "type": "code",
      "text": " sub complain(complaint) {\n // pass along complaint and then do whatever was in error:\n }",
      "id": "b729305374e85da012f627b5258b8991"
    },
    {
      "type": "html",
      "text": "...but this is not directly possible if more work remains to be done following the loops. (Even then, refactoring may save the day.)",
      "id": "5ec724d465544932894bd1e287d04ab6"
    },
    {
      "type": "html",
      "text": "\nMost people agree that, in languages that support exceptions, this would be an ideal place to throw one, and since setjmp/longjmp is merely a non-local goto, it, too, is justifiable for error recovery. Exceptions, in languages that support them, are a more controlled means of doing exactly the same thing: a non-local goto!",
      "id": "39ea098a164cf0b0d0dcbaebcb18f8cd"
    },
    {
      "type": "html",
      "text": "\nThe same reasoning leads to the conclusion that GOTOs or their equivalents could be used anytime there is a need to immediately escape from deeply nested control structures and/or functions, e.g. upon finding the target of an extensive search, not just on fatal error.",
      "id": "02da26e3985fc8d12a0b60a6bb862562"
    },
    {
      "type": "html",
      "text": "\nThe question is merely, does the GOTO improve legibility or lessen it. In almost all circumstances it lessens it, but there are exceptions.",
      "id": "bb9b6922d878fe09c9f2a6fb6d683cd8"
    },
    {
      "type": "html",
      "text": "\nInterestingly, since exceptions are a type of GOTO, <b>precisely</b> the same reasoning applies to them: most of the places they <b>could</b> be used for non-error processing, they should not be.",
      "id": "3f90610c2ef026d35035bf5115ac1784"
    },
    {
      "type": "html",
      "text": "<i>I am under the impression that a function call was considered an acceptable alternative to a GOTO, even in the original debate about GOTO's. An exception system makes things even easier (although the Java exception system is fundamentally broken compared to several of those that preceded it).</i>",
      "id": "eb83ff82dd5df031ac8c0f76c0017ad4"
    },
    {
      "type": "html",
      "text": "<i>Throwing an exception is nothing like a calling a function, because control never returns to the caller (the thrower).</i>",
      "id": "45bf83e66dc6e3f222b45a147ecc20dd"
    },
    {
      "type": "html",
      "text": "\nYes, in this particular example, I personally would agree that using \"complain(NOT_FOUND); return;\" as in the code above is preferable to the goto in my previous example, and don't get me wrong, that's what I usually do in this precise circumstance. But:",
      "id": "99153c74b5c8a7ed86ad5216cc985168"
    },
    {
      "type": "html",
      "text": " Many people think that return out of the middle of a function is just as bad, stylistically, as the goto you replaced, because it violates the single-entry single-exit condition for functions.",
      "id": "ab1eca7f2a0a1bdff3420289e647cee4"
    },
    {
      "type": "html",
      "text": " If there is further work to be done in the current function, then using return won't work.",
      "id": "625e785dc7570ecd6f626117a2edce91"
    },
    {
      "type": "html",
      "text": "(Just wanted to throw in that quick comment before I returned to the stuff below later, which is getting messy.)",
      "id": "1c20b0e425b6ce4fe981b2a071d0748d"
    },
    {
      "type": "html",
      "text": "\nReturning from the middle of a function is language-dependent. Zillions of languages, and in particular Pascal, viewed as the king of the structured languages in the 1970s when [[Goto Considered Harmful]] was a new hot subject, did not allow return from the middle of a function. <i>Which is a very good example of why those languages have now been replaced by [[Cee Language]] or its descendents. On the other hand, by the time I started coding in Pascal in 1982, return could be called anyplace you wanted. The difference between a \"procedure\" and a \"function\" was that we had to assign a value to the function name in order to return a value from a function. I'm pretty sure that's how the language works today, but I haven't coded it in twenty years.</i>",
      "id": "82b42ae1f4e02dd1fd2993e98f4a93cd"
    },
    {
      "type": "html",
      "text": " Pascal (at least the version described by Wirth in <i>Algorithms + Data Structures = Programs</i> and <i>Systematic Programming: An Introduction</i>) could not return from the middle of a function, but it <i>did</i> have a goto statement, which Wirth used in the mini-compiler at the end of <i>Algorithms + Data Structures = Programs</i> in order to handle an error by jumping to near the end of a function. See page 301. He not only does a goto, but he goes to a label inside of a <i>calling function</i>! For example, the following only prints out \"there\":",
      "id": "e74d2655d053ef57ba06830f4d0d4e5e"
    },
    {
      "type": "code",
      "text": "  program test;\n  label 10;\n  begin\n    goto 10;\n    writeln('hello');\n    10:\n    writeln('there')\n  end.",
      "id": "dd7de61de7b03329bf4a69959d6d3f5d"
    },
    {
      "type": "html",
      "text": "Given that, can you see that all this about exceptions and returns is just nitpicking? The point is that sometimes, in some languages, GOTOs are best practice. <i>No, I don't think a GOTO such as you're proposing has EVER been \"best practice\". I haven't even looked at a Pascal manual in twenty years, so I've long since forgotten what the Pascal syntax is or was for this situation. It surely did NOT include GOTO as \"best practice\", however (given Pascal's role as the first \"structured\" language\". Wirth and all that.</i>",
      "id": "dcd6e62a1e28218ab2922a8f5cf80389"
    },
    {
      "type": "html",
      "text": "\nIs it true all the time in all languages? Of course not. Some languages aren't even imperative to start with. Or don't even have a GOTO.",
      "id": "617af44a6d1eea06333f75d08b525f23"
    },
    {
      "type": "html",
      "text": "\nAnd even with your purported solution in C, surely you don't think that using a return will <b>always</b> be better than a GOTO-on-error? In a more complicated function, when return is the wrong thing to do, because one needs to get out of deep nesting but not leave the function yet, refactoring will always allow you to fix that? Always? I don't think so. <i>In more than twenty years of coding, it always has for me.</i>",
      "id": "2b79530038e6e8deb6d041d5a69b4684"
    },
    {
      "type": "html",
      "text": "\nAnd even if it were true, the refactoring might have to wait for another day, and until it happens, the GOTO solution might be the best interim one.",
      "id": "d95ad9eb0d2a467b809c8d659ba7b4a7"
    },
    {
      "type": "html",
      "text": "\nNitpicks: death of a thousand cuts.",
      "id": "8dd62508e4680c3a2160d16ee02e051d"
    },
    {
      "type": "html",
      "text": "<i>Since 1982, when I was paid to write code for the first time (after 7 years doing hardware engineering), I've written code in C, Pascal, [[Object Pascal]], [[Object Cee]], [[Post Script]], Smalltalk, Lisp, [[Cee Plus Plus]], Java, and so on and so forth. I have <b>never</b> needed to use GOTO. Not once. I've needed inline ASM directives, platform functions, deep preprocessor magic with fiascos like CORBA, but not ONCE have I needed GOTO. I don't even know the syntax these days. The paragraph at the top cites \"return\" as a forward GOTO, which Dykstra's argument did not apply to. Nitpick all you want. If you find it a \"best practice\", be my guest. If I'm supporting code like we were talking about here, I'll replace it with my function call. GOTO is just useless baggage that hasn't been necessary for two decades. </i>",
      "id": "584724cbda7d548c3da78b5f46aa7512"
    },
    {
      "type": "html",
      "text": " See [[In All My Years Ive Never]]. I've programmed from 1980 in several languages and I <b>have</b> needed to use it a handful of times (3-6) for precisely the above-mentioned use, as an exit condition of a nasty loop.",
      "id": "07d9b9fbe4f18b9b4a70da9b2c678835"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "This study is been cited by almost every programming teacher as the reason that the use of [[Go To]] statements in code is punishable by expulsion. Except in COBOL, where it's not like removing them would be much help.",
      "id": "39accce1e3989d23a70932b0c48f0169"
    },
    {
      "type": "html",
      "text": "<i>Really bad COBOL has</i>",
      "id": "cb96af51187afe2ab67d02b6698c28dc"
    },
    {
      "type": "code",
      "text": " ALTER <paragraph1> TO PROCEED TO <paragraph2>",
      "id": "f5ad58ca125f35c2ed0b66d9383f1343"
    },
    {
      "type": "html",
      "text": "<i>(It's self-modifying code.)</i>",
      "id": "271aad5729b703237d775e0d858c8776"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "<i>Now that [[Go To]] seems to have largely fallen through a trap door, it makes one wonder what has taken its place as the top [[Warning Signs Of Bad Programming]]?</i>",
      "id": "a25f84ca0e60bee90ae4faf91ff50949"
    },
    {
      "type": "html",
      "text": "\nFor my money, the new number one position belongs to [[Side Effects In Functions]]. When a system contains side-effects in functions, the overall behaviour of the system is immeasurably harder to understand.",
      "id": "09d9c690c54173cbed745e97c1e30eb4"
    },
    {
      "type": "html",
      "text": "\nOf course, like [[Go To]] in the 60's and early 70's, it's widely used and the dangers are not widely appreciated (yet).",
      "id": "f915052b47816ced39a596de1e795a07"
    },
    {
      "type": "html",
      "text": "<i>I think the problem is not [[Side Effects In Functions]], but [[Side Effects In Queries]]. A strict interpretation of the word \"function\" includes a method that returns a boolean value stating whether the operation succeeded or failed - and that obviously must have a side effect. But there should always be separate and distinct methods for performing a query and updating data - a query shouldn't have side effects.</i>",
      "id": "ad3fcd10b32ed8047014fee2830643a7"
    },
    {
      "type": "html",
      "text": "\nThe #1 bad sign is [[Long Method Smell]].",
      "id": "e7f878dbc00312337e7760e7a0f420eb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "Hmmm, now that [[Go To]] has fallen through the trap-door, it would be nice to see Intercal's [[Come From]] more widely used. All the disadvantages and none of the readability!",
      "id": "d25fb48c9b91ec3089755311d1704bf0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "Shouldn't this topic be consolidated with [[Go To]] ?",
      "id": "61155f527894178ed8f8a7d4f9872082"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": " <i>Many people think that return out of the middle of a function is just as bad, stylistically, as the goto you replaced, because it violates the single-entry single-exit condition for functions.</i>",
      "id": "92073e6b02a47701c695c2469b77bc3e"
    },
    {
      "type": "html",
      "text": "\nHuh? What condition is this? Where does that notion come from? ",
      "id": "e18f0b84d5df8bf6a2d59f7a4619d225"
    },
    {
      "type": "html",
      "text": "<i>It came from the original very definition of \"structured programming\" itself. Technically, you are not doing structured programming if you violate that condition. Pragmatists don't care about labels, but purists who avoid GOTOs at all costs should be keenly aware of the contradiction in violating the single-entry single exit condition. Here's one link, of many, that arose when I searched on the term:</i>",
      "id": "f240012e9aeabf2451aea6cffb722e00"
    },
    {
      "type": "html",
      "text": "\n[http://www.ami.ac.uk/courseware/micros/restricted/ch8/micro08strucprog.html www.ami.ac.uk]",
      "id": "91af6e9113dd1b63f1997d751f3122e3"
    },
    {
      "type": "html",
      "text": "\nMy concept of a function is that it takes input, tries to do some processing and reports - as soon as possible - either a result, or an indication that processing was impossible for some reason, in which case the input data should be (still in | returned to) its original state.",
      "id": "71f1c6dbb3bf97f41698fa174678c30d"
    },
    {
      "type": "html",
      "text": " <i>If there is further work to be done in the current function, then using return won't work.</i>",
      "id": "c8b48b19cea669131ba88f647f89c64d"
    },
    {
      "type": "html",
      "text": "\nWhich is why you wrap the current bit of work up in a function. Forward GOTOs can be removed, generally speaking, by [[Extract Method]] and allowing returns from the middle of the new function. Of course, the same potential problems arise here (mainly, potentially having to pass in a large amount of context) as when refactoring away [[Trivial Do While Loop]]. But how did your code ever get <b>that</b> complicated?",
      "id": "25d4f8fa5deb397398fa5ff46e712ea0"
    },
    {
      "type": "html",
      "text": "<i>It's not necessarily that complicated, all it takes is any amount of further work at the end of the function, e.g.:</i>",
      "id": "d111874f6affc5995245c16a5355a4a6"
    },
    {
      "type": "html",
      "text": "\nfunc() {",
      "id": "9e53d1db8065f159d06c1c40042edd33"
    },
    {
      "type": "code",
      "text": "    while(condition()) {\n      work1();\n      if (fatal_error()) goto done;\n      work2();\n    }\n  done:\n    x = sqrt(x) + x*x*x;\n    work3();\n    return work4();",
      "id": "d07cbb0af339b2ad079bdf38ea14ca3c"
    },
    {
      "type": "html",
      "text": "}",
      "id": "ad8b4f459e3c1be337285a65ca3e2a95"
    },
    {
      "type": "html",
      "text": "<i>That's not complicated, but you can't change the goto into a return without [[Extract Method]] or something...and yes, a purist will want to do exactly that refactoring, but a pragmatist may believe that it is more important to keep all of the related work together in one place where it is easier to understand and grasp all at once.</i>",
      "id": "2020c25c61deb6fe8cae8719d6a9aeac"
    },
    {
      "type": "html",
      "text": "<i>To a pragmatist, it's not a question of being forced to use a goto unwillingly, it's a question of whether it will increase readability in some circumstances such as this. A purist will insist that the pragmatist shouldn't have that freedom, or that the result will inherently be less readable. There isn't a \"right\" answer at this point, because there isn't agreement on the premises used to deduce an answer.</i>",
      "id": "d898fa1007f6f770afb1fe69e2920e42"
    },
    {
      "type": "html",
      "text": "\nThe example given is trivial to refactor: ",
      "id": "e057e6f1afd57dcc1c6c044b3740300d"
    },
    {
      "type": "code",
      "text": "  func_loop() {\n    while(condition()) {\n      work1();\n      if (fatal_error()) return;\n      work2();\n    }\n  }",
      "id": "e588266c8ba9aefa8c9876192121df51"
    },
    {
      "type": "code",
      "text": "  func() {\n    func_loop();\n    x = sqrt(x) + x*x*x;\n    work3();\n    return work4();    \n  }",
      "id": "9cb4bee26ca6e36ce39ba4ad70048762"
    },
    {
      "type": "html",
      "text": "As long as the two functions are nearby in the source file, readability shouldn't suffer, and if you can give a [[Meaningful Name]] to the loop, it should even increase (as you don't need to keep the context for func() in mind when looking at the loop. But a simple variation on this becomes much more difficult to refactor:",
      "id": "74518e0546d5633c4f81490f10d1dd38"
    },
    {
      "type": "code",
      "text": "  func(num, str) {\n    x = num / 2 + 34;\n    y = substr(0, x, str);",
      "id": "afd9f5f0cac6afe3e0891f260e4a5dbe"
    },
    {
      "type": "code",
      "text": "    while(condition(x, y)) {\n      y = work1(x, str);\n      if (fatal_error()) goto done;\n      x = work2(y, num);\n    }\n    do_regular_termination(x, y);",
      "id": "04bd0df7368ad160e1386adf341a9bed"
    },
    {
      "type": "code",
      "text": "    done:\n    x = sqrt(num) * y*x*x;\n    str = work3(x, num);\n    return work4(y, str);\n  }",
      "id": "f1e5a12988d5420b80face273d3fb6fb"
    },
    {
      "type": "html",
      "text": "The addition of local variables means that [[Extract Method]] would need a parameter list of 4 variables, and would need to return both x and y (meaning a struct in most languages). The problem persists if you try to do an [[Extract Method]] on 'done:' and tail-call that from the loop and at the end of the function: you'd need to pass in x, y, and num.",
      "id": "497fec7f5a73e8e72de2a95d63d32f79"
    },
    {
      "type": "html",
      "text": "\nThis illustrates a legitimate use for [[Go To]]:  control flow transfer out of a loop where there's a large amount of lexical context that the loop requires. It also illustrates why [[Go To]] is a [[Code Smell]] - most algorithms shouldn't need this much context, and it's worth trying to see if the algorithm can be simplified before reaching for the [[Go To]]. But if it can't, it's good to have it available.",
      "id": "c08cc04529b1d2b9bfc3ad3c9f3da5bb"
    },
    {
      "type": "html",
      "text": "<i>This point about lexical context is exactly what I was trying to get at when I said:</i>",
      "id": "4e0eb63e5d4af1606b809ad6bc91eb0a"
    },
    {
      "type": "html",
      "text": "<i>Of course, the same potential problems arise here (mainly, potentially having to pass in a large amount of context) as when refactoring away [[Trivial Do While Loop]]. But how did your code ever get that complicated?</i>",
      "id": "f9998f1f72bab5cdadd27e151fc6d3b4"
    },
    {
      "type": "html",
      "text": "<i>The stuff that gets passed into the loop is the \"complication\".</i>",
      "id": "5f548375d78f52d52c3160ee5e0ee723"
    },
    {
      "type": "html",
      "text": "\nThe code example in question is not \"that complicated\".",
      "id": "7546e9dc43c5b2ee951af0e94185eb79"
    },
    {
      "type": "html",
      "text": "<i>Yes, it is, because it's contrived. It's not complicated in, say, number of statements or variables, but those are the wrong measures of complexity. Conceptually, this code is complex because it has no purpose, neither an implied nor a stated one, other than twiddling some variables (which it does with a distinctly non-obvious code flow). Pointing out that a refactoring would need a large context transfer is pointing out that this code smells -- goto or no. And \"do_regular_termination\" is a red herring: why is calling a function with </i>two<i> local variables acceptable, but not three? What exactly is \"lots of context\"?</i>",
      "id": "369efae36da11aa5d12d2a0f8f655915"
    },
    {
      "type": "html",
      "text": "<i>This example doesn't convince me that there is code that uses lots of lexical context in a loop </i>and<i> cannot be easily refactored. I see your point in theory, but dispute its application in practice. Note that the goto in this example still smells, but it smells </i>independently<i>. Break statements or exception handling both result in code that is more obvious (if not, of course, </i>shorter<i>, but that's penny wise, pound foolish). Whether these are \"gotos in disguise\" and whether that's also harmful is a separate discussion.</i>",
      "id": "1129a5689278cf7c0d8273a352d066ae"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "\nDijkstra's article really addressed the issue that a goto in the middle of a loop with an autoindex causes difficulty in understanding program flow. In that limited sense the argument is strong. He didn't address at all the use of goto in general coding practice, other than a general comment in his introduction that quality of programming was inversely related to goto density. kd4ttc",
      "id": "27f2c94c38e37a1da4bc4937eb081e50"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "\nI <i>looove</i> the labeled block in java: it makes people's hair stand on end.",
      "id": "50f5177d6d87029e8e8e71eee4a395d4"
    },
    {
      "type": "html",
      "text": "found_ok:<br>{",
      "id": "73f2f95357ae4361c5b046feefb90cd4"
    },
    {
      "type": "code",
      "text": "   for retries = 1 to 3 {\n     loop through items {\n       if we found one, break found_ok.\n     }\n     do a retry delay;\n   }\n   throw new \"oh no! none were found after 3 retries!\";\n }",
      "id": "dcc24db3a4ef219f35c0d765b1755d5c"
    },
    {
      "type": "code",
      "text": " // we found an entry ok",
      "id": "63cc96991e021675a30a78510b51cf31"
    },
    {
      "type": "html",
      "text": "<i>This is pretty awkward. It looks like a backward goto but it really is a forward goto. Confusing. Maybe they should have had it typed out \"{ ...; break found_ok; } : found_ok;\" This would clearly indicate the start and destination of the jump.</i>",
      "id": "e0507d8d70d86154aaf47a10cfa30b78"
    },
    {
      "type": "html",
      "text": "\nWhy not [[Extract Method]] it? Here's how in [[Perl Language]] you can use a sub to return a value, instead of a block and having to throw an exception:",
      "id": "81bbf94be0eaa07dbd25223513e0e7b7"
    },
    {
      "type": "code",
      "text": " sub found_ok {\n   my @items = @_; \n   foreach (@items) {\n     return 1 if $_ eq \"foo\";\n   } \n   return; # gives undef\n }",
      "id": "226a47edba1741107fba9e37ff5863eb"
    },
    {
      "type": "html",
      "text": "Then you can handle the result of the check a little more cleanly with \"if (found_ok(@things))\". Of course, this depends on if you think [[Internal Loop Exits Are Ok]] or not. You can also trivially modify the above to provide a [[Single Function Exit Point]]:",
      "id": "64963b88559190b294f6ba665eca3c70"
    },
    {
      "type": "code",
      "text": " sub found_ok {\n   my @items = @_; \n   my $success;\n   foreach (@items) {\n     $success = 1 if $_ eq \"foo\";\n   } \n   return $success;\n }",
      "id": "b32d581efa1147438e52999da09eb402"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "What about this C function:",
      "id": "b6f5d6976b6d2b21f73690c9e6f074cd"
    },
    {
      "type": "code",
      "text": " void someFunc()\n {\n   T *X1, *X2;\n   ...\n   X1 = (T*)malloc(...);\n   ...\n   if (FAILED(func1())\n     goto clean1;\n   ...\n   X2 = (T*)malloc(...);\n   ...\n   if (FAILED(func2())\n     goto clean2;\n   ...\n clean2:\n   free(X2);\n clean1:\n   free(X1);\n }",
      "id": "74808b95aa4727119f9889b8770e16c2"
    },
    {
      "type": "html",
      "text": "Am I supposed to make a function call per malloc? These gotos produce essentially the same code as would class instances with destructors in C++. Fragmenting such a function to avoid gotos can and will reduce readability, as well as force you to think up useless function names like someFuncBeforeAllocatingX2(). Sometimes this refactoring can be done nicely, sometimes not.",
      "id": "60ae4255cbf8a75972e3f163b3999825"
    },
    {
      "type": "html",
      "text": "<i>Why not use if statements? Block scope and <8 space tab widths are your friends.</i>",
      "id": "80a0bd5a6248a1910f2a0622139bc8b8"
    },
    {
      "type": "code",
      "text": " void someFunc()\n {\n   T *X1 = (T*)malloc(...);\n   ...\n   if (SUCCEEDED(func1())\n   {\n     ...\n     T *X2 = (T*)malloc(...);\n     ...\n     if (SUCCEEDED(func2())\n     {\n       ...\n     }\n     free(X2);\n   }\n   free(X1);\n }",
      "id": "65a2ff75d848b6ae8ef98c2283c190d8"
    },
    {
      "type": "html",
      "text": "If clauses are a good solution, but it bothers me that this issue of destruction interferes with the flow of the program presented to the programmer. By that I mean, in C++ the same function would look like (given T_wrapper that that does the needed [de]allocation during [de]construction and has operator T*:",
      "id": "20a07089dcd0f79722b654bda60b6bc8"
    },
    {
      "type": "html",
      "text": "\nvoid someFunc() {",
      "id": "67bbf94c5e09dec83a1114e706df7b51"
    },
    {
      "type": "code",
      "text": "  T_wrapper X1;\n  if (FAILED(func1()))\n     return;\n  ...\n  T_wrapper X2;\n  if (FAILED(func2()))\n     return;\n  ...",
      "id": "070ae9aea1f9b90c6e35bc77f0d5ea9a"
    },
    {
      "type": "html",
      "text": "}",
      "id": "ad8b4f459e3c1be337285a65ca3e2a95"
    },
    {
      "type": "html",
      "text": "\nAnd it seems to me that what I wrote looks closer to the form I want, compared with the code that puts ... inside if clauses. \nBesides, it can get more complicated than this example, if the last ... is something like two or three nested for statements that can terminate at any time, I'd like to goto cleanup2 there also.",
      "id": "e69cb594d0987570d05af6d1162922a4"
    },
    {
      "type": "html",
      "text": "\nThe gotos implement destruction; I don't think of them as part of the flow control of the \"actual\" program. I'm merely emulating C++ here. It's similar to using function pointer tables to emulate virtual in C. It looks uglier of course, but this is strictly in the syntax level. Of course, hand-crafted emulation is prone to errors, and it would be best to do it using a C++ to C compiler, if only I could find one.",
      "id": "e43c3111213ce355e000a69cb3e69bb9"
    },
    {
      "type": "html",
      "text": "<i>Why not pass a function pointer to a function that allocates T, calls the function pointer function and then deallocates T?</i>",
      "id": "4ae1caa3006c5219c0cd96910ee487d2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "That's an extra virtual call (call [ecx]) per allocation, and you have to split someFunc() into parts (each time you allocate something, you need another function like someFuncAfter3Allocations()) which is exactly what I was trying to avoid. I don't see how that is more acceptable in any possible sense than using cleanup labels at the end to emulate destruction.",
      "id": "42b89862691803e4d7e98721b993cdd7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "Idea: How about matching each goto with a [[Come From]] into a [[Goto Come From Pair]] so that gotos are only allowed from sources explicitly named at the target label?",
      "id": "1550c60ac3480d224154afdd02726f01"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "See: [[Go To]], [[Recv Considered Harmful]], [[Else Considered Smelly]], [[Return Considered Smelly]], [[Objective Evidence Against Gotos]]",
      "id": "32a23a9c5512ba9cfe592d71466ec82d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "4f5e151380a2e9c2844ae326efb86389"
    },
    {
      "type": "html",
      "text": "[[Category Branching And Flow]]",
      "id": "22d5e3dabf92634fbed65d1085b1aae3"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?GotoConsideredHarmful c2.com]",
      "id": "a962c610f9b2e2bcae75d54a10e149b2"
    }
  ],
  "journal": [
    {
      "date": 1375822777000,
      "id": "9976aeb36369060d843943e6deab8a5f",
      "type": "create",
      "item": {
        "title": "Goto Considered Harmful",
        "story": [
          {
            "type": "html",
            "text": "<i>For those too young to remember the goto statement, it was used much as Exceptions are today, but had a more concise, elegant syntax #gotocph</i> --@bigballofmud [[Brian Foote]] ",
            "id": "e4223d3abac8ca02e8e7356a36c42973"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "\nIn 1978, Berkeley scientists did a study on the effects of [[Go To]] on rats. Twenty rats in a control group were fed a normal diet, while twenty other rats were forced to program in Apple BASIC. Their health was to be monitored for a month, but after two weeks all of the rats in the programming group had melted into a dense goo that tasted a little like quiche. ",
            "id": "4382e0be5720801d372d3b30d9adb63b"
          },
          {
            "type": "html",
            "text": "<i>But some rats learned to execute GOTO END_OF_MAZE, and finished in record time, while the nested block rats took too long to climb into and out of nested boxes to get to the end.</i>",
            "id": "87530d3c7082819da4ea415225fb64a2"
          },
          {
            "type": "html",
            "text": "\nSeriously, though, don't use [[Go To]] statements. Like any four letter words, they are not appropriate for polite company.",
            "id": "9d22f4580682df5df4141d2d476834e1"
          },
          {
            "type": "html",
            "text": "<i>Unless of course, failure to use goto results in the code being more buggy and unreadable. Also, there are the hidden <b>gotos</b> (in [[Cee Language]]) such as <b>continue</b>, <b>break</b>, or a mid-function <b>return</b> which the extremists generally lump in. Personally, I have seen code which introduced a number of extra <b>control</b> booleans, doubled the number of lines of code with a factor of ten indentation blocks (the stuff that wraps 3 times on an 80 column screen) to be <b>pure</b> and was not correct due to the twisted logic. In the end, there are those who write bad unreadable code no matter what constructs they limit themselves to, and those who write good/obvious code no matter what constructs they use. I like to ask about gotos during interviews to at least see whether the candidate has thought about the issues, or simply regurgitates the dogma.</i> - [[Chris Hyser]]",
            "id": "76a8246ad142f49fadd77c34422f2f5d"
          },
          {
            "type": "html",
            "text": "\nHere's a good rule of thumb: don't use <i>backward</i> [[Go To]] statements. Notice that <b>continue</b>, <b>break</b>, and mid-function <b>return</b> statements are all forward gotos (and switch is a computed forward goto). [[Ew Dijkstra]]'s argument does not apply to them. I have noticed subjectively that they aren't confusing, unless you jump into something else (like the middle of a loop - see [[Duffs Device]]). I don't think there's anything wrong with using <b>goto</b> to do, for example, a double break. Forward gotos are also useful for jumping to cleanup code after an error - they're often much more readable than doing your real work inside an if statement, and they're always more readable than doing your real work in a terraced landscape of nested if statements. ([[Syntax Matters]])",
            "id": "4f1da9caad297fef5d8dace579235ba4"
          },
          {
            "type": "html",
            "text": "\nBackward <b>gotos</b> could be <i>ok</i> when it makes sense that your error case would repeat the last iteration. I like to call it <i>rare looping.</i>\nA good example exists in beej's networking guide. [http://beej.us/guide/bgnet/ beej.us] See section 8. <b>Why does select() keep falling out on a signal?</b>",
            "id": "157dec282e9bbe4ac1ea8e1e2f5cea15"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "\n[[Ew Dijkstra]]'s original paper is here: [http://www.acm.org/classics/oct95/ www.acm.org]. One might find it rather hard to read, except the opening paragraph:",
            "id": "446ac5c6ee0a3f8d0460cc45c95a7e75"
          },
          {
            "type": "html",
            "text": "For a number of years I have been familiar with the observation that the quality of programmers is a decreasing function of the density of <i>go to</i> statements in the programs they produce.",
            "id": "411631ff7e1d9ea4eee0a98b7a395699"
          },
          {
            "type": "html",
            "text": "\nAlso see [[Peter Naur]]'s paper \"Go To Statements and Good ALGOL Style\" (1963).",
            "id": "60480e71135d95a32de9ef374b4fa6eb"
          },
          {
            "type": "html",
            "text": "\nAlso see Donald Knuth's <b>Structured Programming with go to Statements</b>\nDecember 1974\t\nACM Computing Surveys (CSUR), Volume 6 Issue 4 [http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf pplab.snu.ac.kr]",
            "id": "bcf50c95d8ecd245259fcd722b0494d8"
          },
          {
            "type": "html",
            "text": "\nIn this article he makes some compelling arguments for why GO TO (and its relatives) are useful. For example he demonstrates how a jump <i>into the middle of a loop</i> can be elegant (example 6c). The article also presents some constructs which could be considered a primitive form of exception handling. (He also mentions the [[Come From]] statement, BTW.)",
            "id": "6cd8ff0bd5f84e8d90f7f55048f6eb40"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "\nA summary of [[Ew Dijkstra]]'s original paper:",
            "id": "37f4ac968e7a0ba60f87764f8285236e"
          },
          {
            "type": "html",
            "text": "\nWe write programs as lines of text in a file. But our programs execute as microseconds of clock cycles in a machine. We as programmers think in terms of the lines of text, but what really matters is what happens during the microseconds of clock cycles. Therefore, we should make the relationship between the two as easy to understand as possible.",
            "id": "025d48970ca28e443bbc056fa2f275cb"
          },
          {
            "type": "html",
            "text": "\nDijkstra used a set of so-called coordinates to show how far along the program execution is at any given point. For a straight piece of code, we can simply cite the file and line number to show how far along the program execution is. For a function call, we provide a call stack. For a loop, we give the number of iterations so far executed in the loop. Dijkstra reasoned that if you can state a set of such coordinates at each point during the execution of the program, then it's clear enough how the lines of text map to the microseconds of clock cycles.",
            "id": "e27304107851ecb119179d0860619c3c"
          },
          {
            "type": "html",
            "text": "\nHe also reasoned that many uses of [[Go To]] break this understanding, because in [[Spaghetti Code]], it becomes impossible to state, at some points during the execution of the program, how far along the program is.",
            "id": "7e7a1e6593bb0fce03765c4ec60dc569"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "\nIt is important to understand that Dijkstra wrote his paper at a time when people used [[Programming Language]]s without [[Control Constructs]], and thus their programs were littered with gotos -- [[Spaghetti Code]]. It does not follow that a 10,000 line C program is poisoned by one goto; leaping to that conclusion is an example of [[Thinking In Cliches]].",
            "id": "db43334370f01cb54965a4077946af7d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "\nThere are two major approaches to programming: <i>[is there a page that covers this? there should be]</i>",
            "id": "20da3290f6a3879cfda36abb09c9b0b1"
          },
          {
            "type": "html",
            "text": " Pragmatic:<br>[[Code Smell]]s should be considered on a case by case basis",
            "id": "ddd97a5ecbc207635ca54e8c655f3722"
          },
          {
            "type": "html",
            "text": " Purist:<br>all [[Code Smell]]s should be avoided, no exceptions",
            "id": "063423851f4237bc565e74a43ef389ff"
          },
          {
            "type": "html",
            "text": "...And therefore a [[Code Smell]] is a hint of possible bad practice to a pragmatist, but a sure sign of bad practice to a purist.",
            "id": "439ed5593aaa40b43904ffbf20985eb7"
          },
          {
            "type": "html",
            "text": "\nFor purists, the rule is simple: don't use GOTOs. This is not hard in any language. Even in assembler, one can write macros that simulate structured control constructs.",
            "id": "71152da3e23c06e0ef10b166479a24cd"
          },
          {
            "type": "html",
            "text": "\nFor pragmatists, I think it's important to notice that even Dijkstra(as I recall) and Wirth (definitely) admit that there are certain circumstances when GOTOs are best practice: to exit deeply nested structures (of IFs/FORs/WHILEs) in case of unrecoverable error, because doing so with a goto results in far more readable code than does the same code rewritten to test for FATAL_ERROR everywhere. E.g.",
            "id": "d7c3320b5f0f85d4c16e4c81c5c0618e"
          },
          {
            "type": "code",
            "text": "  for (i=0; i<10; i++) {\n    for (j=0; j<10; j++) {\n       for (k=0; k<10; k++) {\n          if (NOT_FOUND == find(i, j, k))\n            goto error;\n          func1(i, j, k);\n       }\n       func2(i, j, k);\n    }\n    func3(i, j, k);\n  }",
            "id": "62c14f9c99e22199811f65a141007920"
          },
          {
            "type": "html",
            "text": "error:",
            "id": "b6b6f99c9994601557c8d17c23ad1efc"
          },
          {
            "type": "code",
            "text": "  ;",
            "id": "e39287881e81f92dc0edb9a656590f67"
          },
          {
            "type": "html",
            "text": "Compared with",
            "id": "c76dd2324ff3c203ac47307379d8b324"
          },
          {
            "type": "code",
            "text": "  FATAL_ERROR = 0;\n  for (i=0; i<10 && !FATAL_ERROR; i++) {\n    for (j=0; j<10 && !FATAL_ERROR; j++) {\n       for (k=0; k<10 && !FATAL_ERROR; k++) {\n          if (NOT_FOUND == find(i, j, k))\n            FATAL_ERROR = 1;\n          if (!FATAL_ERROR)\n            func1(i, j, k);\n       }\n       if (!FATAL_ERROR)\n         func2(i, j, k);\n    }\n    if (!FATAL_ERROR)\n      func3(i, j, k);\n  }",
            "id": "1553ee6140ec3c21a2620bf86b565201"
          },
          {
            "type": "html",
            "text": "...where you can hardly see the code amidst the references to FATAL_ERROR.",
            "id": "f742d6c0c95336777453dd85ce686124"
          },
          {
            "type": "html",
            "text": "\nABOUT THE CODE ABOVE: I would say all this code is wrong. The call of func2 cannot be outside k loop. func3 cannot be outside j loop. using the goto construct clearly shows that this code is designed wrongly. A better designed code would automatically lead to code without goto statements. Yes, (as below) this code really SMELLS, or even better the design SMELLS. Deaply nested structures are also mostly bad code design (also below). Clearly you don't understand Dijkstra by making such claims. Not fixing SMELLY code leads to high cost in maintenance and updates of the code. So tolerating bad code (as below) is a bad management decision.",
            "id": "2c6d0eac63db048bdbab1ad5197e77d9"
          },
          {
            "type": "html",
            "text": " Let's say, just for the sake of argument, that func2 and func3 are not really functions on (i,j,k) but just some series of statements that happen after the nested for, which was clearly the point of the example. And as for \"designed wrongly\", how do you know that without any context? What if you're doing multiplication or other operations on matrices? Just try avoiding nested loops.",
            "id": "59a2f3cad791b22a59e484be003065b2"
          },
          {
            "type": "html",
            "text": "<i>If I recall correctly, this is was part of the reason (was it [[Kent Beck]] or [[Martin Fowler]]) chose that name for the term. They wanted to emphasize the pragrammatic view of [[Code Smell]]s by the connotation of the word \"smell\". If something smells, it definitely needs to be checked out, but it may not actually need fixing or might have to just be tolerated.</i>",
            "id": "aa22ed816c914a3493fdb2eb593bf920"
          },
          {
            "type": "html",
            "text": "<i>Deeply nested structures themselves are a [[Code Smell]] (cf. [[Arrow Anti Pattern]]), but yeah, sometimes they are indeed unavoidable.</i> ",
            "id": "3d908a6df23498ad3f7b6fe3b2441f68"
          },
          {
            "type": "html",
            "text": "\nFor simple cases, it is generally preferable to use \"return\" rather than \"goto\". It can be considered to be a form of goto, and some dislike it more than GOTOs (it violates the single entry/single exit condition for functions), but others prefer it:",
            "id": "6ad13f14fc93b6326480d8ee95ec6212"
          },
          {
            "type": "code",
            "text": "  for (i=0; i<10; i++) {\n    for (j=0; j<10; j++) {\n       for (k=0; k<10; k++) {\n          if (NOT_FOUND == find(i, j, k)) {\n            complain(NOT_FOUND);\n            return;\n          }\n          func1(i, j, k);\n       }\n       func2(i, j, k);\n    }\n    func3(i, j, k);\n  }",
            "id": "7436b05231cbd2cbcd243bb15169edf5"
          },
          {
            "type": "code",
            "text": " sub complain(complaint) {\n // pass along complaint and then do whatever was in error:\n }",
            "id": "b729305374e85da012f627b5258b8991"
          },
          {
            "type": "html",
            "text": "...but this is not directly possible if more work remains to be done following the loops. (Even then, refactoring may save the day.)",
            "id": "5ec724d465544932894bd1e287d04ab6"
          },
          {
            "type": "html",
            "text": "\nMost people agree that, in languages that support exceptions, this would be an ideal place to throw one, and since setjmp/longjmp is merely a non-local goto, it, too, is justifiable for error recovery. Exceptions, in languages that support them, are a more controlled means of doing exactly the same thing: a non-local goto!",
            "id": "39ea098a164cf0b0d0dcbaebcb18f8cd"
          },
          {
            "type": "html",
            "text": "\nThe same reasoning leads to the conclusion that GOTOs or their equivalents could be used anytime there is a need to immediately escape from deeply nested control structures and/or functions, e.g. upon finding the target of an extensive search, not just on fatal error.",
            "id": "02da26e3985fc8d12a0b60a6bb862562"
          },
          {
            "type": "html",
            "text": "\nThe question is merely, does the GOTO improve legibility or lessen it. In almost all circumstances it lessens it, but there are exceptions.",
            "id": "bb9b6922d878fe09c9f2a6fb6d683cd8"
          },
          {
            "type": "html",
            "text": "\nInterestingly, since exceptions are a type of GOTO, <b>precisely</b> the same reasoning applies to them: most of the places they <b>could</b> be used for non-error processing, they should not be.",
            "id": "3f90610c2ef026d35035bf5115ac1784"
          },
          {
            "type": "html",
            "text": "<i>I am under the impression that a function call was considered an acceptable alternative to a GOTO, even in the original debate about GOTO's. An exception system makes things even easier (although the Java exception system is fundamentally broken compared to several of those that preceded it).</i>",
            "id": "eb83ff82dd5df031ac8c0f76c0017ad4"
          },
          {
            "type": "html",
            "text": "<i>Throwing an exception is nothing like a calling a function, because control never returns to the caller (the thrower).</i>",
            "id": "45bf83e66dc6e3f222b45a147ecc20dd"
          },
          {
            "type": "html",
            "text": "\nYes, in this particular example, I personally would agree that using \"complain(NOT_FOUND); return;\" as in the code above is preferable to the goto in my previous example, and don't get me wrong, that's what I usually do in this precise circumstance. But:",
            "id": "99153c74b5c8a7ed86ad5216cc985168"
          },
          {
            "type": "html",
            "text": " Many people think that return out of the middle of a function is just as bad, stylistically, as the goto you replaced, because it violates the single-entry single-exit condition for functions.",
            "id": "ab1eca7f2a0a1bdff3420289e647cee4"
          },
          {
            "type": "html",
            "text": " If there is further work to be done in the current function, then using return won't work.",
            "id": "625e785dc7570ecd6f626117a2edce91"
          },
          {
            "type": "html",
            "text": "(Just wanted to throw in that quick comment before I returned to the stuff below later, which is getting messy.)",
            "id": "1c20b0e425b6ce4fe981b2a071d0748d"
          },
          {
            "type": "html",
            "text": "\nReturning from the middle of a function is language-dependent. Zillions of languages, and in particular Pascal, viewed as the king of the structured languages in the 1970s when [[Goto Considered Harmful]] was a new hot subject, did not allow return from the middle of a function. <i>Which is a very good example of why those languages have now been replaced by [[Cee Language]] or its descendents. On the other hand, by the time I started coding in Pascal in 1982, return could be called anyplace you wanted. The difference between a \"procedure\" and a \"function\" was that we had to assign a value to the function name in order to return a value from a function. I'm pretty sure that's how the language works today, but I haven't coded it in twenty years.</i>",
            "id": "82b42ae1f4e02dd1fd2993e98f4a93cd"
          },
          {
            "type": "html",
            "text": " Pascal (at least the version described by Wirth in <i>Algorithms + Data Structures = Programs</i> and <i>Systematic Programming: An Introduction</i>) could not return from the middle of a function, but it <i>did</i> have a goto statement, which Wirth used in the mini-compiler at the end of <i>Algorithms + Data Structures = Programs</i> in order to handle an error by jumping to near the end of a function. See page 301. He not only does a goto, but he goes to a label inside of a <i>calling function</i>! For example, the following only prints out \"there\":",
            "id": "e74d2655d053ef57ba06830f4d0d4e5e"
          },
          {
            "type": "code",
            "text": "  program test;\n  label 10;\n  begin\n    goto 10;\n    writeln('hello');\n    10:\n    writeln('there')\n  end.",
            "id": "dd7de61de7b03329bf4a69959d6d3f5d"
          },
          {
            "type": "html",
            "text": "Given that, can you see that all this about exceptions and returns is just nitpicking? The point is that sometimes, in some languages, GOTOs are best practice. <i>No, I don't think a GOTO such as you're proposing has EVER been \"best practice\". I haven't even looked at a Pascal manual in twenty years, so I've long since forgotten what the Pascal syntax is or was for this situation. It surely did NOT include GOTO as \"best practice\", however (given Pascal's role as the first \"structured\" language\". Wirth and all that.</i>",
            "id": "dcd6e62a1e28218ab2922a8f5cf80389"
          },
          {
            "type": "html",
            "text": "\nIs it true all the time in all languages? Of course not. Some languages aren't even imperative to start with. Or don't even have a GOTO.",
            "id": "617af44a6d1eea06333f75d08b525f23"
          },
          {
            "type": "html",
            "text": "\nAnd even with your purported solution in C, surely you don't think that using a return will <b>always</b> be better than a GOTO-on-error? In a more complicated function, when return is the wrong thing to do, because one needs to get out of deep nesting but not leave the function yet, refactoring will always allow you to fix that? Always? I don't think so. <i>In more than twenty years of coding, it always has for me.</i>",
            "id": "2b79530038e6e8deb6d041d5a69b4684"
          },
          {
            "type": "html",
            "text": "\nAnd even if it were true, the refactoring might have to wait for another day, and until it happens, the GOTO solution might be the best interim one.",
            "id": "d95ad9eb0d2a467b809c8d659ba7b4a7"
          },
          {
            "type": "html",
            "text": "\nNitpicks: death of a thousand cuts.",
            "id": "8dd62508e4680c3a2160d16ee02e051d"
          },
          {
            "type": "html",
            "text": "<i>Since 1982, when I was paid to write code for the first time (after 7 years doing hardware engineering), I've written code in C, Pascal, [[Object Pascal]], [[Object Cee]], [[Post Script]], Smalltalk, Lisp, [[Cee Plus Plus]], Java, and so on and so forth. I have <b>never</b> needed to use GOTO. Not once. I've needed inline ASM directives, platform functions, deep preprocessor magic with fiascos like CORBA, but not ONCE have I needed GOTO. I don't even know the syntax these days. The paragraph at the top cites \"return\" as a forward GOTO, which Dykstra's argument did not apply to. Nitpick all you want. If you find it a \"best practice\", be my guest. If I'm supporting code like we were talking about here, I'll replace it with my function call. GOTO is just useless baggage that hasn't been necessary for two decades. </i>",
            "id": "584724cbda7d548c3da78b5f46aa7512"
          },
          {
            "type": "html",
            "text": " See [[In All My Years Ive Never]]. I've programmed from 1980 in several languages and I <b>have</b> needed to use it a handful of times (3-6) for precisely the above-mentioned use, as an exit condition of a nasty loop.",
            "id": "07d9b9fbe4f18b9b4a70da9b2c678835"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "This study is been cited by almost every programming teacher as the reason that the use of [[Go To]] statements in code is punishable by expulsion. Except in COBOL, where it's not like removing them would be much help.",
            "id": "39accce1e3989d23a70932b0c48f0169"
          },
          {
            "type": "html",
            "text": "<i>Really bad COBOL has</i>",
            "id": "cb96af51187afe2ab67d02b6698c28dc"
          },
          {
            "type": "code",
            "text": " ALTER <paragraph1> TO PROCEED TO <paragraph2>",
            "id": "f5ad58ca125f35c2ed0b66d9383f1343"
          },
          {
            "type": "html",
            "text": "<i>(It's self-modifying code.)</i>",
            "id": "271aad5729b703237d775e0d858c8776"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "<i>Now that [[Go To]] seems to have largely fallen through a trap door, it makes one wonder what has taken its place as the top [[Warning Signs Of Bad Programming]]?</i>",
            "id": "a25f84ca0e60bee90ae4faf91ff50949"
          },
          {
            "type": "html",
            "text": "\nFor my money, the new number one position belongs to [[Side Effects In Functions]]. When a system contains side-effects in functions, the overall behaviour of the system is immeasurably harder to understand.",
            "id": "09d9c690c54173cbed745e97c1e30eb4"
          },
          {
            "type": "html",
            "text": "\nOf course, like [[Go To]] in the 60's and early 70's, it's widely used and the dangers are not widely appreciated (yet).",
            "id": "f915052b47816ced39a596de1e795a07"
          },
          {
            "type": "html",
            "text": "<i>I think the problem is not [[Side Effects In Functions]], but [[Side Effects In Queries]]. A strict interpretation of the word \"function\" includes a method that returns a boolean value stating whether the operation succeeded or failed - and that obviously must have a side effect. But there should always be separate and distinct methods for performing a query and updating data - a query shouldn't have side effects.</i>",
            "id": "ad3fcd10b32ed8047014fee2830643a7"
          },
          {
            "type": "html",
            "text": "\nThe #1 bad sign is [[Long Method Smell]].",
            "id": "e7f878dbc00312337e7760e7a0f420eb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "Hmmm, now that [[Go To]] has fallen through the trap-door, it would be nice to see Intercal's [[Come From]] more widely used. All the disadvantages and none of the readability!",
            "id": "d25fb48c9b91ec3089755311d1704bf0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "Shouldn't this topic be consolidated with [[Go To]] ?",
            "id": "61155f527894178ed8f8a7d4f9872082"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": " <i>Many people think that return out of the middle of a function is just as bad, stylistically, as the goto you replaced, because it violates the single-entry single-exit condition for functions.</i>",
            "id": "92073e6b02a47701c695c2469b77bc3e"
          },
          {
            "type": "html",
            "text": "\nHuh? What condition is this? Where does that notion come from? ",
            "id": "e18f0b84d5df8bf6a2d59f7a4619d225"
          },
          {
            "type": "html",
            "text": "<i>It came from the original very definition of \"structured programming\" itself. Technically, you are not doing structured programming if you violate that condition. Pragmatists don't care about labels, but purists who avoid GOTOs at all costs should be keenly aware of the contradiction in violating the single-entry single exit condition. Here's one link, of many, that arose when I searched on the term:</i>",
            "id": "f240012e9aeabf2451aea6cffb722e00"
          },
          {
            "type": "html",
            "text": "\n[http://www.ami.ac.uk/courseware/micros/restricted/ch8/micro08strucprog.html www.ami.ac.uk]",
            "id": "91af6e9113dd1b63f1997d751f3122e3"
          },
          {
            "type": "html",
            "text": "\nMy concept of a function is that it takes input, tries to do some processing and reports - as soon as possible - either a result, or an indication that processing was impossible for some reason, in which case the input data should be (still in | returned to) its original state.",
            "id": "71f1c6dbb3bf97f41698fa174678c30d"
          },
          {
            "type": "html",
            "text": " <i>If there is further work to be done in the current function, then using return won't work.</i>",
            "id": "c8b48b19cea669131ba88f647f89c64d"
          },
          {
            "type": "html",
            "text": "\nWhich is why you wrap the current bit of work up in a function. Forward GOTOs can be removed, generally speaking, by [[Extract Method]] and allowing returns from the middle of the new function. Of course, the same potential problems arise here (mainly, potentially having to pass in a large amount of context) as when refactoring away [[Trivial Do While Loop]]. But how did your code ever get <b>that</b> complicated?",
            "id": "25d4f8fa5deb397398fa5ff46e712ea0"
          },
          {
            "type": "html",
            "text": "<i>It's not necessarily that complicated, all it takes is any amount of further work at the end of the function, e.g.:</i>",
            "id": "d111874f6affc5995245c16a5355a4a6"
          },
          {
            "type": "html",
            "text": "\nfunc() {",
            "id": "9e53d1db8065f159d06c1c40042edd33"
          },
          {
            "type": "code",
            "text": "    while(condition()) {\n      work1();\n      if (fatal_error()) goto done;\n      work2();\n    }\n  done:\n    x = sqrt(x) + x*x*x;\n    work3();\n    return work4();",
            "id": "d07cbb0af339b2ad079bdf38ea14ca3c"
          },
          {
            "type": "html",
            "text": "}",
            "id": "ad8b4f459e3c1be337285a65ca3e2a95"
          },
          {
            "type": "html",
            "text": "<i>That's not complicated, but you can't change the goto into a return without [[Extract Method]] or something...and yes, a purist will want to do exactly that refactoring, but a pragmatist may believe that it is more important to keep all of the related work together in one place where it is easier to understand and grasp all at once.</i>",
            "id": "2020c25c61deb6fe8cae8719d6a9aeac"
          },
          {
            "type": "html",
            "text": "<i>To a pragmatist, it's not a question of being forced to use a goto unwillingly, it's a question of whether it will increase readability in some circumstances such as this. A purist will insist that the pragmatist shouldn't have that freedom, or that the result will inherently be less readable. There isn't a \"right\" answer at this point, because there isn't agreement on the premises used to deduce an answer.</i>",
            "id": "d898fa1007f6f770afb1fe69e2920e42"
          },
          {
            "type": "html",
            "text": "\nThe example given is trivial to refactor: ",
            "id": "e057e6f1afd57dcc1c6c044b3740300d"
          },
          {
            "type": "code",
            "text": "  func_loop() {\n    while(condition()) {\n      work1();\n      if (fatal_error()) return;\n      work2();\n    }\n  }",
            "id": "e588266c8ba9aefa8c9876192121df51"
          },
          {
            "type": "code",
            "text": "  func() {\n    func_loop();\n    x = sqrt(x) + x*x*x;\n    work3();\n    return work4();    \n  }",
            "id": "9cb4bee26ca6e36ce39ba4ad70048762"
          },
          {
            "type": "html",
            "text": "As long as the two functions are nearby in the source file, readability shouldn't suffer, and if you can give a [[Meaningful Name]] to the loop, it should even increase (as you don't need to keep the context for func() in mind when looking at the loop. But a simple variation on this becomes much more difficult to refactor:",
            "id": "74518e0546d5633c4f81490f10d1dd38"
          },
          {
            "type": "code",
            "text": "  func(num, str) {\n    x = num / 2 + 34;\n    y = substr(0, x, str);",
            "id": "afd9f5f0cac6afe3e0891f260e4a5dbe"
          },
          {
            "type": "code",
            "text": "    while(condition(x, y)) {\n      y = work1(x, str);\n      if (fatal_error()) goto done;\n      x = work2(y, num);\n    }\n    do_regular_termination(x, y);",
            "id": "04bd0df7368ad160e1386adf341a9bed"
          },
          {
            "type": "code",
            "text": "    done:\n    x = sqrt(num) * y*x*x;\n    str = work3(x, num);\n    return work4(y, str);\n  }",
            "id": "f1e5a12988d5420b80face273d3fb6fb"
          },
          {
            "type": "html",
            "text": "The addition of local variables means that [[Extract Method]] would need a parameter list of 4 variables, and would need to return both x and y (meaning a struct in most languages). The problem persists if you try to do an [[Extract Method]] on 'done:' and tail-call that from the loop and at the end of the function: you'd need to pass in x, y, and num.",
            "id": "497fec7f5a73e8e72de2a95d63d32f79"
          },
          {
            "type": "html",
            "text": "\nThis illustrates a legitimate use for [[Go To]]:  control flow transfer out of a loop where there's a large amount of lexical context that the loop requires. It also illustrates why [[Go To]] is a [[Code Smell]] - most algorithms shouldn't need this much context, and it's worth trying to see if the algorithm can be simplified before reaching for the [[Go To]]. But if it can't, it's good to have it available.",
            "id": "c08cc04529b1d2b9bfc3ad3c9f3da5bb"
          },
          {
            "type": "html",
            "text": "<i>This point about lexical context is exactly what I was trying to get at when I said:</i>",
            "id": "4e0eb63e5d4af1606b809ad6bc91eb0a"
          },
          {
            "type": "html",
            "text": "<i>Of course, the same potential problems arise here (mainly, potentially having to pass in a large amount of context) as when refactoring away [[Trivial Do While Loop]]. But how did your code ever get that complicated?</i>",
            "id": "f9998f1f72bab5cdadd27e151fc6d3b4"
          },
          {
            "type": "html",
            "text": "<i>The stuff that gets passed into the loop is the \"complication\".</i>",
            "id": "5f548375d78f52d52c3160ee5e0ee723"
          },
          {
            "type": "html",
            "text": "\nThe code example in question is not \"that complicated\".",
            "id": "7546e9dc43c5b2ee951af0e94185eb79"
          },
          {
            "type": "html",
            "text": "<i>Yes, it is, because it's contrived. It's not complicated in, say, number of statements or variables, but those are the wrong measures of complexity. Conceptually, this code is complex because it has no purpose, neither an implied nor a stated one, other than twiddling some variables (which it does with a distinctly non-obvious code flow). Pointing out that a refactoring would need a large context transfer is pointing out that this code smells -- goto or no. And \"do_regular_termination\" is a red herring: why is calling a function with </i>two<i> local variables acceptable, but not three? What exactly is \"lots of context\"?</i>",
            "id": "369efae36da11aa5d12d2a0f8f655915"
          },
          {
            "type": "html",
            "text": "<i>This example doesn't convince me that there is code that uses lots of lexical context in a loop </i>and<i> cannot be easily refactored. I see your point in theory, but dispute its application in practice. Note that the goto in this example still smells, but it smells </i>independently<i>. Break statements or exception handling both result in code that is more obvious (if not, of course, </i>shorter<i>, but that's penny wise, pound foolish). Whether these are \"gotos in disguise\" and whether that's also harmful is a separate discussion.</i>",
            "id": "1129a5689278cf7c0d8273a352d066ae"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "\nDijkstra's article really addressed the issue that a goto in the middle of a loop with an autoindex causes difficulty in understanding program flow. In that limited sense the argument is strong. He didn't address at all the use of goto in general coding practice, other than a general comment in his introduction that quality of programming was inversely related to goto density. kd4ttc",
            "id": "27f2c94c38e37a1da4bc4937eb081e50"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "\nI <i>looove</i> the labeled block in java: it makes people's hair stand on end.",
            "id": "50f5177d6d87029e8e8e71eee4a395d4"
          },
          {
            "type": "html",
            "text": "found_ok:<br>{",
            "id": "73f2f95357ae4361c5b046feefb90cd4"
          },
          {
            "type": "code",
            "text": "   for retries = 1 to 3 {\n     loop through items {\n       if we found one, break found_ok.\n     }\n     do a retry delay;\n   }\n   throw new \"oh no! none were found after 3 retries!\";\n }",
            "id": "dcc24db3a4ef219f35c0d765b1755d5c"
          },
          {
            "type": "code",
            "text": " // we found an entry ok",
            "id": "63cc96991e021675a30a78510b51cf31"
          },
          {
            "type": "html",
            "text": "<i>This is pretty awkward. It looks like a backward goto but it really is a forward goto. Confusing. Maybe they should have had it typed out \"{ ...; break found_ok; } : found_ok;\" This would clearly indicate the start and destination of the jump.</i>",
            "id": "e0507d8d70d86154aaf47a10cfa30b78"
          },
          {
            "type": "html",
            "text": "\nWhy not [[Extract Method]] it? Here's how in [[Perl Language]] you can use a sub to return a value, instead of a block and having to throw an exception:",
            "id": "81bbf94be0eaa07dbd25223513e0e7b7"
          },
          {
            "type": "code",
            "text": " sub found_ok {\n   my @items = @_; \n   foreach (@items) {\n     return 1 if $_ eq \"foo\";\n   } \n   return; # gives undef\n }",
            "id": "226a47edba1741107fba9e37ff5863eb"
          },
          {
            "type": "html",
            "text": "Then you can handle the result of the check a little more cleanly with \"if (found_ok(@things))\". Of course, this depends on if you think [[Internal Loop Exits Are Ok]] or not. You can also trivially modify the above to provide a [[Single Function Exit Point]]:",
            "id": "64963b88559190b294f6ba665eca3c70"
          },
          {
            "type": "code",
            "text": " sub found_ok {\n   my @items = @_; \n   my $success;\n   foreach (@items) {\n     $success = 1 if $_ eq \"foo\";\n   } \n   return $success;\n }",
            "id": "b32d581efa1147438e52999da09eb402"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "What about this C function:",
            "id": "b6f5d6976b6d2b21f73690c9e6f074cd"
          },
          {
            "type": "code",
            "text": " void someFunc()\n {\n   T *X1, *X2;\n   ...\n   X1 = (T*)malloc(...);\n   ...\n   if (FAILED(func1())\n     goto clean1;\n   ...\n   X2 = (T*)malloc(...);\n   ...\n   if (FAILED(func2())\n     goto clean2;\n   ...\n clean2:\n   free(X2);\n clean1:\n   free(X1);\n }",
            "id": "74808b95aa4727119f9889b8770e16c2"
          },
          {
            "type": "html",
            "text": "Am I supposed to make a function call per malloc? These gotos produce essentially the same code as would class instances with destructors in C++. Fragmenting such a function to avoid gotos can and will reduce readability, as well as force you to think up useless function names like someFuncBeforeAllocatingX2(). Sometimes this refactoring can be done nicely, sometimes not.",
            "id": "60ae4255cbf8a75972e3f163b3999825"
          },
          {
            "type": "html",
            "text": "<i>Why not use if statements? Block scope and <8 space tab widths are your friends.</i>",
            "id": "80a0bd5a6248a1910f2a0622139bc8b8"
          },
          {
            "type": "code",
            "text": " void someFunc()\n {\n   T *X1 = (T*)malloc(...);\n   ...\n   if (SUCCEEDED(func1())\n   {\n     ...\n     T *X2 = (T*)malloc(...);\n     ...\n     if (SUCCEEDED(func2())\n     {\n       ...\n     }\n     free(X2);\n   }\n   free(X1);\n }",
            "id": "65a2ff75d848b6ae8ef98c2283c190d8"
          },
          {
            "type": "html",
            "text": "If clauses are a good solution, but it bothers me that this issue of destruction interferes with the flow of the program presented to the programmer. By that I mean, in C++ the same function would look like (given T_wrapper that that does the needed [de]allocation during [de]construction and has operator T*:",
            "id": "20a07089dcd0f79722b654bda60b6bc8"
          },
          {
            "type": "html",
            "text": "\nvoid someFunc() {",
            "id": "67bbf94c5e09dec83a1114e706df7b51"
          },
          {
            "type": "code",
            "text": "  T_wrapper X1;\n  if (FAILED(func1()))\n     return;\n  ...\n  T_wrapper X2;\n  if (FAILED(func2()))\n     return;\n  ...",
            "id": "070ae9aea1f9b90c6e35bc77f0d5ea9a"
          },
          {
            "type": "html",
            "text": "}",
            "id": "ad8b4f459e3c1be337285a65ca3e2a95"
          },
          {
            "type": "html",
            "text": "\nAnd it seems to me that what I wrote looks closer to the form I want, compared with the code that puts ... inside if clauses. \nBesides, it can get more complicated than this example, if the last ... is something like two or three nested for statements that can terminate at any time, I'd like to goto cleanup2 there also.",
            "id": "e69cb594d0987570d05af6d1162922a4"
          },
          {
            "type": "html",
            "text": "\nThe gotos implement destruction; I don't think of them as part of the flow control of the \"actual\" program. I'm merely emulating C++ here. It's similar to using function pointer tables to emulate virtual in C. It looks uglier of course, but this is strictly in the syntax level. Of course, hand-crafted emulation is prone to errors, and it would be best to do it using a C++ to C compiler, if only I could find one.",
            "id": "e43c3111213ce355e000a69cb3e69bb9"
          },
          {
            "type": "html",
            "text": "<i>Why not pass a function pointer to a function that allocates T, calls the function pointer function and then deallocates T?</i>",
            "id": "4ae1caa3006c5219c0cd96910ee487d2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "That's an extra virtual call (call [ecx]) per allocation, and you have to split someFunc() into parts (each time you allocate something, you need another function like someFuncAfter3Allocations()) which is exactly what I was trying to avoid. I don't see how that is more acceptable in any possible sense than using cleanup labels at the end to emulate destruction.",
            "id": "42b89862691803e4d7e98721b993cdd7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "Idea: How about matching each goto with a [[Come From]] into a [[Goto Come From Pair]] so that gotos are only allowed from sources explicitly named at the target label?",
            "id": "1550c60ac3480d224154afdd02726f01"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "See: [[Go To]], [[Recv Considered Harmful]], [[Else Considered Smelly]], [[Return Considered Smelly]], [[Objective Evidence Against Gotos]]",
            "id": "32a23a9c5512ba9cfe592d71466ec82d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "4f5e151380a2e9c2844ae326efb86389"
          },
          {
            "type": "html",
            "text": "[[Category Branching And Flow]]",
            "id": "22d5e3dabf92634fbed65d1085b1aae3"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?GotoConsideredHarmful c2.com]",
            "id": "a962c610f9b2e2bcae75d54a10e149b2"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1631984844313
    }
  ]
}