{
  "title": "Fuel",
  "story": [
    {
      "type": "markdown",
      "id": "8bfbaf0ea8a459fe",
      "text": " is a fast open-source general-purpose binary object serialization framework developed by Mariano Martinez-Peck, Martìn Dias and Max Leske. [https://book.huihoo.com/smalltalk/pharo/enterprise-pharo/book-result/Fuel/Fuel.html page]\n\n"
    },
    {
      "type": "markdown",
      "id": "fd8a12fef6f61dcc",
      "text": "Part of the speed of Fuel comes from the idea that objects are loaded more often than stored. This makes it worth to spend more time while storing to yield faster loading. Also, its storage scheme is based on the pickle format that puts similar objects into groups for efficiency and performance. As a result, Fuel has been shown to be one of the fastest object loaders, while still being a really fast object saver. Moreover, Fuel can serialize nearly any object in the image, it can even serialize a full execution stack and later reload it! "
    },
    {
      "type": "markdown",
      "id": "4c43c441b0b3ffd2",
      "text": "In the context of the `IDRAChangesHandler` the changes are retrieved from an `EpMonitor`, then these changes are serialized using *Fuel* [DPDA11] on the\ncommunication channel with other `IDRAChangesHandlers` and finally the store is reset, starting a new Epicea session. The reset is necessary because otherwise the next changes will include the old ones."
    },
    {
      "type": "markdown",
      "id": "fbec32a71a554683",
      "text": "[DPDA11] Mart ́ın Dias, Mariano Martinez Peck, St ́ephane Ducasse, and Gabriela Ar ́evalo. Clustered serialization with fuel. In Proceedings of the International Workshop on Smalltalk Technologies, IWST ’11, pages 1:1–1:13, New York, NY, USA, 2011. ACM"
    },
    {
      "type": "paragraph",
      "id": "5b6592a08bce1ee3",
      "text": "DIAS, Martín, PECK, Mariano Martinez, DUCASSE, Stéphane and ARÉVALO, Gabriela, 2011. Clustered serialization with fuel. In: Proceedings of the International Workshop on Smalltalk Technologies. Online. New York, NY, USA: Association for Computing Machinery. 23 August 2011. p. 1–13. [Accessed 8 June 2021]. IWST ’11. ISBN 978-1-4503-1050-5. DOI 10.1145/2166929.2166930. "
    },
    {
      "type": "markdown",
      "id": "3821697eee4ccb70",
      "text": "> Serializing object graphs is an important activity since objects should be stored and reloaded on different environments. There is a plethora of frameworks to serialize objects based on recursive parsing of the object graphs. However such approaches are often too slow. Most approaches are limited in their provided features. For example, several serializers do not support class shape changes, global references, transient references or hooks to execute something before or after being stored or loaded. Moreover, to be faster, some serializers are not written taking into account the object-oriented paradigm and they are sometimes even implemented in the Virtual Machine hampering code portability. VM-based serializers such as ImageSegment are difficult to understand, maintain, and fix. For the final user, it means a serializer which is difficult to customize, adapt or extend to his own needs. In this paper we present a general purpose object graph serializer based on a pickling format and algorithm. We implement and validate this approach in the Pharo Smalltalk environment. We demonstrate that we can build a really fast serializer without specific VM support, with a clean object-oriented design, and providing most possible required features for a serializer. We show that our approach is faster that traditional serializers and compare favorably with ImageSegment as soon as serialized objects are not in isolation.\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Fuel",
        "story": []
      },
      "date": 1630491090566
    },
    {
      "item": {
        "type": "factory",
        "id": "c207f17116339aa7"
      },
      "id": "c207f17116339aa7",
      "type": "add",
      "date": 1630491092080
    },
    {
      "type": "remove",
      "id": "c207f17116339aa7",
      "date": 1630491094825
    },
    {
      "item": {
        "type": "factory",
        "id": "be3e0e5a4e6e1ec6"
      },
      "id": "be3e0e5a4e6e1ec6",
      "type": "add",
      "date": 1630491108895
    },
    {
      "type": "remove",
      "id": "be3e0e5a4e6e1ec6",
      "date": 1630491110179
    },
    {
      "item": {
        "type": "factory",
        "id": "8bfbaf0ea8a459fe"
      },
      "id": "8bfbaf0ea8a459fe",
      "type": "add",
      "date": 1630491111109
    },
    {
      "type": "edit",
      "id": "8bfbaf0ea8a459fe",
      "item": {
        "type": "markdown",
        "id": "8bfbaf0ea8a459fe",
        "text": "In the context of the IDRAChangesHandler the changes are retrieved from\nan EpMonitor, then these changes are serialized using Fuel [DPDA11] on the\ncommunication channel with other IDRAChangesHandlers and finally the store\nis reset, starting a new Epicea session. The reset is necessary because otherwise\nthe next changes will include the old ones."
      },
      "date": 1630491113259
    },
    {
      "type": "edit",
      "id": "8bfbaf0ea8a459fe",
      "item": {
        "type": "markdown",
        "id": "8bfbaf0ea8a459fe",
        "text": "In the context of the `IDRAChangesHandler` the changes are retrieved from an `EpMonitor`, then these changes are serialized using [[Fuel]] [DPDA11] on the\ncommunication channel with other `IDRAChangesHandlers` and finally the store is reset, starting a new Epicea session. The reset is necessary because otherwise the next changes will include the old ones."
      },
      "date": 1630491170609
    },
    {
      "item": {
        "type": "factory",
        "id": "d43a9c113466b323"
      },
      "id": "d43a9c113466b323",
      "type": "add",
      "after": "8bfbaf0ea8a459fe",
      "date": 1630491197610
    },
    {
      "type": "remove",
      "id": "d43a9c113466b323",
      "date": 1630491198497
    },
    {
      "item": {
        "type": "factory",
        "id": "fbec32a71a554683"
      },
      "id": "fbec32a71a554683",
      "type": "add",
      "after": "8bfbaf0ea8a459fe",
      "date": 1630491199342
    },
    {
      "type": "edit",
      "id": "fbec32a71a554683",
      "item": {
        "type": "markdown",
        "id": "fbec32a71a554683",
        "text": "102 BIBLIOGRAPHY\nObject-oriented Programming, Systems, Languages, and Applica-\ntions, OOPSLA ’04, pages 331–344, New York, NY, USA, 2004.\nACM.\n[CKDP17] Steven Costiou, Micka ̈el Kerboeuf, Marcus Denker, and Alain\nPlantec. Unanticipated debugging with dynamic layers. Accepted\nfor publication (Apr. 2017), Live Adaptation of Software SYstems,\n2017.\n[DCD13] Martin Dias, Damien Cassou, and St ́ephane Ducasse. Represent-\ning code history with development environment events. CoRR,\nabs/1309.4334, 2013.\n[DG08] Jeffrey Dean and Sanjay Ghemawat. Mapreduce: Simplified data\nprocessing on large clusters. Commun. ACM, 51(1):107–113, Jan-\nuary 2008.\n[DPDA11] Mart ́ın Dias, Mariano Martinez Peck, St ́ephane Ducasse, and\nGabriela Ar ́evalo. Clustered serialization with fuel. In Proceedings\nof the International Workshop on Smalltalk Technologies, IWST\n’11, pages 1:1–1:13, New York, NY, USA, 2011. ACM"
      },
      "date": 1630491201266
    },
    {
      "type": "edit",
      "id": "fbec32a71a554683",
      "item": {
        "type": "markdown",
        "id": "fbec32a71a554683",
        "text": "\n[DPDA11] Mart ́ın Dias, Mariano Martinez Peck, St ́ephane Ducasse, and Gabriela Ar ́evalo. Clustered serialization with fuel. In Proceedings\nof the International Workshop on Smalltalk Technologies, IWST ’11, pages 1:1–1:13, New York, NY, USA, 2011. ACM"
      },
      "date": 1630491232955
    },
    {
      "type": "edit",
      "id": "fbec32a71a554683",
      "item": {
        "type": "markdown",
        "id": "fbec32a71a554683",
        "text": "[DPDA11] Mart ́ın Dias, Mariano Martinez Peck, St ́ephane Ducasse, and Gabriela Ar ́evalo. Clustered serialization with fuel. In Proceedings of the International Workshop on Smalltalk Technologies, IWST ’11, pages 1:1–1:13, New York, NY, USA, 2011. ACM"
      },
      "date": 1630491240683
    },
    {
      "item": {
        "type": "factory",
        "id": "5b6592a08bce1ee3"
      },
      "id": "5b6592a08bce1ee3",
      "type": "add",
      "after": "fbec32a71a554683",
      "date": 1666620714757
    },
    {
      "type": "edit",
      "id": "5b6592a08bce1ee3",
      "item": {
        "type": "paragraph",
        "id": "5b6592a08bce1ee3",
        "text": "\nDIAS, Martín, PECK, Mariano Martinez, DUCASSE, Stéphane and ARÉVALO, Gabriela, 2011. Clustered serialization with fuel. In: Proceedings of the International Workshop on Smalltalk Technologies. Online. New York, NY, USA: Association for Computing Machinery. 23 August 2011. p. 1–13. [Accessed 8 June 2021]. IWST ’11. ISBN 978-1-4503-1050-5. DOI 10.1145/2166929.2166930. Serializing object graphs is an important activity since objects should be stored and reloaded on different environments. There is a plethora of frameworks to serialize objects based on recursive parsing of the object graphs. However such approaches are often too slow. Most approaches are limited in their provided features. For example, several serializers do not support class shape changes, global references, transient references or hooks to execute something before or after being stored or loaded. Moreover, to be faster, some serializers are not written taking into account the object-oriented paradigm and they are sometimes even implemented in the Virtual Machine hampering code portability. VM-based serializers such as ImageSegment are difficult to understand, maintain, and fix. For the final user, it means a serializer which is difficult to customize, adapt or extend to his own needs. In this paper we present a general purpose object graph serializer based on a pickling format and algorithm. We implement and validate this approach in the Pharo Smalltalk environment. We demonstrate that we can build a really fast serializer without specific VM support, with a clean object-oriented design, and providing most possible required features for a serializer. We show that our approach is faster that traditional serializers and compare favorably with ImageSegment as soon as serialized objects are not in isolation.\n"
      },
      "date": 1666620717072
    },
    {
      "type": "edit",
      "id": "5b6592a08bce1ee3",
      "item": {
        "type": "paragraph",
        "id": "5b6592a08bce1ee3",
        "text": "DIAS, Martín, PECK, Mariano Martinez, DUCASSE, Stéphane and ARÉVALO, Gabriela, 2011. Clustered serialization with fuel. In: Proceedings of the International Workshop on Smalltalk Technologies. Online. New York, NY, USA: Association for Computing Machinery. 23 August 2011. p. 1–13. [Accessed 8 June 2021]. IWST ’11. ISBN 978-1-4503-1050-5. DOI 10.1145/2166929.2166930. "
      },
      "date": 1666620728725
    },
    {
      "type": "add",
      "id": "3821697eee4ccb70",
      "item": {
        "type": "paragraph",
        "id": "3821697eee4ccb70",
        "text": "> Serializing object graphs is an important activity since objects should be stored and reloaded on different environments. There is a plethora of frameworks to serialize objects based on recursive parsing of the object graphs. However such approaches are often too slow. Most approaches are limited in their provided features. For example, several serializers do not support class shape changes, global references, transient references or hooks to execute something before or after being stored or loaded. Moreover, to be faster, some serializers are not written taking into account the object-oriented paradigm and they are sometimes even implemented in the Virtual Machine hampering code portability. VM-based serializers such as ImageSegment are difficult to understand, maintain, and fix. For the final user, it means a serializer which is difficult to customize, adapt or extend to his own needs. In this paper we present a general purpose object graph serializer based on a pickling format and algorithm. We implement and validate this approach in the Pharo Smalltalk environment. We demonstrate that we can build a really fast serializer without specific VM support, with a clean object-oriented design, and providing most possible required features for a serializer. We show that our approach is faster that traditional serializers and compare favorably with ImageSegment as soon as serialized objects are not in isolation.\n"
      },
      "after": "5b6592a08bce1ee3",
      "date": 1666620729530
    },
    {
      "type": "edit",
      "id": "3821697eee4ccb70",
      "item": {
        "type": "markdown",
        "id": "3821697eee4ccb70",
        "text": "> Serializing object graphs is an important activity since objects should be stored and reloaded on different environments. There is a plethora of frameworks to serialize objects based on recursive parsing of the object graphs. However such approaches are often too slow. Most approaches are limited in their provided features. For example, several serializers do not support class shape changes, global references, transient references or hooks to execute something before or after being stored or loaded. Moreover, to be faster, some serializers are not written taking into account the object-oriented paradigm and they are sometimes even implemented in the Virtual Machine hampering code portability. VM-based serializers such as ImageSegment are difficult to understand, maintain, and fix. For the final user, it means a serializer which is difficult to customize, adapt or extend to his own needs. In this paper we present a general purpose object graph serializer based on a pickling format and algorithm. We implement and validate this approach in the Pharo Smalltalk environment. We demonstrate that we can build a really fast serializer without specific VM support, with a clean object-oriented design, and providing most possible required features for a serializer. We show that our approach is faster that traditional serializers and compare favorably with ImageSegment as soon as serialized objects are not in isolation.\n"
      },
      "date": 1666620730756
    },
    {
      "type": "edit",
      "id": "8bfbaf0ea8a459fe",
      "item": {
        "type": "markdown",
        "id": "8bfbaf0ea8a459fe",
        "text": " is a fast open-source general-purpose binary object serialization framework developed by Mariano Martinez-Peck, Martìn Dias and Max Leske. \n"
      },
      "date": 1666620940813
    },
    {
      "type": "add",
      "id": "4c43c441b0b3ffd2",
      "item": {
        "type": "markdown",
        "id": "4c43c441b0b3ffd2",
        "text": "In the context of the `IDRAChangesHandler` the changes are retrieved from an `EpMonitor`, then these changes are serialized using [[Fuel]] [DPDA11] on the\ncommunication channel with other `IDRAChangesHandlers` and finally the store is reset, starting a new Epicea session. The reset is necessary because otherwise the next changes will include the old ones."
      },
      "after": "8bfbaf0ea8a459fe",
      "date": 1666620942334
    },
    {
      "type": "edit",
      "id": "8bfbaf0ea8a459fe",
      "item": {
        "type": "markdown",
        "id": "8bfbaf0ea8a459fe",
        "text": " is a fast open-source general-purpose binary object serialization framework developed by Mariano Martinez-Peck, Martìn Dias and Max Leske. [https://book.huihoo.com/smalltalk/pharo/enterprise-pharo/book-result/Fuel/Fuel.html page]\n"
      },
      "date": 1666620968762
    },
    {
      "type": "edit",
      "id": "8bfbaf0ea8a459fe",
      "item": {
        "type": "markdown",
        "id": "8bfbaf0ea8a459fe",
        "text": " is a fast open-source general-purpose binary object serialization framework developed by Mariano Martinez-Peck, Martìn Dias and Max Leske. [https://book.huihoo.com/smalltalk/pharo/enterprise-pharo/book-result/Fuel/Fuel.html page]\n\n"
      },
      "date": 1666621037842
    },
    {
      "type": "add",
      "id": "fd8a12fef6f61dcc",
      "item": {
        "type": "markdown",
        "id": "fd8a12fef6f61dcc",
        "text": "Part of the speed of Fuel comes from the idea that objects are loaded more often than stored. This makes it worth to spend more time while storing to yield faster loading. Also, its storage scheme is based on the pickle format that puts similar objects into groups for efficiency and performance. As a result, Fuel has been shown to be one of the fastest object loaders, while still being a really fast object saver. Moreover, Fuel can serialize nearly any object in the image, it can even serialize a full execution stack and later reload it! "
      },
      "after": "8bfbaf0ea8a459fe",
      "date": 1666621038591
    },
    {
      "type": "edit",
      "id": "4c43c441b0b3ffd2",
      "item": {
        "type": "markdown",
        "id": "4c43c441b0b3ffd2",
        "text": "In the context of the `IDRAChangesHandler` the changes are retrieved from an `EpMonitor`, then these changes are serialized using *Fuel* [DPDA11] on the\ncommunication channel with other `IDRAChangesHandlers` and finally the store is reset, starting a new Epicea session. The reset is necessary because otherwise the next changes will include the old ones."
      },
      "date": 1666624092359
    }
  ]
}