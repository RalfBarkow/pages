{
  "title": "Tight Field Coupling",
  "story": [
    {
      "type": "html",
      "text": "[[Tight Field Coupling]] is a characteristic of object oriented and structured languages in which the members of each class/object are tightly coupled to each other. This means that if you want to only use some of them, or you want to add more, you have to do this in multiple places in your application and then recompile. Worse yet, if you want to do clever things with your fields like display a list of them, you must use reflection or some other clumsy approach to get at the compiled definitions. The problem isn't really the fault of object orientation because it actually predates object orientation. The problem was introduced when we introduced structures. The structures paradigm has been useful for many years but it is now running out of steam.",
      "id": "2ea173a7ccc4f9da76506fd634cfe8ad"
    },
    {
      "type": "html",
      "text": "Aren't members of Objects supposed to be \"tightly coupled\"?  What distinguishes this from [[Encapsulation Definition]]?",
      "id": "92f1dfa82d18349a9cc97f5a94d8de6b"
    },
    {
      "type": "html",
      "text": "Of course they are. Nothing distinguieshes it from that. I think the hinted problem is that there is no way to express the coupling of fields in an abstract way. Synchrony of fields can be stablished only by manually coding the updates in both direction. This problem also manifests itself with tightly couples fields in different classes. If you update one of them (be it by setter, some mutation or reflection) you always have to have some means to update all the related fields. You can do so by provising sufficiently refactored code for the fields in question, but that can be laborius. ",
      "id": "a50ea984701b6259f24739a19fa8395e"
    },
    {
      "type": "html",
      "text": "You might consider the [[Observer Pattern]] to avoid duplication of data.",
      "id": "b9651eeb235db448d7a3f05ea0882d4f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b9c532406db13d8cfd23106808e1320f"
    },
    {
      "type": "html",
      "text": "\nOne possible solution is a [[Data Dictionary]], either in code or a database. However, having new or changed fields automatically propagate into various sub-systems can be problematic if you don't carefully test each one to make sure there are no unintended consequences. It also takes experience to use DD's effectively. In my opinion they would be superior to the code-centric alternatives, but more developers would have to get used to them to avoid them becoming a maintenance risk, as replacement staff won't be used to them. [[Qwerty Syndrome]].",
      "id": "2fe2f4bd7cb0a9b317e1c96b9e3dc1fd"
    },
    {
      "type": "html",
      "text": "<i>How does a [[Data Dictionary]] help with this [[Tight Field Coupling]]?</i>",
      "id": "7fd507cef6091637f5af3fd8a0c87c82"
    },
    {
      "type": "html",
      "text": "<i>In general, use of explicit, specific by-value references -- whether identifiers or foreign keys -- results in tight coupling and/or brittle code.  Unfortunately, alternatives are almost invariably complex and/or risk ambiguity.  The solution is to reliably propagate changes, rather than change how references are done.</i>",
      "id": "b7f14f1f2405ec4ba8294b8f73664141"
    },
    {
      "type": "html",
      "text": "\nIt depends how you define \"coupling\", which is not an easy task.  It's not always easy or practical to know that changing X will break Y. It's a matter of balancing the frequency and magnitude of risks with labor costs. Manual propagation tends to force one to check out each module for impact, but is labor-intensive. Auto-propagation may save a lot of up-front labor, but can create panic situations when something unexpected breaks. [[Software Engineering Is Art Of Compromise]]. -t",
      "id": "b5f8ec95d2503b865a7d8a7de7600220"
    },
    {
      "type": "html",
      "text": "\nFor an typical example of breakage, adding a new field may result in a new field propagating to a printed report (or screen), making the report too wide to fit on the paper, creating either truncated columns or screwy wrapped formatting.  A change impact analysis would normally bring one to ask if the new field is suppose to show up on each report; and if there is no room, what other field gets taken out to make room. -t",
      "id": "c1a3d5e02a80e7be0df247821e43ece0"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?TightFieldCoupling c2.com]",
      "id": "82b11b261d85d40f0990ee17f8f8e5fd"
    }
  ],
  "journal": [
    {
      "date": 1366740990000,
      "id": "23d95ae6193b2937032ba51c279791da",
      "type": "create",
      "item": {
        "title": "Tight Field Coupling",
        "story": [
          {
            "type": "html",
            "text": "[[Tight Field Coupling]] is a characteristic of object oriented and structured languages in which the members of each class/object are tightly coupled to each other. This means that if you want to only use some of them, or you want to add more, you have to do this in multiple places in your application and then recompile. Worse yet, if you want to do clever things with your fields like display a list of them, you must use reflection or some other clumsy approach to get at the compiled definitions. The problem isn't really the fault of object orientation because it actually predates object orientation. The problem was introduced when we introduced structures. The structures paradigm has been useful for many years but it is now running out of steam.",
            "id": "2ea173a7ccc4f9da76506fd634cfe8ad"
          },
          {
            "type": "html",
            "text": "Aren't members of Objects supposed to be \"tightly coupled\"?  What distinguishes this from [[Encapsulation Definition]]?",
            "id": "92f1dfa82d18349a9cc97f5a94d8de6b"
          },
          {
            "type": "html",
            "text": "Of course they are. Nothing distinguieshes it from that. I think the hinted problem is that there is no way to express the coupling of fields in an abstract way. Synchrony of fields can be stablished only by manually coding the updates in both direction. This problem also manifests itself with tightly couples fields in different classes. If you update one of them (be it by setter, some mutation or reflection) you always have to have some means to update all the related fields. You can do so by provising sufficiently refactored code for the fields in question, but that can be laborius. ",
            "id": "a50ea984701b6259f24739a19fa8395e"
          },
          {
            "type": "html",
            "text": "You might consider the [[Observer Pattern]] to avoid duplication of data.",
            "id": "b9651eeb235db448d7a3f05ea0882d4f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b9c532406db13d8cfd23106808e1320f"
          },
          {
            "type": "html",
            "text": "\nOne possible solution is a [[Data Dictionary]], either in code or a database. However, having new or changed fields automatically propagate into various sub-systems can be problematic if you don't carefully test each one to make sure there are no unintended consequences. It also takes experience to use DD's effectively. In my opinion they would be superior to the code-centric alternatives, but more developers would have to get used to them to avoid them becoming a maintenance risk, as replacement staff won't be used to them. [[Qwerty Syndrome]].",
            "id": "2fe2f4bd7cb0a9b317e1c96b9e3dc1fd"
          },
          {
            "type": "html",
            "text": "<i>How does a [[Data Dictionary]] help with this [[Tight Field Coupling]]?</i>",
            "id": "7fd507cef6091637f5af3fd8a0c87c82"
          },
          {
            "type": "html",
            "text": "<i>In general, use of explicit, specific by-value references -- whether identifiers or foreign keys -- results in tight coupling and/or brittle code.  Unfortunately, alternatives are almost invariably complex and/or risk ambiguity.  The solution is to reliably propagate changes, rather than change how references are done.</i>",
            "id": "b7f14f1f2405ec4ba8294b8f73664141"
          },
          {
            "type": "html",
            "text": "\nIt depends how you define \"coupling\", which is not an easy task.  It's not always easy or practical to know that changing X will break Y. It's a matter of balancing the frequency and magnitude of risks with labor costs. Manual propagation tends to force one to check out each module for impact, but is labor-intensive. Auto-propagation may save a lot of up-front labor, but can create panic situations when something unexpected breaks. [[Software Engineering Is Art Of Compromise]]. -t",
            "id": "b5f8ec95d2503b865a7d8a7de7600220"
          },
          {
            "type": "html",
            "text": "\nFor an typical example of breakage, adding a new field may result in a new field propagating to a printed report (or screen), making the report too wide to fit on the paper, creating either truncated columns or screwy wrapped formatting.  A change impact analysis would normally bring one to ask if the new field is suppose to show up on each report; and if there is no room, what other field gets taken out to make room. -t",
            "id": "c1a3d5e02a80e7be0df247821e43ece0"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?TightFieldCoupling c2.com]",
            "id": "82b11b261d85d40f0990ee17f8f8e5fd"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1676882680679
    }
  ]
}