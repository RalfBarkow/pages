{
  "title": "Sizing Grammar and Language",
  "story": [
    {
      "type": "paragraph",
      "id": "c8ed1d2c4a32a359",
      "text": "We consider compiler implementation considerations as concrete evidence for categorizing generative structures like pattern language and causal loop diagrams. [https://app.element.io/#/room/#fedwiki:matrix.org/$1670207224123927sGXRv:matrix.org matrix]"
    },
    {
      "type": "paragraph",
      "id": "5454a2dc992e1fc7",
      "text": "In compilers, typically syntax provide local rules to recognize tokens but doesn't remember anything it has decided. The grammar is matched against tokens where one token lookahead plus memory of what has been seen (a parse stack) is enough information to recognize what grammar rule applies. The syntax and grammar will determine which of all possible inputs are allowed in the language. "
    },
    {
      "type": "html",
      "id": "de5a8a3f39a3fa9a",
      "text": "Consider arithmetic expressions such as <code>5*(2+3)</code>."
    },
    {
      "type": "paragraph",
      "id": "d40131511af1feb4",
      "text": "Syntax rules would Identify numbers vs operators and can do that with fixed space.\n"
    },
    {
      "type": "html",
      "id": "c04d0ce4141dd94d",
      "text": "The grammar rules would say that open and closed parens must match using its stack which will grow in proportion to the depth of paren nesting.\nExpressions <code>5*((2+3))</code> and <code>5*(((2+3)))</code> are equivalent but take proportionally more stack to establish this. We can limit the size of the stack by say that parens can only be nested 10 deep."
    },
    {
      "type": "paragraph",
      "id": "fc89245a778f7139",
      "text": "We can ask, how many allowed ways are there to parenthesize this expression? This is like asking how big is this part of the language and the answer is quite big. Consider the many ways to add parens without violating our 10 max limit.\n"
    },
    {
      "type": "code",
      "id": "ac5b9c31c775ec81",
      "text": "5*(2+3)\n(5)*(2+3)\n((5))*(2+3)\n((5))*((2+3))\n((5))*((2)+3)\n((5))*(2+(3))\n(5*(2+3))\n((5)*(2+3)) "
    },
    {
      "type": "paragraph",
      "id": "9ec52006190b3ad2",
      "text": "Here we haven't yet exhausted the possibilities going only 2 deep in parens. We can guess how many ways we can parenthesize this by noting there are 3 numbers plus 2 operations making 5 places to add up to 10 extra parens. I think that comes out to 5^10 which is close to 10 million.\n"
    },
    {
      "type": "paragraph",
      "id": "2fa1a0f92e9dfed3",
      "text": "We started by talking about what kinds things can be called a language versus syntax or grammar. I've made a counting argument based on how quickly my choices grow or how the memory required of a compiler grows.\nThe same kind of arguments can be made about CLDs which seem most similar to a grammar but similarly could be said to describe systems that could have quickly billions of state.\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Sizing Grammar and Language",
        "story": []
      },
      "date": 1670253745212
    },
    {
      "item": {
        "type": "factory",
        "id": "c8ed1d2c4a32a359"
      },
      "id": "c8ed1d2c4a32a359",
      "type": "add",
      "date": 1670253794954
    },
    {
      "type": "edit",
      "id": "c8ed1d2c4a32a359",
      "item": {
        "type": "paragraph",
        "id": "c8ed1d2c4a32a359",
        "text": "We consider compiler implementation considerations as concrete evidence for categorizing generative structures like pattern language and causal loop diagrams."
      },
      "date": 1670253925051
    },
    {
      "type": "edit",
      "id": "c8ed1d2c4a32a359",
      "item": {
        "type": "paragraph",
        "id": "c8ed1d2c4a32a359",
        "text": "We consider compiler implementation considerations as concrete evidence for categorizing generative structures like pattern language and causal loop diagrams. [https://app.element.io/#/room/#fedwiki:matrix.org/$1670207224123927sGXRv:matrix.org matrix]"
      },
      "date": 1670253962131
    },
    {
      "item": {
        "type": "factory",
        "id": "5454a2dc992e1fc7"
      },
      "id": "5454a2dc992e1fc7",
      "type": "add",
      "after": "c8ed1d2c4a32a359",
      "date": 1670253984117
    },
    {
      "type": "edit",
      "id": "5454a2dc992e1fc7",
      "item": {
        "type": "paragraph",
        "id": "5454a2dc992e1fc7",
        "text": "In compilers, typically syntax provide local rules to recognize tokens but doesn't remember anything it has decided. The grammar is matched against tokens where one token lookahead plus memory of what has been seen (a parse stack) is enough information to recognize what grammar rule applies. The syntax and grammar will determine which of all possible inputs are allowed in the language. "
      },
      "date": 1670253988618
    },
    {
      "type": "add",
      "id": "de5a8a3f39a3fa9a",
      "item": {
        "type": "paragraph",
        "id": "de5a8a3f39a3fa9a",
        "text": "Consider arithmetic expressions such as 5*(2+3).\n"
      },
      "after": "5454a2dc992e1fc7",
      "date": 1670254046634
    },
    {
      "type": "add",
      "id": "d40131511af1feb4",
      "item": {
        "type": "paragraph",
        "id": "d40131511af1feb4",
        "text": "Syntax rules would Identify numbers vs operators and can do that with fixed space.\n"
      },
      "after": "de5a8a3f39a3fa9a",
      "date": 1670254051095
    },
    {
      "type": "add",
      "id": "c04d0ce4141dd94d",
      "item": {
        "type": "paragraph",
        "id": "c04d0ce4141dd94d",
        "text": "The grammar rules would say that open and closed parens must match using its stack which will grow in proportion to the depth of paren nesting.\nExpressions 5*((2+3)) and 5*(((2+3))) are equivalent but take proportionally more stack to establish this. We can limit the size of the stack by say that parens can only be nested 10 deep.\n"
      },
      "after": "d40131511af1feb4",
      "date": 1670254059898
    },
    {
      "type": "add",
      "id": "fc89245a778f7139",
      "item": {
        "type": "paragraph",
        "id": "fc89245a778f7139",
        "text": "We can ask, how many allowed ways are there to parenthesize this expression? This is like asking how big is this part of the language and the answer is quite big. Consider the many ways to add parens without violating our 10 max limit.\n"
      },
      "after": "c04d0ce4141dd94d",
      "date": 1670254069625
    },
    {
      "type": "add",
      "id": "ac5b9c31c775ec81",
      "item": {
        "type": "paragraph",
        "id": "ac5b9c31c775ec81",
        "text": "5*(2+3)\n(5)*(2+3)\n((5))*(2+3)\n((5))*((2+3))\n((5))*((2)+3)\n((5))*(2+(3))\n(5*(2+3))\n((5)*(2+3))\n"
      },
      "after": "fc89245a778f7139",
      "date": 1670254078565
    },
    {
      "type": "add",
      "id": "9ec52006190b3ad2",
      "item": {
        "type": "paragraph",
        "id": "9ec52006190b3ad2",
        "text": "Here we haven't yet exhausted the possibilities going only 2 deep in parens. We can guess how many ways we can parenthesize this by noting there are 3 numbers plus 2 operations making 5 places to add up to 10 extra parens. I think that comes out to 5^10 which is close to 10 million.\n"
      },
      "after": "ac5b9c31c775ec81",
      "date": 1670254087955
    },
    {
      "type": "add",
      "id": "2fa1a0f92e9dfed3",
      "item": {
        "type": "paragraph",
        "id": "2fa1a0f92e9dfed3",
        "text": "We started by talking about what kinds things can be called a language versus syntax or grammar. I've made a counting argument based on how quickly my choices grow or how the memory required of a compiler grows.\nThe same kind of arguments can be made about CLDs which seem most similar to a grammar but similarly could be said to describe systems that could have quickly billions of state.\n"
      },
      "after": "9ec52006190b3ad2",
      "date": 1670254107293
    },
    {
      "type": "edit",
      "id": "de5a8a3f39a3fa9a",
      "item": {
        "type": "factory",
        "id": "de5a8a3f39a3fa9a",
        "text": "Consider arithmetic expressions such as 5*(2+3)."
      },
      "date": 1670254135501
    },
    {
      "type": "edit",
      "id": "de5a8a3f39a3fa9a",
      "item": {
        "type": "html",
        "id": "de5a8a3f39a3fa9a",
        "text": "Consider arithmetic expressions such as <code>5*(2+3)</code>."
      },
      "date": 1670254150531
    },
    {
      "type": "edit",
      "id": "c04d0ce4141dd94d",
      "item": {
        "type": "html",
        "id": "c04d0ce4141dd94d",
        "text": "The grammar rules would say that open and closed parens must match using its stack which will grow in proportion to the depth of paren nesting.\nExpressions <code>5*((2+3))</code> and <code>5*(((2+3)))</code> are equivalent but take proportionally more stack to establish this. We can limit the size of the stack by say that parens can only be nested 10 deep."
      },
      "date": 1670254196660
    },
    {
      "type": "edit",
      "id": "ac5b9c31c775ec81",
      "item": {
        "type": "factory",
        "id": "ac5b9c31c775ec81",
        "text": "5*(2+3)\n(5)*(2+3)\n((5))*(2+3)\n((5))*((2+3))\n((5))*((2)+3)\n((5))*(2+(3))\n(5*(2+3))\n((5)*(2+3))"
      },
      "date": 1670254211366
    },
    {
      "type": "edit",
      "id": "ac5b9c31c775ec81",
      "item": {
        "type": "code",
        "id": "ac5b9c31c775ec81",
        "text": "5*(2+3)\n(5)*(2+3)\n((5))*(2+3)\n((5))*((2+3))\n((5))*((2)+3)\n((5))*(2+(3))\n(5*(2+3))\n((5)*(2+3)) "
      },
      "date": 1670254219587
    },
    {
      "type": "fork",
      "site": "ward.dojo.fed.wiki",
      "date": 1670937011104
    }
  ]
}