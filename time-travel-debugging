{
  "title": "Time Travel Debugging",
  "story": [
    {
      "type": "paragraph",
      "id": "eeefc4dd09b33c18",
      "text": "or time traveling debugging is the process of stepping back in time through source code to understand what is happening during execution of a computer program. [https://en.wikipedia.org/wiki/Time_travel_debugging wikipedia] "
    },
    {
      "type": "paragraph",
      "id": "8cd234694c4b2c2d",
      "text": "enables developers to view all past actions and state changes in their application."
    },
    {
      "type": "paragraph",
      "id": "da6e1c7229ebbfd9",
      "text": "LE, Duc Anh, 2023. E-Commercial Full Stack Web Application Development: with React, Redux, NodeJS, and MongoDB. "
    },
    {
      "type": "paragraph",
      "id": "ea00fd9c32487fad",
      "text": "Additionally, developers can easily view and analyze an application's entire state history, allowing them to determine where a problem may have occurred."
    },
    {
      "type": "pagefold",
      "id": "e7f0a5bae6753045",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "ac126bf9b7a2098a",
      "text": "MVI which stands for Model-View-Intent is an architectural pattern characterized for the flow of data in an unidirectional way. Flow of data from the model to the view and from the view to the model. A simple schema of the model can be viewed in the next figure."
    },
    {
      "type": "image",
      "id": "1a9d09120e7c902f",
      "text": "Sample MVI pattern",
      "size": "wide",
      "width": 419,
      "height": 326,
      "url": "/assets/plugins/image/31b4cb69fa6073870ef8f1c084071a60.jpg"
    },
    {
      "type": "paragraph",
      "id": "7e97d0eb11d2fffd",
      "text": "OROZCO GONZÁLEZ, Andrés Felipe, 2023. back-in-time debugger in Kotlin. "
    },
    {
      "type": "paragraph",
      "id": "7ad41d6477af162d",
      "text": "This dissertation explores a back-in-time debugger implementation for Kotlin based in the MVIKotlin framework."
    },
    {
      "type": "paragraph",
      "id": "e1f11c86ad79f69c",
      "text": "Inspired by the back-in-time debugger DeloreanJS [8], this article presents a back-in-time debugger for Kotlin for reactive style developed code. This work expands on the research line for back-in-time debuggers as it introduces a new language to this form of debugging, and adds on the ways to implement a back-in-time debugger from using continuations as used in DeloreanJS to using a MVI architecture and storing previous states of the application to enable it to swap the current state to previous states and re-run the code from a point on."
    },
    {
      "type": "paragraph",
      "id": "174ed16094e20c7e",
      "text": "The development of this back-in-time debugger will be built on top of https://github.com/ arkivanov/MVIKotlin [7], which provides most of the functionalities of a back-in-time debugger for Kotlin, but it does not allow the users to change previous states and debug from a given state with modifications."
    },
    {
      "type": "pagefold",
      "id": "d1c5a04ee0a52713",
      "text": "~"
    },
    {
      "type": "reference",
      "id": "f4d3442976518c91",
      "site": "elm.dreyeck.ch",
      "slug": "the-elm-architecture",
      "title": "The Elm Architecture",
      "text": "is a simple [[Pattern]] for architecting webapps. The core idea is that your code is built around a [[Model]] of your application state, a way to update your model, and a way to view your model. [https://github.com/evancz/elm-architecture-tutorial/#the-elm-architecture github]"
    },
    {
      "type": "reference",
      "id": "886794c3cfbf7d26",
      "site": "wiki.ralfbarkow.ch",
      "slug": "how-elm-fits-in",
      "title": "How Elm Fits In",
      "text": "[[Elm]] can be used either as a replacement for in-browser JavaScript code or as a complement to it."
    },
    {
      "type": "html",
      "id": "d3f9d778f3579814",
      "text": "<img\n  src = \"https://guide.elm-lang.org/architecture/buttons.svg\"\n  width = \"100%\"\n>"
    },
    {
      "type": "paragraph",
      "id": "4ae4fe8f0fb2ccf4",
      "text": "The Basic Pattern [https://guide.elm-lang.org/architecture/ page]"
    },
    {
      "type": "pagefold",
      "id": "f7acfa23dd19d24e",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "8d52e29b92ba4465",
      "text": "The Matrix Time Machine [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$168633482569207uiPNp:matrix.org?via=matrix.org&via=matrix.allmende.io&via=tchncs.de matrix], [https://github.com/matrix-org/matrix-public-archive/issues/47 github]"
    },
    {
      "type": "video",
      "id": "f56088a7075f4350",
      "text": "YOUTUBE ULbvBIwiGEI\nMatrix Live S08E25 — The Matrix Time Machine "
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Time Travel Debugging",
        "story": []
      },
      "date": 1686320901575
    },
    {
      "item": {
        "type": "factory",
        "id": "eeefc4dd09b33c18"
      },
      "id": "eeefc4dd09b33c18",
      "type": "add",
      "date": 1686320902969
    },
    {
      "type": "edit",
      "id": "eeefc4dd09b33c18",
      "item": {
        "type": "paragraph",
        "id": "eeefc4dd09b33c18",
        "text": "Time travel debugging or time traveling debugging is the process of stepping back in time through source code to understand what is happening during execution of a computer program. Typically, debugging and debuggers, tools that assist a user with the process of debugging, allow users to pause the execution of running software and inspect the current state of the program. Users can then step forward in time, stepping into or over statements and proceeding in a forward direction. Interactive debuggers include the ability to modify code and step forward based on updated information. Reverse debugging tools allow users to step backwards in time through the steps that resulted in reaching a particular point in the program. Time traveling debuggers provide these features and also allow users to interact with the program, changing the history if desired, and watch how the program responds. [ wikipedia]"
      },
      "date": 1686320926218
    },
    {
      "type": "edit",
      "id": "eeefc4dd09b33c18",
      "item": {
        "type": "paragraph",
        "id": "eeefc4dd09b33c18",
        "text": "Time travel debugging or time traveling debugging is the process of stepping back in time through source code to understand what is happening during execution of a computer program. Typically, debugging and debuggers, tools that assist a user with the process of debugging, allow users to pause the execution of running software and inspect the current state of the program. Users can then step forward in time, stepping into or over statements and proceeding in a forward direction. Interactive debuggers include the ability to modify code and step forward based on updated information. Reverse debugging tools allow users to step backwards in time through the steps that resulted in reaching a particular point in the program. Time traveling debuggers provide these features and also allow users to interact with the program, changing the history if desired, and watch how the program responds. [https://en.wikipedia.org/wiki/Time_travel_debugging wikipedia]"
      },
      "date": 1686320932535
    },
    {
      "type": "edit",
      "id": "eeefc4dd09b33c18",
      "item": {
        "type": "paragraph",
        "id": "eeefc4dd09b33c18",
        "text": "or time traveling debugging is the process of stepping back in time through source code to understand what is happening during execution of a computer program. Typically, debugging and debuggers, tools that assist a user with the process of debugging, allow users to pause the execution of running software and inspect the current state of the program. Users can then step forward in time, stepping into or over statements and proceeding in a forward direction. Interactive debuggers include the ability to modify code and step forward based on updated information. Reverse debugging tools allow users to step backwards in time through the steps that resulted in reaching a particular point in the program. Time traveling debuggers provide these features and also allow users to interact with the program, changing the history if desired, and watch how the program responds. [https://en.wikipedia.org/wiki/Time_travel_debugging wikipedia]"
      },
      "date": 1686386979131
    },
    {
      "type": "edit",
      "id": "eeefc4dd09b33c18",
      "item": {
        "type": "paragraph",
        "id": "eeefc4dd09b33c18",
        "text": "or time traveling debugging is the process of stepping back in time through source code to understand what is happening during execution of a computer program.  [https://en.wikipedia.org/wiki/Time_travel_debugging wikipedia] and watch how the program responds."
      },
      "date": 1686386998877
    },
    {
      "type": "edit",
      "id": "eeefc4dd09b33c18",
      "item": {
        "type": "paragraph",
        "id": "eeefc4dd09b33c18",
        "text": "or time traveling debugging is the process of stepping back in time through source code to understand what is happening during execution of a computer program.  [https://en.wikipedia.org/wiki/Time_travel_debugging wikipedia] "
      },
      "date": 1686387006064
    },
    {
      "type": "edit",
      "id": "eeefc4dd09b33c18",
      "item": {
        "type": "paragraph",
        "id": "eeefc4dd09b33c18",
        "text": "or time traveling debugging is the process of stepping back in time through source code to understand what is happening during execution of a computer program. [https://en.wikipedia.org/wiki/Time_travel_debugging wikipedia] "
      },
      "date": 1686387012314
    },
    {
      "item": {
        "type": "factory",
        "id": "8cd234694c4b2c2d"
      },
      "id": "8cd234694c4b2c2d",
      "type": "add",
      "after": "eeefc4dd09b33c18",
      "date": 1686387052607
    },
    {
      "type": "edit",
      "id": "8cd234694c4b2c2d",
      "item": {
        "type": "paragraph",
        "id": "8cd234694c4b2c2d",
        "text": "enables developers to view all past actions and state changes in their application."
      },
      "date": 1686387053868
    },
    {
      "item": {
        "type": "factory",
        "id": "da6e1c7229ebbfd9"
      },
      "id": "da6e1c7229ebbfd9",
      "type": "add",
      "after": "8cd234694c4b2c2d",
      "date": 1686387067186
    },
    {
      "type": "edit",
      "id": "da6e1c7229ebbfd9",
      "item": {
        "type": "paragraph",
        "id": "da6e1c7229ebbfd9",
        "text": "\nLE, Duc Anh, 2023. E-Commercial Full Stack Web Application Development: with React, Redux, NodeJS, and MongoDB. . 2023. \n"
      },
      "date": 1686387068945
    },
    {
      "type": "edit",
      "id": "da6e1c7229ebbfd9",
      "item": {
        "type": "paragraph",
        "id": "da6e1c7229ebbfd9",
        "text": "LE, Duc Anh, 2023. E-Commercial Full Stack Web Application Development: with React, Redux, NodeJS, and MongoDB. "
      },
      "date": 1686387080514
    },
    {
      "item": {
        "type": "factory",
        "id": "ea00fd9c32487fad"
      },
      "id": "ea00fd9c32487fad",
      "type": "add",
      "after": "da6e1c7229ebbfd9",
      "date": 1686387144006
    },
    {
      "type": "edit",
      "id": "ea00fd9c32487fad",
      "item": {
        "type": "paragraph",
        "id": "ea00fd9c32487fad",
        "text": "Additionally, developers can easily view and analyze an application's entire state history, allowing them to determine where a problem may have occurred."
      },
      "date": 1686387145256
    },
    {
      "item": {
        "type": "factory",
        "id": "e7f0a5bae6753045"
      },
      "id": "e7f0a5bae6753045",
      "type": "add",
      "after": "ea00fd9c32487fad",
      "date": 1686387378048
    },
    {
      "type": "edit",
      "id": "e7f0a5bae6753045",
      "item": {
        "type": "pagefold",
        "id": "e7f0a5bae6753045",
        "text": "~"
      },
      "date": 1686387381514
    },
    {
      "item": {
        "type": "factory",
        "id": "ac126bf9b7a2098a"
      },
      "id": "ac126bf9b7a2098a",
      "type": "add",
      "after": "e7f0a5bae6753045",
      "date": 1686387382931
    },
    {
      "type": "edit",
      "id": "ac126bf9b7a2098a",
      "item": {
        "type": "paragraph",
        "id": "ac126bf9b7a2098a",
        "text": "MVI which stands for Model-View-Intent is an architectural pattern characterized for the flow of data in an unidirectional way. Flow of data from the model to the view and from the view to the model. A simple schema of the model can be viewed in the next figure."
      },
      "date": 1686387385037
    },
    {
      "type": "add",
      "id": "7e97d0eb11d2fffd",
      "item": {
        "type": "paragraph",
        "id": "7e97d0eb11d2fffd",
        "text": "\nOROZCO GONZÁLEZ, Andrés Felipe, 2023. back-in-time debugger in Kotlin. . 2023. \n"
      },
      "after": "ac126bf9b7a2098a",
      "date": 1686387403166
    },
    {
      "type": "edit",
      "id": "7e97d0eb11d2fffd",
      "item": {
        "type": "paragraph",
        "id": "7e97d0eb11d2fffd",
        "text": "OROZCO GONZÁLEZ, Andrés Felipe, 2023. back-in-time debugger in Kotlin. \n"
      },
      "date": 1686387409452
    },
    {
      "item": {
        "type": "factory",
        "id": "1a9d09120e7c902f"
      },
      "id": "1a9d09120e7c902f",
      "type": "add",
      "after": "7e97d0eb11d2fffd",
      "date": 1686387461637
    },
    {
      "type": "edit",
      "id": "1a9d09120e7c902f",
      "item": {
        "type": "image",
        "id": "1a9d09120e7c902f",
        "text": "Uploaded image",
        "size": "wide",
        "width": 419,
        "height": 326,
        "url": "/assets/plugins/image/31b4cb69fa6073870ef8f1c084071a60.jpg"
      },
      "date": 1686387476736
    },
    {
      "type": "edit",
      "id": "1a9d09120e7c902f",
      "item": {
        "type": "image",
        "id": "1a9d09120e7c902f",
        "text": "Sample MVI pattern",
        "size": "wide",
        "width": 419,
        "height": 326,
        "url": "/assets/plugins/image/31b4cb69fa6073870ef8f1c084071a60.jpg"
      },
      "date": 1686387490468
    },
    {
      "id": "1a9d09120e7c902f",
      "type": "move",
      "order": [
        "eeefc4dd09b33c18",
        "8cd234694c4b2c2d",
        "da6e1c7229ebbfd9",
        "ea00fd9c32487fad",
        "e7f0a5bae6753045",
        "ac126bf9b7a2098a",
        "1a9d09120e7c902f",
        "7e97d0eb11d2fffd"
      ],
      "date": 1686387499183
    },
    {
      "item": {
        "type": "factory",
        "id": "d1c5a04ee0a52713"
      },
      "id": "d1c5a04ee0a52713",
      "type": "add",
      "after": "7e97d0eb11d2fffd",
      "date": 1686387642275
    },
    {
      "type": "edit",
      "id": "d1c5a04ee0a52713",
      "item": {
        "type": "pagefold",
        "id": "d1c5a04ee0a52713",
        "text": "~"
      },
      "date": 1686387646524
    },
    {
      "item": {
        "type": "factory",
        "id": "f4d3442976518c91"
      },
      "id": "f4d3442976518c91",
      "type": "add",
      "after": "d1c5a04ee0a52713",
      "date": 1686387651820
    },
    {
      "type": "edit",
      "id": "f4d3442976518c91",
      "item": {
        "type": "reference",
        "id": "f4d3442976518c91",
        "site": "elm.dreyeck.ch",
        "slug": "the-elm-architecture",
        "title": "The Elm Architecture",
        "text": "is a simple [[Pattern]] for architecting webapps. The core idea is that your code is built around a [[Model]] of your application state, a way to update your model, and a way to view your model. [https://github.com/evancz/elm-architecture-tutorial/#the-elm-architecture github]"
      },
      "date": 1686387654223
    },
    {
      "item": {
        "type": "factory",
        "id": "886794c3cfbf7d26"
      },
      "id": "886794c3cfbf7d26",
      "type": "add",
      "after": "f4d3442976518c91",
      "date": 1686387662910
    },
    {
      "type": "edit",
      "id": "886794c3cfbf7d26",
      "item": {
        "type": "reference",
        "id": "886794c3cfbf7d26",
        "site": "wiki.ralfbarkow.ch",
        "slug": "how-elm-fits-in",
        "title": "How Elm Fits In",
        "text": "[[Elm]] can be used either as a replacement for in-browser JavaScript code or as a complement to it."
      },
      "date": 1686387665833
    },
    {
      "item": {
        "type": "factory",
        "id": "d3f9d778f3579814"
      },
      "id": "d3f9d778f3579814",
      "type": "add",
      "after": "886794c3cfbf7d26",
      "date": 1686387667994
    },
    {
      "type": "edit",
      "id": "d3f9d778f3579814",
      "item": {
        "type": "html",
        "id": "d3f9d778f3579814",
        "text": "<img\n  src = \"https://guide.elm-lang.org/architecture/buttons.svg\"\n  width = \"100%\"\n>"
      },
      "date": 1686387687543
    },
    {
      "item": {
        "type": "factory",
        "id": "4ae4fe8f0fb2ccf4"
      },
      "id": "4ae4fe8f0fb2ccf4",
      "type": "add",
      "after": "d3f9d778f3579814",
      "date": 1686387697887
    },
    {
      "type": "edit",
      "id": "4ae4fe8f0fb2ccf4",
      "item": {
        "type": "paragraph",
        "id": "4ae4fe8f0fb2ccf4",
        "text": "The Basic Pattern"
      },
      "date": 1686387699297
    },
    {
      "type": "edit",
      "id": "4ae4fe8f0fb2ccf4",
      "item": {
        "type": "paragraph",
        "id": "4ae4fe8f0fb2ccf4",
        "text": "The Basic Pattern [https://guide.elm-lang.org/architecture/ page]"
      },
      "date": 1686387712351
    },
    {
      "type": "edit",
      "id": "7e97d0eb11d2fffd",
      "item": {
        "type": "paragraph",
        "id": "7e97d0eb11d2fffd",
        "text": "OROZCO GONZÁLEZ, Andrés Felipe, 2023. back-in-time debugger in Kotlin. "
      },
      "date": 1686387890352
    },
    {
      "type": "add",
      "id": "7ad41d6477af162d",
      "item": {
        "type": "paragraph",
        "id": "7ad41d6477af162d",
        "text": "This dissertation explores a back-in-time debugger implementation for Kotlin based in the MVIKotlin framework."
      },
      "after": "7e97d0eb11d2fffd",
      "date": 1686387891087
    },
    {
      "type": "add",
      "id": "e1f11c86ad79f69c",
      "item": {
        "type": "paragraph",
        "id": "e1f11c86ad79f69c",
        "text": "Inspired by the back-in-time debugger DeloreanJS [8], this article presents a back-in-time debugger for Kotlin for reactive style developed code. This work expands on the research line for back-in-time debuggers as it introduces a new language to this form of debugging, and adds on the ways to implement a back-in-time debugger from using continuations as used in DeloreanJS to using a MVI architecture and storing previous states of the application to enable it to swap the current state to previous states and re-run the code from a point on."
      },
      "after": "7ad41d6477af162d",
      "date": 1686387946847
    },
    {
      "type": "add",
      "id": "174ed16094e20c7e",
      "item": {
        "type": "paragraph",
        "id": "174ed16094e20c7e",
        "text": "The development of this back-in-time debugger will be built on top of https://github.com/ arkivanov/MVIKotlin [7], which provides most of the functionalities of a back-in-time debugger for Kotlin, but it does not allow the users to change previous states and debug from a given state with modifications."
      },
      "after": "e1f11c86ad79f69c",
      "date": 1686388031492
    },
    {
      "item": {
        "type": "factory",
        "id": "f7acfa23dd19d24e"
      },
      "id": "f7acfa23dd19d24e",
      "type": "add",
      "after": "4ae4fe8f0fb2ccf4",
      "date": 1686388184329
    },
    {
      "type": "edit",
      "id": "f7acfa23dd19d24e",
      "item": {
        "type": "pagefold",
        "id": "f7acfa23dd19d24e",
        "text": "~"
      },
      "date": 1686388188160
    },
    {
      "item": {
        "type": "factory",
        "id": "8d52e29b92ba4465"
      },
      "id": "8d52e29b92ba4465",
      "type": "add",
      "after": "f7acfa23dd19d24e",
      "date": 1686388189519
    },
    {
      "type": "edit",
      "id": "8d52e29b92ba4465",
      "item": {
        "type": "paragraph",
        "id": "8d52e29b92ba4465",
        "text": "The Matrix Time Machine"
      },
      "date": 1686388193270
    },
    {
      "type": "edit",
      "id": "8d52e29b92ba4465",
      "item": {
        "type": "paragraph",
        "id": "8d52e29b92ba4465",
        "text": "The Matrix Time Machine [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$168633482569207uiPNp:matrix.org?via=matrix.org&via=matrix.allmende.io&via=tchncs.de matrix]"
      },
      "date": 1686388209102
    },
    {
      "item": {
        "type": "factory",
        "id": "f56088a7075f4350"
      },
      "id": "f56088a7075f4350",
      "type": "add",
      "after": "8d52e29b92ba4465",
      "date": 1686388215733
    },
    {
      "type": "edit",
      "id": "f56088a7075f4350",
      "item": {
        "type": "video",
        "id": "f56088a7075f4350",
        "text": "YOUTUBE ULbvBIwiGEI"
      },
      "date": 1686388224549
    },
    {
      "type": "edit",
      "id": "f56088a7075f4350",
      "item": {
        "type": "video",
        "id": "f56088a7075f4350",
        "text": "YOUTUBE ULbvBIwiGEI\nMatrix Live S08E25 — The Matrix Time Machine "
      },
      "date": 1686388241066
    },
    {
      "type": "edit",
      "id": "8d52e29b92ba4465",
      "item": {
        "type": "paragraph",
        "id": "8d52e29b92ba4465",
        "text": "The Matrix Time Machine [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$168633482569207uiPNp:matrix.org?via=matrix.org&via=matrix.allmende.io&via=tchncs.de matrix], [https://github.com/matrix-org/matrix-public-archive/issues/47 github]"
      },
      "date": 1686388329487
    }
  ]
}