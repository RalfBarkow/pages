{
  "title": "Digital Archaeology",
  "story": [
    {
      "type": "markdown",
      "id": "102b41735db45b13",
      "text": "Mainframe computing will die with the coming of the millennium. On December 31,1999, right at midnight, when the big ball drops and people are kissing in New York's Times Square, the era of mainframe computing will be over.\n\nMainframe computing will end that night because a lot of people a long time ago made a simple mistake. Beginning in the 1950s, they wrote inventory programs and payroll programs for mainframe computers, programs that process income tax returns and send out welfare checks – programs that today run most of this country. In many ways those programs have become our country. And sometime during those thirty-odd years of being moved from one mainframe computer to another, larger main frame computer, the original program listings, the source code for thousands of mainframe applications, were just thrown away. We have the object code – the part of the program that machines can read – which is enough to move the software from one type of computer to another. But the source code – the original program listing that people can read, that has details of how these programs actually work – is often long gone, fallen through a paper shredder back in 1967. *There is mainframe software in this country that cost at least $50 billion to develop for which no source code exists today.*\n\nThis lack of commented source code would be no big deal if more of those original programmers had expected their programs to outlive them. But hardly any programmer in 1959 expected his payroll application to be still cutting checks in 1999, so nobody thought to teach many of these computer programs what to do when the calendar finally says it's the year 2000. Any program that prints a date on a check or an invoice, and that doesn't have an algorithm for dealing with a change from the twentieth to the twenty-first century, is going to stop working. I know this doesn't sound like a big problem, but it is. *It's a very big problem.* "
    },
    {
      "type": "paragraph",
      "id": "5c15aa61545d2fc8",
      "text": "Looking for a growth industry in which to invest? Between now and the end of the decade, every large company in America either will have to find a way to update its mainframe software or will have to write new software from scratch. New firms will appear dedicated to the digital archaeology needed to update old software. Smart corporations will trash their old software all together and start over. Either solution is going to cost lots more than it did to write the software in the first place. And all this new mainframe software will have one thing in common: it won't run on a mainframe."
    },
    {
      "type": "pagefold",
      "id": "a48737b273f0048b",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "7bcd34c11280a457",
      "text": "Cringely, Accidental empires, p. 304–305."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Digital Archaeology",
        "story": []
      },
      "date": 1661345838392
    },
    {
      "item": {
        "type": "factory",
        "id": "102b41735db45b13"
      },
      "id": "102b41735db45b13",
      "type": "add",
      "date": 1661345860572
    },
    {
      "type": "edit",
      "id": "102b41735db45b13",
      "item": {
        "type": "paragraph",
        "id": "102b41735db45b13",
        "text": "This lack of commented source code would be no big deal if more of those original programmers had expected their programs to outlive them. But hardlyany programmer in 1959 expected his payroll application to be still cutting checks in 1999, so nobody thought to teach many of these computer programs what to do when the calendar finally says it's the year 2000. Any program that prints a date on acheck or an invoice, and that doesn't have an algorithm for dealing with a change from the twentieth to the twenty-first century, is going to stopworking. I know this doesn't sound like a big problem, but it is. It's a very big problem. Looking for a growth industry in which to invest? Between now and the end of the decade, every large company in America either will have to find a way to update its mainframe software or will have to write new software from scratch. New firms will appear dedicated to the digital archaeology needed to update old software. Smart corporations will trash their old software al together and start over. Either solution is going to cost lots more than it did to writethe software in the first place. And all this new mainframe software will have one thing in common: it won't run on a mainframe."
      },
      "date": 1661345862107
    },
    {
      "type": "edit",
      "id": "102b41735db45b13",
      "item": {
        "type": "paragraph",
        "id": "102b41735db45b13",
        "text": "This lack of commented source code would be no big deal if more of those original programmers had expected their programs to outlive them. But hardlyany programmer in 1959 expected his payroll application to be still cutting checks in 1999, so nobody thought to teach many of these computer programs what to do when the calendar finally says it's the year 2000. Any program that prints a date on acheck or an invoice, and that doesn't have an algorithm for dealing with a change from the twentieth to the twenty-first century, is going to stopworking. I know this doesn't sound like a big problem, but it is. *It's a very big problem.* "
      },
      "date": 1661345892398
    },
    {
      "type": "edit",
      "id": "102b41735db45b13",
      "item": {
        "type": "markdown",
        "id": "102b41735db45b13",
        "text": "This lack of commented source code would be no big deal if more of those original programmers had expected their programs to outlive them. But hardlyany programmer in 1959 expected his payroll application to be still cutting checks in 1999, so nobody thought to teach many of these computer programs what to do when the calendar finally says it's the year 2000. Any program that prints a date on acheck or an invoice, and that doesn't have an algorithm for dealing with a change from the twentieth to the twenty-first century, is going to stopworking. I know this doesn't sound like a big problem, but it is. *It's a very big problem.* "
      },
      "date": 1661345894374
    },
    {
      "type": "add",
      "id": "5c15aa61545d2fc8",
      "item": {
        "type": "paragraph",
        "id": "5c15aa61545d2fc8",
        "text": "Looking for a growth industry in which to invest? Between now and the end of the decade, every large company in America either will have to find a way to update its mainframe software or will have to write new software from scratch. New firms will appear dedicated to the digital archaeology needed to update old software. Smart corporations will trash their old software al together and start over. Either solution is going to cost lots more than it did to writethe software in the first place. And all this new mainframe software will have one thing in common: it won't run on a mainframe."
      },
      "after": "102b41735db45b13",
      "date": 1661345895328
    },
    {
      "item": {
        "type": "factory",
        "id": "7bcd34c11280a457"
      },
      "id": "7bcd34c11280a457",
      "type": "add",
      "after": "5c15aa61545d2fc8",
      "date": 1661345907068
    },
    {
      "type": "edit",
      "id": "7bcd34c11280a457",
      "item": {
        "type": "paragraph",
        "id": "7bcd34c11280a457",
        "text": "~"
      },
      "date": 1661345909879
    },
    {
      "type": "edit",
      "id": "7bcd34c11280a457",
      "item": {
        "type": "paragraph",
        "id": "7bcd34c11280a457",
        "text": "Cringely, Accidental empires."
      },
      "date": 1661345919617
    },
    {
      "item": {
        "type": "factory",
        "id": "e0f2fe67ac7f1d40"
      },
      "id": "e0f2fe67ac7f1d40",
      "type": "add",
      "after": "7bcd34c11280a457",
      "date": 1661345923400
    },
    {
      "type": "remove",
      "id": "e0f2fe67ac7f1d40",
      "date": 1661345926329
    },
    {
      "item": {
        "type": "factory",
        "id": "a48737b273f0048b"
      },
      "id": "a48737b273f0048b",
      "type": "add",
      "after": "7bcd34c11280a457",
      "date": 1661345929136
    },
    {
      "type": "edit",
      "id": "a48737b273f0048b",
      "item": {
        "type": "pagefold",
        "id": "a48737b273f0048b",
        "text": "~"
      },
      "date": 1661345931834
    },
    {
      "id": "a48737b273f0048b",
      "type": "move",
      "order": [
        "102b41735db45b13",
        "5c15aa61545d2fc8",
        "a48737b273f0048b",
        "7bcd34c11280a457"
      ],
      "date": 1661345933727
    },
    {
      "type": "edit",
      "id": "7bcd34c11280a457",
      "item": {
        "type": "paragraph",
        "id": "7bcd34c11280a457",
        "text": "Cringely, Accidental empires, p. 305."
      },
      "date": 1661345947675
    },
    {
      "type": "edit",
      "id": "102b41735db45b13",
      "item": {
        "type": "markdown",
        "id": "102b41735db45b13",
        "text": "This lack of commented source code would be no big deal if more of those original programmers had expected their programs to outlive them. But hardly any programmer in 1959 expected his payroll application to be still cutting checks in 1999, so nobody thought to teach many of these computer programs what to do when the calendar finally says it's the year 2000. Any program that prints a date on acheck or an invoice, and that doesn't have an algorithm for dealing with a change from the twentieth to the twenty-first century, is going to stopworking. I know this doesn't sound like a big problem, but it is. *It's a very big problem.* "
      },
      "date": 1661345976485
    },
    {
      "type": "edit",
      "id": "102b41735db45b13",
      "item": {
        "type": "markdown",
        "id": "102b41735db45b13",
        "text": "This lack of commented source code would be no big deal if more of those original programmers had expected their programs to outlive them. But hardly any programmer in 1959 expected his payroll application to be still cutting checks in 1999, so nobody thought to teach many of these computer programs what to do when the calendar finally says it's the year 2000. Any program that prints a date on a check or an invoice, and that doesn't have an algorithm for dealing with a change from the twentieth to the twenty-first century, is going to stopworking. I know this doesn't sound like a big problem, but it is. *It's a very big problem.* "
      },
      "date": 1661345992311
    },
    {
      "type": "edit",
      "id": "102b41735db45b13",
      "item": {
        "type": "markdown",
        "id": "102b41735db45b13",
        "text": "This lack of commented source code would be no big deal if more of those original programmers had expected their programs to outlive them. But hardly any programmer in 1959 expected his payroll application to be still cutting checks in 1999, so nobody thought to teach many of these computer programs what to do when the calendar finally says it's the year 2000. Any program that prints a date on a check or an invoice, and that doesn't have an algorithm for dealing with a change from the twentieth to the twenty-first century, is going to stopw orking. I know this doesn't sound like a big problem, but it is. *It's a very big problem.* "
      },
      "date": 1661346005265
    },
    {
      "type": "edit",
      "id": "5c15aa61545d2fc8",
      "item": {
        "type": "paragraph",
        "id": "5c15aa61545d2fc8",
        "text": "Looking for a growth industry in which to invest? Between now and the end of the decade, every large company in America either will have to find a way to update its mainframe software or will have to write new software from scratch. New firms will appear dedicated to the digital archaeology needed to update old software. Smart corporations will trash their old software all together and start over. Either solution is going to cost lots more than it did to writethe software in the first place. And all this new mainframe software will have one thing in common: it won't run on a mainframe."
      },
      "date": 1661346033382
    },
    {
      "type": "edit",
      "id": "5c15aa61545d2fc8",
      "item": {
        "type": "paragraph",
        "id": "5c15aa61545d2fc8",
        "text": "Looking for a growth industry in which to invest? Between now and the end of the decade, every large company in America either will have to find a way to update its mainframe software or will have to write new software from scratch. New firms will appear dedicated to the digital archaeology needed to update old software. Smart corporations will trash their old software all together and start over. Either solution is going to cost lots more than it did to write the software in the first place. And all this new mainframe software will have one thing in common: it won't run on a mainframe."
      },
      "date": 1661346046688
    },
    {
      "type": "edit",
      "id": "102b41735db45b13",
      "item": {
        "type": "markdown",
        "id": "102b41735db45b13",
        "text": "Mainframe computing will die with the coming of the millennium. On December 31,1999, right at midnight, when the big ball drops and people are kissing in New York's Times Square, the era of mainframe computing will be over.\n\nMainframe computing will end that night because a lot of people a long time ago made a simple mistake. Beginning in the 1950s, they wrote inventory programs and payroll programs for mainframe computers, programs that process income tax returns and send out welfare checks—programs that today run most of this country. In many ways those programs have become our country. And sometime during those thirty-odd years of being moved from one mainframe computer to another, larger main frame computer, the original program listings, the source code for thousands of mainframe applications, were just thrown away. We have the object code – the part of the program that machines can read – which is enough to move the software from one type of computer to another. But the source code – the original program listing that people can read, that has details of how these programs actually work – is often long gone, fallen through a paper shredder back in 1967. *There is mainframe software in this country that cost at least $50 billion to develop for which no source code exists today.*\n\nThis lack of commented source code would be no big deal if more of those original programmers had expected their programs to outlive them. But hardly any programmer in 1959 expected his payroll application to be still cutting checks in 1999, so nobody thought to teach many of these computer programs what to do when the calendar finally says it's the year 2000. Any program that prints a date on a check or an invoice, and that doesn't have an algorithm for dealing with a change from the twentieth to the twenty-first century, is going to stopw orking. I know this doesn't sound like a big problem, but it is. *It's a very big problem.* "
      },
      "date": 1661346329146
    },
    {
      "type": "edit",
      "id": "7bcd34c11280a457",
      "item": {
        "type": "paragraph",
        "id": "7bcd34c11280a457",
        "text": "Cringely, Accidental empires, p. 304–305."
      },
      "date": 1661346349648
    },
    {
      "type": "edit",
      "id": "102b41735db45b13",
      "item": {
        "type": "markdown",
        "id": "102b41735db45b13",
        "text": "Mainframe computing will die with the coming of the millennium. On December 31,1999, right at midnight, when the big ball drops and people are kissing in New York's Times Square, the era of mainframe computing will be over.\n\nMainframe computing will end that night because a lot of people a long time ago made a simple mistake. Beginning in the 1950s, they wrote inventory programs and payroll programs for mainframe computers, programs that process income tax returns and send out welfare checks – programs that today run most of this country. In many ways those programs have become our country. And sometime during those thirty-odd years of being moved from one mainframe computer to another, larger main frame computer, the original program listings, the source code for thousands of mainframe applications, were just thrown away. We have the object code – the part of the program that machines can read – which is enough to move the software from one type of computer to another. But the source code – the original program listing that people can read, that has details of how these programs actually work – is often long gone, fallen through a paper shredder back in 1967. *There is mainframe software in this country that cost at least $50 billion to develop for which no source code exists today.*\n\nThis lack of commented source code would be no big deal if more of those original programmers had expected their programs to outlive them. But hardly any programmer in 1959 expected his payroll application to be still cutting checks in 1999, so nobody thought to teach many of these computer programs what to do when the calendar finally says it's the year 2000. Any program that prints a date on a check or an invoice, and that doesn't have an algorithm for dealing with a change from the twentieth to the twenty-first century, is going to stopw orking. I know this doesn't sound like a big problem, but it is. *It's a very big problem.* "
      },
      "date": 1661346397937
    },
    {
      "type": "edit",
      "id": "102b41735db45b13",
      "item": {
        "type": "markdown",
        "id": "102b41735db45b13",
        "text": "Mainframe computing will die with the coming of the millennium. On December 31,1999, right at midnight, when the big ball drops and people are kissing in New York's Times Square, the era of mainframe computing will be over.\n\nMainframe computing will end that night because a lot of people a long time ago made a simple mistake. Beginning in the 1950s, they wrote inventory programs and payroll programs for mainframe computers, programs that process income tax returns and send out welfare checks – programs that today run most of this country. In many ways those programs have become our country. And sometime during those thirty-odd years of being moved from one mainframe computer to another, larger main frame computer, the original program listings, the source code for thousands of mainframe applications, were just thrown away. We have the object code – the part of the program that machines can read – which is enough to move the software from one type of computer to another. But the source code – the original program listing that people can read, that has details of how these programs actually work – is often long gone, fallen through a paper shredder back in 1967. *There is mainframe software in this country that cost at least $50 billion to develop for which no source code exists today.*\n\nThis lack of commented source code would be no big deal if more of those original programmers had expected their programs to outlive them. But hardly any programmer in 1959 expected his payroll application to be still cutting checks in 1999, so nobody thought to teach many of these computer programs what to do when the calendar finally says it's the year 2000. Any program that prints a date on a check or an invoice, and that doesn't have an algorithm for dealing with a change from the twentieth to the twenty-first century, is going to stop working. I know this doesn't sound like a big problem, but it is. *It's a very big problem.* "
      },
      "date": 1661346472029
    }
  ]
}