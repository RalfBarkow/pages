{
  "title": "Agile Language",
  "story": [
    {
      "type": "html",
      "text": "[[Scripting Language]]s have a poor reputation regarding performance and a good one regarding productivity. Too many people think that they are [[Toy Language]]s.",
      "id": "7f526012ef906a2a830283a9d1095bd9"
    },
    {
      "type": "html",
      "text": "\nBut things have improved a lot recently and some scripting languages are gaining momentum. In an effort to get rid of the poor reputation of scripting languages, these new languages (some are not so new) are called Agile probably to benefit from the momentum of [[Agile Process]]es.",
      "id": "142c20c16efaf9bf43b9785c485759f1"
    },
    {
      "type": "html",
      "text": "\nSome such languages include:",
      "id": "4a1ab1718935b35f39ec0ca9ac01370f"
    },
    {
      "type": "html",
      "text": " [[Perl Language]]",
      "id": "49c19a5124a04ef987a922a21d424f45"
    },
    {
      "type": "html",
      "text": " [[Python Language]]",
      "id": "ea34d6fd37fb5761d88b560494bea06c"
    },
    {
      "type": "html",
      "text": " [[Ruby Language]]",
      "id": "359624066653ad0e197cdf75f1228082"
    },
    {
      "type": "html",
      "text": " [[Smalltalk Language]]",
      "id": "0d2500993267e79b26e1b4faf0fbc71d"
    },
    {
      "type": "html",
      "text": " [[Lisp Language]]",
      "id": "9df3d933c3b04775557c8e5e1852db10"
    },
    {
      "type": "html",
      "text": " [[Php Language]]\nAnd apparently [[Ward Cunningham]] is striking again here: [http://radio.weblogs.com/0102677/2003/04/04.html radio.weblogs.com].",
      "id": "afd38a2d77f0e0591d6125e528f2bed3"
    },
    {
      "type": "html",
      "text": "-- [[Jean Hugues Robert]]",
      "id": "17be9d2e8ee78320af4ce886788950ad"
    },
    {
      "type": "html",
      "text": "\nI am excited about combining expressive [[Scripting Language]](s) with the trustworthyness of [[Test Driven Design]]. -- [[Ward Cunningham]]",
      "id": "4185cf1014270a4da3cdf342923932c6"
    },
    {
      "type": "html",
      "text": "\nIdeally, a language should let you pick high or low level, static or dynamic typing, without clutter (such as C++ templates). But when you invest in tests instead of paranoid typechecks, the odds that a given type combination \"accidentally\" works together moves from a risk to emergent design. -- [[Phl Ip]]",
      "id": "72703f36cc85cc088d9c55ebbe35055f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0177dd882792c0b769f4aa195b3255f2"
    },
    {
      "type": "html",
      "text": "\nWould it not be more constructive to talk of [[Agile Development Environment]] rather than language? Where environment would encompass a whole of language, frameworks, editors, coding conventions, tool support ... If you just focus on language, a static type system can seem like straight-jacket of paranoid typechecks, heavy build steps and a lot of unnecessary code. But one of the strengths of a static type system is that it allows for static reasoning about program behaviour, opening up for tool support, that go hand in hand with the agile way, such as refactoring browsers, modelers and interface builders. ",
      "id": "d34aab5a8edd53a245938e72aa102158"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0177dd882792c0b769f4aa195b3255f2"
    },
    {
      "type": "html",
      "text": "<i>What are the distinguishing characteristics of an [[Agile Language]]? Is it just [[Marketing Speak]] for [[Scripting Language]]?</i>",
      "id": "2674ae14fbcf2e110aa7e2be70331559"
    },
    {
      "type": "html",
      "text": "\nBasically, any language that doesn't excessively hinder you from doing agile practices. Some specific characteristics:",
      "id": "54c528576c665726a0740db5598284f6"
    },
    {
      "type": "html",
      "text": " Easy to refactor in, including ease of automating refactoring",
      "id": "4239f9c31ca5c7c69362e0bb76d116a4"
    },
    {
      "type": "html",
      "text": " This is aided by having a small, simple, and consistent syntax.  [[Perl Language]] fails on this test, but [[Smalltalk Language]] and [[Lisp Language]] pass nicely",
      "id": "1561304186e131431ecd93c0d79d1f58"
    },
    {
      "type": "html",
      "text": " Ability to create a good, fast unit test framework",
      "id": "39a86a2787120e944316e9e30b013b85"
    },
    {
      "type": "html",
      "text": " object-oriented features (helps to make test cases independent of each other)",
      "id": "3b5e18ea68db0af02e8b393114eafbaa"
    },
    {
      "type": "html",
      "text": " Run-time reflection (to make implementing a [[Test Collector]] and [[Test Runner]] easier)",
      "id": "3bfc604d6de2977e6b6505491d1298a1"
    },
    {
      "type": "html",
      "text": " Ability to automate acceptance testing",
      "id": "39c50f8fc68f2cc35dcabb2be340f137"
    },
    {
      "type": "html",
      "text": "<i>It seems like this list is missing an obvious one:</i>",
      "id": "0dc27db97564cc1cd59db3bc2da25b87"
    },
    {
      "type": "html",
      "text": " Strong enough primitives and abstractions to build software at an acceptable rate",
      "id": "28b8f049a0365830076b892c3d9a912b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0177dd882792c0b769f4aa195b3255f2"
    },
    {
      "type": "html",
      "text": "Here's a proposal that I think is not likely to fly because it tries to be [[One Size Fits All]], but it's too compelling of an idea not to share.",
      "id": "520bc6985db6a085594941fb51f65a67"
    },
    {
      "type": "html",
      "text": "\nWhat if we had a programming language with a hybrid of BDD ([[Behavior Driven Development]]) and statically checked contracts baked right in, and it was hybrid static/dynamic, procedural/functional, strong-duck-typed, object oriented.  Yes, this is wacko, but perhaps not as wacko as it sounds.",
      "id": "3092888ca6fcb8416f81da9f5c7bd0e1"
    },
    {
      "type": "html",
      "text": " Hybrid BDD/Contractual: This can be done by allowing an artifact's contracts to be specified externally, and allowing a contract to be either statically provable or to have executable specs (tests) that are automatically run on build and/or on-demand.",
      "id": "298f0d82fd39e07618ab4422c226a551"
    },
    {
      "type": "html",
      "text": " Static/dynamic: Modules can be defined as either compiled/checked, or dynamic, allowing us to [[Alternate Hard And Soft Layers]] within the same language.  ",
      "id": "0cc21bc6c7e3eada73407cd28b65c9d1"
    },
    {
      "type": "html",
      "text": " What if the language gave you access to its own compiler, and the compiled output?  Then, you could pre-compile modules, save the results to disk, provide mechanisms to re-compile each module used only if its source were changed (e.g. MD5 sum of the source file saved in the object code), etc.",
      "id": "70c5a6e837ad684d13d8429aa2fc9d0b"
    },
    {
      "type": "html",
      "text": " Further, it would also help if there were a just-in-time compiler, ",
      "id": "306aa8bfccd8ee660b9644fc845c610c"
    },
    {
      "type": "html",
      "text": " Procedural/Functional:  Many hybrid procedural/functional languages already exist.",
      "id": "aa485fc7974ebafd4008585e05f9c9a9"
    },
    {
      "type": "html",
      "text": " Strong duck typing: Can be done using [[Type Inference]].  Dynamic portions of the code will have fewer restrictions than static portions since they don't have to provably satisfy the type system.",
      "id": "3c2b9bd0ec8b5478e5d9878e21f08c60"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0177dd882792c0b769f4aa195b3255f2"
    },
    {
      "type": "html",
      "text": "[[Category Scripting]]",
      "id": "702045b8fb69c440e82945a89c165b1d"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?AgileLanguage c2.com]",
      "id": "a6942da1f6a378d043d70a5da1f8b59f"
    }
  ],
  "journal": [
    {
      "date": 1250170909000,
      "id": "93f195446cd7273277d8f25706fad9ce",
      "type": "create",
      "item": {
        "title": "Agile Language",
        "story": [
          {
            "type": "html",
            "text": "[[Scripting Language]]s have a poor reputation regarding performance and a good one regarding productivity. Too many people think that they are [[Toy Language]]s.",
            "id": "7f526012ef906a2a830283a9d1095bd9"
          },
          {
            "type": "html",
            "text": "\nBut things have improved a lot recently and some scripting languages are gaining momentum. In an effort to get rid of the poor reputation of scripting languages, these new languages (some are not so new) are called Agile probably to benefit from the momentum of [[Agile Process]]es.",
            "id": "142c20c16efaf9bf43b9785c485759f1"
          },
          {
            "type": "html",
            "text": "\nSome such languages include:",
            "id": "4a1ab1718935b35f39ec0ca9ac01370f"
          },
          {
            "type": "html",
            "text": " [[Perl Language]]",
            "id": "49c19a5124a04ef987a922a21d424f45"
          },
          {
            "type": "html",
            "text": " [[Python Language]]",
            "id": "ea34d6fd37fb5761d88b560494bea06c"
          },
          {
            "type": "html",
            "text": " [[Ruby Language]]",
            "id": "359624066653ad0e197cdf75f1228082"
          },
          {
            "type": "html",
            "text": " [[Smalltalk Language]]",
            "id": "0d2500993267e79b26e1b4faf0fbc71d"
          },
          {
            "type": "html",
            "text": " [[Lisp Language]]",
            "id": "9df3d933c3b04775557c8e5e1852db10"
          },
          {
            "type": "html",
            "text": " [[Php Language]]\nAnd apparently [[Ward Cunningham]] is striking again here: [http://radio.weblogs.com/0102677/2003/04/04.html radio.weblogs.com].",
            "id": "afd38a2d77f0e0591d6125e528f2bed3"
          },
          {
            "type": "html",
            "text": "-- [[Jean Hugues Robert]]",
            "id": "17be9d2e8ee78320af4ce886788950ad"
          },
          {
            "type": "html",
            "text": "\nI am excited about combining expressive [[Scripting Language]](s) with the trustworthyness of [[Test Driven Design]]. -- [[Ward Cunningham]]",
            "id": "4185cf1014270a4da3cdf342923932c6"
          },
          {
            "type": "html",
            "text": "\nIdeally, a language should let you pick high or low level, static or dynamic typing, without clutter (such as C++ templates). But when you invest in tests instead of paranoid typechecks, the odds that a given type combination \"accidentally\" works together moves from a risk to emergent design. -- [[Phl Ip]]",
            "id": "72703f36cc85cc088d9c55ebbe35055f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0177dd882792c0b769f4aa195b3255f2"
          },
          {
            "type": "html",
            "text": "\nWould it not be more constructive to talk of [[Agile Development Environment]] rather than language? Where environment would encompass a whole of language, frameworks, editors, coding conventions, tool support ... If you just focus on language, a static type system can seem like straight-jacket of paranoid typechecks, heavy build steps and a lot of unnecessary code. But one of the strengths of a static type system is that it allows for static reasoning about program behaviour, opening up for tool support, that go hand in hand with the agile way, such as refactoring browsers, modelers and interface builders. ",
            "id": "d34aab5a8edd53a245938e72aa102158"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0177dd882792c0b769f4aa195b3255f2"
          },
          {
            "type": "html",
            "text": "<i>What are the distinguishing characteristics of an [[Agile Language]]? Is it just [[Marketing Speak]] for [[Scripting Language]]?</i>",
            "id": "2674ae14fbcf2e110aa7e2be70331559"
          },
          {
            "type": "html",
            "text": "\nBasically, any language that doesn't excessively hinder you from doing agile practices. Some specific characteristics:",
            "id": "54c528576c665726a0740db5598284f6"
          },
          {
            "type": "html",
            "text": " Easy to refactor in, including ease of automating refactoring",
            "id": "4239f9c31ca5c7c69362e0bb76d116a4"
          },
          {
            "type": "html",
            "text": " This is aided by having a small, simple, and consistent syntax.  [[Perl Language]] fails on this test, but [[Smalltalk Language]] and [[Lisp Language]] pass nicely",
            "id": "1561304186e131431ecd93c0d79d1f58"
          },
          {
            "type": "html",
            "text": " Ability to create a good, fast unit test framework",
            "id": "39a86a2787120e944316e9e30b013b85"
          },
          {
            "type": "html",
            "text": " object-oriented features (helps to make test cases independent of each other)",
            "id": "3b5e18ea68db0af02e8b393114eafbaa"
          },
          {
            "type": "html",
            "text": " Run-time reflection (to make implementing a [[Test Collector]] and [[Test Runner]] easier)",
            "id": "3bfc604d6de2977e6b6505491d1298a1"
          },
          {
            "type": "html",
            "text": " Ability to automate acceptance testing",
            "id": "39c50f8fc68f2cc35dcabb2be340f137"
          },
          {
            "type": "html",
            "text": "<i>It seems like this list is missing an obvious one:</i>",
            "id": "0dc27db97564cc1cd59db3bc2da25b87"
          },
          {
            "type": "html",
            "text": " Strong enough primitives and abstractions to build software at an acceptable rate",
            "id": "28b8f049a0365830076b892c3d9a912b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0177dd882792c0b769f4aa195b3255f2"
          },
          {
            "type": "html",
            "text": "Here's a proposal that I think is not likely to fly because it tries to be [[One Size Fits All]], but it's too compelling of an idea not to share.",
            "id": "520bc6985db6a085594941fb51f65a67"
          },
          {
            "type": "html",
            "text": "\nWhat if we had a programming language with a hybrid of BDD ([[Behavior Driven Development]]) and statically checked contracts baked right in, and it was hybrid static/dynamic, procedural/functional, strong-duck-typed, object oriented.  Yes, this is wacko, but perhaps not as wacko as it sounds.",
            "id": "3092888ca6fcb8416f81da9f5c7bd0e1"
          },
          {
            "type": "html",
            "text": " Hybrid BDD/Contractual: This can be done by allowing an artifact's contracts to be specified externally, and allowing a contract to be either statically provable or to have executable specs (tests) that are automatically run on build and/or on-demand.",
            "id": "298f0d82fd39e07618ab4422c226a551"
          },
          {
            "type": "html",
            "text": " Static/dynamic: Modules can be defined as either compiled/checked, or dynamic, allowing us to [[Alternate Hard And Soft Layers]] within the same language.  ",
            "id": "0cc21bc6c7e3eada73407cd28b65c9d1"
          },
          {
            "type": "html",
            "text": " What if the language gave you access to its own compiler, and the compiled output?  Then, you could pre-compile modules, save the results to disk, provide mechanisms to re-compile each module used only if its source were changed (e.g. MD5 sum of the source file saved in the object code), etc.",
            "id": "70c5a6e837ad684d13d8429aa2fc9d0b"
          },
          {
            "type": "html",
            "text": " Further, it would also help if there were a just-in-time compiler, ",
            "id": "306aa8bfccd8ee660b9644fc845c610c"
          },
          {
            "type": "html",
            "text": " Procedural/Functional:  Many hybrid procedural/functional languages already exist.",
            "id": "aa485fc7974ebafd4008585e05f9c9a9"
          },
          {
            "type": "html",
            "text": " Strong duck typing: Can be done using [[Type Inference]].  Dynamic portions of the code will have fewer restrictions than static portions since they don't have to provably satisfy the type system.",
            "id": "3c2b9bd0ec8b5478e5d9878e21f08c60"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0177dd882792c0b769f4aa195b3255f2"
          },
          {
            "type": "html",
            "text": "[[Category Scripting]]",
            "id": "702045b8fb69c440e82945a89c165b1d"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?AgileLanguage c2.com]",
            "id": "a6942da1f6a378d043d70a5da1f8b59f"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1708205635484
    }
  ]
}