{
  "title": "Once And Only Once",
  "story": [
    {
      "type": "html",
      "text": "One of the main goals (if not <i>the</i> main goal) when [[Re Factoring]] code. Each and every declaration of behavior should appear [[Once And Only Once]]. Conceptually analogous to normalization in the [[Relational Model]]. See also [[Dont Repeat Yourself]].",
      "id": "ce7c1c64e72e2544e9770a6235b9ff2d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "Code wants to be simple. If you are aware of [[Code Smell]]s, and duplicate code is one of the strongest, and you react accordingly, your systems will get simpler. When I began working in this style, I had to give up the idea that I had the perfect vision of the system to which the system had to conform. Instead, I had to accept that I was only the vehicle for the system expressing its own desire for simplicity. My vision could shape initial direction, and my attention to the desires of the code could affect how quickly and how well the system found its desired shape, but the system is riding me much more than I am riding the system. -- [[Kent Beck]], feeling mystical, see [[Mystical Programming]]",
      "id": "f94972f49e9dd9fe4c94d2fd7ae7b5b0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "<i>Beware of introducing unnecessary coupling ([[Coupling And Cohesion]]) when refactoring for [[Once And Only Once]].</i>",
      "id": "432c9ba4e589d5211d07c98890ba2ca3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "Refactoring is the moving of units of functionality from one place to another in your program. Refactoring has as a primary objective getting each piece of functionality to exist in exactly one place in the software. -- [[Ron Jeffries]]",
      "id": "73e7a67148d488595dba50c62da7d489"
    },
    {
      "type": "html",
      "text": "<i>It's not OAOO, and this comment probably ought to be somewhere else, but doesn't refactoring also cover replacing one piece of code with another, simpler piece of code that has the same external \"appearance\" and function?</i>",
      "id": "560665ac6dd600a100ef20bb534dbab1"
    },
    {
      "type": "html",
      "text": "\nYes - good point. Note Ron's subtle use of \"a primary objective\" instead of \"the primary objective\". I personally use two \"first tier\" refactoring rules - [[Once And Only Once]] and [[Separate The What From The How]] (my name - the common name is [[Composed Method]])",
      "id": "c9b09d5b75becac677e765d086f406ec"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "[[Once And Only Once]] is a profound concept, but difficult to apply. I've spent my entire professional life (25 years) learning how to apply it to programs. This page [<i>many versions ago</i>] ... was rewritten to make [[Once And Only Once]] seem like a simple rule to apply, instead of a prime principle. [[Once And Only Once]] is NOT easy! And it was wrong to refactor this page so that all hints of tension and disagreement are removed from it.",
      "id": "c77a44d24776e618792160f5ddca4ef5"
    },
    {
      "type": "html",
      "text": "\n[[Once And Only Once]] is not a pattern. A pattern is something you can teach someone to do in a fairly short amount of time. A day, usually. Perhaps a few weeks. But learning how to refactor classes to form a [[Template Method]] does not help you see how to use XML to represent your user interfaces (a recent [[Once And Only Once]] technique applied to Squeak), or how to make a good virtual machine. These are patterns; [[Once And Only Once]] is not a pattern. [[Once And Only Once]] is a principle. -- [[Ralph Johnson]]",
      "id": "cbf97024267e80ddecc9ba4106b1d118"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "Well said. [[Once And Only Once]] is not just a simple rule, but one of the core goals of all software design. It's why functions were invented. Remember that your program could have been written as a single long function using only ifs, whiles, and try/catch blocks for flow control, and primitives for all the data. Consider what that would look like. For \"hello world\", it's the default.",
      "id": "d1f8c880d977f9a79f6489b830a93ca7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "I once saw Beck declare two patches of almost completely different code to be \"duplication\", change them so that they WERE duplication, and then remove the newly inserted duplication to come up with something obviously better. -- [[Ron Jeffries]], from the [[Xp Mailing List]]",
      "id": "ce79d7f0da58f2108cd2b1d2e30f1553"
    },
    {
      "type": "html",
      "text": "<i>or, the long version...</i>",
      "id": "0fce52a34d392f5e8f6dcd3a247335a4"
    },
    {
      "type": "html",
      "text": "\nI recall once seeing Beck look at two loops that were quite dissimilar: they had different for structures, and different contents, which is pretty much nothing duplicated except the word \"for\", and the fact that they were looping - differently - over the same collection.",
      "id": "b8c8a9f35a74504a66e7744470f360e8"
    },
    {
      "type": "html",
      "text": "\nHe changed the second loop to loop the same way the first one did. This required changing the body of the loop to skip over the items toward the end of the collection, since the previous version only did the front of the collection.",
      "id": "5204f2ad51b0c36f91e11384df0ad418"
    },
    {
      "type": "html",
      "text": "\nNow the for statements were the same. \"Well, gotta eliminate that duplication, he said, and moved the second body into the first loop and deleted the second loop entirely.",
      "id": "34f9af379ea30775a95d7ee0992b523a"
    },
    {
      "type": "html",
      "text": "\nNow he had two kinds of similar processing going on in the one loop. He found some kind of duplication in there, extracted a method, did a couple of other things, and voila! the code was much better.",
      "id": "e10b7e43dfb86671069581a867b40468"
    },
    {
      "type": "html",
      "text": "\nThat first step - creating duplication - was startling. -- [[Ron Jeffries]], from the [[Xp Mailing List]]",
      "id": "7a3b2a5739657e1dd7d93bebd18e1bcc"
    },
    {
      "type": "html",
      "text": "<i>It isn't so startling. That technique is necessary for the more powerful space optimizations of program code: you reduce everything as much as possible, then you find two subgraphs that are similar, you add conditional nodes to them until they're identical (and inject the proper conditions), then you combine them. Repeat until the apparent gains aren't worth the resource cost to acquire them. Beck is just doing it by hand.</i>",
      "id": "6b715cd7447bae2b299d644c2f35c19b"
    },
    {
      "type": "html",
      "text": "\nIt is also frequently used to allow consistent idiomatic expressions to emerge. This allows bugs to be detected via inspection for all cases where the idiom was not followed properly. This is more than superficial coding standards. For example: a loop guard of < n or <=n will behave differently if n starts at 0 vs starting at 1. It is best to pick one idiom and stick with it. I suspect the duplication here was semantic in nature and culling it out allowed a reuse opportunity to emerge.",
      "id": "967dca398898f51ed3eb016ac9b456a8"
    },
    {
      "type": "html",
      "text": "-- [[Marc Grundfest]]",
      "id": "adf8a14e1eabd33e448f676d5eec2794"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "<b>OAOO And Parallel Inheritance Hierarchies</b>",
      "id": "41673d40662f6a47cea3d96767f66e4d"
    },
    {
      "type": "html",
      "text": "\nIn the slides for [[Xp Immersion]], [[Robert Martin]] mentions parallel inheritance hierarchies as an example of [[Once And Only Once]]. I find it to be one of the hardest repetitions to refactor away, though. Does anyone have any hot tips?",
      "id": "e03fd7ea65826aeff65b039faeb13d3c"
    },
    {
      "type": "html",
      "text": "-- [[Johannes Brodwall]]",
      "id": "1ef23cc4ff01fd755fc5ed9fc9d4c577"
    },
    {
      "type": "html",
      "text": "\nThere are two ways to go. To remove the parallel: refactor either or both hierarchies until their members are congruent, then collapse pairwise. To remove duplication between the parallels: define distinct responsibilities refined by each hierarchy and relocate methods as appropriate. -- [[Ward Cunningham]]",
      "id": "132c55ce94898143e9d04f5de40137ba"
    },
    {
      "type": "html",
      "text": "\nThis all became a little abstract for me. What about an example? Say I have an accounting and logistics system. I have an abstract class Account and an abstract class Transaction. Each transaction transfers something from one account to another. Now, I have several types of accounts: Securities<b></b>Account, Bonds<b></b>Account, Money<b></b>Account, etc. For each type of account there is a transaction: Securities<b></b>Transaction, Bonds<b></b>Transaction, Money<b></b>Transaction, etc. Now what? -- [[Johannes Brodwall]]",
      "id": "4796f47566e2fc8b7390bc22fa6406af"
    },
    {
      "type": "html",
      "text": "\nTo solve your dilemma, try building the abstracts Transaction and Account. If you find something abstract enough to put there, you then might find something to reuse between different types of Accounts and Transactions. If not, it might be that those are just abstractions with no functional meaning for your context of usage. Another idea (some get it as an abuse, some as a smart oop move) is to move from hierarchy/inheritance design to aggregate/composition design, in your case, refactor to Transaction, Account and Transactionable (or Accountable) and descend from Transactionable to Money, Bond, etc. This way all your similarities (read code duplicates) should cut up to Transactionable, leaving Account and Transaction to deal only with the abstract behaviour/data that their names imply. The con is that you will have to invent notions to tie Transactionable to Account/Transaction together. Actually, that's the point where abstraction meets creation, but that's another story (see [[Abstraction Addiction]], [[Too Much Abstraction]], [[Parallel Inheritance Hierarchies]]). -- [[Cosmin Apreutesei]]",
      "id": "a60bcefe38791371c527d54a32e5c577"
    },
    {
      "type": "html",
      "text": "\nA good example indeed. My experience on [[Wy Cash]] was that the prevailing domain classification exerted way too much influence over our initial hierarchies as it may have yours too. We couldn't merge the two hierarchies because Transaction and Account instances have different lifetimes. Instead, as per the second choice above, we focused on redistribution of responsibilities which turned out as follows.",
      "id": "b384948f590d54f007f51a0026670829"
    },
    {
      "type": "html",
      "text": " Transactions -- long lived private factual information",
      "id": "25b48bc675e2d2c82e834c9d76e09cc3"
    },
    {
      "type": "html",
      "text": " Accounts -- organizational structure related to reporting",
      "id": "6f85a0f187a22d3fafbe4676c5c66fce"
    },
    {
      "type": "html",
      "text": " Calculators -- industry accepted analytic components",
      "id": "3f934a461e13a879d5d93f5ed754b925"
    },
    {
      "type": "html",
      "text": " Advancers -- mechanics of interpreting transactions",
      "id": "763666913746818aca1f2bec3813b0b6"
    },
    {
      "type": "html",
      "text": "\nWe were stunned at the discovery of advancers two years into maintenance. We never would have gotten this far without a long term commitment to aggressive refactoring. -- [[Ward Cunningham]] (See [[What Is An Advancer]])",
      "id": "e56a1a2122164c27827266aee115242f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "<b>OAOO And Tests</b>",
      "id": "2da5449bf50f379e0e6602b498395644"
    },
    {
      "type": "html",
      "text": "\n[[Once And Only Once]] sounds like a nice principle but, when taken at face value, would lead to untested code. Even XP advocates stating each fact at least twice, preferably three times.",
      "id": "b26a8a1e120203c0a166b9647f923153"
    },
    {
      "type": "html",
      "text": "\nThe three places where our fact is stated are:",
      "id": "5c43d7ecc57b1c76c2152724a832fbe9"
    },
    {
      "type": "html",
      "text": " what the customer wants ([[Functional Test]]s)",
      "id": "e19a0eef6ba07205504132a9c893bf6f"
    },
    {
      "type": "html",
      "text": " what the programmer wants ([[Unit Test]]s)",
      "id": "7e7ffe69c7eaabf88641de8cd31a8f01"
    },
    {
      "type": "html",
      "text": " what the program does (the program itself)",
      "id": "dd6eb07fe9ac693cd73d0609c72b64a5"
    },
    {
      "type": "html",
      "text": "-- [[Dave Whipp]]",
      "id": "1b46cb907019c2cec888e56445ec07d2"
    },
    {
      "type": "html",
      "text": "\nThis is a good point, Dave. I have another rule I use when information must be duplicated: When you must duplicate information make sure you will automatically detect if the duplicated information falls out of sync. Tests do this implicitly, and by definition. There are other common cases where the duplicated information is not self-testing, though. Assertions are a classic tool for handling this kind of problem. -- [[Curtis Bartley]]",
      "id": "dba85f6dc2aeae5b2932d93733f310f9"
    },
    {
      "type": "html",
      "text": "\nThis point is valid only if the code is perfect. Otherwise the two types of test add information to the overall system, and hence are not duplicating knowledge. Also, to be fair, what you're critiquing here is not really OAOO (which is about code refactoring), but [[Dont Repeat Yourself]], which is wider ranging. -- [[David Thomas]]",
      "id": "0cedc2101b126fee38ffc0a0a2728c32"
    },
    {
      "type": "html",
      "text": "\nThe OAOO principle in XP refers specifically to the program. The program should express each idea once and only once - there should be no duplicate <i>code</i>.",
      "id": "306f53136a0384d3b4c2b52025a05d51"
    },
    {
      "type": "html",
      "text": "\nFurther, comparing the code:",
      "id": "b883be6029ee36588486e041a1a1bc56"
    },
    {
      "type": "code",
      "text": " square(NUMBER x) {\n  return x*x;\n }",
      "id": "88d05cede3163d1542196f1580a17465"
    },
    {
      "type": "html",
      "text": "with the test:",
      "id": "bddac699680e96c42e453463000cb940"
    },
    {
      "type": "code",
      "text": " assertEquals(4, square(2));\n assertEquals(9, square(3));\n assertEquals(4, square(-2));\n assertEquals(9, square(-3));",
      "id": "4c0743628400a5c0e10de27dca590623"
    },
    {
      "type": "html",
      "text": "we see no duplication of fact (though the test could be optimized OAOO-wise). As for duplication of tests of specific things, there's no inherent objection, except, of course, that you have to find and change all the places when a change is needed. -- [[Ron Jeffries]]",
      "id": "1dfc33de9420a984a20ecc98c875b459"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "<b>OAOO And SQL</b>",
      "id": "a6225a955b629ef92c1e2d89d701a12e"
    },
    {
      "type": "html",
      "text": "\nI like the idea of OAOO. However, much of my work is RDBMS based (Oracle), meaning that I write a fair bit of SQL. Sometimes, the simplest way to get the data you need is to throw everything into one big (possibly ugly) SQL statement. The database optimizer then works out the best way to get what you need. If the data changes, it does it a different way. The problem is that if I want to encode something once and only once, that means I have to break up these large SQL statements and do things procedurally instead (PL/SQL). This means that the code looks good but runs like a dog and all that money spent on the database and its optimizer is as good as wasted. Thoughts anyone? -- [[Chris Rimmer]]",
      "id": "4a503f674a7e41e20bf0f95c812399a4"
    },
    {
      "type": "html",
      "text": "<i>Anything stopping you from building up the massive SQL statement from the decomposed procedures, and running the optimizer on that?</i>",
      "id": "4a8692b591b5675dd56106d9c924898c"
    },
    {
      "type": "html",
      "text": "\nYes. I think you've misunderstood the problem. The point about SQL is that you tell it what you want, not how to do it. These procedures actually return data, not a fragment of SQL. So there's no way to combine them to produce some big SQL statement.",
      "id": "14021410777b5849e16796d0bb797e16"
    },
    {
      "type": "html",
      "text": "\nThe answer is, I believe, to use database views to encapsulate multi-table relationships. I had already pretty come to this view (pardon the pun) when I read this article by Martin Fowler:",
      "id": "fde8fa8b6b185effcaf53497f6c61f28"
    },
    {
      "type": "html",
      "text": "\n[http://www.martinfowler.com/articles/dblogic.html www.martinfowler.com]",
      "id": "4a14e8e84ce01b66512d6b509cf2c946"
    },
    {
      "type": "html",
      "text": "-- [[Chris Rimmer]]",
      "id": "1c114267c05c2713fd636fbd42de99cc"
    },
    {
      "type": "html",
      "text": "\nYou won't get much direct benefit to performance by practicing OAOO. The benefit comes in reducing complexity and therefore increasing understanding/maintainability/extensibility. In the statement above, \"one big (possibly ugly) SQL statement\" can translate to one big complex, off-putting statement. It may run well, but the next guy that sees it, even if it is you one month from now, may find it sooo hard to understand that he shies away from it, or spends 5 times the effort in understanding and modifying it as would have been necessary for a few separate procedures. -- Jeff Santini",
      "id": "5a604d3931937b2dd46d094d04cafa17"
    },
    {
      "type": "html",
      "text": "\nI have found that I usually get a big performance benefit from this practice; as the refactoring continues and code is isolated and shared, the processing pattern of higher level application layers becomes clearer, function pointers start coming into play (for those of us who did a lot of C and assembler) which makes these higher layers of code properly use polymorphic function/method definitions. Redundant decision making/branching is always reduced or eliminated by doing it. -- Grant Wesley Parks",
      "id": "6d816215c8c6285b98c41ad78620b4a4"
    },
    {
      "type": "html",
      "text": "\nI didn't expect to get a benefit to performance. I was looking for the kind of maintenance gains you talk about. However, what I don't want is a thousand-fold decrease in performance! This is quite possible in the situation I describe. See my comments above about the use of views. -- [[Chris Rimmer]]",
      "id": "727af088beea34560d4a5bc797ee8301"
    },
    {
      "type": "html",
      "text": "\nI don't get it: you think views solve the problem of the execution plan or not? I think they do, with all the benefits of the OAOO. -- [[Cosmin Apreutesei]].",
      "id": "8b23d26c1b425355843db7b6635723f5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "<b>OAOO and Code Generation</b>",
      "id": "92d367032775209bfe714cfb0807ada2"
    },
    {
      "type": "html",
      "text": "\nOAOO is once and only once of human input. If a copy can be regenerated without a human then it does not violate OAOO.\nConsequently [[Code Generation]], for example, does not violate OAOO. Any automated duplication does not violate OAOO. For example, automatically generated program documentation does not violate OAOO even if it contains many duplicates of many pieces of code, as there are two different aspects - OAOO of human input ([[Primary Information]]) and OAOO of computer generated ([[Secondary Information]]). -- [[Aleksey Pavlichenko]]",
      "id": "eb6de3d4e2e0d00214ac2c338e8a4d62"
    },
    {
      "type": "html",
      "text": "\nOAOO of [[Primary Information]] doesn't care about space or runtime performance efficiency; OAOO of human input is what helps produce better code.",
      "id": "7ca9affc4b49dd7ee6421c957af51a32"
    },
    {
      "type": "html",
      "text": "\nOAOO of [[Secondary Information]] affects runtime execution performance or space, but doesn't affect programmer performance. For example, use of C++ templates can easily result in duplicated code, which is not a violation of OAOO because it is code that would not, under normal circumstances, be seen by (or even accessible to) a human.",
      "id": "8d329b97cd9acf4c6a9e08a732033cbf"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "For applying this concept to a more general frame (than programming) please contribute to: [http://www.communitywiki.org/OnceAndOnlyOnce www.communitywiki.org]",
      "id": "794a7aa83631bb4a10f1b325bd9afcf0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "Wouldn't it be that writing to same subject to that other page breaks once and only once? :)",
      "id": "6bff102dabb7161a3a778ca30bf45216"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "I think that [[Once And Only Once]] is a great concept but cannot be taken perfectly literally.. as for example in the documentation, sometimes points need to be repeated in different ways on different pages to ensure the safety of the readers (repeating warnings and such things). Also in code sometimes we have no other choice but to repeat something to make code clearer.... consider:",
      "id": "6135805b79b869487c665f78a3d27a5e"
    },
    {
      "type": "code",
      "text": "  print('more text\\nmore text\\n');",
      "id": "0a4294256bfca72a05c9e58e5cf148b1"
    },
    {
      "type": "html",
      "text": "Versus",
      "id": "fdbcb535bafcdf0104d5efbcf97369e3"
    },
    {
      "type": "code",
      "text": "  println('more text');\n  println('more text');",
      "id": "22cb1465b0906b6f5013174530de6e61"
    },
    {
      "type": "html",
      "text": "The second one may be arguably more repetitive and can be reduced to one print statement.. but not necessarily more clear.\nIf this is not related to [[Once And Only Once]] then please feel free to move this discussion to [[Needless Repetition]].",
      "id": "2c2e89eb37887ee136ddda7dcbeb7240"
    },
    {
      "type": "html",
      "text": "<i>No modeling principle is absolute. There are almost always exceptions and counter-factors. [[Once And Only Once]] is probably one of the simplest and most-agreed-upon modeling principle there is (in a general sense), but there are also exceptions, gray areas, and philosophical dances surrounding it.</i>",
      "id": "a147f741b372428ca957c334e75aadad"
    },
    {
      "type": "html",
      "text": "\n[[Chuck Moore]] has something to say on this, found in [[Thinking Forth]], page 188. While pontificating on the frequency of the idiom <b>OVER + SWAP</b> in Forth software (e.g., <b>OVER + SWAP DO I C@ . LOOP</b>) and why it lacks its own word (e.g., <b>RANGE</b>), he writes,",
      "id": "89f5a6888f2cbb3bb460974c9665d2cf"
    },
    {
      "type": "html",
      "text": " That particular phrase, <b>OVER + SWAP</b>, is one that's right on the margin of being a useful word. Often, though, if you define something as a word, it turns out you use it only once. If you name such a phrase, you have trouble knowing exactly what <b>RANGE</b> does. You can't see the manipulation in your mind. <b>OVER + SWAP</b> has greater mnemonic value than <b>RANGE</b>.",
      "id": "eac4cc095c9a5feb53cc86f9f3b5d3cc"
    },
    {
      "type": "html",
      "text": "\n[[Leo Brodie]] calls them \"cliches,\" but \"idioms\" works as well. The point is, sometimes, over-factoring can produce a net <i>loss</i> of readability to the program. I do not believe that OAOO to be such a hard-and-fast rule that it takes precedence over readability, considering OAOO's sole purpose <i>is</i> the betterment of readability.",
      "id": "96a0db5d883273de20f2a5419666d3fa"
    },
    {
      "type": "html",
      "text": "\nThe println example isn't repetition. You're saying \"Print some text\". Then the next step is \"Print a second lot of text\". It's the output that's repeated, not the code.",
      "id": "2524c50bbc54eb72744ec59db1d8eb42"
    },
    {
      "type": "html",
      "text": "\nActually println is good OAOO. Enumerating print drivers and writing bitmaps/postscript/whatever for each of the 9 chars, then (deep breath) doing it all again would not!",
      "id": "d6c5782cd4c35c409c441e7a2d54ad3e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "The more one generalizes and abstracts, the more difficult it becomes to OAOO. The more you refactor and get it closer, the harder it becomes - kinda like folding paper. - [[Jonathan Crossland]]",
      "id": "620699b4c6dbe439eda4acd06aeefbca"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "Note: New discussion should use \"[[Dont Repeat Yourself]]\"; the DRY term is much more successful, for obvious reasons... C-:",
      "id": "b30b866a2b287a25b726f7e6d1a83e23"
    },
    {
      "type": "html",
      "text": "<i>Why not use [[Exactly Once]] instead? It's a much better and more concise term.</i>",
      "id": "d6498b5bfd64638c0925041c7c89ba82"
    },
    {
      "type": "html",
      "text": "\nBecause it's too strict. It implies we will use [[Big Design Up Front]] to achieve perfect unity. A little duplication is okay; DRY is a transitive verb.",
      "id": "6337c32bdcdfd95c6eb8fc32b604ee47"
    },
    {
      "type": "html",
      "text": "<i>Say, what?!? What in the phrase \"exactly once\" implies big design up front? It's simply a more concise, grammatically accurate rendering of the concept. And by the way, please don't [[Disagree By Deleting]].</i>",
      "id": "bd9b0b8cc487adafcb193714add91799"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "Uses in coding paradigm: [[Copy And Paste Programming]], [[Twice And Only Twice]], [[Trans Clusion]], [[Mirror Model]], [[Seventeen Times And Only Seventeen Times]]",
      "id": "bf483b2a5315314bb223b063c07c240c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "dc095d10fd0356d093f28eda09fb244a"
    },
    {
      "type": "html",
      "text": "See: [[Dont Repeat Yourself]], [[Redundancy Is Inertia]], [[Copy And Paste Programming]], [[Duplication Refactoring Threshold]]",
      "id": "8dbb76e4791bf7cc88a5c83ed56357bb"
    },
    {
      "type": "html",
      "text": "\nCorollary: [[Wiki Pages About Refactoring]]",
      "id": "bf99610699d90b6f57179f34f96c04ce"
    },
    {
      "type": "html",
      "text": "\n[[Category Abstraction]], [[Category Simplification]], [[Category Reuse]]",
      "id": "619d2d6b813aa4da99895c84265db31f"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?OnceAndOnlyOnce c2.com]",
      "id": "02a3ae9fd94a70132283a974a24a251f"
    }
  ],
  "journal": [
    {
      "date": 1415562193000,
      "id": "ea548cb8e49f71c775681f9cf4c1c356",
      "type": "create",
      "item": {
        "title": "Once And Only Once",
        "story": [
          {
            "type": "html",
            "text": "One of the main goals (if not <i>the</i> main goal) when [[Re Factoring]] code. Each and every declaration of behavior should appear [[Once And Only Once]]. Conceptually analogous to normalization in the [[Relational Model]]. See also [[Dont Repeat Yourself]].",
            "id": "ce7c1c64e72e2544e9770a6235b9ff2d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "Code wants to be simple. If you are aware of [[Code Smell]]s, and duplicate code is one of the strongest, and you react accordingly, your systems will get simpler. When I began working in this style, I had to give up the idea that I had the perfect vision of the system to which the system had to conform. Instead, I had to accept that I was only the vehicle for the system expressing its own desire for simplicity. My vision could shape initial direction, and my attention to the desires of the code could affect how quickly and how well the system found its desired shape, but the system is riding me much more than I am riding the system. -- [[Kent Beck]], feeling mystical, see [[Mystical Programming]]",
            "id": "f94972f49e9dd9fe4c94d2fd7ae7b5b0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "<i>Beware of introducing unnecessary coupling ([[Coupling And Cohesion]]) when refactoring for [[Once And Only Once]].</i>",
            "id": "432c9ba4e589d5211d07c98890ba2ca3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "Refactoring is the moving of units of functionality from one place to another in your program. Refactoring has as a primary objective getting each piece of functionality to exist in exactly one place in the software. -- [[Ron Jeffries]]",
            "id": "73e7a67148d488595dba50c62da7d489"
          },
          {
            "type": "html",
            "text": "<i>It's not OAOO, and this comment probably ought to be somewhere else, but doesn't refactoring also cover replacing one piece of code with another, simpler piece of code that has the same external \"appearance\" and function?</i>",
            "id": "560665ac6dd600a100ef20bb534dbab1"
          },
          {
            "type": "html",
            "text": "\nYes - good point. Note Ron's subtle use of \"a primary objective\" instead of \"the primary objective\". I personally use two \"first tier\" refactoring rules - [[Once And Only Once]] and [[Separate The What From The How]] (my name - the common name is [[Composed Method]])",
            "id": "c9b09d5b75becac677e765d086f406ec"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "[[Once And Only Once]] is a profound concept, but difficult to apply. I've spent my entire professional life (25 years) learning how to apply it to programs. This page [<i>many versions ago</i>] ... was rewritten to make [[Once And Only Once]] seem like a simple rule to apply, instead of a prime principle. [[Once And Only Once]] is NOT easy! And it was wrong to refactor this page so that all hints of tension and disagreement are removed from it.",
            "id": "c77a44d24776e618792160f5ddca4ef5"
          },
          {
            "type": "html",
            "text": "\n[[Once And Only Once]] is not a pattern. A pattern is something you can teach someone to do in a fairly short amount of time. A day, usually. Perhaps a few weeks. But learning how to refactor classes to form a [[Template Method]] does not help you see how to use XML to represent your user interfaces (a recent [[Once And Only Once]] technique applied to Squeak), or how to make a good virtual machine. These are patterns; [[Once And Only Once]] is not a pattern. [[Once And Only Once]] is a principle. -- [[Ralph Johnson]]",
            "id": "cbf97024267e80ddecc9ba4106b1d118"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "Well said. [[Once And Only Once]] is not just a simple rule, but one of the core goals of all software design. It's why functions were invented. Remember that your program could have been written as a single long function using only ifs, whiles, and try/catch blocks for flow control, and primitives for all the data. Consider what that would look like. For \"hello world\", it's the default.",
            "id": "d1f8c880d977f9a79f6489b830a93ca7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "I once saw Beck declare two patches of almost completely different code to be \"duplication\", change them so that they WERE duplication, and then remove the newly inserted duplication to come up with something obviously better. -- [[Ron Jeffries]], from the [[Xp Mailing List]]",
            "id": "ce79d7f0da58f2108cd2b1d2e30f1553"
          },
          {
            "type": "html",
            "text": "<i>or, the long version...</i>",
            "id": "0fce52a34d392f5e8f6dcd3a247335a4"
          },
          {
            "type": "html",
            "text": "\nI recall once seeing Beck look at two loops that were quite dissimilar: they had different for structures, and different contents, which is pretty much nothing duplicated except the word \"for\", and the fact that they were looping - differently - over the same collection.",
            "id": "b8c8a9f35a74504a66e7744470f360e8"
          },
          {
            "type": "html",
            "text": "\nHe changed the second loop to loop the same way the first one did. This required changing the body of the loop to skip over the items toward the end of the collection, since the previous version only did the front of the collection.",
            "id": "5204f2ad51b0c36f91e11384df0ad418"
          },
          {
            "type": "html",
            "text": "\nNow the for statements were the same. \"Well, gotta eliminate that duplication, he said, and moved the second body into the first loop and deleted the second loop entirely.",
            "id": "34f9af379ea30775a95d7ee0992b523a"
          },
          {
            "type": "html",
            "text": "\nNow he had two kinds of similar processing going on in the one loop. He found some kind of duplication in there, extracted a method, did a couple of other things, and voila! the code was much better.",
            "id": "e10b7e43dfb86671069581a867b40468"
          },
          {
            "type": "html",
            "text": "\nThat first step - creating duplication - was startling. -- [[Ron Jeffries]], from the [[Xp Mailing List]]",
            "id": "7a3b2a5739657e1dd7d93bebd18e1bcc"
          },
          {
            "type": "html",
            "text": "<i>It isn't so startling. That technique is necessary for the more powerful space optimizations of program code: you reduce everything as much as possible, then you find two subgraphs that are similar, you add conditional nodes to them until they're identical (and inject the proper conditions), then you combine them. Repeat until the apparent gains aren't worth the resource cost to acquire them. Beck is just doing it by hand.</i>",
            "id": "6b715cd7447bae2b299d644c2f35c19b"
          },
          {
            "type": "html",
            "text": "\nIt is also frequently used to allow consistent idiomatic expressions to emerge. This allows bugs to be detected via inspection for all cases where the idiom was not followed properly. This is more than superficial coding standards. For example: a loop guard of < n or <=n will behave differently if n starts at 0 vs starting at 1. It is best to pick one idiom and stick with it. I suspect the duplication here was semantic in nature and culling it out allowed a reuse opportunity to emerge.",
            "id": "967dca398898f51ed3eb016ac9b456a8"
          },
          {
            "type": "html",
            "text": "-- [[Marc Grundfest]]",
            "id": "adf8a14e1eabd33e448f676d5eec2794"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "<b>OAOO And Parallel Inheritance Hierarchies</b>",
            "id": "41673d40662f6a47cea3d96767f66e4d"
          },
          {
            "type": "html",
            "text": "\nIn the slides for [[Xp Immersion]], [[Robert Martin]] mentions parallel inheritance hierarchies as an example of [[Once And Only Once]]. I find it to be one of the hardest repetitions to refactor away, though. Does anyone have any hot tips?",
            "id": "e03fd7ea65826aeff65b039faeb13d3c"
          },
          {
            "type": "html",
            "text": "-- [[Johannes Brodwall]]",
            "id": "1ef23cc4ff01fd755fc5ed9fc9d4c577"
          },
          {
            "type": "html",
            "text": "\nThere are two ways to go. To remove the parallel: refactor either or both hierarchies until their members are congruent, then collapse pairwise. To remove duplication between the parallels: define distinct responsibilities refined by each hierarchy and relocate methods as appropriate. -- [[Ward Cunningham]]",
            "id": "132c55ce94898143e9d04f5de40137ba"
          },
          {
            "type": "html",
            "text": "\nThis all became a little abstract for me. What about an example? Say I have an accounting and logistics system. I have an abstract class Account and an abstract class Transaction. Each transaction transfers something from one account to another. Now, I have several types of accounts: Securities<b></b>Account, Bonds<b></b>Account, Money<b></b>Account, etc. For each type of account there is a transaction: Securities<b></b>Transaction, Bonds<b></b>Transaction, Money<b></b>Transaction, etc. Now what? -- [[Johannes Brodwall]]",
            "id": "4796f47566e2fc8b7390bc22fa6406af"
          },
          {
            "type": "html",
            "text": "\nTo solve your dilemma, try building the abstracts Transaction and Account. If you find something abstract enough to put there, you then might find something to reuse between different types of Accounts and Transactions. If not, it might be that those are just abstractions with no functional meaning for your context of usage. Another idea (some get it as an abuse, some as a smart oop move) is to move from hierarchy/inheritance design to aggregate/composition design, in your case, refactor to Transaction, Account and Transactionable (or Accountable) and descend from Transactionable to Money, Bond, etc. This way all your similarities (read code duplicates) should cut up to Transactionable, leaving Account and Transaction to deal only with the abstract behaviour/data that their names imply. The con is that you will have to invent notions to tie Transactionable to Account/Transaction together. Actually, that's the point where abstraction meets creation, but that's another story (see [[Abstraction Addiction]], [[Too Much Abstraction]], [[Parallel Inheritance Hierarchies]]). -- [[Cosmin Apreutesei]]",
            "id": "a60bcefe38791371c527d54a32e5c577"
          },
          {
            "type": "html",
            "text": "\nA good example indeed. My experience on [[Wy Cash]] was that the prevailing domain classification exerted way too much influence over our initial hierarchies as it may have yours too. We couldn't merge the two hierarchies because Transaction and Account instances have different lifetimes. Instead, as per the second choice above, we focused on redistribution of responsibilities which turned out as follows.",
            "id": "b384948f590d54f007f51a0026670829"
          },
          {
            "type": "html",
            "text": " Transactions -- long lived private factual information",
            "id": "25b48bc675e2d2c82e834c9d76e09cc3"
          },
          {
            "type": "html",
            "text": " Accounts -- organizational structure related to reporting",
            "id": "6f85a0f187a22d3fafbe4676c5c66fce"
          },
          {
            "type": "html",
            "text": " Calculators -- industry accepted analytic components",
            "id": "3f934a461e13a879d5d93f5ed754b925"
          },
          {
            "type": "html",
            "text": " Advancers -- mechanics of interpreting transactions",
            "id": "763666913746818aca1f2bec3813b0b6"
          },
          {
            "type": "html",
            "text": "\nWe were stunned at the discovery of advancers two years into maintenance. We never would have gotten this far without a long term commitment to aggressive refactoring. -- [[Ward Cunningham]] (See [[What Is An Advancer]])",
            "id": "e56a1a2122164c27827266aee115242f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "<b>OAOO And Tests</b>",
            "id": "2da5449bf50f379e0e6602b498395644"
          },
          {
            "type": "html",
            "text": "\n[[Once And Only Once]] sounds like a nice principle but, when taken at face value, would lead to untested code. Even XP advocates stating each fact at least twice, preferably three times.",
            "id": "b26a8a1e120203c0a166b9647f923153"
          },
          {
            "type": "html",
            "text": "\nThe three places where our fact is stated are:",
            "id": "5c43d7ecc57b1c76c2152724a832fbe9"
          },
          {
            "type": "html",
            "text": " what the customer wants ([[Functional Test]]s)",
            "id": "e19a0eef6ba07205504132a9c893bf6f"
          },
          {
            "type": "html",
            "text": " what the programmer wants ([[Unit Test]]s)",
            "id": "7e7ffe69c7eaabf88641de8cd31a8f01"
          },
          {
            "type": "html",
            "text": " what the program does (the program itself)",
            "id": "dd6eb07fe9ac693cd73d0609c72b64a5"
          },
          {
            "type": "html",
            "text": "-- [[Dave Whipp]]",
            "id": "1b46cb907019c2cec888e56445ec07d2"
          },
          {
            "type": "html",
            "text": "\nThis is a good point, Dave. I have another rule I use when information must be duplicated: When you must duplicate information make sure you will automatically detect if the duplicated information falls out of sync. Tests do this implicitly, and by definition. There are other common cases where the duplicated information is not self-testing, though. Assertions are a classic tool for handling this kind of problem. -- [[Curtis Bartley]]",
            "id": "dba85f6dc2aeae5b2932d93733f310f9"
          },
          {
            "type": "html",
            "text": "\nThis point is valid only if the code is perfect. Otherwise the two types of test add information to the overall system, and hence are not duplicating knowledge. Also, to be fair, what you're critiquing here is not really OAOO (which is about code refactoring), but [[Dont Repeat Yourself]], which is wider ranging. -- [[David Thomas]]",
            "id": "0cedc2101b126fee38ffc0a0a2728c32"
          },
          {
            "type": "html",
            "text": "\nThe OAOO principle in XP refers specifically to the program. The program should express each idea once and only once - there should be no duplicate <i>code</i>.",
            "id": "306f53136a0384d3b4c2b52025a05d51"
          },
          {
            "type": "html",
            "text": "\nFurther, comparing the code:",
            "id": "b883be6029ee36588486e041a1a1bc56"
          },
          {
            "type": "code",
            "text": " square(NUMBER x) {\n  return x*x;\n }",
            "id": "88d05cede3163d1542196f1580a17465"
          },
          {
            "type": "html",
            "text": "with the test:",
            "id": "bddac699680e96c42e453463000cb940"
          },
          {
            "type": "code",
            "text": " assertEquals(4, square(2));\n assertEquals(9, square(3));\n assertEquals(4, square(-2));\n assertEquals(9, square(-3));",
            "id": "4c0743628400a5c0e10de27dca590623"
          },
          {
            "type": "html",
            "text": "we see no duplication of fact (though the test could be optimized OAOO-wise). As for duplication of tests of specific things, there's no inherent objection, except, of course, that you have to find and change all the places when a change is needed. -- [[Ron Jeffries]]",
            "id": "1dfc33de9420a984a20ecc98c875b459"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "<b>OAOO And SQL</b>",
            "id": "a6225a955b629ef92c1e2d89d701a12e"
          },
          {
            "type": "html",
            "text": "\nI like the idea of OAOO. However, much of my work is RDBMS based (Oracle), meaning that I write a fair bit of SQL. Sometimes, the simplest way to get the data you need is to throw everything into one big (possibly ugly) SQL statement. The database optimizer then works out the best way to get what you need. If the data changes, it does it a different way. The problem is that if I want to encode something once and only once, that means I have to break up these large SQL statements and do things procedurally instead (PL/SQL). This means that the code looks good but runs like a dog and all that money spent on the database and its optimizer is as good as wasted. Thoughts anyone? -- [[Chris Rimmer]]",
            "id": "4a503f674a7e41e20bf0f95c812399a4"
          },
          {
            "type": "html",
            "text": "<i>Anything stopping you from building up the massive SQL statement from the decomposed procedures, and running the optimizer on that?</i>",
            "id": "4a8692b591b5675dd56106d9c924898c"
          },
          {
            "type": "html",
            "text": "\nYes. I think you've misunderstood the problem. The point about SQL is that you tell it what you want, not how to do it. These procedures actually return data, not a fragment of SQL. So there's no way to combine them to produce some big SQL statement.",
            "id": "14021410777b5849e16796d0bb797e16"
          },
          {
            "type": "html",
            "text": "\nThe answer is, I believe, to use database views to encapsulate multi-table relationships. I had already pretty come to this view (pardon the pun) when I read this article by Martin Fowler:",
            "id": "fde8fa8b6b185effcaf53497f6c61f28"
          },
          {
            "type": "html",
            "text": "\n[http://www.martinfowler.com/articles/dblogic.html www.martinfowler.com]",
            "id": "4a14e8e84ce01b66512d6b509cf2c946"
          },
          {
            "type": "html",
            "text": "-- [[Chris Rimmer]]",
            "id": "1c114267c05c2713fd636fbd42de99cc"
          },
          {
            "type": "html",
            "text": "\nYou won't get much direct benefit to performance by practicing OAOO. The benefit comes in reducing complexity and therefore increasing understanding/maintainability/extensibility. In the statement above, \"one big (possibly ugly) SQL statement\" can translate to one big complex, off-putting statement. It may run well, but the next guy that sees it, even if it is you one month from now, may find it sooo hard to understand that he shies away from it, or spends 5 times the effort in understanding and modifying it as would have been necessary for a few separate procedures. -- Jeff Santini",
            "id": "5a604d3931937b2dd46d094d04cafa17"
          },
          {
            "type": "html",
            "text": "\nI have found that I usually get a big performance benefit from this practice; as the refactoring continues and code is isolated and shared, the processing pattern of higher level application layers becomes clearer, function pointers start coming into play (for those of us who did a lot of C and assembler) which makes these higher layers of code properly use polymorphic function/method definitions. Redundant decision making/branching is always reduced or eliminated by doing it. -- Grant Wesley Parks",
            "id": "6d816215c8c6285b98c41ad78620b4a4"
          },
          {
            "type": "html",
            "text": "\nI didn't expect to get a benefit to performance. I was looking for the kind of maintenance gains you talk about. However, what I don't want is a thousand-fold decrease in performance! This is quite possible in the situation I describe. See my comments above about the use of views. -- [[Chris Rimmer]]",
            "id": "727af088beea34560d4a5bc797ee8301"
          },
          {
            "type": "html",
            "text": "\nI don't get it: you think views solve the problem of the execution plan or not? I think they do, with all the benefits of the OAOO. -- [[Cosmin Apreutesei]].",
            "id": "8b23d26c1b425355843db7b6635723f5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "<b>OAOO and Code Generation</b>",
            "id": "92d367032775209bfe714cfb0807ada2"
          },
          {
            "type": "html",
            "text": "\nOAOO is once and only once of human input. If a copy can be regenerated without a human then it does not violate OAOO.\nConsequently [[Code Generation]], for example, does not violate OAOO. Any automated duplication does not violate OAOO. For example, automatically generated program documentation does not violate OAOO even if it contains many duplicates of many pieces of code, as there are two different aspects - OAOO of human input ([[Primary Information]]) and OAOO of computer generated ([[Secondary Information]]). -- [[Aleksey Pavlichenko]]",
            "id": "eb6de3d4e2e0d00214ac2c338e8a4d62"
          },
          {
            "type": "html",
            "text": "\nOAOO of [[Primary Information]] doesn't care about space or runtime performance efficiency; OAOO of human input is what helps produce better code.",
            "id": "7ca9affc4b49dd7ee6421c957af51a32"
          },
          {
            "type": "html",
            "text": "\nOAOO of [[Secondary Information]] affects runtime execution performance or space, but doesn't affect programmer performance. For example, use of C++ templates can easily result in duplicated code, which is not a violation of OAOO because it is code that would not, under normal circumstances, be seen by (or even accessible to) a human.",
            "id": "8d329b97cd9acf4c6a9e08a732033cbf"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "For applying this concept to a more general frame (than programming) please contribute to: [http://www.communitywiki.org/OnceAndOnlyOnce www.communitywiki.org]",
            "id": "794a7aa83631bb4a10f1b325bd9afcf0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "Wouldn't it be that writing to same subject to that other page breaks once and only once? :)",
            "id": "6bff102dabb7161a3a778ca30bf45216"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "I think that [[Once And Only Once]] is a great concept but cannot be taken perfectly literally.. as for example in the documentation, sometimes points need to be repeated in different ways on different pages to ensure the safety of the readers (repeating warnings and such things). Also in code sometimes we have no other choice but to repeat something to make code clearer.... consider:",
            "id": "6135805b79b869487c665f78a3d27a5e"
          },
          {
            "type": "code",
            "text": "  print('more text\\nmore text\\n');",
            "id": "0a4294256bfca72a05c9e58e5cf148b1"
          },
          {
            "type": "html",
            "text": "Versus",
            "id": "fdbcb535bafcdf0104d5efbcf97369e3"
          },
          {
            "type": "code",
            "text": "  println('more text');\n  println('more text');",
            "id": "22cb1465b0906b6f5013174530de6e61"
          },
          {
            "type": "html",
            "text": "The second one may be arguably more repetitive and can be reduced to one print statement.. but not necessarily more clear.\nIf this is not related to [[Once And Only Once]] then please feel free to move this discussion to [[Needless Repetition]].",
            "id": "2c2e89eb37887ee136ddda7dcbeb7240"
          },
          {
            "type": "html",
            "text": "<i>No modeling principle is absolute. There are almost always exceptions and counter-factors. [[Once And Only Once]] is probably one of the simplest and most-agreed-upon modeling principle there is (in a general sense), but there are also exceptions, gray areas, and philosophical dances surrounding it.</i>",
            "id": "a147f741b372428ca957c334e75aadad"
          },
          {
            "type": "html",
            "text": "\n[[Chuck Moore]] has something to say on this, found in [[Thinking Forth]], page 188. While pontificating on the frequency of the idiom <b>OVER + SWAP</b> in Forth software (e.g., <b>OVER + SWAP DO I C@ . LOOP</b>) and why it lacks its own word (e.g., <b>RANGE</b>), he writes,",
            "id": "89f5a6888f2cbb3bb460974c9665d2cf"
          },
          {
            "type": "html",
            "text": " That particular phrase, <b>OVER + SWAP</b>, is one that's right on the margin of being a useful word. Often, though, if you define something as a word, it turns out you use it only once. If you name such a phrase, you have trouble knowing exactly what <b>RANGE</b> does. You can't see the manipulation in your mind. <b>OVER + SWAP</b> has greater mnemonic value than <b>RANGE</b>.",
            "id": "eac4cc095c9a5feb53cc86f9f3b5d3cc"
          },
          {
            "type": "html",
            "text": "\n[[Leo Brodie]] calls them \"cliches,\" but \"idioms\" works as well. The point is, sometimes, over-factoring can produce a net <i>loss</i> of readability to the program. I do not believe that OAOO to be such a hard-and-fast rule that it takes precedence over readability, considering OAOO's sole purpose <i>is</i> the betterment of readability.",
            "id": "96a0db5d883273de20f2a5419666d3fa"
          },
          {
            "type": "html",
            "text": "\nThe println example isn't repetition. You're saying \"Print some text\". Then the next step is \"Print a second lot of text\". It's the output that's repeated, not the code.",
            "id": "2524c50bbc54eb72744ec59db1d8eb42"
          },
          {
            "type": "html",
            "text": "\nActually println is good OAOO. Enumerating print drivers and writing bitmaps/postscript/whatever for each of the 9 chars, then (deep breath) doing it all again would not!",
            "id": "d6c5782cd4c35c409c441e7a2d54ad3e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "The more one generalizes and abstracts, the more difficult it becomes to OAOO. The more you refactor and get it closer, the harder it becomes - kinda like folding paper. - [[Jonathan Crossland]]",
            "id": "620699b4c6dbe439eda4acd06aeefbca"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "Note: New discussion should use \"[[Dont Repeat Yourself]]\"; the DRY term is much more successful, for obvious reasons... C-:",
            "id": "b30b866a2b287a25b726f7e6d1a83e23"
          },
          {
            "type": "html",
            "text": "<i>Why not use [[Exactly Once]] instead? It's a much better and more concise term.</i>",
            "id": "d6498b5bfd64638c0925041c7c89ba82"
          },
          {
            "type": "html",
            "text": "\nBecause it's too strict. It implies we will use [[Big Design Up Front]] to achieve perfect unity. A little duplication is okay; DRY is a transitive verb.",
            "id": "6337c32bdcdfd95c6eb8fc32b604ee47"
          },
          {
            "type": "html",
            "text": "<i>Say, what?!? What in the phrase \"exactly once\" implies big design up front? It's simply a more concise, grammatically accurate rendering of the concept. And by the way, please don't [[Disagree By Deleting]].</i>",
            "id": "bd9b0b8cc487adafcb193714add91799"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "Uses in coding paradigm: [[Copy And Paste Programming]], [[Twice And Only Twice]], [[Trans Clusion]], [[Mirror Model]], [[Seventeen Times And Only Seventeen Times]]",
            "id": "bf483b2a5315314bb223b063c07c240c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "dc095d10fd0356d093f28eda09fb244a"
          },
          {
            "type": "html",
            "text": "See: [[Dont Repeat Yourself]], [[Redundancy Is Inertia]], [[Copy And Paste Programming]], [[Duplication Refactoring Threshold]]",
            "id": "8dbb76e4791bf7cc88a5c83ed56357bb"
          },
          {
            "type": "html",
            "text": "\nCorollary: [[Wiki Pages About Refactoring]]",
            "id": "bf99610699d90b6f57179f34f96c04ce"
          },
          {
            "type": "html",
            "text": "\n[[Category Abstraction]], [[Category Simplification]], [[Category Reuse]]",
            "id": "619d2d6b813aa4da99895c84265db31f"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?OnceAndOnlyOnce c2.com]",
            "id": "02a3ae9fd94a70132283a974a24a251f"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1627291393879
    }
  ]
}