{
  "title": "Computational Irreducibility",
  "story": [
    {
      "type": "markdown",
      "id": "a5363b1c68c40c1c",
      "text": "While many [[Computation]]s admit shortcuts that allow them to be performed more rapidly, others cannot be sped up. Computations that cannot be sped up by means of any shortcut are called computationally irreducible. The principle of computational irreducibility says that **the only way to determine the answer to a computationally irreducible question is to perform, or [[simulate]], the computation**. Some irreducible computations can be sped up by performing them on faster hardware, as **the principle refers only to computation time**. [https://mathworld.wolfram.com/ComputationalIrreducibility.html wolfram]\n"
    },
    {
      "type": "markdown",
      "id": "b95d630ac21b9342",
      "text": "⇒ [[Simulation Time]]"
    },
    {
      "type": "pagefold",
      "id": "831d2dbda0d61fad",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "e7509b2aeace74b2",
      "text": " According to Wolfram (2002, p. 741), if the behavior of a system is obviously simple – and is say either repetitive or nested – then it will always be computationally reducible. But it follows from the principle of computational equivalence that in practically all other cases it will be computationally irreducible. Here, \"practically all\" refers to cases that arise naturally or from a simple rule system as opposed to cases that are constructed artificially such as the examples given by Wolfram (2002, p. 747).\n\nIsraeli and Goldenfeld (2004) have shown that some computationally irreducible elementary cellular automata have properties that are predictable, and so these properties are computationally reducible. In particular, these cellular automata can emulate reducible cellular automata by coarse-graining. One of those is rule 110, which is a universal cellular automaton.\n\nHowever, as noted by Wolfram (2002, p. 745), \"when the underlying rules are simple there is often still some superficial computational reducibility.... For example, in the rule 30 pattern on the right one can tell whether a cell at a given position has any chance of not being white just by doing a short computation that tests whether that position lies outside the center triangular region of the pattern. And in a class 4 cellular automaton such as rule 110 one can readily shortcut the process of evolution at least for a limited number of steps in places where there happen to be only a few well-separated localized structures present.\" "
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Computational Irreducibility",
        "story": []
      },
      "date": 1651152051784
    },
    {
      "item": {
        "type": "factory",
        "id": "a5363b1c68c40c1c"
      },
      "id": "a5363b1c68c40c1c",
      "type": "add",
      "date": 1651152060568
    },
    {
      "type": "edit",
      "id": "a5363b1c68c40c1c",
      "item": {
        "type": "paragraph",
        "id": "a5363b1c68c40c1c",
        "text": "While many computations admit shortcuts that allow them to be performed more rapidly, others cannot be sped up. Computations that cannot be sped up by means of any shortcut are called computationally irreducible. The principle of computational irreducibility says that the only way to determine the answer to a computationally irreducible question is to perform, or simulate, the computation. Some irreducible computations can be sped up by performing them on faster hardware, as the principle refers only to computation time. "
      },
      "date": 1651152063049
    },
    {
      "type": "edit",
      "id": "a5363b1c68c40c1c",
      "item": {
        "type": "paragraph",
        "id": "a5363b1c68c40c1c",
        "text": "While many computations admit shortcuts that allow them to be performed more rapidly, others cannot be sped up. Computations that cannot be sped up by means of any shortcut are called computationally irreducible. The principle of computational irreducibility says that the only way to determine the answer to a computationally irreducible question is to perform, or simulate, the computation. Some irreducible computations can be sped up by performing them on faster hardware, as the principle refers only to computation time. [https://mathworld.wolfram.com/ComputationalIrreducibility.html wolfram]"
      },
      "date": 1651152078680
    },
    {
      "item": {
        "type": "factory",
        "id": "d37f3d7f85c8fe0b"
      },
      "id": "d37f3d7f85c8fe0b",
      "type": "add",
      "after": "a5363b1c68c40c1c",
      "date": 1654772681658
    },
    {
      "type": "remove",
      "id": "d37f3d7f85c8fe0b",
      "date": 1654772685900
    },
    {
      "item": {
        "type": "factory",
        "id": "831d2dbda0d61fad"
      },
      "id": "831d2dbda0d61fad",
      "type": "add",
      "after": "a5363b1c68c40c1c",
      "date": 1654772687516
    },
    {
      "type": "edit",
      "id": "831d2dbda0d61fad",
      "item": {
        "type": "pagefold",
        "id": "831d2dbda0d61fad",
        "text": "~"
      },
      "date": 1654772690418
    },
    {
      "item": {
        "type": "factory",
        "id": "e7509b2aeace74b2"
      },
      "id": "e7509b2aeace74b2",
      "type": "add",
      "after": "831d2dbda0d61fad",
      "date": 1654772691984
    },
    {
      "type": "edit",
      "id": "e7509b2aeace74b2",
      "item": {
        "type": "paragraph",
        "id": "e7509b2aeace74b2",
        "text": " According to Wolfram (2002, p. 741), if the behavior of a system is obviously simple--and is say either repetitive or nested--then it will always be computationally reducible. But it follows from the principle of computational equivalence that in practically all other cases it will be computationally irreducible. Here, \"practically all\" refers to cases that arise naturally or from a simple rule system as opposed to cases that are constructed artificially such as the examples given by Wolfram (2002, p. 747).\n\nIsraeli and Goldenfeld (2004) have shown that some computationally irreducible elementary cellular automata have properties that are predictable, and so these properties are computationally reducible. In particular, these cellular automata can emulate reducible cellular automata by coarse-graining. One of those is rule 110, which is a universal cellular automaton.\n\nHowever, as noted by Wolfram (2002, p. 745), \"when the underlying rules are simple there is often still some superficial computational reducibility.... For example, in the rule 30 pattern on the right one can tell whether a cell at a given position has any chance of not being white just by doing a short computation that tests whether that position lies outside the center triangular region of the pattern. And in a class 4 cellular automaton such as rule 110 one can readily shortcut the process of evolution at least for a limited number of steps in places where there happen to be only a few well-separated localized structures present.\" "
      },
      "date": 1654772693561
    },
    {
      "type": "edit",
      "id": "e7509b2aeace74b2",
      "item": {
        "type": "paragraph",
        "id": "e7509b2aeace74b2",
        "text": " According to Wolfram (2002, p. 741), if the behavior of a system is obviously simple – and is say either repetitive or nested – then it will always be computationally reducible. But it follows from the principle of computational equivalence that in practically all other cases it will be computationally irreducible. Here, \"practically all\" refers to cases that arise naturally or from a simple rule system as opposed to cases that are constructed artificially such as the examples given by Wolfram (2002, p. 747).\n\nIsraeli and Goldenfeld (2004) have shown that some computationally irreducible elementary cellular automata have properties that are predictable, and so these properties are computationally reducible. In particular, these cellular automata can emulate reducible cellular automata by coarse-graining. One of those is rule 110, which is a universal cellular automaton.\n\nHowever, as noted by Wolfram (2002, p. 745), \"when the underlying rules are simple there is often still some superficial computational reducibility.... For example, in the rule 30 pattern on the right one can tell whether a cell at a given position has any chance of not being white just by doing a short computation that tests whether that position lies outside the center triangular region of the pattern. And in a class 4 cellular automaton such as rule 110 one can readily shortcut the process of evolution at least for a limited number of steps in places where there happen to be only a few well-separated localized structures present.\" "
      },
      "date": 1654772721619
    },
    {
      "type": "edit",
      "id": "a5363b1c68c40c1c",
      "item": {
        "type": "paragraph",
        "id": "a5363b1c68c40c1c",
        "text": "While many [[Computation]]s admit shortcuts that allow them to be performed more rapidly, others cannot be sped up. Computations that cannot be sped up by means of any shortcut are called computationally irreducible. The principle of computational irreducibility says that the only way to determine the answer to a computationally irreducible question is to perform, or simulate, the computation. Some irreducible computations can be sped up by performing them on faster hardware, as the principle refers only to computation time. [https://mathworld.wolfram.com/ComputationalIrreducibility.html wolfram]"
      },
      "date": 1654773136436
    },
    {
      "type": "edit",
      "id": "a5363b1c68c40c1c",
      "item": {
        "type": "paragraph",
        "id": "a5363b1c68c40c1c",
        "text": "While many [[Computation]]s admit shortcuts that allow them to be performed more rapidly, others cannot be sped up. Computations that cannot be sped up by means of any shortcut are called computationally irreducible. The principle of computational irreducibility says that **the only way to determine the answer to a computationally irreducible question is to perform, or simulate, the computation**. Some irreducible computations can be sped up by performing them on faster hardware, as the principle refers only to computation time. [https://mathworld.wolfram.com/ComputationalIrreducibility.html wolfram]"
      },
      "date": 1654773234764
    },
    {
      "type": "edit",
      "id": "a5363b1c68c40c1c",
      "item": {
        "type": "markdown",
        "id": "a5363b1c68c40c1c",
        "text": "While many [[Computation]]s admit shortcuts that allow them to be performed more rapidly, others cannot be sped up. Computations that cannot be sped up by means of any shortcut are called computationally irreducible. The principle of computational irreducibility says that **the only way to determine the answer to a computationally irreducible question is to perform, or simulate, the computation**. Some irreducible computations can be sped up by performing them on faster hardware, as the principle refers only to computation time. [https://mathworld.wolfram.com/ComputationalIrreducibility.html wolfram]"
      },
      "date": 1654773237083
    },
    {
      "type": "edit",
      "id": "a5363b1c68c40c1c",
      "item": {
        "type": "markdown",
        "id": "a5363b1c68c40c1c",
        "text": "While many [[Computation]]s admit shortcuts that allow them to be performed more rapidly, others cannot be sped up. Computations that cannot be sped up by means of any shortcut are called computationally irreducible. The principle of computational irreducibility says that **the only way to determine the answer to a computationally irreducible question is to perform, or [[simulate]], the computation**. Some irreducible computations can be sped up by performing them on faster hardware, as the principle refers only to computation time. [https://mathworld.wolfram.com/ComputationalIrreducibility.html wolfram]"
      },
      "date": 1654773270837
    },
    {
      "type": "edit",
      "id": "a5363b1c68c40c1c",
      "item": {
        "type": "markdown",
        "id": "a5363b1c68c40c1c",
        "text": "While many [[Computation]]s admit shortcuts that allow them to be performed more rapidly, others cannot be sped up. Computations that cannot be sped up by means of any shortcut are called computationally irreducible. The principle of computational irreducibility says that **the only way to determine the answer to a computationally irreducible question is to perform, or [[simulate]], the computation**. Some irreducible computations can be sped up by performing them on faster hardware, as **the principle refers only to computation time**. [https://mathworld.wolfram.com/ComputationalIrreducibility.html wolfram]"
      },
      "date": 1654843550960
    },
    {
      "type": "edit",
      "id": "a5363b1c68c40c1c",
      "item": {
        "type": "markdown",
        "id": "a5363b1c68c40c1c",
        "text": "While many [[Computation]]s admit shortcuts that allow them to be performed more rapidly, others cannot be sped up. Computations that cannot be sped up by means of any shortcut are called computationally irreducible. The principle of computational irreducibility says that **the only way to determine the answer to a computationally irreducible question is to perform, or [[simulate]], the computation**. Some irreducible computations can be sped up by performing them on faster hardware, as **the principle refers only to computation time**. [https://mathworld.wolfram.com/ComputationalIrreducibility.html wolfram]\n"
      },
      "date": 1654843616632
    },
    {
      "type": "add",
      "id": "b95d630ac21b9342",
      "item": {
        "type": "markdown",
        "id": "b95d630ac21b9342",
        "text": "[[Simulation Time]]"
      },
      "after": "a5363b1c68c40c1c",
      "date": 1654843627464
    },
    {
      "type": "edit",
      "id": "b95d630ac21b9342",
      "item": {
        "type": "markdown",
        "id": "b95d630ac21b9342",
        "text": "⇒ [[Simulation Time]]"
      },
      "date": 1654843635621
    }
  ]
}