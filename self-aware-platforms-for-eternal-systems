{
  "title": "Self-Aware Platforms for Eternal Systems",
  "story": [
    {
      "type": "markdown",
      "id": "b48635689a9deea8",
      "text": "Traditionally, the development and deployment of software are viewed as being separate in time and space: first a system is developed, then it is deployed. Indeed, in the classical view, we deal with two completely different artifacts: the source code that can be developed, debugged and understood on the one hand, and on the other hand a generated, closed, non-understandable binary program that just can be run.\n"
    },
    {
      "type": "markdown",
      "id": "3fcc7aaadf9fd048",
      "text": "Classical development plays out like a finite game with fixed rules and boundaries. Eternal software-intensive systems, on the other hand, are better thought of as __infinite games__ without fixed rules or boundaries [3]. Eternal systems will not have a clear separation of development and deployment. The system will continue to evolve when it is already deployed. The systems of the future will not be developed from the outside as a finite game. Development itself will be part of the infinite game of the system. Evolution needs to happen in parts of the system, while it is running.\n"
    },
    {
      "type": "markdown",
      "id": "72ba50660821cdb0",
      "text": "We cannot afford to stop and restart an eternal software system, just as we cannot stop and restart the Internet. The Internet has been up and running since 1969, although each atom that it is physically made of has been replaced since then. The software intensive systems of the future will need to learn from these loosely-coupled, long-lived systems. To support this view, we need appropriate core technologies in terms of programming languages and runtime systems that can serve as a platform for developing eternal systems."
    },
    {
      "type": "markdown",
      "id": "c1ac9e1106bc5d8d",
      "text": "In order to enable change at runtime, an eternal system must be able to fully reflect on itself, that is, it must be self-aware. It is not enough to be model-driven. The models must be explicit and accessible to the run-time system. Furthermore, changes to the model and the system must be explicit and manipulable, so changes must have a first-class representation. Finally, in order to reason about the impact of changes, it is essential that the history of the system must also be fully accessible and manipulable."
    },
    {
      "type": "markdown",
      "id": "fd386e5834886a80",
      "text": "It has been very early understood that abstractions are needed for making programming in the large possible. But with scale, we need to think again: are existing abstractions good enough for __very large__ software systems? One example is that as software gets larger, the idea that every part of the system is in sync with any other part is not very convincing: in huge systems, the parts will indeed be inconsistent. Evolution itself will lead to inconsistency, as the system is so large that we can never evolve the complete system at the same time. As a consequence, an eternal system must be able to cope with multiple, inconsistent views of itself.\n"
    },
    {
      "type": "markdown",
      "id": "6b6195d9ad145cb7",
      "text": "Inconsistency is only tolerable if specific and individual views appear to be locally consistent. Instead of allowing all changes to be globally visible, we need a means to control the scope of changes. That is, eternal systems must support a notion of __context__ and the run-time infrastructure must be __context-aware__. Being able to dispatch on context means that we need to support a form of context-oriented programming [4]. Visibility of changes can then be restricted to the context in which these changes are guaranteed to be valid.\n"
    },
    {
      "type": "markdown",
      "id": "b6566e99b9315c2c",
      "text": "Backward compatibility is the enemy of forward-evolvability. Nevertheless, we cannot live in a world were the old is ignored. A snapshot of an old Windows machine can run on a virtual machine forever, whereas keeping an operating system compatible forever will be bound to fail. Programming languages for eternal systems should provide backwards compatibility in the same way: we need a first class description of the history of all code of the system, freeing the present from being compatible with the past while at the same time providing the possibility to go back in time easily. The system should provide complete, runnable snapshots of the system at any point in the past.\n"
    },
    {
      "type": "markdown",
      "id": "b0ef975c52acdd09",
      "text": "Eternal systems need languages that support continuous development and evolution. But there is another aspect to the language: to think that we can envision the perfect language to realize all future systems is to treat language design like a finite game. Thus a language suited for implementing ever-evolving, eternal software systems needs to be __itself__ an eternal program. An eternal language must evolve to incorporate new ideas and practices while it is used. It needs to be extensible and growable from within [5]."
    },
    {
      "type": "pagefold",
      "id": "7df494e58896caa3",
      "text": "References"
    },
    {
      "type": "markdown",
      "id": "fd7798e7be1578f5",
      "text": "\n"
    },
    {
      "type": "markdown",
      "id": "2a6fec8ba7cace54",
      "text": "[3] J. P. Carse, Finite and Infinite Games — A Vision of Life as Play and Possibility. Ballantine Books, 1987.\n\n"
    },
    {
      "type": "markdown",
      "id": "691b3f3a46d36f24",
      "text": "[4] P. Costanza and R. Hirschfeld, “[[Language constructs for context-oriented programming]]: An overview of ContextL,” in Proceedings of the Dynamic Languages Symposium (DLS) ’05, co-organized with OOPSLA’05, (New York, NY, USA), pp. 1–10, ACM, Oct. 2005."
    },
    {
      "type": "markdown",
      "id": "6ed68445255657c8",
      "text": "[5] G. Steele, “Growing a language,” Higher-Order and Symbolic Computation, vol. 12, pp. 221–236, Oct. 1999."
    },
    {
      "type": "pagefold",
      "id": "a361d3f847f8660d",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "4d9177b24cc85e49",
      "text": "Next: [[Analyzing Self-Aware Eternal Systems]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Self-Aware Platforms for Eternal Systems",
        "story": []
      },
      "date": 1633641015056
    },
    {
      "item": {
        "type": "factory",
        "id": "b48635689a9deea8"
      },
      "id": "b48635689a9deea8",
      "type": "add",
      "date": 1633641022282
    },
    {
      "type": "edit",
      "id": "b48635689a9deea8",
      "item": {
        "type": "markdown",
        "id": "b48635689a9deea8",
        "text": "Traditionally, the development and deployment of software are viewed as being separate in time and space: first a system is developed, then it is deployed. Indeed, in the classical view, we deal with two completely different artifacts: the source code that can be developed, debugged and understood on the one hand, and on the other hand a generated, closed, non-understandable binary program that just can be run."
      },
      "date": 1633641026792
    },
    {
      "type": "edit",
      "id": "b48635689a9deea8",
      "item": {
        "type": "markdown",
        "id": "b48635689a9deea8",
        "text": "Traditionally, the development and deployment of software are viewed as being separate in time and space: first a system is developed, then it is deployed. Indeed, in the classical view, we deal with two completely different artifacts: the source code that can be developed, debugged and understood on the one hand, and on the other hand a generated, closed, non-understandable binary program that just can be run.\n"
      },
      "date": 1633641033582
    },
    {
      "type": "add",
      "id": "3fcc7aaadf9fd048",
      "item": {
        "type": "markdown",
        "id": "3fcc7aaadf9fd048",
        "text": "Classical development plays out like a finite game with fixed rules and boundaries. Eternal software-intensive systems, on the other hand, are better thought of as __infinite games__ without fixed rules or boundaries [3]. Eternal systems will not have a clear separation of development and deployment. The system will continue to evolve when it is already deployed. The systems of the future will not be developed from the outside as a finite game. Development itself will be part of the infinite game of the system. Evolution needs to happen in parts of the system, while it is running."
      },
      "after": "b48635689a9deea8",
      "date": 1633641074813
    },
    {
      "type": "edit",
      "id": "3fcc7aaadf9fd048",
      "item": {
        "type": "markdown",
        "id": "3fcc7aaadf9fd048",
        "text": "Classical development plays out like a finite game with fixed rules and boundaries. Eternal software-intensive systems, on the other hand, are better thought of as __infinite games__ without fixed rules or boundaries [3]. Eternal systems will not have a clear separation of development and deployment. The system will continue to evolve when it is already deployed. The systems of the future will not be developed from the outside as a finite game. Development itself will be part of the infinite game of the system. Evolution needs to happen in parts of the system, while it is running.\n"
      },
      "date": 1633641083117
    },
    {
      "type": "add",
      "id": "72ba50660821cdb0",
      "item": {
        "type": "markdown",
        "id": "72ba50660821cdb0",
        "text": "We cannot afford to stop and restart an eternal software system, just as we cannot stop and restart the Internet. The Internet has been up and running since 1969, although each atom that it is physically made of has been replaced since then. The software intensive systems of the future will need to learn from these loosely-coupled, long-lived systems. To support this view, we need appropriate core technologies in terms of programming languages and runtime systems that can serve as a platform for developing eternal systems."
      },
      "after": "3fcc7aaadf9fd048",
      "date": 1633641088849
    },
    {
      "item": {
        "type": "factory",
        "id": "c1ac9e1106bc5d8d"
      },
      "id": "c1ac9e1106bc5d8d",
      "type": "add",
      "after": "72ba50660821cdb0",
      "date": 1633641103451
    },
    {
      "type": "edit",
      "id": "c1ac9e1106bc5d8d",
      "item": {
        "type": "markdown",
        "id": "c1ac9e1106bc5d8d",
        "text": "In order to enable change at runtime, an eternal system must be able to fully reflect on itself, that is, it must be self-aware. It is not enough to be model-driven. The models must be explicit and accessible to the run-time system. Furthermore, changes to the model and the system must be explicit and manipulable, so changes must have a first-class representation. Finally, in order to reason about the impact of changes, it is essential that the history of the system must also be fully accessible and manipulable."
      },
      "date": 1633641114320
    },
    {
      "item": {
        "type": "factory",
        "id": "fd386e5834886a80"
      },
      "id": "fd386e5834886a80",
      "type": "add",
      "after": "c1ac9e1106bc5d8d",
      "date": 1633641140481
    },
    {
      "type": "edit",
      "id": "fd386e5834886a80",
      "item": {
        "type": "markdown",
        "id": "fd386e5834886a80",
        "text": "It has been very early understood that abstractions are needed for making programming in the large possible. But with scale, we need to think again: are existing abstractions good enough for __very large__ software systems? One example is that as software gets larger, the idea that every part of the system is in sync with any other part is not very convincing: in huge systems, the parts will indeed be inconsistent. Evolution itself will lead to inconsistency, as the system is so large that we can never evolve the complete system at the same time. As a consequence, an eternal system"
      },
      "date": 1633641157928
    },
    {
      "type": "edit",
      "id": "fd386e5834886a80",
      "item": {
        "type": "markdown",
        "id": "fd386e5834886a80",
        "text": "It has been very early understood that abstractions are needed for making programming in the large possible. But with scale, we need to think again: are existing abstractions good enough for __very large__ software systems? One example is that as software gets larger, the idea that every part of the system is in sync with any other part is not very convincing: in huge systems, the parts will indeed be inconsistent. Evolution itself will lead to inconsistency, as the system is so large that we can never evolve the complete system at the same time. As a consequence, an eternal system must be able to cope with multiple, inconsistent views of itself."
      },
      "date": 1633641167226
    },
    {
      "type": "edit",
      "id": "fd386e5834886a80",
      "item": {
        "type": "markdown",
        "id": "fd386e5834886a80",
        "text": "It has been very early understood that abstractions are needed for making programming in the large possible. But with scale, we need to think again: are existing abstractions good enough for __very large__ software systems? One example is that as software gets larger, the idea that every part of the system is in sync with any other part is not very convincing: in huge systems, the parts will indeed be inconsistent. Evolution itself will lead to inconsistency, as the system is so large that we can never evolve the complete system at the same time. As a consequence, an eternal system must be able to cope with multiple, inconsistent views of itself.\n"
      },
      "date": 1633641176280
    },
    {
      "type": "add",
      "id": "6b6195d9ad145cb7",
      "item": {
        "type": "markdown",
        "id": "6b6195d9ad145cb7",
        "text": "Inconsistency is only tolerable if specific and individual views appear to be locally consistent. Instead of allowing all changes to be globally visi- ble, we need a means to control the scope of changes. That is, eternal systems must support a notion of context and the run-time infrastructure must be context-aware. Being able to dispatch on context means that we need to support a form of context-oriented programming [4]. Visibility of changes can then be restricted to the context in which these changes are guaranteed to be valid."
      },
      "after": "fd386e5834886a80",
      "date": 1633641179552
    },
    {
      "type": "edit",
      "id": "6b6195d9ad145cb7",
      "item": {
        "type": "markdown",
        "id": "6b6195d9ad145cb7",
        "text": "Inconsistency is only tolerable if specific and individual views appear to be locally consistent. Instead of allowing all changes to be globally visible, we need a means to control the scope of changes. That is, eternal systems must support a notion of __context__ and the run-time infrastructure must be __context-aware__. Being able to dispatch on context means that we need to support a form of context-oriented programming [4]. Visibility of changes can then be restricted to the context in which these changes are guaranteed to be valid.\n"
      },
      "date": 1633641222969
    },
    {
      "type": "add",
      "id": "b6566e99b9315c2c",
      "item": {
        "type": "markdown",
        "id": "b6566e99b9315c2c",
        "text": "Backward compatibility is the enemy of forward-evolvability. Nevertheless, we cannot live in a world were the old is ignored. A snapshot of an old Windows machine can run on a virtual machine forever, whereas keeping an operating system compatible forever will be bound to fail. Programming languages for eternal systems should provide backwards compatibility in the same way: we need a first class description of the history of all code of the system, freeing the present from being compatible with the past while at the same time providing the possibility to go back in time easily. The system should provide complete, runnable snapshots of the system at any point in the past."
      },
      "after": "6b6195d9ad145cb7",
      "date": 1633641236792
    },
    {
      "type": "edit",
      "id": "b6566e99b9315c2c",
      "item": {
        "type": "markdown",
        "id": "b6566e99b9315c2c",
        "text": "Backward compatibility is the enemy of forward-evolvability. Nevertheless, we cannot live in a world were the old is ignored. A snapshot of an old Windows machine can run on a virtual machine forever, whereas keeping an operating system compatible forever will be bound to fail. Programming languages for eternal systems should provide backwards compatibility in the same way: we need a first class description of the history of all code of the system, freeing the present from being compatible with the past while at the same time providing the possibility to go back in time easily. The system should provide complete, runnable snapshots of the system at any point in the past.\n"
      },
      "date": 1633641244695
    },
    {
      "type": "add",
      "id": "b0ef975c52acdd09",
      "item": {
        "type": "markdown",
        "id": "b0ef975c52acdd09",
        "text": "Eternal systems need languages that support continuous development and evolution. But there is another aspect to the language: to think that we can envision the perfect language to realize all future systems is to treat language design like a finite game. Thus a language suited for implementing ever-evolving, eternal software systems needs to be __itself__ an eternal program. An eternal language must evolve to incorporate new ideas and practices while it is used. It needs to be extensible and growable from within [5]."
      },
      "after": "b6566e99b9315c2c",
      "date": 1633641273407
    },
    {
      "item": {
        "type": "factory",
        "id": "7df494e58896caa3"
      },
      "id": "7df494e58896caa3",
      "type": "add",
      "after": "b0ef975c52acdd09",
      "date": 1633641286081
    },
    {
      "type": "edit",
      "id": "7df494e58896caa3",
      "item": {
        "type": "pagefold",
        "id": "7df494e58896caa3",
        "text": "References"
      },
      "date": 1633641290679
    },
    {
      "item": {
        "type": "factory",
        "id": "fd7798e7be1578f5"
      },
      "id": "fd7798e7be1578f5",
      "type": "add",
      "after": "7df494e58896caa3",
      "date": 1633641299788
    },
    {
      "type": "edit",
      "id": "fd7798e7be1578f5",
      "item": {
        "type": "markdown",
        "id": "fd7798e7be1578f5",
        "text": "[5] G. Steele, “Growing a language,” Higher-Order and Symbolic Computation, vol. 12, pp. 221–236, Oct. 1999."
      },
      "date": 1633641306654
    },
    {
      "type": "edit",
      "id": "fd7798e7be1578f5",
      "item": {
        "type": "markdown",
        "id": "fd7798e7be1578f5",
        "text": "\n"
      },
      "date": 1633669823021
    },
    {
      "type": "add",
      "id": "2a6fec8ba7cace54",
      "item": {
        "type": "markdown",
        "id": "2a6fec8ba7cace54",
        "text": "[5] G. Steele, “Growing a language,” Higher-Order and Symbolic Computation, vol. 12, pp. 221–236, Oct. 1999."
      },
      "after": "fd7798e7be1578f5",
      "date": 1633669825055
    },
    {
      "type": "edit",
      "id": "2a6fec8ba7cace54",
      "item": {
        "type": "markdown",
        "id": "2a6fec8ba7cace54",
        "text": "[3] J. P. Carse, Finite and Infinite Games — A Vision of Life as Play and Possibility. Ballantine Books, 1987.\n"
      },
      "date": 1633669828223
    },
    {
      "type": "add",
      "id": "6ed68445255657c8",
      "item": {
        "type": "markdown",
        "id": "6ed68445255657c8",
        "text": "[5] G. Steele, “Growing a language,” Higher-Order and Symbolic Computation, vol. 12, pp. 221–236, Oct. 1999."
      },
      "after": "2a6fec8ba7cace54",
      "date": 1633669837193
    },
    {
      "type": "edit",
      "id": "2a6fec8ba7cace54",
      "item": {
        "type": "markdown",
        "id": "2a6fec8ba7cace54",
        "text": "[3] J. P. Carse, Finite and Infinite Games — A Vision of Life as Play and Possibility. Ballantine Books, 1987.\n\n"
      },
      "date": 1633670602893
    },
    {
      "type": "add",
      "id": "691b3f3a46d36f24",
      "item": {
        "type": "markdown",
        "id": "691b3f3a46d36f24",
        "text": "[4] P. Costanza and R. Hirschfeld, “Language constructs for context- oriented programming: An overview of ContextL,” in Proceedings of the Dynamic Languages Symposium (DLS) ’05, co-organized with OOPSLA’05, (New York, NY, USA), pp. 1–10, ACM, Oct. 2005."
      },
      "after": "2a6fec8ba7cace54",
      "date": 1633670606866
    },
    {
      "type": "edit",
      "id": "691b3f3a46d36f24",
      "item": {
        "type": "markdown",
        "id": "691b3f3a46d36f24",
        "text": "[4] P. Costanza and R. Hirschfeld, “Language constructs for context- oriented programming: An overview of ContextL,” in Proceedings of the Dynamic Languages Symposium (DLS) ’05, co-organized with OOPSLA’05, (New York, NY, USA), pp. 1–10, ACM, Oct. 2005.\nSee [[Language Constructs for Context-Oriented Programming]]"
      },
      "date": 1633670965455
    },
    {
      "type": "edit",
      "id": "691b3f3a46d36f24",
      "item": {
        "type": "markdown",
        "id": "691b3f3a46d36f24",
        "text": "[4] P. Costanza and R. Hirschfeld, “[[Language constructs for context- oriented programming]]: An overview of ContextL,” in Proceedings of the Dynamic Languages Symposium (DLS) ’05, co-organized with OOPSLA’05, (New York, NY, USA), pp. 1–10, ACM, Oct. 2005."
      },
      "date": 1633671041642
    },
    {
      "type": "edit",
      "id": "691b3f3a46d36f24",
      "item": {
        "type": "markdown",
        "id": "691b3f3a46d36f24",
        "text": "[4] P. Costanza and R. Hirschfeld, “[[Language constructs for context-oriented programming]]: An overview of ContextL,” in Proceedings of the Dynamic Languages Symposium (DLS) ’05, co-organized with OOPSLA’05, (New York, NY, USA), pp. 1–10, ACM, Oct. 2005."
      },
      "date": 1633671054843
    },
    {
      "item": {
        "type": "factory",
        "id": "a361d3f847f8660d"
      },
      "id": "a361d3f847f8660d",
      "type": "add",
      "after": "6ed68445255657c8",
      "date": 1633671244463
    },
    {
      "item": {
        "type": "factory",
        "id": "4d9177b24cc85e49"
      },
      "id": "4d9177b24cc85e49",
      "type": "add",
      "after": "a361d3f847f8660d",
      "date": 1633671251079
    },
    {
      "type": "edit",
      "id": "a361d3f847f8660d",
      "item": {
        "type": "pagefold",
        "id": "a361d3f847f8660d",
        "text": "~"
      },
      "date": 1633671252899
    },
    {
      "type": "edit",
      "id": "4d9177b24cc85e49",
      "item": {
        "type": "markdown",
        "id": "4d9177b24cc85e49",
        "text": "Next: [[Analyzing Self-Aware Eternal Systems]]"
      },
      "date": 1633671263738
    }
  ]
}