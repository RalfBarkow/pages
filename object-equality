{
  "title": "Object Equality",
  "story": [
    {
      "type": "paragraph",
      "id": "b12932b05b75cfe6",
      "text": "is done by reference, not value. For two objects to be equal they have to be exactly the same object. Though, when type casting or type coercion comes into play objects get some interesting behavior."
    },
    {
      "type": "code",
      "id": "cc1e7f1b6ce39b44",
      "text": "var a = { foo: 'bar' }\nvar b = { foo: 'bar' }\n\nconsole.log(a === b) // false"
    },
    {
      "type": "paragraph",
      "id": "fdf644427c9635be",
      "text": "Despite having the same properties with the same values, a and b are not equal."
    },
    {
      "type": "code",
      "id": "080434f80ed8c0c3",
      "text": "var a =\n  { foo: 'bar'\n  , toString: function () {\n      return this.foo\n    }\n  }\n\nconsole.log(a == 'bar') // true"
    },
    {
      "type": "paragraph",
      "id": "83b38ff6315e5bfe",
      "text": "If you provide a toString function it will get used when the object is coerced into a string. Unless you also provide a valueOf function..."
    },
    {
      "type": "code",
      "id": "672f212168bf1d0a",
      "text": "var a =\n  { foo: 'bar'\n  , toString: function () {\n      return this.foo\n    }\n  , valueOf: function () {\n      return 10\n    }\n  }\n\nconsole.log(a == 'bar') // false???\n\nconsole.log(a > 9) // true\n\nconsole.log(a < 11) // true\n\nconsole.log(''+a) // 10, Ohhh"
    },
    {
      "type": "paragraph",
      "id": "433662893a2ba01c",
      "text": "The valueOf function becomes how you get the actual value out of the object. It works well for a lot of use cases, but in most situations you don't want to be doing type coercive operations on an object, hoping that they have implemented toString/valueOf in sensible ways."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Object Equality",
        "story": []
      },
      "date": 1431842663374
    },
    {
      "item": {
        "type": "factory",
        "id": "b12932b05b75cfe6"
      },
      "id": "b12932b05b75cfe6",
      "type": "add",
      "date": 1431842665273
    },
    {
      "type": "edit",
      "id": "b12932b05b75cfe6",
      "item": {
        "type": "paragraph",
        "id": "b12932b05b75cfe6",
        "text": "Object equality is done by reference, not value. For two objects to be equal they have to be exactly the same object. Though, when type casting or type coercion comes into play objects get some interesting behavior."
      },
      "date": 1431842778342
    },
    {
      "item": {
        "type": "factory",
        "id": "cc1e7f1b6ce39b44"
      },
      "id": "cc1e7f1b6ce39b44",
      "type": "add",
      "after": "b12932b05b75cfe6",
      "date": 1431842829258
    },
    {
      "type": "edit",
      "id": "cc1e7f1b6ce39b44",
      "item": {
        "type": "code",
        "id": "cc1e7f1b6ce39b44",
        "text": "var a = { foo: 'bar' }\nvar b = { foo: 'bar' }\n\nconsole.log(a === b) // false"
      },
      "date": 1431842837425
    },
    {
      "item": {
        "type": "factory",
        "id": "fdf644427c9635be"
      },
      "id": "fdf644427c9635be",
      "type": "add",
      "after": "cc1e7f1b6ce39b44",
      "date": 1431842886304
    },
    {
      "type": "edit",
      "id": "fdf644427c9635be",
      "item": {
        "type": "paragraph",
        "id": "fdf644427c9635be",
        "text": "Despite having the same properties with the same values, a and b are not equal."
      },
      "date": 1431842916762
    },
    {
      "item": {
        "type": "factory",
        "id": "080434f80ed8c0c3"
      },
      "id": "080434f80ed8c0c3",
      "type": "add",
      "after": "fdf644427c9635be",
      "date": 1431843178813
    },
    {
      "type": "edit",
      "id": "080434f80ed8c0c3",
      "item": {
        "type": "code",
        "id": "080434f80ed8c0c3",
        "text": "var a =\n  { foo: 'bar'\n  , toString: function () {\n      return this.foo\n    }\n  }\n\nconsole.log(a == 'bar') // true"
      },
      "date": 1431843187473
    },
    {
      "item": {
        "type": "factory",
        "id": "83b38ff6315e5bfe"
      },
      "id": "83b38ff6315e5bfe",
      "type": "add",
      "after": "080434f80ed8c0c3",
      "date": 1431843266064
    },
    {
      "type": "edit",
      "id": "83b38ff6315e5bfe",
      "item": {
        "type": "paragraph",
        "id": "83b38ff6315e5bfe",
        "text": "If you provide a toString function it will get used when the object is coerced into a string. Unless you also provide a valueOf function..."
      },
      "date": 1431843318329
    },
    {
      "item": {
        "type": "factory",
        "id": "672f212168bf1d0a"
      },
      "id": "672f212168bf1d0a",
      "type": "add",
      "after": "83b38ff6315e5bfe",
      "date": 1431843414421
    },
    {
      "type": "edit",
      "id": "672f212168bf1d0a",
      "item": {
        "type": "code",
        "id": "672f212168bf1d0a",
        "text": "var a =\n  { foo: 'bar'\n  , toString: function () {\n      return this.foo\n    }\n  , valueOf: function () {\n      return 10\n    }\n  }\n\nconsole.log(a == 'bar') // false???\n\nconsole.log(a > 9) // true\n\nconsole.log(a < 11) // true\n\nconsole.log(''+a) // 10, Ohhh"
      },
      "date": 1431843420980
    },
    {
      "item": {
        "type": "factory",
        "id": "433662893a2ba01c"
      },
      "id": "433662893a2ba01c",
      "type": "add",
      "after": "672f212168bf1d0a",
      "date": 1431892040351
    },
    {
      "type": "edit",
      "id": "433662893a2ba01c",
      "item": {
        "type": "paragraph",
        "id": "433662893a2ba01c",
        "text": "The valueOf function becomes how you get the actual value out of the object. It works well for a lot of use cases, but in most situations you don't want to be doing type coercive operations on an object, hoping that they have implemented toString/valueOf in sensible ways."
      },
      "date": 1431892203906
    },
    {
      "type": "fork",
      "site": "nrn.io",
      "date": 1652868525403
    },
    {
      "type": "edit",
      "id": "b12932b05b75cfe6",
      "item": {
        "type": "paragraph",
        "id": "b12932b05b75cfe6",
        "text": "is done by reference, not value. For two objects to be equal they have to be exactly the same object. Though, when type casting or type coercion comes into play objects get some interesting behavior."
      },
      "date": 1678198774111
    }
  ]
}