{
  "title": "Shield Pattern",
  "story": [
    {
      "type": "html",
      "text": "A 'Shield' is a phrase in a program that lets you protect some change decision behind it. There are all sorts of shields in programming - that's what programming for robustness is all about, which is why Shield is a pattern that gets invented over and over in different forms. [[Dont Distinguish Between Classes And Interfaces]] is the latest example. Other examples include subroutines, classes, patterns, frameworks, and the fact that in Eiffel and Self an attribute access reads the same as a function call.",
      "id": "c6161c5fc0878446bebf771d60469785"
    },
    {
      "type": "html",
      "text": "<i>All the discussion here makes me wonder if [[Shield Pattern]] is really a [[Meta Pattern]] - a [[Pattern About Patterns]], since so many of the patterns seem to fit</i> -- [[Pete Hardie]]",
      "id": "1ba12214c92c6ac8c2a10ff951f38955"
    },
    {
      "type": "html",
      "text": "\nThe point of the Shield pattern is that you write something in one place, and you are permitted to change your mind about the implementation without changing the reference.",
      "id": "637d9364150c02b1654aacf8316d1919"
    },
    {
      "type": "html",
      "text": "\nIn the cases I have found so far, a Shield takes the form of an interface definition. I think that is because programming is behavioral.",
      "id": "63da1f852607ea6ee409fe82cd2ca16a"
    },
    {
      "type": "html",
      "text": "\nIf there were a pattern whose title takes the form of advice, it would be [[Smallest Shield]] (I don't really care for patterns whose title takes the form of advice, these days; I am experimenting with naming them for their end result). [[Smallest Shield]] says you will do well for your program if you use the smallest possible shield at any moment. Shields are, from smaller to larger:",
      "id": "4b7740eb280b5541df2fa56b85aa7a4f"
    },
    {
      "type": "html",
      "text": " function name (put Eiffel/Self attributes here also)",
      "id": "227161d4bf02838d8037fc32c29e2592"
    },
    {
      "type": "html",
      "text": " class name (put interface vs class name here also)",
      "id": "faa0adf31a39c3301f4b4499804910ea"
    },
    {
      "type": "html",
      "text": " Bridge pattern",
      "id": "031d71270eb228048254aee43143dc27"
    },
    {
      "type": "html",
      "text": " framework name",
      "id": "df8a684c33284661d939586c0168d26a"
    },
    {
      "type": "html",
      "text": "\nI guess that I or we finally have enough data to write up Shield as an official pattern (I have been teaching it for several years, but never thought to write it up before seeing this new use).",
      "id": "2be61545c5553cca00281c8c4fb7269d"
    },
    {
      "type": "html",
      "text": "-- [[Alistair Cockburn]]",
      "id": "ffd063b06b486bd891c9b4e395525e61"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "Can you explain [[Smallest Shield]] a bit more? Is it a combination of [[Shield Pattern]] and [[Do The Simplest Thing That Could Possibly Work]]?",
      "id": "b0bb13262101f15e7feb53f33a57e5a8"
    },
    {
      "type": "html",
      "text": "\nI've recently found myself using big Shields - that is, abstract base classes or interfaces when there is only one implementation behind them. I'm not sure you can convince me this is a bad idea :-)",
      "id": "9376e76336f2d05340751732603ab755"
    },
    {
      "type": "html",
      "text": "-- [[Dave Harris]]",
      "id": "949249fca4f809918ea05d90b2164c9f"
    },
    {
      "type": "html",
      "text": "\nIsn't this just modularity done right; that is, for information hiding? How is Shield different from what [[David Parnas]] wrote in his famous paper [[On Decomposing Systems]]? I'm certainly not complaining about the idea, which is very important, but why give it a new name?",
      "id": "a01e115fd757a32bf6db26f7ad0781f0"
    },
    {
      "type": "html",
      "text": "-- [[Ralph Johnson]]",
      "id": "c379ca4203fec2bca5a7d93d13f5931e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "\nOkay, so this either is not as obvious as I thought, or else it is really trivial and I just haven't seen it yet. Modularity has to do with splitting a program into modules, as in files or classes or something... creating an interface to a module is one form of shield. The fact that in Eiffel an attribute access is \"object.value\" and a function is \"object.value\" is a careful part of the language design and can't be explained by modularity. Nonetheless, it is a shield.",
      "id": "5ee818434db1c9a7155bc24b9eeb9c3e"
    },
    {
      "type": "html",
      "text": "\nThere are different size shields, with different costs for maintenance and different protections. [[David Parnas]]' paper does not talk about the different shields, their costs and values. He more or less picks one size shield, the ambiguous thing called a module. In those days it might have meant a file within a C program. With some stretching you can read it to mean class, or really stretch it to mean framework. I don't think his 'module' can be stretched to cover Java's interfaces. I listed six shields above.",
      "id": "ed38a7bc7fcb657196690f887ae8605d"
    },
    {
      "type": "html",
      "text": "\nThe first time I talked about protecting design decisions behind an interface, I got a classroom full of designs containing interfaces to interfaces to interfaces to interfaces, and nothing carrying out the function. That's when I learned there is possibly too much of a good thing. So I started caring about the weight of a shield.",
      "id": "bff2ec0bb5b3a8fb45526a030868eeee"
    },
    {
      "type": "html",
      "text": "\nSo let me ask you a question - ",
      "id": "9caeb3172e50b92ac24d73f2e9e05b68"
    },
    {
      "type": "html",
      "text": "\nQ1. when is it sufficient to use a function or method, and when must you create a class (for example, [[Dave Harris]]'s abstract base class, above)?",
      "id": "699225adf1104d78e89615884dbc5638"
    },
    {
      "type": "html",
      "text": "\nQ2. When would you use the double interface provided by Bridge or Facade instead of just the single interface provided by a class?",
      "id": "60080630cbf028ff3aee75638f8e275b"
    },
    {
      "type": "html",
      "text": "(If you know of a prior name that carries this discussion, please let me know so I can start translating my slides to use it.)",
      "id": "6976709f3b9429d84f3fbe98769b0c86"
    },
    {
      "type": "html",
      "text": "-- [[Alistair Cockburn]]",
      "id": "ffd063b06b486bd891c9b4e395525e61"
    },
    {
      "type": "html",
      "text": "\nDave, I am guessing you have found over time that when you didn't program an abstract base class, you got bitten a number of times having to create substitutable peer classes, and so ended up breaking your class into an ABC with subclasses. If that hasn't been the case, I can't really imagine why you bother with an ABC and look forward to telling about it. I further guess you count on the fact of the C++ compiler compiling out the overhead of the ABC, and if there were a real performance penalty for using one, you'd rethink your habit.",
      "id": "1627f0189ea4fc5a73e5c0c53ac91a9c"
    },
    {
      "type": "html",
      "text": "\nRegarding Java, I guessed a while back that there would evolve two schools of programming, those who create interface-class pairs as a matter of habit and those who create interfaces when their class needs the protection. I have been seeing that evolution on Wiki here. (I think I am too lazy to make it a matter of habit, and will probably join the latter school, but I haven't fully decided yet).",
      "id": "7d65c8be50b4429840fc774e3a16d46b"
    },
    {
      "type": "html",
      "text": "\nProbably the topic Dave is picking up is, What is the penalty for using a heavier shield?",
      "id": "1eb2f7780544720b1b30644006e84352"
    },
    {
      "type": "html",
      "text": "--- [[Alistair Cockburn]]",
      "id": "ac21620dcf67b6bb21543f38123a35b6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "I guess I'm a bit dull this afternoon. Probably that chicken sandwich. How is Shield different from Encapsulation? I thought that was the property of an object that hid implementation while publishing interface?",
      "id": "3d5321cdaa8b5ed99c0ab76aa8372240"
    },
    {
      "type": "html",
      "text": "--[[Ron Jeffries]]",
      "id": "8ab2b13c0aed11889626f00472d543f4"
    },
    {
      "type": "html",
      "text": "\nWell, maybe I'm the dull one. Help me out. Answer a couple questions:",
      "id": "2a777c500a9174c8bf74084e7ad768b7"
    },
    {
      "type": "html",
      "text": "\nQ3. What exactly does a Java interface encapsulate? (Makes me wonder, Java has interfaces, Smalltalk doesn't - does that make Smalltalk less encapsulated than Java?)",
      "id": "911fa96838bf3d1da469529daa6c7e76"
    },
    {
      "type": "html",
      "text": "\nQ4. In [[Premature Generalization]] there is talk against making abstract base classes too early. What is the problem? (it sounds like that is \"just encapsulation\")",
      "id": "3dd25f75276a5fb31984e9db2e889dba"
    },
    {
      "type": "html",
      "text": "\nQ5. Is there such a thing as too much encapsulation?",
      "id": "e4dcda97eb3887db42aeb9d20872a0ff"
    },
    {
      "type": "html",
      "text": "\nQ6. What exactly does the syntax of Eiffel encapsulate?",
      "id": "23f45f20f9b94f2305fe96cbb9275851"
    },
    {
      "type": "html",
      "text": "\nWhat I learn from this conversation so far is that Shield is used in a sentence differently than Encapsulation. You say, Let's put a Shield here! You don't say, Let's put an encapsulation here!",
      "id": "87c36a74d51f6257230648906c1650b7"
    },
    {
      "type": "html",
      "text": "\nI also learn that there are degrees of encapsulation, or what I call strengths of shields. And there is a cost to this (see [[Premature Generalization]]).",
      "id": "c8a4d7d52f175cc38098f28d0fa7dd35"
    },
    {
      "type": "html",
      "text": "\nI also learn that you are being very polite and blaming your chicken sandwich for my silly questions, but you are not answering my questions. So I now wait for someone's attempt to answer the questions, to learn whose lunch was too heavy.",
      "id": "e7f0317ca78e49bcec60a04434c654eb"
    },
    {
      "type": "html",
      "text": "-- [[Alistair Cockburn]]",
      "id": "ffd063b06b486bd891c9b4e395525e61"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "The gist of [[Premature Generalization]] is that one doesn't know how to <i>reuse</i> a thing\nuntil it has been successfully <i>used</i>,\nand that time spent building elegant class hierarchies before it has been proven that they're needed is time that could be more profitably spent elsewhere.\nIt's not a critique of encapsulation <i>per se.</i> --[[Dave Smith]]",
      "id": "950ac34950f4242a55ee060219e0eb93"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "<i>Q3. What exactly does a Java interface encapsulate? (Makes me wonder, Java has interfaces, Smalltalk doesn't - does that make Smalltalk less encapsulated than Java?)</i>",
      "id": "cc797656b7bc139d21bcfc61dff1308c"
    },
    {
      "type": "html",
      "text": "\nI think a Java interface doesn't encapsulate anything. It records, in a separate document, a language for talking to a certain (abstract) kind of object.",
      "id": "65a786a9b9e49e6221355e64820a66ee"
    },
    {
      "type": "html",
      "text": "\nThe object (any conforming class you might provide) encapsulates <b>everything</b> about how that particular class implements the interface.",
      "id": "dfa9c62720330d0c8a1eb84d5b2c829c"
    },
    {
      "type": "html",
      "text": "\nInterface = specification, class = implementation? Could that be it? ",
      "id": "d3e822e00c33522fb8934b6bf65133f8"
    },
    {
      "type": "html",
      "text": "--[[Ron Jeffries]]",
      "id": "8ab2b13c0aed11889626f00472d543f4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "I'm ready to assert a couple of things, and one is that doing things differently is a stable part of humanity, ergo programmers also - - with the direct consequence that I hesitate to write a pattern called [[Smallest Shield]]. (Now time me and see how many months it takes before I write it anyway.)",
      "id": "89a68d6fd211bc44010853727853fa84"
    },
    {
      "type": "html",
      "text": "\nUnder the same circumstances, some people will say Turn Left, others will say Turn Right, others will say Think Before You Program, others will say Program Before You Think, some will say [[Smallest Shield]], some will say Middle Sized Shield, some will say, Use Accessors, some will say Avoid Accessors, some will say Abstract Base Class First, some will say Concrete Classes Until Forced, and on the list goes, to include process and measurement and ...",
      "id": "8310d6c72d5698de1bd8dcdf363625da"
    },
    {
      "type": "html",
      "text": "\nThe next thing I am willing to assert is that the design shield, or [[Shield Pattern]] gets reinvented in every part of software technology. It is core to our industry. [[Ron Jeffries]] suggested that SQL is designed as a shield - similarly, high level languages are, also. And Ron's answer to Q3 above helps me think that not every design shield takes the form of encapsulation - encapsulation is the shield that matches the module-centric portion of our technology.",
      "id": "5ac8625cb408a06f45dd3aa8f07128a9"
    },
    {
      "type": "html",
      "text": "\nA nice illustration of [[Shield Pattern]] thinking is the fact that both C++ and Eiffel allow the programmer to expose an object's state variable to the programming public. In C++, the syntax for accessing a variable is different than for accessing a function. In Eiffel, quite deliberately, they are the same - this is the shield. A programmer can create a class using a public variable, perhaps erroneously or perhaps for prototyping, and then change it over time to a function, *without the client ever having to change the accessing code*. In C++, on the other hand, the change is a major change, and all clients must be rewritten and recompiled.",
      "id": "af020bf67e800eb034668cbbba407848"
    },
    {
      "type": "html",
      "text": "\nWhere do I go with this? Well I might write [[Smallest Shield]] just to expose the arguments (start measuring in hours instead of months!). I teach design, and one of the things I am interested in is this business about [[Heavier Shields]]. Why not use Bridge everywhere? You know the answer - too much complexity for the benefit given (p.32 of the [[Pattern Languages Of Program Design]]-3 book, [[Ralph Johnson]] and [[Bobby Woolf]], \"Type Object\" contains a lovely example of [[Truth In Advertising]]: \"The disadvantages of the Type Object pattern are: Design complexity...\"). In other words, great shield but heavy - make sure you have a problem needing this weight of shield. [[Dave Harris]] likes ABCs, editing them doesn't bother him. [[Ron Jeffries]] converted from that to creating them only on demand. Beside raw individual preference, how do you teach someone to develop a sense of feel for the heaviness factor of a shield?",
      "id": "dad7a432a1fa7a686dc5d2f6d7e427bd"
    },
    {
      "type": "html",
      "text": "-- [[Alistair Cockburn]]",
      "id": "ffd063b06b486bd891c9b4e395525e61"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "I agree that shields have a cost (and we're not usually talking about machine efficiency here - incidentally, I'm using Java, not C++). I don't <i>always</i> use ABCs. On this recent occasion I wanted to separate in my mind those parts of the interface which were fundamental, from those which were incidental. As it happened, I found that I needed an alternative implementation within the week, but that was a surprise. As the [[Extreme Programming]] people say, it wouldn't have been hard to refactor retrospectively.",
      "id": "0183a1f757dc7f6c8232d638371bfff2"
    },
    {
      "type": "html",
      "text": "\nMaybe my shield was the \"smallest possible\" under the circumstances. It strikes me as a rather vague criteria. A smaller one (that is, no ABC) would not have been \"possible\" because it would not have expressed what I wanted to express.",
      "id": "4eebbbbcf081a3d108d555e44a16bb86"
    },
    {
      "type": "html",
      "text": "\nI feel a lot of these things are really forces, not patterns. We have here a drive against premature generalization. There are opposing drives for necessary generalization. A pattern is needed to bring these forces into dynamic balance. \"[[Smallest Shield]]\" is not a pattern, it's a vacuous restatement of the problem, leaving the real problem (how small is that?) untouched.",
      "id": "eb10dbb5c1fa3bacd60e3a4f0b0da783"
    },
    {
      "type": "html",
      "text": "-- [[Dave Harris]]",
      "id": "949249fca4f809918ea05d90b2164c9f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "I used to think I was pretty smart, but I'm just not getting this. Please see [[Bridge Pattern Is Just Good Factoring]]. -- [[Ron Jeffries]]",
      "id": "c2328bbfeaed8bd6b81adcf3337ded68"
    },
    {
      "type": "html",
      "text": "<i>A parable might help:</i>",
      "id": "dba2bbe699729cf7952ae86f7979e8f3"
    },
    {
      "type": "html",
      "text": "\nOnce upon a time, there was a vegetarian tribe in the Amazon called the Expees. A Catholic missionary arrived in their village one day. Curious, the Expees decided to listen to him, and asked him questions about his religion. During this discussion, the missionary revealed that, if they converted to Catholicism, the Expees could not eat meat on Fridays.",
      "id": "6101a9a2ff0197d9dc180800751c6681"
    },
    {
      "type": "html",
      "text": "\nRonj, War Chief of the Expees, nodded slowly and said, \"We already abstain from meat on Fridays. But what's special about Fridays? I'm just not getting this.\"",
      "id": "7679324e460ed079659a04136222c054"
    },
    {
      "type": "html",
      "text": "\nWhereupon a wide-eyed child of the tribe piped up: \"Yuck! He means Catholics <i>do</i> eat meat the other six days!\"",
      "id": "a9ee58964468e831368ba31940116f0e"
    },
    {
      "type": "html",
      "text": "<i>Deciphering the parable:</i>",
      "id": "72215752252339e3e4e854a4f31170d9"
    },
    {
      "type": "html",
      "text": " eating meat --> putting in something you don't need right now",
      "id": "ee76de072f5ed2311914f662bc1ae246"
    },
    {
      "type": "html",
      "text": " vegetarianism --> following [[You Arent Gonna Need It]]",
      "id": "87af90a7352a9633e470c24ce23955f3"
    },
    {
      "type": "html",
      "text": " Expees --> [isn't this heavy-handed enough already?]",
      "id": "2bba5c5d93473f88736e4ec2869b4daf"
    },
    {
      "type": "html",
      "text": "-- [[George Paci]]",
      "id": "dadb0eacb7b142d7d30a53d220042c33"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "\nHere is a crack at finding out what is essential about the [[Shield Pattern]]. [[Alistair Cockburn]], please tell me if I'm mangling this in any way, but I from what I've read it seems like a very general thing.",
      "id": "348a2bbfc84a833440e7028b9837c24e"
    },
    {
      "type": "html",
      "text": "\nA shield is any construct which changes less rapidly than what it protects. In a sense, abstractions can be shields because they are often assumed to change less rapidly (being partial descriptions) than what could be fully described. In this sense, a base class is a shield for a derived class, and an interface is a shield for a anything that implements it. In addition, an operation signature is a shield for inline code.",
      "id": "04fa28d60a9a2131186ce08026945550"
    },
    {
      "type": "html",
      "text": "\nI would suppose that we could see [[Systems As Living Things]] and consider the shields in the system to be the harder parts (endoskeleton).",
      "id": "506dd8ba777e522544935dfdba15cfe3"
    },
    {
      "type": "html",
      "text": "-- [[Michael Feathers]]",
      "id": "6aabd4bf35b00e3351d29bd9202037ea"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "I'll suggest another direction to take [[Shield Pattern]]. I think it needs to be a bunch of more specific patterns.",
      "id": "de432f76fe8edc549d82da82604c520d"
    },
    {
      "type": "html",
      "text": "\nOne of everybody's favorite patterns is [[Light On Two Sides Of Every Room]]. It describes a specific physical arrangement of space to solve a general and abstract problem.",
      "id": "c4f6ff32a676de7e53cc7023eacae917"
    },
    {
      "type": "html",
      "text": "\n[[Shield Pattern]] seems to me to be an abstract solution of an abstract problem. \"Things change, therefore separate the parts that change from the parts that don't.\" ",
      "id": "3de8dee9d7f75c1bd0bc9b866c0c5cff"
    },
    {
      "type": "html",
      "text": "\nOne of my rules for a pattern is the Ingenious Fool Rule- to what degree can someone think they are following a pattern and really be missing it altogether. [[Shield Pattern]] leaves entirely too much room for misunderstanding. I have often heard people say the equivalent of \"well, that's there because I needed a shield,\" when they didn't. Shield has a wide field of effect with a large margin for error.",
      "id": "235d5ced93a356f128710275d6d65dbb"
    },
    {
      "type": "html",
      "text": "\nHowever, there is clearly something in Shield that we all recognize and resonate with. We've all done things that we can express as \"shields\". Ward's [[Intention Revealing Selector]] is a shield. Bridge is a shield, as are all the creational [[Design Patterns]]. The [[Analysis Patterns]] book has many shields at a business level, like [[Type Object]]/[[Reified Type]].",
      "id": "36dfe9873a521396af3413db3afa5539"
    },
    {
      "type": "html",
      "text": "\nAlexander says \"safety\" is not a pattern, it is encoded in and emerges from a family of concrete patterns- [[Bannister Height]], [[Soft Tile Floor]], and so on. Information hiding and encapsulation are not patterns, they are principles embedded to greater or lesser degree in the things we create and the patterns we use to create them.",
      "id": "71c90c225b95fc9b3c954464de537f1e"
    },
    {
      "type": "html",
      "text": "--[[Kent Beck]]",
      "id": "b7c2cf38a50bf933a7294ba8fd49c06d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "Kent, I think you are right. -- [[Alistair Cockburn]]",
      "id": "0a872e9265f7a5b0ec0edd3bd51f513e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "\nWell, I'm not sure I know what you mean by [[Shield Pattern]], but when I read it here it resonated with a problem I've been thinking about. Consider a large legacy system, written in (say) mostly C, still very alive and being modified,\nwith newer stuff being done in C++. Now say I want to port that to Java. What's the best approach?  ",
      "id": "3224bb3f513a7a1945019c934a59b40e"
    },
    {
      "type": "html",
      "text": "\nFirst thought is to wrap the existing structure of modules behind a set of Facade classes. Then the more dynamic modules can be immediately ported, and the more stable ones can be left alone for a while. This is what I think of Shield as being:  a wrapper for the [[Public Interface]] of a module (package).",
      "id": "b783cf95124eebc3bcc46e6510cbfe9d"
    },
    {
      "type": "html",
      "text": "\nThis is only a small part of the problem, though, because those modules don't just sit there in isolation; they've got to communicate somehow. The way this happens will depend on the system, but at the least there'll be Messages, or Events, or some similar means of communication; also, there will be some type of data or application-object that gets passed around as the various modules perform work on it.",
      "id": "47e13827f0c2da38eb6061891f69bb3e"
    },
    {
      "type": "html",
      "text": "(If the metaphor casts the Facade as a Shield, then these are the Swords and Arrows, I guess. That's probably not a useful characterization.)",
      "id": "e35b227d014c7cae15b0bac576bbacfe"
    },
    {
      "type": "html",
      "text": "\nThese inter-module objects are kind of outside the system; they don't really have a home. Or rather, they have more than one home, and it isn't necessarily clear where they should actually live. I guess it's reasonable to hide their creation behind a Factory method or some similar object-creational method in one of the Facades. But they still need to be public, not hidden, and therefore don't actually fit in with the idea of hiding everything behind a Shield or Facade.",
      "id": "9625586a5bf5096a052885c6e37e175c"
    },
    {
      "type": "html",
      "text": "\nThe standard approach, I guess, would create a new module for 'common' interfaces, and put the definition of these objects there. But that idea sure fails to impress me with its elegance; it's what we did in the first place, when writing the original C version. There ought to be more modern ways of dealing with it.",
      "id": "5a1f0fb7f556a41cf260361b28ec2485"
    },
    {
      "type": "html",
      "text": "\nWhat's a good way of dealing with this kind of stuff?  There's a need for the travelling objects to be able to mutate into new states; there's likely a class hierarchy defining the types of the objects; there's also a set of rules defining the allowable transformations that can be applied along the way; it's necessary that any given module have access to the information it needs in order to determine if an operation is legal, and if so how to apply it. This begins to sound like a pretty large bundle of information that must be available to all modules, and that therefore all modules depend on.",
      "id": "e5cb11b4797ccddc3b96819c98bae8c5"
    },
    {
      "type": "html",
      "text": "\nSo there's a pressure to do some kind of State pattern, and encode the allowable transformations and operations in the objects.",
      "id": "492907a7cdf596ce52bb82eb834c55e1"
    },
    {
      "type": "html",
      "text": "\nThere's also the pressure to maintain some consistency with the legacy system;\nI can't immediately rework the whole thing to handle a new strategy.",
      "id": "c3a5710e36912b6d0e31786416f76c99"
    },
    {
      "type": "html",
      "text": "\nuhhh, geez, I started out talking about the [[Shield Pattern]]; it looks like I got a bit distracted there. :-) Anyway: is this the kind of problem [[Shield Pattern]] is intended to deal with? And, am I missing something obvious that deals with the travelling-objects problem I'm trying to describe?",
      "id": "46d8f9b6281859566225f8faf910fe08"
    },
    {
      "type": "html",
      "text": "-- [[Kevin Kelley]]",
      "id": "6344a9034158ddda42dde38957bfefc6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "\nAre we discovering various shields over in [[Component Design Patterns]]? We have different things like [[Context Independence]], [[Container Independence]], and [[Interface Discovery]]. Would some of the above add to these, and can all of them be thought of as [[Shield Pattern]]s?",
      "id": "f21e073087ddfe319f984439761f4807"
    },
    {
      "type": "html",
      "text": "\n[[Philip Eskelin]]",
      "id": "c6139459d458773bc60b2d5c459ed15a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "\nI always thought of [[Shield Pattern]] as one of the highest-level patterns a person can learn - if they don't get it, then a lot of good software engineering just doesn't make sense to them. A lot of patterns are [[Shield Pattern]]s, but at the same time I don't think that that is the <i>only</i> category that they belong in. As Ralph and Kent point out way up at the top, the [[Shield Pattern]] is the patternizing of a principle that good software engineers have known about and used for years (which, by the way, is what makes it such a good pattern). IMHO I think we should reference it, and mention the connection other patterns have to it, but I don't feel a need to make it a \"foundation pattern\" of the CBD language.",
      "id": "e38d483fc7df44785d106af34c80c023"
    },
    {
      "type": "html",
      "text": "\n[[Kyle Brown]]",
      "id": "89b41c8489aa1b9b265aec2d26db146c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "I think Kent named the trouble. It is an abstract solution to an abstract problem. It is a pattern in the sense that various good people have settled on it at various times in various technologies, and it is difficult to get immediate value out of because it is abstract. I'll just let the abstractness of it suffer until someone gets a better handle on it.",
      "id": "9351bfb26687c148c48ead99f766c703"
    },
    {
      "type": "html",
      "text": "\nWhere I am going with my thoughts about shields in general is to try to assess the cost of a shield. More shielding often means greater cost in cognitive load or performance. So it is not simply a pattern that says \"do this\". The counterforces, or overdose effects, are noticeable and are to be accounted for. The Truth In Advertising for a shield, indeed, any pattern or recommendation, ought to include its costs. (are you it doing with the [[Component Design Patterns]]?) -- [[Alistair Cockburn]]",
      "id": "1f4d2e9c2ba07218adf58f39861bcc81"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "Doing cost? - sort of. In some places we've addressed cost, but what you're describing is somewhat deeper. As Kyle says, we should fully embrace since some of them can be classified that way, but not explicitly give it a home among the other [[Mini Pattern Language]]s. I think components in their nature are all about shielding. They can make it easier for you to eventually strike the right balance between forces associated with too much and too little shielding. Conceptual chunking, or as said above, an abstract solution to an abstract problem. -- [[Philip Eskelin]]",
      "id": "23bb0b687d8c09fe0f2e9a08eee4e87e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "I think that is a hopeful (wishful?) approach. I don't think components are so much about shielding as they are about development cost. I don't buy a component to protect the right of the implementer to change the implementation (gack! rather the opposite!) but mostly because I can buy it and stick it into the system cheaper. If the implementer changes the implementation, I am likely to get hurt. Also, components are more likely to be big than small (small components I would develop myself) - hence would drift toward fat interfaces encapsulating lots of stuff. The Truth in Advertising, cost, counterforce, or overdose business provides a) a chance for me or you, the author, to stare at our stuff and better detect its true placement in the scheme of things, as opposed to our initial optimistic blushful wish; b) a way for the reader to assess the engineering tradeoff of using the idea (as opposed to, say, using it and then cursing you for not mentioning the downside). -- [[Alistair Cockburn]]",
      "id": "fe353b4d9472c08392d1e951b8bbaef0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "A shield should be big enough to cover all the functionality required by clients who are not also creators.\nCreators can have a reference to the implementation, so nothing is shielded from them.\nIf they hand the shielded object to others, the shield should be big enough for the purposes of those others.\nThe cost of the shield is how much effort it takes to change all the implementations if the shield is changed.\nI can see two rules here:",
      "id": "a994184ea426d6fae84e5e32410f3cc1"
    },
    {
      "type": "html",
      "text": " if the only client is the creator, you don't need a shield",
      "id": "a52693b87504eda712b93d97703271a8"
    },
    {
      "type": "html",
      "text": " if there is only one implementation, you don't need a shield",
      "id": "554c336d3948ed7c0539e1059f3e8196"
    },
    {
      "type": "html",
      "text": "-- [[John Farrell]]",
      "id": "833cdfa3ba7a51ecd11f2ddfefb2fcca"
    },
    {
      "type": "html",
      "text": "<i>The above is also found at [[Smallest Shield]].</i>",
      "id": "15e5a71e64c5f5f8d14eb0c7ac251d1b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "<i>The cost of the shield is how much effort it takes to change all the implementations if the shield is changed.</i>",
      "id": "7d22616f6eddfe86fc23dc78173163c2"
    },
    {
      "type": "html",
      "text": "\nThat's one useful measure (let's call it \"[[Shield Change Cost]]\") of how good a given instance of Shield is: If my Shield (e.g. interface) changes, how much do I have to change what's behind it (e.g. implementations).",
      "id": "1350edea4550a62444a8ace59b84183a"
    },
    {
      "type": "html",
      "text": "\nFor example, if I have a Tool interface, and later want to add disabled/enabled behavior, how large will the [[Shield Change Cost]] be?  In this case, not very large: if I have a single [[Abstract Base Class]] that implements the interface (what Swing would call an Adapter), I should be able to add setEnabled()/getEnabled() there and there alone.",
      "id": "a7f2e94b1e5211a2c3434fe18eb08928"
    },
    {
      "type": "html",
      "text": "\nBut Alistair is talking about something much broader when he asks about \"cost\". He's trying to answer this question:",
      "id": "fb3eaf4dedd4a0cf55c843ed8e38259d"
    },
    {
      "type": "html",
      "text": "<i>What things about a given Shield would make me</i> not <i> want to use it?</i>",
      "id": "4411bb3b52af71c5d20c1a66123c2f48"
    },
    {
      "type": "html",
      "text": "\nA partial answer, then, is: the Shield is rigid (has a [[Shield Change Cost]]), and can be hard to change; don't put at Shield at a place in the design that is likely to change.",
      "id": "d1cfd8eba163c5309958e6492d98fade"
    },
    {
      "type": "html",
      "text": "\nBut you should also consider:",
      "id": "c197f9a39fdc1a79ca3bae952eea989f"
    },
    {
      "type": "html",
      "text": " [[Shield Installation Cost]]:<br>how much do you have to change the existing code to put the Shield in?",
      "id": "12077e234500bf5308ae1443c2c25356"
    },
    {
      "type": "html",
      "text": " [[Shield Performance Cost]]:<br>does this Shield make the system slower or more memory-intensive?",
      "id": "b14b3a05d904e686c89936e008f2053e"
    },
    {
      "type": "html",
      "text": " [[Shield Cognitive Cost]]:<br>does this Shield make the system more confusing for people to understand?",
      "id": "a4ee95a065758f8c94e7d2f7dddf5ed2"
    },
    {
      "type": "html",
      "text": " [[Shield Maintenance Cost]]:<br>how much harder does this Shield make it to change the system?  (This should always be negative!)",
      "id": "c5337fd0284c093c4f4238be841c7842"
    },
    {
      "type": "html",
      "text": "\nAs for Interfaces and [[Abstract Base Class]]es (ABCs): I can't see a situation where you wouldn't want to use them together. Any time you have an interface, you presumably have a couple of classes that share some abstract behavior (e.g. draw(), addListener(), for UI components). There will always be some implementation of that behavior that they both have, as well. So refactor it into an [[Abstract Base Class]] that implements the Interface, and have the concrete classes subclass from it.",
      "id": "befa43f9cdadcb0dbb98ff2fcb7b8116"
    },
    {
      "type": "html",
      "text": "\nThe other direction: say you're adding an [[Abstract Base Class]]. Clearly, it implements some Interface. Why not put that explicitly into the program right now? The cost is virtually zero: a tiny bit more typing to create the Interface code; you'd be changing concrete class references to ABC references anyway, so changing them to Interface references instead is free.",
      "id": "eb025c63d7f131226d9bd04e28d3f34d"
    },
    {
      "type": "html",
      "text": "\nAnd the benefit is that if, later, you want to add something that has all the abstract behavior of your [[Abstract Base Class]], but none of the implementation, you can just directly implement Interface; you don't have to touch any of the calling code, and you don't have to convert it from using [[Abstract Base Class]] to using Interface.",
      "id": "f74e842eb3ce97674b3dd86651287af3"
    },
    {
      "type": "html",
      "text": "\nThe only objection I can think of is the [[Shield Cognitive Cost]]; but that seems very small to me. Explaining it to a teammate would go something like this: \"Well, you have an interface, and you also have this adapter that you can subclass so you don't have to reimplement all the basic parts of the implementation. Just like in Swing.\"",
      "id": "6b056f244f0e0ff0ba1ae41e284fd270"
    },
    {
      "type": "html",
      "text": "--[[George Paci]]",
      "id": "85e23d21b123e7054aff0bec7974174d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "Good reply. I wouldn't underestimate the [[Shield Cognitive Cost]], though. I have seen beginners given the [[Shield Pattern]] put so many things behind so many interfaces (protecting so many potential design changes) that I couldn't find where the <i>function</i> was being performed. Huge cognitive cost. As far as I'm concerned, one of the things that sank Taligent was too many itty bitty classes and too high associated cognitive costs - no one could learn how to use the system. -- [[Alistair Cockburn]]",
      "id": "1bacf852296470781e11dd9523222c7c"
    },
    {
      "type": "html",
      "text": "\nYes, but that was a symptom, not the disease. One way to keep shields from being too heavy is to have a group of people work with them every day. It is hard to get an abstraction right, but if a group of people work with it and keep trying to get it better, they will usually complain about bad abstractions and make sure that the abstractions are good enough. Taligent had no users, hence nobody to complain about bad design. Well, I'm sure that some people complained about it, but most people were too busy building their own part of the system to worry about someone else's. Frameworks without users are never any good. -- [[Ralph Johnson]]",
      "id": "b850ac849e9364066ea8bb358c04cbdb"
    },
    {
      "type": "html",
      "text": "\nAlistair: I think your problem wasn't with the cognitive cost of <i>each</i> shield, but with the <i>cumulative</i> cognitive cost of <i>all</i> the shields. Note that I didn't say \"total\" cost: costs of adding things to a system aren't necessarily just a function of the thing being added. You can't just say, \"Well, if we add five shields, our cognitive cost will increase by 5 [[Milli Einstein]]s.\"  It depends a lot on what the rest of the system is like, and whether the shield is actually used.",
      "id": "c50f99abf7ad47c72acde1e6ed5af1c2"
    },
    {
      "type": "html",
      "text": "\nI think if each shield were really pulling its weight, the system would have been easier to understand. Using a structure provides the reader with a concrete example of why it's useful, thus <i>decreasing</i> the associated [[Cognitive Cost]], usually by enough to offset the cost of the client code itself.",
      "id": "b5596b91ac2b31c54ea67e6a9a4184e8"
    },
    {
      "type": "html",
      "text": "\nThe important thing here, I think, is that some of the shields were added, increasing the [[Cognitive Cost]] of the system, without actually conferring any benefit. If we want to assimilate this to your concept of [[Smallest Shield]], I guess we'd say (some of) the instances of Shield could have been replaced with a smaller possible instance: no shield.",
      "id": "31ed69e1d211441f7c07476d3a819aaf"
    },
    {
      "type": "html",
      "text": "(This also illuminates a good meaning for \"possible\", to wit,:\"possible while still gaining the needed benefit\". In the case of unused shields, the benefit is ipso facto nothing, which means just plain leaving them out would still gain the (nonexistent) benefit.)",
      "id": "bb208e8456d72b818c27019c6911d297"
    },
    {
      "type": "html",
      "text": "\n[[Cognitive Cost]] is not dollars-and-sense accounting; get used to looking at costs marginally, and mocking things up to estimate them. Also look squarely at what the marginal benefits are, and whether they outweigh the costs. And if you can't estimate the cost of something, it's a risk, and it may be that [[You Arent Gonna Need It]] anyway.",
      "id": "3662349999df630010b5b941c55ca487"
    },
    {
      "type": "html",
      "text": "-- [[George Paci]]",
      "id": "dadb0eacb7b142d7d30a53d220042c33"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "I was surprised nobody has used the word <i>indirection</i> here (unless I missed it). Is seems to be that much of what the above discussions on the [[Shield Pattern]] seem to be talking about is the often-quoted observation that just about every problem can be solved by adding another level of indirection. -- [[Anthony Lauder]]",
      "id": "d719a6bae341a869fdde10ce5e769107"
    },
    {
      "type": "html",
      "text": "\nExcept for the other part often stuck on that quote, \"...except for too many levels of indirection.\", which seems to fit Alistair's concerns about \"heaviness\". -- [[An Aspirant]]",
      "id": "fd989869c78171abfbd135354a3fb658"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "\nOutside of this page, is \"shield\" a common term used to describe this pattern/principle?  I found the term confusing, and didn't understand what it meant until I read the page a few times. To me, the term \"shield\" implies protection against unwanted access, or an intentional attack, not protection against the consequences of a decision. I think a better term would be something like \"Commitment Minimization\" (but shorter), or maybe \"hedge\". -- [[Kris Johnson]]",
      "id": "a959fed9a873fa7f3d0d006cf975e16c"
    },
    {
      "type": "html",
      "text": "\"Hedge\" might be a good choice; beyond the physical referent of a barrier, it also is used in the context of minimizing risk, as in \"hedging your bets\". Large companies frequently use all sorts of financial instruments to hedge their losses in case of bad weather or high oil prices or whatever else.",
      "id": "bbae7541be8e976aebbe038fd35f91a8"
    },
    {
      "type": "html",
      "text": "<i>\"Hedge\" doesn't work for me. You hedge against bad consequences of action A by taking the very different and in some ways opposite action B as well, like buying a certain stock and, at the same time, put options on the same stock. That's IMHO too specific an idea to match what [[Shield Pattern]] describes.</i>",
      "id": "484b166f37bd432e3bcb9dfa89f38ec9"
    },
    {
      "type": "html",
      "text": "<i>If we need a different term, I would like to humbly suggest [[Design Hinge]]. -- [[Falk Bruegmann]]</i>",
      "id": "ca787b12e9050dba9e2bf4bdd19a3ca7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "Hmmm, a shield is surely just a concrete, immutable point of extensibility no? And has two things going for it... it means a piece can articulate and hence adapt without having to be a limp bendy mess in order to adapt.",
      "id": "2d419c317a514482b5bf229cf895b8db"
    },
    {
      "type": "html",
      "text": "\nOr looking at it another way, a shield is a node on a graph... you have choices you can make at a node as to which edge you can take.",
      "id": "755955bcc9ae6d8644532322da09acdd"
    },
    {
      "type": "html",
      "text": "\nI personally am not sure that \"shield\" is a good choice of term, and think it focuses to much on defensive programming...which isn't to say such focus is bad, simply that it doesn't convey what the pattern offers, and instead focuses on what it avoids.",
      "id": "0b99f51ce3a224dff7a6713c1487d0d3"
    },
    {
      "type": "html",
      "text": "\nEither that or I'm missing the point entirely.",
      "id": "807b1a1d55b133cc70f1aac7f7804212"
    },
    {
      "type": "html",
      "text": "-- [[Guy Murphy]]",
      "id": "d9d31a725f41dc12d14f4c74203fd03c"
    },
    {
      "type": "html",
      "text": "\nThe key difference is (from the top of the page), \"the fact that in Eiffel and Self an attribute access reads the same as a function call.\" In Eiffel, one writes, \"myClass.service\" . . . and cannot, from that, tell if 'service' is a data element being directly referenced, or a zero-argument function call. . . . and Bertrand Meyer did that on purpose, explicitly to allow the author of myClass to change his/her mind about that very choice. ",
      "id": "0e6ef73a040a97aba6d7624d358e517a"
    },
    {
      "type": "html",
      "text": "\nIf this fits what you mean by \"extensibility\", they the answer to your question is \"yes.\" Otherwise it is \"often but not always.\" ",
      "id": "3c14b91d0b23efa44fff657f4d3319a8"
    },
    {
      "type": "html",
      "text": "\nI find two values in metaphoric word \"shield\". The first is that behind a shield (force field, barrier) one can do things hidden and protected from the world in \"front\". In software, that is, change one's implementation. The second is that shields get heavier as they get bigger, so there is a cost as well as a benefit. That aspect doesn't get enough discussion to suit my taste. -- [[Alistair Cockburn]]",
      "id": "4b01aef6031997d30681cad829b88e0a"
    },
    {
      "type": "html",
      "text": "<i>What do you mean by 'heavier'? An interface doesn't seem too heavy to me, albeit redundant. Compared to, say, an abstract class hierarchy.</i>",
      "id": "a254975d947c2870dd77b384d723b012"
    },
    {
      "type": "html",
      "text": "\nIndeed - exactly as you write, \"heavier\" is relative. An interface is relatively heavy or not, depending on what you're comparing it to. A framework's API is heavier than a class's interface is heavier than a function's interface is heavier than a variable name is heavier than a constant. The heavier, the more flexible - but that comes at a cost, of efficiency and cognitive complexity. -- [[Alistair Cockburn]]",
      "id": "c9f1ec7f2decab94267f56f7efb6a7e5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "\nWell, I'm new here, but on a read of GoF and a few of the patterns linked here, I'm of the opinion that [[Shield Pattern]] is far too broad. This strikes me rather as making a \"vehicle\" pattern, and then asserting simplest possible vehicle is desirable, then laying down considerations - fuel efficiency, speed, comfort, prestige, cost - in order to select between [[Roller Blades]], a Lear Jet, a Rolls Royce, a submarine, and the various points inbetween. Whereas it is a useful abstraction, this \"vehicle,\" good for describing utility or intent, is it a useful pattern?  When designing something whose intent is to make a device to transport people or commodities from point(s) to point(s), does first considering it as a vehicle and then applying the commonalities of a vehicle grant you any insight?  Before you point out that the luxury of the Rolls Royce was explicitly imitated by Lear, do remember that we're also talking about surf boards, skateboards, military interceptor fighters, and roller coasters. There aren't many particularly useful general observations.",
      "id": "968635727f8b5bd735bb35fee0e3bf60"
    },
    {
      "type": "html",
      "text": "\nWhat I believe is happening here is that an attempt is being made to codify a more general thing than a pattern as a pattern. The metapattern suggestion that Pete Hardie made at the outset of the discussion seemed about dead-on to me at first, but I've now changed my mind. When you create a new sporting transport device - let's say you're the guy that invented windsurfing - your approach is to identify something you'd like to achieve, generally by analogy with a similar act in an alternate medium. \"Surfing is fun,\" one imagines he might have said, \"but it would be more fun in the air instead of the ocean. Or at least it's worth a try.\"  At that point, there are a bunch of considerations about where you get the velocity, the lift, how you prevent frequent neck breakery, et cetera. However, the observation that it's a vehicle, and that therefore that you will cover distance, that it will take a nonzero amount of time to complete transit, that it involves equipment external to the body, and so on - don't do you a hell of a lot of good. Also, this points out again that some things which seem to be superficially related to a pattern in fact are not, but are common only to the more obvious applications of the pattern - my Rolls Royce example again shows some promise when you make the observation that most windsurfers don't need a wetbar or corinthian leather seating en route.",
      "id": "bc3cce235b6d884a8037fa7ddd7636a7"
    },
    {
      "type": "html",
      "text": "\nThing is, if you've got a sarcastic enough mind, it's very easy to create useless (or so seeming) patterns. For example, it could be suggested that the bulk of programming languages would do well to be expressible with symbols available on a keyboard, which has few counterexamples unless you have experience with digraphs and trigraphs, or APL. I'd argue that that's the case with the vehicle pattern - it is indeed a pattern, but it's so broad and so vague that it doesn't provide any useful rules or observations as a result. By the time you've identified the need for it you've already gotten all of its ramifications by earlier mechanisms. You never say \"oh wow, you know, I should make this thing a vehicle.\"  I also think that that's the case with [[Shield Pattern]]. It's overly broad. Some patterns really do descend from one another (I often get into arguments over my belief that singleton is effectively an ancestor of flyweight.)  Yes, if you wanted to categorize the various ways to protect outside code from change, then you could refer to them all as shields. Does it buy you any utility?  Maybe in discussion. GoF notes that one of the uses of patterns is to provide a common vocabulary for discussion. In that way, maybe Shield Pattern could be useful.",
      "id": "f7f6dc6d37a02e90e20ab71c4edd9a6b"
    },
    {
      "type": "html",
      "text": "\nBut do I think it's a good pattern?  I don't, really. I don't see what it gains us. I'm from the C++ mindset, and I prefer minimalism. I believe that the smallest interface which can represent a set of tasks without introducing extra complexity (yay vagueness) is best. I haven't been here long enough to know whether that's considered common wisdom (or a common misconception,) but it's the platform I choose to argue from. I tend to see patterns as a tool for displaying complex and interlocked concepts in a semiconcrete and usable fashion, mostly as a way to exchange experience. I also see them as a \"heavy tool.\"  I wouldn't use a pattern to describe functions, or variables - the concepts are too simple to warrant such attention. There is a point of diminishing returns here; if you used a pattern to try to explain variables to a novice, it would be harmful; it'd take forever, it'd be distracting, it'd be confusing. I see explanations much in the same way that I see interfaces; the shortest that effectively communicates the whole is best. In more classic terms, \"Brevity is the essence of wit.\"",
      "id": "5e79550584e8fc0f5f26d83c6659ae52"
    },
    {
      "type": "html",
      "text": "\nGoF presents three categories of pattern. Would it be appropriate to make a pattern called \"Creational Pattern?\"  Well, sort of. There are commonalities to creational patterns. They have a similar aim, they have a similar goal, they share some common methods by necessity - they need to pass a created object out, they need to provide mechanisms (be they internal or external) to specify what will be created, et cetera. I would argue that yes, there is a pattern called \"Creational Pattern,\" and that it's a dead pattern. By the time you've realized that what you have on your hands is a creational pattern, there's nothing that Creational Pattern can teach you, no way in which it can advise you, no alternatives or considerations it can provide you.",
      "id": "116e0f30ac1401087e0305c6fc408726"
    },
    {
      "type": "html",
      "text": "\nTo use a phrase without defining it is the ev1l. A dead pattern is a pattern which satisfies the requirements for a pattern but whose existence cannot provide any useful information for judgement. Therefore, a dead pattern requires that you've identified all of its considerations in order to identify it in action. Therefore, I feel satisfied generalizing it into the rule of thumb that a dead pattern is simply a uselessly overbroad pattern.",
      "id": "1b541dae48d4e49b715ab471c9cb90d2"
    },
    {
      "type": "html",
      "text": "\nWhat does the Shield Pattern advise?  The shield pattern advises that you protect something changeable behind something less changeable - Michael Feather's description seems elegant. Then, a few people have made mention that they'd like it kept minimal given circumstances. I had thought that nominal. I fail to see any other real insight here; people are observing that one or another pattern descend from this, that encapsulation is a formalization of this observation, that some languages provide literal implementations of this at the language level (privacy and scoping, namespaces, interfaces, and various things which haven't been mentioned - aspects, call by contract, call by name, or less literal things.)  In many ways, you might observe that the C++ standard serves as a shield of sorts. It specifies what will be available, how long it will take, what its complexity and resource requirements are allowed to be, how limitations are to be reported, and so on. I would suggest that it is in fact an incredibly strict shield for the domain it covers; much unlike Alastair Cockburn, I don't feel that switching implementations should ever hurt the user. I am (usually) not hurt moving my code between compilers; because I understand the C++ Standard shield well, I know what things I may rely on as requirements, and the things which are important to me, such as algorithmic complexity, are maintained. I would argue that if switching implementations is dangerous, you have an insufficient shield.",
      "id": "3acb55e0de7bc1aca2eac419dcf1d7dd"
    },
    {
      "type": "html",
      "text": "\nAll that aside, I can't really see any utility to the [[Shield Pattern]]. I think of patterns essentially solely as a teaching mechanism, and teaching is what I've paid the most attention to of all my hobbies over the last few years. I've come to the conclusion that the most difficult thing to find is a Really Good Example (tm). People tend to choose their examples according to what they know, or what's germane to the topic at hand, rather than for their expressive ability. To give a concrete example, in a recent class I taught (no, I'm not the professor who has my name) I gave chess as a midterm assignment. I feel it's a good learning experience - the rules are absolutely concrete and have no vagueness, the game isn't overly complex, there are some simple easy approaches that give results which aren't outwardly disappointing (by comparison, Go is astonishingly difficult,) has a few interesting caveats but not many (there is a situation in which more than one piece may move, there are times at which you can have more of one piece type than you start with, but never the king or a pawn, et cetera. By contrast, checkers is not a good example; it's too simple to be interesting. Similarly, Magic: the Gathering and other collectable card games, or Knihtmare Chess, or contract bridge, or baccarat, or dungeons and dragons would all make bad examples; though they're fun games, they're far too complex and plagued with far too many special cases to make a good teaching mechanism. To that end, patterns must also be carefully chosen. There are, to my sarcastic eyes, a forest of bad patterns to be identified. Dead patterns are only one class of bad pattern, and they're a particularly dangerous one - they're easy to mistake, they cause the consideration of dangerously different substitutions, they don't provide any utility, they absorb useful brain time.",
      "id": "3c3552771bf34317dbb7d07f6b6e9a7f"
    },
    {
      "type": "html",
      "text": "\nI'm not very confident that a [[Shield Pattern]] is a dead pattern. I'm really just trying to establish the notion of dead patterns, to get criticism, and maybe in the path to identify the problem with Shield. Still, that's my diagnosis. I do think it is a pattern. I just don't see what it's good for.",
      "id": "a844887c0fc49d03b4ff1177d5bfe00d"
    },
    {
      "type": "html",
      "text": "-- [[John Haugeland]]",
      "id": "07f5d3303a9b991bc782c5021521025c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "\nTo me, Shielding is about abstraction entirely. One of the tenets of OOP that caught my attention from the beginning was that abstraction could go all the way up to the point that source-code could almost read like the abstract description of that very same code.",
      "id": "f3d66488e307e5b6cf877562a5c494ad"
    },
    {
      "type": "html",
      "text": "\nFor instance (pun intended), if you are programming some special math or engineering routine that deals with vector algebra, the abstract description for adding two vectors into a third vector would look like:",
      "id": "c980e1e4ef00ac150e7f31279ed6f477"
    },
    {
      "type": "html",
      "text": "\nw = u + v",
      "id": "7e05979496355fda4898e7d46fbfbaa6"
    },
    {
      "type": "html",
      "text": "\nAssuming that operator overloading could be considered some type of shielding, my (client) code could read like this:",
      "id": "83bc481b3ba5051725028d378fcf5be8"
    },
    {
      "type": "html",
      "text": "\nVector w, u, v;",
      "id": "842e80b77104ca869cedb14809fd7e85"
    },
    {
      "type": "html",
      "text": ". . . ",
      "id": "f33dd5c22356af44da470b41726b3ae7"
    },
    {
      "type": "html",
      "text": ". . .",
      "id": "87f4ad6d8e724362458708ad775db701"
    },
    {
      "type": "html",
      "text": ". . .",
      "id": "87f4ad6d8e724362458708ad775db701"
    },
    {
      "type": "html",
      "text": "\nw = u + v;",
      "id": "fa3c72421d4cc279ff283c4b5d5d2e49"
    },
    {
      "type": "html",
      "text": "\nVoil!",
      "id": "cd276c2b2b88ae92fbf5c824070f5dcd"
    },
    {
      "type": "html",
      "text": "\nLets see another example. Lets suppose that for some reason, I have some class that holds XML data on a certain attribute (field). To have a design as abstract as it can get, I would like that the look and feel of the get accessor in my (client) code to be just like the set accessor. So far, so good. ",
      "id": "f09b88801cf0210481d2c2f793aadcef"
    },
    {
      "type": "html",
      "text": "\nBut, what if I want to make sure that my set accessor only accepts well-formed XML expressions?",
      "id": "60f722d669e044a6e2fba9a801bb8dab"
    },
    {
      "type": "html",
      "text": "\nWell, once again, shielding comes to the rescue. I could hide the (well-formed) validation routine within the innards of my set accessor code. If some XML expression doesn't look good enough, my routine could throw the right kind of exception, and, again, abstraction wins.",
      "id": "695a42376200568dd9b20ce78c95899a"
    },
    {
      "type": "html",
      "text": "\nDoes it sound like I am too C# oriented?",
      "id": "026a8cce08f1dddfca8d295202823a63"
    },
    {
      "type": "html",
      "text": "\nWell, you can only use as much shielding as the language of choice supports. I just chose a language versant enough in shielding to make the point.",
      "id": "7e4a37a39e630b955a3845dad8e14326"
    },
    {
      "type": "html",
      "text": "-- GastnNusimovich",
      "id": "1a93f90c43859ef447538a228f65bde8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "\nIMHO, Shielding is a very elegant technique, capable of producing beautiful abstraction. I do not see it as a classic [[Design Pattern]], since you cant apply a unique collaboration of classes to express it.",
      "id": "a5ccaa0753502ee32ee291d96ab17d0a"
    },
    {
      "type": "html",
      "text": "\nA language has syntactic (notation), semantic (meaning) and pragmatic (usage) rules. To me, Shielding could fall within the pragmatic rules of a [[Pattern Language]]. It is a way of using abstraction. You could attain abstraction through other means.",
      "id": "f0d5ddb76ea81e292dc6cba9b0e2c28c"
    },
    {
      "type": "html",
      "text": "\nMaybe the problem resides in the fact that we are using a loose definition of what a pattern is. When you are on a phase of [[Work In Progress]], looseness is an asset. ",
      "id": "3ba4a552b6b1e9613326064b7549450c"
    },
    {
      "type": "html",
      "text": "\nSufficiency is king. We have some illustrious participants in this conversation that form part of the original [[Agile Alliance]] group, so I am using Sufficiency in that very sense of the word. But at some point in time, you need to shift to precision for closure.",
      "id": "1b0e27165a3cebd4116c9ca2002093e3"
    },
    {
      "type": "html",
      "text": "-- GastnNusimovich",
      "id": "1a93f90c43859ef447538a228f65bde8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "\nIn relation to a previous discussion on Interfaces, an Interface (as a separate software construct) has nothing to do with encapsulation, at least that is the way I see it.",
      "id": "9ba35b61eb31d6a763588849f1ecd5ee"
    },
    {
      "type": "html",
      "text": "\nThe public interface of any given component establishes the language that must be used by client code to obtain services from that component.",
      "id": "4f34922d331de221a02f88cdf9d461a6"
    },
    {
      "type": "html",
      "text": "\nThe public interface of any component coded on any OOP language is the one software construct responsible for encapsulation. Components developed in Smalltalk have a public interface just like any component developed in any other OOP language, so Smalltalk is on an equal standing with any other OOP language when it comes to encapsulation.",
      "id": "b4b519fe56577b6fc6e96f009bbf7e1a"
    },
    {
      "type": "html",
      "text": "\nSince the public interface of a component establishes the language used by client code to obtain services from the component, there is a de facto contract between the client code and that component.",
      "id": "1a068c285af0c9cc6dd234d8f79630ee"
    },
    {
      "type": "html",
      "text": "\nAn Interface as a separate software construct serves as the realization of that contract. The capability of any OOP language to have a specific software construct to realize contracts is a very powerful tool.",
      "id": "19214dd41610e1b22bc77520e2e1e3b2"
    },
    {
      "type": "html",
      "text": "\nWhy is this a good thing? Any other component that implements the same contract (Interface) becomes interchangeable with the original component, at least for the services that relate to that given contract. Language designers can create additional productivity tools around the Interface construct (like Interface inheritance).",
      "id": "1013cfe37ae122db46fe05d2f976a762"
    },
    {
      "type": "html",
      "text": "\nIn this respect, Smalltalk is not on an equal standing with other OOP languages, like C# or Java.",
      "id": "dfe34a8fddf3b0893a137c1e1315e1fc"
    },
    {
      "type": "html",
      "text": "-- GastnNusimovich",
      "id": "1a93f90c43859ef447538a228f65bde8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "\nWhat Alistair and John's comments suggest to me is that [[Shield Pattern]] is of the some order as [[Creation Pattern]]. I never write code and think \"I need a [[Creation Pattern]] here.\" Such patterns are useful for understanding the goals and tradeoffs of programming; they allow us to group a number of related patterns together and say \"these are similar.\" It's a cognitive aid for learning about the art of programming, not for implementation of a specific problem.",
      "id": "e362debe92b298966314af04b5265fef"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ffbbd1d8620635b2b935d102163426e9"
    },
    {
      "type": "html",
      "text": "[[Category Pattern]]",
      "id": "3ce3837b31f93782399a6154a3cb8df3"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ShieldPattern c2.com]",
      "id": "b524f6347dc185ce3a289cb81281f16b"
    }
  ],
  "journal": [
    {
      "date": 1281891351000,
      "id": "50acc4897295660f74cc5ebecd9c37bc",
      "type": "create",
      "item": {
        "title": "Shield Pattern",
        "story": [
          {
            "type": "html",
            "text": "A 'Shield' is a phrase in a program that lets you protect some change decision behind it. There are all sorts of shields in programming - that's what programming for robustness is all about, which is why Shield is a pattern that gets invented over and over in different forms. [[Dont Distinguish Between Classes And Interfaces]] is the latest example. Other examples include subroutines, classes, patterns, frameworks, and the fact that in Eiffel and Self an attribute access reads the same as a function call.",
            "id": "c6161c5fc0878446bebf771d60469785"
          },
          {
            "type": "html",
            "text": "<i>All the discussion here makes me wonder if [[Shield Pattern]] is really a [[Meta Pattern]] - a [[Pattern About Patterns]], since so many of the patterns seem to fit</i> -- [[Pete Hardie]]",
            "id": "1ba12214c92c6ac8c2a10ff951f38955"
          },
          {
            "type": "html",
            "text": "\nThe point of the Shield pattern is that you write something in one place, and you are permitted to change your mind about the implementation without changing the reference.",
            "id": "637d9364150c02b1654aacf8316d1919"
          },
          {
            "type": "html",
            "text": "\nIn the cases I have found so far, a Shield takes the form of an interface definition. I think that is because programming is behavioral.",
            "id": "63da1f852607ea6ee409fe82cd2ca16a"
          },
          {
            "type": "html",
            "text": "\nIf there were a pattern whose title takes the form of advice, it would be [[Smallest Shield]] (I don't really care for patterns whose title takes the form of advice, these days; I am experimenting with naming them for their end result). [[Smallest Shield]] says you will do well for your program if you use the smallest possible shield at any moment. Shields are, from smaller to larger:",
            "id": "4b7740eb280b5541df2fa56b85aa7a4f"
          },
          {
            "type": "html",
            "text": " function name (put Eiffel/Self attributes here also)",
            "id": "227161d4bf02838d8037fc32c29e2592"
          },
          {
            "type": "html",
            "text": " class name (put interface vs class name here also)",
            "id": "faa0adf31a39c3301f4b4499804910ea"
          },
          {
            "type": "html",
            "text": " Bridge pattern",
            "id": "031d71270eb228048254aee43143dc27"
          },
          {
            "type": "html",
            "text": " framework name",
            "id": "df8a684c33284661d939586c0168d26a"
          },
          {
            "type": "html",
            "text": "\nI guess that I or we finally have enough data to write up Shield as an official pattern (I have been teaching it for several years, but never thought to write it up before seeing this new use).",
            "id": "2be61545c5553cca00281c8c4fb7269d"
          },
          {
            "type": "html",
            "text": "-- [[Alistair Cockburn]]",
            "id": "ffd063b06b486bd891c9b4e395525e61"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "Can you explain [[Smallest Shield]] a bit more? Is it a combination of [[Shield Pattern]] and [[Do The Simplest Thing That Could Possibly Work]]?",
            "id": "b0bb13262101f15e7feb53f33a57e5a8"
          },
          {
            "type": "html",
            "text": "\nI've recently found myself using big Shields - that is, abstract base classes or interfaces when there is only one implementation behind them. I'm not sure you can convince me this is a bad idea :-)",
            "id": "9376e76336f2d05340751732603ab755"
          },
          {
            "type": "html",
            "text": "-- [[Dave Harris]]",
            "id": "949249fca4f809918ea05d90b2164c9f"
          },
          {
            "type": "html",
            "text": "\nIsn't this just modularity done right; that is, for information hiding? How is Shield different from what [[David Parnas]] wrote in his famous paper [[On Decomposing Systems]]? I'm certainly not complaining about the idea, which is very important, but why give it a new name?",
            "id": "a01e115fd757a32bf6db26f7ad0781f0"
          },
          {
            "type": "html",
            "text": "-- [[Ralph Johnson]]",
            "id": "c379ca4203fec2bca5a7d93d13f5931e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "\nOkay, so this either is not as obvious as I thought, or else it is really trivial and I just haven't seen it yet. Modularity has to do with splitting a program into modules, as in files or classes or something... creating an interface to a module is one form of shield. The fact that in Eiffel an attribute access is \"object.value\" and a function is \"object.value\" is a careful part of the language design and can't be explained by modularity. Nonetheless, it is a shield.",
            "id": "5ee818434db1c9a7155bc24b9eeb9c3e"
          },
          {
            "type": "html",
            "text": "\nThere are different size shields, with different costs for maintenance and different protections. [[David Parnas]]' paper does not talk about the different shields, their costs and values. He more or less picks one size shield, the ambiguous thing called a module. In those days it might have meant a file within a C program. With some stretching you can read it to mean class, or really stretch it to mean framework. I don't think his 'module' can be stretched to cover Java's interfaces. I listed six shields above.",
            "id": "ed38a7bc7fcb657196690f887ae8605d"
          },
          {
            "type": "html",
            "text": "\nThe first time I talked about protecting design decisions behind an interface, I got a classroom full of designs containing interfaces to interfaces to interfaces to interfaces, and nothing carrying out the function. That's when I learned there is possibly too much of a good thing. So I started caring about the weight of a shield.",
            "id": "bff2ec0bb5b3a8fb45526a030868eeee"
          },
          {
            "type": "html",
            "text": "\nSo let me ask you a question - ",
            "id": "9caeb3172e50b92ac24d73f2e9e05b68"
          },
          {
            "type": "html",
            "text": "\nQ1. when is it sufficient to use a function or method, and when must you create a class (for example, [[Dave Harris]]'s abstract base class, above)?",
            "id": "699225adf1104d78e89615884dbc5638"
          },
          {
            "type": "html",
            "text": "\nQ2. When would you use the double interface provided by Bridge or Facade instead of just the single interface provided by a class?",
            "id": "60080630cbf028ff3aee75638f8e275b"
          },
          {
            "type": "html",
            "text": "(If you know of a prior name that carries this discussion, please let me know so I can start translating my slides to use it.)",
            "id": "6976709f3b9429d84f3fbe98769b0c86"
          },
          {
            "type": "html",
            "text": "-- [[Alistair Cockburn]]",
            "id": "ffd063b06b486bd891c9b4e395525e61"
          },
          {
            "type": "html",
            "text": "\nDave, I am guessing you have found over time that when you didn't program an abstract base class, you got bitten a number of times having to create substitutable peer classes, and so ended up breaking your class into an ABC with subclasses. If that hasn't been the case, I can't really imagine why you bother with an ABC and look forward to telling about it. I further guess you count on the fact of the C++ compiler compiling out the overhead of the ABC, and if there were a real performance penalty for using one, you'd rethink your habit.",
            "id": "1627f0189ea4fc5a73e5c0c53ac91a9c"
          },
          {
            "type": "html",
            "text": "\nRegarding Java, I guessed a while back that there would evolve two schools of programming, those who create interface-class pairs as a matter of habit and those who create interfaces when their class needs the protection. I have been seeing that evolution on Wiki here. (I think I am too lazy to make it a matter of habit, and will probably join the latter school, but I haven't fully decided yet).",
            "id": "7d65c8be50b4429840fc774e3a16d46b"
          },
          {
            "type": "html",
            "text": "\nProbably the topic Dave is picking up is, What is the penalty for using a heavier shield?",
            "id": "1eb2f7780544720b1b30644006e84352"
          },
          {
            "type": "html",
            "text": "--- [[Alistair Cockburn]]",
            "id": "ac21620dcf67b6bb21543f38123a35b6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "I guess I'm a bit dull this afternoon. Probably that chicken sandwich. How is Shield different from Encapsulation? I thought that was the property of an object that hid implementation while publishing interface?",
            "id": "3d5321cdaa8b5ed99c0ab76aa8372240"
          },
          {
            "type": "html",
            "text": "--[[Ron Jeffries]]",
            "id": "8ab2b13c0aed11889626f00472d543f4"
          },
          {
            "type": "html",
            "text": "\nWell, maybe I'm the dull one. Help me out. Answer a couple questions:",
            "id": "2a777c500a9174c8bf74084e7ad768b7"
          },
          {
            "type": "html",
            "text": "\nQ3. What exactly does a Java interface encapsulate? (Makes me wonder, Java has interfaces, Smalltalk doesn't - does that make Smalltalk less encapsulated than Java?)",
            "id": "911fa96838bf3d1da469529daa6c7e76"
          },
          {
            "type": "html",
            "text": "\nQ4. In [[Premature Generalization]] there is talk against making abstract base classes too early. What is the problem? (it sounds like that is \"just encapsulation\")",
            "id": "3dd25f75276a5fb31984e9db2e889dba"
          },
          {
            "type": "html",
            "text": "\nQ5. Is there such a thing as too much encapsulation?",
            "id": "e4dcda97eb3887db42aeb9d20872a0ff"
          },
          {
            "type": "html",
            "text": "\nQ6. What exactly does the syntax of Eiffel encapsulate?",
            "id": "23f45f20f9b94f2305fe96cbb9275851"
          },
          {
            "type": "html",
            "text": "\nWhat I learn from this conversation so far is that Shield is used in a sentence differently than Encapsulation. You say, Let's put a Shield here! You don't say, Let's put an encapsulation here!",
            "id": "87c36a74d51f6257230648906c1650b7"
          },
          {
            "type": "html",
            "text": "\nI also learn that there are degrees of encapsulation, or what I call strengths of shields. And there is a cost to this (see [[Premature Generalization]]).",
            "id": "c8a4d7d52f175cc38098f28d0fa7dd35"
          },
          {
            "type": "html",
            "text": "\nI also learn that you are being very polite and blaming your chicken sandwich for my silly questions, but you are not answering my questions. So I now wait for someone's attempt to answer the questions, to learn whose lunch was too heavy.",
            "id": "e7f0317ca78e49bcec60a04434c654eb"
          },
          {
            "type": "html",
            "text": "-- [[Alistair Cockburn]]",
            "id": "ffd063b06b486bd891c9b4e395525e61"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "The gist of [[Premature Generalization]] is that one doesn't know how to <i>reuse</i> a thing\nuntil it has been successfully <i>used</i>,\nand that time spent building elegant class hierarchies before it has been proven that they're needed is time that could be more profitably spent elsewhere.\nIt's not a critique of encapsulation <i>per se.</i> --[[Dave Smith]]",
            "id": "950ac34950f4242a55ee060219e0eb93"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "<i>Q3. What exactly does a Java interface encapsulate? (Makes me wonder, Java has interfaces, Smalltalk doesn't - does that make Smalltalk less encapsulated than Java?)</i>",
            "id": "cc797656b7bc139d21bcfc61dff1308c"
          },
          {
            "type": "html",
            "text": "\nI think a Java interface doesn't encapsulate anything. It records, in a separate document, a language for talking to a certain (abstract) kind of object.",
            "id": "65a786a9b9e49e6221355e64820a66ee"
          },
          {
            "type": "html",
            "text": "\nThe object (any conforming class you might provide) encapsulates <b>everything</b> about how that particular class implements the interface.",
            "id": "dfa9c62720330d0c8a1eb84d5b2c829c"
          },
          {
            "type": "html",
            "text": "\nInterface = specification, class = implementation? Could that be it? ",
            "id": "d3e822e00c33522fb8934b6bf65133f8"
          },
          {
            "type": "html",
            "text": "--[[Ron Jeffries]]",
            "id": "8ab2b13c0aed11889626f00472d543f4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "I'm ready to assert a couple of things, and one is that doing things differently is a stable part of humanity, ergo programmers also - - with the direct consequence that I hesitate to write a pattern called [[Smallest Shield]]. (Now time me and see how many months it takes before I write it anyway.)",
            "id": "89a68d6fd211bc44010853727853fa84"
          },
          {
            "type": "html",
            "text": "\nUnder the same circumstances, some people will say Turn Left, others will say Turn Right, others will say Think Before You Program, others will say Program Before You Think, some will say [[Smallest Shield]], some will say Middle Sized Shield, some will say, Use Accessors, some will say Avoid Accessors, some will say Abstract Base Class First, some will say Concrete Classes Until Forced, and on the list goes, to include process and measurement and ...",
            "id": "8310d6c72d5698de1bd8dcdf363625da"
          },
          {
            "type": "html",
            "text": "\nThe next thing I am willing to assert is that the design shield, or [[Shield Pattern]] gets reinvented in every part of software technology. It is core to our industry. [[Ron Jeffries]] suggested that SQL is designed as a shield - similarly, high level languages are, also. And Ron's answer to Q3 above helps me think that not every design shield takes the form of encapsulation - encapsulation is the shield that matches the module-centric portion of our technology.",
            "id": "5ac8625cb408a06f45dd3aa8f07128a9"
          },
          {
            "type": "html",
            "text": "\nA nice illustration of [[Shield Pattern]] thinking is the fact that both C++ and Eiffel allow the programmer to expose an object's state variable to the programming public. In C++, the syntax for accessing a variable is different than for accessing a function. In Eiffel, quite deliberately, they are the same - this is the shield. A programmer can create a class using a public variable, perhaps erroneously or perhaps for prototyping, and then change it over time to a function, *without the client ever having to change the accessing code*. In C++, on the other hand, the change is a major change, and all clients must be rewritten and recompiled.",
            "id": "af020bf67e800eb034668cbbba407848"
          },
          {
            "type": "html",
            "text": "\nWhere do I go with this? Well I might write [[Smallest Shield]] just to expose the arguments (start measuring in hours instead of months!). I teach design, and one of the things I am interested in is this business about [[Heavier Shields]]. Why not use Bridge everywhere? You know the answer - too much complexity for the benefit given (p.32 of the [[Pattern Languages Of Program Design]]-3 book, [[Ralph Johnson]] and [[Bobby Woolf]], \"Type Object\" contains a lovely example of [[Truth In Advertising]]: \"The disadvantages of the Type Object pattern are: Design complexity...\"). In other words, great shield but heavy - make sure you have a problem needing this weight of shield. [[Dave Harris]] likes ABCs, editing them doesn't bother him. [[Ron Jeffries]] converted from that to creating them only on demand. Beside raw individual preference, how do you teach someone to develop a sense of feel for the heaviness factor of a shield?",
            "id": "dad7a432a1fa7a686dc5d2f6d7e427bd"
          },
          {
            "type": "html",
            "text": "-- [[Alistair Cockburn]]",
            "id": "ffd063b06b486bd891c9b4e395525e61"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "I agree that shields have a cost (and we're not usually talking about machine efficiency here - incidentally, I'm using Java, not C++). I don't <i>always</i> use ABCs. On this recent occasion I wanted to separate in my mind those parts of the interface which were fundamental, from those which were incidental. As it happened, I found that I needed an alternative implementation within the week, but that was a surprise. As the [[Extreme Programming]] people say, it wouldn't have been hard to refactor retrospectively.",
            "id": "0183a1f757dc7f6c8232d638371bfff2"
          },
          {
            "type": "html",
            "text": "\nMaybe my shield was the \"smallest possible\" under the circumstances. It strikes me as a rather vague criteria. A smaller one (that is, no ABC) would not have been \"possible\" because it would not have expressed what I wanted to express.",
            "id": "4eebbbbcf081a3d108d555e44a16bb86"
          },
          {
            "type": "html",
            "text": "\nI feel a lot of these things are really forces, not patterns. We have here a drive against premature generalization. There are opposing drives for necessary generalization. A pattern is needed to bring these forces into dynamic balance. \"[[Smallest Shield]]\" is not a pattern, it's a vacuous restatement of the problem, leaving the real problem (how small is that?) untouched.",
            "id": "eb10dbb5c1fa3bacd60e3a4f0b0da783"
          },
          {
            "type": "html",
            "text": "-- [[Dave Harris]]",
            "id": "949249fca4f809918ea05d90b2164c9f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "I used to think I was pretty smart, but I'm just not getting this. Please see [[Bridge Pattern Is Just Good Factoring]]. -- [[Ron Jeffries]]",
            "id": "c2328bbfeaed8bd6b81adcf3337ded68"
          },
          {
            "type": "html",
            "text": "<i>A parable might help:</i>",
            "id": "dba2bbe699729cf7952ae86f7979e8f3"
          },
          {
            "type": "html",
            "text": "\nOnce upon a time, there was a vegetarian tribe in the Amazon called the Expees. A Catholic missionary arrived in their village one day. Curious, the Expees decided to listen to him, and asked him questions about his religion. During this discussion, the missionary revealed that, if they converted to Catholicism, the Expees could not eat meat on Fridays.",
            "id": "6101a9a2ff0197d9dc180800751c6681"
          },
          {
            "type": "html",
            "text": "\nRonj, War Chief of the Expees, nodded slowly and said, \"We already abstain from meat on Fridays. But what's special about Fridays? I'm just not getting this.\"",
            "id": "7679324e460ed079659a04136222c054"
          },
          {
            "type": "html",
            "text": "\nWhereupon a wide-eyed child of the tribe piped up: \"Yuck! He means Catholics <i>do</i> eat meat the other six days!\"",
            "id": "a9ee58964468e831368ba31940116f0e"
          },
          {
            "type": "html",
            "text": "<i>Deciphering the parable:</i>",
            "id": "72215752252339e3e4e854a4f31170d9"
          },
          {
            "type": "html",
            "text": " eating meat --> putting in something you don't need right now",
            "id": "ee76de072f5ed2311914f662bc1ae246"
          },
          {
            "type": "html",
            "text": " vegetarianism --> following [[You Arent Gonna Need It]]",
            "id": "87af90a7352a9633e470c24ce23955f3"
          },
          {
            "type": "html",
            "text": " Expees --> [isn't this heavy-handed enough already?]",
            "id": "2bba5c5d93473f88736e4ec2869b4daf"
          },
          {
            "type": "html",
            "text": "-- [[George Paci]]",
            "id": "dadb0eacb7b142d7d30a53d220042c33"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "\nHere is a crack at finding out what is essential about the [[Shield Pattern]]. [[Alistair Cockburn]], please tell me if I'm mangling this in any way, but I from what I've read it seems like a very general thing.",
            "id": "348a2bbfc84a833440e7028b9837c24e"
          },
          {
            "type": "html",
            "text": "\nA shield is any construct which changes less rapidly than what it protects. In a sense, abstractions can be shields because they are often assumed to change less rapidly (being partial descriptions) than what could be fully described. In this sense, a base class is a shield for a derived class, and an interface is a shield for a anything that implements it. In addition, an operation signature is a shield for inline code.",
            "id": "04fa28d60a9a2131186ce08026945550"
          },
          {
            "type": "html",
            "text": "\nI would suppose that we could see [[Systems As Living Things]] and consider the shields in the system to be the harder parts (endoskeleton).",
            "id": "506dd8ba777e522544935dfdba15cfe3"
          },
          {
            "type": "html",
            "text": "-- [[Michael Feathers]]",
            "id": "6aabd4bf35b00e3351d29bd9202037ea"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "I'll suggest another direction to take [[Shield Pattern]]. I think it needs to be a bunch of more specific patterns.",
            "id": "de432f76fe8edc549d82da82604c520d"
          },
          {
            "type": "html",
            "text": "\nOne of everybody's favorite patterns is [[Light On Two Sides Of Every Room]]. It describes a specific physical arrangement of space to solve a general and abstract problem.",
            "id": "c4f6ff32a676de7e53cc7023eacae917"
          },
          {
            "type": "html",
            "text": "\n[[Shield Pattern]] seems to me to be an abstract solution of an abstract problem. \"Things change, therefore separate the parts that change from the parts that don't.\" ",
            "id": "3de8dee9d7f75c1bd0bc9b866c0c5cff"
          },
          {
            "type": "html",
            "text": "\nOne of my rules for a pattern is the Ingenious Fool Rule- to what degree can someone think they are following a pattern and really be missing it altogether. [[Shield Pattern]] leaves entirely too much room for misunderstanding. I have often heard people say the equivalent of \"well, that's there because I needed a shield,\" when they didn't. Shield has a wide field of effect with a large margin for error.",
            "id": "235d5ced93a356f128710275d6d65dbb"
          },
          {
            "type": "html",
            "text": "\nHowever, there is clearly something in Shield that we all recognize and resonate with. We've all done things that we can express as \"shields\". Ward's [[Intention Revealing Selector]] is a shield. Bridge is a shield, as are all the creational [[Design Patterns]]. The [[Analysis Patterns]] book has many shields at a business level, like [[Type Object]]/[[Reified Type]].",
            "id": "36dfe9873a521396af3413db3afa5539"
          },
          {
            "type": "html",
            "text": "\nAlexander says \"safety\" is not a pattern, it is encoded in and emerges from a family of concrete patterns- [[Bannister Height]], [[Soft Tile Floor]], and so on. Information hiding and encapsulation are not patterns, they are principles embedded to greater or lesser degree in the things we create and the patterns we use to create them.",
            "id": "71c90c225b95fc9b3c954464de537f1e"
          },
          {
            "type": "html",
            "text": "--[[Kent Beck]]",
            "id": "b7c2cf38a50bf933a7294ba8fd49c06d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "Kent, I think you are right. -- [[Alistair Cockburn]]",
            "id": "0a872e9265f7a5b0ec0edd3bd51f513e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "\nWell, I'm not sure I know what you mean by [[Shield Pattern]], but when I read it here it resonated with a problem I've been thinking about. Consider a large legacy system, written in (say) mostly C, still very alive and being modified,\nwith newer stuff being done in C++. Now say I want to port that to Java. What's the best approach?  ",
            "id": "3224bb3f513a7a1945019c934a59b40e"
          },
          {
            "type": "html",
            "text": "\nFirst thought is to wrap the existing structure of modules behind a set of Facade classes. Then the more dynamic modules can be immediately ported, and the more stable ones can be left alone for a while. This is what I think of Shield as being:  a wrapper for the [[Public Interface]] of a module (package).",
            "id": "b783cf95124eebc3bcc46e6510cbfe9d"
          },
          {
            "type": "html",
            "text": "\nThis is only a small part of the problem, though, because those modules don't just sit there in isolation; they've got to communicate somehow. The way this happens will depend on the system, but at the least there'll be Messages, or Events, or some similar means of communication; also, there will be some type of data or application-object that gets passed around as the various modules perform work on it.",
            "id": "47e13827f0c2da38eb6061891f69bb3e"
          },
          {
            "type": "html",
            "text": "(If the metaphor casts the Facade as a Shield, then these are the Swords and Arrows, I guess. That's probably not a useful characterization.)",
            "id": "e35b227d014c7cae15b0bac576bbacfe"
          },
          {
            "type": "html",
            "text": "\nThese inter-module objects are kind of outside the system; they don't really have a home. Or rather, they have more than one home, and it isn't necessarily clear where they should actually live. I guess it's reasonable to hide their creation behind a Factory method or some similar object-creational method in one of the Facades. But they still need to be public, not hidden, and therefore don't actually fit in with the idea of hiding everything behind a Shield or Facade.",
            "id": "9625586a5bf5096a052885c6e37e175c"
          },
          {
            "type": "html",
            "text": "\nThe standard approach, I guess, would create a new module for 'common' interfaces, and put the definition of these objects there. But that idea sure fails to impress me with its elegance; it's what we did in the first place, when writing the original C version. There ought to be more modern ways of dealing with it.",
            "id": "5a1f0fb7f556a41cf260361b28ec2485"
          },
          {
            "type": "html",
            "text": "\nWhat's a good way of dealing with this kind of stuff?  There's a need for the travelling objects to be able to mutate into new states; there's likely a class hierarchy defining the types of the objects; there's also a set of rules defining the allowable transformations that can be applied along the way; it's necessary that any given module have access to the information it needs in order to determine if an operation is legal, and if so how to apply it. This begins to sound like a pretty large bundle of information that must be available to all modules, and that therefore all modules depend on.",
            "id": "e5cb11b4797ccddc3b96819c98bae8c5"
          },
          {
            "type": "html",
            "text": "\nSo there's a pressure to do some kind of State pattern, and encode the allowable transformations and operations in the objects.",
            "id": "492907a7cdf596ce52bb82eb834c55e1"
          },
          {
            "type": "html",
            "text": "\nThere's also the pressure to maintain some consistency with the legacy system;\nI can't immediately rework the whole thing to handle a new strategy.",
            "id": "c3a5710e36912b6d0e31786416f76c99"
          },
          {
            "type": "html",
            "text": "\nuhhh, geez, I started out talking about the [[Shield Pattern]]; it looks like I got a bit distracted there. :-) Anyway: is this the kind of problem [[Shield Pattern]] is intended to deal with? And, am I missing something obvious that deals with the travelling-objects problem I'm trying to describe?",
            "id": "46d8f9b6281859566225f8faf910fe08"
          },
          {
            "type": "html",
            "text": "-- [[Kevin Kelley]]",
            "id": "6344a9034158ddda42dde38957bfefc6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "\nAre we discovering various shields over in [[Component Design Patterns]]? We have different things like [[Context Independence]], [[Container Independence]], and [[Interface Discovery]]. Would some of the above add to these, and can all of them be thought of as [[Shield Pattern]]s?",
            "id": "f21e073087ddfe319f984439761f4807"
          },
          {
            "type": "html",
            "text": "\n[[Philip Eskelin]]",
            "id": "c6139459d458773bc60b2d5c459ed15a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "\nI always thought of [[Shield Pattern]] as one of the highest-level patterns a person can learn - if they don't get it, then a lot of good software engineering just doesn't make sense to them. A lot of patterns are [[Shield Pattern]]s, but at the same time I don't think that that is the <i>only</i> category that they belong in. As Ralph and Kent point out way up at the top, the [[Shield Pattern]] is the patternizing of a principle that good software engineers have known about and used for years (which, by the way, is what makes it such a good pattern). IMHO I think we should reference it, and mention the connection other patterns have to it, but I don't feel a need to make it a \"foundation pattern\" of the CBD language.",
            "id": "e38d483fc7df44785d106af34c80c023"
          },
          {
            "type": "html",
            "text": "\n[[Kyle Brown]]",
            "id": "89b41c8489aa1b9b265aec2d26db146c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "I think Kent named the trouble. It is an abstract solution to an abstract problem. It is a pattern in the sense that various good people have settled on it at various times in various technologies, and it is difficult to get immediate value out of because it is abstract. I'll just let the abstractness of it suffer until someone gets a better handle on it.",
            "id": "9351bfb26687c148c48ead99f766c703"
          },
          {
            "type": "html",
            "text": "\nWhere I am going with my thoughts about shields in general is to try to assess the cost of a shield. More shielding often means greater cost in cognitive load or performance. So it is not simply a pattern that says \"do this\". The counterforces, or overdose effects, are noticeable and are to be accounted for. The Truth In Advertising for a shield, indeed, any pattern or recommendation, ought to include its costs. (are you it doing with the [[Component Design Patterns]]?) -- [[Alistair Cockburn]]",
            "id": "1f4d2e9c2ba07218adf58f39861bcc81"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "Doing cost? - sort of. In some places we've addressed cost, but what you're describing is somewhat deeper. As Kyle says, we should fully embrace since some of them can be classified that way, but not explicitly give it a home among the other [[Mini Pattern Language]]s. I think components in their nature are all about shielding. They can make it easier for you to eventually strike the right balance between forces associated with too much and too little shielding. Conceptual chunking, or as said above, an abstract solution to an abstract problem. -- [[Philip Eskelin]]",
            "id": "23bb0b687d8c09fe0f2e9a08eee4e87e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "I think that is a hopeful (wishful?) approach. I don't think components are so much about shielding as they are about development cost. I don't buy a component to protect the right of the implementer to change the implementation (gack! rather the opposite!) but mostly because I can buy it and stick it into the system cheaper. If the implementer changes the implementation, I am likely to get hurt. Also, components are more likely to be big than small (small components I would develop myself) - hence would drift toward fat interfaces encapsulating lots of stuff. The Truth in Advertising, cost, counterforce, or overdose business provides a) a chance for me or you, the author, to stare at our stuff and better detect its true placement in the scheme of things, as opposed to our initial optimistic blushful wish; b) a way for the reader to assess the engineering tradeoff of using the idea (as opposed to, say, using it and then cursing you for not mentioning the downside). -- [[Alistair Cockburn]]",
            "id": "fe353b4d9472c08392d1e951b8bbaef0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "A shield should be big enough to cover all the functionality required by clients who are not also creators.\nCreators can have a reference to the implementation, so nothing is shielded from them.\nIf they hand the shielded object to others, the shield should be big enough for the purposes of those others.\nThe cost of the shield is how much effort it takes to change all the implementations if the shield is changed.\nI can see two rules here:",
            "id": "a994184ea426d6fae84e5e32410f3cc1"
          },
          {
            "type": "html",
            "text": " if the only client is the creator, you don't need a shield",
            "id": "a52693b87504eda712b93d97703271a8"
          },
          {
            "type": "html",
            "text": " if there is only one implementation, you don't need a shield",
            "id": "554c336d3948ed7c0539e1059f3e8196"
          },
          {
            "type": "html",
            "text": "-- [[John Farrell]]",
            "id": "833cdfa3ba7a51ecd11f2ddfefb2fcca"
          },
          {
            "type": "html",
            "text": "<i>The above is also found at [[Smallest Shield]].</i>",
            "id": "15e5a71e64c5f5f8d14eb0c7ac251d1b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "<i>The cost of the shield is how much effort it takes to change all the implementations if the shield is changed.</i>",
            "id": "7d22616f6eddfe86fc23dc78173163c2"
          },
          {
            "type": "html",
            "text": "\nThat's one useful measure (let's call it \"[[Shield Change Cost]]\") of how good a given instance of Shield is: If my Shield (e.g. interface) changes, how much do I have to change what's behind it (e.g. implementations).",
            "id": "1350edea4550a62444a8ace59b84183a"
          },
          {
            "type": "html",
            "text": "\nFor example, if I have a Tool interface, and later want to add disabled/enabled behavior, how large will the [[Shield Change Cost]] be?  In this case, not very large: if I have a single [[Abstract Base Class]] that implements the interface (what Swing would call an Adapter), I should be able to add setEnabled()/getEnabled() there and there alone.",
            "id": "a7f2e94b1e5211a2c3434fe18eb08928"
          },
          {
            "type": "html",
            "text": "\nBut Alistair is talking about something much broader when he asks about \"cost\". He's trying to answer this question:",
            "id": "fb3eaf4dedd4a0cf55c843ed8e38259d"
          },
          {
            "type": "html",
            "text": "<i>What things about a given Shield would make me</i> not <i> want to use it?</i>",
            "id": "4411bb3b52af71c5d20c1a66123c2f48"
          },
          {
            "type": "html",
            "text": "\nA partial answer, then, is: the Shield is rigid (has a [[Shield Change Cost]]), and can be hard to change; don't put at Shield at a place in the design that is likely to change.",
            "id": "d1cfd8eba163c5309958e6492d98fade"
          },
          {
            "type": "html",
            "text": "\nBut you should also consider:",
            "id": "c197f9a39fdc1a79ca3bae952eea989f"
          },
          {
            "type": "html",
            "text": " [[Shield Installation Cost]]:<br>how much do you have to change the existing code to put the Shield in?",
            "id": "12077e234500bf5308ae1443c2c25356"
          },
          {
            "type": "html",
            "text": " [[Shield Performance Cost]]:<br>does this Shield make the system slower or more memory-intensive?",
            "id": "b14b3a05d904e686c89936e008f2053e"
          },
          {
            "type": "html",
            "text": " [[Shield Cognitive Cost]]:<br>does this Shield make the system more confusing for people to understand?",
            "id": "a4ee95a065758f8c94e7d2f7dddf5ed2"
          },
          {
            "type": "html",
            "text": " [[Shield Maintenance Cost]]:<br>how much harder does this Shield make it to change the system?  (This should always be negative!)",
            "id": "c5337fd0284c093c4f4238be841c7842"
          },
          {
            "type": "html",
            "text": "\nAs for Interfaces and [[Abstract Base Class]]es (ABCs): I can't see a situation where you wouldn't want to use them together. Any time you have an interface, you presumably have a couple of classes that share some abstract behavior (e.g. draw(), addListener(), for UI components). There will always be some implementation of that behavior that they both have, as well. So refactor it into an [[Abstract Base Class]] that implements the Interface, and have the concrete classes subclass from it.",
            "id": "befa43f9cdadcb0dbb98ff2fcb7b8116"
          },
          {
            "type": "html",
            "text": "\nThe other direction: say you're adding an [[Abstract Base Class]]. Clearly, it implements some Interface. Why not put that explicitly into the program right now? The cost is virtually zero: a tiny bit more typing to create the Interface code; you'd be changing concrete class references to ABC references anyway, so changing them to Interface references instead is free.",
            "id": "eb025c63d7f131226d9bd04e28d3f34d"
          },
          {
            "type": "html",
            "text": "\nAnd the benefit is that if, later, you want to add something that has all the abstract behavior of your [[Abstract Base Class]], but none of the implementation, you can just directly implement Interface; you don't have to touch any of the calling code, and you don't have to convert it from using [[Abstract Base Class]] to using Interface.",
            "id": "f74e842eb3ce97674b3dd86651287af3"
          },
          {
            "type": "html",
            "text": "\nThe only objection I can think of is the [[Shield Cognitive Cost]]; but that seems very small to me. Explaining it to a teammate would go something like this: \"Well, you have an interface, and you also have this adapter that you can subclass so you don't have to reimplement all the basic parts of the implementation. Just like in Swing.\"",
            "id": "6b056f244f0e0ff0ba1ae41e284fd270"
          },
          {
            "type": "html",
            "text": "--[[George Paci]]",
            "id": "85e23d21b123e7054aff0bec7974174d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "Good reply. I wouldn't underestimate the [[Shield Cognitive Cost]], though. I have seen beginners given the [[Shield Pattern]] put so many things behind so many interfaces (protecting so many potential design changes) that I couldn't find where the <i>function</i> was being performed. Huge cognitive cost. As far as I'm concerned, one of the things that sank Taligent was too many itty bitty classes and too high associated cognitive costs - no one could learn how to use the system. -- [[Alistair Cockburn]]",
            "id": "1bacf852296470781e11dd9523222c7c"
          },
          {
            "type": "html",
            "text": "\nYes, but that was a symptom, not the disease. One way to keep shields from being too heavy is to have a group of people work with them every day. It is hard to get an abstraction right, but if a group of people work with it and keep trying to get it better, they will usually complain about bad abstractions and make sure that the abstractions are good enough. Taligent had no users, hence nobody to complain about bad design. Well, I'm sure that some people complained about it, but most people were too busy building their own part of the system to worry about someone else's. Frameworks without users are never any good. -- [[Ralph Johnson]]",
            "id": "b850ac849e9364066ea8bb358c04cbdb"
          },
          {
            "type": "html",
            "text": "\nAlistair: I think your problem wasn't with the cognitive cost of <i>each</i> shield, but with the <i>cumulative</i> cognitive cost of <i>all</i> the shields. Note that I didn't say \"total\" cost: costs of adding things to a system aren't necessarily just a function of the thing being added. You can't just say, \"Well, if we add five shields, our cognitive cost will increase by 5 [[Milli Einstein]]s.\"  It depends a lot on what the rest of the system is like, and whether the shield is actually used.",
            "id": "c50f99abf7ad47c72acde1e6ed5af1c2"
          },
          {
            "type": "html",
            "text": "\nI think if each shield were really pulling its weight, the system would have been easier to understand. Using a structure provides the reader with a concrete example of why it's useful, thus <i>decreasing</i> the associated [[Cognitive Cost]], usually by enough to offset the cost of the client code itself.",
            "id": "b5596b91ac2b31c54ea67e6a9a4184e8"
          },
          {
            "type": "html",
            "text": "\nThe important thing here, I think, is that some of the shields were added, increasing the [[Cognitive Cost]] of the system, without actually conferring any benefit. If we want to assimilate this to your concept of [[Smallest Shield]], I guess we'd say (some of) the instances of Shield could have been replaced with a smaller possible instance: no shield.",
            "id": "31ed69e1d211441f7c07476d3a819aaf"
          },
          {
            "type": "html",
            "text": "(This also illuminates a good meaning for \"possible\", to wit,:\"possible while still gaining the needed benefit\". In the case of unused shields, the benefit is ipso facto nothing, which means just plain leaving them out would still gain the (nonexistent) benefit.)",
            "id": "bb208e8456d72b818c27019c6911d297"
          },
          {
            "type": "html",
            "text": "\n[[Cognitive Cost]] is not dollars-and-sense accounting; get used to looking at costs marginally, and mocking things up to estimate them. Also look squarely at what the marginal benefits are, and whether they outweigh the costs. And if you can't estimate the cost of something, it's a risk, and it may be that [[You Arent Gonna Need It]] anyway.",
            "id": "3662349999df630010b5b941c55ca487"
          },
          {
            "type": "html",
            "text": "-- [[George Paci]]",
            "id": "dadb0eacb7b142d7d30a53d220042c33"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "I was surprised nobody has used the word <i>indirection</i> here (unless I missed it). Is seems to be that much of what the above discussions on the [[Shield Pattern]] seem to be talking about is the often-quoted observation that just about every problem can be solved by adding another level of indirection. -- [[Anthony Lauder]]",
            "id": "d719a6bae341a869fdde10ce5e769107"
          },
          {
            "type": "html",
            "text": "\nExcept for the other part often stuck on that quote, \"...except for too many levels of indirection.\", which seems to fit Alistair's concerns about \"heaviness\". -- [[An Aspirant]]",
            "id": "fd989869c78171abfbd135354a3fb658"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "\nOutside of this page, is \"shield\" a common term used to describe this pattern/principle?  I found the term confusing, and didn't understand what it meant until I read the page a few times. To me, the term \"shield\" implies protection against unwanted access, or an intentional attack, not protection against the consequences of a decision. I think a better term would be something like \"Commitment Minimization\" (but shorter), or maybe \"hedge\". -- [[Kris Johnson]]",
            "id": "a959fed9a873fa7f3d0d006cf975e16c"
          },
          {
            "type": "html",
            "text": "\"Hedge\" might be a good choice; beyond the physical referent of a barrier, it also is used in the context of minimizing risk, as in \"hedging your bets\". Large companies frequently use all sorts of financial instruments to hedge their losses in case of bad weather or high oil prices or whatever else.",
            "id": "bbae7541be8e976aebbe038fd35f91a8"
          },
          {
            "type": "html",
            "text": "<i>\"Hedge\" doesn't work for me. You hedge against bad consequences of action A by taking the very different and in some ways opposite action B as well, like buying a certain stock and, at the same time, put options on the same stock. That's IMHO too specific an idea to match what [[Shield Pattern]] describes.</i>",
            "id": "484b166f37bd432e3bcb9dfa89f38ec9"
          },
          {
            "type": "html",
            "text": "<i>If we need a different term, I would like to humbly suggest [[Design Hinge]]. -- [[Falk Bruegmann]]</i>",
            "id": "ca787b12e9050dba9e2bf4bdd19a3ca7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "Hmmm, a shield is surely just a concrete, immutable point of extensibility no? And has two things going for it... it means a piece can articulate and hence adapt without having to be a limp bendy mess in order to adapt.",
            "id": "2d419c317a514482b5bf229cf895b8db"
          },
          {
            "type": "html",
            "text": "\nOr looking at it another way, a shield is a node on a graph... you have choices you can make at a node as to which edge you can take.",
            "id": "755955bcc9ae6d8644532322da09acdd"
          },
          {
            "type": "html",
            "text": "\nI personally am not sure that \"shield\" is a good choice of term, and think it focuses to much on defensive programming...which isn't to say such focus is bad, simply that it doesn't convey what the pattern offers, and instead focuses on what it avoids.",
            "id": "0b99f51ce3a224dff7a6713c1487d0d3"
          },
          {
            "type": "html",
            "text": "\nEither that or I'm missing the point entirely.",
            "id": "807b1a1d55b133cc70f1aac7f7804212"
          },
          {
            "type": "html",
            "text": "-- [[Guy Murphy]]",
            "id": "d9d31a725f41dc12d14f4c74203fd03c"
          },
          {
            "type": "html",
            "text": "\nThe key difference is (from the top of the page), \"the fact that in Eiffel and Self an attribute access reads the same as a function call.\" In Eiffel, one writes, \"myClass.service\" . . . and cannot, from that, tell if 'service' is a data element being directly referenced, or a zero-argument function call. . . . and Bertrand Meyer did that on purpose, explicitly to allow the author of myClass to change his/her mind about that very choice. ",
            "id": "0e6ef73a040a97aba6d7624d358e517a"
          },
          {
            "type": "html",
            "text": "\nIf this fits what you mean by \"extensibility\", they the answer to your question is \"yes.\" Otherwise it is \"often but not always.\" ",
            "id": "3c14b91d0b23efa44fff657f4d3319a8"
          },
          {
            "type": "html",
            "text": "\nI find two values in metaphoric word \"shield\". The first is that behind a shield (force field, barrier) one can do things hidden and protected from the world in \"front\". In software, that is, change one's implementation. The second is that shields get heavier as they get bigger, so there is a cost as well as a benefit. That aspect doesn't get enough discussion to suit my taste. -- [[Alistair Cockburn]]",
            "id": "4b01aef6031997d30681cad829b88e0a"
          },
          {
            "type": "html",
            "text": "<i>What do you mean by 'heavier'? An interface doesn't seem too heavy to me, albeit redundant. Compared to, say, an abstract class hierarchy.</i>",
            "id": "a254975d947c2870dd77b384d723b012"
          },
          {
            "type": "html",
            "text": "\nIndeed - exactly as you write, \"heavier\" is relative. An interface is relatively heavy or not, depending on what you're comparing it to. A framework's API is heavier than a class's interface is heavier than a function's interface is heavier than a variable name is heavier than a constant. The heavier, the more flexible - but that comes at a cost, of efficiency and cognitive complexity. -- [[Alistair Cockburn]]",
            "id": "c9f1ec7f2decab94267f56f7efb6a7e5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "\nWell, I'm new here, but on a read of GoF and a few of the patterns linked here, I'm of the opinion that [[Shield Pattern]] is far too broad. This strikes me rather as making a \"vehicle\" pattern, and then asserting simplest possible vehicle is desirable, then laying down considerations - fuel efficiency, speed, comfort, prestige, cost - in order to select between [[Roller Blades]], a Lear Jet, a Rolls Royce, a submarine, and the various points inbetween. Whereas it is a useful abstraction, this \"vehicle,\" good for describing utility or intent, is it a useful pattern?  When designing something whose intent is to make a device to transport people or commodities from point(s) to point(s), does first considering it as a vehicle and then applying the commonalities of a vehicle grant you any insight?  Before you point out that the luxury of the Rolls Royce was explicitly imitated by Lear, do remember that we're also talking about surf boards, skateboards, military interceptor fighters, and roller coasters. There aren't many particularly useful general observations.",
            "id": "968635727f8b5bd735bb35fee0e3bf60"
          },
          {
            "type": "html",
            "text": "\nWhat I believe is happening here is that an attempt is being made to codify a more general thing than a pattern as a pattern. The metapattern suggestion that Pete Hardie made at the outset of the discussion seemed about dead-on to me at first, but I've now changed my mind. When you create a new sporting transport device - let's say you're the guy that invented windsurfing - your approach is to identify something you'd like to achieve, generally by analogy with a similar act in an alternate medium. \"Surfing is fun,\" one imagines he might have said, \"but it would be more fun in the air instead of the ocean. Or at least it's worth a try.\"  At that point, there are a bunch of considerations about where you get the velocity, the lift, how you prevent frequent neck breakery, et cetera. However, the observation that it's a vehicle, and that therefore that you will cover distance, that it will take a nonzero amount of time to complete transit, that it involves equipment external to the body, and so on - don't do you a hell of a lot of good. Also, this points out again that some things which seem to be superficially related to a pattern in fact are not, but are common only to the more obvious applications of the pattern - my Rolls Royce example again shows some promise when you make the observation that most windsurfers don't need a wetbar or corinthian leather seating en route.",
            "id": "bc3cce235b6d884a8037fa7ddd7636a7"
          },
          {
            "type": "html",
            "text": "\nThing is, if you've got a sarcastic enough mind, it's very easy to create useless (or so seeming) patterns. For example, it could be suggested that the bulk of programming languages would do well to be expressible with symbols available on a keyboard, which has few counterexamples unless you have experience with digraphs and trigraphs, or APL. I'd argue that that's the case with the vehicle pattern - it is indeed a pattern, but it's so broad and so vague that it doesn't provide any useful rules or observations as a result. By the time you've identified the need for it you've already gotten all of its ramifications by earlier mechanisms. You never say \"oh wow, you know, I should make this thing a vehicle.\"  I also think that that's the case with [[Shield Pattern]]. It's overly broad. Some patterns really do descend from one another (I often get into arguments over my belief that singleton is effectively an ancestor of flyweight.)  Yes, if you wanted to categorize the various ways to protect outside code from change, then you could refer to them all as shields. Does it buy you any utility?  Maybe in discussion. GoF notes that one of the uses of patterns is to provide a common vocabulary for discussion. In that way, maybe Shield Pattern could be useful.",
            "id": "f7f6dc6d37a02e90e20ab71c4edd9a6b"
          },
          {
            "type": "html",
            "text": "\nBut do I think it's a good pattern?  I don't, really. I don't see what it gains us. I'm from the C++ mindset, and I prefer minimalism. I believe that the smallest interface which can represent a set of tasks without introducing extra complexity (yay vagueness) is best. I haven't been here long enough to know whether that's considered common wisdom (or a common misconception,) but it's the platform I choose to argue from. I tend to see patterns as a tool for displaying complex and interlocked concepts in a semiconcrete and usable fashion, mostly as a way to exchange experience. I also see them as a \"heavy tool.\"  I wouldn't use a pattern to describe functions, or variables - the concepts are too simple to warrant such attention. There is a point of diminishing returns here; if you used a pattern to try to explain variables to a novice, it would be harmful; it'd take forever, it'd be distracting, it'd be confusing. I see explanations much in the same way that I see interfaces; the shortest that effectively communicates the whole is best. In more classic terms, \"Brevity is the essence of wit.\"",
            "id": "5e79550584e8fc0f5f26d83c6659ae52"
          },
          {
            "type": "html",
            "text": "\nGoF presents three categories of pattern. Would it be appropriate to make a pattern called \"Creational Pattern?\"  Well, sort of. There are commonalities to creational patterns. They have a similar aim, they have a similar goal, they share some common methods by necessity - they need to pass a created object out, they need to provide mechanisms (be they internal or external) to specify what will be created, et cetera. I would argue that yes, there is a pattern called \"Creational Pattern,\" and that it's a dead pattern. By the time you've realized that what you have on your hands is a creational pattern, there's nothing that Creational Pattern can teach you, no way in which it can advise you, no alternatives or considerations it can provide you.",
            "id": "116e0f30ac1401087e0305c6fc408726"
          },
          {
            "type": "html",
            "text": "\nTo use a phrase without defining it is the ev1l. A dead pattern is a pattern which satisfies the requirements for a pattern but whose existence cannot provide any useful information for judgement. Therefore, a dead pattern requires that you've identified all of its considerations in order to identify it in action. Therefore, I feel satisfied generalizing it into the rule of thumb that a dead pattern is simply a uselessly overbroad pattern.",
            "id": "1b541dae48d4e49b715ab471c9cb90d2"
          },
          {
            "type": "html",
            "text": "\nWhat does the Shield Pattern advise?  The shield pattern advises that you protect something changeable behind something less changeable - Michael Feather's description seems elegant. Then, a few people have made mention that they'd like it kept minimal given circumstances. I had thought that nominal. I fail to see any other real insight here; people are observing that one or another pattern descend from this, that encapsulation is a formalization of this observation, that some languages provide literal implementations of this at the language level (privacy and scoping, namespaces, interfaces, and various things which haven't been mentioned - aspects, call by contract, call by name, or less literal things.)  In many ways, you might observe that the C++ standard serves as a shield of sorts. It specifies what will be available, how long it will take, what its complexity and resource requirements are allowed to be, how limitations are to be reported, and so on. I would suggest that it is in fact an incredibly strict shield for the domain it covers; much unlike Alastair Cockburn, I don't feel that switching implementations should ever hurt the user. I am (usually) not hurt moving my code between compilers; because I understand the C++ Standard shield well, I know what things I may rely on as requirements, and the things which are important to me, such as algorithmic complexity, are maintained. I would argue that if switching implementations is dangerous, you have an insufficient shield.",
            "id": "3acb55e0de7bc1aca2eac419dcf1d7dd"
          },
          {
            "type": "html",
            "text": "\nAll that aside, I can't really see any utility to the [[Shield Pattern]]. I think of patterns essentially solely as a teaching mechanism, and teaching is what I've paid the most attention to of all my hobbies over the last few years. I've come to the conclusion that the most difficult thing to find is a Really Good Example (tm). People tend to choose their examples according to what they know, or what's germane to the topic at hand, rather than for their expressive ability. To give a concrete example, in a recent class I taught (no, I'm not the professor who has my name) I gave chess as a midterm assignment. I feel it's a good learning experience - the rules are absolutely concrete and have no vagueness, the game isn't overly complex, there are some simple easy approaches that give results which aren't outwardly disappointing (by comparison, Go is astonishingly difficult,) has a few interesting caveats but not many (there is a situation in which more than one piece may move, there are times at which you can have more of one piece type than you start with, but never the king or a pawn, et cetera. By contrast, checkers is not a good example; it's too simple to be interesting. Similarly, Magic: the Gathering and other collectable card games, or Knihtmare Chess, or contract bridge, or baccarat, or dungeons and dragons would all make bad examples; though they're fun games, they're far too complex and plagued with far too many special cases to make a good teaching mechanism. To that end, patterns must also be carefully chosen. There are, to my sarcastic eyes, a forest of bad patterns to be identified. Dead patterns are only one class of bad pattern, and they're a particularly dangerous one - they're easy to mistake, they cause the consideration of dangerously different substitutions, they don't provide any utility, they absorb useful brain time.",
            "id": "3c3552771bf34317dbb7d07f6b6e9a7f"
          },
          {
            "type": "html",
            "text": "\nI'm not very confident that a [[Shield Pattern]] is a dead pattern. I'm really just trying to establish the notion of dead patterns, to get criticism, and maybe in the path to identify the problem with Shield. Still, that's my diagnosis. I do think it is a pattern. I just don't see what it's good for.",
            "id": "a844887c0fc49d03b4ff1177d5bfe00d"
          },
          {
            "type": "html",
            "text": "-- [[John Haugeland]]",
            "id": "07f5d3303a9b991bc782c5021521025c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "\nTo me, Shielding is about abstraction entirely. One of the tenets of OOP that caught my attention from the beginning was that abstraction could go all the way up to the point that source-code could almost read like the abstract description of that very same code.",
            "id": "f3d66488e307e5b6cf877562a5c494ad"
          },
          {
            "type": "html",
            "text": "\nFor instance (pun intended), if you are programming some special math or engineering routine that deals with vector algebra, the abstract description for adding two vectors into a third vector would look like:",
            "id": "c980e1e4ef00ac150e7f31279ed6f477"
          },
          {
            "type": "html",
            "text": "\nw = u + v",
            "id": "7e05979496355fda4898e7d46fbfbaa6"
          },
          {
            "type": "html",
            "text": "\nAssuming that operator overloading could be considered some type of shielding, my (client) code could read like this:",
            "id": "83bc481b3ba5051725028d378fcf5be8"
          },
          {
            "type": "html",
            "text": "\nVector w, u, v;",
            "id": "842e80b77104ca869cedb14809fd7e85"
          },
          {
            "type": "html",
            "text": ". . . ",
            "id": "f33dd5c22356af44da470b41726b3ae7"
          },
          {
            "type": "html",
            "text": ". . .",
            "id": "87f4ad6d8e724362458708ad775db701"
          },
          {
            "type": "html",
            "text": ". . .",
            "id": "87f4ad6d8e724362458708ad775db701"
          },
          {
            "type": "html",
            "text": "\nw = u + v;",
            "id": "fa3c72421d4cc279ff283c4b5d5d2e49"
          },
          {
            "type": "html",
            "text": "\nVoil!",
            "id": "cd276c2b2b88ae92fbf5c824070f5dcd"
          },
          {
            "type": "html",
            "text": "\nLets see another example. Lets suppose that for some reason, I have some class that holds XML data on a certain attribute (field). To have a design as abstract as it can get, I would like that the look and feel of the get accessor in my (client) code to be just like the set accessor. So far, so good. ",
            "id": "f09b88801cf0210481d2c2f793aadcef"
          },
          {
            "type": "html",
            "text": "\nBut, what if I want to make sure that my set accessor only accepts well-formed XML expressions?",
            "id": "60f722d669e044a6e2fba9a801bb8dab"
          },
          {
            "type": "html",
            "text": "\nWell, once again, shielding comes to the rescue. I could hide the (well-formed) validation routine within the innards of my set accessor code. If some XML expression doesn't look good enough, my routine could throw the right kind of exception, and, again, abstraction wins.",
            "id": "695a42376200568dd9b20ce78c95899a"
          },
          {
            "type": "html",
            "text": "\nDoes it sound like I am too C# oriented?",
            "id": "026a8cce08f1dddfca8d295202823a63"
          },
          {
            "type": "html",
            "text": "\nWell, you can only use as much shielding as the language of choice supports. I just chose a language versant enough in shielding to make the point.",
            "id": "7e4a37a39e630b955a3845dad8e14326"
          },
          {
            "type": "html",
            "text": "-- GastnNusimovich",
            "id": "1a93f90c43859ef447538a228f65bde8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "\nIMHO, Shielding is a very elegant technique, capable of producing beautiful abstraction. I do not see it as a classic [[Design Pattern]], since you cant apply a unique collaboration of classes to express it.",
            "id": "a5ccaa0753502ee32ee291d96ab17d0a"
          },
          {
            "type": "html",
            "text": "\nA language has syntactic (notation), semantic (meaning) and pragmatic (usage) rules. To me, Shielding could fall within the pragmatic rules of a [[Pattern Language]]. It is a way of using abstraction. You could attain abstraction through other means.",
            "id": "f0d5ddb76ea81e292dc6cba9b0e2c28c"
          },
          {
            "type": "html",
            "text": "\nMaybe the problem resides in the fact that we are using a loose definition of what a pattern is. When you are on a phase of [[Work In Progress]], looseness is an asset. ",
            "id": "3ba4a552b6b1e9613326064b7549450c"
          },
          {
            "type": "html",
            "text": "\nSufficiency is king. We have some illustrious participants in this conversation that form part of the original [[Agile Alliance]] group, so I am using Sufficiency in that very sense of the word. But at some point in time, you need to shift to precision for closure.",
            "id": "1b0e27165a3cebd4116c9ca2002093e3"
          },
          {
            "type": "html",
            "text": "-- GastnNusimovich",
            "id": "1a93f90c43859ef447538a228f65bde8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "\nIn relation to a previous discussion on Interfaces, an Interface (as a separate software construct) has nothing to do with encapsulation, at least that is the way I see it.",
            "id": "9ba35b61eb31d6a763588849f1ecd5ee"
          },
          {
            "type": "html",
            "text": "\nThe public interface of any given component establishes the language that must be used by client code to obtain services from that component.",
            "id": "4f34922d331de221a02f88cdf9d461a6"
          },
          {
            "type": "html",
            "text": "\nThe public interface of any component coded on any OOP language is the one software construct responsible for encapsulation. Components developed in Smalltalk have a public interface just like any component developed in any other OOP language, so Smalltalk is on an equal standing with any other OOP language when it comes to encapsulation.",
            "id": "b4b519fe56577b6fc6e96f009bbf7e1a"
          },
          {
            "type": "html",
            "text": "\nSince the public interface of a component establishes the language used by client code to obtain services from the component, there is a de facto contract between the client code and that component.",
            "id": "1a068c285af0c9cc6dd234d8f79630ee"
          },
          {
            "type": "html",
            "text": "\nAn Interface as a separate software construct serves as the realization of that contract. The capability of any OOP language to have a specific software construct to realize contracts is a very powerful tool.",
            "id": "19214dd41610e1b22bc77520e2e1e3b2"
          },
          {
            "type": "html",
            "text": "\nWhy is this a good thing? Any other component that implements the same contract (Interface) becomes interchangeable with the original component, at least for the services that relate to that given contract. Language designers can create additional productivity tools around the Interface construct (like Interface inheritance).",
            "id": "1013cfe37ae122db46fe05d2f976a762"
          },
          {
            "type": "html",
            "text": "\nIn this respect, Smalltalk is not on an equal standing with other OOP languages, like C# or Java.",
            "id": "dfe34a8fddf3b0893a137c1e1315e1fc"
          },
          {
            "type": "html",
            "text": "-- GastnNusimovich",
            "id": "1a93f90c43859ef447538a228f65bde8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "\nWhat Alistair and John's comments suggest to me is that [[Shield Pattern]] is of the some order as [[Creation Pattern]]. I never write code and think \"I need a [[Creation Pattern]] here.\" Such patterns are useful for understanding the goals and tradeoffs of programming; they allow us to group a number of related patterns together and say \"these are similar.\" It's a cognitive aid for learning about the art of programming, not for implementation of a specific problem.",
            "id": "e362debe92b298966314af04b5265fef"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ffbbd1d8620635b2b935d102163426e9"
          },
          {
            "type": "html",
            "text": "[[Category Pattern]]",
            "id": "3ce3837b31f93782399a6154a3cb8df3"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ShieldPattern c2.com]",
            "id": "b524f6347dc185ce3a289cb81281f16b"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1660216487192
    }
  ]
}