{
  "title": "Directed Graph",
  "story": [
    {
      "type": "html",
      "text": "A directed graph is a [[Data Structure]] containing a vertex set <i>V</i> and an <i>arc</i> set <i>A</i>, where each arc (or <i>edge</i>, or <i>link</i>) is an ordered pair of vertices (or <i>nodes</i>, or <i>sommets</i>). The arcs may be thought of as arrows, each one starting at one vertex and pointing at precisely one other.",
      "id": "8684292f0fa5408b13eef27c5f930fbc"
    },
    {
      "type": "html",
      "text": "\nThere are several variants of this data structure:",
      "id": "086a06ab1b0fc7b683dc45d8bb947510"
    },
    {
      "type": "html",
      "text": " The arrowheads may be removed, resulting in an [[Undirected Graph]].",
      "id": "89117ed5cf053e1bb885a187ed837f9a"
    },
    {
      "type": "html",
      "text": " Weights may be put on the arcs, resulting in a [[Weighted Directed Graph]].",
      "id": "a3165dc7ac538ad56f1af7a06f3a64b5"
    },
    {
      "type": "html",
      "text": " If it is not possible, starting from any given vertex and following any positive quantity of arcs to successive vertices, to return to the starting point, the graph is said to contain no <i>circuits</i> and is called a [[Directed Acyclic Graph]].",
      "id": "2a4ab1499ec9c28464dd6a2045597323"
    },
    {
      "type": "html",
      "text": " Of course, there's also [[Weighted Directed Acyclic Graph]]s.",
      "id": "e014bd809ed5b1b68cab1c6bb1f821d7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d04c5f62c26cf27fdb3331d8c25300c0"
    },
    {
      "type": "html",
      "text": "A [[Directed Graph]] is primarily a [[Mathematical Notation]] which can be <i>represented</i> as a [[Data Structure]] for programming. You might say [[Programming Is Math]], but [[Is Programming Math]]?",
      "id": "51668a6254750e0a0341be1c80529c26"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d04c5f62c26cf27fdb3331d8c25300c0"
    },
    {
      "type": "html",
      "text": "[[Stu Feldman]]'s algorithm (1979) finds a solution to every problem that can be written as a [[Directed Acyclic Graph]].  The algorithm finds and traverses a path through the graph.  The graph is called a <b>makefile</b>, and his tool is called <b>make</b> (see [[Make Program]]). -- [[Chris Garrod]]",
      "id": "d30e80ef222a0d184583aa73ed057216"
    },
    {
      "type": "html",
      "text": "<i>How does [[Stu Feldman]]'s algorithm answer this?</i>",
      "id": "5ee661aba83fc1625e41c19eabc37364"
    },
    {
      "type": "html",
      "text": "<i>Given a [[Directed Acyclic Graph]] <b>G</b>, consider the set <b>S</b> of all possible linear orderings consistent with <b>G</b>. For two vertices <b>A</b> and <b>B</b>, let <b>P(A,B)</b> be the probability that <b>A</b> comes before <b>B</b> in an element of <b>S</b> chosen uniformly at random. Prove that if <b>|S|>1</b> then there exist <b>A</b> and <b>B</b> such that <b>1/3 <= P(A,B) <= 2/3</b>.</i>",
      "id": "68a824e423625740164d9572b6cf4f3c"
    },
    {
      "type": "html",
      "text": "\nThat's not a problem writable <b>as</b> a [[Directed Acyclic Graph]], that's a problem <b>about</b> [[Directed Acyclic Graph]]s. There is a difference. You're going to have to express your problem <b>as</b> a graph, at which point the effectiveness of the algorithm should be obvious. either for or against (see parenthetical paragraph below). However, while with sufficient work such proofs can be expressed as graphs, you may not like the running time.",
      "id": "43cbb781e22b4d1017a596ebab0f6cf7"
    },
    {
      "type": "html",
      "text": "\nA graph of a proof will start with what you gave the system (the Givens in your problem). Each application of an axiom is an arc leading to a new result. It gets real big, real fast. (Colloquialism deliberate.) ",
      "id": "db28ba0894a0fabe31bd420d818a3ac5"
    },
    {
      "type": "html",
      "text": "(In fact it is infinite, technically, and despite the claim that [[Stu Feldman]]'s algorithm finds a solution to all DAG problems, I would expect that only holds for graphs where all nodes have a finite number of exiting arcs. That isn't true in the obvious formulations of the graph I described, because of the presence of numbers, where you can technically try statements about any proportion of the graph.)",
      "id": "ca02fe38c93d489c8e8ea463add671f9"
    },
    {
      "type": "html",
      "text": "<i>Well, I guess I'm having trouble finding any examples of difficult and/or interesting problems that can be \"written as a DAG\". The only examples I've come up with are simple search problems, or have been devised by taking problems and rewriting/encoding them in a non-natural way.</i>",
      "id": "9f794cb60cb8c27da62116f4ed053694"
    },
    {
      "type": "html",
      "text": "\n[[The Reform Society]] probably isn't the kind of example you were looking for, but you may find it interesting nevertheless as it's meant to be a [[Directed Acyclic Graph]].",
      "id": "2d619b2903072e130ef79d93402a6a29"
    },
    {
      "type": "html",
      "text": "<i>As a graph-theorist and compiler writer I have any number of examples of DAGs. I just don't understand what it means to \"write a problem as a DAG.\"</i>",
      "id": "06ecc7e007dec9a1167db1ff44839b14"
    },
    {
      "type": "html",
      "text": "\"Traditional\" artificial intelligence is where you want to look, specifically their \"search problems\". Massive state spaces with discrete transitions, all represented as DAGs. A lot of problems that don't look like a \"search\" actually are.",
      "id": "72e2efb581bd4182522bcf035e560f20"
    },
    {
      "type": "html",
      "text": "<i>OK, I can see you're trying to help, so let me be more specific. It was claimed above that [[Stu Feldman]]'s algorithm(s) \"solved\" every problem that can be written as a DAG. I can't see how [[Stu Feldman]]'s algorithm(s) do anything particularly special. I had discounted the traditional AI problems because [[Stu Feldman]]'s algorithm clearly does nothing there more interesting than the usual, and not very successful, AI searches, so I guess I was hoping for more. I can't find a \"problem written as a DAG\" in which the \"make\" algorithms are of any clear benefit over almost any other techniques well-known to almost any graph-theorist.</i>",
      "id": "a6ecbbe0533caa1a44775b4bf30d6a7f"
    },
    {
      "type": "html",
      "text": "\nActually, I only wrote the later stuff; I've never heard of [[Stu Feldman]]'s algorithm. I was just trying to explain the problem-as-DAG aspect. Sorry.",
      "id": "4bf25b2d2b2f2f67cf0b9721dd9d42aa"
    },
    {
      "type": "html",
      "text": "<i>No need to apologise, I'm just trying to understand what the original author was saying.</i>",
      "id": "b5409416c3fa67161da89f02b1636f58"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d04c5f62c26cf27fdb3331d8c25300c0"
    },
    {
      "type": "html",
      "text": "\nI have written a directed graph class for Java where the nodes are Enum values and the vertexes are stored in [[Enum Set]] objects. Generics makes it a whole lot clearer:",
      "id": "fa63c6ce1d00115bfc6e9d1781dc800a"
    },
    {
      "type": "html",
      "text": "\nclass [[Directed Graph]]<T extends Enum<T>> extends [[Enum Map]]<T, [[Enum Set]]<T>>",
      "id": "ddf7eee85365a8df433636de39afb10c"
    },
    {
      "type": "html",
      "text": "<i>Good for you.  Rather than waste the reader's time patting yourself on the back, would you consider either (a) sharing your code with us; or (b) delete the above and stop teasing us?</i>",
      "id": "7dbfbb82992cc7949abf196aa7d16371"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?DirectedGraph c2.com]",
      "id": "9ee1660099c4c98ac7664d7d0c83b5f6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d04c5f62c26cf27fdb3331d8c25300c0"
    },
    {
      "type": "html",
      "text": "[[Category Data Structure]]",
      "id": "37870bbdc17c9fab99e12e8e9aba89c7"
    },
    {
      "type": "pagefold",
      "id": "457e39c8dc722666",
      "text": "chat.openai"
    },
    {
      "type": "paragraph",
      "id": "ea7edc04430b626b",
      "text": "A directed graph is a data structure containing a vertex set V and an arc set A, where each arc (or edge, or link) is an ordered pair of vertices (or nodes, or sommets). The arcs may be thought of as arrows, each one starting at one vertex and pointing at precisely one other. "
    },
    {
      "type": "paragraph",
      "id": "ca79dbc1e65c8942",
      "text": "There are several variants of this data structure, such as undirected graphs, weighted directed graphs, directed acyclic graphs, and weighted directed acyclic graphs. Directed graphs are primarily used in mathematical notation and can be represented as a data structure for programming. It was claimed that [[Stu Feldman]]'s algorithm(s) \"solved\" every problem that can be written as a DAG, but it's not clear how it does anything particularly special over other techniques known to graph theorists. The author also mentions they have written a directed graph class for Java using Enum values and Enum Set objects."
    }
  ],
  "journal": [
    {
      "date": 1146567117000,
      "id": "917ffff765a3fe0cf577d48b5e9e3a74",
      "type": "create",
      "item": {
        "title": "Directed Graph",
        "story": [
          {
            "type": "html",
            "text": "A directed graph is a [[Data Structure]] containing a vertex set <i>V</i> and an <i>arc</i> set <i>A</i>, where each arc (or <i>edge</i>, or <i>link</i>) is an ordered pair of vertices (or <i>nodes</i>, or <i>sommets</i>). The arcs may be thought of as arrows, each one starting at one vertex and pointing at precisely one other.",
            "id": "8684292f0fa5408b13eef27c5f930fbc"
          },
          {
            "type": "html",
            "text": "\nThere are several variants of this data structure:",
            "id": "086a06ab1b0fc7b683dc45d8bb947510"
          },
          {
            "type": "html",
            "text": " The arrowheads may be removed, resulting in an [[Undirected Graph]].",
            "id": "89117ed5cf053e1bb885a187ed837f9a"
          },
          {
            "type": "html",
            "text": " Weights may be put on the arcs, resulting in a [[Weighted Directed Graph]].",
            "id": "a3165dc7ac538ad56f1af7a06f3a64b5"
          },
          {
            "type": "html",
            "text": " If it is not possible, starting from any given vertex and following any positive quantity of arcs to successive vertices, to return to the starting point, the graph is said to contain no <i>circuits</i> and is called a [[Directed Acyclic Graph]].",
            "id": "2a4ab1499ec9c28464dd6a2045597323"
          },
          {
            "type": "html",
            "text": " Of course, there's also [[Weighted Directed Acyclic Graph]]s.",
            "id": "e014bd809ed5b1b68cab1c6bb1f821d7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d04c5f62c26cf27fdb3331d8c25300c0"
          },
          {
            "type": "html",
            "text": "A [[Directed Graph]] is primarily a [[Mathematical Notation]] which can be <i>represented</i> as a [[Data Structure]] for programming. You might say [[Programming Is Math]], but [[Is Programming Math]]?",
            "id": "51668a6254750e0a0341be1c80529c26"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d04c5f62c26cf27fdb3331d8c25300c0"
          },
          {
            "type": "html",
            "text": "[[Stu Feldman]]'s algorithm (1979) finds a solution to every problem that can be written as a [[Directed Acyclic Graph]].  The algorithm finds and traverses a path through the graph.  The graph is called a <b>makefile</b>, and his tool is called <b>make</b> (see [[Make Program]]). -- [[Chris Garrod]]",
            "id": "d30e80ef222a0d184583aa73ed057216"
          },
          {
            "type": "html",
            "text": "<i>How does [[Stu Feldman]]'s algorithm answer this?</i>",
            "id": "5ee661aba83fc1625e41c19eabc37364"
          },
          {
            "type": "html",
            "text": "<i>Given a [[Directed Acyclic Graph]] <b>G</b>, consider the set <b>S</b> of all possible linear orderings consistent with <b>G</b>. For two vertices <b>A</b> and <b>B</b>, let <b>P(A,B)</b> be the probability that <b>A</b> comes before <b>B</b> in an element of <b>S</b> chosen uniformly at random. Prove that if <b>|S|>1</b> then there exist <b>A</b> and <b>B</b> such that <b>1/3 <= P(A,B) <= 2/3</b>.</i>",
            "id": "68a824e423625740164d9572b6cf4f3c"
          },
          {
            "type": "html",
            "text": "\nThat's not a problem writable <b>as</b> a [[Directed Acyclic Graph]], that's a problem <b>about</b> [[Directed Acyclic Graph]]s. There is a difference. You're going to have to express your problem <b>as</b> a graph, at which point the effectiveness of the algorithm should be obvious. either for or against (see parenthetical paragraph below). However, while with sufficient work such proofs can be expressed as graphs, you may not like the running time.",
            "id": "43cbb781e22b4d1017a596ebab0f6cf7"
          },
          {
            "type": "html",
            "text": "\nA graph of a proof will start with what you gave the system (the Givens in your problem). Each application of an axiom is an arc leading to a new result. It gets real big, real fast. (Colloquialism deliberate.) ",
            "id": "db28ba0894a0fabe31bd420d818a3ac5"
          },
          {
            "type": "html",
            "text": "(In fact it is infinite, technically, and despite the claim that [[Stu Feldman]]'s algorithm finds a solution to all DAG problems, I would expect that only holds for graphs where all nodes have a finite number of exiting arcs. That isn't true in the obvious formulations of the graph I described, because of the presence of numbers, where you can technically try statements about any proportion of the graph.)",
            "id": "ca02fe38c93d489c8e8ea463add671f9"
          },
          {
            "type": "html",
            "text": "<i>Well, I guess I'm having trouble finding any examples of difficult and/or interesting problems that can be \"written as a DAG\". The only examples I've come up with are simple search problems, or have been devised by taking problems and rewriting/encoding them in a non-natural way.</i>",
            "id": "9f794cb60cb8c27da62116f4ed053694"
          },
          {
            "type": "html",
            "text": "\n[[The Reform Society]] probably isn't the kind of example you were looking for, but you may find it interesting nevertheless as it's meant to be a [[Directed Acyclic Graph]].",
            "id": "2d619b2903072e130ef79d93402a6a29"
          },
          {
            "type": "html",
            "text": "<i>As a graph-theorist and compiler writer I have any number of examples of DAGs. I just don't understand what it means to \"write a problem as a DAG.\"</i>",
            "id": "06ecc7e007dec9a1167db1ff44839b14"
          },
          {
            "type": "html",
            "text": "\"Traditional\" artificial intelligence is where you want to look, specifically their \"search problems\". Massive state spaces with discrete transitions, all represented as DAGs. A lot of problems that don't look like a \"search\" actually are.",
            "id": "72e2efb581bd4182522bcf035e560f20"
          },
          {
            "type": "html",
            "text": "<i>OK, I can see you're trying to help, so let me be more specific. It was claimed above that [[Stu Feldman]]'s algorithm(s) \"solved\" every problem that can be written as a DAG. I can't see how [[Stu Feldman]]'s algorithm(s) do anything particularly special. I had discounted the traditional AI problems because [[Stu Feldman]]'s algorithm clearly does nothing there more interesting than the usual, and not very successful, AI searches, so I guess I was hoping for more. I can't find a \"problem written as a DAG\" in which the \"make\" algorithms are of any clear benefit over almost any other techniques well-known to almost any graph-theorist.</i>",
            "id": "a6ecbbe0533caa1a44775b4bf30d6a7f"
          },
          {
            "type": "html",
            "text": "\nActually, I only wrote the later stuff; I've never heard of [[Stu Feldman]]'s algorithm. I was just trying to explain the problem-as-DAG aspect. Sorry.",
            "id": "4bf25b2d2b2f2f67cf0b9721dd9d42aa"
          },
          {
            "type": "html",
            "text": "<i>No need to apologise, I'm just trying to understand what the original author was saying.</i>",
            "id": "b5409416c3fa67161da89f02b1636f58"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d04c5f62c26cf27fdb3331d8c25300c0"
          },
          {
            "type": "html",
            "text": "\nI have written a directed graph class for Java where the nodes are Enum values and the vertexes are stored in [[Enum Set]] objects. Generics makes it a whole lot clearer:",
            "id": "fa63c6ce1d00115bfc6e9d1781dc800a"
          },
          {
            "type": "html",
            "text": "\nclass [[Directed Graph]]<T extends Enum<T>> extends [[Enum Map]]<T, [[Enum Set]]<T>>",
            "id": "ddf7eee85365a8df433636de39afb10c"
          },
          {
            "type": "html",
            "text": "<i>Good for you.  Rather than waste the reader's time patting yourself on the back, would you consider either (a) sharing your code with us; or (b) delete the above and stop teasing us?</i>",
            "id": "7dbfbb82992cc7949abf196aa7d16371"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d04c5f62c26cf27fdb3331d8c25300c0"
          },
          {
            "type": "html",
            "text": "[[Category Data Structure]]",
            "id": "37870bbdc17c9fab99e12e8e9aba89c7"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?DirectedGraph c2.com]",
            "id": "9ee1660099c4c98ac7664d7d0c83b5f6"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com"
    },
    {
      "id": "9ee1660099c4c98ac7664d7d0c83b5f6",
      "type": "move",
      "order": [
        "8684292f0fa5408b13eef27c5f930fbc",
        "086a06ab1b0fc7b683dc45d8bb947510",
        "89117ed5cf053e1bb885a187ed837f9a",
        "a3165dc7ac538ad56f1af7a06f3a64b5",
        "2a4ab1499ec9c28464dd6a2045597323",
        "e014bd809ed5b1b68cab1c6bb1f821d7",
        "d04c5f62c26cf27fdb3331d8c25300c0",
        "51668a6254750e0a0341be1c80529c26",
        "d04c5f62c26cf27fdb3331d8c25300c0",
        "d30e80ef222a0d184583aa73ed057216",
        "5ee661aba83fc1625e41c19eabc37364",
        "68a824e423625740164d9572b6cf4f3c",
        "43cbb781e22b4d1017a596ebab0f6cf7",
        "db28ba0894a0fabe31bd420d818a3ac5",
        "ca02fe38c93d489c8e8ea463add671f9",
        "9f794cb60cb8c27da62116f4ed053694",
        "2d619b2903072e130ef79d93402a6a29",
        "06ecc7e007dec9a1167db1ff44839b14",
        "72e2efb581bd4182522bcf035e560f20",
        "a6ecbbe0533caa1a44775b4bf30d6a7f",
        "4bf25b2d2b2f2f67cf0b9721dd9d42aa",
        "b5409416c3fa67161da89f02b1636f58",
        "d04c5f62c26cf27fdb3331d8c25300c0",
        "fa63c6ce1d00115bfc6e9d1781dc800a",
        "ddf7eee85365a8df433636de39afb10c",
        "7dbfbb82992cc7949abf196aa7d16371",
        "9ee1660099c4c98ac7664d7d0c83b5f6",
        "d04c5f62c26cf27fdb3331d8c25300c0",
        "37870bbdc17c9fab99e12e8e9aba89c7"
      ],
      "date": 1674806102079
    },
    {
      "id": "457e39c8dc722666",
      "type": "add",
      "item": {
        "type": "pagefold",
        "id": "457e39c8dc722666",
        "text": "chat.openai"
      },
      "after": "37870bbdc17c9fab99e12e8e9aba89c7",
      "date": 1674806234407
    },
    {
      "item": {
        "type": "factory",
        "id": "ea7edc04430b626b"
      },
      "id": "ea7edc04430b626b",
      "type": "add",
      "after": "457e39c8dc722666",
      "date": 1674806235801
    },
    {
      "type": "edit",
      "id": "ea7edc04430b626b",
      "item": {
        "type": "paragraph",
        "id": "ea7edc04430b626b",
        "text": "A directed graph is a data structure containing a vertex set V and an arc set A, where each arc (or edge, or link) is an ordered pair of vertices (or nodes, or sommets). The arcs may be thought of as arrows, each one starting at one vertex and pointing at precisely one other. There are several variants of this data structure, such as undirected graphs, weighted directed graphs, directed acyclic graphs, and weighted directed acyclic graphs. Directed graphs are primarily used in mathematical notation and can be represented as a data structure for programming. It was claimed that Stu Feldman's algorithm(s) \"solved\" every problem that can be written as a DAG, but it's not clear how it does anything particularly special over other techniques known to graph theorists. The author also mentions they have written a directed graph class for Java using Enum values and Enum Set objects."
      },
      "date": 1674806237532
    },
    {
      "type": "edit",
      "id": "ea7edc04430b626b",
      "item": {
        "type": "paragraph",
        "id": "ea7edc04430b626b",
        "text": "A directed graph is a data structure containing a vertex set V and an arc set A, where each arc (or edge, or link) is an ordered pair of vertices (or nodes, or sommets). The arcs may be thought of as arrows, each one starting at one vertex and pointing at precisely one other. "
      },
      "date": 1674806278745
    },
    {
      "type": "add",
      "id": "ca79dbc1e65c8942",
      "item": {
        "type": "paragraph",
        "id": "ca79dbc1e65c8942",
        "text": "There are several variants of this data structure, such as undirected graphs, weighted directed graphs, directed acyclic graphs, and weighted directed acyclic graphs. Directed graphs are primarily used in mathematical notation and can be represented as a data structure for programming. It was claimed that Stu Feldman's algorithm(s) \"solved\" every problem that can be written as a DAG, but it's not clear how it does anything particularly special over other techniques known to graph theorists. The author also mentions they have written a directed graph class for Java using Enum values and Enum Set objects."
      },
      "after": "ea7edc04430b626b",
      "date": 1674806279334
    },
    {
      "type": "edit",
      "id": "ca79dbc1e65c8942",
      "item": {
        "type": "paragraph",
        "id": "ca79dbc1e65c8942",
        "text": "There are several variants of this data structure, such as undirected graphs, weighted directed graphs, directed acyclic graphs, and weighted directed acyclic graphs. Directed graphs are primarily used in mathematical notation and can be represented as a data structure for programming. It was claimed that [[Stu Feldman]]'s algorithm(s) \"solved\" every problem that can be written as a DAG, but it's not clear how it does anything particularly special over other techniques known to graph theorists. The author also mentions they have written a directed graph class for Java using Enum values and Enum Set objects."
      },
      "date": 1674806339208
    }
  ]
}