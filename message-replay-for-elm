{
  "title": "Message-Replay for Elm",
  "story": [
    {
      "type": "markdown",
      "id": "52c2e5dedbc19e8b",
      "text": "# Automatic Message-Replay for Elm"
    },
    {
      "type": "paragraph",
      "id": "66c7a06f57a4fec0",
      "text": "opvasger has spent a significant amount of time designing and implementing elm-devtools. [https://discourse.elm-lang.org/t/automatic-message-replay-for-elm/4213 discourse]"
    },
    {
      "type": "markdown",
      "id": "6941ee45717eb0f2",
      "text": "> The value-proposition of that project includes what I’m presenting here, but as the core ideas behind those developer-tools are very simply, I wanted to publish that core first!"
    },
    {
      "type": "paragraph",
      "id": "39dbb8947054fe31",
      "text": "Elm DevTools [https://github.com/opvasger/devtools#elm-devtools github]\n\nThe overarching goal is to close the loop between writing Elm code and interacting with it. This concretely means:"
    },
    {
      "type": "markdown",
      "id": "111934be2d35cff8",
      "text": "\n1. Code changes should be reflected immediately in a running instance of its application.\n1. Code changes should only break application-state if necessary, and if enabled, only partially.\n1. Application-states should be effortless to inspect, navigate, persist and share.\n1. Guidance from the compiler should be right in front of you when you make mistakes.\n1. The boilerplate necessary to enable the first four goals should be minimal, and if needed be, incremental."
    },
    {
      "type": "markdown",
      "id": "c8339e79a356c9a0",
      "text": "> I strongly believe that the optimal design and implementation of these goals will transform how we build our applications. Going through the loop of compiling code, reloading browser windows and getting the application into the right state costs seconds, but those seconds are spent at such a frequency that writing interactive applications is incredibly time-consuming. I hope it doesn't have to be."
    },
    {
      "type": "markdown",
      "id": "55256e64352900ac",
      "text": "# Design\n\nThese devtools are based on the Elm architecture. Since programs are constructed using a few simple functions, they can be embedded and controlled, which also sets some limits for what these devtools can do.\n"
    },
    {
      "type": "markdown",
      "id": "0e3752529fae6abf",
      "text": "## Automatic Message Replay\nAny previous state of an application can be recomputed using the initial state and a list of messages folded by an update-function. These state-transitions happen independently of their environment – no commands are sent during replay, only the state changes. This is very useful to:\n\n* Stop time to look at what happened.\n* Go to a previous point in time to try something else.\n* Reload without losing the state of your application.\n* Reload with code changes but only partial (or no) loss of application state.\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Message-Replay for Elm",
        "story": []
      },
      "date": 1638219369110
    },
    {
      "item": {
        "type": "factory",
        "id": "52c2e5dedbc19e8b"
      },
      "id": "52c2e5dedbc19e8b",
      "type": "add",
      "date": 1638219370497
    },
    {
      "type": "edit",
      "id": "52c2e5dedbc19e8b",
      "item": {
        "type": "paragraph",
        "id": "52c2e5dedbc19e8b",
        "text": "# Automatic Message-Replay for Elm"
      },
      "date": 1638219377032
    },
    {
      "type": "edit",
      "id": "52c2e5dedbc19e8b",
      "item": {
        "type": "markdown",
        "id": "52c2e5dedbc19e8b",
        "text": "# Automatic Message-Replay for Elm"
      },
      "date": 1638219378226
    },
    {
      "item": {
        "type": "factory",
        "id": "a78f00ddaf72021f"
      },
      "id": "a78f00ddaf72021f",
      "type": "add",
      "after": "52c2e5dedbc19e8b",
      "date": 1638219386599
    },
    {
      "type": "edit",
      "id": "a78f00ddaf72021f",
      "item": {
        "type": "paragraph",
        "id": "a78f00ddaf72021f",
        "text": "[https://discourse.elm-lang.org/t/automatic-message-replay-for-elm/4213 discourse]"
      },
      "date": 1638219396325
    },
    {
      "item": {
        "type": "factory",
        "id": "66c7a06f57a4fec0"
      },
      "id": "66c7a06f57a4fec0",
      "type": "add",
      "after": "a78f00ddaf72021f",
      "date": 1638219410620
    },
    {
      "type": "edit",
      "id": "66c7a06f57a4fec0",
      "item": {
        "type": "paragraph",
        "id": "66c7a06f57a4fec0",
        "text": "opvasger"
      },
      "date": 1638219413928
    },
    {
      "type": "edit",
      "id": "66c7a06f57a4fec0",
      "item": {
        "type": "paragraph",
        "id": "66c7a06f57a4fec0",
        "text": "opvasger has spent a significant amount of time designing and implementing elm-devtools 50, which is very close to release. The value-proposition of that project includes what I’m presenting here, but as the core ideas behind those developer-tools are very simply, I wanted to publish that core first!"
      },
      "date": 1638219433641
    },
    {
      "type": "remove",
      "id": "a78f00ddaf72021f",
      "date": 1638219436853
    },
    {
      "type": "edit",
      "id": "66c7a06f57a4fec0",
      "item": {
        "type": "paragraph",
        "id": "66c7a06f57a4fec0",
        "text": "opvasger has spent a significant amount of time designing and implementing elm-devtools.[https://discourse.elm-lang.org/t/automatic-message-replay-for-elm/4213 discourse]"
      },
      "date": 1638219458742
    },
    {
      "type": "add",
      "id": "6941ee45717eb0f2",
      "item": {
        "type": "paragraph",
        "id": "6941ee45717eb0f2",
        "text": "> The value-proposition of that project includes what I’m presenting here, but as the core ideas behind those developer-tools are very simply, I wanted to publish that core first!"
      },
      "after": "66c7a06f57a4fec0",
      "date": 1638219460263
    },
    {
      "type": "edit",
      "id": "6941ee45717eb0f2",
      "item": {
        "type": "markdown",
        "id": "6941ee45717eb0f2",
        "text": "> The value-proposition of that project includes what I’m presenting here, but as the core ideas behind those developer-tools are very simply, I wanted to publish that core first!"
      },
      "date": 1638219462221
    },
    {
      "type": "edit",
      "id": "66c7a06f57a4fec0",
      "item": {
        "type": "paragraph",
        "id": "66c7a06f57a4fec0",
        "text": "opvasger has spent a significant amount of time designing and implementing elm-devtools. [https://discourse.elm-lang.org/t/automatic-message-replay-for-elm/4213 discourse]"
      },
      "date": 1638219468552
    },
    {
      "item": {
        "type": "factory",
        "id": "39dbb8947054fe31"
      },
      "id": "39dbb8947054fe31",
      "type": "add",
      "after": "6941ee45717eb0f2",
      "date": 1638219544156
    },
    {
      "type": "edit",
      "id": "39dbb8947054fe31",
      "item": {
        "type": "paragraph",
        "id": "39dbb8947054fe31",
        "text": "Elm DevTools "
      },
      "date": 1638219548664
    },
    {
      "type": "edit",
      "id": "39dbb8947054fe31",
      "item": {
        "type": "paragraph",
        "id": "39dbb8947054fe31",
        "text": "Elm DevTools [https://github.com/opvasger/devtools#elm-devtools github]"
      },
      "date": 1638219561366
    },
    {
      "item": {
        "type": "factory",
        "id": "a8de47ad540a2396"
      },
      "id": "a8de47ad540a2396",
      "type": "add",
      "after": "39dbb8947054fe31",
      "date": 1638219587752
    },
    {
      "type": "edit",
      "id": "a8de47ad540a2396",
      "item": {
        "type": "paragraph",
        "id": "a8de47ad540a2396",
        "text": "\nElm DevTools\n\nTools for developing Elm programs!\n\nDemo Gif\n\nCI Build Badge NPM Version Badge Elm-package Version Badge\nGoals\n\nThe overarching goal is to close the loop between writing Elm code and interacting with it. This concretely means:\n\n    Code changes should be reflected immediately in a running instance of its application.\n    Code changes should only break application-state if necessary, and if enabled, only partially.\n    Application-states should be effortless to inspect, navigate, persist and share.\n    Guidance from the compiler should be right in front of you when you make mistakes.\n    The boilerplate necessary to enable the first four goals should be minimal, and if needed be, incremental.\n\nI strongly believe that the optimal design and implementation of these goals will transform how we build our applications. Going through the loop of compiling code, reloading browser windows and getting the application into the right state costs seconds, but those seconds are spent at such a frequency that writing interactive applications is incredibly time-consuming. I hope it doesn't have to be.\nDesign\n\nThese devtools are based on the Elm architecture. Since programs are constructed using a few simple functions, they can be embedded and controlled, which also sets some limits for what these devtools can do.\nAutomatic Message Replay"
      },
      "date": 1638219592274
    },
    {
      "type": "remove",
      "id": "a8de47ad540a2396",
      "date": 1638219615258
    },
    {
      "type": "edit",
      "id": "39dbb8947054fe31",
      "item": {
        "type": "paragraph",
        "id": "39dbb8947054fe31",
        "text": "Elm DevTools [https://github.com/opvasger/devtools#elm-devtools github]\n\nThe overarching goal is to close the loop between writing Elm code and interacting with it. This concretely means:\n\n    Code changes should be reflected immediately in a running instance of its application.\n    Code changes should only break application-state if necessary, and if enabled, only partially.\n    Application-states should be effortless to inspect, navigate, persist and share.\n    Guidance from the compiler should be right in front of you when you make mistakes.\n    The boilerplate necessary to enable the first four goals should be minimal, and if needed be, incremental.\n\nI strongly believe that the optimal design and implementation of these goals will transform how we build our applications. Going through the loop of compiling code, reloading browser windows and getting the application into the right state costs seconds, but those seconds are spent at such a frequency that writing interactive applications is incredibly time-consuming. I hope it doesn't have to be.\nDesign\n\nThese devtools are based on the Elm architecture. Since programs are constructed using a few simple functions, they can be embedded and controlled, which also sets some limits for what these devtools can do.\nAutomatic Message Replay"
      },
      "date": 1638219615806
    },
    {
      "type": "edit",
      "id": "39dbb8947054fe31",
      "item": {
        "type": "paragraph",
        "id": "39dbb8947054fe31",
        "text": "Elm DevTools [https://github.com/opvasger/devtools#elm-devtools github]\n\nThe overarching goal is to close the loop between writing Elm code and interacting with it. This concretely means:\n\n1. Code changes should be reflected immediately in a running instance of its application.\n1. Code changes should only break application-state if necessary, and if enabled, only partially.\n1. Application-states should be effortless to inspect, navigate, persist and share.\n1. Guidance from the compiler should be right in front of you when you make mistakes.\n1. The boilerplate necessary to enable the first four goals should be minimal, and if needed be, incremental.\n\nI strongly believe that the optimal design and implementation of these goals will transform how we build our applications. Going through the loop of compiling code, reloading browser windows and getting the application into the right state costs seconds, but those seconds are spent at such a frequency that writing interactive applications is incredibly time-consuming. I hope it doesn't have to be.\nDesign\n\nThese devtools are based on the Elm architecture. Since programs are constructed using a few simple functions, they can be embedded and controlled, which also sets some limits for what these devtools can do.\nAutomatic Message Replay"
      },
      "date": 1638219669227
    },
    {
      "type": "edit",
      "id": "39dbb8947054fe31",
      "item": {
        "type": "paragraph",
        "id": "39dbb8947054fe31",
        "text": "Elm DevTools [https://github.com/opvasger/devtools#elm-devtools github]\n\nThe overarching goal is to close the loop between writing Elm code and interacting with it. This concretely means:"
      },
      "date": 1638219680438
    },
    {
      "type": "add",
      "id": "111934be2d35cff8",
      "item": {
        "type": "paragraph",
        "id": "111934be2d35cff8",
        "text": "\n1. Code changes should be reflected immediately in a running instance of its application.\n1. Code changes should only break application-state if necessary, and if enabled, only partially.\n1. Application-states should be effortless to inspect, navigate, persist and share.\n1. Guidance from the compiler should be right in front of you when you make mistakes.\n1. The boilerplate necessary to enable the first four goals should be minimal, and if needed be, incremental."
      },
      "after": "39dbb8947054fe31",
      "date": 1638219684184
    },
    {
      "type": "add",
      "id": "c8339e79a356c9a0",
      "item": {
        "type": "paragraph",
        "id": "c8339e79a356c9a0",
        "text": "\nI strongly believe that the optimal design and implementation of these goals will transform how we build our applications. Going through the loop of compiling code, reloading browser windows and getting the application into the right state costs seconds, but those seconds are spent at such a frequency that writing interactive applications is incredibly time-consuming. I hope it doesn't have to be.\nDesign\n\nThese devtools are based on the Elm architecture. Since programs are constructed using a few simple functions, they can be embedded and controlled, which also sets some limits for what these devtools can do.\nAutomatic Message Replay"
      },
      "after": "111934be2d35cff8",
      "date": 1638219684501
    },
    {
      "type": "edit",
      "id": "111934be2d35cff8",
      "item": {
        "type": "markdown",
        "id": "111934be2d35cff8",
        "text": "\n1. Code changes should be reflected immediately in a running instance of its application.\n1. Code changes should only break application-state if necessary, and if enabled, only partially.\n1. Application-states should be effortless to inspect, navigate, persist and share.\n1. Guidance from the compiler should be right in front of you when you make mistakes.\n1. The boilerplate necessary to enable the first four goals should be minimal, and if needed be, incremental."
      },
      "date": 1638219691340
    },
    {
      "type": "edit",
      "id": "c8339e79a356c9a0",
      "item": {
        "type": "paragraph",
        "id": "c8339e79a356c9a0",
        "text": "I strongly believe that the optimal design and implementation of these goals will transform how we build our applications. Going through the loop of compiling code, reloading browser windows and getting the application into the right state costs seconds, but those seconds are spent at such a frequency that writing interactive applications is incredibly time-consuming. I hope it doesn't have to be.\nDesign\n\nThese devtools are based on the Elm architecture. Since programs are constructed using a few simple functions, they can be embedded and controlled, which also sets some limits for what these devtools can do.\n"
      },
      "date": 1638219739886
    },
    {
      "type": "add",
      "id": "0e3752529fae6abf",
      "item": {
        "type": "paragraph",
        "id": "0e3752529fae6abf",
        "text": "## Automatic Message Replay"
      },
      "after": "c8339e79a356c9a0",
      "date": 1638219745768
    },
    {
      "type": "edit",
      "id": "0e3752529fae6abf",
      "item": {
        "type": "markdown",
        "id": "0e3752529fae6abf",
        "text": "## Automatic Message Replay"
      },
      "date": 1638219746967
    },
    {
      "type": "edit",
      "id": "c8339e79a356c9a0",
      "item": {
        "type": "paragraph",
        "id": "c8339e79a356c9a0",
        "text": "I strongly believe that the optimal design and implementation of these goals will transform how we build our applications. Going through the loop of compiling code, reloading browser windows and getting the application into the right state costs seconds, but those seconds are spent at such a frequency that writing interactive applications is incredibly time-consuming. I hope it doesn't have to be."
      },
      "date": 1638219777203
    },
    {
      "type": "add",
      "id": "55256e64352900ac",
      "item": {
        "type": "paragraph",
        "id": "55256e64352900ac",
        "text": "## Design\n\nThese devtools are based on the Elm architecture. Since programs are constructed using a few simple functions, they can be embedded and controlled, which also sets some limits for what these devtools can do.\n"
      },
      "after": "c8339e79a356c9a0",
      "date": 1638219781611
    },
    {
      "type": "edit",
      "id": "c8339e79a356c9a0",
      "item": {
        "type": "paragraph",
        "id": "c8339e79a356c9a0",
        "text": "> I strongly believe that the optimal design and implementation of these goals will transform how we build our applications. Going through the loop of compiling code, reloading browser windows and getting the application into the right state costs seconds, but those seconds are spent at such a frequency that writing interactive applications is incredibly time-consuming. I hope it doesn't have to be."
      },
      "date": 1638219784286
    },
    {
      "type": "edit",
      "id": "c8339e79a356c9a0",
      "item": {
        "type": "markdown",
        "id": "c8339e79a356c9a0",
        "text": "> I strongly believe that the optimal design and implementation of these goals will transform how we build our applications. Going through the loop of compiling code, reloading browser windows and getting the application into the right state costs seconds, but those seconds are spent at such a frequency that writing interactive applications is incredibly time-consuming. I hope it doesn't have to be."
      },
      "date": 1638219785608
    },
    {
      "type": "edit",
      "id": "55256e64352900ac",
      "item": {
        "type": "markdown",
        "id": "55256e64352900ac",
        "text": "## Design\n\nThese devtools are based on the Elm architecture. Since programs are constructed using a few simple functions, they can be embedded and controlled, which also sets some limits for what these devtools can do.\n"
      },
      "date": 1638219787816
    },
    {
      "type": "edit",
      "id": "55256e64352900ac",
      "item": {
        "type": "markdown",
        "id": "55256e64352900ac",
        "text": "# Design\n\nThese devtools are based on the Elm architecture. Since programs are constructed using a few simple functions, they can be embedded and controlled, which also sets some limits for what these devtools can do.\n"
      },
      "date": 1638219818155
    },
    {
      "type": "edit",
      "id": "0e3752529fae6abf",
      "item": {
        "type": "markdown",
        "id": "0e3752529fae6abf",
        "text": "## Automatic Message Replay\nAny previous state of an application can be recomputed using the initial state and a list of messages folded by an update-function. These state-transitions happen independently of their environment - no commands are sent during replay, only the state changes. This is very useful to:"
      },
      "date": 1638219820724
    },
    {
      "type": "edit",
      "id": "0e3752529fae6abf",
      "item": {
        "type": "markdown",
        "id": "0e3752529fae6abf",
        "text": "## Automatic Message Replay\nAny previous state of an application can be recomputed using the initial state and a list of messages folded by an update-function. These state-transitions happen independently of their environment – no commands are sent during replay, only the state changes. This is very useful to:"
      },
      "date": 1638219846720
    },
    {
      "type": "edit",
      "id": "0e3752529fae6abf",
      "item": {
        "type": "markdown",
        "id": "0e3752529fae6abf",
        "text": "## Automatic Message Replay\nAny previous state of an application can be recomputed using the initial state and a list of messages folded by an update-function. These state-transitions happen independently of their environment – no commands are sent during replay, only the state changes. This is very useful to:\n\n* Stop time to look at what happened.\n* Go to a previous point in time to try something else.\n* Reload without losing the state of your application.\n* Reload with code changes but only partial (or no) loss of application state.\n"
      },
      "date": 1638219882714
    }
  ]
}