{
  "title": "Design Shield",
  "story": [
    {
      "type": "html",
      "text": "[[Design Shield]] is something you put in to hide what you are doing, to give you protection, something to hide behind to give you room to change your mind, perhaps.  Also discussed in [[Shield Pattern]].  Opposite of [[Design Shield]] is looking for a name, see [[Design Burp]].",
      "id": "01bee0db569f6497ca797ddaf8e09115"
    },
    {
      "type": "html",
      "text": "\nDesign shields come in different sizes, strengths, or weights.  A heavier, bigger, stronger one adds flexibility but costs your design in cognitive complexity.  [[Kent Beck]] told me they talk about a bag of design or coding ideas, and you want to take the things at the top of the bag.  If you have to reach wayyy down into the bag and mess with 'become:', then you are at some level of desperation.  [[Paul Dyson]] comments in [[Make It Fast Breaks Make It Right]] on people overusing patterns and getting very flexible code, but at high complexity.  I could wish Kent or Ron would write a starter list of what's at the top of the bag, and what is below, and so on down to the bottom.",
      "id": "7ffb8581fda287d56b83f718520030b4"
    },
    {
      "type": "html",
      "text": "--[[Alistair Cockburn]]",
      "id": "88bfda3016fff6bae6014ce7f678d2fb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0fca17345500c35cfbbfb74614899788"
    },
    {
      "type": "html",
      "text": "\nWe need a name for a shield that is not provided by the programmer's design, but by the language - [[Language Shield]]!? One could then describe the history of programming language as one of Design Shields becoming Language Shields. Gee, am I looking forward to those fully pattern oriented languages! :-) --[[Falk Bruegmann]]",
      "id": "c047e47902c569b5e2391cb39bf5d5e8"
    },
    {
      "type": "html",
      "text": "<i>You are asking the the language designer to put some special design shields in for you?  What, in particular?  --[[Alistair Cockburn]]</i>",
      "id": "35ecae1912b52ee9ed2c33fdf13c4aa5"
    },
    {
      "type": "html",
      "text": "\nIn fact, I was not thinking about any particular shields. I guess I was not very clear on just <i>what</i> I was thinking...",
      "id": "2d2ba0283632d895ed9d18f8e99c56ea"
    },
    {
      "type": "html",
      "text": "\nYou can be shielded against certain types of change by certain features of a programming language. You might call such a feature a [[Language Shield]]. If these are not provided, and you still need to keep the cost of change down, you have to provide equivalent Design Shields instead.",
      "id": "dc8663e9eb86e7625049d00bf90f2ee6"
    },
    {
      "type": "html",
      "text": "\nMachine language does not provide many Language Shields (although it provides some, when compared to setting switches on ENIAC :-). Assembly language, procedural languages, object-oriented languages... Each one puts some shield features into the language that had to be provided by design before.",
      "id": "4a164ee915d1c6cccce4603145933021"
    },
    {
      "type": "html",
      "text": "\nMaybe patterns are \"just\" the kind of Design Shield that is evolving today. They have already influenced the design of some languages (e.g. Java). So if you extrapolate the trend, it leads to the prediction that some patterns that are Design Shields will migrate into programming language to become Language Shields in the future (will Java be called \"hybrid-pattern oriented\" some day?!). This was what I was driving at. Of course, it's just a guess.",
      "id": "1e9706e7fd694044f7566d15ad78c62b"
    },
    {
      "type": "html",
      "text": "\nHope this is not too crazy. Doesn't matter... it's fun :-)",
      "id": "725d38b77db317d7961b141b3fc6bd4a"
    },
    {
      "type": "html",
      "text": "\nBTW, maybe [[Shield Pattern]] seems so hard to \"nail down\" at first just because a lot of shields already reside in the language, not in the design as with most patterns. --[[Falk Bruegmann]]",
      "id": "cc2cc7673dfd5de9fa271553079b9a3a"
    },
    {
      "type": "html",
      "text": "<i>One classic example of a [[Design Pattern]] being subsumed into a language feature is the Iterator pattern which is very useful in C++ and Java but just not required in the, dare I say, more advanced Smalltalk. It is interesting that the feature of Smalltalk that makes Iterators redundant, Blocks, is nothing to do with iteration per se. Its not even anything to do with collections. Having said all of this, I'm not sure if Iterator is a [[Design Shield]], or Block a [[Language Shield]] :-) -- [[Stephen Hutchinson]]</i>",
      "id": "70aeb434c6ce4865b39ad357cc483e8b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0fca17345500c35cfbbfb74614899788"
    },
    {
      "type": "html",
      "text": "\nWiki places mentioning a design shield or [[Design Burp]].",
      "id": "9394f1b20c055d244aea865902886a31"
    },
    {
      "type": "html",
      "text": "<b>[[Design Shield]]</b>",
      "id": "ccebe84b72f44c5a7fe5a3642da8def3"
    },
    {
      "type": "html",
      "text": " [[Shield Pattern]]",
      "id": "6c2b7708b64ef5d5f325eefbf55b10d8"
    },
    {
      "type": "html",
      "text": " The several pages discussing Java interface-implementation question",
      "id": "20b5fa768d7995843cbf612eb4db033e"
    },
    {
      "type": "html",
      "text": " [[Interfaces Should Be Adjectives]]",
      "id": "61111024cc5d92adbd20f39ad914be86"
    },
    {
      "type": "html",
      "text": " [[Extend To Implement Interfaces]]",
      "id": "0f943a58216aa2830526186c3703e787"
    },
    {
      "type": "html",
      "text": " [[Dont Distinguish Between Classes And Interfaces]]",
      "id": "dc60ce1965c506443e83d034ca961434"
    },
    {
      "type": "html",
      "text": " Many of the [[Design Patterns]], especially Bridge and Facade, of course.",
      "id": "94cd0c1fa332f003ab4939d4b7932051"
    },
    {
      "type": "html",
      "text": " [[Template Method]]/[[Hook Method]] are the quintessential OO design shield form ",
      "id": "4942cb0e1d0c7487bc0fb1e6f9969e9f"
    },
    {
      "type": "html",
      "text": " The observer family of patterns including the bigger ones like Reactor and [[Multi Caster]]",
      "id": "6cff62b16305c58735c447f58dc03945"
    },
    {
      "type": "html",
      "text": "<b>[[Design Burp]]</b>",
      "id": "dcc09c920cd2445e7c7b7564a3c2a82f"
    },
    {
      "type": "html",
      "text": " [[Hungarian Notation]]",
      "id": "ce1089055da066082ffdc96d0fbf4efc"
    },
    {
      "type": "html",
      "text": " [[Interfaces Should Be Adjectives]] also has the counter argument",
      "id": "4787692adfa5366275549b7e5701338b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0fca17345500c35cfbbfb74614899788"
    },
    {
      "type": "html",
      "text": "I question whether [[Hungarian Notation]] and [[Interfaces Should Be Adjectives]] are [[Design Burp]](s).  It seems to depend on how they are used and what your perspective is.",
      "id": "1b23a838443925f0d98ca58864f5d108"
    },
    {
      "type": "html",
      "text": "\n[[Hungarian Notation]] has been called a burp because it tells you about the internals of a variable.  Is that true?  Actually, it tells you about the type of a variable, that is, it is a statement of its external behavior.  It could be considered a burp if the type tells you more than you need to know in a particular context.  The fact that classes and types are pretty much synonymous in many languages further clouds this.",
      "id": "067ec4ac057a8a5c866abd9b7669ad2b"
    },
    {
      "type": "html",
      "text": "\n[[Interfaces Should Be Adjectives]] seems more clear cut to me.  Within the context of [[Extreme Programming]] (which is one strong basis for [[Dont Distinguish Between Classes And Interfaces]]) adjectival names are burps.  This is pretty much because you chose to make a noun-based concrete class name in the beginning.  If, on the other hand, you chose to start with some statements of partial behavior (Cloneable, Serializable, [[Elliptically Formed]], Renderable, Connectable, Graphical) and use factories to create the instances, the shield is intact.  This is definitely not your everyday programming, and I am still suspicious of it, but to me it does make the burp categorization contextual.",
      "id": "4bc5e923906bc288e55d31e165302d6f"
    },
    {
      "type": "html",
      "text": "-- [[Michael Feathers]]",
      "id": "f37dca7ba67938a0e1ecadf86a18c8aa"
    },
    {
      "type": "html",
      "text": "<i>Are you inferring that a [[Design Burp]] is a bad thing? I think the name gives that impression, but the page itself implies it is neutral. It says a burp is something that gives out information, and then adds \"hopefully something you want them to know\". So whether [[Hungarian Notation]] is a burp is independent of whether the type tells you too much.</i>",
      "id": "b0be4c493acabe3384d577346198f526"
    },
    {
      "type": "html",
      "text": "<i>The same probably applies to [[Design Shield]]. Sometimes the author of a class hides <b>too much</b> of the implementation, so that there isn't enough information to use or reuse it. Then a shield becomes a bad thing. (I'm think here of 3rd party software, not the XP context.) Lack of documentation is a [[Design Shield]] in that it hides the intent of the author - often bad. Other shields are good.</i>  -- [[Dave Harris]]",
      "id": "0d3b93a50b0cc27f99b6e7ae943c2aa4"
    },
    {
      "type": "html",
      "text": "\nI agree the name has a bad connotation.  But with a burp you get some idea of the person's innards, so there is a kind of graphic exposure there.  [[Hungarian Notation]] explicitly chooses to expose the innards of a design element, and so is the exact opposite of a [[Design Shield]], which conceals the innards, or, alternatively, provides a place behind which the designer can hide and reshuffle.  I guess I do think revealing the innards are generally a bad idea, hence the name.  I recall when C started doing type checking, and I had to declare that the parameter was a pointer to a pointer to a structure.  I never managed to get comfortable with that much exposure of other parts of the system.  Alternate name suggestions are of course welcome, since naming is not my forte.  --[[Alistair Cockburn]]",
      "id": "32e243cb52108e0ce52c99f58b4733bd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0fca17345500c35cfbbfb74614899788"
    },
    {
      "type": "html",
      "text": "I think I did react a bit emotionally to use of 'burp' (I apologize) but that aside, I do really wonder about this internals vs. externals thing.  If we use m_ppnCounter (pointer to a pointer to an int) then where are the insides?  What is the inside of an int?  If we have m_ppmcThing where mc is my class, it is a shield (except in the case of [[Black Box Componentry]]) because the innards of my class can change radically over time.  The behavior is exposed, it is just a matter of whether it is documented in the code.  ",
      "id": "66dc6ff9f7637f6b6f9b38625969da19"
    },
    {
      "type": "html",
      "text": "\nTo me, it seems that there are a variety of levels at which the principle of shielding can operate.  At some levels the hiding and reshuffling has to do with source code dependency: what else do I have to change when I change this?  [[Hungarian Notation]] is an example of one of these.  At the design level it seems that classes themselves are shields, since we expect them to change type over time.  ",
      "id": "f3298e7fc243232966869cc2e57ae8e4"
    },
    {
      "type": "html",
      "text": "\nI suspect that [[Interfaces Should Be Adjectives]] is a shield as well because it allows you to pass in reference to only the part of an object that makes sense in a context.  In Java, it specifically allows you to be independent of the hierarchy concerns that are imposed by the single inheritance model. -- [[Michael Feathers]]",
      "id": "d7fa197d63a76f4cc39b8f416df44579"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0fca17345500c35cfbbfb74614899788"
    },
    {
      "type": "html",
      "text": "...(recovering from lost append) pointer to a pointer to an int is terribly fragile.  suppose I add or subtract one pointer to that (pn or pppn).  All sorts of things are hanging on this, and I have to go and find them all and change them all.  The point of a class is that it hides / shields/ protects the client.  If the ppnCounter were instead a pointer to a Fuzzball object, then it's the Fuzzball's personal business whether there is another pointer involved or not. Should Fuzzball get changed to add or remove a level of pointerness, the client's don't all have to be edited to add or remove a 'p' to a variable name that shouldn't be worrying about it in the first place.  The Fuzzball class definition acts as a [[Design Shield]], protecting the client's programmer from the Fuzzball's programmer, and giving the Fuzzball's programmer some implementation latitude.   The ppnCounter, on the other hand, forces the client's programmer to know what the Fuzzball's programmer has eaten for lunch, as it were, to get back to burps, and gets the two really closely bound.  not much space for movement.  ppn reveals the insides because it is saying, there is a thing1 I know of, and I also know it knows of a thing2, and I know that thing1 knows that thing2 is an integer.  You have the objects there, just without clothes on.   --[[Alistair Cockburn]]",
      "id": "568047859203ddc52faf58f789991c81"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0fca17345500c35cfbbfb74614899788"
    },
    {
      "type": "html",
      "text": "[[Category Jargon]]",
      "id": "ec6b8ee96a3d1c61add2f3e47d34b004"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?DesignShield c2.com]",
      "id": "95d4ab6239e03e96487e38fca2c397e3"
    }
  ],
  "journal": [
    {
      "date": 999102547000,
      "id": "e8b3dc8b81796ca54bf4ccc9b7f3d2b4",
      "type": "create",
      "item": {
        "title": "Design Shield",
        "story": [
          {
            "type": "html",
            "text": "[[Design Shield]] is something you put in to hide what you are doing, to give you protection, something to hide behind to give you room to change your mind, perhaps.  Also discussed in [[Shield Pattern]].  Opposite of [[Design Shield]] is looking for a name, see [[Design Burp]].",
            "id": "01bee0db569f6497ca797ddaf8e09115"
          },
          {
            "type": "html",
            "text": "\nDesign shields come in different sizes, strengths, or weights.  A heavier, bigger, stronger one adds flexibility but costs your design in cognitive complexity.  [[Kent Beck]] told me they talk about a bag of design or coding ideas, and you want to take the things at the top of the bag.  If you have to reach wayyy down into the bag and mess with 'become:', then you are at some level of desperation.  [[Paul Dyson]] comments in [[Make It Fast Breaks Make It Right]] on people overusing patterns and getting very flexible code, but at high complexity.  I could wish Kent or Ron would write a starter list of what's at the top of the bag, and what is below, and so on down to the bottom.",
            "id": "7ffb8581fda287d56b83f718520030b4"
          },
          {
            "type": "html",
            "text": "--[[Alistair Cockburn]]",
            "id": "88bfda3016fff6bae6014ce7f678d2fb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0fca17345500c35cfbbfb74614899788"
          },
          {
            "type": "html",
            "text": "\nWe need a name for a shield that is not provided by the programmer's design, but by the language - [[Language Shield]]!? One could then describe the history of programming language as one of Design Shields becoming Language Shields. Gee, am I looking forward to those fully pattern oriented languages! :-) --[[Falk Bruegmann]]",
            "id": "c047e47902c569b5e2391cb39bf5d5e8"
          },
          {
            "type": "html",
            "text": "<i>You are asking the the language designer to put some special design shields in for you?  What, in particular?  --[[Alistair Cockburn]]</i>",
            "id": "35ecae1912b52ee9ed2c33fdf13c4aa5"
          },
          {
            "type": "html",
            "text": "\nIn fact, I was not thinking about any particular shields. I guess I was not very clear on just <i>what</i> I was thinking...",
            "id": "2d2ba0283632d895ed9d18f8e99c56ea"
          },
          {
            "type": "html",
            "text": "\nYou can be shielded against certain types of change by certain features of a programming language. You might call such a feature a [[Language Shield]]. If these are not provided, and you still need to keep the cost of change down, you have to provide equivalent Design Shields instead.",
            "id": "dc8663e9eb86e7625049d00bf90f2ee6"
          },
          {
            "type": "html",
            "text": "\nMachine language does not provide many Language Shields (although it provides some, when compared to setting switches on ENIAC :-). Assembly language, procedural languages, object-oriented languages... Each one puts some shield features into the language that had to be provided by design before.",
            "id": "4a164ee915d1c6cccce4603145933021"
          },
          {
            "type": "html",
            "text": "\nMaybe patterns are \"just\" the kind of Design Shield that is evolving today. They have already influenced the design of some languages (e.g. Java). So if you extrapolate the trend, it leads to the prediction that some patterns that are Design Shields will migrate into programming language to become Language Shields in the future (will Java be called \"hybrid-pattern oriented\" some day?!). This was what I was driving at. Of course, it's just a guess.",
            "id": "1e9706e7fd694044f7566d15ad78c62b"
          },
          {
            "type": "html",
            "text": "\nHope this is not too crazy. Doesn't matter... it's fun :-)",
            "id": "725d38b77db317d7961b141b3fc6bd4a"
          },
          {
            "type": "html",
            "text": "\nBTW, maybe [[Shield Pattern]] seems so hard to \"nail down\" at first just because a lot of shields already reside in the language, not in the design as with most patterns. --[[Falk Bruegmann]]",
            "id": "cc2cc7673dfd5de9fa271553079b9a3a"
          },
          {
            "type": "html",
            "text": "<i>One classic example of a [[Design Pattern]] being subsumed into a language feature is the Iterator pattern which is very useful in C++ and Java but just not required in the, dare I say, more advanced Smalltalk. It is interesting that the feature of Smalltalk that makes Iterators redundant, Blocks, is nothing to do with iteration per se. Its not even anything to do with collections. Having said all of this, I'm not sure if Iterator is a [[Design Shield]], or Block a [[Language Shield]] :-) -- [[Stephen Hutchinson]]</i>",
            "id": "70aeb434c6ce4865b39ad357cc483e8b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0fca17345500c35cfbbfb74614899788"
          },
          {
            "type": "html",
            "text": "\nWiki places mentioning a design shield or [[Design Burp]].",
            "id": "9394f1b20c055d244aea865902886a31"
          },
          {
            "type": "html",
            "text": "<b>[[Design Shield]]</b>",
            "id": "ccebe84b72f44c5a7fe5a3642da8def3"
          },
          {
            "type": "html",
            "text": " [[Shield Pattern]]",
            "id": "6c2b7708b64ef5d5f325eefbf55b10d8"
          },
          {
            "type": "html",
            "text": " The several pages discussing Java interface-implementation question",
            "id": "20b5fa768d7995843cbf612eb4db033e"
          },
          {
            "type": "html",
            "text": " [[Interfaces Should Be Adjectives]]",
            "id": "61111024cc5d92adbd20f39ad914be86"
          },
          {
            "type": "html",
            "text": " [[Extend To Implement Interfaces]]",
            "id": "0f943a58216aa2830526186c3703e787"
          },
          {
            "type": "html",
            "text": " [[Dont Distinguish Between Classes And Interfaces]]",
            "id": "dc60ce1965c506443e83d034ca961434"
          },
          {
            "type": "html",
            "text": " Many of the [[Design Patterns]], especially Bridge and Facade, of course.",
            "id": "94cd0c1fa332f003ab4939d4b7932051"
          },
          {
            "type": "html",
            "text": " [[Template Method]]/[[Hook Method]] are the quintessential OO design shield form ",
            "id": "4942cb0e1d0c7487bc0fb1e6f9969e9f"
          },
          {
            "type": "html",
            "text": " The observer family of patterns including the bigger ones like Reactor and [[Multi Caster]]",
            "id": "6cff62b16305c58735c447f58dc03945"
          },
          {
            "type": "html",
            "text": "<b>[[Design Burp]]</b>",
            "id": "dcc09c920cd2445e7c7b7564a3c2a82f"
          },
          {
            "type": "html",
            "text": " [[Hungarian Notation]]",
            "id": "ce1089055da066082ffdc96d0fbf4efc"
          },
          {
            "type": "html",
            "text": " [[Interfaces Should Be Adjectives]] also has the counter argument",
            "id": "4787692adfa5366275549b7e5701338b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0fca17345500c35cfbbfb74614899788"
          },
          {
            "type": "html",
            "text": "I question whether [[Hungarian Notation]] and [[Interfaces Should Be Adjectives]] are [[Design Burp]](s).  It seems to depend on how they are used and what your perspective is.",
            "id": "1b23a838443925f0d98ca58864f5d108"
          },
          {
            "type": "html",
            "text": "\n[[Hungarian Notation]] has been called a burp because it tells you about the internals of a variable.  Is that true?  Actually, it tells you about the type of a variable, that is, it is a statement of its external behavior.  It could be considered a burp if the type tells you more than you need to know in a particular context.  The fact that classes and types are pretty much synonymous in many languages further clouds this.",
            "id": "067ec4ac057a8a5c866abd9b7669ad2b"
          },
          {
            "type": "html",
            "text": "\n[[Interfaces Should Be Adjectives]] seems more clear cut to me.  Within the context of [[Extreme Programming]] (which is one strong basis for [[Dont Distinguish Between Classes And Interfaces]]) adjectival names are burps.  This is pretty much because you chose to make a noun-based concrete class name in the beginning.  If, on the other hand, you chose to start with some statements of partial behavior (Cloneable, Serializable, [[Elliptically Formed]], Renderable, Connectable, Graphical) and use factories to create the instances, the shield is intact.  This is definitely not your everyday programming, and I am still suspicious of it, but to me it does make the burp categorization contextual.",
            "id": "4bc5e923906bc288e55d31e165302d6f"
          },
          {
            "type": "html",
            "text": "-- [[Michael Feathers]]",
            "id": "f37dca7ba67938a0e1ecadf86a18c8aa"
          },
          {
            "type": "html",
            "text": "<i>Are you inferring that a [[Design Burp]] is a bad thing? I think the name gives that impression, but the page itself implies it is neutral. It says a burp is something that gives out information, and then adds \"hopefully something you want them to know\". So whether [[Hungarian Notation]] is a burp is independent of whether the type tells you too much.</i>",
            "id": "b0be4c493acabe3384d577346198f526"
          },
          {
            "type": "html",
            "text": "<i>The same probably applies to [[Design Shield]]. Sometimes the author of a class hides <b>too much</b> of the implementation, so that there isn't enough information to use or reuse it. Then a shield becomes a bad thing. (I'm think here of 3rd party software, not the XP context.) Lack of documentation is a [[Design Shield]] in that it hides the intent of the author - often bad. Other shields are good.</i>  -- [[Dave Harris]]",
            "id": "0d3b93a50b0cc27f99b6e7ae943c2aa4"
          },
          {
            "type": "html",
            "text": "\nI agree the name has a bad connotation.  But with a burp you get some idea of the person's innards, so there is a kind of graphic exposure there.  [[Hungarian Notation]] explicitly chooses to expose the innards of a design element, and so is the exact opposite of a [[Design Shield]], which conceals the innards, or, alternatively, provides a place behind which the designer can hide and reshuffle.  I guess I do think revealing the innards are generally a bad idea, hence the name.  I recall when C started doing type checking, and I had to declare that the parameter was a pointer to a pointer to a structure.  I never managed to get comfortable with that much exposure of other parts of the system.  Alternate name suggestions are of course welcome, since naming is not my forte.  --[[Alistair Cockburn]]",
            "id": "32e243cb52108e0ce52c99f58b4733bd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0fca17345500c35cfbbfb74614899788"
          },
          {
            "type": "html",
            "text": "I think I did react a bit emotionally to use of 'burp' (I apologize) but that aside, I do really wonder about this internals vs. externals thing.  If we use m_ppnCounter (pointer to a pointer to an int) then where are the insides?  What is the inside of an int?  If we have m_ppmcThing where mc is my class, it is a shield (except in the case of [[Black Box Componentry]]) because the innards of my class can change radically over time.  The behavior is exposed, it is just a matter of whether it is documented in the code.  ",
            "id": "66dc6ff9f7637f6b6f9b38625969da19"
          },
          {
            "type": "html",
            "text": "\nTo me, it seems that there are a variety of levels at which the principle of shielding can operate.  At some levels the hiding and reshuffling has to do with source code dependency: what else do I have to change when I change this?  [[Hungarian Notation]] is an example of one of these.  At the design level it seems that classes themselves are shields, since we expect them to change type over time.  ",
            "id": "f3298e7fc243232966869cc2e57ae8e4"
          },
          {
            "type": "html",
            "text": "\nI suspect that [[Interfaces Should Be Adjectives]] is a shield as well because it allows you to pass in reference to only the part of an object that makes sense in a context.  In Java, it specifically allows you to be independent of the hierarchy concerns that are imposed by the single inheritance model. -- [[Michael Feathers]]",
            "id": "d7fa197d63a76f4cc39b8f416df44579"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0fca17345500c35cfbbfb74614899788"
          },
          {
            "type": "html",
            "text": "...(recovering from lost append) pointer to a pointer to an int is terribly fragile.  suppose I add or subtract one pointer to that (pn or pppn).  All sorts of things are hanging on this, and I have to go and find them all and change them all.  The point of a class is that it hides / shields/ protects the client.  If the ppnCounter were instead a pointer to a Fuzzball object, then it's the Fuzzball's personal business whether there is another pointer involved or not. Should Fuzzball get changed to add or remove a level of pointerness, the client's don't all have to be edited to add or remove a 'p' to a variable name that shouldn't be worrying about it in the first place.  The Fuzzball class definition acts as a [[Design Shield]], protecting the client's programmer from the Fuzzball's programmer, and giving the Fuzzball's programmer some implementation latitude.   The ppnCounter, on the other hand, forces the client's programmer to know what the Fuzzball's programmer has eaten for lunch, as it were, to get back to burps, and gets the two really closely bound.  not much space for movement.  ppn reveals the insides because it is saying, there is a thing1 I know of, and I also know it knows of a thing2, and I know that thing1 knows that thing2 is an integer.  You have the objects there, just without clothes on.   --[[Alistair Cockburn]]",
            "id": "568047859203ddc52faf58f789991c81"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0fca17345500c35cfbbfb74614899788"
          },
          {
            "type": "html",
            "text": "[[Category Jargon]]",
            "id": "ec6b8ee96a3d1c61add2f3e47d34b004"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?DesignShield c2.com]",
            "id": "95d4ab6239e03e96487e38fca2c397e3"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1708963527745
    }
  ]
}