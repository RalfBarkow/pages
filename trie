{
  "title": "Trie",
  "story": [
    {
      "type": "paragraph",
      "id": "22130989ce8f72e0",
      "text": "The concept of a trie was introduced by A. Thue in 1912 as a means to represent a set of strings (see Knuth, 1998). In its simplest form, a trie is a multiway branching tree where each edge is labelled with a character. For example, the set of strings fear; earl ; east; easy; eyeg is represented by the trie depicted in gure 1."
    },
    {
      "type": "pagefold",
      "id": "9565564588760ded",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "6ee0879e4f726c92",
      "text": "\nHINZE, Ralf, 2000. Generalizing generalized tries. Journal of Functional Programming. Online. July 2000. Vol. 10, no. 4, p. 327–351. [Accessed 6 September 2023]. DOI 10.1017/S0956796800003713. A trie is a search tree scheme that employs the structure of search keys to organize information. \nTries were originally devised as a means to represent a collection of records indexed by strings \nover a fixed alphabet. Based on work by C. P. Wadsworth and others, R. H. Connelly and \nF. L. Morris generalized the concept to permit indexing by elements built according to an \narbitrary signature. Here we go one step further, and define tries and operations on tries \ngenerically for arbitrary datatypes of first-order kind, including parameterized and nested \ndatatypes. The derivation employs techniques recently developed in the context of polytypic \nprogramming and can be regarded as a comprehensive case study in this new programming \nparadigm. It is well known that for the implementation of generalized tries, nested datatypes \nand polymorphic recursion are needed. Implementing tries for first-order kinded datatypes \nplaces even greater demands on the type system: it requires rank-2 type signatures and second-order nested datatypes. Despite these requirements, the definition of tries is surprisingly simple, \nwhich is mostly due to the framework of polytypic programming.\n"
    },
    {
      "type": "paragraph",
      "id": "1ff7cff797ab562e",
      "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. 3rd ed. Reading, Mass: Addison-Wesley. ISBN 978-0-201-89683-1, p. 687.\n"
    },
    {
      "type": "paragraph",
      "id": "67fa0839e622b3b3",
      "text": "[…] if we encode each qi(x) by a [[Sequence]] of 0s and 1s according as qi(x) does or doesn’t divide t(x)(pd−1)/2 − 1 for the successive t’s tried, we obtain a random binary trie with r lieves (see Section 6.3)."
    },
    {
      "type": "paragraph",
      "id": "d6c852db4ade8ba4",
      "text": "⇒ Tries ⇒ [[Sequence]] ⇒ [[Digital Searching]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Trie",
        "story": []
      },
      "date": 1694251326880
    },
    {
      "item": {
        "type": "factory",
        "id": "22130989ce8f72e0"
      },
      "id": "22130989ce8f72e0",
      "type": "add",
      "date": 1694251328298
    },
    {
      "type": "edit",
      "id": "22130989ce8f72e0",
      "item": {
        "type": "paragraph",
        "id": "22130989ce8f72e0",
        "text": "The concept of a trie was introduced by A. Thue in 1912 as a means to represent a set of strings (see Knuth, 1998). In its simplest form, a trie is a multiway branching tree where each edge is labelled with a character. For example, the set of strings fear; earl ; east; easy; eyeg is represented by the trie depicted in gure 1."
      },
      "date": 1694251330022
    },
    {
      "item": {
        "type": "factory",
        "id": "9565564588760ded"
      },
      "id": "9565564588760ded",
      "type": "add",
      "after": "22130989ce8f72e0",
      "date": 1694251339793
    },
    {
      "type": "edit",
      "id": "9565564588760ded",
      "item": {
        "type": "pagefold",
        "id": "9565564588760ded",
        "text": "~"
      },
      "date": 1694251342562
    },
    {
      "item": {
        "type": "factory",
        "id": "6ee0879e4f726c92"
      },
      "id": "6ee0879e4f726c92",
      "type": "add",
      "after": "9565564588760ded",
      "date": 1694251344296
    },
    {
      "type": "edit",
      "id": "6ee0879e4f726c92",
      "item": {
        "type": "paragraph",
        "id": "6ee0879e4f726c92",
        "text": "\nHINZE, Ralf, 2000. Generalizing generalized tries. Journal of Functional Programming. Online. July 2000. Vol. 10, no. 4, p. 327–351. [Accessed 6 September 2023]. DOI 10.1017/S0956796800003713. A trie is a search tree scheme that employs the structure of search keys to organize information. \nTries were originally devised as a means to represent a collection of records indexed by strings \nover a fixed alphabet. Based on work by C. P. Wadsworth and others, R. H. Connelly and \nF. L. Morris generalized the concept to permit indexing by elements built according to an \narbitrary signature. Here we go one step further, and define tries and operations on tries \ngenerically for arbitrary datatypes of first-order kind, including parameterized and nested \ndatatypes. The derivation employs techniques recently developed in the context of polytypic \nprogramming and can be regarded as a comprehensive case study in this new programming \nparadigm. It is well known that for the implementation of generalized tries, nested datatypes \nand polymorphic recursion are needed. Implementing tries for first-order kinded datatypes \nplaces even greater demands on the type system: it requires rank-2 type signatures and second-order nested datatypes. Despite these requirements, the definition of tries is surprisingly simple, \nwhich is mostly due to the framework of polytypic programming.\n"
      },
      "date": 1694251348056
    },
    {
      "id": "67fa0839e622b3b3",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "67fa0839e622b3b3",
        "text": "[…] if we encode each qi(x) by a [[Sequence]] of 0s and 1s according as qi(x) does or doesn’t divide t(x)(pd−1)/2 − 1 for the successive t’s tried, we obtain a random binary trie with r lieves (see Section 6.3)."
      },
      "after": "6ee0879e4f726c92",
      "attribution": {
        "page": "2023-09-09"
      },
      "date": 1694253491130
    },
    {
      "id": "1ff7cff797ab562e",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "1ff7cff797ab562e",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. 3rd ed. Reading, Mass: Addison-Wesley. ISBN 978-0-201-89683-1, p. 687.\n"
      },
      "after": "6ee0879e4f726c92",
      "attribution": {
        "page": "2023-09-09"
      },
      "date": 1694253493987
    },
    {
      "id": "d6c852db4ade8ba4",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "d6c852db4ade8ba4",
        "text": "⇒ [[Trie]]s ⇒ [[Sequence]] ⇒ [[Digital Searching]]"
      },
      "after": "67fa0839e622b3b3",
      "attribution": {
        "page": "2023-09-09"
      },
      "date": 1694253508379
    },
    {
      "type": "edit",
      "id": "d6c852db4ade8ba4",
      "item": {
        "type": "paragraph",
        "id": "d6c852db4ade8ba4",
        "text": "⇒ Tries ⇒ [[Sequence]] ⇒ [[Digital Searching]]"
      },
      "date": 1694253515454
    }
  ]
}