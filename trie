{
  "title": "Trie",
  "story": [
    {
      "type": "paragraph",
      "id": "22130989ce8f72e0",
      "text": "The concept of a trie was introduced by A. Thue in 1912 as a means to represent a set of strings (see Knuth, 1998)."
    },
    {
      "type": "paragraph",
      "id": "74898b7c03d28d8f",
      "text": "In its simplest form, a trie is a multiway branching tree where each edge is labelled with a character."
    },
    {
      "type": "image",
      "id": "d6bfc01a0e4105ff",
      "text": "Fig. 1 A simple trie. (R. Hinze)",
      "size": "thumbnail",
      "width": 183,
      "height": 211,
      "url": "/assets/plugins/image/d54ff751e39e25f8424a881a87183d13.jpg"
    },
    {
      "type": "paragraph",
      "id": "59b1c8b8a138c092",
      "text": "For example, the set of strings {ear, earl, east, easy, eye} is represented by the trie depicted in figure 1."
    },
    {
      "type": "paragraph",
      "id": "540af88f9a758ca2",
      "text": "Searching in a trie starts at the root and proceeds by traversing the edge that matches the first character, then traversing the edge that matches the second character, and so forth."
    },
    {
      "type": "paragraph",
      "id": "81a91a8549709ea4",
      "text": "The search key is a member of the represented set if the search stops in a node that is marked – marked nodes are drawn as filled circles in figure 1."
    },
    {
      "type": "paragraph",
      "id": "159c5e4abcc4c9ca",
      "text": "Tries can also be used to represent finite [[Map]]s [⇒ [[Map Dialect]] ]. In this case marked nodes additionally contain values associated with the strings. Interestingly, the move from sets to finite maps is not a mere variation of the scheme. As we shall see it is essential for the further development."
    },
    {
      "type": "paragraph",
      "id": "b00e2bd293946b22",
      "text": "On a more abstract level, a trie itself can be seen as a composition of finite maps. Each collection of edges descending from the same node constitutes a finite map sending a character to a trie. With this interpretation in mind, it is relatively straightforward to devise an implementation of string-indexed tries. For concreteness, programs will be given in the functional programming language Haskell 98 (Peyton Jones and Hughes, 1999)."
    },
    {
      "type": "pagefold",
      "id": "9565564588760ded",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "6ee0879e4f726c92",
      "text": "\nHINZE, Ralf, 2000. Generalizing generalized tries. Journal of Functional Programming. Online. July 2000. Vol. 10, no. 4, p. 327–351. [Accessed 6 September 2023]. DOI 10.1017/S0956796800003713. A trie is a search tree scheme that employs the structure of search keys to organize information. \nTries were originally devised as a means to represent a collection of records indexed by strings \nover a fixed alphabet. Based on work by C. P. Wadsworth and others, R. H. Connelly and \nF. L. Morris generalized the concept to permit indexing by elements built according to an \narbitrary signature. Here we go one step further, and define tries and operations on tries \ngenerically for arbitrary datatypes of first-order kind, including parameterized and nested \ndatatypes. The derivation employs techniques recently developed in the context of polytypic \nprogramming and can be regarded as a comprehensive case study in this new programming \nparadigm. It is well known that for the implementation of generalized tries, nested datatypes \nand polymorphic recursion are needed. Implementing tries for first-order kinded datatypes \nplaces even greater demands on the type system: it requires rank-2 type signatures and second-order nested datatypes. Despite these requirements, the definition of tries is surprisingly simple, \nwhich is mostly due to the framework of polytypic programming.\n"
    },
    {
      "type": "paragraph",
      "id": "d6c852db4ade8ba4",
      "text": "⇒ Tries ⇒ [[Sequence]] ⇒ [[Digital Searching]]"
    },
    {
      "type": "paragraph",
      "id": "1ff7cff797ab562e",
      "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. v. 2. Seminumerical Algorithms. 3rd ed. Reading, Mass: Addison-Wesley. ISBN  0-201-89684-2, p. 687."
    },
    {
      "type": "paragraph",
      "id": "67fa0839e622b3b3",
      "text": "[…] if we encode each qi(x) by a [[Sequence]] of 0s and 1s according as qi(x) does or doesn’t divide t(x)(pd−1)/2 − 1 for the successive t’s tried, we obtain a random binary trie with r lieves (see Section 6.3)."
    },
    {
      "type": "paragraph",
      "id": "16646e5aa51a2b96",
      "text": "Note: Section 6.3 is [[Digital Searching]]."
    },
    {
      "type": "image",
      "id": "6a6cb29e348f81de",
      "text": "A TRIE FOR THE 31 MOST COMMON ENGLISH WORDS",
      "size": "wide",
      "width": 419,
      "height": 427,
      "url": "/assets/plugins/image/9deb72bb64ba1a02d04b6e562ce55f71.jpg"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Trie",
        "story": []
      },
      "date": 1694251326880
    },
    {
      "item": {
        "type": "factory",
        "id": "22130989ce8f72e0"
      },
      "id": "22130989ce8f72e0",
      "type": "add",
      "date": 1694251328298
    },
    {
      "type": "edit",
      "id": "22130989ce8f72e0",
      "item": {
        "type": "paragraph",
        "id": "22130989ce8f72e0",
        "text": "The concept of a trie was introduced by A. Thue in 1912 as a means to represent a set of strings (see Knuth, 1998). In its simplest form, a trie is a multiway branching tree where each edge is labelled with a character. For example, the set of strings fear; earl ; east; easy; eyeg is represented by the trie depicted in gure 1."
      },
      "date": 1694251330022
    },
    {
      "item": {
        "type": "factory",
        "id": "9565564588760ded"
      },
      "id": "9565564588760ded",
      "type": "add",
      "after": "22130989ce8f72e0",
      "date": 1694251339793
    },
    {
      "type": "edit",
      "id": "9565564588760ded",
      "item": {
        "type": "pagefold",
        "id": "9565564588760ded",
        "text": "~"
      },
      "date": 1694251342562
    },
    {
      "item": {
        "type": "factory",
        "id": "6ee0879e4f726c92"
      },
      "id": "6ee0879e4f726c92",
      "type": "add",
      "after": "9565564588760ded",
      "date": 1694251344296
    },
    {
      "type": "edit",
      "id": "6ee0879e4f726c92",
      "item": {
        "type": "paragraph",
        "id": "6ee0879e4f726c92",
        "text": "\nHINZE, Ralf, 2000. Generalizing generalized tries. Journal of Functional Programming. Online. July 2000. Vol. 10, no. 4, p. 327–351. [Accessed 6 September 2023]. DOI 10.1017/S0956796800003713. A trie is a search tree scheme that employs the structure of search keys to organize information. \nTries were originally devised as a means to represent a collection of records indexed by strings \nover a fixed alphabet. Based on work by C. P. Wadsworth and others, R. H. Connelly and \nF. L. Morris generalized the concept to permit indexing by elements built according to an \narbitrary signature. Here we go one step further, and define tries and operations on tries \ngenerically for arbitrary datatypes of first-order kind, including parameterized and nested \ndatatypes. The derivation employs techniques recently developed in the context of polytypic \nprogramming and can be regarded as a comprehensive case study in this new programming \nparadigm. It is well known that for the implementation of generalized tries, nested datatypes \nand polymorphic recursion are needed. Implementing tries for first-order kinded datatypes \nplaces even greater demands on the type system: it requires rank-2 type signatures and second-order nested datatypes. Despite these requirements, the definition of tries is surprisingly simple, \nwhich is mostly due to the framework of polytypic programming.\n"
      },
      "date": 1694251348056
    },
    {
      "id": "67fa0839e622b3b3",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "67fa0839e622b3b3",
        "text": "[…] if we encode each qi(x) by a [[Sequence]] of 0s and 1s according as qi(x) does or doesn’t divide t(x)(pd−1)/2 − 1 for the successive t’s tried, we obtain a random binary trie with r lieves (see Section 6.3)."
      },
      "after": "6ee0879e4f726c92",
      "attribution": {
        "page": "2023-09-09"
      },
      "date": 1694253491130
    },
    {
      "id": "1ff7cff797ab562e",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "1ff7cff797ab562e",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. 3rd ed. Reading, Mass: Addison-Wesley. ISBN 978-0-201-89683-1, p. 687.\n"
      },
      "after": "6ee0879e4f726c92",
      "attribution": {
        "page": "2023-09-09"
      },
      "date": 1694253493987
    },
    {
      "id": "d6c852db4ade8ba4",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "d6c852db4ade8ba4",
        "text": "⇒ [[Trie]]s ⇒ [[Sequence]] ⇒ [[Digital Searching]]"
      },
      "after": "67fa0839e622b3b3",
      "attribution": {
        "page": "2023-09-09"
      },
      "date": 1694253508379
    },
    {
      "type": "edit",
      "id": "d6c852db4ade8ba4",
      "item": {
        "type": "paragraph",
        "id": "d6c852db4ade8ba4",
        "text": "⇒ Tries ⇒ [[Sequence]] ⇒ [[Digital Searching]]"
      },
      "date": 1694253515454
    },
    {
      "type": "edit",
      "id": "22130989ce8f72e0",
      "item": {
        "type": "paragraph",
        "id": "22130989ce8f72e0",
        "text": "The concept of a trie was introduced by A. Thue in 1912 as a means to represent a set of strings (see Knuth, 1998). In its simplest form, a trie is a multiway branching tree where each edge is labelled with a character. For example, the set of strings fear; earl ; east; easy; eyeg is represented by the trie depicted in figure 1."
      },
      "date": 1694690347312
    },
    {
      "id": "d6c852db4ade8ba4",
      "type": "move",
      "order": [
        "22130989ce8f72e0",
        "d6c852db4ade8ba4",
        "9565564588760ded",
        "6ee0879e4f726c92",
        "1ff7cff797ab562e",
        "67fa0839e622b3b3"
      ],
      "date": 1694690366014
    },
    {
      "item": {
        "type": "factory",
        "id": "d6bfc01a0e4105ff"
      },
      "id": "d6bfc01a0e4105ff",
      "type": "add",
      "after": "67fa0839e622b3b3",
      "date": 1694690437867
    },
    {
      "id": "d6bfc01a0e4105ff",
      "type": "move",
      "order": [
        "22130989ce8f72e0",
        "d6bfc01a0e4105ff",
        "d6c852db4ade8ba4",
        "9565564588760ded",
        "6ee0879e4f726c92",
        "1ff7cff797ab562e",
        "67fa0839e622b3b3"
      ],
      "date": 1694690443580
    },
    {
      "type": "edit",
      "id": "d6bfc01a0e4105ff",
      "item": {
        "type": "image",
        "id": "d6bfc01a0e4105ff",
        "text": "Fig. 1 A simple trie. (R. Hinze)",
        "size": "thumbnail",
        "width": 183,
        "height": 211,
        "url": "/assets/plugins/image/d54ff751e39e25f8424a881a87183d13.jpg"
      },
      "date": 1694690469017
    },
    {
      "id": "d6bfc01a0e4105ff",
      "type": "move",
      "order": [
        "d6bfc01a0e4105ff",
        "22130989ce8f72e0",
        "d6c852db4ade8ba4",
        "9565564588760ded",
        "6ee0879e4f726c92",
        "1ff7cff797ab562e",
        "67fa0839e622b3b3"
      ],
      "date": 1694690473262
    },
    {
      "type": "edit",
      "id": "22130989ce8f72e0",
      "item": {
        "type": "paragraph",
        "id": "22130989ce8f72e0",
        "text": "The concept of a trie was introduced by A. Thue in 1912 as a means to represent a set of strings (see Knuth, 1998)."
      },
      "date": 1694690481204
    },
    {
      "type": "add",
      "id": "74898b7c03d28d8f",
      "item": {
        "type": "paragraph",
        "id": "74898b7c03d28d8f",
        "text": "In its simplest form, a trie is a multiway branching tree where each edge is labelled with a character. For example, the set of strings fear; earl ; east; easy; eyeg is represented by the trie depicted in figure 1."
      },
      "after": "22130989ce8f72e0",
      "date": 1694690482733
    },
    {
      "id": "d6bfc01a0e4105ff",
      "type": "move",
      "order": [
        "22130989ce8f72e0",
        "d6bfc01a0e4105ff",
        "74898b7c03d28d8f",
        "d6c852db4ade8ba4",
        "9565564588760ded",
        "6ee0879e4f726c92",
        "1ff7cff797ab562e",
        "67fa0839e622b3b3"
      ],
      "date": 1694690486051
    },
    {
      "type": "edit",
      "id": "74898b7c03d28d8f",
      "item": {
        "type": "paragraph",
        "id": "74898b7c03d28d8f",
        "text": "In its simplest form, a trie is a multiway branching tree where each edge is labelled with a character. For example, the set of strings {ear, earl, east, easy, eye} is represented by the trie depicted in figure 1."
      },
      "date": 1694690550323
    },
    {
      "type": "add",
      "id": "540af88f9a758ca2",
      "item": {
        "type": "paragraph",
        "id": "540af88f9a758ca2",
        "text": "Searching in a trie starts at the root and proceeds by traversing the edge that matches the \frst"
      },
      "after": "74898b7c03d28d8f",
      "date": 1694690589887
    },
    {
      "type": "edit",
      "id": "540af88f9a758ca2",
      "item": {
        "type": "paragraph",
        "id": "540af88f9a758ca2",
        "text": "Searching in a trie starts at the root and proceeds by traversing the edge that matches the first"
      },
      "date": 1694690600212
    },
    {
      "type": "edit",
      "id": "540af88f9a758ca2",
      "item": {
        "type": "paragraph",
        "id": "540af88f9a758ca2",
        "text": "Searching in a trie starts at the root and proceeds by traversing the edge that matches the first character, then traversing the edge that matches the second character, and so forth."
      },
      "date": 1694690621566
    },
    {
      "type": "edit",
      "id": "74898b7c03d28d8f",
      "item": {
        "type": "paragraph",
        "id": "74898b7c03d28d8f",
        "text": "In its simplest form, a trie is a multiway branching tree where each edge is labelled with a character."
      },
      "date": 1694690633301
    },
    {
      "type": "add",
      "id": "59b1c8b8a138c092",
      "item": {
        "type": "paragraph",
        "id": "59b1c8b8a138c092",
        "text": "For example, the set of strings {ear, earl, east, easy, eye} is represented by the trie depicted in figure 1."
      },
      "after": "74898b7c03d28d8f",
      "date": 1694690637003
    },
    {
      "id": "d6bfc01a0e4105ff",
      "type": "move",
      "order": [
        "22130989ce8f72e0",
        "74898b7c03d28d8f",
        "d6bfc01a0e4105ff",
        "59b1c8b8a138c092",
        "540af88f9a758ca2",
        "d6c852db4ade8ba4",
        "9565564588760ded",
        "6ee0879e4f726c92",
        "1ff7cff797ab562e",
        "67fa0839e622b3b3"
      ],
      "date": 1694690641328
    },
    {
      "type": "add",
      "id": "81a91a8549709ea4",
      "item": {
        "type": "paragraph",
        "id": "81a91a8549709ea4",
        "text": "The search key is a member of the represented set if the search stops in a node that is marked { marked nodes are drawn as \flled circles in \fgure 1."
      },
      "after": "540af88f9a758ca2",
      "date": 1694690721327
    },
    {
      "type": "edit",
      "id": "81a91a8549709ea4",
      "item": {
        "type": "paragraph",
        "id": "81a91a8549709ea4",
        "text": "The search key is a member of the represented set if the search stops in a node that is marked { marked nodes are drawn as filled circles in figure 1."
      },
      "date": 1694690740767
    },
    {
      "type": "edit",
      "id": "81a91a8549709ea4",
      "item": {
        "type": "paragraph",
        "id": "81a91a8549709ea4",
        "text": "The search key is a member of the represented set if the search stops in a node that is marked – marked nodes are drawn as filled circles in figure 1."
      },
      "date": 1694690759901
    },
    {
      "type": "add",
      "id": "159c5e4abcc4c9ca",
      "item": {
        "type": "paragraph",
        "id": "159c5e4abcc4c9ca",
        "text": "Tries can also be used to represent finite maps. In this case marked nodes additionally contain values associated with the strings. Interestingly, the move from sets to finite maps is not a mere variation of the scheme. As we shall see it is essential for the further development."
      },
      "after": "81a91a8549709ea4",
      "date": 1694690815695
    },
    {
      "id": "d6c852db4ade8ba4",
      "type": "move",
      "order": [
        "22130989ce8f72e0",
        "74898b7c03d28d8f",
        "d6bfc01a0e4105ff",
        "59b1c8b8a138c092",
        "540af88f9a758ca2",
        "81a91a8549709ea4",
        "159c5e4abcc4c9ca",
        "9565564588760ded",
        "6ee0879e4f726c92",
        "d6c852db4ade8ba4",
        "1ff7cff797ab562e",
        "67fa0839e622b3b3"
      ],
      "date": 1694690878669
    },
    {
      "type": "edit",
      "id": "1ff7cff797ab562e",
      "item": {
        "type": "paragraph",
        "id": "1ff7cff797ab562e",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. Vol."
      },
      "date": 1694690942944
    },
    {
      "type": "edit",
      "id": "1ff7cff797ab562e",
      "item": {
        "type": "paragraph",
        "id": "1ff7cff797ab562e",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. Volume 2. 3rd ed. Reading, Mass: Addison-Wesley. ISBN 978-0-201-89683-1, p. 687."
      },
      "date": 1694691009479
    },
    {
      "item": {
        "type": "factory",
        "id": "16646e5aa51a2b96"
      },
      "id": "16646e5aa51a2b96",
      "type": "add",
      "after": "67fa0839e622b3b3",
      "date": 1694691047512
    },
    {
      "type": "edit",
      "id": "16646e5aa51a2b96",
      "item": {
        "type": "paragraph",
        "id": "16646e5aa51a2b96",
        "text": "Note: Section 6.3 is "
      },
      "date": 1694691057020
    },
    {
      "type": "edit",
      "id": "16646e5aa51a2b96",
      "item": {
        "type": "paragraph",
        "id": "16646e5aa51a2b96",
        "text": "Note: Section 6.3 is [[Digital Searching]]."
      },
      "date": 1694691062372
    },
    {
      "item": {
        "type": "factory",
        "id": "6a6cb29e348f81de"
      },
      "id": "6a6cb29e348f81de",
      "type": "add",
      "after": "16646e5aa51a2b96",
      "date": 1694691544786
    },
    {
      "type": "edit",
      "id": "6a6cb29e348f81de",
      "item": {
        "type": "image",
        "id": "6a6cb29e348f81de",
        "text": "A TRIE FOR THE 31 MOST COMMON ENGLISH WORDS",
        "size": "wide",
        "width": 419,
        "height": 427,
        "url": "/assets/plugins/image/9deb72bb64ba1a02d04b6e562ce55f71.jpg"
      },
      "date": 1694691581588
    },
    {
      "type": "edit",
      "id": "159c5e4abcc4c9ca",
      "item": {
        "type": "paragraph",
        "id": "159c5e4abcc4c9ca",
        "text": "Tries can also be used to represent finite [[Map]]s. In this case marked nodes additionally contain values associated with the strings. Interestingly, the move from sets to finite maps is not a mere variation of the scheme. As we shall see it is essential for the further development."
      },
      "date": 1694699656673
    },
    {
      "type": "edit",
      "id": "159c5e4abcc4c9ca",
      "item": {
        "type": "paragraph",
        "id": "159c5e4abcc4c9ca",
        "text": "Tries can also be used to represent finite [[Map]]s [⇒ [[Map Dialect]] ]. In this case marked nodes additionally contain values associated with the strings. Interestingly, the move from sets to finite maps is not a mere variation of the scheme. As we shall see it is essential for the further development."
      },
      "date": 1694699701705
    },
    {
      "type": "edit",
      "id": "1ff7cff797ab562e",
      "item": {
        "type": "paragraph",
        "id": "1ff7cff797ab562e",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. v. 2. Seminumerical Algorithms. 3rd ed. Reading, Mass: Addison-Wesley. ISBN 978-0-201-89683-1, p. 687."
      },
      "date": 1694787334367
    },
    {
      "type": "edit",
      "id": "1ff7cff797ab562e",
      "item": {
        "type": "paragraph",
        "id": "1ff7cff797ab562e",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. v. 2. Seminumerical Algorithms. 3rd ed. Reading, Mass: Addison-Wesley. ISBN  0-201-89684-2, p. 687."
      },
      "date": 1694787462020
    },
    {
      "item": {
        "type": "factory",
        "id": "54929345256fae10"
      },
      "id": "54929345256fae10",
      "type": "add",
      "after": "6a6cb29e348f81de",
      "date": 1694791588386
    },
    {
      "item": {
        "type": "factory",
        "id": "c60d5902fbe50c6d"
      },
      "id": "c60d5902fbe50c6d",
      "type": "add",
      "after": "54929345256fae10",
      "date": 1694791592700
    },
    {
      "type": "edit",
      "id": "c60d5902fbe50c6d",
      "item": {
        "type": "reference",
        "id": "c60d5902fbe50c6d",
        "site": "wiki.ralfbarkow.ch",
        "slug": "patricia",
        "title": "Patricia",
        "text": "Donald R. Morrison [JACM 15 (1968), 514–534] has discovered a very pretty way to form N-node search trees based on the binary representation of keys, without storing keys in the nodes. His method, called “Patricia” (Practical Algorithm To Retrieve Information Coded In Alphanumeric), is especially suitable for dealing with extremely long, variable-length keys such as titles or phrases stored within a large bulk file. A closely related algorithm was published at almost exactly the same time in Germany by G. Gwehenberger, Elektronische Rechenanlagen 10 (196"
      },
      "date": 1694791595204
    },
    {
      "type": "edit",
      "id": "c60d5902fbe50c6d",
      "item": {
        "type": "reference",
        "id": "c60d5902fbe50c6d",
        "site": "wiki.ralfbarkow.ch",
        "slug": "patricia",
        "title": "Patricia",
        "text": "’s basic idea is to build a binary [[Trie]], but to avoid one-way branching by including in each node the number of bits to skip over before making the next test. "
      },
      "date": 1694791632871
    },
    {
      "type": "edit",
      "id": "c60d5902fbe50c6d",
      "item": {
        "type": "reference",
        "id": "c60d5902fbe50c6d",
        "site": "wiki.ralfbarkow.ch",
        "slug": "patricia",
        "title": "Patricia",
        "text": "Patricia’s basic idea is to build a binary [[Trie]], but to avoid one-way branching by including in each node the number of bits to skip over before making the next test. "
      },
      "date": 1694791646014
    },
    {
      "type": "edit",
      "id": "c60d5902fbe50c6d",
      "item": {
        "type": "reference",
        "id": "c60d5902fbe50c6d",
        "site": "wiki.ralfbarkow.ch",
        "slug": "patricia",
        "title": "Patricia",
        "text": "Practical Algorithm To Retrieve Information Coded In Alphanumeric’s basic idea is to build a binary [[Trie]], but to avoid one-way branching by including in each node the number of bits to skip over before making the next test. "
      },
      "date": 1694792264605
    },
    {
      "type": "remove",
      "id": "54929345256fae10",
      "date": 1694792274479
    },
    {
      "type": "add",
      "id": "b00e2bd293946b22",
      "item": {
        "type": "paragraph",
        "id": "b00e2bd293946b22",
        "text": "On a more abstract level, a trie itself can be seen as a composition of \fnite maps. Each collection of edges descending from the same node constitutes a \fnite map sending a character to a trie. With this interpretation in mind, it is relatively straightforward to devise an implementation of string-indexed tries. For concreteness, programs will be given in the functional programming language Haskell 98 (Peyton Jones and Hughes, 1999)."
      },
      "after": "159c5e4abcc4c9ca",
      "date": 1694793260211
    },
    {
      "type": "edit",
      "id": "b00e2bd293946b22",
      "item": {
        "type": "paragraph",
        "id": "b00e2bd293946b22",
        "text": "On a more abstract level, a trie itself can be seen as a composition of finite maps. Each collection of edges descending from the same node constitutes a finite map sending a character to a trie. With this interpretation in mind, it is relatively straightforward to devise an implementation of string-indexed tries. For concreteness, programs will be given in the functional programming language Haskell 98 (Peyton Jones and Hughes, 1999)."
      },
      "date": 1694793274743
    },
    {
      "id": "c60d5902fbe50c6d",
      "type": "remove",
      "removedTo": {
        "page": "2023-09-18"
      },
      "date": 1695021461109
    }
  ]
}