{
  "title": "GtExample",
  "story": [
    {
      "type": "markdown",
      "id": "9c7fffe89a78c2dd",
      "text": "I represent the concept of an [[Example]].\n\nI am constructed out of a method that returns an object. I hold the meta-information about that method and I know how to construct the concrete resulting object that is returned by the method. \n\nI can depend on other examples, and other examples can depend on me. When I depend on another example, the code that produces me uses the result of the other example to construct me.\n\nThe class for which I represent the example is called my subject. I can have multiple subjects.\n\nThe object on which I am executed is the provider. This is obtained using the provider class. The class that offers the method out of which I am constructed is the method class. The provider class and the method class are not the same in case of inherited examples. For them, the provider class can be a subclass of the method class. In this case the method resides in a superclass and is executed on an instance of the subclass.\n\nI also know how to handle possible exceptions, which makes me a great candidate for encoding assumptions that are otherwise expressed as classic tests.\n\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "GtExample",
        "story": []
      },
      "date": 1654579749328
    },
    {
      "item": {
        "type": "factory",
        "id": "9c7fffe89a78c2dd"
      },
      "id": "9c7fffe89a78c2dd",
      "type": "add",
      "date": 1654579754738
    },
    {
      "type": "edit",
      "id": "9c7fffe89a78c2dd",
      "item": {
        "type": "markdown",
        "id": "9c7fffe89a78c2dd",
        "text": "I represent the concept of an example.\n\nI am constructed out of a method that returns an object. I hold the meta-information about that method and I know how to construct the concrete resulting object that is returned by the method. \n\nI can depend on other examples, and other examples can depend on me. When I depend on another example, the code that produces me uses the result of the other example to construct me.\n\nThe class for which I represent the example is called my subject. I can have multiple subjects.\n\nThe object on which I am executed is the provider. This is obtained using the provider class. The class that offers the method out of which I am constructed is the method class. The provider class and the method class are not the same in case of inherited examples. For them, the provider class can be a subclass of the method class. In this case the method resides in a superclass and is executed on an instance of the subclass.\n\nI also know how to handle possible exceptions, which makes me a great candidate for encoding assumptions that are otherwise expressed as classic tests.\n\n"
      },
      "date": 1654579756564
    },
    {
      "type": "edit",
      "id": "9c7fffe89a78c2dd",
      "item": {
        "type": "markdown",
        "id": "9c7fffe89a78c2dd",
        "text": "I represent the concept of an [[Example]].\n\nI am constructed out of a method that returns an object. I hold the meta-information about that method and I know how to construct the concrete resulting object that is returned by the method. \n\nI can depend on other examples, and other examples can depend on me. When I depend on another example, the code that produces me uses the result of the other example to construct me.\n\nThe class for which I represent the example is called my subject. I can have multiple subjects.\n\nThe object on which I am executed is the provider. This is obtained using the provider class. The class that offers the method out of which I am constructed is the method class. The provider class and the method class are not the same in case of inherited examples. For them, the provider class can be a subclass of the method class. In this case the method resides in a superclass and is executed on an instance of the subclass.\n\nI also know how to handle possible exceptions, which makes me a great candidate for encoding assumptions that are otherwise expressed as classic tests.\n\n"
      },
      "date": 1654579821681
    }
  ]
}