{
  "title": "Island Parsing",
  "story": [
    {
      "type": "paragraph",
      "id": "331930d1b1ba27d1",
      "text": "Lake symbols for island parsing [https://programming-journal.org/2021/5/11/ page] [https://doi.org/10.22152/programming-journal.org/2021/5/11 doi]"
    },
    {
      "type": "paragraph",
      "id": "56b0859546d37c3e",
      "text": "Context: An island parser reads an input text and builds the parse (or abstract syntax) tree of only the programming constructs of interest in the text. These constructs are called [[Islands]] and the rest of the text is called [[Water]], which the parser ignores and skips over. Since an island parser does not have to parse all the details of the input, it is often easy to develop but still useful enough for a number of software engineering tools. When a parser generator is used, the developer can implement an island parser by just describing a small number of grammar rules, for example, in [[Parsing Expression Grammar]] ([[PEG]])."
    },
    {
      "type": "pagefold",
      "id": "5dec0c87e4267517",
      "text": "~"
    },
    {
      "type": "reference",
      "id": "5c6d1420200d7802",
      "site": "wiki.ralfbarkow.ch",
      "slug": "islands-in-the-river",
      "title": "Islands in the River",
      "text": "I (Ward) sometimes write a long post in our chat rooms that deserves a life of its own. Maybe I don't realize this until I arrive at some conclusion beyond the precipitating conversation. Then I treat it as a first draft. Name the conclusion. Make the page. Then cut, paste and refine the argument hoping others, not yet in the conversation, will find it useful. I'll try that now."
    },
    {
      "type": "reference",
      "site": "found.ward.bay.wiki.org",
      "slug": "exploratory-parsing",
      "title": "Exploratory Parsing",
      "text": "See AboutUs Getting Started blog post announcing the open-sourcing of this technology. [https://github.com/WardCunningham/devblog/blob/master/_posts/2011-07-03-getting-started-exploratory-parsing.markdown github]"
    },
    {
      "type": "pagefold",
      "id": "fd2fe02616cac3ff",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "234ef11a1cf4249a",
      "text": "Inquiry: In practice, however, the grammar rules are often complicated since the developer must define the water inside the island; otherwise, the island parsing will not reduce the total number of grammar rules. When describing the grammar rules for such water, the developer must consider other rules and enumerate a set of symbols, which we call alternative symbols. Due to this difficulty, island parsing seems to be not widely used today despite its usefulness in many applications."
    },
    {
      "type": "paragraph",
      "id": "8524d6c038689335",
      "text": "Approach: This paper proposes the lake symbols for addressing this difficulty in developing an island parser. It also presents an extension to PEG for supporting the lake symbols. The lake symbols automate the enumeration of the alternative symbols for the water inside an island. The paper proposes an algorithm for translating the extended PEG to the normal PEG, which can be given to an existing parser generator based on PEG."
    },
    {
      "type": "paragraph",
      "id": "161e6bdf37c1c2e1",
      "text": "Knowledge: The user can use lake symbols to define water without specifying each alternative symbol. Our algorithms can calculate all alternative symbols for a lake symbol, based on where the lake symbol is used in the grammar."
    },
    {
      "type": "paragraph",
      "id": "e75b46efd9b17c31",
      "text": "Grounding: We implemented a parser generator accepting our extended PEG and implemented 36 island parsers for Java and 20 island parsers for Python. Our experiments show that the lake symbols reduce 42 % of grammar rules for Java and 89 % of rules for Python on average, excluding the case where islands are expressions."
    },
    {
      "type": "paragraph",
      "id": "9cd5d4d1cd35ecdb",
      "text": "Importance: This work eases the use of island parsing. Lake symbols enable the user to define the water inside the island simpler than before. Defining water inside the island is essential to apply island parsing for practical programming languages."
    },
    {
      "type": "pagefold",
      "id": "210778400c71b922",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "3d8ac2dbd5995698",
      "text": "# PP2PossesiveRepeatingNode"
    },
    {
      "type": "paragraph",
      "id": "e3f54ac66fb6ba14",
      "text": "The default repeating parser with standard [[PEG]] semantics (i.e. possessive, blind, eager)."
    },
    {
      "type": "image",
      "id": "902af203f35266b3",
      "text": "Island Parsing [https://discord.com/channels/729445214812504107/819329587728613388/1192048214090711100 discord]",
      "size": "wide",
      "width": 419,
      "height": 299,
      "url": "/assets/plugins/image/f15d2e0bf6b219231be3cb4475752293.jpg"
    },
    {
      "type": "paragraph",
      "id": "a229b396f7ab743a",
      "text": "Examples:\n$a asPParser star parse: 'aaaa'\n\"always fails, because star is greedy\"\n($a asPParser star, $a asPParser) parse: 'aaa' \n\n\nUse #starLazy if you want a non-greedy parse:\n($a asPParser starLazy, ($a asPParser, #endOfInput asPParser)) parse: 'aaa'\n\nNote that #starLazy consumes as little as possible, contrary to your expectations:\n($a asPParser starLazy, $a asPParser) parse: 'aaa'"
    },
    {
      "type": "pagefold",
      "id": "c0ef274f8353831e",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "88695264f71a4785",
      "text": "⇒ [[Sea Parser]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Island Parsing",
        "story": []
      },
      "date": 1705663267931
    },
    {
      "id": "331930d1b1ba27d1",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "331930d1b1ba27d1",
        "text": "Lake symbols for island parsing [https://programming-journal.org/2021/5/11/ page] [https://doi.org/10.22152/programming-journal.org/2021/5/11 doi]"
      },
      "attribution": {
        "page": "2024-01-19"
      },
      "date": 1705663270451
    },
    {
      "id": "56b0859546d37c3e",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "56b0859546d37c3e",
        "text": "Context: An island parser reads an input text and builds the parse (or abstract syntax) tree of only the programming constructs of interest in the text. These constructs are called islands and the rest of the text is called water, which the parser ignores and skips over. Since an island parser does not have to parse all the details of the input, it is often easy to develop but still useful enough for a number of software engineering tools. When a parser generator is used, the developer can implement an island parser by just describing a small number of grammar rules, for example, in Parsing Expression Grammar (PEG)."
      },
      "after": "331930d1b1ba27d1",
      "attribution": {
        "page": "2024-01-19"
      },
      "date": 1705663272907
    },
    {
      "id": "234ef11a1cf4249a",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "234ef11a1cf4249a",
        "text": "Inquiry: In practice, however, the grammar rules are often complicated since the developer must define the water inside the island; otherwise, the island parsing will not reduce the total number of grammar rules. When describing the grammar rules for such water, the developer must consider other rules and enumerate a set of symbols, which we call alternative symbols. Due to this difficulty, island parsing seems to be not widely used today despite its usefulness in many applications."
      },
      "after": "56b0859546d37c3e",
      "attribution": {
        "page": "2024-01-19"
      },
      "date": 1705663276152
    },
    {
      "id": "210778400c71b922",
      "type": "add",
      "item": {
        "type": "pagefold",
        "id": "210778400c71b922",
        "text": "~"
      },
      "after": "234ef11a1cf4249a",
      "attribution": {
        "page": "2024-01-19"
      },
      "date": 1705663402452
    },
    {
      "id": "902af203f35266b3",
      "type": "add",
      "item": {
        "type": "image",
        "id": "902af203f35266b3",
        "text": "Island Parsing",
        "size": "wide",
        "width": 419,
        "height": 299,
        "url": "/assets/plugins/image/f15d2e0bf6b219231be3cb4475752293.jpg"
      },
      "after": "210778400c71b922",
      "attribution": {
        "page": "2024-01-19"
      },
      "date": 1705663404722
    },
    {
      "id": "3d8ac2dbd5995698",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "3d8ac2dbd5995698",
        "text": "# PP2PossesiveRepeatingNode"
      },
      "after": "902af203f35266b3",
      "attribution": {
        "page": "2024-01-19"
      },
      "date": 1705663408438
    },
    {
      "id": "e3f54ac66fb6ba14",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "e3f54ac66fb6ba14",
        "text": "The default repeating parser with standard PEG semantics (i.e. possessive, blind, eager).\n\nExamples:\n$a asPParser star parse: 'aaaa'\n\"always fails, because star is greedy\"\n($a asPParser star, $a asPParser) parse: 'aaa' \n\n\nUse #starLazy if you want a non-greedy parse:\n($a asPParser starLazy, ($a asPParser, #endOfInput asPParser)) parse: 'aaa'\n\nNote that #starLazy consumes as little as possible, contrary to your expectations:\n($a asPParser starLazy, $a asPParser) parse: 'aaa'"
      },
      "after": "902af203f35266b3",
      "attribution": {
        "page": "2024-01-19"
      },
      "date": 1705663428328
    },
    {
      "id": "3d8ac2dbd5995698",
      "type": "move",
      "order": [
        "331930d1b1ba27d1",
        "56b0859546d37c3e",
        "234ef11a1cf4249a",
        "210778400c71b922",
        "902af203f35266b3",
        "3d8ac2dbd5995698",
        "e3f54ac66fb6ba14"
      ],
      "date": 1705663448823
    },
    {
      "type": "edit",
      "id": "e3f54ac66fb6ba14",
      "item": {
        "type": "paragraph",
        "id": "e3f54ac66fb6ba14",
        "text": "The default repeating parser with standard PEG semantics (i.e. possessive, blind, eager)."
      },
      "date": 1705663470180
    },
    {
      "type": "add",
      "id": "a229b396f7ab743a",
      "item": {
        "type": "paragraph",
        "id": "a229b396f7ab743a",
        "text": "Examples:\n$a asPParser star parse: 'aaaa'\n\"always fails, because star is greedy\"\n($a asPParser star, $a asPParser) parse: 'aaa' \n\n\nUse #starLazy if you want a non-greedy parse:\n($a asPParser starLazy, ($a asPParser, #endOfInput asPParser)) parse: 'aaa'\n\nNote that #starLazy consumes as little as possible, contrary to your expectations:\n($a asPParser starLazy, $a asPParser) parse: 'aaa'"
      },
      "after": "e3f54ac66fb6ba14",
      "date": 1705663471076
    },
    {
      "id": "902af203f35266b3",
      "type": "move",
      "order": [
        "331930d1b1ba27d1",
        "56b0859546d37c3e",
        "234ef11a1cf4249a",
        "210778400c71b922",
        "3d8ac2dbd5995698",
        "e3f54ac66fb6ba14",
        "902af203f35266b3",
        "a229b396f7ab743a"
      ],
      "date": 1705663474922
    },
    {
      "id": "8524d6c038689335",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "8524d6c038689335",
        "text": "Approach: This paper proposes the lake symbols for addressing this difficulty in developing an island parser. It also presents an extension to PEG for supporting the lake symbols. The lake symbols automate the enumeration of the alternative symbols for the water inside an island. The paper proposes an algorithm for translating the extended PEG to the normal PEG, which can be given to an existing parser generator based on PEG."
      },
      "after": "234ef11a1cf4249a",
      "attribution": {
        "page": "2024-01-19"
      },
      "date": 1705663523547
    },
    {
      "id": "161e6bdf37c1c2e1",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "161e6bdf37c1c2e1",
        "text": "Knowledge: The user can use lake symbols to define water without specifying each alternative symbol. Our algorithms can calculate all alternative symbols for a lake symbol, based on where the lake symbol is used in the grammar."
      },
      "after": "8524d6c038689335",
      "attribution": {
        "page": "2024-01-19"
      },
      "date": 1705663527164
    },
    {
      "id": "e75b46efd9b17c31",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "e75b46efd9b17c31",
        "text": "Grounding: We implemented a parser generator accepting our extended PEG and implemented 36 island parsers for Java and 20 island parsers for Python. Our experiments show that the lake symbols reduce 42 % of grammar rules for Java and 89 % of rules for Python on average, excluding the case where islands are expressions."
      },
      "after": "161e6bdf37c1c2e1",
      "attribution": {
        "page": "2024-01-19"
      },
      "date": 1705663529731
    },
    {
      "id": "9cd5d4d1cd35ecdb",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "9cd5d4d1cd35ecdb",
        "text": "Importance: This work eases the use of island parsing. Lake symbols enable the user to define the water inside the island simpler than before. Defining water inside the island is essential to apply island parsing for practical programming languages."
      },
      "after": "e75b46efd9b17c31",
      "attribution": {
        "page": "2024-01-19"
      },
      "date": 1705663534255
    },
    {
      "item": {
        "type": "factory",
        "id": "5c6d1420200d7802"
      },
      "id": "5c6d1420200d7802",
      "type": "add",
      "after": "a229b396f7ab743a",
      "date": 1705663610010
    },
    {
      "type": "edit",
      "id": "5c6d1420200d7802",
      "item": {
        "type": "reference",
        "id": "5c6d1420200d7802",
        "site": "wiki.ralfbarkow.ch",
        "slug": "islands-in-the-river",
        "title": "Islands in the River",
        "text": "I (Ward) sometimes write a long post in our chat rooms that deserves a life of its own. Maybe I don't realize this until I arrive at some conclusion beyond the precipitating conversation. Then I treat it as a first draft. Name the conclusion. Make the page. Then cut, paste and refine the argument hoping others, not yet in the conversation, will find it useful. I'll try that now."
      },
      "date": 1705663613707
    },
    {
      "id": "5c6d1420200d7802",
      "type": "move",
      "order": [
        "331930d1b1ba27d1",
        "56b0859546d37c3e",
        "5c6d1420200d7802",
        "234ef11a1cf4249a",
        "8524d6c038689335",
        "161e6bdf37c1c2e1",
        "e75b46efd9b17c31",
        "9cd5d4d1cd35ecdb",
        "210778400c71b922",
        "3d8ac2dbd5995698",
        "e3f54ac66fb6ba14",
        "902af203f35266b3",
        "a229b396f7ab743a"
      ],
      "date": 1705663621518
    },
    {
      "item": {
        "type": "factory",
        "id": "5dec0c87e4267517"
      },
      "id": "5dec0c87e4267517",
      "type": "add",
      "after": "a229b396f7ab743a",
      "date": 1705663641091
    },
    {
      "id": "5dec0c87e4267517",
      "type": "move",
      "order": [
        "331930d1b1ba27d1",
        "56b0859546d37c3e",
        "5dec0c87e4267517",
        "5c6d1420200d7802",
        "234ef11a1cf4249a",
        "8524d6c038689335",
        "161e6bdf37c1c2e1",
        "e75b46efd9b17c31",
        "9cd5d4d1cd35ecdb",
        "210778400c71b922",
        "3d8ac2dbd5995698",
        "e3f54ac66fb6ba14",
        "902af203f35266b3",
        "a229b396f7ab743a"
      ],
      "date": 1705663648425
    },
    {
      "item": {
        "type": "factory",
        "id": "fd2fe02616cac3ff"
      },
      "id": "fd2fe02616cac3ff",
      "type": "add",
      "after": "a229b396f7ab743a",
      "date": 1705663652237
    },
    {
      "id": "fd2fe02616cac3ff",
      "type": "move",
      "order": [
        "331930d1b1ba27d1",
        "56b0859546d37c3e",
        "5dec0c87e4267517",
        "5c6d1420200d7802",
        "fd2fe02616cac3ff",
        "234ef11a1cf4249a",
        "8524d6c038689335",
        "161e6bdf37c1c2e1",
        "e75b46efd9b17c31",
        "9cd5d4d1cd35ecdb",
        "210778400c71b922",
        "3d8ac2dbd5995698",
        "e3f54ac66fb6ba14",
        "902af203f35266b3",
        "a229b396f7ab743a"
      ],
      "date": 1705663658010
    },
    {
      "type": "edit",
      "id": "5dec0c87e4267517",
      "item": {
        "type": "pagefold",
        "id": "5dec0c87e4267517",
        "text": "~"
      },
      "date": 1705663673453
    },
    {
      "type": "edit",
      "id": "fd2fe02616cac3ff",
      "item": {
        "type": "pagefold",
        "id": "fd2fe02616cac3ff",
        "text": "~"
      },
      "date": 1705663678145
    },
    {
      "type": "edit",
      "id": "56b0859546d37c3e",
      "item": {
        "type": "paragraph",
        "id": "56b0859546d37c3e",
        "text": "Context: An island parser reads an input text and builds the parse (or abstract syntax) tree of only the programming constructs of interest in the text. These constructs are called islands and the rest of the text is called water, which the parser ignores and skips over. Since an island parser does not have to parse all the details of the input, it is often easy to develop but still useful enough for a number of software engineering tools. When a parser generator is used, the developer can implement an island parser by just describing a small number of grammar rules, for example, in Parsing Expression Grammar ([[PEG]])."
      },
      "date": 1705663689812
    },
    {
      "type": "edit",
      "id": "56b0859546d37c3e",
      "item": {
        "type": "paragraph",
        "id": "56b0859546d37c3e",
        "text": "Context: An island parser reads an input text and builds the parse (or abstract syntax) tree of only the programming constructs of interest in the text. These constructs are called [[Islands]] and the rest of the text is called [[Water]], which the parser ignores and skips over. Since an island parser does not have to parse all the details of the input, it is often easy to develop but still useful enough for a number of software engineering tools. When a parser generator is used, the developer can implement an island parser by just describing a small number of grammar rules, for example, in Parsing Expression Grammar ([[PEG]])."
      },
      "date": 1705663731608
    },
    {
      "type": "edit",
      "id": "56b0859546d37c3e",
      "item": {
        "type": "paragraph",
        "id": "56b0859546d37c3e",
        "text": "Context: An island parser reads an input text and builds the parse (or abstract syntax) tree of only the programming constructs of interest in the text. These constructs are called [[Islands]] and the rest of the text is called [[Water]], which the parser ignores and skips over. Since an island parser does not have to parse all the details of the input, it is often easy to develop but still useful enough for a number of software engineering tools. When a parser generator is used, the developer can implement an island parser by just describing a small number of grammar rules, for example, in [[Parsing Expression Grammar]] ([[PEG]])."
      },
      "date": 1705663760502
    },
    {
      "type": "add",
      "item": {
        "type": "reference",
        "site": "found.ward.bay.wiki.org",
        "slug": "exploratory-parsing",
        "title": "Exploratory Parsing",
        "text": "See AboutUs Getting Started blog post announcing the open-sourcing of this technology. [https://github.com/WardCunningham/devblog/blob/master/_posts/2011-07-03-getting-started-exploratory-parsing.markdown github]"
      },
      "after": "5c6d1420200d7802",
      "date": 1705663802260
    },
    {
      "type": "edit",
      "id": "e3f54ac66fb6ba14",
      "item": {
        "type": "paragraph",
        "id": "e3f54ac66fb6ba14",
        "text": "The default repeating parser with standard [[PEG]] semantics (i.e. possessive, blind, eager)."
      },
      "date": 1705663898742
    },
    {
      "type": "edit",
      "id": "902af203f35266b3",
      "item": {
        "type": "image",
        "id": "902af203f35266b3",
        "text": "Island Parsing [https://discord.com/channels/729445214812504107/819329587728613388/1192048214090711100 discord]",
        "size": "wide",
        "width": 419,
        "height": 299,
        "url": "/assets/plugins/image/f15d2e0bf6b219231be3cb4475752293.jpg"
      },
      "date": 1705663934666
    },
    {
      "item": {
        "type": "factory",
        "id": "c0ef274f8353831e"
      },
      "id": "c0ef274f8353831e",
      "type": "add",
      "after": "a229b396f7ab743a",
      "date": 1705664008892
    },
    {
      "type": "edit",
      "id": "c0ef274f8353831e",
      "item": {
        "type": "pagefold",
        "id": "c0ef274f8353831e",
        "text": "~"
      },
      "date": 1705664011857
    },
    {
      "item": {
        "type": "factory",
        "id": "88695264f71a4785"
      },
      "id": "88695264f71a4785",
      "type": "add",
      "after": "c0ef274f8353831e",
      "date": 1705664013463
    },
    {
      "type": "edit",
      "id": "88695264f71a4785",
      "item": {
        "type": "paragraph",
        "id": "88695264f71a4785",
        "text": "⇒ [[Sea Parser]]"
      },
      "date": 1705664046809
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1705668264237
    },
    {
      "type": "fork",
      "site": "wiki.ralfbarkow.ch",
      "date": 1706529097320
    }
  ]
}