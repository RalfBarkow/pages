{
  "title": "Lazy Evaluation",
  "story": [
    {
      "type": "html",
      "text": "Waiting until the last possible moment to evaluate an expression, especially for the purpose of optimizing an algorithm that may not use the value of the expression. Contrast this with [[Strict Evaluation]].",
      "id": "652b07fb2947fe9bb85bef77a6e8d615"
    },
    {
      "type": "html",
      "text": "\n[[Lazy Evaluation]] comes in handy when an expression is expensive or impossible to evaluate and may not need to be evaluated at all. It is also useful for recursively defining infinite data structures. Since each level of recursion is evaluated only as it is needed, data is only generated as it is consumed and the evaluation of the data structure can terminate when the consumption is completed.",
      "id": "cec2e3aa3a5b1a0f2fca167c827d917f"
    },
    {
      "type": "html",
      "text": "\nThe notion of [[Lazy Evaluation]] can be extended so that the value of an expression is used interchangeably with the expression itself. This extension of [[Lazy Evaluation]] and sharing the value of the evaluated expression is used to implement [[Call By Need Semantics]]. [[Call By Need Semantics]] essentially means that expressions are only evaluated once and then only if the evaluation is actually needed. All future instances of the expression are then exchanged directly for the calculated value. In some cases this can go beyond incremental optimization and actually reduce the computational complexity of an algorithm.",
      "id": "0bc56fd0bf5fecf8aa2541624ae0b048"
    },
    {
      "type": "html",
      "text": "\n[[Lazy Evaluation]] requires the data used in the calculation to be available and meaningful at the time of evaluation. In pure [[Functional Programming Language]]s this condition is guaranteed because state changes aren't allowed. Procedural languages, however, present some challenges along with greater opportunities. Since these languages support changes in state we must ensure that the timing of [[Lazy Evaluation]] falls within the window of opportunity for the expression to be evaluated correctly. If we try to evaluate too soon the data may not be available. If we evaluate too late the data may no longer be valid. [[Lazy Evaluation]] gives us the opportunity to delay calculations until the data for them becomes available. Indeed, it also gives us the ability to instigate state-changing operations but delay their execution until an appropriate time.",
      "id": "d1139deb120607b7e590492e78121c6c"
    },
    {
      "type": "html",
      "text": "\n[[Lazy Evaluation And Transaction Semantics]] can be combined to complement each other: [[Transaction Semantics]] can be used to isolate expressions from tentative changes in state and [[Lazy Evaluation]] can be used as a mechanism to delay those same changes until it is time to commit the transaction.",
      "id": "8ef75a24ce6c7274a8b80f851fc2255c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "98cbd583adae3c67ddbd5c1e5dde596f"
    },
    {
      "type": "html",
      "text": "\nMany discussions of lazy evaluation concentrate on performance issues and on [[Lazy Evaluation Overhead]]. However, performance is of little importance in lazy evaluation. The most important thing with lazy evaluation is that it provides new means to solve programming tasks: for example, parts of program can easily communicate with the help of potentially-infinite data structures. Lazy Evaluation supports [[Horizontal Execution Of Vertical Constructs]].",
      "id": "02e2ba24ab15a05e209d3d910050a1e5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "98cbd583adae3c67ddbd5c1e5dde596f"
    },
    {
      "type": "html",
      "text": "\n[[Lazy Evaluation]] speeds creation/initialization time at the cost of some things being slower later.  It also saves memory by not creating things until they are needed with no real cost later in the program.  People usually focus on performance when speaking of lazy evaluation, but memory savings are important as well.",
      "id": "e13354937a058eae7552c64fd05632d5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "98cbd583adae3c67ddbd5c1e5dde596f"
    },
    {
      "type": "html",
      "text": "\nCouldn't it be said that logical AND (&&) and OR (||) are the simplest examples of [[Lazy Evaluation]]? -- [[Patrick Parker]]",
      "id": "c0c164606eb50aad16cd80ac3258dd0c"
    },
    {
      "type": "html",
      "text": "\nYes, quite right. These are non-strict operators, i.e., they do not evaluate all their arguments right away but may leave some unevaluated if possible. Non-strictness is very much related to [[Lazy Evaluation]] and *every* language has to have a non-strict operator/function even if built in. For example a conditional statement (if) has to be non-strict about the block it is guarding. -- [[Thomas Kuehne]]",
      "id": "e3439fe17580f894d8ecc5cba64228d3"
    },
    {
      "type": "html",
      "text": "<i>Well, non-strict operators can certainly be emulated in a strict language.  [[Scheme Language]] is a strict language using [[Call By Value]] reduction, yet can emulate *if* as follows by nesting its arguments inside thunks (zero-arity functions).</i>",
      "id": "dc478dbae1b8a58108531765847db13e"
    },
    {
      "type": "code",
      "text": " (define (true x y) \n   x)",
      "id": "cd7328af8bf98abcad82052c341d3a98"
    },
    {
      "type": "code",
      "text": " (define (false x y)\n   y)",
      "id": "190def8dc2bafb3b773c08d8302af04b"
    },
    {
      "type": "code",
      "text": " (define-syntax my-if                               ; Defines syntactic abbreviation\n   (syntax-rules (lambda)\n     [(my-if c exp1 exp2) ((c (lambda () exp1)      ; Choose a thunk and evaluate it (extra ())\n                              (lambda () exp2)))])) ",
      "id": "880db23f08e00e367b2dbcbd8bc79e48"
    },
    {
      "type": "code",
      "text": " (my-if true \n        (print \"evaluating true branch\")\n        (print \"evaluating false branch\"))",
      "id": "ffcffcdc959db3a7975ef5af15a54baa"
    },
    {
      "type": "html",
      "text": "\ngives \"evaluating true branch\"",
      "id": "267cac55f2d27781aa2b026d8322f208"
    },
    {
      "type": "code",
      "text": " (my-if false \n        (print \"evaluating true branch\")\n        (print \"evaluating false branch\"))",
      "id": "922000c28d2d27b33045158b839a90a9"
    },
    {
      "type": "html",
      "text": "\ngives \"evaluating false branch\".",
      "id": "2af394d259113d34dcac15ea19547b65"
    },
    {
      "type": "html",
      "text": "\nIf you object to the [[Syntactic Sugar]] provided by [[Define Syntax]], you can get the same effect by simply writing it out.  For example, the first my-if above expands to  ",
      "id": "ad73d494dda98115ab01cbf6367fb8cb"
    },
    {
      "type": "code",
      "text": " ((true (lambda () (print \"evaluating true branch\"))\n        (lambda () (print \"evaluating false branch\")))",
      "id": "bc3442f55b2d39be485d00e462ac04ff"
    },
    {
      "type": "html",
      "text": "\nTrue selects its first argument, which is a thunk (a function of no arguments), and the extra pair of parentheses then calls this function, causing the evaluation of its body.  No primitive lazy operator is needed, unless we count lambda (which perhaps we should?)",
      "id": "c0598b9d280dace87c0caf520cd18057"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "98cbd583adae3c67ddbd5c1e5dde596f"
    },
    {
      "type": "html",
      "text": "\nI would argue (as have others) that lazy evaluation and [[Normal Order Evaluation]] are two different things; the difference is alluded to above.  In lazy evaluation, evaluation of the argument is deferred until it is needed, at which point the argument is evaluated and its result saved (memoized).  Further uses of the argument in the function use the computed value.  The C/C++ operators ||, &&, and ? : are both examples of lazy evaluation.  (Unless some newbie C/C++ programmer is daft enough to overload && or ||, in which case the overloaded versions are evaluated in strict order; which is why the && and || operators should NEVER be overloaded in C++).",
      "id": "24b7ded6b5ce2ac83b53c0f78cfc4c2c"
    },
    {
      "type": "html",
      "text": "\nIn other words, each argument is evaluated <i>at most once</i>, possibly not at all.",
      "id": "5860bf13f84cd9ae57c3abe74aa627b3"
    },
    {
      "type": "html",
      "text": "\n[[Normal Order Evaluation]], on the other hand, re-evaluates the expression each time it is used.  Think of C macros, [[Call By Name]] in languages which support it, and the semantics of looping control structures, etc.  Normal-order evaluation can take much longer than applicative order evaluation, and can cause side effects to happen more than once.  (Which is why, of course, statements with side effects generally ought not be given as arguments to macros in C/C++)",
      "id": "d06b198b70a415930264b2d427e28f13"
    },
    {
      "type": "html",
      "text": "\nIf the argument is invariant and has no side effects, the only difference between the two is performance.  Indeed, in a purely functional language, lazy eval can be viewed as an optimization of normal-order evaluation.  With side effects present, or expressions which can return a different value when re-evaluated, the two have different behavior; normal order eval in particular has a bad reputation in procedural languages due to the difficulty of reasoning about such programs without [[Referential Transparency]]",
      "id": "a6494da7a881682372d15a368a1d9006"
    },
    {
      "type": "html",
      "text": "\nShould also be noted that strict-order evaluation (as well as lazy evaluation) can be achieved in a language which supports normal-order evaluation via explicit memoing.  The opposite isn't true; it requires passing in thunks, functions, or objects which can be called/messaged in order to defer/repeat the evaluation.",
      "id": "9671d88aef143b196c4abb48715dc012"
    },
    {
      "type": "html",
      "text": "-- [[Scott Johnson]]",
      "id": "94d6f211d289d622c25d020a187c6358"
    },
    {
      "type": "html",
      "text": "\nYes, but you can do [[Continuation Passing Style]] transformation in a lazily evaluated language to force strict evaluation; and you can lift all expressions into subfunctions in a strict language to get lazy / normal-order evaluation.",
      "id": "77d87b3ffed0ecdc8e61c99f5415e7ef"
    },
    {
      "type": "html",
      "text": "\nBy the way, common examples of normal-order evaluation are typesetting systems such as TeX.  In these systems, having a side-effect happen more than once is usually the desired result.",
      "id": "4839f6d3a3da2eea291b34ad6f35aa79"
    },
    {
      "type": "html",
      "text": "-- [[Panu Kalliokoski]]",
      "id": "946dd22792829048e0d3f92775d668ef"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "98cbd583adae3c67ddbd5c1e5dde596f"
    },
    {
      "type": "html",
      "text": "See [[Functoids In Cpp]] for a way of implementing this in [[Cee Plus Plus]].",
      "id": "3df804a04ba0fcc928952523359b9c4f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "98cbd583adae3c67ddbd5c1e5dde596f"
    },
    {
      "type": "html",
      "text": "[[Category Object Functional Patterns]] [[Category Lazy Pattern]]",
      "id": "508ab3ebec14eabd5950178113761292"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?LazyEvaluation c2.com]",
      "id": "d2e3ff6b481ea95eb213230cf408da4c"
    }
  ],
  "journal": [
    {
      "date": 1261068327000,
      "id": "1ab27ca3728a26018428f660e231b431",
      "type": "create",
      "item": {
        "title": "Lazy Evaluation",
        "story": [
          {
            "type": "html",
            "text": "Waiting until the last possible moment to evaluate an expression, especially for the purpose of optimizing an algorithm that may not use the value of the expression. Contrast this with [[Strict Evaluation]].",
            "id": "652b07fb2947fe9bb85bef77a6e8d615"
          },
          {
            "type": "html",
            "text": "\n[[Lazy Evaluation]] comes in handy when an expression is expensive or impossible to evaluate and may not need to be evaluated at all. It is also useful for recursively defining infinite data structures. Since each level of recursion is evaluated only as it is needed, data is only generated as it is consumed and the evaluation of the data structure can terminate when the consumption is completed.",
            "id": "cec2e3aa3a5b1a0f2fca167c827d917f"
          },
          {
            "type": "html",
            "text": "\nThe notion of [[Lazy Evaluation]] can be extended so that the value of an expression is used interchangeably with the expression itself. This extension of [[Lazy Evaluation]] and sharing the value of the evaluated expression is used to implement [[Call By Need Semantics]]. [[Call By Need Semantics]] essentially means that expressions are only evaluated once and then only if the evaluation is actually needed. All future instances of the expression are then exchanged directly for the calculated value. In some cases this can go beyond incremental optimization and actually reduce the computational complexity of an algorithm.",
            "id": "0bc56fd0bf5fecf8aa2541624ae0b048"
          },
          {
            "type": "html",
            "text": "\n[[Lazy Evaluation]] requires the data used in the calculation to be available and meaningful at the time of evaluation. In pure [[Functional Programming Language]]s this condition is guaranteed because state changes aren't allowed. Procedural languages, however, present some challenges along with greater opportunities. Since these languages support changes in state we must ensure that the timing of [[Lazy Evaluation]] falls within the window of opportunity for the expression to be evaluated correctly. If we try to evaluate too soon the data may not be available. If we evaluate too late the data may no longer be valid. [[Lazy Evaluation]] gives us the opportunity to delay calculations until the data for them becomes available. Indeed, it also gives us the ability to instigate state-changing operations but delay their execution until an appropriate time.",
            "id": "d1139deb120607b7e590492e78121c6c"
          },
          {
            "type": "html",
            "text": "\n[[Lazy Evaluation And Transaction Semantics]] can be combined to complement each other: [[Transaction Semantics]] can be used to isolate expressions from tentative changes in state and [[Lazy Evaluation]] can be used as a mechanism to delay those same changes until it is time to commit the transaction.",
            "id": "8ef75a24ce6c7274a8b80f851fc2255c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "98cbd583adae3c67ddbd5c1e5dde596f"
          },
          {
            "type": "html",
            "text": "\nMany discussions of lazy evaluation concentrate on performance issues and on [[Lazy Evaluation Overhead]]. However, performance is of little importance in lazy evaluation. The most important thing with lazy evaluation is that it provides new means to solve programming tasks: for example, parts of program can easily communicate with the help of potentially-infinite data structures. Lazy Evaluation supports [[Horizontal Execution Of Vertical Constructs]].",
            "id": "02e2ba24ab15a05e209d3d910050a1e5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "98cbd583adae3c67ddbd5c1e5dde596f"
          },
          {
            "type": "html",
            "text": "\n[[Lazy Evaluation]] speeds creation/initialization time at the cost of some things being slower later.  It also saves memory by not creating things until they are needed with no real cost later in the program.  People usually focus on performance when speaking of lazy evaluation, but memory savings are important as well.",
            "id": "e13354937a058eae7552c64fd05632d5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "98cbd583adae3c67ddbd5c1e5dde596f"
          },
          {
            "type": "html",
            "text": "\nCouldn't it be said that logical AND (&&) and OR (||) are the simplest examples of [[Lazy Evaluation]]? -- [[Patrick Parker]]",
            "id": "c0c164606eb50aad16cd80ac3258dd0c"
          },
          {
            "type": "html",
            "text": "\nYes, quite right. These are non-strict operators, i.e., they do not evaluate all their arguments right away but may leave some unevaluated if possible. Non-strictness is very much related to [[Lazy Evaluation]] and *every* language has to have a non-strict operator/function even if built in. For example a conditional statement (if) has to be non-strict about the block it is guarding. -- [[Thomas Kuehne]]",
            "id": "e3439fe17580f894d8ecc5cba64228d3"
          },
          {
            "type": "html",
            "text": "<i>Well, non-strict operators can certainly be emulated in a strict language.  [[Scheme Language]] is a strict language using [[Call By Value]] reduction, yet can emulate *if* as follows by nesting its arguments inside thunks (zero-arity functions).</i>",
            "id": "dc478dbae1b8a58108531765847db13e"
          },
          {
            "type": "code",
            "text": " (define (true x y) \n   x)",
            "id": "cd7328af8bf98abcad82052c341d3a98"
          },
          {
            "type": "code",
            "text": " (define (false x y)\n   y)",
            "id": "190def8dc2bafb3b773c08d8302af04b"
          },
          {
            "type": "code",
            "text": " (define-syntax my-if                               ; Defines syntactic abbreviation\n   (syntax-rules (lambda)\n     [(my-if c exp1 exp2) ((c (lambda () exp1)      ; Choose a thunk and evaluate it (extra ())\n                              (lambda () exp2)))])) ",
            "id": "880db23f08e00e367b2dbcbd8bc79e48"
          },
          {
            "type": "code",
            "text": " (my-if true \n        (print \"evaluating true branch\")\n        (print \"evaluating false branch\"))",
            "id": "ffcffcdc959db3a7975ef5af15a54baa"
          },
          {
            "type": "html",
            "text": "\ngives \"evaluating true branch\"",
            "id": "267cac55f2d27781aa2b026d8322f208"
          },
          {
            "type": "code",
            "text": " (my-if false \n        (print \"evaluating true branch\")\n        (print \"evaluating false branch\"))",
            "id": "922000c28d2d27b33045158b839a90a9"
          },
          {
            "type": "html",
            "text": "\ngives \"evaluating false branch\".",
            "id": "2af394d259113d34dcac15ea19547b65"
          },
          {
            "type": "html",
            "text": "\nIf you object to the [[Syntactic Sugar]] provided by [[Define Syntax]], you can get the same effect by simply writing it out.  For example, the first my-if above expands to  ",
            "id": "ad73d494dda98115ab01cbf6367fb8cb"
          },
          {
            "type": "code",
            "text": " ((true (lambda () (print \"evaluating true branch\"))\n        (lambda () (print \"evaluating false branch\")))",
            "id": "bc3442f55b2d39be485d00e462ac04ff"
          },
          {
            "type": "html",
            "text": "\nTrue selects its first argument, which is a thunk (a function of no arguments), and the extra pair of parentheses then calls this function, causing the evaluation of its body.  No primitive lazy operator is needed, unless we count lambda (which perhaps we should?)",
            "id": "c0598b9d280dace87c0caf520cd18057"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "98cbd583adae3c67ddbd5c1e5dde596f"
          },
          {
            "type": "html",
            "text": "\nI would argue (as have others) that lazy evaluation and [[Normal Order Evaluation]] are two different things; the difference is alluded to above.  In lazy evaluation, evaluation of the argument is deferred until it is needed, at which point the argument is evaluated and its result saved (memoized).  Further uses of the argument in the function use the computed value.  The C/C++ operators ||, &&, and ? : are both examples of lazy evaluation.  (Unless some newbie C/C++ programmer is daft enough to overload && or ||, in which case the overloaded versions are evaluated in strict order; which is why the && and || operators should NEVER be overloaded in C++).",
            "id": "24b7ded6b5ce2ac83b53c0f78cfc4c2c"
          },
          {
            "type": "html",
            "text": "\nIn other words, each argument is evaluated <i>at most once</i>, possibly not at all.",
            "id": "5860bf13f84cd9ae57c3abe74aa627b3"
          },
          {
            "type": "html",
            "text": "\n[[Normal Order Evaluation]], on the other hand, re-evaluates the expression each time it is used.  Think of C macros, [[Call By Name]] in languages which support it, and the semantics of looping control structures, etc.  Normal-order evaluation can take much longer than applicative order evaluation, and can cause side effects to happen more than once.  (Which is why, of course, statements with side effects generally ought not be given as arguments to macros in C/C++)",
            "id": "d06b198b70a415930264b2d427e28f13"
          },
          {
            "type": "html",
            "text": "\nIf the argument is invariant and has no side effects, the only difference between the two is performance.  Indeed, in a purely functional language, lazy eval can be viewed as an optimization of normal-order evaluation.  With side effects present, or expressions which can return a different value when re-evaluated, the two have different behavior; normal order eval in particular has a bad reputation in procedural languages due to the difficulty of reasoning about such programs without [[Referential Transparency]]",
            "id": "a6494da7a881682372d15a368a1d9006"
          },
          {
            "type": "html",
            "text": "\nShould also be noted that strict-order evaluation (as well as lazy evaluation) can be achieved in a language which supports normal-order evaluation via explicit memoing.  The opposite isn't true; it requires passing in thunks, functions, or objects which can be called/messaged in order to defer/repeat the evaluation.",
            "id": "9671d88aef143b196c4abb48715dc012"
          },
          {
            "type": "html",
            "text": "-- [[Scott Johnson]]",
            "id": "94d6f211d289d622c25d020a187c6358"
          },
          {
            "type": "html",
            "text": "\nYes, but you can do [[Continuation Passing Style]] transformation in a lazily evaluated language to force strict evaluation; and you can lift all expressions into subfunctions in a strict language to get lazy / normal-order evaluation.",
            "id": "77d87b3ffed0ecdc8e61c99f5415e7ef"
          },
          {
            "type": "html",
            "text": "\nBy the way, common examples of normal-order evaluation are typesetting systems such as TeX.  In these systems, having a side-effect happen more than once is usually the desired result.",
            "id": "4839f6d3a3da2eea291b34ad6f35aa79"
          },
          {
            "type": "html",
            "text": "-- [[Panu Kalliokoski]]",
            "id": "946dd22792829048e0d3f92775d668ef"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "98cbd583adae3c67ddbd5c1e5dde596f"
          },
          {
            "type": "html",
            "text": "See [[Functoids In Cpp]] for a way of implementing this in [[Cee Plus Plus]].",
            "id": "3df804a04ba0fcc928952523359b9c4f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "98cbd583adae3c67ddbd5c1e5dde596f"
          },
          {
            "type": "html",
            "text": "[[Category Object Functional Patterns]] [[Category Lazy Pattern]]",
            "id": "508ab3ebec14eabd5950178113761292"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?LazyEvaluation c2.com]",
            "id": "d2e3ff6b481ea95eb213230cf408da4c"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1644990739282
    }
  ]
}