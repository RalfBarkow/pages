{
  "title": "Letâ€™s Be Mainstream",
  "story": [
    {
      "type": "paragraph",
      "id": "52377aea8c989955",
      "text": "If typed functional programming is so great, how come nobody uses it?"
    },
    {
      "type": "video",
      "id": "5e29400f6fcd0c71",
      "text": "YOUTUBE oYk8CKH7OhE\n[[Evan Czaplicki]] - Let's be mainstream! User focused design in Elm - Curry On"
    },
    {
      "type": "paragraph",
      "id": "badddde0b65d4b81",
      "text": "hi sign and Evan chip and depending on where you're from you might say it different so I designed this programming language called Elm that's focused on front-end programming so doing stuff in browser interactive applications games this kind of thing and so I'm sort of coming from a perspective of typed functional programming and one thing I think about a lot is this question like if typed functional programming is so great how come nobody uses it"
    },
    {
      "type": "paragraph",
      "id": "1ca8005ad201ab2c",
      "text": "and and I think this is a question that people sort of outside this community ask and I think it's a reasonable question for them just like as a filter right like obscure things aren't always amazing and it's something that I don't think we ask within that community enough right why is it that we don't have more users if if it is true that we really are doing something really great so the rough theory is that we're engaged in a decent amount of self-destructive behavior so I kind of want to talk about sort of how Elm sort of how I think about these things in how I only tries to do do a better job dealing with those things and I also I don't I don't want to be like a mean mean guy so I tried to frame things in a positive way and not like be too mean or anything like this is all meant as a as a how can we do better kind of thing so for me I think it's valuable to sort of think about like the history of programming in trying to figure out what's going to come next so this one's actually the history program as seen from JavaScript so if you if you try to do a I tried to do a more realistic history it just broke down so what does history looked like from from like JavaScript world so in the beginning there was assembly and it was it was hard but somehow people wrote a super Mario in it so that was pretty cool but we got to this crisis point where things just like we're not working out anymore so like Along Came see and now we have the structured programming approach and like okay that's not exactly high street okay but this is a scene from Johnson so si comes along and suddenly we're not doing this really low-level thing we're doing like a much higher level thing and that's true for many many years and at a certain point we get to this other crisis point where it's like ah and Java comes along and we're like oh great this is amazing and eventually we get into JavaScript and the other sort of roughly arranged timewise like that it doesn't exactly line up timewise but from the perspective of JavaScript you sort of say like well before us there was Java and before then they was seeing it's kind of a true true enough in fact it's true from that perspective so it might as well be true so when we look back the C and Java and JavaScript rivers can all look at assembly I was maintained a bowling night I couldn't write this in a portable way I couldn't have people read this easily so we solved that when we went to C and now the Java and JavaScript programs like I could see no way o memory man how could they even deal with that in that crazy language back in the day and so that's what it was the ingredients of this crisis point that that it was perceived how we got the job and when JavaScript looks a Java they're like how do people deal with all those freaking types like how can you get anything done at all and so I have a feeling that we're at another one of these crisis points where the issue again is maintainability so when you talk to companies that have let's say 50,000 100,000 lines of JavaScript they're there in this place where when they add a new feature they're going to break 3 so one way I think it is like Facebook used to say like move fast and break things and I think it's sort of shifted to like move slow and break things so what I'm getting at though is like at a large enough scale people are trying to see issues in practice and that's not to say that there's that this isn't a valuable place to be but we're starting to get these like rough spots so the question you might ask then is like well okay so what's this next era going to be what's the next part of this history and so maybe that's something functional maybe it's way crazier than we imagined and it's a stack-based language or a prologue right like ooh something insane happens maybe types won't be involved maybe not so like a lisp or ml maybe it'll be something gradually typed these are all viable and different degrees right I add this prologue and stack-based because you know these are small communities that people really love a lot and maybe they're great right like they say they're great should I believe them I don't know so for me I think of well a typed functional language is going to address a lot of these issues we can look back at history and say we got the memory management under control we got all those freaking types under control in the sense that if you can infer all that information you get a lot of the benefits without the like really heavy syntax that a lot of JavaScript programmers look at no like ah so and then maintainability as well so the problem with that is that in 1973 like and they'll like was introduced okay so this is huh the this is a one year after seat si was making send me to but for some reason I didn't work out I don't sew something mysterious happened so we have another chance 1990 standard ml came out so this is actually five years before Java Java was 1995 so we could have gone that route but for some reason didn't happen and in 1996 we had oh camel this is one year after Java it has objects like it's got it is got at all like what's the problem so in all of these situations we were sort of addressing the core concerns but in a way that for some reason didn't connect and didn't make it big so when we think about what's going to happen next I think it makes sense to ask who's going to be deciding what happens next so we've got this massive chunk of Furman programmers people who day to day are making web applications making games and we've got this tiny population of people using type function languages now this isn't to scale okay I think I don't know how small that red dot should be but so I to try to put in perspective Oracle says that there are 10 million Java programmers and if I try to do some estimation I can say ok so maybe they're like two hundred thousand scallop programmers maybe maybe more maybe less and and then how many Haskell programmers are so like we're talking about orders of magnitude the difference here like it said they're the number of jQuery users is like way huger than the number of people who are doing these functional languages I think I don't know so if this giant group of functional front-end programmers are going to be deciding we should understand what they want in this next error of programming so I think there are two sort of main accesses that we can think about that are helpful here so we have JavaScript and the XS here usable and what I mean by usable is the ability to use it so so I sort of defined that as like the time it takes to get from a novice level to actually a product that you can show your friends and be like hey check us out so I wanted to demo something real quick so this is Google guys I'm using javascript like the time from novice to getting something done was like it's unreal it's crazy I don't think anything has really matched that and like if this was a competitive market and this would probably be like abusive market position that it's baked in in this way but like it's really really easy to get started here and so if you are doing some kind of let's say you want to get a webpage up maybe that's a five minute or an hour long process even for someone who's a total beginner so that's a really amazing ability to use the language now the issue people having is about maintainability now I've got 50,000 lines the company I notice is successful and we're getting new users we're trying to add new features but we're having trouble doing that so another point on this map is Java right so we have much more maintainability here but the usability is down and so this isn't this is more about like the time it would take to start using Java is just longer rather than five minutes or an hour you're looking at something a little bit more and that part of that learning time part of that's getting things installed getting things set up so from the JavaScript programmers perspective like this is a no this is a no-go I mean partly friendly maintainable and usability but also partly from an emotional sort of crazy standpoint we're just like ah like that's kind of the logic of this isn't viable so what we want is to get that maintainability and either keep the usability or even improve it a bit and the direction people are taking here is gradual types you're seeing this coming out of Microsoft and Google like a lot of companies are betting in this direction so you can keep the usability profile where when you start out it's very simple and as your thing grows you can add types to it what I don't know if people are thinking about is like what is the endgame here when we have a JavaScript program that is fully typed like didn't we make Java again III don't I don't know maybe not but there's something here where I don't know if that's a quite an exciting resolution I don't know if that's what will satisfy b-but but it is addressing the main concern we get this maintainability now what a lot of JavaScript people don't realize is that this graph is actually later the you can be much less usable than then than anyone imagined what's interesting though is you can actually be way more maintainable than a lot of people think about as well so in the top right corner or top left when we have ml family language this is a like Haskell and oh camel so I can I can speak to my experience getting started with Haskell that led me to put it in this corner I'd say it was a good like year before I was like I'm good pretty good at this and like it's just not that way in another language so when you're set up takes a couple days and the learning process takes months or years potentially to get to an expert level it's making things really hard for you so the important point here though is that the levels of maintainability that are available are way higher than and people think about so what I want to do is I want to get to this magic realm where we get that level of maintainability but we have something usable we have something that like in an hour or in finding that people can get started with and be productive so the question is how do we get from here to there okay this is a trick this isn't actually the thing we want to hope it doesn't make sense to try to move these languages to this nice place because that means we're moving a really small set of users to a place that they generally don't necessarily want to go in the sense that if you make a really nice front-end programming language for people who don't do front-end programming and I don't so the thing you want to do is actually get Java Script to this and this nice place so when you focus on what a JavaScript programmer needs to get there you end up making different design decisions so this is kind of the shape of the world from as sort of as I see it so the next thing thing about is what does this mean for designing Elm so the broad category I name this is like user focused design and Elm so I know that I am designing for people who are doing front-end work and they have specific issues that they need addressed and if we're able to address them the best then will win if we're if we aren't the best I may be some random things will happen but if we can do better than we have a better chance so the sort of key design principles here our first gradual learning when you have a bunch of stuff to get used to it's good to have a really nice learning curve so in JavaScript you have this like you can start doing stuff really quickly and Python you have this in a lot of functional languages you don't on day one you get smacked with a lot of details a lot of intense sounding stuff and is it possible to make progress and be productive without learning all that on the first day so the second one is communication so maybe we have something good but are we able to tell people that in a convincing way I think right now we don't do all that that was that one I have a lot to say about finally we have we have culture so so what does the community like focus on what do they find important so you'll notice so far I haven't talked about anything strictly technical this is all sort of community cultural touches on documentation but it's going to impact the technical decisions ending and I think this is also stuff that can be designed this is something you can think about and do a better or worse job at so the last two one of the last points is usage driven design so based on these sort of foundational things how what does it mean to add a feature and finally we have to link so how can we do a really good job of making great tools so ok let's get into this so gradual learning so this is something where I think it needs to be designed into the language and libraries to really work so you can design the language such that as someone's get started and gets productive slowly they realize these concepts in a way that builds upon each other in a way that works for worse for people so a nice example of this in Elm that came out recently it's called start app so okay so this is a little startup program I have start and I give it a model a way to view that model and a way to update that model so this is just a counter that I can increment and decrement and the initial model is zero I view it so I'm generating some HTML here a div it's got a button I say what the number is and then another button and I have a way to update it so I increment it sometimes in a decrement of some times so someone can get started programming without really doing any functional programming like this isn't that far off from something like CoffeeScript you can actually get something going in there a very little time without getting hit with a ton of crazy concepts so I had a visited the WWDC conference and that guy who did a lot of Swift program and so he opened up this program and just added a reset button and like in the first couple minutes like two minutes in and he like didn't really know it was going on but like he was able to add a feature and that's amazing right he didn't have to read a tutorial he didn't have to read a paper he just like looked at the pattern added a thing in and added the feature he needed so that's a great kind of learning he's able to start doing and have the confidence to do stuff and slowly fill in the gaps so and I think this focus on gradual learning is a big part of why we're starting to see some education uses of Elm so there's a class of Chicago that was taught in Elm and they did a mix of doing front-end stuff and doing some data structure stuff but there's also one called McMaster outreach so this is a program for 4th through 6th grader or sorry fourth through eighth graders so this is a little this is the session they did so these are some kids who are writing in Elms online editor and they made spider-man someone has a question I'm sure he got it though eventually and they also have a Hall of Fame of stuff that people made so this is made by 6th grader this one's crazy a fourth grader made this like how did you even watch the movie so so you start to see like this is something that you can get up to speed with in a really nice way so the next topic is communication so this is something where I think we we can do a lot better so I want to do a little thought experiment okay you're going to hear six pitches trying to solve the same problem and essentially you're a busy person you know maybe you just your your that your a team lead you just had your first kid things are going crazy the project you're working on is is it's more people than you've managed before and you're looking around for the right way to deal with that so we hear there's this javascript liven for building user interfaces well I use JavaScript I need to build user interface that sounds sounds pretty good you can write JavaScript away you really want to that's actually exactly how I want to write JavaScript that sounds really good you can you can have a frame of our creative ambitious web app which I actually I really love this one because it like guilts you into it it's like do you want to write an unambitious one I think that one's really well done maybe you want HTML enhanced for web apps exclamation point that it's weaker I don't know if I'd look into that one but maybe you want scalable productive app development sounds kind of Java but yeah I could be into it I could I could check that out or maybe you want an advanced purely functional yeah advanced purely functional programming language it's like well do I want something advanced do I want something purely functional I have a lot of code that's not that is it programming language necessary solution to this thing so you're really not connecting with people who are looking at this thing at a fairly early stage so people who are just dancing through they don't have time to spend six months learning about the different characteristics here and why it's a good idea like there's going to look at this and say like I build user interfaces that we lost you know that we missed the we missed the the person moved on so essentially the question is like how likely you to explore the one that doesn't directly address your problem like how often do you hear a pitch that doesn't make any sense to you and then when you look into it it actually works right so the general advice I have is be direct like you want to say exactly what you're going to provide so another way it says is leave nothing to the imagination you don't want someone making for mental jumps before they understand what you're saying you want it to be an immediate comprehension so have a couple examples here and I'm going to try to not keep it chill um so one word that we use a lot is pure function so the way I'm going to do is to sort of deconstruct the word from a JavaScript perspective and then provide an alternative that I think is better so pure function I don't know what that is it implies that they're impure functions so the neither of these things are things that I have in my worldview as a JavaScript programmer so at that point some people will just move on and say that doesn't seem interesting some people will go to Wikipedia and look up what if your function is and they'll say okay I guess that kind of makes sense now at that point some people will say I don't know if that's really relevant to me and move on some smaller fraction people will say okay that might be interesting and then they look at intimate but so we took so many jumps to get to someone potentially being interesting that we're losing a lot of people so I have had a lot more success saying stateless function JavaScript programmers have state they know that it often causes issue what if you didn't have that state in a lot of your functions so it directly connects to something that happens day to day in your code and says hey what if you didn't have the problems that come from that I don't know if that's the perfect term but it's certainly an improved term one that connects to how people use stuff another phrase that people say a lot is easy to reason about so my my mom is she like to review my work so she actually like read my thesis before it was time to turn it in and she came across this phrase and she was like I don't think this is English like I think you forgot some number of words it's easy to reason about like it is not really clear what that's going to give me right like was it hard to reason about like I'm a JavaScript pervert I spend a lot of time reasoning about what my code does cuz like weird stuff can happen so another way to say this is it's easy to refactor so just connected directly to what's happening in your code do you have problems refactoring well what if it was easier and you can kind of get the take the inference steps and save the last one another one is safe we like to talk about type people like to talk about safety but safety is kind of boring right like a safe investment is like bonds no one's no one's really like bonds yeah yeah you should see my bond portfolio it's been like 2% growth it's amazing another the image of like floaties you know like so like that's that's what I think of when I think of of safe and to connect it more to code like when I write javascript code I don't think about it as safe or unsafe it's not like it's going to punch me you know it doesn't really connect with how I think about the code so we've been saying reliable in the sense that you know you get runtime errors in JavaScript so what if you had a program that didn't do that what if you had the reliability that you want so last one is monad so so this is a term that I struggled with a lot I don't know how many people like go and say that but I would say it was a good like six months to a year before I felt I really was like on board nah I won't say on board before I really understood was going on there and I think I didn't have a deep understanding for maybe a year or two more after that and when I finally did understand I was pretty upset that it wasn't actually a complex thing so there's something about this term that it it asks you to think that it's complicated right so my my experience learning it was like oh I want to print something out okay I'll use a monad well that needs category theory so should I buy a book on category theory and like I'm not learning from a professor or from someone who's used Haskell a lot like I'm just sort of going through like what would make sense here's a term that I don't know well then I should learn what it is oh it's depending on this I should learn about that and yeah Haskell person would say oh you don't need to buy a book on category theory but Haskell is saying you should write like I need to know about monads so there's a story I like to tell that sort of reveals this in a way that doesn't actually connect to people's conceived notions so let's say there's a there's a person who they have an apple in each hand they say I have an apple and have an apple how many apples do I have total and so you say to them well first you need to understand group theory so there are four laws commutativity associativity identity identity for idem potency and so you can do all these commutative operations if you follow the laws it's really cool and they see that the person is like I have an applicator and I have an apple there how many apples do have it so okay okay let's be more concrete so multiplication on integers is it is a group a rotation in 3d space around an axis is a group do you get it so you when you put it in that in that framing it sort of reveals that it's a it's a crazy way to teach addition like there's a reason we don't take that route and it may be that route works for some percentage of people who are learning but I'd say for a vast majority let's say 95% of people saying to is is a better explanation so the point I'm making here isn't that this is an unimportant concept but it's one that we emphasize very very early very very emphatically and sometimes in a way that's actually confusing so another aspect of this is often people say like the state monad the IO monad it's a very weird thing because it makes the noun monad like it's a physical thing it's like saying oh you want to add numbers just use the addition group why would you say that just add them so there are a lot of ways we can deal with this the general thrust of it is is you can essentially be very active using monadic things without ever talking about it so in JavaScript for example the promises library has a function called n so I can say here's the thing I want to do and when it's done then do this thing then do this other thing so we found it's actually really effective to say callbacks I I suspect you will be mad about this but so if we look at we have this end then function in a bunch of different libraries so in maybe for example I can say here it is here it is try to turn it to an integer and then turn into a valid month okay you can read it the first time through it's not crazy do this and then you do that and we don't have to talk about any concept to it we just say give us a maybe and give us a call back if you're successful we'll keep going if you're unsuccessful will fail so you're able to get the core concept in a way that doesn't introduce any extra stuff and so as people start seeing this in different libraries maybe they'll be interested in the general pattern but the point is you don't have to understand the general pattern to be get up to speed and use this kind of thing you call it a monad of course obviously the point is you don't have to do that in the first day right like when you want to know the general pattern of addition and multiplication and rotation in 3d space around axis he called it a group but that's what it is but the point is you don't have to talk about that superplex note on communication which is about obvious names I really like obvious names I was at Microsoft and briefly and everything had a three-letter abbreviation so there was a joke that like tio everything was a TL a three-letter abbreviation so they'd abbreviated so you know we try to just like be very minimal so the tool for building things is L make the tool for packaging things is a package the tool for LM HTML is or sorry that's over HTML is M HTML like can anyone guess what L markdown does like it helps you do markdown so just like making it so there's no extra steps that you have to take is a really important goal for me okay next is culture so this one I think was a cool realization that I I was running to meet up in San Francisco and the setup was someone would do a talk a couple people would show up maybe like 20 25 people would show up and generally was a pretty like elite group of people so people who had PhDs about some sort of functional programming topic so essentially when you do like there's a person talking and a bunch of people listening you get like a group of people who are relatively elite and you try to make them more elite so I met this person who was running a meet-up called Dame's making games and the way it was set up was as a hackathon people show up they pair program together they work on a concrete project so they say today's focus is a side-scrolling game and let's focus on that and so I started trying that out for the Elm meetup in San Francisco and the makeup of the attendees changed dramatically right so it was people who are totally new to Elm it was people who were interested in using at work people who are making packages to do front-end work so just by sort of changing the focus of the meetup you change the makeup of the community right so essentially by doing that I'm sending a message to people who are interested in using at home and that Elm is interested in being used as well so I think that was actually a really interesting technique so another example of this is this culture of like just getting out there and making stuff is there's a company called no red ink in San Francisco and they recently started using a home in production and essentially the way they got it started was an engineer decided like I'm gonna do this and he did it like a lot of times you get blocked on on smaller issues but it's important to sort of see like if you go if you decide to do it it's not it's not that difficult so another one is time to the time-travelling debugger a lot of people think I made this it's which I didn't so if you haven't seen it before Oh ten ton ton so we've got a little more in here and he can hop around now the interesting thing is that you can pause and go back in time and then you can change your program and like different things happen and you can also attract what's going on so this was a guy named Lazlo Pandey who was just interested in debugging how can we do this in a really cool way and he decided to like go and give it a try and when I first saw the demo like I didn't really understand what he'd been talking about and then he showed me the thing and I was like okay this is a big deal this is cool and so this culture just like go out there and make something useful I think has been really guys on that way one final piece is a style guide so a lot of people will say like oh those ml languages are hard to and what they're saying in fact is those people who use ML languages write code that's hard to read so it's not quite the same thing it's not an inherent fact about an ml language or it's that there's a coding style that isn't super professional that's very very common so as a quick example of this we have two different ways so the top is what I recommend and we took a lot of lessons from Python here actually so you can do certain layout things so in this one we always have two spaces between top-level deficits this is something that Python does it lets you chunk functions in a much easier way we also say always bring things down on a new line so that you can sort of visually see things in a nicer way and the goal here is like how can we have code that is going to last for five years or ten years that when you go do a blame on some change you're going to actually point to something real and a lot of code that I've seen on the internet in some languages looks more like this like it's much more compact it's easier to fit on a slide for a presentation and it's easier to fit in the two columns of a academic paper but it has problems right so if I ever need to add another case that's longer do I move all of these do I leave them if this case becomes really long I have to move it down but do I move all of them down I'm just creating a maintenance problem for myself that didn't need to exist and so part of what I want to make a value of elm is we're writing code for like real use in the world and so we need to have a professional style the last point is I have a guide for designing packages which is just a set of best practices but essentially how can we help people make really great stuff okay so finally we'll get to a more technical aspect of this so usage driven design so what that means to me is start with the minimum viable solution something that will work and maybe it's not enough but maybe will be we don't know and from there see if there are any concrete issues in practice if so bring that information back in and either update your solution make it a little bit more powerful what's been interesting is that the minimal viable solutions often enough so we have a couple examples of this where we've gotten very nice results from keeping things simple so one example of this is static signal so if you're not super familiar without my I don't know if this will make a ton of sense but essentially values flow through your program in a particular way and in Elm you can't reconfigure that flow and so folks who had been working on frv we're very very skeptical they're like how can you make a interactive list a dynamic list where they're stateful elements and so like how could you make a list of counters where you can add and remove counters something like this this is also on the time-travelling debugger so you can go back but so how can we do something like that and so I essentially made the wager of we could add something complicated or we could see if this actually can be solved with the minimal solution and so what ended up happening is this turned into the Elm architecture so there's a nice pattern that you can use to structure your own programs that's gives you modulated it gives you testability it's very easy to stamp out and we're starting to see it being sort of ported over to closure script and react code perhaps sometimes that's co invention sometimes it's people saying hey I saw this cool thing let's do it here but what that means is we're able to start with a very simple step so this is similar to the counter that I was showing before I have a model oh sorry which is an integer I have a way to increment it and decrement it and I have a way to view it and I've wrapped this up in a module so I can reuse it as many times as I want so when I create a list of counters I just import counter and then I use those functions so I can initialize it I can update it and I can view it and all of this is just reusing that code that I wrote before so now when I add features to counter this code doesn't need to know what's happening there I just have a way to update it and view it so you get this very nice modularity and I don't think we would have ended up with that solution how do we started with what was the more complex thing that sort of was the generally agreed upon way of doing things another example of this that's I already regret putting this in here so at this moment Elm doesn't have type classes so this is something that's controversial some people so for JavaScript programmers this is a feature people love this for Haskell programmers this is a travesty this is terrible I can't believe it how could how's it even possible so part of this is that a language exists over 20 or 30 years and when you release a feature is also part of the feature right so if you add a feature in the first year the whole culture that grows around it is going to use that if you add it in the 15th year that whole community that you built will have a way of doing things and you introduced an advanced feature for advanced users so you can totally change that usage and practice by thinking about timing so one interesting result that's come from this so far is how we do our JSON parsing so this was something we weren't really sure how it was going to look but oops so this is how we represent our documentation on the documentation website so I have documentation has name comment and then all the values and such and the way we get that of JSON is with this decoder so I say hey there's a name field it's a string there's a comment field it has a string there's a bunch of values and that's a list of that actually there's aliases and that's a list of alias so let's look at what alias is that's also a decoder and it has certain fields they have certain values so you're able to sort of build up these JSON decoders in a really nice explicit way and that's not tied to any particular type I can make five of these for four documents maybe there are different errors of documents like I change the format at some point and I need to have a decoder for both of those it makes that really simple and you might say okay well I wouldn't I'd rather not write this code so that doesn't actually need type classes this is something that you could perhaps generate based on the type declaration so you find yourself in a situation where you actually end up with a pretty simple solution that you wouldn't have seen if you had a fancier tool in your tool kit so the overall observation here is that simpler foundation produces simpler code in practice and that I think is a really valuable thing and if you're going to give away simplicity you better be doing it for a very good reason that doesn't mean that you can't but you should at least know what the trade-off is that you're making so the final thing is tooling so because we have sort of all these invariants about type functional language so elm for example is immutable we have managed effects so effects aren't just happening arbitrary we can use that to create unique and delightful experiences stuff that couldn't be created by some other project so so elm is competing with languages like dart or typescript where they have a team of 20 or 50 people and I can't compete like even if even if someone's 10x that's 20 and 50 X no one no one even no one even talks about that so the way that you can be competitive is to design things that just can't be done in those languages at all so one example of that is a time travel debugger which we saw another example is automatic Smet semantic versioning enforcement so this is something that I don't know if a lot of people know about so let's say a new version of LM HTML comes out and it's a major change and you want to know what happened so we can run diff and it'll say hey these two things were added and we changed call span to dick and int Andros been ticking it so what happened here is someone read the spec more carefully than me and realized that in those particular cases you can't give four pixels or 4% you really have to give a number so you can actually look what exactly changed and so this can be produced at any point so when someone's going to release a package we run this and say hey it looks like you added or removed such-and-such and we can say exactly this is a major change in some minor changes the patch change and that means every package that is released follows these rules and maybe that's feasible in some languages but if we're competing with JavaScript this is a this is really nice thing and there are a lot of fairly well known cases in Java so we're a big project we'll do a patch release or a minor release release that breaks a lot of stuff and as well it wasn't really that big a deal so I didn't but you violated everyone's constraints and their builds are broken and they can't push the production so this rules that kind of case out another thing that we did recently is friendly error messages so sometimes people say I don't like using these type languages those error messages or pain and the realization here is like maybe they are painful maybe maybe we can make them better in certain ways so the way this ended up looking is we tried to think about what would help the user the most so on the Left we have a little code snippet and on the right we have the error that is happening there and so we get the little red underline list doesn't expose nap maybe you want one of these other things so it's very explicit about what's going wrong there another example of this is oh yeah this one's this one's great the first argument to the function has an unexpected type looks like the record is missing the field if you look at the program we're giving Herman to is over 50 and trying to get his age but he doesn't have an age so we directly identified in a way that a person can read what's going on yeah so essentially by focusing on sort of the user experience of these error messages we can get a lot a better result and so the hope here is this is a work in progress and the hope is that we can get to a point where these error messages actually start to feel good we can get to a point where it's just helpful I am writing a program and it says hey check out this line something that this particular thing is going wrong here and I think it's conceivable to change the relationship people have with a compiler from adversary to assistant right so instead of the relationship being like hey check out this code know what if I mess with this how about this other thing no okay this yep and then and then maybe it crashes anyway if you're if you're using Java and you have a nullpointerexception to something that's more like hey here's this program you shouldn't you should change this and avoid a crash that way so I think that's a long-term process but I think we should think about trying to move in that direction another thing is the startup experience of using Elm so I want people to like accidentally learn how if they come to the website so I have all these examples and so like the hope is that you can click on one say I'm interested in that and just see how that codes working directly and one nice thing here is that we have little hints so you can go read about what's going on down so if you want to know what a div is you can go look at I think that will start to turn into more advanced editors and IDs and such but having that experience really helps you will get started in a quick way this one will be interesting so based on the design of Elm we can be faster than JavaScript like from a like from a theoretical foundation so this is a really huge engineering project but this is something that if we're able to achieve work this is a huge benefit one thing javascript promoters really love is performance so when asm.js came out people are like when you're going to be compiling to that you need a garbage collector and then when a web assembly comes out there okay this is how about yeah can you use that you need a garbage collector so I suspect we'll eventually have one um and we'll be able to actually deliver on that but the message here is that like invariants are a most competitive advantage if we can provide experiences that you can't get anywhere else that people haven't seen before that are delightful for people then I think we have a much better chance of being the the next chunk of programming history so that's sort of the outline of user focused design and out and hopefully that's going to help us be an inch green any questions something that people really like about using javascript for building their client applications is that they can use JavaScript on the client and the server and then get like these at server-side rendered locations using the same logic and is that is is having elm run on the server a thing that yes I think it's likely to happen in the next release so essentially I wanted to focus on a clearer neesh before expanding out too far like I felt if you have a really broad focus your going to do a lot of things poorly but we're at a point now where I think we can start running on node and the long term hope would be that just be running compiling to assembly and running much much faster than having different sort of having better support for concurrency and parallelism and such but that's coming so there are different theories about what programming like adoption probing language adoption follows some people think that it's you know based on killer apps and people think it's based on features what if it is really entirely random I would say that observational II it does seem to be kind of random if that's the case it's not going to hurt to to operate under a different theory right right so trying real hard to think through what it might be and if it does end up being random this this won't hurt but another part of this is that there are sort of different trajectories for languages that have been successful so you have the sort of big like languages from corporations and for a long time that was the only way you would have the resources to make a language so like C and Java but you also have sort of languages that got started out of like some person working on it so Ruby and Python or sort of examples of that so I try to Scala enclosure as well so I try to look at those to see what techniques might have been influential in making that in making that happen but maybe it's random in which case like yeah how do I let the the guidelines you describe say whether you you make these choices you know say introducing your concept or try to reuse the existing concepts and so on whether it is helpful or say gradual learning is does this work in only in San Francisco or would it work also in the communities elsewhere so how do you know whether the choice you made was supposed to write one so I feel like San Francisco is actually a more it's a tougher City for typed functional programming it's I think it's true on the East Coast you you have a lot of it and part of that's because of the universities that like what the professor's particularly loyalties are to so on the east coast of the United States you get a lot of typed functional stuff in Europe you get a lot on the west coast not really as much so I try to just ask people very aggressively what how things are going and like what their background is and and such but it's hard to I would be surprised if there was an advantage it in San Francisco but that's a place where the thought experiment about having six different pitches in San Francisco it's like you have 80 different pitches and they all have a meet-up tonight and you have to like and you're just like I don't know so it's it's it's a San Francisco is tough Oh when Zell I'm going to have macros just just kidding do you have any data on the or some examples of the complexity of applications that are being built in elm right now like Oh Lord just one like so that's probably the folks at no red ink so the particular part that they did in oh so it's helping people learn grammar so the example that they show is a they're helping people learn passive voice and active voice and apparently people answer 2.5 million questions a day on that chunk of code I don't know how huge that code bases but we're it's not like we've we've got like JavaScript scale or tens of thousands hundreds of thousands of blind projects yet yeah so a lot of the things you mentioned seem to make a lot of sense especially in the context of elm but they also that trade-offs with a lot of the of the decisions that you've made that as I said makes sense in the context of elm but you also seem to be suggesting to the general functional programming community and I'm wondering whether and some of those lessons I think we really should learn but I'm wondering whether it isn't so for instance losing the connection in our terminology with academia seems like it's a trade off or not having typed classes and I'm wondering whether instead of making those trade offs we can't just have you be the sort of you know elm be the gateway drug until you do all those things and say I'll go try out all the other functional programming languages afterwards so anyway that that's yeah I think that's plausible uh the point I want to make here isn't that all ml family images need to be making these decisions but starting from like who is your user exactly how can I cater them in particular how can I mess set up my messaging so people know what they're getting themselves into so my experience has been in some communities there's disagreement about like is this a research tool is this a way to make products is this and so that can be quite confusing but the answer might be the actual user of that language is defined in a different way and for that user you need to think about different things so I wouldn't say like oh do all this stuff in high school like I don't think that's a good idea this is that kind of what it's what is the production usage of right now are there any like real-world large applications built with it so we have I know three companies definitely that are using it so one is this company Tarun Cisco one is called circuit hub and they're doing some diagram rendering it with it and there's a German company who's who's using for some internal tools but we haven't gotten a like a massive a print in it yet in production so you're working at Prezi they're not using element production going to they are going to it's a more complicated story than I then maybe I want to share but essentially we're in the process of doing a rewrite from flash to JavaScript and when you're doing a big rewrite lots of things are complicated besides like the languages involved so there's lots of factors there and I think it's going to be some more months but I think it's it's going to happen the other questions phil has a question it's kind of an honor one of the big factors in language adoption and learning is familiarity it's not just that it's easier to learn because of the context people know what choices did you made make in the design of Elm to make it familiar like something else that's the large extent why Java and JavaScript succeeded because they looked like the thing that came before them so one I can give one example in one counterexample so one example of trying to make things look familiar is we have a concept of tasks which looks very much like promises in JavaScript and so you sort of have this one-to-one mapping where hey you know promises we've got tasks API is quite similar and that's filling the role of the i/o monad without introducing that sort of conceptual world so an example where I I think we're I don't really know what the answer is but so I went with syntax highly inspired by Haskell and Oh Campbell and for a lot of people to like ah this is crazy and it's not clear to me what the right solution is there because if I look five years down it's the right choice how it is if I look at today maybe there's some benefit to making things a little bit more familiar looking so I'll share an interesting experience on that so I've had people come up to me after talk and say hey that syntax looks a lot like Python was that an influence and I was like no but I'm so happy that you think that so I think the style guide that we set up for home is going to help a lot with the like perception of craziness so for people who are coming from stuff like CoffeeScript it's not that wild in terms of syntax so I'm making a bet that we can get away with certain things especially if the overall message is like it's really important to make things easy to learn you"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Letâ€™s Be Mainstream",
        "story": []
      },
      "date": 1697459555495
    },
    {
      "id": "5e29400f6fcd0c71",
      "type": "add",
      "item": {
        "type": "video",
        "id": "5e29400f6fcd0c71",
        "text": "YOUTUBE oYk8CKH7OhE\n[[Evan Czaplicki]] - Let's be mainstream! User focused design in Elm - Curry On"
      },
      "attribution": {
        "page": "2023-10-16"
      },
      "date": 1697459559496
    },
    {
      "item": {
        "type": "factory",
        "id": "badddde0b65d4b81"
      },
      "id": "badddde0b65d4b81",
      "type": "add",
      "after": "5e29400f6fcd0c71",
      "date": 1697459565126
    },
    {
      "type": "edit",
      "id": "badddde0b65d4b81",
      "item": {
        "type": "paragraph",
        "id": "badddde0b65d4b81",
        "text": "hi sign and Evan chip and depending on where you're from you might say it different so I designed this programming language called Elm that's focused on front-end programming so doing stuff in browser interactive applications games this kind of thing and so I'm sort of coming from a perspective of typed functional programming and one thing I think about a lot is this question like if typed functional programming is so great how come nobody uses it and and I think this is a question that people sort of outside this community ask and I think it's a reasonable question for them just like as a filter right like obscure things aren't always amazing and it's something that I don't think we ask within that community enough right why is it that we don't have more users if if it is true that we really are doing something really great so the rough theory is that we're engaged in a decent amount of self-destructive behavior so I kind of want to talk about sort of how Elm sort of how I think about these things in how I only tries to do do a better job dealing with those things and I also I don't I don't want to be like a mean mean guy so I tried to frame things in a positive way and not like be too mean or anything like this is all meant as a as a how can we do better kind of thing so for me I think it's valuable to sort of think about like the history of programming in trying to figure out what's going to come next so this one's actually the history program as seen from JavaScript so if you if you try to do a I tried to do a more realistic history it just broke down so what does history looked like from from like JavaScript world so in the beginning there was assembly and it was it was hard but somehow people wrote a super Mario in it so that was pretty cool but we got to this crisis point where things just like we're not working out anymore so like Along Came see and now we have the structured programming approach and like okay that's not exactly high street okay but this is a scene from Johnson so si comes along and suddenly we're not doing this really low-level thing we're doing like a much higher level thing and that's true for many many years and at a certain point we get to this other crisis point where it's like ah and Java comes along and we're like oh great this is amazing and eventually we get into JavaScript and the other sort of roughly arranged timewise like that it doesn't exactly line up timewise but from the perspective of JavaScript you sort of say like well before us there was Java and before then they was seeing it's kind of a true true enough in fact it's true from that perspective so it might as well be true so when we look back the C and Java and JavaScript rivers can all look at assembly I was maintained a bowling night I couldn't write this in a portable way I couldn't have people read this easily so we solved that when we went to C and now the Java and JavaScript programs like I could see no way o memory man how could they even deal with that in that crazy language back in the day and so that's what it was the ingredients of this crisis point that that it was perceived how we got the job and when JavaScript looks a Java they're like how do people deal with all those freaking types like how can you get anything done at all and so I have a feeling that we're at another one of these crisis points where the issue again is maintainability so when you talk to companies that have let's say 50,000 100,000 lines of JavaScript they're there in this place where when they add a new feature they're going to break 3 so one way I think it is like Facebook used to say like move fast and break things and I think it's sort of shifted to like move slow and break things so what I'm getting at though is like at a large enough scale people are trying to see issues in practice and that's not to say that there's that this isn't a valuable place to be but we're starting to get these like rough spots so the question you might ask then is like well okay so what's this next era going to be what's the next part of this history and so maybe that's something functional maybe it's way crazier than we imagined and it's a stack-based language or a prologue right like ooh something insane happens maybe types won't be involved maybe not so like a lisp or ml maybe it'll be something gradually typed these are all viable and different degrees right I add this prologue and stack-based because you know these are small communities that people really love a lot and maybe they're great right like they say they're great should I believe them I don't know so for me I think of well a typed functional language is going to address a lot of these issues we can look back at history and say we got the memory management under control we got all those freaking types under control in the sense that if you can infer all that information you get a lot of the benefits without the like really heavy syntax that a lot of JavaScript programmers look at no like ah so and then maintainability as well so the problem with that is that in 1973 like and they'll like was introduced okay so this is huh the this is a one year after seat si was making send me to but for some reason I didn't work out I don't sew something mysterious happened so we have another chance 1990 standard ml came out so this is actually five years before Java Java was 1995 so we could have gone that route but for some reason didn't happen and in 1996 we had oh camel this is one year after Java it has objects like it's got it is got at all like what's the problem so in all of these situations we were sort of addressing the core concerns but in a way that for some reason didn't connect and didn't make it big so when we think about what's going to happen next I think it makes sense to ask who's going to be deciding what happens next so we've got this massive chunk of Furman programmers people who day to day are making web applications making games and we've got this tiny population of people using type function languages now this isn't to scale okay I think I don't know how small that red dot should be but so I to try to put in perspective Oracle says that there are 10 million Java programmers and if I try to do some estimation I can say ok so maybe they're like two hundred thousand scallop programmers maybe maybe more maybe less and and then how many Haskell programmers are so like we're talking about orders of magnitude the difference here like it said they're the number of jQuery users is like way huger than the number of people who are doing these functional languages I think I don't know so if this giant group of functional front-end programmers are going to be deciding we should understand what they want in this next error of programming so I think there are two sort of main accesses that we can think about that are helpful here so we have JavaScript and the XS here usable and what I mean by usable is the ability to use it so so I sort of defined that as like the time it takes to get from a novice level to actually a product that you can show your friends and be like hey check us out so I wanted to demo something real quick so this is Google guys I'm using javascript like the time from novice to getting something done was like it's unreal it's crazy I don't think anything has really matched that and like if this was a competitive market and this would probably be like abusive market position that it's baked in in this way but like it's really really easy to get started here and so if you are doing some kind of let's say you want to get a webpage up maybe that's a five minute or an hour long process even for someone who's a total beginner so that's a really amazing ability to use the language now the issue people having is about maintainability now I've got 50,000 lines the company I notice is successful and we're getting new users we're trying to add new features but we're having trouble doing that so another point on this map is Java right so we have much more maintainability here but the usability is down and so this isn't this is more about like the time it would take to start using Java is just longer rather than five minutes or an hour you're looking at something a little bit more and that part of that learning time part of that's getting things installed getting things set up so from the JavaScript programmers perspective like this is a no this is a no-go I mean partly friendly maintainable and usability but also partly from an emotional sort of crazy standpoint we're just like ah like that's kind of the logic of this isn't viable so what we want is to get that maintainability and either keep the usability or even improve it a bit and the direction people are taking here is gradual types you're seeing this coming out of Microsoft and Google like a lot of companies are betting in this direction so you can keep the usability profile where when you start out it's very simple and as your thing grows you can add types to it what I don't know if people are thinking about is like what is the endgame here when we have a JavaScript program that is fully typed like didn't we make Java again III don't I don't know maybe not but there's something here where I don't know if that's a quite an exciting resolution I don't know if that's what will satisfy b-but but it is addressing the main concern we get this maintainability now what a lot of JavaScript people don't realize is that this graph is actually later the you can be much less usable than then than anyone imagined what's interesting though is you can actually be way more maintainable than a lot of people think about as well so in the top right corner or top left when we have ml family language this is a like Haskell and oh camel so I can I can speak to my experience getting started with Haskell that led me to put it in this corner I'd say it was a good like year before I was like I'm good pretty good at this and like it's just not that way in another language so when you're set up takes a couple days and the learning process takes months or years potentially to get to an expert level it's making things really hard for you so the important point here though is that the levels of maintainability that are available are way higher than and people think about so what I want to do is I want to get to this magic realm where we get that level of maintainability but we have something usable we have something that like in an hour or in finding that people can get started with and be productive so the question is how do we get from here to there okay this is a trick this isn't actually the thing we want to hope it doesn't make sense to try to move these languages to this nice place because that means we're moving a really small set of users to a place that they generally don't necessarily want to go in the sense that if you make a really nice front-end programming language for people who don't do front-end programming and I don't so the thing you want to do is actually get Java Script to this and this nice place so when you focus on what a JavaScript programmer needs to get there you end up making different design decisions so this is kind of the shape of the world from as sort of as I see it so the next thing thing about is what does this mean for designing Elm so the broad category I name this is like user focused design and Elm so I know that I am designing for people who are doing front-end work and they have specific issues that they need addressed and if we're able to address them the best then will win if we're if we aren't the best I may be some random things will happen but if we can do better than we have a better chance so the sort of key design principles here our first gradual learning when you have a bunch of stuff to get used to it's good to have a really nice learning curve so in JavaScript you have this like you can start doing stuff really quickly and Python you have this in a lot of functional languages you don't on day one you get smacked with a lot of details a lot of intense sounding stuff and is it possible to make progress and be productive without learning all that on the first day so the second one is communication so maybe we have something good but are we able to tell people that in a convincing way I think right now we don't do all that that was that one I have a lot to say about finally we have we have culture so so what does the community like focus on what do they find important so you'll notice so far I haven't talked about anything strictly technical this is all sort of community cultural touches on documentation but it's going to impact the technical decisions ending and I think this is also stuff that can be designed this is something you can think about and do a better or worse job at so the last two one of the last points is usage driven design so based on these sort of foundational things how what does it mean to add a feature and finally we have to link so how can we do a really good job of making great tools so ok let's get into this so gradual learning so this is something where I think it needs to be designed into the language and libraries to really work so you can design the language such that as someone's get started and gets productive slowly they realize these concepts in a way that builds upon each other in a way that works for worse for people so a nice example of this in Elm that came out recently it's called start app so okay so this is a little startup program I have start and I give it a model a way to view that model and a way to update that model so this is just a counter that I can increment and decrement and the initial model is zero I view it so I'm generating some HTML here a div it's got a button I say what the number is and then another button and I have a way to update it so I increment it sometimes in a decrement of some times so someone can get started programming without really doing any functional programming like this isn't that far off from something like CoffeeScript you can actually get something going in there a very little time without getting hit with a ton of crazy concepts so I had a visited the WWDC conference and that guy who did a lot of Swift program and so he opened up this program and just added a reset button and like in the first couple minutes like two minutes in and he like didn't really know it was going on but like he was able to add a feature and that's amazing right he didn't have to read a tutorial he didn't have to read a paper he just like looked at the pattern added a thing in and added the feature he needed so that's a great kind of learning he's able to start doing and have the confidence to do stuff and slowly fill in the gaps so and I think this focus on gradual learning is a big part of why we're starting to see some education uses of Elm so there's a class of Chicago that was taught in Elm and they did a mix of doing front-end stuff and doing some data structure stuff but there's also one called McMaster outreach so this is a program for 4th through 6th grader or sorry fourth through eighth graders so this is a little this is the session they did so these are some kids who are writing in Elms online editor and they made spider-man someone has a question I'm sure he got it though eventually and they also have a Hall of Fame of stuff that people made so this is made by 6th grader this one's crazy a fourth grader made this like how did you even watch the movie so so you start to see like this is something that you can get up to speed with in a really nice way so the next topic is communication so this is something where I think we we can do a lot better so I want to do a little thought experiment okay you're going to hear six pitches trying to solve the same problem and essentially you're a busy person you know maybe you just your your that your a team lead you just had your first kid things are going crazy the project you're working on is is it's more people than you've managed before and you're looking around for the right way to deal with that so we hear there's this javascript liven for building user interfaces well I use JavaScript I need to build user interface that sounds sounds pretty good you can write JavaScript away you really want to that's actually exactly how I want to write JavaScript that sounds really good you can you can have a frame of our creative ambitious web app which I actually I really love this one because it like guilts you into it it's like do you want to write an unambitious one I think that one's really well done maybe you want HTML enhanced for web apps exclamation point that it's weaker I don't know if I'd look into that one but maybe you want scalable productive app development sounds kind of Java but yeah I could be into it I could I could check that out or maybe you want an advanced purely functional yeah advanced purely functional programming language it's like well do I want something advanced do I want something purely functional I have a lot of code that's not that is it programming language necessary solution to this thing so you're really not connecting with people who are looking at this thing at a fairly early stage so people who are just dancing through they don't have time to spend six months learning about the different characteristics here and why it's a good idea like there's going to look at this and say like I build user interfaces that we lost you know that we missed the we missed the the person moved on so essentially the question is like how likely you to explore the one that doesn't directly address your problem like how often do you hear a pitch that doesn't make any sense to you and then when you look into it it actually works right so the general advice I have is be direct like you want to say exactly what you're going to provide so another way it says is leave nothing to the imagination you don't want someone making for mental jumps before they understand what you're saying you want it to be an immediate comprehension so have a couple examples here and I'm going to try to not keep it chill um so one word that we use a lot is pure function so the way I'm going to do is to sort of deconstruct the word from a JavaScript perspective and then provide an alternative that I think is better so pure function I don't know what that is it implies that they're impure functions so the neither of these things are things that I have in my worldview as a JavaScript programmer so at that point some people will just move on and say that doesn't seem interesting some people will go to Wikipedia and look up what if your function is and they'll say okay I guess that kind of makes sense now at that point some people will say I don't know if that's really relevant to me and move on some smaller fraction people will say okay that might be interesting and then they look at intimate but so we took so many jumps to get to someone potentially being interesting that we're losing a lot of people so I have had a lot more success saying stateless function JavaScript programmers have state they know that it often causes issue what if you didn't have that state in a lot of your functions so it directly connects to something that happens day to day in your code and says hey what if you didn't have the problems that come from that I don't know if that's the perfect term but it's certainly an improved term one that connects to how people use stuff another phrase that people say a lot is easy to reason about so my my mom is she like to review my work so she actually like read my thesis before it was time to turn it in and she came across this phrase and she was like I don't think this is English like I think you forgot some number of words it's easy to reason about like it is not really clear what that's going to give me right like was it hard to reason about like I'm a JavaScript pervert I spend a lot of time reasoning about what my code does cuz like weird stuff can happen so another way to say this is it's easy to refactor so just connected directly to what's happening in your code do you have problems refactoring well what if it was easier and you can kind of get the take the inference steps and save the last one another one is safe we like to talk about type people like to talk about safety but safety is kind of boring right like a safe investment is like bonds no one's no one's really like bonds yeah yeah you should see my bond portfolio it's been like 2% growth it's amazing another the image of like floaties you know like so like that's that's what I think of when I think of of safe and to connect it more to code like when I write javascript code I don't think about it as safe or unsafe it's not like it's going to punch me you know it doesn't really connect with how I think about the code so we've been saying reliable in the sense that you know you get runtime errors in JavaScript so what if you had a program that didn't do that what if you had the reliability that you want so last one is monad so so this is a term that I struggled with a lot I don't know how many people like go and say that but I would say it was a good like six months to a year before I felt I really was like on board nah I won't say on board before I really understood was going on there and I think I didn't have a deep understanding for maybe a year or two more after that and when I finally did understand I was pretty upset that it wasn't actually a complex thing so there's something about this term that it it asks you to think that it's complicated right so my my experience learning it was like oh I want to print something out okay I'll use a monad well that needs category theory so should I buy a book on category theory and like I'm not learning from a professor or from someone who's used Haskell a lot like I'm just sort of going through like what would make sense here's a term that I don't know well then I should learn what it is oh it's depending on this I should learn about that and yeah Haskell person would say oh you don't need to buy a book on category theory but Haskell is saying you should write like I need to know about monads so there's a story I like to tell that sort of reveals this in a way that doesn't actually connect to people's conceived notions so let's say there's a there's a person who they have an apple in each hand they say I have an apple and have an apple how many apples do I have total and so you say to them well first you need to understand group theory so there are four laws commutativity associativity identity identity for idem potency and so you can do all these commutative operations if you follow the laws it's really cool and they see that the person is like I have an applicator and I have an apple there how many apples do have it so okay okay let's be more concrete so multiplication on integers is it is a group a rotation in 3d space around an axis is a group do you get it so you when you put it in that in that framing it sort of reveals that it's a it's a crazy way to teach addition like there's a reason we don't take that route and it may be that route works for some percentage of people who are learning but I'd say for a vast majority let's say 95% of people saying to is is a better explanation so the point I'm making here isn't that this is an unimportant concept but it's one that we emphasize very very early very very emphatically and sometimes in a way that's actually confusing so another aspect of this is often people say like the state monad the IO monad it's a very weird thing because it makes the noun monad like it's a physical thing it's like saying oh you want to add numbers just use the addition group why would you say that just add them so there are a lot of ways we can deal with this the general thrust of it is is you can essentially be very active using monadic things without ever talking about it so in JavaScript for example the promises library has a function called n so I can say here's the thing I want to do and when it's done then do this thing then do this other thing so we found it's actually really effective to say callbacks I I suspect you will be mad about this but so if we look at we have this end then function in a bunch of different libraries so in maybe for example I can say here it is here it is try to turn it to an integer and then turn into a valid month okay you can read it the first time through it's not crazy do this and then you do that and we don't have to talk about any concept to it we just say give us a maybe and give us a call back if you're successful we'll keep going if you're unsuccessful will fail so you're able to get the core concept in a way that doesn't introduce any extra stuff and so as people start seeing this in different libraries maybe they'll be interested in the general pattern but the point is you don't have to understand the general pattern to be get up to speed and use this kind of thing you call it a monad of course obviously the point is you don't have to do that in the first day right like when you want to know the general pattern of addition and multiplication and rotation in 3d space around axis he called it a group but that's what it is but the point is you don't have to talk about that superplex note on communication which is about obvious names I really like obvious names I was at Microsoft and briefly and everything had a three-letter abbreviation so there was a joke that like tio everything was a TL a three-letter abbreviation so they'd abbreviated so you know we try to just like be very minimal so the tool for building things is L make the tool for packaging things is a package the tool for LM HTML is or sorry that's over HTML is M HTML like can anyone guess what L markdown does like it helps you do markdown so just like making it so there's no extra steps that you have to take is a really important goal for me okay next is culture so this one I think was a cool realization that I I was running to meet up in San Francisco and the setup was someone would do a talk a couple people would show up maybe like 20 25 people would show up and generally was a pretty like elite group of people so people who had PhDs about some sort of functional programming topic so essentially when you do like there's a person talking and a bunch of people listening you get like a group of people who are relatively elite and you try to make them more elite so I met this person who was running a meet-up called Dame's making games and the way it was set up was as a hackathon people show up they pair program together they work on a concrete project so they say today's focus is a side-scrolling game and let's focus on that and so I started trying that out for the Elm meetup in San Francisco and the makeup of the attendees changed dramatically right so it was people who are totally new to Elm it was people who were interested in using at work people who are making packages to do front-end work so just by sort of changing the focus of the meetup you change the makeup of the community right so essentially by doing that I'm sending a message to people who are interested in using at home and that Elm is interested in being used as well so I think that was actually a really interesting technique so another example of this is this culture of like just getting out there and making stuff is there's a company called no red ink in San Francisco and they recently started using a home in production and essentially the way they got it started was an engineer decided like I'm gonna do this and he did it like a lot of times you get blocked on on smaller issues but it's important to sort of see like if you go if you decide to do it it's not it's not that difficult so another one is time to the time-travelling debugger a lot of people think I made this it's which I didn't so if you haven't seen it before Oh ten ton ton so we've got a little more in here and he can hop around now the interesting thing is that you can pause and go back in time and then you can change your program and like different things happen and you can also attract what's going on so this was a guy named Lazlo Pandey who was just interested in debugging how can we do this in a really cool way and he decided to like go and give it a try and when I first saw the demo like I didn't really understand what he'd been talking about and then he showed me the thing and I was like okay this is a big deal this is cool and so this culture just like go out there and make something useful I think has been really guys on that way one final piece is a style guide so a lot of people will say like oh those ml languages are hard to and what they're saying in fact is those people who use ML languages write code that's hard to read so it's not quite the same thing it's not an inherent fact about an ml language or it's that there's a coding style that isn't super professional that's very very common so as a quick example of this we have two different ways so the top is what I recommend and we took a lot of lessons from Python here actually so you can do certain layout things so in this one we always have two spaces between top-level deficits this is something that Python does it lets you chunk functions in a much easier way we also say always bring things down on a new line so that you can sort of visually see things in a nicer way and the goal here is like how can we have code that is going to last for five years or ten years that when you go do a blame on some change you're going to actually point to something real and a lot of code that I've seen on the internet in some languages looks more like this like it's much more compact it's easier to fit on a slide for a presentation and it's easier to fit in the two columns of a academic paper but it has problems right so if I ever need to add another case that's longer do I move all of these do I leave them if this case becomes really long I have to move it down but do I move all of them down I'm just creating a maintenance problem for myself that didn't need to exist and so part of what I want to make a value of elm is we're writing code for like real use in the world and so we need to have a professional style the last point is I have a guide for designing packages which is just a set of best practices but essentially how can we help people make really great stuff okay so finally we'll get to a more technical aspect of this so usage driven design so what that means to me is start with the minimum viable solution something that will work and maybe it's not enough but maybe will be we don't know and from there see if there are any concrete issues in practice if so bring that information back in and either update your solution make it a little bit more powerful what's been interesting is that the minimal viable solutions often enough so we have a couple examples of this where we've gotten very nice results from keeping things simple so one example of this is static signal so if you're not super familiar without my I don't know if this will make a ton of sense but essentially values flow through your program in a particular way and in Elm you can't reconfigure that flow and so folks who had been working on frv we're very very skeptical they're like how can you make a interactive list a dynamic list where they're stateful elements and so like how could you make a list of counters where you can add and remove counters something like this this is also on the time-travelling debugger so you can go back but so how can we do something like that and so I essentially made the wager of we could add something complicated or we could see if this actually can be solved with the minimal solution and so what ended up happening is this turned into the Elm architecture so there's a nice pattern that you can use to structure your own programs that's gives you modulated it gives you testability it's very easy to stamp out and we're starting to see it being sort of ported over to closure script and react code perhaps sometimes that's co invention sometimes it's people saying hey I saw this cool thing let's do it here but what that means is we're able to start with a very simple step so this is similar to the counter that I was showing before I have a model oh sorry which is an integer I have a way to increment it and decrement it and I have a way to view it and I've wrapped this up in a module so I can reuse it as many times as I want so when I create a list of counters I just import counter and then I use those functions so I can initialize it I can update it and I can view it and all of this is just reusing that code that I wrote before so now when I add features to counter this code doesn't need to know what's happening there I just have a way to update it and view it so you get this very nice modularity and I don't think we would have ended up with that solution how do we started with what was the more complex thing that sort of was the generally agreed upon way of doing things another example of this that's I already regret putting this in here so at this moment Elm doesn't have type classes so this is something that's controversial some people so for JavaScript programmers this is a feature people love this for Haskell programmers this is a travesty this is terrible I can't believe it how could how's it even possible so part of this is that a language exists over 20 or 30 years and when you release a feature is also part of the feature right so if you add a feature in the first year the whole culture that grows around it is going to use that if you add it in the 15th year that whole community that you built will have a way of doing things and you introduced an advanced feature for advanced users so you can totally change that usage and practice by thinking about timing so one interesting result that's come from this so far is how we do our JSON parsing so this was something we weren't really sure how it was going to look but oops so this is how we represent our documentation on the documentation website so I have documentation has name comment and then all the values and such and the way we get that of JSON is with this decoder so I say hey there's a name field it's a string there's a comment field it has a string there's a bunch of values and that's a list of that actually there's aliases and that's a list of alias so let's look at what alias is that's also a decoder and it has certain fields they have certain values so you're able to sort of build up these JSON decoders in a really nice explicit way and that's not tied to any particular type I can make five of these for four documents maybe there are different errors of documents like I change the format at some point and I need to have a decoder for both of those it makes that really simple and you might say okay well I wouldn't I'd rather not write this code so that doesn't actually need type classes this is something that you could perhaps generate based on the type declaration so you find yourself in a situation where you actually end up with a pretty simple solution that you wouldn't have seen if you had a fancier tool in your tool kit so the overall observation here is that simpler foundation produces simpler code in practice and that I think is a really valuable thing and if you're going to give away simplicity you better be doing it for a very good reason that doesn't mean that you can't but you should at least know what the trade-off is that you're making so the final thing is tooling so because we have sort of all these invariants about type functional language so elm for example is immutable we have managed effects so effects aren't just happening arbitrary we can use that to create unique and delightful experiences stuff that couldn't be created by some other project so so elm is competing with languages like dart or typescript where they have a team of 20 or 50 people and I can't compete like even if even if someone's 10x that's 20 and 50 X no one no one even no one even talks about that so the way that you can be competitive is to design things that just can't be done in those languages at all so one example of that is a time travel debugger which we saw another example is automatic Smet semantic versioning enforcement so this is something that I don't know if a lot of people know about so let's say a new version of LM HTML comes out and it's a major change and you want to know what happened so we can run diff and it'll say hey these two things were added and we changed call span to dick and int Andros been ticking it so what happened here is someone read the spec more carefully than me and realized that in those particular cases you can't give four pixels or 4% you really have to give a number so you can actually look what exactly changed and so this can be produced at any point so when someone's going to release a package we run this and say hey it looks like you added or removed such-and-such and we can say exactly this is a major change in some minor changes the patch change and that means every package that is released follows these rules and maybe that's feasible in some languages but if we're competing with JavaScript this is a this is really nice thing and there are a lot of fairly well known cases in Java so we're a big project we'll do a patch release or a minor release release that breaks a lot of stuff and as well it wasn't really that big a deal so I didn't but you violated everyone's constraints and their builds are broken and they can't push the production so this rules that kind of case out another thing that we did recently is friendly error messages so sometimes people say I don't like using these type languages those error messages or pain and the realization here is like maybe they are painful maybe maybe we can make them better in certain ways so the way this ended up looking is we tried to think about what would help the user the most so on the Left we have a little code snippet and on the right we have the error that is happening there and so we get the little red underline list doesn't expose nap maybe you want one of these other things so it's very explicit about what's going wrong there another example of this is oh yeah this one's this one's great the first argument to the function has an unexpected type looks like the record is missing the field if you look at the program we're giving Herman to is over 50 and trying to get his age but he doesn't have an age so we directly identified in a way that a person can read what's going on yeah so essentially by focusing on sort of the user experience of these error messages we can get a lot a better result and so the hope here is this is a work in progress and the hope is that we can get to a point where these error messages actually start to feel good we can get to a point where it's just helpful I am writing a program and it says hey check out this line something that this particular thing is going wrong here and I think it's conceivable to change the relationship people have with a compiler from adversary to assistant right so instead of the relationship being like hey check out this code know what if I mess with this how about this other thing no okay this yep and then and then maybe it crashes anyway if you're if you're using Java and you have a nullpointerexception to something that's more like hey here's this program you shouldn't you should change this and avoid a crash that way so I think that's a long-term process but I think we should think about trying to move in that direction another thing is the startup experience of using Elm so I want people to like accidentally learn how if they come to the website so I have all these examples and so like the hope is that you can click on one say I'm interested in that and just see how that codes working directly and one nice thing here is that we have little hints so you can go read about what's going on down so if you want to know what a div is you can go look at I think that will start to turn into more advanced editors and IDs and such but having that experience really helps you will get started in a quick way this one will be interesting so based on the design of Elm we can be faster than JavaScript like from a like from a theoretical foundation so this is a really huge engineering project but this is something that if we're able to achieve work this is a huge benefit one thing javascript promoters really love is performance so when asm.js came out people are like when you're going to be compiling to that you need a garbage collector and then when a web assembly comes out there okay this is how about yeah can you use that you need a garbage collector so I suspect we'll eventually have one um and we'll be able to actually deliver on that but the message here is that like invariants are a most competitive advantage if we can provide experiences that you can't get anywhere else that people haven't seen before that are delightful for people then I think we have a much better chance of being the the next chunk of programming history so that's sort of the outline of user focused design and out and hopefully that's going to help us be an inch green any questions something that people really like about using javascript for building their client applications is that they can use JavaScript on the client and the server and then get like these at server-side rendered locations using the same logic and is that is is having elm run on the server a thing that yes I think it's likely to happen in the next release so essentially I wanted to focus on a clearer neesh before expanding out too far like I felt if you have a really broad focus your going to do a lot of things poorly but we're at a point now where I think we can start running on node and the long term hope would be that just be running compiling to assembly and running much much faster than having different sort of having better support for concurrency and parallelism and such but that's coming so there are different theories about what programming like adoption probing language adoption follows some people think that it's you know based on killer apps and people think it's based on features what if it is really entirely random I would say that observational II it does seem to be kind of random if that's the case it's not going to hurt to to operate under a different theory right right so trying real hard to think through what it might be and if it does end up being random this this won't hurt but another part of this is that there are sort of different trajectories for languages that have been successful so you have the sort of big like languages from corporations and for a long time that was the only way you would have the resources to make a language so like C and Java but you also have sort of languages that got started out of like some person working on it so Ruby and Python or sort of examples of that so I try to Scala enclosure as well so I try to look at those to see what techniques might have been influential in making that in making that happen but maybe it's random in which case like yeah how do I let the the guidelines you describe say whether you you make these choices you know say introducing your concept or try to reuse the existing concepts and so on whether it is helpful or say gradual learning is does this work in only in San Francisco or would it work also in the communities elsewhere so how do you know whether the choice you made was supposed to write one so I feel like San Francisco is actually a more it's a tougher City for typed functional programming it's I think it's true on the East Coast you you have a lot of it and part of that's because of the universities that like what the professor's particularly loyalties are to so on the east coast of the United States you get a lot of typed functional stuff in Europe you get a lot on the west coast not really as much so I try to just ask people very aggressively what how things are going and like what their background is and and such but it's hard to I would be surprised if there was an advantage it in San Francisco but that's a place where the thought experiment about having six different pitches in San Francisco it's like you have 80 different pitches and they all have a meet-up tonight and you have to like and you're just like I don't know so it's it's it's a San Francisco is tough Oh when Zell I'm going to have macros just just kidding do you have any data on the or some examples of the complexity of applications that are being built in elm right now like Oh Lord just one like so that's probably the folks at no red ink so the particular part that they did in oh so it's helping people learn grammar so the example that they show is a they're helping people learn passive voice and active voice and apparently people answer 2.5 million questions a day on that chunk of code I don't know how huge that code bases but we're it's not like we've we've got like JavaScript scale or tens of thousands hundreds of thousands of blind projects yet yeah so a lot of the things you mentioned seem to make a lot of sense especially in the context of elm but they also that trade-offs with a lot of the of the decisions that you've made that as I said makes sense in the context of elm but you also seem to be suggesting to the general functional programming community and I'm wondering whether and some of those lessons I think we really should learn but I'm wondering whether it isn't so for instance losing the connection in our terminology with academia seems like it's a trade off or not having typed classes and I'm wondering whether instead of making those trade offs we can't just have you be the sort of you know elm be the gateway drug until you do all those things and say I'll go try out all the other functional programming languages afterwards so anyway that that's yeah I think that's plausible uh the point I want to make here isn't that all ml family images need to be making these decisions but starting from like who is your user exactly how can I cater them in particular how can I mess set up my messaging so people know what they're getting themselves into so my experience has been in some communities there's disagreement about like is this a research tool is this a way to make products is this and so that can be quite confusing but the answer might be the actual user of that language is defined in a different way and for that user you need to think about different things so I wouldn't say like oh do all this stuff in high school like I don't think that's a good idea this is that kind of what it's what is the production usage of right now are there any like real-world large applications built with it so we have I know three companies definitely that are using it so one is this company Tarun Cisco one is called circuit hub and they're doing some diagram rendering it with it and there's a German company who's who's using for some internal tools but we haven't gotten a like a massive a print in it yet in production so you're working at Prezi they're not using element production going to they are going to it's a more complicated story than I then maybe I want to share but essentially we're in the process of doing a rewrite from flash to JavaScript and when you're doing a big rewrite lots of things are complicated besides like the languages involved so there's lots of factors there and I think it's going to be some more months but I think it's it's going to happen the other questions phil has a question it's kind of an honor one of the big factors in language adoption and learning is familiarity it's not just that it's easier to learn because of the context people know what choices did you made make in the design of Elm to make it familiar like something else that's the large extent why Java and JavaScript succeeded because they looked like the thing that came before them so one I can give one example in one counterexample so one example of trying to make things look familiar is we have a concept of tasks which looks very much like promises in JavaScript and so you sort of have this one-to-one mapping where hey you know promises we've got tasks API is quite similar and that's filling the role of the i/o monad without introducing that sort of conceptual world so an example where I I think we're I don't really know what the answer is but so I went with syntax highly inspired by Haskell and Oh Campbell and for a lot of people to like ah this is crazy and it's not clear to me what the right solution is there because if I look five years down it's the right choice how it is if I look at today maybe there's some benefit to making things a little bit more familiar looking so I'll share an interesting experience on that so I've had people come up to me after talk and say hey that syntax looks a lot like Python was that an influence and I was like no but I'm so happy that you think that so I think the style guide that we set up for home is going to help a lot with the like perception of craziness so for people who are coming from stuff like CoffeeScript it's not that wild in terms of syntax so I'm making a bet that we can get away with certain things especially if the overall message is like it's really important to make things easy to learn you"
      },
      "date": 1697459566428
    },
    {
      "type": "edit",
      "id": "badddde0b65d4b81",
      "item": {
        "type": "paragraph",
        "id": "badddde0b65d4b81",
        "text": "hi sign and Evan chip and depending on where you're from you might say it different so I designed this programming language called Elm that's focused on front-end programming so doing stuff in browser interactive applications games this kind of thing and so I'm sort of coming from a perspective of typed functional programming and one thing I think about a lot is this question like if typed functional programming is so great how come nobody uses it"
      },
      "date": 1697459708245
    },
    {
      "type": "add",
      "id": "1ca8005ad201ab2c",
      "item": {
        "type": "paragraph",
        "id": "1ca8005ad201ab2c",
        "text": "and and I think this is a question that people sort of outside this community ask and I think it's a reasonable question for them just like as a filter right like obscure things aren't always amazing and it's something that I don't think we ask within that community enough right why is it that we don't have more users if if it is true that we really are doing something really great so the rough theory is that we're engaged in a decent amount of self-destructive behavior so I kind of want to talk about sort of how Elm sort of how I think about these things in how I only tries to do do a better job dealing with those things and I also I don't I don't want to be like a mean mean guy so I tried to frame things in a positive way and not like be too mean or anything like this is all meant as a as a how can we do better kind of thing so for me I think it's valuable to sort of think about like the history of programming in trying to figure out what's going to come next so this one's actually the history program as seen from JavaScript so if you if you try to do a I tried to do a more realistic history it just broke down so what does history looked like from from like JavaScript world so in the beginning there was assembly and it was it was hard but somehow people wrote a super Mario in it so that was pretty cool but we got to this crisis point where things just like we're not working out anymore so like Along Came see and now we have the structured programming approach and like okay that's not exactly high street okay but this is a scene from Johnson so si comes along and suddenly we're not doing this really low-level thing we're doing like a much higher level thing and that's true for many many years and at a certain point we get to this other crisis point where it's like ah and Java comes along and we're like oh great this is amazing and eventually we get into JavaScript and the other sort of roughly arranged timewise like that it doesn't exactly line up timewise but from the perspective of JavaScript you sort of say like well before us there was Java and before then they was seeing it's kind of a true true enough in fact it's true from that perspective so it might as well be true so when we look back the C and Java and JavaScript rivers can all look at assembly I was maintained a bowling night I couldn't write this in a portable way I couldn't have people read this easily so we solved that when we went to C and now the Java and JavaScript programs like I could see no way o memory man how could they even deal with that in that crazy language back in the day and so that's what it was the ingredients of this crisis point that that it was perceived how we got the job and when JavaScript looks a Java they're like how do people deal with all those freaking types like how can you get anything done at all and so I have a feeling that we're at another one of these crisis points where the issue again is maintainability so when you talk to companies that have let's say 50,000 100,000 lines of JavaScript they're there in this place where when they add a new feature they're going to break 3 so one way I think it is like Facebook used to say like move fast and break things and I think it's sort of shifted to like move slow and break things so what I'm getting at though is like at a large enough scale people are trying to see issues in practice and that's not to say that there's that this isn't a valuable place to be but we're starting to get these like rough spots so the question you might ask then is like well okay so what's this next era going to be what's the next part of this history and so maybe that's something functional maybe it's way crazier than we imagined and it's a stack-based language or a prologue right like ooh something insane happens maybe types won't be involved maybe not so like a lisp or ml maybe it'll be something gradually typed these are all viable and different degrees right I add this prologue and stack-based because you know these are small communities that people really love a lot and maybe they're great right like they say they're great should I believe them I don't know so for me I think of well a typed functional language is going to address a lot of these issues we can look back at history and say we got the memory management under control we got all those freaking types under control in the sense that if you can infer all that information you get a lot of the benefits without the like really heavy syntax that a lot of JavaScript programmers look at no like ah so and then maintainability as well so the problem with that is that in 1973 like and they'll like was introduced okay so this is huh the this is a one year after seat si was making send me to but for some reason I didn't work out I don't sew something mysterious happened so we have another chance 1990 standard ml came out so this is actually five years before Java Java was 1995 so we could have gone that route but for some reason didn't happen and in 1996 we had oh camel this is one year after Java it has objects like it's got it is got at all like what's the problem so in all of these situations we were sort of addressing the core concerns but in a way that for some reason didn't connect and didn't make it big so when we think about what's going to happen next I think it makes sense to ask who's going to be deciding what happens next so we've got this massive chunk of Furman programmers people who day to day are making web applications making games and we've got this tiny population of people using type function languages now this isn't to scale okay I think I don't know how small that red dot should be but so I to try to put in perspective Oracle says that there are 10 million Java programmers and if I try to do some estimation I can say ok so maybe they're like two hundred thousand scallop programmers maybe maybe more maybe less and and then how many Haskell programmers are so like we're talking about orders of magnitude the difference here like it said they're the number of jQuery users is like way huger than the number of people who are doing these functional languages I think I don't know so if this giant group of functional front-end programmers are going to be deciding we should understand what they want in this next error of programming so I think there are two sort of main accesses that we can think about that are helpful here so we have JavaScript and the XS here usable and what I mean by usable is the ability to use it so so I sort of defined that as like the time it takes to get from a novice level to actually a product that you can show your friends and be like hey check us out so I wanted to demo something real quick so this is Google guys I'm using javascript like the time from novice to getting something done was like it's unreal it's crazy I don't think anything has really matched that and like if this was a competitive market and this would probably be like abusive market position that it's baked in in this way but like it's really really easy to get started here and so if you are doing some kind of let's say you want to get a webpage up maybe that's a five minute or an hour long process even for someone who's a total beginner so that's a really amazing ability to use the language now the issue people having is about maintainability now I've got 50,000 lines the company I notice is successful and we're getting new users we're trying to add new features but we're having trouble doing that so another point on this map is Java right so we have much more maintainability here but the usability is down and so this isn't this is more about like the time it would take to start using Java is just longer rather than five minutes or an hour you're looking at something a little bit more and that part of that learning time part of that's getting things installed getting things set up so from the JavaScript programmers perspective like this is a no this is a no-go I mean partly friendly maintainable and usability but also partly from an emotional sort of crazy standpoint we're just like ah like that's kind of the logic of this isn't viable so what we want is to get that maintainability and either keep the usability or even improve it a bit and the direction people are taking here is gradual types you're seeing this coming out of Microsoft and Google like a lot of companies are betting in this direction so you can keep the usability profile where when you start out it's very simple and as your thing grows you can add types to it what I don't know if people are thinking about is like what is the endgame here when we have a JavaScript program that is fully typed like didn't we make Java again III don't I don't know maybe not but there's something here where I don't know if that's a quite an exciting resolution I don't know if that's what will satisfy b-but but it is addressing the main concern we get this maintainability now what a lot of JavaScript people don't realize is that this graph is actually later the you can be much less usable than then than anyone imagined what's interesting though is you can actually be way more maintainable than a lot of people think about as well so in the top right corner or top left when we have ml family language this is a like Haskell and oh camel so I can I can speak to my experience getting started with Haskell that led me to put it in this corner I'd say it was a good like year before I was like I'm good pretty good at this and like it's just not that way in another language so when you're set up takes a couple days and the learning process takes months or years potentially to get to an expert level it's making things really hard for you so the important point here though is that the levels of maintainability that are available are way higher than and people think about so what I want to do is I want to get to this magic realm where we get that level of maintainability but we have something usable we have something that like in an hour or in finding that people can get started with and be productive so the question is how do we get from here to there okay this is a trick this isn't actually the thing we want to hope it doesn't make sense to try to move these languages to this nice place because that means we're moving a really small set of users to a place that they generally don't necessarily want to go in the sense that if you make a really nice front-end programming language for people who don't do front-end programming and I don't so the thing you want to do is actually get Java Script to this and this nice place so when you focus on what a JavaScript programmer needs to get there you end up making different design decisions so this is kind of the shape of the world from as sort of as I see it so the next thing thing about is what does this mean for designing Elm so the broad category I name this is like user focused design and Elm so I know that I am designing for people who are doing front-end work and they have specific issues that they need addressed and if we're able to address them the best then will win if we're if we aren't the best I may be some random things will happen but if we can do better than we have a better chance so the sort of key design principles here our first gradual learning when you have a bunch of stuff to get used to it's good to have a really nice learning curve so in JavaScript you have this like you can start doing stuff really quickly and Python you have this in a lot of functional languages you don't on day one you get smacked with a lot of details a lot of intense sounding stuff and is it possible to make progress and be productive without learning all that on the first day so the second one is communication so maybe we have something good but are we able to tell people that in a convincing way I think right now we don't do all that that was that one I have a lot to say about finally we have we have culture so so what does the community like focus on what do they find important so you'll notice so far I haven't talked about anything strictly technical this is all sort of community cultural touches on documentation but it's going to impact the technical decisions ending and I think this is also stuff that can be designed this is something you can think about and do a better or worse job at so the last two one of the last points is usage driven design so based on these sort of foundational things how what does it mean to add a feature and finally we have to link so how can we do a really good job of making great tools so ok let's get into this so gradual learning so this is something where I think it needs to be designed into the language and libraries to really work so you can design the language such that as someone's get started and gets productive slowly they realize these concepts in a way that builds upon each other in a way that works for worse for people so a nice example of this in Elm that came out recently it's called start app so okay so this is a little startup program I have start and I give it a model a way to view that model and a way to update that model so this is just a counter that I can increment and decrement and the initial model is zero I view it so I'm generating some HTML here a div it's got a button I say what the number is and then another button and I have a way to update it so I increment it sometimes in a decrement of some times so someone can get started programming without really doing any functional programming like this isn't that far off from something like CoffeeScript you can actually get something going in there a very little time without getting hit with a ton of crazy concepts so I had a visited the WWDC conference and that guy who did a lot of Swift program and so he opened up this program and just added a reset button and like in the first couple minutes like two minutes in and he like didn't really know it was going on but like he was able to add a feature and that's amazing right he didn't have to read a tutorial he didn't have to read a paper he just like looked at the pattern added a thing in and added the feature he needed so that's a great kind of learning he's able to start doing and have the confidence to do stuff and slowly fill in the gaps so and I think this focus on gradual learning is a big part of why we're starting to see some education uses of Elm so there's a class of Chicago that was taught in Elm and they did a mix of doing front-end stuff and doing some data structure stuff but there's also one called McMaster outreach so this is a program for 4th through 6th grader or sorry fourth through eighth graders so this is a little this is the session they did so these are some kids who are writing in Elms online editor and they made spider-man someone has a question I'm sure he got it though eventually and they also have a Hall of Fame of stuff that people made so this is made by 6th grader this one's crazy a fourth grader made this like how did you even watch the movie so so you start to see like this is something that you can get up to speed with in a really nice way so the next topic is communication so this is something where I think we we can do a lot better so I want to do a little thought experiment okay you're going to hear six pitches trying to solve the same problem and essentially you're a busy person you know maybe you just your your that your a team lead you just had your first kid things are going crazy the project you're working on is is it's more people than you've managed before and you're looking around for the right way to deal with that so we hear there's this javascript liven for building user interfaces well I use JavaScript I need to build user interface that sounds sounds pretty good you can write JavaScript away you really want to that's actually exactly how I want to write JavaScript that sounds really good you can you can have a frame of our creative ambitious web app which I actually I really love this one because it like guilts you into it it's like do you want to write an unambitious one I think that one's really well done maybe you want HTML enhanced for web apps exclamation point that it's weaker I don't know if I'd look into that one but maybe you want scalable productive app development sounds kind of Java but yeah I could be into it I could I could check that out or maybe you want an advanced purely functional yeah advanced purely functional programming language it's like well do I want something advanced do I want something purely functional I have a lot of code that's not that is it programming language necessary solution to this thing so you're really not connecting with people who are looking at this thing at a fairly early stage so people who are just dancing through they don't have time to spend six months learning about the different characteristics here and why it's a good idea like there's going to look at this and say like I build user interfaces that we lost you know that we missed the we missed the the person moved on so essentially the question is like how likely you to explore the one that doesn't directly address your problem like how often do you hear a pitch that doesn't make any sense to you and then when you look into it it actually works right so the general advice I have is be direct like you want to say exactly what you're going to provide so another way it says is leave nothing to the imagination you don't want someone making for mental jumps before they understand what you're saying you want it to be an immediate comprehension so have a couple examples here and I'm going to try to not keep it chill um so one word that we use a lot is pure function so the way I'm going to do is to sort of deconstruct the word from a JavaScript perspective and then provide an alternative that I think is better so pure function I don't know what that is it implies that they're impure functions so the neither of these things are things that I have in my worldview as a JavaScript programmer so at that point some people will just move on and say that doesn't seem interesting some people will go to Wikipedia and look up what if your function is and they'll say okay I guess that kind of makes sense now at that point some people will say I don't know if that's really relevant to me and move on some smaller fraction people will say okay that might be interesting and then they look at intimate but so we took so many jumps to get to someone potentially being interesting that we're losing a lot of people so I have had a lot more success saying stateless function JavaScript programmers have state they know that it often causes issue what if you didn't have that state in a lot of your functions so it directly connects to something that happens day to day in your code and says hey what if you didn't have the problems that come from that I don't know if that's the perfect term but it's certainly an improved term one that connects to how people use stuff another phrase that people say a lot is easy to reason about so my my mom is she like to review my work so she actually like read my thesis before it was time to turn it in and she came across this phrase and she was like I don't think this is English like I think you forgot some number of words it's easy to reason about like it is not really clear what that's going to give me right like was it hard to reason about like I'm a JavaScript pervert I spend a lot of time reasoning about what my code does cuz like weird stuff can happen so another way to say this is it's easy to refactor so just connected directly to what's happening in your code do you have problems refactoring well what if it was easier and you can kind of get the take the inference steps and save the last one another one is safe we like to talk about type people like to talk about safety but safety is kind of boring right like a safe investment is like bonds no one's no one's really like bonds yeah yeah you should see my bond portfolio it's been like 2% growth it's amazing another the image of like floaties you know like so like that's that's what I think of when I think of of safe and to connect it more to code like when I write javascript code I don't think about it as safe or unsafe it's not like it's going to punch me you know it doesn't really connect with how I think about the code so we've been saying reliable in the sense that you know you get runtime errors in JavaScript so what if you had a program that didn't do that what if you had the reliability that you want so last one is monad so so this is a term that I struggled with a lot I don't know how many people like go and say that but I would say it was a good like six months to a year before I felt I really was like on board nah I won't say on board before I really understood was going on there and I think I didn't have a deep understanding for maybe a year or two more after that and when I finally did understand I was pretty upset that it wasn't actually a complex thing so there's something about this term that it it asks you to think that it's complicated right so my my experience learning it was like oh I want to print something out okay I'll use a monad well that needs category theory so should I buy a book on category theory and like I'm not learning from a professor or from someone who's used Haskell a lot like I'm just sort of going through like what would make sense here's a term that I don't know well then I should learn what it is oh it's depending on this I should learn about that and yeah Haskell person would say oh you don't need to buy a book on category theory but Haskell is saying you should write like I need to know about monads so there's a story I like to tell that sort of reveals this in a way that doesn't actually connect to people's conceived notions so let's say there's a there's a person who they have an apple in each hand they say I have an apple and have an apple how many apples do I have total and so you say to them well first you need to understand group theory so there are four laws commutativity associativity identity identity for idem potency and so you can do all these commutative operations if you follow the laws it's really cool and they see that the person is like I have an applicator and I have an apple there how many apples do have it so okay okay let's be more concrete so multiplication on integers is it is a group a rotation in 3d space around an axis is a group do you get it so you when you put it in that in that framing it sort of reveals that it's a it's a crazy way to teach addition like there's a reason we don't take that route and it may be that route works for some percentage of people who are learning but I'd say for a vast majority let's say 95% of people saying to is is a better explanation so the point I'm making here isn't that this is an unimportant concept but it's one that we emphasize very very early very very emphatically and sometimes in a way that's actually confusing so another aspect of this is often people say like the state monad the IO monad it's a very weird thing because it makes the noun monad like it's a physical thing it's like saying oh you want to add numbers just use the addition group why would you say that just add them so there are a lot of ways we can deal with this the general thrust of it is is you can essentially be very active using monadic things without ever talking about it so in JavaScript for example the promises library has a function called n so I can say here's the thing I want to do and when it's done then do this thing then do this other thing so we found it's actually really effective to say callbacks I I suspect you will be mad about this but so if we look at we have this end then function in a bunch of different libraries so in maybe for example I can say here it is here it is try to turn it to an integer and then turn into a valid month okay you can read it the first time through it's not crazy do this and then you do that and we don't have to talk about any concept to it we just say give us a maybe and give us a call back if you're successful we'll keep going if you're unsuccessful will fail so you're able to get the core concept in a way that doesn't introduce any extra stuff and so as people start seeing this in different libraries maybe they'll be interested in the general pattern but the point is you don't have to understand the general pattern to be get up to speed and use this kind of thing you call it a monad of course obviously the point is you don't have to do that in the first day right like when you want to know the general pattern of addition and multiplication and rotation in 3d space around axis he called it a group but that's what it is but the point is you don't have to talk about that superplex note on communication which is about obvious names I really like obvious names I was at Microsoft and briefly and everything had a three-letter abbreviation so there was a joke that like tio everything was a TL a three-letter abbreviation so they'd abbreviated so you know we try to just like be very minimal so the tool for building things is L make the tool for packaging things is a package the tool for LM HTML is or sorry that's over HTML is M HTML like can anyone guess what L markdown does like it helps you do markdown so just like making it so there's no extra steps that you have to take is a really important goal for me okay next is culture so this one I think was a cool realization that I I was running to meet up in San Francisco and the setup was someone would do a talk a couple people would show up maybe like 20 25 people would show up and generally was a pretty like elite group of people so people who had PhDs about some sort of functional programming topic so essentially when you do like there's a person talking and a bunch of people listening you get like a group of people who are relatively elite and you try to make them more elite so I met this person who was running a meet-up called Dame's making games and the way it was set up was as a hackathon people show up they pair program together they work on a concrete project so they say today's focus is a side-scrolling game and let's focus on that and so I started trying that out for the Elm meetup in San Francisco and the makeup of the attendees changed dramatically right so it was people who are totally new to Elm it was people who were interested in using at work people who are making packages to do front-end work so just by sort of changing the focus of the meetup you change the makeup of the community right so essentially by doing that I'm sending a message to people who are interested in using at home and that Elm is interested in being used as well so I think that was actually a really interesting technique so another example of this is this culture of like just getting out there and making stuff is there's a company called no red ink in San Francisco and they recently started using a home in production and essentially the way they got it started was an engineer decided like I'm gonna do this and he did it like a lot of times you get blocked on on smaller issues but it's important to sort of see like if you go if you decide to do it it's not it's not that difficult so another one is time to the time-travelling debugger a lot of people think I made this it's which I didn't so if you haven't seen it before Oh ten ton ton so we've got a little more in here and he can hop around now the interesting thing is that you can pause and go back in time and then you can change your program and like different things happen and you can also attract what's going on so this was a guy named Lazlo Pandey who was just interested in debugging how can we do this in a really cool way and he decided to like go and give it a try and when I first saw the demo like I didn't really understand what he'd been talking about and then he showed me the thing and I was like okay this is a big deal this is cool and so this culture just like go out there and make something useful I think has been really guys on that way one final piece is a style guide so a lot of people will say like oh those ml languages are hard to and what they're saying in fact is those people who use ML languages write code that's hard to read so it's not quite the same thing it's not an inherent fact about an ml language or it's that there's a coding style that isn't super professional that's very very common so as a quick example of this we have two different ways so the top is what I recommend and we took a lot of lessons from Python here actually so you can do certain layout things so in this one we always have two spaces between top-level deficits this is something that Python does it lets you chunk functions in a much easier way we also say always bring things down on a new line so that you can sort of visually see things in a nicer way and the goal here is like how can we have code that is going to last for five years or ten years that when you go do a blame on some change you're going to actually point to something real and a lot of code that I've seen on the internet in some languages looks more like this like it's much more compact it's easier to fit on a slide for a presentation and it's easier to fit in the two columns of a academic paper but it has problems right so if I ever need to add another case that's longer do I move all of these do I leave them if this case becomes really long I have to move it down but do I move all of them down I'm just creating a maintenance problem for myself that didn't need to exist and so part of what I want to make a value of elm is we're writing code for like real use in the world and so we need to have a professional style the last point is I have a guide for designing packages which is just a set of best practices but essentially how can we help people make really great stuff okay so finally we'll get to a more technical aspect of this so usage driven design so what that means to me is start with the minimum viable solution something that will work and maybe it's not enough but maybe will be we don't know and from there see if there are any concrete issues in practice if so bring that information back in and either update your solution make it a little bit more powerful what's been interesting is that the minimal viable solutions often enough so we have a couple examples of this where we've gotten very nice results from keeping things simple so one example of this is static signal so if you're not super familiar without my I don't know if this will make a ton of sense but essentially values flow through your program in a particular way and in Elm you can't reconfigure that flow and so folks who had been working on frv we're very very skeptical they're like how can you make a interactive list a dynamic list where they're stateful elements and so like how could you make a list of counters where you can add and remove counters something like this this is also on the time-travelling debugger so you can go back but so how can we do something like that and so I essentially made the wager of we could add something complicated or we could see if this actually can be solved with the minimal solution and so what ended up happening is this turned into the Elm architecture so there's a nice pattern that you can use to structure your own programs that's gives you modulated it gives you testability it's very easy to stamp out and we're starting to see it being sort of ported over to closure script and react code perhaps sometimes that's co invention sometimes it's people saying hey I saw this cool thing let's do it here but what that means is we're able to start with a very simple step so this is similar to the counter that I was showing before I have a model oh sorry which is an integer I have a way to increment it and decrement it and I have a way to view it and I've wrapped this up in a module so I can reuse it as many times as I want so when I create a list of counters I just import counter and then I use those functions so I can initialize it I can update it and I can view it and all of this is just reusing that code that I wrote before so now when I add features to counter this code doesn't need to know what's happening there I just have a way to update it and view it so you get this very nice modularity and I don't think we would have ended up with that solution how do we started with what was the more complex thing that sort of was the generally agreed upon way of doing things another example of this that's I already regret putting this in here so at this moment Elm doesn't have type classes so this is something that's controversial some people so for JavaScript programmers this is a feature people love this for Haskell programmers this is a travesty this is terrible I can't believe it how could how's it even possible so part of this is that a language exists over 20 or 30 years and when you release a feature is also part of the feature right so if you add a feature in the first year the whole culture that grows around it is going to use that if you add it in the 15th year that whole community that you built will have a way of doing things and you introduced an advanced feature for advanced users so you can totally change that usage and practice by thinking about timing so one interesting result that's come from this so far is how we do our JSON parsing so this was something we weren't really sure how it was going to look but oops so this is how we represent our documentation on the documentation website so I have documentation has name comment and then all the values and such and the way we get that of JSON is with this decoder so I say hey there's a name field it's a string there's a comment field it has a string there's a bunch of values and that's a list of that actually there's aliases and that's a list of alias so let's look at what alias is that's also a decoder and it has certain fields they have certain values so you're able to sort of build up these JSON decoders in a really nice explicit way and that's not tied to any particular type I can make five of these for four documents maybe there are different errors of documents like I change the format at some point and I need to have a decoder for both of those it makes that really simple and you might say okay well I wouldn't I'd rather not write this code so that doesn't actually need type classes this is something that you could perhaps generate based on the type declaration so you find yourself in a situation where you actually end up with a pretty simple solution that you wouldn't have seen if you had a fancier tool in your tool kit so the overall observation here is that simpler foundation produces simpler code in practice and that I think is a really valuable thing and if you're going to give away simplicity you better be doing it for a very good reason that doesn't mean that you can't but you should at least know what the trade-off is that you're making so the final thing is tooling so because we have sort of all these invariants about type functional language so elm for example is immutable we have managed effects so effects aren't just happening arbitrary we can use that to create unique and delightful experiences stuff that couldn't be created by some other project so so elm is competing with languages like dart or typescript where they have a team of 20 or 50 people and I can't compete like even if even if someone's 10x that's 20 and 50 X no one no one even no one even talks about that so the way that you can be competitive is to design things that just can't be done in those languages at all so one example of that is a time travel debugger which we saw another example is automatic Smet semantic versioning enforcement so this is something that I don't know if a lot of people know about so let's say a new version of LM HTML comes out and it's a major change and you want to know what happened so we can run diff and it'll say hey these two things were added and we changed call span to dick and int Andros been ticking it so what happened here is someone read the spec more carefully than me and realized that in those particular cases you can't give four pixels or 4% you really have to give a number so you can actually look what exactly changed and so this can be produced at any point so when someone's going to release a package we run this and say hey it looks like you added or removed such-and-such and we can say exactly this is a major change in some minor changes the patch change and that means every package that is released follows these rules and maybe that's feasible in some languages but if we're competing with JavaScript this is a this is really nice thing and there are a lot of fairly well known cases in Java so we're a big project we'll do a patch release or a minor release release that breaks a lot of stuff and as well it wasn't really that big a deal so I didn't but you violated everyone's constraints and their builds are broken and they can't push the production so this rules that kind of case out another thing that we did recently is friendly error messages so sometimes people say I don't like using these type languages those error messages or pain and the realization here is like maybe they are painful maybe maybe we can make them better in certain ways so the way this ended up looking is we tried to think about what would help the user the most so on the Left we have a little code snippet and on the right we have the error that is happening there and so we get the little red underline list doesn't expose nap maybe you want one of these other things so it's very explicit about what's going wrong there another example of this is oh yeah this one's this one's great the first argument to the function has an unexpected type looks like the record is missing the field if you look at the program we're giving Herman to is over 50 and trying to get his age but he doesn't have an age so we directly identified in a way that a person can read what's going on yeah so essentially by focusing on sort of the user experience of these error messages we can get a lot a better result and so the hope here is this is a work in progress and the hope is that we can get to a point where these error messages actually start to feel good we can get to a point where it's just helpful I am writing a program and it says hey check out this line something that this particular thing is going wrong here and I think it's conceivable to change the relationship people have with a compiler from adversary to assistant right so instead of the relationship being like hey check out this code know what if I mess with this how about this other thing no okay this yep and then and then maybe it crashes anyway if you're if you're using Java and you have a nullpointerexception to something that's more like hey here's this program you shouldn't you should change this and avoid a crash that way so I think that's a long-term process but I think we should think about trying to move in that direction another thing is the startup experience of using Elm so I want people to like accidentally learn how if they come to the website so I have all these examples and so like the hope is that you can click on one say I'm interested in that and just see how that codes working directly and one nice thing here is that we have little hints so you can go read about what's going on down so if you want to know what a div is you can go look at I think that will start to turn into more advanced editors and IDs and such but having that experience really helps you will get started in a quick way this one will be interesting so based on the design of Elm we can be faster than JavaScript like from a like from a theoretical foundation so this is a really huge engineering project but this is something that if we're able to achieve work this is a huge benefit one thing javascript promoters really love is performance so when asm.js came out people are like when you're going to be compiling to that you need a garbage collector and then when a web assembly comes out there okay this is how about yeah can you use that you need a garbage collector so I suspect we'll eventually have one um and we'll be able to actually deliver on that but the message here is that like invariants are a most competitive advantage if we can provide experiences that you can't get anywhere else that people haven't seen before that are delightful for people then I think we have a much better chance of being the the next chunk of programming history so that's sort of the outline of user focused design and out and hopefully that's going to help us be an inch green any questions something that people really like about using javascript for building their client applications is that they can use JavaScript on the client and the server and then get like these at server-side rendered locations using the same logic and is that is is having elm run on the server a thing that yes I think it's likely to happen in the next release so essentially I wanted to focus on a clearer neesh before expanding out too far like I felt if you have a really broad focus your going to do a lot of things poorly but we're at a point now where I think we can start running on node and the long term hope would be that just be running compiling to assembly and running much much faster than having different sort of having better support for concurrency and parallelism and such but that's coming so there are different theories about what programming like adoption probing language adoption follows some people think that it's you know based on killer apps and people think it's based on features what if it is really entirely random I would say that observational II it does seem to be kind of random if that's the case it's not going to hurt to to operate under a different theory right right so trying real hard to think through what it might be and if it does end up being random this this won't hurt but another part of this is that there are sort of different trajectories for languages that have been successful so you have the sort of big like languages from corporations and for a long time that was the only way you would have the resources to make a language so like C and Java but you also have sort of languages that got started out of like some person working on it so Ruby and Python or sort of examples of that so I try to Scala enclosure as well so I try to look at those to see what techniques might have been influential in making that in making that happen but maybe it's random in which case like yeah how do I let the the guidelines you describe say whether you you make these choices you know say introducing your concept or try to reuse the existing concepts and so on whether it is helpful or say gradual learning is does this work in only in San Francisco or would it work also in the communities elsewhere so how do you know whether the choice you made was supposed to write one so I feel like San Francisco is actually a more it's a tougher City for typed functional programming it's I think it's true on the East Coast you you have a lot of it and part of that's because of the universities that like what the professor's particularly loyalties are to so on the east coast of the United States you get a lot of typed functional stuff in Europe you get a lot on the west coast not really as much so I try to just ask people very aggressively what how things are going and like what their background is and and such but it's hard to I would be surprised if there was an advantage it in San Francisco but that's a place where the thought experiment about having six different pitches in San Francisco it's like you have 80 different pitches and they all have a meet-up tonight and you have to like and you're just like I don't know so it's it's it's a San Francisco is tough Oh when Zell I'm going to have macros just just kidding do you have any data on the or some examples of the complexity of applications that are being built in elm right now like Oh Lord just one like so that's probably the folks at no red ink so the particular part that they did in oh so it's helping people learn grammar so the example that they show is a they're helping people learn passive voice and active voice and apparently people answer 2.5 million questions a day on that chunk of code I don't know how huge that code bases but we're it's not like we've we've got like JavaScript scale or tens of thousands hundreds of thousands of blind projects yet yeah so a lot of the things you mentioned seem to make a lot of sense especially in the context of elm but they also that trade-offs with a lot of the of the decisions that you've made that as I said makes sense in the context of elm but you also seem to be suggesting to the general functional programming community and I'm wondering whether and some of those lessons I think we really should learn but I'm wondering whether it isn't so for instance losing the connection in our terminology with academia seems like it's a trade off or not having typed classes and I'm wondering whether instead of making those trade offs we can't just have you be the sort of you know elm be the gateway drug until you do all those things and say I'll go try out all the other functional programming languages afterwards so anyway that that's yeah I think that's plausible uh the point I want to make here isn't that all ml family images need to be making these decisions but starting from like who is your user exactly how can I cater them in particular how can I mess set up my messaging so people know what they're getting themselves into so my experience has been in some communities there's disagreement about like is this a research tool is this a way to make products is this and so that can be quite confusing but the answer might be the actual user of that language is defined in a different way and for that user you need to think about different things so I wouldn't say like oh do all this stuff in high school like I don't think that's a good idea this is that kind of what it's what is the production usage of right now are there any like real-world large applications built with it so we have I know three companies definitely that are using it so one is this company Tarun Cisco one is called circuit hub and they're doing some diagram rendering it with it and there's a German company who's who's using for some internal tools but we haven't gotten a like a massive a print in it yet in production so you're working at Prezi they're not using element production going to they are going to it's a more complicated story than I then maybe I want to share but essentially we're in the process of doing a rewrite from flash to JavaScript and when you're doing a big rewrite lots of things are complicated besides like the languages involved so there's lots of factors there and I think it's going to be some more months but I think it's it's going to happen the other questions phil has a question it's kind of an honor one of the big factors in language adoption and learning is familiarity it's not just that it's easier to learn because of the context people know what choices did you made make in the design of Elm to make it familiar like something else that's the large extent why Java and JavaScript succeeded because they looked like the thing that came before them so one I can give one example in one counterexample so one example of trying to make things look familiar is we have a concept of tasks which looks very much like promises in JavaScript and so you sort of have this one-to-one mapping where hey you know promises we've got tasks API is quite similar and that's filling the role of the i/o monad without introducing that sort of conceptual world so an example where I I think we're I don't really know what the answer is but so I went with syntax highly inspired by Haskell and Oh Campbell and for a lot of people to like ah this is crazy and it's not clear to me what the right solution is there because if I look five years down it's the right choice how it is if I look at today maybe there's some benefit to making things a little bit more familiar looking so I'll share an interesting experience on that so I've had people come up to me after talk and say hey that syntax looks a lot like Python was that an influence and I was like no but I'm so happy that you think that so I think the style guide that we set up for home is going to help a lot with the like perception of craziness so for people who are coming from stuff like CoffeeScript it's not that wild in terms of syntax so I'm making a bet that we can get away with certain things especially if the overall message is like it's really important to make things easy to learn you"
      },
      "after": "badddde0b65d4b81",
      "date": 1697459710680
    },
    {
      "type": "add",
      "id": "52377aea8c989955",
      "item": {
        "type": "paragraph",
        "id": "52377aea8c989955",
        "text": "if typed functional programming is so great how come nobody uses it"
      },
      "after": "badddde0b65d4b81",
      "date": 1697459724320
    },
    {
      "id": "52377aea8c989955",
      "type": "move",
      "order": [
        "52377aea8c989955",
        "5e29400f6fcd0c71",
        "badddde0b65d4b81",
        "1ca8005ad201ab2c"
      ],
      "date": 1697459726617
    },
    {
      "type": "edit",
      "id": "52377aea8c989955",
      "item": {
        "type": "paragraph",
        "id": "52377aea8c989955",
        "text": "If typed functional programming is so great how come nobody uses it?"
      },
      "date": 1697459735747
    },
    {
      "type": "edit",
      "id": "52377aea8c989955",
      "item": {
        "type": "paragraph",
        "id": "52377aea8c989955",
        "text": "If typed functional programming is so great, how come nobody uses it?"
      },
      "date": 1697459980626
    }
  ]
}