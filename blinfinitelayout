{
  "title": "BlInfiniteLayout",
  "story": [
    {
      "type": "markdown",
      "id": "032e99046767b565",
      "text": "I am layout supposed to be used by infinite element to position children within [[visible bounds]].\n"
    },
    {
      "type": "markdown",
      "id": "fa7ed1155bb2f1dc",
      "text": "Concrete layouting algorithms used to support infinite amount of children differs from non-infinite case, meaning that normal layouts can not be used by infinite element.\n\n# Animations\n\nThe `BlInfiniteLayout` is in charge of the behavior of item animations. By default, `BlInfiniteElement` has a non-null `#itemAnimator`, and simple item animations are enabled. This means that add/remove operations on the datasource will result in animations to add new or appearing items, removed or disappearing items, and moved items.\n\nIf a `BlInfiniteLayout` returns false from `#supportsPredictiveItemAnimations`, which is the default, and runs a normal layout operation during `#layoutChildrenIn: state:`, the `BlInfiniteElement` will have enough information to run those animations in a simple way. For example, the default `BlInfiniteItemAnimator`, will simply fade elements in and out, whether they are actually added/removed or whether they are moved on or off the screen due to other add/remove operations.\n\nA `BlInfiniteLayout` wanting a better item animation experience, where items can be animated onto and off of the screen according to where the items exist when they are not on screen, then the `BlInfiniteLayout` should return true from `#supportsPredictiveItemAnimations` and add additional logic to `#layoutChildrenIn: state:`. Supporting predictive animations means that `#layoutChildrenIn: state:` will be called twice; once as a  layout step to determine where items would have been prior to a real layout, and again to do the 'real' layout. In the pre-layout phase, items will remember their pre-layout positions to allow them to be laid out appropriately. Also, removed (`BlInfiniteLayoutConstraints>>#isItemRemoved`) items will be returned from the scrap to help determine correct placement of other items. These removed items should not be added to the child list, but should be used to help calculate correct positioning of other elements, including elements that were not previously onscreen (referred to as APPEARING elements), but whose pre-layout offscreen position can be determined given the extra information about the pre-layout removed elements.\n\nThe second layout pass is the real layout in which only non-removed elements will be used. The only additional requirement during this pass is, if `#supportsPredictiveItemAnimations` returns true, to note which elements exist in the child list prior to layout and which are not there after layout (referred to as DISAPPEARING elements), and to position/layout those children appropriately, without regard to the actual bounds of the `BlInfiniteElement`. This allows the animation system to know the location to which to animate these disappearing elements.\n\nThe default `BlInfiniteLayout` implementations for `BlInfiniteElement` handle all of these requirements for animations already. Clients of `BlInfiniteElement` can either use one of these layouts directly or look at their implementations of `#layoutChildrenIn: state:` to see how they account for the APPEARING and DISAPPEARING e;ements.\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "BlInfiniteLayout",
        "story": []
      },
      "date": 1662139640864
    },
    {
      "item": {
        "type": "factory",
        "id": "032e99046767b565"
      },
      "id": "032e99046767b565",
      "type": "add",
      "date": 1662139646019
    },
    {
      "type": "edit",
      "id": "032e99046767b565",
      "item": {
        "type": "markdown",
        "id": "032e99046767b565",
        "text": "I am layout supposed to be used by infinite element to position children within visible bounds.\nConcrete layouting algorithms used to support infinite amount of children differs from non-infinite case, meaning that normal layouts can not be used by infinite element.\n\n# Animations\n\nThe `BlInfiniteLayout` is in charge of the behavior of item animations. By default, `BlInfiniteElement` has a non-null `#itemAnimator`, and simple item animations are enabled. This means that add/remove operations on the datasource will result in animations to add new or appearing items, removed or disappearing items, and moved items.\n\nIf a `BlInfiniteLayout` returns false from `#supportsPredictiveItemAnimations`, which is the default, and runs a normal layout operation during `#layoutChildrenIn: state:`, the `BlInfiniteElement` will have enough information to run those animations in a simple way. For example, the default `BlInfiniteItemAnimator`, will simply fade elements in and out, whether they are actually added/removed or whether they are moved on or off the screen due to other add/remove operations.\n\nA `BlInfiniteLayout` wanting a better item animation experience, where items can be animated onto and off of the screen according to where the items exist when they are not on screen, then the `BlInfiniteLayout` should return true from `#supportsPredictiveItemAnimations` and add additional logic to `#layoutChildrenIn: state:`. Supporting predictive animations means that `#layoutChildrenIn: state:` will be called twice; once as a  layout step to determine where items would have been prior to a real layout, and again to do the 'real' layout. In the pre-layout phase, items will remember their pre-layout positions to allow them to be laid out appropriately. Also, removed (`BlInfiniteLayoutConstraints>>#isItemRemoved`) items will be returned from the scrap to help determine correct placement of other items. These removed items should not be added to the child list, but should be used to help calculate correct positioning of other elements, including elements that were not previously onscreen (referred to as APPEARING elements), but whose pre-layout offscreen position can be determined given the extra information about the pre-layout removed elements.\n\nThe second layout pass is the real layout in which only non-removed elements will be used. The only additional requirement during this pass is, if `#supportsPredictiveItemAnimations` returns true, to note which elements exist in the child list prior to layout and which are not there after layout (referred to as DISAPPEARING elements), and to position/layout those children appropriately, without regard to the actual bounds of the `BlInfiniteElement`. This allows the animation system to know the location to which to animate these disappearing elements.\n\nThe default `BlInfiniteLayout` implementations for `BlInfiniteElement` handle all of these requirements for animations already. Clients of `BlInfiniteElement` can either use one of these layouts directly or look at their implementations of `#layoutChildrenIn: state:` to see how they account for the APPEARING and DISAPPEARING e;ements.\n"
      },
      "date": 1662139648234
    },
    {
      "type": "edit",
      "id": "032e99046767b565",
      "item": {
        "type": "markdown",
        "id": "032e99046767b565",
        "text": "I am layout supposed to be used by infinite element to position children within visible bounds.\n"
      },
      "date": 1662139658731
    },
    {
      "type": "add",
      "id": "fa7ed1155bb2f1dc",
      "item": {
        "type": "markdown",
        "id": "fa7ed1155bb2f1dc",
        "text": "Concrete layouting algorithms used to support infinite amount of children differs from non-infinite case, meaning that normal layouts can not be used by infinite element.\n\n# Animations\n\nThe `BlInfiniteLayout` is in charge of the behavior of item animations. By default, `BlInfiniteElement` has a non-null `#itemAnimator`, and simple item animations are enabled. This means that add/remove operations on the datasource will result in animations to add new or appearing items, removed or disappearing items, and moved items.\n\nIf a `BlInfiniteLayout` returns false from `#supportsPredictiveItemAnimations`, which is the default, and runs a normal layout operation during `#layoutChildrenIn: state:`, the `BlInfiniteElement` will have enough information to run those animations in a simple way. For example, the default `BlInfiniteItemAnimator`, will simply fade elements in and out, whether they are actually added/removed or whether they are moved on or off the screen due to other add/remove operations.\n\nA `BlInfiniteLayout` wanting a better item animation experience, where items can be animated onto and off of the screen according to where the items exist when they are not on screen, then the `BlInfiniteLayout` should return true from `#supportsPredictiveItemAnimations` and add additional logic to `#layoutChildrenIn: state:`. Supporting predictive animations means that `#layoutChildrenIn: state:` will be called twice; once as a  layout step to determine where items would have been prior to a real layout, and again to do the 'real' layout. In the pre-layout phase, items will remember their pre-layout positions to allow them to be laid out appropriately. Also, removed (`BlInfiniteLayoutConstraints>>#isItemRemoved`) items will be returned from the scrap to help determine correct placement of other items. These removed items should not be added to the child list, but should be used to help calculate correct positioning of other elements, including elements that were not previously onscreen (referred to as APPEARING elements), but whose pre-layout offscreen position can be determined given the extra information about the pre-layout removed elements.\n\nThe second layout pass is the real layout in which only non-removed elements will be used. The only additional requirement during this pass is, if `#supportsPredictiveItemAnimations` returns true, to note which elements exist in the child list prior to layout and which are not there after layout (referred to as DISAPPEARING elements), and to position/layout those children appropriately, without regard to the actual bounds of the `BlInfiniteElement`. This allows the animation system to know the location to which to animate these disappearing elements.\n\nThe default `BlInfiniteLayout` implementations for `BlInfiniteElement` handle all of these requirements for animations already. Clients of `BlInfiniteElement` can either use one of these layouts directly or look at their implementations of `#layoutChildrenIn: state:` to see how they account for the APPEARING and DISAPPEARING e;ements.\n"
      },
      "after": "032e99046767b565",
      "date": 1662139659111
    },
    {
      "type": "edit",
      "id": "032e99046767b565",
      "item": {
        "type": "markdown",
        "id": "032e99046767b565",
        "text": "I am layout supposed to be used by infinite element to position children within [[visible bounds]].\n"
      },
      "date": 1662139690178
    }
  ]
}