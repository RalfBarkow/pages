{
  "title": "Distinctions, Labels, and Smalltalk",
  "story": [
    {
      "type": "markdown",
      "id": "c087350e20108f44",
      "text": "In [[Smalltalk]], objects *are* distinctions. Since everything in Smalltalk is an object, then everything in Smalltalk is a [[Distinction]]."
    },
    {
      "type": "paragraph",
      "id": "a5ae46ea3699513c",
      "text": "If we look at this in terms of the piece of paper analogy, instance variables inside an object are circles inside an enclosing circle. To distinguish between instance variables in the context of an object, we typically name them just like we name circles. See [[Doughnut]]."
    },
    {
      "type": "paragraph",
      "id": "190a47c6bdf60c49",
      "text": "In Smalltalk, assignment lets us name any distinction by applying a label. Since everything in Smalltalk is a distinction, then everything in Smalltalk can be named. This is an extraordinary ability to have."
    },
    {
      "type": "markdown",
      "id": "a16c679ff0294178",
      "text": "> In some Smalltalks, assignment is written as ← instead of :=. This gives the wrong impression as well. It would be much better to use → or :>."
    },
    {
      "type": "paragraph",
      "id": "50a7b5ffb2fa6b53",
      "text": "Note that assignment should not be interpreted as loading a value into some named memory cells. Naming an object should not be seen along the lines of modifying the object to hold its name either. On the contrary, the act of giving a name should be thought of in terms of remembering an object by means of a label. Also, since a distinction is not the private property of the name either, you are free to give a distinction as many names as you want."
    },
    {
      "type": "markdown",
      "id": "d805c753025d780d",
      "text": "Commonplace keywords like `instanceVariableNames:` and expressions such as “temporary variable names” take a whole new meaning from this point of view. In fact, they should not even contain the term variable at all. Therefore, we will not refer to names by means of, or assisted by, the word *variable* any further."
    },
    {
      "type": "markdown",
      "id": "8c292a8be5671b3a",
      "text": "> Note how without the word variable, this statement becomes trivial."
    },
    {
      "type": "paragraph",
      "id": "c24f6ee61f607153",
      "text": "Ideas like instance name encapsulation also take a new powerful meaning when viewed in terms of distinctions. Instance names live inside the boundary of instances, thus in order to get at them the boundary of the instance has to be crossed."
    },
    {
      "type": "paragraph",
      "id": "409b79f0198e5147",
      "text": "Since everything that happens in Smalltalk occurs in terms of messages, it turns out that messages are the only entities that can cross boundaries, possibly carrying other objects (distinctions) with them."
    },
    {
      "type": "markdown",
      "id": "b44ef0de000edeae",
      "text": "> Did we mention Alan Kay has a biology background?"
    },
    {
      "type": "paragraph",
      "id": "fe2ed78112e7dcf9",
      "text": "Compare this mass of distinctions and messages crossing boundaries with other complex systems in which objects interact. One example could be a live multicellular being such as yourself, in which multiple cells typically influence the behavior of each other by means of protein messages which cross cell membranes."
    },
    {
      "type": "paragraph",
      "id": "8d4194ff655fcf9c",
      "text": "Or let’s say you would like to have lunch with a friend. In an assembler or obfuscated C world, you would reach inside your friend’s mind and manipulate values and pointers until you made lunch appear attractive. You might even tickle the stomach to get the appetite going."
    },
    {
      "type": "markdown",
      "id": "f0df324b3adf4e6b",
      "text": "But Smalltalk imposes much more civilized manners. In the same way that your friend is not a `struct{...}`, objects are not allowed to arbitrarily cross distinctions and mess with internal details. Instead, objects must communicate by means of messages. As long as the agreed upon behavior is respected, the implementation artifacts are happily taken for granted."
    },
    {
      "type": "markdown",
      "id": "e6c1553bc0faf5f9",
      "text": "If we keep in mind that everything in Smalltalk is a distinction, and that all distinctions can be named, then it follows that it must be possible to name every distinguished bit of behavior. In Smalltalk, the names of bits of behavior are called *selectors*."
    },
    {
      "type": "markdown",
      "id": "482128beeba0fef1",
      "text": "Since messages provide the only mechanism to cross into a distinction, it obviously follows that even the behavior named `instVarAt:` must be a message."
    },
    {
      "type": "pagefold",
      "id": "e6e9117ae2d01b05",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "8ca38823fcd18412",
      "text": "For those not familiar with the message `instVarAt:`, what sending it does is to answer the object referenced by the nth instance name of the receiver. This works because all instance variables are stored in the order given by the [[Class]] and superclass definitions. Feel free to check out the implementation in your Smalltalk of choice."
    },
    {
      "type": "pagefold",
      "id": "cc3ed01a84a8b5b4",
      "text": "."
    },
    {
      "type": "paragraph",
      "id": "5599b7e7fcea5186",
      "text": "⇒ On the Use of Labels with the Special Object Array"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Distinctions, Labels, and Smalltalk",
        "story": []
      },
      "date": 1660152910656
    },
    {
      "item": {
        "type": "factory",
        "id": "c087350e20108f44"
      },
      "id": "c087350e20108f44",
      "type": "add",
      "date": 1660152931087
    },
    {
      "type": "edit",
      "id": "c087350e20108f44",
      "item": {
        "type": "paragraph",
        "id": "c087350e20108f44",
        "text": "In Smalltalk, objects are distinctions. Since everything in Smalltalk is an object, then everything in Smalltalk is a distinction."
      },
      "date": 1660152933710
    },
    {
      "type": "edit",
      "id": "c087350e20108f44",
      "item": {
        "type": "paragraph",
        "id": "c087350e20108f44",
        "text": "In Smalltalk, objects *are* distinctions. Since everything in Smalltalk is an object, then everything in Smalltalk is a distinction."
      },
      "date": 1660152953644
    },
    {
      "type": "edit",
      "id": "c087350e20108f44",
      "item": {
        "type": "markdown",
        "id": "c087350e20108f44",
        "text": "In Smalltalk, objects *are* distinctions. Since everything in Smalltalk is an object, then everything in Smalltalk is a distinction."
      },
      "date": 1660152954891
    },
    {
      "item": {
        "type": "factory",
        "id": "a5ae46ea3699513c"
      },
      "id": "a5ae46ea3699513c",
      "type": "add",
      "after": "c087350e20108f44",
      "date": 1660152981452
    },
    {
      "type": "edit",
      "id": "a5ae46ea3699513c",
      "item": {
        "type": "paragraph",
        "id": "a5ae46ea3699513c",
        "text": "If we look at this in terms of the piece of paper analogy, instance variables inside an object are circles inside an enclosing circle. To distinguish between instance variables in the context of an object, we typically name them just like we name circles."
      },
      "date": 1660152983842
    },
    {
      "item": {
        "type": "factory",
        "id": "190a47c6bdf60c49"
      },
      "id": "190a47c6bdf60c49",
      "type": "add",
      "after": "a5ae46ea3699513c",
      "date": 1660152993675
    },
    {
      "type": "edit",
      "id": "190a47c6bdf60c49",
      "item": {
        "type": "paragraph",
        "id": "190a47c6bdf60c49",
        "text": "In Smalltalk, assignment lets us name any distinction by applying a label. Since everything in Smalltalk is a distinction, then everything in Smalltalk can be named. This is an extraordinary ability to have."
      },
      "date": 1660152995278
    },
    {
      "item": {
        "type": "factory",
        "id": "a16c679ff0294178"
      },
      "id": "a16c679ff0294178",
      "type": "add",
      "after": "190a47c6bdf60c49",
      "date": 1660153048223
    },
    {
      "type": "edit",
      "id": "a16c679ff0294178",
      "item": {
        "type": "markdown",
        "id": "a16c679ff0294178",
        "text": "> In some Smalltalks, assignment is written as ← instead of :=. This gives the wrong impression as well. It would be much better to use → or :>."
      },
      "date": 1660153051190
    },
    {
      "item": {
        "type": "factory",
        "id": "50a7b5ffb2fa6b53"
      },
      "id": "50a7b5ffb2fa6b53",
      "type": "add",
      "after": "a16c679ff0294178",
      "date": 1660153079985
    },
    {
      "type": "edit",
      "id": "50a7b5ffb2fa6b53",
      "item": {
        "type": "paragraph",
        "id": "50a7b5ffb2fa6b53",
        "text": "Note that assignment should not be interpreted as loading a value into some named memory cells. Naming an object should not be seen along the lines of modifying the object to hold its name either. On the contrary, the act of giving a name should be thought of in terms of remembering an object by means of a label. Also, since a distinction is not the private property of the name either, you are free to give a distinction as many names as you want."
      },
      "date": 1660153081540
    },
    {
      "item": {
        "type": "factory",
        "id": "d805c753025d780d"
      },
      "id": "d805c753025d780d",
      "type": "add",
      "after": "50a7b5ffb2fa6b53",
      "date": 1660153131155
    },
    {
      "type": "edit",
      "id": "d805c753025d780d",
      "item": {
        "type": "paragraph",
        "id": "d805c753025d780d",
        "text": "Commonplace keywords like instanceVariableNames: and expressions such as “temporary variable names” take a whole new meaning from this point of view. In fact, they should not even contain the term variable at all. Therefore, we will not refer to names by means of, or assisted by, the word variable any further."
      },
      "date": 1660153133080
    },
    {
      "type": "edit",
      "id": "d805c753025d780d",
      "item": {
        "type": "paragraph",
        "id": "d805c753025d780d",
        "text": "Commonplace keywords like `instanceVariableNames:` and expressions such as “temporary variable names” take a whole new meaning from this point of view. In fact, they should not even contain the term variable at all. Therefore, we will not refer to names by means of, or assisted by, the word variable any further."
      },
      "date": 1660153148871
    },
    {
      "type": "edit",
      "id": "d805c753025d780d",
      "item": {
        "type": "markdown",
        "id": "d805c753025d780d",
        "text": "Commonplace keywords like `instanceVariableNames:` and expressions such as “temporary variable names” take a whole new meaning from this point of view. In fact, they should not even contain the term variable at all. Therefore, we will not refer to names by means of, or assisted by, the word variable any further."
      },
      "date": 1660153150153
    },
    {
      "type": "edit",
      "id": "d805c753025d780d",
      "item": {
        "type": "markdown",
        "id": "d805c753025d780d",
        "text": "Commonplace keywords like `instanceVariableNames:` and expressions such as “temporary variable names” take a whole new meaning from this point of view. In fact, they should not even contain the term variable at all. Therefore, we will not refer to names by means of, or assisted by, the word *variable* any further."
      },
      "date": 1660153182153
    },
    {
      "item": {
        "type": "factory",
        "id": "8c292a8be5671b3a"
      },
      "id": "8c292a8be5671b3a",
      "type": "add",
      "after": "d805c753025d780d",
      "date": 1660153251509
    },
    {
      "type": "edit",
      "id": "8c292a8be5671b3a",
      "item": {
        "type": "paragraph",
        "id": "8c292a8be5671b3a",
        "text": "> Note how without the word variable, this statement becomes trivial."
      },
      "date": 1660153254089
    },
    {
      "type": "edit",
      "id": "8c292a8be5671b3a",
      "item": {
        "type": "markdown",
        "id": "8c292a8be5671b3a",
        "text": "> Note how without the word variable, this statement becomes trivial."
      },
      "date": 1660153255166
    },
    {
      "item": {
        "type": "factory",
        "id": "c24f6ee61f607153"
      },
      "id": "c24f6ee61f607153",
      "type": "add",
      "after": "8c292a8be5671b3a",
      "date": 1660153265390
    },
    {
      "type": "edit",
      "id": "c24f6ee61f607153",
      "item": {
        "type": "paragraph",
        "id": "c24f6ee61f607153",
        "text": "Ideas like instance name encapsulation also take a new powerful meaning when viewed in terms of distinctions. Instance names live inside the boundary of instances, thus in order to get at them the boundary of the instance has to be crossed."
      },
      "date": 1660153267091
    },
    {
      "item": {
        "type": "factory",
        "id": "409b79f0198e5147"
      },
      "id": "409b79f0198e5147",
      "type": "add",
      "after": "c24f6ee61f607153",
      "date": 1660153306227
    },
    {
      "type": "edit",
      "id": "409b79f0198e5147",
      "item": {
        "type": "paragraph",
        "id": "409b79f0198e5147",
        "text": "Since everything that happens in Smalltalk occurs in terms of messages, it turns out that messages are the only entities that can cross boundaries, possibly carrying other objects (distinctions) with them."
      },
      "date": 1660153308082
    },
    {
      "item": {
        "type": "factory",
        "id": "b44ef0de000edeae"
      },
      "id": "b44ef0de000edeae",
      "type": "add",
      "after": "409b79f0198e5147",
      "date": 1660153324207
    },
    {
      "type": "edit",
      "id": "b44ef0de000edeae",
      "item": {
        "type": "markdown",
        "id": "b44ef0de000edeae",
        "text": "> Did we mention Alan Kay has a biology background?"
      },
      "date": 1660153327933
    },
    {
      "item": {
        "type": "factory",
        "id": "fe2ed78112e7dcf9"
      },
      "id": "fe2ed78112e7dcf9",
      "type": "add",
      "after": "b44ef0de000edeae",
      "date": 1660153355730
    },
    {
      "type": "edit",
      "id": "fe2ed78112e7dcf9",
      "item": {
        "type": "paragraph",
        "id": "fe2ed78112e7dcf9",
        "text": "Compare this mass of distinctions and messages crossing boundaries with other complex systems in which objects interact. One example could be a live multicellular being such as yourself, in which multiple cells typically influence the behavior of each other by means of protein messages which cross cell membranes."
      },
      "date": 1660153357485
    },
    {
      "item": {
        "type": "factory",
        "id": "8d4194ff655fcf9c"
      },
      "id": "8d4194ff655fcf9c",
      "type": "add",
      "after": "fe2ed78112e7dcf9",
      "date": 1660153519062
    },
    {
      "type": "edit",
      "id": "8d4194ff655fcf9c",
      "item": {
        "type": "paragraph",
        "id": "8d4194ff655fcf9c",
        "text": "Or let’s say you would like to have lunch with a friend. In an assembler or obfuscated C world, you would reach inside your friend’s mind and manipulate values and pointers until you made lunch appear attractive. You might even tickle the stomach to get the appetite going."
      },
      "date": 1660153520734
    },
    {
      "item": {
        "type": "factory",
        "id": "f0df324b3adf4e6b"
      },
      "id": "f0df324b3adf4e6b",
      "type": "add",
      "after": "8d4194ff655fcf9c",
      "date": 1660153545859
    },
    {
      "type": "edit",
      "id": "f0df324b3adf4e6b",
      "item": {
        "type": "paragraph",
        "id": "f0df324b3adf4e6b",
        "text": "But Smalltalk imposes much more civilized manners. In the same way that your friend is not a struct{...}, objects are not allowed to arbitrarily cross distinctions and mess with internal details. Instead, objects must communicate by means of messages. As long as the agreed upon behavior is respected, the implementation artifacts are happily taken for granted."
      },
      "date": 1660153547839
    },
    {
      "type": "edit",
      "id": "f0df324b3adf4e6b",
      "item": {
        "type": "paragraph",
        "id": "f0df324b3adf4e6b",
        "text": "But Smalltalk imposes much more civilized manners. In the same way that your friend is not a `struct{...}, objects are not allowed to arbitrarily cross distinctions and mess with internal details. Instead, objects must communicate by means of messages. As long as the agreed upon behavior is respected, the implementation artifacts are happily taken for granted."
      },
      "date": 1660153572557
    },
    {
      "type": "edit",
      "id": "f0df324b3adf4e6b",
      "item": {
        "type": "paragraph",
        "id": "f0df324b3adf4e6b",
        "text": "But Smalltalk imposes much more civilized manners. In the same way that your friend is not a `struct{...}`, objects are not allowed to arbitrarily cross distinctions and mess with internal details. Instead, objects must communicate by means of messages. As long as the agreed upon behavior is respected, the implementation artifacts are happily taken for granted."
      },
      "date": 1660153577578
    },
    {
      "type": "edit",
      "id": "f0df324b3adf4e6b",
      "item": {
        "type": "markdown",
        "id": "f0df324b3adf4e6b",
        "text": "But Smalltalk imposes much more civilized manners. In the same way that your friend is not a `struct{...}`, objects are not allowed to arbitrarily cross distinctions and mess with internal details. Instead, objects must communicate by means of messages. As long as the agreed upon behavior is respected, the implementation artifacts are happily taken for granted."
      },
      "date": 1660153578984
    },
    {
      "item": {
        "type": "factory",
        "id": "e6c1553bc0faf5f9"
      },
      "id": "e6c1553bc0faf5f9",
      "type": "add",
      "after": "f0df324b3adf4e6b",
      "date": 1660153606693
    },
    {
      "type": "edit",
      "id": "e6c1553bc0faf5f9",
      "item": {
        "type": "paragraph",
        "id": "e6c1553bc0faf5f9",
        "text": "If we keep in mind that everything in Smalltalk is a distinction, and that all distinctions can be named, then it follows that it must be possible to name every distinguished bit of behavior. In Smalltalk, the names of bits of behavior are called selectors."
      },
      "date": 1660153608643
    },
    {
      "type": "edit",
      "id": "e6c1553bc0faf5f9",
      "item": {
        "type": "paragraph",
        "id": "e6c1553bc0faf5f9",
        "text": "If we keep in mind that everything in Smalltalk is a distinction, and that all distinctions can be named, then it follows that it must be possible to name every distinguished bit of behavior. In Smalltalk, the names of bits of behavior are called *selectors*."
      },
      "date": 1660153634763
    },
    {
      "type": "edit",
      "id": "e6c1553bc0faf5f9",
      "item": {
        "type": "markdown",
        "id": "e6c1553bc0faf5f9",
        "text": "If we keep in mind that everything in Smalltalk is a distinction, and that all distinctions can be named, then it follows that it must be possible to name every distinguished bit of behavior. In Smalltalk, the names of bits of behavior are called *selectors*."
      },
      "date": 1660153636094
    },
    {
      "item": {
        "type": "factory",
        "id": "482128beeba0fef1"
      },
      "id": "482128beeba0fef1",
      "type": "add",
      "after": "e6c1553bc0faf5f9",
      "date": 1660153650483
    },
    {
      "type": "edit",
      "id": "482128beeba0fef1",
      "item": {
        "type": "paragraph",
        "id": "482128beeba0fef1",
        "text": "Since messages provide the only mechanism to cross into a distinction, it obviously follows that even the behavior named `instVarAt:` must be a message."
      },
      "date": 1660153660162
    },
    {
      "type": "edit",
      "id": "482128beeba0fef1",
      "item": {
        "type": "markdown",
        "id": "482128beeba0fef1",
        "text": "Since messages provide the only mechanism to cross into a distinction, it obviously follows that even the behavior named `instVarAt:` must be a message."
      },
      "date": 1660153662197
    },
    {
      "item": {
        "type": "factory",
        "id": "e6e9117ae2d01b05"
      },
      "id": "e6e9117ae2d01b05",
      "type": "add",
      "after": "482128beeba0fef1",
      "date": 1660153678771
    },
    {
      "type": "edit",
      "id": "e6e9117ae2d01b05",
      "item": {
        "type": "pagefold",
        "id": "e6e9117ae2d01b05",
        "text": "~"
      },
      "date": 1660153682786
    },
    {
      "item": {
        "type": "factory",
        "id": "8ca38823fcd18412"
      },
      "id": "8ca38823fcd18412",
      "type": "add",
      "after": "e6e9117ae2d01b05",
      "date": 1660153684221
    },
    {
      "type": "edit",
      "id": "8ca38823fcd18412",
      "item": {
        "type": "paragraph",
        "id": "8ca38823fcd18412",
        "text": "For those not familiar with the message `instVarAt:`, what sending it does is to answer the object referenced by the nth instance name of the receiver. This works because all instance variables are stored in the order given by the class and superclass definitions. Feel free to check out the implementation in your Smalltalk of choice."
      },
      "date": 1660153692567
    },
    {
      "type": "edit",
      "id": "8ca38823fcd18412",
      "item": {
        "type": "markdown",
        "id": "8ca38823fcd18412",
        "text": "For those not familiar with the message `instVarAt:`, what sending it does is to answer the object referenced by the nth instance name of the receiver. This works because all instance variables are stored in the order given by the class and superclass definitions. Feel free to check out the implementation in your Smalltalk of choice."
      },
      "date": 1660153693774
    },
    {
      "item": {
        "type": "factory",
        "id": "cc3ed01a84a8b5b4"
      },
      "id": "cc3ed01a84a8b5b4",
      "type": "add",
      "after": "8ca38823fcd18412",
      "date": 1660153720502
    },
    {
      "type": "edit",
      "id": "cc3ed01a84a8b5b4",
      "item": {
        "type": "pagefold",
        "id": "cc3ed01a84a8b5b4",
        "text": "."
      },
      "date": 1660153724123
    },
    {
      "item": {
        "type": "factory",
        "id": "5599b7e7fcea5186"
      },
      "id": "5599b7e7fcea5186",
      "type": "add",
      "after": "cc3ed01a84a8b5b4",
      "date": 1660153741198
    },
    {
      "type": "edit",
      "id": "5599b7e7fcea5186",
      "item": {
        "type": "paragraph",
        "id": "5599b7e7fcea5186",
        "text": "On the Use of Labels with the Special Object Array"
      },
      "date": 1660153745925
    },
    {
      "type": "edit",
      "id": "5599b7e7fcea5186",
      "item": {
        "type": "paragraph",
        "id": "5599b7e7fcea5186",
        "text": "⇒ On the Use of Labels with the Special Object Array"
      },
      "date": 1660153752490
    },
    {
      "type": "edit",
      "id": "c087350e20108f44",
      "item": {
        "type": "markdown",
        "id": "c087350e20108f44",
        "text": "In [[Smalltalk]], objects *are* distinctions. Since everything in Smalltalk is an object, then everything in Smalltalk is a distinction."
      },
      "date": 1660202314523
    },
    {
      "type": "edit",
      "id": "c087350e20108f44",
      "item": {
        "type": "markdown",
        "id": "c087350e20108f44",
        "text": "In [[Smalltalk]], objects *are* distinctions. Since everything in Smalltalk is an object, then everything in Smalltalk is a [[Distinction]]."
      },
      "date": 1702993049341
    },
    {
      "type": "edit",
      "id": "8ca38823fcd18412",
      "item": {
        "type": "markdown",
        "id": "8ca38823fcd18412",
        "text": "For those not familiar with the message `instVarAt:`, what sending it does is to answer the object referenced by the nth instance name of the receiver. This works because all instance variables are stored in the order given by the [[Class]] and superclass definitions. Feel free to check out the implementation in your Smalltalk of choice."
      },
      "date": 1702993162685
    },
    {
      "type": "edit",
      "id": "a5ae46ea3699513c",
      "item": {
        "type": "paragraph",
        "id": "a5ae46ea3699513c",
        "text": "If we look at this in terms of the piece of paper analogy, instance variables inside an object are circles inside an enclosing circle. To distinguish between instance variables in the context of an object, we typically name them just like we name circles. See [[Doughnut]]"
      },
      "date": 1702993219968
    },
    {
      "type": "edit",
      "id": "a5ae46ea3699513c",
      "item": {
        "type": "paragraph",
        "id": "a5ae46ea3699513c",
        "text": "If we look at this in terms of the piece of paper analogy, instance variables inside an object are circles inside an enclosing circle. To distinguish between instance variables in the context of an object, we typically name them just like we name circles. See [[Doughnut]]."
      },
      "date": 1702993224250
    },
    {
      "type": "fork",
      "site": "wiki.ralfbarkow.ch",
      "date": 1703083570717
    }
  ]
}