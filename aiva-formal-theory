{
  "title": "AIVA Formal Theory",
  "story": [
    {
      "type": "markdown",
      "id": "06584bb7b0408f6c",
      "text": "Definitions [https://kengz.github.io/aiva-doc/#design36 page]\n\n * g: The entire graph of CGKB\n * g_i, h: placeholder for any subgraph of g\n * Contextualize: the Contextualize algorithm\n * c_0: the initial context, determined from fn, i_p\n * <fn, i_p>: the canonicalized input from the interface of HTMI [https://kengz.github.io/aiva-doc/#human-turing-machine-interface page] after parsing a human input, where fn is a TM function, and i_p the partial information needed for fn’s execution.\n * filter: fields used to filter context, i.e. constrain the expansion of initial context in the Contexualize algorithm; thus far they are {privacy, entity, ranking, time, constraints, graph properties}\n * scope: the lists of fulfilled and unfulfilled information, scope_f, i_u respectively for the extraction of i for fn(i).\n * c: contextual (knowledge) graph, or the contextualized subgraph, i.e. the output Contextualize(g, c_0, i_p); c ⊂ g\n * i ∈ I: the complete information needed to compute fn(i). It is encoded within g; obviously there exists a smallest subgraph h ⊂ g that sufficiently encodes i. Equivalently i is the union of partial information i_1, i_2, ...\n * k: knowledge, i.e. the complete information extractable from g. Note i ⊂ k, but fn(i) = fn(k) since the TM function fn only computes using the needed information.\n * k_h: the information extractable from subgraph h ⊂ g. Note k = k_g.\n * Ex: the extraction operator to extract knowledge from a graph, e.g. k = Ex(g), k_h = Ex(h)\n * -*->: graph path, or ‘derives’. We say g_1 -*-> g_2 if g_1 is connected to g_2, and k_1 -*-> k_2 if k_1 derives k_2.\n"
    },
    {
      "type": "paragraph",
      "id": "5c68ce28aa0c62e6",
      "text": "Axioms"
    },
    {
      "type": "paragraph",
      "id": "bf457f2bc0e6ec31",
      "text": "[…]"
    },
    {
      "type": "markdown",
      "id": "4cb6726fcedc78c8",
      "text": "1. Knowledge is encoded in a graph g, and decoded using the Ex operator.\n2. Knowledge is deriverable, and this is reflected in its graph encoding by connectedness. Let k_1 = Ex(g_1), k_2 = Ex(g_2), if k_1 derives k_2, i.e. k_1 -*-> k_2, then there must exists a corresponding path g_1 -*-> g_2, s.t. (k_1 ∪ k_2) is extractable from the connected component CC of g_1, i.e. (k_1 ∪ k_2) ⊂ Ex(CC(g_1)).\n3. Base knowledge (graph sink) is the most basic knowledge, and is the source of the derivation path. If the path is cyclic, arbitrarily choose the last-encountered node as the basic knowledge. Base knowledge resolves all knowledge along the derivation path by gradual substitutions."
    },
    {
      "type": "paragraph",
      "id": "b257a75ec0460146",
      "text": "⇒ [[Contextualize Algorithm]]"
    },
    {
      "type": "paragraph",
      "id": "724fdb36bafd6429",
      "text": "⇒ [[Connectivity of Nodes]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "AIVA Formal Theory",
        "story": []
      },
      "date": 1709212969640
    },
    {
      "item": {
        "type": "factory",
        "id": "b0c06cc561302010"
      },
      "id": "b0c06cc561302010",
      "type": "add",
      "date": 1709212997055
    },
    {
      "type": "edit",
      "id": "b0c06cc561302010",
      "item": {
        "type": "paragraph",
        "id": "b0c06cc561302010",
        "text": "[https://kengz.github.io/aiva-doc/#design36 page]"
      },
      "date": 1709213006596
    },
    {
      "item": {
        "type": "factory",
        "id": "06584bb7b0408f6c"
      },
      "id": "06584bb7b0408f6c",
      "type": "add",
      "after": "b0c06cc561302010",
      "date": 1709213024846
    },
    {
      "type": "edit",
      "id": "06584bb7b0408f6c",
      "item": {
        "type": "markdown",
        "id": "06584bb7b0408f6c",
        "text": "Definitions\n\n    g: The entire graph of CGKB\n    g_i, h: placeholder for any subgraph of g\n    Contextualize: the Contextualize algorithm\n    c_0: the initial context, determined from fn, i_p\n    <fn, i_p>: the canonicalized input from the interface of HTMI after parsing a human input, where fn is a TM function, and i_p the partial information needed for fn’s execution.\n    filter: fields used to filter context, i.e. constrain the expansion of initial context in the Contexualize algorithm; thus far they are {privacy, entity, ranking, time, constraints, graph properties}\n    scope: the lists of fulfilled and unfulfilled information, scope_f, i_u respectively for the extraction of i for fn(i).\n    c: contextual (knowledge) graph, or the contextualized subgraph, i.e. the output Contextualize(g, c_0, i_p); c ⊂ g\n    i ∈ I: the complete information needed to compute fn(i). It is encoded within g; obviously there exists a smallest subgraph h ⊂ g that sufficiently encodes i. Equivalently i is the union of partial information i_1, i_2, ...\n    k: knowledge, i.e. the complete information extractable from g. Note i ⊂ k, but fn(i) = fn(k) since the TM function fn only computes using the needed information.\n    k_h: the information extractable from subgraph h ⊂ g. Note k = k_g.\n    Ex: the extraction operator to extract knowledge from a graph, e.g. k = Ex(g), k_h = Ex(h)\n    -*->: graph path, or ‘derives’. We say g_1 -*-> g_2 if g_1 is connected to g_2, and k_1 -*-> k_2 if k_1 derives k_2.\n"
      },
      "date": 1709213027203
    },
    {
      "type": "edit",
      "id": "06584bb7b0408f6c",
      "item": {
        "type": "markdown",
        "id": "06584bb7b0408f6c",
        "text": "Definitions\n\n * g: The entire graph of CGKB\n * g_i, h: placeholder for any subgraph of g\n * Contextualize: the Contextualize algorithm\n * c_0: the initial context, determined from fn, i_p\n * <fn, i_p>: the canonicalized input from the interface of HTMI after parsing a human input, where fn is a TM function, and i_p the partial information needed for fn’s execution.\n * filter: fields used to filter context, i.e. constrain the expansion of initial context in the Contexualize algorithm; thus far they are {privacy, entity, ranking, time, constraints, graph properties}\n * scope: the lists of fulfilled and unfulfilled information, scope_f, i_u respectively for the extraction of i for fn(i).\n * c: contextual (knowledge) graph, or the contextualized subgraph, i.e. the output Contextualize(g, c_0, i_p); c ⊂ g\n * i ∈ I: the complete information needed to compute fn(i). It is encoded within g; obviously there exists a smallest subgraph h ⊂ g that sufficiently encodes i. Equivalently i is the union of partial information i_1, i_2, ...\n * k: knowledge, i.e. the complete information extractable from g. Note i ⊂ k, but fn(i) = fn(k) since the TM function fn only computes using the needed information.\n * k_h: the information extractable from subgraph h ⊂ g. Note k = k_g.\n * Ex: the extraction operator to extract knowledge from a graph, e.g. k = Ex(g), k_h = Ex(h)\n * -*->: graph path, or ‘derives’. We say g_1 -*-> g_2 if g_1 is connected to g_2, and k_1 -*-> k_2 if k_1 derives k_2.\n"
      },
      "date": 1709213074742
    },
    {
      "type": "remove",
      "id": "b0c06cc561302010",
      "date": 1709213082216
    },
    {
      "type": "edit",
      "id": "06584bb7b0408f6c",
      "item": {
        "type": "markdown",
        "id": "06584bb7b0408f6c",
        "text": "Definitions [https://kengz.github.io/aiva-doc/#design36 page]\n\n * g: The entire graph of CGKB\n * g_i, h: placeholder for any subgraph of g\n * Contextualize: the Contextualize algorithm\n * c_0: the initial context, determined from fn, i_p\n * <fn, i_p>: the canonicalized input from the interface of HTMI after parsing a human input, where fn is a TM function, and i_p the partial information needed for fn’s execution.\n * filter: fields used to filter context, i.e. constrain the expansion of initial context in the Contexualize algorithm; thus far they are {privacy, entity, ranking, time, constraints, graph properties}\n * scope: the lists of fulfilled and unfulfilled information, scope_f, i_u respectively for the extraction of i for fn(i).\n * c: contextual (knowledge) graph, or the contextualized subgraph, i.e. the output Contextualize(g, c_0, i_p); c ⊂ g\n * i ∈ I: the complete information needed to compute fn(i). It is encoded within g; obviously there exists a smallest subgraph h ⊂ g that sufficiently encodes i. Equivalently i is the union of partial information i_1, i_2, ...\n * k: knowledge, i.e. the complete information extractable from g. Note i ⊂ k, but fn(i) = fn(k) since the TM function fn only computes using the needed information.\n * k_h: the information extractable from subgraph h ⊂ g. Note k = k_g.\n * Ex: the extraction operator to extract knowledge from a graph, e.g. k = Ex(g), k_h = Ex(h)\n * -*->: graph path, or ‘derives’. We say g_1 -*-> g_2 if g_1 is connected to g_2, and k_1 -*-> k_2 if k_1 derives k_2.\n"
      },
      "date": 1709213085129
    },
    {
      "item": {
        "type": "factory",
        "id": "5c68ce28aa0c62e6"
      },
      "id": "5c68ce28aa0c62e6",
      "type": "add",
      "after": "06584bb7b0408f6c",
      "date": 1709213152997
    },
    {
      "type": "edit",
      "id": "5c68ce28aa0c62e6",
      "item": {
        "type": "paragraph",
        "id": "5c68ce28aa0c62e6",
        "text": "[…]"
      },
      "date": 1709213167217
    },
    {
      "type": "add",
      "id": "b257a75ec0460146",
      "item": {
        "type": "paragraph",
        "id": "b257a75ec0460146",
        "text": "⇒ [[Contextualize Algorithm]]"
      },
      "after": "5c68ce28aa0c62e6",
      "date": 1709213173241
    },
    {
      "item": {
        "type": "factory",
        "id": "630ef590e84fef6e"
      },
      "id": "630ef590e84fef6e",
      "type": "add",
      "after": "b257a75ec0460146",
      "date": 1709213196277
    },
    {
      "type": "edit",
      "id": "630ef590e84fef6e",
      "item": {
        "type": "paragraph",
        "id": "630ef590e84fef6e",
        "text": "Let there be given graph g, initial context c_0, partial information i_p.\n\ninput: g, c_0, i_p\n\noutput: contextual knowledge graph c\n\nenumerate:\n\n    Initialize scope from c_0, i_p\n    while scope is not completely fulfilled, do:\n        BFS expansion on c_0 using the unfulfilled scope, filters and i_p, and\n        if context is expanded, update scope, continue;\n        else, apply learning with inquire to expand g (but not context and scope); then retry on success or break on failure.\n    Return the context c, along with the fulfilled scope for direct access of i.\n\nWe also call the resulting context c the contextual knowledge graph, and the extractable knowledge k_c = Ex(c) the contextual knowledge, obtained by using g, c_0, i_p, filters. Note also fn(i) = fn(k_c), thus the resulting contextual knowledge is sufficient for TM computation.\n\nWe prove below that this algorithm yields knowledge that is g-bounded complete; it also proves that the algorithm is correct."
      },
      "date": 1709213197939
    },
    {
      "id": "630ef590e84fef6e",
      "type": "remove",
      "removedTo": {
        "page": "Contextualize Algorithm"
      },
      "date": 1709213215226
    },
    {
      "type": "edit",
      "id": "5c68ce28aa0c62e6",
      "item": {
        "type": "paragraph",
        "id": "5c68ce28aa0c62e6",
        "text": "Axioms"
      },
      "date": 1709213305382
    },
    {
      "type": "add",
      "id": "bf457f2bc0e6ec31",
      "item": {
        "type": "paragraph",
        "id": "bf457f2bc0e6ec31",
        "text": "[…]"
      },
      "after": "5c68ce28aa0c62e6",
      "date": 1709213307379
    },
    {
      "item": {
        "type": "factory",
        "id": "4cb6726fcedc78c8"
      },
      "id": "4cb6726fcedc78c8",
      "type": "add",
      "after": "b257a75ec0460146",
      "date": 1709213353650
    },
    {
      "type": "edit",
      "id": "4cb6726fcedc78c8",
      "item": {
        "type": "markdown",
        "id": "4cb6726fcedc78c8",
        "text": "1. Knowledge is encoded in a graph g, and decoded using the Ex operator.\n2. Knowledge is deriverable, and this is reflected in its graph encoding by connectedness. Let k_1 = Ex(g_1), k_2 = Ex(g_2), if k_1 derives k_2, i.e. k_1 -*-> k_2, then there must exists a corresponding path g_1 -*-> g_2, s.t. (k_1 ∪ k_2) is extractable from the connected component CC of g_1, i.e. (k_1 ∪ k_2) ⊂ Ex(CC(g_1)).\n3. Base knowledge (graph sink) is the most basic knowledge, and is the source of the derivation path. If the path is cyclic, arbitrarily choose the last-encountered node as the basic knowledge. Base knowledge resolves all knowledge along the derivation path by gradual substitutions."
      },
      "date": 1709213356541
    },
    {
      "id": "4cb6726fcedc78c8",
      "type": "move",
      "order": [
        "06584bb7b0408f6c",
        "5c68ce28aa0c62e6",
        "bf457f2bc0e6ec31",
        "4cb6726fcedc78c8",
        "b257a75ec0460146"
      ],
      "date": 1709213366498
    },
    {
      "type": "edit",
      "id": "06584bb7b0408f6c",
      "item": {
        "type": "markdown",
        "id": "06584bb7b0408f6c",
        "text": "Definitions [https://kengz.github.io/aiva-doc/#design36 page]\n\n * g: The entire graph of CGKB\n * g_i, h: placeholder for any subgraph of g\n * Contextualize: the Contextualize algorithm\n * c_0: the initial context, determined from fn, i_p\n * <fn, i_p>: the canonicalized input from the interface of HTMI [https://kengz.github.io/aiva-doc/#human-turing-machine-interface page] after parsing a human input, where fn is a TM function, and i_p the partial information needed for fn’s execution.\n * filter: fields used to filter context, i.e. constrain the expansion of initial context in the Contexualize algorithm; thus far they are {privacy, entity, ranking, time, constraints, graph properties}\n * scope: the lists of fulfilled and unfulfilled information, scope_f, i_u respectively for the extraction of i for fn(i).\n * c: contextual (knowledge) graph, or the contextualized subgraph, i.e. the output Contextualize(g, c_0, i_p); c ⊂ g\n * i ∈ I: the complete information needed to compute fn(i). It is encoded within g; obviously there exists a smallest subgraph h ⊂ g that sufficiently encodes i. Equivalently i is the union of partial information i_1, i_2, ...\n * k: knowledge, i.e. the complete information extractable from g. Note i ⊂ k, but fn(i) = fn(k) since the TM function fn only computes using the needed information.\n * k_h: the information extractable from subgraph h ⊂ g. Note k = k_g.\n * Ex: the extraction operator to extract knowledge from a graph, e.g. k = Ex(g), k_h = Ex(h)\n * -*->: graph path, or ‘derives’. We say g_1 -*-> g_2 if g_1 is connected to g_2, and k_1 -*-> k_2 if k_1 derives k_2.\n"
      },
      "date": 1709214090186
    },
    {
      "type": "add",
      "id": "724fdb36bafd6429",
      "item": {
        "type": "paragraph",
        "id": "724fdb36bafd6429",
        "text": "⇒ [[Connectivity of Nodes[["
      },
      "after": "b257a75ec0460146",
      "date": 1709215228399
    },
    {
      "type": "edit",
      "id": "724fdb36bafd6429",
      "item": {
        "type": "paragraph",
        "id": "724fdb36bafd6429",
        "text": "⇒ [[Connectivity of Nodes]]"
      },
      "date": 1709215232641
    },
    {
      "type": "fork",
      "site": "wiki.ralfbarkow.ch",
      "date": 1709475323659
    }
  ]
}