{
  "title": "Two Phase Commit",
  "story": [
    {
      "type": "html",
      "text": "A feature of transaction processing systems that enables databases or other transacted resources to be returned to the pre-transaction state if some error condition occurs.  Sometimes abbreviated 2PC.  Under 2PC, a single transaction can update many different databases or resources, and these resources may be distributed across networks, and have independent availability and failure modes. The two-phase commit strategy is designed to ensure that either all the resources are updated or none of them, so that the resources under transactional control remain synchronized. ",
      "id": "0150e27c199a56db5c17b64991abbeb3"
    },
    {
      "type": "html",
      "text": "\nResources that participate in 2PC agree to be managed by a transaction manager.  ",
      "id": "5c6c1647e0fcb01ee0c2d53849f18079"
    },
    {
      "type": "html",
      "text": "\nIn the X/Open model, there are 3 parties: the application, the resource manager (RM), and the transaction manager (TM).   An example of an RM might be a database (like Oracle, DB2, SQL Server) or a transactional message queue (like IBM MQSeries or Microsoft Message Queue).  An example of an App is, the code that denotes the transaction operation. The TM is often invisible to the app, but plays the role of director when multiple distributed RMs participate in a transaction.  ",
      "id": "5447611ca3bdefeef34017a413539f2d"
    },
    {
      "type": "html",
      "text": "\nThe way it works:  ",
      "id": "d278fc7fb75be099f2a6c2446c4290ea"
    },
    {
      "type": "html",
      "text": "The app begins a transaction.  The TM opens and maintains a context on behalf of the app.  ",
      "id": "2d082ce066b53a87360bcc5da304f62b"
    },
    {
      "type": "html",
      "text": "The app then contacts an RM and reads or writes within the context of that transaction.  The app must communicate to the RM via a client library that is aware of the TM, and the RM itself must be aware of the TM context. ",
      "id": "cb0ed76e262660221e250488af0686c5"
    },
    {
      "type": "html",
      "text": "The app can then contact other RMs similarly.  ",
      "id": "03f02be41818559e930e93a04305b1cb"
    },
    {
      "type": "html",
      "text": "When the app is finished, it can request a commit.  ",
      "id": "be9d0963a2e37cd6307c9ee431673c32"
    },
    {
      "type": "html",
      "text": "The TM then contacts each RM that was involved in the transaction, and sends the \"prepare\" command.  Essentially the TM is asking the RM, \"the changes performed at your resource, on behalf of this transaction - can you make them permanent?\"  ",
      "id": "4e31ee829d24e03a417ac466dd53cf87"
    },
    {
      "type": "html",
      "text": "Each RM then must respond \"commit\" or \"abort\" .  This is sometimes called the \"vote\".  If the RM votes to commit, it implicitly assures the TM that no changes will be lost, even in the face of failure (like power failure, or network failure).  This generally means the RM must store its changes to durable media, like a disk.  ",
      "id": "8b5dfd1c152934e521573cf7d2876265"
    },
    {
      "type": "html",
      "text": "If the TM gets a unanimous \"commit\" vote, then the TM sends \"commit\" messages to each RM.   If any RM votes to abort, then the TM Sends an abort message to each RM.  ",
      "id": "289565f6163fb6987c2e69f8078f44af"
    },
    {
      "type": "html",
      "text": "Each RM receives the direction of the TM, and then either rolls forward or back, and releases locks held on behalf of the transaction.  If the network is interrupted and the RM never gets the message, the RM never resolves the transaction.  In this case administrator intervention may be required. ",
      "id": "190cf163a90b0f562463b2c0fd42cf1a"
    },
    {
      "type": "html",
      "text": "\nSee also: ",
      "id": "014d1e0f88d44d1a510752530fdc1212"
    },
    {
      "type": "html",
      "text": "[http://webopedia.internet.com/TERM/t/two_phase_commit.html webopedia.internet.com]",
      "id": "7d045a9bf7eaaecea39cc9c7fc065761"
    },
    {
      "type": "html",
      "text": "[http://en.wikipedia.org/wiki/Two-phase-commit_protocol en.wikipedia.org]",
      "id": "b90f95fce1e1aa14a7659fe1e81207c6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "72068659528cada948cf062fc2659e4d"
    },
    {
      "type": "html",
      "text": "It has been my understanding that two-phase commit had largely been discredited, at least as a way of keeping databases synchronized, since if any of the several databases is down, none can continue. More recent replication strategies (while not as simple as the salesman might suggest) do a better job. Any input from real world users?",
      "id": "cb1050c332c926d50affdc1d191db968"
    },
    {
      "type": "html",
      "text": "''No, not discredited at all!  a better word is, 2PC is better understood.   For example: the use of distributed transactions implies synchronizing updates to multiple independent data stores, and therefore the reliability of the system as a whole is reduced.  Suppose the availability rate of a database is 99%, and the availability of a message queue is 99%.  A distributed transaction involving both of them would have an availability of 0.99*0.99 = ~98%.  If you add another resource, you would reduce the availability of the app further.  BUT,  in cases where synchronized updates are required, 2PC is quite useful.  It's a case of knowing when to use it.   -- [[Dino Chiesa]]",
      "id": "629e50de6a5a02094d5e03e31dfed043"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "72068659528cada948cf062fc2659e4d"
    },
    {
      "type": "html",
      "text": "It's also true that waiting for all databases to be updated is a bad strategy. Even if no database is down, you can be sure that one of them is the slowest, and if you wait for all databases to be updated before continuing, then you're running at the speed of the slowest one.",
      "id": "d12f0d3d01ed16b00efe4b7c152c53f0"
    },
    {
      "type": "html",
      "text": "\nHowever, there are cases where two-phase commit makes sense.  For example, suppose you have an application design that accepts incoming messages on a queue.  When a message arrives, the design calls for a row in a database to be updated or modified.  How does one coordinate the updates across these two independent stores?  A two-phased commit makes this sort of application possible.  ",
      "id": "0700d5ed24befac47f0f72c84c71d607"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "72068659528cada948cf062fc2659e4d"
    },
    {
      "type": "html",
      "text": "<b>2PC != Transaction</b>",
      "id": "88be4bfa8ce88732e98ade91d4226f35"
    },
    {
      "type": "html",
      "text": "\nTransactions are sometimes confused with 2PC.  2PC is an example of a distributed transaction commit protocol.  While transactions can be used across distributed resources, the transaction concept is also often (most often?) used within a single resource manager, for example to to keep tables consistent within a single database.  ",
      "id": "32642c263ee5f41255517b2a3ba2e1e4"
    },
    {
      "type": "html",
      "text": "\nExample: Let's say you want to transfer $20 from your checking account to your savings account. The bank's computer might do something like this:",
      "id": "d146484ece68e5a32ce4823b4f29adad"
    },
    {
      "type": "html",
      "text": " BEGIN TRANSACTION",
      "id": "333e22091a5be3c550d61e7cdbe9887c"
    },
    {
      "type": "html",
      "text": " Debit checking account $20.",
      "id": "7acf7f17ca381ae1d32a30dd7998f1a2"
    },
    {
      "type": "html",
      "text": " Credit savings account $20.",
      "id": "0f4bd634b49e6ef6bb0c2319d1f996db"
    },
    {
      "type": "html",
      "text": " COMMIT TRANSACTION",
      "id": "b8f5093ea8389987fde7d51ed68332b4"
    },
    {
      "type": "html",
      "text": "\nIf the database crashes between step 2 and 3 without transaction control, you could end up with one account debited but the other one not being credited.  By wrapping the steps in a transaction, you are assured that either both steps will be completed or the whole transaction will be \"rolled back\", that is to say, the database will be in the state it was in before the transaction. In this case, that means that neither account will be changed. <i>This is an example of a transaction that DOES NOT use 2PC.</i>",
      "id": "b30159c85abb55fabaef71004fa68936"
    },
    {
      "type": "html",
      "text": "\nAs long as you're not running with distributed databases, \"single phase\" commit is what is used. All the necessary information for the transaction to be undone or completed are written to persistent storage (typically called a \"transaction log\") in an atomic step. The transaction is committed as soon as this information is permanently recorded.  This is not possible in a distributed system, as there's no guarantee that the commit record is written on all participating systems. With distributed databases, [[Two Phase Commit]] solves this problem.",
      "id": "fd93e1e1039f2f7a67935161d0e60c10"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "72068659528cada948cf062fc2659e4d"
    },
    {
      "type": "html",
      "text": "\n[[Two Phase Commit]] assumes reliable communications and tends to utilize locking (between receipt of 'Prepare' and TM's final 'Commit').  If the communications are unreliable (especially if the TM can go down in the middle of a commit) or if blocking is undesirable, [[Three Phase Commit]] will be required.",
      "id": "978c81e601084e6d75b211f58e23baa8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "72068659528cada948cf062fc2659e4d"
    },
    {
      "type": "html",
      "text": "In [[Version Control]](CVS), most developers do an update(checks for conflicts with repository), then a commit(write to repository). Most of the time it's a two step process, but sometimes it's of the form: update, if no conflicts, do a commit(as one automated step). It's a little different from SQL transactions, but the goal is always to handle conflicts.",
      "id": "24d73f69c94157603fe8d4e2bdf123a8"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?TwoPhaseCommit c2.com]",
      "id": "0a8e1232817721ba5e9b5d0a92974950"
    }
  ],
  "journal": [
    {
      "date": 1357636371000,
      "id": "a197333da2f767973ac368a8fc455881",
      "type": "create",
      "item": {
        "title": "Two Phase Commit",
        "story": [
          {
            "type": "html",
            "text": "A feature of transaction processing systems that enables databases or other transacted resources to be returned to the pre-transaction state if some error condition occurs.  Sometimes abbreviated 2PC.  Under 2PC, a single transaction can update many different databases or resources, and these resources may be distributed across networks, and have independent availability and failure modes. The two-phase commit strategy is designed to ensure that either all the resources are updated or none of them, so that the resources under transactional control remain synchronized. ",
            "id": "0150e27c199a56db5c17b64991abbeb3"
          },
          {
            "type": "html",
            "text": "\nResources that participate in 2PC agree to be managed by a transaction manager.  ",
            "id": "5c6c1647e0fcb01ee0c2d53849f18079"
          },
          {
            "type": "html",
            "text": "\nIn the X/Open model, there are 3 parties: the application, the resource manager (RM), and the transaction manager (TM).   An example of an RM might be a database (like Oracle, DB2, SQL Server) or a transactional message queue (like IBM MQSeries or Microsoft Message Queue).  An example of an App is, the code that denotes the transaction operation. The TM is often invisible to the app, but plays the role of director when multiple distributed RMs participate in a transaction.  ",
            "id": "5447611ca3bdefeef34017a413539f2d"
          },
          {
            "type": "html",
            "text": "\nThe way it works:  ",
            "id": "d278fc7fb75be099f2a6c2446c4290ea"
          },
          {
            "type": "html",
            "text": "The app begins a transaction.  The TM opens and maintains a context on behalf of the app.  ",
            "id": "2d082ce066b53a87360bcc5da304f62b"
          },
          {
            "type": "html",
            "text": "The app then contacts an RM and reads or writes within the context of that transaction.  The app must communicate to the RM via a client library that is aware of the TM, and the RM itself must be aware of the TM context. ",
            "id": "cb0ed76e262660221e250488af0686c5"
          },
          {
            "type": "html",
            "text": "The app can then contact other RMs similarly.  ",
            "id": "03f02be41818559e930e93a04305b1cb"
          },
          {
            "type": "html",
            "text": "When the app is finished, it can request a commit.  ",
            "id": "be9d0963a2e37cd6307c9ee431673c32"
          },
          {
            "type": "html",
            "text": "The TM then contacts each RM that was involved in the transaction, and sends the \"prepare\" command.  Essentially the TM is asking the RM, \"the changes performed at your resource, on behalf of this transaction - can you make them permanent?\"  ",
            "id": "4e31ee829d24e03a417ac466dd53cf87"
          },
          {
            "type": "html",
            "text": "Each RM then must respond \"commit\" or \"abort\" .  This is sometimes called the \"vote\".  If the RM votes to commit, it implicitly assures the TM that no changes will be lost, even in the face of failure (like power failure, or network failure).  This generally means the RM must store its changes to durable media, like a disk.  ",
            "id": "8b5dfd1c152934e521573cf7d2876265"
          },
          {
            "type": "html",
            "text": "If the TM gets a unanimous \"commit\" vote, then the TM sends \"commit\" messages to each RM.   If any RM votes to abort, then the TM Sends an abort message to each RM.  ",
            "id": "289565f6163fb6987c2e69f8078f44af"
          },
          {
            "type": "html",
            "text": "Each RM receives the direction of the TM, and then either rolls forward or back, and releases locks held on behalf of the transaction.  If the network is interrupted and the RM never gets the message, the RM never resolves the transaction.  In this case administrator intervention may be required. ",
            "id": "190cf163a90b0f562463b2c0fd42cf1a"
          },
          {
            "type": "html",
            "text": "\nSee also: ",
            "id": "014d1e0f88d44d1a510752530fdc1212"
          },
          {
            "type": "html",
            "text": "[http://webopedia.internet.com/TERM/t/two_phase_commit.html webopedia.internet.com]",
            "id": "7d045a9bf7eaaecea39cc9c7fc065761"
          },
          {
            "type": "html",
            "text": "[http://en.wikipedia.org/wiki/Two-phase-commit_protocol en.wikipedia.org]",
            "id": "b90f95fce1e1aa14a7659fe1e81207c6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "72068659528cada948cf062fc2659e4d"
          },
          {
            "type": "html",
            "text": "It has been my understanding that two-phase commit had largely been discredited, at least as a way of keeping databases synchronized, since if any of the several databases is down, none can continue. More recent replication strategies (while not as simple as the salesman might suggest) do a better job. Any input from real world users?",
            "id": "cb1050c332c926d50affdc1d191db968"
          },
          {
            "type": "html",
            "text": "''No, not discredited at all!  a better word is, 2PC is better understood.   For example: the use of distributed transactions implies synchronizing updates to multiple independent data stores, and therefore the reliability of the system as a whole is reduced.  Suppose the availability rate of a database is 99%, and the availability of a message queue is 99%.  A distributed transaction involving both of them would have an availability of 0.99*0.99 = ~98%.  If you add another resource, you would reduce the availability of the app further.  BUT,  in cases where synchronized updates are required, 2PC is quite useful.  It's a case of knowing when to use it.   -- [[Dino Chiesa]]",
            "id": "629e50de6a5a02094d5e03e31dfed043"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "72068659528cada948cf062fc2659e4d"
          },
          {
            "type": "html",
            "text": "It's also true that waiting for all databases to be updated is a bad strategy. Even if no database is down, you can be sure that one of them is the slowest, and if you wait for all databases to be updated before continuing, then you're running at the speed of the slowest one.",
            "id": "d12f0d3d01ed16b00efe4b7c152c53f0"
          },
          {
            "type": "html",
            "text": "\nHowever, there are cases where two-phase commit makes sense.  For example, suppose you have an application design that accepts incoming messages on a queue.  When a message arrives, the design calls for a row in a database to be updated or modified.  How does one coordinate the updates across these two independent stores?  A two-phased commit makes this sort of application possible.  ",
            "id": "0700d5ed24befac47f0f72c84c71d607"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "72068659528cada948cf062fc2659e4d"
          },
          {
            "type": "html",
            "text": "<b>2PC != Transaction</b>",
            "id": "88be4bfa8ce88732e98ade91d4226f35"
          },
          {
            "type": "html",
            "text": "\nTransactions are sometimes confused with 2PC.  2PC is an example of a distributed transaction commit protocol.  While transactions can be used across distributed resources, the transaction concept is also often (most often?) used within a single resource manager, for example to to keep tables consistent within a single database.  ",
            "id": "32642c263ee5f41255517b2a3ba2e1e4"
          },
          {
            "type": "html",
            "text": "\nExample: Let's say you want to transfer $20 from your checking account to your savings account. The bank's computer might do something like this:",
            "id": "d146484ece68e5a32ce4823b4f29adad"
          },
          {
            "type": "html",
            "text": " BEGIN TRANSACTION",
            "id": "333e22091a5be3c550d61e7cdbe9887c"
          },
          {
            "type": "html",
            "text": " Debit checking account $20.",
            "id": "7acf7f17ca381ae1d32a30dd7998f1a2"
          },
          {
            "type": "html",
            "text": " Credit savings account $20.",
            "id": "0f4bd634b49e6ef6bb0c2319d1f996db"
          },
          {
            "type": "html",
            "text": " COMMIT TRANSACTION",
            "id": "b8f5093ea8389987fde7d51ed68332b4"
          },
          {
            "type": "html",
            "text": "\nIf the database crashes between step 2 and 3 without transaction control, you could end up with one account debited but the other one not being credited.  By wrapping the steps in a transaction, you are assured that either both steps will be completed or the whole transaction will be \"rolled back\", that is to say, the database will be in the state it was in before the transaction. In this case, that means that neither account will be changed. <i>This is an example of a transaction that DOES NOT use 2PC.</i>",
            "id": "b30159c85abb55fabaef71004fa68936"
          },
          {
            "type": "html",
            "text": "\nAs long as you're not running with distributed databases, \"single phase\" commit is what is used. All the necessary information for the transaction to be undone or completed are written to persistent storage (typically called a \"transaction log\") in an atomic step. The transaction is committed as soon as this information is permanently recorded.  This is not possible in a distributed system, as there's no guarantee that the commit record is written on all participating systems. With distributed databases, [[Two Phase Commit]] solves this problem.",
            "id": "fd93e1e1039f2f7a67935161d0e60c10"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "72068659528cada948cf062fc2659e4d"
          },
          {
            "type": "html",
            "text": "\n[[Two Phase Commit]] assumes reliable communications and tends to utilize locking (between receipt of 'Prepare' and TM's final 'Commit').  If the communications are unreliable (especially if the TM can go down in the middle of a commit) or if blocking is undesirable, [[Three Phase Commit]] will be required.",
            "id": "978c81e601084e6d75b211f58e23baa8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "72068659528cada948cf062fc2659e4d"
          },
          {
            "type": "html",
            "text": "In [[Version Control]](CVS), most developers do an update(checks for conflicts with repository), then a commit(write to repository). Most of the time it's a two step process, but sometimes it's of the form: update, if no conflicts, do a commit(as one automated step). It's a little different from SQL transactions, but the goal is always to handle conflicts.",
            "id": "24d73f69c94157603fe8d4e2bdf123a8"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?TwoPhaseCommit c2.com]",
            "id": "0a8e1232817721ba5e9b5d0a92974950"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1626125104296
    }
  ]
}