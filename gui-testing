{
  "title": "Gui Testing",
  "story": [
    {
      "type": "html",
      "text": "I may have missed it, but I've searched all over for a Wiki page devoted to testing user interfaces. It's a difficult problem in general, but with such enthusiasm for testing in the Wiki community, I'm sure a lot of people have thoughts about how to do it well. Anyone? <i>(Recently some other thoughts on the topic have popped up on [[Thoughtful Reactions Unit Tests]].)</i> (For another nice article on testing java GUIs, see [http://www.xp123.com/xplor/xp0001/index.shtml www.xp123.com].)",
      "id": "ecc3f4628bb98884dc85672ae41ba717"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nThe best method I know of is effective, but requires up-front work by the developers, and some test framework development by at least a Visual Basic level programmer. In practice, useful tests can be developed a half step behind the GUI developers and could be done earlier if anyone ever scheduled it like that. Unfortunately, what needs to happen is sufficiently specific to the technology/functionality involved that I don't know of a full commercial product. (Or maybe no one wants to buy or support a product that actually does it all?) But I haven't looked for a year+ : not since Q1 1997.",
      "id": "fe4c18b63b2922757e695b1c7f03bc11"
    },
    {
      "type": "html",
      "text": "\nThe standard cycle I have abstracted (and perhaps over-stated) from observation of multiple organizations goes:",
      "id": "567e2a98b1e96f8d806704442957b5ad"
    },
    {
      "type": "html",
      "text": "\n0) GUIs are tested manually, often by the developers themselves. This is very unreliable and expensive. For new GUIs or those being significantly changed, quality is low, and failures at integration time or during user acceptance tests are common.",
      "id": "c8736826c95c67bf1b5a88565af3531b"
    },
    {
      "type": "html",
      "text": "\n1) [[Screen Scraper]]/replay based GUI test techniques are adopted. In a few months, someone notices that these don't work, though they are beloved by managers looking for cheap solutions. The problem is that every time you change the screen layout all existing tests become useless, which means you have no regression tests. [See [[Regression Testing]].] Also, you can't write tests till the GUIs are finished, which means that the developers (often contractors) are unavailable to answer questions and the cost of writing the tests includes the cost of having the test authors reverse engineer the GUI.",
      "id": "eca469ad5cbce2089b6038826acf2ab5"
    },
    {
      "type": "html",
      "text": "\n2) Someone convinces the org that the methods that do work require the GUI tests to be written at \"screen object level\": e.g. in terms of send a message (or better, do an abstracted operation) to a certain control. For this to work, EVERY control must have a unique name, preferably meaningful. (NOT just button1 ... button89.) This requires up-front developer assistance and enforced \"GUI coding standards\" and forbids the use of some standard Wizards and other tools which uselessly rename all GUI controls every time you make a change to the visual screen layout.",
      "id": "2844ffd54c4b73bca275a4fecc5f4605"
    },
    {
      "type": "html",
      "text": "\n3) For each screen (or better, [[Use Case]]) one can write a test script which exercises it. Use a commercial testing tool which allows writing these at the object/event level if possible. (Windows test modes are full of nasty special cases.) Structure the scripts with initialization, body, cleanup ...subscripts or sections which you can reuse later as appropriate to the GUI functionality you are testing. Each run of the test script should be independent of all others: you will often want to run a specific one of what will be many scripts.",
      "id": "8dceef8d5afa1dbb207e074369087578"
    },
    {
      "type": "html",
      "text": "\n4) However, for each such script there are MANY \"test cases\", representing different values/choices for the controls. If you just write the scripts, you will have an incredible number of scripts to maintain.",
      "id": "7fd7cdacbe8d0576c90bdec94fb54e4c"
    },
    {
      "type": "html",
      "text": "\nInstead, write the scripts generically, with named variables rather than literals and appropriate handling of optional (hence possibly missing) values. You will have a small number of scripts (maybe 1) per screen or task you are testing.",
      "id": "457991fb741d1e90c4254f7bfe94fcf3"
    },
    {
      "type": "html",
      "text": "\nDefine the test cases as rows in a database or flat file. MS Access works well for this: the \"script runner\" can be a VB program inside an Access DB which invokes the test script, passing in the values (or the test script can fetch the values itself....) Sometimes you store (control_name, value) tuples to define a test case, which avoids needing a new relational table/screen.",
      "id": "8408d3d491162850d006dd30185b25be"
    },
    {
      "type": "html",
      "text": "\nA real [[Users Manual]] is very helpful here. If you already have one and the full toolset this process is building, you can start here before the GUI exists, filling in screen control names later.",
      "id": "b0c998bdf1e529f062475c27319958cf"
    },
    {
      "type": "html",
      "text": "\nFailing results should normally be logged and summarized (in another table) and possibly mailed to a contact/screen or GUI. You really do NOT want to have to only find one failure at a time. However, a single test script should typically terminate on first failure, as other problems will then cascade.",
      "id": "5b09b3ff049f026a4059360800e52a9b"
    },
    {
      "type": "html",
      "text": "\n5) At this point, it is then a \"simple\" extension to create a test development environment, complete with versioning tests for different GUI versions, screens to automate setting up a new test/script, review & report test development status and semi-randomly choose values based on min/max meta-data for the controls, etc.",
      "id": "73b3e44c7aa0639aabdb58d57d511a41"
    },
    {
      "type": "html",
      "text": "\nYou now have a method for very efficiently developing GUI regression tests which can survive across many releases. [See [[Regression Testing]].] Of course, the whole process took longer than the original GUI project that asked for it. But later projects will benefit.",
      "id": "607369533d443bff15bb7909af3732b1"
    },
    {
      "type": "html",
      "text": "\nOf course, this being Windows, none of your tools will likely be under change control. Nor well documented.",
      "id": "4a38ff44ee410e54901fc91d14abc3be"
    },
    {
      "type": "html",
      "text": "\nAt this point, the cycle usually continues:",
      "id": "a6cb70905c9d5b33011000a7ac0a3bdf"
    },
    {
      "type": "html",
      "text": "\n6) The person developing the test environment falls in love with it and stops developing tests. The environment becomes increasingly Gothic, the MS Access infrastructure is prone to data and version lossage and the sheer volume of stuff you are dumping into MS Access starts to overwhelm it.",
      "id": "8763e2785a93bdb3d18d92a476e0f715"
    },
    {
      "type": "html",
      "text": "\nMeanwhile, other new hires (testing groups have high turnover) find it too hard/undocumented and long for a simpler method (or at least their method.) ",
      "id": "220a3a304bf1de73fad090a1ead8ce09"
    },
    {
      "type": "html",
      "text": "\nThe constraints on developing GUIs which fit the framework annoy new GUI developers, who complain to their managers that the coding rules are uselessly delaying their projects and forbidding their use of the most recent GUI technology. (Normally the test framework needs some support builtin for each class of screen control. If \"overhead\" expenditures for things like updating the framework are being controlled....)",
      "id": "7348320b7ae7533b25c78071b5b52f55"
    },
    {
      "type": "html",
      "text": "\n7) A new senior manager comes in who think testing is fundamentally simple (\"Just record the key clicks!\") and doesn't see why he should be paying for all this VB development effort and support. Many of the GUI developers and some of the testing group finds the setup effort, support/coding constraints and learning curve excessive. ",
      "id": "37b67019023980b015bf589102e272fd"
    },
    {
      "type": "html",
      "text": "\n8) To \"reduce overhead\", the central testing group is dissolved, with each project told to buy some screen scrapers. The original test system developers leave (also lots of places for them to go: they have very valuable skills/experience). No one is maintaining the GUI regression test suites (see [[Regression Testing]]) nor the environment/test apps which run them, which therefore become quickly obsolete....",
      "id": "746facb0d10e7b0561860c0d086b74a5"
    },
    {
      "type": "html",
      "text": "\n9) A year+ later it is noticed that the GUIs have no automated tests and are of increasingly low quality and have long manual test cycles. A new manager decides to do something about it and we proceed to step 1.",
      "id": "f10afc7c06d3c58754034a00b6cb47ef"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nSince senior management regard testing issues, especially for GUIs, as a technical detail beneath them, this cycle can continue as long as the organization remains solvent. The shift to Web based application architectures may represent an effective exit strategy. -- [[Mark Swanson]]",
      "id": "ae893f6467c1a4344bbde7b9865503fe"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "<b>This whole piece is just delicious to read.</b> Thanks! Couldn't agree more, you should write a book Mark... -- gb",
      "id": "9d0e8640912c3336e569f52c0429c53e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nHelp help help!!",
      "id": "523794ae5d52217a71b69a9cb7ef448f"
    },
    {
      "type": "html",
      "text": "\nIn my new project we are focusing early attention on the GUI, as it's absolutely central to the app. (I'm almost willing to say the GUI <i>is</i> the problem domain.) We're talking win32, here, and that great horrible beast called MFC.",
      "id": "1535fb17abf6456fc196a4f16cfdd4a6"
    },
    {
      "type": "html",
      "text": "\nHow am I going to develop reasonable [[Unit Test]]s? For that matter, how am I going to develop reasonable [[Acceptance Test]]s? I am quite concerned about this, as I've been imbibing too much XP juice (contains guarana [lots of caffiene] ), and I want to launch my new team into XP by exposing them to the joys of pre-testing code.",
      "id": "216bfc4d5b1da476d60a88ec5f3db2ac"
    },
    {
      "type": "html",
      "text": "\nHere's a first pass, but it seems unsatisfactory. Please comment and theorize!",
      "id": "fba3e9ddcb8a402513385cad6be44241"
    },
    {
      "type": "html",
      "text": "1. Add controllers:<br>MFC (more correctly, Win32) tends to combine view and controller (and even model at times) into a single object, which makes it difficult to isolate the functionality. So replace in-situ control functionality with calls into an explicit controller. In essence, we add a layer of controllers between the windows and the model. Once this is done, we can test the controller-model functionality and the view-controller functionality independently.",
      "id": "4110561db1ef76ec50ffcd75a3463cb0"
    },
    {
      "type": "html",
      "text": "2. Build/buy a minimalist layout system:<br>A very important gui issue is the physical layout of the gui components on the screen, which will vary from box to box and even run to run. A simple layout system can be readily tested w/o having a user watch, because it will have constraints that can be asserted against.",
      "id": "a1ac5590c13c0dc44f8400e454484c03"
    },
    {
      "type": "html",
      "text": "3. Build/buy a robust multi-channel log:<br>Ultimately, there's no way to get around writing scripts that simulate user interaction. This is not terribly difficult, and we should be able to buy the desired scripting software. The hard part is testing the results. A 'multi-channel' logging unit might simplify the testing process. The log has a number of channels, each of which can be written to independently, e.g. LOG(channel,text). A given acceptance test drives the program via script then compares the by-channel logs for the results. To develop a test, we turn on the script-capturer, interact with the program, then quit. Examine the logs manually and verify their correctness, then build an acceptance test that will re-run the script and compare the logs. The multiple channels are important, because we don't want to break existing script/log pairs just because we add function at another level.",
      "id": "6d2a337c6892065c974937401c7d07bb"
    },
    {
      "type": "html",
      "text": "\nSo. Yech. Sounds like a lot of work. Worse, it sounds anti-XP because of all the thinking too far ahead I just did. Please help me figure out what's wrong with this picture-testing! -- [[Michael Hill]]",
      "id": "8b76c7665296845dffa0fc1e343b5010"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nI have a similar question. I just met with one of our consultants who is doing some graphing/plotting software for a client. I was talking to him about the importance of tests, good test data, and so forth. I was emphasizing them along with their XP friends - refactoring, etc. In many ways, the XP method will work for him, but his function tests will have to be visually verified every single time. Won't they? Is there any other way?",
      "id": "e418cd4ec9966e5799f80269a3fdad01"
    },
    {
      "type": "html",
      "text": "\nThis seems to be a harder problem than GUI testing in general, because often with GUI testing the layout isn't a huge concern; rather, you just want to verify the interactions between components, and that can be done by watching events and similar strategies. But for plotting and graphing, tiny details (individual pixels, even) are important. But you can't get that just from tracking drawing primitives, because optimization might change drawing strategies drastically while producing the same results.",
      "id": "bd18068c81c2e669d89bc1b5dc2bc5e7"
    },
    {
      "type": "html",
      "text": "\nI suppose he could do screen captures and compare them pixel-for-pixel ... is there an Extreme Programming challenge here? -- [[Glenn Vanderburg]]",
      "id": "0ccb4d78e18faf5f499ae2bd15f2d3e9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nHow about this ...",
      "id": "0b6525f6ab4376c9cbd23041da7060f9"
    },
    {
      "type": "html",
      "text": "\nWrite [[Acceptance Test]]s that check whether the system's \"analytical\" features produce the right \"vectors\" of values to feed into the graphing tool. These can all be checked with the usual testing tools.",
      "id": "3967632e95ba29ff574041777689dcd3"
    },
    {
      "type": "html",
      "text": "\nWrite a small number of tests that convert provided constant vectors into pictures on the screen. Capture these and compare them bit for bit. ",
      "id": "ca893c24b0e1a5fbed48d0493b3c6ce9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nI've encountered QA departments with serious internal knowledge problems. One has to mentor them gently on some deep insights of software development. Like, save your test plan, because in a few months we'll give you the next release of the software and you won't want to write the test plan again from scratch.",
      "id": "f98431fcc2c2343418b2b0397b66f2a2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nThe JDK 1.3 offers a special class for [[Gui Testing]]: [http://java.sun.com/products/jdk/1.3/docs/api/java/awt/Robot.html java.sun.com]. -- [[Helmut Merz]] <i>[[Broken Link]], 06 Apr 2004</i>",
      "id": "130db2b6be32f84e13dd42a7fe4a7baa"
    },
    {
      "type": "html",
      "text": "<i>Hmm, Robot appears to be a [[Screen Scraper]] utility; it has mouseMove and mousePress methods, for example. So it probably is not as useful as it could be.</i>",
      "id": "e6d17b503f4b1b838fba4a6b8bfa319c"
    },
    {
      "type": "html",
      "text": "\nThat's true, it's really only about native events. So it's just an API for the development of - platform independent - [[Screen Scraper]] utilities. -- [[Helmut Merz]] (slightly disappointed :-|)",
      "id": "3a1d5d20ecff175789e46899962ef882"
    },
    {
      "type": "html",
      "text": "<i>I suppose that you could get it to do something cleverer without too much fuss: rather than remembering screen locations and putting mouse-clicks on them (and so on), one could do something like:</i>",
      "id": "2bcae2ddd1734df21bc0a2d7d4318965"
    },
    {
      "type": "code",
      "text": "  robot.mouseMove(myComponent.getX(), myComponent.getY());\n  robot.mousePress(InputEvent.BUTTON1_MASK);\n  robot.mouseRelease(InputEvent.BUTTON1_MASK);",
      "id": "e5ead447a3978e06bd13138c8fcb9c6c"
    },
    {
      "type": "html",
      "text": "<i>which would make a good definition for a clickButtonOn(Component myComponent) method. Hmm. Well, it's a thought anyway.</i>",
      "id": "d7921bea2b73612f99011dd0a63cd5dc"
    },
    {
      "type": "html",
      "text": "\nUnfortunately, if you already have myComponent you can just call the doClick() method on it. I for one would like to do the GUI testing without having to keep references to each component. -- [[Brian Robinson]]",
      "id": "e27cd73694bf7970b2f88c5d57422b67"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nA cycle I've used a few times (not enough to <i>know</i>, but enough to smell the existence of something useful) involves the use of a [[Wiki Clone]] and some associated stuff. It goes something like this:",
      "id": "3f30c0317f8451d20e548b810222c2ac"
    },
    {
      "type": "html",
      "text": " Clone a Wiki that pertains to the project at hand, and make sure the team and some stakeholders have access to it and know how to use it. I seed this with a few interesting index pages...[[User Profile Index]], [[Use Case Index]], [[Scenario Index]], [[Choreography Index]], [[Feature Index]], [[Design Index]], and some others.",
      "id": "5aa73f752e611c1201da911fc5a037cf"
    },
    {
      "type": "html",
      "text": " Write a handful of key [[Use Case]]s. Usually more than two...ten is too many. I use a common form (in Wiki), and I end each name with '[[Use Case]]' as a suffix (like [[Pay Per View Use Case]]). Each agent in a [[Use Case]] has a user profile, like [[Domain Expert User Profile]]. Generally the community can get the [[Use Case]]s and [[User Profile]]s put together reasonably soon, and the experience usually gets them fired up about Wiki as well. Also, the ability to adjust them is a huge win.",
      "id": "5d2dbf97a4b33439ce9d324a0106b56c"
    },
    {
      "type": "html",
      "text": " Write a few [[Scenario Index]]'s for each [[Use Case]], as you need them. Each describes how a user (referenced by [[User Profile]]) accomplishes the task.",
      "id": "f787bf69eaf79fa6867b6daf2a58c9ce"
    },
    {
      "type": "html",
      "text": "3. Design a choreography. This is the flow through the application - although a good graphic designer or industrial designer can help, the choreography is more about behavior than appearance. I draw mine, using Visio. They look a lot like flowcharts. For websites, these sort-of correspond to screens. I hacked Wiki so that my users see the drawings (I turn them into GIFs or JPGs, then expand them inline), and I embed each in a page that includes wiki links to others. So the general theme is that you can walk through the application in Wiki. My teams like this because Wiki lets them annotate the things they like and don't like, and we can always change stuff. [A good resource for this kind of diagramming is [[Jesse James Garrett]]'s [[Visual Vocabulary]]:<br>[http://www.jjg.net/ia/visvocab/ www.jjg.net] - [[Dinah Sanders]]]",
      "id": "c89d70e4c21ab6500abd152c096d5d0f"
    },
    {
      "type": "html",
      "text": " The boxes on a choreography end up being actions the application has to do. These turn into something like services.",
      "id": "773b8380d556f3432f6d3bff844bbed9"
    },
    {
      "type": "html",
      "text": " Now, each scenario can get a drawing that shows several choreographies.",
      "id": "f34378be6974de198aa15f9eb102df14"
    },
    {
      "type": "html",
      "text": " Somewhere between choreographies and scenario's, you can have the UI designer's sketch screen designs. These can be linked to the corresponding choreography or scenario.",
      "id": "49d7274c8cd9c52fd491d7cb5a8be2f8"
    },
    {
      "type": "html",
      "text": " The QA team can use all this to develop test suites, generally driven by the [[Use Case]]s. They can walk through the choreographies and scenarios, looking for special things to exercise.",
      "id": "b94b9af1d1035d3a4d6c75259d828195"
    },
    {
      "type": "html",
      "text": " The QA team and stakeholders can begin walkthroughs, making sure that the app is solving the right problem. Sometimes applications that work precisely as designed fail because they were designed to solve the wrong problem.",
      "id": "2301420a018d26acdd4a97c3fec9d0f5"
    },
    {
      "type": "html",
      "text": " The test scripts and tests themselves, along with expected results, notes, and all sorts of useful material, can be developed in or closely integrated with Wiki. I've found that this helps preserve organizational memory and learnings.",
      "id": "5012f824c5645df2f3d8b46f96a9cda8"
    },
    {
      "type": "html",
      "text": " Finally, as parts start to be finished, everybody can try them out and exercise them along the way. Developers can exercise their code with the test scripts. Developers and testers can repeat tests. Etc.",
      "id": "6f785978557388f5477c35a2c84147b2"
    },
    {
      "type": "html",
      "text": " When everybody says its finished, there is a reasonable (not perfect, but reasonable) way of supporting that assertion.",
      "id": "689c0573da4343f71a75895ecb1bee51"
    },
    {
      "type": "html",
      "text": "\nAs I say, I've done this on about four projects. I'm sure there's lots of cool stuff to do here, someday maybe I'll even get to work more on it. The trouble, as always, is that there is always more code to write...I never get to follow up on these cool things. Wiki is <i>awesome</i>!",
      "id": "7994f67f94c8ad9a3969e973f0cd5be9"
    },
    {
      "type": "html",
      "text": "-- [[Tom Stambaugh]]",
      "id": "a2e89575f6b7f4230f783a34567ac356"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nI have a short history of GUI automation and a set of useful links in a Web Watch article I wrote for Software Testing and Quality Engineering Magazine. \n[http://www.stqemagazine.com/webinfo_detail.asp?id=102 www.stqemagazine.com] [[[Broken Link]]<b></b>?, 06 Apr 2004] The page is automatically generated from who-knows-what, so it's pretty ugly. Sorry about that.",
      "id": "306c6b255615fcc6022fbf4866b75cf0"
    },
    {
      "type": "html",
      "text": "-- [[Brian Marick]]",
      "id": "fe21b4bd50614d85ad1c307c3fc32948"
    },
    {
      "type": "html",
      "text": "<b>Actually,</b> it is not all that bad. We had been trying for nearly two years to find value in the screen-scraping style of GUITesting. We found that:",
      "id": "3f22628f6154b90dbf36f558733bd8ec"
    },
    {
      "type": "html",
      "text": " The automated tools were fairly expensive and required a completely different set of skills that the developers had, so",
      "id": "26d2b184f8055b2a10e8a7a9b1e89927"
    },
    {
      "type": "html",
      "text": " only a few persons were assigned to create GUI [[Unit Test]]s, and",
      "id": "a7c823782d1ffb91bc3bf7d47437a6ef"
    },
    {
      "type": "html",
      "text": " they couldn't keep up with the GUI developers, and",
      "id": "7499de543f811ef0f3536fb76696bcda"
    },
    {
      "type": "html",
      "text": " the tests they produced were very brittle, breaking whenever simple changes were made to the GUIs (this may have been their inexperience), so",
      "id": "fe3d7049565ea41eb9d006feb25216b3"
    },
    {
      "type": "html",
      "text": " the tests produced were essentially useless and the testers got discouraged and quit.",
      "id": "6a4c829f09ee9538e7ad4af3bb3d1173"
    },
    {
      "type": "html",
      "text": "\nThe result was that the only [[Unit Test]]s we had were on the non-GUI portions of the code. All the business logic resides there, so that was not too bad but the GUIs became more and more bloated. When we got into [[Performance Testing]], we found that some of the GUIs were horrendously slow with large amounts of data. Some we could modify reasonably easily, but one particularly egregious GUI was so bad that nobody knew how it worked.",
      "id": "dbbfc42b6afa5c12532263208ead1bc7"
    },
    {
      "type": "html",
      "text": "\nFinally, we followed a suggestion by [[Martin Fowler]] to write a test for the GUI by hand, using the same framework and techniques used in our other [[Unit Test]]s. Once we had written a reasonable library of GUI manipulation methods (which took just a few days) implementing the actual test went very quickly, and we were able to refactor the GUI, cutting its code size down by nearly two-thirds (writing the tests and refactoring took three weeks), followed by three days to speed up the code so that operations which used to take 6 minutes now take about 2 seconds.",
      "id": "4d7aeb821965cf73db8ee66d3ea08b72"
    },
    {
      "type": "html",
      "text": "\nMy advice - just wade in and start writing those tests. -- [[Russell Gold]]",
      "id": "6e29e69119cd24bb714b97416cb60519"
    },
    {
      "type": "html",
      "text": "<i>Can you provide example methods from your library of [[Gui Manipulation Methods]]? Are they like the AWT Robot calls above? Do you eventually wind up rendering the GUI to a bitmap and compare it to an expected bitmap?</i>",
      "id": "703245c6c36c5e15597b0fad3b728e9a"
    },
    {
      "type": "html",
      "text": "\nHere is an example test, which adds a subtree of business nodes to a structure represented by a JTree, saves it, deletes the top of the subtree, and finally confirms that all of the subnodes below are removed as well:",
      "id": "d95f1e3e891ed7cd11373485f4d47482"
    },
    {
      "type": "code",
      "text": "  public void testNodeTreeDelete() throws Exception {\n  clickOn( _tree, getEntityPath( _nodeRoot ) );\n  DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) _tree.getLeadSelectionPath().getLastPathComponent();\n  int numChildren = rootNode.getChildCount();",
      "id": "0358f1f8c5165f51fa1f381aee9e478a"
    },
    {
      "type": "code",
      "text": "  selectPopupMenu( _tree, getEntityPath( _nodeRoot ), new String[] { \"New Node\" } );\n  replaceText( EnterpriseModelerFrame.BUSINESS_NODE_NAME, \"NodeT1\" );\n  selectComboBoxValue( EnterpriseModelerFrame.BUSINESS_NODE_STATUS, \"Active\" );\n  Object nodeT1 = getSelectedObject();",
      "id": "0f77d95e82e32be40cf124e8c470a7a3"
    },
    {
      "type": "code",
      "text": "  selectTreePopupMenu( nodeT1, \"Copy\" );\n  replaceText( EnterpriseModelerFrame.BUSINESS_NODE_NAME, \"NodeT1A\" );\n  selectComboBoxValue( EnterpriseModelerFrame.BUSINESS_NODE_STATUS, \"Active\" );\n  Object nodeT1A = getSelectedObject();\n  dragAndDrop( nodeT1A, nodeT1 );",
      "id": "a4a061e4caf875c50bf6e44025d0c63e"
    },
    {
      "type": "code",
      "text": "  selectPopupMenu( _tree, getEntityPath( nodeT1 ), new String[] { \"Delete Family\" }, new ConfirmationDialogHandler() );",
      "id": "0aada8fd6ae4edff74a5fa265c0baa3b"
    },
    {
      "type": "code",
      "text": "  if (rootNode.getChildCount() != numChildren) reportFailure( \"Wrong number of children on root node.\" );\n  }",
      "id": "372aa9aeaa24cddea7d66431fb936670"
    },
    {
      "type": "html",
      "text": "\nThis approach relies on the underlying entities, which are tested elsewhere, and on the Swing classes themselves, which are presumed to be reliable. We expect our Frames to implement an interface which returns a control by name. We absolutely do not use bit-maps, which would be very fragile. These tests can actually be written, like all good [[Unit Test]]s, before the code which implements them. In some cases, we can check the color or size by fetching the appropriate renderer and asking for its color, size, position, etc.",
      "id": "581c409647bf12d28510e1502d4f89b2"
    },
    {
      "type": "html",
      "text": "\nSome of the library methods used include:",
      "id": "e5cdf865c78957f1d95b75ebe87db3b0"
    },
    {
      "type": "html",
      "text": "selectTreePopupMenu:<br>pops up a menu on the specified tree node and selects the named menu item",
      "id": "44a37ee6dc71d9ecba48109d4333eddc"
    },
    {
      "type": "html",
      "text": "clickOn:<br>does a mouse-down on a GUI element, or a path in a JTree",
      "id": "7bf048b0b36f4856a70fef398e6490c4"
    },
    {
      "type": "html",
      "text": "dragAndDrop:<br>drags one JTree node onto another",
      "id": "e38e74610bea95f33e3462f68e3a5d1f"
    },
    {
      "type": "html",
      "text": "replaceText:<br>selects the text in a control and types the specified text in its place",
      "id": "e4bf3e3068139f6c13d0a2e6e487884b"
    },
    {
      "type": "html",
      "text": "selectMenu:<br>selects a menu item from the menu bar",
      "id": "57181d11122c816390f646078d635019"
    },
    {
      "type": "html",
      "text": "selectComboBoxValue:<br>selects a named value from a combo box",
      "id": "2c8e058cb676f6cce96d100998e068c8"
    },
    {
      "type": "html",
      "text": "\nWe have others, not shown here, and we develop new ones as needed. -- [[Russell Gold]]",
      "id": "8468f421a4f4c9be8466d169e9085d47"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nSome various GUI testing resources:",
      "id": "006bd67565d08696468f9ff7b5f32a6e"
    },
    {
      "type": "html",
      "text": "\nThere are good tools available for doing [[Regression Testing]] on GUI applications. I've had some good experiences with SQA Robot and Microsoft Test. They have scripting languages, and can test field values or do bitmap comparisons, as you wish.",
      "id": "165ef6e49834cab0f1f428003edea58b"
    },
    {
      "type": "html",
      "text": "\nSQA Robot, by SQA Software - bought by Rational. See [http://www.rational.com/products/sqa_load/prodinfo/robot.jtmpl www.rational.com] ([[Broken Link]] as of 2003-05-07. Apparently SQA Robot is now called [[Rational Robot]]. See [http://www.rational.com/products/robot/index.jsp www.rational.com]) and [http://www.rational.com/products/visual_test/index.jtmpl www.rational.com] (See also the Saint Louis SQA user group at [http://www.midwest-st-lab.com/Usersgroup.html www.midwest-st-lab.com])",
      "id": "6ae7b58e1a922c89526d18e8e625e2be"
    },
    {
      "type": "html",
      "text": "\nFor Java users, there are several projects which extend JUnit to test Java GUIs. ",
      "id": "2391844b248b57d28a3522a67f7a2d0b"
    },
    {
      "type": "code",
      "text": " http://sourceforge.net/projects/abbot\n http://jemmy.netbeans.org\n http://sourceforge.net/projects/jfcunit\n http://sourceforge.net/projects/pounder",
      "id": "06c3bf23aca86bdbbf87767c342b8337"
    },
    {
      "type": "html",
      "text": "\nJFCUnit, Jemmy, and Abbot provide an extended library of robot-like functions similar to those described above (Button.click, Tree.selectNode, etc.). Abbot and Pounder also provide recording/playback and scripted tests which are useful for acceptance testing.",
      "id": "af11ff2620ac6ecda024ebe3df9a4a1e"
    },
    {
      "type": "html",
      "text": "\nThere is also a list for discussing these types of issues at [http://groups.yahoo.com/group/java-gui-testing groups.yahoo.com].",
      "id": "d2294fe6924aa173cbbc9a035840781e"
    },
    {
      "type": "html",
      "text": "\nAvignon ([http://www.nolacom.com/avignon/index.asp www.nolacom.com]) helps you develop your own language for customer tests and allows you to develop your own level of GUI testing.",
      "id": "6916e748fc6dadf4ed33cdd75cfeade8"
    },
    {
      "type": "html",
      "text": "\nSee [http://resolute.teradyne.com/prods/sst/product_center/testexec.html resolute.teradyne.com] for a good list of GUI test tools ([[Broken Link]]).",
      "id": "1d245cb514a54be016fcef4bee8ee8d9"
    },
    {
      "type": "html",
      "text": "\nSee also [[Marathon Man]].",
      "id": "29ec239d30dafee61050f52a276c91db"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nAn idea...",
      "id": "e40386b083882790e5ab0630aac1b716"
    },
    {
      "type": "html",
      "text": "\nGUI development is difficult to test ... therefore, [[Do The Simplest Thing That Could Possibly Work]] (and Test) and avoiding writing complicated widgets. I don't mean don't use the latest UI controls, just remove complication internally. Move that to other classes.",
      "id": "7803cf3f703035724e49d4f65fed52e0"
    },
    {
      "type": "html",
      "text": "\nYou can minimize complication in widgets by inverting the relationship between widgets and the underlying mechanics. Instead of having the UI drive the application, have the application drive the UI. That is, consider the UI a tool for the model/engine to communicate to the user, not for the user to communicate to the model/engine. [[Model View Controller]] helps immensely.",
      "id": "a9067dd7f265f3d99b8e7c3cf577a877"
    },
    {
      "type": "html",
      "text": "\nTake this concept right into the Controller. Break it into separate [[Tight Groups Of Classes]]. One that interacts with the operating system, that receives events for example. Another that contains a [[Finite State Machine]] that reacts to your OS wrapper class.",
      "id": "c82c6bb97667df674a2b16f5d751f6fb"
    },
    {
      "type": "html",
      "text": "\nMFC and Win32 [[Makes Me Cry]]. [[App Wizard]] doesn't help because it likes putting the entire model inside the UI. The Doc/View architecture really isn't. Why do CDocument subclasses receive Windows events?!",
      "id": "c0ee06b1ec11ea60d19bfccd2af1153f"
    },
    {
      "type": "html",
      "text": "\nTherefore, just do it by hand, or if you can't, gut out the classes that [[App Wizard]] generates. Put everything into separate classes that MFC call. ",
      "id": "98ed39074057415e8584ed6b488fa82f"
    },
    {
      "type": "html",
      "text": "\nYou'll get lightweight UI controls you can easily test, even without [[Unit Test]]s if you can't figure out how to write them for every possible user event. And you can easily test the non-OS driven classes using [[Unit Test]]s. -- [[Sunir Shah]]",
      "id": "27ef3e2b8ec2015f2f56bcc0114ab98c"
    },
    {
      "type": "html",
      "text": "[This is useless advice because you're basically saying don't test the GUI, test the logic. Which is fine, but I was assuming that people were already separating this code out (Anyone who's professionally writing GUIs should be fired if they don't understand and use MVC. Of course, I don't think anyone sane should be using MFC, either...). The question at hand is unit testing GUIs per se, and I really don't see a correct way to do this. How do you test that a tooltip is shown at the correct time and in the correct place? That it has correct text? How about things like flicker and graphic corruption from resizing, especially with custom-built widgets? I don't think there's any way to solve these sort of problems.]",
      "id": "458f72206b26467779a9f3fd5dd51e38"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nI think the article \"Integrated, Effective Test Design and Automation\" by Edward Kit (Software Development, February 1999) provides an XP-like approach to GUI testing. The idea is to use the scripting abilities of the testing tool. Kit argues that Capture / Playback creates scripts that are non-structured, non-commented and virtually non-maintainable. Thus, engineers should create test scripts by hand.",
      "id": "c6d44982697cce854390c191db17a7b5"
    },
    {
      "type": "html",
      "text": "\nIf the scripting language is easy to use, it should be easy to add tests \"on the fly\". -- [[Albert Brandl]]",
      "id": "51e094b5ba23642e6bf3dfa85202f7f8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nPerhaps some of the current discussion could be [[Re Factor]]ed out into the [[Gui Testing Patterns]] page.",
      "id": "67aaf5840cf590896333711849b3cf70"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nThese all sound like discussions of how to test an existing GUI. How do you [[Code Unit Test First]] for GUIs? -- [[Eddie Deyo]]",
      "id": "273a2bc3a82a673b6b4868a45a9265fe"
    },
    {
      "type": "html",
      "text": "\nTo [[Code Unit Test First]] for GUIs, read [[Then Dont Call Main Loop]].",
      "id": "20aa97501654dbd14606988b19ae65b5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nI thought of an Idea of an EFFECTIVE GUI TESTING FRAMEWORK:",
      "id": "d6d23e66c0ab0f5ce748020a43386d3b"
    },
    {
      "type": "html",
      "text": "\nWhy not using the power of AOP ([[Aspect Oriented Programming]]) for GUI tests?",
      "id": "8cafd34e5c01d078aa58f3a85d0d6ea8"
    },
    {
      "type": "html",
      "text": "\nIt will look like that: ",
      "id": "5082f289571e3f1d1e0edca60f73a62d"
    },
    {
      "type": "html",
      "text": "(This is Pseudo - AspectJ. I don't know it - yet.\nI have written GUI in Delphi, but never in Java)",
      "id": "af07df3c320f04ce1b4e658314e45cce"
    },
    {
      "type": "html",
      "text": "\nAspet Test.testAddOrder {",
      "id": "c02045a0e4acb4a4d279ba4969cf384b"
    },
    {
      "type": "code",
      "text": "  int step = 0; // count steps during the test",
      "id": "19f2f00fbfa2f10dd3142752a3df2bdc"
    },
    {
      "type": "html",
      "text": "after:<br>class [[Form Order]].onOpen() {",
      "id": "31dc5e702c37435b96f5c2475a7fe07c"
    },
    {
      "type": "code",
      "text": "        if (step == 4) {\n        btnDetails.click();\n        }\n        if (step == 8) \n        btnClose.click();\n  }",
      "id": "36d064cee9f4d28665d0d2c707d3341d"
    },
    {
      "type": "html",
      "text": "after:<br>class [[Form Order Details]].onOpen() {",
      "id": "7ffe8a54578d2e6961f75fd7bdb26211"
    },
    {
      "type": "code",
      "text": "        if (step == 5) {\n        editOrderNumber.text = \"ED1723-74\"; // an edit box\n        btnSearch.click();\n        AssertTrue(TableOrder.get(\"OrderNo\").equals(\"ED1723-74\")); // suppose some aspect exoses DB easily\n        editIRR.text = \"0.88\";\n        btnUpdate.click();\n        AssertTrue(MessageBox.isActive(Message.ERROR)); // some framework aid to indentify error dialog\n        Dialog.btnOk.click(); // close dialog\n        editIRR.text = \"... // and so on  \n        }\n  }",
      "id": "401eca96e4fcf8c3e613bdb811930437"
    },
    {
      "type": "html",
      "text": "}",
      "id": "74c8fc888d603696ce8d2134a07d91c8"
    },
    {
      "type": "html",
      "text": "\nthru [[Aspect Jay]] you can check that all buttons named \"btnAddRecordXXX\" indeed add record to a table named XXX",
      "id": "02aa3891d18dddf7b13fe349998321bf"
    },
    {
      "type": "html",
      "text": "\nideas:",
      "id": "60eb3cceb8aa603c020c387a89b3b66f"
    },
    {
      "type": "html",
      "text": " the step tracking could be smarter",
      "id": "b777baa343d8a16e049ed29684e72dd4"
    },
    {
      "type": "html",
      "text": " no gui must be displayed => test is Swift! (aspect for all forms to be hidden)",
      "id": "406548eec9987264c20cbba67391b9ac"
    },
    {
      "type": "html",
      "text": " assumption:<br>standard gui classes work and need no test.",
      "id": "aae7cc68184c889d10dbb70b1f268b79"
    },
    {
      "type": "html",
      "text": " strict naming scheme required, or [[Find Button]](String name) functions could be written in the frameworks",
      "id": "4c466582bab45c1ecd581acd4f86d996"
    },
    {
      "type": "html",
      "text": " the test must use presentation layer classes only. Changes to Database will be available by some specific DBRead class.",
      "id": "76534b4b25f019fb38d623318dc3ff95"
    },
    {
      "type": "html",
      "text": "\nthe good:",
      "id": "b98fde1c83c8e33c7d43d2f04030f1f0"
    },
    {
      "type": "html",
      "text": " fast",
      "id": "2f2efeca386ba1b95462e590fb03588f"
    },
    {
      "type": "html",
      "text": " easy",
      "id": "91bfd63ef150721257de1e2f90911219"
    },
    {
      "type": "html",
      "text": " robust to Gui design changes (I think button name is more robust than finding button label);",
      "id": "44777519217fcd16e4df410fb2c63db6"
    },
    {
      "type": "html",
      "text": "\nthe bad:",
      "id": "960984ec0cae3279702972c94f1a8400"
    },
    {
      "type": "code",
      "text": " ???",
      "id": "bb5d5509bb10ea3578bba4ea99a2fc31"
    },
    {
      "type": "html",
      "text": "If I get some positive feedback that this is innovative and useful idea, I'll develop it as my Senior Project. I need your feedback. Thanks!",
      "id": "f5602c87dbfc4eb4e9e71affaa3d6640"
    },
    {
      "type": "html",
      "text": "-- Lior Bar-On",
      "id": "062c715d8fa0e45ab7ae8f2d9b2a3dd9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "[[[Refactor Me]]: I'm curious how this can be applied to HTML UIs. I want to introduce [[Extreme Programming]] into a web project. Has anyone done this for an existing project? a new one? -- [[Andrew Kris Thompson]]]",
      "id": "84b6bacc6107944452c088c3e00a2ba4"
    },
    {
      "type": "html",
      "text": "\nSee [[Web Testing]].",
      "id": "85a639f1b3fa0e8060672ad91f69256a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nI haven't had much success in using [[Test Driven Development]] when [[Gui Testing Game Apps]]. Perhaps this is one of those instances when this method doesn't work.",
      "id": "4fe6290c0eb1a2f16d7df349491ac771"
    },
    {
      "type": "html",
      "text": "<i>E-search for [[Tom Plunket]]; he seems to be doing the polygon mesh layers test-first. You could ask him this question on news:comp.object, for example. -- [[Phl Ip]]</i>",
      "id": "60233b3efadfb74d1db7b8ef4f85f87f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nSee the extensions that I'm building into FIT for GUI testing - [[John Goodsen]]. Remember FIT is at [http://fit.c2.com fit.c2.com].",
      "id": "6216ff600cfb74597481282f74146feb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nI found a good link with GUITesting references (payware, freeware, Java-only, etc.)",
      "id": "26a5832c1073b40fd40f0dd412472680"
    },
    {
      "type": "html",
      "text": "\n[http://www.testingfaqs.org/t-gui.html www.testingfaqs.org]",
      "id": "2e8c5d8dd98c15ff2d79c08ad4b5b850"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "\nThe only good way of testing GUIs I know requires the GUI to be written, in two parts.  The front part is visual only, it contains the interface and it produces a string of text commands which gets sent to the back end, which processes them, and returns text responses.  Each individual half is easy to test.  ",
      "id": "e8daa253627173e9194fc91b8fe2d817"
    },
    {
      "type": "html",
      "text": "\nTo test the front end, push the buttons in the right order and check that the right text file is generated.  It's manual, but it's quick, and doesn't have to be done often.  And the actual checking can just about be done with diff.",
      "id": "d8bc0d286f2b1b6874c7b6deb5dcf614"
    },
    {
      "type": "html",
      "text": "\nTo test the back end, feed in a text file, and check what happens.  The text file can be generated with the front end, by hand, or a combination of both.  This can be completely automated.",
      "id": "5a63bdb6ffb43649907131e4cc926414"
    },
    {
      "type": "html",
      "text": "\nThe problem is that your GUI developers have to have enough discipline to keep everything that can break in the back end.  I've seen it done, if only when the text version came first and the front end was a bolt-on.  Otherwise, it's always too tempting to put the logic into the front end.  Regards, --[[Ben Aveling]]",
      "id": "b06857ed740c96184991e84910924c80"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "See [[Test First User Interfaces]] [[User Interface]]",
      "id": "8324008e250ec5f1e52a4efc109c763e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c8c22fa316221cf7810cac2a2799fdc9"
    },
    {
      "type": "html",
      "text": "[[Category Testing]] [[Category User Interface]]",
      "id": "293487e1170377f1499499ea5c1cd32e"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?GuiTesting c2.com]",
      "id": "756fb439cd80f44e87ec6865db15e6f0"
    }
  ],
  "journal": [
    {
      "date": 1267223163000,
      "id": "2e84d24f18b045b324cbb542f64bd29f",
      "type": "create",
      "item": {
        "title": "Gui Testing",
        "story": [
          {
            "type": "html",
            "text": "I may have missed it, but I've searched all over for a Wiki page devoted to testing user interfaces. It's a difficult problem in general, but with such enthusiasm for testing in the Wiki community, I'm sure a lot of people have thoughts about how to do it well. Anyone? <i>(Recently some other thoughts on the topic have popped up on [[Thoughtful Reactions Unit Tests]].)</i> (For another nice article on testing java GUIs, see [http://www.xp123.com/xplor/xp0001/index.shtml www.xp123.com].)",
            "id": "ecc3f4628bb98884dc85672ae41ba717"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nThe best method I know of is effective, but requires up-front work by the developers, and some test framework development by at least a Visual Basic level programmer. In practice, useful tests can be developed a half step behind the GUI developers and could be done earlier if anyone ever scheduled it like that. Unfortunately, what needs to happen is sufficiently specific to the technology/functionality involved that I don't know of a full commercial product. (Or maybe no one wants to buy or support a product that actually does it all?) But I haven't looked for a year+ : not since Q1 1997.",
            "id": "fe4c18b63b2922757e695b1c7f03bc11"
          },
          {
            "type": "html",
            "text": "\nThe standard cycle I have abstracted (and perhaps over-stated) from observation of multiple organizations goes:",
            "id": "567e2a98b1e96f8d806704442957b5ad"
          },
          {
            "type": "html",
            "text": "\n0) GUIs are tested manually, often by the developers themselves. This is very unreliable and expensive. For new GUIs or those being significantly changed, quality is low, and failures at integration time or during user acceptance tests are common.",
            "id": "c8736826c95c67bf1b5a88565af3531b"
          },
          {
            "type": "html",
            "text": "\n1) [[Screen Scraper]]/replay based GUI test techniques are adopted. In a few months, someone notices that these don't work, though they are beloved by managers looking for cheap solutions. The problem is that every time you change the screen layout all existing tests become useless, which means you have no regression tests. [See [[Regression Testing]].] Also, you can't write tests till the GUIs are finished, which means that the developers (often contractors) are unavailable to answer questions and the cost of writing the tests includes the cost of having the test authors reverse engineer the GUI.",
            "id": "eca469ad5cbce2089b6038826acf2ab5"
          },
          {
            "type": "html",
            "text": "\n2) Someone convinces the org that the methods that do work require the GUI tests to be written at \"screen object level\": e.g. in terms of send a message (or better, do an abstracted operation) to a certain control. For this to work, EVERY control must have a unique name, preferably meaningful. (NOT just button1 ... button89.) This requires up-front developer assistance and enforced \"GUI coding standards\" and forbids the use of some standard Wizards and other tools which uselessly rename all GUI controls every time you make a change to the visual screen layout.",
            "id": "2844ffd54c4b73bca275a4fecc5f4605"
          },
          {
            "type": "html",
            "text": "\n3) For each screen (or better, [[Use Case]]) one can write a test script which exercises it. Use a commercial testing tool which allows writing these at the object/event level if possible. (Windows test modes are full of nasty special cases.) Structure the scripts with initialization, body, cleanup ...subscripts or sections which you can reuse later as appropriate to the GUI functionality you are testing. Each run of the test script should be independent of all others: you will often want to run a specific one of what will be many scripts.",
            "id": "8dceef8d5afa1dbb207e074369087578"
          },
          {
            "type": "html",
            "text": "\n4) However, for each such script there are MANY \"test cases\", representing different values/choices for the controls. If you just write the scripts, you will have an incredible number of scripts to maintain.",
            "id": "7fd7cdacbe8d0576c90bdec94fb54e4c"
          },
          {
            "type": "html",
            "text": "\nInstead, write the scripts generically, with named variables rather than literals and appropriate handling of optional (hence possibly missing) values. You will have a small number of scripts (maybe 1) per screen or task you are testing.",
            "id": "457991fb741d1e90c4254f7bfe94fcf3"
          },
          {
            "type": "html",
            "text": "\nDefine the test cases as rows in a database or flat file. MS Access works well for this: the \"script runner\" can be a VB program inside an Access DB which invokes the test script, passing in the values (or the test script can fetch the values itself....) Sometimes you store (control_name, value) tuples to define a test case, which avoids needing a new relational table/screen.",
            "id": "8408d3d491162850d006dd30185b25be"
          },
          {
            "type": "html",
            "text": "\nA real [[Users Manual]] is very helpful here. If you already have one and the full toolset this process is building, you can start here before the GUI exists, filling in screen control names later.",
            "id": "b0c998bdf1e529f062475c27319958cf"
          },
          {
            "type": "html",
            "text": "\nFailing results should normally be logged and summarized (in another table) and possibly mailed to a contact/screen or GUI. You really do NOT want to have to only find one failure at a time. However, a single test script should typically terminate on first failure, as other problems will then cascade.",
            "id": "5b09b3ff049f026a4059360800e52a9b"
          },
          {
            "type": "html",
            "text": "\n5) At this point, it is then a \"simple\" extension to create a test development environment, complete with versioning tests for different GUI versions, screens to automate setting up a new test/script, review & report test development status and semi-randomly choose values based on min/max meta-data for the controls, etc.",
            "id": "73b3e44c7aa0639aabdb58d57d511a41"
          },
          {
            "type": "html",
            "text": "\nYou now have a method for very efficiently developing GUI regression tests which can survive across many releases. [See [[Regression Testing]].] Of course, the whole process took longer than the original GUI project that asked for it. But later projects will benefit.",
            "id": "607369533d443bff15bb7909af3732b1"
          },
          {
            "type": "html",
            "text": "\nOf course, this being Windows, none of your tools will likely be under change control. Nor well documented.",
            "id": "4a38ff44ee410e54901fc91d14abc3be"
          },
          {
            "type": "html",
            "text": "\nAt this point, the cycle usually continues:",
            "id": "a6cb70905c9d5b33011000a7ac0a3bdf"
          },
          {
            "type": "html",
            "text": "\n6) The person developing the test environment falls in love with it and stops developing tests. The environment becomes increasingly Gothic, the MS Access infrastructure is prone to data and version lossage and the sheer volume of stuff you are dumping into MS Access starts to overwhelm it.",
            "id": "8763e2785a93bdb3d18d92a476e0f715"
          },
          {
            "type": "html",
            "text": "\nMeanwhile, other new hires (testing groups have high turnover) find it too hard/undocumented and long for a simpler method (or at least their method.) ",
            "id": "220a3a304bf1de73fad090a1ead8ce09"
          },
          {
            "type": "html",
            "text": "\nThe constraints on developing GUIs which fit the framework annoy new GUI developers, who complain to their managers that the coding rules are uselessly delaying their projects and forbidding their use of the most recent GUI technology. (Normally the test framework needs some support builtin for each class of screen control. If \"overhead\" expenditures for things like updating the framework are being controlled....)",
            "id": "7348320b7ae7533b25c78071b5b52f55"
          },
          {
            "type": "html",
            "text": "\n7) A new senior manager comes in who think testing is fundamentally simple (\"Just record the key clicks!\") and doesn't see why he should be paying for all this VB development effort and support. Many of the GUI developers and some of the testing group finds the setup effort, support/coding constraints and learning curve excessive. ",
            "id": "37b67019023980b015bf589102e272fd"
          },
          {
            "type": "html",
            "text": "\n8) To \"reduce overhead\", the central testing group is dissolved, with each project told to buy some screen scrapers. The original test system developers leave (also lots of places for them to go: they have very valuable skills/experience). No one is maintaining the GUI regression test suites (see [[Regression Testing]]) nor the environment/test apps which run them, which therefore become quickly obsolete....",
            "id": "746facb0d10e7b0561860c0d086b74a5"
          },
          {
            "type": "html",
            "text": "\n9) A year+ later it is noticed that the GUIs have no automated tests and are of increasingly low quality and have long manual test cycles. A new manager decides to do something about it and we proceed to step 1.",
            "id": "f10afc7c06d3c58754034a00b6cb47ef"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nSince senior management regard testing issues, especially for GUIs, as a technical detail beneath them, this cycle can continue as long as the organization remains solvent. The shift to Web based application architectures may represent an effective exit strategy. -- [[Mark Swanson]]",
            "id": "ae893f6467c1a4344bbde7b9865503fe"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "<b>This whole piece is just delicious to read.</b> Thanks! Couldn't agree more, you should write a book Mark... -- gb",
            "id": "9d0e8640912c3336e569f52c0429c53e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nHelp help help!!",
            "id": "523794ae5d52217a71b69a9cb7ef448f"
          },
          {
            "type": "html",
            "text": "\nIn my new project we are focusing early attention on the GUI, as it's absolutely central to the app. (I'm almost willing to say the GUI <i>is</i> the problem domain.) We're talking win32, here, and that great horrible beast called MFC.",
            "id": "1535fb17abf6456fc196a4f16cfdd4a6"
          },
          {
            "type": "html",
            "text": "\nHow am I going to develop reasonable [[Unit Test]]s? For that matter, how am I going to develop reasonable [[Acceptance Test]]s? I am quite concerned about this, as I've been imbibing too much XP juice (contains guarana [lots of caffiene] ), and I want to launch my new team into XP by exposing them to the joys of pre-testing code.",
            "id": "216bfc4d5b1da476d60a88ec5f3db2ac"
          },
          {
            "type": "html",
            "text": "\nHere's a first pass, but it seems unsatisfactory. Please comment and theorize!",
            "id": "fba3e9ddcb8a402513385cad6be44241"
          },
          {
            "type": "html",
            "text": "1. Add controllers:<br>MFC (more correctly, Win32) tends to combine view and controller (and even model at times) into a single object, which makes it difficult to isolate the functionality. So replace in-situ control functionality with calls into an explicit controller. In essence, we add a layer of controllers between the windows and the model. Once this is done, we can test the controller-model functionality and the view-controller functionality independently.",
            "id": "4110561db1ef76ec50ffcd75a3463cb0"
          },
          {
            "type": "html",
            "text": "2. Build/buy a minimalist layout system:<br>A very important gui issue is the physical layout of the gui components on the screen, which will vary from box to box and even run to run. A simple layout system can be readily tested w/o having a user watch, because it will have constraints that can be asserted against.",
            "id": "a1ac5590c13c0dc44f8400e454484c03"
          },
          {
            "type": "html",
            "text": "3. Build/buy a robust multi-channel log:<br>Ultimately, there's no way to get around writing scripts that simulate user interaction. This is not terribly difficult, and we should be able to buy the desired scripting software. The hard part is testing the results. A 'multi-channel' logging unit might simplify the testing process. The log has a number of channels, each of which can be written to independently, e.g. LOG(channel,text). A given acceptance test drives the program via script then compares the by-channel logs for the results. To develop a test, we turn on the script-capturer, interact with the program, then quit. Examine the logs manually and verify their correctness, then build an acceptance test that will re-run the script and compare the logs. The multiple channels are important, because we don't want to break existing script/log pairs just because we add function at another level.",
            "id": "6d2a337c6892065c974937401c7d07bb"
          },
          {
            "type": "html",
            "text": "\nSo. Yech. Sounds like a lot of work. Worse, it sounds anti-XP because of all the thinking too far ahead I just did. Please help me figure out what's wrong with this picture-testing! -- [[Michael Hill]]",
            "id": "8b76c7665296845dffa0fc1e343b5010"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nI have a similar question. I just met with one of our consultants who is doing some graphing/plotting software for a client. I was talking to him about the importance of tests, good test data, and so forth. I was emphasizing them along with their XP friends - refactoring, etc. In many ways, the XP method will work for him, but his function tests will have to be visually verified every single time. Won't they? Is there any other way?",
            "id": "e418cd4ec9966e5799f80269a3fdad01"
          },
          {
            "type": "html",
            "text": "\nThis seems to be a harder problem than GUI testing in general, because often with GUI testing the layout isn't a huge concern; rather, you just want to verify the interactions between components, and that can be done by watching events and similar strategies. But for plotting and graphing, tiny details (individual pixels, even) are important. But you can't get that just from tracking drawing primitives, because optimization might change drawing strategies drastically while producing the same results.",
            "id": "bd18068c81c2e669d89bc1b5dc2bc5e7"
          },
          {
            "type": "html",
            "text": "\nI suppose he could do screen captures and compare them pixel-for-pixel ... is there an Extreme Programming challenge here? -- [[Glenn Vanderburg]]",
            "id": "0ccb4d78e18faf5f499ae2bd15f2d3e9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nHow about this ...",
            "id": "0b6525f6ab4376c9cbd23041da7060f9"
          },
          {
            "type": "html",
            "text": "\nWrite [[Acceptance Test]]s that check whether the system's \"analytical\" features produce the right \"vectors\" of values to feed into the graphing tool. These can all be checked with the usual testing tools.",
            "id": "3967632e95ba29ff574041777689dcd3"
          },
          {
            "type": "html",
            "text": "\nWrite a small number of tests that convert provided constant vectors into pictures on the screen. Capture these and compare them bit for bit. ",
            "id": "ca893c24b0e1a5fbed48d0493b3c6ce9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nI've encountered QA departments with serious internal knowledge problems. One has to mentor them gently on some deep insights of software development. Like, save your test plan, because in a few months we'll give you the next release of the software and you won't want to write the test plan again from scratch.",
            "id": "f98431fcc2c2343418b2b0397b66f2a2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nThe JDK 1.3 offers a special class for [[Gui Testing]]: [http://java.sun.com/products/jdk/1.3/docs/api/java/awt/Robot.html java.sun.com]. -- [[Helmut Merz]] <i>[[Broken Link]], 06 Apr 2004</i>",
            "id": "130db2b6be32f84e13dd42a7fe4a7baa"
          },
          {
            "type": "html",
            "text": "<i>Hmm, Robot appears to be a [[Screen Scraper]] utility; it has mouseMove and mousePress methods, for example. So it probably is not as useful as it could be.</i>",
            "id": "e6d17b503f4b1b838fba4a6b8bfa319c"
          },
          {
            "type": "html",
            "text": "\nThat's true, it's really only about native events. So it's just an API for the development of - platform independent - [[Screen Scraper]] utilities. -- [[Helmut Merz]] (slightly disappointed :-|)",
            "id": "3a1d5d20ecff175789e46899962ef882"
          },
          {
            "type": "html",
            "text": "<i>I suppose that you could get it to do something cleverer without too much fuss: rather than remembering screen locations and putting mouse-clicks on them (and so on), one could do something like:</i>",
            "id": "2bcae2ddd1734df21bc0a2d7d4318965"
          },
          {
            "type": "code",
            "text": "  robot.mouseMove(myComponent.getX(), myComponent.getY());\n  robot.mousePress(InputEvent.BUTTON1_MASK);\n  robot.mouseRelease(InputEvent.BUTTON1_MASK);",
            "id": "e5ead447a3978e06bd13138c8fcb9c6c"
          },
          {
            "type": "html",
            "text": "<i>which would make a good definition for a clickButtonOn(Component myComponent) method. Hmm. Well, it's a thought anyway.</i>",
            "id": "d7921bea2b73612f99011dd0a63cd5dc"
          },
          {
            "type": "html",
            "text": "\nUnfortunately, if you already have myComponent you can just call the doClick() method on it. I for one would like to do the GUI testing without having to keep references to each component. -- [[Brian Robinson]]",
            "id": "e27cd73694bf7970b2f88c5d57422b67"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nA cycle I've used a few times (not enough to <i>know</i>, but enough to smell the existence of something useful) involves the use of a [[Wiki Clone]] and some associated stuff. It goes something like this:",
            "id": "3f30c0317f8451d20e548b810222c2ac"
          },
          {
            "type": "html",
            "text": " Clone a Wiki that pertains to the project at hand, and make sure the team and some stakeholders have access to it and know how to use it. I seed this with a few interesting index pages...[[User Profile Index]], [[Use Case Index]], [[Scenario Index]], [[Choreography Index]], [[Feature Index]], [[Design Index]], and some others.",
            "id": "5aa73f752e611c1201da911fc5a037cf"
          },
          {
            "type": "html",
            "text": " Write a handful of key [[Use Case]]s. Usually more than two...ten is too many. I use a common form (in Wiki), and I end each name with '[[Use Case]]' as a suffix (like [[Pay Per View Use Case]]). Each agent in a [[Use Case]] has a user profile, like [[Domain Expert User Profile]]. Generally the community can get the [[Use Case]]s and [[User Profile]]s put together reasonably soon, and the experience usually gets them fired up about Wiki as well. Also, the ability to adjust them is a huge win.",
            "id": "5d2dbf97a4b33439ce9d324a0106b56c"
          },
          {
            "type": "html",
            "text": " Write a few [[Scenario Index]]'s for each [[Use Case]], as you need them. Each describes how a user (referenced by [[User Profile]]) accomplishes the task.",
            "id": "f787bf69eaf79fa6867b6daf2a58c9ce"
          },
          {
            "type": "html",
            "text": "3. Design a choreography. This is the flow through the application - although a good graphic designer or industrial designer can help, the choreography is more about behavior than appearance. I draw mine, using Visio. They look a lot like flowcharts. For websites, these sort-of correspond to screens. I hacked Wiki so that my users see the drawings (I turn them into GIFs or JPGs, then expand them inline), and I embed each in a page that includes wiki links to others. So the general theme is that you can walk through the application in Wiki. My teams like this because Wiki lets them annotate the things they like and don't like, and we can always change stuff. [A good resource for this kind of diagramming is [[Jesse James Garrett]]'s [[Visual Vocabulary]]:<br>[http://www.jjg.net/ia/visvocab/ www.jjg.net] - [[Dinah Sanders]]]",
            "id": "c89d70e4c21ab6500abd152c096d5d0f"
          },
          {
            "type": "html",
            "text": " The boxes on a choreography end up being actions the application has to do. These turn into something like services.",
            "id": "773b8380d556f3432f6d3bff844bbed9"
          },
          {
            "type": "html",
            "text": " Now, each scenario can get a drawing that shows several choreographies.",
            "id": "f34378be6974de198aa15f9eb102df14"
          },
          {
            "type": "html",
            "text": " Somewhere between choreographies and scenario's, you can have the UI designer's sketch screen designs. These can be linked to the corresponding choreography or scenario.",
            "id": "49d7274c8cd9c52fd491d7cb5a8be2f8"
          },
          {
            "type": "html",
            "text": " The QA team can use all this to develop test suites, generally driven by the [[Use Case]]s. They can walk through the choreographies and scenarios, looking for special things to exercise.",
            "id": "b94b9af1d1035d3a4d6c75259d828195"
          },
          {
            "type": "html",
            "text": " The QA team and stakeholders can begin walkthroughs, making sure that the app is solving the right problem. Sometimes applications that work precisely as designed fail because they were designed to solve the wrong problem.",
            "id": "2301420a018d26acdd4a97c3fec9d0f5"
          },
          {
            "type": "html",
            "text": " The test scripts and tests themselves, along with expected results, notes, and all sorts of useful material, can be developed in or closely integrated with Wiki. I've found that this helps preserve organizational memory and learnings.",
            "id": "5012f824c5645df2f3d8b46f96a9cda8"
          },
          {
            "type": "html",
            "text": " Finally, as parts start to be finished, everybody can try them out and exercise them along the way. Developers can exercise their code with the test scripts. Developers and testers can repeat tests. Etc.",
            "id": "6f785978557388f5477c35a2c84147b2"
          },
          {
            "type": "html",
            "text": " When everybody says its finished, there is a reasonable (not perfect, but reasonable) way of supporting that assertion.",
            "id": "689c0573da4343f71a75895ecb1bee51"
          },
          {
            "type": "html",
            "text": "\nAs I say, I've done this on about four projects. I'm sure there's lots of cool stuff to do here, someday maybe I'll even get to work more on it. The trouble, as always, is that there is always more code to write...I never get to follow up on these cool things. Wiki is <i>awesome</i>!",
            "id": "7994f67f94c8ad9a3969e973f0cd5be9"
          },
          {
            "type": "html",
            "text": "-- [[Tom Stambaugh]]",
            "id": "a2e89575f6b7f4230f783a34567ac356"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nI have a short history of GUI automation and a set of useful links in a Web Watch article I wrote for Software Testing and Quality Engineering Magazine. \n[http://www.stqemagazine.com/webinfo_detail.asp?id=102 www.stqemagazine.com] [[[Broken Link]]<b></b>?, 06 Apr 2004] The page is automatically generated from who-knows-what, so it's pretty ugly. Sorry about that.",
            "id": "306c6b255615fcc6022fbf4866b75cf0"
          },
          {
            "type": "html",
            "text": "-- [[Brian Marick]]",
            "id": "fe21b4bd50614d85ad1c307c3fc32948"
          },
          {
            "type": "html",
            "text": "<b>Actually,</b> it is not all that bad. We had been trying for nearly two years to find value in the screen-scraping style of GUITesting. We found that:",
            "id": "3f22628f6154b90dbf36f558733bd8ec"
          },
          {
            "type": "html",
            "text": " The automated tools were fairly expensive and required a completely different set of skills that the developers had, so",
            "id": "26d2b184f8055b2a10e8a7a9b1e89927"
          },
          {
            "type": "html",
            "text": " only a few persons were assigned to create GUI [[Unit Test]]s, and",
            "id": "a7c823782d1ffb91bc3bf7d47437a6ef"
          },
          {
            "type": "html",
            "text": " they couldn't keep up with the GUI developers, and",
            "id": "7499de543f811ef0f3536fb76696bcda"
          },
          {
            "type": "html",
            "text": " the tests they produced were very brittle, breaking whenever simple changes were made to the GUIs (this may have been their inexperience), so",
            "id": "fe3d7049565ea41eb9d006feb25216b3"
          },
          {
            "type": "html",
            "text": " the tests produced were essentially useless and the testers got discouraged and quit.",
            "id": "6a4c829f09ee9538e7ad4af3bb3d1173"
          },
          {
            "type": "html",
            "text": "\nThe result was that the only [[Unit Test]]s we had were on the non-GUI portions of the code. All the business logic resides there, so that was not too bad but the GUIs became more and more bloated. When we got into [[Performance Testing]], we found that some of the GUIs were horrendously slow with large amounts of data. Some we could modify reasonably easily, but one particularly egregious GUI was so bad that nobody knew how it worked.",
            "id": "dbbfc42b6afa5c12532263208ead1bc7"
          },
          {
            "type": "html",
            "text": "\nFinally, we followed a suggestion by [[Martin Fowler]] to write a test for the GUI by hand, using the same framework and techniques used in our other [[Unit Test]]s. Once we had written a reasonable library of GUI manipulation methods (which took just a few days) implementing the actual test went very quickly, and we were able to refactor the GUI, cutting its code size down by nearly two-thirds (writing the tests and refactoring took three weeks), followed by three days to speed up the code so that operations which used to take 6 minutes now take about 2 seconds.",
            "id": "4d7aeb821965cf73db8ee66d3ea08b72"
          },
          {
            "type": "html",
            "text": "\nMy advice - just wade in and start writing those tests. -- [[Russell Gold]]",
            "id": "6e29e69119cd24bb714b97416cb60519"
          },
          {
            "type": "html",
            "text": "<i>Can you provide example methods from your library of [[Gui Manipulation Methods]]? Are they like the AWT Robot calls above? Do you eventually wind up rendering the GUI to a bitmap and compare it to an expected bitmap?</i>",
            "id": "703245c6c36c5e15597b0fad3b728e9a"
          },
          {
            "type": "html",
            "text": "\nHere is an example test, which adds a subtree of business nodes to a structure represented by a JTree, saves it, deletes the top of the subtree, and finally confirms that all of the subnodes below are removed as well:",
            "id": "d95f1e3e891ed7cd11373485f4d47482"
          },
          {
            "type": "code",
            "text": "  public void testNodeTreeDelete() throws Exception {\n  clickOn( _tree, getEntityPath( _nodeRoot ) );\n  DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) _tree.getLeadSelectionPath().getLastPathComponent();\n  int numChildren = rootNode.getChildCount();",
            "id": "0358f1f8c5165f51fa1f381aee9e478a"
          },
          {
            "type": "code",
            "text": "  selectPopupMenu( _tree, getEntityPath( _nodeRoot ), new String[] { \"New Node\" } );\n  replaceText( EnterpriseModelerFrame.BUSINESS_NODE_NAME, \"NodeT1\" );\n  selectComboBoxValue( EnterpriseModelerFrame.BUSINESS_NODE_STATUS, \"Active\" );\n  Object nodeT1 = getSelectedObject();",
            "id": "0f77d95e82e32be40cf124e8c470a7a3"
          },
          {
            "type": "code",
            "text": "  selectTreePopupMenu( nodeT1, \"Copy\" );\n  replaceText( EnterpriseModelerFrame.BUSINESS_NODE_NAME, \"NodeT1A\" );\n  selectComboBoxValue( EnterpriseModelerFrame.BUSINESS_NODE_STATUS, \"Active\" );\n  Object nodeT1A = getSelectedObject();\n  dragAndDrop( nodeT1A, nodeT1 );",
            "id": "a4a061e4caf875c50bf6e44025d0c63e"
          },
          {
            "type": "code",
            "text": "  selectPopupMenu( _tree, getEntityPath( nodeT1 ), new String[] { \"Delete Family\" }, new ConfirmationDialogHandler() );",
            "id": "0aada8fd6ae4edff74a5fa265c0baa3b"
          },
          {
            "type": "code",
            "text": "  if (rootNode.getChildCount() != numChildren) reportFailure( \"Wrong number of children on root node.\" );\n  }",
            "id": "372aa9aeaa24cddea7d66431fb936670"
          },
          {
            "type": "html",
            "text": "\nThis approach relies on the underlying entities, which are tested elsewhere, and on the Swing classes themselves, which are presumed to be reliable. We expect our Frames to implement an interface which returns a control by name. We absolutely do not use bit-maps, which would be very fragile. These tests can actually be written, like all good [[Unit Test]]s, before the code which implements them. In some cases, we can check the color or size by fetching the appropriate renderer and asking for its color, size, position, etc.",
            "id": "581c409647bf12d28510e1502d4f89b2"
          },
          {
            "type": "html",
            "text": "\nSome of the library methods used include:",
            "id": "e5cdf865c78957f1d95b75ebe87db3b0"
          },
          {
            "type": "html",
            "text": "selectTreePopupMenu:<br>pops up a menu on the specified tree node and selects the named menu item",
            "id": "44a37ee6dc71d9ecba48109d4333eddc"
          },
          {
            "type": "html",
            "text": "clickOn:<br>does a mouse-down on a GUI element, or a path in a JTree",
            "id": "7bf048b0b36f4856a70fef398e6490c4"
          },
          {
            "type": "html",
            "text": "dragAndDrop:<br>drags one JTree node onto another",
            "id": "e38e74610bea95f33e3462f68e3a5d1f"
          },
          {
            "type": "html",
            "text": "replaceText:<br>selects the text in a control and types the specified text in its place",
            "id": "e4bf3e3068139f6c13d0a2e6e487884b"
          },
          {
            "type": "html",
            "text": "selectMenu:<br>selects a menu item from the menu bar",
            "id": "57181d11122c816390f646078d635019"
          },
          {
            "type": "html",
            "text": "selectComboBoxValue:<br>selects a named value from a combo box",
            "id": "2c8e058cb676f6cce96d100998e068c8"
          },
          {
            "type": "html",
            "text": "\nWe have others, not shown here, and we develop new ones as needed. -- [[Russell Gold]]",
            "id": "8468f421a4f4c9be8466d169e9085d47"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nSome various GUI testing resources:",
            "id": "006bd67565d08696468f9ff7b5f32a6e"
          },
          {
            "type": "html",
            "text": "\nThere are good tools available for doing [[Regression Testing]] on GUI applications. I've had some good experiences with SQA Robot and Microsoft Test. They have scripting languages, and can test field values or do bitmap comparisons, as you wish.",
            "id": "165ef6e49834cab0f1f428003edea58b"
          },
          {
            "type": "html",
            "text": "\nSQA Robot, by SQA Software - bought by Rational. See [http://www.rational.com/products/sqa_load/prodinfo/robot.jtmpl www.rational.com] ([[Broken Link]] as of 2003-05-07. Apparently SQA Robot is now called [[Rational Robot]]. See [http://www.rational.com/products/robot/index.jsp www.rational.com]) and [http://www.rational.com/products/visual_test/index.jtmpl www.rational.com] (See also the Saint Louis SQA user group at [http://www.midwest-st-lab.com/Usersgroup.html www.midwest-st-lab.com])",
            "id": "6ae7b58e1a922c89526d18e8e625e2be"
          },
          {
            "type": "html",
            "text": "\nFor Java users, there are several projects which extend JUnit to test Java GUIs. ",
            "id": "2391844b248b57d28a3522a67f7a2d0b"
          },
          {
            "type": "code",
            "text": " http://sourceforge.net/projects/abbot\n http://jemmy.netbeans.org\n http://sourceforge.net/projects/jfcunit\n http://sourceforge.net/projects/pounder",
            "id": "06c3bf23aca86bdbbf87767c342b8337"
          },
          {
            "type": "html",
            "text": "\nJFCUnit, Jemmy, and Abbot provide an extended library of robot-like functions similar to those described above (Button.click, Tree.selectNode, etc.). Abbot and Pounder also provide recording/playback and scripted tests which are useful for acceptance testing.",
            "id": "af11ff2620ac6ecda024ebe3df9a4a1e"
          },
          {
            "type": "html",
            "text": "\nThere is also a list for discussing these types of issues at [http://groups.yahoo.com/group/java-gui-testing groups.yahoo.com].",
            "id": "d2294fe6924aa173cbbc9a035840781e"
          },
          {
            "type": "html",
            "text": "\nAvignon ([http://www.nolacom.com/avignon/index.asp www.nolacom.com]) helps you develop your own language for customer tests and allows you to develop your own level of GUI testing.",
            "id": "6916e748fc6dadf4ed33cdd75cfeade8"
          },
          {
            "type": "html",
            "text": "\nSee [http://resolute.teradyne.com/prods/sst/product_center/testexec.html resolute.teradyne.com] for a good list of GUI test tools ([[Broken Link]]).",
            "id": "1d245cb514a54be016fcef4bee8ee8d9"
          },
          {
            "type": "html",
            "text": "\nSee also [[Marathon Man]].",
            "id": "29ec239d30dafee61050f52a276c91db"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nAn idea...",
            "id": "e40386b083882790e5ab0630aac1b716"
          },
          {
            "type": "html",
            "text": "\nGUI development is difficult to test ... therefore, [[Do The Simplest Thing That Could Possibly Work]] (and Test) and avoiding writing complicated widgets. I don't mean don't use the latest UI controls, just remove complication internally. Move that to other classes.",
            "id": "7803cf3f703035724e49d4f65fed52e0"
          },
          {
            "type": "html",
            "text": "\nYou can minimize complication in widgets by inverting the relationship between widgets and the underlying mechanics. Instead of having the UI drive the application, have the application drive the UI. That is, consider the UI a tool for the model/engine to communicate to the user, not for the user to communicate to the model/engine. [[Model View Controller]] helps immensely.",
            "id": "a9067dd7f265f3d99b8e7c3cf577a877"
          },
          {
            "type": "html",
            "text": "\nTake this concept right into the Controller. Break it into separate [[Tight Groups Of Classes]]. One that interacts with the operating system, that receives events for example. Another that contains a [[Finite State Machine]] that reacts to your OS wrapper class.",
            "id": "c82c6bb97667df674a2b16f5d751f6fb"
          },
          {
            "type": "html",
            "text": "\nMFC and Win32 [[Makes Me Cry]]. [[App Wizard]] doesn't help because it likes putting the entire model inside the UI. The Doc/View architecture really isn't. Why do CDocument subclasses receive Windows events?!",
            "id": "c0ee06b1ec11ea60d19bfccd2af1153f"
          },
          {
            "type": "html",
            "text": "\nTherefore, just do it by hand, or if you can't, gut out the classes that [[App Wizard]] generates. Put everything into separate classes that MFC call. ",
            "id": "98ed39074057415e8584ed6b488fa82f"
          },
          {
            "type": "html",
            "text": "\nYou'll get lightweight UI controls you can easily test, even without [[Unit Test]]s if you can't figure out how to write them for every possible user event. And you can easily test the non-OS driven classes using [[Unit Test]]s. -- [[Sunir Shah]]",
            "id": "27ef3e2b8ec2015f2f56bcc0114ab98c"
          },
          {
            "type": "html",
            "text": "[This is useless advice because you're basically saying don't test the GUI, test the logic. Which is fine, but I was assuming that people were already separating this code out (Anyone who's professionally writing GUIs should be fired if they don't understand and use MVC. Of course, I don't think anyone sane should be using MFC, either...). The question at hand is unit testing GUIs per se, and I really don't see a correct way to do this. How do you test that a tooltip is shown at the correct time and in the correct place? That it has correct text? How about things like flicker and graphic corruption from resizing, especially with custom-built widgets? I don't think there's any way to solve these sort of problems.]",
            "id": "458f72206b26467779a9f3fd5dd51e38"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nI think the article \"Integrated, Effective Test Design and Automation\" by Edward Kit (Software Development, February 1999) provides an XP-like approach to GUI testing. The idea is to use the scripting abilities of the testing tool. Kit argues that Capture / Playback creates scripts that are non-structured, non-commented and virtually non-maintainable. Thus, engineers should create test scripts by hand.",
            "id": "c6d44982697cce854390c191db17a7b5"
          },
          {
            "type": "html",
            "text": "\nIf the scripting language is easy to use, it should be easy to add tests \"on the fly\". -- [[Albert Brandl]]",
            "id": "51e094b5ba23642e6bf3dfa85202f7f8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nPerhaps some of the current discussion could be [[Re Factor]]ed out into the [[Gui Testing Patterns]] page.",
            "id": "67aaf5840cf590896333711849b3cf70"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nThese all sound like discussions of how to test an existing GUI. How do you [[Code Unit Test First]] for GUIs? -- [[Eddie Deyo]]",
            "id": "273a2bc3a82a673b6b4868a45a9265fe"
          },
          {
            "type": "html",
            "text": "\nTo [[Code Unit Test First]] for GUIs, read [[Then Dont Call Main Loop]].",
            "id": "20aa97501654dbd14606988b19ae65b5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nI thought of an Idea of an EFFECTIVE GUI TESTING FRAMEWORK:",
            "id": "d6d23e66c0ab0f5ce748020a43386d3b"
          },
          {
            "type": "html",
            "text": "\nWhy not using the power of AOP ([[Aspect Oriented Programming]]) for GUI tests?",
            "id": "8cafd34e5c01d078aa58f3a85d0d6ea8"
          },
          {
            "type": "html",
            "text": "\nIt will look like that: ",
            "id": "5082f289571e3f1d1e0edca60f73a62d"
          },
          {
            "type": "html",
            "text": "(This is Pseudo - AspectJ. I don't know it - yet.\nI have written GUI in Delphi, but never in Java)",
            "id": "af07df3c320f04ce1b4e658314e45cce"
          },
          {
            "type": "html",
            "text": "\nAspet Test.testAddOrder {",
            "id": "c02045a0e4acb4a4d279ba4969cf384b"
          },
          {
            "type": "code",
            "text": "  int step = 0; // count steps during the test",
            "id": "19f2f00fbfa2f10dd3142752a3df2bdc"
          },
          {
            "type": "html",
            "text": "after:<br>class [[Form Order]].onOpen() {",
            "id": "31dc5e702c37435b96f5c2475a7fe07c"
          },
          {
            "type": "code",
            "text": "        if (step == 4) {\n        btnDetails.click();\n        }\n        if (step == 8) \n        btnClose.click();\n  }",
            "id": "36d064cee9f4d28665d0d2c707d3341d"
          },
          {
            "type": "html",
            "text": "after:<br>class [[Form Order Details]].onOpen() {",
            "id": "7ffe8a54578d2e6961f75fd7bdb26211"
          },
          {
            "type": "code",
            "text": "        if (step == 5) {\n        editOrderNumber.text = \"ED1723-74\"; // an edit box\n        btnSearch.click();\n        AssertTrue(TableOrder.get(\"OrderNo\").equals(\"ED1723-74\")); // suppose some aspect exoses DB easily\n        editIRR.text = \"0.88\";\n        btnUpdate.click();\n        AssertTrue(MessageBox.isActive(Message.ERROR)); // some framework aid to indentify error dialog\n        Dialog.btnOk.click(); // close dialog\n        editIRR.text = \"... // and so on  \n        }\n  }",
            "id": "401eca96e4fcf8c3e613bdb811930437"
          },
          {
            "type": "html",
            "text": "}",
            "id": "74c8fc888d603696ce8d2134a07d91c8"
          },
          {
            "type": "html",
            "text": "\nthru [[Aspect Jay]] you can check that all buttons named \"btnAddRecordXXX\" indeed add record to a table named XXX",
            "id": "02aa3891d18dddf7b13fe349998321bf"
          },
          {
            "type": "html",
            "text": "\nideas:",
            "id": "60eb3cceb8aa603c020c387a89b3b66f"
          },
          {
            "type": "html",
            "text": " the step tracking could be smarter",
            "id": "b777baa343d8a16e049ed29684e72dd4"
          },
          {
            "type": "html",
            "text": " no gui must be displayed => test is Swift! (aspect for all forms to be hidden)",
            "id": "406548eec9987264c20cbba67391b9ac"
          },
          {
            "type": "html",
            "text": " assumption:<br>standard gui classes work and need no test.",
            "id": "aae7cc68184c889d10dbb70b1f268b79"
          },
          {
            "type": "html",
            "text": " strict naming scheme required, or [[Find Button]](String name) functions could be written in the frameworks",
            "id": "4c466582bab45c1ecd581acd4f86d996"
          },
          {
            "type": "html",
            "text": " the test must use presentation layer classes only. Changes to Database will be available by some specific DBRead class.",
            "id": "76534b4b25f019fb38d623318dc3ff95"
          },
          {
            "type": "html",
            "text": "\nthe good:",
            "id": "b98fde1c83c8e33c7d43d2f04030f1f0"
          },
          {
            "type": "html",
            "text": " fast",
            "id": "2f2efeca386ba1b95462e590fb03588f"
          },
          {
            "type": "html",
            "text": " easy",
            "id": "91bfd63ef150721257de1e2f90911219"
          },
          {
            "type": "html",
            "text": " robust to Gui design changes (I think button name is more robust than finding button label);",
            "id": "44777519217fcd16e4df410fb2c63db6"
          },
          {
            "type": "html",
            "text": "\nthe bad:",
            "id": "960984ec0cae3279702972c94f1a8400"
          },
          {
            "type": "code",
            "text": " ???",
            "id": "bb5d5509bb10ea3578bba4ea99a2fc31"
          },
          {
            "type": "html",
            "text": "If I get some positive feedback that this is innovative and useful idea, I'll develop it as my Senior Project. I need your feedback. Thanks!",
            "id": "f5602c87dbfc4eb4e9e71affaa3d6640"
          },
          {
            "type": "html",
            "text": "-- Lior Bar-On",
            "id": "062c715d8fa0e45ab7ae8f2d9b2a3dd9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "[[[Refactor Me]]: I'm curious how this can be applied to HTML UIs. I want to introduce [[Extreme Programming]] into a web project. Has anyone done this for an existing project? a new one? -- [[Andrew Kris Thompson]]]",
            "id": "84b6bacc6107944452c088c3e00a2ba4"
          },
          {
            "type": "html",
            "text": "\nSee [[Web Testing]].",
            "id": "85a639f1b3fa0e8060672ad91f69256a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nI haven't had much success in using [[Test Driven Development]] when [[Gui Testing Game Apps]]. Perhaps this is one of those instances when this method doesn't work.",
            "id": "4fe6290c0eb1a2f16d7df349491ac771"
          },
          {
            "type": "html",
            "text": "<i>E-search for [[Tom Plunket]]; he seems to be doing the polygon mesh layers test-first. You could ask him this question on news:comp.object, for example. -- [[Phl Ip]]</i>",
            "id": "60233b3efadfb74d1db7b8ef4f85f87f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nSee the extensions that I'm building into FIT for GUI testing - [[John Goodsen]]. Remember FIT is at [http://fit.c2.com fit.c2.com].",
            "id": "6216ff600cfb74597481282f74146feb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nI found a good link with GUITesting references (payware, freeware, Java-only, etc.)",
            "id": "26a5832c1073b40fd40f0dd412472680"
          },
          {
            "type": "html",
            "text": "\n[http://www.testingfaqs.org/t-gui.html www.testingfaqs.org]",
            "id": "2e8c5d8dd98c15ff2d79c08ad4b5b850"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "\nThe only good way of testing GUIs I know requires the GUI to be written, in two parts.  The front part is visual only, it contains the interface and it produces a string of text commands which gets sent to the back end, which processes them, and returns text responses.  Each individual half is easy to test.  ",
            "id": "e8daa253627173e9194fc91b8fe2d817"
          },
          {
            "type": "html",
            "text": "\nTo test the front end, push the buttons in the right order and check that the right text file is generated.  It's manual, but it's quick, and doesn't have to be done often.  And the actual checking can just about be done with diff.",
            "id": "d8bc0d286f2b1b6874c7b6deb5dcf614"
          },
          {
            "type": "html",
            "text": "\nTo test the back end, feed in a text file, and check what happens.  The text file can be generated with the front end, by hand, or a combination of both.  This can be completely automated.",
            "id": "5a63bdb6ffb43649907131e4cc926414"
          },
          {
            "type": "html",
            "text": "\nThe problem is that your GUI developers have to have enough discipline to keep everything that can break in the back end.  I've seen it done, if only when the text version came first and the front end was a bolt-on.  Otherwise, it's always too tempting to put the logic into the front end.  Regards, --[[Ben Aveling]]",
            "id": "b06857ed740c96184991e84910924c80"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "See [[Test First User Interfaces]] [[User Interface]]",
            "id": "8324008e250ec5f1e52a4efc109c763e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c8c22fa316221cf7810cac2a2799fdc9"
          },
          {
            "type": "html",
            "text": "[[Category Testing]] [[Category User Interface]]",
            "id": "293487e1170377f1499499ea5c1cd32e"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?GuiTesting c2.com]",
            "id": "756fb439cd80f44e87ec6865db15e6f0"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1628148915391
    }
  ]
}