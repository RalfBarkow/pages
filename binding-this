{
  "title": "binding `this`",
  "story": [
    {
      "type": "paragraph",
      "id": "73922aa8066a2ee0",
      "text": "Loosing your invocation context (`this`) is one of the [[JavaScript common pitfalls]]. Using `this` you can write generic methods that modify the objects they are part of, in an object oriented way. However as you start combining that with more functional programming, passing references to functions into other functions and the like, your function can be invoked in ways you didn't expect, often with no way to access the originally intended `this`."
    },
    {
      "type": "code",
      "id": "04da9ee01e15ef36",
      "text": "var a =\n  { total: 0\n  , inc: function () { this.total += 1 }\n  };\n\n// broken\notherThing(a.inc)\n\nconsole.log(a.total) // 0\n\nconsole.log(total) // NaN\n\nfunction otherThing (incFn) {\n  incFn()\n  incFn()\n  incFn()\n}\n"
    },
    {
      "type": "paragraph",
      "id": "c4ba1f79c31f2368",
      "text": "There is a mysterious global called total because functions executed without another context are executed in the global context, and [[properties on window are global variables]]."
    },
    {
      "type": "paragraph",
      "id": "f941270c8d30e426",
      "text": "The increment function is passed in as a reference to the creatively named otherThing, but it no longer has any idea what it's context is. The 'this' isn't tied to how the function is defined, it is tied to how it is called. But of course we can cheat it by binding it permanently ourselves."
    },
    {
      "type": "paragraph",
      "id": "504907fb67cd979c",
      "text": "One way to bind the function to a set context is the built in 'function.bind(context)'. This returns a new copy of our function, permanently bound to the context provided, irregardless of how we invoke it."
    },
    {
      "type": "code",
      "id": "3ae2be7651f46b71",
      "text": "var a = { total: 0 };\na.inc = incTotal.bind(a)\n\notherThing(a.inc)\n\nconsole.log(a.total) // 3\n\nfunction incTotal () { this.total += 1 }\n\nfunction otherThing (incFn) {\n  incFn()\n  incFn()\n  incFn()\n}"
    },
    {
      "type": "paragraph",
      "id": "d228a4e4740f4e1b",
      "text": "The other way is to quite simply use any possible reference to the object other than this to define our function."
    },
    {
      "type": "code",
      "id": "cf0ddbc9ae9f42fa",
      "text": "var a =\n  { total: 0\n  , inc: incTotal\n  }\n\notherThing(a.inc)\n\nconsole.log(a.total) // 3\n\nfunction incTotal () { a.total += 1 }\n\nfunction otherThing (incFn) {\n  incFn()\n  incFn()\n  incFn()\n}\n"
    },
    {
      "type": "paragraph",
      "id": "411f91564e931487",
      "text": "Either of these solutions work fine. The downside to both is the same, you have to have a different copy of the function for each object you want to increment. It's just the nature of the beast, if you want the function to be generic you need to either invoke it with the correct context, or pass all of the parameters in as arguments. Otherwise you need to create different copies of the function to work on each object, which is almost always just fine to do."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "binding `this`",
        "story": []
      },
      "date": 1432347646741
    },
    {
      "item": {
        "type": "factory",
        "id": "73922aa8066a2ee0"
      },
      "id": "73922aa8066a2ee0",
      "type": "add",
      "date": 1432347649254
    },
    {
      "type": "edit",
      "id": "73922aa8066a2ee0",
      "item": {
        "type": "paragraph",
        "id": "73922aa8066a2ee0",
        "text": "Keeping track of `this` can be very hard in JavaScript, but it's powerful for certain kinds of things. You can use it to write generic methods that modify the objects they are part of, in an object oriented way. Or you can use it to provide context to callbacks or other functions handed in to places."
      },
      "date": 1432348984498
    },
    {
      "type": "edit",
      "id": "73922aa8066a2ee0",
      "item": {
        "type": "paragraph",
        "id": "73922aa8066a2ee0",
        "text": "Keeping track of `this` is one of the [[JavaScript common pitfalls]], but it's powerful for certain kinds of things. You can use it to write generic methods that modify the objects they are part of, in an object oriented way. Or you can use it to provide context to callbacks or other functions handed in to places."
      },
      "date": 1432354687175
    },
    {
      "item": {
        "type": "factory",
        "id": "04da9ee01e15ef36"
      },
      "id": "04da9ee01e15ef36",
      "type": "add",
      "after": "73922aa8066a2ee0",
      "date": 1432355046175
    },
    {
      "type": "edit",
      "id": "04da9ee01e15ef36",
      "item": {
        "type": "code",
        "id": "04da9ee01e15ef36",
        "text": "var a =\n  { total: 0\n  , inc: function () { this.total += 1 }\n  };\n\n// broken\notherThing(a.inc)\n\nconsole.log(a.total) // 0\n\nconsole.log(total) // NaN\n\nfunction otherThing (incFn) {\n  incFn()\n  incFn()\n  incFn()\n}\n"
      },
      "date": 1432355055451
    },
    {
      "item": {
        "type": "factory",
        "id": "c4ba1f79c31f2368"
      },
      "id": "c4ba1f79c31f2368",
      "type": "add",
      "after": "04da9ee01e15ef36",
      "date": 1432355196261
    },
    {
      "type": "edit",
      "id": "c4ba1f79c31f2368",
      "item": {
        "type": "paragraph",
        "id": "c4ba1f79c31f2368",
        "text": "There is a mysterious global called total because functions executed without another context are executed in the global context, and [[properties on window are global variables]]."
      },
      "date": 1432355235632
    },
    {
      "type": "add",
      "id": "f941270c8d30e426",
      "item": {
        "type": "paragraph",
        "id": "f941270c8d30e426",
        "text": "The increment function is passed in as a reference to the creatively named otherThing, but it no longer has any idea what it's context is. The 'this' isn't tied to how the function is defined, it is tied to how it is called. But of course we can cheat it by binding it permanently ourselves."
      },
      "after": "c4ba1f79c31f2368",
      "date": 1432355436361
    },
    {
      "item": {
        "type": "factory",
        "id": "504907fb67cd979c"
      },
      "id": "504907fb67cd979c",
      "type": "add",
      "after": "f941270c8d30e426",
      "date": 1432361293124
    },
    {
      "type": "edit",
      "id": "504907fb67cd979c",
      "item": {
        "type": "paragraph",
        "id": "504907fb67cd979c",
        "text": "One way to bind the function to a set context is the built in 'function.bind(context)'. This returns a new copy of our function, permanently bound to the context provided, irregardless of how we invoke it."
      },
      "date": 1432361403715
    },
    {
      "item": {
        "type": "factory",
        "id": "3ae2be7651f46b71"
      },
      "id": "3ae2be7651f46b71",
      "type": "add",
      "after": "504907fb67cd979c",
      "date": 1432361608489
    },
    {
      "type": "edit",
      "id": "3ae2be7651f46b71",
      "item": {
        "type": "code",
        "id": "3ae2be7651f46b71",
        "text": "var a = { total: 0 };\na.inc = incTotal.bind(a)\n\notherThing(a.inc)\n\nconsole.log(a.total) // 3\n\nfunction incTotal () { this.total += 1 }\n\nfunction otherThing (incFn) {\n  incFn()\n  incFn()\n  incFn()\n}"
      },
      "date": 1432361617012
    },
    {
      "item": {
        "type": "factory",
        "id": "d228a4e4740f4e1b"
      },
      "id": "d228a4e4740f4e1b",
      "type": "add",
      "after": "3ae2be7651f46b71",
      "date": 1432361650514
    },
    {
      "type": "edit",
      "id": "d228a4e4740f4e1b",
      "item": {
        "type": "paragraph",
        "id": "d228a4e4740f4e1b",
        "text": "The other way is to quite simply use any possible reference to the object other than this to define our function."
      },
      "date": 1432361742621
    },
    {
      "item": {
        "type": "factory",
        "id": "cf0ddbc9ae9f42fa"
      },
      "id": "cf0ddbc9ae9f42fa",
      "type": "add",
      "after": "d228a4e4740f4e1b",
      "date": 1432361907108
    },
    {
      "type": "edit",
      "id": "cf0ddbc9ae9f42fa",
      "item": {
        "type": "code",
        "id": "cf0ddbc9ae9f42fa",
        "text": "var a =\n  { total: 0\n  , inc: incTotal\n  }\n\notherThing(a.inc)\n\nconsole.log(a.total) // 3\n\nfunction incTotal () { a.total += 1 }\n\nfunction otherThing (incFn) {\n  incFn()\n  incFn()\n  incFn()\n}\n"
      },
      "date": 1432361912182
    },
    {
      "item": {
        "type": "factory",
        "id": "411f91564e931487"
      },
      "id": "411f91564e931487",
      "type": "add",
      "after": "cf0ddbc9ae9f42fa",
      "date": 1432361932915
    },
    {
      "type": "edit",
      "id": "411f91564e931487",
      "item": {
        "type": "paragraph",
        "id": "411f91564e931487",
        "text": "Either of these solutions work fine. The downside to both is the same, you have to have a different copy of the function for each object you want to increment. It's just the nature of the beast, if you want the function to be generic you need to either invoke it with the correct context, or pass all of the parameters in as arguments. Otherwise you need to create different copies of the function, which is almost always just fine to do."
      },
      "date": 1432362297139
    },
    {
      "type": "edit",
      "id": "411f91564e931487",
      "item": {
        "type": "paragraph",
        "id": "411f91564e931487",
        "text": "Either of these solutions work fine. The downside to both is the same, you have to have a different copy of the function for each object you want to increment. It's just the nature of the beast, if you want the function to be generic you need to either invoke it with the correct context, or pass all of the parameters in as arguments. Otherwise you need to create different copies of the function to work on each object, which is almost always just fine to do."
      },
      "date": 1432362367520
    },
    {
      "type": "edit",
      "id": "73922aa8066a2ee0",
      "item": {
        "type": "paragraph",
        "id": "73922aa8066a2ee0",
        "text": "Loosing your invocation context (`this`) is one of the [[JavaScript common pitfalls]]. Using `this` you can write generic methods that modify the objects they are part of, in an object oriented way. However as you start combining that with more functional programming, passing references to functions into other functions and the like, your function can be invoked in ways you didn't expect, often with no way to access the originally intended `this`."
      },
      "date": 1432363801303
    },
    {
      "type": "fork",
      "site": "nrn.io",
      "date": 1652868540366
    }
  ]
}