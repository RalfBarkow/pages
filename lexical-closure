{
  "title": "Lexical Closure",
  "story": [
    {
      "type": "html",
      "text": "A [[Lexical Closure]], often referred to just as a <i>closure</i>, is a function that can refer to and alter the values of bindings established by binding forms that textually include the function definition.",
      "id": "136194a70717718fd9ced93e4ac993a3"
    },
    {
      "type": "html",
      "text": "\nBy 'binding', we mean the association of a name with a value. By 'binding forms', we mean the constructs that define bindings and their scope in the language. ",
      "id": "d94cabf685ac03215df150af8c54fc58"
    },
    {
      "type": "html",
      "text": "\nConsider the following example in [[Common Lisp]]:",
      "id": "d5c5c3f1816a1ff539c95a65b05db735"
    },
    {
      "type": "code",
      "text": " (defun two-funs (x)\n  (list (function (lambda () x))\n   (function (lambda (y) (setq x y)))))\n (setq funs1 (two-funs 6))\n (funcall (first funs1)) =>  6\n (funcall (second funs1) 43) =>  43\n (funcall (first funs1)) =>  43\n (setq funs2 (two-funs 5))\n (funcall (first funs2)) =>  5\n (funcall (second funs2) 13) =>  13\n (funcall (first funs2)) =>  13\n (funcall (first funs1)) =>  43",
      "id": "d72ecf1ff5eb08dcc4aee1cee093862a"
    },
    {
      "type": "html",
      "text": "\nEach time TWO-FUNS is called, each lambda expression is evaluated to produce a closure. The two closures are returned as a list of two elements. A different <i>lexical environment</i> is in effect each time, in which the name X is bound to a value. The two closures share the binding of X. However, each call to TWO-FUNS results in a <i>new</i> lexical environment, so that the binding of X used by the closures in FUNS1 is distinct from the bindings of X used by the closures in FUNS2.",
      "id": "6d9351ca198f7355ee720393ee5f7dcd"
    },
    {
      "type": "html",
      "text": "\nIn languages or situations in which the bindings are immutable, a closure acts as if the references to lexical bindings had been replaced by their values when the closure is created. However, as the example illustrates, the bindings can be changed in languages that have mutable variables.",
      "id": "ff5ab59c48d6c2cd58f821d8ea5ea1d9"
    },
    {
      "type": "html",
      "text": "\nThe concept of lexical closure is potentially relevant to any programming language that supports lexical binding scopes and the definition of functions within a resulting lexical environment.",
      "id": "efe5c1563a8e9254b62448bfa766b998"
    },
    {
      "type": "html",
      "text": "\nLexical closures are most interesting in, and are usually associated with, languages that can treat functions as data ([[First Class Function]]s), since storing a closure for later use implies an extension of the lifetime of the closed-over lexical environment beyond what one would normally expect. However, there are languages without first-class functions that allow for the definition of functions in lexical scopes (e.g. Pascal, Algol). These nested functions can be used only within that lexical scope, and thus the lifetime of lexical bindings are not extended in such languages. Although 'closures' in such languages are far less powerful as a way of organizing program, they still serve as a useful notational convenience.",
      "id": "e7bf3694c387a7f9735b0ad420bedac0"
    },
    {
      "type": "html",
      "text": "\nLanguages that support lexical closures include:",
      "id": "1ac53c19925b2c292c22a766f472f7b3"
    },
    {
      "type": "html",
      "text": " [[Common Lisp]]",
      "id": "aceeda7f451c6c3837ab246cdae1ceee"
    },
    {
      "type": "html",
      "text": " [[Scheme Language]]",
      "id": "5fcc1420072ec39ba7de6fed2fba9987"
    },
    {
      "type": "html",
      "text": " [[Ruby Language]]",
      "id": "e73aef92f16ab9a3dd45858024a3a437"
    },
    {
      "type": "html",
      "text": " [[Cee Sharp]] (version 2.0+)",
      "id": "eb9741e46844371c3c2bf83b9a1df8f7"
    },
    {
      "type": "html",
      "text": " [[Lua Language]]",
      "id": "ff482f2df26b064301b9b01da99ac2c2"
    },
    {
      "type": "html",
      "text": " [[Perl Language]]",
      "id": "f7b891ca4b3c9cf00d3ac62acaf96c7f"
    },
    {
      "type": "html",
      "text": " [[Php Language]] (version 5.3+)",
      "id": "2c5864e866d1e840502b47b922ef1381"
    },
    {
      "type": "html",
      "text": " [[Python Language]] (full support since version 3 by nonlocal-declaration; partial support before, see [http://web.archive.org/web/20070223143715/http://mail.python.org/pipermail/python-list/2004-July/270951.html web.archive.org])",
      "id": "3570d3205b9a3bbb138677583fc5d23b"
    },
    {
      "type": "html",
      "text": " [[Java Script]]",
      "id": "16be4d7dcf78b2fcfc7fdacbe6c8bed7"
    },
    {
      "type": "html",
      "text": " [[Smalltalk Language]]",
      "id": "9433b0a1289b4e51c071dd5edb0dc485"
    },
    {
      "type": "html",
      "text": " [[Pascal Language]] (no first-class functions)",
      "id": "d9d80e223bdd8959d42c8ffb9ae6d7c3"
    },
    {
      "type": "html",
      "text": " [[Algol Language]] (no first-class functions)",
      "id": "bdb6f2c8d89fcf5b4317d9e43827f162"
    },
    {
      "type": "html",
      "text": " [[Objective Cee]] (version 2.1+; available for Mac OS X 10.6+)",
      "id": "1d84d135b0ec59f5484e62295ae9a49d"
    },
    {
      "type": "html",
      "text": " [[Cee Language]] and [[Cee Plus Plus]] (with the open source Clang([[Cee Language Family Front End]])/LLVM ([[Low Level Virtual Machine]]) compiler; Apple has submitted the specification for consideration by the ANSI C Standards Committee)",
      "id": "487bf3db81263dc1aefb3c61dd2fe82e"
    },
    {
      "type": "html",
      "text": " C++11 ([[Cee Plus Plus Eleven]]) (Partial support with new C++ lambdas--the programmer chooses whether the lambda makes copies of the captured stack variables or only references them.  References will cause [[Undefined Behavior]] if the lambda escapes the scope it was created in.",
      "id": "e48fffb47ebccd586f564a380e71548f"
    },
    {
      "type": "html",
      "text": "\nIn [[Pascal Language]] and [[Algol Language]], a function can be passed as an argument to another function, but cannot be stored in a variable or data structure, cannot be returned from a function, and cannot be created without being given a name.  However, when a function is passed to another function and later called, it will execute in the lexical context it was defined in, so it is, in some sense, \"closed over\" that context.",
      "id": "869f74ea30788be243d7189af4c8198e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0574aa9230fe392633c3719382651fa6"
    },
    {
      "type": "html",
      "text": "Notes on the above definition:",
      "id": "5b4bb40988b9fcd20e4036c749eed4f5"
    },
    {
      "type": "html",
      "text": "\nI rewrote the definition that was here, because it was not as clear as it could have been regarding the mutability of bindings. The wikipedia entry for closures suffers from the same problem. I was recently involved in an online discussion with someone who had misunderstood this, and it appears that some of the developers working on C# at Microsoft may have, also. See [http://blogs.msdn.com/abhinaba/archive/2005/10/18/482180.aspx blogs.msdn.com] . Thus they seem to think that the anonymous methods in C# version 2.0 somehow differ from lexical closures.",
      "id": "64700336904868d4af7a4652fa164fcf"
    },
    {
      "type": "html",
      "text": "\nThe definition and example that I have given are adapted from the the Common Lisp standard specification; cf. [http://www.lisp.org/HyperSpec/Body/sec_3-1-4.html www.lisp.org]. It is my contention that in a language supporting mutable bindings (variables), a lexical closure must support mutability of the closed-over bindings. I tried to modify and expand the definition to make it language agnostic.",
      "id": "b350f549dbee19b9171313f45bbcb045"
    },
    {
      "type": "html",
      "text": "\nThe original definition follows. [[Delete When Cooked]]. Note that the reference to SICP is misleading; as far as I can tell, SICP does not refer to lexical closures by that name, although it may describe the concepts involved. Also, AFAICT, the Scheme standard document does not mention closures by name either.",
      "id": "3989bbaa88f24419d9168bf4a4dbb66e"
    },
    {
      "type": "html",
      "text": "\nI also tried to succinctly address some issues that were discussed later on this page. For instance, the last paragraph should make it clear that dynamic typing is not relevant to the definition of a lexical closure.",
      "id": "84f79949c1654ebe715debfbb821574a"
    },
    {
      "type": "html",
      "text": "\nIn response to someone's addition of Pascal and Algol to the language list, I added a paragraph about 'closures' in languages lacking first-class functions.",
      "id": "7f7804019192f4ced6ad4bf2f5dd6f47"
    },
    {
      "type": "html",
      "text": "\nSomeone else clarified that functions can be passed as parameters in Pascal and Algol. I didn't remember this feature (haven't used Pascal in many years, and never learned Algol). Thanks!",
      "id": "8a2cce1a6f41de9620fe90c4204cb60d"
    },
    {
      "type": "html",
      "text": "-- [[Dan Muller]]",
      "id": "29559f94666874a94686000b8e8641b7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0574aa9230fe392633c3719382651fa6"
    },
    {
      "type": "html",
      "text": "<i>Previous definition appearing on this page:</i>",
      "id": "ea203bda31836fe3a5edef18e4d7557d"
    },
    {
      "type": "html",
      "text": "\nA [[Lexical Closure]] is a function whose [[Free Variable]]s have been given values by an enclosing [[Lexical Scope]].",
      "id": "618406d0c85fbedcfef8b185627f62e6"
    },
    {
      "type": "html",
      "text": "\nLexical closures are typically (but not always) formed by defining a function inside another function, for example (in [[Scheme Language]]):",
      "id": "98eaab76bcb8b826035406b895756bac"
    },
    {
      "type": "code",
      "text": " (define (foo x)\n  (define (bar y)\n  (+ x y))\n  bar)",
      "id": "a6d9a48ac0e6a65ca1533335c6656743"
    },
    {
      "type": "html",
      "text": "Now calling (foo arg) returns a closure consisting of a) the code of 'bar', and b) an environment where x has the value of arg.",
      "id": "0536e5587c799d98f9244615d38a3797"
    },
    {
      "type": "code",
      "text": " (define bar1 (foo 1))\n (define bar2 (foo 2))",
      "id": "1da2936a2553bdac6ac3ef3dc0f1e610"
    },
    {
      "type": "code",
      "text": " (bar1 5) => 6\n (bar2 5) => 7",
      "id": "ec15c0298d5c4220fa5d3c5b07d60493"
    },
    {
      "type": "html",
      "text": "In proper closures, not just the value is kept, but a reference to the actual object passed in. See the body of this page for a full explanation. As you may have noticed, lexical closures are necessary for [[Currying Schonfinkelling]].",
      "id": "0a533b556e6bb80be72d26fca9b8cd92"
    },
    {
      "type": "html",
      "text": "\nThose who are really interested in this should read [[Structure And Interpretation Of Computer Programs]]. ",
      "id": "6b6ba007b3d70ada085ae9261ef424f7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0574aa9230fe392633c3719382651fa6"
    },
    {
      "type": "html",
      "text": "[[Objective Caml]] example, where an enclosing 'let' is used rather than an enlcosing function:",
      "id": "e5c12d5594a26ae2f746626af13f51ee"
    },
    {
      "type": "code",
      "text": " let produce_counter_from initval =\n  let value = ref initval in\n  fun () -> incr value; (!value, initval);;",
      "id": "c9fc056749a190066d3365a765ca2882"
    },
    {
      "type": "code",
      "text": " let mycount = produce_counter_from 3;;\n mycount ();; (* produces (4, 3) *)\n mycount ();; (* produces (5, 3) *)",
      "id": "8fafa266d242bfc7b470d43df9523be5"
    },
    {
      "type": "html",
      "text": "\nThe anonymous function defined by 'fun () -> ...' remembers the names <b>value</b> and <b>initval</b>, which are bound in the surrounding scopes defined by the two 'let's. These names are accessible to it even after the call to produce_counter_from has finished.",
      "id": "b6917aca9318b0af7d2d3a67cb561f74"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0574aa9230fe392633c3719382651fa6"
    },
    {
      "type": "html",
      "text": "Note that although [[Anonymous Function]]s are often used to create closures, they are not necessary. [[Named Function]]s work equally well.",
      "id": "75c44893dcba92a166a219ffa075e334"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0574aa9230fe392633c3719382651fa6"
    },
    {
      "type": "html",
      "text": "A lexical closure is called just like an ordinary function. When this happens, the code of the closure is executed, and the references to the 'captured' [[Lexical Variable]]s just work. For this, the captured lexicals must be saved somehow, in an object that persists as long as the closure exists. This means the lexical variables can't be stored in an ordinary stack frame that expires when the execution of the outer [[Lexical Scope]] is finished.",
      "id": "7410ad477025bb559aa467b71ba89a22"
    },
    {
      "type": "html",
      "text": "\nThe closure has internal variables too, such as the parameters of its anonymous function, or local variables defined within the body of that function. These are the closure's <i>bound</i> variables, and are not included in the closure object, because their bindings are established whenever the closure is called. The captured variables from the surrounding environments are called <i>free</i> variables (that is, free with respect to the function because they are not bound within it but have to be \"reached\" for in the lexical environment). It's useful to know this <i>free variable</i> terminology because it's somewhat counter-intuitive, yet used quite a bit in the literature.",
      "id": "968288ba5574cfaae7b1bf1e2fb842fe"
    },
    {
      "type": "html",
      "text": "\nA [[Common Lisp]] example is useful, because the syntax is fairly obvious even to non-Lisp programmers, thanks to the parentheses that denote the tree structure without ambiguity.",
      "id": "2a184940bd25c7a62984d4b180c77150"
    },
    {
      "type": "code",
      "text": "  (defun make-counter (initial-value) ; initial-value is the variable we will capture in our anonymous function\n  (lambda ()      ; We'll make a closure that takes no parameters\n  (incf initial-value))))   ; This is equivalent to '++initial-value' in C",
      "id": "d2865d14cc23218aceaf8811f2b3b61a"
    },
    {
      "type": "html",
      "text": "\nThe result of the 'lambda' expression (a closure) is returned as the result of 'make-counter'.",
      "id": "800362dcb0d6736e2ea3450b0562b77d"
    },
    {
      "type": "code",
      "text": "  (defvar *closure-one* (make-counter 10))\n  (defvar *closure-two* (make-counter 100))",
      "id": "3cdab692dcfede44a1a4412b5c1c30a2"
    },
    {
      "type": "code",
      "text": "  (funcall *closure-one*) ;; --> 11\n  (funcall *closure-two*) ;; --> 101\n  (funcall *closure-one*) ;; --> 12\n  (funcall *closure-one*) ;; --> 13\n  (funcall *closure-two*) ;; --> 102",
      "id": "0c0dc9df64c56d4265c93efea8214690"
    },
    {
      "type": "html",
      "text": "\nAs you can see, two closure objects were made, <b>each capturing a distinct binding of the INITIAL-VALUE variable,</b> giving rise to two independent counting sessions. Note how the closures can continue to access INITIAL-VALUE, even though it's the parameter of a function call that has terminated.",
      "id": "4177ea2724abd29a32b4f09ad26b7000"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0574aa9230fe392633c3719382651fa6"
    },
    {
      "type": "html",
      "text": "Here is a similar example from [[Scheme Language]]. The goal is to create a counter.",
      "id": "b5f1572ad841c0ec0cd7471a56100e4e"
    },
    {
      "type": "code",
      "text": " (define (make-counter)\n  (let ((count 0))\n  (lambda ()\n    (set! count (+ count 1))\n    count)))",
      "id": "762bbd48f13c73d0f4dd153ef7c54773"
    },
    {
      "type": "html",
      "text": "\nWhat does this do? Well, every time you call (make-counter), it produces\na new counter procedure, like so:",
      "id": "37a20cfedd0f0c1bb5477df5a678605b"
    },
    {
      "type": "code",
      "text": " (define counter1 (make-counter))",
      "id": "0d7e589826374337db6214b063b5d1db"
    },
    {
      "type": "html",
      "text": "\nNow repeated calls to (counter1) will produce 1, 2, 3, etc... What happens\nis that the variable count (which is a local variable to the procedure make-counter) remains accessible by the counter procedure even after make-counter has\nterminated.",
      "id": "ed4e7411e6565a61c322c4ba284060e0"
    },
    {
      "type": "html",
      "text": "-- [[Stephan Houben]]",
      "id": "d50e43383464b4750dde7d52b42a8f58"
    },
    {
      "type": "html",
      "text": "---",
      "id": "4fbf1647022f56f3440e772386335850"
    },
    {
      "type": "html",
      "text": "\nAnd here's the same program in C# 2.0:",
      "id": "da3b8610fc44e83ed74d83e011f9ca59"
    },
    {
      "type": "code",
      "text": " static Function<int> makeCounter() {\n  int count = 0;\n  return delegate() { return ++count; }\n }",
      "id": "750b92c0e4b5d44b254182b1c3c01efa"
    },
    {
      "type": "code",
      "text": " Function<int> counter1 = makeCounter();\n Function<int> counter2 = makeCounter();\n Console.Write''''''Line(counter1()) // prints 1\n Console.Write''''''Line(counter1()) // prints 2\n Console.Write''''''Line(counter2()) // prints 1",
      "id": "8088c7dd0d2cccbefb645892942a4400"
    },
    {
      "type": "html",
      "text": "---\nSome may ask: what are closures <i>for</i>?  For a typical example, compare\nthe pain some languages have in getting a callback to occur.  You register\nsome specific function, or functor object, worry about who destroys it, etc.\nIn [[Common Lisp]], you register a [[Lexical Closure]] which closes over all the relevant\nstate and objects, and the callback occurs when the other thread funcalls\nthe closure.  Problem solved---no fuss, no muss.  Yet another <i>[one of the [[Benefits Of Dynamic Typing]]]</i>.  --[[Alain Picard]]",
      "id": "ed1c77dcaea699c30e1348bc7dd9b2ce"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0574aa9230fe392633c3719382651fa6"
    },
    {
      "type": "html",
      "text": "The preceding comment that closures are a benefit of dynamic typing seems to be incorrect. Take the first example on this page: it is written in [[Objective Caml]], which is a statically-typed language.",
      "id": "5bfae50dc3e66166a89a53832fed1564"
    },
    {
      "type": "html",
      "text": "<i>[[Lexical Closure]]s are clearly not a benefit of [[Dynamic Typing]], or even of [[Implicit Typing]], since it is possible to have closures without implicit or dynamic typing, and implicit or dynamic typing without closures.</i>",
      "id": "4410869645ae01a4a33b784c91f68b6b"
    },
    {
      "type": "html",
      "text": "<i>But like many other programming language features, they form a [[Cross Product]] with [[Implicit Typing]], which enhances their utility. In a implicitly typed setting, like that of either [[Common Lisp]] or [[Objective Caml]], a call to a function is correct if it merely gets the syntax right: all the required parameters are present, keyword parameters are paired up properly with the indicators and so on. There is no requirement (although it may be possible) to statically declare some function to have a given parameter type signature. If some subsystem of a program wants a one-argument callback, any old one-argument function will do, provided it doesn't try to misuse the object it is given. This means that you are not forced into writing dummy functions just for the sake of adapting to some manifestly typed interface so that your program compiles. It also means that if you are writing macros, your job is substantially easier, because you don't have to extract type information from the macro parameters in order to construct the right kind of closure.</i>",
      "id": "81901415333744f42a554eaf9aaddf96"
    },
    {
      "type": "html",
      "text": "<i>In implicitly typed languages with [[Type Inference]] (ML and friends, Haskell, etc.), there is the added guarantee that calling a closure won't fall over at runtime with a type mismatch error.</i>",
      "id": "bdae2dcbd6cb59baa74e1ab7ad2e9776"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0574aa9230fe392633c3719382651fa6"
    },
    {
      "type": "html",
      "text": "\nClosures are not the same as generators ([[Generator Closure]]), but they are closely related. Generators are a very easily implemented with closures, and a generator can be thought of a as a very limited kind of closure.",
      "id": "9b088f090d861c40e8056991d05305e3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0574aa9230fe392633c3719382651fa6"
    },
    {
      "type": "html",
      "text": "\nSee also: [[Functor Object]], [[Curried Functor]], [[Scope And Closures]], [[Blocks In Ruby]], [[Blocks In Java]], [[Closures And Objects Are Equivalent]], [[Dynamic Closure]]",
      "id": "5d94dde91220f296aaaa1e3cf447d2ea"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "0574aa9230fe392633c3719382651fa6"
    },
    {
      "type": "html",
      "text": "[[Category Functional Programming]] | [[Category Closure]] | [[Category Scheme]] | [[Category Lisp]] | [[Category Common Lisp]]",
      "id": "2d0b2ea409f4e562cef053f643b1e274"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?LexicalClosure c2.com]",
      "id": "1ec4dcc4babd6f2a63ae05015b2f3609"
    }
  ],
  "journal": [
    {
      "date": 1385152813000,
      "id": "083b0cfd76a2532a1cd0cb26fda545d8",
      "type": "create",
      "item": {
        "title": "Lexical Closure",
        "story": [
          {
            "type": "html",
            "text": "A [[Lexical Closure]], often referred to just as a <i>closure</i>, is a function that can refer to and alter the values of bindings established by binding forms that textually include the function definition.",
            "id": "136194a70717718fd9ced93e4ac993a3"
          },
          {
            "type": "html",
            "text": "\nBy 'binding', we mean the association of a name with a value. By 'binding forms', we mean the constructs that define bindings and their scope in the language. ",
            "id": "d94cabf685ac03215df150af8c54fc58"
          },
          {
            "type": "html",
            "text": "\nConsider the following example in [[Common Lisp]]:",
            "id": "d5c5c3f1816a1ff539c95a65b05db735"
          },
          {
            "type": "code",
            "text": " (defun two-funs (x)\n  (list (function (lambda () x))\n   (function (lambda (y) (setq x y)))))\n (setq funs1 (two-funs 6))\n (funcall (first funs1)) =>  6\n (funcall (second funs1) 43) =>  43\n (funcall (first funs1)) =>  43\n (setq funs2 (two-funs 5))\n (funcall (first funs2)) =>  5\n (funcall (second funs2) 13) =>  13\n (funcall (first funs2)) =>  13\n (funcall (first funs1)) =>  43",
            "id": "d72ecf1ff5eb08dcc4aee1cee093862a"
          },
          {
            "type": "html",
            "text": "\nEach time TWO-FUNS is called, each lambda expression is evaluated to produce a closure. The two closures are returned as a list of two elements. A different <i>lexical environment</i> is in effect each time, in which the name X is bound to a value. The two closures share the binding of X. However, each call to TWO-FUNS results in a <i>new</i> lexical environment, so that the binding of X used by the closures in FUNS1 is distinct from the bindings of X used by the closures in FUNS2.",
            "id": "6d9351ca198f7355ee720393ee5f7dcd"
          },
          {
            "type": "html",
            "text": "\nIn languages or situations in which the bindings are immutable, a closure acts as if the references to lexical bindings had been replaced by their values when the closure is created. However, as the example illustrates, the bindings can be changed in languages that have mutable variables.",
            "id": "ff5ab59c48d6c2cd58f821d8ea5ea1d9"
          },
          {
            "type": "html",
            "text": "\nThe concept of lexical closure is potentially relevant to any programming language that supports lexical binding scopes and the definition of functions within a resulting lexical environment.",
            "id": "efe5c1563a8e9254b62448bfa766b998"
          },
          {
            "type": "html",
            "text": "\nLexical closures are most interesting in, and are usually associated with, languages that can treat functions as data ([[First Class Function]]s), since storing a closure for later use implies an extension of the lifetime of the closed-over lexical environment beyond what one would normally expect. However, there are languages without first-class functions that allow for the definition of functions in lexical scopes (e.g. Pascal, Algol). These nested functions can be used only within that lexical scope, and thus the lifetime of lexical bindings are not extended in such languages. Although 'closures' in such languages are far less powerful as a way of organizing program, they still serve as a useful notational convenience.",
            "id": "e7bf3694c387a7f9735b0ad420bedac0"
          },
          {
            "type": "html",
            "text": "\nLanguages that support lexical closures include:",
            "id": "1ac53c19925b2c292c22a766f472f7b3"
          },
          {
            "type": "html",
            "text": " [[Common Lisp]]",
            "id": "aceeda7f451c6c3837ab246cdae1ceee"
          },
          {
            "type": "html",
            "text": " [[Scheme Language]]",
            "id": "5fcc1420072ec39ba7de6fed2fba9987"
          },
          {
            "type": "html",
            "text": " [[Ruby Language]]",
            "id": "e73aef92f16ab9a3dd45858024a3a437"
          },
          {
            "type": "html",
            "text": " [[Cee Sharp]] (version 2.0+)",
            "id": "eb9741e46844371c3c2bf83b9a1df8f7"
          },
          {
            "type": "html",
            "text": " [[Lua Language]]",
            "id": "ff482f2df26b064301b9b01da99ac2c2"
          },
          {
            "type": "html",
            "text": " [[Perl Language]]",
            "id": "f7b891ca4b3c9cf00d3ac62acaf96c7f"
          },
          {
            "type": "html",
            "text": " [[Php Language]] (version 5.3+)",
            "id": "2c5864e866d1e840502b47b922ef1381"
          },
          {
            "type": "html",
            "text": " [[Python Language]] (full support since version 3 by nonlocal-declaration; partial support before, see [http://web.archive.org/web/20070223143715/http://mail.python.org/pipermail/python-list/2004-July/270951.html web.archive.org])",
            "id": "3570d3205b9a3bbb138677583fc5d23b"
          },
          {
            "type": "html",
            "text": " [[Java Script]]",
            "id": "16be4d7dcf78b2fcfc7fdacbe6c8bed7"
          },
          {
            "type": "html",
            "text": " [[Smalltalk Language]]",
            "id": "9433b0a1289b4e51c071dd5edb0dc485"
          },
          {
            "type": "html",
            "text": " [[Pascal Language]] (no first-class functions)",
            "id": "d9d80e223bdd8959d42c8ffb9ae6d7c3"
          },
          {
            "type": "html",
            "text": " [[Algol Language]] (no first-class functions)",
            "id": "bdb6f2c8d89fcf5b4317d9e43827f162"
          },
          {
            "type": "html",
            "text": " [[Objective Cee]] (version 2.1+; available for Mac OS X 10.6+)",
            "id": "1d84d135b0ec59f5484e62295ae9a49d"
          },
          {
            "type": "html",
            "text": " [[Cee Language]] and [[Cee Plus Plus]] (with the open source Clang([[Cee Language Family Front End]])/LLVM ([[Low Level Virtual Machine]]) compiler; Apple has submitted the specification for consideration by the ANSI C Standards Committee)",
            "id": "487bf3db81263dc1aefb3c61dd2fe82e"
          },
          {
            "type": "html",
            "text": " C++11 ([[Cee Plus Plus Eleven]]) (Partial support with new C++ lambdas--the programmer chooses whether the lambda makes copies of the captured stack variables or only references them.  References will cause [[Undefined Behavior]] if the lambda escapes the scope it was created in.",
            "id": "e48fffb47ebccd586f564a380e71548f"
          },
          {
            "type": "html",
            "text": "\nIn [[Pascal Language]] and [[Algol Language]], a function can be passed as an argument to another function, but cannot be stored in a variable or data structure, cannot be returned from a function, and cannot be created without being given a name.  However, when a function is passed to another function and later called, it will execute in the lexical context it was defined in, so it is, in some sense, \"closed over\" that context.",
            "id": "869f74ea30788be243d7189af4c8198e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0574aa9230fe392633c3719382651fa6"
          },
          {
            "type": "html",
            "text": "Notes on the above definition:",
            "id": "5b4bb40988b9fcd20e4036c749eed4f5"
          },
          {
            "type": "html",
            "text": "\nI rewrote the definition that was here, because it was not as clear as it could have been regarding the mutability of bindings. The wikipedia entry for closures suffers from the same problem. I was recently involved in an online discussion with someone who had misunderstood this, and it appears that some of the developers working on C# at Microsoft may have, also. See [http://blogs.msdn.com/abhinaba/archive/2005/10/18/482180.aspx blogs.msdn.com] . Thus they seem to think that the anonymous methods in C# version 2.0 somehow differ from lexical closures.",
            "id": "64700336904868d4af7a4652fa164fcf"
          },
          {
            "type": "html",
            "text": "\nThe definition and example that I have given are adapted from the the Common Lisp standard specification; cf. [http://www.lisp.org/HyperSpec/Body/sec_3-1-4.html www.lisp.org]. It is my contention that in a language supporting mutable bindings (variables), a lexical closure must support mutability of the closed-over bindings. I tried to modify and expand the definition to make it language agnostic.",
            "id": "b350f549dbee19b9171313f45bbcb045"
          },
          {
            "type": "html",
            "text": "\nThe original definition follows. [[Delete When Cooked]]. Note that the reference to SICP is misleading; as far as I can tell, SICP does not refer to lexical closures by that name, although it may describe the concepts involved. Also, AFAICT, the Scheme standard document does not mention closures by name either.",
            "id": "3989bbaa88f24419d9168bf4a4dbb66e"
          },
          {
            "type": "html",
            "text": "\nI also tried to succinctly address some issues that were discussed later on this page. For instance, the last paragraph should make it clear that dynamic typing is not relevant to the definition of a lexical closure.",
            "id": "84f79949c1654ebe715debfbb821574a"
          },
          {
            "type": "html",
            "text": "\nIn response to someone's addition of Pascal and Algol to the language list, I added a paragraph about 'closures' in languages lacking first-class functions.",
            "id": "7f7804019192f4ced6ad4bf2f5dd6f47"
          },
          {
            "type": "html",
            "text": "\nSomeone else clarified that functions can be passed as parameters in Pascal and Algol. I didn't remember this feature (haven't used Pascal in many years, and never learned Algol). Thanks!",
            "id": "8a2cce1a6f41de9620fe90c4204cb60d"
          },
          {
            "type": "html",
            "text": "-- [[Dan Muller]]",
            "id": "29559f94666874a94686000b8e8641b7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0574aa9230fe392633c3719382651fa6"
          },
          {
            "type": "html",
            "text": "<i>Previous definition appearing on this page:</i>",
            "id": "ea203bda31836fe3a5edef18e4d7557d"
          },
          {
            "type": "html",
            "text": "\nA [[Lexical Closure]] is a function whose [[Free Variable]]s have been given values by an enclosing [[Lexical Scope]].",
            "id": "618406d0c85fbedcfef8b185627f62e6"
          },
          {
            "type": "html",
            "text": "\nLexical closures are typically (but not always) formed by defining a function inside another function, for example (in [[Scheme Language]]):",
            "id": "98eaab76bcb8b826035406b895756bac"
          },
          {
            "type": "code",
            "text": " (define (foo x)\n  (define (bar y)\n  (+ x y))\n  bar)",
            "id": "a6d9a48ac0e6a65ca1533335c6656743"
          },
          {
            "type": "html",
            "text": "Now calling (foo arg) returns a closure consisting of a) the code of 'bar', and b) an environment where x has the value of arg.",
            "id": "0536e5587c799d98f9244615d38a3797"
          },
          {
            "type": "code",
            "text": " (define bar1 (foo 1))\n (define bar2 (foo 2))",
            "id": "1da2936a2553bdac6ac3ef3dc0f1e610"
          },
          {
            "type": "code",
            "text": " (bar1 5) => 6\n (bar2 5) => 7",
            "id": "ec15c0298d5c4220fa5d3c5b07d60493"
          },
          {
            "type": "html",
            "text": "In proper closures, not just the value is kept, but a reference to the actual object passed in. See the body of this page for a full explanation. As you may have noticed, lexical closures are necessary for [[Currying Schonfinkelling]].",
            "id": "0a533b556e6bb80be72d26fca9b8cd92"
          },
          {
            "type": "html",
            "text": "\nThose who are really interested in this should read [[Structure And Interpretation Of Computer Programs]]. ",
            "id": "6b6ba007b3d70ada085ae9261ef424f7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0574aa9230fe392633c3719382651fa6"
          },
          {
            "type": "html",
            "text": "[[Objective Caml]] example, where an enclosing 'let' is used rather than an enlcosing function:",
            "id": "e5c12d5594a26ae2f746626af13f51ee"
          },
          {
            "type": "code",
            "text": " let produce_counter_from initval =\n  let value = ref initval in\n  fun () -> incr value; (!value, initval);;",
            "id": "c9fc056749a190066d3365a765ca2882"
          },
          {
            "type": "code",
            "text": " let mycount = produce_counter_from 3;;\n mycount ();; (* produces (4, 3) *)\n mycount ();; (* produces (5, 3) *)",
            "id": "8fafa266d242bfc7b470d43df9523be5"
          },
          {
            "type": "html",
            "text": "\nThe anonymous function defined by 'fun () -> ...' remembers the names <b>value</b> and <b>initval</b>, which are bound in the surrounding scopes defined by the two 'let's. These names are accessible to it even after the call to produce_counter_from has finished.",
            "id": "b6917aca9318b0af7d2d3a67cb561f74"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0574aa9230fe392633c3719382651fa6"
          },
          {
            "type": "html",
            "text": "Note that although [[Anonymous Function]]s are often used to create closures, they are not necessary. [[Named Function]]s work equally well.",
            "id": "75c44893dcba92a166a219ffa075e334"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0574aa9230fe392633c3719382651fa6"
          },
          {
            "type": "html",
            "text": "A lexical closure is called just like an ordinary function. When this happens, the code of the closure is executed, and the references to the 'captured' [[Lexical Variable]]s just work. For this, the captured lexicals must be saved somehow, in an object that persists as long as the closure exists. This means the lexical variables can't be stored in an ordinary stack frame that expires when the execution of the outer [[Lexical Scope]] is finished.",
            "id": "7410ad477025bb559aa467b71ba89a22"
          },
          {
            "type": "html",
            "text": "\nThe closure has internal variables too, such as the parameters of its anonymous function, or local variables defined within the body of that function. These are the closure's <i>bound</i> variables, and are not included in the closure object, because their bindings are established whenever the closure is called. The captured variables from the surrounding environments are called <i>free</i> variables (that is, free with respect to the function because they are not bound within it but have to be \"reached\" for in the lexical environment). It's useful to know this <i>free variable</i> terminology because it's somewhat counter-intuitive, yet used quite a bit in the literature.",
            "id": "968288ba5574cfaae7b1bf1e2fb842fe"
          },
          {
            "type": "html",
            "text": "\nA [[Common Lisp]] example is useful, because the syntax is fairly obvious even to non-Lisp programmers, thanks to the parentheses that denote the tree structure without ambiguity.",
            "id": "2a184940bd25c7a62984d4b180c77150"
          },
          {
            "type": "code",
            "text": "  (defun make-counter (initial-value) ; initial-value is the variable we will capture in our anonymous function\n  (lambda ()      ; We'll make a closure that takes no parameters\n  (incf initial-value))))   ; This is equivalent to '++initial-value' in C",
            "id": "d2865d14cc23218aceaf8811f2b3b61a"
          },
          {
            "type": "html",
            "text": "\nThe result of the 'lambda' expression (a closure) is returned as the result of 'make-counter'.",
            "id": "800362dcb0d6736e2ea3450b0562b77d"
          },
          {
            "type": "code",
            "text": "  (defvar *closure-one* (make-counter 10))\n  (defvar *closure-two* (make-counter 100))",
            "id": "3cdab692dcfede44a1a4412b5c1c30a2"
          },
          {
            "type": "code",
            "text": "  (funcall *closure-one*) ;; --> 11\n  (funcall *closure-two*) ;; --> 101\n  (funcall *closure-one*) ;; --> 12\n  (funcall *closure-one*) ;; --> 13\n  (funcall *closure-two*) ;; --> 102",
            "id": "0c0dc9df64c56d4265c93efea8214690"
          },
          {
            "type": "html",
            "text": "\nAs you can see, two closure objects were made, <b>each capturing a distinct binding of the INITIAL-VALUE variable,</b> giving rise to two independent counting sessions. Note how the closures can continue to access INITIAL-VALUE, even though it's the parameter of a function call that has terminated.",
            "id": "4177ea2724abd29a32b4f09ad26b7000"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0574aa9230fe392633c3719382651fa6"
          },
          {
            "type": "html",
            "text": "Here is a similar example from [[Scheme Language]]. The goal is to create a counter.",
            "id": "b5f1572ad841c0ec0cd7471a56100e4e"
          },
          {
            "type": "code",
            "text": " (define (make-counter)\n  (let ((count 0))\n  (lambda ()\n    (set! count (+ count 1))\n    count)))",
            "id": "762bbd48f13c73d0f4dd153ef7c54773"
          },
          {
            "type": "html",
            "text": "\nWhat does this do? Well, every time you call (make-counter), it produces\na new counter procedure, like so:",
            "id": "37a20cfedd0f0c1bb5477df5a678605b"
          },
          {
            "type": "code",
            "text": " (define counter1 (make-counter))",
            "id": "0d7e589826374337db6214b063b5d1db"
          },
          {
            "type": "html",
            "text": "\nNow repeated calls to (counter1) will produce 1, 2, 3, etc... What happens\nis that the variable count (which is a local variable to the procedure make-counter) remains accessible by the counter procedure even after make-counter has\nterminated.",
            "id": "ed4e7411e6565a61c322c4ba284060e0"
          },
          {
            "type": "html",
            "text": "-- [[Stephan Houben]]",
            "id": "d50e43383464b4750dde7d52b42a8f58"
          },
          {
            "type": "html",
            "text": "---",
            "id": "4fbf1647022f56f3440e772386335850"
          },
          {
            "type": "html",
            "text": "\nAnd here's the same program in C# 2.0:",
            "id": "da3b8610fc44e83ed74d83e011f9ca59"
          },
          {
            "type": "code",
            "text": " static Function<int> makeCounter() {\n  int count = 0;\n  return delegate() { return ++count; }\n }",
            "id": "750b92c0e4b5d44b254182b1c3c01efa"
          },
          {
            "type": "code",
            "text": " Function<int> counter1 = makeCounter();\n Function<int> counter2 = makeCounter();\n Console.Write''''''Line(counter1()) // prints 1\n Console.Write''''''Line(counter1()) // prints 2\n Console.Write''''''Line(counter2()) // prints 1",
            "id": "8088c7dd0d2cccbefb645892942a4400"
          },
          {
            "type": "html",
            "text": "---\nSome may ask: what are closures <i>for</i>?  For a typical example, compare\nthe pain some languages have in getting a callback to occur.  You register\nsome specific function, or functor object, worry about who destroys it, etc.\nIn [[Common Lisp]], you register a [[Lexical Closure]] which closes over all the relevant\nstate and objects, and the callback occurs when the other thread funcalls\nthe closure.  Problem solved---no fuss, no muss.  Yet another <i>[one of the [[Benefits Of Dynamic Typing]]]</i>.  --[[Alain Picard]]",
            "id": "ed1c77dcaea699c30e1348bc7dd9b2ce"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0574aa9230fe392633c3719382651fa6"
          },
          {
            "type": "html",
            "text": "The preceding comment that closures are a benefit of dynamic typing seems to be incorrect. Take the first example on this page: it is written in [[Objective Caml]], which is a statically-typed language.",
            "id": "5bfae50dc3e66166a89a53832fed1564"
          },
          {
            "type": "html",
            "text": "<i>[[Lexical Closure]]s are clearly not a benefit of [[Dynamic Typing]], or even of [[Implicit Typing]], since it is possible to have closures without implicit or dynamic typing, and implicit or dynamic typing without closures.</i>",
            "id": "4410869645ae01a4a33b784c91f68b6b"
          },
          {
            "type": "html",
            "text": "<i>But like many other programming language features, they form a [[Cross Product]] with [[Implicit Typing]], which enhances their utility. In a implicitly typed setting, like that of either [[Common Lisp]] or [[Objective Caml]], a call to a function is correct if it merely gets the syntax right: all the required parameters are present, keyword parameters are paired up properly with the indicators and so on. There is no requirement (although it may be possible) to statically declare some function to have a given parameter type signature. If some subsystem of a program wants a one-argument callback, any old one-argument function will do, provided it doesn't try to misuse the object it is given. This means that you are not forced into writing dummy functions just for the sake of adapting to some manifestly typed interface so that your program compiles. It also means that if you are writing macros, your job is substantially easier, because you don't have to extract type information from the macro parameters in order to construct the right kind of closure.</i>",
            "id": "81901415333744f42a554eaf9aaddf96"
          },
          {
            "type": "html",
            "text": "<i>In implicitly typed languages with [[Type Inference]] (ML and friends, Haskell, etc.), there is the added guarantee that calling a closure won't fall over at runtime with a type mismatch error.</i>",
            "id": "bdae2dcbd6cb59baa74e1ab7ad2e9776"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0574aa9230fe392633c3719382651fa6"
          },
          {
            "type": "html",
            "text": "\nClosures are not the same as generators ([[Generator Closure]]), but they are closely related. Generators are a very easily implemented with closures, and a generator can be thought of a as a very limited kind of closure.",
            "id": "9b088f090d861c40e8056991d05305e3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0574aa9230fe392633c3719382651fa6"
          },
          {
            "type": "html",
            "text": "\nSee also: [[Functor Object]], [[Curried Functor]], [[Scope And Closures]], [[Blocks In Ruby]], [[Blocks In Java]], [[Closures And Objects Are Equivalent]], [[Dynamic Closure]]",
            "id": "5d94dde91220f296aaaa1e3cf447d2ea"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "0574aa9230fe392633c3719382651fa6"
          },
          {
            "type": "html",
            "text": "[[Category Functional Programming]] | [[Category Closure]] | [[Category Scheme]] | [[Category Lisp]] | [[Category Common Lisp]]",
            "id": "2d0b2ea409f4e562cef053f643b1e274"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?LexicalClosure c2.com]",
            "id": "1ec4dcc4babd6f2a63ae05015b2f3609"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1674055812527
    }
  ]
}