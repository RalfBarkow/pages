{
  "title": "Finding Expression",
  "story": [
    {
      "type": "paragraph",
      "id": "5570ed7b5b718fd0",
      "text": "McCarthy originally proposed using M-expressions but  programmers found S-expressions more valuable. "
    },
    {
      "type": "pagefold",
      "id": "381c4b6f3e01c61f",
      "text": "wikipedia"
    },
    {
      "type": "paragraph",
      "id": "2165080b1b61e019",
      "text": "John McCarthy began developing Lisp in 1958 while he was at the Massachusetts Institute of Technology (MIT). McCarthy published its design in a paper in Communications of the ACM in April 1960, entitled \"Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I\".  He showed that with a few simple operators and a notation for anonymous functions borrowed from Church, one can build a Turing-complete language for algorithms.\n\nInformation Processing Language was the first AI language, from 1955 or 1956, and already included many of the concepts, such as list-processing and recursion, which came to be used in Lisp.\n\nMcCarthy's original notation used bracketed \"M-expressions\" that would be translated into S-expressions. As an example, the M-expression car[cons[A,B]] is equivalent to the S-expression (car (cons A B)). Once Lisp was implemented, programmers rapidly chose to use S-expressions, and M-expressions were abandoned. M-expressions surfaced again with short-lived attempts of MLisp by Horace Enea and CGOL by Vaughan Pratt.\n\nLisp was first implemented by Steve Russell on an IBM 704 computer using punched cards. Russell had read McCarthy's paper and realized (to McCarthy's surprise) that the Lisp eval function could be implemented in machine code. "
    },
    {
      "type": "paragraph",
      "id": "a578c709a00fe0f6",
      "text": "[https://en.wikipedia.org/wiki/Lisp_(programming_language) wikipedia]"
    },
    {
      "type": "pagefold",
      "id": "1968605f9f5e4a0a",
      "text": "chat.openai"
    },
    {
      "type": "paragraph",
      "id": "9e3d5a950f5c8721",
      "text": "Lisp uses S-expressions and not M-expressions because S-expressions are simpler and more flexible, making them easier to parse and manipulate.\n\nS-expressions, which stands for Symbolic Expressions, are a simple syntax consisting of nested lists of symbols and other S-expressions. This syntax is easy to read and write, and it allows for the manipulation of code as data, which is a powerful feature of Lisp. In addition, S-expressions can be easily parsed using recursive algorithms, which allows for powerful metaprogramming capabilities, such as macros.\n\nM-expressions, on the other hand, are a more complex syntax that was proposed as an alternative to S-expressions. M-expressions use prefix notation with a special character to indicate the start and end of an expression. While M-expressions are more expressive than S-expressions, they are also more difficult to parse and manipulate, which limits their flexibility and metaprogramming capabilities.\n\nOverall, the simplicity and flexibility of S-expressions made them a more practical and powerful choice for the development of Lisp. S-expressions allowed Lisp to become a powerful language for metaprogramming and functional programming, and they have influenced the development of many other programming languages, including Scheme, Clojure, and Racket."
    },
    {
      "type": "pagefold",
      "id": "bdc723c08f60d1b4",
      "text": "wondering"
    },
    {
      "type": "paragraph",
      "id": "801698d1005203c3",
      "text": "As we explore a fundamental distinction of these expressions, that of space introduced, we become curious about the emergent potential of [[Whitespace]], [[The Space Between]]."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Finding Expression",
        "story": []
      },
      "date": 1676566089866
    },
    {
      "item": {
        "type": "factory",
        "id": "5570ed7b5b718fd0"
      },
      "id": "5570ed7b5b718fd0",
      "type": "add",
      "date": 1676566091292
    },
    {
      "type": "edit",
      "id": "5570ed7b5b718fd0",
      "item": {
        "type": "paragraph",
        "id": "5570ed7b5b718fd0",
        "text": "McCarthy originally proposed using M"
      },
      "date": 1676566107641
    },
    {
      "type": "add",
      "id": "1968605f9f5e4a0a",
      "item": {
        "type": "factory",
        "id": "1968605f9f5e4a0a",
        "text": "chat.opena "
      },
      "after": "5570ed7b5b718fd0",
      "date": 1676566119678
    },
    {
      "type": "edit",
      "id": "1968605f9f5e4a0a",
      "item": {
        "type": "pagefold",
        "id": "1968605f9f5e4a0a",
        "text": "chat.openai"
      },
      "date": 1676566125501
    },
    {
      "item": {
        "type": "factory",
        "id": "9e3d5a950f5c8721"
      },
      "id": "9e3d5a950f5c8721",
      "type": "add",
      "after": "1968605f9f5e4a0a",
      "date": 1676566127008
    },
    {
      "type": "edit",
      "id": "9e3d5a950f5c8721",
      "item": {
        "type": "paragraph",
        "id": "9e3d5a950f5c8721",
        "text": "Lisp uses S-expressions and not M-expressions because S-expressions are simpler and more flexible, making them easier to parse and manipulate.\n\nS-expressions, which stands for Symbolic Expressions, are a simple syntax consisting of nested lists of symbols and other S-expressions. This syntax is easy to read and write, and it allows for the manipulation of code as data, which is a powerful feature of Lisp. In addition, S-expressions can be easily parsed using recursive algorithms, which allows for powerful metaprogramming capabilities, such as macros.\n\nM-expressions, on the other hand, are a more complex syntax that was proposed as an alternative to S-expressions. M-expressions use prefix notation with a special character to indicate the start and end of an expression. While M-expressions are more expressive than S-expressions, they are also more difficult to parse and manipulate, which limits their flexibility and metaprogramming capabilities.\n\nOverall, the simplicity and flexibility of S-expressions made them a more practical and powerful choice for the development of Lisp. S-expressions allowed Lisp to become a powerful language for metaprogramming and functional programming, and they have influenced the development of many other programming languages, including Scheme, Clojure, and Racket."
      },
      "date": 1676566129601
    },
    {
      "type": "add",
      "id": "2165080b1b61e019",
      "item": {
        "type": "paragraph",
        "id": "2165080b1b61e019",
        "text": "John McCarthy began developing Lisp in 1958 while he was at the Massachusetts Institute of Technology (MIT). McCarthy published its design in a paper in Communications of the ACM in April 1960, entitled \"Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I\".[14] He showed that with a few simple operators and a notation for anonymous functions borrowed from Church, one can build a Turing-complete language for algorithms.\n\nInformation Processing Language was the first AI language, from 1955 or 1956, and already included many of the concepts, such as list-processing and recursion, which came to be used in Lisp.\n\nMcCarthy's original notation used bracketed \"M-expressions\" that would be translated into S-expressions. As an example, the M-expression car[cons[A,B]] is equivalent to the S-expression (car (cons A B)). Once Lisp was implemented, programmers rapidly chose to use S-expressions, and M-expressions were abandoned. M-expressions surfaced again with short-lived attempts of MLisp[15] by Horace Enea and CGOL by Vaughan Pratt.\n\nLisp was first implemented by Steve Russell on an IBM 704 computer using punched cards.[16] Russell had read McCarthy's paper and realized (to McCarthy's surprise) that the Lisp eval function could be implemented in machine code."
      },
      "after": "5570ed7b5b718fd0",
      "date": 1676566187870
    },
    {
      "item": {
        "type": "factory",
        "id": "381c4b6f3e01c61f"
      },
      "id": "381c4b6f3e01c61f",
      "type": "add",
      "after": "9e3d5a950f5c8721",
      "date": 1676566192793
    },
    {
      "type": "edit",
      "id": "381c4b6f3e01c61f",
      "item": {
        "type": "pagefold",
        "id": "381c4b6f3e01c61f",
        "text": "wikipedia"
      },
      "date": 1676566198240
    },
    {
      "id": "381c4b6f3e01c61f",
      "type": "move",
      "order": [
        "5570ed7b5b718fd0",
        "381c4b6f3e01c61f",
        "2165080b1b61e019",
        "1968605f9f5e4a0a",
        "9e3d5a950f5c8721"
      ],
      "date": 1676566202575
    },
    {
      "type": "edit",
      "id": "2165080b1b61e019",
      "item": {
        "type": "paragraph",
        "id": "2165080b1b61e019",
        "text": "John McCarthy began developing Lisp in 1958 while he was at the Massachusetts Institute of Technology (MIT). McCarthy published its design in a paper in Communications of the ACM in April 1960, entitled \"Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I\".  He showed that with a few simple operators and a notation for anonymous functions borrowed from Church, one can build a Turing-complete language for algorithms.\n\nInformation Processing Language was the first AI language, from 1955 or 1956, and already included many of the concepts, such as list-processing and recursion, which came to be used in Lisp.\n\nMcCarthy's original notation used bracketed \"M-expressions\" that would be translated into S-expressions. As an example, the M-expression car[cons[A,B]] is equivalent to the S-expression (car (cons A B)). Once Lisp was implemented, programmers rapidly chose to use S-expressions, and M-expressions were abandoned. M-expressions surfaced again with short-lived attempts of MLisp by Horace Enea and CGOL by Vaughan Pratt.\n\nLisp was first implemented by Steve Russell on an IBM 704 computer using punched cards. Russell had read McCarthy's paper and realized (to McCarthy's surprise) that the Lisp eval function could be implemented in machine code."
      },
      "date": 1676566244976
    },
    {
      "type": "edit",
      "id": "5570ed7b5b718fd0",
      "item": {
        "type": "paragraph",
        "id": "5570ed7b5b718fd0",
        "text": "McCarthy originally proposed using M-expressions but  programmers found S-expressions more valuable. "
      },
      "date": 1676566290058
    },
    {
      "type": "edit",
      "id": "2165080b1b61e019",
      "item": {
        "type": "paragraph",
        "id": "2165080b1b61e019",
        "text": "John McCarthy began developing Lisp in 1958 while he was at the Massachusetts Institute of Technology (MIT). McCarthy published its design in a paper in Communications of the ACM in April 1960, entitled \"Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I\".  He showed that with a few simple operators and a notation for anonymous functions borrowed from Church, one can build a Turing-complete language for algorithms.\n\nInformation Processing Language was the first AI language, from 1955 or 1956, and already included many of the concepts, such as list-processing and recursion, which came to be used in Lisp.\n\nMcCarthy's original notation used bracketed \"M-expressions\" that would be translated into S-expressions. As an example, the M-expression car[cons[A,B]] is equivalent to the S-expression (car (cons A B)). Once Lisp was implemented, programmers rapidly chose to use S-expressions, and M-expressions were abandoned. M-expressions surfaced again with short-lived attempts of MLisp by Horace Enea and CGOL by Vaughan Pratt.\n\nLisp was first implemented by Steve Russell on an IBM 704 computer using punched cards. Russell had read McCarthy's paper and realized (to McCarthy's surprise) that the Lisp eval function could be implemented in machine code. [https://en.wikipedia.org/wiki/Lisp_(programming_language) Wikipedia]"
      },
      "date": 1676566325857
    },
    {
      "type": "edit",
      "id": "2165080b1b61e019",
      "item": {
        "type": "paragraph",
        "id": "2165080b1b61e019",
        "text": "John McCarthy began developing Lisp in 1958 while he was at the Massachusetts Institute of Technology (MIT). McCarthy published its design in a paper in Communications of the ACM in April 1960, entitled \"Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I\".  He showed that with a few simple operators and a notation for anonymous functions borrowed from Church, one can build a Turing-complete language for algorithms.\n\nInformation Processing Language was the first AI language, from 1955 or 1956, and already included many of the concepts, such as list-processing and recursion, which came to be used in Lisp.\n\nMcCarthy's original notation used bracketed \"M-expressions\" that would be translated into S-expressions. As an example, the M-expression car[cons[A,B]] is equivalent to the S-expression (car (cons A B)). Once Lisp was implemented, programmers rapidly chose to use S-expressions, and M-expressions were abandoned. M-expressions surfaced again with short-lived attempts of MLisp by Horace Enea and CGOL by Vaughan Pratt.\n\nLisp was first implemented by Steve Russell on an IBM 704 computer using punched cards. Russell had read McCarthy's paper and realized (to McCarthy's surprise) that the Lisp eval function could be implemented in machine code. "
      },
      "date": 1676566334296
    },
    {
      "type": "add",
      "id": "a578c709a00fe0f6",
      "item": {
        "type": "paragraph",
        "id": "a578c709a00fe0f6",
        "text": "[https://en.wikipedia.org/wiki/Lisp_(programming_language) wikipedia]"
      },
      "after": "2165080b1b61e019",
      "date": 1676566335238
    },
    {
      "item": {
        "type": "factory",
        "id": "bdc723c08f60d1b4"
      },
      "id": "bdc723c08f60d1b4",
      "type": "add",
      "after": "9e3d5a950f5c8721",
      "date": 1676566428609
    },
    {
      "type": "edit",
      "id": "bdc723c08f60d1b4",
      "item": {
        "type": "pagefold",
        "id": "bdc723c08f60d1b4",
        "text": "wondering"
      },
      "date": 1676566433998
    },
    {
      "item": {
        "type": "factory",
        "id": "801698d1005203c3"
      },
      "id": "801698d1005203c3",
      "type": "add",
      "after": "bdc723c08f60d1b4",
      "date": 1676566437791
    },
    {
      "type": "edit",
      "id": "801698d1005203c3",
      "item": {
        "type": "paragraph",
        "id": "801698d1005203c3",
        "text": "[[The Space Between]]"
      },
      "date": 1676566446290
    },
    {
      "type": "edit",
      "id": "801698d1005203c3",
      "item": {
        "type": "paragraph",
        "id": "801698d1005203c3",
        "text": "We are curious about the emergent potential of whitespace, [[The Space Between]]."
      },
      "date": 1676566488854
    },
    {
      "type": "edit",
      "id": "801698d1005203c3",
      "item": {
        "type": "paragraph",
        "id": "801698d1005203c3",
        "text": "As we explore a fundamental distinction of these expressions, that of space introduced, we become curious about the emergent potential of whitespace, [[The Space Between]]."
      },
      "date": 1676566597016
    },
    {
      "type": "edit",
      "id": "801698d1005203c3",
      "item": {
        "type": "paragraph",
        "id": "801698d1005203c3",
        "text": "As we explore a fundamental distinction of these expressions, that of space introduced, we become curious about the emergent potential of [[Whitespace]], [[The Space Between]]."
      },
      "date": 1676566612667
    },
    {
      "type": "fork",
      "site": "thompson.fed.wiki",
      "date": 1676670290162
    }
  ]
}