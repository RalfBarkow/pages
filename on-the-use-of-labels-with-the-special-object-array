{
  "title": "On the Use of Labels with the Special Object Array",
  "story": [
    {
      "type": "markdown",
      "id": "55f9e7cee2d18fd7",
      "text": "One of the first things stored in Smalltalk images is a small array of special objects, which usually contains references to objects like `Smalltalk`, `nil`, `true` and `false`. Why is it necessary to give special treatment to these things, and what does this special treatment imply?"
    },
    {
      "type": "markdown",
      "id": "e04624d461be1376",
      "text": "Consider the implementation of the message `==`. This message is implemented as a primitive, and as such the actual work is performed by the virtual machine running the image. Essentially, what it will do is to see if the argument and the receiver are not just equal, but exactly and identically the same object. Whatever the objects involved are, after the comparison is done the virtual machine will have to answer either `true` or `false`. Why these objects and not anything else? Because the rest of the code in the image is written in a way that requires one of these to be answered by the primitive. And how does the virtual machine know the objects `true` and `false`? By looking them up in the special object array.\n"
    },
    {
      "type": "markdown",
      "id": "b808c2b6af0aaa51",
      "text": "Of course, one could have the virtual machine behave more like C and answer 1 or 0 instead. And in fact one could have it do so, because the virtual machine itself does not care. Therefore, the fact that the virtual machine answers `true` or `false` is the result of some arbitrary choice. As such, we can separate the act of answering two different things (the actual answer) from the actual things being answered (how the answer is labelled for our convenience).\n\n\n"
    },
    {
      "type": "markdown",
      "id": "3603862e00b29d41",
      "text": "But then, if the actual answer could be whatever pair of distinct objects we want, we can also see that the meaning of these objects is not given by their name (`true`, `false`, `0`, `1`), not even by their identity. Rather, they become meaningful because of their location in the network of message paths. If we replace `true` and `false` by `0` and `1`, the image would still work if what is expected from booleans is satisfied by their replacements."
    },
    {
      "type": "paragraph",
      "id": "1804cf985ba0de36",
      "text": "This is an excellent opportunity to remind ourselves to avoid confusing the labels with the labelled objects. It is perfectly fine to refer to distinctions by means of names, as long as we always keep in mind that a name is something we assign according to our intentions. But labels are not the labelled objects."
    },
    {
      "type": "paragraph",
      "id": "95569afb2239a142",
      "text": "⇒ [[Large Systems]]"
    },
    {
      "type": "pagefold",
      "id": "79abf75a280c8322",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "7db33b4a0bde38ba",
      "text": "Section 1.2.6 of [[A Mentoring Course on Smalltalk]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "On the Use of Labels with the Special Object Array",
        "story": []
      },
      "date": 1660202371537
    },
    {
      "item": {
        "type": "paragraph",
        "id": "55f9e7cee2d18fd7",
        "text": "One of the first things stored in Smalltalk images is a small array of special objects, which usually contains references to objects like Smalltalk, nil, true and false. Why is it necessary to give special treatment to these things, and what does this special treatment imply?"
      },
      "id": "55f9e7cee2d18fd7",
      "type": "add",
      "date": 1660202391922
    },
    {
      "type": "edit",
      "id": "55f9e7cee2d18fd7",
      "item": {
        "type": "paragraph",
        "id": "55f9e7cee2d18fd7",
        "text": "One of the first things stored in Smalltalk images is a small array of special objects, which usually contains references to objects like Smalltalk, nil, true and false. Why is it necessary to give special treatment to these things, and what does this special treatment imply?"
      },
      "date": 1660202395246,
      "error": {
        "type": "error",
        "msg": ""
      }
    },
    {
      "type": "fork",
      "date": 1660202398795
    },
    {
      "type": "edit",
      "id": "55f9e7cee2d18fd7",
      "item": {
        "type": "paragraph",
        "id": "55f9e7cee2d18fd7",
        "text": "One of the first things stored in Smalltalk images is a small array of special objects, which usually contains references to objects like `Smalltalk`, `nil`, `true` and `false`. Why is it necessary to give special treatment to these things, and what does this special treatment imply?"
      },
      "date": 1660202427067
    },
    {
      "type": "edit",
      "id": "55f9e7cee2d18fd7",
      "item": {
        "type": "markdown",
        "id": "55f9e7cee2d18fd7",
        "text": "One of the first things stored in Smalltalk images is a small array of special objects, which usually contains references to objects like `Smalltalk`, `nil`, `true` and `false`. Why is it necessary to give special treatment to these things, and what does this special treatment imply?"
      },
      "date": 1660202429204
    },
    {
      "item": {
        "type": "factory",
        "id": "e04624d461be1376"
      },
      "id": "e04624d461be1376",
      "type": "add",
      "after": "55f9e7cee2d18fd7",
      "date": 1660202460134
    },
    {
      "type": "edit",
      "id": "e04624d461be1376",
      "item": {
        "type": "paragraph",
        "id": "e04624d461be1376",
        "text": "Consider the implementation of the message ==. This message is implemented as a primitive, and as such the actual work is performed by the virtual machine running the image. Essentially, what it will do is to see if the argument and the receiver are not just equal, but exactly and identically the same object. Whatever the objects involved are, after the comparison is done the virtual machine will have to answer either true or false. Why these objects and not anything else? Because the rest of the code in the image is written in a way that requires one of these to be answered by the primitive. And how does the virtual machine know the objects true and false? By looking them up in the special object array."
      },
      "date": 1660202464128
    },
    {
      "type": "add",
      "id": "1804cf985ba0de36",
      "item": {
        "type": "paragraph",
        "id": "1804cf985ba0de36",
        "text": "[…]"
      },
      "after": "e04624d461be1376",
      "date": 1660202466142
    },
    {
      "type": "edit",
      "id": "e04624d461be1376",
      "item": {
        "type": "paragraph",
        "id": "e04624d461be1376",
        "text": "Consider the implementation of the message `==`. This message is implemented as a primitive, and as such the actual work is performed by the virtual machine running the image. Essentially, what it will do is to see if the argument and the receiver are not just equal, but exactly and identically the same object. Whatever the objects involved are, after the comparison is done the virtual machine will have to answer either true or false. Why these objects and not anything else? Because the rest of the code in the image is written in a way that requires one of these to be answered by the primitive. And how does the virtual machine know the objects true and false? By looking them up in the special object array."
      },
      "date": 1660202559001
    },
    {
      "type": "edit",
      "id": "e04624d461be1376",
      "item": {
        "type": "markdown",
        "id": "e04624d461be1376",
        "text": "Consider the implementation of the message `==`. This message is implemented as a primitive, and as such the actual work is performed by the virtual machine running the image. Essentially, what it will do is to see if the argument and the receiver are not just equal, but exactly and identically the same object. Whatever the objects involved are, after the comparison is done the virtual machine will have to answer either true or false. Why these objects and not anything else? Because the rest of the code in the image is written in a way that requires one of these to be answered by the primitive. And how does the virtual machine know the objects true and false? By looking them up in the special object array."
      },
      "date": 1660202560314
    },
    {
      "type": "edit",
      "id": "e04624d461be1376",
      "item": {
        "type": "markdown",
        "id": "e04624d461be1376",
        "text": "Consider the implementation of the message `==`. This message is implemented as a primitive, and as such the actual work is performed by the virtual machine running the image. Essentially, what it will do is to see if the argument and the receiver are not just equal, but exactly and identically the same object. Whatever the objects involved are, after the comparison is done the virtual machine will have to answer either `true` or `false`. Why these objects and not anything else? Because the rest of the code in the image is written in a way that requires one of these to be answered by the primitive. And how does the virtual machine know the objects true and false? By looking them up in the special object array."
      },
      "date": 1660202593018
    },
    {
      "type": "edit",
      "id": "e04624d461be1376",
      "item": {
        "type": "markdown",
        "id": "e04624d461be1376",
        "text": "Consider the implementation of the message `==`. This message is implemented as a primitive, and as such the actual work is performed by the virtual machine running the image. Essentially, what it will do is to see if the argument and the receiver are not just equal, but exactly and identically the same object. Whatever the objects involved are, after the comparison is done the virtual machine will have to answer either `true` or `false`. Why these objects and not anything else? Because the rest of the code in the image is written in a way that requires one of these to be answered by the primitive. And how does the virtual machine know the objects `true` and `false`? By looking them up in the special object array."
      },
      "date": 1660202628669
    },
    {
      "type": "edit",
      "id": "e04624d461be1376",
      "item": {
        "type": "markdown",
        "id": "e04624d461be1376",
        "text": "Consider the implementation of the message `==`. This message is implemented as a primitive, and as such the actual work is performed by the virtual machine running the image. Essentially, what it will do is to see if the argument and the receiver are not just equal, but exactly and identically the same object. Whatever the objects involved are, after the comparison is done the virtual machine will have to answer either `true` or `false`. Why these objects and not anything else? Because the rest of the code in the image is written in a way that requires one of these to be answered by the primitive. And how does the virtual machine know the objects `true` and `false`? By looking them up in the special object array.\n"
      },
      "date": 1660202672406
    },
    {
      "type": "add",
      "id": "b808c2b6af0aaa51",
      "item": {
        "type": "markdown",
        "id": "b808c2b6af0aaa51",
        "text": "Of course, one could have the virtual machine behave more like C and answer 1 or 0 instead. And in fact one could have it do so, because the virtual machine itself does not care. Therefore, the fact that the virtual machine answers true or false is the result of some arbitrary choice. As such, we can separate the act of answering two different things (the actual answer) from the actual things being answered (how the answer is labelled for our convenience)."
      },
      "after": "e04624d461be1376",
      "date": 1660202673128
    },
    {
      "type": "edit",
      "id": "b808c2b6af0aaa51",
      "item": {
        "type": "markdown",
        "id": "b808c2b6af0aaa51",
        "text": "Of course, one could have the virtual machine behave more like C and answer 1 or 0 instead. And in fact one could have it do so, because the virtual machine itself does not care. Therefore, the fact that the virtual machine answers `true` or `false` is the result of some arbitrary choice. As such, we can separate the act of answering two different things (the actual answer) from the actual things being answered (how the answer is labelled for our convenience)."
      },
      "date": 1660202698828
    },
    {
      "type": "edit",
      "id": "b808c2b6af0aaa51",
      "item": {
        "type": "markdown",
        "id": "b808c2b6af0aaa51",
        "text": "Of course, one could have the virtual machine behave more like C and answer 1 or 0 instead. And in fact one could have it do so, because the virtual machine itself does not care. Therefore, the fact that the virtual machine answers `true` or `false` is the result of some arbitrary choice. As such, we can separate the act of answering two different things (the actual answer) from the actual things being answered (how the answer is labelled for our convenience).\n\n\n"
      },
      "date": 1660202733634
    },
    {
      "type": "add",
      "id": "3603862e00b29d41",
      "item": {
        "type": "markdown",
        "id": "3603862e00b29d41",
        "text": "But then, if the actual answer could be whatever pair of distinct objects we want, we can also see that the meaning of these objects is not given by their name (true, false, 0, 1), not even by their identity. Rather, they become meaningful because of their location in the network of message paths. If we replace true and false by 0 and 1, the image would still work if what is expected from booleans is satisfied by their replacements."
      },
      "after": "b808c2b6af0aaa51",
      "date": 1660202734438
    },
    {
      "type": "edit",
      "id": "3603862e00b29d41",
      "item": {
        "type": "markdown",
        "id": "3603862e00b29d41",
        "text": "But then, if the actual answer could be whatever pair of distinct objects we want, we can also see that the meaning of these objects is not given by their name (`true`, `false`, `0`, `1`), not even by their identity. Rather, they become meaningful because of their location in the network of message paths. If we replace true and false by 0 and 1, the image would still work if what is expected from booleans is satisfied by their replacements."
      },
      "date": 1660202772206
    },
    {
      "type": "edit",
      "id": "3603862e00b29d41",
      "item": {
        "type": "markdown",
        "id": "3603862e00b29d41",
        "text": "But then, if the actual answer could be whatever pair of distinct objects we want, we can also see that the meaning of these objects is not given by their name (`true`, `false`, `0`, `1`), not even by their identity. Rather, they become meaningful because of their location in the network of message paths. If we replace `true` and `false` by `0` and `1`, the image would still work if what is expected from booleans is satisfied by their replacements."
      },
      "date": 1660202819067
    },
    {
      "type": "edit",
      "id": "1804cf985ba0de36",
      "item": {
        "type": "paragraph",
        "id": "1804cf985ba0de36",
        "text": "This is an excellent opportunity to remind ourselves to avoid confusing the labels with the labelled objects. It is perfectly fine to refer to distinctions by means of names, as long as we always keep in mind that a name is something we assign according to our intentions. But labels are not the labelled objects."
      },
      "date": 1660202840678
    },
    {
      "item": {
        "type": "factory",
        "id": "95569afb2239a142"
      },
      "id": "95569afb2239a142",
      "type": "add",
      "after": "1804cf985ba0de36",
      "date": 1660202870734
    },
    {
      "type": "edit",
      "id": "95569afb2239a142",
      "item": {
        "type": "paragraph",
        "id": "95569afb2239a142",
        "text": "– [[Large Systems]]"
      },
      "date": 1660202880915
    },
    {
      "type": "edit",
      "id": "95569afb2239a142",
      "item": {
        "type": "paragraph",
        "id": "95569afb2239a142",
        "text": "⇒ [[Large Systems]]"
      },
      "date": 1660202943629
    },
    {
      "item": {
        "type": "factory",
        "id": "79abf75a280c8322"
      },
      "id": "79abf75a280c8322",
      "type": "add",
      "after": "95569afb2239a142",
      "date": 1660203112209
    },
    {
      "item": {
        "type": "factory",
        "id": "7db33b4a0bde38ba"
      },
      "id": "7db33b4a0bde38ba",
      "type": "add",
      "after": "79abf75a280c8322",
      "date": 1660203118051
    },
    {
      "type": "edit",
      "id": "79abf75a280c8322",
      "item": {
        "type": "pagefold",
        "id": "79abf75a280c8322",
        "text": "~"
      },
      "date": 1660203118949
    },
    {
      "type": "edit",
      "id": "7db33b4a0bde38ba",
      "item": {
        "type": "paragraph",
        "id": "7db33b4a0bde38ba",
        "text": "Section 1.3 of [[A Mentoring Course on Smalltalk]]"
      },
      "date": 1660203120780
    },
    {
      "type": "edit",
      "id": "7db33b4a0bde38ba",
      "item": {
        "type": "paragraph",
        "id": "7db33b4a0bde38ba",
        "text": "Section 1.2.6 of [[A Mentoring Course on Smalltalk]]"
      },
      "date": 1660203127417
    }
  ]
}