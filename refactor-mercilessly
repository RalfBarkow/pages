{
  "title": "Refactor Mercilessly",
  "story": [
    {
      "type": "html",
      "text": "One of the [[Extreme Programming]] practices is to [[Refactor Mercilessly]]. When you find two methods that look the same, you refactor the code to combine them. When you find two objects with common functionality, you refactor to make there be just one (see [[Parameterize Method]]). Extreme projects do not use [[Big Design Up Front]]. Therefore they upgrade their designs continuously. [[Relentless Testing]] and [[Continuous Integration]] ([[Unit Test]]s synchronized with changes disseminated to other engineers) permit changes that would introduce the risk of bugs in slower projects.",
      "id": "a913e2250e2abc09d9de46ded43d8019"
    },
    {
      "type": "html",
      "text": "\nAnd you change all the users of the old capability to use the new. In [[Small Talk]], that's particularly easy to do, because you can open a browser on all the senders of the old one and edit them to the new. (There may be [[Code Ownership]] issues, of course.)",
      "id": "585e3b693bc57e96d481e799ca003832"
    },
    {
      "type": "html",
      "text": "\nSince we have extensive [[Unit Test]]s and [[Acceptance Test]]s, we can always refactor with the confidence that we haven't broken anything.",
      "id": "37ce710290c6e922dc7482cf159fb189"
    },
    {
      "type": "html",
      "text": "\nThe result of these practices is that the system does not get held hostage by some old, hide-bound, ill-conceived idea from the past. It remains fresh and new, productive and fun to work with.",
      "id": "d53a0a60a4e8ef883879e12a3cac7431"
    },
    {
      "type": "html",
      "text": "\nSince we [[Do The Simplest Thing That Could Possibly Work]], sometimes what we do needs improvement an iteration or so down the line. We welcome these opportunities to make the system more like what it should be, and we welcome the fact that we do it in solid knowledge of what is <i>really</i> needed, not what we imagined in the past was needed.",
      "id": "d854612c75fec94926cb01b7d5401710"
    },
    {
      "type": "html",
      "text": "\nThe result of this is that the system is always as simple as we can make it, which means we can understand it better, which means we can change it more rapidly while keeping it reliable.",
      "id": "8d3b845ed14507fcd34c843844d28a5f"
    },
    {
      "type": "html",
      "text": "\nTry it, you'll like it ...",
      "id": "600a4dbc0f20a0f87dbfec31a9c679dc"
    },
    {
      "type": "html",
      "text": "-- [[Ron Jeffries]]",
      "id": "f9b9c6bfd292baadd6f36759b3efd47b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nIs [[Refactor Mercilessly]] supposed to be so merciless as to refactor across the boundaries of multiple projects and shared libraries? -- [[Helmut Leitner]]",
      "id": "b202d1693f8fc589b4de7e9846e88738"
    },
    {
      "type": "html",
      "text": "<i>That depends on code ownership issues. You cannot refactor it if you don't own it. On the other hand, why not refactor a shared library, the functionality and API shouldn't change.</i>",
      "id": "6659c4f8a2be69ed72b5003b12d1c66d"
    },
    {
      "type": "html",
      "text": "\nThis would mean to refactor within a single project. I asked for \"across the boundaries\" in a \"multiple project, multiple library\" situation where APIs need to be improved. [[Collective Code Ownership]] for all projects and libraries is assumed. Is this attempted? What is it to attempt this in Smalltalk? Do the refactoring tools still help?",
      "id": "29cb0670fe27ebf85e1ebb54d55206be"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "If you have refactoring tools for this, they help of course. The prerequisite is that libraries and other projects are written in the same programming language (and that language is available in the tool).",
      "id": "c095088a29bac09da1e39b52a16f41f8"
    },
    {
      "type": "html",
      "text": "\nIf the library used created by an open source project (REAL open source, not Apple's \"you may do nothing useful but read and only until we cancel the agreement\" - License), this is where some of the power of open source comes from: Developers that need something from a library can jump in and code it.",
      "id": "3127e35408346b1c718fa6f640c1055f"
    },
    {
      "type": "html",
      "text": "\nThere are also drawbacks: When a large refactoring is done, often a consensus has to be reached before a \"patch\" is included in the library, and patches that have been forgotten because they aren't \"sexy\" fall out of date. Summary: Open Source has good potential for cross-project refactoring, but can use it only if it patches are quickly judged and integrated. -- [[Peter Schaefer]]",
      "id": "e6e38f304e193aabd4692c60ae4227d8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\"[[Water Fall]]\" theory says only \"Analysis\" can identify the elements of a program most depended-on by others, and these must be designed and coded first, before their clients are coded.",
      "id": "d48d62a34e415df6c564864f30c0f090"
    },
    {
      "type": "html",
      "text": "\n[[Refactor Mercilessly]] says the longer your program has been committed into real source code and demonstrated performing features, the more you know about how to improve & upgrade its internal structure.",
      "id": "be6d911f9871d477f30ce2bcd2adf71c"
    },
    {
      "type": "html",
      "text": "\nI'm sold.",
      "id": "430f60c6b250bbc9bd804ca21e3c8bc1"
    },
    {
      "type": "html",
      "text": "-- [[Phl Ip]]",
      "id": "08b72f6e647da1fc1270c35d77f2335b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nThis ain't near the bottom of the page, so only 'last edited' aficionados will get to read it. Responding to Phil, above...",
      "id": "12951be2eb4d688005e2d176510afde7"
    },
    {
      "type": "html",
      "text": "\nWhere can I read about \"[[Water Fall]] theory\"? On these pages, [[Water Fall]] is like the Mc<b></b>Carthyist Communism of the 1950's - an acceptable thing to fear (parody on [[An Acceptable Way Of Failing]]).",
      "id": "13b8a77f03bddc80f255527d043dcba5"
    },
    {
      "type": "html",
      "text": "<i>I ([[Phl Ip]]) am just relating my experiences reading [[Job Security]]-style code. AFAIK [[Water Fall]] theory does _not_ say you write the most-depended on classes first. But that's the way everyone in [[Real Life]] does it.</i>",
      "id": "a3fd2e2908cc3e1157ce8fdd44932e3b"
    },
    {
      "type": "html",
      "text": "\nI don't know what \"[[Water Fall]] theory\" says, but Phil is right on target with the insight about the connection between analysis and refactoring (see comments toward the end of [[What Is Analysis]] and [[Analysis Is Refactoring]]). When you are refactoring, you are analyzing. The right time to do it cannot come from some process manual or methodology - it's when you see an opportunity to express something more powerfully and simply. The project phase and the medium are unimportant. The people, their skills, and the project context are important. And it's far more important to do it when you can than to quibble about the ideal time to do it.",
      "id": "d7d0a2967f3ed14e38385918a7025550"
    },
    {
      "type": "html",
      "text": "\nI fancy I'm following my own advice here, by pointing out the commonality between code refactoring and other forms of analysis. <i>This is the essence of systems development, no matter what name you give it.</i>",
      "id": "7aa7264822bebfa95e10fd638bb46016"
    },
    {
      "type": "html",
      "text": "\nI guess the term \"analysis\" has some stigma associated with it (by hanging out with \"[[Water Fall]]\", no doubt). I've noticed that to some people, analysis is always [[Analysis Paralysis]]. Maybe I'm just an old fashioned analyst, but I still like the word \"analysis\" and its semantic roots. Therefore, I propose a new base class to the [[Refactor Mercilessly]] class: [[Analyze Mercilessly]]. <i>Do it everywhere, not just in code.</i> -- [[Walden Mathews]]",
      "id": "714910006158e0aefaf95768cf58f0ee"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "<i>See [[Refactoring With Cee Plus Plus]] for issues and tips for XP with C/C++</i> -- [[Douglas Auclair]]",
      "id": "19afc95e14be6e32f6962b8b844158fb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nOn [[Specialization Is For Insects]], [[Ron Jeffries]] said the following about [[Chrysler Comprehensive Compensation]]: <i>\"It's no phone system, but it is complex (1800 classes, 25000 methods), and the ordinary folks who wrote it actually understand it!\"</i>",
      "id": "b51ae4f9f7d157b29040a304384abae0"
    },
    {
      "type": "html",
      "text": "\nIt would be neat to see a frequency histogram of classes with given numbers of methods. That is, number of classes with one method, number of classes with two methods... The average of your numbers is ~13.9 methods per class.",
      "id": "4015364cdd968c3f382a43d8efc927ea"
    },
    {
      "type": "html",
      "text": "\nI'd just guess that you could tell a good amount from a histogram. I'd expect that in well-factored systems, it would have a single peak that would rise gradually and then fall off quicker. If there are some outliers far out to the right, you could have some [[God Object]]s. If there are multiple large distinguished peaks, that could indicate a multitude of things: inconsistent refactoring, architectural decisions that have produced categories of classes, or a fractured team. On the other hand, there probably isn't enough spread to see more than the most grievous cases.",
      "id": "831b391208470bc171804e9c85c8927d"
    },
    {
      "type": "html",
      "text": "-- [[Michael Feathers]]",
      "id": "52639166d94ae390aae5613c99347552"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nFair enough. One problem that I have with [[Refactor Mercilessly]], though, is that it seems to conflate intensional with extensional. Compare the following two statements:",
      "id": "37c0d4c8405a44ad3a206ce0a86079c1"
    },
    {
      "type": "html",
      "text": "\nA:<i>These two classes implement the same piece of code (contain a similar method, whatever), and it's an essential similarity.</i>",
      "id": "fe8a612324a2dd27ed13c1b06b6dae08"
    },
    {
      "type": "html",
      "text": "\nB:<i>These two classes implement the same piece of code (contain a similar method, whatever), but it's pretty much coincidence.</i>",
      "id": "cff16b756e7d19370743e230d87af406"
    },
    {
      "type": "html",
      "text": "\nNow in the first case, it's clear the refactoring should take place on the classes to exploit (expose ?) the essential similarity. But in the second case ? You could claim that this indicates a need to refactor somewhere else (for example: if more than one client of a server is performing the same sequence of operations, then maybe the server should support that sequence with a single method call).",
      "id": "2505cf60285ea14c507b8a1d468c5629"
    },
    {
      "type": "html",
      "text": "\nBut I don't know. In general, especially when the code is evolving, I'm inclined to cut the second case a little slack. Let the functionality hang for a while and see if the code evolves along different paths as more functionality is added to the system.",
      "id": "6f9d5f8668588d04e0d44668fa4dd744"
    },
    {
      "type": "html",
      "text": "\nRelated notion: Anyone care to comment on the following quicktime movie [http://www.isi.edu/isd/LOOM/loom-classifier.mov www.isi.edu]",
      "id": "4ba1e43c115d66fb360b2fe114bc99a7"
    },
    {
      "type": "html",
      "text": "-- [[William Grosso]]",
      "id": "956fb65db6bf284049105d90a20c113d"
    },
    {
      "type": "html",
      "text": "\"it's pretty much coincidence\" - When I think this, generally it is because I don't understand. Often moving responsibility to a shared server fixes the problem. Or I have something to learn about what is similar and what is different. In any case, I don't stress about it. If the code is talking, I'd better be listening. Damned arrogant of me to think I know better. -- [[Kent Beck]]",
      "id": "35203f441ef952b310a47ca2413ae03a"
    },
    {
      "type": "html",
      "text": "\nWhat's the cost of getting it wrong and combining methods that \"should\" be separate? Ideally, it would just mean undoing the refactoring later on when the methods diverge. This second refactoring should be cheap, and its cost offset by the benefit of having the simpler system (with one less method) in the meantime. So you win overall by merging the methods.",
      "id": "276f8f2600393c5a4df5e769482298b9"
    },
    {
      "type": "html",
      "text": "\nIn a worse case you make a change to the merged method that only one use needs, and that screws up the second use. You get a side effect, and a bug in some other part of the system that you weren't working on. This risk is offset by [[Unit Test]]s and the like. They detect the bug straight away because they test remote parts of the system automatically, without you thinking about it. So you can pin it down to the change you just made, and figure out that you need to split the method. So this isn't something to fear, as long as you have [[The Full Monty]] XP. -- [[Dave Harris]]",
      "id": "60e252bc2ff742676d9a9ef591398978"
    },
    {
      "type": "html",
      "text": "\nThe crucial question is whether the second refactoring is actually cheap. If the method is called in a dozen places, you have to check each one to see which version of the method it should be calling. This requires a bit of brain-power; you need to understand what those other methods are doing. One approach might be to preserve the difference even while performing the merge. For example, leave the second method there but have it forward to the first method. Or have two factory methods that both return the same class. This would be less Extreme, but better than having two copies of the code. -- [[Dave Harris]]",
      "id": "21cd6af473320afea5728b54dea3b78d"
    },
    {
      "type": "html",
      "text": "\nThe forwarding solution doesn't bother me, if I have two different things to say. It was such a revelation to me the day I understood the value of",
      "id": "9932e52ebbf10fd3222e6f159857bfde"
    },
    {
      "type": "html",
      "text": "highlight:<br>aRectangle",
      "id": "a3470a84caa82a619a6d14518a58312b"
    },
    {
      "type": "html",
      "text": "self reverse:<br>aRectangle",
      "id": "e7f5f880571b216006bb62b021a2ba86"
    },
    {
      "type": "html",
      "text": "OTOH, if you really can't tell the difference, squish them together and have the faith that the system will tell you different when it knows different. -- [[Kent Beck]]",
      "id": "1dcaa7a40647a94e362c49bf42734d94"
    },
    {
      "type": "html",
      "text": "\nSee Also: [[Cost Of Refactor Carry]]",
      "id": "9f2e213370c3d6414b2dc401bf994916"
    },
    {
      "type": "html",
      "text": "\nAnyone else consider that [[William Grosso]] could have refactored to :",
      "id": "affdd8455257906ddd2e2f735ba89096"
    },
    {
      "type": "html",
      "text": "\nThese two classes implement the same piece of code (contain a similar method, whatever), -",
      "id": "cb7323456d230393ac6d73a1e848ced8"
    },
    {
      "type": "html",
      "text": "\nA:<i>and it's an essential similarity.</i>",
      "id": "74cf4fd6e6b70698b083ab1dd0bd3cab"
    },
    {
      "type": "html",
      "text": "\nB:<i>but it's pretty much coincidence.</i>",
      "id": "9a27ea5f735043ca42a29676d189026d"
    },
    {
      "type": "html",
      "text": "\nor am I just being tedious?!",
      "id": "ebde76c54e3ab7a52d573e094bdce0a4"
    },
    {
      "type": "html",
      "text": "\nI think that's OK. The coincidental refactoring comes when you now see the common \"it's\" in those 2 choices and attempt to refactor further.",
      "id": "df1546ddb2891f12a6b22a13bd2cfb0b"
    },
    {
      "type": "code",
      "text": "  Base = \"These two classes implement the same piece of code (contain a similar method, whatever), -\n   [name]: [join] it's [clause].\"\n  A:Base = {join=\"and\" clause=\"an essential similarity\"}\n  B:Base = {join=\"but\" clause=\"pretty much coincidence\"}",
      "id": "91d6be12525d882955170f0ce86f8449"
    },
    {
      "type": "html",
      "text": "-- [[Dave Whipp]]",
      "id": "7690edb11552e69ae2219532c989ac7f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nWilliam: please offer one example of coincidental implementation of the same piece of code that seems to you not to suggest refactoring. Thanks. -- [[Ron Jeffries]]",
      "id": "e3cbe35fdbc9be2402640c5bc055620a"
    },
    {
      "type": "html",
      "text": "\nSuppose I've got two classes, each with one instance variable, and each class has an \"initialize\" method that sets the variable to zero. If I renamed one of the variables to be same as the other, I could give them a common superclass and just implement \"initialize\" once.",
      "id": "d7e8e13887402d7afceb0bb03c957e0c"
    },
    {
      "type": "html",
      "text": "\nIn practice, humans don't have much problem with these false positives. Although I'm sure someone made that refactoring at some time or other, most developers are smart enough to know better. Automated refactoring tools are not, however. This is one of the reasons that I think that tools should always be under the direction of humans, and not decide whether or not to perform a refactoring. -- [[Ralph Johnson]]",
      "id": "929bb6d18c58e3e5e93ae397b71e27bd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nI like Ralph's example a lot. It makes me think, a good trick in itself. I was thinking of duplications with just a <i>bit</i> more processing, such as maybe",
      "id": "25627e08a15b2d3c0248a9725acbb6a8"
    },
    {
      "type": "html",
      "text": "1 to:<br>array size do: [ :index | array at: index put: zero ]",
      "id": "3af76ee7877f6c8ab91b6e4f61a32b98"
    },
    {
      "type": "html",
      "text": "which might lead one to wonder whether collections should have a method named, e.g. #atAllPut: or #zeroize. No conclusion yet, except that I think the human should look at duplications carefully to see whether they are saying something important about the program. A good tool like [Small]lint can help by discovering candidates for consideration. -- [[Ron Jeffries]]",
      "id": "32e86ec602598f7ed895f176acf56831"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nIf you've got two classes, each with one instance variable, and you find out that the one and only instance variable plays exactly the same role in both of those classes and thus needs to be named the same, you might want to look at merging more than just that initialize method. -- [[Don Wells]]",
      "id": "5c38cad8ffffd662d252ecbe258e8a43"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nOkay, here's the thing I've been trying to figure out about how to [[Refactor Mercilessly]]: Suppose in the code I want to refactor I have a class A with a method x. If x is part of the [[Public Interface]] of A. Or perhaps a better example would be if it's semi-public, meaning it's not going to be used by normal client programmers but it is used by other classes in *my* code. At any rate, I probably have a [[Unit Test]] that calls x and makes sure it behaves properly. Now I'm refactoring and I decide that x's behavior needs to change or maybe the behavior stays the same but it really belongs in some other class. So I fire up my browser (or wish I had one in Java and do it the hard way) and find all the callers and fix them. But the only way I can make the test work is to change the test itself. But now it seems there's a hole in the safety net that my [[Unit Test]] was giving me - since both the code and the test changed I could have broken the code and also broken the test so it's not really equivalent to the old test. Voila, I've got a regression. I realize that some (maybe most) refactorings will leave the surface API the same so the tests don't change but are there strategies for dealing with this harder case? -- [[Peter Seibel]]",
      "id": "8db28db2d036de075e8c4abca0945962"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nPerhaps \"this harder case\" is largely illusory. For the problem described to occur, it would be necessary to inject a defect in the refactoring (which isn't impossible, but if it's really a refactoring, it's difficult), and then inject a corresponding but exactly opposite defect in the test. Flaws in a [[Unit Test]] generally produce false positives, indications of errors that aren't, not false negatives. There are exceptions ... but they're rare enough that I'd not worry about it. -- [[Ron Jeffries]]",
      "id": "788bdcd42a0a99df75cb0630b2298ac9"
    },
    {
      "type": "html",
      "text": "\nHmm.. I'm not sure about this assertion. I guess it depends how you code your [[Unit Test]]s. I'll admit up front that I don't use any of the UT frameworks discussed here, but I have found the occasional false-negative due to cut-and-paste errors :- a test may accidentally end up just a copy of a similar test; or expression-bracketing issues which don't actually execute the real code. [[Pair Programming]] would help to overcome this, but it's hard for me at home on my own. I do worry that I'm missing the point sometimes, though, as I seem to need to refactor the [[Unit Test]]s every time I refactor the main code. -- [[Frank Carver]]",
      "id": "76a61558331bb3915d669ecfa3a8d33e"
    },
    {
      "type": "html",
      "text": "\nRefactoring is changing implementation without changing interface. It should be rare for [[Unit Test]]s to need changing under refactoring. Perhaps you are changing interface, not refactoring? In that case, yes, the [[Unit Test]]s will have to change, just as they do when you add or remove functionality. It's the price of knowing that your changes work. False negatives are OK, they point themselves out, you look at them and fix them. False positives are bad, but they're rare by the above argument. -- [[Ron Jeffries]]",
      "id": "a91cf2a945ab17960f3d96e070f0e58a"
    },
    {
      "type": "html",
      "text": "[\nCome again? One person says \"false positives, indications of errors that aren't\", and another person says \"False negatives are OK, they point themselves out\". It looks like what one person calls \"false positive\", the other person calls \"false negative\", and vice versa. [[False Positive]]. [[False Negative]]. I think one person thinks of \"positive\" as \"Yes, I get some error messages here\", while the other person thinks of positive as \"Yippee, unit tests tell me everything is A-OK !\". Or did I miss the point somewhere?",
      "id": "a163a31176d62e2539b10c7d3f5cccff"
    },
    {
      "type": "html",
      "text": "-- [[David Cary]]",
      "id": "5e595082286724526bc51db000cd2783"
    },
    {
      "type": "html",
      "text": "]",
      "id": "4eff870c671f191ef67831431d58727b"
    },
    {
      "type": "html",
      "text": "\nRefactoring must surely encompass changing interface sometimes....",
      "id": "ad1d3770d51e7b249c10fd498a84543b"
    },
    {
      "type": "html",
      "text": "\nLooking at [[Martin Fowler]]'s page [ [http://www2.awl.com/cseng/titles/0-201-89542-0/refactor/index.html www2.awl.com] ]",
      "id": "32224602f267a4fc5bc29aa624106bdd"
    },
    {
      "type": "html",
      "text": "\nI can see a few \"refactorings\" that involve moving methods or changing classes and adjusting all references....",
      "id": "4cc6f84663fe939f231e7e0647181b33"
    },
    {
      "type": "html",
      "text": "\nIs his book incorrectly named? :-)",
      "id": "2c241192598de5db2bc67562c49206a0"
    },
    {
      "type": "html",
      "text": "-- [[Alan Francis]]",
      "id": "279f1b205d58e80dc6ff0642eec31709"
    },
    {
      "type": "html",
      "text": "<i>Not necessarily - moving methods doesn't change (system) functionality. Of course it changes the functionality of one class, but not of the cluster of classes involved in the refactoring. -- [[Ron Jeffries]]</i>",
      "id": "97310bda10b874c154ae17bda88fa955"
    },
    {
      "type": "html",
      "text": "\nYes, from what I understood from the book refactoring is about changing the implementation without changing the functionality. [[Ron Jeffries]] comment raises issues about which parts of your system are interfaces. Since [[Sub System]] or [[Component Modelling]] don't form a part of XP there is no level of interface higher than the interface to a class.",
      "id": "519a993ff4758febbe10fa56c959138e"
    },
    {
      "type": "html",
      "text": "\nOne question I have with [[Refactor Mercilessly]] is how to make sure people are refactoring. Some people I've worked with the past can barely manage to get their systems functioning at all never mind making them well factored. -- 193.36.79.206",
      "id": "8b13d2f997426e0700016b4e54fed96d"
    },
    {
      "type": "html",
      "text": "-- [[Glen Stampoultzis]]",
      "id": "1b63b427e6e3d39bcd06f362a095b24a"
    },
    {
      "type": "html",
      "text": "<i>Are you saying you can't trust your team to do what they have agreed to do? What does this tell you about the place where you are? -- rj</i>",
      "id": "5c84c03148f83439adc127367e76cc92"
    },
    {
      "type": "html",
      "text": "(Sorry, Ron, I have only most rarely seen people do what they agreed to do. Most people \"agree\" out loud because it is expected and less tiring than disagreeing. But that doesn't mean they agree inside, and even if they agree inside, it still doesn't mean they'll have the energy to follow through the next day or two weeks later. So on most projects, Glen's question is meaningful -- [[Alistair Cockburn]])",
      "id": "4d9ae1201f0c30a6a97a9b538fef5e06"
    },
    {
      "type": "html",
      "text": "\nI'm saying that I've worked in a number of different environments and that the quality level of varies significantly. Many people I know I would have complete confidence in but there are also plenty of people out there who write complete spaghetti and get away with it. Luckily the people I'm working with at the moment are quite competent and conscientious but I expect it wont be the last time I come across programmers from hell.",
      "id": "3b327efc698b18855c9af487164caf27"
    },
    {
      "type": "html",
      "text": "\nLet me rephrase my question: How do you encourage people to [[Refactor Mercilessly]]?",
      "id": "47ee6109c24d96fae63f2d6edeeee8a4"
    },
    {
      "type": "html",
      "text": "-- [[Glen Stampoultzis]]",
      "id": "1b63b427e6e3d39bcd06f362a095b24a"
    },
    {
      "type": "html",
      "text": "\nIt's one of the team practices. They have promised to follow the practices. If they don't, we get to kill them. Makes a good example for the others.",
      "id": "a8588d6eb208a652051276c28ba9ae12"
    },
    {
      "type": "html",
      "text": "\nI've never once worked with programmers who were not conscientious, and who did not want to do the right thing. If somehow I fell in with a batch of such people, and they didn't instantly convert to giving a ****, I'd desert them. -- rj",
      "id": "65793cc113ace498da69c2dceff66b6b"
    },
    {
      "type": "html",
      "text": "\nI think you have to do some [[Pair Programming]] with them, refactor something, and let them see that it is not so difficult, doesn't break the system, and they feel better afterwards. For a group who don't [[Refactor Mercilessly]], I would expect each person would need at least three such sessions to get the feeling. I don't think ordering someone to do something they don't understand is effective. -- [[Alistair Cockburn]]",
      "id": "003ac101ec3e03e38bb4590322f5e044"
    },
    {
      "type": "html",
      "text": "\nPeople who are trying to do good are just fine and you can work with them. I refer above specifically to a group who are not conscientious and do not care whether they do the right thing. I don't think such people are thick on the ground. If I found a bunch, I wouldn't want to be there. -- rj",
      "id": "9be0e61daa32edddd6e6576c23884976"
    },
    {
      "type": "html",
      "text": "\nI suspect that Ron is just trying to make a point. I know Ron and I can not imagine him just abandoning a project. He has the tenacity of a bulldog. -- [[Don Wells]]",
      "id": "d3336e4b940e15ef28ef1ec024792672"
    },
    {
      "type": "html",
      "text": "\n[[Xp Is Nota Silver Bullet]] -- [[John Brewer]]",
      "id": "dde4ed87c253fd874b0ad94b570f1552"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nOkay, I'm very intrigued by what I've read so far. I like iterative design and I'd love to give [[Big Design Up Front]] the boot and refactor like mad, but there's one thing standing in my way: the [[Relational Database]]. I read stories about people changing their classes as they go and it sounds great but I keep thinking, \"How does he get his DBA to change the schema every 10 minutes?\" Most of us aren't using [[Gem Stone]] for persistence (or [[Small Talk]], but that's a different matter). Are we just out of luck with XP? -- [[Perrin Harkins]]",
      "id": "ad9b910285a28744236e6a7aa7d7fd90"
    },
    {
      "type": "html",
      "text": "<i>See [[Refactoring With Relational Databases]]</i>",
      "id": "c560906dc3ee847ea366770849691023"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nSee [[Dont Refactor Published Interfaces Mercilessly]]",
      "id": "df9b68098bc67c79e2b80eaf264655a9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nWhat constitutes [[Duplicated Code]]? Anything that looks very similar is duplicated code. Some you can't eliminate, as it relates to the nature of the language, but much of it can be \"factored together\" in to something more centralized. If you can't see how to make it more centralized, then flag it with a TODO comment and maybe later insight will strike. -- Anonymous",
      "id": "545b808b2d0f88d939e9077a3deb145a"
    },
    {
      "type": "html",
      "text": "\nI would suggest not to use TODO comments - see [[Todo Comments Considered Harmful]]. I would use a [[Bug Database]] instead. -- [[Guillermo Schwarz]]",
      "id": "450e0436c682d4a6f37951695255cefd"
    },
    {
      "type": "html",
      "text": "<i>I would merge duplicated definitions of </i>behavior<i>. -- [[Phl Ip]]</i>",
      "id": "f88396094bfc216ba6038b5ec6058336"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\n[[Refactor Mercilessly]] means that once the bar is green, you and your partner spend as much time is required to make the code as simple as you can. Don't move on to another story while the code remains poorly factored. -- [[Eric Herman]]",
      "id": "1a2c7be9c8b8c41702b7dc6f8ff990b0"
    },
    {
      "type": "html",
      "text": "\nBut it's often beneficial to <i>wait</i> to refactor. If you're not sure <i>how</i> best to refactor, put it off: [[Duplication Refactoring Threshold]].",
      "id": "c313d93ca1fe3d18838a555ab83af2e5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\n[[Temporary Detailed Testing Supporting Refactoring]] is a technique that uses even more aggressive testing, tests whose results are not be expected to remain consistent during normal development as features are added, to provide confidence during refactorings that are supposed to change just program structure, and not program output. -- [[Andy Glew]]",
      "id": "8d1be03bff39c74e74ccb77b6b8ac719"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "<i>Do we have a case for [[Simplify Mercilessly]] as a purpose? If so please create the page and explain, and move relevant parts from here to this new page.</i> -- [[David Liu]]",
      "id": "811cc06295fd05636d14f231b359b107"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "Refactoring is by all means a complicated task. In-depth knowledge of, and preferably experience in implementing, the [[Design Patterns]] is a must. XP is a set of (common sense) skills and not a methodology. \nXP by its nature is not simple. Maybe the Extreme in XP is that it is full of contradictions. An XP programmer teaching piano would say: \"Playing the piano is simple. Just hit the keys and you hear a melody. Sit by my side and do as I do.\" My point is that the word simple seems to have a different meaning in XP. [[Jim Caprioli]]",
      "id": "047729475775585e5bc41174a4bbc1a0"
    },
    {
      "type": "html",
      "text": " A real XP programmer would teach singing, since that's the quickest way to produce a coherent tune (usually - not meaning to omit the tone-deaf). The piano part could be generated from that. -- [[Peter Lynch]]",
      "id": "67f1e928119f6804be34ebbfb6c7ed87"
    },
    {
      "type": "html",
      "text": "\nXP programmers only work with the tools best suited for the job. (?) That would certainly make a programmer more productive. I see a few problems though (real XP programmers only see solutions!)",
      "id": "1c99d6cb26bbfa96be0f25758a585b02"
    },
    {
      "type": "html",
      "text": " the guy longest on the job who is too stupid to learn a new trick and who is afraid of the new",
      "id": "ebcce1fec180d58f0cd236dd629d8c2e"
    },
    {
      "type": "html",
      "text": " his father-in-law, the manager (who else?) who controls the tools budget",
      "id": "087e61cf93909fc0357bfdd0c040ff85"
    },
    {
      "type": "html",
      "text": " and so on... [[Real Normal Programmers]] work with imperfect tools and people --[[Jim Caprioli]]",
      "id": "81798dd7ef545a66cd0ecf8e93127006"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "<i>Where can I find case studies of large complex XP projects?</i> [[Answer Me]]",
      "id": "af1c1ebf205a4de02c702ca5b81c2df9"
    },
    {
      "type": "html",
      "text": "\nRegarding code duplication by \"coincidence\" ... \"coincidence\" is probably the not the best word. I think what was meant was the scenario in which two or more segments of code have the same logic, but there is no inherent reason for them to remain the same for the long term, and they can be changed independently without introducing inconsistent behavior in the system.",
      "id": "9de31c45ebdeb9acd588f16fae533e5c"
    },
    {
      "type": "html",
      "text": "\nFor example, consider a bank with 3 types of checking accounts - standard, silver, and gold. They come with different features and fees, but some of those are in common. Suppose silver and gold both pay interest if you have a daily average balance of $10000. So that piece of the code is duplicated for silver and gold accounts.",
      "id": "8798bd5e836f3b0334bbdaa19d091e78"
    },
    {
      "type": "html",
      "text": " Note that some of us believe that \"types of accounts\" is likely a problematic modeling technique. A more flexible solution is to model the different features of the accounts without any hard-wired grouping of features. Then perhaps have another entity (class or table) called \"account packages\" that assigns names to sets of features. Customers really want a Feature Buffet, but marketers like to group stuff into bundled deals, but keep tweaking the bundles over time, recombining the features in different ways. If you only use type hierarchies, you will have to keep shuffling stuff up and down the tree as the scope changes, if a tree can even fit. In OOAD, at least use some form of composition instead of inheritance.",
      "id": "9f4cc2db6c20ab1e517f1187563395c5"
    },
    {
      "type": "html",
      "text": "\nThat duplication isn't bad because there is no inherent necessity to change both if one has to be changed. It is perfectly acceptable to change the gold account to require a daily *minimum* of $10000, while leaving the silver with *average* balance rule. -- [[Thomas Norman]]",
      "id": "568419a7619a2a6d2fa42f96fc72a92d"
    },
    {
      "type": "html",
      "text": "<i>This is a nice example on the surface, but it belies a deeper issue than code duplication. If your bank account behavior is based on code as described, something is broken - this should be a data-driven design. On the flip side, if it's more complex logic (like having different formulae for compounding interest on the accounts), there is no reason to have three functions [[Compound Interest Standard]], [[Compound Interest Silver]], [[Compound Interest Gold]]. Either this should have been foreseen in the original design of the system, and been built in a data-driven way, or refactored into the system later when the need arose. I think [[Ralph Johnson]]<b></b>'s example above covers the \"pure coincidence\" case nicely. The \"accidental coincidence\" case (where the code is pre-emptively duplicated in anticipation of a future divergence) is subject to [[Yag Ni]], and, as such, shouldn't even occur in the wild (assuming an ideal world, of course).</i>",
      "id": "32fcd6fc941a77bdb5857c4e751b4d61"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nThere is only one problem with [[Refactor Mercilessly]] - the real world. In the real world of assigned issues and non-paired programming, your performance is measured by the number of issues you resolve. Producing well-factored code not only slows down your own progress, but it aids your [[Cow Orker]]s in making sense of your code when they have an issue on it that they must handle (while their code is still a cyclopean horror when you work on it). So well-factored code makes you look like the worst developer.",
      "id": "2eba862e8ce80748046d879a0b8e6eed"
    },
    {
      "type": "html",
      "text": "<i>Only in the short term. On projects that did [[Refactor Mercilessly]] vs. more traditional, fear-based projects (\"fix the issue as stated with the least code perturbation\"), I've found that the time required to add features and resolve issues drops on well-factored projects. In particular, if you're in a company with at least two projects of comparable size, and only one team does [[Refactor Mercilessly]], the difference between the two will become embarrassingly apparent around the second or third major release.</i>",
      "id": "8e00c93e878c8329a4bb806fefb5c4ad"
    },
    {
      "type": "html",
      "text": "<i>Naturally, if you're in a company where there's no long-term visibility, or one that has only one product, or that specializes in short-term one-offs projects, this won't apply. -- [[Tim Lesher]]</i>",
      "id": "cd82af2a0e17681346a736c241b687cf"
    },
    {
      "type": "html",
      "text": "\nThere is a time and place for a company to go fast and take on [[Technical Debt]].  There is also a time and place to pay down that debt. I would not say that it is an ideal to never accumulate technical debt.  It sometimes makes a lot of sense to go very fast.   The main thing is that if the software is intended to have a long life, it is critical to keep its [[Technical Debt]] low.  --[[Joshua Kerievsky]]",
      "id": "1f8acfb1683e3053a36d72e410f63056"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nI like to do [[Braindead Refactoring]] sometimes. Joel talks about it here [http://www.joelonsoftware.com/articles/fog0000000348.html www.joelonsoftware.com]. The idea is just to simplify without necessarily creating pristine code at the end. Example from Joel: take every string of SQL and dump it into a general 'SQL' class, without worrying about class design. Example from my PhD, refactoring 16 similar algorithms by extracting common code, even when I couldn't see an obvious meaning in the new predicates I was creating. I take away from this that even ugly simplification can be worthwhile. --[[Daniel Lucraft]] (first edit)",
      "id": "bfebb06fcbf53523a6aca655959db72b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "\nSee [[When To Stop Refactoring]], [[Refactor Low Hanging Fruit]], [[Grand Refactoring Day]], [[Refactoring Improving The Design Of Existing Code]], [[Architect The Negative Space]], [[Refactoring Mercilessly Dialog]], [[Data Transfer Object]], [[Refactoring Metaphor]], [[Refactoring In Various Languages]], [[Directed Refactoring]]",
      "id": "fdfb5b5394b6702ac4cde80c4fa1f007"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "08c76068daff12a79339258db509eff1"
    },
    {
      "type": "html",
      "text": "[[Category Refactoring]]",
      "id": "c941fb81b3ecef9b48585ddde3ef034f"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?RefactorMercilessly c2.com]",
      "id": "4823a4d336ab799243d4f33b3918d3a8"
    }
  ],
  "journal": [
    {
      "date": 1408012559000,
      "id": "33d6891cf20177d0d63aadc77f65a3a7",
      "type": "create",
      "item": {
        "title": "Refactor Mercilessly",
        "story": [
          {
            "type": "html",
            "text": "One of the [[Extreme Programming]] practices is to [[Refactor Mercilessly]]. When you find two methods that look the same, you refactor the code to combine them. When you find two objects with common functionality, you refactor to make there be just one (see [[Parameterize Method]]). Extreme projects do not use [[Big Design Up Front]]. Therefore they upgrade their designs continuously. [[Relentless Testing]] and [[Continuous Integration]] ([[Unit Test]]s synchronized with changes disseminated to other engineers) permit changes that would introduce the risk of bugs in slower projects.",
            "id": "a913e2250e2abc09d9de46ded43d8019"
          },
          {
            "type": "html",
            "text": "\nAnd you change all the users of the old capability to use the new. In [[Small Talk]], that's particularly easy to do, because you can open a browser on all the senders of the old one and edit them to the new. (There may be [[Code Ownership]] issues, of course.)",
            "id": "585e3b693bc57e96d481e799ca003832"
          },
          {
            "type": "html",
            "text": "\nSince we have extensive [[Unit Test]]s and [[Acceptance Test]]s, we can always refactor with the confidence that we haven't broken anything.",
            "id": "37ce710290c6e922dc7482cf159fb189"
          },
          {
            "type": "html",
            "text": "\nThe result of these practices is that the system does not get held hostage by some old, hide-bound, ill-conceived idea from the past. It remains fresh and new, productive and fun to work with.",
            "id": "d53a0a60a4e8ef883879e12a3cac7431"
          },
          {
            "type": "html",
            "text": "\nSince we [[Do The Simplest Thing That Could Possibly Work]], sometimes what we do needs improvement an iteration or so down the line. We welcome these opportunities to make the system more like what it should be, and we welcome the fact that we do it in solid knowledge of what is <i>really</i> needed, not what we imagined in the past was needed.",
            "id": "d854612c75fec94926cb01b7d5401710"
          },
          {
            "type": "html",
            "text": "\nThe result of this is that the system is always as simple as we can make it, which means we can understand it better, which means we can change it more rapidly while keeping it reliable.",
            "id": "8d3b845ed14507fcd34c843844d28a5f"
          },
          {
            "type": "html",
            "text": "\nTry it, you'll like it ...",
            "id": "600a4dbc0f20a0f87dbfec31a9c679dc"
          },
          {
            "type": "html",
            "text": "-- [[Ron Jeffries]]",
            "id": "f9b9c6bfd292baadd6f36759b3efd47b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nIs [[Refactor Mercilessly]] supposed to be so merciless as to refactor across the boundaries of multiple projects and shared libraries? -- [[Helmut Leitner]]",
            "id": "b202d1693f8fc589b4de7e9846e88738"
          },
          {
            "type": "html",
            "text": "<i>That depends on code ownership issues. You cannot refactor it if you don't own it. On the other hand, why not refactor a shared library, the functionality and API shouldn't change.</i>",
            "id": "6659c4f8a2be69ed72b5003b12d1c66d"
          },
          {
            "type": "html",
            "text": "\nThis would mean to refactor within a single project. I asked for \"across the boundaries\" in a \"multiple project, multiple library\" situation where APIs need to be improved. [[Collective Code Ownership]] for all projects and libraries is assumed. Is this attempted? What is it to attempt this in Smalltalk? Do the refactoring tools still help?",
            "id": "29cb0670fe27ebf85e1ebb54d55206be"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "If you have refactoring tools for this, they help of course. The prerequisite is that libraries and other projects are written in the same programming language (and that language is available in the tool).",
            "id": "c095088a29bac09da1e39b52a16f41f8"
          },
          {
            "type": "html",
            "text": "\nIf the library used created by an open source project (REAL open source, not Apple's \"you may do nothing useful but read and only until we cancel the agreement\" - License), this is where some of the power of open source comes from: Developers that need something from a library can jump in and code it.",
            "id": "3127e35408346b1c718fa6f640c1055f"
          },
          {
            "type": "html",
            "text": "\nThere are also drawbacks: When a large refactoring is done, often a consensus has to be reached before a \"patch\" is included in the library, and patches that have been forgotten because they aren't \"sexy\" fall out of date. Summary: Open Source has good potential for cross-project refactoring, but can use it only if it patches are quickly judged and integrated. -- [[Peter Schaefer]]",
            "id": "e6e38f304e193aabd4692c60ae4227d8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\"[[Water Fall]]\" theory says only \"Analysis\" can identify the elements of a program most depended-on by others, and these must be designed and coded first, before their clients are coded.",
            "id": "d48d62a34e415df6c564864f30c0f090"
          },
          {
            "type": "html",
            "text": "\n[[Refactor Mercilessly]] says the longer your program has been committed into real source code and demonstrated performing features, the more you know about how to improve & upgrade its internal structure.",
            "id": "be6d911f9871d477f30ce2bcd2adf71c"
          },
          {
            "type": "html",
            "text": "\nI'm sold.",
            "id": "430f60c6b250bbc9bd804ca21e3c8bc1"
          },
          {
            "type": "html",
            "text": "-- [[Phl Ip]]",
            "id": "08b72f6e647da1fc1270c35d77f2335b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nThis ain't near the bottom of the page, so only 'last edited' aficionados will get to read it. Responding to Phil, above...",
            "id": "12951be2eb4d688005e2d176510afde7"
          },
          {
            "type": "html",
            "text": "\nWhere can I read about \"[[Water Fall]] theory\"? On these pages, [[Water Fall]] is like the Mc<b></b>Carthyist Communism of the 1950's - an acceptable thing to fear (parody on [[An Acceptable Way Of Failing]]).",
            "id": "13b8a77f03bddc80f255527d043dcba5"
          },
          {
            "type": "html",
            "text": "<i>I ([[Phl Ip]]) am just relating my experiences reading [[Job Security]]-style code. AFAIK [[Water Fall]] theory does _not_ say you write the most-depended on classes first. But that's the way everyone in [[Real Life]] does it.</i>",
            "id": "a3fd2e2908cc3e1157ce8fdd44932e3b"
          },
          {
            "type": "html",
            "text": "\nI don't know what \"[[Water Fall]] theory\" says, but Phil is right on target with the insight about the connection between analysis and refactoring (see comments toward the end of [[What Is Analysis]] and [[Analysis Is Refactoring]]). When you are refactoring, you are analyzing. The right time to do it cannot come from some process manual or methodology - it's when you see an opportunity to express something more powerfully and simply. The project phase and the medium are unimportant. The people, their skills, and the project context are important. And it's far more important to do it when you can than to quibble about the ideal time to do it.",
            "id": "d7d0a2967f3ed14e38385918a7025550"
          },
          {
            "type": "html",
            "text": "\nI fancy I'm following my own advice here, by pointing out the commonality between code refactoring and other forms of analysis. <i>This is the essence of systems development, no matter what name you give it.</i>",
            "id": "7aa7264822bebfa95e10fd638bb46016"
          },
          {
            "type": "html",
            "text": "\nI guess the term \"analysis\" has some stigma associated with it (by hanging out with \"[[Water Fall]]\", no doubt). I've noticed that to some people, analysis is always [[Analysis Paralysis]]. Maybe I'm just an old fashioned analyst, but I still like the word \"analysis\" and its semantic roots. Therefore, I propose a new base class to the [[Refactor Mercilessly]] class: [[Analyze Mercilessly]]. <i>Do it everywhere, not just in code.</i> -- [[Walden Mathews]]",
            "id": "714910006158e0aefaf95768cf58f0ee"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "<i>See [[Refactoring With Cee Plus Plus]] for issues and tips for XP with C/C++</i> -- [[Douglas Auclair]]",
            "id": "19afc95e14be6e32f6962b8b844158fb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nOn [[Specialization Is For Insects]], [[Ron Jeffries]] said the following about [[Chrysler Comprehensive Compensation]]: <i>\"It's no phone system, but it is complex (1800 classes, 25000 methods), and the ordinary folks who wrote it actually understand it!\"</i>",
            "id": "b51ae4f9f7d157b29040a304384abae0"
          },
          {
            "type": "html",
            "text": "\nIt would be neat to see a frequency histogram of classes with given numbers of methods. That is, number of classes with one method, number of classes with two methods... The average of your numbers is ~13.9 methods per class.",
            "id": "4015364cdd968c3f382a43d8efc927ea"
          },
          {
            "type": "html",
            "text": "\nI'd just guess that you could tell a good amount from a histogram. I'd expect that in well-factored systems, it would have a single peak that would rise gradually and then fall off quicker. If there are some outliers far out to the right, you could have some [[God Object]]s. If there are multiple large distinguished peaks, that could indicate a multitude of things: inconsistent refactoring, architectural decisions that have produced categories of classes, or a fractured team. On the other hand, there probably isn't enough spread to see more than the most grievous cases.",
            "id": "831b391208470bc171804e9c85c8927d"
          },
          {
            "type": "html",
            "text": "-- [[Michael Feathers]]",
            "id": "52639166d94ae390aae5613c99347552"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nFair enough. One problem that I have with [[Refactor Mercilessly]], though, is that it seems to conflate intensional with extensional. Compare the following two statements:",
            "id": "37c0d4c8405a44ad3a206ce0a86079c1"
          },
          {
            "type": "html",
            "text": "\nA:<i>These two classes implement the same piece of code (contain a similar method, whatever), and it's an essential similarity.</i>",
            "id": "fe8a612324a2dd27ed13c1b06b6dae08"
          },
          {
            "type": "html",
            "text": "\nB:<i>These two classes implement the same piece of code (contain a similar method, whatever), but it's pretty much coincidence.</i>",
            "id": "cff16b756e7d19370743e230d87af406"
          },
          {
            "type": "html",
            "text": "\nNow in the first case, it's clear the refactoring should take place on the classes to exploit (expose ?) the essential similarity. But in the second case ? You could claim that this indicates a need to refactor somewhere else (for example: if more than one client of a server is performing the same sequence of operations, then maybe the server should support that sequence with a single method call).",
            "id": "2505cf60285ea14c507b8a1d468c5629"
          },
          {
            "type": "html",
            "text": "\nBut I don't know. In general, especially when the code is evolving, I'm inclined to cut the second case a little slack. Let the functionality hang for a while and see if the code evolves along different paths as more functionality is added to the system.",
            "id": "6f9d5f8668588d04e0d44668fa4dd744"
          },
          {
            "type": "html",
            "text": "\nRelated notion: Anyone care to comment on the following quicktime movie [http://www.isi.edu/isd/LOOM/loom-classifier.mov www.isi.edu]",
            "id": "4ba1e43c115d66fb360b2fe114bc99a7"
          },
          {
            "type": "html",
            "text": "-- [[William Grosso]]",
            "id": "956fb65db6bf284049105d90a20c113d"
          },
          {
            "type": "html",
            "text": "\"it's pretty much coincidence\" - When I think this, generally it is because I don't understand. Often moving responsibility to a shared server fixes the problem. Or I have something to learn about what is similar and what is different. In any case, I don't stress about it. If the code is talking, I'd better be listening. Damned arrogant of me to think I know better. -- [[Kent Beck]]",
            "id": "35203f441ef952b310a47ca2413ae03a"
          },
          {
            "type": "html",
            "text": "\nWhat's the cost of getting it wrong and combining methods that \"should\" be separate? Ideally, it would just mean undoing the refactoring later on when the methods diverge. This second refactoring should be cheap, and its cost offset by the benefit of having the simpler system (with one less method) in the meantime. So you win overall by merging the methods.",
            "id": "276f8f2600393c5a4df5e769482298b9"
          },
          {
            "type": "html",
            "text": "\nIn a worse case you make a change to the merged method that only one use needs, and that screws up the second use. You get a side effect, and a bug in some other part of the system that you weren't working on. This risk is offset by [[Unit Test]]s and the like. They detect the bug straight away because they test remote parts of the system automatically, without you thinking about it. So you can pin it down to the change you just made, and figure out that you need to split the method. So this isn't something to fear, as long as you have [[The Full Monty]] XP. -- [[Dave Harris]]",
            "id": "60e252bc2ff742676d9a9ef591398978"
          },
          {
            "type": "html",
            "text": "\nThe crucial question is whether the second refactoring is actually cheap. If the method is called in a dozen places, you have to check each one to see which version of the method it should be calling. This requires a bit of brain-power; you need to understand what those other methods are doing. One approach might be to preserve the difference even while performing the merge. For example, leave the second method there but have it forward to the first method. Or have two factory methods that both return the same class. This would be less Extreme, but better than having two copies of the code. -- [[Dave Harris]]",
            "id": "21cd6af473320afea5728b54dea3b78d"
          },
          {
            "type": "html",
            "text": "\nThe forwarding solution doesn't bother me, if I have two different things to say. It was such a revelation to me the day I understood the value of",
            "id": "9932e52ebbf10fd3222e6f159857bfde"
          },
          {
            "type": "html",
            "text": "highlight:<br>aRectangle",
            "id": "a3470a84caa82a619a6d14518a58312b"
          },
          {
            "type": "html",
            "text": "self reverse:<br>aRectangle",
            "id": "e7f5f880571b216006bb62b021a2ba86"
          },
          {
            "type": "html",
            "text": "OTOH, if you really can't tell the difference, squish them together and have the faith that the system will tell you different when it knows different. -- [[Kent Beck]]",
            "id": "1dcaa7a40647a94e362c49bf42734d94"
          },
          {
            "type": "html",
            "text": "\nSee Also: [[Cost Of Refactor Carry]]",
            "id": "9f2e213370c3d6414b2dc401bf994916"
          },
          {
            "type": "html",
            "text": "\nAnyone else consider that [[William Grosso]] could have refactored to :",
            "id": "affdd8455257906ddd2e2f735ba89096"
          },
          {
            "type": "html",
            "text": "\nThese two classes implement the same piece of code (contain a similar method, whatever), -",
            "id": "cb7323456d230393ac6d73a1e848ced8"
          },
          {
            "type": "html",
            "text": "\nA:<i>and it's an essential similarity.</i>",
            "id": "74cf4fd6e6b70698b083ab1dd0bd3cab"
          },
          {
            "type": "html",
            "text": "\nB:<i>but it's pretty much coincidence.</i>",
            "id": "9a27ea5f735043ca42a29676d189026d"
          },
          {
            "type": "html",
            "text": "\nor am I just being tedious?!",
            "id": "ebde76c54e3ab7a52d573e094bdce0a4"
          },
          {
            "type": "html",
            "text": "\nI think that's OK. The coincidental refactoring comes when you now see the common \"it's\" in those 2 choices and attempt to refactor further.",
            "id": "df1546ddb2891f12a6b22a13bd2cfb0b"
          },
          {
            "type": "code",
            "text": "  Base = \"These two classes implement the same piece of code (contain a similar method, whatever), -\n   [name]: [join] it's [clause].\"\n  A:Base = {join=\"and\" clause=\"an essential similarity\"}\n  B:Base = {join=\"but\" clause=\"pretty much coincidence\"}",
            "id": "91d6be12525d882955170f0ce86f8449"
          },
          {
            "type": "html",
            "text": "-- [[Dave Whipp]]",
            "id": "7690edb11552e69ae2219532c989ac7f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nWilliam: please offer one example of coincidental implementation of the same piece of code that seems to you not to suggest refactoring. Thanks. -- [[Ron Jeffries]]",
            "id": "e3cbe35fdbc9be2402640c5bc055620a"
          },
          {
            "type": "html",
            "text": "\nSuppose I've got two classes, each with one instance variable, and each class has an \"initialize\" method that sets the variable to zero. If I renamed one of the variables to be same as the other, I could give them a common superclass and just implement \"initialize\" once.",
            "id": "d7e8e13887402d7afceb0bb03c957e0c"
          },
          {
            "type": "html",
            "text": "\nIn practice, humans don't have much problem with these false positives. Although I'm sure someone made that refactoring at some time or other, most developers are smart enough to know better. Automated refactoring tools are not, however. This is one of the reasons that I think that tools should always be under the direction of humans, and not decide whether or not to perform a refactoring. -- [[Ralph Johnson]]",
            "id": "929bb6d18c58e3e5e93ae397b71e27bd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nI like Ralph's example a lot. It makes me think, a good trick in itself. I was thinking of duplications with just a <i>bit</i> more processing, such as maybe",
            "id": "25627e08a15b2d3c0248a9725acbb6a8"
          },
          {
            "type": "html",
            "text": "1 to:<br>array size do: [ :index | array at: index put: zero ]",
            "id": "3af76ee7877f6c8ab91b6e4f61a32b98"
          },
          {
            "type": "html",
            "text": "which might lead one to wonder whether collections should have a method named, e.g. #atAllPut: or #zeroize. No conclusion yet, except that I think the human should look at duplications carefully to see whether they are saying something important about the program. A good tool like [Small]lint can help by discovering candidates for consideration. -- [[Ron Jeffries]]",
            "id": "32e86ec602598f7ed895f176acf56831"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nIf you've got two classes, each with one instance variable, and you find out that the one and only instance variable plays exactly the same role in both of those classes and thus needs to be named the same, you might want to look at merging more than just that initialize method. -- [[Don Wells]]",
            "id": "5c38cad8ffffd662d252ecbe258e8a43"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nOkay, here's the thing I've been trying to figure out about how to [[Refactor Mercilessly]]: Suppose in the code I want to refactor I have a class A with a method x. If x is part of the [[Public Interface]] of A. Or perhaps a better example would be if it's semi-public, meaning it's not going to be used by normal client programmers but it is used by other classes in *my* code. At any rate, I probably have a [[Unit Test]] that calls x and makes sure it behaves properly. Now I'm refactoring and I decide that x's behavior needs to change or maybe the behavior stays the same but it really belongs in some other class. So I fire up my browser (or wish I had one in Java and do it the hard way) and find all the callers and fix them. But the only way I can make the test work is to change the test itself. But now it seems there's a hole in the safety net that my [[Unit Test]] was giving me - since both the code and the test changed I could have broken the code and also broken the test so it's not really equivalent to the old test. Voila, I've got a regression. I realize that some (maybe most) refactorings will leave the surface API the same so the tests don't change but are there strategies for dealing with this harder case? -- [[Peter Seibel]]",
            "id": "8db28db2d036de075e8c4abca0945962"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nPerhaps \"this harder case\" is largely illusory. For the problem described to occur, it would be necessary to inject a defect in the refactoring (which isn't impossible, but if it's really a refactoring, it's difficult), and then inject a corresponding but exactly opposite defect in the test. Flaws in a [[Unit Test]] generally produce false positives, indications of errors that aren't, not false negatives. There are exceptions ... but they're rare enough that I'd not worry about it. -- [[Ron Jeffries]]",
            "id": "788bdcd42a0a99df75cb0630b2298ac9"
          },
          {
            "type": "html",
            "text": "\nHmm.. I'm not sure about this assertion. I guess it depends how you code your [[Unit Test]]s. I'll admit up front that I don't use any of the UT frameworks discussed here, but I have found the occasional false-negative due to cut-and-paste errors :- a test may accidentally end up just a copy of a similar test; or expression-bracketing issues which don't actually execute the real code. [[Pair Programming]] would help to overcome this, but it's hard for me at home on my own. I do worry that I'm missing the point sometimes, though, as I seem to need to refactor the [[Unit Test]]s every time I refactor the main code. -- [[Frank Carver]]",
            "id": "76a61558331bb3915d669ecfa3a8d33e"
          },
          {
            "type": "html",
            "text": "\nRefactoring is changing implementation without changing interface. It should be rare for [[Unit Test]]s to need changing under refactoring. Perhaps you are changing interface, not refactoring? In that case, yes, the [[Unit Test]]s will have to change, just as they do when you add or remove functionality. It's the price of knowing that your changes work. False negatives are OK, they point themselves out, you look at them and fix them. False positives are bad, but they're rare by the above argument. -- [[Ron Jeffries]]",
            "id": "a91cf2a945ab17960f3d96e070f0e58a"
          },
          {
            "type": "html",
            "text": "[\nCome again? One person says \"false positives, indications of errors that aren't\", and another person says \"False negatives are OK, they point themselves out\". It looks like what one person calls \"false positive\", the other person calls \"false negative\", and vice versa. [[False Positive]]. [[False Negative]]. I think one person thinks of \"positive\" as \"Yes, I get some error messages here\", while the other person thinks of positive as \"Yippee, unit tests tell me everything is A-OK !\". Or did I miss the point somewhere?",
            "id": "a163a31176d62e2539b10c7d3f5cccff"
          },
          {
            "type": "html",
            "text": "-- [[David Cary]]",
            "id": "5e595082286724526bc51db000cd2783"
          },
          {
            "type": "html",
            "text": "]",
            "id": "4eff870c671f191ef67831431d58727b"
          },
          {
            "type": "html",
            "text": "\nRefactoring must surely encompass changing interface sometimes....",
            "id": "ad1d3770d51e7b249c10fd498a84543b"
          },
          {
            "type": "html",
            "text": "\nLooking at [[Martin Fowler]]'s page [ [http://www2.awl.com/cseng/titles/0-201-89542-0/refactor/index.html www2.awl.com] ]",
            "id": "32224602f267a4fc5bc29aa624106bdd"
          },
          {
            "type": "html",
            "text": "\nI can see a few \"refactorings\" that involve moving methods or changing classes and adjusting all references....",
            "id": "4cc6f84663fe939f231e7e0647181b33"
          },
          {
            "type": "html",
            "text": "\nIs his book incorrectly named? :-)",
            "id": "2c241192598de5db2bc67562c49206a0"
          },
          {
            "type": "html",
            "text": "-- [[Alan Francis]]",
            "id": "279f1b205d58e80dc6ff0642eec31709"
          },
          {
            "type": "html",
            "text": "<i>Not necessarily - moving methods doesn't change (system) functionality. Of course it changes the functionality of one class, but not of the cluster of classes involved in the refactoring. -- [[Ron Jeffries]]</i>",
            "id": "97310bda10b874c154ae17bda88fa955"
          },
          {
            "type": "html",
            "text": "\nYes, from what I understood from the book refactoring is about changing the implementation without changing the functionality. [[Ron Jeffries]] comment raises issues about which parts of your system are interfaces. Since [[Sub System]] or [[Component Modelling]] don't form a part of XP there is no level of interface higher than the interface to a class.",
            "id": "519a993ff4758febbe10fa56c959138e"
          },
          {
            "type": "html",
            "text": "\nOne question I have with [[Refactor Mercilessly]] is how to make sure people are refactoring. Some people I've worked with the past can barely manage to get their systems functioning at all never mind making them well factored. -- 193.36.79.206",
            "id": "8b13d2f997426e0700016b4e54fed96d"
          },
          {
            "type": "html",
            "text": "-- [[Glen Stampoultzis]]",
            "id": "1b63b427e6e3d39bcd06f362a095b24a"
          },
          {
            "type": "html",
            "text": "<i>Are you saying you can't trust your team to do what they have agreed to do? What does this tell you about the place where you are? -- rj</i>",
            "id": "5c84c03148f83439adc127367e76cc92"
          },
          {
            "type": "html",
            "text": "(Sorry, Ron, I have only most rarely seen people do what they agreed to do. Most people \"agree\" out loud because it is expected and less tiring than disagreeing. But that doesn't mean they agree inside, and even if they agree inside, it still doesn't mean they'll have the energy to follow through the next day or two weeks later. So on most projects, Glen's question is meaningful -- [[Alistair Cockburn]])",
            "id": "4d9ae1201f0c30a6a97a9b538fef5e06"
          },
          {
            "type": "html",
            "text": "\nI'm saying that I've worked in a number of different environments and that the quality level of varies significantly. Many people I know I would have complete confidence in but there are also plenty of people out there who write complete spaghetti and get away with it. Luckily the people I'm working with at the moment are quite competent and conscientious but I expect it wont be the last time I come across programmers from hell.",
            "id": "3b327efc698b18855c9af487164caf27"
          },
          {
            "type": "html",
            "text": "\nLet me rephrase my question: How do you encourage people to [[Refactor Mercilessly]]?",
            "id": "47ee6109c24d96fae63f2d6edeeee8a4"
          },
          {
            "type": "html",
            "text": "-- [[Glen Stampoultzis]]",
            "id": "1b63b427e6e3d39bcd06f362a095b24a"
          },
          {
            "type": "html",
            "text": "\nIt's one of the team practices. They have promised to follow the practices. If they don't, we get to kill them. Makes a good example for the others.",
            "id": "a8588d6eb208a652051276c28ba9ae12"
          },
          {
            "type": "html",
            "text": "\nI've never once worked with programmers who were not conscientious, and who did not want to do the right thing. If somehow I fell in with a batch of such people, and they didn't instantly convert to giving a ****, I'd desert them. -- rj",
            "id": "65793cc113ace498da69c2dceff66b6b"
          },
          {
            "type": "html",
            "text": "\nI think you have to do some [[Pair Programming]] with them, refactor something, and let them see that it is not so difficult, doesn't break the system, and they feel better afterwards. For a group who don't [[Refactor Mercilessly]], I would expect each person would need at least three such sessions to get the feeling. I don't think ordering someone to do something they don't understand is effective. -- [[Alistair Cockburn]]",
            "id": "003ac101ec3e03e38bb4590322f5e044"
          },
          {
            "type": "html",
            "text": "\nPeople who are trying to do good are just fine and you can work with them. I refer above specifically to a group who are not conscientious and do not care whether they do the right thing. I don't think such people are thick on the ground. If I found a bunch, I wouldn't want to be there. -- rj",
            "id": "9be0e61daa32edddd6e6576c23884976"
          },
          {
            "type": "html",
            "text": "\nI suspect that Ron is just trying to make a point. I know Ron and I can not imagine him just abandoning a project. He has the tenacity of a bulldog. -- [[Don Wells]]",
            "id": "d3336e4b940e15ef28ef1ec024792672"
          },
          {
            "type": "html",
            "text": "\n[[Xp Is Nota Silver Bullet]] -- [[John Brewer]]",
            "id": "dde4ed87c253fd874b0ad94b570f1552"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nOkay, I'm very intrigued by what I've read so far. I like iterative design and I'd love to give [[Big Design Up Front]] the boot and refactor like mad, but there's one thing standing in my way: the [[Relational Database]]. I read stories about people changing their classes as they go and it sounds great but I keep thinking, \"How does he get his DBA to change the schema every 10 minutes?\" Most of us aren't using [[Gem Stone]] for persistence (or [[Small Talk]], but that's a different matter). Are we just out of luck with XP? -- [[Perrin Harkins]]",
            "id": "ad9b910285a28744236e6a7aa7d7fd90"
          },
          {
            "type": "html",
            "text": "<i>See [[Refactoring With Relational Databases]]</i>",
            "id": "c560906dc3ee847ea366770849691023"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nSee [[Dont Refactor Published Interfaces Mercilessly]]",
            "id": "df9b68098bc67c79e2b80eaf264655a9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nWhat constitutes [[Duplicated Code]]? Anything that looks very similar is duplicated code. Some you can't eliminate, as it relates to the nature of the language, but much of it can be \"factored together\" in to something more centralized. If you can't see how to make it more centralized, then flag it with a TODO comment and maybe later insight will strike. -- Anonymous",
            "id": "545b808b2d0f88d939e9077a3deb145a"
          },
          {
            "type": "html",
            "text": "\nI would suggest not to use TODO comments - see [[Todo Comments Considered Harmful]]. I would use a [[Bug Database]] instead. -- [[Guillermo Schwarz]]",
            "id": "450e0436c682d4a6f37951695255cefd"
          },
          {
            "type": "html",
            "text": "<i>I would merge duplicated definitions of </i>behavior<i>. -- [[Phl Ip]]</i>",
            "id": "f88396094bfc216ba6038b5ec6058336"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\n[[Refactor Mercilessly]] means that once the bar is green, you and your partner spend as much time is required to make the code as simple as you can. Don't move on to another story while the code remains poorly factored. -- [[Eric Herman]]",
            "id": "1a2c7be9c8b8c41702b7dc6f8ff990b0"
          },
          {
            "type": "html",
            "text": "\nBut it's often beneficial to <i>wait</i> to refactor. If you're not sure <i>how</i> best to refactor, put it off: [[Duplication Refactoring Threshold]].",
            "id": "c313d93ca1fe3d18838a555ab83af2e5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\n[[Temporary Detailed Testing Supporting Refactoring]] is a technique that uses even more aggressive testing, tests whose results are not be expected to remain consistent during normal development as features are added, to provide confidence during refactorings that are supposed to change just program structure, and not program output. -- [[Andy Glew]]",
            "id": "8d1be03bff39c74e74ccb77b6b8ac719"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "<i>Do we have a case for [[Simplify Mercilessly]] as a purpose? If so please create the page and explain, and move relevant parts from here to this new page.</i> -- [[David Liu]]",
            "id": "811cc06295fd05636d14f231b359b107"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "Refactoring is by all means a complicated task. In-depth knowledge of, and preferably experience in implementing, the [[Design Patterns]] is a must. XP is a set of (common sense) skills and not a methodology. \nXP by its nature is not simple. Maybe the Extreme in XP is that it is full of contradictions. An XP programmer teaching piano would say: \"Playing the piano is simple. Just hit the keys and you hear a melody. Sit by my side and do as I do.\" My point is that the word simple seems to have a different meaning in XP. [[Jim Caprioli]]",
            "id": "047729475775585e5bc41174a4bbc1a0"
          },
          {
            "type": "html",
            "text": " A real XP programmer would teach singing, since that's the quickest way to produce a coherent tune (usually - not meaning to omit the tone-deaf). The piano part could be generated from that. -- [[Peter Lynch]]",
            "id": "67f1e928119f6804be34ebbfb6c7ed87"
          },
          {
            "type": "html",
            "text": "\nXP programmers only work with the tools best suited for the job. (?) That would certainly make a programmer more productive. I see a few problems though (real XP programmers only see solutions!)",
            "id": "1c99d6cb26bbfa96be0f25758a585b02"
          },
          {
            "type": "html",
            "text": " the guy longest on the job who is too stupid to learn a new trick and who is afraid of the new",
            "id": "ebcce1fec180d58f0cd236dd629d8c2e"
          },
          {
            "type": "html",
            "text": " his father-in-law, the manager (who else?) who controls the tools budget",
            "id": "087e61cf93909fc0357bfdd0c040ff85"
          },
          {
            "type": "html",
            "text": " and so on... [[Real Normal Programmers]] work with imperfect tools and people --[[Jim Caprioli]]",
            "id": "81798dd7ef545a66cd0ecf8e93127006"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "<i>Where can I find case studies of large complex XP projects?</i> [[Answer Me]]",
            "id": "af1c1ebf205a4de02c702ca5b81c2df9"
          },
          {
            "type": "html",
            "text": "\nRegarding code duplication by \"coincidence\" ... \"coincidence\" is probably the not the best word. I think what was meant was the scenario in which two or more segments of code have the same logic, but there is no inherent reason for them to remain the same for the long term, and they can be changed independently without introducing inconsistent behavior in the system.",
            "id": "9de31c45ebdeb9acd588f16fae533e5c"
          },
          {
            "type": "html",
            "text": "\nFor example, consider a bank with 3 types of checking accounts - standard, silver, and gold. They come with different features and fees, but some of those are in common. Suppose silver and gold both pay interest if you have a daily average balance of $10000. So that piece of the code is duplicated for silver and gold accounts.",
            "id": "8798bd5e836f3b0334bbdaa19d091e78"
          },
          {
            "type": "html",
            "text": " Note that some of us believe that \"types of accounts\" is likely a problematic modeling technique. A more flexible solution is to model the different features of the accounts without any hard-wired grouping of features. Then perhaps have another entity (class or table) called \"account packages\" that assigns names to sets of features. Customers really want a Feature Buffet, but marketers like to group stuff into bundled deals, but keep tweaking the bundles over time, recombining the features in different ways. If you only use type hierarchies, you will have to keep shuffling stuff up and down the tree as the scope changes, if a tree can even fit. In OOAD, at least use some form of composition instead of inheritance.",
            "id": "9f4cc2db6c20ab1e517f1187563395c5"
          },
          {
            "type": "html",
            "text": "\nThat duplication isn't bad because there is no inherent necessity to change both if one has to be changed. It is perfectly acceptable to change the gold account to require a daily *minimum* of $10000, while leaving the silver with *average* balance rule. -- [[Thomas Norman]]",
            "id": "568419a7619a2a6d2fa42f96fc72a92d"
          },
          {
            "type": "html",
            "text": "<i>This is a nice example on the surface, but it belies a deeper issue than code duplication. If your bank account behavior is based on code as described, something is broken - this should be a data-driven design. On the flip side, if it's more complex logic (like having different formulae for compounding interest on the accounts), there is no reason to have three functions [[Compound Interest Standard]], [[Compound Interest Silver]], [[Compound Interest Gold]]. Either this should have been foreseen in the original design of the system, and been built in a data-driven way, or refactored into the system later when the need arose. I think [[Ralph Johnson]]<b></b>'s example above covers the \"pure coincidence\" case nicely. The \"accidental coincidence\" case (where the code is pre-emptively duplicated in anticipation of a future divergence) is subject to [[Yag Ni]], and, as such, shouldn't even occur in the wild (assuming an ideal world, of course).</i>",
            "id": "32fcd6fc941a77bdb5857c4e751b4d61"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nThere is only one problem with [[Refactor Mercilessly]] - the real world. In the real world of assigned issues and non-paired programming, your performance is measured by the number of issues you resolve. Producing well-factored code not only slows down your own progress, but it aids your [[Cow Orker]]s in making sense of your code when they have an issue on it that they must handle (while their code is still a cyclopean horror when you work on it). So well-factored code makes you look like the worst developer.",
            "id": "2eba862e8ce80748046d879a0b8e6eed"
          },
          {
            "type": "html",
            "text": "<i>Only in the short term. On projects that did [[Refactor Mercilessly]] vs. more traditional, fear-based projects (\"fix the issue as stated with the least code perturbation\"), I've found that the time required to add features and resolve issues drops on well-factored projects. In particular, if you're in a company with at least two projects of comparable size, and only one team does [[Refactor Mercilessly]], the difference between the two will become embarrassingly apparent around the second or third major release.</i>",
            "id": "8e00c93e878c8329a4bb806fefb5c4ad"
          },
          {
            "type": "html",
            "text": "<i>Naturally, if you're in a company where there's no long-term visibility, or one that has only one product, or that specializes in short-term one-offs projects, this won't apply. -- [[Tim Lesher]]</i>",
            "id": "cd82af2a0e17681346a736c241b687cf"
          },
          {
            "type": "html",
            "text": "\nThere is a time and place for a company to go fast and take on [[Technical Debt]].  There is also a time and place to pay down that debt. I would not say that it is an ideal to never accumulate technical debt.  It sometimes makes a lot of sense to go very fast.   The main thing is that if the software is intended to have a long life, it is critical to keep its [[Technical Debt]] low.  --[[Joshua Kerievsky]]",
            "id": "1f8acfb1683e3053a36d72e410f63056"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nI like to do [[Braindead Refactoring]] sometimes. Joel talks about it here [http://www.joelonsoftware.com/articles/fog0000000348.html www.joelonsoftware.com]. The idea is just to simplify without necessarily creating pristine code at the end. Example from Joel: take every string of SQL and dump it into a general 'SQL' class, without worrying about class design. Example from my PhD, refactoring 16 similar algorithms by extracting common code, even when I couldn't see an obvious meaning in the new predicates I was creating. I take away from this that even ugly simplification can be worthwhile. --[[Daniel Lucraft]] (first edit)",
            "id": "bfebb06fcbf53523a6aca655959db72b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "\nSee [[When To Stop Refactoring]], [[Refactor Low Hanging Fruit]], [[Grand Refactoring Day]], [[Refactoring Improving The Design Of Existing Code]], [[Architect The Negative Space]], [[Refactoring Mercilessly Dialog]], [[Data Transfer Object]], [[Refactoring Metaphor]], [[Refactoring In Various Languages]], [[Directed Refactoring]]",
            "id": "fdfb5b5394b6702ac4cde80c4fa1f007"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "08c76068daff12a79339258db509eff1"
          },
          {
            "type": "html",
            "text": "[[Category Refactoring]]",
            "id": "c941fb81b3ecef9b48585ddde3ef034f"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?RefactorMercilessly c2.com]",
            "id": "4823a4d336ab799243d4f33b3918d3a8"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1634968519213
    }
  ]
}