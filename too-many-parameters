{
  "title": "Too Many Parameters",
  "story": [
    {
      "type": "html",
      "text": "When does the function (or method, if you use Java)",
      "id": "f29aeaf230e750b8072ff5ef5397164f"
    },
    {
      "type": "code",
      "text": "  myFunction(param1, param2, ..., paramn)",
      "id": "638a9a77f3eda07a372d1205ac7a18ad"
    },
    {
      "type": "html",
      "text": "have too many parameters?",
      "id": "f0d7c050cb386c8371bba284cc192363"
    },
    {
      "type": "html",
      "text": "\nClearly one parameter is not too many, and clearly 16 parameters would be too many. I personally prefer to use no more than two or three parameters, but even this can be too many when all of the parameters are of the same type.  For example, it is easy to inadvertently swap the parameters in a call to the function",
      "id": "ceb062fc77137c9bf988e6f1f6271987"
    },
    {
      "type": "code",
      "text": "  myFunction(int param1, int param2)",
      "id": "dda7e545da70c88e1d3ede285a0d593c"
    },
    {
      "type": "html",
      "text": "unless param1 and param2 have a natural and obvious semantic order. ",
      "id": "6577a80054d7f79bca9b88daaec20a08"
    },
    {
      "type": "html",
      "text": "(removed information already covered below.)",
      "id": "404ac6f6b0611036d14b9b9e79f3a7db"
    },
    {
      "type": "html",
      "text": "\nI have found one instance where the parameter count is difficult to limit:  in the constructors of [[Immutable Object]]s.  How do I limit the parameter count (or alternatively make the ordering obvious) in the constructor of an immutable object with several fields?  <i>One approach: Build a factory.  If you need immensely complex objects, allow the factory to build a component from a string-descriptor or input stream.</i>  <i>Another approach: build a (mutable) parameter-struct that defaults to reasonable values, and pass that into the constructor.</i>",
      "id": "35087ad4f0c2124117813ed292a8d924"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1fcc75419d69842e28e5fe487397d252"
    },
    {
      "type": "html",
      "text": "<b>Possible Solutions</b>",
      "id": "6856e96f012d2b77decd4b92db53e6d6"
    },
    {
      "type": "html",
      "text": " Use named parameters for those that are optional (if language supports them)",
      "id": "7de76afb3f4cc2b591aac474afe8cfd4"
    },
    {
      "type": "html",
      "text": " Pass in an associative array or object",
      "id": "5bcdeb554381e4b792335518579c38c2"
    },
    {
      "type": "html",
      "text": " Use regional (module-wide) variables (controversial)",
      "id": "47d7215d2efcbceefdd5528f561165e3"
    },
    {
      "type": "html",
      "text": " Use Pascal-like nested functions to manage scope",
      "id": "a48d77a4417603183bace5a071e93841"
    },
    {
      "type": "html",
      "text": " [[Parameter Object]]",
      "id": "626fa56c3a93739f4a1d6a945eb48c27"
    },
    {
      "type": "html",
      "text": " XML",
      "id": "1931f1c61ca4fe32ee9fe9a6edbf752b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1fcc75419d69842e28e5fe487397d252"
    },
    {
      "type": "html",
      "text": "\nTry [[Emulate Keyword And Default Parameters]]. Or program in a language that has them (Lisp, VB, [[Objective Caml]]).",
      "id": "6a558bd144c6086bd75dd0a71c853061"
    },
    {
      "type": "html",
      "text": "\nOr you might use a [[Parameter Object]].",
      "id": "b0365e646fbc16d65bb0e511e0ffed6c"
    },
    {
      "type": "html",
      "text": "[Or assuming the function is a method in a class have attribute variables of the class \nto pre-store some of the information needed by the function. But then you may need additional Set() functions before calling the function you are focused on. Then you have to balance against [[Lots Of Short Methods]]]",
      "id": "cea7c5045832da607737686ca52439bf"
    },
    {
      "type": "html",
      "text": " That's usually an [[Anti Pattern]] due to problems regarding incomplete initialization.",
      "id": "6345a384d10b145b4279c92f4681d363"
    },
    {
      "type": "html",
      "text": "<i>When I'm looking for a short solution to this problem I usually just pass in a hash with a pre-set list of either strings or symbols as keys. But this is usually a hack, and if I end up working on that code for a while I often refactor out some sort of intermediate class. Maybe [[Too Many Parameters]] is a smell. --francis</i>",
      "id": "93b1b5bf9b29a62fd0941c79513252f7"
    },
    {
      "type": "html",
      "text": " See [[Magic Container]]",
      "id": "b05a12cbb8fa16ae24be9a98b8f4047d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1fcc75419d69842e28e5fe487397d252"
    },
    {
      "type": "html",
      "text": "I have a config file that contains options, formula etc, and is read in by a class which  stores the config in some internal efficient format. Now I need to pass in data corresponding to that config and get results out. What is the best pattern to use here? I started off with having another class that knows the interals of the above class and so is able to compute the formula for the given input - I did not like this because if I change the way I stored the config/formula I would need to change this processor class also; then I thought about having methods within the same original class for processing the input since it knows the internal representation of the config and so is in a best position to provide the output for a given input. But then as I execute several steps for producing an output, I would end up with  method calls for each step, and each of those methods having too many parameters relating to the input and relating to the previous steps. One way could be to use a parameter object, but I am trying to see if there is a pattern identified for the \"formula config and processing\".",
      "id": "bda75b849978ea5fe2d216f3e03ddfe6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1fcc75419d69842e28e5fe487397d252"
    },
    {
      "type": "html",
      "text": "[[Too Many Parameters]] is often a [[Code Smell]]. If you have to pass that much data together, it could indicate the data is related in some way and wants to be encapsulated in its own class. Passing in a single structure data that belongs apart doesn't solve the problem. Rather, the idea is that things that belong together, keep together; things that belong apart, keep apart; per the [[One Responsibility Rule]].",
      "id": "f3f35633633dea1940bd125b1b1fc73f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1fcc75419d69842e28e5fe487397d252"
    },
    {
      "type": "html",
      "text": "Suppose I encapsulate those input data that belong together; then what would be the best structure/pattern to do the 'evaluation' of the formula/options given a config and an encapsulated input? One option is to have several methods within the config class to be responsible for each of the evaluation steps, and a composing method that executes these steps. The other option is to have a separate evaluator class (which is cleaner, I think) but not clear how it could avoid knowning the inner representation of the config.. I am thinking of coding in Java.",
      "id": "35b998db9e29ba7ff2056117d5292070"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1fcc75419d69842e28e5fe487397d252"
    },
    {
      "type": "html",
      "text": "As long as you use them properly, I see nothing really wrong with module-level variables. They have a bad rap, but the alternative is often uglier, forcing one to package concepts that perhaps should not be packaged over the longer run. In other words, excessive or inappropriate coupling.",
      "id": "db32c980bcb80c709fb193811166c330"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "1fcc75419d69842e28e5fe487397d252"
    },
    {
      "type": "html",
      "text": "See also [[Long Parameter List]]",
      "id": "beda5d792b616e2b544ca417e9d96399"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?TooManyParameters c2.com]",
      "id": "57d95557932b332852f0c71a5fceb23b"
    }
  ],
  "journal": [
    {
      "date": 1392938057000,
      "id": "91eb837600a1f0e4847936fa95c178f1",
      "type": "create",
      "item": {
        "title": "Too Many Parameters",
        "story": [
          {
            "type": "html",
            "text": "When does the function (or method, if you use Java)",
            "id": "f29aeaf230e750b8072ff5ef5397164f"
          },
          {
            "type": "code",
            "text": "  myFunction(param1, param2, ..., paramn)",
            "id": "638a9a77f3eda07a372d1205ac7a18ad"
          },
          {
            "type": "html",
            "text": "have too many parameters?",
            "id": "f0d7c050cb386c8371bba284cc192363"
          },
          {
            "type": "html",
            "text": "\nClearly one parameter is not too many, and clearly 16 parameters would be too many. I personally prefer to use no more than two or three parameters, but even this can be too many when all of the parameters are of the same type.  For example, it is easy to inadvertently swap the parameters in a call to the function",
            "id": "ceb062fc77137c9bf988e6f1f6271987"
          },
          {
            "type": "code",
            "text": "  myFunction(int param1, int param2)",
            "id": "dda7e545da70c88e1d3ede285a0d593c"
          },
          {
            "type": "html",
            "text": "unless param1 and param2 have a natural and obvious semantic order. ",
            "id": "6577a80054d7f79bca9b88daaec20a08"
          },
          {
            "type": "html",
            "text": "(removed information already covered below.)",
            "id": "404ac6f6b0611036d14b9b9e79f3a7db"
          },
          {
            "type": "html",
            "text": "\nI have found one instance where the parameter count is difficult to limit:  in the constructors of [[Immutable Object]]s.  How do I limit the parameter count (or alternatively make the ordering obvious) in the constructor of an immutable object with several fields?  <i>One approach: Build a factory.  If you need immensely complex objects, allow the factory to build a component from a string-descriptor or input stream.</i>  <i>Another approach: build a (mutable) parameter-struct that defaults to reasonable values, and pass that into the constructor.</i>",
            "id": "35087ad4f0c2124117813ed292a8d924"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1fcc75419d69842e28e5fe487397d252"
          },
          {
            "type": "html",
            "text": "<b>Possible Solutions</b>",
            "id": "6856e96f012d2b77decd4b92db53e6d6"
          },
          {
            "type": "html",
            "text": " Use named parameters for those that are optional (if language supports them)",
            "id": "7de76afb3f4cc2b591aac474afe8cfd4"
          },
          {
            "type": "html",
            "text": " Pass in an associative array or object",
            "id": "5bcdeb554381e4b792335518579c38c2"
          },
          {
            "type": "html",
            "text": " Use regional (module-wide) variables (controversial)",
            "id": "47d7215d2efcbceefdd5528f561165e3"
          },
          {
            "type": "html",
            "text": " Use Pascal-like nested functions to manage scope",
            "id": "a48d77a4417603183bace5a071e93841"
          },
          {
            "type": "html",
            "text": " [[Parameter Object]]",
            "id": "626fa56c3a93739f4a1d6a945eb48c27"
          },
          {
            "type": "html",
            "text": " XML",
            "id": "1931f1c61ca4fe32ee9fe9a6edbf752b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1fcc75419d69842e28e5fe487397d252"
          },
          {
            "type": "html",
            "text": "\nTry [[Emulate Keyword And Default Parameters]]. Or program in a language that has them (Lisp, VB, [[Objective Caml]]).",
            "id": "6a558bd144c6086bd75dd0a71c853061"
          },
          {
            "type": "html",
            "text": "\nOr you might use a [[Parameter Object]].",
            "id": "b0365e646fbc16d65bb0e511e0ffed6c"
          },
          {
            "type": "html",
            "text": "[Or assuming the function is a method in a class have attribute variables of the class \nto pre-store some of the information needed by the function. But then you may need additional Set() functions before calling the function you are focused on. Then you have to balance against [[Lots Of Short Methods]]]",
            "id": "cea7c5045832da607737686ca52439bf"
          },
          {
            "type": "html",
            "text": " That's usually an [[Anti Pattern]] due to problems regarding incomplete initialization.",
            "id": "6345a384d10b145b4279c92f4681d363"
          },
          {
            "type": "html",
            "text": "<i>When I'm looking for a short solution to this problem I usually just pass in a hash with a pre-set list of either strings or symbols as keys. But this is usually a hack, and if I end up working on that code for a while I often refactor out some sort of intermediate class. Maybe [[Too Many Parameters]] is a smell. --francis</i>",
            "id": "93b1b5bf9b29a62fd0941c79513252f7"
          },
          {
            "type": "html",
            "text": " See [[Magic Container]]",
            "id": "b05a12cbb8fa16ae24be9a98b8f4047d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1fcc75419d69842e28e5fe487397d252"
          },
          {
            "type": "html",
            "text": "I have a config file that contains options, formula etc, and is read in by a class which  stores the config in some internal efficient format. Now I need to pass in data corresponding to that config and get results out. What is the best pattern to use here? I started off with having another class that knows the interals of the above class and so is able to compute the formula for the given input - I did not like this because if I change the way I stored the config/formula I would need to change this processor class also; then I thought about having methods within the same original class for processing the input since it knows the internal representation of the config and so is in a best position to provide the output for a given input. But then as I execute several steps for producing an output, I would end up with  method calls for each step, and each of those methods having too many parameters relating to the input and relating to the previous steps. One way could be to use a parameter object, but I am trying to see if there is a pattern identified for the \"formula config and processing\".",
            "id": "bda75b849978ea5fe2d216f3e03ddfe6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1fcc75419d69842e28e5fe487397d252"
          },
          {
            "type": "html",
            "text": "[[Too Many Parameters]] is often a [[Code Smell]]. If you have to pass that much data together, it could indicate the data is related in some way and wants to be encapsulated in its own class. Passing in a single structure data that belongs apart doesn't solve the problem. Rather, the idea is that things that belong together, keep together; things that belong apart, keep apart; per the [[One Responsibility Rule]].",
            "id": "f3f35633633dea1940bd125b1b1fc73f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1fcc75419d69842e28e5fe487397d252"
          },
          {
            "type": "html",
            "text": "Suppose I encapsulate those input data that belong together; then what would be the best structure/pattern to do the 'evaluation' of the formula/options given a config and an encapsulated input? One option is to have several methods within the config class to be responsible for each of the evaluation steps, and a composing method that executes these steps. The other option is to have a separate evaluator class (which is cleaner, I think) but not clear how it could avoid knowning the inner representation of the config.. I am thinking of coding in Java.",
            "id": "35b998db9e29ba7ff2056117d5292070"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1fcc75419d69842e28e5fe487397d252"
          },
          {
            "type": "html",
            "text": "As long as you use them properly, I see nothing really wrong with module-level variables. They have a bad rap, but the alternative is often uglier, forcing one to package concepts that perhaps should not be packaged over the longer run. In other words, excessive or inappropriate coupling.",
            "id": "db32c980bcb80c709fb193811166c330"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "1fcc75419d69842e28e5fe487397d252"
          },
          {
            "type": "html",
            "text": "See also [[Long Parameter List]]",
            "id": "beda5d792b616e2b544ca417e9d96399"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?TooManyParameters c2.com]",
            "id": "57d95557932b332852f0c71a5fceb23b"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1628111929953
    }
  ]
}