{
  "title": "String Buffer",
  "story": [
    {
      "type": "html",
      "text": "See also [[String Builder]] which should be your first choice for most usages in Java since 1.5 (see also below).",
      "id": "96f9f2528ebbec9451c7c9718d65e1d0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "\njava.lang.[[String Buffer]] is a class in the Java runtime library.  ",
      "id": "c22a8bb7505466cb2ecc7369fdfaed8c"
    },
    {
      "type": "html",
      "text": " [http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/StringBuffer.html docs.oracle.com]",
      "id": "610543aaa2de958bdeaa75aa5fd12351"
    },
    {
      "type": "html",
      "text": "\nIt provides a convenient way to concatenate strings together:",
      "id": "b723deda71a36deeec52e76b7999c116"
    },
    {
      "type": "code",
      "text": "  StringBuffer buffer = new StringBuffer();\n  buffer.append (\"foo\");\n  buffer.append (\" \");\n  buffer.append (\"bar\");\n  String s = buffer.toString();\n  System.out.println (s);",
      "id": "fc58c37dc1d12949c5724d56759d117f"
    },
    {
      "type": "code",
      "text": "  ''foo bar''",
      "id": "7e9bd76abfd525b305314162b1a22d65"
    },
    {
      "type": "html",
      "text": "\nUgly?  Don't worry -- when you use the + operator and either of the operands is a String, Java uses a [[String Buffer]] behinds the scenes.  The above is equivalent to:",
      "id": "c2b2124fff64e64080187c3331776a3b"
    },
    {
      "type": "code",
      "text": "  String s = \"foo\" + \" \" + \"bar\";\n  System.out.println (s);",
      "id": "e5fcbd6418d02bddb8fd6aa0509b3374"
    },
    {
      "type": "code",
      "text": "  ''foo bar''",
      "id": "7e9bd76abfd525b305314162b1a22d65"
    },
    {
      "type": "html",
      "text": "\nContributors: [[Wayne Conrad]]",
      "id": "a93a8f3f344c659c6e86bc2a40843987"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "Q: I thought the \"nice\" version created a lot of garbage \"String\"s. Since Strings are immutable [[Value Object]]s and the + operation returns a String, the only option is to create another String...",
      "id": "f984cc9e9f16659995a727c92a6d5ff2"
    },
    {
      "type": "html",
      "text": "\nA: It's implementation dependent, but the reference implementation (JDK) does optimize away the garbage Strings.",
      "id": "7c2bebd316f967a50a8172ace7138afd"
    },
    {
      "type": "html",
      "text": "\nFrom the Java Language Spec version 1.0:",
      "id": "fd8b20ca2a4480dabd62ebcf37526c05"
    },
    {
      "type": "html",
      "text": "15.17.1.2 Optimization of String Concatenation",
      "id": "81ac9c733d423cbf1190a05d4df97bcd"
    },
    {
      "type": "html",
      "text": "An implementation may choose to perform conversion and concatenation in one step to avoid creating and then discarding an intermediate String object. To increase the performance of repeated string concatenation, a Java compiler may use the [[String Buffer]] class (ยง20.13) or a similar technique to reduce the number of intermediate String objects that are created by evaluation of an expression.",
      "id": "e6f07ef86fb8e889cad036e569744af0"
    },
    {
      "type": "html",
      "text": "For primitive objects, an implementation may also optimize away the creation of a wrapper object by converting directly from a primitive type to a string.",
      "id": "d64f4af124c165393f373bf37dcd6fbc"
    },
    {
      "type": "html",
      "text": "\nThe JDK does the [[String Buffer]] optimization, so that + creates no extra String temporaries (compared to just using [[String Buffer]] yourself).  Furthermore, the compiler is allowed to perform String concatenation at compile time for <i>final</i> variables, and the JDK does.",
      "id": "c41b9aebbf4475a5310e559beed475e4"
    },
    {
      "type": "html",
      "text": "\nLet's disassemble some code and see what it actually does.  I'll use JDK 1.2.2.  The compile command is \"javac -O <filename>\", and the disassembly command is \"javap -c <classname>\".",
      "id": "399c96f5f5b6dff81aac86a2e845023e"
    },
    {
      "type": "html",
      "text": "<b>+ with final variables</b>",
      "id": "62468dedbc9de93d1eedbe96c760ea3d"
    },
    {
      "type": "code",
      "text": "  public void plusWithFinals() {\n  final String a = \"abc\";\n  final int i = 2;\n  final double d = 3.4;\n  String s = a + i + d;\n  }",
      "id": "23be737cea1f356803aef10a23249b75"
    },
    {
      "type": "code",
      "text": "  Method void plusWithFinals()\n  0 ldc #1 <String \"abc\">\n  2 astore_1\n  3 iconst_2\n  4 istore_2\n  5 ldc2_w #15 <Double 3.4>\n  8 dstore_3\n  9 ldc #2 <String \"abc23.4\">\n  11 astore 5\n  13 return",
      "id": "4c89c26fcc7f71859d3427fae3ed9b59"
    },
    {
      "type": "html",
      "text": "\nThe compiler has cleverly done the concatenation at compile time.  It can do this since we declared the variables <i>final</i>.",
      "id": "678b8826a02eb02b6563e0f65f259c2d"
    },
    {
      "type": "html",
      "text": "<b>+ with non-final variables</b>",
      "id": "f6fca3139fde7f24ff7c4fe7e69f4c64"
    },
    {
      "type": "code",
      "text": "  public void plus() {\n  String a = \"abc\";\n  int i = 2;\n  double d = 3.4;\n  String s = a + i + d;\n  }",
      "id": "a9536205336ff0d0614b713648082009"
    },
    {
      "type": "code",
      "text": "  Method void plus()\n  0 ldc #1 <String \"abc\">\n  2 astore_1\n  3 iconst_2\n  4 istore_2\n  5 ldc2_w #15 <Double 3.4>\n  8 dstore_3\n  9 new #6 <Class java.lang.StringBuffer>\n  12 dup\n  13 aload_1\n  14 invokestatic #14 <Method java.lang.String valueOf(java.lang.Object)>\n  17 invokespecial #9 <Method java.lang.StringBuffer(java.lang.String)>\n  20 iload_2\n  21 invokevirtual #11 <Method java.lang.StringBuffer append(int)>\n  24 dload_3\n  25 invokevirtual #10 <Method java.lang.StringBuffer append(double)>\n  28 invokevirtual #13 <Method java.lang.String toString()>\n  31 astore 5\n  33 return",
      "id": "0ee0831aec0b20a599aed7621f6f2006"
    },
    {
      "type": "html",
      "text": "\nThe compiler used a [[String Buffer]] to avoid creating lots of temporaries.  The call to \"valueOf\" is interesting: valueOf returns a string representation of an object.  Since \"a\" is already a String, why did the compiler call valueOf on it?",
      "id": "a6dbae28328010694928adf8d0e291bf"
    },
    {
      "type": "html",
      "text": "<b>[[String Buffer]]</b>",
      "id": "97c0caa7563673c28ec6d963f8fd079f"
    },
    {
      "type": "code",
      "text": "  public void useStringBuffer() {\n  String a = \"abc\";\n  int i = 2;\n  double d = 3.4;\n  StringBuffer buffer = new StringBuffer();\n  buffer.append(a);\n  buffer.append(i);\n  buffer.append(d);\n  String s = buffer.toString();\n  }",
      "id": "15ddb264f875055b48a0915f30159a0c"
    },
    {
      "type": "code",
      "text": "  Method void useStringBuffer()\n  0 ldc #1 <String \"abc\">\n  2 astore_1\n  3 iconst_2\n  4 istore_2\n  5 ldc2_w #15 <Double 3.4>\n  8 dstore_3\n  9 new #6 <Class java.lang.StringBuffer>\n  12 dup\n  13 invokespecial #8 <Method java.lang.StringBuffer()>\n  16 astore 5\n  18 aload 5\n  20 aload_1\n  21 invokevirtual #12 <Method java.lang.StringBuffer append(java.lang.String)>\n  24 pop\n  25 aload 5\n  27 iload_2\n  28 invokevirtual #11 <Method java.lang.StringBuffer append(int)>\n  31 pop\n  32 aload 5\n  34 dload_3\n  35 invokevirtual #10 <Method java.lang.StringBuffer append(double)>\n  38 pop\n  39 aload 5\n  41 invokevirtual #13 <Method java.lang.String toString()>\n  44 astore 6\n  46 return",
      "id": "37c79c0d95c4e3337fc95b53a314db6c"
    },
    {
      "type": "html",
      "text": "\nThis is very close to what the compiler generated when we used +.  No extra stack temporaries are being created.  The extra code is from the \"pop/aload 5\" pairs that the compiler did not generate for the \"+\" case.  But these certainly aren't the performance killer that extra string temporaries might be.",
      "id": "0f16fd80692831e1618d5224cb722ab3"
    },
    {
      "type": "html",
      "text": "\nStrangely, the gratuiotous call to valueOf that the compiler inserted when we used + isn't generated when we use [[String Buffer]].",
      "id": "1bbe5e2f18a603ca348d0aa47ef22da0"
    },
    {
      "type": "html",
      "text": "-- [[Wayne Conrad]]",
      "id": "8422c518467d4d91ecbbdc9860136b45"
    },
    {
      "type": "html",
      "text": "\nWayne, you [[Utter Bastard]]. -- Redundant author of [[String Buffer Example]]",
      "id": "10ebcfcf7f6ed1b1f8daf43ccd9684e9"
    },
    {
      "type": "html",
      "text": "\nI saw that!  It made me laugh that we both did this and at almost exactly the same time.",
      "id": "327caf3d7f7152efc1bd825304b43036"
    },
    {
      "type": "html",
      "text": "\nI like that you ran timing tests.  How would you prefer to merge our results?  Or should we keep yours?  Looks like you used a different platform than me, and that's valuable.  --[[Wayne Conrad]]",
      "id": "6c5d5610e79b6decefe4b667f6a04805"
    },
    {
      "type": "html",
      "text": "\nVery amusing timing, nice to see that someone else is as much a victim of curiosity as myself :-). I used Linux JDK 1.2.2 (the copy Sun distributes, I think) without a JIT. It would be nice to merge the results, though it's way past my bedtime so for the moment I've just put the code I used on the web: [http://www.javagroup.org/luke/string.java www.javagroup.org] is the java source, [http://www.javagroup.org/luke/string.jsm www.javagroup.org] is the jasmin-syntax assembler code. -- [[Luke Gorrie]]",
      "id": "17e4f16e04f535879db8d57b8c5af579"
    },
    {
      "type": "html",
      "text": "\nHave a nice sleep.  Things to do to this page:",
      "id": "f5f80712ddccf69edb586a7da864de6f"
    },
    {
      "type": "html",
      "text": " Add the timing test",
      "id": "8ddde66cd5d86dc2ce631ac4ca58575f"
    },
    {
      "type": "html",
      "text": " Fix the examples at the top of the page (As you pointed out, examples should use variables to prevent the compiler from doing the concatenation at compile time)>",
      "id": "3f62d48a8971cd884058bcc1f7fbb06a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "\nHas anyone taken the initiative on this to test other compilers? The above bytecodes are all generated by javac from 1.2.2.  Let me think, I've used all of the following: [[Jikes Compiler]], the compiler packaged with Visual Age, the JBuilder JDK compiler, JDK 1.1.6, JDK 1.1.8, JDK 1.3 (from Sun), jdk 1.1.8 for Linux from Blackdown, JDK 1.2 for Linux from Blackdown, JDK for Linux from IBM.  Whew! The point being, just because one compiler <i>does</i> optimize away the differences, is that behavior something we should count on?",
      "id": "199f0bfbabbbf08170643d12206a2c42"
    },
    {
      "type": "html",
      "text": "-- [[Steven Newton]]",
      "id": "7b302200fd86395ad620c1f38dfd74b2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "I think the core insight of [[String Buffer]] is that most of the time strings can and should be immutable. When you want them to be mutable, use a separate class. I mention this because it is something the C++ STD library got wrong. They have a single mutable string class, and they have a devil of a job getting the implementation both correct and efficient, especially in the face of multi-threading and reference-counted behind-the-scenes sharing. They should have made strings immutable and added a mutable [[String Buffer]] class. -- [[Dave Harris]]",
      "id": "2eba3ea8524e031485669df0d16b9d76"
    },
    {
      "type": "html",
      "text": "<i>Does anyone besides me use [[String Buffer]] instances in Java where they would use instances of Stream (on a String) in Smalltalk? I keep looking for the analogous abstraction in Java: a decorator on an array that lets me iterate through it (using next), peek at it (looking at values without changing the current position), append things to the end, and so forth. I always seem to bounce around between \"Iterator\", \"Vector\" and \"[[String Buffer]]\" in Java -- but I don't know the toolbox that well yet. -- [[Tom Stambaugh]]</i>",
      "id": "57afcd7849fa4444421989ca7835cd31"
    },
    {
      "type": "html",
      "text": "\nHave you looked at [[String Reader]]/[[String Writer]]? -- [[Steven Newton]]\nOr [[String Tokenizer]] and [[Stream Tokenizer]]? --[[Nat Pryce]]",
      "id": "3c5aff52740aa32ba8212595dd17de15"
    },
    {
      "type": "html",
      "text": "<i>Yes, I started there ([[String Reader]]/[[String Writer]]). They're really doing something different, though. [[String Reader]] reads into a char[] -- I'm looking for a \"next\" operation that returns a string. I want to work with instances of String -- not chars, char arrays, and so forth. For example, I want to pass a String to #put and get back a string from #next (and similarly for #peek and #poke).</i>",
      "id": "a3c022012d8c85fd61fffb433f314e5c"
    },
    {
      "type": "html",
      "text": "<i>The next thing is that operations on String and File instances should, from the client's perspective, be nearly transparent -- when I want to leave behind a permanent file, I open a \"Stream\" on a filename. From the caller's side, the API is the same. That way, I can write a set of utilities that does the work and then pass along a Stream on a String for temporary operations and a Stream on a File for more permanent ones. Does this help clarify my desire? Thanks -- [[Tom Stambaugh]]</i>",
      "id": "2e784f90ce92bc02dc3c39981c05e39e"
    },
    {
      "type": "html",
      "text": "\nWhat about [[Object Output Stream]] and [[Object Input Stream]]? You can use these in conjunction with [[Print Stream]]. Honestly, though, it just seems like you want a List collection such as [[Linked List]]. You could even implement your own List that uses a [[String Buffer]] as its contents in the case where you'd want the result to be a concatenated string instead of a collection of strings. It's hard to advise without some examples of how you'd like to use it. --[[Robert Di Falco]]",
      "id": "2d8aab2a333f92c1d830f86dfbaba51f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "\nHere's how to use String<b></b>Writer to do what ostrstream does in C++.\nIn the JDK, at least, String<b></b>Writer uses String<b></b>Buffer, so\nthis gives you a fairly friendly way to use String<b></b>Buffer.\nWrapping the String<b></b>Writer in a Print<b></b>Writer\ngives you the usual print and println methods.",
      "id": "abfe72a8f3a87a0ec280a4706fc4889d"
    },
    {
      "type": "code",
      "text": "  public String toString()\n  {\n  String''''''Writer stringWriter = new String''''''Writer();\n  Print''''''Writer out = new Print''''''Writer (stringWriter);\n  out.print (\"[name='\" + name + \"'\");\n  out.print (\" age=\" + age);\n  out.print (\" gender=\" + gender);\n  out.print (\"]\");\n  return stringWriter.toString();\n  }",
      "id": "16fb8b2ba1066c6e4c3b200bd64fa1e0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "\nThe String vs. [[String Buffer]] debate is not, as the author of the string.java class assumes, that using 1 [[String Buffer]] is faster than using 1 String.  Rather, it is that calling append() many times is faster than using concatenation many times.  I've posted a test that reflects this at [http://www.users.uswest.net/~jgregg3/StringTest.java www.users.uswest.net]  Sun's JDK 1.2.2 for NT takes around 1700ms and 424592 bytes of memory in my String test.  Doing the same thing with 1 [[String Buffer]] and many calls to append() takes 16ms and 74544 bytes.  There were similar large differences using 1.2.2 on LinuxPPC.  The practical import of this is that applications that do large amounts of String concatenation, like dynamic SQL builders or text file parsers, should be switched to use [[String Buffer]].",
      "id": "346bc525c8cfeee945b3a385e50267f4"
    },
    {
      "type": "html",
      "text": "--john gregg\nmailto:jgregg1@uswest.net",
      "id": "8554625109d71d4043f51677bd0e5f2e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "\nFirst comment:",
      "id": "8fccd08e49162692ff5a0e15ae65c6a7"
    },
    {
      "type": "html",
      "text": "\nYou can get rid of the extra pop/aload 5 pairs in the bytecode by\nusing the following code instead:",
      "id": "896354888c942faac700726c4acd6719"
    },
    {
      "type": "code",
      "text": "  public void useStringBuffer() {\n  String a = \"abc\";\n  int i = 2;\n  double d = 3.4;\n  String s = new StringBuffer().append(a).append(i).append(d).toString();\n  }",
      "id": "1aee2f981068812c4c9b01e8412ca748"
    },
    {
      "type": "html",
      "text": "\nNote that this is using the result of the append() method",
      "id": "1c316daf5fb0fa4e54057d979aa99d3c"
    },
    {
      "type": "html",
      "text": "(which returns the [[String Buffer]] instance)\ninstead of a local variable reference.",
      "id": "cf90759c326414be7d4323ecaf62015e"
    },
    {
      "type": "html",
      "text": "\nI actually think that this is atrocious coding style;\nmethods should not always return a predetermined argument or <i>this</i>.\nSuch a return encourages the programmer to use the return value,\nactively defeating any compile-time",
      "id": "2ec00ae75833247ee4f644ed69cd80f6"
    },
    {
      "type": "html",
      "text": "(or, in the case of Java, JIT-time)\noptimizations for things like null pointer checks.\nSince the compiler is not told that the return value can never be null,\nit has to make the null check each time you use a method on the return value,\ninstead of being able to make that check once and then be sure",
      "id": "43fd53ee6ef6f4651371c440024dd1f7"
    },
    {
      "type": "html",
      "text": "(since nothing else can reference the local variable)\nthat the value hasn't become null in the course of the method call.",
      "id": "354eafc4df3b2b6a76c2315b8a5e2ce6"
    },
    {
      "type": "html",
      "text": "\nSecond comment:",
      "id": "677e8ec262426b05b5b42ad20009feff"
    },
    {
      "type": "html",
      "text": "\nMicrosoft's JVC uses String.concat() instead of [[String Buffer]].\nWhether this is more or less efficient than using [[String Buffer]]\ndepends highly on the underlying implementation of both those classes.\nIt does produce marginally shorter bytecode",
      "id": "5de1e0c0b30b26895604383c569b0a8a"
    },
    {
      "type": "html",
      "text": "(no initialization of a [[String Buffer]] or calling of toString()),\nfor whatever good that's worth.",
      "id": "664f6e75cb10a1b48ae82b757b250193"
    },
    {
      "type": "html",
      "text": "-- [[Alex Popiel]]",
      "id": "1fd908ded06df8e27fe5406c27510f3e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "\nIf you care about performance, dump [[String Buffer]] and write your own version which doesn't have so many synchronized methods.  There are a pile of bug reports filed with Sun about this; I've found that this can make string concatenation at least an order of magnitude faster.  If you can take a risk, have your [[Fast String Buffer]] provide direct access to its char array too if you need that.  Shame Java lacks const. -- [[James Dennett]]",
      "id": "ce53dbb04c8ea4db62716c88cdda5d7b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "\nThis really blows my mind. Everywhre, everywhere, everywhere, I see Java literature advising me to use [[String Buffers]] everywhere because they're \"much faster\". Just this week, I saw it in a \"performance tips\" column. [[Together Soft]] IDE has a code audit facility that flags string concatenations as a potential performance problem. I actually performed the compilation / disassembly myself because I couldn't believe that so many Java experts could be so wrong. What do you know. They're wrong.",
      "id": "446d0bb50dce4a327759dee2ddd4b67f"
    },
    {
      "type": "html",
      "text": "\nMoral of the story: Java experts are all sheep. The emperor has no clothes.",
      "id": "49159fdcbacfba82f1d91c31d2eb03a1"
    },
    {
      "type": "html",
      "text": "\nNot quite, see [[String Buffer Example Take Three]]",
      "id": "d9327eb1eef6af900323f920820aa7c3"
    },
    {
      "type": "html",
      "text": "\nThe upshot is that the compiler doesn't perform the usual '+' to stringbuf optimization in more complex situations, and that's where it can make a huge difference.",
      "id": "598998a322118b6708cce8693ca91768"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "As mentioned above, appending non-final primitive types to String/[[String Buffer]] results in call to String.valueOf() for the primitive value, which creates a new String. That's 2 object allocations per primitive type append, which really hurts when you've got a lot to append!",
      "id": "8d4741c0dee349bfb18b6e098a472f43"
    },
    {
      "type": "html",
      "text": "\nIn fact, it get's worse. Looking at integers, String.valueOf(int) calls Integer.toString(int), which allocates a local char array and eventually a new String, so that's possibly 3 object allocations (one for the array, 2 for the string - strings constructed from char arrays don't share the array). Profiling JDBC and other systems doing a lot of text to number conversion has shown that this can be a real performance bottleneck.",
      "id": "a53e6acfc00f49a26142a6c8a4a381b6"
    },
    {
      "type": "html",
      "text": "\nDoes anyone know of an implementation of a [[Fast String Buffer]] that doesn't require any object creation for appends/inserts, of course, apart from when the buffer itself has to grow?",
      "id": "695337e268297edb5a390d7b6bb993cc"
    },
    {
      "type": "html",
      "text": "(A small aside: the author of Integer.toString(int) seems to have gone to a lot of trouble to make the conversion fast (using tables to convert base 10 radix instead of divides) - surely all that is going to be negligible compared to the object allocation overhead? Or is object allocation so fast these days that we don't need to worry about it and the associated garbage collection?)",
      "id": "bf4ca5d5d1626538fac8b515be0a5565"
    },
    {
      "type": "html",
      "text": "-- Mat [[Mc Gowan]]\nmailto:mdm@revival.force9.co.uk",
      "id": "2e0f1395a4608eb7afc6427282bb306d"
    },
    {
      "type": "html",
      "text": "<i>In a garbage-collected environment, object allocation overhead can be extremely cheap, as you say.  Consider a stop-the-world compacting collector: after each GC, all the live objects are squished together at one end of the heap.  Allocating an object is then almost as simple as adding the size to the \"next object\" pointer, checking for overflow, and initializing the fields of the object.  Some extra stuff might need to be done to handle threads (each thread having its own newspace, for example).  In a JIT environment, initialization can sometimes be optimized away.</i>",
      "id": "99d7298a6b8dfc392382ac1b444aae69"
    },
    {
      "type": "html",
      "text": "\nThough the more you allocate, the more you have to stop-and-copy, so you're still paying eventually.",
      "id": "fa71e7a11f82edec1cad48f4d158af4c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": ".Net [[String Builder]] further optimizes the [[String Buffer]].T<b></b>oString() operation, by simply using the [[String Builder]] Char array in order to build the string.  This means that you don't have to create unnecessary garbage.  If you then continue to update the [[String Builder]], it will make a copy of the Char array.  So that you effectively get a string that is mutable while under the control of [[String Builder]], but then becomes immutable after T<b></b>oString.  (The semantics are the identical to Java's [[String Buffer]], its just a cool optimization that I do not think java.lang makes.  Your own [[Fast String Buffer]] cannot do this due to java.lang being sealed.)",
      "id": "d78e45fd45ce8959cd0f6258185810ac"
    },
    {
      "type": "html",
      "text": "\nAlso, a .Net string is one object, whereas a Java string is two objects (the class and the array) -- important for such a common object.",
      "id": "5d79a62c972ebdd5ca4504d5238ef03a"
    },
    {
      "type": "html",
      "text": "\nIt would be interesting to do timings to see what difference this really makes.",
      "id": "80ca23065ed23e993a38b9cec1419ba9"
    },
    {
      "type": "html",
      "text": "\nAnthony Berglas",
      "id": "0fbb0863645841d1a91a64fe5181bc84"
    },
    {
      "type": "html",
      "text": "<i>Actually java.lang.[[String Buffer]] performs the same optimization. And even better, according to [http://java.sun.com/developer/community/chat/JavaLive/2003/jl0729.html java.sun.com] Java 1.5 will have unsynchronized java.lang.[[String Builder]] as well. The new [[String Builder]] will also be used by the compiler to optimize String-concatenations.</i>",
      "id": "5263e5ff19c53682f150f0220e2f0edf"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "Are we missing the real problem with String and String Buffer?  Why must the compiler and JVM expose these internal implementation issues to the programmer?  When assigning a new value to an existing string, the JVM can do whatever it wants as long as when I ask for its value later, it gives the correct value.  I don't care whether it created a new object off a heap, it reused an existing chunk of memory, or it reused the same object memory which already had space for an expanded value.",
      "id": "50d82d697b5afcded6db0bdad45efe96"
    },
    {
      "type": "html",
      "text": "\nAfter all, the compiler can see a string append operation inside of a loop.  Use C#.Net in Visual Studio 2005 to get source code analysis that warns you to use a [[String Builder]] instead of a string.  Therefore, this same logic could be put into a compiler so the programmer need not be concerned.  If fine tuning performance is the issue, the syntax should allow the programmer to provide usage information.",
      "id": "082f68ffae94ceb150b3553c5d55ea2b"
    },
    {
      "type": "html",
      "text": " <i>These optimizations <b>are</b> handled by the compiler, just not the first one that translates the source to byte code.  That compiler is more of a translator that tries to keep the byte code simple.  The run-time compiler (such as [[Hot Spot]]) performs the serious optimizations.  Usage information is gathered from actual usage and applied as needed.  The programmer doesn't need to worry about it, nor do they need to provide usage hints.</i>",
      "id": "b3c8075cc2915894c2b912786d456621"
    },
    {
      "type": "html",
      "text": "\nTo illustrate, the following three strings can be stored in the same overlapping memory--if the compiler so chooses:",
      "id": "8e39229588914d8e9a34f102a264587c"
    },
    {
      "type": "code",
      "text": "  string a = \"foo\";\n  string b = a + \"bar\";\n  string c = a.substring(1,1);",
      "id": "4401e06e02244fb5e55cf54974aa5da9"
    },
    {
      "type": "html",
      "text": "\nI am ignoring the situation of comparing object addresses (pointers) of strings.  I need to think more about that.",
      "id": "3a9a9bf28844a30bc86e1f39b3265d3a"
    },
    {
      "type": "html",
      "text": "-- [[Dave Eaton]]",
      "id": "5c33fd79d34d2e7c28b7fd5721a78919"
    },
    {
      "type": "html",
      "text": "\nComparing object addresses of strings has no meaning in Java.",
      "id": "b3440fcc5e4f95af261b7333bc3a8e52"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
    },
    {
      "type": "html",
      "text": "[[Category Java]]",
      "id": "dc3fd3f137e2d006f9bfdeb4dfc956fb"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?StringBuffer c2.com]",
      "id": "dba343c332f0ac626a60e65d96e862f5"
    }
  ],
  "journal": [
    {
      "date": 1412660047000,
      "id": "cdc3149dac43a1da59bd5f6d74ccf807",
      "type": "create",
      "item": {
        "title": "String Buffer",
        "story": [
          {
            "type": "html",
            "text": "See also [[String Builder]] which should be your first choice for most usages in Java since 1.5 (see also below).",
            "id": "96f9f2528ebbec9451c7c9718d65e1d0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "\njava.lang.[[String Buffer]] is a class in the Java runtime library.  ",
            "id": "c22a8bb7505466cb2ecc7369fdfaed8c"
          },
          {
            "type": "html",
            "text": " [http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/StringBuffer.html docs.oracle.com]",
            "id": "610543aaa2de958bdeaa75aa5fd12351"
          },
          {
            "type": "html",
            "text": "\nIt provides a convenient way to concatenate strings together:",
            "id": "b723deda71a36deeec52e76b7999c116"
          },
          {
            "type": "code",
            "text": "  StringBuffer buffer = new StringBuffer();\n  buffer.append (\"foo\");\n  buffer.append (\" \");\n  buffer.append (\"bar\");\n  String s = buffer.toString();\n  System.out.println (s);",
            "id": "fc58c37dc1d12949c5724d56759d117f"
          },
          {
            "type": "code",
            "text": "  ''foo bar''",
            "id": "7e9bd76abfd525b305314162b1a22d65"
          },
          {
            "type": "html",
            "text": "\nUgly?  Don't worry -- when you use the + operator and either of the operands is a String, Java uses a [[String Buffer]] behinds the scenes.  The above is equivalent to:",
            "id": "c2b2124fff64e64080187c3331776a3b"
          },
          {
            "type": "code",
            "text": "  String s = \"foo\" + \" \" + \"bar\";\n  System.out.println (s);",
            "id": "e5fcbd6418d02bddb8fd6aa0509b3374"
          },
          {
            "type": "code",
            "text": "  ''foo bar''",
            "id": "7e9bd76abfd525b305314162b1a22d65"
          },
          {
            "type": "html",
            "text": "\nContributors: [[Wayne Conrad]]",
            "id": "a93a8f3f344c659c6e86bc2a40843987"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "Q: I thought the \"nice\" version created a lot of garbage \"String\"s. Since Strings are immutable [[Value Object]]s and the + operation returns a String, the only option is to create another String...",
            "id": "f984cc9e9f16659995a727c92a6d5ff2"
          },
          {
            "type": "html",
            "text": "\nA: It's implementation dependent, but the reference implementation (JDK) does optimize away the garbage Strings.",
            "id": "7c2bebd316f967a50a8172ace7138afd"
          },
          {
            "type": "html",
            "text": "\nFrom the Java Language Spec version 1.0:",
            "id": "fd8b20ca2a4480dabd62ebcf37526c05"
          },
          {
            "type": "html",
            "text": "15.17.1.2 Optimization of String Concatenation",
            "id": "81ac9c733d423cbf1190a05d4df97bcd"
          },
          {
            "type": "html",
            "text": "An implementation may choose to perform conversion and concatenation in one step to avoid creating and then discarding an intermediate String object. To increase the performance of repeated string concatenation, a Java compiler may use the [[String Buffer]] class (ยง20.13) or a similar technique to reduce the number of intermediate String objects that are created by evaluation of an expression.",
            "id": "e6f07ef86fb8e889cad036e569744af0"
          },
          {
            "type": "html",
            "text": "For primitive objects, an implementation may also optimize away the creation of a wrapper object by converting directly from a primitive type to a string.",
            "id": "d64f4af124c165393f373bf37dcd6fbc"
          },
          {
            "type": "html",
            "text": "\nThe JDK does the [[String Buffer]] optimization, so that + creates no extra String temporaries (compared to just using [[String Buffer]] yourself).  Furthermore, the compiler is allowed to perform String concatenation at compile time for <i>final</i> variables, and the JDK does.",
            "id": "c41b9aebbf4475a5310e559beed475e4"
          },
          {
            "type": "html",
            "text": "\nLet's disassemble some code and see what it actually does.  I'll use JDK 1.2.2.  The compile command is \"javac -O <filename>\", and the disassembly command is \"javap -c <classname>\".",
            "id": "399c96f5f5b6dff81aac86a2e845023e"
          },
          {
            "type": "html",
            "text": "<b>+ with final variables</b>",
            "id": "62468dedbc9de93d1eedbe96c760ea3d"
          },
          {
            "type": "code",
            "text": "  public void plusWithFinals() {\n  final String a = \"abc\";\n  final int i = 2;\n  final double d = 3.4;\n  String s = a + i + d;\n  }",
            "id": "23be737cea1f356803aef10a23249b75"
          },
          {
            "type": "code",
            "text": "  Method void plusWithFinals()\n  0 ldc #1 <String \"abc\">\n  2 astore_1\n  3 iconst_2\n  4 istore_2\n  5 ldc2_w #15 <Double 3.4>\n  8 dstore_3\n  9 ldc #2 <String \"abc23.4\">\n  11 astore 5\n  13 return",
            "id": "4c89c26fcc7f71859d3427fae3ed9b59"
          },
          {
            "type": "html",
            "text": "\nThe compiler has cleverly done the concatenation at compile time.  It can do this since we declared the variables <i>final</i>.",
            "id": "678b8826a02eb02b6563e0f65f259c2d"
          },
          {
            "type": "html",
            "text": "<b>+ with non-final variables</b>",
            "id": "f6fca3139fde7f24ff7c4fe7e69f4c64"
          },
          {
            "type": "code",
            "text": "  public void plus() {\n  String a = \"abc\";\n  int i = 2;\n  double d = 3.4;\n  String s = a + i + d;\n  }",
            "id": "a9536205336ff0d0614b713648082009"
          },
          {
            "type": "code",
            "text": "  Method void plus()\n  0 ldc #1 <String \"abc\">\n  2 astore_1\n  3 iconst_2\n  4 istore_2\n  5 ldc2_w #15 <Double 3.4>\n  8 dstore_3\n  9 new #6 <Class java.lang.StringBuffer>\n  12 dup\n  13 aload_1\n  14 invokestatic #14 <Method java.lang.String valueOf(java.lang.Object)>\n  17 invokespecial #9 <Method java.lang.StringBuffer(java.lang.String)>\n  20 iload_2\n  21 invokevirtual #11 <Method java.lang.StringBuffer append(int)>\n  24 dload_3\n  25 invokevirtual #10 <Method java.lang.StringBuffer append(double)>\n  28 invokevirtual #13 <Method java.lang.String toString()>\n  31 astore 5\n  33 return",
            "id": "0ee0831aec0b20a599aed7621f6f2006"
          },
          {
            "type": "html",
            "text": "\nThe compiler used a [[String Buffer]] to avoid creating lots of temporaries.  The call to \"valueOf\" is interesting: valueOf returns a string representation of an object.  Since \"a\" is already a String, why did the compiler call valueOf on it?",
            "id": "a6dbae28328010694928adf8d0e291bf"
          },
          {
            "type": "html",
            "text": "<b>[[String Buffer]]</b>",
            "id": "97c0caa7563673c28ec6d963f8fd079f"
          },
          {
            "type": "code",
            "text": "  public void useStringBuffer() {\n  String a = \"abc\";\n  int i = 2;\n  double d = 3.4;\n  StringBuffer buffer = new StringBuffer();\n  buffer.append(a);\n  buffer.append(i);\n  buffer.append(d);\n  String s = buffer.toString();\n  }",
            "id": "15ddb264f875055b48a0915f30159a0c"
          },
          {
            "type": "code",
            "text": "  Method void useStringBuffer()\n  0 ldc #1 <String \"abc\">\n  2 astore_1\n  3 iconst_2\n  4 istore_2\n  5 ldc2_w #15 <Double 3.4>\n  8 dstore_3\n  9 new #6 <Class java.lang.StringBuffer>\n  12 dup\n  13 invokespecial #8 <Method java.lang.StringBuffer()>\n  16 astore 5\n  18 aload 5\n  20 aload_1\n  21 invokevirtual #12 <Method java.lang.StringBuffer append(java.lang.String)>\n  24 pop\n  25 aload 5\n  27 iload_2\n  28 invokevirtual #11 <Method java.lang.StringBuffer append(int)>\n  31 pop\n  32 aload 5\n  34 dload_3\n  35 invokevirtual #10 <Method java.lang.StringBuffer append(double)>\n  38 pop\n  39 aload 5\n  41 invokevirtual #13 <Method java.lang.String toString()>\n  44 astore 6\n  46 return",
            "id": "37c79c0d95c4e3337fc95b53a314db6c"
          },
          {
            "type": "html",
            "text": "\nThis is very close to what the compiler generated when we used +.  No extra stack temporaries are being created.  The extra code is from the \"pop/aload 5\" pairs that the compiler did not generate for the \"+\" case.  But these certainly aren't the performance killer that extra string temporaries might be.",
            "id": "0f16fd80692831e1618d5224cb722ab3"
          },
          {
            "type": "html",
            "text": "\nStrangely, the gratuiotous call to valueOf that the compiler inserted when we used + isn't generated when we use [[String Buffer]].",
            "id": "1bbe5e2f18a603ca348d0aa47ef22da0"
          },
          {
            "type": "html",
            "text": "-- [[Wayne Conrad]]",
            "id": "8422c518467d4d91ecbbdc9860136b45"
          },
          {
            "type": "html",
            "text": "\nWayne, you [[Utter Bastard]]. -- Redundant author of [[String Buffer Example]]",
            "id": "10ebcfcf7f6ed1b1f8daf43ccd9684e9"
          },
          {
            "type": "html",
            "text": "\nI saw that!  It made me laugh that we both did this and at almost exactly the same time.",
            "id": "327caf3d7f7152efc1bd825304b43036"
          },
          {
            "type": "html",
            "text": "\nI like that you ran timing tests.  How would you prefer to merge our results?  Or should we keep yours?  Looks like you used a different platform than me, and that's valuable.  --[[Wayne Conrad]]",
            "id": "6c5d5610e79b6decefe4b667f6a04805"
          },
          {
            "type": "html",
            "text": "\nVery amusing timing, nice to see that someone else is as much a victim of curiosity as myself :-). I used Linux JDK 1.2.2 (the copy Sun distributes, I think) without a JIT. It would be nice to merge the results, though it's way past my bedtime so for the moment I've just put the code I used on the web: [http://www.javagroup.org/luke/string.java www.javagroup.org] is the java source, [http://www.javagroup.org/luke/string.jsm www.javagroup.org] is the jasmin-syntax assembler code. -- [[Luke Gorrie]]",
            "id": "17e4f16e04f535879db8d57b8c5af579"
          },
          {
            "type": "html",
            "text": "\nHave a nice sleep.  Things to do to this page:",
            "id": "f5f80712ddccf69edb586a7da864de6f"
          },
          {
            "type": "html",
            "text": " Add the timing test",
            "id": "8ddde66cd5d86dc2ce631ac4ca58575f"
          },
          {
            "type": "html",
            "text": " Fix the examples at the top of the page (As you pointed out, examples should use variables to prevent the compiler from doing the concatenation at compile time)>",
            "id": "3f62d48a8971cd884058bcc1f7fbb06a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "\nHas anyone taken the initiative on this to test other compilers? The above bytecodes are all generated by javac from 1.2.2.  Let me think, I've used all of the following: [[Jikes Compiler]], the compiler packaged with Visual Age, the JBuilder JDK compiler, JDK 1.1.6, JDK 1.1.8, JDK 1.3 (from Sun), jdk 1.1.8 for Linux from Blackdown, JDK 1.2 for Linux from Blackdown, JDK for Linux from IBM.  Whew! The point being, just because one compiler <i>does</i> optimize away the differences, is that behavior something we should count on?",
            "id": "199f0bfbabbbf08170643d12206a2c42"
          },
          {
            "type": "html",
            "text": "-- [[Steven Newton]]",
            "id": "7b302200fd86395ad620c1f38dfd74b2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "I think the core insight of [[String Buffer]] is that most of the time strings can and should be immutable. When you want them to be mutable, use a separate class. I mention this because it is something the C++ STD library got wrong. They have a single mutable string class, and they have a devil of a job getting the implementation both correct and efficient, especially in the face of multi-threading and reference-counted behind-the-scenes sharing. They should have made strings immutable and added a mutable [[String Buffer]] class. -- [[Dave Harris]]",
            "id": "2eba3ea8524e031485669df0d16b9d76"
          },
          {
            "type": "html",
            "text": "<i>Does anyone besides me use [[String Buffer]] instances in Java where they would use instances of Stream (on a String) in Smalltalk? I keep looking for the analogous abstraction in Java: a decorator on an array that lets me iterate through it (using next), peek at it (looking at values without changing the current position), append things to the end, and so forth. I always seem to bounce around between \"Iterator\", \"Vector\" and \"[[String Buffer]]\" in Java -- but I don't know the toolbox that well yet. -- [[Tom Stambaugh]]</i>",
            "id": "57afcd7849fa4444421989ca7835cd31"
          },
          {
            "type": "html",
            "text": "\nHave you looked at [[String Reader]]/[[String Writer]]? -- [[Steven Newton]]\nOr [[String Tokenizer]] and [[Stream Tokenizer]]? --[[Nat Pryce]]",
            "id": "3c5aff52740aa32ba8212595dd17de15"
          },
          {
            "type": "html",
            "text": "<i>Yes, I started there ([[String Reader]]/[[String Writer]]). They're really doing something different, though. [[String Reader]] reads into a char[] -- I'm looking for a \"next\" operation that returns a string. I want to work with instances of String -- not chars, char arrays, and so forth. For example, I want to pass a String to #put and get back a string from #next (and similarly for #peek and #poke).</i>",
            "id": "a3c022012d8c85fd61fffb433f314e5c"
          },
          {
            "type": "html",
            "text": "<i>The next thing is that operations on String and File instances should, from the client's perspective, be nearly transparent -- when I want to leave behind a permanent file, I open a \"Stream\" on a filename. From the caller's side, the API is the same. That way, I can write a set of utilities that does the work and then pass along a Stream on a String for temporary operations and a Stream on a File for more permanent ones. Does this help clarify my desire? Thanks -- [[Tom Stambaugh]]</i>",
            "id": "2e784f90ce92bc02dc3c39981c05e39e"
          },
          {
            "type": "html",
            "text": "\nWhat about [[Object Output Stream]] and [[Object Input Stream]]? You can use these in conjunction with [[Print Stream]]. Honestly, though, it just seems like you want a List collection such as [[Linked List]]. You could even implement your own List that uses a [[String Buffer]] as its contents in the case where you'd want the result to be a concatenated string instead of a collection of strings. It's hard to advise without some examples of how you'd like to use it. --[[Robert Di Falco]]",
            "id": "2d8aab2a333f92c1d830f86dfbaba51f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "\nHere's how to use String<b></b>Writer to do what ostrstream does in C++.\nIn the JDK, at least, String<b></b>Writer uses String<b></b>Buffer, so\nthis gives you a fairly friendly way to use String<b></b>Buffer.\nWrapping the String<b></b>Writer in a Print<b></b>Writer\ngives you the usual print and println methods.",
            "id": "abfe72a8f3a87a0ec280a4706fc4889d"
          },
          {
            "type": "code",
            "text": "  public String toString()\n  {\n  String''''''Writer stringWriter = new String''''''Writer();\n  Print''''''Writer out = new Print''''''Writer (stringWriter);\n  out.print (\"[name='\" + name + \"'\");\n  out.print (\" age=\" + age);\n  out.print (\" gender=\" + gender);\n  out.print (\"]\");\n  return stringWriter.toString();\n  }",
            "id": "16fb8b2ba1066c6e4c3b200bd64fa1e0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "\nThe String vs. [[String Buffer]] debate is not, as the author of the string.java class assumes, that using 1 [[String Buffer]] is faster than using 1 String.  Rather, it is that calling append() many times is faster than using concatenation many times.  I've posted a test that reflects this at [http://www.users.uswest.net/~jgregg3/StringTest.java www.users.uswest.net]  Sun's JDK 1.2.2 for NT takes around 1700ms and 424592 bytes of memory in my String test.  Doing the same thing with 1 [[String Buffer]] and many calls to append() takes 16ms and 74544 bytes.  There were similar large differences using 1.2.2 on LinuxPPC.  The practical import of this is that applications that do large amounts of String concatenation, like dynamic SQL builders or text file parsers, should be switched to use [[String Buffer]].",
            "id": "346bc525c8cfeee945b3a385e50267f4"
          },
          {
            "type": "html",
            "text": "--john gregg\nmailto:jgregg1@uswest.net",
            "id": "8554625109d71d4043f51677bd0e5f2e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "\nFirst comment:",
            "id": "8fccd08e49162692ff5a0e15ae65c6a7"
          },
          {
            "type": "html",
            "text": "\nYou can get rid of the extra pop/aload 5 pairs in the bytecode by\nusing the following code instead:",
            "id": "896354888c942faac700726c4acd6719"
          },
          {
            "type": "code",
            "text": "  public void useStringBuffer() {\n  String a = \"abc\";\n  int i = 2;\n  double d = 3.4;\n  String s = new StringBuffer().append(a).append(i).append(d).toString();\n  }",
            "id": "1aee2f981068812c4c9b01e8412ca748"
          },
          {
            "type": "html",
            "text": "\nNote that this is using the result of the append() method",
            "id": "1c316daf5fb0fa4e54057d979aa99d3c"
          },
          {
            "type": "html",
            "text": "(which returns the [[String Buffer]] instance)\ninstead of a local variable reference.",
            "id": "cf90759c326414be7d4323ecaf62015e"
          },
          {
            "type": "html",
            "text": "\nI actually think that this is atrocious coding style;\nmethods should not always return a predetermined argument or <i>this</i>.\nSuch a return encourages the programmer to use the return value,\nactively defeating any compile-time",
            "id": "2ec00ae75833247ee4f644ed69cd80f6"
          },
          {
            "type": "html",
            "text": "(or, in the case of Java, JIT-time)\noptimizations for things like null pointer checks.\nSince the compiler is not told that the return value can never be null,\nit has to make the null check each time you use a method on the return value,\ninstead of being able to make that check once and then be sure",
            "id": "43fd53ee6ef6f4651371c440024dd1f7"
          },
          {
            "type": "html",
            "text": "(since nothing else can reference the local variable)\nthat the value hasn't become null in the course of the method call.",
            "id": "354eafc4df3b2b6a76c2315b8a5e2ce6"
          },
          {
            "type": "html",
            "text": "\nSecond comment:",
            "id": "677e8ec262426b05b5b42ad20009feff"
          },
          {
            "type": "html",
            "text": "\nMicrosoft's JVC uses String.concat() instead of [[String Buffer]].\nWhether this is more or less efficient than using [[String Buffer]]\ndepends highly on the underlying implementation of both those classes.\nIt does produce marginally shorter bytecode",
            "id": "5de1e0c0b30b26895604383c569b0a8a"
          },
          {
            "type": "html",
            "text": "(no initialization of a [[String Buffer]] or calling of toString()),\nfor whatever good that's worth.",
            "id": "664f6e75cb10a1b48ae82b757b250193"
          },
          {
            "type": "html",
            "text": "-- [[Alex Popiel]]",
            "id": "1fd908ded06df8e27fe5406c27510f3e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "\nIf you care about performance, dump [[String Buffer]] and write your own version which doesn't have so many synchronized methods.  There are a pile of bug reports filed with Sun about this; I've found that this can make string concatenation at least an order of magnitude faster.  If you can take a risk, have your [[Fast String Buffer]] provide direct access to its char array too if you need that.  Shame Java lacks const. -- [[James Dennett]]",
            "id": "ce53dbb04c8ea4db62716c88cdda5d7b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "\nThis really blows my mind. Everywhre, everywhere, everywhere, I see Java literature advising me to use [[String Buffers]] everywhere because they're \"much faster\". Just this week, I saw it in a \"performance tips\" column. [[Together Soft]] IDE has a code audit facility that flags string concatenations as a potential performance problem. I actually performed the compilation / disassembly myself because I couldn't believe that so many Java experts could be so wrong. What do you know. They're wrong.",
            "id": "446d0bb50dce4a327759dee2ddd4b67f"
          },
          {
            "type": "html",
            "text": "\nMoral of the story: Java experts are all sheep. The emperor has no clothes.",
            "id": "49159fdcbacfba82f1d91c31d2eb03a1"
          },
          {
            "type": "html",
            "text": "\nNot quite, see [[String Buffer Example Take Three]]",
            "id": "d9327eb1eef6af900323f920820aa7c3"
          },
          {
            "type": "html",
            "text": "\nThe upshot is that the compiler doesn't perform the usual '+' to stringbuf optimization in more complex situations, and that's where it can make a huge difference.",
            "id": "598998a322118b6708cce8693ca91768"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "As mentioned above, appending non-final primitive types to String/[[String Buffer]] results in call to String.valueOf() for the primitive value, which creates a new String. That's 2 object allocations per primitive type append, which really hurts when you've got a lot to append!",
            "id": "8d4741c0dee349bfb18b6e098a472f43"
          },
          {
            "type": "html",
            "text": "\nIn fact, it get's worse. Looking at integers, String.valueOf(int) calls Integer.toString(int), which allocates a local char array and eventually a new String, so that's possibly 3 object allocations (one for the array, 2 for the string - strings constructed from char arrays don't share the array). Profiling JDBC and other systems doing a lot of text to number conversion has shown that this can be a real performance bottleneck.",
            "id": "a53e6acfc00f49a26142a6c8a4a381b6"
          },
          {
            "type": "html",
            "text": "\nDoes anyone know of an implementation of a [[Fast String Buffer]] that doesn't require any object creation for appends/inserts, of course, apart from when the buffer itself has to grow?",
            "id": "695337e268297edb5a390d7b6bb993cc"
          },
          {
            "type": "html",
            "text": "(A small aside: the author of Integer.toString(int) seems to have gone to a lot of trouble to make the conversion fast (using tables to convert base 10 radix instead of divides) - surely all that is going to be negligible compared to the object allocation overhead? Or is object allocation so fast these days that we don't need to worry about it and the associated garbage collection?)",
            "id": "bf4ca5d5d1626538fac8b515be0a5565"
          },
          {
            "type": "html",
            "text": "-- Mat [[Mc Gowan]]\nmailto:mdm@revival.force9.co.uk",
            "id": "2e0f1395a4608eb7afc6427282bb306d"
          },
          {
            "type": "html",
            "text": "<i>In a garbage-collected environment, object allocation overhead can be extremely cheap, as you say.  Consider a stop-the-world compacting collector: after each GC, all the live objects are squished together at one end of the heap.  Allocating an object is then almost as simple as adding the size to the \"next object\" pointer, checking for overflow, and initializing the fields of the object.  Some extra stuff might need to be done to handle threads (each thread having its own newspace, for example).  In a JIT environment, initialization can sometimes be optimized away.</i>",
            "id": "99d7298a6b8dfc392382ac1b444aae69"
          },
          {
            "type": "html",
            "text": "\nThough the more you allocate, the more you have to stop-and-copy, so you're still paying eventually.",
            "id": "fa71e7a11f82edec1cad48f4d158af4c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": ".Net [[String Builder]] further optimizes the [[String Buffer]].T<b></b>oString() operation, by simply using the [[String Builder]] Char array in order to build the string.  This means that you don't have to create unnecessary garbage.  If you then continue to update the [[String Builder]], it will make a copy of the Char array.  So that you effectively get a string that is mutable while under the control of [[String Builder]], but then becomes immutable after T<b></b>oString.  (The semantics are the identical to Java's [[String Buffer]], its just a cool optimization that I do not think java.lang makes.  Your own [[Fast String Buffer]] cannot do this due to java.lang being sealed.)",
            "id": "d78e45fd45ce8959cd0f6258185810ac"
          },
          {
            "type": "html",
            "text": "\nAlso, a .Net string is one object, whereas a Java string is two objects (the class and the array) -- important for such a common object.",
            "id": "5d79a62c972ebdd5ca4504d5238ef03a"
          },
          {
            "type": "html",
            "text": "\nIt would be interesting to do timings to see what difference this really makes.",
            "id": "80ca23065ed23e993a38b9cec1419ba9"
          },
          {
            "type": "html",
            "text": "\nAnthony Berglas",
            "id": "0fbb0863645841d1a91a64fe5181bc84"
          },
          {
            "type": "html",
            "text": "<i>Actually java.lang.[[String Buffer]] performs the same optimization. And even better, according to [http://java.sun.com/developer/community/chat/JavaLive/2003/jl0729.html java.sun.com] Java 1.5 will have unsynchronized java.lang.[[String Builder]] as well. The new [[String Builder]] will also be used by the compiler to optimize String-concatenations.</i>",
            "id": "5263e5ff19c53682f150f0220e2f0edf"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "Are we missing the real problem with String and String Buffer?  Why must the compiler and JVM expose these internal implementation issues to the programmer?  When assigning a new value to an existing string, the JVM can do whatever it wants as long as when I ask for its value later, it gives the correct value.  I don't care whether it created a new object off a heap, it reused an existing chunk of memory, or it reused the same object memory which already had space for an expanded value.",
            "id": "50d82d697b5afcded6db0bdad45efe96"
          },
          {
            "type": "html",
            "text": "\nAfter all, the compiler can see a string append operation inside of a loop.  Use C#.Net in Visual Studio 2005 to get source code analysis that warns you to use a [[String Builder]] instead of a string.  Therefore, this same logic could be put into a compiler so the programmer need not be concerned.  If fine tuning performance is the issue, the syntax should allow the programmer to provide usage information.",
            "id": "082f68ffae94ceb150b3553c5d55ea2b"
          },
          {
            "type": "html",
            "text": " <i>These optimizations <b>are</b> handled by the compiler, just not the first one that translates the source to byte code.  That compiler is more of a translator that tries to keep the byte code simple.  The run-time compiler (such as [[Hot Spot]]) performs the serious optimizations.  Usage information is gathered from actual usage and applied as needed.  The programmer doesn't need to worry about it, nor do they need to provide usage hints.</i>",
            "id": "b3c8075cc2915894c2b912786d456621"
          },
          {
            "type": "html",
            "text": "\nTo illustrate, the following three strings can be stored in the same overlapping memory--if the compiler so chooses:",
            "id": "8e39229588914d8e9a34f102a264587c"
          },
          {
            "type": "code",
            "text": "  string a = \"foo\";\n  string b = a + \"bar\";\n  string c = a.substring(1,1);",
            "id": "4401e06e02244fb5e55cf54974aa5da9"
          },
          {
            "type": "html",
            "text": "\nI am ignoring the situation of comparing object addresses (pointers) of strings.  I need to think more about that.",
            "id": "3a9a9bf28844a30bc86e1f39b3265d3a"
          },
          {
            "type": "html",
            "text": "-- [[Dave Eaton]]",
            "id": "5c33fd79d34d2e7c28b7fd5721a78919"
          },
          {
            "type": "html",
            "text": "\nComparing object addresses of strings has no meaning in Java.",
            "id": "b3440fcc5e4f95af261b7333bc3a8e52"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4ccd317dcccc278a1f3ebf7104a6b30"
          },
          {
            "type": "html",
            "text": "[[Category Java]]",
            "id": "dc3fd3f137e2d006f9bfdeb4dfc956fb"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?StringBuffer c2.com]",
            "id": "dba343c332f0ac626a60e65d96e862f5"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1702055218751
    }
  ]
}