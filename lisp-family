{
  "title": "Lisp Family",
  "story": [
    {
      "type": "html",
      "text": "Originally, the term <i>Lisp</i> referred to the language which was the brainchild of [[John Mc Carthy]].",
      "id": "f29d3d353222eda702ff39cb182f704d"
    },
    {
      "type": "html",
      "text": "\nNowadays, when unspecified, the term <i>Lisp</i> either refers to <i>[[Common Lisp]]</i> (a language), or the <i>Lisp family of languages</i>, all of which share the [[Lambda Nature]] (see [[Language Families]]). ",
      "id": "435d695daa956e94b4c5954ffe824293"
    },
    {
      "type": "html",
      "text": "\nA less strict criterion for inclusion of a language into the [[Lisp Family]] is the use of parenthesized lists to represent a program, and manipulation of lists made of two-field cells that can be manufactured and connected by a function called CONS (see [[Cons Cell]]s). It's somewhat of a custom that whenever someone writes a one-weekend interpreter for such a language, it is given a name that includes the word \"Lisp\". (Never heard of that - where is that?) Much newbie confusion arises from all of the different things that are called Lisp but have nothing to do with the mature, complex, super-powerful [[Common Lisp]], which, as the result of the combined efforts of the dominating lisp communities, is seen by many as the only thing that should be called Lisp (see [[The Evolution Of Lisp]]).",
      "id": "405e15fc12561b794694fe969c8092e6"
    },
    {
      "type": "html",
      "text": "'SEXP-Syntax is neither sufficient nor necessary' for a Lisp dialect.",
      "id": "b3e33e2292ea1dd339bf39ecf493e2e4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a9f51d200d84fa63207961f8270fdb2c"
    },
    {
      "type": "html",
      "text": "The sharing of the CONS function is something I borrowed from a paper by [[Kent Pitman]] in which he tries to pin down what exactly makes something Lisp. (See [http://www.nhplace.com/kent/PS/Lambda.html www.nhplace.com]. Also see [[Parenthetically Speaking]].) \nThere, he also argues that there is no lambda commonality among things calling themselves Lisp; the syntax varies - some things don't have lexical closures, others closures that can only be passed down, not returned, etc. [[Lambda Nature]] cannot exist without lexical scoping, so that the [[Lambda Expression]] creates a function-object that has captured the lexical bindings.",
      "id": "501415eac1b413decf921001c3880eac"
    },
    {
      "type": "html",
      "text": " Why is [[Lambda Nature]] dependent on lexical scoping, given that lambda is so much older than Lisp lexical scoping?",
      "id": "2cf5850d73fbc85702d646a646f260f2"
    },
    {
      "type": "html",
      "text": "\nBut note that I disagree with this paper on the whole; Pitman believes that there is a [[Lisp Family]], but that it arises out of some vague cultural connections rather than any specific language features. I view myself strictly as a [[Common Lisp]] user, and nothing more. I stay away from anything else that resembles Lisp, and don't feel that I belong to any broader community. Communities based on sharing a programming language are a fiction. Two people who don't know each other at all, but just happen to use the same programming language, text editor, operating system or whatever, are not automatically a community! That they can be is just some touchy-feely thinking thinking that might be called [[Techno Collectivism]]. Or maybe it's a spinoff idea from [[Brand Identification]] that westerners grow up with. If you drive a certain make of car, you are suddenly a member of the group of people who drive that car, and somehow this is more than just a dry mathematical observation that places you in a set. But really, to have a community, you must have a group of individuals who identify together in some concrete way, and actually know and recognize each other. I might form a community with some CL users, but not all of them at once!",
      "id": "e91cd4461d241dd855801455d9fc4445"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a9f51d200d84fa63207961f8270fdb2c"
    },
    {
      "type": "html",
      "text": "\n[[Paul Graham]] provides another reasoning what defines Lisp. See [http://www.paulgraham.com/diff.html www.paulgraham.com]",
      "id": "27c595626a2dd45db7970f4ba2fcfeeb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a9f51d200d84fa63207961f8270fdb2c"
    },
    {
      "type": "html",
      "text": "\n[[Gerald Sussman]] and [[Guy Steele]] named their dialect Scheme at a time when it was fashionable to give each Lisp dialect their own name (MDL, T, NIL, Conniver, and so on). Note that in the original papers about Scheme, Scheme is always described as a Lisp dialect. Further note that today's Scheme looks remarkably different to the original Scheme. Further further note, that the original Lisp didn't have lexical closures but that they were introduced in a clean way in Scheme. The [[Common Lisp]] designers have taken the [[Lexical Closure]] concept from Scheme. (In turn, lexical closures were first defined in [[Algol Language]].)",
      "id": "ae10f81bc86b22c5cd258692f2c2a466"
    },
    {
      "type": "html",
      "text": "\nThere are many reasons why to prefer [[Common Lisp]] over [[Scheme Language]] (see [[Lisp Scheme Differences]]), and vice-versa, but to describe Scheme as not being a Lisp is as simplistic as to say that Scheme and Lisp are more or less the same. The truth is somewhere in between.",
      "id": "27a2c9c075aae99a45f86c017600badf"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a9f51d200d84fa63207961f8270fdb2c"
    },
    {
      "type": "html",
      "text": "\nI wouldn't care if the Scheme people take over the word Lisp, and the [[Common Lisp]] people then rename their language and stop using the word. The point is that the term is simply too diluted when it takes on too many meanings, and as such it has little value. We can't even agree on what Lisp means; so maybe there is no point in using this word? Yet somehow it seems so coveted that people get ruffled when someone dares suggest that their pet language is not Lisp. Maybe \"Lisp\" is just a synonym for \"cool\". So if you say that some language is not Lisp, you are really saying that it's not cool. Also, because \"cool\" is hard to define, \"Lisp\" is hard to define. Moreover, things that are obviously not Lisp at all are clearly uncool. I can't think of a single counterexample when \"Lisp\" does not mean \"cool\", except when it's used in the name of some concrete language or implementation. AutoLISP doesn't mean AutoCOOL, and Common Lisp doesn't mean Common Cool. But as an adjective, to say that something is Lisp simply means that it has hacker approval.",
      "id": "248b098b503307bedc623c4cbe35faeb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a9f51d200d84fa63207961f8270fdb2c"
    },
    {
      "type": "html",
      "text": "\nOkay, so how about this: Lisp as an adjective means \"cool\". Lisp as a noun that is part of a noun phrase designating a programming language adds the semantic attribute \"language derived from cool ideas\". And used entirely by itself, in the absence of historic context, it means \"ANSI Common Lisp\", where this second occurrence of Lisp is not subject to the cool-substitution, but simply stands for itself. In some proper historic context it means \"the language invented by [[John Mc Carthy]] and peers\". There, it's settled!",
      "id": "dda8ef2b5a6061146485901e4a6ee802"
    },
    {
      "type": "html",
      "text": "---- ",
      "id": "5d6a8e99877c07ac844511fbd632b486"
    },
    {
      "type": "html",
      "text": "<i>So, Lisp == cool? I thought that [[Csharp Language]] == cool! By transitivity, this implies that Lisp == C#</i>",
      "id": "d3b5c26aa9ee72b4cd79b611fc4b9e61"
    },
    {
      "type": "html",
      "text": "<i>Amazing. And all this time I had thought that C#/[[Dot Net]] was little more than a blatant ripoff of Java (both the language and the platform)! Now we find it's really Lisp in disguise!</i>",
      "id": "77b7252248d38cbd03b17ca5df383428"
    },
    {
      "type": "html",
      "text": "<i>So, then why doesn't C# have [[Ess Expressions]]?</i>",
      "id": "fd02a569b76526240eeff74bf7ff3534"
    },
    {
      "type": "html",
      "text": "\nAh, I think your \"==\" operator means, in this context, \"is a member of the set\".",
      "id": "dc401338a03cdfa343a41b48536c44b9"
    },
    {
      "type": "html",
      "text": "<i>No, \"==\" means equality. The development codename for the C# project at Microsoft was \"Cool\", one of the worst-kept secrets of the past couple years. The rest of the above section is tongue-in-cheek</i>",
      "id": "78ff363979928f09a8d657590f91ca86"
    },
    {
      "type": "html",
      "text": "<i>So... when do you think we will see [[Microsoft Visual Lisp]] (or, for that matter, [[Visual Lisp Dot Net]]?????) What will the [[Lisp Hippie]]s do if their favorite language is taken over by the [[Evil Empire]]? I guess it would make writing macros in [[Microsoft Excel]] more fun!</i>",
      "id": "d64ecbbea8f2849a022eeab7b82e75d4"
    },
    {
      "type": "html",
      "text": "<i>-- [[Scott Johnson]]</i>",
      "id": "b37ead8eb50d12fa1f4cd8a8b23b1be2"
    },
    {
      "type": "html",
      "text": "\nWell, long, long ago, there was already an MS Lisp...\n[http://groups.google.com/groups?q=microsoft+lisp&ie=ISO-8859-1&hl=en groups.google.com]",
      "id": "d16373b2b5469b15223f58c1a08855fc"
    },
    {
      "type": "html",
      "text": "<i>There is a Visual Lisp product from Autodesk for use with its popular AutoCAD software. Not surprisingly, the appearance of Visual Lisp coincided with the full-scale conversion of AutoCAD from a cross-platform tool into an application deeply rooted in, and heavily dependent on, the Windows environment (with ActiveX, etc.). -- [[Jeff Read]]</i>",
      "id": "b71d0aea4764fa81409617b336ce3fff"
    },
    {
      "type": "html",
      "text": " I hadn't noticed that it used to be heavily cross-platform. Anyway, just to avoid confusion: [[Auto Cad]] included [[Auto Lisp]] since 1985, and [[Auto Desk]] added the [[Visual Lisp]] programming environment for [[Auto Lisp]] in 1997. [http://courses.home.att.net/autolisp/ahistory.htm courses.home.att.net]",
      "id": "476de2cfe6800445e489c77f229f672f"
    },
    {
      "type": "html",
      "text": "---- ",
      "id": "5d6a8e99877c07ac844511fbd632b486"
    },
    {
      "type": "html",
      "text": "\nA few things that might define some core of Lisp dialects and their typical implementation:",
      "id": "1b6cfb694df9ae54bd396dc47ea7fc74"
    },
    {
      "type": "html",
      "text": " supports functional programming (LAMBDA, higher order functions, anonymous functions, local functions, APPLY, recursion, ...)",
      "id": "3b24cdc7a4cf96fe44a583320543a0e0"
    },
    {
      "type": "html",
      "text": " supports imperative programming (SETQ, BLOCK, TAGBODY, ...)",
      "id": "0335ab8808c279729ee570d811fcb0d2"
    },
    {
      "type": "html",
      "text": " code transformation with macros",
      "id": "3a9c5d55dc9478cc323d8f877a79b713"
    },
    {
      "type": "html",
      "text": " S-Expression notation as external notation for data-structures",
      "id": "f217b52462bb4b59e892ad2bae633fbe"
    },
    {
      "type": "html",
      "text": " Read Eval Print Loop for interactive programming",
      "id": "f2d2ef3a8bee0c4e4ccb95a53e2455a7"
    },
    {
      "type": "html",
      "text": " some form of automatic memory management",
      "id": "3f236581c613989122d4e90a5f0eb680"
    },
    {
      "type": "html",
      "text": " types declarations are optional",
      "id": "abd504637e48f1c2cbcef3577ef1969b"
    },
    {
      "type": "html",
      "text": " runtime generation and loading of source code",
      "id": "8834f8ab2765e59d1241bf6e73d912c1"
    },
    {
      "type": "html",
      "text": " image-based programming environment",
      "id": "9cc35f159e6f79f07cb554ac5749c977"
    },
    {
      "type": "html",
      "text": " support for datastructures (symbols, functions, numbers, strings, arrays, conses, structures/classes, ...)",
      "id": "98581a4c851c017c033a035d8d081343"
    },
    {
      "type": "html",
      "text": " basic error handling",
      "id": "7c1a5fad22b236b6e2a380e8e97b3919"
    },
    {
      "type": "html",
      "text": " basic I/O with streams",
      "id": "42246c338373f2fae8d5d1958aa5e677"
    },
    {
      "type": "html",
      "text": "\nScheme extends this list by:",
      "id": "e23f36848fac4b6941d23f25dcb7b000"
    },
    {
      "type": "html",
      "text": " defined syntax",
      "id": "06eba43aaaf938387cce53a4955a355c"
    },
    {
      "type": "html",
      "text": " defined semantics",
      "id": "cebd475e0b20c46256a49e224d349be7"
    },
    {
      "type": "html",
      "text": " hygienic macros",
      "id": "5793966fdc84353ad5617f848859b33d"
    },
    {
      "type": "html",
      "text": " continuations",
      "id": "e0043c7d4f6663d65835e2ae07f0d6e6"
    },
    {
      "type": "html",
      "text": " lexical scope",
      "id": "1b9ed38532c6e83bff5c4786ca8411ad"
    },
    {
      "type": "html",
      "text": " tail-call optimization",
      "id": "f3d3e26e80b5c7b1a22435745f489524"
    },
    {
      "type": "html",
      "text": "\nCommon Lisp extends the list by too many things to list:",
      "id": "e1627a09f84c6bbfeebc328669a43d9f"
    },
    {
      "type": "html",
      "text": " declarations (types, compiler directives, ...)",
      "id": "a4d8a816a6f7a0881bd83df289a77b88"
    },
    {
      "type": "html",
      "text": " multiple values",
      "id": "6a1b8e40e73a6dda94ffc5c54eb42c13"
    },
    {
      "type": "html",
      "text": " lexical scope as the default in addition to dynamic scope",
      "id": "1e9da63878bbc1ec6d62fd5ab32dbb2a"
    },
    {
      "type": "html",
      "text": " Common Lisp Object System",
      "id": "449538675814e88764289125b8770ca8"
    },
    {
      "type": "html",
      "text": " compiler",
      "id": "10020a8acbad6179c7e846b56a61aeb6"
    },
    {
      "type": "html",
      "text": " extensive error handling (condition system)",
      "id": "c745268ce5219800d5e5232eab69c7d0"
    },
    {
      "type": "html",
      "text": " more datatypes (extensive numeric tower, hashtables, streams, pathnames, ...)",
      "id": "efa18b138b44d69d21993c8071302b27"
    },
    {
      "type": "html",
      "text": " environment functions (ED, INSPECT, DESCRIBE, TRACE, ...)",
      "id": "0d06f3c99ba0f4be3c9ef18f47f7da2f"
    },
    {
      "type": "html",
      "text": " read-macros",
      "id": "bd83b1f6068db7156772a0d8041b4fb0"
    },
    {
      "type": "html",
      "text": "\nLet's look at Dylan (the later Dylan):",
      "id": "795455fc3a16b8b3a8890bba5e35501c"
    },
    {
      "type": "html",
      "text": " declarations",
      "id": "fe2321a1d29fe87e0c71f69867e07695"
    },
    {
      "type": "html",
      "text": " lexical scope",
      "id": "1b9ed38532c6e83bff5c4786ca8411ad"
    },
    {
      "type": "html",
      "text": " object system built-in (simple version of CLOS)",
      "id": "aeb01a7733208c8aac6069d4e5d663c4"
    },
    {
      "type": "html",
      "text": " error-handling",
      "id": "dcd9561fde73a3f5e313251db78e53d1"
    },
    {
      "type": "html",
      "text": " type-checking at compile time",
      "id": "51e19185e25073bf7385cb7503b19f7d"
    },
    {
      "type": "html",
      "text": "\nDylan lacks (despite its name) as a language the dynamic nature of the environment (though implementations are providing it as an addition): no read-eval-print-loop, no image-based development, no runtime code generation and no loading, ... Dylan also lacks the S-Expression syntax (the earlier Dylan version had it).",
      "id": "f4c3a392bfb0d96a3f8e49192bf83199"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a9f51d200d84fa63207961f8270fdb2c"
    },
    {
      "type": "html",
      "text": "<i>What do you consider the boundary between early-Dylan and late-Dylan? The switch to misfix syntax, or the demise of [[Apple Dylan]]? AFAIK, the original [[Apple Dylan]] had image-based development and a REPL loop. [[Gwydion Dylan]] lacked it because the Gwydion implementation was incomplete (funding pulled), but the original intent of the Gwydion project was to develop a state-of-the-art IDE that most likely would've included those features. Recent versions (2.3.10 and up) have added a REPL anyway. -- [[Jonathan Tang]]</i> ",
      "id": "cc72a7321c27f6ea21be82ac76c04856"
    },
    {
      "type": "html",
      "text": "\nGenerally I see Dylan as a language with several implementations. There were implementations of both versions of the language (early Dylan was more Lisp-like, late Dylan was more static with a different syntax).",
      "id": "779358b62fef8a1660b46f3e0933afb8"
    },
    {
      "type": "html",
      "text": "\nEarly Dylan was a OODL (Object-oriented dynamic language). Basically, it was Scheme-like with the CLOS object-system (plus conditions, ...). The later Dylan was more concerned with efficient compilation and a mixfix (infix/prefix) syntax. It was also in many respects quite similar in spirit to [[Eu Lisp]] (an European attempt at an efficient and modern Lisp). Though I would say that Dylan is smaller and more monolithic than [[Eu Lisp]]. But [[Eu Lisp]] was the much better Lisp - compared to Dylan. As a Lisp programmer I liked the earlier version more - but Lisp programmers were not the target audience.",
      "id": "8acf3e08b887de994a59125fe2d26a97"
    },
    {
      "type": "html",
      "text": "\nThe [[Apple Dylan]] development environment was a bit unusual for an integrated Lisp system. (btw., It was not written in Dylan, but Common Lisp) Typically it had the source stored in a database and had remote connections to running Dylan applications. Though the GUI builder was written in Dylan and was running inside the remote Dylan application. So it is a bit similar in spirit (remote Lisp controlled by a foreign IDE) with Emacs-based IDEs for Common Lisp. Many Common Lisp IDEs are running inside the same image like the applications they are used to develop. One exception is CMUCL/Hemlock. There also is the idea of some 'slave' Lisp. I would say that the [[Apple Dylan]] environment was not very typical for a Lisp-based development environment - though it was a logical step from earlier systems.",
      "id": "56cbe9ea807405b7956947e3e09760d8"
    },
    {
      "type": "html",
      "text": "\nThe Gwydion team start with bold ideas of a novel programming environment. But they never got far in that direction. They were mostly busy implementing the language. For quite some time.",
      "id": "e9b5518d6e403ae8662d01729f49488e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a9f51d200d84fa63207961f8270fdb2c"
    },
    {
      "type": "html",
      "text": "[[Category Lisp]]",
      "id": "1f39f018a1536a466edd1749e30e0dfe"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?LispFamily c2.com]",
      "id": "1d03d7aac1e0f48a86b66cafda21f76d"
    }
  ],
  "journal": [
    {
      "date": 1405958458000,
      "id": "59ca572026228b79d5aba660f8451c7e",
      "type": "create",
      "item": {
        "title": "Lisp Family",
        "story": [
          {
            "type": "html",
            "text": "Originally, the term <i>Lisp</i> referred to the language which was the brainchild of [[John Mc Carthy]].",
            "id": "f29d3d353222eda702ff39cb182f704d"
          },
          {
            "type": "html",
            "text": "\nNowadays, when unspecified, the term <i>Lisp</i> either refers to <i>[[Common Lisp]]</i> (a language), or the <i>Lisp family of languages</i>, all of which share the [[Lambda Nature]] (see [[Language Families]]). ",
            "id": "435d695daa956e94b4c5954ffe824293"
          },
          {
            "type": "html",
            "text": "\nA less strict criterion for inclusion of a language into the [[Lisp Family]] is the use of parenthesized lists to represent a program, and manipulation of lists made of two-field cells that can be manufactured and connected by a function called CONS (see [[Cons Cell]]s). It's somewhat of a custom that whenever someone writes a one-weekend interpreter for such a language, it is given a name that includes the word \"Lisp\". (Never heard of that - where is that?) Much newbie confusion arises from all of the different things that are called Lisp but have nothing to do with the mature, complex, super-powerful [[Common Lisp]], which, as the result of the combined efforts of the dominating lisp communities, is seen by many as the only thing that should be called Lisp (see [[The Evolution Of Lisp]]).",
            "id": "405e15fc12561b794694fe969c8092e6"
          },
          {
            "type": "html",
            "text": "'SEXP-Syntax is neither sufficient nor necessary' for a Lisp dialect.",
            "id": "b3e33e2292ea1dd339bf39ecf493e2e4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a9f51d200d84fa63207961f8270fdb2c"
          },
          {
            "type": "html",
            "text": "The sharing of the CONS function is something I borrowed from a paper by [[Kent Pitman]] in which he tries to pin down what exactly makes something Lisp. (See [http://www.nhplace.com/kent/PS/Lambda.html www.nhplace.com]. Also see [[Parenthetically Speaking]].) \nThere, he also argues that there is no lambda commonality among things calling themselves Lisp; the syntax varies - some things don't have lexical closures, others closures that can only be passed down, not returned, etc. [[Lambda Nature]] cannot exist without lexical scoping, so that the [[Lambda Expression]] creates a function-object that has captured the lexical bindings.",
            "id": "501415eac1b413decf921001c3880eac"
          },
          {
            "type": "html",
            "text": " Why is [[Lambda Nature]] dependent on lexical scoping, given that lambda is so much older than Lisp lexical scoping?",
            "id": "2cf5850d73fbc85702d646a646f260f2"
          },
          {
            "type": "html",
            "text": "\nBut note that I disagree with this paper on the whole; Pitman believes that there is a [[Lisp Family]], but that it arises out of some vague cultural connections rather than any specific language features. I view myself strictly as a [[Common Lisp]] user, and nothing more. I stay away from anything else that resembles Lisp, and don't feel that I belong to any broader community. Communities based on sharing a programming language are a fiction. Two people who don't know each other at all, but just happen to use the same programming language, text editor, operating system or whatever, are not automatically a community! That they can be is just some touchy-feely thinking thinking that might be called [[Techno Collectivism]]. Or maybe it's a spinoff idea from [[Brand Identification]] that westerners grow up with. If you drive a certain make of car, you are suddenly a member of the group of people who drive that car, and somehow this is more than just a dry mathematical observation that places you in a set. But really, to have a community, you must have a group of individuals who identify together in some concrete way, and actually know and recognize each other. I might form a community with some CL users, but not all of them at once!",
            "id": "e91cd4461d241dd855801455d9fc4445"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a9f51d200d84fa63207961f8270fdb2c"
          },
          {
            "type": "html",
            "text": "\n[[Paul Graham]] provides another reasoning what defines Lisp. See [http://www.paulgraham.com/diff.html www.paulgraham.com]",
            "id": "27c595626a2dd45db7970f4ba2fcfeeb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a9f51d200d84fa63207961f8270fdb2c"
          },
          {
            "type": "html",
            "text": "\n[[Gerald Sussman]] and [[Guy Steele]] named their dialect Scheme at a time when it was fashionable to give each Lisp dialect their own name (MDL, T, NIL, Conniver, and so on). Note that in the original papers about Scheme, Scheme is always described as a Lisp dialect. Further note that today's Scheme looks remarkably different to the original Scheme. Further further note, that the original Lisp didn't have lexical closures but that they were introduced in a clean way in Scheme. The [[Common Lisp]] designers have taken the [[Lexical Closure]] concept from Scheme. (In turn, lexical closures were first defined in [[Algol Language]].)",
            "id": "ae10f81bc86b22c5cd258692f2c2a466"
          },
          {
            "type": "html",
            "text": "\nThere are many reasons why to prefer [[Common Lisp]] over [[Scheme Language]] (see [[Lisp Scheme Differences]]), and vice-versa, but to describe Scheme as not being a Lisp is as simplistic as to say that Scheme and Lisp are more or less the same. The truth is somewhere in between.",
            "id": "27a2c9c075aae99a45f86c017600badf"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a9f51d200d84fa63207961f8270fdb2c"
          },
          {
            "type": "html",
            "text": "\nI wouldn't care if the Scheme people take over the word Lisp, and the [[Common Lisp]] people then rename their language and stop using the word. The point is that the term is simply too diluted when it takes on too many meanings, and as such it has little value. We can't even agree on what Lisp means; so maybe there is no point in using this word? Yet somehow it seems so coveted that people get ruffled when someone dares suggest that their pet language is not Lisp. Maybe \"Lisp\" is just a synonym for \"cool\". So if you say that some language is not Lisp, you are really saying that it's not cool. Also, because \"cool\" is hard to define, \"Lisp\" is hard to define. Moreover, things that are obviously not Lisp at all are clearly uncool. I can't think of a single counterexample when \"Lisp\" does not mean \"cool\", except when it's used in the name of some concrete language or implementation. AutoLISP doesn't mean AutoCOOL, and Common Lisp doesn't mean Common Cool. But as an adjective, to say that something is Lisp simply means that it has hacker approval.",
            "id": "248b098b503307bedc623c4cbe35faeb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a9f51d200d84fa63207961f8270fdb2c"
          },
          {
            "type": "html",
            "text": "\nOkay, so how about this: Lisp as an adjective means \"cool\". Lisp as a noun that is part of a noun phrase designating a programming language adds the semantic attribute \"language derived from cool ideas\". And used entirely by itself, in the absence of historic context, it means \"ANSI Common Lisp\", where this second occurrence of Lisp is not subject to the cool-substitution, but simply stands for itself. In some proper historic context it means \"the language invented by [[John Mc Carthy]] and peers\". There, it's settled!",
            "id": "dda8ef2b5a6061146485901e4a6ee802"
          },
          {
            "type": "html",
            "text": "---- ",
            "id": "5d6a8e99877c07ac844511fbd632b486"
          },
          {
            "type": "html",
            "text": "<i>So, Lisp == cool? I thought that [[Csharp Language]] == cool! By transitivity, this implies that Lisp == C#</i>",
            "id": "d3b5c26aa9ee72b4cd79b611fc4b9e61"
          },
          {
            "type": "html",
            "text": "<i>Amazing. And all this time I had thought that C#/[[Dot Net]] was little more than a blatant ripoff of Java (both the language and the platform)! Now we find it's really Lisp in disguise!</i>",
            "id": "77b7252248d38cbd03b17ca5df383428"
          },
          {
            "type": "html",
            "text": "<i>So, then why doesn't C# have [[Ess Expressions]]?</i>",
            "id": "fd02a569b76526240eeff74bf7ff3534"
          },
          {
            "type": "html",
            "text": "\nAh, I think your \"==\" operator means, in this context, \"is a member of the set\".",
            "id": "dc401338a03cdfa343a41b48536c44b9"
          },
          {
            "type": "html",
            "text": "<i>No, \"==\" means equality. The development codename for the C# project at Microsoft was \"Cool\", one of the worst-kept secrets of the past couple years. The rest of the above section is tongue-in-cheek</i>",
            "id": "78ff363979928f09a8d657590f91ca86"
          },
          {
            "type": "html",
            "text": "<i>So... when do you think we will see [[Microsoft Visual Lisp]] (or, for that matter, [[Visual Lisp Dot Net]]?????) What will the [[Lisp Hippie]]s do if their favorite language is taken over by the [[Evil Empire]]? I guess it would make writing macros in [[Microsoft Excel]] more fun!</i>",
            "id": "d64ecbbea8f2849a022eeab7b82e75d4"
          },
          {
            "type": "html",
            "text": "<i>-- [[Scott Johnson]]</i>",
            "id": "b37ead8eb50d12fa1f4cd8a8b23b1be2"
          },
          {
            "type": "html",
            "text": "\nWell, long, long ago, there was already an MS Lisp...\n[http://groups.google.com/groups?q=microsoft+lisp&ie=ISO-8859-1&hl=en groups.google.com]",
            "id": "d16373b2b5469b15223f58c1a08855fc"
          },
          {
            "type": "html",
            "text": "<i>There is a Visual Lisp product from Autodesk for use with its popular AutoCAD software. Not surprisingly, the appearance of Visual Lisp coincided with the full-scale conversion of AutoCAD from a cross-platform tool into an application deeply rooted in, and heavily dependent on, the Windows environment (with ActiveX, etc.). -- [[Jeff Read]]</i>",
            "id": "b71d0aea4764fa81409617b336ce3fff"
          },
          {
            "type": "html",
            "text": " I hadn't noticed that it used to be heavily cross-platform. Anyway, just to avoid confusion: [[Auto Cad]] included [[Auto Lisp]] since 1985, and [[Auto Desk]] added the [[Visual Lisp]] programming environment for [[Auto Lisp]] in 1997. [http://courses.home.att.net/autolisp/ahistory.htm courses.home.att.net]",
            "id": "476de2cfe6800445e489c77f229f672f"
          },
          {
            "type": "html",
            "text": "---- ",
            "id": "5d6a8e99877c07ac844511fbd632b486"
          },
          {
            "type": "html",
            "text": "\nA few things that might define some core of Lisp dialects and their typical implementation:",
            "id": "1b6cfb694df9ae54bd396dc47ea7fc74"
          },
          {
            "type": "html",
            "text": " supports functional programming (LAMBDA, higher order functions, anonymous functions, local functions, APPLY, recursion, ...)",
            "id": "3b24cdc7a4cf96fe44a583320543a0e0"
          },
          {
            "type": "html",
            "text": " supports imperative programming (SETQ, BLOCK, TAGBODY, ...)",
            "id": "0335ab8808c279729ee570d811fcb0d2"
          },
          {
            "type": "html",
            "text": " code transformation with macros",
            "id": "3a9c5d55dc9478cc323d8f877a79b713"
          },
          {
            "type": "html",
            "text": " S-Expression notation as external notation for data-structures",
            "id": "f217b52462bb4b59e892ad2bae633fbe"
          },
          {
            "type": "html",
            "text": " Read Eval Print Loop for interactive programming",
            "id": "f2d2ef3a8bee0c4e4ccb95a53e2455a7"
          },
          {
            "type": "html",
            "text": " some form of automatic memory management",
            "id": "3f236581c613989122d4e90a5f0eb680"
          },
          {
            "type": "html",
            "text": " types declarations are optional",
            "id": "abd504637e48f1c2cbcef3577ef1969b"
          },
          {
            "type": "html",
            "text": " runtime generation and loading of source code",
            "id": "8834f8ab2765e59d1241bf6e73d912c1"
          },
          {
            "type": "html",
            "text": " image-based programming environment",
            "id": "9cc35f159e6f79f07cb554ac5749c977"
          },
          {
            "type": "html",
            "text": " support for datastructures (symbols, functions, numbers, strings, arrays, conses, structures/classes, ...)",
            "id": "98581a4c851c017c033a035d8d081343"
          },
          {
            "type": "html",
            "text": " basic error handling",
            "id": "7c1a5fad22b236b6e2a380e8e97b3919"
          },
          {
            "type": "html",
            "text": " basic I/O with streams",
            "id": "42246c338373f2fae8d5d1958aa5e677"
          },
          {
            "type": "html",
            "text": "\nScheme extends this list by:",
            "id": "e23f36848fac4b6941d23f25dcb7b000"
          },
          {
            "type": "html",
            "text": " defined syntax",
            "id": "06eba43aaaf938387cce53a4955a355c"
          },
          {
            "type": "html",
            "text": " defined semantics",
            "id": "cebd475e0b20c46256a49e224d349be7"
          },
          {
            "type": "html",
            "text": " hygienic macros",
            "id": "5793966fdc84353ad5617f848859b33d"
          },
          {
            "type": "html",
            "text": " continuations",
            "id": "e0043c7d4f6663d65835e2ae07f0d6e6"
          },
          {
            "type": "html",
            "text": " lexical scope",
            "id": "1b9ed38532c6e83bff5c4786ca8411ad"
          },
          {
            "type": "html",
            "text": " tail-call optimization",
            "id": "f3d3e26e80b5c7b1a22435745f489524"
          },
          {
            "type": "html",
            "text": "\nCommon Lisp extends the list by too many things to list:",
            "id": "e1627a09f84c6bbfeebc328669a43d9f"
          },
          {
            "type": "html",
            "text": " declarations (types, compiler directives, ...)",
            "id": "a4d8a816a6f7a0881bd83df289a77b88"
          },
          {
            "type": "html",
            "text": " multiple values",
            "id": "6a1b8e40e73a6dda94ffc5c54eb42c13"
          },
          {
            "type": "html",
            "text": " lexical scope as the default in addition to dynamic scope",
            "id": "1e9da63878bbc1ec6d62fd5ab32dbb2a"
          },
          {
            "type": "html",
            "text": " Common Lisp Object System",
            "id": "449538675814e88764289125b8770ca8"
          },
          {
            "type": "html",
            "text": " compiler",
            "id": "10020a8acbad6179c7e846b56a61aeb6"
          },
          {
            "type": "html",
            "text": " extensive error handling (condition system)",
            "id": "c745268ce5219800d5e5232eab69c7d0"
          },
          {
            "type": "html",
            "text": " more datatypes (extensive numeric tower, hashtables, streams, pathnames, ...)",
            "id": "efa18b138b44d69d21993c8071302b27"
          },
          {
            "type": "html",
            "text": " environment functions (ED, INSPECT, DESCRIBE, TRACE, ...)",
            "id": "0d06f3c99ba0f4be3c9ef18f47f7da2f"
          },
          {
            "type": "html",
            "text": " read-macros",
            "id": "bd83b1f6068db7156772a0d8041b4fb0"
          },
          {
            "type": "html",
            "text": "\nLet's look at Dylan (the later Dylan):",
            "id": "795455fc3a16b8b3a8890bba5e35501c"
          },
          {
            "type": "html",
            "text": " declarations",
            "id": "fe2321a1d29fe87e0c71f69867e07695"
          },
          {
            "type": "html",
            "text": " lexical scope",
            "id": "1b9ed38532c6e83bff5c4786ca8411ad"
          },
          {
            "type": "html",
            "text": " object system built-in (simple version of CLOS)",
            "id": "aeb01a7733208c8aac6069d4e5d663c4"
          },
          {
            "type": "html",
            "text": " error-handling",
            "id": "dcd9561fde73a3f5e313251db78e53d1"
          },
          {
            "type": "html",
            "text": " type-checking at compile time",
            "id": "51e19185e25073bf7385cb7503b19f7d"
          },
          {
            "type": "html",
            "text": "\nDylan lacks (despite its name) as a language the dynamic nature of the environment (though implementations are providing it as an addition): no read-eval-print-loop, no image-based development, no runtime code generation and no loading, ... Dylan also lacks the S-Expression syntax (the earlier Dylan version had it).",
            "id": "f4c3a392bfb0d96a3f8e49192bf83199"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a9f51d200d84fa63207961f8270fdb2c"
          },
          {
            "type": "html",
            "text": "<i>What do you consider the boundary between early-Dylan and late-Dylan? The switch to misfix syntax, or the demise of [[Apple Dylan]]? AFAIK, the original [[Apple Dylan]] had image-based development and a REPL loop. [[Gwydion Dylan]] lacked it because the Gwydion implementation was incomplete (funding pulled), but the original intent of the Gwydion project was to develop a state-of-the-art IDE that most likely would've included those features. Recent versions (2.3.10 and up) have added a REPL anyway. -- [[Jonathan Tang]]</i> ",
            "id": "cc72a7321c27f6ea21be82ac76c04856"
          },
          {
            "type": "html",
            "text": "\nGenerally I see Dylan as a language with several implementations. There were implementations of both versions of the language (early Dylan was more Lisp-like, late Dylan was more static with a different syntax).",
            "id": "779358b62fef8a1660b46f3e0933afb8"
          },
          {
            "type": "html",
            "text": "\nEarly Dylan was a OODL (Object-oriented dynamic language). Basically, it was Scheme-like with the CLOS object-system (plus conditions, ...). The later Dylan was more concerned with efficient compilation and a mixfix (infix/prefix) syntax. It was also in many respects quite similar in spirit to [[Eu Lisp]] (an European attempt at an efficient and modern Lisp). Though I would say that Dylan is smaller and more monolithic than [[Eu Lisp]]. But [[Eu Lisp]] was the much better Lisp - compared to Dylan. As a Lisp programmer I liked the earlier version more - but Lisp programmers were not the target audience.",
            "id": "8acf3e08b887de994a59125fe2d26a97"
          },
          {
            "type": "html",
            "text": "\nThe [[Apple Dylan]] development environment was a bit unusual for an integrated Lisp system. (btw., It was not written in Dylan, but Common Lisp) Typically it had the source stored in a database and had remote connections to running Dylan applications. Though the GUI builder was written in Dylan and was running inside the remote Dylan application. So it is a bit similar in spirit (remote Lisp controlled by a foreign IDE) with Emacs-based IDEs for Common Lisp. Many Common Lisp IDEs are running inside the same image like the applications they are used to develop. One exception is CMUCL/Hemlock. There also is the idea of some 'slave' Lisp. I would say that the [[Apple Dylan]] environment was not very typical for a Lisp-based development environment - though it was a logical step from earlier systems.",
            "id": "56cbe9ea807405b7956947e3e09760d8"
          },
          {
            "type": "html",
            "text": "\nThe Gwydion team start with bold ideas of a novel programming environment. But they never got far in that direction. They were mostly busy implementing the language. For quite some time.",
            "id": "e9b5518d6e403ae8662d01729f49488e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a9f51d200d84fa63207961f8270fdb2c"
          },
          {
            "type": "html",
            "text": "[[Category Lisp]]",
            "id": "1f39f018a1536a466edd1749e30e0dfe"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?LispFamily c2.com]",
            "id": "1d03d7aac1e0f48a86b66cafda21f76d"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1626125177664
    }
  ]
}