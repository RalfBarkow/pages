{
  "title": "Hiding the Machine",
  "story": [
    {
      "type": "paragraph",
      "id": "0c68353265904c66",
      "text": "During the much discussed “software crisis” of the late 1960s, which stemmed from such spectacular debacles as IBM’s OS/360, many (especially European programmers, such as Friedrich [Fritz] Bauer and Peter Naur) viewed “software engineering,” or structured programming, as a way to move programming from a craft to a standardized industrial practice, and as a way to create disciplined programmers who dealt with abstractions rather than numerical processes. As Michael Mahoney has argued, structured programming emerged as a “means both of quality control and of disciplining programmers, methods of cost accounting and estimation, methods of verification and validation, techniques of quality assurance.”"
    },
    {
      "type": "markdown",
      "id": "e7311b3caebc9d54",
      "text": "“Structured programming” (also generally known as “good programming”) hides, and thus secures, the machine. Not surprisingly, having little to no contact with the actual machine enhances one’s ability to think abstractly rather than numerically. Edsger Dijkstra, whose famous condemnation of “go to” statements has encapsulated to many the fundamental tenets of structure programming, believes that he was able to “pioneer” structured programming precisely because he began his programming career by **coding for machines that did not yet exist**. In “Go To Statement Considered Harmful,” Dijkstra argues, “the quality of programmers is a decreasing function of the density of go to statements in the programs they produce.” This is because go to statements go against the fundamental tenet of good programming—the necessity to “shorten the conceptual gap between **static program and dynamic process**, to make the correspondence between **the program (spread out in text space) and the process (spread out in time)** as trivial as possible.” More specifically, **if a program is halted, go tos make it difficult to find a place in the programming that corresponds to the halted process—it makes it “terribly hard to find a meaningful set of coordinates in which to describe the process progress.”** That is, go tos make difficult the conflation of instruction with command, which grounds “programming.”"
    },
    {
      "type": "markdown",
      "id": "15facc6b92ce0b0d",
      "text": "Structured programming languages “save” programmers from themselves by providing good security, where security means secure from the programmer. In the name of security, structured programming, which emphasizes **programming as a question of flow**, is itself giving way to data abstraction, which views programming as a question of interrelated objects and hides far more than the machine. **Data abstraction depends on information hiding, on the nonreflection of changeable facts in software. As [[John V. Guttag]], a “pioneer” in data abstraction explains, data abstraction is all about forgetting.** Rather than “polluting” a program by enabling invisible lines of contact between supposedly independent modules, **data abstraction presents a clean or “beautiful” interface** by confining specificities, and by reducing the knowledge and power of the programmer. Knowledge, Guttag insists, is dangerous: “‘Drink deep, or taste not the Pierian Spring,’ is not necessarily good advice. Knowing too much is no better, and often worse, than knowing too little. People cannot assimilate very much information. **Any programming method or approach that assumes that people will understand a lot is highly risky.**”"
    },
    {
      "type": "markdown",
      "id": "987eef5c778d5b01",
      "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist [[David Eck]] argues, “**every programming language defines a [[virtual machine]], for which it is the machine language**. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the [[limitations]] imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its **[[separation of machine]] into software and hardware**, the act of programming to the machine itself. Koss scoffed at the early notion of [[computers as brains]] because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of [[software as a commodity]], despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to [[define]] its [[Product]]. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
    },
    {
      "type": "markdown",
      "id": "2fa372964f0fff2f",
      "text": "Importantly, programmers are *users*: they create programs using editors, which are themselves software programs. **The [[distinction]] between programmers and users is gradually eroding**, not only because users are becoming programmers (in a real sense programmers no longer program a computer; they code), but also because, with highlevel languages, programmers are becoming more like simple users. **The difference between users and programmers is an effect of software.**\n"
    },
    {
      "type": "markdown",
      "id": "e30dada904b32039",
      "text": "⇒ [[Causal Pleasure]]"
    },
    {
      "type": "pagefold",
      "id": "f9296c197365b990",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "b1314114afa1a504",
      "text": "Chun, „On Software, or the [[Persistence of Visual Knowledge]]“, p.37–38."
    },
    {
      "type": "pagefold",
      "id": "976de0a924e32ca1",
      "text": "DE"
    },
    {
      "type": "paragraph",
      "id": "e550da8de2e08aeb",
      "text": "Die Datenabstraktion beruht auf dem Verstecken von Informationen, auf der Nichtreflexion von veränderlichen Fakten in der Software."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Hiding the Machine",
        "story": []
      },
      "date": 1661461179002
    },
    {
      "item": {
        "type": "factory",
        "id": "0c68353265904c66"
      },
      "id": "0c68353265904c66",
      "type": "add",
      "date": 1661461199064
    },
    {
      "type": "edit",
      "id": "0c68353265904c66",
      "item": {
        "type": "paragraph",
        "id": "0c68353265904c66",
        "text": "During the much discussed “software crisis” of the late 1960s, which stemmed from such spectacular debacles as IBM’s OS/360, many (especially European programmers, such as Friedrich [Fritz] Bauer and Peter Naur) viewed “software engineering,” or structured programming, as a way to move programming from a craft to a standardized industrial practice, and as a way to create disciplined programmers who dealt with abstractions rather than numerical processes.33 As Michael Mahoney has argued, structured programming emerged as a “means both of quality control and of disciplining programmers, methods of cost accounting and estimation, methods of verification and validation, techniques of quality assurance.”34"
      },
      "date": 1661461201217
    },
    {
      "type": "add",
      "id": "2fa372964f0fff2f",
      "item": {
        "type": "paragraph",
        "id": "2fa372964f0fff2f",
        "text": "[…]"
      },
      "after": "0c68353265904c66",
      "date": 1661461230999
    },
    {
      "type": "edit",
      "id": "0c68353265904c66",
      "item": {
        "type": "paragraph",
        "id": "0c68353265904c66",
        "text": "During the much discussed “software crisis” of the late 1960s, which stemmed from such spectacular debacles as IBM’s OS/360, many (especially European programmers, such as Friedrich [Fritz] Bauer and Peter Naur) viewed “software engineering,” or structured programming, as a way to move programming from a craft to a standardized industrial practice, and as a way to create disciplined programmers who dealt with abstractions rather than numerical processes. As Michael Mahoney has argued, structured programming emerged as a “means both of quality control and of disciplining programmers, methods of cost accounting and estimation, methods of verification and validation, techniques of quality assurance.”"
      },
      "date": 1661461238991
    },
    {
      "type": "add",
      "id": "e7311b3caebc9d54",
      "item": {
        "type": "paragraph",
        "id": "e7311b3caebc9d54",
        "text": "“Structured programming” (also generally known as “good programming”) hides, and thus secures, the machine. Not surprisingly, having little to no contact with the actual machine enhances one’s ability to think abstractly rather than numerically. Edsger Dijkstra, whose famous condemnation of “go to” statements has encapsulated to many the fundamental tenets of structure programming, believes that he was able to “pioneer” structured programming precisely because he began his programming career by coding for machines that did not yet exist.35 In “Go To Statement Considered Harmful,” Dijkstra argues, “the quality of programmers is a decreasing function of the density of go to statements in the programs they produce.” This is because go to statements go against the fundamental tenet of good programming—the necessity to “shorten the conceptual gap between static program and dynamic process, to make the correspondence between the program (spread out in text space) and the process (spread out in time) as trivial as possible.” More specifically, if a program is halted, go tos make it difficult to find a place in the programming that corresponds to the halted process—it makes it “terribly hard to find a meaningful set of coordinates in which to describe the process progress.”36 That is, go tos make difficult the conflation of instruction with command, which grounds “programming.”37"
      },
      "after": "0c68353265904c66",
      "date": 1661461275024
    },
    {
      "type": "edit",
      "id": "e7311b3caebc9d54",
      "item": {
        "type": "paragraph",
        "id": "e7311b3caebc9d54",
        "text": "“Structured programming” (also generally known as “good programming”) hides, and thus secures, the machine. Not surprisingly, having little to no contact with the actual machine enhances one’s ability to think abstractly rather than numerically. Edsger Dijkstra, whose famous condemnation of “go to” statements has encapsulated to many the fundamental tenets of structure programming, believes that he was able to “pioneer” structured programming precisely because he began his programming career by coding for machines that did not yet exist. In “Go To Statement Considered Harmful,” Dijkstra argues, “the quality of programmers is a decreasing function of the density of go to statements in the programs they produce.” This is because go to statements go against the fundamental tenet of good programming—the necessity to “shorten the conceptual gap between static program and dynamic process, to make the correspondence between the program (spread out in text space) and the process (spread out in time) as trivial as possible.” More specifically, if a program is halted, go tos make it difficult to find a place in the programming that corresponds to the halted process—it makes it “terribly hard to find a meaningful set of coordinates in which to describe the process progress.” That is, go tos make difficult the conflation of instruction with command, which grounds “programming.”"
      },
      "date": 1661461319921
    },
    {
      "type": "add",
      "id": "15facc6b92ce0b0d",
      "item": {
        "type": "paragraph",
        "id": "15facc6b92ce0b0d",
        "text": "Structured programming languages “save” programmers from themselves by providing good security, where security means secure from the programmer.38 In the name of security, structured programming, which emphasizes programming as a question of flow, is itself giving way to data abstraction, which views programming as a question of interrelated objects and hides far more than the machine. Data abstraction depends on information hiding, on the nonreflection of changeable facts in software. As John V. Guttag, a “pioneer” in data abstraction explains, data abstraction is all about forgetting.39 Rather than “polluting” a program by enabling invisible lines of contact"
      },
      "after": "e7311b3caebc9d54",
      "date": 1661461360735
    },
    {
      "item": {
        "type": "factory",
        "id": "f9296c197365b990"
      },
      "id": "f9296c197365b990",
      "type": "add",
      "after": "2fa372964f0fff2f",
      "date": 1661461365798
    },
    {
      "type": "edit",
      "id": "f9296c197365b990",
      "item": {
        "type": "pagefold",
        "id": "f9296c197365b990",
        "text": "~"
      },
      "date": 1661461369840
    },
    {
      "item": {
        "type": "factory",
        "id": "b1314114afa1a504"
      },
      "id": "b1314114afa1a504",
      "type": "add",
      "after": "f9296c197365b990",
      "date": 1661461372059
    },
    {
      "type": "edit",
      "id": "b1314114afa1a504",
      "item": {
        "type": "paragraph",
        "id": "b1314114afa1a504",
        "text": "Chun, „On Software, or the Persistence of Visual Knowledge“, p.37."
      },
      "date": 1661461384632
    },
    {
      "type": "edit",
      "id": "b1314114afa1a504",
      "item": {
        "type": "paragraph",
        "id": "b1314114afa1a504",
        "text": "Chun, „On Software, or the [[Persistence of Visual Knowledge]]“, p.37."
      },
      "date": 1661461403258
    },
    {
      "type": "edit",
      "id": "15facc6b92ce0b0d",
      "item": {
        "type": "paragraph",
        "id": "15facc6b92ce0b0d",
        "text": "Structured programming languages “save” programmers from themselves by providing good security, where security means secure from the programmer. In the name of security, structured programming, which emphasizes programming as a question of flow, is itself giving way to data abstraction, which views programming as a question of interrelated objects and hides far more than the machine. Data abstraction depends on information hiding, on the nonreflection of changeable facts in software. As John V. Guttag, a “pioneer” in data abstraction explains, data abstraction is all about forgetting. Rather than “polluting” a program by enabling invisible lines of contact between supposedly independent modules, data abstraction presents a clean or “beautiful” interface by confining specificities, and by reducing the knowledge and power of the programmer. Knowledge, Guttag insists, is dangerous: “‘Drink deep, or taste not the Pierian Spring,’ is not necessarily good advice. Knowing too much is no better, and often worse, than knowing too little. People cannot assimilate very much information. Any programming method or approach that assumes that people will understand a lot is highly risky.”"
      },
      "date": 1661461445072
    },
    {
      "item": {
        "type": "factory",
        "id": "976de0a924e32ca1"
      },
      "id": "976de0a924e32ca1",
      "type": "add",
      "after": "b1314114afa1a504",
      "date": 1661461522255
    },
    {
      "type": "edit",
      "id": "976de0a924e32ca1",
      "item": {
        "type": "pagefold",
        "id": "976de0a924e32ca1",
        "text": "DE"
      },
      "date": 1661461526646
    },
    {
      "item": {
        "type": "factory",
        "id": "e550da8de2e08aeb"
      },
      "id": "e550da8de2e08aeb",
      "type": "add",
      "after": "976de0a924e32ca1",
      "date": 1661461528136
    },
    {
      "type": "edit",
      "id": "e550da8de2e08aeb",
      "item": {
        "type": "paragraph",
        "id": "e550da8de2e08aeb",
        "text": "Data abstraction depends on information hiding, on the nonreflection of changeable facts in software.s"
      },
      "date": 1661461531044
    },
    {
      "type": "edit",
      "id": "e550da8de2e08aeb",
      "item": {
        "type": "paragraph",
        "id": "e550da8de2e08aeb",
        "text": "Die Datenabstraktion beruht auf dem Verstecken von Informationen, auf der Nichtreflexion von veränderlichen Fakten in der Software."
      },
      "date": 1661461536307
    },
    {
      "type": "edit",
      "id": "b1314114afa1a504",
      "item": {
        "type": "paragraph",
        "id": "b1314114afa1a504",
        "text": "Chun, „On Software, or the [[Persistence of Visual Knowledge]]“, p.37–38."
      },
      "date": 1661461556365
    },
    {
      "type": "add",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "paragraph",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist David Eck argues, “every programming language defines a virtual machine, for which it is the machine language. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the limitations imposed by materials and manufacturing technology.”41 However, this abstraction—this drawing away from the specificities of the machine—gives over, in its separation of machine into software and hardware, the act of programming to the machine itself. Koss scoffed at the early notion of computers as brains because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object.42 The current status of software as a commodity, despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to define its product. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "after": "15facc6b92ce0b0d",
      "date": 1661461653680
    },
    {
      "type": "edit",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "paragraph",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist David Eck argues, “every programming language defines a virtual machine, for which it is the machine language. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the limitations imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its separation of machine into software and hardware, the act of programming to the machine itself. Koss scoffed at the early notion of computers as brains because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of software as a commodity, despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to define its product. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "date": 1661461677730
    },
    {
      "type": "edit",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "paragraph",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist [[David Eck]] argues, “every programming language defines a [[virtual machine]], for which it is the machine language. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the limitations imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its separation of machine into software and hardware, the act of programming to the machine itself. Koss scoffed at the early notion of computers as brains because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of software as a commodity, despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to define its product. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "date": 1661461722641
    },
    {
      "type": "edit",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "paragraph",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist [[David Eck]] argues, “every programming language defines a [[virtual machine]], for which it is the machine language. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the limitations imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its separation of machine into software and hardware, the act of programming to the machine itself. Koss scoffed at the early notion of [[computers as brains]] because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of software as a commodity, despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to define its product. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "date": 1661461769982
    },
    {
      "type": "edit",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "paragraph",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist [[David Eck]] argues, “every programming language defines a [[virtual machine]], for which it is the machine language. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the limitations imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its separation of machine into software and hardware, the act of programming to the machine itself. Koss scoffed at the early notion of [[computers as brains]] because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of [[software as a commodity]], despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to define its product. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "date": 1661461838098
    },
    {
      "type": "edit",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "paragraph",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist [[David Eck]] argues, “every programming language defines a [[virtual machine]], for which it is the machine language. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the limitations imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its separation of machine into software and hardware, the act of programming to the machine itself. Koss scoffed at the early notion of [[computers as brains]] because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of [[software as a commodity]], despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to [[define]] its product. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "date": 1661461951484
    },
    {
      "type": "edit",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "paragraph",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist [[David Eck]] argues, “every programming language defines a [[virtual machine]], for which it is the machine language. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the limitations imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its separation of machine into software and hardware, the act of programming to the machine itself. Koss scoffed at the early notion of [[computers as brains]] because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of [[software as a commodity]], despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to [[define]] its [[Product]]. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "date": 1661461988253
    },
    {
      "type": "edit",
      "id": "2fa372964f0fff2f",
      "item": {
        "type": "paragraph",
        "id": "2fa372964f0fff2f",
        "text": "Importantly, programmers are *users*: they create programs using editors, which are themselves software programs. The distinction between programmers and users is gradually eroding, not only because users are becoming programmers (in a real sense programmers no longer program a computer; they code), but also because, with highlevel languages, programmers are becoming more like simple users. The difference between users and programmers is an effect of software."
      },
      "date": 1661462268761
    },
    {
      "type": "edit",
      "id": "2fa372964f0fff2f",
      "item": {
        "type": "markdown",
        "id": "2fa372964f0fff2f",
        "text": "Importantly, programmers are *users*: they create programs using editors, which are themselves software programs. The distinction between programmers and users is gradually eroding, not only because users are becoming programmers (in a real sense programmers no longer program a computer; they code), but also because, with highlevel languages, programmers are becoming more like simple users. The difference between users and programmers is an effect of software."
      },
      "date": 1661462269979
    },
    {
      "type": "edit",
      "id": "2fa372964f0fff2f",
      "item": {
        "type": "markdown",
        "id": "2fa372964f0fff2f",
        "text": "Importantly, programmers are *users*: they create programs using editors, which are themselves software programs. **The [[distinction]] between programmers and users is gradually eroding**, not only because users are becoming programmers (in a real sense programmers no longer program a computer; they code), but also because, with highlevel languages, programmers are becoming more like simple users. **The difference between users and programmers is an effect of software.**"
      },
      "date": 1661462337620
    },
    {
      "type": "edit",
      "id": "2fa372964f0fff2f",
      "item": {
        "type": "markdown",
        "id": "2fa372964f0fff2f",
        "text": "Importantly, programmers are *users*: they create programs using editors, which are themselves software programs. **The [[distinction]] between programmers and users is gradually eroding**, not only because users are becoming programmers (in a real sense programmers no longer program a computer; they code), but also because, with highlevel languages, programmers are becoming more like simple users. **The difference between users and programmers is an effect of software.**\n"
      },
      "date": 1661462375527
    },
    {
      "type": "add",
      "id": "e30dada904b32039",
      "item": {
        "type": "markdown",
        "id": "e30dada904b32039",
        "text": "– [[Causal Pleasure]]"
      },
      "after": "2fa372964f0fff2f",
      "date": 1661462386134
    },
    {
      "type": "edit",
      "id": "e30dada904b32039",
      "item": {
        "type": "markdown",
        "id": "e30dada904b32039",
        "text": "⇒ [[Causal Pleasure]]"
      },
      "date": 1661462393026
    },
    {
      "type": "edit",
      "id": "e7311b3caebc9d54",
      "item": {
        "type": "paragraph",
        "id": "e7311b3caebc9d54",
        "text": "“Structured programming” (also generally known as “good programming”) hides, and thus secures, the machine. Not surprisingly, having little to no contact with the actual machine enhances one’s ability to think abstractly rather than numerically. Edsger Dijkstra, whose famous condemnation of “go to” statements has encapsulated to many the fundamental tenets of structure programming, believes that he was able to “pioneer” structured programming precisely because he began his programming career by coding for machines that did not yet exist. In “Go To Statement Considered Harmful,” Dijkstra argues, “the quality of programmers is a decreasing function of the density of go to statements in the programs they produce.” This is because go to statements go against the fundamental tenet of good programming—the necessity to “shorten the conceptual gap between **static program and dynamic process**, to make the correspondence between **the program (spread out in text space) and the process (spread out in time)** as trivial as possible.” More specifically, if a program is halted, go tos make it difficult to find a place in the programming that corresponds to the halted process—it makes it “terribly hard to find a meaningful set of coordinates in which to describe the process progress.” That is, go tos make difficult the conflation of instruction with command, which grounds “programming.”"
      },
      "date": 1661462748665
    },
    {
      "type": "edit",
      "id": "e7311b3caebc9d54",
      "item": {
        "type": "markdown",
        "id": "e7311b3caebc9d54",
        "text": "“Structured programming” (also generally known as “good programming”) hides, and thus secures, the machine. Not surprisingly, having little to no contact with the actual machine enhances one’s ability to think abstractly rather than numerically. Edsger Dijkstra, whose famous condemnation of “go to” statements has encapsulated to many the fundamental tenets of structure programming, believes that he was able to “pioneer” structured programming precisely because he began his programming career by coding for machines that did not yet exist. In “Go To Statement Considered Harmful,” Dijkstra argues, “the quality of programmers is a decreasing function of the density of go to statements in the programs they produce.” This is because go to statements go against the fundamental tenet of good programming—the necessity to “shorten the conceptual gap between **static program and dynamic process**, to make the correspondence between **the program (spread out in text space) and the process (spread out in time)** as trivial as possible.” More specifically, if a program is halted, go tos make it difficult to find a place in the programming that corresponds to the halted process—it makes it “terribly hard to find a meaningful set of coordinates in which to describe the process progress.” That is, go tos make difficult the conflation of instruction with command, which grounds “programming.”"
      },
      "date": 1661462751359
    },
    {
      "type": "edit",
      "id": "e7311b3caebc9d54",
      "item": {
        "type": "markdown",
        "id": "e7311b3caebc9d54",
        "text": "“Structured programming” (also generally known as “good programming”) hides, and thus secures, the machine. Not surprisingly, having little to no contact with the actual machine enhances one’s ability to think abstractly rather than numerically. Edsger Dijkstra, whose famous condemnation of “go to” statements has encapsulated to many the fundamental tenets of structure programming, believes that he was able to “pioneer” structured programming precisely because he began his programming career by **coding for machines that did not yet exist**. In “Go To Statement Considered Harmful,” Dijkstra argues, “the quality of programmers is a decreasing function of the density of go to statements in the programs they produce.” This is because go to statements go against the fundamental tenet of good programming—the necessity to “shorten the conceptual gap between **static program and dynamic process**, to make the correspondence between **the program (spread out in text space) and the process (spread out in time)** as trivial as possible.” More specifically, if a program is halted, go tos make it difficult to find a place in the programming that corresponds to the halted process—it makes it “terribly hard to find a meaningful set of coordinates in which to describe the process progress.” That is, go tos make difficult the conflation of instruction with command, which grounds “programming.”"
      },
      "date": 1661462801888
    },
    {
      "type": "edit",
      "id": "e7311b3caebc9d54",
      "item": {
        "type": "markdown",
        "id": "e7311b3caebc9d54",
        "text": "“Structured programming” (also generally known as “good programming”) hides, and thus secures, the machine. Not surprisingly, having little to no contact with the actual machine enhances one’s ability to think abstractly rather than numerically. Edsger Dijkstra, whose famous condemnation of “go to” statements has encapsulated to many the fundamental tenets of structure programming, believes that he was able to “pioneer” structured programming precisely because he began his programming career by **coding for machines that did not yet exist**. In “Go To Statement Considered Harmful,” Dijkstra argues, “the quality of programmers is a decreasing function of the density of go to statements in the programs they produce.” This is because go to statements go against the fundamental tenet of good programming—the necessity to “shorten the conceptual gap between **static program and dynamic process**, to make the correspondence between **the program (spread out in text space) and the process (spread out in time)** as trivial as possible.” More specifically, **if a program is halted, go tos make it difficult to find a place in the programming that corresponds to the halted process—it makes it “terribly hard to find a meaningful set of coordinates in which to describe the process progress.”** That is, go tos make difficult the conflation of instruction with command, which grounds “programming.”"
      },
      "date": 1661462854237
    },
    {
      "type": "edit",
      "id": "15facc6b92ce0b0d",
      "item": {
        "type": "paragraph",
        "id": "15facc6b92ce0b0d",
        "text": "Structured programming languages “save” programmers from themselves by providing good security, where security means secure from the programmer. In the name of security, structured programming, which emphasizes **programming as a question of flow**, is itself giving way to data abstraction, which views programming as a question of interrelated objects and hides far more than the machine. Data abstraction depends on information hiding, on the nonreflection of changeable facts in software. As John V. Guttag, a “pioneer” in data abstraction explains, data abstraction is all about forgetting. Rather than “polluting” a program by enabling invisible lines of contact between supposedly independent modules, data abstraction presents a clean or “beautiful” interface by confining specificities, and by reducing the knowledge and power of the programmer. Knowledge, Guttag insists, is dangerous: “‘Drink deep, or taste not the Pierian Spring,’ is not necessarily good advice. Knowing too much is no better, and often worse, than knowing too little. People cannot assimilate very much information. Any programming method or approach that assumes that people will understand a lot is highly risky.”"
      },
      "date": 1661462970164
    },
    {
      "type": "edit",
      "id": "15facc6b92ce0b0d",
      "item": {
        "type": "markdown",
        "id": "15facc6b92ce0b0d",
        "text": "Structured programming languages “save” programmers from themselves by providing good security, where security means secure from the programmer. In the name of security, structured programming, which emphasizes **programming as a question of flow**, is itself giving way to data abstraction, which views programming as a question of interrelated objects and hides far more than the machine. Data abstraction depends on information hiding, on the nonreflection of changeable facts in software. As John V. Guttag, a “pioneer” in data abstraction explains, data abstraction is all about forgetting. Rather than “polluting” a program by enabling invisible lines of contact between supposedly independent modules, data abstraction presents a clean or “beautiful” interface by confining specificities, and by reducing the knowledge and power of the programmer. Knowledge, Guttag insists, is dangerous: “‘Drink deep, or taste not the Pierian Spring,’ is not necessarily good advice. Knowing too much is no better, and often worse, than knowing too little. People cannot assimilate very much information. Any programming method or approach that assumes that people will understand a lot is highly risky.”"
      },
      "date": 1661462972023
    },
    {
      "type": "edit",
      "id": "15facc6b92ce0b0d",
      "item": {
        "type": "markdown",
        "id": "15facc6b92ce0b0d",
        "text": "Structured programming languages “save” programmers from themselves by providing good security, where security means secure from the programmer. In the name of security, structured programming, which emphasizes **programming as a question of flow**, is itself giving way to data abstraction, which views programming as a question of interrelated objects and hides far more than the machine. **Data abstraction depends on information hiding, on the nonreflection of changeable facts in software. As [[John V. Guttag]], a “pioneer” in data abstraction explains, data abstraction is all about forgetting.** Rather than “polluting” a program by enabling invisible lines of contact between supposedly independent modules, data abstraction presents a clean or “beautiful” interface by confining specificities, and by reducing the knowledge and power of the programmer. Knowledge, Guttag insists, is dangerous: “‘Drink deep, or taste not the Pierian Spring,’ is not necessarily good advice. Knowing too much is no better, and often worse, than knowing too little. People cannot assimilate very much information. Any programming method or approach that assumes that people will understand a lot is highly risky.”"
      },
      "date": 1661463018676
    },
    {
      "type": "edit",
      "id": "15facc6b92ce0b0d",
      "item": {
        "type": "markdown",
        "id": "15facc6b92ce0b0d",
        "text": "Structured programming languages “save” programmers from themselves by providing good security, where security means secure from the programmer. In the name of security, structured programming, which emphasizes **programming as a question of flow**, is itself giving way to data abstraction, which views programming as a question of interrelated objects and hides far more than the machine. **Data abstraction depends on information hiding, on the nonreflection of changeable facts in software. As [[John V. Guttag]], a “pioneer” in data abstraction explains, data abstraction is all about forgetting.** Rather than “polluting” a program by enabling invisible lines of contact between supposedly independent modules, **data abstraction presents a clean or “beautiful” interface** by confining specificities, and by reducing the knowledge and power of the programmer. Knowledge, Guttag insists, is dangerous: “‘Drink deep, or taste not the Pierian Spring,’ is not necessarily good advice. Knowing too much is no better, and often worse, than knowing too little. People cannot assimilate very much information. Any programming method or approach that assumes that people will understand a lot is highly risky.”"
      },
      "date": 1661463114586
    },
    {
      "type": "edit",
      "id": "15facc6b92ce0b0d",
      "item": {
        "type": "markdown",
        "id": "15facc6b92ce0b0d",
        "text": "Structured programming languages “save” programmers from themselves by providing good security, where security means secure from the programmer. In the name of security, structured programming, which emphasizes **programming as a question of flow**, is itself giving way to data abstraction, which views programming as a question of interrelated objects and hides far more than the machine. **Data abstraction depends on information hiding, on the nonreflection of changeable facts in software. As [[John V. Guttag]], a “pioneer” in data abstraction explains, data abstraction is all about forgetting.** Rather than “polluting” a program by enabling invisible lines of contact between supposedly independent modules, **data abstraction presents a clean or “beautiful” interface** by confining specificities, and by reducing the knowledge and power of the programmer. Knowledge, Guttag insists, is dangerous: “‘Drink deep, or taste not the Pierian Spring,’ is not necessarily good advice. Knowing too much is no better, and often worse, than knowing too little. People cannot assimilate very much information. **Any programming method or approach that assumes that people will understand a lot is highly risky.**”"
      },
      "date": 1661463213665
    },
    {
      "type": "edit",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "paragraph",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist [[David Eck]] argues, “**every programming language defines a [[virtual machine]], for which it is the machine language**. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the limitations imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its separation of machine into software and hardware, the act of programming to the machine itself. Koss scoffed at the early notion of [[computers as brains]] because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of [[software as a commodity]], despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to [[define]] its [[Product]]. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "date": 1661463263083
    },
    {
      "type": "edit",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "markdown",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist [[David Eck]] argues, “**every programming language defines a [[virtual machine]], for which it is the machine language**. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the limitations imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its separation of machine into software and hardware, the act of programming to the machine itself. Koss scoffed at the early notion of [[computers as brains]] because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of [[software as a commodity]], despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to [[define]] its [[Product]]. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "date": 1661463264546
    },
    {
      "type": "edit",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "markdown",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist [[David Eck]] argues, “**every programming language defines a [[virtual machine]], for which it is the machine language**. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the [[limitations]] imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its separation of machine into software and hardware, the act of programming to the machine itself. Koss scoffed at the early notion of [[computers as brains]] because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of [[software as a commodity]], despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to [[define]] its [[Product]]. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "date": 1661463298663
    },
    {
      "type": "edit",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "markdown",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist [[David Eck]] argues, “**every programming language defines a [[virtual machine]], for which it is the machine language**. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the [[limitations]] imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its **separation of machine into software and hardware**, the act of programming to the machine itself. Koss scoffed at the early notion of [[computers as brains]] because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of [[software as a commodity]], despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to [[define]] its [[Product]]. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "date": 1661463367476
    },
    {
      "type": "edit",
      "id": "987eef5c778d5b01",
      "item": {
        "type": "markdown",
        "id": "987eef5c778d5b01",
        "text": "Thus abstraction both empowers the programmer and insists on his/her ignorance. Because abstraction exists “in the mind of the programmer,” abstraction gives programmers new creative abilities. Computer scientist [[David Eck]] argues, “**every programming language defines a [[virtual machine]], for which it is the machine language**. Designers of programming languages are creating computing machines as surely as the engineer who works in silicon and copper, but without the [[limitations]] imposed by materials and manufacturing technology.” However, this abstraction—this drawing away from the specificities of the machine—gives over, in its **[[separation of machine]] into software and hardware**, the act of programming to the machine itself. Koss scoffed at the early notion of [[computers as brains]] because “they couldn’t think in the way a human thinks, but had to be given a set of step-by-step machine instructions to be executed before they could provide answers to a specific problem”—at that time software was not considered to be an independent object. The current status of [[software as a commodity]], despite the fact that its instructions are immaterial and nonrivalrous indicates the triumph of the software industry, an industry that first struggled not only financially but also conceptually to [[define]] its [[Product]]. The rise of software depends both on historical moves, such as IBM’s unbundling of its services from its products, and on abstractions enabled by higher-level languages. Guttag’s insistence on the unreliability and incapability of human beings to understand underscores the costs of such an abstraction. Abstraction is the computer’s game, as is programming in the strictest sense of the word."
      },
      "date": 1661463388159
    }
  ]
}