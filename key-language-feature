{
  "title": "Key Language Feature",
  "story": [
    {
      "type": "html",
      "text": "A [[Key Language Feature]] is a feature in a programming language which according to the [[Blub Paradox]] in [[Paul Graham]]s [[Beating The Averages]], has the following properties:",
      "id": "afcc7a7ac86471438ab2235a031ec339"
    },
    {
      "type": "html",
      "text": " Domain independent -- useful in most (if not all) problem domains; [[Considered Harmful]] in at most a few.",
      "id": "f2068e6301b5ae2914c42eb160fa9597"
    },
    {
      "type": "html",
      "text": " If not present in a language, difficult or impossible to simulate without writing an interpreter to simulate a (different) language with the feature.",
      "id": "ce7b0a2dcb7613656d81d62aecaf85ac"
    },
    {
      "type": "html",
      "text": "\nIn several parts of the below discussion people also assumed that the feature should be \"essential\", which is not actually part of the given definition of a [[Key Language Feature]].",
      "id": "eee4059afc03ffaa462c28ff95816ad3"
    },
    {
      "type": "html",
      "text": "\nThe list of candidates for such features below is currently unsorted; as a possible refactoring it might be nice to sort it somehow. Note the term objects refers to any datatype here; and does not necessarily imply what is commonly referred to as [[Object Oriented]].",
      "id": "1654fc3c427d99bd3a1d398181c23442"
    },
    {
      "type": "html",
      "text": " <b>Support for each of the basic Paradigms (Imperative, Functional, Constraint/Logic, Goal-based - see [[There Are Exactly Three Paradigms]])</b> - all of these are both [[Domain Independent]] and subject to the [[Blub Paradox]]. This actually covers a great number listed in duplicate, below.",
      "id": "f35fa1095cbfb6e40e6ab3aa5bca6f0e"
    },
    {
      "type": "html",
      "text": " <b>Tables support</b> - ability to create tables/relations or something more general that are capable of associating data, in addition to support for relational operations between tables, constraints within and between tables, and automatic maintenance of appropriate indexing for the tables. Most languages don't have this, it is very much [[Domain Independent]] and has proven extremely difficult to implement via library (in any elegant, fast, bug-free manner) in languages that don't support them natively.",
      "id": "9a76d5a1b0c44f2cdfe5063e1dae3bee"
    },
    {
      "type": "html",
      "text": " <b>Language Integrated Query support</b> - ability to perform queries over tables, tree-structures, data (for [[Logic Programming]]) and just about anything else. Automatic optimization support for these queries based upon indexes.",
      "id": "fb2e65b8e34dbcf225fd06fcc231cb0b"
    },
    {
      "type": "html",
      "text": " <b>Patterns Matching and Analysis</b> - support for pattern-matching over and between values in the language and automatic extraction of sub-values for use when the pattern does match... ideally usable for such things as 'case' statements or expressions. If not part of the language by default, it is rare to see a language that supports more than the most primitive forms of pattern-matching (e.g. regexps). Ideally the pattern-matching ought to be advanced enough to casually write parsers for new languages (or support a library capable of such).",
      "id": "815a470fbeadad34c77596a2c16def5c"
    },
    {
      "type": "html",
      "text": " <b>Numbers</b> - Useful in any domain that involves measurement or that is related to a domain that involves measurement, which means EVERY domain (with maybe a couple exceptions). Depending on the language, you might be able to implement numbers if you didn't already have them... but you'd need to have several other features instead (especially pattern-matching, structural aggregates, and sequential composition). Really, they are too convenient to go without.",
      "id": "5dc62530010013be6eea6d308aa5c0eb"
    },
    {
      "type": "html",
      "text": " <b>Functions</b>. The ability to write functions, callable from any point in the program (subject to programmer limitations), with defined arguments and return value; with the requirement that upon completion of the function, control is transferred back to the caller.",
      "id": "f6ace689649485a5224c1045f9759b49"
    },
    {
      "type": "html",
      "text": " <b>Conditional Execution</b>. Ability to condition the execution of a portion of the program (or evaluate only part of an expression) based on a condition.",
      "id": "bd9d76c0c466b7780f26a57abaa29410"
    },
    {
      "type": "html",
      "text": " <b>Recursive definitions</b> (of procedures, functions. Requires either a multiple-pass compiler/interpreter, or prototypes of some sort (this isn't really a big issue these days; but I remember when [[Holy War]]s were waged over the merits of two-pass compilers)",
      "id": "22ac02d1695285542895783317db9762"
    },
    {
      "type": "html",
      "text": " <b>Recursive processes</b> (arising from recursive definitions) which require <b>one of</b>:",
      "id": "59515b7b5cb2dda1788fff94f3e787e5"
    },
    {
      "type": "html",
      "text": " <b>Enforced [[Tail Call Elimination]]</b>, or",
      "id": "2096a250d68cb25b6bac687a58e4bf11"
    },
    {
      "type": "html",
      "text": " <b>LIFO Memory Allocation</b> The ability to allocate additional memory from the runtime system in a fashion which obeys a [[Last In First Out]] discipline - the most recent object/memory block allocated is the first freed. Suitable for implementation on a stack.",
      "id": "d08c718352415563d637dcaa1fe30c77"
    },
    {
      "type": "html",
      "text": " <b>Dynamic memory allocation</b> (explicit or implicit). The ability to create additional \"objects\" at runtime which can have unbounded lifetime, subject to the limitations of system memory. In general, not suitable for stack-based implementation; requires what is commonly known as a <i>heap</i>. ",
      "id": "04c8280cf1c39fa6ebfacc157f860881"
    },
    {
      "type": "html",
      "text": " <b>[[Higher Order Function]]s</b>. The ability of a function to accept functions as arguments and return functions as results.",
      "id": "57d8392a1ca007587e7efbd7ddf8885d"
    },
    {
      "type": "html",
      "text": " <b>[[Lambda Expression]]s</b>. The ability to create a \"new\" function by binding arguments (supplied at runtime) with existing functions and logic. ",
      "id": "adb3a56065b884b992589f8678a3acd7"
    },
    {
      "type": "html",
      "text": " <b>[[Exception Handling]]</b>. The ability to signal a potentially parameterized fault and propagate flow of control back to a handler.",
      "id": "9641b20315d4ca6be1fd4de486960598"
    },
    {
      "type": "html",
      "text": " <b>[[Resumable Exception]]</b>:<br>The ability for an exception handler to propagate flow of control, potentially with parameters, back into the original operation or predetermined resumption points. Allows <i>much</i> greater modularization of error handling because the handler doesn't need to know as much about the implementation. Instead needs to determine only where it may resume, the general semantics of such resumption (usually in relation to the exception... (e.g. <b>catch</b>(div_by_zero<int>) { <b>resume</b> continue_with<int>(0); }\").",
      "id": "160808fa7ec76ff52314c220e07095f3"
    },
    {
      "type": "html",
      "text": " <b>[[Lexical Closure]]s</b>. The ability to create functions at runtime that \"capture\" (close over) bindings in the surrounding lexical environment. (Most commonly the captured bindings are of variables, but any class of thing whose names follow lexical scoping discipline are candidates to be captured. For example, in [[Common Lisp]] closures can capture block names allowing a closure passed down the stack to unwind back to the block.)",
      "id": "56f12fa0c83121071828d090a6de8bc7"
    },
    {
      "type": "html",
      "text": " <b>Structural aggregates</b> The ability to create complex datatypes/objects out of simpler ones, by providing associative aggregates (think structs/records/a subset of classes), and to create multiple instances of the aggregate.",
      "id": "c13725c7bdd2ec5186070d879190c44d"
    },
    {
      "type": "html",
      "text": " <b>Structured flow control</b>. Structured conditions (if/then/elif/else) and loops (for/foreach/do/while). Can be implemented atop recursive definitions or [[Call With Current Continuation]], [[Go To]], and conditional execution if you have them in the right combination.",
      "id": "36e3d2965c963768bbed31ae42fda181"
    },
    {
      "type": "html",
      "text": " <b>Sequential aggregates</b> Includes tuples and arrays, essentially.",
      "id": "d794d08f0f4175fb6a26cac81247671a"
    },
    {
      "type": "html",
      "text": " <b>[[Reference Semantics]] and aliasing</b> The ability to have multiple references to an object; either implicitly (in a language such as Smalltalk or Java, in which all/most variables are references) or explicitly (via pointers in C/C++/Pascal, etc.)",
      "id": "43ed15907ec2c19ab28e96c5aaf4c56a"
    },
    {
      "type": "html",
      "text": " <b>[[Parametric Polymorphism]]</b> The ability to define functions/types/whatever which are really a function which maps a \"type\" to something else. Templates in C++, pretty much any function in Lisp/Smalltalk.",
      "id": "b19aa330d17d11eabfffa380b353cc5d"
    },
    {
      "type": "html",
      "text": " <b>[[Multiple Dispatch]]</b>. The ability to dispatch on more than one argument to a function. If you don't have this feature you end up constructing a veritable zoo of various kinds of [[Visitor Patterns]] (ranging from extrinsic to hierarchical to acyclic) just to hack around this limitation. Each time you implement these patterns however you're basically building a one-off dispatching framework that you'll be duplicating a few days later when you get to the next bit of complicated logic.",
      "id": "63b94035c68a00fc0e0f0e73088a9224"
    },
    {
      "type": "html",
      "text": " <b>[[First Class Types]]:</b> Support for construction and communication of type-descriptors at runtime, along with their subsequent use when comes time to validate [[Type Safety]]. If [[Everything Isa]] object, then types and classes are objects ([[Meta Object Protocol]]). If [[Everything Isa]] value, then types are values. This is extremely useful [[Meta Programming]], and is of value whether or not one is using [[Dynamic Typing]] or [[Static Typing]] or something in between ([[Soft Typing]]). However, it is worth noting that [[First Class Types]] at runtime under '[[Static Typing]]' will also require including the compiler in the runtime environment.",
      "id": "673442579ff8f44583e4c928c4c9200a"
    },
    {
      "type": "html",
      "text": " <b>[[Causally Reflective Environment]]</b> The environment includes a full dynamic model of its own dynamic machinery, such as processes, stack frames, dispatch tables, semaphores, and so on. Changes to this model change the behavior of the environment accordingly.",
      "id": "a0a91aab7a6cc44823bcf7805a301bdd"
    },
    {
      "type": "html",
      "text": " <b>[[Introspection And Reflection]]</b> The ability to discover at runtime the properties/attributes of an object (without having to give the object that capability explicitly).",
      "id": "00f677c775da8a5d2d828301de7a45c9"
    },
    {
      "type": "html",
      "text": " <b>Modules</b>. This is a basic software engineering requirement. Divide software systems into cohesive units, define contracts for the modules, separate interface from implementation, allow independent evolution of caller and callee, etc, etc. Most popular languages do not support this (yet), or can be worked around painfully. Languages that support good modularity features:<br>Ada, Modula family, Standard ML. With support can be counted Java and C/C++. Ideally, modules should be [[First Class]].",
      "id": "c542198a6ef6208ee8976af2fb0912a3"
    },
    {
      "type": "html",
      "text": " <b>[[Aspect Oriented Programming]]:</b> or, more generally, the ability to describe [[Cross Cutting Concern]]s in one place, whether they be business rules or logging of messages, and automatically have these descriptions be leveraged at all other relevant points in the code. The fundamental capability to accomplish this has a <i>categorical duality</i> with <b>modules</b> - a direct inversion of dependencies. Instead of a value/function/class/etc. being described at one location and 'pulled' by clients that import it, client modules must be able to describe parts of a value/function/class/etc. and 'push' these parts to to a common location, often across modules. Lesser forms of this feature include 'open' functions (add new pattern-matches to a function) and 'open' types (add new tagged unions to a data type).",
      "id": "782dec493ccac69ed47a4ce342ead7f1"
    },
    {
      "type": "html",
      "text": " <b>[[Compile Time Resolution]]:</b> Formal support for performing communications to link arbitrary remote sources. In a 'dynamic' environment that possesses no distinct [[Compile Time]], this might relate more to the ability to specify lazy one-time executions to be performed at need or when initially loading the environment.",
      "id": "99a76f842c45bba4bd17556fff16f5c3"
    },
    {
      "type": "html",
      "text": " <b>Automatic [[Type Inference]]</b>. Essentially a precondition for [[Typeful Programming]] and for internally supporting types more complex than are conveniently described by hand (e.g. structured monads, [[Effect Typing]], etc.). Utterly impossible to implement in a language supporting only [[Manifest Typing]], it clearly requires implementing an interpreter or compiler to acquire its benefits. Can include both dynamic typed languages ([[Common Lisp]], [[Smalltalk Language]]) and statically-typed languages which use [[Type Inference]] ([[Ml Language]] and its successors, [[Haskell Language]]).",
      "id": "d6cb9826503323beca86e1c8b4f180ec"
    },
    {
      "type": "html",
      "text": "\nThe maybe list:",
      "id": "22cb63ed97c4af5653ee33e1259f5aeb"
    },
    {
      "type": "html",
      "text": " <b>[[Real Macros]]</b> (more generally <b>[[Extensible Programming Language]]</b>). Lisp users swear by these (see comments below). Other languages do without. Certainly, they are one of the cool features of [[Common Lisp]] and [[Scheme Language]]. On the other hand, macros are a way of automatically expanding things that can already be done in the language; anything which can be done with a macro can be done by hand (though this violates [[Once And Only Once]] -- which is why language aware macros are here....)",
      "id": "18d4dc4eb3284c132c63f33a3943bd95"
    },
    {
      "type": "html",
      "text": " <b>Support for Annotations:</b> Formal support for including <i>and</i> processing annotations that <i>aren't</i> intended to be processed by the final interpreter or compiler (but might be processed by something else in the post-processor pipeline, or some back-end other than the compiler such as an IDE or [[Literate Programming]], or plug-in type-checker or theorem prover or static verifier like lint or emily, or plug-in optimizers, or semantics extensions). More discussion available in [[Hot Comments]]. This class of extensions cannot be accomplished by [[Real Macros]] alone. ([[Annotation Metadata]] doesn't support the sort of processing described here.)",
      "id": "58c7b05dc32167214116415670374e72"
    },
    {
      "type": "html",
      "text": " <b>[[Explicit Management Of Implicit Context]]:</b> A mechanism to manage the context in which programs, subprograms, threads, thunks, and continuations are operating that is consistent across the language, all language libraries and modules, and integrated with the core language services. Especially the ability to replace much of the 'global' context with such context-limited services. Especially useful for supporting security, modularity, and scripting ([[Alternate Hard And Soft Layers]]) in a multi-user environment like a [[Web Server]] or [[Operating System]] or vehicle controller.",
      "id": "a1fb36104e260cff4587b198db8d70e3"
    },
    {
      "type": "html",
      "text": " <b>[[Dynamically Scoped Variables]]</b> (Not by default, but as an option.) The ability to create variable bindings with dynamic extent (they exist for as long as the binding form is on the stack) and indefinite scope (they can be referred to from anywhere). Moved to \"maybe\" because they are [[Considered Harmful]] in the [[Object Capability Model]]. Support for this is implied by [[Explicit Management Of Implicit Context]].",
      "id": "3701ae67d37e3cf1d15067115e628f56"
    },
    {
      "type": "html",
      "text": " <b>[[First Class Undo]]:</b> Ability to contextually 'undo' user-driven actions, especially those involving state-manipulation, at some point <i>after</i> they have already been committed, within the limits of what can logically be undone. Dealing with [[Human Computer Interaction]] either directly or indirectly is part of almost any programming environment, and [[First Class Undo]] can provide great support programmers involved in these fields. Further, even for internal-system coding, it can be useful in the post exception and error contexts. Also relates to language-features that perform backtracking, such as those seen in [[Constraint Logic Programming]].",
      "id": "7f7765c22c773cdd9b8cad4f3f30a4db"
    },
    {
      "type": "html",
      "text": " <b>[[Partial Evaluation]]:</b> An optimization that, if given formal support within a language, makes practical a much greater degree of [[Meta Programming]]. If not guaranteed, then programmers cannot count upon it",
      "id": "801cbb7be24966bcd873b116e7bccae4"
    },
    {
      "type": "html",
      "text": " <b>[[Static Assert]]:</b> Essentially [[Design By Contract]] + [[Partial Evaluation]] on steroids; would provide among the most powerful (and arbitrary) of code-proofs. Ideally allows for some flexible expressions.",
      "id": "326905a636c184786fc8a95a2d420c2e"
    },
    {
      "type": "html",
      "text": " <b>[[Garbage Collection]].</b> The ability of the system to recycle the storage allocated to objects which no longer contribute to the behavior of a program (or a useful subset thereof; such as those which are not linked to the root set.)  Flawed implementations make it [[Considered Harmful]] in many domains.",
      "id": "8e5fed049126ab94bde48e859ec572ef"
    },
    {
      "type": "html",
      "text": " <b>Encapsulation</b>. Different access levels (public, private, etc.) A key feature of many languages, particularly those which support object orientation and modules, although [[Python Language]] does not support this for either. It proves most valuable when programming in a team environment, where dictatorial control over how every programmer may be allowed to code his work proves impossible. For single-programmer or small-team projects, it potentially adds no value. Not quite as powerful or generic as a true, <b>Explicit [[Security Model]]</b>, especially a [[Capability Model]] (which can provide far more capabilities than 'public/private' access levels), but much easier to implement without introducing runtime costs.",
      "id": "472cafc95fd730d07bf71996c202325a"
    },
    {
      "type": "html",
      "text": "\nThings explicitly not included; move these above if you think they should be included (and say why):",
      "id": "3b93be041981136c876aed3c400e944c"
    },
    {
      "type": "html",
      "text": " <b>I/O</b>. Provided by the library in most languages; highly OS dependent in many cases. Typically not a key differentiator between languages.",
      "id": "75630d80db189476e1cddedf82bddc81"
    },
    {
      "type": "html",
      "text": " <b>Lists</b>. Can be done as a combination of sequential/structural aggregation and references/pointers. Likewise, other aggregate forms can be implemented as lists.",
      "id": "c29c2e9074d4d63ecbefd21591b1f141"
    },
    {
      "type": "html",
      "text": " <b>[[Generic Associative Collections]]</b>. Tables and Relations (ideal). Second-best:<br>Sets, maps, hashes, etc. Useful; but can generally be implemented in a library in a language which doesn't have these. (Should be part of the standard library, though... which really is just as much a part of the language as the keywords.)",
      "id": "2d25e39ba654dc145487807ed85956c5"
    },
    {
      "type": "html",
      "text": " <b>[[Call With Current Continuation]]</b>. Maybe; it's useful but I'm not entirely convinced it's essential. (It's also dangerous). Of course, if there was some way to limit the extent of the continuation...",
      "id": "0f5b1cea61e65c7bec2a10ce217a33e5"
    },
    {
      "type": "html",
      "text": " <b>[[Go To]]</b>. transfer control to an arbitrary point in the same function (lesser form of [[Call With Current Continuation]], still dangerous). But might not qualify - often [[Considered Harmful]].",
      "id": "0e09e663acb244f25e188cdf97719720"
    },
    {
      "type": "html",
      "text": " <b>[[Single Assignment]]/[[Referential Transparency]]</b>. Powerful features for complexity management and optimization (especially amenable to [[Partial Evaluation]], selective [[Lazy Evaluation]], and operation reordering). However, excluded above because these features aren't an 'end' in and of themselves... not so much as the optimizations they support are. Also, forcing the whole language to be 'pure' forces requires some counter-intuitive approaches to supporting concurrency, communications, and OS integration. Something like [[Mercury Language]] with its support for explicit and implicit 'purity' levels, or otherwise dividing functions from procedures within the language, might provide both the desired complexity control and the optimizations without the counter-intuitive IO monads. See [[Kill Mutable State]] for more on this view.",
      "id": "c3c91a68b469e338d95f20fed5cb5005"
    },
    {
      "type": "html",
      "text": " <b>Variables</b>. Objects with mutable state. Assumes some method to mutate the state. Opposite view of [[Single Assignment]]/[[Referential Transparency]].",
      "id": "e9aa786cfa8528f8bf0cf676e59c3176"
    },
    {
      "type": "html",
      "text": " <b>[[Pointer Arithmetic]]</b>. Used as a surrogate in low-level languages to implement (in an unclean fashion) the higher-level features found in higher-level languages. This also includes other unsafe practices as pointers-to-stack-objects and the like. While flexible, often [[Considered Harmful]].",
      "id": "9ba535fc778fae6fa602591194cbc5cb"
    },
    {
      "type": "html",
      "text": " <b>[[Unsafe Type Casts]]</b>. Like pointer arithmetic, necessary in low-level languages to get around the restrictions of the language. Unnecessary in high-level languages.",
      "id": "8e52f585a0f3294aa26a40da02325025"
    },
    {
      "type": "html",
      "text": " <b>[[Static Typing]]/[[Dynamic Typing]]/[[Soft Typing]]</b>. I believe that neither is inherently better than the other; though certainly Automatic [[Type Inference]] is better than being forced to use [[Manifest Typing]] at <i>every</i> place in the code. ",
      "id": "1ac895d22cf61f4f91a784ad50cbfce2"
    },
    {
      "type": "html",
      "text": " <b>Preprocessors and Text-based Macros</b>. (In other words, macros which operate on the text stream before it is parsed by the compiler/interpreter; ala C/C++) Some consider these evil; many languages have no such capability and do fine. Others consider these essential - usually to work around a deficiency or limitation in the language proper. (Part of the problem, I suppose, is that the C/C++ preprocessor is so god-awful...)",
      "id": "f04a567612a98351061653826f66f9c0"
    },
    {
      "type": "html",
      "text": " <b>Concurrency</b> While this is a good thing (and somewhat necessary given the future of processors is in multiple processing cores), the jury is still out on the best way to implement concurrency. Several approaches have been tried. <b>[[Co Routine]]s</b> were one of the first; and still useful in some instances -- however when used to implement non-preemptive multithreading, it doesn't scale to multiprocessor systems and few production languages these days have generic coroutines as a language feature. <b>[[Preemptive Multithreading]]</b> (multiple threads running in an address space; with context switching beyond the control of the language in most cases) is common in many languages, either as a language feature (Java) or as an OS extension (C/C++). It introduces a whole rats-nest of synchronization issues. It scales well to multiprocessors; but less well to distributed systems. Coroutines or other mechanisms used to implement <b>[[Communicating Sequential Processes]]</b> and <b>[[Actors Model]]</b> approaches look promising; they scale to any system (single-CPU, multiple-CPU, distributed) and avoid the some of the synchronization problems of multithreading. ",
      "id": "980ed473c6467a1fc6a9b24461c52b05"
    },
    {
      "type": "html",
      "text": " <b>[[Dataflow Programming]]</b>, especially in combination with [[Data Delta Isolation]] - essentially the ability to 'subscribe to' expressions written in the language and receive the altered values with a controllable latency. In normal programming, it seems there is only support for 'pulling' from data cells to evaluate the expression. Languages without support force you to jump through hoops to make this work:<br>dig in and modify memory/variable services to add subscriptions, intelligently resist cyclic recursion, deal with inconvenient syntax (dataflow expressions would likely look extremely different from regular ones), etc.). [[Dataflow Programming]] is of high value in realtime distributed applications, where the cost of polling expressions is too high and you want latency to be minimized. However, down in the 'excluded' list because [[Dataflow Programming]] essentially depends on Concurrency (which is in the 'excluded' list for some reason).",
      "id": "b4160974b412555a0049f619184ef99f"
    },
    {
      "type": "html",
      "text": " <b>Transactions</b> Support for atomic manipulation of shared mutable state in the context of concurrent operations, and useful whether that shared state is a filesystem or individual cells of memory shared between threads. As with concurrency, the jury is out on how to best perform it. Optimistic [[Software Transactional Memory]] looks promising.",
      "id": "4ca1683b3b3337b277714a09e91b2216"
    },
    {
      "type": "html",
      "text": " <b>Linkage</b> Ability to link high-level code to low level code written in the correct tool for the low-level problem. I am being perfectly serious here:<br>I have seen and worked on problems where the only solution was to use [[Cee Language]] or [[Assembly Language]] with pointer hopping. One bad case actually required allocating 1.5 GB of RAM in one contiguous chunk and using it as a bitvector. It turned out that any other method would exceed the 4GB address space limitation of the processor in the worst case. [[Alternate Hard And Soft Layers]] can pay out. (But this is a more specific form of [[Compile Time Resolution]], and doesn't need to be formal within the language; given good support for [[Compile Time Resolution]] and [[Partial Evaluation]], this isn't necessary.)",
      "id": "ea421c069d6d1d883305f4e5bee01d2e"
    },
    {
      "type": "html",
      "text": " <b>[[Subtyping And Subsumption]]</b> The heart of [[Object Oriented]] (part of it, anyway). The ability to specify that one type can substitute for another in any given context, and the ability to actually perform that substitution. Note that inheritance is a mechanism for this; not the only one. This is only really an issue for statically typed languages, dynamically typed languages get this for free. On the 'explicitly not included' list because [[Object Oriented]] itself is not among the [[Key Language Features]], and is strongly related to [[Multiple Dispatch]] and [[Aspect Oriented Programming]].",
      "id": "5ea711d781ff12127a522b2a91706f7b"
    },
    {
      "type": "html",
      "text": " <b>Explicit [[Security Model]]</b> Can provide far stronger, truer, more generic security than mere <b>Encapsulation</b>. Especially applicable within 'systems' programs that involve multiple users or multiple programmers. If one is going to have any security model, it is important to have a common, pervasive security model integrated with the language standard libraries and other shared program components; the alternative, having different security models for different components and needing to translate between them for each library, is such a hassle as to render the feature useless in every library. <i>Which</i> [[Security Model]] doesn't matter so much as that it is a <i>provable</i> security model, and is readily used in practice with minimal hassle (the easiest way to do things ought to be the most secure way to do things), so integration with [[Explicit Management Of Implicit Context]] is desirable (reducing the need to pass security-parameters around explicitly). [[Capability Security Model]]s seem the most promising for this sort of integration (due, largely, to their inherent locality of internal reference, which is both highly subject to optimization and allows for distributed management of authority). [[Object Capability Model]] naturally applies as an extension to Encapsulation in OOP languages, whereas [[Simple Public Key Infrastructure]] (a [[Password Capability Model]]) or some modification thereof (one such model described in [[Explicit Management Of Implicit Context]]) might be useful in a distributed languages with [[First Class]] processes (moving towards [[Languages Are Operating Systems]]). While a good [[Security Model]] is certainly subject to the [[Blub Paradox]] (being very difficult to implement or add, and especially integrate, with a system where it doesn't already exist), it should probably remain with the concurrency support issues above:<br>there simply isn't much need for this level of 'true' security before one has concurrency; any demand to diminish accidental coupling can be supported via the lesser <b>Encapsulation</b>.",
      "id": "718ba92ee4ee05293e715ae001f00c28"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "093abd39ae949e3aa4972bc737a3db84"
    },
    {
      "type": "html",
      "text": "\nOk, I think somebody has an attitude about what a key language feature is. Considering that IO, Linkage, and GOTO are on the list of explicitly not included, while Reflection is on the list of must have makes this list rather off the wall. ",
      "id": "267627636bffb552a0be3d06df573e0c"
    },
    {
      "type": "html",
      "text": "<i>You misunderstand the list. The categorization is NOT one of 'must have' and otherwise. It is a list of 'definitely is a [[Key Language Feature]]' (in accordance to the definition at the top of this page) vs. 'useful, but either not subject to [[Blub Paradox]] or not Domain Independent'.</i>",
      "id": "5a99936bfc526b3f65f6f33d39a9c6f7"
    },
    {
      "type": "html",
      "text": "\nNo language will ever get off the ground with IO. ",
      "id": "d81c4b2d20ede31e766947dda234bceb"
    },
    {
      "type": "html",
      "text": "<i>Perhaps. But plenty of languages have gotten off the ground without <b>standardizing</b> IO - i.e. without making IO part of the language specification. That said, I happen to be a distributed systems weenie, and I am all for putting IO and related features (pickling, moving executables, etc.) as [[Key Language Feature]]s, but I'm willing to acknowledge that most problem domains really don't require it.</i>",
      "id": "43aa27fd5feb99ccecec525aaee895a7"
    },
    {
      "type": "html",
      "text": "\nNo language can grow beyond the vision of its creator without low-level Linkage available (hint: [[Compile Time Resolution]] will not get you this; it is irrelevant to the issue): it is the only to access OS features that do not exist on the designer's platform. ",
      "id": "cdfd5d8e4bc7ecad98c795c8464572c9"
    },
    {
      "type": "html",
      "text": "<i>Access to the OS is often well abstracted as a set of services, modules, or procedures in a language whether or not the language  is interpreted vs. compiled. Where does 'linkage' as a language feature come into that? In any case, 'linkage' doesn't seem very domain independent as a language feature. I do agree that [[Compile Time Resolution]] won't help for [[Operating System]] access; it helps more for [[Compile Time]] access to foreign resources (be they text files, remote databases, or ELF executables).</i>",
      "id": "ce3d93da493b4b06c733ed990f5bb03d"
    },
    {
      "type": "html",
      "text": "\nA few years ago I would have said unsafe casts are rare but mandatory. I now find that they can be subsumed into the core by adding a handful of core library functions that convert between scaler types and arrays of bytes without changing any bits.",
      "id": "e471d542656674419e011ff4e75d50d4"
    },
    {
      "type": "html",
      "text": "\nIf you think about the rule about writing an interpreter to simulate a different language to simulate a different language, there is no getting out of the need to add linkage to assembly code as sometimes you just cannot do without it. I really shouldn't have to monkeypatch some other process besides my own, but sometimes it is necessary.",
      "id": "c359080a8b71fa5a35d5b50c3fe2ec74"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "093abd39ae949e3aa4972bc737a3db84"
    },
    {
      "type": "html",
      "text": "\nNow, dependency information between the various features:",
      "id": "383d6c351b3290c8834a60383e01de46"
    },
    {
      "type": "html",
      "text": " \"A implies B\" means that if a language has feature A, then feature B comes \"for free\". Likewise, (A && B) implies C means if a language has both A and B, then feature C comes \"for free\" (for free means with minimal effort on the part of a programmer, and suitable for implementation in a library written in the language).",
      "id": "c52296c51e53c48e1d801a6c7e69cf98"
    },
    {
      "type": "html",
      "text": " \"A requires B\" means that if language has feature A, it MUST also have feature B. Likewise for the (A && B) requires C",
      "id": "02c358d26a1f7ebf908c5c89f9881e53"
    },
    {
      "type": "html",
      "text": "<b>[[Recursive Processes]] require Functions</b>. Should be obvious.",
      "id": "918d70c5ff6ff02f172de12fc97384d5"
    },
    {
      "type": "html",
      "text": "<b>[[Recursive Processes]] require [[Recursive Definitions]]</b>. Also should be obvious.",
      "id": "74e3a712605eb5e8d365c463218e7e28"
    },
    {
      "type": "html",
      "text": "<b>[[Recursive Processes]] require (LIFO Memory Allocation or Enforced [[Tail Call Elimination]])</b>.",
      "id": "22415221ad437d98f49422319dd8a23e"
    },
    {
      "type": "html",
      "text": "<b>Dynamic Memory Allocation implies LIFO Memory Allocation</b>. If you have a heap, you can simulate a stack. Simple enough.",
      "id": "e882213a57bf2b100629c664c7d417c2"
    },
    {
      "type": "html",
      "text": "<b>[[Garbage Collection]] implies Dynamic Memory Allocation</b>. Doesn't make any sense without it.",
      "id": "691fca984b089da0ee9a93d9c6baabed"
    },
    {
      "type": "html",
      "text": "<b>[[Lambda Expression]]s requires [[Higher Order Function]]s</b>. Should be obvious. Note that the converse is not true; C/C++ has [[Higher Order Function]]s if you count function pointers; but it doesn't have lambda expressions. See next rule why not.",
      "id": "887856aa8a5c06133e175b1f854be18a"
    },
    {
      "type": "html",
      "text": "<b>[[Lambda Expression]]s requires [[Garbage Collection]]</b>. It's often said that garbage collection is required for a [[Functional Programming Language]] (especially one with [[Side Effect]]s; without side effects reference counting will suffice). This is one reason why. The result of a [[Lambda Expression]] must almost always be heap-allocated, as they do not obey LIFO discipline. Furthermore, the usage patterns of lambda expressions (they get passed around like a cigarette) makes manual memory management of these dang near impossible. For this reason; I claim that lambda expressions <i>require</i> [[Garbage Collection]].",
      "id": "3499959fed23a6e552d7a9802410542a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "093abd39ae949e3aa4972bc737a3db84"
    },
    {
      "type": "html",
      "text": "<b>Thread mode stuff</b>",
      "id": "b10fde845eb0c61df73582ae290bb2e5"
    },
    {
      "type": "html",
      "text": "\nRegarding <b>Preprocessors and Text Macros</b>",
      "id": "d74c88005ab1a05c7b27c57d471aa26f"
    },
    {
      "type": "html",
      "text": "<i>This is an interesting entry given the genesis of this page. From a [[Smug Lisp Weenie]]s' point of view, this is the poster child for the [[Blub Paradox]] -- anyone who thinks that macros are an optional feature (let alone evil) is programming in Blub where Blub is a language that either doesn't have macros at all (e.g. Java or Python) or has a horrendously broken thing that it happens to call macros (e.g. C's text/token macros). Lumping preprocessors and macros (in the [[Common Lisp]] sense) together is probably not going to lead to clarity.</i> ",
      "id": "d160947eeca5fe9563a6f1757ef1f76c"
    },
    {
      "type": "html",
      "text": "\nGood point; I'll happily separate preprocessor text macros (which perform substitutions on the text before the bulk of the scanning and parsing is done) with language-aware semantic macros ala [[Common Lisp]]. However, an interesting question still remains: If you accept the viewpoint that macros operate \"outside\" the core language; they are often are used to automate things that the core language cannot. Which leads to two viewpoints: 1) Macros reveal a deficiency in the core language, rather than using an \"outside\" mechanism, the core language should be modified to accommodate. This may be more C++ bias ([[Bjarne Stroustrup]] is known to despise the C preprocessor; many features in C++ were put in to eliminate a common preprocessor use). 2) Macros are a legitimate tool; and as they operate using the standard capabilities of the core; they allow the language to be extended in ways which do not compromise the core. Macros are a layer on top, and layering is good. Personally, I tend to fall in between - when I use a macro, I wish there were a better way. Perhaps this is again C/C++ bias; though I've yet to encounter a preprocessor whose semantics were completely clean and neat. -- [[Scott Johnson]]",
      "id": "c6c7e4b5ca802374624189855fed0016"
    },
    {
      "type": "html",
      "text": "\nHmmm. I vote for 2) but I'm not sure I buy your definition of \"outside the core\". In [[Common Lisp]], macros are part of the core which, by their presence, allow other things to be left out of the core. For instance, in [[Common Lisp]] most of the \"control constructs\" that programmers normally use in are macros on top of more primitive control flow constructs. (For instance, all the structured looping constructs in [[Common Lisp]] are built on top of a primitive that is essentially the same as C's goto.) Thus those control constructs are not part of the \"core\" the way for and while loops are in C/Java/Python/Perl. (They are part of the language standard - most of the language standard is really specifying the standard library, not the language core.) Also perhaps worth noting: [[Common Lisp]] macros are <i>not</i> a preprocessor - they are more like a hook into the compiler itself. Basically whenever the compiler hits a \"call\" to a macro it passes the macro form to the macro code which then returns a form that the compiler compiles in the place of the original form (which might entail expanding macros that occur in the new form). If that doesn't seem clean and neat enough for you, I'd be curious what seems unclean or unneat about it. -- [[Peter Seibel]]",
      "id": "14f9608367f6c15db48b21af5098df8e"
    },
    {
      "type": "html",
      "text": "\nIn Lisp and Scheme, \"macros\" are just ordinary code that happens to execute at compile time, and as such they are utterly different in nature than text macros in other languages. #2 is definitely the only one that applies, not #1, in Lisp-family languages. <i>[Nitpick: Scheme has two macro systems, and in one of them macros are not just ordinary code.]</i>",
      "id": "ee396adccfad67cbcc72dd95003fbc29"
    },
    {
      "type": "html",
      "text": "\nThe word \"macro\" has always meant, as the core of its definition, \"something that happens at compile time, not run time\", which is why the word \"macro\" is used in both Lisp and e.g. C, even though the constructs thus referred to are otherwise unrelated. Mentally substitute the phrase \"compile-time first-class function\" for \"Lisp macro\" when in doubt.",
      "id": "79e09b98f48d5ff4dd6f95eb0d34cf2b"
    },
    {
      "type": "html",
      "text": "\nThus it is mostly uncontroversial in the C/C++ world that C/C++ macros are mostly a bad language feature (although essential in C and in a few contexts in C++), yet uncontroversial in the Lisp world that Lisp/Scheme macros are mostly a good and essential language feature (although susceptible to misuse, as with anything).",
      "id": "83a1f6829e1c33bdeda9d0f0137c85db"
    },
    {
      "type": "html",
      "text": "\nThere is no contradiction; the \"macros\" in question are quite different things in the two language families.",
      "id": "576b3eab1345846b75ca74d565fedbcf"
    },
    {
      "type": "html",
      "text": "-- [[Doug Merritt]]",
      "id": "f76d5e207c4438013bad8dcc6bd9d503"
    },
    {
      "type": "html",
      "text": "\nSo <i>that's</i> what [[Lisp Macro]]s are... [[Forth Language]] also has the notion of compile-time (immediate) vs. run-time semantics. One can define a Forth word to have either or both types of semantics. As with Lisp, it can be used to good effect to create domain specific languages and to extend the compiler. Also as with Lisp, <i>all</i> the flow control words in Forth are immediate words implemented using a couple of branching primitives. This allows the user to extend the Forth compiler with novel flow control constructs.",
      "id": "f7ca0f36310029be495fc24ea75becaa"
    },
    {
      "type": "html",
      "text": "[<i>Lisp Lisp Lisp. Macros Macros Macros. Blah blah blah. If macros and lisp are <b>so great</b>,  let's see them implement <b>[[Tutorial Dee]]</b> or a similar query language right into the Lisp program using Macros. Good luck. And no, I don't mean just a bunch of brackets smashed together that kind of look like a half assed macaroni/nail clipping based relational language in oatmeal.</i>]",
      "id": "c5877a3ebe90f2389d0880c1ca4bddca"
    },
    {
      "type": "html",
      "text": "\n[[Tutorial Dee]] could be done. SQL has been done. Admittedly, [[Lisp Macro]]s don't offer considerable manipulation of syntax (Lisp has no real syntax) so it would look 'ugly' by some peoples' standards (and beautiful by others...). What's up with your ranting? Weenie [[Feature Envy]]? ",
      "id": "3c50a0e7adb571d314e05faac0f1603b"
    },
    {
      "type": "html",
      "text": "<i>Actually, I'm envious of Algol style syntax - and using Lisp macros I couldn't implement the most important feature I needed - Algol derivative syntax - which [[Tutorial Dee]] and Cee/Oberon style languages have. In other words,  if I was using Lisp - I would be very <b>envious</b> of Algol style languages. If a weenie steps out of first person [[Smug Lisp Weenie]] view for a moment - he can see that all the snobbish arguments <b>for lisp</b> can be used <b>against lisp</b>. Its strength is its weakness. One can always fork a Lisp process from within an Algol program if they need Lisp, too.</i>",
      "id": "2e150768f7b3dc868916c67b3b6cde16"
    },
    {
      "type": "html",
      "text": "\nIt seems <i>wrong</i> to complain that a feature not meant to deliver some other feature you desire isn't delivering it. A bit like saying: \"Tables suck!  They don't give me secure communications over a network!\"  Admittedly, macros and syntax are somewhat more related, but they're still distinct facilities. Macros allow compile-time execution of code. Extensible syntax allows manipulation of the parser. Lisp has the former and lacks the latter. Either of them offer <i>mechanisms</i> for embedding [[Domain Specific Language]]s, and they combine in a rather powerful way, but they are <i>distinct</i> features.",
      "id": "6883b09585299f7b4e524b539571b3e9"
    },
    {
      "type": "html",
      "text": "<i>It doesn't provide me with a [[Domain Specific Language]], it only provides more Lisp.</i> ",
      "id": "902847b9b68304e876789dcc40af92ff"
    },
    {
      "type": "html",
      "text": "\nAh, you must be promoting your strange idea that language = syntax and is independent of semantics.",
      "id": "7795e4fe5e2d5b4d738aa2fcfa6a5f0a"
    },
    {
      "type": "html",
      "text": "<i>The idea that it offers a [[Domain Specific Language]] is actually just another way of saying it provides more Lisp. Providing domain specific languages can be done by forking processes in most languages - so I don't consider it a feature of Lisp to provide domain specific languages (think about it: since [[Lisp Does Not Provide Domain Specific Languages]], it just provides more lisp). Forking an interpreter (such as forking a PHP interpreter from a Cee program, or forking a Python interpreter from a Cee program, or forking some [[Pascal Script]] interpreter from a [[Free Pascal]] program) provides more power. First, someone has already written the interpreter or domain specific language which I can fork and make use of. Second, these interpreters are actual languages - not just more Lisp on top of Lisp. They truly are domain specific languages (consider forking [[Tutorial Dee]] compiler or interpreter).</i>",
      "id": "c4e0ac587e6ede55f3ffe5f5b519a05e"
    },
    {
      "type": "html",
      "text": "<i>Another domain specific language is Regex. Lisp is not the only language capable of extending itself - consider a regex interpretter built into an executable (Cee or Freepascal program). Consider I wrote an SQL interpreter inside a program. SQL and regexes are truly domain specific languages - whereas Lisp on top of Lisp, is just Lisp - it isn't domain specific language. It's maybe domain specific Lisp.</i>",
      "id": "bef38c02a889e1cfe006a65fd549fd2a"
    },
    {
      "type": "html",
      "text": "<i>[[Smug Lisp Weenies]] go on to argue that it takes too long to write languages that are forked or parsed. They argue that Lisp offers us this power of writing a language inside Lisp. But, Lisp is just Lisp. It isn't a domain specific language - it's more like domain specific Lisp - which is the very flaw of lisp, in that it does not create domain specific languages... but supposed domain specific Lisp (which forces one to program with odd functional syntax, which is not very domain specific). Forking interpreters that are already written and ready to go - is much more domain specific. Parsing a string inside a program, is more domain specific (parsing INI, parsing SQL, etc). And don't think that one has to write his own SQL or INI interpreter - their are already plenty written available as modules.</i>",
      "id": "91be9f1d112dc771441cac316a48f713"
    },
    {
      "type": "html",
      "text": "<i>[[Smug Lisp Weenies]] are contradictory: the domain specific Lisp languages are <b>not</b> languages at all. They are just more <b>lisp on lisp</b>. However, if I write an SQL interpreter or Regex interpreter module for a Cee program or Freepascal program, this truly is <b>domain specific</b>. Actually I don't have to <b>write</b> a domain specific language many times - there are plenty of <b>existing</b> domain specific languages available that can be forked (perl, awk, regex, php, INI parser, pascalscript, JScript, web language could be forked, [[Brain Fuck]] could be forked, compiler could be forked and launch a program right after compiling, etc). I can reuse a domain specific INI, Regex, or SQL parsing module over and over again in any language that can fork a process or parse a string.</i>  ",
      "id": "8689e2cd740ad51b0f4c42a9feb3d75a"
    },
    {
      "type": "html",
      "text": "<i>This is truly domain specific: being able to utilize INI syntax, regex syntax, SQL syntax, script syntax, right inside a program on a string (or on a file that is read). One could even <b>fork</b> a Lisp interpreter - if they needed - but I think rather a more domain <b>specific</b> language should be forked. See the <b>irony</b>: lisp isn't very domain specific. In other words, its strength is a weakness - and its claims are jokingly recursively contradictory.</i>",
      "id": "f175988be19cd6f1192bccd5c82c0a59"
    },
    {
      "type": "html",
      "text": "\nThe assertions found in the above italic paragraphs are bizarre - somehow forking an interpreter constitutes embedding, but a language whose syntax consists of [[Ess Expressions]] isn't a [[Domain Specific Language]]? I think [[Paul Graham]] would point to RTML as an example of a [[Domain Specific Language]]. It's hard to deny that it's domain specific. Is it not a language because it's got Lisp syntax? Isn't Lisp a language?",
      "id": "a279d602a918a626bda78af241efe994"
    },
    {
      "type": "html",
      "text": "\nIncidentally, contrary to the admissions made by the non-italic participant in the preceding discussion, [[Common Lisp]] <i>does</i> allow manipulating the parser, through the use of reader macros. It's just that it's far too painful to implement any language that isn't LL(0) that way, and, as execrable as Lisp's syntax is, it's hard to design something better that's LL(0), especially if you also want to be able to use macros to manipulate it. (I would ask defenders of Lisp syntax to consider why all-capitals is hard to read, and compare that to an all-round-bracket syntax.)",
      "id": "c0fbc505934195f1644e641e230f038a"
    },
    {
      "type": "code",
      "text": " You are in a maze of twisty little parentheses, all alike.",
      "id": "0d373b0bbfdb9503cec48cc69de9ec8e"
    },
    {
      "type": "html",
      "text": "Actually, I would argue that Lisp is (with the possible exception of syntax) the ultimate interpreted language. Yes, Lisp compilers exist, but Lisp's features can (as noted by Greenspun) be implemented in other languages by writing a Lisp interpreter. Whereas the features missing from Lisp (other than nice syntax) that make Lisp look a little Blubish to, say, [[Smug Haskell Weenies]] can, as far as I can see, only be implemented by writing a compiler (loosely speaking, that is - Haskell interpreters exist, but they do a compiler-like amount of static analysis at load-time).",
      "id": "20bf556a79cef86660dc292475d0a6a8"
    },
    {
      "type": "html",
      "text": "<b>I would agree that the italic rant is a bit weird. He talks about \"just\" forking processes, but ignores the overhead that simple forking requires; and I don't think he understands how difficult it is to mingle domain specific languages when you have to \"fork out\" to get those advantages. And, finally, he's assuming that there exists specific languages for your domains, and that if there isn't, it's a simple matter of firing up your favorite parsing tools, create a compiler (or interpreter) for your new domain, and write your language, all in one go! What are you supposed to do, if you don't want to go through that work -- or, for that matter, can't know the syntax of the yet-to-be-defined language, because you don't know what it's going to look like? Well, I would <i>suppose</i> that you can start with a simple, easy to manipulate and extend syntax, that already comes with an industrial-strength language behind it, and then gradually extend its syntax piecewise and experimentally, until you have a brand new domain specific language that can be optimized to near-C levels if necessary, and can be easily mixed with other existing (and even developing) domain specific languages where those domains intersect...or, I <i>suppose</i> you could just write a compiler, and fork it...</b>",
      "id": "2cec8de086e7c66b0cd9ac16f80dbcd0"
    },
    {
      "type": "html",
      "text": "<b>Somehow, I have the feeling that if forking processes really is more convenient than creating new domain specific languages as needs arise, that [[Smug Lisp Weenies]] would have figured that out decades ago. But then again, perhaps they did...you could find C and FORTRAN compilers for Lisp Machines...but then yet again, perhaps that's just a fallback to the idea that \"once something is written, you shouldn't rewrite it, but just let it be, in the language that it's originally written in, for all sorts of different reasons!\" -- Alpheus</b>",
      "id": "dd691da2c7d4bc53cba062539b211a58"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "093abd39ae949e3aa4972bc737a3db84"
    },
    {
      "type": "html",
      "text": "\nRe: [[Lambda Expression]]s:",
      "id": "d70468704ce1bf0ae35f8e799772de07"
    },
    {
      "type": "html",
      "text": "(<i>Is this different from the definition of [[Lexical Closure]]s below?</i>)",
      "id": "1b4ea29b3deee53548e8ff9347ba819f"
    },
    {
      "type": "html",
      "text": "\nMy distinction between the two is: [[Lambda Expression]]s might not have access to the referencing environment in which they were created; and can be used in languages which don't have nested lexical scoping. A C++ [[Functor Object]] (ignoring the [[Garbage Collection]] issue noted above) could thus be considered a form of a [[Lambda Expression]]. [[Lambda Expression]]s need to be [[First Class Object]]s to be much use. A [[Java Inner Class]] object declared within a method is kind of like a [[Lambda Expression]] (it does have access to the environment; but only to variables declared final. In reality; the variables are copied into the object, and no reference is kept to the enclosing scope beyond creation).",
      "id": "28e9386be1c4f1c8e79a18cbb6e57f56"
    },
    {
      "type": "html",
      "text": "\nA [[Lexical Closure]], on the other hand, does have access to the referencing environment in which it is created (including the ability to modify that environment); but need not be first class. [[Lexical Closure]]s aren't that tricky to implement until you try to have last longer than their referencing environment; in which case they become a royal pain (they tend to require spaghetti/cactus stacks). [[First Class]] [[Lexical Closure]]s are nice to have, obviously; as they generalize both concepts. However, they complicate the implementation of a language greatly.",
      "id": "902302a735492a86965d8085ed4677dc"
    },
    {
      "type": "html",
      "text": "\nOf course, I may be all wet here.",
      "id": "6270ebf9b2209f8626f7defa16cdcdc7"
    },
    {
      "type": "html",
      "text": "-- [[Scott Johnson]]",
      "id": "e9659f651bea0ab4590105cbd7b19280"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "093abd39ae949e3aa4972bc737a3db84"
    },
    {
      "type": "html",
      "text": "See also [[Quest For The Perfect Language]]",
      "id": "1a021a77280273a5b66e36c542f88a1e"
    },
    {
      "type": "html",
      "text": "\n[[April Zero Eight]]",
      "id": "8969b5227d1a212de45ed888a02611f6"
    },
    {
      "type": "html",
      "text": "\n[[Category Programming Language]]",
      "id": "a8a143b1511db6607992d892470fe39a"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?KeyLanguageFeature c2.com]",
      "id": "5eb9d69307d5887883e95f53166d363c"
    }
  ],
  "journal": [
    {
      "date": 1415512079000,
      "id": "d27a089823d679c0c4828145fdcc4ab1",
      "type": "create",
      "item": {
        "title": "Key Language Feature",
        "story": [
          {
            "type": "html",
            "text": "A [[Key Language Feature]] is a feature in a programming language which according to the [[Blub Paradox]] in [[Paul Graham]]s [[Beating The Averages]], has the following properties:",
            "id": "afcc7a7ac86471438ab2235a031ec339"
          },
          {
            "type": "html",
            "text": " Domain independent -- useful in most (if not all) problem domains; [[Considered Harmful]] in at most a few.",
            "id": "f2068e6301b5ae2914c42eb160fa9597"
          },
          {
            "type": "html",
            "text": " If not present in a language, difficult or impossible to simulate without writing an interpreter to simulate a (different) language with the feature.",
            "id": "ce7b0a2dcb7613656d81d62aecaf85ac"
          },
          {
            "type": "html",
            "text": "\nIn several parts of the below discussion people also assumed that the feature should be \"essential\", which is not actually part of the given definition of a [[Key Language Feature]].",
            "id": "eee4059afc03ffaa462c28ff95816ad3"
          },
          {
            "type": "html",
            "text": "\nThe list of candidates for such features below is currently unsorted; as a possible refactoring it might be nice to sort it somehow. Note the term objects refers to any datatype here; and does not necessarily imply what is commonly referred to as [[Object Oriented]].",
            "id": "1654fc3c427d99bd3a1d398181c23442"
          },
          {
            "type": "html",
            "text": " <b>Support for each of the basic Paradigms (Imperative, Functional, Constraint/Logic, Goal-based - see [[There Are Exactly Three Paradigms]])</b> - all of these are both [[Domain Independent]] and subject to the [[Blub Paradox]]. This actually covers a great number listed in duplicate, below.",
            "id": "f35fa1095cbfb6e40e6ab3aa5bca6f0e"
          },
          {
            "type": "html",
            "text": " <b>Tables support</b> - ability to create tables/relations or something more general that are capable of associating data, in addition to support for relational operations between tables, constraints within and between tables, and automatic maintenance of appropriate indexing for the tables. Most languages don't have this, it is very much [[Domain Independent]] and has proven extremely difficult to implement via library (in any elegant, fast, bug-free manner) in languages that don't support them natively.",
            "id": "9a76d5a1b0c44f2cdfe5063e1dae3bee"
          },
          {
            "type": "html",
            "text": " <b>Language Integrated Query support</b> - ability to perform queries over tables, tree-structures, data (for [[Logic Programming]]) and just about anything else. Automatic optimization support for these queries based upon indexes.",
            "id": "fb2e65b8e34dbcf225fd06fcc231cb0b"
          },
          {
            "type": "html",
            "text": " <b>Patterns Matching and Analysis</b> - support for pattern-matching over and between values in the language and automatic extraction of sub-values for use when the pattern does match... ideally usable for such things as 'case' statements or expressions. If not part of the language by default, it is rare to see a language that supports more than the most primitive forms of pattern-matching (e.g. regexps). Ideally the pattern-matching ought to be advanced enough to casually write parsers for new languages (or support a library capable of such).",
            "id": "815a470fbeadad34c77596a2c16def5c"
          },
          {
            "type": "html",
            "text": " <b>Numbers</b> - Useful in any domain that involves measurement or that is related to a domain that involves measurement, which means EVERY domain (with maybe a couple exceptions). Depending on the language, you might be able to implement numbers if you didn't already have them... but you'd need to have several other features instead (especially pattern-matching, structural aggregates, and sequential composition). Really, they are too convenient to go without.",
            "id": "5dc62530010013be6eea6d308aa5c0eb"
          },
          {
            "type": "html",
            "text": " <b>Functions</b>. The ability to write functions, callable from any point in the program (subject to programmer limitations), with defined arguments and return value; with the requirement that upon completion of the function, control is transferred back to the caller.",
            "id": "f6ace689649485a5224c1045f9759b49"
          },
          {
            "type": "html",
            "text": " <b>Conditional Execution</b>. Ability to condition the execution of a portion of the program (or evaluate only part of an expression) based on a condition.",
            "id": "bd9d76c0c466b7780f26a57abaa29410"
          },
          {
            "type": "html",
            "text": " <b>Recursive definitions</b> (of procedures, functions. Requires either a multiple-pass compiler/interpreter, or prototypes of some sort (this isn't really a big issue these days; but I remember when [[Holy War]]s were waged over the merits of two-pass compilers)",
            "id": "22ac02d1695285542895783317db9762"
          },
          {
            "type": "html",
            "text": " <b>Recursive processes</b> (arising from recursive definitions) which require <b>one of</b>:",
            "id": "59515b7b5cb2dda1788fff94f3e787e5"
          },
          {
            "type": "html",
            "text": " <b>Enforced [[Tail Call Elimination]]</b>, or",
            "id": "2096a250d68cb25b6bac687a58e4bf11"
          },
          {
            "type": "html",
            "text": " <b>LIFO Memory Allocation</b> The ability to allocate additional memory from the runtime system in a fashion which obeys a [[Last In First Out]] discipline - the most recent object/memory block allocated is the first freed. Suitable for implementation on a stack.",
            "id": "d08c718352415563d637dcaa1fe30c77"
          },
          {
            "type": "html",
            "text": " <b>Dynamic memory allocation</b> (explicit or implicit). The ability to create additional \"objects\" at runtime which can have unbounded lifetime, subject to the limitations of system memory. In general, not suitable for stack-based implementation; requires what is commonly known as a <i>heap</i>. ",
            "id": "04c8280cf1c39fa6ebfacc157f860881"
          },
          {
            "type": "html",
            "text": " <b>[[Higher Order Function]]s</b>. The ability of a function to accept functions as arguments and return functions as results.",
            "id": "57d8392a1ca007587e7efbd7ddf8885d"
          },
          {
            "type": "html",
            "text": " <b>[[Lambda Expression]]s</b>. The ability to create a \"new\" function by binding arguments (supplied at runtime) with existing functions and logic. ",
            "id": "adb3a56065b884b992589f8678a3acd7"
          },
          {
            "type": "html",
            "text": " <b>[[Exception Handling]]</b>. The ability to signal a potentially parameterized fault and propagate flow of control back to a handler.",
            "id": "9641b20315d4ca6be1fd4de486960598"
          },
          {
            "type": "html",
            "text": " <b>[[Resumable Exception]]</b>:<br>The ability for an exception handler to propagate flow of control, potentially with parameters, back into the original operation or predetermined resumption points. Allows <i>much</i> greater modularization of error handling because the handler doesn't need to know as much about the implementation. Instead needs to determine only where it may resume, the general semantics of such resumption (usually in relation to the exception... (e.g. <b>catch</b>(div_by_zero<int>) { <b>resume</b> continue_with<int>(0); }\").",
            "id": "160808fa7ec76ff52314c220e07095f3"
          },
          {
            "type": "html",
            "text": " <b>[[Lexical Closure]]s</b>. The ability to create functions at runtime that \"capture\" (close over) bindings in the surrounding lexical environment. (Most commonly the captured bindings are of variables, but any class of thing whose names follow lexical scoping discipline are candidates to be captured. For example, in [[Common Lisp]] closures can capture block names allowing a closure passed down the stack to unwind back to the block.)",
            "id": "56f12fa0c83121071828d090a6de8bc7"
          },
          {
            "type": "html",
            "text": " <b>Structural aggregates</b> The ability to create complex datatypes/objects out of simpler ones, by providing associative aggregates (think structs/records/a subset of classes), and to create multiple instances of the aggregate.",
            "id": "c13725c7bdd2ec5186070d879190c44d"
          },
          {
            "type": "html",
            "text": " <b>Structured flow control</b>. Structured conditions (if/then/elif/else) and loops (for/foreach/do/while). Can be implemented atop recursive definitions or [[Call With Current Continuation]], [[Go To]], and conditional execution if you have them in the right combination.",
            "id": "36e3d2965c963768bbed31ae42fda181"
          },
          {
            "type": "html",
            "text": " <b>Sequential aggregates</b> Includes tuples and arrays, essentially.",
            "id": "d794d08f0f4175fb6a26cac81247671a"
          },
          {
            "type": "html",
            "text": " <b>[[Reference Semantics]] and aliasing</b> The ability to have multiple references to an object; either implicitly (in a language such as Smalltalk or Java, in which all/most variables are references) or explicitly (via pointers in C/C++/Pascal, etc.)",
            "id": "43ed15907ec2c19ab28e96c5aaf4c56a"
          },
          {
            "type": "html",
            "text": " <b>[[Parametric Polymorphism]]</b> The ability to define functions/types/whatever which are really a function which maps a \"type\" to something else. Templates in C++, pretty much any function in Lisp/Smalltalk.",
            "id": "b19aa330d17d11eabfffa380b353cc5d"
          },
          {
            "type": "html",
            "text": " <b>[[Multiple Dispatch]]</b>. The ability to dispatch on more than one argument to a function. If you don't have this feature you end up constructing a veritable zoo of various kinds of [[Visitor Patterns]] (ranging from extrinsic to hierarchical to acyclic) just to hack around this limitation. Each time you implement these patterns however you're basically building a one-off dispatching framework that you'll be duplicating a few days later when you get to the next bit of complicated logic.",
            "id": "63b94035c68a00fc0e0f0e73088a9224"
          },
          {
            "type": "html",
            "text": " <b>[[First Class Types]]:</b> Support for construction and communication of type-descriptors at runtime, along with their subsequent use when comes time to validate [[Type Safety]]. If [[Everything Isa]] object, then types and classes are objects ([[Meta Object Protocol]]). If [[Everything Isa]] value, then types are values. This is extremely useful [[Meta Programming]], and is of value whether or not one is using [[Dynamic Typing]] or [[Static Typing]] or something in between ([[Soft Typing]]). However, it is worth noting that [[First Class Types]] at runtime under '[[Static Typing]]' will also require including the compiler in the runtime environment.",
            "id": "673442579ff8f44583e4c928c4c9200a"
          },
          {
            "type": "html",
            "text": " <b>[[Causally Reflective Environment]]</b> The environment includes a full dynamic model of its own dynamic machinery, such as processes, stack frames, dispatch tables, semaphores, and so on. Changes to this model change the behavior of the environment accordingly.",
            "id": "a0a91aab7a6cc44823bcf7805a301bdd"
          },
          {
            "type": "html",
            "text": " <b>[[Introspection And Reflection]]</b> The ability to discover at runtime the properties/attributes of an object (without having to give the object that capability explicitly).",
            "id": "00f677c775da8a5d2d828301de7a45c9"
          },
          {
            "type": "html",
            "text": " <b>Modules</b>. This is a basic software engineering requirement. Divide software systems into cohesive units, define contracts for the modules, separate interface from implementation, allow independent evolution of caller and callee, etc, etc. Most popular languages do not support this (yet), or can be worked around painfully. Languages that support good modularity features:<br>Ada, Modula family, Standard ML. With support can be counted Java and C/C++. Ideally, modules should be [[First Class]].",
            "id": "c542198a6ef6208ee8976af2fb0912a3"
          },
          {
            "type": "html",
            "text": " <b>[[Aspect Oriented Programming]]:</b> or, more generally, the ability to describe [[Cross Cutting Concern]]s in one place, whether they be business rules or logging of messages, and automatically have these descriptions be leveraged at all other relevant points in the code. The fundamental capability to accomplish this has a <i>categorical duality</i> with <b>modules</b> - a direct inversion of dependencies. Instead of a value/function/class/etc. being described at one location and 'pulled' by clients that import it, client modules must be able to describe parts of a value/function/class/etc. and 'push' these parts to to a common location, often across modules. Lesser forms of this feature include 'open' functions (add new pattern-matches to a function) and 'open' types (add new tagged unions to a data type).",
            "id": "782dec493ccac69ed47a4ce342ead7f1"
          },
          {
            "type": "html",
            "text": " <b>[[Compile Time Resolution]]:</b> Formal support for performing communications to link arbitrary remote sources. In a 'dynamic' environment that possesses no distinct [[Compile Time]], this might relate more to the ability to specify lazy one-time executions to be performed at need or when initially loading the environment.",
            "id": "99a76f842c45bba4bd17556fff16f5c3"
          },
          {
            "type": "html",
            "text": " <b>Automatic [[Type Inference]]</b>. Essentially a precondition for [[Typeful Programming]] and for internally supporting types more complex than are conveniently described by hand (e.g. structured monads, [[Effect Typing]], etc.). Utterly impossible to implement in a language supporting only [[Manifest Typing]], it clearly requires implementing an interpreter or compiler to acquire its benefits. Can include both dynamic typed languages ([[Common Lisp]], [[Smalltalk Language]]) and statically-typed languages which use [[Type Inference]] ([[Ml Language]] and its successors, [[Haskell Language]]).",
            "id": "d6cb9826503323beca86e1c8b4f180ec"
          },
          {
            "type": "html",
            "text": "\nThe maybe list:",
            "id": "22cb63ed97c4af5653ee33e1259f5aeb"
          },
          {
            "type": "html",
            "text": " <b>[[Real Macros]]</b> (more generally <b>[[Extensible Programming Language]]</b>). Lisp users swear by these (see comments below). Other languages do without. Certainly, they are one of the cool features of [[Common Lisp]] and [[Scheme Language]]. On the other hand, macros are a way of automatically expanding things that can already be done in the language; anything which can be done with a macro can be done by hand (though this violates [[Once And Only Once]] -- which is why language aware macros are here....)",
            "id": "18d4dc4eb3284c132c63f33a3943bd95"
          },
          {
            "type": "html",
            "text": " <b>Support for Annotations:</b> Formal support for including <i>and</i> processing annotations that <i>aren't</i> intended to be processed by the final interpreter or compiler (but might be processed by something else in the post-processor pipeline, or some back-end other than the compiler such as an IDE or [[Literate Programming]], or plug-in type-checker or theorem prover or static verifier like lint or emily, or plug-in optimizers, or semantics extensions). More discussion available in [[Hot Comments]]. This class of extensions cannot be accomplished by [[Real Macros]] alone. ([[Annotation Metadata]] doesn't support the sort of processing described here.)",
            "id": "58c7b05dc32167214116415670374e72"
          },
          {
            "type": "html",
            "text": " <b>[[Explicit Management Of Implicit Context]]:</b> A mechanism to manage the context in which programs, subprograms, threads, thunks, and continuations are operating that is consistent across the language, all language libraries and modules, and integrated with the core language services. Especially the ability to replace much of the 'global' context with such context-limited services. Especially useful for supporting security, modularity, and scripting ([[Alternate Hard And Soft Layers]]) in a multi-user environment like a [[Web Server]] or [[Operating System]] or vehicle controller.",
            "id": "a1fb36104e260cff4587b198db8d70e3"
          },
          {
            "type": "html",
            "text": " <b>[[Dynamically Scoped Variables]]</b> (Not by default, but as an option.) The ability to create variable bindings with dynamic extent (they exist for as long as the binding form is on the stack) and indefinite scope (they can be referred to from anywhere). Moved to \"maybe\" because they are [[Considered Harmful]] in the [[Object Capability Model]]. Support for this is implied by [[Explicit Management Of Implicit Context]].",
            "id": "3701ae67d37e3cf1d15067115e628f56"
          },
          {
            "type": "html",
            "text": " <b>[[First Class Undo]]:</b> Ability to contextually 'undo' user-driven actions, especially those involving state-manipulation, at some point <i>after</i> they have already been committed, within the limits of what can logically be undone. Dealing with [[Human Computer Interaction]] either directly or indirectly is part of almost any programming environment, and [[First Class Undo]] can provide great support programmers involved in these fields. Further, even for internal-system coding, it can be useful in the post exception and error contexts. Also relates to language-features that perform backtracking, such as those seen in [[Constraint Logic Programming]].",
            "id": "7f7765c22c773cdd9b8cad4f3f30a4db"
          },
          {
            "type": "html",
            "text": " <b>[[Partial Evaluation]]:</b> An optimization that, if given formal support within a language, makes practical a much greater degree of [[Meta Programming]]. If not guaranteed, then programmers cannot count upon it",
            "id": "801cbb7be24966bcd873b116e7bccae4"
          },
          {
            "type": "html",
            "text": " <b>[[Static Assert]]:</b> Essentially [[Design By Contract]] + [[Partial Evaluation]] on steroids; would provide among the most powerful (and arbitrary) of code-proofs. Ideally allows for some flexible expressions.",
            "id": "326905a636c184786fc8a95a2d420c2e"
          },
          {
            "type": "html",
            "text": " <b>[[Garbage Collection]].</b> The ability of the system to recycle the storage allocated to objects which no longer contribute to the behavior of a program (or a useful subset thereof; such as those which are not linked to the root set.)  Flawed implementations make it [[Considered Harmful]] in many domains.",
            "id": "8e5fed049126ab94bde48e859ec572ef"
          },
          {
            "type": "html",
            "text": " <b>Encapsulation</b>. Different access levels (public, private, etc.) A key feature of many languages, particularly those which support object orientation and modules, although [[Python Language]] does not support this for either. It proves most valuable when programming in a team environment, where dictatorial control over how every programmer may be allowed to code his work proves impossible. For single-programmer or small-team projects, it potentially adds no value. Not quite as powerful or generic as a true, <b>Explicit [[Security Model]]</b>, especially a [[Capability Model]] (which can provide far more capabilities than 'public/private' access levels), but much easier to implement without introducing runtime costs.",
            "id": "472cafc95fd730d07bf71996c202325a"
          },
          {
            "type": "html",
            "text": "\nThings explicitly not included; move these above if you think they should be included (and say why):",
            "id": "3b93be041981136c876aed3c400e944c"
          },
          {
            "type": "html",
            "text": " <b>I/O</b>. Provided by the library in most languages; highly OS dependent in many cases. Typically not a key differentiator between languages.",
            "id": "75630d80db189476e1cddedf82bddc81"
          },
          {
            "type": "html",
            "text": " <b>Lists</b>. Can be done as a combination of sequential/structural aggregation and references/pointers. Likewise, other aggregate forms can be implemented as lists.",
            "id": "c29c2e9074d4d63ecbefd21591b1f141"
          },
          {
            "type": "html",
            "text": " <b>[[Generic Associative Collections]]</b>. Tables and Relations (ideal). Second-best:<br>Sets, maps, hashes, etc. Useful; but can generally be implemented in a library in a language which doesn't have these. (Should be part of the standard library, though... which really is just as much a part of the language as the keywords.)",
            "id": "2d25e39ba654dc145487807ed85956c5"
          },
          {
            "type": "html",
            "text": " <b>[[Call With Current Continuation]]</b>. Maybe; it's useful but I'm not entirely convinced it's essential. (It's also dangerous). Of course, if there was some way to limit the extent of the continuation...",
            "id": "0f5b1cea61e65c7bec2a10ce217a33e5"
          },
          {
            "type": "html",
            "text": " <b>[[Go To]]</b>. transfer control to an arbitrary point in the same function (lesser form of [[Call With Current Continuation]], still dangerous). But might not qualify - often [[Considered Harmful]].",
            "id": "0e09e663acb244f25e188cdf97719720"
          },
          {
            "type": "html",
            "text": " <b>[[Single Assignment]]/[[Referential Transparency]]</b>. Powerful features for complexity management and optimization (especially amenable to [[Partial Evaluation]], selective [[Lazy Evaluation]], and operation reordering). However, excluded above because these features aren't an 'end' in and of themselves... not so much as the optimizations they support are. Also, forcing the whole language to be 'pure' forces requires some counter-intuitive approaches to supporting concurrency, communications, and OS integration. Something like [[Mercury Language]] with its support for explicit and implicit 'purity' levels, or otherwise dividing functions from procedures within the language, might provide both the desired complexity control and the optimizations without the counter-intuitive IO monads. See [[Kill Mutable State]] for more on this view.",
            "id": "c3c91a68b469e338d95f20fed5cb5005"
          },
          {
            "type": "html",
            "text": " <b>Variables</b>. Objects with mutable state. Assumes some method to mutate the state. Opposite view of [[Single Assignment]]/[[Referential Transparency]].",
            "id": "e9aa786cfa8528f8bf0cf676e59c3176"
          },
          {
            "type": "html",
            "text": " <b>[[Pointer Arithmetic]]</b>. Used as a surrogate in low-level languages to implement (in an unclean fashion) the higher-level features found in higher-level languages. This also includes other unsafe practices as pointers-to-stack-objects and the like. While flexible, often [[Considered Harmful]].",
            "id": "9ba535fc778fae6fa602591194cbc5cb"
          },
          {
            "type": "html",
            "text": " <b>[[Unsafe Type Casts]]</b>. Like pointer arithmetic, necessary in low-level languages to get around the restrictions of the language. Unnecessary in high-level languages.",
            "id": "8e52f585a0f3294aa26a40da02325025"
          },
          {
            "type": "html",
            "text": " <b>[[Static Typing]]/[[Dynamic Typing]]/[[Soft Typing]]</b>. I believe that neither is inherently better than the other; though certainly Automatic [[Type Inference]] is better than being forced to use [[Manifest Typing]] at <i>every</i> place in the code. ",
            "id": "1ac895d22cf61f4f91a784ad50cbfce2"
          },
          {
            "type": "html",
            "text": " <b>Preprocessors and Text-based Macros</b>. (In other words, macros which operate on the text stream before it is parsed by the compiler/interpreter; ala C/C++) Some consider these evil; many languages have no such capability and do fine. Others consider these essential - usually to work around a deficiency or limitation in the language proper. (Part of the problem, I suppose, is that the C/C++ preprocessor is so god-awful...)",
            "id": "f04a567612a98351061653826f66f9c0"
          },
          {
            "type": "html",
            "text": " <b>Concurrency</b> While this is a good thing (and somewhat necessary given the future of processors is in multiple processing cores), the jury is still out on the best way to implement concurrency. Several approaches have been tried. <b>[[Co Routine]]s</b> were one of the first; and still useful in some instances -- however when used to implement non-preemptive multithreading, it doesn't scale to multiprocessor systems and few production languages these days have generic coroutines as a language feature. <b>[[Preemptive Multithreading]]</b> (multiple threads running in an address space; with context switching beyond the control of the language in most cases) is common in many languages, either as a language feature (Java) or as an OS extension (C/C++). It introduces a whole rats-nest of synchronization issues. It scales well to multiprocessors; but less well to distributed systems. Coroutines or other mechanisms used to implement <b>[[Communicating Sequential Processes]]</b> and <b>[[Actors Model]]</b> approaches look promising; they scale to any system (single-CPU, multiple-CPU, distributed) and avoid the some of the synchronization problems of multithreading. ",
            "id": "980ed473c6467a1fc6a9b24461c52b05"
          },
          {
            "type": "html",
            "text": " <b>[[Dataflow Programming]]</b>, especially in combination with [[Data Delta Isolation]] - essentially the ability to 'subscribe to' expressions written in the language and receive the altered values with a controllable latency. In normal programming, it seems there is only support for 'pulling' from data cells to evaluate the expression. Languages without support force you to jump through hoops to make this work:<br>dig in and modify memory/variable services to add subscriptions, intelligently resist cyclic recursion, deal with inconvenient syntax (dataflow expressions would likely look extremely different from regular ones), etc.). [[Dataflow Programming]] is of high value in realtime distributed applications, where the cost of polling expressions is too high and you want latency to be minimized. However, down in the 'excluded' list because [[Dataflow Programming]] essentially depends on Concurrency (which is in the 'excluded' list for some reason).",
            "id": "b4160974b412555a0049f619184ef99f"
          },
          {
            "type": "html",
            "text": " <b>Transactions</b> Support for atomic manipulation of shared mutable state in the context of concurrent operations, and useful whether that shared state is a filesystem or individual cells of memory shared between threads. As with concurrency, the jury is out on how to best perform it. Optimistic [[Software Transactional Memory]] looks promising.",
            "id": "4ca1683b3b3337b277714a09e91b2216"
          },
          {
            "type": "html",
            "text": " <b>Linkage</b> Ability to link high-level code to low level code written in the correct tool for the low-level problem. I am being perfectly serious here:<br>I have seen and worked on problems where the only solution was to use [[Cee Language]] or [[Assembly Language]] with pointer hopping. One bad case actually required allocating 1.5 GB of RAM in one contiguous chunk and using it as a bitvector. It turned out that any other method would exceed the 4GB address space limitation of the processor in the worst case. [[Alternate Hard And Soft Layers]] can pay out. (But this is a more specific form of [[Compile Time Resolution]], and doesn't need to be formal within the language; given good support for [[Compile Time Resolution]] and [[Partial Evaluation]], this isn't necessary.)",
            "id": "ea421c069d6d1d883305f4e5bee01d2e"
          },
          {
            "type": "html",
            "text": " <b>[[Subtyping And Subsumption]]</b> The heart of [[Object Oriented]] (part of it, anyway). The ability to specify that one type can substitute for another in any given context, and the ability to actually perform that substitution. Note that inheritance is a mechanism for this; not the only one. This is only really an issue for statically typed languages, dynamically typed languages get this for free. On the 'explicitly not included' list because [[Object Oriented]] itself is not among the [[Key Language Features]], and is strongly related to [[Multiple Dispatch]] and [[Aspect Oriented Programming]].",
            "id": "5ea711d781ff12127a522b2a91706f7b"
          },
          {
            "type": "html",
            "text": " <b>Explicit [[Security Model]]</b> Can provide far stronger, truer, more generic security than mere <b>Encapsulation</b>. Especially applicable within 'systems' programs that involve multiple users or multiple programmers. If one is going to have any security model, it is important to have a common, pervasive security model integrated with the language standard libraries and other shared program components; the alternative, having different security models for different components and needing to translate between them for each library, is such a hassle as to render the feature useless in every library. <i>Which</i> [[Security Model]] doesn't matter so much as that it is a <i>provable</i> security model, and is readily used in practice with minimal hassle (the easiest way to do things ought to be the most secure way to do things), so integration with [[Explicit Management Of Implicit Context]] is desirable (reducing the need to pass security-parameters around explicitly). [[Capability Security Model]]s seem the most promising for this sort of integration (due, largely, to their inherent locality of internal reference, which is both highly subject to optimization and allows for distributed management of authority). [[Object Capability Model]] naturally applies as an extension to Encapsulation in OOP languages, whereas [[Simple Public Key Infrastructure]] (a [[Password Capability Model]]) or some modification thereof (one such model described in [[Explicit Management Of Implicit Context]]) might be useful in a distributed languages with [[First Class]] processes (moving towards [[Languages Are Operating Systems]]). While a good [[Security Model]] is certainly subject to the [[Blub Paradox]] (being very difficult to implement or add, and especially integrate, with a system where it doesn't already exist), it should probably remain with the concurrency support issues above:<br>there simply isn't much need for this level of 'true' security before one has concurrency; any demand to diminish accidental coupling can be supported via the lesser <b>Encapsulation</b>.",
            "id": "718ba92ee4ee05293e715ae001f00c28"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "093abd39ae949e3aa4972bc737a3db84"
          },
          {
            "type": "html",
            "text": "\nOk, I think somebody has an attitude about what a key language feature is. Considering that IO, Linkage, and GOTO are on the list of explicitly not included, while Reflection is on the list of must have makes this list rather off the wall. ",
            "id": "267627636bffb552a0be3d06df573e0c"
          },
          {
            "type": "html",
            "text": "<i>You misunderstand the list. The categorization is NOT one of 'must have' and otherwise. It is a list of 'definitely is a [[Key Language Feature]]' (in accordance to the definition at the top of this page) vs. 'useful, but either not subject to [[Blub Paradox]] or not Domain Independent'.</i>",
            "id": "5a99936bfc526b3f65f6f33d39a9c6f7"
          },
          {
            "type": "html",
            "text": "\nNo language will ever get off the ground with IO. ",
            "id": "d81c4b2d20ede31e766947dda234bceb"
          },
          {
            "type": "html",
            "text": "<i>Perhaps. But plenty of languages have gotten off the ground without <b>standardizing</b> IO - i.e. without making IO part of the language specification. That said, I happen to be a distributed systems weenie, and I am all for putting IO and related features (pickling, moving executables, etc.) as [[Key Language Feature]]s, but I'm willing to acknowledge that most problem domains really don't require it.</i>",
            "id": "43aa27fd5feb99ccecec525aaee895a7"
          },
          {
            "type": "html",
            "text": "\nNo language can grow beyond the vision of its creator without low-level Linkage available (hint: [[Compile Time Resolution]] will not get you this; it is irrelevant to the issue): it is the only to access OS features that do not exist on the designer's platform. ",
            "id": "cdfd5d8e4bc7ecad98c795c8464572c9"
          },
          {
            "type": "html",
            "text": "<i>Access to the OS is often well abstracted as a set of services, modules, or procedures in a language whether or not the language  is interpreted vs. compiled. Where does 'linkage' as a language feature come into that? In any case, 'linkage' doesn't seem very domain independent as a language feature. I do agree that [[Compile Time Resolution]] won't help for [[Operating System]] access; it helps more for [[Compile Time]] access to foreign resources (be they text files, remote databases, or ELF executables).</i>",
            "id": "ce3d93da493b4b06c733ed990f5bb03d"
          },
          {
            "type": "html",
            "text": "\nA few years ago I would have said unsafe casts are rare but mandatory. I now find that they can be subsumed into the core by adding a handful of core library functions that convert between scaler types and arrays of bytes without changing any bits.",
            "id": "e471d542656674419e011ff4e75d50d4"
          },
          {
            "type": "html",
            "text": "\nIf you think about the rule about writing an interpreter to simulate a different language to simulate a different language, there is no getting out of the need to add linkage to assembly code as sometimes you just cannot do without it. I really shouldn't have to monkeypatch some other process besides my own, but sometimes it is necessary.",
            "id": "c359080a8b71fa5a35d5b50c3fe2ec74"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "093abd39ae949e3aa4972bc737a3db84"
          },
          {
            "type": "html",
            "text": "\nNow, dependency information between the various features:",
            "id": "383d6c351b3290c8834a60383e01de46"
          },
          {
            "type": "html",
            "text": " \"A implies B\" means that if a language has feature A, then feature B comes \"for free\". Likewise, (A && B) implies C means if a language has both A and B, then feature C comes \"for free\" (for free means with minimal effort on the part of a programmer, and suitable for implementation in a library written in the language).",
            "id": "c52296c51e53c48e1d801a6c7e69cf98"
          },
          {
            "type": "html",
            "text": " \"A requires B\" means that if language has feature A, it MUST also have feature B. Likewise for the (A && B) requires C",
            "id": "02c358d26a1f7ebf908c5c89f9881e53"
          },
          {
            "type": "html",
            "text": "<b>[[Recursive Processes]] require Functions</b>. Should be obvious.",
            "id": "918d70c5ff6ff02f172de12fc97384d5"
          },
          {
            "type": "html",
            "text": "<b>[[Recursive Processes]] require [[Recursive Definitions]]</b>. Also should be obvious.",
            "id": "74e3a712605eb5e8d365c463218e7e28"
          },
          {
            "type": "html",
            "text": "<b>[[Recursive Processes]] require (LIFO Memory Allocation or Enforced [[Tail Call Elimination]])</b>.",
            "id": "22415221ad437d98f49422319dd8a23e"
          },
          {
            "type": "html",
            "text": "<b>Dynamic Memory Allocation implies LIFO Memory Allocation</b>. If you have a heap, you can simulate a stack. Simple enough.",
            "id": "e882213a57bf2b100629c664c7d417c2"
          },
          {
            "type": "html",
            "text": "<b>[[Garbage Collection]] implies Dynamic Memory Allocation</b>. Doesn't make any sense without it.",
            "id": "691fca984b089da0ee9a93d9c6baabed"
          },
          {
            "type": "html",
            "text": "<b>[[Lambda Expression]]s requires [[Higher Order Function]]s</b>. Should be obvious. Note that the converse is not true; C/C++ has [[Higher Order Function]]s if you count function pointers; but it doesn't have lambda expressions. See next rule why not.",
            "id": "887856aa8a5c06133e175b1f854be18a"
          },
          {
            "type": "html",
            "text": "<b>[[Lambda Expression]]s requires [[Garbage Collection]]</b>. It's often said that garbage collection is required for a [[Functional Programming Language]] (especially one with [[Side Effect]]s; without side effects reference counting will suffice). This is one reason why. The result of a [[Lambda Expression]] must almost always be heap-allocated, as they do not obey LIFO discipline. Furthermore, the usage patterns of lambda expressions (they get passed around like a cigarette) makes manual memory management of these dang near impossible. For this reason; I claim that lambda expressions <i>require</i> [[Garbage Collection]].",
            "id": "3499959fed23a6e552d7a9802410542a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "093abd39ae949e3aa4972bc737a3db84"
          },
          {
            "type": "html",
            "text": "<b>Thread mode stuff</b>",
            "id": "b10fde845eb0c61df73582ae290bb2e5"
          },
          {
            "type": "html",
            "text": "\nRegarding <b>Preprocessors and Text Macros</b>",
            "id": "d74c88005ab1a05c7b27c57d471aa26f"
          },
          {
            "type": "html",
            "text": "<i>This is an interesting entry given the genesis of this page. From a [[Smug Lisp Weenie]]s' point of view, this is the poster child for the [[Blub Paradox]] -- anyone who thinks that macros are an optional feature (let alone evil) is programming in Blub where Blub is a language that either doesn't have macros at all (e.g. Java or Python) or has a horrendously broken thing that it happens to call macros (e.g. C's text/token macros). Lumping preprocessors and macros (in the [[Common Lisp]] sense) together is probably not going to lead to clarity.</i> ",
            "id": "d160947eeca5fe9563a6f1757ef1f76c"
          },
          {
            "type": "html",
            "text": "\nGood point; I'll happily separate preprocessor text macros (which perform substitutions on the text before the bulk of the scanning and parsing is done) with language-aware semantic macros ala [[Common Lisp]]. However, an interesting question still remains: If you accept the viewpoint that macros operate \"outside\" the core language; they are often are used to automate things that the core language cannot. Which leads to two viewpoints: 1) Macros reveal a deficiency in the core language, rather than using an \"outside\" mechanism, the core language should be modified to accommodate. This may be more C++ bias ([[Bjarne Stroustrup]] is known to despise the C preprocessor; many features in C++ were put in to eliminate a common preprocessor use). 2) Macros are a legitimate tool; and as they operate using the standard capabilities of the core; they allow the language to be extended in ways which do not compromise the core. Macros are a layer on top, and layering is good. Personally, I tend to fall in between - when I use a macro, I wish there were a better way. Perhaps this is again C/C++ bias; though I've yet to encounter a preprocessor whose semantics were completely clean and neat. -- [[Scott Johnson]]",
            "id": "c6c7e4b5ca802374624189855fed0016"
          },
          {
            "type": "html",
            "text": "\nHmmm. I vote for 2) but I'm not sure I buy your definition of \"outside the core\". In [[Common Lisp]], macros are part of the core which, by their presence, allow other things to be left out of the core. For instance, in [[Common Lisp]] most of the \"control constructs\" that programmers normally use in are macros on top of more primitive control flow constructs. (For instance, all the structured looping constructs in [[Common Lisp]] are built on top of a primitive that is essentially the same as C's goto.) Thus those control constructs are not part of the \"core\" the way for and while loops are in C/Java/Python/Perl. (They are part of the language standard - most of the language standard is really specifying the standard library, not the language core.) Also perhaps worth noting: [[Common Lisp]] macros are <i>not</i> a preprocessor - they are more like a hook into the compiler itself. Basically whenever the compiler hits a \"call\" to a macro it passes the macro form to the macro code which then returns a form that the compiler compiles in the place of the original form (which might entail expanding macros that occur in the new form). If that doesn't seem clean and neat enough for you, I'd be curious what seems unclean or unneat about it. -- [[Peter Seibel]]",
            "id": "14f9608367f6c15db48b21af5098df8e"
          },
          {
            "type": "html",
            "text": "\nIn Lisp and Scheme, \"macros\" are just ordinary code that happens to execute at compile time, and as such they are utterly different in nature than text macros in other languages. #2 is definitely the only one that applies, not #1, in Lisp-family languages. <i>[Nitpick: Scheme has two macro systems, and in one of them macros are not just ordinary code.]</i>",
            "id": "ee396adccfad67cbcc72dd95003fbc29"
          },
          {
            "type": "html",
            "text": "\nThe word \"macro\" has always meant, as the core of its definition, \"something that happens at compile time, not run time\", which is why the word \"macro\" is used in both Lisp and e.g. C, even though the constructs thus referred to are otherwise unrelated. Mentally substitute the phrase \"compile-time first-class function\" for \"Lisp macro\" when in doubt.",
            "id": "79e09b98f48d5ff4dd6f95eb0d34cf2b"
          },
          {
            "type": "html",
            "text": "\nThus it is mostly uncontroversial in the C/C++ world that C/C++ macros are mostly a bad language feature (although essential in C and in a few contexts in C++), yet uncontroversial in the Lisp world that Lisp/Scheme macros are mostly a good and essential language feature (although susceptible to misuse, as with anything).",
            "id": "83a1f6829e1c33bdeda9d0f0137c85db"
          },
          {
            "type": "html",
            "text": "\nThere is no contradiction; the \"macros\" in question are quite different things in the two language families.",
            "id": "576b3eab1345846b75ca74d565fedbcf"
          },
          {
            "type": "html",
            "text": "-- [[Doug Merritt]]",
            "id": "f76d5e207c4438013bad8dcc6bd9d503"
          },
          {
            "type": "html",
            "text": "\nSo <i>that's</i> what [[Lisp Macro]]s are... [[Forth Language]] also has the notion of compile-time (immediate) vs. run-time semantics. One can define a Forth word to have either or both types of semantics. As with Lisp, it can be used to good effect to create domain specific languages and to extend the compiler. Also as with Lisp, <i>all</i> the flow control words in Forth are immediate words implemented using a couple of branching primitives. This allows the user to extend the Forth compiler with novel flow control constructs.",
            "id": "f7ca0f36310029be495fc24ea75becaa"
          },
          {
            "type": "html",
            "text": "[<i>Lisp Lisp Lisp. Macros Macros Macros. Blah blah blah. If macros and lisp are <b>so great</b>,  let's see them implement <b>[[Tutorial Dee]]</b> or a similar query language right into the Lisp program using Macros. Good luck. And no, I don't mean just a bunch of brackets smashed together that kind of look like a half assed macaroni/nail clipping based relational language in oatmeal.</i>]",
            "id": "c5877a3ebe90f2389d0880c1ca4bddca"
          },
          {
            "type": "html",
            "text": "\n[[Tutorial Dee]] could be done. SQL has been done. Admittedly, [[Lisp Macro]]s don't offer considerable manipulation of syntax (Lisp has no real syntax) so it would look 'ugly' by some peoples' standards (and beautiful by others...). What's up with your ranting? Weenie [[Feature Envy]]? ",
            "id": "3c50a0e7adb571d314e05faac0f1603b"
          },
          {
            "type": "html",
            "text": "<i>Actually, I'm envious of Algol style syntax - and using Lisp macros I couldn't implement the most important feature I needed - Algol derivative syntax - which [[Tutorial Dee]] and Cee/Oberon style languages have. In other words,  if I was using Lisp - I would be very <b>envious</b> of Algol style languages. If a weenie steps out of first person [[Smug Lisp Weenie]] view for a moment - he can see that all the snobbish arguments <b>for lisp</b> can be used <b>against lisp</b>. Its strength is its weakness. One can always fork a Lisp process from within an Algol program if they need Lisp, too.</i>",
            "id": "2e150768f7b3dc868916c67b3b6cde16"
          },
          {
            "type": "html",
            "text": "\nIt seems <i>wrong</i> to complain that a feature not meant to deliver some other feature you desire isn't delivering it. A bit like saying: \"Tables suck!  They don't give me secure communications over a network!\"  Admittedly, macros and syntax are somewhat more related, but they're still distinct facilities. Macros allow compile-time execution of code. Extensible syntax allows manipulation of the parser. Lisp has the former and lacks the latter. Either of them offer <i>mechanisms</i> for embedding [[Domain Specific Language]]s, and they combine in a rather powerful way, but they are <i>distinct</i> features.",
            "id": "6883b09585299f7b4e524b539571b3e9"
          },
          {
            "type": "html",
            "text": "<i>It doesn't provide me with a [[Domain Specific Language]], it only provides more Lisp.</i> ",
            "id": "902847b9b68304e876789dcc40af92ff"
          },
          {
            "type": "html",
            "text": "\nAh, you must be promoting your strange idea that language = syntax and is independent of semantics.",
            "id": "7795e4fe5e2d5b4d738aa2fcfa6a5f0a"
          },
          {
            "type": "html",
            "text": "<i>The idea that it offers a [[Domain Specific Language]] is actually just another way of saying it provides more Lisp. Providing domain specific languages can be done by forking processes in most languages - so I don't consider it a feature of Lisp to provide domain specific languages (think about it: since [[Lisp Does Not Provide Domain Specific Languages]], it just provides more lisp). Forking an interpreter (such as forking a PHP interpreter from a Cee program, or forking a Python interpreter from a Cee program, or forking some [[Pascal Script]] interpreter from a [[Free Pascal]] program) provides more power. First, someone has already written the interpreter or domain specific language which I can fork and make use of. Second, these interpreters are actual languages - not just more Lisp on top of Lisp. They truly are domain specific languages (consider forking [[Tutorial Dee]] compiler or interpreter).</i>",
            "id": "c4e0ac587e6ede55f3ffe5f5b519a05e"
          },
          {
            "type": "html",
            "text": "<i>Another domain specific language is Regex. Lisp is not the only language capable of extending itself - consider a regex interpretter built into an executable (Cee or Freepascal program). Consider I wrote an SQL interpreter inside a program. SQL and regexes are truly domain specific languages - whereas Lisp on top of Lisp, is just Lisp - it isn't domain specific language. It's maybe domain specific Lisp.</i>",
            "id": "bef38c02a889e1cfe006a65fd549fd2a"
          },
          {
            "type": "html",
            "text": "<i>[[Smug Lisp Weenies]] go on to argue that it takes too long to write languages that are forked or parsed. They argue that Lisp offers us this power of writing a language inside Lisp. But, Lisp is just Lisp. It isn't a domain specific language - it's more like domain specific Lisp - which is the very flaw of lisp, in that it does not create domain specific languages... but supposed domain specific Lisp (which forces one to program with odd functional syntax, which is not very domain specific). Forking interpreters that are already written and ready to go - is much more domain specific. Parsing a string inside a program, is more domain specific (parsing INI, parsing SQL, etc). And don't think that one has to write his own SQL or INI interpreter - their are already plenty written available as modules.</i>",
            "id": "91be9f1d112dc771441cac316a48f713"
          },
          {
            "type": "html",
            "text": "<i>[[Smug Lisp Weenies]] are contradictory: the domain specific Lisp languages are <b>not</b> languages at all. They are just more <b>lisp on lisp</b>. However, if I write an SQL interpreter or Regex interpreter module for a Cee program or Freepascal program, this truly is <b>domain specific</b>. Actually I don't have to <b>write</b> a domain specific language many times - there are plenty of <b>existing</b> domain specific languages available that can be forked (perl, awk, regex, php, INI parser, pascalscript, JScript, web language could be forked, [[Brain Fuck]] could be forked, compiler could be forked and launch a program right after compiling, etc). I can reuse a domain specific INI, Regex, or SQL parsing module over and over again in any language that can fork a process or parse a string.</i>  ",
            "id": "8689e2cd740ad51b0f4c42a9feb3d75a"
          },
          {
            "type": "html",
            "text": "<i>This is truly domain specific: being able to utilize INI syntax, regex syntax, SQL syntax, script syntax, right inside a program on a string (or on a file that is read). One could even <b>fork</b> a Lisp interpreter - if they needed - but I think rather a more domain <b>specific</b> language should be forked. See the <b>irony</b>: lisp isn't very domain specific. In other words, its strength is a weakness - and its claims are jokingly recursively contradictory.</i>",
            "id": "f175988be19cd6f1192bccd5c82c0a59"
          },
          {
            "type": "html",
            "text": "\nThe assertions found in the above italic paragraphs are bizarre - somehow forking an interpreter constitutes embedding, but a language whose syntax consists of [[Ess Expressions]] isn't a [[Domain Specific Language]]? I think [[Paul Graham]] would point to RTML as an example of a [[Domain Specific Language]]. It's hard to deny that it's domain specific. Is it not a language because it's got Lisp syntax? Isn't Lisp a language?",
            "id": "a279d602a918a626bda78af241efe994"
          },
          {
            "type": "html",
            "text": "\nIncidentally, contrary to the admissions made by the non-italic participant in the preceding discussion, [[Common Lisp]] <i>does</i> allow manipulating the parser, through the use of reader macros. It's just that it's far too painful to implement any language that isn't LL(0) that way, and, as execrable as Lisp's syntax is, it's hard to design something better that's LL(0), especially if you also want to be able to use macros to manipulate it. (I would ask defenders of Lisp syntax to consider why all-capitals is hard to read, and compare that to an all-round-bracket syntax.)",
            "id": "c0fbc505934195f1644e641e230f038a"
          },
          {
            "type": "code",
            "text": " You are in a maze of twisty little parentheses, all alike.",
            "id": "0d373b0bbfdb9503cec48cc69de9ec8e"
          },
          {
            "type": "html",
            "text": "Actually, I would argue that Lisp is (with the possible exception of syntax) the ultimate interpreted language. Yes, Lisp compilers exist, but Lisp's features can (as noted by Greenspun) be implemented in other languages by writing a Lisp interpreter. Whereas the features missing from Lisp (other than nice syntax) that make Lisp look a little Blubish to, say, [[Smug Haskell Weenies]] can, as far as I can see, only be implemented by writing a compiler (loosely speaking, that is - Haskell interpreters exist, but they do a compiler-like amount of static analysis at load-time).",
            "id": "20bf556a79cef86660dc292475d0a6a8"
          },
          {
            "type": "html",
            "text": "<b>I would agree that the italic rant is a bit weird. He talks about \"just\" forking processes, but ignores the overhead that simple forking requires; and I don't think he understands how difficult it is to mingle domain specific languages when you have to \"fork out\" to get those advantages. And, finally, he's assuming that there exists specific languages for your domains, and that if there isn't, it's a simple matter of firing up your favorite parsing tools, create a compiler (or interpreter) for your new domain, and write your language, all in one go! What are you supposed to do, if you don't want to go through that work -- or, for that matter, can't know the syntax of the yet-to-be-defined language, because you don't know what it's going to look like? Well, I would <i>suppose</i> that you can start with a simple, easy to manipulate and extend syntax, that already comes with an industrial-strength language behind it, and then gradually extend its syntax piecewise and experimentally, until you have a brand new domain specific language that can be optimized to near-C levels if necessary, and can be easily mixed with other existing (and even developing) domain specific languages where those domains intersect...or, I <i>suppose</i> you could just write a compiler, and fork it...</b>",
            "id": "2cec8de086e7c66b0cd9ac16f80dbcd0"
          },
          {
            "type": "html",
            "text": "<b>Somehow, I have the feeling that if forking processes really is more convenient than creating new domain specific languages as needs arise, that [[Smug Lisp Weenies]] would have figured that out decades ago. But then again, perhaps they did...you could find C and FORTRAN compilers for Lisp Machines...but then yet again, perhaps that's just a fallback to the idea that \"once something is written, you shouldn't rewrite it, but just let it be, in the language that it's originally written in, for all sorts of different reasons!\" -- Alpheus</b>",
            "id": "dd691da2c7d4bc53cba062539b211a58"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "093abd39ae949e3aa4972bc737a3db84"
          },
          {
            "type": "html",
            "text": "\nRe: [[Lambda Expression]]s:",
            "id": "d70468704ce1bf0ae35f8e799772de07"
          },
          {
            "type": "html",
            "text": "(<i>Is this different from the definition of [[Lexical Closure]]s below?</i>)",
            "id": "1b4ea29b3deee53548e8ff9347ba819f"
          },
          {
            "type": "html",
            "text": "\nMy distinction between the two is: [[Lambda Expression]]s might not have access to the referencing environment in which they were created; and can be used in languages which don't have nested lexical scoping. A C++ [[Functor Object]] (ignoring the [[Garbage Collection]] issue noted above) could thus be considered a form of a [[Lambda Expression]]. [[Lambda Expression]]s need to be [[First Class Object]]s to be much use. A [[Java Inner Class]] object declared within a method is kind of like a [[Lambda Expression]] (it does have access to the environment; but only to variables declared final. In reality; the variables are copied into the object, and no reference is kept to the enclosing scope beyond creation).",
            "id": "28e9386be1c4f1c8e79a18cbb6e57f56"
          },
          {
            "type": "html",
            "text": "\nA [[Lexical Closure]], on the other hand, does have access to the referencing environment in which it is created (including the ability to modify that environment); but need not be first class. [[Lexical Closure]]s aren't that tricky to implement until you try to have last longer than their referencing environment; in which case they become a royal pain (they tend to require spaghetti/cactus stacks). [[First Class]] [[Lexical Closure]]s are nice to have, obviously; as they generalize both concepts. However, they complicate the implementation of a language greatly.",
            "id": "902302a735492a86965d8085ed4677dc"
          },
          {
            "type": "html",
            "text": "\nOf course, I may be all wet here.",
            "id": "6270ebf9b2209f8626f7defa16cdcdc7"
          },
          {
            "type": "html",
            "text": "-- [[Scott Johnson]]",
            "id": "e9659f651bea0ab4590105cbd7b19280"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "093abd39ae949e3aa4972bc737a3db84"
          },
          {
            "type": "html",
            "text": "See also [[Quest For The Perfect Language]]",
            "id": "1a021a77280273a5b66e36c542f88a1e"
          },
          {
            "type": "html",
            "text": "\n[[April Zero Eight]]",
            "id": "8969b5227d1a212de45ed888a02611f6"
          },
          {
            "type": "html",
            "text": "\n[[Category Programming Language]]",
            "id": "a8a143b1511db6607992d892470fe39a"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?KeyLanguageFeature c2.com]",
            "id": "5eb9d69307d5887883e95f53166d363c"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1709253330246
    }
  ]
}