{
  "title": "Model/View Interaction",
  "story": [
    {
      "type": "paragraph",
      "id": "3c83aa5fe35afd45",
      "text": "As in MVC views are dependent on their models. Views can know about the models they represent but a model must not require knowledge of the views which may be on it. A model must be entirely independent of its view. This means that implementing a view for a particular object should not require any modification of that object's behaviour. This leaves us with the question, \"How does the view know when the model has changed?\". There are several ways of dealing with this problem."
    },
    {
      "type": "paragraph",
      "id": "37492bb558f2273d",
      "text": "What is needed is a coordination mechanism for the view and model. This coordinator can tell when some action will cause the value of the view to be changed. Sensing that the model has changed, the coordinator tells the view which takes the appropriate action. Since the coordinator forms a much used link between the model and view it must be light weight."
    },
    {
      "type": "paragraph",
      "id": "0fe4b822fc9a1651",
      "text": "A constraint satisfaction system such as the Filters Paradigm [Ege, 1986] [Grossman and Ege, 1987] is one such system. Filters combines light and heavy weight constraints (filters and logic) to coordinate user-object and object-object interaction respectively. Constraint Hierarchies [Boming et al., 1987] provides more complete but expensive constraint specification. Both are built on top of [[ThingLab]] and allow the user to explicitly define what the interactions between entities are."
    },
    {
      "type": "paragraph",
      "id": "aa0edbcc4229853c",
      "text": "Another approach to this problem is the use of encapsulators [Pascoe, 1986]. An encapsulator is an object which surrounds another object intercepting all messages to it. In this way, the encapsulator can sense when a \"significant\" change occurs and directly inform interested objects. In both solutions a nice way of specifying what constitutes a significant change remains a challenge."
    },
    {
      "type": "paragraph",
      "id": "ddb8d96c3492c6ed",
      "text": "⇒ [[Eva Implementation]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Model/View Interaction",
        "story": []
      },
      "date": 1655964490542
    },
    {
      "item": {
        "type": "factory",
        "id": "3c83aa5fe35afd45"
      },
      "id": "3c83aa5fe35afd45",
      "type": "add",
      "date": 1655964500182
    },
    {
      "type": "edit",
      "id": "3c83aa5fe35afd45",
      "item": {
        "type": "paragraph",
        "id": "3c83aa5fe35afd45",
        "text": "As in MVC views are dependent on their models. Views can know about the models they represent but a model must not require knowledge of the views which may be on it. A model must be entirely independent of its view. This means that implementing a view for a particular object should not require any modification of that object's behaviour. This leaves us with the question, \"How does the view know when"
      },
      "date": 1655964501723
    },
    {
      "item": {
        "type": "factory",
        "id": "37492bb558f2273d"
      },
      "id": "37492bb558f2273d",
      "type": "add",
      "after": "3c83aa5fe35afd45",
      "date": 1655964532987
    },
    {
      "type": "edit",
      "id": "3c83aa5fe35afd45",
      "item": {
        "type": "paragraph",
        "id": "3c83aa5fe35afd45",
        "text": "As in MVC views are dependent on their models. Views can know about the models they represent but a model must not require knowledge of the views which may be on it. A model must be entirely independent of its view. This means that implementing a view for a particular object should not require any modification of that object's behaviour. This leaves us with the question, \"How does the view know when the model has changed?\". There are several ways of dealing with this problem."
      },
      "date": 1655964542262
    },
    {
      "type": "edit",
      "id": "37492bb558f2273d",
      "item": {
        "type": "paragraph",
        "id": "37492bb558f2273d",
        "text": "What is needed is a coordination mechanism for the view and model. This coordinator can tell when some action will cause the value of the view to be changed. Sensing that the model has changed, the coordinator tells the view which takes the appropriate action. Since the coordinator forms a much use"
      },
      "date": 1655964549483
    },
    {
      "type": "edit",
      "id": "37492bb558f2273d",
      "item": {
        "type": "paragraph",
        "id": "37492bb558f2273d",
        "text": "What is needed is a coordination mechanism for the view and model. This coordinator can tell when some action will cause the value of the view to be changed. Sensing that the model has changed, the coordinator tells the view which takes the appropriate action. Since the coordinator forms a much used link between the model and view it must be light weight."
      },
      "date": 1655964574386
    },
    {
      "item": {
        "type": "factory",
        "id": "0fe4b822fc9a1651"
      },
      "id": "0fe4b822fc9a1651",
      "type": "add",
      "after": "37492bb558f2273d",
      "date": 1655964583105
    },
    {
      "type": "edit",
      "id": "0fe4b822fc9a1651",
      "item": {
        "type": "paragraph",
        "id": "0fe4b822fc9a1651",
        "text": "A constraint satisfaction system such as the Filters Paradigm [Ege, 1986] [Grossman and Ege, 1987] is one such system. Filters combines light and heavy weight constraints (filters and logic) to coordinate user-object and object-object interaction respectively. Constraint Hierarchies [Boming et al., 1987] provides more complete but expensive constraint specification. Both are built on top of ThingLuh und allow the user to explicitly define what the interactions between entities are."
      },
      "date": 1655964585381
    },
    {
      "type": "edit",
      "id": "0fe4b822fc9a1651",
      "item": {
        "type": "paragraph",
        "id": "0fe4b822fc9a1651",
        "text": "A constraint satisfaction system such as the Filters Paradigm [Ege, 1986] [Grossman and Ege, 1987] is one such system. Filters combines light and heavy weight constraints (filters and logic) to coordinate user-object and object-object interaction respectively. Constraint Hierarchies [Boming et al., 1987] provides more complete but expensive constraint specification. Both are built on top of ThingLah and allow the user to explicitly define what the interactions between entities are."
      },
      "date": 1655964627269
    },
    {
      "item": {
        "type": "factory",
        "id": "aa0edbcc4229853c"
      },
      "id": "aa0edbcc4229853c",
      "type": "add",
      "after": "0fe4b822fc9a1651",
      "date": 1655964638961
    },
    {
      "type": "edit",
      "id": "aa0edbcc4229853c",
      "item": {
        "type": "paragraph",
        "id": "aa0edbcc4229853c",
        "text": "Another approach to this problem is the use of encapsulators [Pascoe, 1986]. An encapsulator is an object which surrounds another object intercepting all messages to it. In this way, the encapsulator can sense when a \"significant\" change occurs and directly inform interested objects. In both solutions a nice way of specifying what constitutes a significant change remains a challenge."
      },
      "date": 1655964640541
    },
    {
      "type": "edit",
      "id": "0fe4b822fc9a1651",
      "item": {
        "type": "paragraph",
        "id": "0fe4b822fc9a1651",
        "text": "A constraint satisfaction system such as the Filters Paradigm [Ege, 1986] [Grossman and Ege, 1987] is one such system. Filters combines light and heavy weight constraints (filters and logic) to coordinate user-object and object-object interaction respectively. Constraint Hierarchies [Boming et al., 1987] provides more complete but expensive constraint specification. Both are built on top of ThingLab and allow the user to explicitly define what the interactions between entities are."
      },
      "date": 1655964678678
    },
    {
      "type": "edit",
      "id": "0fe4b822fc9a1651",
      "item": {
        "type": "paragraph",
        "id": "0fe4b822fc9a1651",
        "text": "A constraint satisfaction system such as the Filters Paradigm [Ege, 1986] [Grossman and Ege, 1987] is one such system. Filters combines light and heavy weight constraints (filters and logic) to coordinate user-object and object-object interaction respectively. Constraint Hierarchies [Boming et al., 1987] provides more complete but expensive constraint specification. Both are built on top of [[ThingLab]] and allow the user to explicitly define what the interactions between entities are."
      },
      "date": 1655964734524
    },
    {
      "item": {
        "type": "factory",
        "id": "ddb8d96c3492c6ed"
      },
      "id": "ddb8d96c3492c6ed",
      "type": "add",
      "after": "aa0edbcc4229853c",
      "date": 1655964797508
    },
    {
      "type": "edit",
      "id": "ddb8d96c3492c6ed",
      "item": {
        "type": "paragraph",
        "id": "ddb8d96c3492c6ed",
        "text": "⇒ [[Eva Implementation]]"
      },
      "date": 1655964811495
    }
  ]
}