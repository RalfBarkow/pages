{
  "title": "Generic Digital Instrument",
  "story": [
    {
      "type": "paragraph",
      "id": "27520edb6c4c5d09",
      "text": "The prototype imagined something like a software defined radio but with acquisition, memory and display modules aimed at test instrumentation."
    },
    {
      "type": "paragraph",
      "id": "dfd7b0602f2f83a7",
      "text": "The physical design was TM500 sided modules with a 20 MHz ECL bus connecting adjacent plugins which would then have to be plugged in together. A debug extender card was not an option."
    },
    {
      "type": "paragraph",
      "id": "ef36f65852a1d036",
      "text": "Computing was provided by an adjacent rack with a then new Multibus backplane. Various processor, memory and io cards shared the bus asynchronously. We found the commercially available cards lacking in an environment without reliable setup and hold. Instructions failed to properly set state. Memories dropped refresh cycles and eventually forgot."
    },
    {
      "type": "paragraph",
      "id": "3c6e66cc6f4c305f",
      "text": "I was responsible for modular software that would communicate with queued data packets in a scheme generally referred to as \"mailboxes\". I wrote a round-robin scheduler for tasks resident on each individual cpu board. A generic digital module then would consists of its tasks and would communicate with other addressable tasks disregarding their origins."
    },
    {
      "type": "paragraph",
      "id": "e2524417a74964ed",
      "text": "I chose a fixed packet size of 80 bytes plus headers. This matched the terminals we used which were 80 characters wide. In retrospect I should have chosen 128 bytes which would have seemed more modern at the dawn of the microcontroller era."
    },
    {
      "type": "paragraph",
      "id": "e56e5e9792b1b7b5",
      "text": "A request was composed as a sequence of numbers interspersed among control bytes drawn from the printable ascii alphabet. They were created and sent with string interpolation inspired by unix printf. They were parsed upon receipt with a switch statement where clauses for each control code would read numbers where expected. I converted binary data to decimal thereby avoiding any concern for word-endian differences between cpu cards."
    },
    {
      "type": "paragraph",
      "id": "5448b5c6ab687327",
      "text": "I learned the trick of assembling numbers in the slightly larger space of negative two's-complement numbers then negating the result. "
    },
    {
      "type": "code",
      "id": "6236b6bc947abb72",
      "text": "while (nextchar isDigit)\n  assembly = assembly * 10 - digitValue"
    },
    {
      "type": "paragraph",
      "id": "7b639b8ff6f921a5",
      "text": "Tasks could be bundled and burned into EPROM with headers that would cause them to be launched at boot. Parts would be labeled with a bundle name and start address, C000, D000 or E000, depending on which socket they would be placed."
    },
    {
      "type": "paragraph",
      "id": "264b441daa15acce",
      "text": "See [[Multi-Processor Debugging]]"
    },
    {
      "type": "paragraph",
      "id": "246f5206831a75c4",
      "text": "Collaborating tasks guided data through the modular hardware whatever its current configuration. A frequent destination was the custom waveform display which mixed video with 24x80 color characters."
    },
    {
      "type": "paragraph",
      "id": "119bfd9d93ee378a",
      "text": "A window task managed overlapping rectangular character regions on behalf of other tasks. A color manager allocated scarce pallet slots on behalf of tasks that wanted color. A touch task recognized taps, drags and two-finger stretches and dispatched corresponding messages to tasks that registered them."
    },
    {
      "type": "paragraph",
      "id": "c051f72334eac85e",
      "text": "Aside from the rigor of developing in a demanding environment, the multi-bus machinery turned out to be little more than an exotic memory bank switcher commonly used in simpler designs to extend the then prevalent 16-bit processor address space."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Generic Digital Instrument",
        "story": []
      },
      "date": 1463855753068
    },
    {
      "item": {
        "type": "factory",
        "id": "27520edb6c4c5d09"
      },
      "id": "27520edb6c4c5d09",
      "type": "add",
      "date": 1463855768154
    },
    {
      "type": "edit",
      "id": "27520edb6c4c5d09",
      "item": {
        "type": "paragraph",
        "id": "27520edb6c4c5d09",
        "text": "The prototype imagined something like a software defined radio but with acquisition, memory and display modules aimed at test instrumentation."
      },
      "date": 1463855869503
    },
    {
      "type": "add",
      "id": "dfd7b0602f2f83a7",
      "item": {
        "type": "paragraph",
        "id": "dfd7b0602f2f83a7",
        "text": "The physical design was TM500 sided modules with a 20 MHz ECL bus connecting adjacent plugins which would then have to be plugged in together. A debug extender card was not an option."
      },
      "after": "27520edb6c4c5d09",
      "date": 1463856013292
    },
    {
      "type": "add",
      "id": "ef36f65852a1d036",
      "item": {
        "type": "paragraph",
        "id": "ef36f65852a1d036",
        "text": "Computing was provided by an adjacent rack with a then new Multibus backplane. Various processor, memory and io cards shared the bus asynchronously. We found the commercially available cards lacking in an environment without reliable setup and hold. Instructions failed to properly set state. Memories dropped refresh cycles and eventually forgot."
      },
      "after": "dfd7b0602f2f83a7",
      "date": 1463856301454
    },
    {
      "type": "add",
      "id": "3c6e66cc6f4c305f",
      "item": {
        "type": "paragraph",
        "id": "3c6e66cc6f4c305f",
        "text": "I was responsible for modular software that would communicate with queued data packets in a scheme generally referred to as \"mailboxes\". I wrote a round-robin scheduler for tasks resident on each individual cpu board. A generic digital module then would consists of its tasks and would communicate with other addressable tasks disregarding their origins."
      },
      "after": "ef36f65852a1d036",
      "date": 1463856715158
    },
    {
      "type": "add",
      "id": "e2524417a74964ed",
      "item": {
        "type": "paragraph",
        "id": "e2524417a74964ed",
        "text": "I chose a fixed packet size of 80 bytes plus headers. This matched the terminals we used which were 80 characters wide. In retrospect I should have chosen 128 bytes which would have seemed more modern at the dawn of the microcontroller era."
      },
      "after": "3c6e66cc6f4c305f",
      "date": 1463856881467
    },
    {
      "type": "add",
      "id": "e56e5e9792b1b7b5",
      "item": {
        "type": "paragraph",
        "id": "e56e5e9792b1b7b5",
        "text": "A request was composed as a sequence of numbers interspersed among control bytes drawn from the printable ascii alphabet. They were created with string interpolation inspired by unix printf. They were parsed with a switch statement with clauses for each control code. I converted binary data to decimal thereby avoiding any concern for word-endian differences between cpu cards."
      },
      "after": "e2524417a74964ed",
      "date": 1463857164592
    },
    {
      "type": "edit",
      "id": "e56e5e9792b1b7b5",
      "item": {
        "type": "paragraph",
        "id": "e56e5e9792b1b7b5",
        "text": "A request was composed as a sequence of numbers interspersed among control bytes drawn from the printable ascii alphabet. They were created and sent with string interpolation inspired by unix printf. They were parsed upon receipt with a switch statement where clauses for each control code would read numbers where expected. I converted binary data to decimal thereby avoiding any concern for word-endian differences between cpu cards."
      },
      "date": 1463857296608
    },
    {
      "type": "add",
      "id": "7b639b8ff6f921a5",
      "item": {
        "type": "paragraph",
        "id": "7b639b8ff6f921a5",
        "text": "Tasks could be bundled and burned into EPROM with headers that would cause them to be launched at boot. Parts would be labeled with a bundle name and start address, C000, D000 or E000, depending on which socket they would be placed."
      },
      "after": "e56e5e9792b1b7b5",
      "date": 1463857537214
    },
    {
      "type": "add",
      "id": "264b441daa15acce",
      "item": {
        "type": "paragraph",
        "id": "264b441daa15acce",
        "text": "See [[Multi-Processor Debugging]]"
      },
      "after": "7b639b8ff6f921a5",
      "date": 1463857559792
    },
    {
      "item": {
        "type": "factory",
        "id": "6236b6bc947abb72"
      },
      "id": "6236b6bc947abb72",
      "type": "add",
      "after": "264b441daa15acce",
      "date": 1463857624575
    },
    {
      "type": "edit",
      "id": "6236b6bc947abb72",
      "item": {
        "type": "code",
        "id": "6236b6bc947abb72",
        "text": "while (nextchar isDigit)\n  assembly = assembly * 10 - digitValue"
      },
      "date": 1463857758987
    },
    {
      "type": "move",
      "order": [
        "27520edb6c4c5d09",
        "dfd7b0602f2f83a7",
        "ef36f65852a1d036",
        "3c6e66cc6f4c305f",
        "e2524417a74964ed",
        "e56e5e9792b1b7b5",
        "6236b6bc947abb72",
        "7b639b8ff6f921a5",
        "264b441daa15acce"
      ],
      "id": "6236b6bc947abb72",
      "date": 1463857771436
    },
    {
      "type": "add",
      "id": "5448b5c6ab687327",
      "item": {
        "type": "paragraph",
        "id": "5448b5c6ab687327",
        "text": "I learned the trick of assembling numbers in the slightly larger space of negative two's-complement numbers then negating the result. "
      },
      "after": "e56e5e9792b1b7b5",
      "date": 1463857887764
    },
    {
      "type": "add",
      "id": "246f5206831a75c4",
      "item": {
        "type": "paragraph",
        "id": "246f5206831a75c4",
        "text": "Collaborating tasks guided data through the modular hardware whatever its current configuration. A frequent destination was the custom waveform display which mixed video with 24x80 color characters."
      },
      "after": "264b441daa15acce",
      "date": 1463858264539
    },
    {
      "type": "add",
      "id": "119bfd9d93ee378a",
      "item": {
        "type": "paragraph",
        "id": "119bfd9d93ee378a",
        "text": "A window task managed overlapping rectangular character regions on behalf of other tasks. A color manager allocated scarce pallet slots on behalf of tasks that wanted color. A touch task recognized taps, drags and two-finger stretches and dispatched corresponding messages to tasks that registered them."
      },
      "after": "246f5206831a75c4",
      "date": 1463858611674
    },
    {
      "type": "add",
      "id": "c051f72334eac85e",
      "item": {
        "type": "paragraph",
        "id": "c051f72334eac85e",
        "text": "Aside from the rigor of developing in a demanding environment, the multi-bus machinery turned out to be little more than an exotic memory bank switcher commonly used in simpler designs to extend the then prevalent 16-bit processor address space."
      },
      "after": "119bfd9d93ee378a",
      "date": 1463858814604
    },
    {
      "type": "fork",
      "site": "code.fed.wiki.org",
      "date": 1641562792117
    }
  ]
}