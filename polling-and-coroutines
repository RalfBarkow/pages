{
  "title": "Polling and Coroutines",
  "story": [
    {
      "type": "paragraph",
      "id": "20c9a985a7032dfa",
      "text": "The use of polling and coroutines to handle asynchronous events places too much responsibility on the application programmer who must obtain and release control of the processor. Polling systems are simple but they prevent true multitasking, restrict the interface to a single focus of control and force the user interface to keep the notion of an active window to maintain context. Further, since a polling loop will test the supported devices in a specific order, some inputs have a slightly higher priority than the others."
    },
    {
      "type": "markdown",
      "id": "0641f7dd9d93a6e8",
      "text": "In a system based on polling, programmers can inadvertently lockup the system while debugging the user interface. Such a lockup typically leaves them asking the question so frequently asked by Smalltalk users, \"When I am in this part of the window what code gets executed when I do this (e.g., [[move]] the [[Mouse]])?\". These problems arise because **Smalltalk’s controllers** (discussed below) **poll for both input and control**. When input is sensed by one controller, it asks the other controllers if they want control, the first controller that wants control processes the input. This confusion is indicative of the problems surrounding polling mechanisms."
    },
    {
      "type": "graphviz",
      "id": "3f89bff608a77499",
      "text": "DOT FROM lambda-browsing"
    },
    {
      "type": "paragraph",
      "id": "8b8b4c3b6ba9fe0f",
      "text": "It is often difficult to implement a clean solution to a problem in a polling-based system. For example, the decision to use a single event loop in systems like the Macintosh makes writing complex applications very difficult and multitasking is hard to introduce (e.g., MultiFinder). As a result, the event loops arc complicated and monolithic."
    },
    {
      "type": "paragraph",
      "id": "bd6e2ee4109d9279",
      "text": "⇒ [[You Can't Do It All With Inheritance]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Polling and Coroutines",
        "story": []
      },
      "date": 1655957723055
    },
    {
      "item": {
        "type": "factory",
        "id": "20c9a985a7032dfa"
      },
      "id": "20c9a985a7032dfa",
      "type": "add",
      "date": 1655957736339
    },
    {
      "type": "edit",
      "id": "20c9a985a7032dfa",
      "item": {
        "type": "paragraph",
        "id": "20c9a985a7032dfa",
        "text": "The use of polling and coroutines to handle asynchronous events places too much responsibility on the application programmer who must obtain and release control of the processor. Polling systems are simple but they prevent true multitasking, restrict the interface to a single focus of control and force the user interface to keep the notion of an active window to maintain context. Further, since a polling loop will test the supported devices in a specific order, some inputs have a slightly higher priority than the others."
      },
      "date": 1655957737692
    },
    {
      "item": {
        "type": "factory",
        "id": "0641f7dd9d93a6e8"
      },
      "id": "0641f7dd9d93a6e8",
      "type": "add",
      "after": "20c9a985a7032dfa",
      "date": 1655957769302
    },
    {
      "type": "edit",
      "id": "0641f7dd9d93a6e8",
      "item": {
        "type": "paragraph",
        "id": "0641f7dd9d93a6e8",
        "text": "In a system based on polling, programmers can inadvertently lockup the system while debugging the user interface. Such a lockup typically leaves them asking the"
      },
      "date": 1655957770874
    },
    {
      "type": "edit",
      "id": "0641f7dd9d93a6e8",
      "item": {
        "type": "paragraph",
        "id": "0641f7dd9d93a6e8",
        "text": "In a system based on polling, programmers can inadvertently lockup the system while debugging the user interface. Such a lockup typically leaves them asking the question so frequently asked by Smalltalk users, \"When 1 am in tl-.is part of the window what code gets executed when I do this (e.g., move the mouse)?\". These problems arise because Smalltalk’s controllers (discussed below) poll for both input and control. When input is sensed by one controller, it asks the other controllers if they want control, the first controller that wants control processes the input. This confusion is indicative of the problems surrounding polling mechanisms."
      },
      "date": 1655957783146
    },
    {
      "type": "edit",
      "id": "0641f7dd9d93a6e8",
      "item": {
        "type": "paragraph",
        "id": "0641f7dd9d93a6e8",
        "text": "In a system based on polling, programmers can inadvertently lockup the system while debugging the user interface. Such a lockup typically leaves them asking the question so frequently asked by Smalltalk users, \"When I am in this part of the window what code gets executed when I do this (e.g., move the mouse)?\". These problems arise because Smalltalk’s controllers (discussed below) poll for both input and control. When input is sensed by one controller, it asks the other controllers if they want control, the first controller that wants control processes the input. This confusion is indicative of the problems surrounding polling mechanisms."
      },
      "date": 1655957820597
    },
    {
      "type": "edit",
      "id": "0641f7dd9d93a6e8",
      "item": {
        "type": "paragraph",
        "id": "0641f7dd9d93a6e8",
        "text": "In a system based on polling, programmers can inadvertently lockup the system while debugging the user interface. Such a lockup typically leaves them asking the question so frequently asked by Smalltalk users, \"When I am in this part of the window what code gets executed when I do this (e.g., [[move]] the mouse)?\". These problems arise because Smalltalk’s controllers (discussed below) poll for both input and control. When input is sensed by one controller, it asks the other controllers if they want control, the first controller that wants control processes the input. This confusion is indicative of the problems surrounding polling mechanisms."
      },
      "date": 1655957850428
    },
    {
      "type": "edit",
      "id": "0641f7dd9d93a6e8",
      "item": {
        "type": "paragraph",
        "id": "0641f7dd9d93a6e8",
        "text": "In a system based on polling, programmers can inadvertently lockup the system while debugging the user interface. Such a lockup typically leaves them asking the question so frequently asked by Smalltalk users, \"When I am in this part of the window what code gets executed when I do this (e.g., [[move]] the [[Mouse]])?\". These problems arise because Smalltalk’s controllers (discussed below) poll for both input and control. When input is sensed by one controller, it asks the other controllers if they want control, the first controller that wants control processes the input. This confusion is indicative of the problems surrounding polling mechanisms."
      },
      "date": 1655958067064
    },
    {
      "item": {
        "type": "factory",
        "id": "3f89bff608a77499"
      },
      "id": "3f89bff608a77499",
      "type": "add",
      "after": "0641f7dd9d93a6e8",
      "date": 1655958073408
    },
    {
      "type": "edit",
      "id": "3f89bff608a77499",
      "item": {
        "type": "graphviz",
        "id": "3f89bff608a77499",
        "text": "DOT FROM lambda-browsing"
      },
      "date": 1655958082164
    },
    {
      "type": "edit",
      "id": "0641f7dd9d93a6e8",
      "item": {
        "type": "paragraph",
        "id": "0641f7dd9d93a6e8",
        "text": "In a system based on polling, programmers can inadvertently lockup the system while debugging the user interface. Such a lockup typically leaves them asking the question so frequently asked by Smalltalk users, \"When I am in this part of the window what code gets executed when I do this (e.g., [[move]] the [[Mouse]])?\". These problems arise because **Smalltalk’s controllers (discussed below) poll for both input and control**. When input is sensed by one controller, it asks the other controllers if they want control, the first controller that wants control processes the input. This confusion is indicative of the problems surrounding polling mechanisms."
      },
      "date": 1655958115276
    },
    {
      "type": "edit",
      "id": "0641f7dd9d93a6e8",
      "item": {
        "type": "markdown",
        "id": "0641f7dd9d93a6e8",
        "text": "In a system based on polling, programmers can inadvertently lockup the system while debugging the user interface. Such a lockup typically leaves them asking the question so frequently asked by Smalltalk users, \"When I am in this part of the window what code gets executed when I do this (e.g., [[move]] the [[Mouse]])?\". These problems arise because **Smalltalk’s controllers (discussed below) poll for both input and control**. When input is sensed by one controller, it asks the other controllers if they want control, the first controller that wants control processes the input. This confusion is indicative of the problems surrounding polling mechanisms."
      },
      "date": 1655958116733
    },
    {
      "type": "edit",
      "id": "0641f7dd9d93a6e8",
      "item": {
        "type": "markdown",
        "id": "0641f7dd9d93a6e8",
        "text": "In a system based on polling, programmers can inadvertently lockup the system while debugging the user interface. Such a lockup typically leaves them asking the question so frequently asked by Smalltalk users, \"When I am in this part of the window what code gets executed when I do this (e.g., [[move]] the [[Mouse]])?\". These problems arise because **Smalltalk’s controllers** (discussed below) **poll for both input and control**. When input is sensed by one controller, it asks the other controllers if they want control, the first controller that wants control processes the input. This confusion is indicative of the problems surrounding polling mechanisms."
      },
      "date": 1655958128784
    },
    {
      "item": {
        "type": "factory",
        "id": "8b8b4c3b6ba9fe0f"
      },
      "id": "8b8b4c3b6ba9fe0f",
      "type": "add",
      "after": "3f89bff608a77499",
      "date": 1655958288203
    },
    {
      "type": "edit",
      "id": "8b8b4c3b6ba9fe0f",
      "item": {
        "type": "paragraph",
        "id": "8b8b4c3b6ba9fe0f",
        "text": "It is often difficult to implement a clean solution to a problem in a polling-based system. For example, the decision to use a single event loop in systems like the Macintosh makes writing complex applications very difficult and multitasking is hard to introduce (e.g., MultiFinder). As a result, the event loops arc complicated and monolithic."
      },
      "date": 1655958289899
    },
    {
      "item": {
        "type": "factory",
        "id": "bd6e2ee4109d9279"
      },
      "id": "bd6e2ee4109d9279",
      "type": "add",
      "after": "8b8b4c3b6ba9fe0f",
      "date": 1655959887576
    },
    {
      "type": "edit",
      "id": "bd6e2ee4109d9279",
      "item": {
        "type": "paragraph",
        "id": "bd6e2ee4109d9279",
        "text": "⇒ [[You Can't Do It All With Inheritance]]"
      },
      "date": 1655959902161
    }
  ]
}