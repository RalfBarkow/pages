{
  "title": "2022-01-20",
  "story": [
    {
      "type": "pagefold",
      "id": "545d8a987abee3a0",
      "text": "gt Discord"
    },
    {
      "type": "markdown",
      "id": "7295016dc92fad38",
      "text": "robr — gestern um 23:17 Uhr\n@tudor girba I think the characteristics of [[GT]] that I find the most intriguing are how it reiterates/expands upon ideas like [[Ted Nelson]]'s [[Hypermedia]] inclusions and Don Kunth's \"[[Literate Programming]]\". For instance, annotating text with markers that expand inline into other components/visualizations is a very powerful idea, and one that (I feel) we've only explored in very näive ways. I do a lot of mentoring less experienced developers and I find I'm always flipping between code and documentation/explanation which can not only be wearying, but I find it interferes with the pedagogical process. Unfortunately, for me, the most intriguing features of GT seem to be the least documented (at least as I've so far discovered.) I'm itching to give engineering presentations using GToolkit-Presenter. \n"
    },
    {
      "type": "markdown",
      "id": "f5f43886d26ef9e0",
      "text": "@tudor girba If you have any preliminary doc for Presenter, I'd be happy to help clean it up / expand it.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "c0db74ad1452615a",
      "text": "tudor girba — gestern um 23:52 Uhr\nThere isn't a documentation beyond the slideshows from the image. But, how about I show you around in a 1-to-1 session that we record and in which I can address your questions?\n\n"
    },
    {
      "type": "markdown",
      "id": "51e3ec0d9eb78aef",
      "text": "See [[Watch What I Do]] pattern"
    },
    {
      "type": "markdown",
      "id": "83819198f751bab0",
      "text": "robr — gestern um 23:57 Uhr\nThat would be wonderful. Let me familiarize myself with the classes a bit and reach back when I have enough knowledge to be dangerous (and so your explanations won't go in one ear and out the other. ;))"
    },
    {
      "type": "pagefold",
      "id": "61d9ea2ad2fa3dd2",
      "text": "how-to"
    },
    {
      "type": "paragraph",
      "id": "002220cdb18556c1",
      "text": "Steering Agile Architecture by Example: the Feature Toggles From Open edX [https://lepiter.io/feenk/steering-agile-architecture-by-example--th-e2p6aps2brbby94deek31xqxh/ post]"
    },
    {
      "type": "reference",
      "id": "bcacd2225e21545e",
      "site": "wiki.ralfbarkow.ch",
      "slug": "steering-agile-architecture-by-example",
      "title": "Steering Agile Architecture by Example",
      "text": "[https://lepiter.io/feenk/steering-agile-architecture-by-example--th-e2p6aps2brbby94deek31xqxh/ page] – an illustration of what \"understanding the system without reading code\" means in practice."
    },
    {
      "type": "pagefold",
      "id": "7f213fa55144adf7",
      "text": "Twitter"
    },
    {
      "type": "reference",
      "id": "6e02a6e683cc9c07",
      "site": "wiki.ralfbarkow.ch",
      "slug": "another-level-of-thought",
      "title": "Another Level of Thought",
      "text": "I am digging deeper into Smalltalk and agile after my check-in this week with Ward."
    },
    {
      "type": "pagefold",
      "id": "965a6278506a6363",
      "text": "hoot-smalltalk"
    },
    {
      "type": "paragraph",
      "id": "a4b462ddcdd92210",
      "text": "Using Natural Language in Software Development [https://educery.dev/papers/modeling/natural-language-software-development/#head page]"
    },
    {
      "type": "markdown",
      "id": "0e6b8a3c68af5cbd",
      "text": "### Smalltalk is a better modeling language than Java and C#.\n\nSmalltalk is far more expressive and readable than Java and C#, partly due to Smalltalk's simplicity. But also, as I indicated in Using Natural Language in Software Development, Smalltalk provides a natural way to model the elements of problem descriptions expressed in English (and at least potentially, any natural language) by directly supporting the linguistic metaphors we use in object-oriented software designs. Thus, Smalltalk can provide superior traceability from code back to the original solution requirements. [https://github.com/nikboyd/hoot-smalltalk/blob/main/hoot-design/faq.md#frequently-asked-questions github] ﻿﻿Nikolas S Boyd"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2022-01-20",
        "story": []
      },
      "date": 1642674372928
    },
    {
      "item": {
        "type": "factory",
        "id": "7295016dc92fad38"
      },
      "id": "7295016dc92fad38",
      "type": "add",
      "date": 1642674375431
    },
    {
      "type": "edit",
      "id": "7295016dc92fad38",
      "item": {
        "type": "markdown",
        "id": "7295016dc92fad38",
        "text": "robr — gestern um 23:17 Uhr\n@tudor girba I think the characteristics of GT that I find the most intriguing are how it reiterates/expands upon ideas like Ted Nelson's Hypermedia inclusions and Don Kunth's \"Literate Programming\". For instance, annotating text with markers that expand inline into other components/visualizations is a very powerful idea, and one that (I feel) we've only explored in very näive ways. I do a lot of mentoring less experienced developers and I find I'm always flipping between code and documentation/explanation which can not only be wearying, but I find it interferes with the pedagogical process. Unfortunately, for me, the most intriguing features of GT seem to be the least documented (at least as I've so far discovered.) I'm itching to give engineering presentations using GToolkit-Presenter. \n@tudor girba If you have any preliminary doc for Presenter, I'd be happy to help clean it up / expand it.\ntudor girba — gestern um 23:52 Uhr\nThere isn't a documentation beyond the slideshows from the image. But, how about I show you around in a 1-to-1 session that we record and in which I can address your questions?\nrobr — gestern um 23:57 Uhr\nThat would be wonderful. Let me familiarize myself with the classes a bit and reach back when I have enough knowledge to be dangerous (and so your explanations won't go in one ear and out the other. ;))"
      },
      "date": 1642674377050
    },
    {
      "type": "edit",
      "id": "7295016dc92fad38",
      "item": {
        "type": "markdown",
        "id": "7295016dc92fad38",
        "text": "robr — gestern um 23:17 Uhr\n@tudor girba I think the characteristics of GT that I find the most intriguing are how it reiterates/expands upon ideas like [[Ted Nelson]]'s [[Hypermedia]] inclusions and Don Kunth's \"[[Literate Programming]]\". For instance, annotating text with markers that expand inline into other components/visualizations is a very powerful idea, and one that (I feel) we've only explored in very näive ways. I do a lot of mentoring less experienced developers and I find I'm always flipping between code and documentation/explanation which can not only be wearying, but I find it interferes with the pedagogical process. Unfortunately, for me, the most intriguing features of GT seem to be the least documented (at least as I've so far discovered.) I'm itching to give engineering presentations using GToolkit-Presenter. \n@tudor girba If you have any preliminary doc for Presenter, I'd be happy to help clean it up / expand it.\ntudor girba — gestern um 23:52 Uhr\nThere isn't a documentation beyond the slideshows from the image. But, how about I show you around in a 1-to-1 session that we record and in which I can address your questions?\nrobr — gestern um 23:57 Uhr\nThat would be wonderful. Let me familiarize myself with the classes a bit and reach back when I have enough knowledge to be dangerous (and so your explanations won't go in one ear and out the other. ;))"
      },
      "date": 1642674417026
    },
    {
      "item": {
        "type": "factory",
        "id": "545d8a987abee3a0"
      },
      "id": "545d8a987abee3a0",
      "type": "add",
      "after": "7295016dc92fad38",
      "date": 1642674487317
    },
    {
      "type": "edit",
      "id": "7295016dc92fad38",
      "item": {
        "type": "markdown",
        "id": "7295016dc92fad38",
        "text": "robr — gestern um 23:17 Uhr\n@tudor girba I think the characteristics of [[GT]] that I find the most intriguing are how it reiterates/expands upon ideas like [[Ted Nelson]]'s [[Hypermedia]] inclusions and Don Kunth's \"[[Literate Programming]]\". For instance, annotating text with markers that expand inline into other components/visualizations is a very powerful idea, and one that (I feel) we've only explored in very näive ways. I do a lot of mentoring less experienced developers and I find I'm always flipping between code and documentation/explanation which can not only be wearying, but I find it interferes with the pedagogical process. Unfortunately, for me, the most intriguing features of GT seem to be the least documented (at least as I've so far discovered.) I'm itching to give engineering presentations using GToolkit-Presenter. \n@tudor girba If you have any preliminary doc for Presenter, I'd be happy to help clean it up / expand it.\ntudor girba — gestern um 23:52 Uhr\nThere isn't a documentation beyond the slideshows from the image. But, how about I show you around in a 1-to-1 session that we record and in which I can address your questions?\nrobr — gestern um 23:57 Uhr\nThat would be wonderful. Let me familiarize myself with the classes a bit and reach back when I have enough knowledge to be dangerous (and so your explanations won't go in one ear and out the other. ;))"
      },
      "date": 1642674488775
    },
    {
      "type": "edit",
      "id": "545d8a987abee3a0",
      "item": {
        "type": "pagefold",
        "id": "545d8a987abee3a0",
        "text": "gt"
      },
      "date": 1642674492061
    },
    {
      "id": "545d8a987abee3a0",
      "type": "move",
      "order": [
        "545d8a987abee3a0",
        "7295016dc92fad38"
      ],
      "date": 1642674494577
    },
    {
      "type": "edit",
      "id": "545d8a987abee3a0",
      "item": {
        "type": "pagefold",
        "id": "545d8a987abee3a0",
        "text": "gt Discord"
      },
      "date": 1642674504158
    },
    {
      "type": "edit",
      "id": "7295016dc92fad38",
      "item": {
        "type": "markdown",
        "id": "7295016dc92fad38",
        "text": "robr — gestern um 23:17 Uhr\n@tudor girba I think the characteristics of [[GT]] that I find the most intriguing are how it reiterates/expands upon ideas like [[Ted Nelson]]'s [[Hypermedia]] inclusions and Don Kunth's \"[[Literate Programming]]\". For instance, annotating text with markers that expand inline into other components/visualizations is a very powerful idea, and one that (I feel) we've only explored in very näive ways. I do a lot of mentoring less experienced developers and I find I'm always flipping between code and documentation/explanation which can not only be wearying, but I find it interferes with the pedagogical process. Unfortunately, for me, the most intriguing features of GT seem to be the least documented (at least as I've so far discovered.) I'm itching to give engineering presentations using GToolkit-Presenter. \n@tudor girba If you have any preliminary doc for Presenter, I'd be happy to help clean it up / expand it.\n\ntudor girba — gestern um 23:52 Uhr\nThere isn't a documentation beyond the slideshows from the image. But, how about I show you around in a 1-to-1 session that we record and in which I can address your questions?\n\n"
      },
      "date": 1642674529348
    },
    {
      "item": {
        "type": "factory",
        "id": "6f868b57ad037ce6"
      },
      "id": "6f868b57ad037ce6",
      "type": "add",
      "after": "83819198f751bab0",
      "date": 1642674531621
    },
    {
      "type": "add",
      "id": "83819198f751bab0",
      "item": {
        "type": "markdown",
        "id": "83819198f751bab0",
        "text": "robr — gestern um 23:57 Uhr\nThat would be wonderful. Let me familiarize myself with the classes a bit and reach back when I have enough knowledge to be dangerous (and so your explanations won't go in one ear and out the other. ;))"
      },
      "after": "7295016dc92fad38",
      "date": 1642674532665
    },
    {
      "type": "remove",
      "id": "6f868b57ad037ce6",
      "date": 1642674534692
    },
    {
      "type": "edit",
      "id": "7295016dc92fad38",
      "item": {
        "type": "markdown",
        "id": "7295016dc92fad38",
        "text": "robr — gestern um 23:17 Uhr\n@tudor girba I think the characteristics of [[GT]] that I find the most intriguing are how it reiterates/expands upon ideas like [[Ted Nelson]]'s [[Hypermedia]] inclusions and Don Kunth's \"[[Literate Programming]]\". For instance, annotating text with markers that expand inline into other components/visualizations is a very powerful idea, and one that (I feel) we've only explored in very näive ways. I do a lot of mentoring less experienced developers and I find I'm always flipping between code and documentation/explanation which can not only be wearying, but I find it interferes with the pedagogical process. Unfortunately, for me, the most intriguing features of GT seem to be the least documented (at least as I've so far discovered.) I'm itching to give engineering presentations using GToolkit-Presenter. \n@tudor girba If you have any preliminary doc for Presenter, I'd be happy to help clean it up / expand it.\n\n\n"
      },
      "date": 1642674565504
    },
    {
      "type": "add",
      "id": "c0db74ad1452615a",
      "item": {
        "type": "markdown",
        "id": "c0db74ad1452615a",
        "text": "tudor girba — gestern um 23:52 Uhr\nThere isn't a documentation beyond the slideshows from the image. But, how about I show you around in a 1-to-1 session that we record and in which I can address your questions?\n\n"
      },
      "after": "7295016dc92fad38",
      "date": 1642674568036
    },
    {
      "type": "add",
      "id": "51e3ec0d9eb78aef",
      "item": {
        "type": "markdown",
        "id": "51e3ec0d9eb78aef",
        "text": "See [[Watch What I Do]]"
      },
      "after": "c0db74ad1452615a",
      "date": 1642674574035
    },
    {
      "type": "edit",
      "id": "51e3ec0d9eb78aef",
      "item": {
        "type": "markdown",
        "id": "51e3ec0d9eb78aef",
        "text": "See [[Watch What I Do]] pattern"
      },
      "date": 1642674591830
    },
    {
      "type": "edit",
      "id": "7295016dc92fad38",
      "item": {
        "type": "markdown",
        "id": "7295016dc92fad38",
        "text": "robr — gestern um 23:17 Uhr\n@tudor girba I think the characteristics of [[GT]] that I find the most intriguing are how it reiterates/expands upon ideas like [[Ted Nelson]]'s [[Hypermedia]] inclusions and Don Kunth's \"[[Literate Programming]]\". For instance, annotating text with markers that expand inline into other components/visualizations is a very powerful idea, and one that (I feel) we've only explored in very näive ways. I do a lot of mentoring less experienced developers and I find I'm always flipping between code and documentation/explanation which can not only be wearying, but I find it interferes with the pedagogical process. Unfortunately, for me, the most intriguing features of GT seem to be the least documented (at least as I've so far discovered.) I'm itching to give engineering presentations using GToolkit-Presenter. \n"
      },
      "date": 1642674619197
    },
    {
      "type": "add",
      "id": "f5f43886d26ef9e0",
      "item": {
        "type": "markdown",
        "id": "f5f43886d26ef9e0",
        "text": "@tudor girba If you have any preliminary doc for Presenter, I'd be happy to help clean it up / expand it.\n\n\n"
      },
      "after": "7295016dc92fad38",
      "date": 1642674619700
    },
    {
      "item": {
        "type": "factory",
        "id": "61d9ea2ad2fa3dd2"
      },
      "id": "61d9ea2ad2fa3dd2",
      "type": "add",
      "after": "83819198f751bab0",
      "date": 1642674683658
    },
    {
      "type": "edit",
      "id": "61d9ea2ad2fa3dd2",
      "item": {
        "type": "pagefold",
        "id": "61d9ea2ad2fa3dd2",
        "text": "how-to"
      },
      "date": 1642674692704
    },
    {
      "item": {
        "type": "factory",
        "id": "002220cdb18556c1"
      },
      "id": "002220cdb18556c1",
      "type": "add",
      "after": "61d9ea2ad2fa3dd2",
      "date": 1642674697226
    },
    {
      "type": "edit",
      "id": "002220cdb18556c1",
      "item": {
        "type": "paragraph",
        "id": "002220cdb18556c1",
        "text": "Steering Agile Architecture by Example: the Feature Toggles From Open edX "
      },
      "date": 1642674700343
    },
    {
      "type": "edit",
      "id": "002220cdb18556c1",
      "item": {
        "type": "paragraph",
        "id": "002220cdb18556c1",
        "text": "Steering Agile Architecture by Example: the Feature Toggles From Open edX [https://lepiter.io/feenk/steering-agile-architecture-by-example--th-e2p6aps2brbby94deek31xqxh/ post]"
      },
      "date": 1642674708752
    },
    {
      "item": {
        "type": "factory",
        "id": "bcacd2225e21545e"
      },
      "id": "bcacd2225e21545e",
      "type": "add",
      "after": "002220cdb18556c1",
      "date": 1642674725395
    },
    {
      "type": "edit",
      "id": "bcacd2225e21545e",
      "item": {
        "type": "reference",
        "id": "bcacd2225e21545e",
        "site": "wiki.ralfbarkow.ch",
        "slug": "steering-agile-architecture-by-example",
        "title": "Steering Agile Architecture by Example",
        "text": "[https://lepiter.io/feenk/steering-agile-architecture-by-example--th-e2p6aps2brbby94deek31xqxh/ page] – an illustration of what \"understanding the system without reading code\" means in practice."
      },
      "date": 1642674728246
    },
    {
      "item": {
        "type": "factory",
        "id": "7f213fa55144adf7"
      },
      "id": "7f213fa55144adf7",
      "type": "add",
      "after": "bcacd2225e21545e",
      "date": 1642676370806
    },
    {
      "type": "edit",
      "id": "7f213fa55144adf7",
      "item": {
        "type": "pagefold",
        "id": "7f213fa55144adf7",
        "text": "Twitter"
      },
      "date": 1642676375438
    },
    {
      "item": {
        "type": "factory",
        "id": "6e02a6e683cc9c07"
      },
      "id": "6e02a6e683cc9c07",
      "type": "add",
      "after": "7f213fa55144adf7",
      "date": 1642676391848
    },
    {
      "type": "edit",
      "id": "6e02a6e683cc9c07",
      "item": {
        "type": "reference",
        "id": "6e02a6e683cc9c07",
        "site": "wiki.ralfbarkow.ch",
        "slug": "another-level-of-thought",
        "title": "Another Level of Thought",
        "text": "I am digging deeper into Smalltalk and agile after my check-in this week with Ward."
      },
      "date": 1642676395192
    },
    {
      "item": {
        "type": "factory",
        "id": "965a6278506a6363"
      },
      "id": "965a6278506a6363",
      "type": "add",
      "after": "6e02a6e683cc9c07",
      "date": 1642719237464
    },
    {
      "type": "edit",
      "id": "965a6278506a6363",
      "item": {
        "type": "pagefold",
        "id": "965a6278506a6363",
        "text": "~"
      },
      "date": 1642719242558
    },
    {
      "item": {
        "type": "factory",
        "id": "a4b462ddcdd92210"
      },
      "id": "a4b462ddcdd92210",
      "type": "add",
      "after": "965a6278506a6363",
      "date": 1642719244113
    },
    {
      "type": "edit",
      "id": "a4b462ddcdd92210",
      "item": {
        "type": "paragraph",
        "id": "a4b462ddcdd92210",
        "text": "Using Natural Language in Software Development"
      },
      "date": 1642719247717
    },
    {
      "type": "edit",
      "id": "965a6278506a6363",
      "item": {
        "type": "pagefold",
        "id": "965a6278506a6363",
        "text": "hoot-smalltalk"
      },
      "date": 1642719259081
    },
    {
      "type": "edit",
      "id": "a4b462ddcdd92210",
      "item": {
        "type": "paragraph",
        "id": "a4b462ddcdd92210",
        "text": "Using Natural Language in Software Development [https://educery.dev/papers/modeling/natural-language-software-development/#head "
      },
      "date": 1642719361457
    },
    {
      "type": "edit",
      "id": "a4b462ddcdd92210",
      "item": {
        "type": "paragraph",
        "id": "a4b462ddcdd92210",
        "text": "Using Natural Language in Software Development [https://educery.dev/papers/modeling/natural-language-software-development/#head page]"
      },
      "date": 1642719374977
    },
    {
      "type": "add",
      "id": "0e6b8a3c68af5cbd",
      "item": {
        "type": "paragraph",
        "id": "0e6b8a3c68af5cbd",
        "text": "Smalltalk is a better modeling language than Java and C#.\n\nSmalltalk is far more expressive and readable than Java and C#, partly due to Smalltalk's simplicity. But also, as I indicated in Using Natural Language in Software Development, Smalltalk provides a natural way to model the elements of problem descriptions expressed in English (and at least potentially, any natural language) by directly supporting the linguistic metaphors we use in object-oriented software designs. Thus, Smalltalk can provide superior traceability from code back to the original solution requirements."
      },
      "after": "a4b462ddcdd92210",
      "date": 1642719586969
    },
    {
      "type": "edit",
      "id": "0e6b8a3c68af5cbd",
      "item": {
        "type": "paragraph",
        "id": "0e6b8a3c68af5cbd",
        "text": "Smalltalk is a better modeling language than Java and C#.\n\nSmalltalk is far more expressive and readable than Java and C#, partly due to Smalltalk's simplicity. But also, as I indicated in Using Natural Language in Software Development, Smalltalk provides a natural way to model the elements of problem descriptions expressed in English (and at least potentially, any natural language) by directly supporting the linguistic metaphors we use in object-oriented software designs. Thus, Smalltalk can provide superior traceability from code back to the original solution requirements. [https://github.com/nikboyd/hoot-smalltalk/blob/main/hoot-design/faq.md#frequently-asked-questions github]"
      },
      "date": 1642719599130
    },
    {
      "type": "edit",
      "id": "0e6b8a3c68af5cbd",
      "item": {
        "type": "paragraph",
        "id": "0e6b8a3c68af5cbd",
        "text": "### Smalltalk is a better modeling language than Java and C#.\n\nSmalltalk is far more expressive and readable than Java and C#, partly due to Smalltalk's simplicity. But also, as I indicated in Using Natural Language in Software Development, Smalltalk provides a natural way to model the elements of problem descriptions expressed in English (and at least potentially, any natural language) by directly supporting the linguistic metaphors we use in object-oriented software designs. Thus, Smalltalk can provide superior traceability from code back to the original solution requirements. [https://github.com/nikboyd/hoot-smalltalk/blob/main/hoot-design/faq.md#frequently-asked-questions github]"
      },
      "date": 1642719669664
    },
    {
      "type": "edit",
      "id": "0e6b8a3c68af5cbd",
      "item": {
        "type": "markdown",
        "id": "0e6b8a3c68af5cbd",
        "text": "### Smalltalk is a better modeling language than Java and C#.\n\nSmalltalk is far more expressive and readable than Java and C#, partly due to Smalltalk's simplicity. But also, as I indicated in Using Natural Language in Software Development, Smalltalk provides a natural way to model the elements of problem descriptions expressed in English (and at least potentially, any natural language) by directly supporting the linguistic metaphors we use in object-oriented software designs. Thus, Smalltalk can provide superior traceability from code back to the original solution requirements. [https://github.com/nikboyd/hoot-smalltalk/blob/main/hoot-design/faq.md#frequently-asked-questions github]"
      },
      "date": 1642719671170
    },
    {
      "type": "edit",
      "id": "0e6b8a3c68af5cbd",
      "item": {
        "type": "markdown",
        "id": "0e6b8a3c68af5cbd",
        "text": "### Smalltalk is a better modeling language than Java and C#.\n\nSmalltalk is far more expressive and readable than Java and C#, partly due to Smalltalk's simplicity. But also, as I indicated in Using Natural Language in Software Development, Smalltalk provides a natural way to model the elements of problem descriptions expressed in English (and at least potentially, any natural language) by directly supporting the linguistic metaphors we use in object-oriented software designs. Thus, Smalltalk can provide superior traceability from code back to the original solution requirements. [https://github.com/nikboyd/hoot-smalltalk/blob/main/hoot-design/faq.md#frequently-asked-questions github] "
      },
      "date": 1642719855515
    },
    {
      "type": "edit",
      "id": "0e6b8a3c68af5cbd",
      "item": {
        "type": "markdown",
        "id": "0e6b8a3c68af5cbd",
        "text": "### Smalltalk is a better modeling language than Java and C#.\n\nSmalltalk is far more expressive and readable than Java and C#, partly due to Smalltalk's simplicity. But also, as I indicated in Using Natural Language in Software Development, Smalltalk provides a natural way to model the elements of problem descriptions expressed in English (and at least potentially, any natural language) by directly supporting the linguistic metaphors we use in object-oriented software designs. Thus, Smalltalk can provide superior traceability from code back to the original solution requirements. [https://github.com/nikboyd/hoot-smalltalk/blob/main/hoot-design/faq.md#frequently-asked-questions github] ﻿﻿Nikolas S Boyd"
      },
      "date": 1642719877898
    }
  ]
}