{
  "title": "Remote-DOM",
  "story": [
    {
      "type": "paragraph",
      "id": "66ef7cd633810823",
      "text": "Remote-DOM is a tiny library with less than 1k lines of code, with two halves remote and local. The remote half, supplies a [[browser facade]], a virtual window and document, to other libraries letting them use the APIs they know and expect the browser to supply like: document.createElement window.addEventListener and so on, without having any actual DOM, and sends these commands back as JSONs to the local half. The local half of the library interprets that JSON and does the real creating of DOM nodes and adding event listeners, and when an event happens it send it’s information back to the remote side as JSON, all you need to do to connect them is give them a way to communicate between them."
    },
    {
      "type": "paragraph",
      "id": "b9f4b0c6124696dd",
      "text": "Trust in the browser is an all or nothing affair, you either run a snippet of JavaScript in the main document on the main UI thread, with access to every global, to any part of the DOM, or you run it in an isolated environment either an [[iframe]] where it is constrained to a small rectangular box or a WebWorker where it can’t directly affect the UI at all. [https://hackernoon.com/remote-dom-aka-virtual-virtual-dom-479c6d88de54?utm_source=pocket_mylist hackernoon]"
    },
    {
      "type": "markdown",
      "id": "22f5da760dfa735c",
      "text": "> I wanted more, using multiple iframes makes sites slow, it forces the browser to parse/compile/evaluate the same JavaScript sources multiple times, and makes your UI contained to these small boxes…\n\n> I wanted to be able to write React components, run them without having to trust their code, and have them draw to the same DOM. I found a nice open source library react-worker-dom, and started tinkering with it."
    },
    {
      "type": "paragraph",
      "id": "b1eab0f3b06173f7",
      "text": "React-Worker-DOM is a heavily modified fork of React which consists of two complimentary halves. One where your actual React code resides and where every line that was supposed to touch the DOM was changed so it would eventually postMessage from a WebWorker back to the main frame. The other half, interprets these messages, applies them to the DOM & listens to events sending them back in the opposite direction."
    },
    {
      "type": "paragraph",
      "id": "b51896c6e2465464",
      "text": "The projects’s focus was on the performance benefit of running most of your code inside a different thread via a WebWorker, and it worked beautifully. Although it didn’t support a few features [[Avi Marcus]] needed like a pluggable transport layer and multi-tenancy, these were relatively easy to add, "
    },
    {
      "type": "markdown",
      "id": "c4352c12f5e21198",
      "text": "> and I even went through with the effort of porting the code to newer React 0.14 to get a sense of how hard it was to keep up with newer React versions."
    },
    {
      "type": "paragraph",
      "id": "40c4727cadce0c1e",
      "text": "[…]"
    },
    {
      "type": "markdown",
      "id": "bc2bbb44efa21935",
      "text": "> I found out ages ago that when things are hard it usually means I’m doing it wrong. There had to be a saner way to get the benefits we needed without this ongoing tax on my time & happiness. A lot of software engineering is about learning where to draw the boundary lines between different pieces of the puzzle, what is unique about the task at hand, what should be reused and what should be cast aside.\n\n> I went for a long walk, trying to find alternative ways to solve the problem, and then it hit me. I needed something that is a lot more stable to polyfill or patch, and React was a too fast moving target, I had to remove React from the equation. Which only left the browser DOM API itself, React almost exclusively writes to the DOM without doing any reads, all I had to do was supply a facade that provides the tiny set of browser APIs React expects and I could get all the benefits without modifying a single line of React’s code, thus [[Remote-DOM]] was born."
    },
    {
      "type": "paragraph",
      "id": "f472a8d0c9b4486d",
      "text": "[…] So what can you do with it? Gain performance from removing React from the main UI thread, build a truly distributed ad network that doesn’t need to run any code in the browser except for the remote-dom library and thus can connect fluidly to dozens of ad providers, or maybe just maybe create the next evolutionary step of React - using server side rendering with React is awesome but in the time between HTML loaded and all your client code fully ready you have a dead static website that doesn’t respond to user events, what if we changed it so the server rendered using remote-dom and kept handling user interactions until the client was ready, at which time the client would get a snapshot of the redux store and switch over to handling the events itself… But that is a story for a different post ;)"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Remote-DOM",
        "story": []
      },
      "date": 1652938702298
    },
    {
      "item": {
        "type": "factory",
        "id": "66ef7cd633810823"
      },
      "id": "66ef7cd633810823",
      "type": "add",
      "date": 1652938709325
    },
    {
      "type": "edit",
      "id": "66ef7cd633810823",
      "item": {
        "type": "paragraph",
        "id": "66ef7cd633810823",
        "text": "– [https://hackernoon.com/remote-dom-aka-virtual-virtual-dom-479c6d88de54?utm_source=pocket_mylist hackernoon]"
      },
      "date": 1652938732963
    },
    {
      "type": "edit",
      "id": "66ef7cd633810823",
      "item": {
        "type": "paragraph",
        "id": "66ef7cd633810823",
        "text": "– [https://hackernoon.com/remote-dom-aka-virtual-virtual-dom-479c6d88de54?utm_source=pocket_mylist hackernoon], [https://github.com/wix/remote-dom github]"
      },
      "date": 1652938746179
    },
    {
      "type": "edit",
      "id": "66ef7cd633810823",
      "item": {
        "type": "paragraph",
        "id": "66ef7cd633810823",
        "text": "Trust in the browser is an all or nothing affair, you either run a snippet of JavaScript in the main document on the main UI thread, with access to every global, to any part of the DOM, or you run it in an isolated environment either an iframe where it is constrained to a small rectangular box or a WebWorker where it can’t directly affect the UI at all. [https://hackernoon.com/remote-dom-aka-virtual-virtual-dom-479c6d88de54?utm_source=pocket_mylist hackernoon], [https://github.com/wix/remote-dom github]"
      },
      "date": 1652938791243
    },
    {
      "type": "edit",
      "id": "66ef7cd633810823",
      "item": {
        "type": "paragraph",
        "id": "66ef7cd633810823",
        "text": "Trust in the browser is an all or nothing affair, you either run a snippet of JavaScript in the main document on the main UI thread, with access to every global, to any part of the DOM, or you run it in an isolated environment either an [[iframe]] where it is constrained to a small rectangular box or a WebWorker where it can’t directly affect the UI at all. [https://hackernoon.com/remote-dom-aka-virtual-virtual-dom-479c6d88de54?utm_source=pocket_mylist hackernoon], [https://github.com/wix/remote-dom github]"
      },
      "date": 1652938826469
    },
    {
      "item": {
        "type": "factory",
        "id": "22f5da760dfa735c"
      },
      "id": "22f5da760dfa735c",
      "type": "add",
      "after": "66ef7cd633810823",
      "date": 1652939781043
    },
    {
      "type": "edit",
      "id": "22f5da760dfa735c",
      "item": {
        "type": "markdown",
        "id": "22f5da760dfa735c",
        "text": "> I wanted more, using multiple iframes makes sites slow, it forces the browser to parse/compile/evaluate the same JavaScript sources multiple times, and makes your UI contained to these small boxes…\n\n> I wanted to be able to write React components, run them without having to trust their code, and have them draw to the same DOM. I found a nice open source library react-worker-dom, and started tinkering with it."
      },
      "date": 1652939791983
    },
    {
      "item": {
        "type": "factory",
        "id": "b1eab0f3b06173f7"
      },
      "id": "b1eab0f3b06173f7",
      "type": "add",
      "after": "22f5da760dfa735c",
      "date": 1652939876893
    },
    {
      "type": "edit",
      "id": "b1eab0f3b06173f7",
      "item": {
        "type": "paragraph",
        "id": "b1eab0f3b06173f7",
        "text": "React-Worker-DOM is a heavily modified fork of React which consists of two complimentary halves. One where your actual React code resides and where every line that was supposed to touch the DOM was changed so it would eventually postMessage from a WebWorker back to the main frame. The other half, interprets these messages, applies them to the DOM & listens to events sending them back in the opposite direction."
      },
      "date": 1652939878856
    },
    {
      "item": {
        "type": "factory",
        "id": "b51896c6e2465464"
      },
      "id": "b51896c6e2465464",
      "type": "add",
      "after": "b1eab0f3b06173f7",
      "date": 1652939915116
    },
    {
      "type": "edit",
      "id": "b51896c6e2465464",
      "item": {
        "type": "paragraph",
        "id": "b51896c6e2465464",
        "text": "The projects’s focus was on the performance benefit of running most of your code inside a different thread via a WebWorker, and it worked beautifully. Although it didn’t support a few features I needed like a pluggable transport layer and multi-tenancy, these were relatively easy to add, and I even went through with the effort of porting the code to newer React 0.14 to get a sense of how hard it was to keep up with newer React versions."
      },
      "date": 1652939916997
    },
    {
      "type": "edit",
      "id": "b51896c6e2465464",
      "item": {
        "type": "paragraph",
        "id": "b51896c6e2465464",
        "text": "The projects’s focus was on the performance benefit of running most of your code inside a different thread via a WebWorker, and it worked beautifully. Although it didn’t support a few features Avi Marcus needed like a pluggable transport layer and multi-tenancy, these were relatively easy to add, and I even went through with the effort of porting the code to newer React 0.14 to get a sense of how hard it was to keep up with newer React versions."
      },
      "date": 1652939983570
    },
    {
      "type": "edit",
      "id": "b51896c6e2465464",
      "item": {
        "type": "paragraph",
        "id": "b51896c6e2465464",
        "text": "The projects’s focus was on the performance benefit of running most of your code inside a different thread via a WebWorker, and it worked beautifully. Although it didn’t support a few features [[Avi Marcus]] needed like a pluggable transport layer and multi-tenancy, these were relatively easy to add, and I even went through with the effort of porting the code to newer React 0.14 to get a sense of how hard it was to keep up with newer React versions."
      },
      "date": 1652939999233
    },
    {
      "type": "edit",
      "id": "b51896c6e2465464",
      "item": {
        "type": "paragraph",
        "id": "b51896c6e2465464",
        "text": "The projects’s focus was on the performance benefit of running most of your code inside a different thread via a WebWorker, and it worked beautifully. Although it didn’t support a few features [[Avi Marcus]] needed like a pluggable transport layer and multi-tenancy, these were relatively easy to add, "
      },
      "date": 1652940370608
    },
    {
      "type": "add",
      "id": "c4352c12f5e21198",
      "item": {
        "type": "paragraph",
        "id": "c4352c12f5e21198",
        "text": "> and I even went through with the effort of porting the code to newer React 0.14 to get a sense of how hard it was to keep up with newer React versions."
      },
      "after": "b51896c6e2465464",
      "date": 1652940371341
    },
    {
      "type": "edit",
      "id": "c4352c12f5e21198",
      "item": {
        "type": "markdown",
        "id": "c4352c12f5e21198",
        "text": "> and I even went through with the effort of porting the code to newer React 0.14 to get a sense of how hard it was to keep up with newer React versions."
      },
      "date": 1652940372646
    },
    {
      "item": {
        "type": "factory",
        "id": "40c4727cadce0c1e"
      },
      "id": "40c4727cadce0c1e",
      "type": "add",
      "after": "c4352c12f5e21198",
      "date": 1652940413783
    },
    {
      "type": "edit",
      "id": "40c4727cadce0c1e",
      "item": {
        "type": "paragraph",
        "id": "40c4727cadce0c1e",
        "text": "[…]"
      },
      "date": 1652940417434
    },
    {
      "item": {
        "type": "factory",
        "id": "bc2bbb44efa21935"
      },
      "id": "bc2bbb44efa21935",
      "type": "add",
      "after": "40c4727cadce0c1e",
      "date": 1652940419078
    },
    {
      "type": "edit",
      "id": "bc2bbb44efa21935",
      "item": {
        "type": "markdown",
        "id": "bc2bbb44efa21935",
        "text": "> I found out ages ago that when things are hard it usually means I’m doing it wrong. There had to be a saner way to get the benefits we needed without this ongoing tax on my time & happiness. A lot of software engineering is about learning where to draw the boundary lines between different pieces of the puzzle, what is unique about the task at hand, what should be reused and what should be cast aside.\n\n> I went for a long walk, trying to find alternative ways to solve the problem, and then it hit me. I needed something that is a lot more stable to polyfill or patch, and React was a too fast moving target, I had to remove React from the equation. Which only left the browser DOM API itself, React almost exclusively writes to the DOM without doing any reads, all I had to do was supply a facade that provides the tiny set of browser APIs React expects and I could get all the benefits without modifying a single line of React’s code, thus Remote-DOM was born."
      },
      "date": 1652940428593
    },
    {
      "type": "edit",
      "id": "bc2bbb44efa21935",
      "item": {
        "type": "markdown",
        "id": "bc2bbb44efa21935",
        "text": "> I found out ages ago that when things are hard it usually means I’m doing it wrong. There had to be a saner way to get the benefits we needed without this ongoing tax on my time & happiness. A lot of software engineering is about learning where to draw the boundary lines between different pieces of the puzzle, what is unique about the task at hand, what should be reused and what should be cast aside.\n\n> I went for a long walk, trying to find alternative ways to solve the problem, and then it hit me. I needed something that is a lot more stable to polyfill or patch, and React was a too fast moving target, I had to remove React from the equation. Which only left the browser DOM API itself, React almost exclusively writes to the DOM without doing any reads, all I had to do was supply a facade that provides the tiny set of browser APIs React expects and I could get all the benefits without modifying a single line of React’s code, thus [[Remote-DOM]] was born."
      },
      "date": 1652940452742
    },
    {
      "type": "edit",
      "id": "66ef7cd633810823",
      "item": {
        "type": "paragraph",
        "id": "66ef7cd633810823",
        "text": "Remote-DOM is a tiny library with less than 1k lines of code, with two halves remote and local. The remote half, supplies a browser facade, a virtual window and document, to other libraries letting them use the APIs they know and expect the browser to supply like: document.createElement window.addEventListener and so on, without having any actual DOM, and sends these commands back as JSONs to the local half. The local half of the library interprets that JSON and does the real creating of DOM nodes and adding event listeners, and when an event happens it send it’s information back to the remote side as JSON, all you need to do to connect them is give them a way to communicate between them."
      },
      "date": 1652940493804
    },
    {
      "type": "add",
      "id": "b9f4b0c6124696dd",
      "item": {
        "type": "paragraph",
        "id": "b9f4b0c6124696dd",
        "text": "Trust in the browser is an all or nothing affair, you either run a snippet of JavaScript in the main document on the main UI thread, with access to every global, to any part of the DOM, or you run it in an isolated environment either an [[iframe]] where it is constrained to a small rectangular box or a WebWorker where it can’t directly affect the UI at all. [https://hackernoon.com/remote-dom-aka-virtual-virtual-dom-479c6d88de54?utm_source=pocket_mylist hackernoon], [https://github.com/wix/remote-dom github]"
      },
      "after": "66ef7cd633810823",
      "date": 1652940494546
    },
    {
      "item": {
        "type": "factory",
        "id": "f472a8d0c9b4486d"
      },
      "id": "f472a8d0c9b4486d",
      "type": "add",
      "after": "bc2bbb44efa21935",
      "date": 1652940590755
    },
    {
      "type": "edit",
      "id": "f472a8d0c9b4486d",
      "item": {
        "type": "paragraph",
        "id": "f472a8d0c9b4486d",
        "text": "[…] So what can you do with it? Gain performance from removing React from the main UI thread, build a truly distributed ad network that doesn’t need to run any code in the browser except for the remote-dom libary and thus can connect fluidly to dozens of ad providers, or maybe just maybe create the next evolutionary step of React - using server side rendering with React is awesome but in the time between HTML loaded and all your client code fully ready you have a dead static website that doesn’t respond to user events, what if we changed it so the server rendered using remote-dom and kept handling user interactions until the client was ready, at which time the client would get a snapshot of the redux store and switch over to handling the events itself… But that is a story for a different post ;)"
      },
      "date": 1652940597288
    },
    {
      "type": "edit",
      "id": "f472a8d0c9b4486d",
      "item": {
        "type": "paragraph",
        "id": "f472a8d0c9b4486d",
        "text": "[…] So what can you do with it? Gain performance from removing React from the main UI thread, build a truly distributed ad network that doesn’t need to run any code in the browser except for the remote-dom library and thus can connect fluidly to dozens of ad providers, or maybe just maybe create the next evolutionary step of React - using server side rendering with React is awesome but in the time between HTML loaded and all your client code fully ready you have a dead static website that doesn’t respond to user events, what if we changed it so the server rendered using remote-dom and kept handling user interactions until the client was ready, at which time the client would get a snapshot of the redux store and switch over to handling the events itself… But that is a story for a different post ;)"
      },
      "date": 1652940623024
    },
    {
      "type": "edit",
      "id": "b9f4b0c6124696dd",
      "item": {
        "type": "paragraph",
        "id": "b9f4b0c6124696dd",
        "text": "Trust in the browser is an all or nothing affair, you either run a snippet of JavaScript in the main document on the main UI thread, with access to every global, to any part of the DOM, or you run it in an isolated environment either an [[iframe]] where it is constrained to a small rectangular box or a WebWorker where it can’t directly affect the UI at all. [https://hackernoon.com/remote-dom-aka-virtual-virtual-dom-479c6d88de54?utm_source=pocket_mylist hackernoon]"
      },
      "date": 1652942207028
    },
    {
      "type": "edit",
      "id": "66ef7cd633810823",
      "item": {
        "type": "paragraph",
        "id": "66ef7cd633810823",
        "text": "Remote-DOM is a tiny library with less than 1k lines of code, with two halves remote and local. [https://github.com/wix/remote-dom github] The remote half, supplies a browser facade, a virtual window and document, to other libraries letting them use the APIs they know and expect the browser to supply like: document.createElement window.addEventListener and so on, without having any actual DOM, and sends these commands back as JSONs to the local half. The local half of the library interprets that JSON and does the real creating of DOM nodes and adding event listeners, and when an event happens it send it’s information back to the remote side as JSON, all you need to do to connect them is give them a way to communicate between them."
      },
      "date": 1652942215053
    },
    {
      "type": "edit",
      "id": "66ef7cd633810823",
      "item": {
        "type": "paragraph",
        "id": "66ef7cd633810823",
        "text": "Remote-DOM is a tiny library with less than 1k lines of code, with two halves remote and local. The remote half, supplies a [[browser facade]], a virtual window and document, to other libraries letting them use the APIs they know and expect the browser to supply like: document.createElement window.addEventListener and so on, without having any actual DOM, and sends these commands back as JSONs to the local half. The local half of the library interprets that JSON and does the real creating of DOM nodes and adding event listeners, and when an event happens it send it’s information back to the remote side as JSON, all you need to do to connect them is give them a way to communicate between them."
      },
      "date": 1652942394066
    }
  ]
}