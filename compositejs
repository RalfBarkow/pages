{
  "title": "composite.js",
  "story": [
    {
      "type": "code",
      "id": "ccb1bc1266fa311b",
      "text": "// aggregate multiple graphs into a single graph\n\nimport {Graph} from './graph.js'\n\nconst uniq = (value, index, self) => self.indexOf(value) === index\n\nexport function composite(concepts) {\n  const merged = {nids:[]}\n  const comp = new Graph()\n  for (const concept of concepts) {\n    const {name,graph} = concept\n    merge(comp,graph,name)\n  }\n  return {graph:comp, merged}\n\n\n  function merge(comp,incr,source) {\n\n    function mergeprops(into,from) {\n      const keys = Object.keys(into)\n        .concat(Object.keys(from))\n        .filter(uniq)\n      for (const key of keys) {\n        if (into[key]) {\n          // if (from[key] && into[key] != from[key]) {\n          //   window.result.innerHTML +=\n          //     `<div style=\"font-size:small; padding:4px; background-color:#fee; border-radius:4px; border:1px solid #aaa;\">\n          //       conflict for \"${key}\" property<br>\n          //       choosing \"${into[key]}\" over \"${from[key]}\"</div>`\n          // }\n        }\n        else {\n          if(from[key]) {\n            into[key] = from[key]\n          }\n        }\n      }\n    }\n\n    const nids = {}  // incr => comp\n    incr.nodes.forEach((node,id) => {\n      const match = comp.nodes.find(each =>\n        each.type == node.type &&\n        each.props.name == node.props.name)\n      if(match) {\n        // window.result.innerHTML += `Same <b>${match.type}</b> ${match.props.name}<br>`\n        nids[id] = comp.nodes.findIndex(node => node === match)\n        merged.nids.push(nids[id])\n        mergeprops(match.props, node.props)\n      } else {\n        nids[id] = comp.addNode(node.type,node.props)\n      }\n    })\n    incr.rels.forEach(rel => {\n      const match = comp.rels.find(each =>\n        each.type == rel.type &&\n        each.from == nids[rel.from] &&\n        each.to == nids[rel.to]\n      )\n      if(match) {\n        // window.result.innerHTML += `Same\n        //   <b>${comp.nodes[match.from].type}</b> ${comp.nodes[match.from].props.name}\n        //   <b>${match.type}</b> ▷\n        //   ${comp.nodes[match.to].type} ${comp.nodes[match.to].props.name}<br>`\n        mergeprops(match.props, rel.props)\n      } else {\n        rel.props.source = source\n        comp.addRel(rel.type, nids[rel.from], nids[rel.to], rel.props)\n      }\n    })\n  }\n}\n"
    },
    {
      "type": "assets",
      "id": "168506e0be530467",
      "text": "home"
    },
    {
      "type": "paragraph",
      "id": "0eef1957e12af625",
      "text": "⇒ [[dotify.js]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "composite.js",
        "story": []
      },
      "date": 1667222752635
    },
    {
      "item": {
        "type": "factory",
        "id": "168506e0be530467"
      },
      "id": "168506e0be530467",
      "type": "add",
      "date": 1667222754044
    },
    {
      "type": "edit",
      "id": "168506e0be530467",
      "item": {
        "type": "assets",
        "id": "168506e0be530467",
        "text": "⇒"
      },
      "date": 1667222759493
    },
    {
      "type": "edit",
      "id": "168506e0be530467",
      "item": {
        "type": "assets",
        "id": "168506e0be530467",
        "text": "home"
      },
      "date": 1667222766924
    },
    {
      "item": {
        "type": "factory",
        "id": "ccb1bc1266fa311b"
      },
      "id": "ccb1bc1266fa311b",
      "type": "add",
      "after": "168506e0be530467",
      "date": 1667222776529
    },
    {
      "type": "edit",
      "id": "ccb1bc1266fa311b",
      "item": {
        "type": "code",
        "id": "ccb1bc1266fa311b",
        "text": "// aggregate multiple graphs into a single graph\n\nimport {Graph} from './graph.js'\n\nconst uniq = (value, index, self) => self.indexOf(value) === index\n\nexport function composite(concepts) {\n  const merged = {nids:[]}\n  const comp = new Graph()\n  for (const concept of concepts) {\n    const {name,graph} = concept\n    merge(comp,graph,name)\n  }\n  return {graph:comp, merged}\n\n\n  function merge(comp,incr,source) {\n\n    function mergeprops(into,from) {\n      const keys = Object.keys(into)\n        .concat(Object.keys(from))\n        .filter(uniq)\n      for (const key of keys) {\n        if (into[key]) {\n          // if (from[key] && into[key] != from[key]) {\n          //   window.result.innerHTML +=\n          //     `<div style=\"font-size:small; padding:4px; background-color:#fee; border-radius:4px; border:1px solid #aaa;\">\n          //       conflict for \"${key}\" property<br>\n          //       choosing \"${into[key]}\" over \"${from[key]}\"</div>`\n          // }\n        }\n        else {\n          if(from[key]) {\n            into[key] = from[key]\n          }\n        }\n      }\n    }\n\n    const nids = {}  // incr => comp\n    incr.nodes.forEach((node,id) => {\n      const match = comp.nodes.find(each =>\n        each.type == node.type &&\n        each.props.name == node.props.name)\n      if(match) {\n        // window.result.innerHTML += `Same <b>${match.type}</b> ${match.props.name}<br>`\n        nids[id] = comp.nodes.findIndex(node => node === match)\n        merged.nids.push(nids[id])\n        mergeprops(match.props, node.props)\n      } else {\n        nids[id] = comp.addNode(node.type,node.props)\n      }\n    })\n    incr.rels.forEach(rel => {\n      const match = comp.rels.find(each =>\n        each.type == rel.type &&\n        each.from == nids[rel.from] &&\n        each.to == nids[rel.to]\n      )\n      if(match) {\n        // window.result.innerHTML += `Same\n        //   <b>${comp.nodes[match.from].type}</b> ${comp.nodes[match.from].props.name}\n        //   <b>${match.type}</b> ▷\n        //   ${comp.nodes[match.to].type} ${comp.nodes[match.to].props.name}<br>`\n        mergeprops(match.props, rel.props)\n      } else {\n        rel.props.source = source\n        comp.addRel(rel.type, nids[rel.from], nids[rel.to], rel.props)\n      }\n    })\n  }\n}\n"
      },
      "date": 1667222778761
    },
    {
      "id": "168506e0be530467",
      "type": "move",
      "order": [
        "ccb1bc1266fa311b",
        "168506e0be530467"
      ],
      "date": 1667222795771
    },
    {
      "item": {
        "type": "factory",
        "id": "0eef1957e12af625"
      },
      "id": "0eef1957e12af625",
      "type": "add",
      "after": "168506e0be530467",
      "date": 1667222813076
    },
    {
      "type": "edit",
      "id": "0eef1957e12af625",
      "item": {
        "type": "paragraph",
        "id": "0eef1957e12af625",
        "text": "⇒ [[dotify.js]]"
      },
      "date": 1667222814762
    }
  ]
}