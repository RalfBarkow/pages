{
  "title": "Ian Piumarta",
  "story": [
    {
      "type": "markdown",
      "id": "80780fba07967bcd",
      "text": "Recursive-descent parser generators for C, peg/leg [https://www.piumarta.com/software/peg/ site]\n"
    },
    {
      "type": "markdown",
      "id": "c170768efb861e61",
      "text": "peg and leg are tools for generating recursive-descent parsers: programs that perform pattern matching on text. They processes a Parsing Expression Grammar ([[PEG]]) [Ford 2004] to produce a program that recognises legal sentences of that grammar. peg processes PEGs written using the original syntax described by Ford; leg processes PEGs written using slightly different syntax and conventions that are intended to make it an attractive replacement for parsers built with lex and yacc. Unlike lex and yacc, peg and leg [[support]] unlimited backtracking, provide ordered choice as a means for disambiguation, and can combine scanning (lexical analysis) and parsing (syntactic analysis) into a single activity. "
    },
    {
      "type": "paragraph",
      "id": "5aefadd357a8beb6",
      "text": "PEG-based transformer provides front-, middle\nand back-end stages in a simple compiler. [https://www.vpri.org/pdf/tr2010003_PEG.pdf pdf]"
    },
    {
      "type": "markdown",
      "id": "a0de8a1526b8ea36",
      "text": "> Traditional compiler generators target a single stage within the compilation process. Each generator typically uses a dedicated specification language and the generated code often imposes restrictions on the program representation accepted as input or generated as output. This makes compilers larger and more complex than they need to be. We present a simple compiler that unifies specification and implementation of all its stages, using PEG-based transformations on a single, versatile representation. The resulting compiler is small, easy to understand, and highly suited to implementing its own implementation language."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Ian Piumarta",
        "story": []
      },
      "date": 1639141650475
    },
    {
      "item": {
        "type": "factory",
        "id": "80780fba07967bcd"
      },
      "id": "80780fba07967bcd",
      "type": "add",
      "date": 1639141708712
    },
    {
      "type": "edit",
      "id": "80780fba07967bcd",
      "item": {
        "type": "paragraph",
        "id": "80780fba07967bcd",
        "text": "https://www.piumarta.com/software/peg/"
      },
      "date": 1639141710023
    },
    {
      "type": "edit",
      "id": "80780fba07967bcd",
      "item": {
        "type": "markdown",
        "id": "80780fba07967bcd",
        "text": "https://www.piumarta.com/software/peg/"
      },
      "date": 1639141713737
    },
    {
      "type": "edit",
      "id": "80780fba07967bcd",
      "item": {
        "type": "markdown",
        "id": "80780fba07967bcd",
        "text": "peg/leg — recursive-descent parser generators for C. [https://www.piumarta.com/software/peg/ page]"
      },
      "date": 1639141736830
    },
    {
      "type": "edit",
      "id": "80780fba07967bcd",
      "item": {
        "type": "markdown",
        "id": "80780fba07967bcd",
        "text": "peg/leg [https://www.piumarta.com/software/peg/ page] — recursive-descent parser generators for C. "
      },
      "date": 1639141749601
    },
    {
      "type": "edit",
      "id": "80780fba07967bcd",
      "item": {
        "type": "markdown",
        "id": "80780fba07967bcd",
        "text": "peg/leg [https://www.piumarta.com/software/peg/ page] — recursive-descent parser generators for C"
      },
      "date": 1639141760439
    },
    {
      "item": {
        "type": "factory",
        "id": "5aefadd357a8beb6"
      },
      "id": "5aefadd357a8beb6",
      "type": "add",
      "after": "80780fba07967bcd",
      "date": 1639141899039
    },
    {
      "type": "edit",
      "id": "5aefadd357a8beb6",
      "item": {
        "type": "paragraph",
        "id": "5aefadd357a8beb6",
        "text": "PEG-based transformer provides front-, middle\nand back-end stages in a simple compiler"
      },
      "date": 1639141907532
    },
    {
      "type": "edit",
      "id": "5aefadd357a8beb6",
      "item": {
        "type": "paragraph",
        "id": "5aefadd357a8beb6",
        "text": "PEG-based transformer provides front-, middle\nand back-end stages in a simple compiler. [https://www.vpri.org/pdf/tr2010003_PEG.pdf pdf]"
      },
      "date": 1639141918233
    },
    {
      "type": "add",
      "id": "a0de8a1526b8ea36",
      "item": {
        "type": "paragraph",
        "id": "a0de8a1526b8ea36",
        "text": "> Traditional compiler generators target a single stage within the\ncompilation process. Each generator typically uses a dedicated spec-\nification language and the generated code often imposes restrictions\non the program representation accepted as input or generated as\noutput. This makes compilers larger and more complex than they\nneed to be. We present a simple compiler that unifies specification\nand implementation of all its stages, using PEG-based transforma-\ntions on a single, versatile representation. The resulting compiler\nis small, easy to understand, and highly suited to implementing its\nown implementation language."
      },
      "after": "5aefadd357a8beb6",
      "date": 1639141947890
    },
    {
      "type": "edit",
      "id": "a0de8a1526b8ea36",
      "item": {
        "type": "markdown",
        "id": "a0de8a1526b8ea36",
        "text": "> Traditional compiler generators target a single stage within the\ncompilation process. Each generator typically uses a dedicated spec-\nification language and the generated code often imposes restrictions\non the program representation accepted as input or generated as\noutput. This makes compilers larger and more complex than they\nneed to be. We present a simple compiler that unifies specification\nand implementation of all its stages, using PEG-based transforma-\ntions on a single, versatile representation. The resulting compiler\nis small, easy to understand, and highly suited to implementing its\nown implementation language."
      },
      "date": 1639141949179
    },
    {
      "type": "edit",
      "id": "a0de8a1526b8ea36",
      "item": {
        "type": "markdown",
        "id": "a0de8a1526b8ea36",
        "text": "> Traditional compiler generators target a single stage within the compilation process. Each generator typically uses a dedicated spec-\nification language and the generated code often imposes restrictions\non the program representation accepted as input or generated as\noutput. This makes compilers larger and more complex than they\nneed to be. We present a simple compiler that unifies specification\nand implementation of all its stages, using PEG-based transforma-\ntions on a single, versatile representation. The resulting compiler\nis small, easy to understand, and highly suited to implementing its\nown implementation language."
      },
      "date": 1639141954961
    },
    {
      "type": "edit",
      "id": "a0de8a1526b8ea36",
      "item": {
        "type": "markdown",
        "id": "a0de8a1526b8ea36",
        "text": "> Traditional compiler generators target a single stage within the compilation process. Each generator typically uses a dedicated specification language and the generated code often imposes restrictions on the program representation accepted as input or generated as output. This makes compilers larger and more complex than they need to be. We present a simple compiler that unifies specification and implementation of all its stages, using PEG-based transformations on a single, versatile representation. The resulting compiler is small, easy to understand, and highly suited to implementing its own implementation language."
      },
      "date": 1639141990646
    },
    {
      "type": "edit",
      "id": "80780fba07967bcd",
      "item": {
        "type": "markdown",
        "id": "80780fba07967bcd",
        "text": "peg/leg [https://www.piumarta.com/software/peg/ site] — recursive-descent parser generators for C"
      },
      "date": 1639142132672
    },
    {
      "type": "edit",
      "id": "80780fba07967bcd",
      "item": {
        "type": "markdown",
        "id": "80780fba07967bcd",
        "text": "peg/leg [https://www.piumarta.com/software/peg/ site] — recursive-descent parser generators for C\n"
      },
      "date": 1651135115121
    },
    {
      "type": "add",
      "id": "c170768efb861e61",
      "item": {
        "type": "markdown",
        "id": "c170768efb861e61",
        "text": "peg and leg are tools for generating recursive-descent parsers: programs that perform pattern matching on text. They processes a Parsing Expression Grammar (PEG) [Ford 2004] to produce a program that recognises legal sentences of that grammar. peg processes PEGs written using the original syntax described by Ford; leg processes PEGs written using slightly different syntax and conventions that are intended to make it an attractive replacement for parsers built with lex and yacc. Unlike lex and yacc, peg and leg support unlimited backtracking, provide ordered choice as a means for disambiguation, and can combine scanning (lexical analysis) and parsing (syntactic analysis) into a single activity. "
      },
      "after": "80780fba07967bcd",
      "date": 1651135115810
    },
    {
      "type": "edit",
      "id": "80780fba07967bcd",
      "item": {
        "type": "markdown",
        "id": "80780fba07967bcd",
        "text": "Recursive-descent parser generators for C,\npeg/leg [https://www.piumarta.com/software/peg/ site]\n"
      },
      "date": 1652353636887
    },
    {
      "type": "edit",
      "id": "80780fba07967bcd",
      "item": {
        "type": "markdown",
        "id": "80780fba07967bcd",
        "text": "Recursive-descent parser generators for C, peg/leg [https://www.piumarta.com/software/peg/ site]\n"
      },
      "date": 1652353643759
    },
    {
      "type": "edit",
      "id": "c170768efb861e61",
      "item": {
        "type": "markdown",
        "id": "c170768efb861e61",
        "text": "peg and leg are tools for generating recursive-descent parsers: programs that perform pattern matching on text. They processes a Parsing Expression Grammar ([[PEG]]) [Ford 2004] to produce a program that recognises legal sentences of that grammar. peg processes PEGs written using the original syntax described by Ford; leg processes PEGs written using slightly different syntax and conventions that are intended to make it an attractive replacement for parsers built with lex and yacc. Unlike lex and yacc, peg and leg support unlimited backtracking, provide ordered choice as a means for disambiguation, and can combine scanning (lexical analysis) and parsing (syntactic analysis) into a single activity. "
      },
      "date": 1652353664471
    },
    {
      "type": "edit",
      "id": "c170768efb861e61",
      "item": {
        "type": "markdown",
        "id": "c170768efb861e61",
        "text": "peg and leg are tools for generating recursive-descent parsers: programs that perform pattern matching on text. They processes a Parsing Expression Grammar ([[PEG]]) [Ford 2004] to produce a program that recognises legal sentences of that grammar. peg processes PEGs written using the original syntax described by Ford; leg processes PEGs written using slightly different syntax and conventions that are intended to make it an attractive replacement for parsers built with lex and yacc. Unlike lex and yacc, peg and leg [[support]] unlimited backtracking, provide ordered choice as a means for disambiguation, and can combine scanning (lexical analysis) and parsing (syntactic analysis) into a single activity. "
      },
      "date": 1662095069052
    }
  ]
}