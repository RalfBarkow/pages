{
  "title": "Polysynchronous Stochastic Circuits",
  "story": [
    {
      "type": "paragraph",
      "id": "74bddb9d90430d71",
      "text": "Clock distribution networks (CDNs) are costly in high-performance ASICs. This paper proposes a new approach: splitting clock domains at a very fine level, down to the level of a handful of gates. Each domain is synchronized with an inexpensive clock signal, generated locally. This is possible by adopting the paradigm of [[Stochastic Computation]], where signal values are encoded as random bit streams. The design method is illustrated with the synthesis of circuits for applications in signal and image processing."
    },
    {
      "type": "pagefold",
      "id": "ae22cf8607150449",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "7ad6a6613a9ba9ca",
      "text": "NAJAFI, M. Hassan, LILJA, David J., RIEDEL, Marc and BAZARGAN, Kia, 2016. Polysynchronous stochastic circuits. In: 2016 21st Asia and South Pacific Design Automation Conference (ASP-DAC). IEEE. 2016. p. 492–498. [https://ieeexplore.ieee.org/abstract/document/7428060/ ieee] [Accessed 23 February 2024]. \n"
    },
    {
      "type": "paragraph",
      "id": "46719a54c4822064",
      "text": "All electronic systems are inherently [[asynchronous]] in nature. By carefully choreographing transitions with clock signals, asynchronous circuitry can be adapted to appear to behave synchronously. Such synchronism brings significant advantages: it greatly simplifies the design effort; also, with predictable timing, one can make performance guarantees. However, synchronism comes at a significant cost: one must create a clock distribution network (CDN) that supplies a common reference signal to all synchronous components. Historically, the primary design goal for CDNs has been to ensure that a single clock signal arrives at every synchronous component at precisely the same time (so there is zero clock skew). Achieving this is difficult and costly in terms of design effort and resources. In modern large-scale integrated circuits, the CDN accounts for significant area, consumes significant power, and often limits the overall circuit performance [1][2]. With increasing variation in circuit parameters, designing CDNs with tolerable clock skew is becoming a major design bottleneck."
    },
    {
      "type": "paragraph",
      "id": "e4881b072a220193",
      "text": "[1] E.G. Friedman. Clock distribution networks in synchronous digital integrated circuits. Proceedings of the IEEE, 89(5):665692, May 2001."
    },
    {
      "type": "paragraph",
      "id": "4294912acf6b9d74",
      "text": "[2] Y. Jiang, H. Zhang, H. Zhang, H. Liu, X. Song, M. Gu, and J. Sun. Design of mixed synchronous/asynchronous systems with multiple clocks. Parallel and Distributed Systems, IEEE Transactions on, PP(99):1–1, 2014."
    },
    {
      "type": "paragraph",
      "id": "7b1cd9b77822bfe6",
      "text": "Completely asynchronous design methodologies have been studied for decades, but these have never gained widespread acceptance (in spite of strong advocacy by proponents). Circuits with multiple independent clock domains – so circuits that are globally asynchronous, but locally synchronous (GALS) – have become common [3]. Splitting the domains reduces the cost of the distribution network, but relatively complex circuitry for handshaking is needed at domain crossings, so the splitting is only performed at a coarse level."
    },
    {
      "type": "paragraph",
      "id": "d16dfd5cbe71fd28",
      "text": "[3] D. Chapiro. Globally-asynchronous locally-synchronous systems. Stanford University, 1984. [https://apps.dtic.mil/sti/tr/pdf/ADA154624.pdf pdf]"
    },
    {
      "type": "paragraph",
      "id": "70f9028e83c76377",
      "text": "This paper proposes a radically new approach: splitting clock domains at a very fine level, with domains consisting of only a handful of gates each. Each domain is synchronized by an inexpensive clock signal, generated locally. This is feasible if one adopts a stochastic representation for signal values [4, 5, 6, 7, 8, 9]. Logical computation is performed on randomized bit streams, with signal values encoded in the statistics of the streams: a real value x in the interval [0, 1] is represented by a stream with bits each having independent probability x of being 1."
    },
    {
      "type": "paragraph",
      "id": "da3d47099abfec94",
      "text": "[4] B.R. Gaines. Stochastic computing systems. In JuliusT. Tou, editor, Advances in Information Systems Science, Advances in Information Systems Science, pages 37–172. Springer US, 1969."
    },
    {
      "type": "paragraph",
      "id": "26934441e5524b70",
      "text": "[5] W. Qian and M.D. Riedel. The synthesis of robust polynomial arithmetic with stochastic logic. In 45th ACM/IEEE Design Automation Conference, DAC’08, pages 648–653, 2008."
    },
    {
      "type": "paragraph",
      "id": "4dea707cb9242ec2",
      "text": "[6] Weikang Qian, Xin Li, M.D. Riedel, K. Bazargan, and D.J. Lilja. An architecture for fault-tolerant computation with stochastic logic. Computers, IEEE Transactions on, 60(1):93105, Jan 2011."
    },
    {
      "type": "paragraph",
      "id": "8576037c9538100e",
      "text": "[7] P. Li, D. J. Lilja, W. Qian, K. Bazargan, and M. Riedel. The synthesis of complex arithmetic computation on stochastic bit streams using sequential logic. In Computer-Aided Design, 2012. ICCAD 2012. IEEE/ACM International Conference on. IEEE, 2012."
    },
    {
      "type": "paragraph",
      "id": "ade8fe6742eaaffc",
      "text": "[8] Peng Li, D.J. Lilja, Weikang Qian, K. Bazargan, and M.D. Riedel. Computation on stochastic bit streams digital image processing case studies. Very Large Scale Integration (VLSI) Systems, IEEE Transactions on, 22(3):449–462, March 2014."
    },
    {
      "type": "paragraph",
      "id": "e67384dddb94476e",
      "text": "[9] Armin Alaghi and John P. Hayes. Survey of stochastic computing. ACM Trans. Embed. Comput. Syst., 12(2s):92:1–92:19, May 2013."
    },
    {
      "type": "paragraph",
      "id": "40bc441a9bd9408e",
      "text": "Compared to a binary radix representation, such a stochastic representation is not very compact. With M bits, a binary radix representation can represent 2^M distinct numbers. To represent real numbers with a resolution of 2^−M , i.e., numbers of the form a/2^M for integers a between 0 and 2^M , a stochastic representation requires a stream of 2^M bits. The two representations are at opposite ends of the spectrum: conventional binary radix is a maximally compressed, positional encoding; a stochastic representation is an uncompressed, uniform encoding."
    },
    {
      "type": "pagefold",
      "id": "d2da8b670ab9e86f",
      "text": "~"
    },
    {
      "type": "reference",
      "id": "7abbaa5b6319488f",
      "site": "wiki.ralfbarkow.ch",
      "slug": "0000000010",
      "title": "0000000010…",
      "text": "How to achieve persistence of a 2D coordinate system representing connexions? This post explains it in a bottom-up approach. [https://ralfbarkow.wordpress.com/2006/11/29/0000000010/#more-141 post]"
    },
    {
      "type": "reference",
      "id": "ac080f0ea5f186e1",
      "site": "wiki.ralfbarkow.ch",
      "slug": "an-other-space",
      "title": "An Other Space",
      "text": "A visual proof of the existence on an anti-symmetric complementary space S* of gaps (an other space) within the traditional mathematical continuum X=[0,1]."
    },
    {
      "type": "pagefold",
      "id": "646261a1eea963f0",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "fccac7a025601ac9",
      "text": "A stochastic representation, although not very compact, has an advantage over binary radix in terms of error tolerance. Suppose that the environment is noisy: bit flips occur and these afflict all the bits with equal probability. With a binary radix representation, in the worst case, the most significant bit gets flipped, resulting in a large error. In contrast, with a stochastic representation, all the bits in the stream have equal weight. A single flip results in a small error. This error tolerance scales to high error rates: multiple bit flips produce small and uniform deviations from the nominal value. More compelling than the error tolerance is the simplicity of the designs in the stochastic paradigm. Complex functions can be implemented with remarkably simple logic. A reduction in area of 50x or 100x compared to conventional implementations is common [8][10]."
    },
    {
      "type": "paragraph",
      "id": "8953deabf50aae43",
      "text": "[8] Peng Li, D.J. Lilja, Weikang Qian, K. Bazargan, and M.D. Riedel. Computation on stochastic bit streams digital image processing case studies. Very Large Scale Integration (VLSI) Systems, IEEE Transactions on, 22(3):449–462, March 2014."
    },
    {
      "type": "paragraph",
      "id": "2eb9c0fa6c2c78da",
      "text": "[10] A. Alaghi and J.P. Hayes. Fast and accurate computation using stochastic circuits. In Design, Automation and Test in Europe Conference and Exhibition (DATE), 2014, pages 1–4, March 2014."
    },
    {
      "type": "paragraph",
      "id": "0f5f716ec82be777",
      "text": "A more compelling advantage still of the stochastic paradigm could be the idea advocated in this paper. With a stochastic representation, computational units can tolerate skew in the arrival time of their inputs. This stems from the fact that the stochastic representation is uniform: all that matters in terms of the value that is computed is the fraction of time that the signal is high. We will demonstrate that the correct value is computed even when the inputs are misaligned temporally. Accordingly, adopting the stochastic paradigm obviates the need for a global clock signal and the associated CDN. Instead one can simply use local clock signal generators throughout."
    },
    {
      "type": "pagefold",
      "id": "51ef7cc4d8b8e7dc",
      "text": "1–2"
    },
    {
      "type": "paragraph",
      "id": "30dbd480d415353c",
      "text": "We call this approach [[polysynchronous stochastic]] (to distinguish it from asynchronous and GALS methodologies)."
    },
    {
      "type": "paragraph",
      "id": "593831328e29921c",
      "text": "The paper is structured as follows. In Section II, we provide some background on stochastic computing. In Section III, we introduce polysynchronous stochastic concepts and demonstrate how to implement basic operations. In Section IV, we describe our experimental methodology and present experimental results. Finally, in Section V, we present conclusions and discuss future work."
    },
    {
      "type": "paragraph",
      "id": "ee990f95ac827148",
      "text": "BACKGROUND"
    },
    {
      "type": "paragraph",
      "id": "bfd71dbe9bd58195",
      "text": "In the paradigm of [[Stochastic Computing]] (SC), circuits operate on random bit streams where the signal value is encoded by the probability of obtaining a one versus a zero. In the unipolar stochastic representation, each realvalued number x (0 ≤ x ≤ 1) is represented by a sequence of random bits, each of which has probability x of being one and probability 1 − x of being zero. In the bipolar representation, each real-valued number y (−1 ≤ y ≤ 1) is represented by a sequence of random bits, each of which has probability y+1 2 of being one and probability 1 − y+1 2 of being zero."
    },
    {
      "type": "paragraph",
      "id": "d968f4492b24a7f4",
      "text": "This representation is much less compact than a binary radix. However, complex operations can be performed with very simple logic. In particular, arithmetic functions, consisting of operations like addition and multiplication can be implemented very efficiently. Complex functions, such as exponentials and trigonometric functions, can be computed through polynomial approximations [5, 8]."
    },
    {
      "type": "paragraph",
      "id": "76136ab6e2e64038",
      "text": "[5] W. Qian and M.D. Riedel. The synthesis of robust polynomial arithmetic with stochastic logic. In 45th ACM/IEEE Design Automation Conference, DAC’08, pages 648–653, 2008."
    },
    {
      "type": "paragraph",
      "id": "b10e256f2d5a8e32",
      "text": "[8] Peng Li, D.J. Lilja, Weikang Qian, K. Bazargan, and M.D. Riedel. Computation on stochastic bit streams digital image processing case studies. Very Large Scale Integration (VLSI) Systems, IEEE Transactions on, 22(3):449–462, March 2014."
    },
    {
      "type": "paragraph",
      "id": "c0c27611f1ec6c63",
      "text": "Because the bit stream representation is uniform, with all bits weighted equally, circuits designed this way are highly tolerant of soft errors (i.e., bit flips) [6]."
    },
    {
      "type": "paragraph",
      "id": "52b8b2542ba8508f",
      "text": "[6] Weikang Qian, Xin Li, M.D. Riedel, K. Bazargan, and D.J. Lilja. An architecture for fault-tolerant computation with stochastic logic. Computers, IEEE Transactions on, 60(1):93105, Jan 2011."
    },
    {
      "type": "paragraph",
      "id": "4a7ad64a1637a291",
      "text": "Critical to the ideas in this paper is the observation that the stochastic representation is a uniform fractional representation: all that matters is the fraction of time that the signal is high. Consequently, precise synchronization between the arrival time of input values to logic gates does not matter. This is illustrated in the next section."
    },
    {
      "type": "paragraph",
      "id": "a9e98b9612a94038",
      "text": "[…]"
    },
    {
      "type": "pagefold",
      "id": "2cd351490d4c38dc",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "f3abf18e52e25586",
      "text": "Ward did interesting computation on networks of computers using only one page of assembly language. [http://code.fed.wiki.org/cybords.html page] See [[Cybords]]"
    },
    {
      "type": "markdown",
      "id": "8bf9bdb9c9df3ad0",
      "text": "> These little computers were so inexpensive that I would buy 50 at a time. \n> A message was just an electrical pulse, high or low, repeated stochastically until communication happened a few tenths of a second later. Each part had to interface pins, one sending, the other listening. A computer could listen to multiple senders at the same time and chance would have it [[Hear the Arithmetic Sum]] of both sources."
    },
    {
      "type": "pagefold",
      "id": "8136920c49f672e0",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "95b5cbd82f305baf",
      "text": "⇒ [[Stochastic Operations]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Polysynchronous Stochastic Circuits",
        "story": []
      },
      "date": 1708684236840
    },
    {
      "type": "edit",
      "id": "74bddb9d90430d71",
      "item": {
        "type": "paragraph",
        "id": "74bddb9d90430d71",
        "text": "Clock distribution networks (CDNs) are costly in high-performance ASICs. This paper proposes a new approach: splitting clock domains at a very fine level, down to the level of a handful of gates. Each domain is synchronized with an inexpensive clock signal, generated locally. This is possible by adopting the paradigm of stochastic computation, where signal values are encoded as random bit streams. The design method is illustrated with the synthesis of circuits for applications in signal and image processing."
      },
      "date": 1708684240352
    },
    {
      "item": {
        "type": "factory",
        "id": "ae22cf8607150449"
      },
      "id": "ae22cf8607150449",
      "type": "add",
      "after": "74bddb9d90430d71",
      "date": 1708684258144
    },
    {
      "item": {
        "type": "factory",
        "id": "7ad6a6613a9ba9ca"
      },
      "id": "7ad6a6613a9ba9ca",
      "type": "add",
      "after": "ae22cf8607150449",
      "date": 1708684262713
    },
    {
      "type": "edit",
      "id": "7ad6a6613a9ba9ca",
      "item": {
        "type": "paragraph",
        "id": "7ad6a6613a9ba9ca",
        "text": "\nNAJAFI, M. Hassan, LILJA, David J., RIEDEL, Marc and BAZARGAN, Kia, 2016. Polysynchronous stochastic circuits. In: 2016 21st Asia and South Pacific Design Automation Conference (ASP-DAC). Online. IEEE. 2016. p. 492–498. Available from: https://ieeexplore.ieee.org/abstract/document/7428060/ [Accessed 23 February 2024]. \n"
      },
      "date": 1708684264841
    },
    {
      "type": "edit",
      "id": "7ad6a6613a9ba9ca",
      "item": {
        "type": "paragraph",
        "id": "7ad6a6613a9ba9ca",
        "text": "NAJAFI, M. Hassan, LILJA, David J., RIEDEL, Marc and BAZARGAN, Kia, 2016. Polysynchronous stochastic circuits. In: 2016 21st Asia and South Pacific Design Automation Conference (ASP-DAC). IEEE. 2016. p. 492–498. [https://ieeexplore.ieee.org/abstract/document/7428060/ ieee] [Accessed 23 February 2024]. \n"
      },
      "date": 1708684288935
    },
    {
      "type": "edit",
      "id": "74bddb9d90430d71",
      "item": {
        "type": "paragraph",
        "id": "74bddb9d90430d71",
        "text": "Clock distribution networks (CDNs) are costly in high-performance ASICs. This paper proposes a new approach: splitting clock domains at a very fine level, down to the level of a handful of gates. Each domain is synchronized with an inexpensive clock signal, generated locally. This is possible by adopting the paradigm of [[Stochastic Computation]], where signal values are encoded as random bit streams. The design method is illustrated with the synthesis of circuits for applications in signal and image processing."
      },
      "date": 1708684380159
    },
    {
      "type": "fork",
      "date": 1708684775635
    },
    {
      "type": "edit",
      "id": "ae22cf8607150449",
      "item": {
        "type": "pagefold",
        "id": "ae22cf8607150449",
        "text": "~"
      },
      "date": 1708684780688
    },
    {
      "item": {
        "type": "factory",
        "id": "46719a54c4822064"
      },
      "id": "46719a54c4822064",
      "type": "add",
      "after": "7ad6a6613a9ba9ca",
      "date": 1708684852852
    },
    {
      "type": "edit",
      "id": "46719a54c4822064",
      "item": {
        "type": "paragraph",
        "id": "46719a54c4822064",
        "text": "All electronic systems are inherently asynchronous in nature. By carefully choreographing transitions with clock signals, asynchronous circuitry can be adapted to appear to behave synchronously. Such synchronism brings significant advantages: it greatly simplifies the design effort; also, with predictable timing, one can make performance guarantees. However, synchronism comes at a significant cost: one must create a clock distribution network (CDN) that supplies a common reference signal to all synchronous components. Historically, the primary design goal for CDNs has been to ensure that a single clock signal arrives at every synchronous component at precisely the same time (so there is zero clock skew). Achieving this is difficult and costly in terms of design effort and resources. In modern large-scale integrated circuits, the CDN accounts for significant area, consumes significant power, and often limits the overall circuit performance [1][2]. With increasing variation in circuit parameters, designing CDNs with tolerable clock skew is becoming a major design bottleneck."
      },
      "date": 1708684854876
    },
    {
      "type": "edit",
      "id": "46719a54c4822064",
      "item": {
        "type": "paragraph",
        "id": "46719a54c4822064",
        "text": "All electronic systems are inherently [[asynchronous]] in nature. By carefully choreographing transitions with clock signals, asynchronous circuitry can be adapted to appear to behave synchronously. Such synchronism brings significant advantages: it greatly simplifies the design effort; also, with predictable timing, one can make performance guarantees. However, synchronism comes at a significant cost: one must create a clock distribution network (CDN) that supplies a common reference signal to all synchronous components. Historically, the primary design goal for CDNs has been to ensure that a single clock signal arrives at every synchronous component at precisely the same time (so there is zero clock skew). Achieving this is difficult and costly in terms of design effort and resources. In modern large-scale integrated circuits, the CDN accounts for significant area, consumes significant power, and often limits the overall circuit performance [1][2]. With increasing variation in circuit parameters, designing CDNs with tolerable clock skew is becoming a major design bottleneck."
      },
      "date": 1708684891328
    },
    {
      "type": "add",
      "id": "e4881b072a220193",
      "item": {
        "type": "paragraph",
        "id": "e4881b072a220193",
        "text": "[1] E.G. Friedman. Clock distribution networks in synchronous digital integrated circuits. Proceedings of the IEEE, 89(5):665692, May 2001."
      },
      "after": "46719a54c4822064",
      "date": 1708684975294
    },
    {
      "type": "add",
      "id": "4294912acf6b9d74",
      "item": {
        "type": "paragraph",
        "id": "4294912acf6b9d74",
        "text": "[2] Y. Jiang, H. Zhang, H. Zhang, H. Liu, X. Song, M. Gu, and J. Sun. Design of mixed synchronous/asynchronous systems with multiple clocks. Parallel and Distributed Systems, IEEE Transactions on, PP(99):1–1, 2014."
      },
      "after": "e4881b072a220193",
      "date": 1708684991189
    },
    {
      "type": "add",
      "id": "7b1cd9b77822bfe6",
      "item": {
        "type": "paragraph",
        "id": "7b1cd9b77822bfe6",
        "text": "Completely asynchronous design methodologies have been studied for decades, but these have never gained widespread acceptance (in spite of strong advocacy by proponents). Circuits with multiple independent clock domains – so circuits that are globally asynchronous, but locally synchronous (GALS) – have become common [3]. Splitting the domains reduces the cost of the distribution network, but relatively complex circuitry for handshaking is needed at domain crossings, so the splitting is only performed at a coarse level."
      },
      "after": "4294912acf6b9d74",
      "date": 1708685030175
    },
    {
      "type": "add",
      "id": "d16dfd5cbe71fd28",
      "item": {
        "type": "paragraph",
        "id": "d16dfd5cbe71fd28",
        "text": "[3] D. Chapiro. Globally-asynchronous locally-synchronous systems. Stanford University, 1984."
      },
      "after": "7b1cd9b77822bfe6",
      "date": 1708685080806
    },
    {
      "type": "edit",
      "id": "d16dfd5cbe71fd28",
      "item": {
        "type": "paragraph",
        "id": "d16dfd5cbe71fd28",
        "text": "[3] D. Chapiro. Globally-asynchronous locally-synchronous systems. Stanford University, 1984. [https://apps.dtic.mil/sti/tr/pdf/ADA154624.pdf pdf]"
      },
      "date": 1708685156494
    },
    {
      "item": {
        "type": "factory",
        "id": "70f9028e83c76377"
      },
      "id": "70f9028e83c76377",
      "type": "add",
      "after": "d16dfd5cbe71fd28",
      "date": 1708685446683
    },
    {
      "type": "edit",
      "id": "70f9028e83c76377",
      "item": {
        "type": "paragraph",
        "id": "70f9028e83c76377",
        "text": "This paper proposes a radically new approach: splitting clock domains at a very fine level, with domains consisting"
      },
      "date": 1708685449006
    },
    {
      "type": "edit",
      "id": "70f9028e83c76377",
      "item": {
        "type": "paragraph",
        "id": "70f9028e83c76377",
        "text": "This paper proposes a radically new approach: splitting clock domains at a very fine level, with domains consisting of only a handful of gates each. Each domain is synchronized by an inexpensive clock signal, generated locally. This is feasible if one adopts a stochastic representation for signal values [4, 5, 6, 7, 8, 9]. Logical computation is performed on randomized bit streams, with signal values encoded in the statistics of the streams: a real value x in the interval [0, 1] is represented by a stream with bits each having independent probability x of being 1."
      },
      "date": 1708685464189
    },
    {
      "type": "add",
      "id": "da3d47099abfec94",
      "item": {
        "type": "paragraph",
        "id": "da3d47099abfec94",
        "text": "[4] B.R. Gaines. Stochastic computing systems. In JuliusT. Tou, editor, Advances in Information Systems Science, Advances in Information Systems Science, pages 37–172. Springer US, 1969."
      },
      "after": "70f9028e83c76377",
      "date": 1708685625427
    },
    {
      "type": "add",
      "id": "26934441e5524b70",
      "item": {
        "type": "paragraph",
        "id": "26934441e5524b70",
        "text": "[5] W. Qian and M.D. Riedel. The synthesis of robust polynomial arithmetic with stochastic logic. In 45th ACM/IEEE Design Automation Conference, DAC’08, pages 648–653, 2008."
      },
      "after": "da3d47099abfec94",
      "date": 1708685637747
    },
    {
      "type": "add",
      "id": "4dea707cb9242ec2",
      "item": {
        "type": "paragraph",
        "id": "4dea707cb9242ec2",
        "text": "[6] Weikang Qian, Xin Li, M.D. Riedel, K. Bazargan, and D.J. Lilja. An architecture for fault-tolerant computation with stochastic logic. Computers, IEEE Transactions on, 60(1):93105, Jan 2011."
      },
      "after": "26934441e5524b70",
      "date": 1708685662331
    },
    {
      "type": "add",
      "id": "8576037c9538100e",
      "item": {
        "type": "paragraph",
        "id": "8576037c9538100e",
        "text": "[7] P. Li, D. J. Lilja, W. Qian, K. Bazargan, and M. Riedel. The synthesis of complex arithmetic computation on stochastic bit streams using sequential logic. In Computer-Aided Design,"
      },
      "after": "4dea707cb9242ec2",
      "date": 1708685673806
    },
    {
      "type": "edit",
      "id": "8576037c9538100e",
      "item": {
        "type": "paragraph",
        "id": "8576037c9538100e",
        "text": "[7] P. Li, D. J. Lilja, W. Qian, K. Bazargan, and M. Riedel. The synthesis of complex arithmetic computation on stochastic bit streams using sequential logic. In Computer-Aided Design, 2012. ICCAD 2012. IEEE/ACM International Conference on. IEEE, 2012."
      },
      "date": 1708685685879
    },
    {
      "type": "add",
      "id": "ade8fe6742eaaffc",
      "item": {
        "type": "paragraph",
        "id": "ade8fe6742eaaffc",
        "text": "[8] Peng Li, D.J. Lilja, Weikang Qian, K. Bazargan, and M.D. Riedel. Computation on stochastic bit streams digital image processing case studies. Very Large Scale Integration (VLSI) Systems, IEEE Transactions on, 22(3):449–462, March 2014."
      },
      "after": "8576037c9538100e",
      "date": 1708685723620
    },
    {
      "type": "add",
      "id": "e67384dddb94476e",
      "item": {
        "type": "paragraph",
        "id": "e67384dddb94476e",
        "text": "[9] Armin Alaghi and John P. Hayes. Survey of stochastic computing. ACM Trans. Embed. Comput. Syst., 12(2s):92:1–92:19, May 2013."
      },
      "after": "ade8fe6742eaaffc",
      "date": 1708685735999
    },
    {
      "type": "add",
      "id": "40bc441a9bd9408e",
      "item": {
        "type": "paragraph",
        "id": "40bc441a9bd9408e",
        "text": "Compared to a binary radix representation, such a stochastic representation is not very compact. With M bits, a binary radix representation can represent 2M distinct numbers. To represent real numbers with a resolution of 2−M , i.e., numbers of the form a 2M for integers a between 0 and 2M , a stochastic representation requires a stream of 2M bits. The two representations are at opposite ends of the spectrum: conventional binary radix is a maximally compressed, positional encoding; a stochastic representation is an uncompressed, uniform encoding."
      },
      "after": "e67384dddb94476e",
      "date": 1708685773405
    },
    {
      "item": {
        "type": "factory",
        "id": "2ec9b5433370ed53"
      },
      "id": "2ec9b5433370ed53",
      "type": "add",
      "after": "40bc441a9bd9408e",
      "date": 1708686111563
    },
    {
      "type": "edit",
      "id": "3cca1fdd49c19c56",
      "item": {
        "type": "paragraph",
        "id": "3cca1fdd49c19c56",
        "text": "[[0000000010…]]"
      },
      "date": 1708686125046
    },
    {
      "item": {
        "type": "factory",
        "id": "7abbaa5b6319488f"
      },
      "id": "7abbaa5b6319488f",
      "type": "add",
      "after": "3cca1fdd49c19c56",
      "date": 1708686132859
    },
    {
      "type": "edit",
      "id": "7abbaa5b6319488f",
      "item": {
        "type": "reference",
        "id": "7abbaa5b6319488f",
        "site": "wiki.ralfbarkow.ch",
        "slug": "0000000010",
        "title": "0000000010…",
        "text": "How to achieve persistence of a 2D coordinate system representing connexions? This post explains it in a bottom-up approach. [https://ralfbarkow.wordpress.com/2006/11/29/0000000010/#more-141 post]"
      },
      "date": 1708686139279
    },
    {
      "item": {
        "type": "factory",
        "id": "d2da8b670ab9e86f"
      },
      "id": "d2da8b670ab9e86f",
      "type": "add",
      "after": "7abbaa5b6319488f",
      "date": 1708686145209
    },
    {
      "type": "edit",
      "id": "d2da8b670ab9e86f",
      "item": {
        "type": "pagefold",
        "id": "d2da8b670ab9e86f",
        "text": "~"
      },
      "date": 1708686149735
    },
    {
      "id": "3cca1fdd49c19c56",
      "type": "remove",
      "removedTo": {
        "page": "~/clock/0"
      },
      "date": 1708686171443
    },
    {
      "type": "fork",
      "site": "wiki.ralfbarkow.ch",
      "date": 1708686408584
    },
    {
      "id": "7abbaa5b6319488f",
      "type": "remove",
      "removedTo": {
        "page": "scratch"
      },
      "date": 1708686435589
    },
    {
      "id": "d2da8b670ab9e86f",
      "type": "remove",
      "removedTo": {
        "page": "scratch"
      },
      "date": 1708686438933
    },
    {
      "id": "7abbaa5b6319488f",
      "type": "add",
      "item": {
        "type": "reference",
        "id": "7abbaa5b6319488f",
        "site": "wiki.ralfbarkow.ch",
        "slug": "0000000010",
        "title": "0000000010…",
        "text": "How to achieve persistence of a 2D coordinate system representing connexions? This post explains it in a bottom-up approach. [https://ralfbarkow.wordpress.com/2006/11/29/0000000010/#more-141 post]"
      },
      "after": "40bc441a9bd9408e",
      "attribution": {
        "page": "scratch"
      },
      "date": 1708686449655
    },
    {
      "id": "d2da8b670ab9e86f",
      "type": "add",
      "item": {
        "type": "pagefold",
        "id": "d2da8b670ab9e86f",
        "text": "~"
      },
      "after": "40bc441a9bd9408e",
      "attribution": {
        "page": "scratch"
      },
      "date": 1708686452886
    },
    {
      "type": "edit",
      "id": "2ec9b5433370ed53",
      "item": {
        "type": "markdown",
        "id": "2ec9b5433370ed53",
        "text": "~"
      },
      "date": 1708686459091
    },
    {
      "type": "remove",
      "id": "2ec9b5433370ed53",
      "date": 1708686470875
    },
    {
      "type": "fork",
      "date": 1708686484893
    },
    {
      "item": {
        "type": "factory",
        "id": "646261a1eea963f0"
      },
      "id": "646261a1eea963f0",
      "type": "add",
      "after": "7abbaa5b6319488f",
      "date": 1708686486740
    },
    {
      "type": "edit",
      "id": "646261a1eea963f0",
      "item": {
        "type": "pagefold",
        "id": "646261a1eea963f0",
        "text": "~"
      },
      "date": 1708686491229
    },
    {
      "type": "edit",
      "id": "40bc441a9bd9408e",
      "item": {
        "type": "paragraph",
        "id": "40bc441a9bd9408e",
        "text": "Compared to a binary radix representation, such a stochastic representation is not very compact. With M bits, a binary radix representation can represent 2M distinct numbers. To represent real numbers with a resolution of 2^−M , i.e., numbers of the form a 2^M for integers a between 0 and 2M , a stochastic representation requires a stream of 2M bits. The two representations are at opposite ends of the spectrum: conventional binary radix is a maximally compressed, positional encoding; a stochastic representation is an uncompressed, uniform encoding."
      },
      "date": 1708686533952
    },
    {
      "type": "edit",
      "id": "40bc441a9bd9408e",
      "item": {
        "type": "paragraph",
        "id": "40bc441a9bd9408e",
        "text": "Compared to a binary radix representation, such a stochastic representation is not very compact. With M bits, a binary radix representation can represent 2^M distinct numbers. To represent real numbers with a resolution of 2^−M , i.e., numbers of the form a/2^M for integers a between 0 and 2^M , a stochastic representation requires a stream of 2M bits. The two representations are at opposite ends of the spectrum: conventional binary radix is a maximally compressed, positional encoding; a stochastic representation is an uncompressed, uniform encoding."
      },
      "date": 1708686572767
    },
    {
      "type": "edit",
      "id": "40bc441a9bd9408e",
      "item": {
        "type": "paragraph",
        "id": "40bc441a9bd9408e",
        "text": "Compared to a binary radix representation, such a stochastic representation is not very compact. With M bits, a binary radix representation can represent 2^M distinct numbers. To represent real numbers with a resolution of 2^−M , i.e., numbers of the form a/2^M for integers a between 0 and 2^M , a stochastic representation requires a stream of 2^M bits. The two representations are at opposite ends of the spectrum: conventional binary radix is a maximally compressed, positional encoding; a stochastic representation is an uncompressed, uniform encoding."
      },
      "date": 1708686588247
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1708686781432
    },
    {
      "item": {
        "type": "factory",
        "id": "71451a8c8635ae54"
      },
      "id": "71451a8c8635ae54",
      "type": "add",
      "after": "646261a1eea963f0",
      "date": 1708686965403
    },
    {
      "type": "edit",
      "id": "71451a8c8635ae54",
      "item": {
        "type": "paragraph",
        "id": "71451a8c8635ae54",
        "text": "[[An Other Space]]"
      },
      "date": 1708686969537
    },
    {
      "item": {
        "type": "factory",
        "id": "ac080f0ea5f186e1"
      },
      "id": "ac080f0ea5f186e1",
      "type": "add",
      "after": "71451a8c8635ae54",
      "date": 1708687098971
    },
    {
      "type": "edit",
      "id": "ac080f0ea5f186e1",
      "item": {
        "type": "reference",
        "id": "ac080f0ea5f186e1",
        "site": "wiki.ralfbarkow.ch",
        "slug": "an-other-space",
        "title": "An Other Space",
        "text": "A visual proof of the existence on an anti-symmetric complementary space S* of gaps (an other space) within the traditional mathematical continuum X=[0,1]."
      },
      "date": 1708687102688
    },
    {
      "id": "ac080f0ea5f186e1",
      "type": "move",
      "order": [
        "74bddb9d90430d71",
        "ae22cf8607150449",
        "7ad6a6613a9ba9ca",
        "46719a54c4822064",
        "e4881b072a220193",
        "4294912acf6b9d74",
        "7b1cd9b77822bfe6",
        "d16dfd5cbe71fd28",
        "70f9028e83c76377",
        "da3d47099abfec94",
        "26934441e5524b70",
        "4dea707cb9242ec2",
        "8576037c9538100e",
        "ade8fe6742eaaffc",
        "e67384dddb94476e",
        "40bc441a9bd9408e",
        "d2da8b670ab9e86f",
        "7abbaa5b6319488f",
        "ac080f0ea5f186e1",
        "646261a1eea963f0",
        "71451a8c8635ae54"
      ],
      "date": 1708687111294
    },
    {
      "id": "71451a8c8635ae54",
      "type": "remove",
      "removedTo": {
        "page": "~/clock/0"
      },
      "date": 1708687403623
    },
    {
      "item": {
        "type": "factory",
        "id": "fccac7a025601ac9"
      },
      "id": "fccac7a025601ac9",
      "type": "add",
      "after": "646261a1eea963f0",
      "date": 1708688490529
    },
    {
      "type": "edit",
      "id": "fccac7a025601ac9",
      "item": {
        "type": "paragraph",
        "id": "fccac7a025601ac9",
        "text": "A stochastic representation, although not very compact, has an advantage over binary radix in terms of error tolerance. Suppose that the environment is noisy: bit flips occur and these afflict all the bits with equal probability. With a binary radix representation, in the worst case, the most significant bit gets flipped, resulting in a large error. In contrast, with a stochastic representation, all the bits in the stream have equal weight. A single flip results in a small error. This error tolerance scales to high error rates: multiple bit flips produce small and uniform deviations from the nominal value. More compelling than the error tolerance is the simplicity of the designs in the stochastic paradigm. Complex functions can be implemented with remarkably simple logic. A reduction in area of 50x or 100x compared to conventional implementations is common [8][10]."
      },
      "date": 1708688493213
    },
    {
      "type": "add",
      "id": "8953deabf50aae43",
      "item": {
        "type": "paragraph",
        "id": "8953deabf50aae43",
        "text": "[8] Peng Li, D.J. Lilja, Weikang Qian, K. Bazargan, and M.D. Riedel. Computation on stochastic bit streams digital image processing case studies. Very Large Scale Integration (VLSI) Systems, IEEE Transactions on, 22(3):449–462, March 2014."
      },
      "after": "fccac7a025601ac9",
      "date": 1708688755736
    },
    {
      "type": "add",
      "id": "2eb9c0fa6c2c78da",
      "item": {
        "type": "paragraph",
        "id": "2eb9c0fa6c2c78da",
        "text": "[10] A. Alaghi and J.P. Hayes. Fast and accurate computation using stochastic circuits. In Design, Automation and Test in Europe Conference and Exhibition (DATE), 2014, pages 1–4, March 2014."
      },
      "after": "8953deabf50aae43",
      "date": 1708688767481
    },
    {
      "type": "add",
      "id": "0f5f716ec82be777",
      "item": {
        "type": "paragraph",
        "id": "0f5f716ec82be777",
        "text": "A more compelling advantage still of the stochastic paradigm could be the idea advocated in this paper. With a stochastic representation, computational units can tolerate skew in the arrival time of their inputs. This stems from the fact that the stochastic representation is uniform: all that matters in terms of the value that is computed is the fraction of time that the signal is high. We will demonstrate that the correct value is computed even when the inputs are misaligned temporally. Accordingly, adopting the stochastic paradigm obviates the need for a global clock signal and the associated CDN. Instead one can simply use local clock signal generators throughout."
      },
      "after": "2eb9c0fa6c2c78da",
      "date": 1708688802174
    },
    {
      "item": {
        "type": "factory",
        "id": "51ef7cc4d8b8e7dc"
      },
      "id": "51ef7cc4d8b8e7dc",
      "type": "add",
      "after": "0f5f716ec82be777",
      "date": 1708689088776
    },
    {
      "type": "edit",
      "id": "51ef7cc4d8b8e7dc",
      "item": {
        "type": "pagefold",
        "id": "51ef7cc4d8b8e7dc",
        "text": "1–2"
      },
      "date": 1708689101074
    },
    {
      "item": {
        "type": "factory",
        "id": "30dbd480d415353c"
      },
      "id": "30dbd480d415353c",
      "type": "add",
      "after": "51ef7cc4d8b8e7dc",
      "date": 1708689112683
    },
    {
      "type": "edit",
      "id": "30dbd480d415353c",
      "item": {
        "type": "paragraph",
        "id": "30dbd480d415353c",
        "text": "We call this approach polysynchronous stochastic (to distinguish it from asynchronous and GALS methodologies)."
      },
      "date": 1708689118727
    },
    {
      "type": "add",
      "id": "593831328e29921c",
      "item": {
        "type": "paragraph",
        "id": "593831328e29921c",
        "text": "The paper is structured as follows. In Section II, we provide some background on stochastic computing. In Section III, we introduce polysynchronous stochastic concepts and demonstrate how to implement basic operations. In Section IV, we describe our experimental methodology and present experimental results. Finally, in Section V, we present conclusions and discuss future work"
      },
      "after": "30dbd480d415353c",
      "date": 1708689121304
    },
    {
      "type": "edit",
      "id": "30dbd480d415353c",
      "item": {
        "type": "paragraph",
        "id": "30dbd480d415353c",
        "text": "We call this approach [[polysynchronous stochastic]] (to distinguish it from asynchronous and GALS methodologies)."
      },
      "date": 1708689127364
    },
    {
      "type": "edit",
      "id": "593831328e29921c",
      "item": {
        "type": "paragraph",
        "id": "593831328e29921c",
        "text": "The paper is structured as follows. In Section II, we provide some background on stochastic computing. In Section III, we introduce polysynchronous stochastic concepts and demonstrate how to implement basic operations. In Section IV, we describe our experimental methodology and present experimental results. Finally, in Section V, we present conclusions and discuss future work."
      },
      "date": 1708689148407
    },
    {
      "item": {
        "type": "factory",
        "id": "ee990f95ac827148"
      },
      "id": "ee990f95ac827148",
      "type": "add",
      "after": "593831328e29921c",
      "date": 1708689156331
    },
    {
      "type": "edit",
      "id": "ee990f95ac827148",
      "item": {
        "type": "paragraph",
        "id": "ee990f95ac827148",
        "text": "BACKGROUND"
      },
      "date": 1708689158020
    },
    {
      "type": "add",
      "id": "bfd71dbe9bd58195",
      "item": {
        "type": "paragraph",
        "id": "bfd71dbe9bd58195",
        "text": "In the paradigm of stochastic computing (SC), circuits operate on random bit streams where the signal value is encoded by the probability of obtaining a one versus a zero. In the unipolar stochastic representation, each realvalued number x (0 ≤ x ≤ 1) is represented by a sequence of random bits, each of which has probability x of being one and probability 1 − x of being zero. In the bipolar representation, each real-valued number y (−1 ≤ y ≤ 1) is represented by a sequence of random bits, each of which has probability y+1 2 of being one and probability 1 − y+1 2 of being zero."
      },
      "after": "ee990f95ac827148",
      "date": 1708689177192
    },
    {
      "type": "add",
      "id": "a9e98b9612a94038",
      "item": {
        "type": "paragraph",
        "id": "a9e98b9612a94038",
        "text": "[…]"
      },
      "after": "bfd71dbe9bd58195",
      "date": 1708689179089
    },
    {
      "type": "edit",
      "id": "bfd71dbe9bd58195",
      "item": {
        "type": "paragraph",
        "id": "bfd71dbe9bd58195",
        "text": "In the paradigm of [[Stochastic Computing]] (SC), circuits operate on random bit streams where the signal value is encoded by the probability of obtaining a one versus a zero. In the unipolar stochastic representation, each realvalued number x (0 ≤ x ≤ 1) is represented by a sequence of random bits, each of which has probability x of being one and probability 1 − x of being zero. In the bipolar representation, each real-valued number y (−1 ≤ y ≤ 1) is represented by a sequence of random bits, each of which has probability y+1 2 of being one and probability 1 − y+1 2 of being zero."
      },
      "date": 1708689196339
    },
    {
      "type": "add",
      "id": "d968f4492b24a7f4",
      "item": {
        "type": "paragraph",
        "id": "d968f4492b24a7f4",
        "text": "This representation is much less compact than a binary radix. However, complex operations can be performed with very simple logic. In particular, arithmetic functions, consisting of operations like addition and multiplication can be implemented very efficiently. Complex functions, such as exponentials and trigonometric functions, can be computed through polynomial approximations [5, 8]. Because the bit stream representation is uniform, with all bits weighted equally, circuits designed this way are highly tolerant of soft errors (i.e., bit flips) [6]."
      },
      "after": "bfd71dbe9bd58195",
      "date": 1708689256634
    },
    {
      "type": "add",
      "id": "52b8b2542ba8508f",
      "item": {
        "type": "paragraph",
        "id": "52b8b2542ba8508f",
        "text": "[6] Weikang Qian, Xin Li, M.D. Riedel, K. Bazargan, and D.J. Lilja. An architecture for fault-tolerant computation with stochastic logic. Computers, IEEE Transactions on, 60(1):93105, Jan 2011."
      },
      "after": "d968f4492b24a7f4",
      "date": 1708689263963
    },
    {
      "type": "edit",
      "id": "d968f4492b24a7f4",
      "item": {
        "type": "paragraph",
        "id": "d968f4492b24a7f4",
        "text": "This representation is much less compact than a binary radix. However, complex operations can be performed with very simple logic. In particular, arithmetic functions, consisting of operations like addition and multiplication can be implemented very efficiently. Complex functions, such as exponentials and trigonometric functions, can be computed through polynomial approximations [5, 8]."
      },
      "date": 1708689305299
    },
    {
      "type": "add",
      "id": "c0c27611f1ec6c63",
      "item": {
        "type": "paragraph",
        "id": "c0c27611f1ec6c63",
        "text": "Because the bit stream representation is uniform, with all bits weighted equally, circuits designed this way are highly tolerant of soft errors (i.e., bit flips) [6]."
      },
      "after": "d968f4492b24a7f4",
      "date": 1708689306767
    },
    {
      "type": "add",
      "id": "76136ab6e2e64038",
      "item": {
        "type": "paragraph",
        "id": "76136ab6e2e64038",
        "text": "[5] W. Qian and M.D. Riedel. The synthesis of robust polynomial arithmetic with stochastic logic. In 45th ACM/IEEE Design Automation Conference, DAC’08, pages 648–653, 2008."
      },
      "after": "d968f4492b24a7f4",
      "date": 1708689320499
    },
    {
      "type": "add",
      "id": "b10e256f2d5a8e32",
      "item": {
        "type": "paragraph",
        "id": "b10e256f2d5a8e32",
        "text": "[8] Peng Li, D.J. Lilja, Weikang Qian, K. Bazargan, and M.D. Riedel. Computation on stochastic bit streams digital image processing case studies. Very Large Scale Integration (VLSI) Systems, IEEE Transactions on, 22(3):449–462, March 2014."
      },
      "after": "76136ab6e2e64038",
      "date": 1708689335368
    },
    {
      "type": "add",
      "id": "4a7ad64a1637a291",
      "item": {
        "type": "paragraph",
        "id": "4a7ad64a1637a291",
        "text": "Critical to the ideas in this paper is the observation that the stochastic representation is a uniform fractional representation: all that matters is the fraction of time that the signal is high. Consequently, precise synchronization between the arrival time of input values to logic gates does not matter. This is illustrated in the next section."
      },
      "after": "52b8b2542ba8508f",
      "date": 1708689471890
    },
    {
      "item": {
        "type": "factory",
        "id": "2cd351490d4c38dc"
      },
      "id": "2cd351490d4c38dc",
      "type": "add",
      "after": "a9e98b9612a94038",
      "date": 1708689717545
    },
    {
      "item": {
        "type": "factory",
        "id": "f3abf18e52e25586"
      },
      "id": "f3abf18e52e25586",
      "type": "add",
      "after": "2cd351490d4c38dc",
      "date": 1708689721939
    },
    {
      "type": "edit",
      "id": "f3abf18e52e25586",
      "item": {
        "type": "paragraph",
        "id": "f3abf18e52e25586",
        "text": "Ward has done interesting computation on networks of computers using only one page of assembly language. http://code.fed.wiki.org/cybords.html\nThese little computers were so inexpensive that I would buy 50 at a time.\nA message was just an electrical pulse, high or low, repeated stochastically until communication happened a few tenths of a second later. Each part had to interface pins, one sending, the other listening. A computer could listen to multiple senders at the same time and chance would have it hear the arithmetic sum of both sources."
      },
      "date": 1708689734621
    },
    {
      "type": "edit",
      "id": "f3abf18e52e25586",
      "item": {
        "type": "paragraph",
        "id": "f3abf18e52e25586",
        "text": "Ward did interesting computation on networks of computers using only one page of assembly language. http://code.fed.wiki.org/cybords.html\nThese little computers were so inexpensive that I would buy 50 at a time.\nA message was just an electrical pulse, high or low, repeated stochastically until communication happened a few tenths of a second later. Each part had to interface pins, one sending, the other listening. A computer could listen to multiple senders at the same time and chance would have it hear the arithmetic sum of both sources."
      },
      "date": 1708689771636
    },
    {
      "type": "edit",
      "id": "f3abf18e52e25586",
      "item": {
        "type": "paragraph",
        "id": "f3abf18e52e25586",
        "text": "Ward did interesting computation on networks of computers using only one page of assembly language. [http://code.fed.wiki.org/cybords.html page]] \nThese little computers were so inexpensive that I would buy 50 at a time.\nA message was just an electrical pulse, high or low, repeated stochastically until communication happened a few tenths of a second later. Each part had to interface pins, one sending, the other listening. A computer could listen to multiple senders at the same time and chance would have it hear the arithmetic sum of both sources."
      },
      "date": 1708689791400
    },
    {
      "type": "edit",
      "id": "f3abf18e52e25586",
      "item": {
        "type": "paragraph",
        "id": "f3abf18e52e25586",
        "text": "Ward did interesting computation on networks of computers using only one page of assembly language. [http://code.fed.wiki.org/cybords.html page] See [[Cybords]]"
      },
      "date": 1708689809592
    },
    {
      "type": "add",
      "id": "8bf9bdb9c9df3ad0",
      "item": {
        "type": "paragraph",
        "id": "8bf9bdb9c9df3ad0",
        "text": "These little computers were so inexpensive that I would buy 50 at a time.\nA message was just an electrical pulse, high or low, repeated stochastically until communication happened a few tenths of a second later. Each part had to interface pins, one sending, the other listening. A computer could listen to multiple senders at the same time and chance would have it hear the arithmetic sum of both sources."
      },
      "after": "f3abf18e52e25586",
      "date": 1708689809996
    },
    {
      "type": "edit",
      "id": "8bf9bdb9c9df3ad0",
      "item": {
        "type": "paragraph",
        "id": "8bf9bdb9c9df3ad0",
        "text": "> These little computers were so inexpensive that I would buy 50 at a time."
      },
      "date": 1708689842543
    },
    {
      "type": "edit",
      "id": "8bf9bdb9c9df3ad0",
      "item": {
        "type": "markdown",
        "id": "8bf9bdb9c9df3ad0",
        "text": "> These little computers were so inexpensive that I would buy 50 at a time. A message was just an electrical pulse, high or low, repeated stochastically until communication happened a few tenths of a second later. Each part had to interface pins, one sending, the other listening. A computer could listen to multiple senders at the same time and chance would have it hear the arithmetic sum of both sources."
      },
      "date": 1708689847038
    },
    {
      "type": "edit",
      "id": "8bf9bdb9c9df3ad0",
      "item": {
        "type": "markdown",
        "id": "8bf9bdb9c9df3ad0",
        "text": "> These little computers were so inexpensive that I would buy 50 at a time. \n> A message was just an electrical pulse, high or low, repeated stochastically until communication happened a few tenths of a second later. Each part had to interface pins, one sending, the other listening. A computer could listen to multiple senders at the same time and chance would have it hear the arithmetic sum of both sources."
      },
      "date": 1708689851840
    },
    {
      "type": "edit",
      "id": "8bf9bdb9c9df3ad0",
      "item": {
        "type": "markdown",
        "id": "8bf9bdb9c9df3ad0",
        "text": "> These little computers were so inexpensive that I would buy 50 at a time. \n> A message was just an electrical pulse, high or low, repeated stochastically until communication happened a few tenths of a second later. Each part had to interface pins, one sending, the other listening. A computer could listen to multiple senders at the same time and chance would have it [[Hear the Arithmetic Sum]] of both sources."
      },
      "date": 1708689912868
    },
    {
      "item": {
        "type": "factory",
        "id": "8136920c49f672e0"
      },
      "id": "8136920c49f672e0",
      "type": "add",
      "after": "8bf9bdb9c9df3ad0",
      "date": 1708689931238
    },
    {
      "type": "edit",
      "id": "8136920c49f672e0",
      "item": {
        "type": "pagefold",
        "id": "8136920c49f672e0",
        "text": "~"
      },
      "date": 1708689933935
    },
    {
      "item": {
        "type": "factory",
        "id": "95b5cbd82f305baf"
      },
      "id": "95b5cbd82f305baf",
      "type": "add",
      "after": "8136920c49f672e0",
      "date": 1708689970787
    },
    {
      "type": "edit",
      "id": "95b5cbd82f305baf",
      "item": {
        "type": "paragraph",
        "id": "95b5cbd82f305baf",
        "text": "⇒ [[Stochastic Operations]]"
      },
      "date": 1708689980245
    },
    {
      "type": "edit",
      "id": "2cd351490d4c38dc",
      "item": {
        "type": "pagefold",
        "id": "2cd351490d4c38dc",
        "text": "~"
      },
      "date": 1708691533496
    }
  ]
}