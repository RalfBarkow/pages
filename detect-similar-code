{
  "title": "Detect Similar Code",
  "story": [
    {
      "type": "paragraph",
      "id": "28a176f2924502d3",
      "text": "CARLOS PAIVA, José, PAULO LEAL, José and FIGUEIRA, Álvaro, 2024. Comparing Semantic Graph Representations of Source Code: The Case of Automatic Feedback on Programming Assignments. Computer Science & Information Systems. 2024. Vol. 21, no. 1. DOI 10.2298/CSIS230615004P. [Accessed 10 March 2024]. [https://doiserbia.nb.rs/img/doi/1820-0214/2024/1820-02142400004P.pdf pdf]"
    },
    {
      "type": "paragraph",
      "id": "c31baf9887954d75",
      "text": "Static source code analysis techniques are gaining relevance in automated assessment of programming assignments as they can provide less rigorous evaluation and more comprehensive and formative feedback. These techniques focus on source code aspects rather than requiring effective code execution. To this end, syntactic and semantic information encoded in textual data is typically represented internally as graphs, after parsing and other preprocessing stages. Static automated assessment techniques, therefore, draw inferences from intermediate representations to determine the correctness of a solution and derive feedback. Consequently, achieving the most effective semantic graph representation of source code for the specific task is critical, impacting both techniques’ accuracy, outcome, and execution time. This paper aims to provide a thorough comparison of the most widespread semantic graph representations for the automated assessment of programming assignments, including usage examples, facets, and costs for each of these representations. A benchmark has been conducted to assess their cost using the Abstract Syntax Tree (AST) as a baseline. The results demonstrate that the Code Property Graph (CPG) is the most feature-rich representation, but also the largest and most space-consuming (about 33% more than AST)."
    },
    {
      "type": "paragraph",
      "id": "b1c4a1d3c8e6604d",
      "text": "[74, 34, 68, 50]"
    },
    {
      "type": "paragraph",
      "id": "f4f09e4f22a737f7",
      "text": "White, M., Tufano, M., Vendome, C., Poshyvanyk, D.: Deep learning code fragments for code clone detection. In: Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering. p. 87–98. ASE 2016, Association for Computing Machinery, New York, NY, USA (2016), [https://doi.org/10.1145/2970276.2970326 doi]"
    },
    {
      "type": "paragraph",
      "id": "1b0bf46b6f843679",
      "text": "Code clone detection is an important problem for software maintenance and evolution. Many approaches consider either structure or identifiers, but none of the existing detection techniques model both sources of information. These techniques also depend on generic, handcrafted features to represent code fragments. We introduce learning-based detection techniques where everything for representing terms and fragments in source code is mined from the repository. Our code analysis supports a framework, which relies on deep learning, for automatically linking patterns mined at the lexical level with patterns mined at the syntactic level. We evaluated our novel learning-based approach for code clone detection with respect to feasibility from the point of view of software maintainers. We sampled and manually evaluated 398 file- and 480 method-level pairs across eight real-world Java systems; 93% of the file- and method-level samples were evaluated to be true positives. Among the true positives, we found pairs mapping to all four clone types. We compared our approach to a traditional structure-oriented technique and found that our learning-based approach detected clones that were either undetected or suboptimally reported by the prominent tool [[Deckard]]. Our results affirm that our learning-based approach is suitable for clone detection and a tenable technique for researchers. "
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Detect Similar Code",
        "story": []
      },
      "date": 1710134223910
    },
    {
      "id": "28a176f2924502d3",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "28a176f2924502d3",
        "text": "CARLOS PAIVA, José, PAULO LEAL, José and FIGUEIRA, Álvaro, 2024. Comparing Semantic Graph Representations of Source Code: The Case of Automatic Feedback on Programming Assignments. Computer Science & Information Systems. 2024. Vol. 21, no. 1. DOI 10.2298/CSIS230615004P. [Accessed 10 March 2024]. [https://doiserbia.nb.rs/img/doi/1820-0214/2024/1820-02142400004P.pdf pdf]"
      },
      "attribution": {
        "page": "2024-03-11"
      },
      "date": 1710134235586
    },
    {
      "id": "b1c4a1d3c8e6604d",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "b1c4a1d3c8e6604d",
        "text": "[[Detect Similar Code]] [74, 34, 68, 50]"
      },
      "after": "28a176f2924502d3",
      "attribution": {
        "page": "2024-03-11"
      },
      "date": 1710134239273
    },
    {
      "type": "edit",
      "id": "b1c4a1d3c8e6604d",
      "item": {
        "type": "paragraph",
        "id": "b1c4a1d3c8e6604d",
        "text": "[74, 34, 68, 50]"
      },
      "date": 1710134258706
    },
    {
      "id": "c31baf9887954d75",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "c31baf9887954d75",
        "text": "Static source code analysis techniques are gaining relevance in automated assessment of programming assignments as they can provide less rigorous evaluation and more comprehensive and formative feedback. These techniques focus on source code aspects rather than requiring effective code execution. To this end, syntactic and semantic information encoded in textual data is typically represented internally as graphs, after parsing and other preprocessing stages. Static automated assessment techniques, therefore, draw inferences from intermediate representations to determine the correctness of a solution and derive feedback. Consequently, achieving the most effective semantic graph representation of source code for the specific task is critical, impacting both techniques’ accuracy, outcome, and execution time. This paper aims to provide a thorough comparison of the most widespread semantic graph representations for the automated assessment of programming assignments, including usage examples, facets, and costs for each of these representations. A benchmark has been conducted to assess their cost using the Abstract Syntax Tree (AST) as a baseline. The results demonstrate that the Code Property Graph (CPG) is the most feature-rich representation, but also the largest and most space-consuming (about 33% more than AST)."
      },
      "after": "28a176f2924502d3",
      "attribution": {
        "page": "2024-03-11"
      },
      "date": 1710134264385
    },
    {
      "id": "f4f09e4f22a737f7",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "f4f09e4f22a737f7",
        "text": "White, M., Tufano, M., Vendome, C., Poshyvanyk, D.: Deep learning code fragments for code clone detection. In: Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering. p. 87–98. ASE 2016, Association for Computing Machinery, New York, NY, USA (2016), https://doi.org/10.1145/2970276.2970326"
      },
      "after": "b1c4a1d3c8e6604d",
      "attribution": {
        "page": "2024-03-11"
      },
      "date": 1710134272323
    },
    {
      "type": "edit",
      "id": "f4f09e4f22a737f7",
      "item": {
        "type": "paragraph",
        "id": "f4f09e4f22a737f7",
        "text": "White, M., Tufano, M., Vendome, C., Poshyvanyk, D.: Deep learning code fragments for code clone detection. In: Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering. p. 87–98. ASE 2016, Association for Computing Machinery, New York, NY, USA (2016), [https://doi.org/10.1145/2970276.2970326 doi]"
      },
      "date": 1710134296748
    },
    {
      "type": "add",
      "id": "1b0bf46b6f843679",
      "item": {
        "type": "paragraph",
        "id": "1b0bf46b6f843679",
        "text": "Code clone detection is an important problem for software maintenance and evolution. Many approaches consider either structure or identifiers, but none of the existing detection techniques model both sources of information. These techniques also depend on generic, handcrafted features to represent code fragments. We introduce learning-based detection techniques where everything for representing terms and fragments in source code is mined from the repository. Our code analysis supports a framework, which relies on deep learning, for automatically linking patterns mined at the lexical level with patterns mined at the syntactic level. We evaluated our novel learning-based approach for code clone detection with respect to feasibility from the point of view of software maintainers. We sampled and manually evaluated 398 file- and 480 method-level pairs across eight real-world Java systems; 93% of the file- and method-level samples were evaluated to be true positives. Among the true positives, we found pairs mapping to all four clone types. We compared our approach to a traditional structure-oriented technique and found that our learning-based approach detected clones that were either undetected or suboptimally reported by the prominent tool Deckard. Our results affirm that our learning-based approach is suitable for clone detection and a tenable technique for researchers. "
      },
      "after": "f4f09e4f22a737f7",
      "date": 1710134367489
    },
    {
      "type": "edit",
      "id": "1b0bf46b6f843679",
      "item": {
        "type": "paragraph",
        "id": "1b0bf46b6f843679",
        "text": "Code clone detection is an important problem for software maintenance and evolution. Many approaches consider either structure or identifiers, but none of the existing detection techniques model both sources of information. These techniques also depend on generic, handcrafted features to represent code fragments. We introduce learning-based detection techniques where everything for representing terms and fragments in source code is mined from the repository. Our code analysis supports a framework, which relies on deep learning, for automatically linking patterns mined at the lexical level with patterns mined at the syntactic level. We evaluated our novel learning-based approach for code clone detection with respect to feasibility from the point of view of software maintainers. We sampled and manually evaluated 398 file- and 480 method-level pairs across eight real-world Java systems; 93% of the file- and method-level samples were evaluated to be true positives. Among the true positives, we found pairs mapping to all four clone types. We compared our approach to a traditional structure-oriented technique and found that our learning-based approach detected clones that were either undetected or suboptimally reported by the prominent tool [[Deckard]]. Our results affirm that our learning-based approach is suitable for clone detection and a tenable technique for researchers. "
      },
      "date": 1710134449006
    }
  ]
}