{
  "title": "Resource Acquisition Is Initialization",
  "story": [
    {
      "type": "html",
      "text": "This [[Cee Plus Plus]] idiom ([[Resource Acquisition Is Initialization]] or RAII) relies on the life-cycle of objects: constructors called to initialize the object, and a destructor called when it goes away.  Objects are usually created either automatically in a local scope, in which case they are destroyed when the scope is exited (via normal flow, return, or exception), or they can be created with \"new\" in which case they are destroyed by an explicit \"delete\" (which is not RAII). ",
      "id": "025f85631052c980407158ea2ee07c20"
    },
    {
      "type": "html",
      "text": "<i>(Not to be confused with RIAA - [[Recording Industry Association Of America]].  RAII isn't evil.)</i>",
      "id": "c52d14734508811238607f58d6fb9de4"
    },
    {
      "type": "html",
      "text": "\nIf the resource in question (a file, lock, window, etc.) is acquired (opened, locked, created) in a constructor, and released (closed, unlocked, disposed) in the destructor, then the use of the resource is tied to the lifetime of the object.  Since object lifetimes are well-defined, so is the use of the resource.  Local objects can be used particularly elegantly:",
      "id": "a2a1751e11013f385718aa6bdc244d61"
    },
    {
      "type": "code",
      "text": " {\n  File f(\"/some/path/name\");\n  // use f\n }",
      "id": "2720d4a1bf6ba6b0ced366dd8c284ab8"
    },
    {
      "type": "html",
      "text": "Here, assuming the class File opens a named file upon construction and closes it upon destruction, this section of code will open a file (or throw an exception), do whatever it cares to in the \"use f\" section, and then close it.  It is common to use this idiom to simply wrap the resource use itself, e.g. given a Mutex class with lock() and unlock() methods, a RAII class Mutex<b></b>Lock can be written whose constructor lock()s (and remembers) some Mutex and whose destructor unlock()s it; then one can write code like: ",
      "id": "6afcf12645011a8dcf13e8038d6d1e3a"
    },
    {
      "type": "code",
      "text": " {\n  Mutex''''''Lock l1(mutex1);\n  Mutex''''''Lock l2(mutex2);\n  // critical section\n }",
      "id": "a887c2b73e5e80c8b71c09db5f5d91a0"
    },
    {
      "type": "html",
      "text": "Since destruction is in the reverse order of construction, this produces the right semantics, for mutexes as for many other resources.  Note, you have to be very careful that the object you use for a mutex still exists at the end of the function, otherwise things get very messy, very quickly.",
      "id": "7f425e834717d015dff962c673a199eb"
    },
    {
      "type": "html",
      "text": "\nIn C++, of course, new'd objects must be explicitly deleted, but in many cases the RAII idiom can be used to automate this;  the ANSI C++ standard defines an ''auto_ptr\" template to standardize this idiomatic use.",
      "id": "3a63f8b01b5a632d691a8a11b5f0c3e1"
    },
    {
      "type": "html",
      "text": "\nWhile the idiom is particularly elegant for use with lexically-scoped objects, it applies equally to dynamically-allocated, 'semantic lifetime' ones: a new'd File object as described above will hold open the file resources until it is later deleted, at which time it will close the file before the memory actually returns to the heap.  For dynamic-lifetime objects, the 'delete' operation acts as a universal release-your-resources indication.  Since, in a properly-written program you at least need to always release the memory, you can generally rely on that happening.",
      "id": "44d5cbf266f2d9e2d5ed65bb0a1e481f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "<b>[[Lisp Language]]:</b>",
      "id": "dfa5332524a71889f834a77c7fcdf554"
    },
    {
      "type": "html",
      "text": "<i>The Lisp way has been to not use destructors, finalizers, what have you, and to use macros instead.  Therefore...</i>",
      "id": "e1a492e7d52584db30b6018b0b6708f7"
    },
    {
      "type": "code",
      "text": " (with-open-file (file :direction :input)\n  ...)",
      "id": "4cc760730ba2f18f5cb5ba3a65177dc9"
    },
    {
      "type": "html",
      "text": "<i>and come hell or high water, 'file' will be closed when the scope of the 'with-open-file' ends.  Now of course, this won't be sufficient for all uses, but it is just as powerful as the C++ idiom, and you have OPEN and CLOSE for the rest.  One sees this over and over again, whenever you're interested in this kind of discipline: WITH-LOCK, WITH-TRANSACTION, etc.</i>",
      "id": "66c61f423ec0847a75f03f8a850f1c37"
    },
    {
      "type": "html",
      "text": "<i>Note also that these macros are built on top of the standard UNWIND-PROTECT (see [[Unwind Protect]]) form (which basically says \"do this form, then do these cleanup forms no matter what happened during the execution of this stuff\" - not so unlike Java's try/finally would be if you didn't catch anything), so if you invent a new kind of resource you can invent a new WITH-FOO macro to go with it.  You're not limited to whatever someone else thought you'd need</i>",
      "id": "81b61e713340496b9073866fb91c8461"
    },
    {
      "type": "html",
      "text": "\nNo, the Lisp idiom is -- believe it or not -- <i>not</i> as powerful as the C++ idiom. Yes, it is equivalent for the degenerate case when the resource handle does not escape the scope in which it is created. But the C++ idiom allows a much more powerful pattern, where the resource can be passed <i>up</i> the call stack. Consider the following C++:",
      "id": "62d620f64a4f6438a98c1df277426c70"
    },
    {
      "type": "code",
      "text": "  my_file special_file (string name) {\n          my_file file {name};\n          // Initialize the contents of my_file\n          return file;\n  }",
      "id": "13bd5d9ae32d518f43686d73cfa76c0f"
    },
    {
      "type": "code",
      "text": "  void do_stuff () {\n          my_file file = special_file (\"foo\");\n          // ...\n          // file is cleaned up here\n  }",
      "id": "c06dd66611717d20c82012cb9723eb2c"
    },
    {
      "type": "html",
      "text": "\nCalling 'special_file (\"foo\")' will give you an RAII resource unbounded by lexical scope <i>but still guaranteed to be destroyed when the handle is destroyed</i>. Macros derived from UNWIND-PROTECT cannot do this, by design; the cleanup code will be called at the end of the macro form, even if you want the resource to persist beyond the form. (For the curious, 'return file;' does not cause a copy; where NRVO is not performed, it's a move. Regardless, there are ways of implementing RAII-style handles that handle copying gracefully, e.g. with std::shared_ptr.)",
      "id": "e7f6c6b7cc151722d81244f4367fc6c7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "<b>[[Ruby Language]]:</b>",
      "id": "98ae040077b6f439852f21ad7b5290d9"
    },
    {
      "type": "code",
      "text": " File.open('/tmp/file', 'r') do |aFile|\n  process\n  process\n  process\n end",
      "id": "c064b48fa5ab1902aa47e07c08dc8891"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "<b>[[Cee Sharp]]:</b>",
      "id": "5f702279a4625d902d1b4b422ed8a12c"
    },
    {
      "type": "code",
      "text": " using (File f = new File(@\"C:\\foo.txt\")) {  // File must implement System.IDisposable; \n  // do stuff to file                  // not RAII because of necessary 'using' block \n }",
      "id": "d4218c7f5aaee57d2487344c7f0eb8f9"
    },
    {
      "type": "html",
      "text": "<i>compiles to code that looks like it came from...</i>",
      "id": "ed73a248832375f5811607c8d0770d91"
    },
    {
      "type": "html",
      "text": "<b>[[Java Language]]:</b>",
      "id": "c9119709db28b12119df12a2817941d9"
    },
    {
      "type": "html",
      "text": "\nBefore Java 7:",
      "id": "40da61834e4e968deb25f431872d26cb"
    },
    {
      "type": "code",
      "text": " final File f = new File(@\"C:\\foo.txt\");\n try {\n  // do stuff to file\n } finally {\n  f.Dispose()\n }",
      "id": "702ffcfb704cb3dadfd2e06f9ac3a124"
    },
    {
      "type": "html",
      "text": "\nJava 7 and later:",
      "id": "3420efeef2fe34b9d73f4f7387fec6f3"
    },
    {
      "type": "code",
      "text": " try (File f = new File(@\"C:\\foo.txt\")) {\n  // do stuff to file\n }",
      "id": "b740a7bea705faf4c8d4f7e792b9b521"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "<b>[[Perl Language]]:</b>",
      "id": "52d5ba16e7e81a06ad1c114684e75afa"
    },
    {
      "type": "code",
      "text": " {\n  open (my $fh, '<', $file) or die \"Couldn't open $file: $!\";\n  # now read stuff from $fh...\n }",
      "id": "d3e838fef80d3bc8b9a6c76bb698f456"
    },
    {
      "type": "html",
      "text": "<i>$fh goes out of scope, thus destructs, thus closes.  Shweet!</i>",
      "id": "129b7d6edf39d1e6a9870ef76c38f7d5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "One problem with the name [[Resource Acquisition Is Initialization]] is that it is inaccurate: it's not always about resources, and it is nothing to do with initialization -- what makes the idiom tick is finalization. Other than that, the name's fine ;-> For more on this, and a small [[Pattern Language]] for C++ that resolves such paired-action issues, see [[Execute Around Sequences]]. -- [[Kevlin Henney]]",
      "id": "f3e02b9721d75edc69a461d84b1d15cf"
    },
    {
      "type": "html",
      "text": "<i>It is always about resources: things you must give back when you're done -- and it has everything to do with initialization: the whole point of RAII is to encapsulate a resource in an object, with the acquisition of the resource done when the object is constructed. That RAII can be viewed as an example of a broader pattern doesn't mean that RAII isn't RAII.</i>",
      "id": "b0982c4c8b9baf91b016cfe03649ea65"
    },
    {
      "type": "html",
      "text": "\nI think the point is that we don't have a name for that broader pattern, and so we use the term RAII for it. [http://www.boost.org/doc/libs/1_48_0/libs/scope_exit www.boost.org] specifically mentions RAII and resource acquisition even though Boost.[[Scope Exit]] is applicable more generally than solely in resource-management scenarios (e.g. logging the exit from a function). It would be of benefit to all, but particularly novices, to have a more concise, and less opaque term for this pattern than [[Resource Acquisition Is Initialization]]. -- [[Rob Desbois]]",
      "id": "c987d8373fe8a1503bd1c24031cfceb1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "This is one of the few times I have wished [[Smalltalk Language]] had destructors.  The problem with tenured [[Garbage Collection]] algorithms is that you don't get notice when an object is about to die, all you find are object corpses of the John Doe variety.  P.s. for Smalltalk experts, is there a tidy way to handle termination (such as releasing resources=) these days? -- [[Alistair Cockburn]]",
      "id": "d27983c9f0c0ac7c0561939ffe340ef2"
    },
    {
      "type": "html",
      "text": "\nI expect that Smalltalk could use the same \"blocks\" idiom that [[Ruby Language]] uses.  E.g. where a Ruby coder would write a File class that could be used like this:",
      "id": "ad3a70ec580b3f451f57ed85702d5fac"
    },
    {
      "type": "code",
      "text": " File.open(\"filename\") do |stream|\n  ... read from stream ...\n end",
      "id": "fc7d7e372579c3fd455a28d4716593fc"
    },
    {
      "type": "html",
      "text": "a Smalltalk coder could write a File class that could be used like this:",
      "id": "a9d8d222c3e6c89df5a6bced5b28268c"
    },
    {
      "type": "html",
      "text": "File open:<br>\"filename\" do: [ stream |",
      "id": "31c5a3f473cf86a8ebfbdf71265ee209"
    },
    {
      "type": "code",
      "text": "  ... read from stream ...\n ].",
      "id": "f7bba90b026b588e0c6d94d705c4b4d5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "[[Andrei Alexandrescu]] and Petru Marginean introduced the [[Scope Guard]] idiom which is a way of utilizing [[Resource Acquisition Is Initialization]] without having to create new classes for each resource. This provides for a simple way of writing exception safe code. -- [[Kristian Dupont]]",
      "id": "69e69bdd488f8b6d365f3d0927616d0a"
    },
    {
      "type": "html",
      "text": "<i>scope guards map to try/catch/finally (they are explicitly defined as transformations to same)  -- which is an alternative to RAII, not a form of RAII.</i>",
      "id": "0913383ecdae0ed2995ad292d2fe5705"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "One of the important aspects of RAII that is often missed is that of design invariant guarantees.  This shows up most clearly in the design of, say, mutexes.  For example (original Turner example corrected):",
      "id": "b353c99aa8aebcc4465623848c566959"
    },
    {
      "type": "code",
      "text": "  class Mutex {\n  public:\n  class Scoped''''''Lock {\n    Mutex& m_;\n  public:\n    Scoped''''''Lock(Mutex& m): m_(m) { m_.lock(); }\n    ~Scoped''''''Lock() { m_.unlock(); }\n  };",
      "id": "78bacb28f74844dac1a14146d70eac63"
    },
    {
      "type": "code",
      "text": "  Mutex() {}\n  private:\n  void lock();\n  void unlock();\n  friend class Mutex::Scoped''''''Lock;\n  // non-copyable\n  Mutex (const Mutex&);\n  Mutex& operator= (const Mutex&);\n  };",
      "id": "66d9df31d65b40bbe5ac7eb5da1269e4"
    },
    {
      "type": "code",
      "text": "  void foo() {\n    Mutex m;\n    Mutex::Scoped''''''Lock l(m);\n  // ...\n  }",
      "id": "03d5e6ca0b0755876055ecc54df6da27"
    },
    {
      "type": "html",
      "text": "By making the lock() and unlock() methods private, the designer of the Mutex class can guarantee that the mutex will only by operated through the sentry Mutex::Scoped<b></b>Lock class (as this is the only accessible way of locking the mutex).  Thus the design invariant \"for every call to lock() there shall be a corresponding call to unlock()\" is enforced.  Most importantly, the \"correct\" way becomes the \"easy\" way for the user of this class.  Contrast this with \"try/finally\" and \"using\" clauses.",
      "id": "0a8e5c132626c9fe92e5221db7c2f759"
    },
    {
      "type": "html",
      "text": "-- [[David Keith Turner]]",
      "id": "c195d704acb67440f8b407f6ccf6b75c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "The important aspect of RAII is automatic(!!) finalization. Many examples on this page ([[Cee Sharp]]'s using or Alexandrescu's scope guard) are not RAII because they involve manual resource management on every location where they are used. In that sense they are the opposite of RAII.",
      "id": "50b9383e363a48d95a34027a853e773d"
    },
    {
      "type": "html",
      "text": "<i>Sorry, I don't see how RAII implies automatic finalization.  Objects allocated on the stack in local scope have their destructors called automatically, but objects allocated on the heap require manual finalization.  In garbage collected environments destructors may never be called.</i>",
      "id": "0b2878af20124d4ad2da723ee80bb1b3"
    },
    {
      "type": "html",
      "text": "\nObjects allocated on the heap are controlled (released) by a stack object and therefore require no manual finalization. That's the point of RAII. ",
      "id": "0aa1ae2ca59415a66db49a70becebcb5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "<i>Objects allocated on the heap are controlled (released) by a stack object and therefore require no manual finalization. That's the point of RAII. </i>",
      "id": "da224f0a4a14fec3fd483e936a497989"
    },
    {
      "type": "html",
      "text": "\nUntil, that is, you find yourself returning objects (initialized or otherwise) to another function.  Then, RAII breaks down.  The heap exists because not everything can be expressed on the call stack.  --[[Samuel Falvo]]",
      "id": "acc066c31a8fb8135855885dba764228"
    },
    {
      "type": "html",
      "text": "<i>No it doesn't.  Instead of returning a new Foo(), return a shared_ptr<Foo>(new Foo()) from [[Boost Libraries]] or [[Technical Report One]].  RAII still applies because the shared_ptr<T> will only destroy its resource when the last reference to the shared_ptr goes out of scope.</i>",
      "id": "4258ea7a3352156d22bc67511403a8a0"
    },
    {
      "type": "html",
      "text": "\nOr even better, use the <i>polymorphic object</i> idiom, which makes an object containing pointers look like a simple object that can be copied, returned, passed as an argument, etc. This doesn't cost much because the object you are copying is just a reference count and a pointer. Unfortunately, with currently available C++ language features it is a bit of a pain to implement such a type, but I understand that situation should be improved with the 0x standard. -- [[Steve Heller]]",
      "id": "ab08a58af0b89ea861e5c00a1de4fac3"
    },
    {
      "type": "html",
      "text": "Wait, isn't this what shared_ptr<T> is?  How is it different if not?\nThe difference is that polymorphic objects have value semantics, whereas shared_ptr has pointer semantics. -- [[Steve Heller]]",
      "id": "0b083aefd8b16b880da4470e6e094a55"
    },
    {
      "type": "html",
      "text": "This means nothing to me.  Is it possible to rephrase the answer in a more complete way?  Using polymorphic object idiom, it seems you're going to be passing around a \"smart handle\", a pointer + reference count combination.  This is precisely what shared_ptr<> is.  Another thing I thought of while waiting for the answer was, what happens if you have a <i>single</i> object you're referencing, but <i>multiple</i> shared_ptr<> / polymorphic objects, particularly in different threads, for example?  This seems like it'd break the system, as if one thread's reference count drops to zero, the object is disposed, despite live references from other threads.  The reference count really does have to be associated with the <i>object</i>, not its reference.  The reference itself, however, can be smart enough to automatically adjust it as needed. --[[Samuel Falvo]]",
      "id": "e24e9afd1ce4191c6dfb9a3ebffaf705"
    },
    {
      "type": "html",
      "text": "Indeed this \"difference\" does not exist and is nonsensical -- shared_ptr is a used as a value, which is <b>convertible</b> to a pointer type, namely the type of the pointer it contains. 0x (now C++11) is irrelevant ... it has move semantics, which allows unique_ptr (no reference count, it's transferred between owners).''",
      "id": "3748ce29e35a62dd7a1a3fc923fb6ee6"
    },
    {
      "type": "html",
      "text": "\nI wasn't aware of the shared_ptr type; I checked [http://www.boost.org/boost/shared_ptr.hpp www.boost.org] and see that it implements a reference-counted wrapper around the object.  A pretty slick workaround to the problem, but one which appears to be very high overhead.  Use it sparingly if you're even remotely concerned about performance.  --[[Samuel Falvo]]",
      "id": "f467d2484f851d55a5ad53df58c07658"
    },
    {
      "type": "html",
      "text": "\nThe overhead is lower than you might expect, and a number of optimizations are available if you're concerned about extra indirection; the big cost is the extra heap allocation to carry the reference counts, and even that can be avoided if one is willing to utilize an invasive solution (i.e. adding reference counts directly to the object).  Your advice, I think, is a little extreme.  I'd suggest, instead: \"don't hesitate to use it except where performance is a primary concern.\"  You won't often be attempting <i>resource acquisition</i> within a tight inner-loop.  Resist [[Premature Optimization]].",
      "id": "8cf3af7fa83d2b8f63f90fe6a8af4407"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "Contributors: [[Jim Perry]], [[Alistair Cockburn]], [[Graham Hughes]], [[Tom Anderson]], [[Nathan Sharfi]], [[John Douglas Porter]], [[Dirck Blaskey]], [[Kevlin Henney]], [[John Allensworth]]",
      "id": "e95920d2e7de2597ce70e86334d7ce86"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "See also: [[Resource Acquisition Is Invocation]], [[Initialization Is Resource Acquisition]], [[Forget To Close The File]], [[Cee Plus Plus Idioms]]",
      "id": "b070049ba8f78a09c871d7c8dc85c35a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c4a2e7b436d3808a50b10b4b5a122e23"
    },
    {
      "type": "html",
      "text": "[[Category Cpp]]",
      "id": "7f264f60c2770896f110bfdb8fa098a1"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ResourceAcquisitionIsInitialization c2.com]",
      "id": "fa88bb21ac6f0b4efc20c20070f88169"
    }
  ],
  "journal": [
    {
      "date": 1392142381000,
      "id": "2b4ea91238c3517c79381be5e93fa938",
      "type": "create",
      "item": {
        "title": "Resource Acquisition Is Initialization",
        "story": [
          {
            "type": "html",
            "text": "This [[Cee Plus Plus]] idiom ([[Resource Acquisition Is Initialization]] or RAII) relies on the life-cycle of objects: constructors called to initialize the object, and a destructor called when it goes away.  Objects are usually created either automatically in a local scope, in which case they are destroyed when the scope is exited (via normal flow, return, or exception), or they can be created with \"new\" in which case they are destroyed by an explicit \"delete\" (which is not RAII). ",
            "id": "025f85631052c980407158ea2ee07c20"
          },
          {
            "type": "html",
            "text": "<i>(Not to be confused with RIAA - [[Recording Industry Association Of America]].  RAII isn't evil.)</i>",
            "id": "c52d14734508811238607f58d6fb9de4"
          },
          {
            "type": "html",
            "text": "\nIf the resource in question (a file, lock, window, etc.) is acquired (opened, locked, created) in a constructor, and released (closed, unlocked, disposed) in the destructor, then the use of the resource is tied to the lifetime of the object.  Since object lifetimes are well-defined, so is the use of the resource.  Local objects can be used particularly elegantly:",
            "id": "a2a1751e11013f385718aa6bdc244d61"
          },
          {
            "type": "code",
            "text": " {\n  File f(\"/some/path/name\");\n  // use f\n }",
            "id": "2720d4a1bf6ba6b0ced366dd8c284ab8"
          },
          {
            "type": "html",
            "text": "Here, assuming the class File opens a named file upon construction and closes it upon destruction, this section of code will open a file (or throw an exception), do whatever it cares to in the \"use f\" section, and then close it.  It is common to use this idiom to simply wrap the resource use itself, e.g. given a Mutex class with lock() and unlock() methods, a RAII class Mutex<b></b>Lock can be written whose constructor lock()s (and remembers) some Mutex and whose destructor unlock()s it; then one can write code like: ",
            "id": "6afcf12645011a8dcf13e8038d6d1e3a"
          },
          {
            "type": "code",
            "text": " {\n  Mutex''''''Lock l1(mutex1);\n  Mutex''''''Lock l2(mutex2);\n  // critical section\n }",
            "id": "a887c2b73e5e80c8b71c09db5f5d91a0"
          },
          {
            "type": "html",
            "text": "Since destruction is in the reverse order of construction, this produces the right semantics, for mutexes as for many other resources.  Note, you have to be very careful that the object you use for a mutex still exists at the end of the function, otherwise things get very messy, very quickly.",
            "id": "7f425e834717d015dff962c673a199eb"
          },
          {
            "type": "html",
            "text": "\nIn C++, of course, new'd objects must be explicitly deleted, but in many cases the RAII idiom can be used to automate this;  the ANSI C++ standard defines an ''auto_ptr\" template to standardize this idiomatic use.",
            "id": "3a63f8b01b5a632d691a8a11b5f0c3e1"
          },
          {
            "type": "html",
            "text": "\nWhile the idiom is particularly elegant for use with lexically-scoped objects, it applies equally to dynamically-allocated, 'semantic lifetime' ones: a new'd File object as described above will hold open the file resources until it is later deleted, at which time it will close the file before the memory actually returns to the heap.  For dynamic-lifetime objects, the 'delete' operation acts as a universal release-your-resources indication.  Since, in a properly-written program you at least need to always release the memory, you can generally rely on that happening.",
            "id": "44d5cbf266f2d9e2d5ed65bb0a1e481f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "<b>[[Lisp Language]]:</b>",
            "id": "dfa5332524a71889f834a77c7fcdf554"
          },
          {
            "type": "html",
            "text": "<i>The Lisp way has been to not use destructors, finalizers, what have you, and to use macros instead.  Therefore...</i>",
            "id": "e1a492e7d52584db30b6018b0b6708f7"
          },
          {
            "type": "code",
            "text": " (with-open-file (file :direction :input)\n  ...)",
            "id": "4cc760730ba2f18f5cb5ba3a65177dc9"
          },
          {
            "type": "html",
            "text": "<i>and come hell or high water, 'file' will be closed when the scope of the 'with-open-file' ends.  Now of course, this won't be sufficient for all uses, but it is just as powerful as the C++ idiom, and you have OPEN and CLOSE for the rest.  One sees this over and over again, whenever you're interested in this kind of discipline: WITH-LOCK, WITH-TRANSACTION, etc.</i>",
            "id": "66c61f423ec0847a75f03f8a850f1c37"
          },
          {
            "type": "html",
            "text": "<i>Note also that these macros are built on top of the standard UNWIND-PROTECT (see [[Unwind Protect]]) form (which basically says \"do this form, then do these cleanup forms no matter what happened during the execution of this stuff\" - not so unlike Java's try/finally would be if you didn't catch anything), so if you invent a new kind of resource you can invent a new WITH-FOO macro to go with it.  You're not limited to whatever someone else thought you'd need</i>",
            "id": "81b61e713340496b9073866fb91c8461"
          },
          {
            "type": "html",
            "text": "\nNo, the Lisp idiom is -- believe it or not -- <i>not</i> as powerful as the C++ idiom. Yes, it is equivalent for the degenerate case when the resource handle does not escape the scope in which it is created. But the C++ idiom allows a much more powerful pattern, where the resource can be passed <i>up</i> the call stack. Consider the following C++:",
            "id": "62d620f64a4f6438a98c1df277426c70"
          },
          {
            "type": "code",
            "text": "  my_file special_file (string name) {\n          my_file file {name};\n          // Initialize the contents of my_file\n          return file;\n  }",
            "id": "13bd5d9ae32d518f43686d73cfa76c0f"
          },
          {
            "type": "code",
            "text": "  void do_stuff () {\n          my_file file = special_file (\"foo\");\n          // ...\n          // file is cleaned up here\n  }",
            "id": "c06dd66611717d20c82012cb9723eb2c"
          },
          {
            "type": "html",
            "text": "\nCalling 'special_file (\"foo\")' will give you an RAII resource unbounded by lexical scope <i>but still guaranteed to be destroyed when the handle is destroyed</i>. Macros derived from UNWIND-PROTECT cannot do this, by design; the cleanup code will be called at the end of the macro form, even if you want the resource to persist beyond the form. (For the curious, 'return file;' does not cause a copy; where NRVO is not performed, it's a move. Regardless, there are ways of implementing RAII-style handles that handle copying gracefully, e.g. with std::shared_ptr.)",
            "id": "e7f6c6b7cc151722d81244f4367fc6c7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "<b>[[Ruby Language]]:</b>",
            "id": "98ae040077b6f439852f21ad7b5290d9"
          },
          {
            "type": "code",
            "text": " File.open('/tmp/file', 'r') do |aFile|\n  process\n  process\n  process\n end",
            "id": "c064b48fa5ab1902aa47e07c08dc8891"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "<b>[[Cee Sharp]]:</b>",
            "id": "5f702279a4625d902d1b4b422ed8a12c"
          },
          {
            "type": "code",
            "text": " using (File f = new File(@\"C:\\foo.txt\")) {  // File must implement System.IDisposable; \n  // do stuff to file                  // not RAII because of necessary 'using' block \n }",
            "id": "d4218c7f5aaee57d2487344c7f0eb8f9"
          },
          {
            "type": "html",
            "text": "<i>compiles to code that looks like it came from...</i>",
            "id": "ed73a248832375f5811607c8d0770d91"
          },
          {
            "type": "html",
            "text": "<b>[[Java Language]]:</b>",
            "id": "c9119709db28b12119df12a2817941d9"
          },
          {
            "type": "html",
            "text": "\nBefore Java 7:",
            "id": "40da61834e4e968deb25f431872d26cb"
          },
          {
            "type": "code",
            "text": " final File f = new File(@\"C:\\foo.txt\");\n try {\n  // do stuff to file\n } finally {\n  f.Dispose()\n }",
            "id": "702ffcfb704cb3dadfd2e06f9ac3a124"
          },
          {
            "type": "html",
            "text": "\nJava 7 and later:",
            "id": "3420efeef2fe34b9d73f4f7387fec6f3"
          },
          {
            "type": "code",
            "text": " try (File f = new File(@\"C:\\foo.txt\")) {\n  // do stuff to file\n }",
            "id": "b740a7bea705faf4c8d4f7e792b9b521"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "<b>[[Perl Language]]:</b>",
            "id": "52d5ba16e7e81a06ad1c114684e75afa"
          },
          {
            "type": "code",
            "text": " {\n  open (my $fh, '<', $file) or die \"Couldn't open $file: $!\";\n  # now read stuff from $fh...\n }",
            "id": "d3e838fef80d3bc8b9a6c76bb698f456"
          },
          {
            "type": "html",
            "text": "<i>$fh goes out of scope, thus destructs, thus closes.  Shweet!</i>",
            "id": "129b7d6edf39d1e6a9870ef76c38f7d5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "One problem with the name [[Resource Acquisition Is Initialization]] is that it is inaccurate: it's not always about resources, and it is nothing to do with initialization -- what makes the idiom tick is finalization. Other than that, the name's fine ;-> For more on this, and a small [[Pattern Language]] for C++ that resolves such paired-action issues, see [[Execute Around Sequences]]. -- [[Kevlin Henney]]",
            "id": "f3e02b9721d75edc69a461d84b1d15cf"
          },
          {
            "type": "html",
            "text": "<i>It is always about resources: things you must give back when you're done -- and it has everything to do with initialization: the whole point of RAII is to encapsulate a resource in an object, with the acquisition of the resource done when the object is constructed. That RAII can be viewed as an example of a broader pattern doesn't mean that RAII isn't RAII.</i>",
            "id": "b0982c4c8b9baf91b016cfe03649ea65"
          },
          {
            "type": "html",
            "text": "\nI think the point is that we don't have a name for that broader pattern, and so we use the term RAII for it. [http://www.boost.org/doc/libs/1_48_0/libs/scope_exit www.boost.org] specifically mentions RAII and resource acquisition even though Boost.[[Scope Exit]] is applicable more generally than solely in resource-management scenarios (e.g. logging the exit from a function). It would be of benefit to all, but particularly novices, to have a more concise, and less opaque term for this pattern than [[Resource Acquisition Is Initialization]]. -- [[Rob Desbois]]",
            "id": "c987d8373fe8a1503bd1c24031cfceb1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "This is one of the few times I have wished [[Smalltalk Language]] had destructors.  The problem with tenured [[Garbage Collection]] algorithms is that you don't get notice when an object is about to die, all you find are object corpses of the John Doe variety.  P.s. for Smalltalk experts, is there a tidy way to handle termination (such as releasing resources=) these days? -- [[Alistair Cockburn]]",
            "id": "d27983c9f0c0ac7c0561939ffe340ef2"
          },
          {
            "type": "html",
            "text": "\nI expect that Smalltalk could use the same \"blocks\" idiom that [[Ruby Language]] uses.  E.g. where a Ruby coder would write a File class that could be used like this:",
            "id": "ad3a70ec580b3f451f57ed85702d5fac"
          },
          {
            "type": "code",
            "text": " File.open(\"filename\") do |stream|\n  ... read from stream ...\n end",
            "id": "fc7d7e372579c3fd455a28d4716593fc"
          },
          {
            "type": "html",
            "text": "a Smalltalk coder could write a File class that could be used like this:",
            "id": "a9d8d222c3e6c89df5a6bced5b28268c"
          },
          {
            "type": "html",
            "text": "File open:<br>\"filename\" do: [ stream |",
            "id": "31c5a3f473cf86a8ebfbdf71265ee209"
          },
          {
            "type": "code",
            "text": "  ... read from stream ...\n ].",
            "id": "f7bba90b026b588e0c6d94d705c4b4d5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "[[Andrei Alexandrescu]] and Petru Marginean introduced the [[Scope Guard]] idiom which is a way of utilizing [[Resource Acquisition Is Initialization]] without having to create new classes for each resource. This provides for a simple way of writing exception safe code. -- [[Kristian Dupont]]",
            "id": "69e69bdd488f8b6d365f3d0927616d0a"
          },
          {
            "type": "html",
            "text": "<i>scope guards map to try/catch/finally (they are explicitly defined as transformations to same)  -- which is an alternative to RAII, not a form of RAII.</i>",
            "id": "0913383ecdae0ed2995ad292d2fe5705"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "One of the important aspects of RAII that is often missed is that of design invariant guarantees.  This shows up most clearly in the design of, say, mutexes.  For example (original Turner example corrected):",
            "id": "b353c99aa8aebcc4465623848c566959"
          },
          {
            "type": "code",
            "text": "  class Mutex {\n  public:\n  class Scoped''''''Lock {\n    Mutex& m_;\n  public:\n    Scoped''''''Lock(Mutex& m): m_(m) { m_.lock(); }\n    ~Scoped''''''Lock() { m_.unlock(); }\n  };",
            "id": "78bacb28f74844dac1a14146d70eac63"
          },
          {
            "type": "code",
            "text": "  Mutex() {}\n  private:\n  void lock();\n  void unlock();\n  friend class Mutex::Scoped''''''Lock;\n  // non-copyable\n  Mutex (const Mutex&);\n  Mutex& operator= (const Mutex&);\n  };",
            "id": "66d9df31d65b40bbe5ac7eb5da1269e4"
          },
          {
            "type": "code",
            "text": "  void foo() {\n    Mutex m;\n    Mutex::Scoped''''''Lock l(m);\n  // ...\n  }",
            "id": "03d5e6ca0b0755876055ecc54df6da27"
          },
          {
            "type": "html",
            "text": "By making the lock() and unlock() methods private, the designer of the Mutex class can guarantee that the mutex will only by operated through the sentry Mutex::Scoped<b></b>Lock class (as this is the only accessible way of locking the mutex).  Thus the design invariant \"for every call to lock() there shall be a corresponding call to unlock()\" is enforced.  Most importantly, the \"correct\" way becomes the \"easy\" way for the user of this class.  Contrast this with \"try/finally\" and \"using\" clauses.",
            "id": "0a8e5c132626c9fe92e5221db7c2f759"
          },
          {
            "type": "html",
            "text": "-- [[David Keith Turner]]",
            "id": "c195d704acb67440f8b407f6ccf6b75c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "The important aspect of RAII is automatic(!!) finalization. Many examples on this page ([[Cee Sharp]]'s using or Alexandrescu's scope guard) are not RAII because they involve manual resource management on every location where they are used. In that sense they are the opposite of RAII.",
            "id": "50b9383e363a48d95a34027a853e773d"
          },
          {
            "type": "html",
            "text": "<i>Sorry, I don't see how RAII implies automatic finalization.  Objects allocated on the stack in local scope have their destructors called automatically, but objects allocated on the heap require manual finalization.  In garbage collected environments destructors may never be called.</i>",
            "id": "0b2878af20124d4ad2da723ee80bb1b3"
          },
          {
            "type": "html",
            "text": "\nObjects allocated on the heap are controlled (released) by a stack object and therefore require no manual finalization. That's the point of RAII. ",
            "id": "0aa1ae2ca59415a66db49a70becebcb5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "<i>Objects allocated on the heap are controlled (released) by a stack object and therefore require no manual finalization. That's the point of RAII. </i>",
            "id": "da224f0a4a14fec3fd483e936a497989"
          },
          {
            "type": "html",
            "text": "\nUntil, that is, you find yourself returning objects (initialized or otherwise) to another function.  Then, RAII breaks down.  The heap exists because not everything can be expressed on the call stack.  --[[Samuel Falvo]]",
            "id": "acc066c31a8fb8135855885dba764228"
          },
          {
            "type": "html",
            "text": "<i>No it doesn't.  Instead of returning a new Foo(), return a shared_ptr<Foo>(new Foo()) from [[Boost Libraries]] or [[Technical Report One]].  RAII still applies because the shared_ptr<T> will only destroy its resource when the last reference to the shared_ptr goes out of scope.</i>",
            "id": "4258ea7a3352156d22bc67511403a8a0"
          },
          {
            "type": "html",
            "text": "\nOr even better, use the <i>polymorphic object</i> idiom, which makes an object containing pointers look like a simple object that can be copied, returned, passed as an argument, etc. This doesn't cost much because the object you are copying is just a reference count and a pointer. Unfortunately, with currently available C++ language features it is a bit of a pain to implement such a type, but I understand that situation should be improved with the 0x standard. -- [[Steve Heller]]",
            "id": "ab08a58af0b89ea861e5c00a1de4fac3"
          },
          {
            "type": "html",
            "text": "Wait, isn't this what shared_ptr<T> is?  How is it different if not?\nThe difference is that polymorphic objects have value semantics, whereas shared_ptr has pointer semantics. -- [[Steve Heller]]",
            "id": "0b083aefd8b16b880da4470e6e094a55"
          },
          {
            "type": "html",
            "text": "This means nothing to me.  Is it possible to rephrase the answer in a more complete way?  Using polymorphic object idiom, it seems you're going to be passing around a \"smart handle\", a pointer + reference count combination.  This is precisely what shared_ptr<> is.  Another thing I thought of while waiting for the answer was, what happens if you have a <i>single</i> object you're referencing, but <i>multiple</i> shared_ptr<> / polymorphic objects, particularly in different threads, for example?  This seems like it'd break the system, as if one thread's reference count drops to zero, the object is disposed, despite live references from other threads.  The reference count really does have to be associated with the <i>object</i>, not its reference.  The reference itself, however, can be smart enough to automatically adjust it as needed. --[[Samuel Falvo]]",
            "id": "e24e9afd1ce4191c6dfb9a3ebffaf705"
          },
          {
            "type": "html",
            "text": "Indeed this \"difference\" does not exist and is nonsensical -- shared_ptr is a used as a value, which is <b>convertible</b> to a pointer type, namely the type of the pointer it contains. 0x (now C++11) is irrelevant ... it has move semantics, which allows unique_ptr (no reference count, it's transferred between owners).''",
            "id": "3748ce29e35a62dd7a1a3fc923fb6ee6"
          },
          {
            "type": "html",
            "text": "\nI wasn't aware of the shared_ptr type; I checked [http://www.boost.org/boost/shared_ptr.hpp www.boost.org] and see that it implements a reference-counted wrapper around the object.  A pretty slick workaround to the problem, but one which appears to be very high overhead.  Use it sparingly if you're even remotely concerned about performance.  --[[Samuel Falvo]]",
            "id": "f467d2484f851d55a5ad53df58c07658"
          },
          {
            "type": "html",
            "text": "\nThe overhead is lower than you might expect, and a number of optimizations are available if you're concerned about extra indirection; the big cost is the extra heap allocation to carry the reference counts, and even that can be avoided if one is willing to utilize an invasive solution (i.e. adding reference counts directly to the object).  Your advice, I think, is a little extreme.  I'd suggest, instead: \"don't hesitate to use it except where performance is a primary concern.\"  You won't often be attempting <i>resource acquisition</i> within a tight inner-loop.  Resist [[Premature Optimization]].",
            "id": "8cf3af7fa83d2b8f63f90fe6a8af4407"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "Contributors: [[Jim Perry]], [[Alistair Cockburn]], [[Graham Hughes]], [[Tom Anderson]], [[Nathan Sharfi]], [[John Douglas Porter]], [[Dirck Blaskey]], [[Kevlin Henney]], [[John Allensworth]]",
            "id": "e95920d2e7de2597ce70e86334d7ce86"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "See also: [[Resource Acquisition Is Invocation]], [[Initialization Is Resource Acquisition]], [[Forget To Close The File]], [[Cee Plus Plus Idioms]]",
            "id": "b070049ba8f78a09c871d7c8dc85c35a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c4a2e7b436d3808a50b10b4b5a122e23"
          },
          {
            "type": "html",
            "text": "[[Category Cpp]]",
            "id": "7f264f60c2770896f110bfdb8fa098a1"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ResourceAcquisitionIsInitialization c2.com]",
            "id": "fa88bb21ac6f0b4efc20c20070f88169"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1628112707018
    }
  ]
}