{
  "title": "Session",
  "story": [
    {
      "type": "markdown",
      "id": "51603a7947a7ef8d",
      "text": "When you launch a [[Croquet]] application, you automatically join a shared session. As long as you're in the session, your models will be identical to the models of every other user in the session. [https://croquet.io/docs/croquet/#main-concepts page], [https://croquet.io/docs/croquet/Session.html page]"
    },
    {
      "type": "pagefold",
      "id": "78edc367a4192376",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "479f34ea1a2e3b2f",
      "text": "If you're building an interactive game, the core experience of the application will likely be on a single route for most of the session. Serving the page with initial data from your [[Elm Backend]] in an elm-pages app would have neglible benefit, especially for loading the kinds of larger assets that are used in games. [https://elm-pages.com/docs/what-is-elm-pages/#what's-not-a-good-fit-for-elm-pages? page]"
    },
    {
      "type": "pagefold",
      "id": "40bdeee7a276c5ae",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "507dbc44dc3c1b2b",
      "text": "Joins a session by instantiating the root model (for a new session) or resuming from a snapshot, then constructs the view root instance. [https://croquet.io/docs/croquet/Session.html page]"
    },
    {
      "type": "markdown",
      "id": "2490500ff4f389b4",
      "text": "The appId identifies each Croquet app. It must be a globally unique identifier following the Android convention, e.g. \"com.example.myapp\". Each dot-separated segment must start with a letter, and only letters, digits, and underscores are allowed.\n\nThe session name identifies individual sessions within an app. You can use it for example to create different sessions for different users. That is, a user in session \"ABC\" will not see a user in \"DEF\". One simple way to create unique sessions is via Croquet.App.autoSession() which will use or generate a random name in the query part (?...) of the current url. (If you use a constant, then all users will end up in the same session. This is what we do in some of our tutorials for simplicity, but actual apps should manage sessions.)\n\nThe session password is used for end-to-end encryption of all data leaving the client. If your app does not need to protect user data, you will still have to provide a constant dummy password. One simple way to have individual passwords is via Croquet.App.autoPassword() which will use or generate a random password in the hash part (#...) of the current url.\n\nA session id is created from the given session name, and a hash of all the registered Model classes and Constants. This ensures that only users running the exact same source code end up in the same session, which is a prerequisite for perfectly replicated computation.\n\nThe session id is used to connect to a reflector. If there is no ongoing session, an instance of the model class is created (which in turn typically creates a number of submodels). Otherwise, the previously stored modelRoot is deserialized from the snapshot, along with all additional models.\n\nThat root model instance is passed to the constructor of your root view class. The root view should set up the input and output operations of your application, and create any additional views as to match the application state as found in the models.\n\nThen the Croquet main loop is started (unless you pass in a step: \"manual\" parameter, e.g. for WebXR, see example below). This uses requestAnimationFrame() for continuous updating. Each step of the main loop executes in three phases:"
    },
    {
      "type": "markdown",
      "id": "c1651cf1e901ef88",
      "text": "[[Simulation]]: the models execute the events received via the reflector, and the future messages up to the latest time stamp received from the reflector. The events generated in this phase are put in a queue for the views to consume."
    },
    {
      "type": "markdown",
      "id": "511138a21dccc32c",
      "text": "Event Processing: the queued events are processed by calling the view's event handlers. The views typically use these events to modify some view state, e.g. moving a DOM element or setting some attribute of a Three.js object."
    },
    {
      "type": "markdown",
      "id": "8c3b5354218a9f1a",
      "text": "Updating/Rendering: The view root's update() method is called after all the queued events have been processed. In some applications, the update method will do nothing (e.g. DOM elements are rendered after returning control to the browser). When using other UI frameworks (e.g. Three.js), this is the place to perform the actual rendering. Also, polling input and other tasks that should happen in every frame should be placed here."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Session",
        "story": []
      },
      "date": 1655032149817
    },
    {
      "item": {
        "type": "factory",
        "id": "51603a7947a7ef8d"
      },
      "id": "51603a7947a7ef8d",
      "type": "add",
      "date": 1655032151134
    },
    {
      "type": "edit",
      "id": "51603a7947a7ef8d",
      "item": {
        "type": "paragraph",
        "id": "51603a7947a7ef8d",
        "text": "– https://croquet.io/docs/croquet/Session.html"
      },
      "date": 1655032153739
    },
    {
      "type": "edit",
      "id": "51603a7947a7ef8d",
      "item": {
        "type": "markdown",
        "id": "51603a7947a7ef8d",
        "text": "– https://croquet.io/docs/croquet/Session.html"
      },
      "date": 1655032154817
    },
    {
      "type": "edit",
      "id": "51603a7947a7ef8d",
      "item": {
        "type": "markdown",
        "id": "51603a7947a7ef8d",
        "text": "Join a Croquet session. – https://croquet.io/docs/croquet/Session.html"
      },
      "date": 1655032169837
    },
    {
      "item": {
        "type": "factory",
        "id": "507dbc44dc3c1b2b"
      },
      "id": "507dbc44dc3c1b2b",
      "type": "add",
      "after": "51603a7947a7ef8d",
      "date": 1655032192235
    },
    {
      "type": "edit",
      "id": "507dbc44dc3c1b2b",
      "item": {
        "type": "markdown",
        "id": "507dbc44dc3c1b2b",
        "text": "Joins a session by instantiating the root model (for a new session) or resuming from a snapshot, then constructs the view root instance.\n\nThe appId identifies each Croquet app. It must be a globally unique identifier following the Android convention, e.g. \"com.example.myapp\". Each dot-separated segment must start with a letter, and only letters, digits, and underscores are allowed.\n\nThe session name identifies individual sessions within an app. You can use it for example to create different sessions for different users. That is, a user in session \"ABC\" will not see a user in \"DEF\". One simple way to create unique sessions is via Croquet.App.autoSession() which will use or generate a random name in the query part (?...) of the current url. (If you use a constant, then all users will end up in the same session. This is what we do in some of our tutorials for simplicity, but actual apps should manage sessions.)\n\nThe session password is used for end-to-end encryption of all data leaving the client. If your app does not need to protect user data, you will still have to provide a constant dummy password. One simple way to have individual passwords is via Croquet.App.autoPassword() which will use or generate a random password in the hash part (#...) of the current url.\n\nA session id is created from the given session name, and a hash of all the registered Model classes and Constants. This ensures that only users running the exact same source code end up in the same session, which is a prerequisite for perfectly replicated computation.\n\nThe session id is used to connect to a reflector. If there is no ongoing session, an instance of the model class is created (which in turn typically creates a number of submodels). Otherwise, the previously stored modelRoot is deserialized from the snapshot, along with all additional models.\n\nThat root model instance is passed to the constructor of your root view class. The root view should set up the input and output operations of your application, and create any additional views as to match the application state as found in the models.\n\nThen the Croquet main loop is started (unless you pass in a step: \"manual\" parameter, e.g. for WebXR, see example below). This uses requestAnimationFrame() for continuous updating. Each step of the main loop executes in three phases:\n\nSimulation: the models execute the events received via the reflector, and the future messages up to the latest time stamp received from the reflector. The events generated in this phase are put in a queue for the views to consume.\nEvent Processing: the queued events are processed by calling the view's event handlers. The views typically use these events to modify some view state, e.g. moving a DOM element or setting some attribute of a Three.js object.\nUpdating/Rendering: The view root's update() method is called after all the queued events have been processed. In some applications, the update method will do nothing (e.g. DOM elements are rendered after returning control to the browser). When using other UI frameworks (e.g. Three.js), this is the place to perform the actual rendering. Also, polling input and other tasks that should happen in every frame should be placed here."
      },
      "date": 1655032193757
    },
    {
      "type": "edit",
      "id": "51603a7947a7ef8d",
      "item": {
        "type": "markdown",
        "id": "51603a7947a7ef8d",
        "text": "When you launch a Croquet application, you automatically join a shared session. As long as you're in the session, your models will be identical to the models of every other user in the session."
      },
      "date": 1692261886786
    },
    {
      "type": "add",
      "id": "fb9e91013791af96",
      "item": {
        "type": "markdown",
        "id": "fb9e91013791af96",
        "text": "Join a Croquet session. – https://croquet.io/docs/croquet/Session.html"
      },
      "after": "51603a7947a7ef8d",
      "date": 1692261889549
    },
    {
      "type": "edit",
      "id": "51603a7947a7ef8d",
      "item": {
        "type": "markdown",
        "id": "51603a7947a7ef8d",
        "text": "When you launch a Croquet application, you automatically join a shared session. As long as you're in the session, your models will be identical to the models of every other user in the session. [https://croquet.io/docs/croquet/#main-concepts page]"
      },
      "date": 1692261896012
    },
    {
      "type": "edit",
      "id": "51603a7947a7ef8d",
      "item": {
        "type": "markdown",
        "id": "51603a7947a7ef8d",
        "text": "When you launch a [[Croquet]] application, you automatically join a shared session. As long as you're in the session, your models will be identical to the models of every other user in the session. [https://croquet.io/docs/croquet/#main-concepts page]"
      },
      "date": 1692261902277
    },
    {
      "type": "edit",
      "id": "51603a7947a7ef8d",
      "item": {
        "type": "markdown",
        "id": "51603a7947a7ef8d",
        "text": "When you launch a [[Croquet]] application, you automatically join a shared session. As long as you're in the session, your models will be identical to the models of every other user in the session. [https://croquet.io/docs/croquet/#main-concepts page], [https://croquet.io/docs/croquet/Session.html page]"
      },
      "date": 1692261917940
    },
    {
      "type": "remove",
      "id": "fb9e91013791af96",
      "date": 1692261933025
    },
    {
      "type": "edit",
      "id": "507dbc44dc3c1b2b",
      "item": {
        "type": "markdown",
        "id": "507dbc44dc3c1b2b",
        "text": "Joins a session by instantiating the root model (for a new session) or resuming from a snapshot, then constructs the view root instance. [https://croquet.io/docs/croquet/Session.html page]"
      },
      "date": 1692261957100
    },
    {
      "type": "add",
      "id": "2490500ff4f389b4",
      "item": {
        "type": "markdown",
        "id": "2490500ff4f389b4",
        "text": "The appId identifies each Croquet app. It must be a globally unique identifier following the Android convention, e.g. \"com.example.myapp\". Each dot-separated segment must start with a letter, and only letters, digits, and underscores are allowed.\n\nThe session name identifies individual sessions within an app. You can use it for example to create different sessions for different users. That is, a user in session \"ABC\" will not see a user in \"DEF\". One simple way to create unique sessions is via Croquet.App.autoSession() which will use or generate a random name in the query part (?...) of the current url. (If you use a constant, then all users will end up in the same session. This is what we do in some of our tutorials for simplicity, but actual apps should manage sessions.)\n\nThe session password is used for end-to-end encryption of all data leaving the client. If your app does not need to protect user data, you will still have to provide a constant dummy password. One simple way to have individual passwords is via Croquet.App.autoPassword() which will use or generate a random password in the hash part (#...) of the current url.\n\nA session id is created from the given session name, and a hash of all the registered Model classes and Constants. This ensures that only users running the exact same source code end up in the same session, which is a prerequisite for perfectly replicated computation.\n\nThe session id is used to connect to a reflector. If there is no ongoing session, an instance of the model class is created (which in turn typically creates a number of submodels). Otherwise, the previously stored modelRoot is deserialized from the snapshot, along with all additional models.\n\nThat root model instance is passed to the constructor of your root view class. The root view should set up the input and output operations of your application, and create any additional views as to match the application state as found in the models.\n\nThen the Croquet main loop is started (unless you pass in a step: \"manual\" parameter, e.g. for WebXR, see example below). This uses requestAnimationFrame() for continuous updating. Each step of the main loop executes in three phases:\n\nSimulation: the models execute the events received via the reflector, and the future messages up to the latest time stamp received from the reflector. The events generated in this phase are put in a queue for the views to consume.\nEvent Processing: the queued events are processed by calling the view's event handlers. The views typically use these events to modify some view state, e.g. moving a DOM element or setting some attribute of a Three.js object.\nUpdating/Rendering: The view root's update() method is called after all the queued events have been processed. In some applications, the update method will do nothing (e.g. DOM elements are rendered after returning control to the browser). When using other UI frameworks (e.g. Three.js), this is the place to perform the actual rendering. Also, polling input and other tasks that should happen in every frame should be placed here."
      },
      "after": "507dbc44dc3c1b2b",
      "date": 1692261958479
    },
    {
      "type": "edit",
      "id": "2490500ff4f389b4",
      "item": {
        "type": "markdown",
        "id": "2490500ff4f389b4",
        "text": "The appId identifies each Croquet app. It must be a globally unique identifier following the Android convention, e.g. \"com.example.myapp\". Each dot-separated segment must start with a letter, and only letters, digits, and underscores are allowed.\n\nThe session name identifies individual sessions within an app. You can use it for example to create different sessions for different users. That is, a user in session \"ABC\" will not see a user in \"DEF\". One simple way to create unique sessions is via Croquet.App.autoSession() which will use or generate a random name in the query part (?...) of the current url. (If you use a constant, then all users will end up in the same session. This is what we do in some of our tutorials for simplicity, but actual apps should manage sessions.)\n\nThe session password is used for end-to-end encryption of all data leaving the client. If your app does not need to protect user data, you will still have to provide a constant dummy password. One simple way to have individual passwords is via Croquet.App.autoPassword() which will use or generate a random password in the hash part (#...) of the current url.\n\nA session id is created from the given session name, and a hash of all the registered Model classes and Constants. This ensures that only users running the exact same source code end up in the same session, which is a prerequisite for perfectly replicated computation.\n\nThe session id is used to connect to a reflector. If there is no ongoing session, an instance of the model class is created (which in turn typically creates a number of submodels). Otherwise, the previously stored modelRoot is deserialized from the snapshot, along with all additional models.\n\nThat root model instance is passed to the constructor of your root view class. The root view should set up the input and output operations of your application, and create any additional views as to match the application state as found in the models.\n\nThen the Croquet main loop is started (unless you pass in a step: \"manual\" parameter, e.g. for WebXR, see example below). This uses requestAnimationFrame() for continuous updating. Each step of the main loop executes in three phases:"
      },
      "date": 1692262127315
    },
    {
      "type": "add",
      "id": "c1651cf1e901ef88",
      "item": {
        "type": "markdown",
        "id": "c1651cf1e901ef88",
        "text": "[[Simulation]]: the models execute the events received via the reflector, and the future messages up to the latest time stamp received from the reflector. The events generated in this phase are put in a queue for the views to consume.\nEvent Processing: the queued events are processed by calling the view's event handlers. The views typically use these events to modify some view state, e.g. moving a DOM element or setting some attribute of a Three.js object.\nUpdating/Rendering: The view root's update() method is called after all the queued events have been processed. In some applications, the update method will do nothing (e.g. DOM elements are rendered after returning control to the browser). When using other UI frameworks (e.g. Three.js), this is the place to perform the actual rendering. Also, polling input and other tasks that should happen in every frame should be placed here."
      },
      "after": "2490500ff4f389b4",
      "date": 1692262132981
    },
    {
      "type": "edit",
      "id": "c1651cf1e901ef88",
      "item": {
        "type": "markdown",
        "id": "c1651cf1e901ef88",
        "text": "[[Simulation]]: the models execute the events received via the reflector, and the future messages up to the latest time stamp received from the reflector. The events generated in this phase are put in a queue for the views to consume."
      },
      "date": 1692262241622
    },
    {
      "type": "add",
      "id": "511138a21dccc32c",
      "item": {
        "type": "markdown",
        "id": "511138a21dccc32c",
        "text": "Event Processing: the queued events are processed by calling the view's event handlers. The views typically use these events to modify some view state, e.g. moving a DOM element or setting some attribute of a Three.js object."
      },
      "after": "c1651cf1e901ef88",
      "date": 1692262243805
    },
    {
      "type": "add",
      "id": "8c3b5354218a9f1a",
      "item": {
        "type": "markdown",
        "id": "8c3b5354218a9f1a",
        "text": "Updating/Rendering: The view root's update() method is called after all the queued events have been processed. In some applications, the update method will do nothing (e.g. DOM elements are rendered after returning control to the browser). When using other UI frameworks (e.g. Three.js), this is the place to perform the actual rendering. Also, polling input and other tasks that should happen in every frame should be placed here."
      },
      "after": "511138a21dccc32c",
      "date": 1692262244461
    },
    {
      "id": "479f34ea1a2e3b2f",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "479f34ea1a2e3b2f",
        "text": "[…] if you're building an interactive game, the core experience of the application will likely be on a single route for most of the session. Serving the page with initial data from your [[Elm Backend]] in an elm-pages app would have neglible benefit, especially for loading the kinds of larger assets that are used in games. "
      },
      "after": "51603a7947a7ef8d",
      "attribution": {
        "page": "2023-08-17"
      },
      "date": 1692263476727
    },
    {
      "type": "edit",
      "id": "479f34ea1a2e3b2f",
      "item": {
        "type": "paragraph",
        "id": "479f34ea1a2e3b2f",
        "text": "If you're building an interactive game, the core experience of the application will likely be on a single route for most of the session. Serving the page with initial data from your [[Elm Backend]] in an elm-pages app would have neglible benefit, especially for loading the kinds of larger assets that are used in games. "
      },
      "date": 1692263481057
    },
    {
      "type": "edit",
      "id": "479f34ea1a2e3b2f",
      "item": {
        "type": "paragraph",
        "id": "479f34ea1a2e3b2f",
        "text": "If you're building an interactive game, the core experience of the application will likely be on a single route for most of the session. Serving the page with initial data from your [[Elm Backend]] in an elm-pages app would have neglible benefit, especially for loading the kinds of larger assets that are used in games. [https://elm-pages.com/docs/what-is-elm-pages/#what's-not-a-good-fit-for-elm-pages? page]"
      },
      "date": 1692263512401
    },
    {
      "item": {
        "type": "factory",
        "id": "78edc367a4192376"
      },
      "id": "78edc367a4192376",
      "type": "add",
      "after": "8c3b5354218a9f1a",
      "date": 1692263529417
    },
    {
      "id": "78edc367a4192376",
      "type": "move",
      "order": [
        "51603a7947a7ef8d",
        "78edc367a4192376",
        "479f34ea1a2e3b2f",
        "507dbc44dc3c1b2b",
        "2490500ff4f389b4",
        "c1651cf1e901ef88",
        "511138a21dccc32c",
        "8c3b5354218a9f1a"
      ],
      "date": 1692263537990
    },
    {
      "type": "edit",
      "id": "78edc367a4192376",
      "item": {
        "type": "pagefold",
        "id": "78edc367a4192376",
        "text": "~"
      },
      "date": 1692263540295
    },
    {
      "item": {
        "type": "factory",
        "id": "40bdeee7a276c5ae"
      },
      "id": "40bdeee7a276c5ae",
      "type": "add",
      "after": "8c3b5354218a9f1a",
      "date": 1692263543272
    },
    {
      "id": "40bdeee7a276c5ae",
      "type": "move",
      "order": [
        "51603a7947a7ef8d",
        "78edc367a4192376",
        "479f34ea1a2e3b2f",
        "40bdeee7a276c5ae",
        "507dbc44dc3c1b2b",
        "2490500ff4f389b4",
        "c1651cf1e901ef88",
        "511138a21dccc32c",
        "8c3b5354218a9f1a"
      ],
      "date": 1692263549121
    },
    {
      "type": "edit",
      "id": "40bdeee7a276c5ae",
      "item": {
        "type": "pagefold",
        "id": "40bdeee7a276c5ae",
        "text": "~"
      },
      "date": 1692263551635
    }
  ]
}