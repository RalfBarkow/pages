{
  "title": "Refactoring Legacy Code",
  "story": [
    {
      "type": "paragraph",
      "id": "28d60829ee7042e9",
      "text": "Ideas like TDD, BDD and Continuous Delivery are great, but how do you introduce them to legacy systems? Practically, hands-on, how do you change legacy-code  to make it testable? In this episode [[Dave Farley]] starts a new mini-series to demonstrate the application of techniques like [[Approval Testing]] and code refactoring and applies them to some very nasty code.\n"
    },
    {
      "type": "paragraph",
      "id": "aa98f0e738ee0f22",
      "text": "When [[Kent Beck]] wrote about TDD he introduced a profoundly valuable engineering practice to software development. In his book “ Working Effectively with Legacy Code” Michael Feathers defines a legacy system as “a system without automated tests”. So how can we take advantage of the benefits of TDD when our code is the wrong shape, when it was developed without automated tests?\n\nIn this episode Dave will demonstrate two of his four steps to refactoring, Approval Testing and De-cluttering. In the next episode Dave will describe the next two steps, reducing complexity and composing methods. In the final episode in this mini-series, Dave takes this nasty code the final step to testability.\n\nIf you would like to try this for yourself, you can find the bad code, a simple Approval Test, and a sample XML file to support the test here: https://github.com/davef77/Refactorin...\n"
    },
    {
      "type": "video",
      "id": "6604d27ab671df1d",
      "text": "YOUTUBE p-oWHEfXEVs\nRefactoring Legacy Code: STEP BY STEP (Part 1)"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Refactoring Legacy Code",
        "story": []
      },
      "date": 1652956766770
    },
    {
      "id": "6604d27ab671df1d",
      "type": "add",
      "item": {
        "type": "video",
        "id": "6604d27ab671df1d",
        "text": "YOUTUBE p-oWHEfXEVs\nRefactoring Legacy Code: STEP BY STEP (Part 1)"
      },
      "date": 1652956777206
    },
    {
      "item": {
        "type": "paragraph",
        "id": "28d60829ee7042e9",
        "text": "Ideas like TDD, BDD and Continuous Delivery are great, but how do you introduce them to legacy systems? Practically, hands-on, how do you change legacy-code  to make it testable? In this episode Dave Farley starts a new mini-series to demonstrate the application of techniques like Approval Testing and code refactoring and applies them to some very nasty code.\n"
      },
      "id": "28d60829ee7042e9",
      "type": "add",
      "after": "6604d27ab671df1d",
      "date": 1652956809493
    },
    {
      "type": "edit",
      "id": "28d60829ee7042e9",
      "item": {
        "type": "paragraph",
        "id": "28d60829ee7042e9",
        "text": "Ideas like TDD, BDD and Continuous Delivery are great, but how do you introduce them to legacy systems? Practically, hands-on, how do you change legacy-code  to make it testable? In this episode Dave Farley starts a new mini-series to demonstrate the application of techniques like Approval Testing and code refactoring and applies them to some very nasty code.\n"
      },
      "date": 1652956811489
    },
    {
      "type": "edit",
      "id": "28d60829ee7042e9",
      "item": {
        "type": "paragraph",
        "id": "28d60829ee7042e9",
        "text": "Ideas like TDD, BDD and Continuous Delivery are great, but how do you introduce them to legacy systems? Practically, hands-on, how do you change legacy-code  to make it testable? In this episode Dave Farley starts a new mini-series to demonstrate the application of techniques like Approval Testing and code refactoring and applies them to some very nasty code.\n"
      },
      "date": 1652956820610
    },
    {
      "id": "28d60829ee7042e9",
      "type": "move",
      "order": [
        "28d60829ee7042e9",
        "6604d27ab671df1d",
        "aa98f0e738ee0f22"
      ],
      "date": 1652956822934,
      "error": {
        "type": "error",
        "msg": "Internal Server Error",
        "response": "Server Ignoring move. Try reload."
      }
    },
    {
      "type": "fork",
      "date": 1652956829550
    },
    {
      "type": "add",
      "id": "aa98f0e738ee0f22",
      "item": {
        "type": "paragraph",
        "id": "aa98f0e738ee0f22",
        "text": "When Kent Beck wrote about TDD he introduced a profoundly valuable engineering practice to software development. In his book “ Working Effectively with Legacy Code” Michael Feathers defines a legacy system as “a system without automated tests”. So how can we take advantage of the benefits of TDD when our code is the wrong shape, when it was developed without automated tests?\n\nIn this episode Dave will demonstrate two of his four steps to refactoring, Approval Testing and De-cluttering. In the next episode Dave will describe the next two steps, reducing complexity and composing methods. In the final episode in this mini-series, Dave takes this nasty code the final step to testability.\n\nIf you would like to try this for yourself, you can find the bad code, a simple Approval Test, and a sample XML file to support the test here: https://github.com/davef77/Refactorin...\n"
      },
      "after": "28d60829ee7042e9",
      "date": 1652956829978
    },
    {
      "type": "edit",
      "id": "28d60829ee7042e9",
      "item": {
        "type": "paragraph",
        "id": "28d60829ee7042e9",
        "text": "Ideas like TDD, BDD and Continuous Delivery are great, but how do you introduce them to legacy systems? Practically, hands-on, how do you change legacy-code  to make it testable? In this episode [[Dave Farley]] starts a new mini-series to demonstrate the application of techniques like Approval Testing and code refactoring and applies them to some very nasty code.\n"
      },
      "date": 1652956854263
    },
    {
      "type": "edit",
      "id": "28d60829ee7042e9",
      "item": {
        "type": "paragraph",
        "id": "28d60829ee7042e9",
        "text": "Ideas like TDD, BDD and Continuous Delivery are great, but how do you introduce them to legacy systems? Practically, hands-on, how do you change legacy-code  to make it testable? In this episode [[Dave Farley]] starts a new mini-series to demonstrate the application of techniques like [[Approval Testing]] and code refactoring and applies them to some very nasty code.\n"
      },
      "date": 1652956868396
    },
    {
      "type": "edit",
      "id": "aa98f0e738ee0f22",
      "item": {
        "type": "paragraph",
        "id": "aa98f0e738ee0f22",
        "text": "When [[Kent Beck]] wrote about TDD he introduced a profoundly valuable engineering practice to software development. In his book “ Working Effectively with Legacy Code” Michael Feathers defines a legacy system as “a system without automated tests”. So how can we take advantage of the benefits of TDD when our code is the wrong shape, when it was developed without automated tests?\n\nIn this episode Dave will demonstrate two of his four steps to refactoring, Approval Testing and De-cluttering. In the next episode Dave will describe the next two steps, reducing complexity and composing methods. In the final episode in this mini-series, Dave takes this nasty code the final step to testability.\n\nIf you would like to try this for yourself, you can find the bad code, a simple Approval Test, and a sample XML file to support the test here: https://github.com/davef77/Refactorin...\n"
      },
      "date": 1652956888936
    }
  ]
}