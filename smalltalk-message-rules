{
  "title": "Smalltalk Message Rules",
  "story": [
    {
      "type": "html",
      "text": "The basic rules for messages/methods in [[Smalltalk Language]] are:",
      "id": "32978b8a89c7b34d3b89816dae574cd1"
    },
    {
      "type": "html",
      "text": " <b>Unary messages:</b> Take no arguments.",
      "id": "9fda2fd6993252bc3a69a0164f1c09e9"
    },
    {
      "type": "code",
      "text": " Dictionary ''new''.\n 12 ''factorial''.",
      "id": "cdd7db92c1416428bf1da8080f3b72b3"
    },
    {
      "type": "html",
      "text": " <b>Binary messages:</b>  Take exactly one argument and use one or more non-alphabetic symbols for the selector.",
      "id": "76ec4e6312a3b1f5f7f6686bbb5ba788"
    },
    {
      "type": "html",
      "text": " <i>+</i> 7.",
      "id": "2ea7aeae5802e168cfaec2c16f4c9766"
    },
    {
      "type": "code",
      "text": " 'BIG' ''>'' 'little'",
      "id": "dd706e68ab8c571da48007ff7185d35e"
    },
    {
      "type": "html",
      "text": " <b>Keyword messages:</b> Take one or more arguments and use words followed by colon before each argument.",
      "id": "bdebcc33d409b825130338916ee7f926"
    },
    {
      "type": "html",
      "text": " <i>between:</i> 1 <i>and:</i> 10.",
      "id": "8ad4c1eead955228801d506d94d3a8f8"
    },
    {
      "type": "code",
      "text": " Transcript ''show:'' aString.\n 12 > 7 ''ifTrue:'' ['yes'] ''ifFalse:'' ['no'].",
      "id": "7767ffce06360e4df37e009f058adaf8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "334e6b9441ededd7680001990f90ac9d"
    },
    {
      "type": "html",
      "text": " <b>Precedence rules:</b>  Left to right, Unary then binary then keyword.",
      "id": "a9fa5735887f7ab0ddfa47e1f2f0b70f"
    },
    {
      "type": "html",
      "text": "3 squared + 4 squared between:<br>1 and: 1000.",
      "id": "8fba5c7d9b9f36b44be0971a890d2bc5"
    },
    {
      "type": "html",
      "text": "Executes <i>3 squared</i> then <i>4 squared</i> then <i>9 + 16</i> then <i>25 between:<br>1 and: 1000</i>.",
      "id": "5420c486385a03491dcbe8be2acb8eba"
    },
    {
      "type": "html",
      "text": " <b>Method signatures:</b> Methods are identified by the symbol which is their selector:",
      "id": "5a15efe2b6305fb45afefca696f242bc"
    },
    {
      "type": "code",
      "text": " #new, #factorial, #+, #>, #between:and:, #show:, #ifTrue:ifFalse:",
      "id": "9370b59e8193c00eba53cdaa003e1027"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "334e6b9441ededd7680001990f90ac9d"
    },
    {
      "type": "html",
      "text": "\nCan anyone explain how the messaging notation works when combined with\nthe ; cascading operator? I.e. I have something like:",
      "id": "834defd5abf0abc4a17504496da21922"
    },
    {
      "type": "html",
      "text": "7 + 3 squared; printOn:<br>aStream",
      "id": "cd7709297cddda5714860be631e75ea4"
    },
    {
      "type": "html",
      "text": "\nWhat's printed now? 3 or (7 + 3 squared)?",
      "id": "6ba9163e4162e01ac31e66f28ec2823f"
    },
    {
      "type": "html",
      "text": "-- [[Stephan Houben]] (trying to write a YACC grammar of Smalltalk, just for the\nheck of it). ",
      "id": "591f06c2b7c101f0792d3a406e5098ed"
    },
    {
      "type": "html",
      "text": "\nThe meaning of semi-colon is, \"Send the next message to the same object that received the previous message\". A simpler example would be:",
      "id": "79299670c2703c53af4059a287a10216"
    },
    {
      "type": "code",
      "text": " aStream\n    nextPutAll: 'line 1';\n    cr;\n    nextPutAll: 'line 2'.",
      "id": "d00f1b5acd0ec0fb9962934e4041f830"
    },
    {
      "type": "html",
      "text": "\nSo in this case, <b>cr</b> is sent to the same object that received the first <b>nextPutAll:</b>, namely aStream. Same goes for the last <b>nextPutAll:</b>.",
      "id": "960263b3e4d8d197b2b359f99ef93891"
    },
    {
      "type": "html",
      "text": "\nYour example is a bit trickier, though, because of the precedence rules:",
      "id": "5b3d145bcb0868c56923cc61383ac1aa"
    },
    {
      "type": "html",
      "text": "7 + 3 squared; printOn:<br>aStream",
      "id": "cd7709297cddda5714860be631e75ea4"
    },
    {
      "type": "html",
      "text": "<i>3 squared</i> gets evaluated first. Then <i>7 + 9</i>, then <i>7 printOn:<br>aStream</i>.",
      "id": "9777e9f1ed7b3c85ed41b95ca04d383b"
    },
    {
      "type": "html",
      "text": "\nHere's a couple more examples:",
      "id": "4982cf734735ec50cfb81ff4bf1a7744"
    },
    {
      "type": "html",
      "text": " + 4 squared; factorial; yourself.",
      "id": "6cf74994325fc85fcb7a975a0205cb89"
    },
    {
      "type": "code",
      "text": " ''4 squared'', then ''7 + 16'', then ''7 factorial'' then ''7 yourself'' -> 7.",
      "id": "543215f0f1efc8fe57d9d39b511a9f84"
    },
    {
      "type": "html",
      "text": " + 2 squared factorial; yourself.",
      "id": "f50699f5169a4ce186767c610da99e5a"
    },
    {
      "type": "code",
      "text": " ''2 squared'', then ''4 factorial'' then ''7 + 24'', then ''7 yourself'' -> 7.",
      "id": "f66174abaaf7348c5ca657c6dfbd64ab"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "334e6b9441ededd7680001990f90ac9d"
    },
    {
      "type": "html",
      "text": "\nI find it quite easier \"parse\" the above examples like this (it avoids english :)",
      "id": "f08346362d2e020e00e099944ed91bc2"
    },
    {
      "type": "html",
      "text": " ",
      "id": "2bcd4d4c7ebb2b8e867b9a4ad72701d7"
    },
    {
      "type": "code",
      "text": "  + 4 squared;\n  factorial;\n  yourself.",
      "id": "4ed7b24bd4c779caacf63f8dd59a0401"
    },
    {
      "type": "html",
      "text": " ",
      "id": "2bcd4d4c7ebb2b8e867b9a4ad72701d7"
    },
    {
      "type": "code",
      "text": "  + 2 squared factorial;\n  yourself.",
      "id": "17b283e5713ae48aef3b770edc5f4178"
    },
    {
      "type": "html",
      "text": "-- [[Etoffi Person]]",
      "id": "07982951434a0ee5e4f80e56d3151d28"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "334e6b9441ededd7680001990f90ac9d"
    },
    {
      "type": "html",
      "text": "<b>Q</b>: Can anyone explain how Smalltalk implements shortcut evaluation of logical operators?  E.g. is this possible?",
      "id": "6530f2f9c25b9e13195e66863527b06e"
    },
    {
      "type": "html",
      "text": "((x != 0) && ((n / x) > 10)) ifTrue:<br>[ .... ].",
      "id": "81314f10926a9f55cc198fc9d8de0ae2"
    },
    {
      "type": "html",
      "text": "\nApologies if the operators are not correct -- I'm interested in the semantics, rather than the precise syntax. -- anon",
      "id": "00a9a1f651d0031a6433a6205312773e"
    },
    {
      "type": "html",
      "text": "<b>A</b>: That is a form of deferred evaluation, which in Smalltalk is always done with blocks. The example becomes:",
      "id": "c2f9c9fe5220085fbb87707635a97c90"
    },
    {
      "type": "html",
      "text": "(x ~= 0 and:<br>[n / x > 10]) ifTrue: [ .... ].",
      "id": "9b597d969b1c7d0d6098c45ac85b7231"
    },
    {
      "type": "html",
      "text": "\nThe first part, x ~= 0, returns true or false which are normal objects. When true is sent #and:, it evaluates the second argument (the block [n / x > 10]) with #value and returns that. When false is sent #and:, it just returns false without evaluating the second argument.",
      "id": "a2465058d9f400211cee8e3a48c93287"
    },
    {
      "type": "html",
      "text": "\nThus what is done in [[Cee Plus Plus]] with special language magic is done in Smalltalk with the general mechanisms of blocks and polymorphism. One consequence is that you can write your own short-cut methods which behave like the built-in ones. In C++, you can overload operator&&() but you cannot duplicate the short-cut arguments.",
      "id": "2dedaf16317d6c8af22c458fa8b426f0"
    },
    {
      "type": "html",
      "text": "<i>Previous edit of this page was 2005 -- in 2012, C++ finally has deferred evaluation with lambdas, so you could write this as:</i>",
      "id": "1fc7f014d2e970df1ff7affe85707ad3"
    },
    {
      "type": "code",
      "text": "    Iftrue(And(x != 0, [=]{ return (n / x) > 10 }), [=]{ ... })",
      "id": "9c2dbe92bbd1288aa03da78a03fe0657"
    },
    {
      "type": "html",
      "text": "<i>What? I didn't say the future was *pretty*</i>",
      "id": "8a531af6973e764ab9d039a6841ee45e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "334e6b9441ededd7680001990f90ac9d"
    },
    {
      "type": "html",
      "text": "[[Category Smalltalk]]",
      "id": "da76df09b744463f921217b57c704206"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?SmalltalkMessageRules c2.com]",
      "id": "7ed61c135ef807b9d60bd7acf26dbaeb"
    }
  ],
  "journal": [
    {
      "date": 1327512429000,
      "id": "6bc2fca2a83f5f86f7cf6484990bb669",
      "type": "create",
      "item": {
        "title": "Smalltalk Message Rules",
        "story": [
          {
            "type": "html",
            "text": "The basic rules for messages/methods in [[Smalltalk Language]] are:",
            "id": "32978b8a89c7b34d3b89816dae574cd1"
          },
          {
            "type": "html",
            "text": " <b>Unary messages:</b> Take no arguments.",
            "id": "9fda2fd6993252bc3a69a0164f1c09e9"
          },
          {
            "type": "code",
            "text": " Dictionary ''new''.\n 12 ''factorial''.",
            "id": "cdd7db92c1416428bf1da8080f3b72b3"
          },
          {
            "type": "html",
            "text": " <b>Binary messages:</b>  Take exactly one argument and use one or more non-alphabetic symbols for the selector.",
            "id": "76ec4e6312a3b1f5f7f6686bbb5ba788"
          },
          {
            "type": "html",
            "text": " <i>+</i> 7.",
            "id": "2ea7aeae5802e168cfaec2c16f4c9766"
          },
          {
            "type": "code",
            "text": " 'BIG' ''>'' 'little'",
            "id": "dd706e68ab8c571da48007ff7185d35e"
          },
          {
            "type": "html",
            "text": " <b>Keyword messages:</b> Take one or more arguments and use words followed by colon before each argument.",
            "id": "bdebcc33d409b825130338916ee7f926"
          },
          {
            "type": "html",
            "text": " <i>between:</i> 1 <i>and:</i> 10.",
            "id": "8ad4c1eead955228801d506d94d3a8f8"
          },
          {
            "type": "code",
            "text": " Transcript ''show:'' aString.\n 12 > 7 ''ifTrue:'' ['yes'] ''ifFalse:'' ['no'].",
            "id": "7767ffce06360e4df37e009f058adaf8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "334e6b9441ededd7680001990f90ac9d"
          },
          {
            "type": "html",
            "text": " <b>Precedence rules:</b>  Left to right, Unary then binary then keyword.",
            "id": "a9fa5735887f7ab0ddfa47e1f2f0b70f"
          },
          {
            "type": "html",
            "text": "3 squared + 4 squared between:<br>1 and: 1000.",
            "id": "8fba5c7d9b9f36b44be0971a890d2bc5"
          },
          {
            "type": "html",
            "text": "Executes <i>3 squared</i> then <i>4 squared</i> then <i>9 + 16</i> then <i>25 between:<br>1 and: 1000</i>.",
            "id": "5420c486385a03491dcbe8be2acb8eba"
          },
          {
            "type": "html",
            "text": " <b>Method signatures:</b> Methods are identified by the symbol which is their selector:",
            "id": "5a15efe2b6305fb45afefca696f242bc"
          },
          {
            "type": "code",
            "text": " #new, #factorial, #+, #>, #between:and:, #show:, #ifTrue:ifFalse:",
            "id": "9370b59e8193c00eba53cdaa003e1027"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "334e6b9441ededd7680001990f90ac9d"
          },
          {
            "type": "html",
            "text": "\nCan anyone explain how the messaging notation works when combined with\nthe ; cascading operator? I.e. I have something like:",
            "id": "834defd5abf0abc4a17504496da21922"
          },
          {
            "type": "html",
            "text": "7 + 3 squared; printOn:<br>aStream",
            "id": "cd7709297cddda5714860be631e75ea4"
          },
          {
            "type": "html",
            "text": "\nWhat's printed now? 3 or (7 + 3 squared)?",
            "id": "6ba9163e4162e01ac31e66f28ec2823f"
          },
          {
            "type": "html",
            "text": "-- [[Stephan Houben]] (trying to write a YACC grammar of Smalltalk, just for the\nheck of it). ",
            "id": "591f06c2b7c101f0792d3a406e5098ed"
          },
          {
            "type": "html",
            "text": "\nThe meaning of semi-colon is, \"Send the next message to the same object that received the previous message\". A simpler example would be:",
            "id": "79299670c2703c53af4059a287a10216"
          },
          {
            "type": "code",
            "text": " aStream\n    nextPutAll: 'line 1';\n    cr;\n    nextPutAll: 'line 2'.",
            "id": "d00f1b5acd0ec0fb9962934e4041f830"
          },
          {
            "type": "html",
            "text": "\nSo in this case, <b>cr</b> is sent to the same object that received the first <b>nextPutAll:</b>, namely aStream. Same goes for the last <b>nextPutAll:</b>.",
            "id": "960263b3e4d8d197b2b359f99ef93891"
          },
          {
            "type": "html",
            "text": "\nYour example is a bit trickier, though, because of the precedence rules:",
            "id": "5b3d145bcb0868c56923cc61383ac1aa"
          },
          {
            "type": "html",
            "text": "7 + 3 squared; printOn:<br>aStream",
            "id": "cd7709297cddda5714860be631e75ea4"
          },
          {
            "type": "html",
            "text": "<i>3 squared</i> gets evaluated first. Then <i>7 + 9</i>, then <i>7 printOn:<br>aStream</i>.",
            "id": "9777e9f1ed7b3c85ed41b95ca04d383b"
          },
          {
            "type": "html",
            "text": "\nHere's a couple more examples:",
            "id": "4982cf734735ec50cfb81ff4bf1a7744"
          },
          {
            "type": "html",
            "text": " + 4 squared; factorial; yourself.",
            "id": "6cf74994325fc85fcb7a975a0205cb89"
          },
          {
            "type": "code",
            "text": " ''4 squared'', then ''7 + 16'', then ''7 factorial'' then ''7 yourself'' -> 7.",
            "id": "543215f0f1efc8fe57d9d39b511a9f84"
          },
          {
            "type": "html",
            "text": " + 2 squared factorial; yourself.",
            "id": "f50699f5169a4ce186767c610da99e5a"
          },
          {
            "type": "code",
            "text": " ''2 squared'', then ''4 factorial'' then ''7 + 24'', then ''7 yourself'' -> 7.",
            "id": "f66174abaaf7348c5ca657c6dfbd64ab"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "334e6b9441ededd7680001990f90ac9d"
          },
          {
            "type": "html",
            "text": "\nI find it quite easier \"parse\" the above examples like this (it avoids english :)",
            "id": "f08346362d2e020e00e099944ed91bc2"
          },
          {
            "type": "html",
            "text": " ",
            "id": "2bcd4d4c7ebb2b8e867b9a4ad72701d7"
          },
          {
            "type": "code",
            "text": "  + 4 squared;\n  factorial;\n  yourself.",
            "id": "4ed7b24bd4c779caacf63f8dd59a0401"
          },
          {
            "type": "html",
            "text": " ",
            "id": "2bcd4d4c7ebb2b8e867b9a4ad72701d7"
          },
          {
            "type": "code",
            "text": "  + 2 squared factorial;\n  yourself.",
            "id": "17b283e5713ae48aef3b770edc5f4178"
          },
          {
            "type": "html",
            "text": "-- [[Etoffi Person]]",
            "id": "07982951434a0ee5e4f80e56d3151d28"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "334e6b9441ededd7680001990f90ac9d"
          },
          {
            "type": "html",
            "text": "<b>Q</b>: Can anyone explain how Smalltalk implements shortcut evaluation of logical operators?  E.g. is this possible?",
            "id": "6530f2f9c25b9e13195e66863527b06e"
          },
          {
            "type": "html",
            "text": "((x != 0) && ((n / x) > 10)) ifTrue:<br>[ .... ].",
            "id": "81314f10926a9f55cc198fc9d8de0ae2"
          },
          {
            "type": "html",
            "text": "\nApologies if the operators are not correct -- I'm interested in the semantics, rather than the precise syntax. -- anon",
            "id": "00a9a1f651d0031a6433a6205312773e"
          },
          {
            "type": "html",
            "text": "<b>A</b>: That is a form of deferred evaluation, which in Smalltalk is always done with blocks. The example becomes:",
            "id": "c2f9c9fe5220085fbb87707635a97c90"
          },
          {
            "type": "html",
            "text": "(x ~= 0 and:<br>[n / x > 10]) ifTrue: [ .... ].",
            "id": "9b597d969b1c7d0d6098c45ac85b7231"
          },
          {
            "type": "html",
            "text": "\nThe first part, x ~= 0, returns true or false which are normal objects. When true is sent #and:, it evaluates the second argument (the block [n / x > 10]) with #value and returns that. When false is sent #and:, it just returns false without evaluating the second argument.",
            "id": "a2465058d9f400211cee8e3a48c93287"
          },
          {
            "type": "html",
            "text": "\nThus what is done in [[Cee Plus Plus]] with special language magic is done in Smalltalk with the general mechanisms of blocks and polymorphism. One consequence is that you can write your own short-cut methods which behave like the built-in ones. In C++, you can overload operator&&() but you cannot duplicate the short-cut arguments.",
            "id": "2dedaf16317d6c8af22c458fa8b426f0"
          },
          {
            "type": "html",
            "text": "<i>Previous edit of this page was 2005 -- in 2012, C++ finally has deferred evaluation with lambdas, so you could write this as:</i>",
            "id": "1fc7f014d2e970df1ff7affe85707ad3"
          },
          {
            "type": "code",
            "text": "    Iftrue(And(x != 0, [=]{ return (n / x) > 10 }), [=]{ ... })",
            "id": "9c2dbe92bbd1288aa03da78a03fe0657"
          },
          {
            "type": "html",
            "text": "<i>What? I didn't say the future was *pretty*</i>",
            "id": "8a531af6973e764ab9d039a6841ee45e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "334e6b9441ededd7680001990f90ac9d"
          },
          {
            "type": "html",
            "text": "[[Category Smalltalk]]",
            "id": "da76df09b744463f921217b57c704206"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?SmalltalkMessageRules c2.com]",
            "id": "7ed61c135ef807b9d60bd7acf26dbaeb"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1702911555078
    }
  ]
}