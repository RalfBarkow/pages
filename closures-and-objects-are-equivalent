{
  "title": "Closures And Objects Are Equivalent",
  "story": [
    {
      "type": "html",
      "text": "<i>The venerable master Qc Na was walking with his student, Anton.  Hoping to prompt the master into a discussion, Anton said \"Master, I have heard that objects are a very good thing - is this true?\"  Qc Na looked pityingly at his student and replied, \"Foolish pupil - objects are merely a poor man's closures.\"</i>",
      "id": "1c6ec874dcd8a2ae71aca22fdc11f07d"
    },
    {
      "type": "html",
      "text": "<i>Chastised, Anton took his leave from his master and returned to his cell, intent on studying closures. He carefully read the entire \"Lambda: The Ultimate...\" series of papers and its cousins, and implemented a small Scheme interpreter with a closure-based object system. He learned much, and looked forward to informing his master of his progress.</i>",
      "id": "f15d10528e48a5a5d8ffa05680c09210"
    },
    {
      "type": "html",
      "text": "<i>On his next walk with Qc Na, Anton attempted to impress his master by saying \"Master, I have diligently studied the matter, and now understand that objects are truly a poor man's closures.\" Qc Na responded by hitting Anton with his stick, saying \"When will you learn? Closures are a poor man's object.\" At that moment, Anton became enlightened.</i>",
      "id": "24a904d7b644bc4c511868baed28aee7"
    },
    {
      "type": "html",
      "text": "\nFrom: [http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html people.csail.mit.edu]",
      "id": "a299d92a0974b09988d7b463d6685e0f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "<b>Poll</b>: Are objects and closures equivalent?",
      "id": "7d7d2870a7a95b390516cae924893a73"
    },
    {
      "type": "html",
      "text": "<b>Aye's</b>:",
      "id": "c4ac5cfdc0e40278246cdc3c053174b5"
    },
    {
      "type": "html",
      "text": " (vote here)",
      "id": "460266ca843d682dc2d6c4f59f2844f8"
    },
    {
      "type": "html",
      "text": "<b>Nays</b>:",
      "id": "c60402f014aa046af8e8967e5fadc150"
    },
    {
      "type": "html",
      "text": " Winheim Raulsh - closures are immutable, have no methods, receive no messages, and don't provide the equivalent of inheritance and polymorphism on their own. ",
      "id": "25fc6753c1adfef232c6ab8e49b9647a"
    },
    {
      "type": "html",
      "text": " [[[Eric Tetz]] - a closure *is* mutable (it closes over mutable state, so it's mutable to the same extent that a class instance is) and it's callable (it can receive an \"execute\" message) so it's like a class instance with one public method]",
      "id": "e0461896e8bc5eb7104e995aa95e3157"
    },
    {
      "type": "html",
      "text": " [[Mark Janssen]] - they are equivalent as <i>things</i>, static in themselves, but not in actual usage in anyway whatsoever. See [[Computer Science Version Two]].",
      "id": "8de638c5240a9944a371a073706e73d2"
    },
    {
      "type": "html",
      "text": " (vote here)",
      "id": "460266ca843d682dc2d6c4f59f2844f8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "It is well-known that objects and closures over lexical scopes ([[Lexical Closure]]s) are equivalent things; which one you prefer is a matter of taste and background. (Actors are also equivalent to both; see [[Actors Model]].) Those with a strong functional background (in particular, Lisp/Scheme) tend to prefer closures; and many object systems in [[Lisp Language]] and [[Scheme Language]] (but not including [[Common Lisp Object System]], which uses method polymorphism on pure data objects) use closures to implement objects.",
      "id": "f2450278ae765de17408a64af60969ba"
    },
    {
      "type": "html",
      "text": "<i>[[Structure And Interpretation Of Computer Programs]] gives a [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1 mitpress.mit.edu] nice sample for this type of object system].</i>",
      "id": "46d85ceb148c2c479cefe35836cac44f"
    },
    {
      "type": "html",
      "text": "<i>It is not well-known that objects and closures are equivalent. On the contrary, what is \"well-known\" is what [[Luca Cardelli]] presents in the 18th chapter of [[Theory Of Objects]], precisely that encoding object oriented features in lambda calculi is unwieldly and cumbersome, especially when it comes to typed version of those calculi. This page is further evidence as it presents only objects with one method and no inheritance.</i>",
      "id": "9f668f7cb4ac5351c873a1e3b0fe1676"
    },
    {
      "type": "html",
      "text": "\nUsing [[Pattern Matching]], supporting more than one method is no more difficult than supporting a single method. [[Delegation Is Inheritance]], and delegation can be supported straightforwardly by adding a <i>self</i> parameter to calls.",
      "id": "bb7c13aaee49c0d0e6f228e9f3ff06f2"
    },
    {
      "type": "html",
      "text": "<i>In general, emulating object features in a statically typed functional language with closures (and even with more advanced features like modules), for example [[Standard Ml]], is at least cumbersome if not impossible. There are object systems written for Lisp and Scheme, some of them using macros (CLOS), some in functional style without macros, however I don't think there's any particular object system with all the major features (polymorphism, inheritance, etc) written without macros. Nor there should be since object systems with macros look easier to write and comprehend.</i>",
      "id": "0f2abb730668765dfc348e67cef103e4"
    },
    {
      "type": "html",
      "text": "<i>What exactly is the problem with macros? They are used to give you a nicer syntax, which is a Good Idea IMHO.</i>",
      "id": "20719f8e96d57d202c11cd19e9fafb3f"
    },
    {
      "type": "html",
      "text": "[Well it is well known that an object is one particular form of a closure, and a closure can be used as an object, which they often are, and is what the above paragraph is trying to convey. Sure, some languages give us a nice clean little package that wraps up polymorphism and inheritance into a thing called class, but one doesn't need either polymorphism or inheritance to have an object. Polymorphism and inheritance are used to specialize objects, closures are used to create anonymous one-shot objects that don't need specialization, they are complimentary abstractions. You are setting up a straw man here, polymorphism and inheritance are not required to build objects, polymorphism and inheritance may be required to call it object oriented, but not object based. No claim was made that Closures = OO programming, just that objects and closures are equivalent, which is true.]",
      "id": "7ca0df7006eb2a8c910a0c2937605f10"
    },
    {
      "type": "html",
      "text": " <i>Please make up your mind: either closures and objects complement each other, or they are equivalent. You can't have them both. If objects can be perfectly emulated by closures, than objects would be unnecessary entities and unnecessary entities do not complement anything. To complement means to add something essential in order to make up a whole, bring to perfection, supplant, etc. With regards to polymorphism and inheritance, they are essential to objects insofar that high level programming languages are essential to programming (of course we can program in assembly and that would still be called programming).</i>",
      "id": "fb4b3cb609dded82655674fcdd36bdf1"
    },
    {
      "type": "html",
      "text": "[You can have both, don't be so closed minded. Objects wrap up polymorphism and inheritance in an easy to use fashion that would be more verbose with closures, however they don't give you anything special, just a shorter syntax. Objects are necessary for domain entities and such, well-defined objects so to say. Closures are necessary for one-shot objects that aren't well defined, and are different just about every time, but essential none the less. Polymorphism and inheritance are not essential to build an object, that is if you define an object as a thing with state and identity, which closures have.]",
      "id": "b3620243ba8d47555e97c38e58daa0e6"
    },
    {
      "type": "html",
      "text": " I don't think equivalence and complementariness (better word for that?) are mutually exclusive. You can use one to implement the other - that is sufficient to demonstrate equivalence.",
      "id": "d355dd9ffc25d92eafde347f21b533eb"
    },
    {
      "type": "html",
      "text": "<i>More precisely, equivalence means that two concepts can simulate each other </i>without requiring a global transformation on programs<i>. Otherwise we get caught in the [[Turing Trap]].</i>",
      "id": "d25b9f9341780b3831cd941248bc9cfe"
    },
    {
      "type": "html",
      "text": " But that doesn't make one or the other redundant; having both is nice as each can be used to solve different problems. Furthermore, I can simulate either with a rats-nest of pointers and macros, but that doesn'e mean we should abandon both high-level concepts and go back to programming everything in [[Cee Language]].",
      "id": "6cb519b06c839fbcec5974675bd11190"
    },
    {
      "type": "html",
      "text": "<i>The fact that you can use one to implement another do not an equivalence make. The same good old argument that says that Java and assembly are not equivalent programming languages, in spite of the fact all <b>computations</b> that can be implemented in one can be implemented in the other, and you can use Java to implement an assembly interpreter or you can use assembly to implement a Java (bytecode) interpreter.</i>",
      "id": "c7f581f42b327c61ac7917204e00974a"
    },
    {
      "type": "html",
      "text": "<i>The page as it stands now gives a false advice in the sense that if the claim was true, than it would be easier to program in [[Object Oriented]] style in a language like [[Standard Ml]], but it isn't. Neither functional programming subsumes object oriented programming, nor the other way around. It is beneficial for most programmers to know both styles.</i>",
      "id": "0e015fb0e3291c3102ac9fb23f134c79"
    },
    {
      "type": "html",
      "text": " Agreed",
      "id": "df20dd2bb9665a328933b9b5877074c1"
    },
    {
      "type": "html",
      "text": "\nMany modern OO languages, however, don't have full closures. Some languages have something similar (Java [[Inner Class]]es); others don't bother at all. It has been argued ([[Global Variables Considered Harmful]]) that full lexical closures aren't always a good thing - they dramatically increase coupling between modules (as the closure has hooks into the guts of the enclosing scope), and they complicate a language's implementation. (See also [[What Is Closure]] for more on that).",
      "id": "945138acedcbfeda2a2bc9f40f5f7c73"
    },
    {
      "type": "html",
      "text": "\nFor many of the purposes (not all) that a Lisp user might use a closure - an OO programmer would use an <i>object</i> - and an object is often a perfectly good substitute.",
      "id": "6956a5eccb44acf2016f6ee41a5c60e0"
    },
    {
      "type": "html",
      "text": "[[Wait.  Hold on.  What exactly here makes a \"closure\" have to be functional? You can have a \"closure\" also be an object. Java's anonymous inner classes close over the final variables in scope. [[Ee Language]]'s object definitions are closures, which allows it to avoid the concept of a \"class\" without using prototypes and yet still having a central module used to spawn new objects of a given type. Yet, neither of those are exactly \"lambdas\". Yes, they could arguably be defined as [[Hash Map]]s of lambdas, but the point still stands: closures can be defined as anything which can capture lexical variables and take them into other stack frames. They don't actually <i>have</i> to be lambdas.",
      "id": "89e8d37497021e85826a4098d48efdba"
    },
    {
      "type": "html",
      "text": "\nOf course, most people think of them as lambdas. I know what a \"closure\" implies. Still, [[Food For Thought]].]]",
      "id": "41ce6c8297f31a6960842cc5ae3569bc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "[Moved from [[Lexical Scoping]]]",
      "id": "2e90e4359a7d7bc246fab9493dbef4cb"
    },
    {
      "type": "html",
      "text": "\nIn many cases, a bunch of related functions defined within a single outer function (and accessing - incestuously - it's variables) are parts of a single concept - the functions are all tightly coupled and using explicit parameters would become a nightmare (giving you a bunch of functions with dozens of parameters to pass around). Whenever I see this, I see an <b>object</b> waiting to be born. Refactor the whole mess into a class. If you are in a non-OO language; find the union of all the shared state and make it a struct/record - and pass <i>that</i> around (by reference). In both cases, you get the ability to make lots of instances of your abstraction (and to access the inner methods without calling the outermost method first). In the OO case, you get the additional benefits of OO - [[Poly Morphism]] and such.",
      "id": "e64c66c038785789b663618453dddf92"
    },
    {
      "type": "html",
      "text": "\nThis is (or is very similar to) a [[Method Object]].",
      "id": "e4f2350127c80b0a903af6052aecb718"
    },
    {
      "type": "html",
      "text": "<i>Umm, this is not really the common case for closures. You see examples like that, but they're largely academic. Indeed in 90% of the cases where you'd see that pattern, it'd be wiser to use an Object in Lisp. Especially since CLOS provides such an incredible system. Most of the time we're using closures in lambda-passing functions. It is far superior to Java inner classes or C++ functors for this. As an example:</i>",
      "id": "3c900389e08dfd37e1753fa704dbc786"
    },
    {
      "type": "code",
      "text": "  (defun bizzare-example (list)\n  (let ((ctr 0))\n  (mapc (lambda (x) (incf ctr)) list)\n  ctr))",
      "id": "5c44e71ac33025adc8b20f5e9af5926b"
    },
    {
      "type": "html",
      "text": "<i>While trivial and academic, it demonstrates why lisp and scheme programmers like function-passing style with closures so much. The standard combinators like the mapping functions and sorting functions can take the surrounding context into account. Also, closures allow for awesome control-flow constructs like the lisp condition handling system. Heck, people have made a limited kind of continuation just with \"goto\" and closures (but I am not saying that I don't envy Scheme's real continuations).</i>",
      "id": "0e89bcd6cc0f3fa18332c3f15748e55c"
    },
    {
      "type": "html",
      "text": "<i>Closures and Objects are closely related, but closures are more general. You can't really use objects to implement closures unless your object system is actually doing closures under the covers. You can implement objects with closures by linking methods across a set of variables (note in lisp this practice is considered archaic and generic functions are instead used to handle this). </i>",
      "id": "ab62274c6b068d0f11630cbc1771a4a6"
    },
    {
      "type": "html",
      "text": " Maybe I just need another cup of coffee, but my brain is boggling on this phrase: \"linking methods across a set of variables\", could you help me out on its meaning?",
      "id": "db54c18bf103f4ad4a554b9af2268d4b"
    },
    {
      "type": "html",
      "text": "<i> I was unclear. You can make objects (without any kind of dispatch) by creating a closure over a set of variables (data portion) and defining a list of lambdas (code portion) to create rudimentary objects. Adding inheritance and polymorphism from there really isn't that hard. As I said though, these kinds of object systems are unpopular in Lisp and Scheme today, because of the prevailing style in Lisp. Also, some people claim the message-passing system (which people also note is \"specialization on only one argument\") which most systems base themselves off of is inherently inferior compared to the pure multimethods approach that CLOS favors. I personally am on the fence on this issue.</i>",
      "id": "2a415d122e97140c178d7815e1cb9adb"
    },
    {
      "type": "html",
      "text": "<i> My point though, is that closures and objects aren't really equivalent. Objects are a subset of closures, so they carry some similar traits.</i>",
      "id": "0c9d01c7d62ffef4b6000861c82a301f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "\nNote: objects and closures over lexical scopes are equivalent. Idiomatic style of programming in a language that allows nested function definitions takes advantage of this fact, rather than being confounded by it. E.g. a function in the [[Scheme Language]] can return one or more local functions that can use variables in the defining scope, and that are therefore fully encapsulated.",
      "id": "7fa5cdf4155d67186e56cc854346cf75"
    },
    {
      "type": "code",
      "text": " (define (make-counter count)\n  (define (inc) \n  (define old-count count)\n  (set! count (+ 1 count))\n  old-count)\n  inc)",
      "id": "c8002e2605b0e8efe131b9dcf9506ace"
    },
    {
      "type": "code",
      "text": " (define the-counter (make-counter 1))\n (the-counter)\n  ==> returns 1\n (the-counter)\n  ==> returns 2\n ... etc. ...",
      "id": "ba33c67c83d4513e05d53693dd7c0f81"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "\nI'm not sure if I'm grokking the level of equivalence of the above example. It shows me how a single method object is equivalent to an closure, but I'm not seeing how this extends to a multiple-method object (does it?). Could somebody provide a translation of the following into closures:",
      "id": "7f3133af278672716248c1d32b3c7fa5"
    },
    {
      "type": "code",
      "text": "  class Multiplier\n  def initialize(a,b) \n  @a, @b = a,b \n  end\n  def addA(value)\n  @a = @a + value \n  end\n  def addB(value) \n  @b = @b + value \n  end\n  def result\n  @a * @b \n  end\n  end",
      "id": "e8ddf87cd35a48edf8ac848fa8ea916d"
    },
    {
      "type": "code",
      "text": "  mult = Multiplier.new(5, 4)\n  puts mult.result    # returns 5 * 4 = 20\n  mult.addA(3)\n  puts mult.result    # returns 8 * 4 = 32\n  mult.addB(5)\n  puts mult.result    # returns 8 * 9 = 72",
      "id": "7fde1fa061b2ae6f77eabd00d6b927e8"
    },
    {
      "type": "html",
      "text": "\nMy scheme skills are a bit weak, but try this:",
      "id": "3eec62d2e2a356612a2230784ea03987"
    },
    {
      "type": "code",
      "text": "  (define (make-multiplier a b)\n  (lambda (method-name)\n  (case method-name\n  ((add-a)\n   (lambda (value)\n    (set! a (+ a value))))\n  ((add-b)\n   (lambda (value)\n    (set! b (+ b value))))\n  ((result)\n   (lambda ()\n    (* a b))))))",
      "id": "e1e1dbbe8b7d86aa9eaca48c4753a238"
    },
    {
      "type": "code",
      "text": "  (define mult (make-multiplier 5 4))\n  (print ((mult 'result)))    ; prints 20\n  ((mult 'add-a) 3)\n  (print ((mult 'result)))    ; prints 32\n  ((mult 'add-b) 5)\n  (print ((mult 'result)))    ; prints 72",
      "id": "d85d6f83e8aa39d8027a8953ce1abe2a"
    },
    {
      "type": "html",
      "text": "\nmake-multiplier returns a function that takes a method selector, and then returns the appropriate method. The method can then be called normally.",
      "id": "2d246bfbe26186009d57be4445393cb3"
    },
    {
      "type": "html",
      "text": "\nThis is probably not idiomatic Scheme though, which would look more like this:",
      "id": "87f649db8de0d8bcc6a9e19897ec21fd"
    },
    {
      "type": "code",
      "text": "  (define (make-multiplier a b)\n  (list\n  (lambda (value)\n  (set! a (+ a value)))\n  (lambda (value)\n  (set! b (+ b value)))\n  (lambda ()\n  (* a b))))",
      "id": "cc26f40832c99295fb9441432b89da7c"
    },
    {
      "type": "code",
      "text": "  (define (add-a mult)\n  (car mult))",
      "id": "9859ad79abd4fbf54e811447bc55d12c"
    },
    {
      "type": "code",
      "text": "  (define (add-b mult)\n  (cadr mult))",
      "id": "1198b2f30fcaeed9684b89794e1842d5"
    },
    {
      "type": "code",
      "text": "  (define (result mult)\n  (caddr mult))",
      "id": "69539f6b81d11afc538a4f1120e3e6d3"
    },
    {
      "type": "code",
      "text": "  (define mult (make-multiplier 5 4))\n  (print ((result mult)))\n  ((add-a mult) 3)\n  (print ((result mult)))\n  ((add-b mult) 5)\n  (print ((result mult)))",
      "id": "eaf67d04fc9328f13c5529eb41645eb8"
    },
    {
      "type": "html",
      "text": "\nThis time, make-multiplier returns a list of 3 functions: the methods in the class. A production scheme system would probably use a hashtable, alist, or record, some data structure where the methods are not positionally dependent. In any case, there're accessor functions that return the correct lambda, so that the client programmer doesn't need to worry about the actual data structure returned.",
      "id": "1eb9a85c8c624cf01351a7bb812fc351"
    },
    {
      "type": "html",
      "text": "\nYou can get polymorphism too, by replacing the functions within the data structure returned by the constructor, but subclass methods won't be able to access superclass data unless the subclass is lexically enclosed by the superclass. This is annoying, because any moderately deep inheritance hierarchy becomes virtually impossible to read. Granted, most moderately deep inheritance hierarchies in traditional languages aren't very easy to follow either, if the subclasses use large amounts of data in the superclass.",
      "id": "b11f8ce6ced7a18cf8480e17f945d05d"
    },
    {
      "type": "html",
      "text": "<i>An approach which might match the original request better:</i>",
      "id": "aef7ee80f9bc233e82dcee21dbcb2c3c"
    },
    {
      "type": "code",
      "text": " (define (multiplier . x)\n  (case (car x)\n  ('new (let ((a (cadr x)) \n     (b (caddr x)))\n    (lambda message\n    (case (car message)\n     ('add-A (set! a (+ a (cadr message))))\n     ('add-B (set! b (+ b (cadr message))))\n     ('result (* a b))\n     (else (error \"Not a valid instance method of class multiplier.\"))))))\n  (else (error \"Not a valid class method of class multiplier.\"))))",
      "id": "ebdaef967011676baa3f5a3f9e2e0f60"
    },
    {
      "type": "code",
      "text": " (define mult (multiplier 'new 5 4))\n (display (mult 'result))\n (newline)\n (mult 'add-A 3)\n (display (mult 'result))\n (newline)\n (mult 'add-B 5)\n (display (mult 'result))",
      "id": "f5c0350ac70523cb9e63643e7efceed4"
    },
    {
      "type": "html",
      "text": "<i>This code  is a variant of the closure-object idiom demonstrated in [[Structure And Interpretation Of Computer Programs]], chapter 3, which is widely known among Schemers; it has been tested under Dr Scheme and works as designed. While objects could be built manually this way, it would make more sense to define a set of forms to automatically generate the class form, which IIUC is how SOS works. HTH. - [[Jay Osako]]</i>",
      "id": "b6cedb60842252ac34c5f4af0ec145b1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "It's been claimed, on [[Smalltalk Instead Of Python]], that smalltalk is preferable because it has real closures, where Python only has one-shot lambda functions. But if you want to encapsulate a structured state, why not use an object? Perl gives you closures ... but the only use I've seen for them is to hide the data members of an object ... what else can you do with 'em?",
      "id": "0ceeef08019b0332aa779ce97c90771e"
    },
    {
      "type": "html",
      "text": "<i>Well, for one you can write an object system with them. This is a popular exercise in Scheme and at least one of the object systems in SLIB requires no macros.</i>",
      "id": "80d3e65dcbbfc4f581d99b0cfeabcdc7"
    },
    {
      "type": "html",
      "text": "\nA class is simply one form of a more general concept, a closure. In other words, classes are closures... with names, but not all closures need names. The use of closures goes beyond the class concept, and is more general and more powerful. Object systems are written with closures. Closures allow one shot specialized objects, and are far more general than classes.",
      "id": "773fd976cc2872f2a0ca0b54bdc2c4da"
    },
    {
      "type": "html",
      "text": "<i>In Smalltalk they are an enormous convenience. You </i>could<i> create a class with a value method that does just that one computation, but this is a lot of work for little or no gain, and you can't do ifTrue: and while: and such very easily at all. In Python they are unnecessary but still an enormous convenience, and their lack is unfortunate.</i>",
      "id": "e32db4e8767dc64551493f8bf3d85ddd"
    },
    {
      "type": "html",
      "text": "\nCan you give an ur-python snippet that would illustrate what could be done with them if they were in the language?",
      "id": "e15cebc8a0de909e34ddbab60641b4b6"
    },
    {
      "type": "html",
      "text": "<i>If closures were added to Python tomorrow, I could do this:</i>'",
      "id": "21d949273c32b4b95b5da96ae614eb43"
    },
    {
      "type": "code",
      "text": " class Foo:\n  def iterator(self):\n   i = 0\n   def temp():\n    value = self[i]\n    i = i + 1\n    return value\n   return Iterator(temp)",
      "id": "c2cf233e569fa4537821876c615ca7df"
    },
    {
      "type": "code",
      "text": " for node in Foo().iterator():\n  node.process()",
      "id": "69d4d5bcc2960088ad627b7b0e72e014"
    },
    {
      "type": "html",
      "text": "<i>This is a very easy xrange equivalent, if Iterator is a simple class that just handles __getitem__ and the usual Python iteration protocol. It is harder to do in stock Python and as a result people don't do it; I know of no equivalent in the standard libraries save xrange.</i>",
      "id": "19624149756bb7774aeeb1ee5071e5c0"
    },
    {
      "type": "html",
      "text": "\nMaybe the above message is old, but closures exist in Python today. Only the example you given above doesn't work because Python doesn't distinguish between \"let\" and \"setf\"; It creates a new \"let\" block for i within temp, making it different from the i in iterator. The way around this is to uglify the code slightly with an array, which changes \"i = i + 1\" from assignment to a modification of an object.",
      "id": "e62303fb5b693bb08271d8087928fa22"
    },
    {
      "type": "code",
      "text": " class Foo:\n  def iterator(self):\n  i = [0]\n  def temp():\n    value = self[i[0]]\n    i[0] += 1\n    return value\n  return Iterator(temp)",
      "id": "fe898830e3b8e9c07ba300009c1ed88c"
    },
    {
      "type": "code",
      "text": " for node in Foo().iterator():\n  node.process()",
      "id": "69d4d5bcc2960088ad627b7b0e72e014"
    },
    {
      "type": "html",
      "text": "\nYou don't need closures for this:",
      "id": "23587f566d6f3e9d18f85a6fdb0956d5"
    },
    {
      "type": "code",
      "text": " def my_xrange(start, stop=None, step=1):\n  if stop is None:\n    start, stop = 0, start\n  while start < stop:\n   yield start\n   start += step",
      "id": "75da9dfe6331bba581a0a2523929c399"
    },
    {
      "type": "code",
      "text": " for i in my_xrange(7):\n  print i",
      "id": "59ca6e05493b59498c35c4419976fd10"
    },
    {
      "type": "code",
      "text": " for i in my_xrange(4, 100, 3):\n  print i",
      "id": "9905b623c1ac8920ec5c58889da27997"
    },
    {
      "type": "html",
      "text": "\nLocking can also be implemented without closures:",
      "id": "5a8787e0676977d10d8fcd9bc95bf5d5"
    },
    {
      "type": "code",
      "text": " >>> def Lock(func):\n ...  print \"Locking...\" # your self.lock()\n ...  try:\n ...    return func()\n ...  finally:\n ...    print \"Unlocking!\" # your self.unlock()",
      "id": "830a13859c7c84c015447f00b77b2bcd"
    },
    {
      "type": "html",
      "text": ">>> def func():<br>print \"... Now in func!\"",
      "id": "3d16183e19df3078098676631403aa14"
    },
    {
      "type": "code",
      "text": " >>> Lock(func)\n Locking...\n ... Now in func!\n Unlocking!",
      "id": "953dc9af83eaed151a34284dfd4b4245"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "\nThough this still doesn't seem like something I'd use, I see no difficulty. It can be done readily with python's builtin compile and eval:",
      "id": "e8f00eb613ab46261530a13a83fbb778"
    },
    {
      "type": "code",
      "text": " class Closure:\n  def __init__(self, statements, locals=None):\n   import copy\n   self.stuff = compile(statements, \"<string>\", \"exec\")\n   self.locals=copy.deepcopy(locals)\n   self.globals=copy.deepcopy(globals())\n  def __call__(self):\n   return eval(self.stuff, self.locals, self.globals)",
      "id": "bda1221eed6c041958ec16298e7ce6ba"
    },
    {
      "type": "code",
      "text": " Lock.with_lock(Closure(\"\"\"\n  statement1\n  ...\n  statementN\n \"\"\", locals())",
      "id": "466fa0487ab6748aa2b96275c43c2194"
    },
    {
      "type": "html",
      "text": "You might leave <i>locals()</i> out for the most part. I haven't tried to make this work, but it seems straightforward. Do Smalltalk closures do something more magical than this?",
      "id": "c4d9479308d33666e2bb9de6cdac176e"
    },
    {
      "type": "html",
      "text": "<i>Yes. For one thing, they don't make deep copies of the variables referred to:</i>",
      "id": "206d8bde9a7e08aa1c609d66f794f538"
    },
    {
      "type": "code",
      "text": " | i sum |\n i := 0. sum := 0.\n aCollection do: [ :each |\n  i := i + 1.\n  sum := sum + each\n ].",
      "id": "93d80775d19d592f70b1a5a098da3e80"
    },
    {
      "type": "html",
      "text": "<i>or, in the hypothetical Python-with-closures:</i>",
      "id": "b0610480e066421b95b1ac70e9776f7f"
    },
    {
      "type": "code",
      "text": " i, sum = 0, 0\n def act(number):\n  i += 1\n  sum += number\n aList.do(act)",
      "id": "7346e2b57163c041f9d12f4166f6b792"
    },
    {
      "type": "html",
      "text": "<i>actually works. For another thing they're much more efficient and transparent; they only refer to some locals, and you needn't do the full setup for so called downward-funargs, etc. The current Python Way of doing this is to create an object:</i>",
      "id": "f05512d6a80aa708156253b7d346d7f5"
    },
    {
      "type": "code",
      "text": " class Counter:\n  def __init__(self):\n   self.i, self.sum = 0, 0\n  def actOn(self, number):\n   self.i += 1\n   self.sum += number\n c = Counter()\n aList.do(c.actOn)",
      "id": "f54cf625b672eaf45a2d29da81d2b8b2"
    },
    {
      "type": "html",
      "text": "<i>While certainly feasible this is by no stretch of the imagination convenient, particularly for short iteration methods.</i>",
      "id": "f2c1bce3545d5c2a6c55431425022f1d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "\nOkay, I tried the Closure class above and had to ditch the copying because modules wouldn't let themselves be copied. No matter, any relevant state can be stuck inside the <i>statements</i> string.",
      "id": "29523a86bfca8a1bd45b56f7bda132cd"
    },
    {
      "type": "code",
      "text": " class Closure:\n  def __init__(self, statements):\n   self.stuff = compile(statements, \"<string>\", \"exec\")\n  def __call__(self, *arg, **kword):\n   return eval(self.stuff, locals(), globals())",
      "id": "5b9d297d23ed83d74db55d0be2280aa8"
    },
    {
      "type": "html",
      "text": "So then you can do all this with map:",
      "id": "f49c1b955b16a9dfae59241d476cf0c0"
    },
    {
      "type": "code",
      "text": " sum, prod = 0, 1\n act = Closure(\"\"\"\n sum = sum + arg[0]\n prod = prod * arg[0]\n \"\"\")\n map(act, aList)",
      "id": "1f36c8741ecb094af5e128ef1e3666e4"
    },
    {
      "type": "html",
      "text": "The trick is that arg and kword get stuck into locals(). It seems possible to go into all kinds of conniptions over this - see  [http://starship.python.net/crew/mwh/bch/module-bytecodehacks.closure.html starship.python.net] - but I'm still not getting what smalltalk does better than the little idiom here.",
      "id": "f3d78bd405031df1a8fde8c23e6b044f"
    },
    {
      "type": "html",
      "text": "<i>Well, Smalltalk works for one :) But try this:</i>",
      "id": "5459aa0e6bc0aca6ac6a94f16860c8c5"
    },
    {
      "type": "code",
      "text": " def foo(list):\n  sum, prod = 0, 1\n  act = Closure(\"sum = sum + arg[0]; prod = prod * arg[0]\")\n  map(act, list)\n  return sum, prod",
      "id": "71bb64a3f91eb875bd2369e2643db98e"
    },
    {
      "type": "html",
      "text": "\nAlthough the original now works, you're right, this foo(list) doesn't work. sum and prod were going into globals, not locals. Unfortunately (?) locals() returns a read-only dictionary, which means Closure can't affect it. You can still do it in a horrible way with globals ...",
      "id": "d4340146b72e03dbbf8746c936dca78c"
    },
    {
      "type": "code",
      "text": " def foo(list):\n  global sum, prod\n  sum, prod = 0, 1\n  act = Closure(\"sum = sum + arg[0]; prod = prod * arg[0]\")\n  map(act, list)\n  return sum, prod",
      "id": "d514b2e2a741ebd2c8b98cc4fbcda8a7"
    },
    {
      "type": "html",
      "text": "\nDon't lose hope entirely, though. <i>locals()</i> is mutable in [[Java Python]], so foo(list) should work fine there.",
      "id": "7a869b8504a4571b1dabf9f7aeaad881"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "<i>The problems with Closure:</i>",
      "id": "145311840a793bdd149c627090757545"
    },
    {
      "type": "html",
      "text": " <i>for one:<br>whitespace is important in Python, and sticking it in weird places and trying to exec the results has problems.</i>",
      "id": "bde0fe071629be5086271f8474c33dee"
    },
    {
      "type": "html",
      "text": "\nThat one's not a big deal once the idiom is established.",
      "id": "6bb316fc12089f699fc904763fa6f6b8"
    },
    {
      "type": "html",
      "text": " <i>For two:<br>syntax errors will not be discovered until run time.</i> Umm, python being a language which typically compiles just-in-time, would that really make much difference?",
      "id": "2e6a0b83c3d6127460a352d33044a56d"
    },
    {
      "type": "html",
      "text": "\nSo what? [[Code Unit Test First]].",
      "id": "05ea31d05f279aee25c082fad47e41a0"
    },
    {
      "type": "html",
      "text": " <i>For three there is no way I can recall to get `what are the local variables in my caller's frame?' without going down to the bytecode level (bytecodehacks), so it can't actually work.</i>",
      "id": "6436038ec86f2ae8f7282f95b613ace3"
    },
    {
      "type": "html",
      "text": "\nActually, there is. <i>locals()</i>. To make this look cute we should capture locals() without explicitly passing it in ... maybe we need to choose between the lesser of two evals? <i>Ugh.</i>",
      "id": "b3df3eb8f94597238f61670e8a393ee5"
    },
    {
      "type": "html",
      "text": "<i>Bytecodehacks attempts closures, but has problems; you have to wrap all the local variables in lists if you expect to change them, it's very low level and in fact contradicts the reference, if not the reference implementation, and probably won't work at all for JPython.</i>",
      "id": "07ad7858246ad4766f5e562fc3f8eb0d"
    },
    {
      "type": "html",
      "text": "\nYes, agreed, the bytecodehacks stuff is more a suggestion to [[Guido Van Rossum]] and his crew, not intended useful to regular python programmers except under very special circumstances.",
      "id": "13b47589b7c238a0890c050ee8288c96"
    },
    {
      "type": "html",
      "text": "<i>Since you can dodge the issue by using an auxiliary object, this is a flaw, not an immense gaping hole, but it's still irritating.</i>",
      "id": "15136a0ca0ccc3615aada0de691286ec"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "\nJust curious: using this idiom, can you do a non-local return?",
      "id": "c77fe322524415d4e538d2b3dc8ffce9"
    },
    {
      "type": "html",
      "text": "<i>Can you be a little more explicit?</i>",
      "id": "b270c5cf5b334b209ad6a2d7b38bf543"
    },
    {
      "type": "html",
      "text": "\nSure. Non-local return is basically the equivalent of longjump in C. Take for example, this Smalltalk block:",
      "id": "044ded5ebb1bfc6e31d6c008c42a26db"
    },
    {
      "type": "code",
      "text": "  [^12]",
      "id": "f3d7a6fef0ae837e4a6a73a9c6c8755f"
    },
    {
      "type": "html",
      "text": "\nThe semantics of non-local return (the ^ symbol) is that instead of returning from the method the block is evaluated in, it returns from the method the block is defined in.",
      "id": "766e4bced5af22f741542cd46efd2538"
    },
    {
      "type": "html",
      "text": "\nHere's an example:",
      "id": "c66c20e6f43f54b066181ea7d76db7f6"
    },
    {
      "type": "code",
      "text": "  BlockExample class>>foo",
      "id": "1ee69f9a30c1f89ce6bfcb35824e4d5f"
    },
    {
      "type": "code",
      "text": "  Dictionary new\n    at: 12 ifAbsent: [^'no such element'].",
      "id": "4b683155e3c7640358c1b8903dee9b05"
    },
    {
      "type": "html",
      "text": "\nThe implementation is Dictionary at:ifAbsent: looks like this:",
      "id": "e545b8c1644af4d1443ba42a0f4ae543"
    },
    {
      "type": "html",
      "text": "at:<br>key ifAbsent: aBlock",
      "id": "19da9b9706a6545b164e86d45688584a"
    },
    {
      "type": "html",
      "text": "^self contents lookUpValue:<br>key for: self ifAbsent: aBlock",
      "id": "9d99ff3b14a0a864b015c7e2eb5b8296"
    },
    {
      "type": "html",
      "text": "\nthe contents of the dictionary is actually a hash table, and its implementation of #lookUpValue:for:ifAbsent: looks like this:",
      "id": "d0000bdcb50c047390a1b9e8ead3522f"
    },
    {
      "type": "html",
      "text": "lookUpValue:<br>key for: client ifAbsent: aBlock",
      "id": "2950a7ab8c61985f55cdc452f2d9c03a"
    },
    {
      "type": "code",
      "text": "  | assoc | \n  assoc := self at: (self findKeyIndex: key for: client).\n  ^assoc == nil\n    '''ifTrue: [aBlock value]'''\n    ifFalse: [assoc value].",
      "id": "8c7e06afb34220298332aeb7eb6c66f2"
    },
    {
      "type": "html",
      "text": "\nThe bold line will evaluate the block from waaaay back up in [[Block Example]]>foo and cause control to return to the sender of #foo, not the sender of #lookUpValue:for:ifAbsent:.",
      "id": "a18fa57d59887c7b0b9d4813f73906bb"
    },
    {
      "type": "html",
      "text": "\nCan you do this in Python with closures?",
      "id": "586d256d3eaaaed4d465ff6de11213c8"
    },
    {
      "type": "html",
      "text": "<i>The trick above is merely an attempt to do closures by glomming the local and global dictionaries. Stack frames don't seem so easy to pick up ... though maybe rooting around in the IDE traceback could show how to grab them. I seem to recall, however, that reusing them is very unsafe.</i>",
      "id": "4c508bf56aee2a1808e0b4ad77995dc1"
    },
    {
      "type": "html",
      "text": "<i>So instead you really ought to check out the new [[Stackless Python]] with its </i>continuations<i>, which I think are exactly what you're looking for. These should be standard pretty soon (1.6?). Or use python's try/throw exception handling. Does smalltalk have try/throw?</i>",
      "id": "11ee525fb4e228645a6549d065268f5c"
    },
    {
      "type": "html",
      "text": "\nSmalltalk does have exceptions. Smalltalk also has non-local returns. They are useful for different things, and in fact quite a few languages have both: [[Common Lisp]] has RETURN-FROM, which uses lexical scoping to decide where to return from, as well as the condition system. It is arguable that non-local returns are easier to understand than using exceptions for non-exceptional purposes, just because both sides must necessarily be in the same textual location.",
      "id": "fd95a50f90cfc9dd4d71b62c678b368e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "\nCombined with map, closures would provide a powerful tool that augments but doesn't compete with objects. The Python Closure class we got above is syntactically and semantically crippled by the current python implementation. The <i>Continuations</i> in [[Stackless Python]], however, seem like they could provide the equivalent of Smalltalk closures. They already do [[Co Routine]]s and much else.",
      "id": "a8acefcd5fc4e76c361913164416b36c"
    },
    {
      "type": "html",
      "text": "<i>Pardon a doubting Thomas, but how does [[Stackless Python]] help the scope issues?</i>",
      "id": "d2fabfb4b260a644b6ed6b8121c348d4"
    },
    {
      "type": "html",
      "text": "\nGood question. Dang, now I gotta go actually understand these continuation things ...",
      "id": "f26c9ffdd51a12121ce46e11eee53de4"
    },
    {
      "type": "html",
      "text": "<i>I wrote what I understand of [[Continuations And Coroutines]] on the [[Stackless Python]] page -- [[Shae Erisson]]</i>",
      "id": "c32d6b95fc527786faa9f9ccebccc89e"
    },
    {
      "type": "html",
      "text": "\nGood job, Shae. Now to use a continuation as a closure we need a way to get data into it ... if those [[Co Routine]]s could message each other maybe ... ?",
      "id": "01173e63c25175e3681d0054e5fb5ce8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "\nTCL is actually quite suitable for smalltalk-style blocks; uplevel and upvar can be used to get the scoping right, and non-local returns work as well. (This makes a certain amount of sense, tcl and smalltalk both use unevaluated blocks to generate control structures)  I don't believe python is as plastic, but some of the examples above are just plain silly. <i>[I am only an egg. -- PM]</i>  Here are some rewrites in a style that doesn't go against the [[Grain Of The Language]]:",
      "id": "982c5061b966b30eb555e2234254842d"
    },
    {
      "type": "code",
      "text": " class Foo:\n  def __init__(self, seq):\n   self.seq = seq",
      "id": "ffeff43da07d95ec379f3e6ce9234f98"
    },
    {
      "type": "code",
      "text": " foo = Foo(\"asdf\")\n for c in foo.seq:\n  print c,\n print ''",
      "id": "ddf8437133609dbaf941fb40c7d4ff9e"
    },
    {
      "type": "html",
      "text": "<i>Note that the above code can be more simply written as:</i>",
      "id": "734f6703dcbaa550e5c7a30368672fa4"
    },
    {
      "type": "code",
      "text": " ''for c in \"asdf\":''\n ''  print c,''\n ''print''",
      "id": "942e4815c80b91d058097b2f1a2b6017"
    },
    {
      "type": "code",
      "text": " def act(state, number):\n  (i, mysum) = state\n  return (i + 1, mysum + number)",
      "id": "a3e8dc0ff536977f2b056508655c6394"
    },
    {
      "type": "code",
      "text": " aList = range(4)\n print reduce(act, aList, (0, 0))",
      "id": "7f69ea39baa45851841cd52d9a66f117"
    },
    {
      "type": "html",
      "text": "\nor, ideally, you would go for absolute simplicity:",
      "id": "9f0ec30891e7f6604301b04c9ec28bb8"
    },
    {
      "type": "code",
      "text": " mylist = range(4)\n print (len(mylist), sum(mylist))",
      "id": "8600ec2ed9d1f9f3fc2ec53f5b2b2ac4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "\nOpinion: Closure ws. Class is not an issue for large code blocks; the size/effort difference in defining them pales in comparison to what you're really trying to accomplish. If you need a process/alogorithm object for some nontrivial purpose, it really won't hurt to go ahead and write it. It goes with the grain of, eg., [[Python Language]].",
      "id": "b340045260b584817460fa3093a06dd4"
    },
    {
      "type": "html",
      "text": "\nOn the other hand, for trivial bits you have [[Lambda Forms]], [[List Comprehension]]s, and functions/methods as first-class, accessable objects that you can pass around and call directly.",
      "id": "0cd683f2b938e3c5513390de0d244cf7"
    },
    {
      "type": "html",
      "text": "\nLastly, you should implement the iterator protocol for interesting collections.",
      "id": "2a660b35caa696d73e8b39ff01ef0248"
    },
    {
      "type": "html",
      "text": "\nHere's the classic example of sum-and-product, with an internal iterator:",
      "id": "ec72780f4370cbda4b046262670adaf1"
    },
    {
      "type": "code",
      "text": " def InternalIterator(func, state):\n  for x in range(1, 7):\n   state = func(state, x)\n  return state",
      "id": "1eb1c1d6301341193c4585612cd3e75d"
    },
    {
      "type": "html",
      "text": "(sum, prod) = [[Internal Iterator]]((lambda (s, p), x:<br>(s+x, p*x)), (0, 1))",
      "id": "5b94fbacbe8ca3cd69dcdf0a161f20a4"
    },
    {
      "type": "html",
      "text": "\nTested on python 2.2 by [[Ian Kjos]]",
      "id": "c9043cd3e962d9dce273e1211f537b27"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "\n[[Blocks In Java]] shows how one can fake closures in a language that doesn't have them.\nThe idea is to construct an \"expression object\" that acts like the desired closure. Effectively, the constructors for expression objects form a small\nsub-language towrite closures in. In principle, a pre-processor to the real\ncompiler could translate \"real\" closures into such an expression sub-language.\nThis shows how closures can be implemented without back-end support.",
      "id": "8c0ecb1118c83b3d0d8b44d7d42c73fa"
    },
    {
      "type": "html",
      "text": "-- [[Stephan Houben]]",
      "id": "45901b327e09f81020ed13787e80e06b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "<i>The [[Pizza Language]] extends [[Java Language]] by adding [[First Class]] functions, and so encourages a functional style of programming. Much more so than the anonymous classes of Java.</i>",
      "id": "8cc29eaa36778aefa976a46ef53d724e"
    },
    {
      "type": "html",
      "text": "\nI just don't understand why first class functions have to be unrelated to objects. A function is just a stateless [[Value Object]], after all. Why would melding functions and objects be problematic? I don't see why they they could not participate in inheritance, etc. ",
      "id": "5e61a226f6d59de53b00a90ec74e3716"
    },
    {
      "type": "html",
      "text": "-- [[Michael Feathers]] (or am I missing something?)",
      "id": "ea0cfb8d8d4afde5427a6df9aa373b7b"
    },
    {
      "type": "html",
      "text": "\nYou're absolutely right. Furthermore, if a function is a closure, it may have\na state. Closures thus completely implement objects, things with an identity and state that can reply to messages. In 1992 [[Ken Dickey]] wrote a fascinating paper [[Scheming With Objects]], which starts as follows:",
      "id": "41c90708694073a7467457dde5d0ac77"
    },
    {
      "type": "html",
      "text": "There is a saying - attributed to [[Norman Adams]] - that 'Objects are a poor man's closures.' In this article we discuss what closures are and how objects and closures are related, show code samples to make these abstract ideas concrete, and implement a Scheme Object System which solves the problems we uncover along the way.",
      "id": "0faa6b726d67bc63f3ed47528624d9d6"
    },
    {
      "type": "html",
      "text": "\nOne might think that [[Referential Transparency]] (e.g., lack of mutation) may preclude objects with a mutable state. Fortunately, this is not the case. For one thing, we can use general, proven techniques - monads and unique types. There are simpler approaches, for example [[Oleg Kiselyov]]'s purely functional object-oriented system ([http://pobox.com/~oleg/ftp/Scheme/index.html#pure-oo pobox.com]). It shows a fully referentially transparent OO system: objects with a distinct state and identity, inheritance and polymorphism -- and not a single assignment. This system shares the drawbacks of OOP as well.",
      "id": "169e471fe269e395ddc10981564c7032"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "I have used objects to implement closures in languages where they were unavailable. I have use closures to implement objects in languages where they were unavailable. QED. -- [[Bottom Mind]]",
      "id": "4b332778c49ff2e9218ec268f55c850c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e5ebfd0f635731e42c5b01be183b818f"
    },
    {
      "type": "html",
      "text": "[[Category Closure]]",
      "id": "53fd7a02cf0373e5ecc5a616e08f4133"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent c2.com]",
      "id": "8723e7020fc958c8203f69cfd66d33b9"
    }
  ],
  "journal": [
    {
      "date": 1370765209000,
      "id": "48c51032329c1eddffa351925bfc1d97",
      "type": "create",
      "item": {
        "title": "Closures And Objects Are Equivalent",
        "story": [
          {
            "type": "html",
            "text": "<i>The venerable master Qc Na was walking with his student, Anton.  Hoping to prompt the master into a discussion, Anton said \"Master, I have heard that objects are a very good thing - is this true?\"  Qc Na looked pityingly at his student and replied, \"Foolish pupil - objects are merely a poor man's closures.\"</i>",
            "id": "1c6ec874dcd8a2ae71aca22fdc11f07d"
          },
          {
            "type": "html",
            "text": "<i>Chastised, Anton took his leave from his master and returned to his cell, intent on studying closures. He carefully read the entire \"Lambda: The Ultimate...\" series of papers and its cousins, and implemented a small Scheme interpreter with a closure-based object system. He learned much, and looked forward to informing his master of his progress.</i>",
            "id": "f15d10528e48a5a5d8ffa05680c09210"
          },
          {
            "type": "html",
            "text": "<i>On his next walk with Qc Na, Anton attempted to impress his master by saying \"Master, I have diligently studied the matter, and now understand that objects are truly a poor man's closures.\" Qc Na responded by hitting Anton with his stick, saying \"When will you learn? Closures are a poor man's object.\" At that moment, Anton became enlightened.</i>",
            "id": "24a904d7b644bc4c511868baed28aee7"
          },
          {
            "type": "html",
            "text": "\nFrom: [http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html people.csail.mit.edu]",
            "id": "a299d92a0974b09988d7b463d6685e0f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "<b>Poll</b>: Are objects and closures equivalent?",
            "id": "7d7d2870a7a95b390516cae924893a73"
          },
          {
            "type": "html",
            "text": "<b>Aye's</b>:",
            "id": "c4ac5cfdc0e40278246cdc3c053174b5"
          },
          {
            "type": "html",
            "text": " (vote here)",
            "id": "460266ca843d682dc2d6c4f59f2844f8"
          },
          {
            "type": "html",
            "text": "<b>Nays</b>:",
            "id": "c60402f014aa046af8e8967e5fadc150"
          },
          {
            "type": "html",
            "text": " Winheim Raulsh - closures are immutable, have no methods, receive no messages, and don't provide the equivalent of inheritance and polymorphism on their own. ",
            "id": "25fc6753c1adfef232c6ab8e49b9647a"
          },
          {
            "type": "html",
            "text": " [[[Eric Tetz]] - a closure *is* mutable (it closes over mutable state, so it's mutable to the same extent that a class instance is) and it's callable (it can receive an \"execute\" message) so it's like a class instance with one public method]",
            "id": "e0461896e8bc5eb7104e995aa95e3157"
          },
          {
            "type": "html",
            "text": " [[Mark Janssen]] - they are equivalent as <i>things</i>, static in themselves, but not in actual usage in anyway whatsoever. See [[Computer Science Version Two]].",
            "id": "8de638c5240a9944a371a073706e73d2"
          },
          {
            "type": "html",
            "text": " (vote here)",
            "id": "460266ca843d682dc2d6c4f59f2844f8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "It is well-known that objects and closures over lexical scopes ([[Lexical Closure]]s) are equivalent things; which one you prefer is a matter of taste and background. (Actors are also equivalent to both; see [[Actors Model]].) Those with a strong functional background (in particular, Lisp/Scheme) tend to prefer closures; and many object systems in [[Lisp Language]] and [[Scheme Language]] (but not including [[Common Lisp Object System]], which uses method polymorphism on pure data objects) use closures to implement objects.",
            "id": "f2450278ae765de17408a64af60969ba"
          },
          {
            "type": "html",
            "text": "<i>[[Structure And Interpretation Of Computer Programs]] gives a [[http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1 mitpress.mit.edu] nice sample for this type of object system].</i>",
            "id": "46d85ceb148c2c479cefe35836cac44f"
          },
          {
            "type": "html",
            "text": "<i>It is not well-known that objects and closures are equivalent. On the contrary, what is \"well-known\" is what [[Luca Cardelli]] presents in the 18th chapter of [[Theory Of Objects]], precisely that encoding object oriented features in lambda calculi is unwieldly and cumbersome, especially when it comes to typed version of those calculi. This page is further evidence as it presents only objects with one method and no inheritance.</i>",
            "id": "9f668f7cb4ac5351c873a1e3b0fe1676"
          },
          {
            "type": "html",
            "text": "\nUsing [[Pattern Matching]], supporting more than one method is no more difficult than supporting a single method. [[Delegation Is Inheritance]], and delegation can be supported straightforwardly by adding a <i>self</i> parameter to calls.",
            "id": "bb7c13aaee49c0d0e6f228e9f3ff06f2"
          },
          {
            "type": "html",
            "text": "<i>In general, emulating object features in a statically typed functional language with closures (and even with more advanced features like modules), for example [[Standard Ml]], is at least cumbersome if not impossible. There are object systems written for Lisp and Scheme, some of them using macros (CLOS), some in functional style without macros, however I don't think there's any particular object system with all the major features (polymorphism, inheritance, etc) written without macros. Nor there should be since object systems with macros look easier to write and comprehend.</i>",
            "id": "0f2abb730668765dfc348e67cef103e4"
          },
          {
            "type": "html",
            "text": "<i>What exactly is the problem with macros? They are used to give you a nicer syntax, which is a Good Idea IMHO.</i>",
            "id": "20719f8e96d57d202c11cd19e9fafb3f"
          },
          {
            "type": "html",
            "text": "[Well it is well known that an object is one particular form of a closure, and a closure can be used as an object, which they often are, and is what the above paragraph is trying to convey. Sure, some languages give us a nice clean little package that wraps up polymorphism and inheritance into a thing called class, but one doesn't need either polymorphism or inheritance to have an object. Polymorphism and inheritance are used to specialize objects, closures are used to create anonymous one-shot objects that don't need specialization, they are complimentary abstractions. You are setting up a straw man here, polymorphism and inheritance are not required to build objects, polymorphism and inheritance may be required to call it object oriented, but not object based. No claim was made that Closures = OO programming, just that objects and closures are equivalent, which is true.]",
            "id": "7ca0df7006eb2a8c910a0c2937605f10"
          },
          {
            "type": "html",
            "text": " <i>Please make up your mind: either closures and objects complement each other, or they are equivalent. You can't have them both. If objects can be perfectly emulated by closures, than objects would be unnecessary entities and unnecessary entities do not complement anything. To complement means to add something essential in order to make up a whole, bring to perfection, supplant, etc. With regards to polymorphism and inheritance, they are essential to objects insofar that high level programming languages are essential to programming (of course we can program in assembly and that would still be called programming).</i>",
            "id": "fb4b3cb609dded82655674fcdd36bdf1"
          },
          {
            "type": "html",
            "text": "[You can have both, don't be so closed minded. Objects wrap up polymorphism and inheritance in an easy to use fashion that would be more verbose with closures, however they don't give you anything special, just a shorter syntax. Objects are necessary for domain entities and such, well-defined objects so to say. Closures are necessary for one-shot objects that aren't well defined, and are different just about every time, but essential none the less. Polymorphism and inheritance are not essential to build an object, that is if you define an object as a thing with state and identity, which closures have.]",
            "id": "b3620243ba8d47555e97c38e58daa0e6"
          },
          {
            "type": "html",
            "text": " I don't think equivalence and complementariness (better word for that?) are mutually exclusive. You can use one to implement the other - that is sufficient to demonstrate equivalence.",
            "id": "d355dd9ffc25d92eafde347f21b533eb"
          },
          {
            "type": "html",
            "text": "<i>More precisely, equivalence means that two concepts can simulate each other </i>without requiring a global transformation on programs<i>. Otherwise we get caught in the [[Turing Trap]].</i>",
            "id": "d25b9f9341780b3831cd941248bc9cfe"
          },
          {
            "type": "html",
            "text": " But that doesn't make one or the other redundant; having both is nice as each can be used to solve different problems. Furthermore, I can simulate either with a rats-nest of pointers and macros, but that doesn'e mean we should abandon both high-level concepts and go back to programming everything in [[Cee Language]].",
            "id": "6cb519b06c839fbcec5974675bd11190"
          },
          {
            "type": "html",
            "text": "<i>The fact that you can use one to implement another do not an equivalence make. The same good old argument that says that Java and assembly are not equivalent programming languages, in spite of the fact all <b>computations</b> that can be implemented in one can be implemented in the other, and you can use Java to implement an assembly interpreter or you can use assembly to implement a Java (bytecode) interpreter.</i>",
            "id": "c7f581f42b327c61ac7917204e00974a"
          },
          {
            "type": "html",
            "text": "<i>The page as it stands now gives a false advice in the sense that if the claim was true, than it would be easier to program in [[Object Oriented]] style in a language like [[Standard Ml]], but it isn't. Neither functional programming subsumes object oriented programming, nor the other way around. It is beneficial for most programmers to know both styles.</i>",
            "id": "0e015fb0e3291c3102ac9fb23f134c79"
          },
          {
            "type": "html",
            "text": " Agreed",
            "id": "df20dd2bb9665a328933b9b5877074c1"
          },
          {
            "type": "html",
            "text": "\nMany modern OO languages, however, don't have full closures. Some languages have something similar (Java [[Inner Class]]es); others don't bother at all. It has been argued ([[Global Variables Considered Harmful]]) that full lexical closures aren't always a good thing - they dramatically increase coupling between modules (as the closure has hooks into the guts of the enclosing scope), and they complicate a language's implementation. (See also [[What Is Closure]] for more on that).",
            "id": "945138acedcbfeda2a2bc9f40f5f7c73"
          },
          {
            "type": "html",
            "text": "\nFor many of the purposes (not all) that a Lisp user might use a closure - an OO programmer would use an <i>object</i> - and an object is often a perfectly good substitute.",
            "id": "6956a5eccb44acf2016f6ee41a5c60e0"
          },
          {
            "type": "html",
            "text": "[[Wait.  Hold on.  What exactly here makes a \"closure\" have to be functional? You can have a \"closure\" also be an object. Java's anonymous inner classes close over the final variables in scope. [[Ee Language]]'s object definitions are closures, which allows it to avoid the concept of a \"class\" without using prototypes and yet still having a central module used to spawn new objects of a given type. Yet, neither of those are exactly \"lambdas\". Yes, they could arguably be defined as [[Hash Map]]s of lambdas, but the point still stands: closures can be defined as anything which can capture lexical variables and take them into other stack frames. They don't actually <i>have</i> to be lambdas.",
            "id": "89e8d37497021e85826a4098d48efdba"
          },
          {
            "type": "html",
            "text": "\nOf course, most people think of them as lambdas. I know what a \"closure\" implies. Still, [[Food For Thought]].]]",
            "id": "41ce6c8297f31a6960842cc5ae3569bc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "[Moved from [[Lexical Scoping]]]",
            "id": "2e90e4359a7d7bc246fab9493dbef4cb"
          },
          {
            "type": "html",
            "text": "\nIn many cases, a bunch of related functions defined within a single outer function (and accessing - incestuously - it's variables) are parts of a single concept - the functions are all tightly coupled and using explicit parameters would become a nightmare (giving you a bunch of functions with dozens of parameters to pass around). Whenever I see this, I see an <b>object</b> waiting to be born. Refactor the whole mess into a class. If you are in a non-OO language; find the union of all the shared state and make it a struct/record - and pass <i>that</i> around (by reference). In both cases, you get the ability to make lots of instances of your abstraction (and to access the inner methods without calling the outermost method first). In the OO case, you get the additional benefits of OO - [[Poly Morphism]] and such.",
            "id": "e64c66c038785789b663618453dddf92"
          },
          {
            "type": "html",
            "text": "\nThis is (or is very similar to) a [[Method Object]].",
            "id": "e4f2350127c80b0a903af6052aecb718"
          },
          {
            "type": "html",
            "text": "<i>Umm, this is not really the common case for closures. You see examples like that, but they're largely academic. Indeed in 90% of the cases where you'd see that pattern, it'd be wiser to use an Object in Lisp. Especially since CLOS provides such an incredible system. Most of the time we're using closures in lambda-passing functions. It is far superior to Java inner classes or C++ functors for this. As an example:</i>",
            "id": "3c900389e08dfd37e1753fa704dbc786"
          },
          {
            "type": "code",
            "text": "  (defun bizzare-example (list)\n  (let ((ctr 0))\n  (mapc (lambda (x) (incf ctr)) list)\n  ctr))",
            "id": "5c44e71ac33025adc8b20f5e9af5926b"
          },
          {
            "type": "html",
            "text": "<i>While trivial and academic, it demonstrates why lisp and scheme programmers like function-passing style with closures so much. The standard combinators like the mapping functions and sorting functions can take the surrounding context into account. Also, closures allow for awesome control-flow constructs like the lisp condition handling system. Heck, people have made a limited kind of continuation just with \"goto\" and closures (but I am not saying that I don't envy Scheme's real continuations).</i>",
            "id": "0e89bcd6cc0f3fa18332c3f15748e55c"
          },
          {
            "type": "html",
            "text": "<i>Closures and Objects are closely related, but closures are more general. You can't really use objects to implement closures unless your object system is actually doing closures under the covers. You can implement objects with closures by linking methods across a set of variables (note in lisp this practice is considered archaic and generic functions are instead used to handle this). </i>",
            "id": "ab62274c6b068d0f11630cbc1771a4a6"
          },
          {
            "type": "html",
            "text": " Maybe I just need another cup of coffee, but my brain is boggling on this phrase: \"linking methods across a set of variables\", could you help me out on its meaning?",
            "id": "db54c18bf103f4ad4a554b9af2268d4b"
          },
          {
            "type": "html",
            "text": "<i> I was unclear. You can make objects (without any kind of dispatch) by creating a closure over a set of variables (data portion) and defining a list of lambdas (code portion) to create rudimentary objects. Adding inheritance and polymorphism from there really isn't that hard. As I said though, these kinds of object systems are unpopular in Lisp and Scheme today, because of the prevailing style in Lisp. Also, some people claim the message-passing system (which people also note is \"specialization on only one argument\") which most systems base themselves off of is inherently inferior compared to the pure multimethods approach that CLOS favors. I personally am on the fence on this issue.</i>",
            "id": "2a415d122e97140c178d7815e1cb9adb"
          },
          {
            "type": "html",
            "text": "<i> My point though, is that closures and objects aren't really equivalent. Objects are a subset of closures, so they carry some similar traits.</i>",
            "id": "0c9d01c7d62ffef4b6000861c82a301f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "\nNote: objects and closures over lexical scopes are equivalent. Idiomatic style of programming in a language that allows nested function definitions takes advantage of this fact, rather than being confounded by it. E.g. a function in the [[Scheme Language]] can return one or more local functions that can use variables in the defining scope, and that are therefore fully encapsulated.",
            "id": "7fa5cdf4155d67186e56cc854346cf75"
          },
          {
            "type": "code",
            "text": " (define (make-counter count)\n  (define (inc) \n  (define old-count count)\n  (set! count (+ 1 count))\n  old-count)\n  inc)",
            "id": "c8002e2605b0e8efe131b9dcf9506ace"
          },
          {
            "type": "code",
            "text": " (define the-counter (make-counter 1))\n (the-counter)\n  ==> returns 1\n (the-counter)\n  ==> returns 2\n ... etc. ...",
            "id": "ba33c67c83d4513e05d53693dd7c0f81"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "\nI'm not sure if I'm grokking the level of equivalence of the above example. It shows me how a single method object is equivalent to an closure, but I'm not seeing how this extends to a multiple-method object (does it?). Could somebody provide a translation of the following into closures:",
            "id": "7f3133af278672716248c1d32b3c7fa5"
          },
          {
            "type": "code",
            "text": "  class Multiplier\n  def initialize(a,b) \n  @a, @b = a,b \n  end\n  def addA(value)\n  @a = @a + value \n  end\n  def addB(value) \n  @b = @b + value \n  end\n  def result\n  @a * @b \n  end\n  end",
            "id": "e8ddf87cd35a48edf8ac848fa8ea916d"
          },
          {
            "type": "code",
            "text": "  mult = Multiplier.new(5, 4)\n  puts mult.result    # returns 5 * 4 = 20\n  mult.addA(3)\n  puts mult.result    # returns 8 * 4 = 32\n  mult.addB(5)\n  puts mult.result    # returns 8 * 9 = 72",
            "id": "7fde1fa061b2ae6f77eabd00d6b927e8"
          },
          {
            "type": "html",
            "text": "\nMy scheme skills are a bit weak, but try this:",
            "id": "3eec62d2e2a356612a2230784ea03987"
          },
          {
            "type": "code",
            "text": "  (define (make-multiplier a b)\n  (lambda (method-name)\n  (case method-name\n  ((add-a)\n   (lambda (value)\n    (set! a (+ a value))))\n  ((add-b)\n   (lambda (value)\n    (set! b (+ b value))))\n  ((result)\n   (lambda ()\n    (* a b))))))",
            "id": "e1e1dbbe8b7d86aa9eaca48c4753a238"
          },
          {
            "type": "code",
            "text": "  (define mult (make-multiplier 5 4))\n  (print ((mult 'result)))    ; prints 20\n  ((mult 'add-a) 3)\n  (print ((mult 'result)))    ; prints 32\n  ((mult 'add-b) 5)\n  (print ((mult 'result)))    ; prints 72",
            "id": "d85d6f83e8aa39d8027a8953ce1abe2a"
          },
          {
            "type": "html",
            "text": "\nmake-multiplier returns a function that takes a method selector, and then returns the appropriate method. The method can then be called normally.",
            "id": "2d246bfbe26186009d57be4445393cb3"
          },
          {
            "type": "html",
            "text": "\nThis is probably not idiomatic Scheme though, which would look more like this:",
            "id": "87f649db8de0d8bcc6a9e19897ec21fd"
          },
          {
            "type": "code",
            "text": "  (define (make-multiplier a b)\n  (list\n  (lambda (value)\n  (set! a (+ a value)))\n  (lambda (value)\n  (set! b (+ b value)))\n  (lambda ()\n  (* a b))))",
            "id": "cc26f40832c99295fb9441432b89da7c"
          },
          {
            "type": "code",
            "text": "  (define (add-a mult)\n  (car mult))",
            "id": "9859ad79abd4fbf54e811447bc55d12c"
          },
          {
            "type": "code",
            "text": "  (define (add-b mult)\n  (cadr mult))",
            "id": "1198b2f30fcaeed9684b89794e1842d5"
          },
          {
            "type": "code",
            "text": "  (define (result mult)\n  (caddr mult))",
            "id": "69539f6b81d11afc538a4f1120e3e6d3"
          },
          {
            "type": "code",
            "text": "  (define mult (make-multiplier 5 4))\n  (print ((result mult)))\n  ((add-a mult) 3)\n  (print ((result mult)))\n  ((add-b mult) 5)\n  (print ((result mult)))",
            "id": "eaf67d04fc9328f13c5529eb41645eb8"
          },
          {
            "type": "html",
            "text": "\nThis time, make-multiplier returns a list of 3 functions: the methods in the class. A production scheme system would probably use a hashtable, alist, or record, some data structure where the methods are not positionally dependent. In any case, there're accessor functions that return the correct lambda, so that the client programmer doesn't need to worry about the actual data structure returned.",
            "id": "1eb9a85c8c624cf01351a7bb812fc351"
          },
          {
            "type": "html",
            "text": "\nYou can get polymorphism too, by replacing the functions within the data structure returned by the constructor, but subclass methods won't be able to access superclass data unless the subclass is lexically enclosed by the superclass. This is annoying, because any moderately deep inheritance hierarchy becomes virtually impossible to read. Granted, most moderately deep inheritance hierarchies in traditional languages aren't very easy to follow either, if the subclasses use large amounts of data in the superclass.",
            "id": "b11f8ce6ced7a18cf8480e17f945d05d"
          },
          {
            "type": "html",
            "text": "<i>An approach which might match the original request better:</i>",
            "id": "aef7ee80f9bc233e82dcee21dbcb2c3c"
          },
          {
            "type": "code",
            "text": " (define (multiplier . x)\n  (case (car x)\n  ('new (let ((a (cadr x)) \n     (b (caddr x)))\n    (lambda message\n    (case (car message)\n     ('add-A (set! a (+ a (cadr message))))\n     ('add-B (set! b (+ b (cadr message))))\n     ('result (* a b))\n     (else (error \"Not a valid instance method of class multiplier.\"))))))\n  (else (error \"Not a valid class method of class multiplier.\"))))",
            "id": "ebdaef967011676baa3f5a3f9e2e0f60"
          },
          {
            "type": "code",
            "text": " (define mult (multiplier 'new 5 4))\n (display (mult 'result))\n (newline)\n (mult 'add-A 3)\n (display (mult 'result))\n (newline)\n (mult 'add-B 5)\n (display (mult 'result))",
            "id": "f5c0350ac70523cb9e63643e7efceed4"
          },
          {
            "type": "html",
            "text": "<i>This code  is a variant of the closure-object idiom demonstrated in [[Structure And Interpretation Of Computer Programs]], chapter 3, which is widely known among Schemers; it has been tested under Dr Scheme and works as designed. While objects could be built manually this way, it would make more sense to define a set of forms to automatically generate the class form, which IIUC is how SOS works. HTH. - [[Jay Osako]]</i>",
            "id": "b6cedb60842252ac34c5f4af0ec145b1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "It's been claimed, on [[Smalltalk Instead Of Python]], that smalltalk is preferable because it has real closures, where Python only has one-shot lambda functions. But if you want to encapsulate a structured state, why not use an object? Perl gives you closures ... but the only use I've seen for them is to hide the data members of an object ... what else can you do with 'em?",
            "id": "0ceeef08019b0332aa779ce97c90771e"
          },
          {
            "type": "html",
            "text": "<i>Well, for one you can write an object system with them. This is a popular exercise in Scheme and at least one of the object systems in SLIB requires no macros.</i>",
            "id": "80d3e65dcbbfc4f581d99b0cfeabcdc7"
          },
          {
            "type": "html",
            "text": "\nA class is simply one form of a more general concept, a closure. In other words, classes are closures... with names, but not all closures need names. The use of closures goes beyond the class concept, and is more general and more powerful. Object systems are written with closures. Closures allow one shot specialized objects, and are far more general than classes.",
            "id": "773fd976cc2872f2a0ca0b54bdc2c4da"
          },
          {
            "type": "html",
            "text": "<i>In Smalltalk they are an enormous convenience. You </i>could<i> create a class with a value method that does just that one computation, but this is a lot of work for little or no gain, and you can't do ifTrue: and while: and such very easily at all. In Python they are unnecessary but still an enormous convenience, and their lack is unfortunate.</i>",
            "id": "e32db4e8767dc64551493f8bf3d85ddd"
          },
          {
            "type": "html",
            "text": "\nCan you give an ur-python snippet that would illustrate what could be done with them if they were in the language?",
            "id": "e15cebc8a0de909e34ddbab60641b4b6"
          },
          {
            "type": "html",
            "text": "<i>If closures were added to Python tomorrow, I could do this:</i>'",
            "id": "21d949273c32b4b95b5da96ae614eb43"
          },
          {
            "type": "code",
            "text": " class Foo:\n  def iterator(self):\n   i = 0\n   def temp():\n    value = self[i]\n    i = i + 1\n    return value\n   return Iterator(temp)",
            "id": "c2cf233e569fa4537821876c615ca7df"
          },
          {
            "type": "code",
            "text": " for node in Foo().iterator():\n  node.process()",
            "id": "69d4d5bcc2960088ad627b7b0e72e014"
          },
          {
            "type": "html",
            "text": "<i>This is a very easy xrange equivalent, if Iterator is a simple class that just handles __getitem__ and the usual Python iteration protocol. It is harder to do in stock Python and as a result people don't do it; I know of no equivalent in the standard libraries save xrange.</i>",
            "id": "19624149756bb7774aeeb1ee5071e5c0"
          },
          {
            "type": "html",
            "text": "\nMaybe the above message is old, but closures exist in Python today. Only the example you given above doesn't work because Python doesn't distinguish between \"let\" and \"setf\"; It creates a new \"let\" block for i within temp, making it different from the i in iterator. The way around this is to uglify the code slightly with an array, which changes \"i = i + 1\" from assignment to a modification of an object.",
            "id": "e62303fb5b693bb08271d8087928fa22"
          },
          {
            "type": "code",
            "text": " class Foo:\n  def iterator(self):\n  i = [0]\n  def temp():\n    value = self[i[0]]\n    i[0] += 1\n    return value\n  return Iterator(temp)",
            "id": "fe898830e3b8e9c07ba300009c1ed88c"
          },
          {
            "type": "code",
            "text": " for node in Foo().iterator():\n  node.process()",
            "id": "69d4d5bcc2960088ad627b7b0e72e014"
          },
          {
            "type": "html",
            "text": "\nYou don't need closures for this:",
            "id": "23587f566d6f3e9d18f85a6fdb0956d5"
          },
          {
            "type": "code",
            "text": " def my_xrange(start, stop=None, step=1):\n  if stop is None:\n    start, stop = 0, start\n  while start < stop:\n   yield start\n   start += step",
            "id": "75da9dfe6331bba581a0a2523929c399"
          },
          {
            "type": "code",
            "text": " for i in my_xrange(7):\n  print i",
            "id": "59ca6e05493b59498c35c4419976fd10"
          },
          {
            "type": "code",
            "text": " for i in my_xrange(4, 100, 3):\n  print i",
            "id": "9905b623c1ac8920ec5c58889da27997"
          },
          {
            "type": "html",
            "text": "\nLocking can also be implemented without closures:",
            "id": "5a8787e0676977d10d8fcd9bc95bf5d5"
          },
          {
            "type": "code",
            "text": " >>> def Lock(func):\n ...  print \"Locking...\" # your self.lock()\n ...  try:\n ...    return func()\n ...  finally:\n ...    print \"Unlocking!\" # your self.unlock()",
            "id": "830a13859c7c84c015447f00b77b2bcd"
          },
          {
            "type": "html",
            "text": ">>> def func():<br>print \"... Now in func!\"",
            "id": "3d16183e19df3078098676631403aa14"
          },
          {
            "type": "code",
            "text": " >>> Lock(func)\n Locking...\n ... Now in func!\n Unlocking!",
            "id": "953dc9af83eaed151a34284dfd4b4245"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "\nThough this still doesn't seem like something I'd use, I see no difficulty. It can be done readily with python's builtin compile and eval:",
            "id": "e8f00eb613ab46261530a13a83fbb778"
          },
          {
            "type": "code",
            "text": " class Closure:\n  def __init__(self, statements, locals=None):\n   import copy\n   self.stuff = compile(statements, \"<string>\", \"exec\")\n   self.locals=copy.deepcopy(locals)\n   self.globals=copy.deepcopy(globals())\n  def __call__(self):\n   return eval(self.stuff, self.locals, self.globals)",
            "id": "bda1221eed6c041958ec16298e7ce6ba"
          },
          {
            "type": "code",
            "text": " Lock.with_lock(Closure(\"\"\"\n  statement1\n  ...\n  statementN\n \"\"\", locals())",
            "id": "466fa0487ab6748aa2b96275c43c2194"
          },
          {
            "type": "html",
            "text": "You might leave <i>locals()</i> out for the most part. I haven't tried to make this work, but it seems straightforward. Do Smalltalk closures do something more magical than this?",
            "id": "c4d9479308d33666e2bb9de6cdac176e"
          },
          {
            "type": "html",
            "text": "<i>Yes. For one thing, they don't make deep copies of the variables referred to:</i>",
            "id": "206d8bde9a7e08aa1c609d66f794f538"
          },
          {
            "type": "code",
            "text": " | i sum |\n i := 0. sum := 0.\n aCollection do: [ :each |\n  i := i + 1.\n  sum := sum + each\n ].",
            "id": "93d80775d19d592f70b1a5a098da3e80"
          },
          {
            "type": "html",
            "text": "<i>or, in the hypothetical Python-with-closures:</i>",
            "id": "b0610480e066421b95b1ac70e9776f7f"
          },
          {
            "type": "code",
            "text": " i, sum = 0, 0\n def act(number):\n  i += 1\n  sum += number\n aList.do(act)",
            "id": "7346e2b57163c041f9d12f4166f6b792"
          },
          {
            "type": "html",
            "text": "<i>actually works. For another thing they're much more efficient and transparent; they only refer to some locals, and you needn't do the full setup for so called downward-funargs, etc. The current Python Way of doing this is to create an object:</i>",
            "id": "f05512d6a80aa708156253b7d346d7f5"
          },
          {
            "type": "code",
            "text": " class Counter:\n  def __init__(self):\n   self.i, self.sum = 0, 0\n  def actOn(self, number):\n   self.i += 1\n   self.sum += number\n c = Counter()\n aList.do(c.actOn)",
            "id": "f54cf625b672eaf45a2d29da81d2b8b2"
          },
          {
            "type": "html",
            "text": "<i>While certainly feasible this is by no stretch of the imagination convenient, particularly for short iteration methods.</i>",
            "id": "f2c1bce3545d5c2a6c55431425022f1d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "\nOkay, I tried the Closure class above and had to ditch the copying because modules wouldn't let themselves be copied. No matter, any relevant state can be stuck inside the <i>statements</i> string.",
            "id": "29523a86bfca8a1bd45b56f7bda132cd"
          },
          {
            "type": "code",
            "text": " class Closure:\n  def __init__(self, statements):\n   self.stuff = compile(statements, \"<string>\", \"exec\")\n  def __call__(self, *arg, **kword):\n   return eval(self.stuff, locals(), globals())",
            "id": "5b9d297d23ed83d74db55d0be2280aa8"
          },
          {
            "type": "html",
            "text": "So then you can do all this with map:",
            "id": "f49c1b955b16a9dfae59241d476cf0c0"
          },
          {
            "type": "code",
            "text": " sum, prod = 0, 1\n act = Closure(\"\"\"\n sum = sum + arg[0]\n prod = prod * arg[0]\n \"\"\")\n map(act, aList)",
            "id": "1f36c8741ecb094af5e128ef1e3666e4"
          },
          {
            "type": "html",
            "text": "The trick is that arg and kword get stuck into locals(). It seems possible to go into all kinds of conniptions over this - see  [http://starship.python.net/crew/mwh/bch/module-bytecodehacks.closure.html starship.python.net] - but I'm still not getting what smalltalk does better than the little idiom here.",
            "id": "f3d78bd405031df1a8fde8c23e6b044f"
          },
          {
            "type": "html",
            "text": "<i>Well, Smalltalk works for one :) But try this:</i>",
            "id": "5459aa0e6bc0aca6ac6a94f16860c8c5"
          },
          {
            "type": "code",
            "text": " def foo(list):\n  sum, prod = 0, 1\n  act = Closure(\"sum = sum + arg[0]; prod = prod * arg[0]\")\n  map(act, list)\n  return sum, prod",
            "id": "71bb64a3f91eb875bd2369e2643db98e"
          },
          {
            "type": "html",
            "text": "\nAlthough the original now works, you're right, this foo(list) doesn't work. sum and prod were going into globals, not locals. Unfortunately (?) locals() returns a read-only dictionary, which means Closure can't affect it. You can still do it in a horrible way with globals ...",
            "id": "d4340146b72e03dbbf8746c936dca78c"
          },
          {
            "type": "code",
            "text": " def foo(list):\n  global sum, prod\n  sum, prod = 0, 1\n  act = Closure(\"sum = sum + arg[0]; prod = prod * arg[0]\")\n  map(act, list)\n  return sum, prod",
            "id": "d514b2e2a741ebd2c8b98cc4fbcda8a7"
          },
          {
            "type": "html",
            "text": "\nDon't lose hope entirely, though. <i>locals()</i> is mutable in [[Java Python]], so foo(list) should work fine there.",
            "id": "7a869b8504a4571b1dabf9f7aeaad881"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "<i>The problems with Closure:</i>",
            "id": "145311840a793bdd149c627090757545"
          },
          {
            "type": "html",
            "text": " <i>for one:<br>whitespace is important in Python, and sticking it in weird places and trying to exec the results has problems.</i>",
            "id": "bde0fe071629be5086271f8474c33dee"
          },
          {
            "type": "html",
            "text": "\nThat one's not a big deal once the idiom is established.",
            "id": "6bb316fc12089f699fc904763fa6f6b8"
          },
          {
            "type": "html",
            "text": " <i>For two:<br>syntax errors will not be discovered until run time.</i> Umm, python being a language which typically compiles just-in-time, would that really make much difference?",
            "id": "2e6a0b83c3d6127460a352d33044a56d"
          },
          {
            "type": "html",
            "text": "\nSo what? [[Code Unit Test First]].",
            "id": "05ea31d05f279aee25c082fad47e41a0"
          },
          {
            "type": "html",
            "text": " <i>For three there is no way I can recall to get `what are the local variables in my caller's frame?' without going down to the bytecode level (bytecodehacks), so it can't actually work.</i>",
            "id": "6436038ec86f2ae8f7282f95b613ace3"
          },
          {
            "type": "html",
            "text": "\nActually, there is. <i>locals()</i>. To make this look cute we should capture locals() without explicitly passing it in ... maybe we need to choose between the lesser of two evals? <i>Ugh.</i>",
            "id": "b3df3eb8f94597238f61670e8a393ee5"
          },
          {
            "type": "html",
            "text": "<i>Bytecodehacks attempts closures, but has problems; you have to wrap all the local variables in lists if you expect to change them, it's very low level and in fact contradicts the reference, if not the reference implementation, and probably won't work at all for JPython.</i>",
            "id": "07ad7858246ad4766f5e562fc3f8eb0d"
          },
          {
            "type": "html",
            "text": "\nYes, agreed, the bytecodehacks stuff is more a suggestion to [[Guido Van Rossum]] and his crew, not intended useful to regular python programmers except under very special circumstances.",
            "id": "13b47589b7c238a0890c050ee8288c96"
          },
          {
            "type": "html",
            "text": "<i>Since you can dodge the issue by using an auxiliary object, this is a flaw, not an immense gaping hole, but it's still irritating.</i>",
            "id": "15136a0ca0ccc3615aada0de691286ec"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "\nJust curious: using this idiom, can you do a non-local return?",
            "id": "c77fe322524415d4e538d2b3dc8ffce9"
          },
          {
            "type": "html",
            "text": "<i>Can you be a little more explicit?</i>",
            "id": "b270c5cf5b334b209ad6a2d7b38bf543"
          },
          {
            "type": "html",
            "text": "\nSure. Non-local return is basically the equivalent of longjump in C. Take for example, this Smalltalk block:",
            "id": "044ded5ebb1bfc6e31d6c008c42a26db"
          },
          {
            "type": "code",
            "text": "  [^12]",
            "id": "f3d7a6fef0ae837e4a6a73a9c6c8755f"
          },
          {
            "type": "html",
            "text": "\nThe semantics of non-local return (the ^ symbol) is that instead of returning from the method the block is evaluated in, it returns from the method the block is defined in.",
            "id": "766e4bced5af22f741542cd46efd2538"
          },
          {
            "type": "html",
            "text": "\nHere's an example:",
            "id": "c66c20e6f43f54b066181ea7d76db7f6"
          },
          {
            "type": "code",
            "text": "  BlockExample class>>foo",
            "id": "1ee69f9a30c1f89ce6bfcb35824e4d5f"
          },
          {
            "type": "code",
            "text": "  Dictionary new\n    at: 12 ifAbsent: [^'no such element'].",
            "id": "4b683155e3c7640358c1b8903dee9b05"
          },
          {
            "type": "html",
            "text": "\nThe implementation is Dictionary at:ifAbsent: looks like this:",
            "id": "e545b8c1644af4d1443ba42a0f4ae543"
          },
          {
            "type": "html",
            "text": "at:<br>key ifAbsent: aBlock",
            "id": "19da9b9706a6545b164e86d45688584a"
          },
          {
            "type": "html",
            "text": "^self contents lookUpValue:<br>key for: self ifAbsent: aBlock",
            "id": "9d99ff3b14a0a864b015c7e2eb5b8296"
          },
          {
            "type": "html",
            "text": "\nthe contents of the dictionary is actually a hash table, and its implementation of #lookUpValue:for:ifAbsent: looks like this:",
            "id": "d0000bdcb50c047390a1b9e8ead3522f"
          },
          {
            "type": "html",
            "text": "lookUpValue:<br>key for: client ifAbsent: aBlock",
            "id": "2950a7ab8c61985f55cdc452f2d9c03a"
          },
          {
            "type": "code",
            "text": "  | assoc | \n  assoc := self at: (self findKeyIndex: key for: client).\n  ^assoc == nil\n    '''ifTrue: [aBlock value]'''\n    ifFalse: [assoc value].",
            "id": "8c7e06afb34220298332aeb7eb6c66f2"
          },
          {
            "type": "html",
            "text": "\nThe bold line will evaluate the block from waaaay back up in [[Block Example]]>foo and cause control to return to the sender of #foo, not the sender of #lookUpValue:for:ifAbsent:.",
            "id": "a18fa57d59887c7b0b9d4813f73906bb"
          },
          {
            "type": "html",
            "text": "\nCan you do this in Python with closures?",
            "id": "586d256d3eaaaed4d465ff6de11213c8"
          },
          {
            "type": "html",
            "text": "<i>The trick above is merely an attempt to do closures by glomming the local and global dictionaries. Stack frames don't seem so easy to pick up ... though maybe rooting around in the IDE traceback could show how to grab them. I seem to recall, however, that reusing them is very unsafe.</i>",
            "id": "4c508bf56aee2a1808e0b4ad77995dc1"
          },
          {
            "type": "html",
            "text": "<i>So instead you really ought to check out the new [[Stackless Python]] with its </i>continuations<i>, which I think are exactly what you're looking for. These should be standard pretty soon (1.6?). Or use python's try/throw exception handling. Does smalltalk have try/throw?</i>",
            "id": "11ee525fb4e228645a6549d065268f5c"
          },
          {
            "type": "html",
            "text": "\nSmalltalk does have exceptions. Smalltalk also has non-local returns. They are useful for different things, and in fact quite a few languages have both: [[Common Lisp]] has RETURN-FROM, which uses lexical scoping to decide where to return from, as well as the condition system. It is arguable that non-local returns are easier to understand than using exceptions for non-exceptional purposes, just because both sides must necessarily be in the same textual location.",
            "id": "fd95a50f90cfc9dd4d71b62c678b368e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "\nCombined with map, closures would provide a powerful tool that augments but doesn't compete with objects. The Python Closure class we got above is syntactically and semantically crippled by the current python implementation. The <i>Continuations</i> in [[Stackless Python]], however, seem like they could provide the equivalent of Smalltalk closures. They already do [[Co Routine]]s and much else.",
            "id": "a8acefcd5fc4e76c361913164416b36c"
          },
          {
            "type": "html",
            "text": "<i>Pardon a doubting Thomas, but how does [[Stackless Python]] help the scope issues?</i>",
            "id": "d2fabfb4b260a644b6ed6b8121c348d4"
          },
          {
            "type": "html",
            "text": "\nGood question. Dang, now I gotta go actually understand these continuation things ...",
            "id": "f26c9ffdd51a12121ce46e11eee53de4"
          },
          {
            "type": "html",
            "text": "<i>I wrote what I understand of [[Continuations And Coroutines]] on the [[Stackless Python]] page -- [[Shae Erisson]]</i>",
            "id": "c32d6b95fc527786faa9f9ccebccc89e"
          },
          {
            "type": "html",
            "text": "\nGood job, Shae. Now to use a continuation as a closure we need a way to get data into it ... if those [[Co Routine]]s could message each other maybe ... ?",
            "id": "01173e63c25175e3681d0054e5fb5ce8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "\nTCL is actually quite suitable for smalltalk-style blocks; uplevel and upvar can be used to get the scoping right, and non-local returns work as well. (This makes a certain amount of sense, tcl and smalltalk both use unevaluated blocks to generate control structures)  I don't believe python is as plastic, but some of the examples above are just plain silly. <i>[I am only an egg. -- PM]</i>  Here are some rewrites in a style that doesn't go against the [[Grain Of The Language]]:",
            "id": "982c5061b966b30eb555e2234254842d"
          },
          {
            "type": "code",
            "text": " class Foo:\n  def __init__(self, seq):\n   self.seq = seq",
            "id": "ffeff43da07d95ec379f3e6ce9234f98"
          },
          {
            "type": "code",
            "text": " foo = Foo(\"asdf\")\n for c in foo.seq:\n  print c,\n print ''",
            "id": "ddf8437133609dbaf941fb40c7d4ff9e"
          },
          {
            "type": "html",
            "text": "<i>Note that the above code can be more simply written as:</i>",
            "id": "734f6703dcbaa550e5c7a30368672fa4"
          },
          {
            "type": "code",
            "text": " ''for c in \"asdf\":''\n ''  print c,''\n ''print''",
            "id": "942e4815c80b91d058097b2f1a2b6017"
          },
          {
            "type": "code",
            "text": " def act(state, number):\n  (i, mysum) = state\n  return (i + 1, mysum + number)",
            "id": "a3e8dc0ff536977f2b056508655c6394"
          },
          {
            "type": "code",
            "text": " aList = range(4)\n print reduce(act, aList, (0, 0))",
            "id": "7f69ea39baa45851841cd52d9a66f117"
          },
          {
            "type": "html",
            "text": "\nor, ideally, you would go for absolute simplicity:",
            "id": "9f0ec30891e7f6604301b04c9ec28bb8"
          },
          {
            "type": "code",
            "text": " mylist = range(4)\n print (len(mylist), sum(mylist))",
            "id": "8600ec2ed9d1f9f3fc2ec53f5b2b2ac4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "\nOpinion: Closure ws. Class is not an issue for large code blocks; the size/effort difference in defining them pales in comparison to what you're really trying to accomplish. If you need a process/alogorithm object for some nontrivial purpose, it really won't hurt to go ahead and write it. It goes with the grain of, eg., [[Python Language]].",
            "id": "b340045260b584817460fa3093a06dd4"
          },
          {
            "type": "html",
            "text": "\nOn the other hand, for trivial bits you have [[Lambda Forms]], [[List Comprehension]]s, and functions/methods as first-class, accessable objects that you can pass around and call directly.",
            "id": "0cd683f2b938e3c5513390de0d244cf7"
          },
          {
            "type": "html",
            "text": "\nLastly, you should implement the iterator protocol for interesting collections.",
            "id": "2a660b35caa696d73e8b39ff01ef0248"
          },
          {
            "type": "html",
            "text": "\nHere's the classic example of sum-and-product, with an internal iterator:",
            "id": "ec72780f4370cbda4b046262670adaf1"
          },
          {
            "type": "code",
            "text": " def InternalIterator(func, state):\n  for x in range(1, 7):\n   state = func(state, x)\n  return state",
            "id": "1eb1c1d6301341193c4585612cd3e75d"
          },
          {
            "type": "html",
            "text": "(sum, prod) = [[Internal Iterator]]((lambda (s, p), x:<br>(s+x, p*x)), (0, 1))",
            "id": "5b94fbacbe8ca3cd69dcdf0a161f20a4"
          },
          {
            "type": "html",
            "text": "\nTested on python 2.2 by [[Ian Kjos]]",
            "id": "c9043cd3e962d9dce273e1211f537b27"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "\n[[Blocks In Java]] shows how one can fake closures in a language that doesn't have them.\nThe idea is to construct an \"expression object\" that acts like the desired closure. Effectively, the constructors for expression objects form a small\nsub-language towrite closures in. In principle, a pre-processor to the real\ncompiler could translate \"real\" closures into such an expression sub-language.\nThis shows how closures can be implemented without back-end support.",
            "id": "8c0ecb1118c83b3d0d8b44d7d42c73fa"
          },
          {
            "type": "html",
            "text": "-- [[Stephan Houben]]",
            "id": "45901b327e09f81020ed13787e80e06b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "<i>The [[Pizza Language]] extends [[Java Language]] by adding [[First Class]] functions, and so encourages a functional style of programming. Much more so than the anonymous classes of Java.</i>",
            "id": "8cc29eaa36778aefa976a46ef53d724e"
          },
          {
            "type": "html",
            "text": "\nI just don't understand why first class functions have to be unrelated to objects. A function is just a stateless [[Value Object]], after all. Why would melding functions and objects be problematic? I don't see why they they could not participate in inheritance, etc. ",
            "id": "5e61a226f6d59de53b00a90ec74e3716"
          },
          {
            "type": "html",
            "text": "-- [[Michael Feathers]] (or am I missing something?)",
            "id": "ea0cfb8d8d4afde5427a6df9aa373b7b"
          },
          {
            "type": "html",
            "text": "\nYou're absolutely right. Furthermore, if a function is a closure, it may have\na state. Closures thus completely implement objects, things with an identity and state that can reply to messages. In 1992 [[Ken Dickey]] wrote a fascinating paper [[Scheming With Objects]], which starts as follows:",
            "id": "41c90708694073a7467457dde5d0ac77"
          },
          {
            "type": "html",
            "text": "There is a saying - attributed to [[Norman Adams]] - that 'Objects are a poor man's closures.' In this article we discuss what closures are and how objects and closures are related, show code samples to make these abstract ideas concrete, and implement a Scheme Object System which solves the problems we uncover along the way.",
            "id": "0faa6b726d67bc63f3ed47528624d9d6"
          },
          {
            "type": "html",
            "text": "\nOne might think that [[Referential Transparency]] (e.g., lack of mutation) may preclude objects with a mutable state. Fortunately, this is not the case. For one thing, we can use general, proven techniques - monads and unique types. There are simpler approaches, for example [[Oleg Kiselyov]]'s purely functional object-oriented system ([http://pobox.com/~oleg/ftp/Scheme/index.html#pure-oo pobox.com]). It shows a fully referentially transparent OO system: objects with a distinct state and identity, inheritance and polymorphism -- and not a single assignment. This system shares the drawbacks of OOP as well.",
            "id": "169e471fe269e395ddc10981564c7032"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "I have used objects to implement closures in languages where they were unavailable. I have use closures to implement objects in languages where they were unavailable. QED. -- [[Bottom Mind]]",
            "id": "4b332778c49ff2e9218ec268f55c850c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e5ebfd0f635731e42c5b01be183b818f"
          },
          {
            "type": "html",
            "text": "[[Category Closure]]",
            "id": "53fd7a02cf0373e5ecc5a616e08f4133"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent c2.com]",
            "id": "8723e7020fc958c8203f69cfd66d33b9"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1674055865752
    }
  ]
}