{
  "title": "Match with Heuristics",
  "story": [
    {
      "type": "paragraph",
      "id": "0b2321e4490ba47e",
      "text": "We will find that the names of things we care about vary from source to source so it is upon us to reconcile these variations so as to produce reliable node identifiers during the transform step."
    },
    {
      "type": "paragraph",
      "id": "1ed527240400b5e5",
      "text": "See [[Why Names Don't Match]]"
    },
    {
      "type": "paragraph",
      "id": "c11968ccaf3bf8bd",
      "text": "Consider the case where we want to retrieve an employee's id number given some subset of information of questionable consistency. Often a human can recognize a correspondence based on partial matches and familiar substitutions."
    },
    {
      "type": "paragraph",
      "id": "1a0ff1755e238ad4",
      "text": "John Doe ≃ Jonathan Doe"
    },
    {
      "type": "paragraph",
      "id": "1ec79f7fc754364a",
      "text": "@jdoe ≃ jdoe@example.com"
    },
    {
      "type": "paragraph",
      "id": "f82a74c799969f74",
      "text": "Our approach will be to read the more definitive sources first, match new names by applying rules, and record the chosen rule in each relation thus constructed."
    },
    {
      "type": "paragraph",
      "id": "0533408ed6c26c23",
      "text": "We often make a new class to manage rule evaluation but here is serviable ruby code where each rule returns true when successful having read and modified @props and identified itself in @rule. The result of the heuristic match is a tuple of [node, rule] where rule will be added to subsequent relations."
    },
    {
      "type": "code",
      "id": "a74dded2530487be",
      "text": "def match_employee props\n  @props = props\n  if rule1 || rule 2 || rule3 || rule4\n    [node('EMPLOYEE', @props), @rule]\n  else\n    [node('STRANGER', @props), 'no match']\n  end\nend"
    },
    {
      "type": "paragraph",
      "id": "5ae91ebdaccfb7d5",
      "text": "We can query for strangers, an obvious failure."
    },
    {
      "type": "code",
      "id": "2f4ee779cb9601a8",
      "text": "match (s:STRANGER)\nreturn\n  s.name as name,\n  s.email as email"
    },
    {
      "type": "paragraph",
      "id": "d4eee3db68d7653a",
      "text": "We can also query for matches for each rule to look for less obvious failures of individual heuristics."
    },
    {
      "type": "code",
      "id": "0e0c423383c9c1ed",
      "text": "match (e:EMPLOYEE)-[r]-(x)\nwhere exists(r.rule)\nreturn\n  r.rule as rule,\n  collect(distinct e.name + e.email) as employee,\n  collect(distinct r.source) as source"
    },
    {
      "type": "paragraph",
      "id": "39f6a14ee161939e",
      "text": "We often write multiple queries which drill down into cases when the heuristics are complex and edge cases obscure. This might seem tedious but it is really a privileged view into how work happens."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Match with Heuristics",
        "story": []
      },
      "date": 1508596323034
    },
    {
      "item": {
        "type": "factory",
        "id": "0b2321e4490ba47e"
      },
      "id": "0b2321e4490ba47e",
      "type": "add",
      "date": 1508596471484
    },
    {
      "type": "edit",
      "id": "0b2321e4490ba47e",
      "item": {
        "type": "paragraph",
        "id": "0b2321e4490ba47e",
        "text": "We will find that the names of things we care about vary from source to source so it is upon us to reconcile these variations so as to produce reliable node identifiers during the transform step."
      },
      "date": 1508596754397
    },
    {
      "type": "add",
      "id": "1ed527240400b5e5",
      "item": {
        "type": "paragraph",
        "id": "1ed527240400b5e5",
        "text": "See [[Why Names Don't Match]]"
      },
      "after": "0b2321e4490ba47e",
      "date": 1508596801650
    },
    {
      "type": "add",
      "id": "c11968ccaf3bf8bd",
      "item": {
        "type": "paragraph",
        "id": "c11968ccaf3bf8bd",
        "text": "Consider the case where we want to retrieve an employee's id number given some subset of information of questionable consistency. Often a human can recognize a correspondence based on partial matches and familiar substitutions."
      },
      "after": "1ed527240400b5e5",
      "date": 1508597750737
    },
    {
      "type": "add",
      "id": "1a0ff1755e238ad4",
      "item": {
        "type": "paragraph",
        "id": "1a0ff1755e238ad4",
        "text": "John Doe ≣ Jonathan Doe"
      },
      "after": "c11968ccaf3bf8bd",
      "date": 1508597805772
    },
    {
      "type": "add",
      "id": "1ec79f7fc754364a",
      "item": {
        "type": "paragraph",
        "id": "1ec79f7fc754364a",
        "text": "jdoe ≣ jdoe@example.com"
      },
      "after": "1a0ff1755e238ad4",
      "date": 1508597846495
    },
    {
      "type": "add",
      "id": "f82a74c799969f74",
      "item": {
        "type": "paragraph",
        "id": "f82a74c799969f74",
        "text": "Our approach will be to read the more definitive sources first, match new names by applying rules, and record the chosen rule in each relation thus constructed."
      },
      "after": "1ec79f7fc754364a",
      "date": 1508598455108
    },
    {
      "item": {
        "type": "factory",
        "id": "a74dded2530487be"
      },
      "id": "a74dded2530487be",
      "type": "add",
      "after": "f82a74c799969f74",
      "date": 1508598605087
    },
    {
      "type": "edit",
      "id": "a74dded2530487be",
      "item": {
        "type": "code",
        "id": "a74dded2530487be",
        "text": "def employee name, email\n  if rule1 || rule 2 || rule3 || rule4\n"
      },
      "date": 1508598788151
    },
    {
      "type": "edit",
      "id": "a74dded2530487be",
      "item": {
        "type": "code",
        "id": "a74dded2530487be",
        "text": "def employee props\n  @props = props\n  if rule1 || rule 2 || rule3 || rule4\n    [node('EMPLOYEE', @props), @rule]\n  else\n    [node('STRANGER', @props), 'no match']\nend"
      },
      "date": 1508599058683
    },
    {
      "type": "add",
      "id": "0533408ed6c26c23",
      "item": {
        "type": "paragraph",
        "id": "0533408ed6c26c23",
        "text": "We often make a new class to manage rule evaluation but here is serviable ruby code where each rule returns true when successful having read and modified @props and identified itself in @rule. The result of the heuristic match is a tuple of [node, rule] where rule will be added to subsequent relations."
      },
      "after": "f82a74c799969f74",
      "date": 1508599473683
    },
    {
      "type": "edit",
      "id": "a74dded2530487be",
      "item": {
        "type": "code",
        "id": "a74dded2530487be",
        "text": "def match_employee props\n  @props = props\n  if rule1 || rule 2 || rule3 || rule4\n    [node('EMPLOYEE', @props), @rule]\n  else\n    [node('STRANGER', @props), 'no match']\n  end\nend"
      },
      "date": 1508599518074
    },
    {
      "item": {
        "type": "factory",
        "id": "5ae91ebdaccfb7d5"
      },
      "id": "5ae91ebdaccfb7d5",
      "type": "add",
      "after": "a74dded2530487be",
      "date": 1508599699172
    },
    {
      "type": "edit",
      "id": "5ae91ebdaccfb7d5",
      "item": {
        "type": "paragraph",
        "id": "5ae91ebdaccfb7d5",
        "text": "We can query for strangers, an obvious failure."
      },
      "date": 1508599863214
    },
    {
      "item": {
        "type": "factory",
        "id": "2f4ee779cb9601a8"
      },
      "id": "2f4ee779cb9601a8",
      "type": "add",
      "after": "5ae91ebdaccfb7d5",
      "date": 1508599866701
    },
    {
      "type": "edit",
      "id": "2f4ee779cb9601a8",
      "item": {
        "type": "code",
        "id": "2f4ee779cb9601a8",
        "text": "match (s:STRANGER)\nreturn\n  s.name as name,\n  s.email as email"
      },
      "date": 1508599924394
    },
    {
      "item": {
        "type": "factory",
        "id": "d4eee3db68d7653a"
      },
      "id": "d4eee3db68d7653a",
      "type": "add",
      "after": "2f4ee779cb9601a8",
      "date": 1508599973877
    },
    {
      "type": "edit",
      "id": "d4eee3db68d7653a",
      "item": {
        "type": "paragraph",
        "id": "d4eee3db68d7653a",
        "text": "We can also query for matches for each rule to look for less obvious failures of individual heuristics."
      },
      "date": 1508600066429
    },
    {
      "item": {
        "type": "factory",
        "id": "0e0c423383c9c1ed"
      },
      "id": "0e0c423383c9c1ed",
      "type": "add",
      "after": "d4eee3db68d7653a",
      "date": 1508600076186
    },
    {
      "type": "edit",
      "id": "0e0c423383c9c1ed",
      "item": {
        "type": "code",
        "id": "0e0c423383c9c1ed",
        "text": "match (e:EMPLOYEE)-[r]-(x)\nwhere exists(r.rule)\nreturn\n  r.rule as rule,\n  collect(distinct e.name + e.email) as employee,\n  collect(distinct r.source) as source"
      },
      "date": 1508600521933
    },
    {
      "item": {
        "type": "factory",
        "id": "39f6a14ee161939e"
      },
      "id": "39f6a14ee161939e",
      "type": "add",
      "after": "0e0c423383c9c1ed",
      "date": 1508600620684
    },
    {
      "type": "edit",
      "id": "39f6a14ee161939e",
      "item": {
        "type": "paragraph",
        "id": "39f6a14ee161939e",
        "text": "We will often write multiple queries which drill down into cases when the heuristics are complex and edge cases obscure. This might seem tedious but it is really a privileged view into how work happens."
      },
      "date": 1508600809579
    },
    {
      "type": "edit",
      "id": "39f6a14ee161939e",
      "item": {
        "type": "paragraph",
        "id": "39f6a14ee161939e",
        "text": "We often write multiple queries which drill down into cases when the heuristics are complex and edge cases obscure. This might seem tedious but it is really a privileged view into how work happens."
      },
      "date": 1508600827600
    },
    {
      "type": "add",
      "id": "abdd963031380523",
      "item": {
        "type": "paragraph",
        "id": "abdd963031380523",
        "text": "See [[Sharing Ad-Hoc Queries]]"
      },
      "after": "39f6a14ee161939e",
      "date": 1508611523377
    },
    {
      "type": "remove",
      "id": "abdd963031380523",
      "date": 1508613251934
    },
    {
      "type": "edit",
      "id": "1a0ff1755e238ad4",
      "item": {
        "type": "paragraph",
        "id": "1a0ff1755e238ad4",
        "text": "John Doe ≊ Jonathan Doe"
      },
      "date": 1508613850618
    },
    {
      "type": "edit",
      "id": "1a0ff1755e238ad4",
      "item": {
        "type": "paragraph",
        "id": "1a0ff1755e238ad4",
        "text": "John Doe ≃ Jonathan Doe"
      },
      "date": 1508613876084
    },
    {
      "type": "edit",
      "id": "1ec79f7fc754364a",
      "item": {
        "type": "paragraph",
        "id": "1ec79f7fc754364a",
        "text": "jdoe ≃ jdoe@example.com"
      },
      "date": 1508613886797
    },
    {
      "type": "edit",
      "id": "1ec79f7fc754364a",
      "item": {
        "type": "paragraph",
        "id": "1ec79f7fc754364a",
        "text": "@jdoe ≃ jdoe@example.com"
      },
      "date": 1508613922686
    },
    {
      "type": "fork",
      "site": "ddd.ward.wiki.org",
      "date": 1627665666616
    }
  ]
}