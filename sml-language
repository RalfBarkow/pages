{
  "title": "Sml Language",
  "story": [
    {
      "type": "html",
      "text": "Standard ML (or SML for short) is a modern dialect of ML [[[Ml Language]]].",
      "id": "46455e4c9c5b0826478c49a1d657fa2e"
    },
    {
      "type": "html",
      "text": "\nSee [http://www.smlnj.org/sml.html www.smlnj.org] and [http://www.smlnj.org/sml97.html www.smlnj.org].",
      "id": "4312d2bbc2dcecb433f63bcb4dcc4b2e"
    },
    {
      "type": "html",
      "text": "\nType-based pattern matching and function tricks\nmake this a handy language for writing compilers.",
      "id": "f81aa725a144bc08ea4910ca26e27a75"
    },
    {
      "type": "html",
      "text": "\nAlso see [[Ml Kit]], [[Ml Ton]], and [[Sml Nj Language]]. And [[Sml Unit]].",
      "id": "40c52576062f3cc1fb6dc30f93e9cb7f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "59deefc4dacf1e87b33648209025e607"
    },
    {
      "type": "html",
      "text": "\nHow about some programming examples? I'll start small and simple:",
      "id": "90d360ec2b055043fbc564e027f14c55"
    },
    {
      "type": "code",
      "text": " (* A comment in SML. (* They can be nested. *) *)",
      "id": "bca13793368f1e2f5bfc1505dc1ce258"
    },
    {
      "type": "code",
      "text": " (* This function recurses along a list, applying a function to each element and an accumulator in turn.\n    Note the pattern matching and the use of _, which matches (and ignores) anything. *)",
      "id": "5be42027b76020f80861748b2c2b7cfc"
    },
    {
      "type": "code",
      "text": " fun revfold _ nil b = b (* If the second argument is nil (an empty list), return the third argument. *)\n | revfold f (hd::tl) b = revfold f tl (f(hd,b)); (* Otherwise, recurse on the tail of the list and\n                                                     replace b with the result of applying f to the head\n                                                     of the list and the old b. *)",
      "id": "855e18033f347e8f67bde7b60fc112ec"
    },
    {
      "type": "code",
      "text": " (* More pattern matching, this time to destructure the list (the second argument) into a head (hd) and\n    a tail (tl). The head is a single list element, the tail is the rest of the list (which may be nil). *)",
      "id": "d36e74d34cfba989d68afee0b47dc3d8"
    },
    {
      "type": "html",
      "text": "(* The type of this function is \"val revfold = fn :<br>('a * 'b -> 'b) -> 'a list -> 'b -> 'b\".",
      "id": "e2da2cd5bc74399533852aee177d821b"
    },
    {
      "type": "code",
      "text": "    This means that the first argument is a function of a two-element tuple of incomplete types 'a and 'b\n    which may or may not be the same. The function must return a value of type 'b, however. The second\n    argument is a list of elements of type 'a, and the third argument is a single object of type 'b. The\n    return value is also a single object of type 'b. *)",
      "id": "5d49f4cd691a344c2c1a5410d57464b2"
    },
    {
      "type": "code",
      "text": "  (* Filter out undesirable elements from a list. *)",
      "id": "2e1765c1bcd8df738f7b03cb62212a56"
    },
    {
      "type": "code",
      "text": "  fun filter _ nil = nil\n  |   filter f (hd::tl) = if (f hd) then hd::(filter f tl) else (filter f tl);",
      "id": "28b9b48e4ccd56ca2979d77c885158cd"
    },
    {
      "type": "html",
      "text": "(* Another basic recursive function. The if..then..else works exactly as expected. The ::<br>infix operator",
      "id": "7e3141b1943c20a8bfa6d88745d808d8"
    },
    {
      "type": "html",
      "text": "is cons from Lisp:<br>It glues individual objects into lists. The list [1,2,3] can also be written",
      "id": "79bea363b3744dff8e55dd30697f7290"
    },
    {
      "type": "code",
      "text": "     1::2::3::nil, just like the Lisp list '(1 2 3) can also be written '(1 . (2 . (3 . nil))). *)",
      "id": "323b2e6983a5cab301f0daa4a8b78d10"
    },
    {
      "type": "code",
      "text": "  (* Check to see if a value is in a specific range. *)\n  (* This function takes two arguments: A two-element tuple of ints and a single int. *)",
      "id": "1c49ce9ca75430ece47a9f1ecc7f3afe"
    },
    {
      "type": "code",
      "text": "  fun inRange (min,max) v = ((v >= min) andalso (v <= max));",
      "id": "dd008a5675ac9a6ed3f7844981adee89"
    },
    {
      "type": "code",
      "text": "  (* Determine if a given character is a decimal digit. *)\n  (* The o operator is the composition operator: It works such that f o g is equivalent to f(g(x)) for\n     some implicit x. Here, it allows us to trivially convert the argument from a char to an int\n     before passing it to the anonymous function of one argument created by just passing \n     inRange the tuple. *)",
      "id": "4d3f88d6cab7a6e631a754a3e144390d"
    },
    {
      "type": "code",
      "text": "  val digitp = inRange (Char.ord #\"0\", Char.ord #\"9\") o Char.ord;",
      "id": "0883b2cb80454aba596be2a10a8db858"
    },
    {
      "type": "code",
      "text": "  (* The classic atoi function. The first argument to revfold is what anonymous functions look like.\n     Char.ord converts characters into ints and explode turns strings into lists of characters. *)",
      "id": "3461b25dbc2b7d0e1e45b9ef17c613c7"
    },
    {
      "type": "code",
      "text": "  fun atoi s = revfold (fn(a,b)=>((Char.ord a)-(Char.ord #\"0\")+10*b) (filter digitp (explode s)) 0;",
      "id": "e72ae2bd3dd7a50dbeadb35ad2ad9927"
    },
    {
      "type": "code",
      "text": "  (* The inevitable factorial function. Note the two special cases handled by pattern-matching. *)",
      "id": "ed2ed87ef709d8f7616bdef8bdd67cbf"
    },
    {
      "type": "code",
      "text": "  fun fac 0 = 0\n  |   fac 1 = 1\n  |   fac n = if n < 0 then n else n*(fac(n-1));",
      "id": "12ffc05f5ee0357635705d0da4ffa2a7"
    },
    {
      "type": "code",
      "text": "  (* Compute the factorial of the number represented by the string and return the result as a string. *)",
      "id": "1982181bdac8a17f92fc9920e6e79c2e"
    },
    {
      "type": "code",
      "text": "  fun strfac s = Int.toString(fac(atoi s)); (* Int.toString is a standard library function. *)",
      "id": "ef7b3989ca505b7a16b0e15ceed41411"
    },
    {
      "type": "code",
      "text": "  (* Determine if the string really is a valid number. Useful for error reporting. *)\n  (* REALLY useful for showing off let..in..end blocks and lexical functions. ;) *)",
      "id": "4ae23221fbd8299e7cbe7c888c578613"
    },
    {
      "type": "code",
      "text": "  fun check \"\" = true\n  |   check s =\n          let fun inner nil = true\n              |   inner (hd::tl) = digitp hd andalso inner tl\n          in inner (explode s) end;",
      "id": "d9e72ce2b1e4fdc5a1c51d8e159c8e31"
    },
    {
      "type": "code",
      "text": "  (* I do it this way instead of with revfold because this function will bail early \n     if the string is not valid. *)",
      "id": "742faa78d995757fad99dd78732e4f20"
    },
    {
      "type": "code",
      "text": "  (* The main function. Note how the 'val _ =' means the return value of the main loop is thrown away. *)\n  (* The function app is like map in that it maps its first (function) argument across its second (list),\n     but it does not return a (useful) value. It is only useful if the function has side-effects. Such as\n     printing something. Like this one does. *)",
      "id": "4afcdfe1dcf595c23b744b6ba681c20e"
    },
    {
      "type": "code",
      "text": "  val _ =\n     app (fn s => (if not (check s) then (print s; print \" is not a number\\n\")\n             else (print s; print \"\\t\"; print(strfac s); print \"\\n\"))) (CommandLine.arguments());",
      "id": "856925ece060b5da861a7bfd4e48cd33"
    },
    {
      "type": "html",
      "text": "(* [[Command Line]].arguments is a function of one argument:<br>(), also called unit. A function of no arguments",
      "id": "a97ecb62afedc6b1ea3553f1175006bc"
    },
    {
      "type": "html",
      "text": "is impossible in SML:<br>Attempting to call a function without any arguments gets you the value of that",
      "id": "44d89cf4d0688daa8b5344c051279fc8"
    },
    {
      "type": "code",
      "text": "     function, just as calling a function with 'too few' arguments creates an anonymous function that will\n     take the arguments you did not specify. Similarly, it is impossible for a function to not return a\n     value. The solution is unit, which is how SML programmers tell each other (and their compilers) that\n     this function either takes no real arguments or returns no real value. It is like NULL in C, except\n     type-safe and otherwise completely unlike any other value in the language. *)",
      "id": "e78e437f3dbe84037d9c8f0a07fded66"
    },
    {
      "type": "code",
      "text": "  (* Save this source in a file called \"fac.sml\", compile it with MLton, and run it as \"./fac 0 1 10 12\".\n     (12! is the highest factorial a 32-bit machine can handle. SML programs treat integer overflow as a\n     failure and this program will fail with an unhandled exception if you attempt to compute a factorial\n     larger than you can handle.) *)",
      "id": "e07a1d1fc6096f6b41e65802166b5a74"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "59deefc4dacf1e87b33648209025e607"
    },
    {
      "type": "html",
      "text": "\nSorry -- I just <i>had</i> to space out the code above -- I just couldn't read it otherwise.  Hopefully I didn't accidentally change the semantics of the program.  Not sure if SML is white-space sensitive or not like Haskell is.  --[[Samuel Falvo]]",
      "id": "3c451c75b2ee5c95d7fee33287f31d0d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "59deefc4dacf1e87b33648209025e607"
    },
    {
      "type": "html",
      "text": "\nUm... 0! = 1, not 0.  And isn't unit more like void than NULL?",
      "id": "9cf17186089b2bba4a73a4f137cd6c32"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "59deefc4dacf1e87b33648209025e607"
    },
    {
      "type": "html",
      "text": "There is a wiki discussing an improved SML at [http://successor-ml.org/ successor-ml.org]",
      "id": "3107dc0f94364fb27af3b16f1bffeb02"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "59deefc4dacf1e87b33648209025e607"
    },
    {
      "type": "html",
      "text": "[[Category Programming Language]]",
      "id": "abbbf956311a94b81bece0053c950e86"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?SmlLanguage c2.com]",
      "id": "bb6fecbb03a8c53f96ac8a3b1ffeb39e"
    }
  ],
  "journal": [
    {
      "date": 1340199309000,
      "id": "9011831c4825a08f2348a0c596dff597",
      "type": "create",
      "item": {
        "title": "Sml Language",
        "story": [
          {
            "type": "html",
            "text": "Standard ML (or SML for short) is a modern dialect of ML [[[Ml Language]]].",
            "id": "46455e4c9c5b0826478c49a1d657fa2e"
          },
          {
            "type": "html",
            "text": "\nSee [http://www.smlnj.org/sml.html www.smlnj.org] and [http://www.smlnj.org/sml97.html www.smlnj.org].",
            "id": "4312d2bbc2dcecb433f63bcb4dcc4b2e"
          },
          {
            "type": "html",
            "text": "\nType-based pattern matching and function tricks\nmake this a handy language for writing compilers.",
            "id": "f81aa725a144bc08ea4910ca26e27a75"
          },
          {
            "type": "html",
            "text": "\nAlso see [[Ml Kit]], [[Ml Ton]], and [[Sml Nj Language]]. And [[Sml Unit]].",
            "id": "40c52576062f3cc1fb6dc30f93e9cb7f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "59deefc4dacf1e87b33648209025e607"
          },
          {
            "type": "html",
            "text": "\nHow about some programming examples? I'll start small and simple:",
            "id": "90d360ec2b055043fbc564e027f14c55"
          },
          {
            "type": "code",
            "text": " (* A comment in SML. (* They can be nested. *) *)",
            "id": "bca13793368f1e2f5bfc1505dc1ce258"
          },
          {
            "type": "code",
            "text": " (* This function recurses along a list, applying a function to each element and an accumulator in turn.\n    Note the pattern matching and the use of _, which matches (and ignores) anything. *)",
            "id": "5be42027b76020f80861748b2c2b7cfc"
          },
          {
            "type": "code",
            "text": " fun revfold _ nil b = b (* If the second argument is nil (an empty list), return the third argument. *)\n | revfold f (hd::tl) b = revfold f tl (f(hd,b)); (* Otherwise, recurse on the tail of the list and\n                                                     replace b with the result of applying f to the head\n                                                     of the list and the old b. *)",
            "id": "855e18033f347e8f67bde7b60fc112ec"
          },
          {
            "type": "code",
            "text": " (* More pattern matching, this time to destructure the list (the second argument) into a head (hd) and\n    a tail (tl). The head is a single list element, the tail is the rest of the list (which may be nil). *)",
            "id": "d36e74d34cfba989d68afee0b47dc3d8"
          },
          {
            "type": "html",
            "text": "(* The type of this function is \"val revfold = fn :<br>('a * 'b -> 'b) -> 'a list -> 'b -> 'b\".",
            "id": "e2da2cd5bc74399533852aee177d821b"
          },
          {
            "type": "code",
            "text": "    This means that the first argument is a function of a two-element tuple of incomplete types 'a and 'b\n    which may or may not be the same. The function must return a value of type 'b, however. The second\n    argument is a list of elements of type 'a, and the third argument is a single object of type 'b. The\n    return value is also a single object of type 'b. *)",
            "id": "5d49f4cd691a344c2c1a5410d57464b2"
          },
          {
            "type": "code",
            "text": "  (* Filter out undesirable elements from a list. *)",
            "id": "2e1765c1bcd8df738f7b03cb62212a56"
          },
          {
            "type": "code",
            "text": "  fun filter _ nil = nil\n  |   filter f (hd::tl) = if (f hd) then hd::(filter f tl) else (filter f tl);",
            "id": "28b9b48e4ccd56ca2979d77c885158cd"
          },
          {
            "type": "html",
            "text": "(* Another basic recursive function. The if..then..else works exactly as expected. The ::<br>infix operator",
            "id": "7e3141b1943c20a8bfa6d88745d808d8"
          },
          {
            "type": "html",
            "text": "is cons from Lisp:<br>It glues individual objects into lists. The list [1,2,3] can also be written",
            "id": "79bea363b3744dff8e55dd30697f7290"
          },
          {
            "type": "code",
            "text": "     1::2::3::nil, just like the Lisp list '(1 2 3) can also be written '(1 . (2 . (3 . nil))). *)",
            "id": "323b2e6983a5cab301f0daa4a8b78d10"
          },
          {
            "type": "code",
            "text": "  (* Check to see if a value is in a specific range. *)\n  (* This function takes two arguments: A two-element tuple of ints and a single int. *)",
            "id": "1c49ce9ca75430ece47a9f1ecc7f3afe"
          },
          {
            "type": "code",
            "text": "  fun inRange (min,max) v = ((v >= min) andalso (v <= max));",
            "id": "dd008a5675ac9a6ed3f7844981adee89"
          },
          {
            "type": "code",
            "text": "  (* Determine if a given character is a decimal digit. *)\n  (* The o operator is the composition operator: It works such that f o g is equivalent to f(g(x)) for\n     some implicit x. Here, it allows us to trivially convert the argument from a char to an int\n     before passing it to the anonymous function of one argument created by just passing \n     inRange the tuple. *)",
            "id": "4d3f88d6cab7a6e631a754a3e144390d"
          },
          {
            "type": "code",
            "text": "  val digitp = inRange (Char.ord #\"0\", Char.ord #\"9\") o Char.ord;",
            "id": "0883b2cb80454aba596be2a10a8db858"
          },
          {
            "type": "code",
            "text": "  (* The classic atoi function. The first argument to revfold is what anonymous functions look like.\n     Char.ord converts characters into ints and explode turns strings into lists of characters. *)",
            "id": "3461b25dbc2b7d0e1e45b9ef17c613c7"
          },
          {
            "type": "code",
            "text": "  fun atoi s = revfold (fn(a,b)=>((Char.ord a)-(Char.ord #\"0\")+10*b) (filter digitp (explode s)) 0;",
            "id": "e72ae2bd3dd7a50dbeadb35ad2ad9927"
          },
          {
            "type": "code",
            "text": "  (* The inevitable factorial function. Note the two special cases handled by pattern-matching. *)",
            "id": "ed2ed87ef709d8f7616bdef8bdd67cbf"
          },
          {
            "type": "code",
            "text": "  fun fac 0 = 0\n  |   fac 1 = 1\n  |   fac n = if n < 0 then n else n*(fac(n-1));",
            "id": "12ffc05f5ee0357635705d0da4ffa2a7"
          },
          {
            "type": "code",
            "text": "  (* Compute the factorial of the number represented by the string and return the result as a string. *)",
            "id": "1982181bdac8a17f92fc9920e6e79c2e"
          },
          {
            "type": "code",
            "text": "  fun strfac s = Int.toString(fac(atoi s)); (* Int.toString is a standard library function. *)",
            "id": "ef7b3989ca505b7a16b0e15ceed41411"
          },
          {
            "type": "code",
            "text": "  (* Determine if the string really is a valid number. Useful for error reporting. *)\n  (* REALLY useful for showing off let..in..end blocks and lexical functions. ;) *)",
            "id": "4ae23221fbd8299e7cbe7c888c578613"
          },
          {
            "type": "code",
            "text": "  fun check \"\" = true\n  |   check s =\n          let fun inner nil = true\n              |   inner (hd::tl) = digitp hd andalso inner tl\n          in inner (explode s) end;",
            "id": "d9e72ce2b1e4fdc5a1c51d8e159c8e31"
          },
          {
            "type": "code",
            "text": "  (* I do it this way instead of with revfold because this function will bail early \n     if the string is not valid. *)",
            "id": "742faa78d995757fad99dd78732e4f20"
          },
          {
            "type": "code",
            "text": "  (* The main function. Note how the 'val _ =' means the return value of the main loop is thrown away. *)\n  (* The function app is like map in that it maps its first (function) argument across its second (list),\n     but it does not return a (useful) value. It is only useful if the function has side-effects. Such as\n     printing something. Like this one does. *)",
            "id": "4afcdfe1dcf595c23b744b6ba681c20e"
          },
          {
            "type": "code",
            "text": "  val _ =\n     app (fn s => (if not (check s) then (print s; print \" is not a number\\n\")\n             else (print s; print \"\\t\"; print(strfac s); print \"\\n\"))) (CommandLine.arguments());",
            "id": "856925ece060b5da861a7bfd4e48cd33"
          },
          {
            "type": "html",
            "text": "(* [[Command Line]].arguments is a function of one argument:<br>(), also called unit. A function of no arguments",
            "id": "a97ecb62afedc6b1ea3553f1175006bc"
          },
          {
            "type": "html",
            "text": "is impossible in SML:<br>Attempting to call a function without any arguments gets you the value of that",
            "id": "44d89cf4d0688daa8b5344c051279fc8"
          },
          {
            "type": "code",
            "text": "     function, just as calling a function with 'too few' arguments creates an anonymous function that will\n     take the arguments you did not specify. Similarly, it is impossible for a function to not return a\n     value. The solution is unit, which is how SML programmers tell each other (and their compilers) that\n     this function either takes no real arguments or returns no real value. It is like NULL in C, except\n     type-safe and otherwise completely unlike any other value in the language. *)",
            "id": "e78e437f3dbe84037d9c8f0a07fded66"
          },
          {
            "type": "code",
            "text": "  (* Save this source in a file called \"fac.sml\", compile it with MLton, and run it as \"./fac 0 1 10 12\".\n     (12! is the highest factorial a 32-bit machine can handle. SML programs treat integer overflow as a\n     failure and this program will fail with an unhandled exception if you attempt to compute a factorial\n     larger than you can handle.) *)",
            "id": "e07a1d1fc6096f6b41e65802166b5a74"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "59deefc4dacf1e87b33648209025e607"
          },
          {
            "type": "html",
            "text": "\nSorry -- I just <i>had</i> to space out the code above -- I just couldn't read it otherwise.  Hopefully I didn't accidentally change the semantics of the program.  Not sure if SML is white-space sensitive or not like Haskell is.  --[[Samuel Falvo]]",
            "id": "3c451c75b2ee5c95d7fee33287f31d0d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "59deefc4dacf1e87b33648209025e607"
          },
          {
            "type": "html",
            "text": "\nUm... 0! = 1, not 0.  And isn't unit more like void than NULL?",
            "id": "9cf17186089b2bba4a73a4f137cd6c32"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "59deefc4dacf1e87b33648209025e607"
          },
          {
            "type": "html",
            "text": "There is a wiki discussing an improved SML at [http://successor-ml.org/ successor-ml.org]",
            "id": "3107dc0f94364fb27af3b16f1bffeb02"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "59deefc4dacf1e87b33648209025e607"
          },
          {
            "type": "html",
            "text": "[[Category Programming Language]]",
            "id": "abbbf956311a94b81bece0053c950e86"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?SmlLanguage c2.com]",
            "id": "bb6fecbb03a8c53f96ac8a3b1ffeb39e"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1707795856496
    }
  ]
}