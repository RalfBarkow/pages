{
  "title": "You Can't Do It All With Inheritance",
  "story": [
    {
      "type": "paragraph",
      "id": "f14909a2372c1a97",
      "text": "There has been much written about the natural match between object oriented programming and user interface design. The design of abstract objects such as windows which do not correspond to any object in physical reality remains a challenge. We have found many programmers using [[Smalltalk]]'s or [[Flavors]]' subclassing organization ([[Inheritance]]) where an aggregation or parts organization would be better. "
    },
    {
      "type": "paragraph",
      "id": "b56ec1f5334447cb",
      "text": "Is it really true that a bordered window is a subclass of window? Should a text window with a scroll bar be different from one without? Subclassing leads to very cumbersome and confusing user interface datatypes, especially in a single inheritance model. Systems such as Animus [Duisberg, 1986] have clearly illustrated that it is better to [[think]] of a bordered window as a composite object [Lieberman, 1986] [Lalonde, Thomas and Pugh, 1986b] composed of a border part and a window part."
    },
    {
      "type": "paragraph",
      "id": "51cdef62cec62b62",
      "text": "This means we need a system with lots of small parts such as buttons, text views, scroll bars, etc. which are assembled by the user interface designer. Combining these parts to form new parts should not require us to change existing code or write large amounts of new code. Examples of systems with this capability are ThingLab [Horning, 1979] and The Alternate Realities Kit [Smith, 1986]."
    },
    {
      "type": "paragraph",
      "id": "98de059ef5010fc5",
      "text": "⇒ [[Coordination Facilities Must Be Explicit]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "You Can't Do It All With Inheritance",
        "story": []
      },
      "date": 1655959905968
    },
    {
      "item": {
        "type": "factory",
        "id": "f14909a2372c1a97"
      },
      "id": "f14909a2372c1a97",
      "type": "add",
      "date": 1655959928570
    },
    {
      "type": "edit",
      "id": "f14909a2372c1a97",
      "item": {
        "type": "paragraph",
        "id": "f14909a2372c1a97",
        "text": "(’here has been much written about the natural match between object oriented programming and user interface design. The design of abstract objects such as windows which do not correspond to any object in physical reality remains a challenge. We have found many programmers using Smalltalk's or Flavors' subclassing organization (inheritance) where an aggregation or parts organization would be better. Is it really true that a bordered window is a subclass of window? Should a text window with a scroll bar be different from one without? Subclassing leads to very cumbersome and confusing user interface datatypes, especially in a single inheritance model. Systems such as Animus [Duisberg, 1986] have clearly illustrated that it is better to think of a bordered window as a composite object [Lieberman, 1986] [Lalonde, Thomas and Pugh, 1986b] composed of a border part and a window part."
      },
      "date": 1655959930521
    },
    {
      "type": "edit",
      "id": "f14909a2372c1a97",
      "item": {
        "type": "paragraph",
        "id": "f14909a2372c1a97",
        "text": "There has been much written about the natural match between object oriented programming and user interface design. The design of abstract objects such as windows which do not correspond to any object in physical reality remains a challenge. We have found many programmers using Smalltalk's or Flavors' subclassing organization (inheritance) where an aggregation or parts organization would be better. Is it really true that a bordered window is a subclass of window? Should a text window with a scroll bar be different from one without? Subclassing leads to very cumbersome and confusing user interface datatypes, especially in a single inheritance model. Systems such as Animus [Duisberg, 1986] have clearly illustrated that it is better to think of a bordered window as a composite object [Lieberman, 1986] [Lalonde, Thomas and Pugh, 1986b] composed of a border part and a window part."
      },
      "date": 1655959940001
    },
    {
      "type": "edit",
      "id": "f14909a2372c1a97",
      "item": {
        "type": "paragraph",
        "id": "f14909a2372c1a97",
        "text": "There has been much written about the natural match between object oriented programming and user interface design. The design of abstract objects such as windows which do not correspond to any object in physical reality remains a challenge. We have found many programmers using [[Smalltalk]]'s or [[Flavors]]' subclassing organization (inheritance) where an aggregation or parts organization would be better. Is it really true that a bordered window is a subclass of window? Should a text window with a scroll bar be different from one without? Subclassing leads to very cumbersome and confusing user interface datatypes, especially in a single inheritance model. Systems such as Animus [Duisberg, 1986] have clearly illustrated that it is better to think of a bordered window as a composite object [Lieberman, 1986] [Lalonde, Thomas and Pugh, 1986b] composed of a border part and a window part."
      },
      "date": 1655959979244
    },
    {
      "type": "edit",
      "id": "f14909a2372c1a97",
      "item": {
        "type": "paragraph",
        "id": "f14909a2372c1a97",
        "text": "There has been much written about the natural match between object oriented programming and user interface design. The design of abstract objects such as windows which do not correspond to any object in physical reality remains a challenge. We have found many programmers using [[Smalltalk]]'s or [[Flavors]]' subclassing organization ([[Inheritance]]) where an aggregation or parts organization would be better. Is it really true that a bordered window is a subclass of window? Should a text window with a scroll bar be different from one without? Subclassing leads to very cumbersome and confusing user interface datatypes, especially in a single inheritance model. Systems such as Animus [Duisberg, 1986] have clearly illustrated that it is better to think of a bordered window as a composite object [Lieberman, 1986] [Lalonde, Thomas and Pugh, 1986b] composed of a border part and a window part."
      },
      "date": 1655960003309
    },
    {
      "type": "edit",
      "id": "f14909a2372c1a97",
      "item": {
        "type": "paragraph",
        "id": "f14909a2372c1a97",
        "text": "There has been much written about the natural match between object oriented programming and user interface design. The design of abstract objects such as windows which do not correspond to any object in physical reality remains a challenge. We have found many programmers using [[Smalltalk]]'s or [[Flavors]]' subclassing organization ([[Inheritance]]) where an aggregation or parts organization would be better. "
      },
      "date": 1655960032487
    },
    {
      "type": "add",
      "id": "b56ec1f5334447cb",
      "item": {
        "type": "paragraph",
        "id": "b56ec1f5334447cb",
        "text": "Is it really true that a bordered window is a subclass of window? Should a text window with a scroll bar be different from one without? Subclassing leads to very cumbersome and confusing user interface datatypes, especially in a single inheritance model. Systems such as Animus [Duisberg, 1986] have clearly illustrated that it is better to think of a bordered window as a composite object [Lieberman, 1986] [Lalonde, Thomas and Pugh, 1986b] composed of a border part and a window part."
      },
      "after": "f14909a2372c1a97",
      "date": 1655960033906
    },
    {
      "type": "edit",
      "id": "b56ec1f5334447cb",
      "item": {
        "type": "paragraph",
        "id": "b56ec1f5334447cb",
        "text": "Is it really true that a bordered window is a subclass of window? Should a text window with a scroll bar be different from one without? Subclassing leads to very cumbersome and confusing user interface datatypes, especially in a single inheritance model. Systems such as Animus [Duisberg, 1986] have clearly illustrated that it is better to [[think]] of a bordered window as a composite object [Lieberman, 1986] [Lalonde, Thomas and Pugh, 1986b] composed of a border part and a window part."
      },
      "date": 1655960065109
    },
    {
      "item": {
        "type": "factory",
        "id": "51cdef62cec62b62"
      },
      "id": "51cdef62cec62b62",
      "type": "add",
      "after": "b56ec1f5334447cb",
      "date": 1655960161611
    },
    {
      "type": "edit",
      "id": "51cdef62cec62b62",
      "item": {
        "type": "paragraph",
        "id": "51cdef62cec62b62",
        "text": "This means we need a system with lots of small parts such as buttons, text views, scroll bars, etc. which are assembled by the user interface designer. Combining these parts to form new parts should not require us to change existing code or write large amounts of new code. Examples of systems with this capability are ThingLab [Horning, 1979] and The Alternate Realities Kit [Smith, 1986]."
      },
      "date": 1655960163006
    },
    {
      "item": {
        "type": "factory",
        "id": "98de059ef5010fc5"
      },
      "id": "98de059ef5010fc5",
      "type": "add",
      "after": "51cdef62cec62b62",
      "date": 1655960190478
    },
    {
      "type": "edit",
      "id": "98de059ef5010fc5",
      "item": {
        "type": "paragraph",
        "id": "98de059ef5010fc5",
        "text": "⇒ [[Coordination Facilities Must Be Explicit]]"
      },
      "date": 1655960202422
    }
  ]
}