{
  "title": "Krestianstvo Luminary",
  "story": [
    {
      "type": "paragraph",
      "id": "5795e9078e1a176e",
      "text": "avinash â€” [https://discord.com/channels/694586717247635488/984210689503662140/986584133524418580 discord]\nwould like to know the advantages for selecting Croquet's [[Reflector]] approach over Krestianstvo Luminary. i am working for a metaverse hackathon project and thinking of which one to use. please elucidate ..thanks."
    },
    {
      "type": "paragraph",
      "id": "7885cba3df1e466e",
      "text": "croqueteer â€” [https://discord.com/channels/694586717247635488/984210689503662140/986627069268099137 discord]\nKrestianstvo Luminary is built in the original Smalltalk version of Croquet that I designed much of. That was a critical system in informing our thinking about the next few iterations including the DoD [[Virtual World Framework]] that I also designed. The current Croquet addresses many shortcomings in the earlier systems including the introduction of model/view, a beautiful publish/subscribe communication model, live collaborative programming among many other things."
    },
    {
      "type": "paragraph",
      "id": "1981692c5c0d44f2",
      "text": "codefrau ðŸ¦© â€” [https://discord.com/channels/694586717247635488/984210689503662140/986659381410164757 discord]\nLuminary is actually Javascript, built on [[VWF]], but supports live coding (even in non-JS languages via Ohm), uses A-Frame for 3D and replaced reflectors with [[Gun DB]]. It's a pretty cool system but I'm not really familiar with it, you would have to ask Nikolay himself.\nRe reflectors, we have deployed reflectors world-wide, here in Los Angeles I get < 10ms latency, but if I even just ping Luminary's default reflector that's 200ms because it's somewhere in Europe and does not have a whole fleet nor does it do the automatic routing to the nearest reflector as we do (AFAIK). Besides that I'd argue our architecture is much less baroque than VWF (which is not Nikolay's fault, that was in the original project he forked). \n"
    },
    {
      "type": "paragraph",
      "id": "4433dc8d8953c3b5",
      "text": "avinash â€” [https://discord.com/channels/694586717247635488/984210689503662140/986840187764080650 discord]\nreplacing reflectors with gundb and democratizing the servers and gundb's plan to incentivize using AXE crypto seem to be the newer concepts Luminary adopted from an economics standpoint.\nhowever the usage of an older codebase and being a single person effort are detractions.\nalso the removal of reflectors in the newer versions and letting the users play out in a p2p fashion seemed an interesting idea. \ni have seen an example using webrtc in livecoding.space, which using webrtc transfers the audio and video from the webcam into the 3d space, would like to know if croquet has something similar as that is something that would be useful for what i'm trying to prototype. "
    },
    {
      "type": "paragraph",
      "id": "876edcfaf3ab43fd",
      "text": "ccrraaiigg â€” 2022-05-15\nHi, I'm [[Craig Latta]], a longtime livecoder with Smalltalk and now JavaScript. I'm working on some integrations with Croquet and Caffeine, a web IDE I've made with SqueakJS. Current areas are WebRTC and remote music collaboration. Onward!"
    },
    {
      "type": "markdown",
      "id": "6398138dea70bd9d",
      "text": "# Krestianstvo Luminary \n\nThe source code [https://github.com/NikolaySuslov/luminary github] of the current **Luminary** implementation mainly at [LiveCoding.space](https://livecoding.space) project repository:   \n\n- **Krestianstvo Luminary** functional prototype is avaliable to try out at https://livecoding.space  \n\n- **Source code** at [LiveCoding.space GitHub repository **master** branch](https://github.com/NikolaySuslov/livecodingspace)  \n\n- **Research paper** about Krestianstvo Luminary architecture here: [https://raw.githubusercontent.com/NikolaySuslov/luminary/master/paper/Luminary.pdf pdf]"
    },
    {
      "type": "markdown",
      "id": "33cfc513b8da316f",
      "text": "---\n\n## Krestianstvo Luminary for Open Croquet architecture and Virtual World Framework in peer-to-peer Web\n\nEveryone who is familiar with [Croquet architecture](https://en.wikipedia.org/wiki/Croquet_Project) are anticipating (waiting breathless) the updates for Open Croquet architecture from **Croquet V** by David A. Smith and [Croquet Studios](https://croquet.studio)!\n\nHowever, while working on [LiveCoding.space](https://www.krestianstvo.org/sdk3) project by Krestianstvo.org that is heavily based on [Virtual World Framework](https://en.wikipedia.org/wiki/Virtual_world_framework) (containing elements of Open Croquet architecture), I have started revising the current Reflector server.\n\nLet me introduce to you an ideas and early prototype of the **Krestianstvo Luminary** for Open Croquet architecture and Virtual World Framework. \n**Krestianstvo Luminary** potentially could replace Reflector server in flavour of using offline-first [Gun DB](https://gun.eco/docs/Introduction) pure distributed storage system. That allows instead of â€˜Reflectingâ€™ messages with centralised Croquetâ€™s time now, to â€˜Shiningâ€™ time on every connected node using Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), running in peer-to-peer Web. Also to secure all external messages streams by using peer-to-peer identities and [SEA](https://gun.eco/docs/SEA) cryptographic library for Gun DB. More over running Luminary on [AXE](https://gun.eco/docs/AXE#faq) blockchain.  \n**Krestianstvo Luminary** simply transforms the only server related Croquetâ€™s part - Reflector (taken from VWF version) into the pure peer-to-peer application, running on a clientâ€™s Web Browsers.  \n\n| | Croquet&nbsp;Reflector&nbsp;(VWF) | Krestianstvo Luminary |\n| --- | :---: | :---: |\n| **Architecture:** | Client-Server | Peer-to-Peer |\n| **Croquet time stamp:** | on server | on peer |\n| **Time now is:** | server machineâ€™s time | GunDB HAM state: combines timestamps, vector clocks, and a conflict resolution algorithm |\n| source code | new Date( ).getTime( ) | Gun.state.is ( node, property ) |\n| **Heartbeat messages:** | by server | by selected peer |\n| **Reflector app logic:** | on server | on peer |\n| **Hosting:** | dedicated server with Web Sockets | peerâ€™s Web Browsers connected through Daisy-chain Ad-hoc Mesh-network (for swapping in different transport layers: Web Sockets, WebRTC, etc.) |\n| **Securing the streams of messages:** | by server | by peer-to-peer identities |\n\n\nFor those who are not familiar with Open Croquet architecture, just want to mark key principals behind it in simple words.\n"
    },
    {
      "type": "html",
      "id": "980f55ed48518800",
      "text": "<img\n  width=\"100%\"\n  src=\"https://github.com/RalfBarkow/luminary/raw/master/assets/croquet-reflector.jpg\"\n>"
    },
    {
      "type": "markdown",
      "id": "3699bfc17cdbe53c",
      "text": "### Croquet Architecture\n\nCroquet introduced the notion of [[Virtual Time]] for decentralised computations. Thinking on objects as stream of messages, which lead to deterministic computations on every connected node in decentralised network. All computations are done on every node by itself while interpreting an internal queue of messages, which are not replicated to the network. But these queues are synchronised by an external heartbeat messages coming from [[Reflector]] â€“ a tiny server. Also any nodeâ€™s self generated messages, which should be distributed to other nodes are marked as external. They are explicitly routed to the Reflector, where the are stamped with the Reflectorâ€™s time now and are returned back to the node itself and all other nodes on the network. \n"
    },
    {
      "type": "markdown",
      "id": "2a767ebe0e974649",
      "text": "Reflector is not only used for sending heartbeat messages, stamping external messages, but also it is used for holding the list of connected clients, list of running virtual world instances, bootstrapping new client connections.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "d3c5d9c8882e321f",
      "text": "### Reflector \n\nSo, in Croquet architecture for decentralised networks, the Reflector while being a very tiny or even being a micro service - it remains a server. It uses WebSockets for coordinating clients, world instances, providing â€˜now timeâ€™ for the clients, reflecting external messages.\n\nLetâ€™s look how it works in Virtual World Framework (VWF). I will use the available open source code from VWF, which I am using in LiveCoding.space project by Krestianstvo.org\n\nThatâ€™s a function returning time now by Reflector. Time is getting from a machine, running a Reflector server:\n(server code from **lib/reflector.js**)\n\n``` \nfunction GetNow( ) {\n    return new Date( ).getTime( ) / 1000.0;\n}\n``` \n\nThen it uses to make a stamp for a virtual world instance:\n\n```\nreturn ( GetNow( ) - this.start_time ) * this.rate\n```\n\nReflector send this time stamps using WebSockets. And on a client side VWF has a method for dispatching: \n(client code from **public/vwf.js**)\n\n```\nsocket.on( \"message\", function( message ) {\n  var fields = message;\n  â€¦.\n  fields.time = Number( fields.time );\n  fields.origin = \"reflector\";\n  queue.insert( fields, !fields.action );\n  â€¦.\n```\n\nLook at send and respond methods, where clients use WebSocket to send external messages back to the Reflector:\n```\n   var message = JSON.stringify( fields );\n   socket.send( message );\n```\n\n\n\n"
    },
    {
      "type": "markdown",
      "id": "3b43549a033e3a17",
      "text": "### Luminary\n\nNow, letâ€™s look at how Krestianstvo Luminary could identically replace the Reflector server.\n"
    },
    {
      "type": "html",
      "id": "904d819b95ccd02e",
      "text": "<img \n  width=\"100%\"\n  src=\"https://github.com/RalfBarkow/luminary/raw/master/assets/luminary.jpg\"\n>"
    },
    {
      "type": "markdown",
      "id": "6873a40373efa5b7",
      "text": "First of all clients are never forced using WebSockets directly from the application itself for sending or receiving messages. Instead Gun DB responds for that functionality internally. All operations which previously relay on WebSocket connection are replaced by subscribing to updates and changes on a Gun DB nodes and properties.\n"
    },
    {
      "type": "markdown",
      "id": "27de0c4121dbe74c",
      "text": "So, instances, clients â€“ are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\n\n"
    },
    {
      "type": "markdown",
      "id": "7993df889363cabb",
      "text": "Client, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a [[Metronome]] (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n"
    },
    {
      "type": "markdown",
      "id": "9821d36f7a9c0630",
      "text": "\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜[[tick]]â€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\n"
    },
    {
      "type": "markdown",
      "id": "7ddbe985087f73ba",
      "text": "The start time will be the state value of HAM at â€˜start_timeâ€™ property, of heartbeat node. Please notice, that actual Croquet timestamp is not calculated here, as it was in Reflector server. The timestamp used for the Croquet internal queue of messages will be calculated on reading of â€˜tickâ€™ by the VWF client in itâ€™s main application. \n\nHere is the simplified core version of dispatching â€˜tickâ€™ on VWF client main app, just to get the idea: (full code on **public/vwf.js**, links below)\n\n```\nlet instance = _LCSDB.get(vwf.namespace_);\n\ninstance.get('heartbeat').on(function (res) { \n   if(res.tick) {\n  let msg = self.stamp(res, start_time, rate);\n\n  queue.insert(fields, !fields.action);\n\n  }\n}\n\nthis.stamp = function(source, start_time, rate) {\n\n            let message = JSON.parse(source.tick);\n\n            message.state = Gun.state.is(source, 'tick');\n            message.start_time = start_time; //Gun.state.is(source, 'start_time');\n            message.rate = rate; //source.rate;\n\n            var time = ((message.state - message.start_time)*message.rate)/1000;\n\n            if (message.action == 'setState'){\n                time = ((_app.reflector.setStateTime - message.start_time)*message.rate)/1000;\n            }\n            message.time = Number( time );\n            message.origin = â€œreflector\";\n\n            return message\n        }\n\n```\n\nThe main point here is the calculation of Croquet time using Gunâ€™s HAM state:\n```\nGun.state.is ( node, property )\n```\n\nfor message:\n```\nmessage.state = Gun.state.is(source, â€˜tickâ€™); // time of updating tick\nmessage.start_time = Gun.state.is(source, â€˜start_time'); //start time of the instance heartbeat\nmessage.rate = source.rate;\nvar time = ((message.state - message.start_time)*message.rate)/1000;\n```\n\nSo, all peers will calculate exactly the same Croquet time on getting an update from Gun DB,  regardless of the time when they get this update (network delays, etc). \n\nAs you could imagine, sending external messages will be as simple as just writing the message by a peer to an instance heartbeat with a new messageâ€™s content. All connected peers and a peer itself will get that message, stamped with Croquet time, while they are subscribed on changes on heartbeat node (look above at **instance.get(â€˜heartbeatâ€™).on()** definition )\n```\ninstance.get('heartbeat').get('tick').put(JSON.stringify(newMsg));\n```\n\nActually thatâ€™s it!\n\n\n"
    },
    {
      "type": "markdown",
      "id": "5814f736f0973188",
      "text": "### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing [[Metronome]] empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deployed anywhere, anytime available on AXE blockchain.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "0777ec77addf27e1",
      "text": "### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \n"
    },
    {
      "type": "markdown",
      "id": "2728ea493e519d09",
      "text": "There are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n\n"
    },
    {
      "type": "markdown",
      "id": "5a84b907341d5a0f",
      "text": "### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\n[[Nikolai Suslov]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Krestianstvo Luminary",
        "story": []
      },
      "date": 1655292679172
    },
    {
      "item": {
        "type": "paragraph",
        "id": "5795e9078e1a176e",
        "text": "avinash â€” [https://discord.com/channels/694586717247635488/984210689503662140/986584133524418580 discord]\nwould like to know the advantages for selecting Croquet's [[Reflector]] approach over Krestianstvo Luminary. i am working for a metaverse hackathon project and thinking of which one to use. please elucidate ..thanks."
      },
      "id": "5795e9078e1a176e",
      "type": "add",
      "date": 1655292689912
    },
    {
      "type": "edit",
      "id": "5795e9078e1a176e",
      "item": {
        "type": "paragraph",
        "id": "5795e9078e1a176e",
        "text": "avinash â€” [https://discord.com/channels/694586717247635488/984210689503662140/986584133524418580 discord]\nwould like to know the advantages for selecting Croquet's [[Reflector]] approach over Krestianstvo Luminary. i am working for a metaverse hackathon project and thinking of which one to use. please elucidate ..thanks."
      },
      "date": 1655292692034
    },
    {
      "type": "edit",
      "id": "5795e9078e1a176e",
      "item": {
        "type": "paragraph",
        "id": "5795e9078e1a176e",
        "text": "avinash â€” [https://discord.com/channels/694586717247635488/984210689503662140/986584133524418580 discord]\nwould like to know the advantages for selecting Croquet's [[Reflector]] approach over Krestianstvo Luminary. i am working for a metaverse hackathon project and thinking of which one to use. please elucidate ..thanks."
      },
      "date": 1655292708918
    },
    {
      "type": "edit",
      "id": "5795e9078e1a176e",
      "item": {
        "type": "paragraph",
        "id": "5795e9078e1a176e",
        "text": "avinash â€” [https://discord.com/channels/694586717247635488/984210689503662140/986584133524418580 discord]\nwould like to know the advantages for selecting Croquet's [[Reflector]] approach over Krestianstvo Luminary. i am working for a metaverse hackathon project and thinking of which one to use. please elucidate ..thanks."
      },
      "date": 1655292721380
    },
    {
      "type": "edit",
      "id": "5795e9078e1a176e",
      "item": {
        "type": "paragraph",
        "id": "5795e9078e1a176e",
        "text": "avinash â€” [https://discord.com/channels/694586717247635488/984210689503662140/986584133524418580 discord]\nwould like to know the advantages for selecting Croquet's [[Reflector]] approach over Krestianstvo Luminary. i am working for a metaverse hackathon project and thinking of which one to use. please elucidate ..thanks."
      },
      "date": 1655292728904
    },
    {
      "item": {
        "type": "markdown",
        "id": "2b4f2a80b92f1677",
        "text": "â€“ https://github.com/NikolaySuslov/luminary"
      },
      "id": "2b4f2a80b92f1677",
      "type": "add",
      "after": "5795e9078e1a176e",
      "date": 1655292741263
    },
    {
      "type": "edit",
      "id": "2b4f2a80b92f1677",
      "item": {
        "type": "markdown",
        "id": "2b4f2a80b92f1677",
        "text": "â€“ https://github.com/NikolaySuslov/luminary"
      },
      "date": 1655292744516
    },
    {
      "type": "edit",
      "id": "2b4f2a80b92f1677",
      "item": {
        "type": "markdown",
        "id": "2b4f2a80b92f1677",
        "text": "â€“ https://github.com/NikolaySuslov/luminary"
      },
      "date": 1655292745643
    },
    {
      "item": {
        "type": "markdown",
        "id": "6398138dea70bd9d",
        "text": "# Krestianstvo Luminary\n\nThe source code of the current **Luminary** implementation mainly at [LiveCoding.space](https://livecoding.space) project repository:   \n\n- **Krestianstvo Luminary** functional prototype is avaliable to try out at https://livecoding.space  \n\n- **Source code** at [LiveCoding.space GitHub repository **master** branch](https://github.com/NikolaySuslov/livecodingspace)  \n\n- **Research paper** about Krestianstvo Luminary architecture here: [download / read](/paper/Luminary.pdf)"
      },
      "id": "6398138dea70bd9d",
      "type": "add",
      "after": "2b4f2a80b92f1677",
      "date": 1655292792428
    },
    {
      "type": "edit",
      "id": "6398138dea70bd9d",
      "item": {
        "type": "markdown",
        "id": "6398138dea70bd9d",
        "text": "# Krestianstvo Luminary\n\nThe source code of the current **Luminary** implementation mainly at [LiveCoding.space](https://livecoding.space) project repository:   \n\n- **Krestianstvo Luminary** functional prototype is avaliable to try out at https://livecoding.space  \n\n- **Source code** at [LiveCoding.space GitHub repository **master** branch](https://github.com/NikolaySuslov/livecodingspace)  \n\n- **Research paper** about Krestianstvo Luminary architecture here: [download / read](/paper/Luminary.pdf)"
      },
      "date": 1655292794248
    },
    {
      "item": {
        "type": "markdown",
        "id": "33cfc513b8da316f",
        "text": "---\n\n## Krestianstvo Luminary for Open Croquet architecture and Virtual World Framework in peer-to-peer Web\n\nEveryone who is familiar with [Croquet architecture](https://en.wikipedia.org/wiki/Croquet_Project) are anticipating (waiting breathless) the updates for Open Croquet architecture from **Croquet V** by David A. Smith and [Croquet Studios](https://croquet.studio)!\n\nHowever, while working on [LiveCoding.space](https://www.krestianstvo.org/sdk3) project by Krestianstvo.org that is heavily based on [Virtual World Framework](https://en.wikipedia.org/wiki/Virtual_world_framework) (containing elements of Open Croquet architecture), I have started revising the current Reflector server.\n\nLet me introduce to you an ideas and early prototype of the **Krestianstvo Luminary** for Open Croquet architecture and Virtual World Framework. \n**Krestianstvo Luminary** potentially could replace Reflector server in flavour of using offline-first [Gun DB](https://gun.eco/docs/Introduction) pure distributed storage system. That allows instead of â€˜Reflectingâ€™ messages with centralised Croquetâ€™s time now, to â€˜Shiningâ€™ time on every connected node using Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), running in peer-to-peer Web. Also to secure all external messages streams by using peer-to-peer identities and [SEA](https://gun.eco/docs/SEA) cryptographic library for Gun DB. More over running Luminary on [AXE](https://gun.eco/docs/AXE#faq) blockchain.  \n**Krestianstvo Luminary** simply transforms the only server related Croquetâ€™s part - Reflector (taken from VWF version) into the pure peer-to-peer application, running on a clientâ€™s Web Browsers.  \n\n| | Croquet&nbsp;Reflector&nbsp;(VWF) | Krestianstvo Luminary |\n| --- | :---: | :---: |\n| **Architecture:** | Client-Server | Peer-to-Peer |\n| **Croquet time stamp:** | on server | on peer |\n| **Time now is:** | server machineâ€™s time | GunDB HAM state: combines timestamps, vector clocks, and a conflict resolution algorithm |\n| source code | new Date( ).getTime( ) | Gun.state.is ( node, property ) |\n| **Heartbeat messages:** | by server | by selected peer |\n| **Reflector app logic:** | on server | on peer |\n| **Hosting:** | dedicated server with Web Sockets | peerâ€™s Web Browsers connected through Daisy-chain Ad-hoc Mesh-network (for swapping in different transport layers: Web Sockets, WebRTC, etc.) |\n| **Securing the streams of messages:** | by server | by peer-to-peer identities |\n\n\nFor those who are not familiar with Open Croquet architecture, just want to mark key principals behind it in simple words.\n"
      },
      "id": "33cfc513b8da316f",
      "type": "add",
      "after": "6398138dea70bd9d",
      "date": 1655292838746
    },
    {
      "type": "edit",
      "id": "33cfc513b8da316f",
      "item": {
        "type": "markdown",
        "id": "33cfc513b8da316f",
        "text": "---\n\n## Krestianstvo Luminary for Open Croquet architecture and Virtual World Framework in peer-to-peer Web\n\nEveryone who is familiar with [Croquet architecture](https://en.wikipedia.org/wiki/Croquet_Project) are anticipating (waiting breathless) the updates for Open Croquet architecture from **Croquet V** by David A. Smith and [Croquet Studios](https://croquet.studio)!\n\nHowever, while working on [LiveCoding.space](https://www.krestianstvo.org/sdk3) project by Krestianstvo.org that is heavily based on [Virtual World Framework](https://en.wikipedia.org/wiki/Virtual_world_framework) (containing elements of Open Croquet architecture), I have started revising the current Reflector server.\n\nLet me introduce to you an ideas and early prototype of the **Krestianstvo Luminary** for Open Croquet architecture and Virtual World Framework. \n**Krestianstvo Luminary** potentially could replace Reflector server in flavour of using offline-first [Gun DB](https://gun.eco/docs/Introduction) pure distributed storage system. That allows instead of â€˜Reflectingâ€™ messages with centralised Croquetâ€™s time now, to â€˜Shiningâ€™ time on every connected node using Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), running in peer-to-peer Web. Also to secure all external messages streams by using peer-to-peer identities and [SEA](https://gun.eco/docs/SEA) cryptographic library for Gun DB. More over running Luminary on [AXE](https://gun.eco/docs/AXE#faq) blockchain.  \n**Krestianstvo Luminary** simply transforms the only server related Croquetâ€™s part - Reflector (taken from VWF version) into the pure peer-to-peer application, running on a clientâ€™s Web Browsers.  \n\n| | Croquet&nbsp;Reflector&nbsp;(VWF) | Krestianstvo Luminary |\n| --- | :---: | :---: |\n| **Architecture:** | Client-Server | Peer-to-Peer |\n| **Croquet time stamp:** | on server | on peer |\n| **Time now is:** | server machineâ€™s time | GunDB HAM state: combines timestamps, vector clocks, and a conflict resolution algorithm |\n| source code | new Date( ).getTime( ) | Gun.state.is ( node, property ) |\n| **Heartbeat messages:** | by server | by selected peer |\n| **Reflector app logic:** | on server | on peer |\n| **Hosting:** | dedicated server with Web Sockets | peerâ€™s Web Browsers connected through Daisy-chain Ad-hoc Mesh-network (for swapping in different transport layers: Web Sockets, WebRTC, etc.) |\n| **Securing the streams of messages:** | by server | by peer-to-peer identities |\n\n\nFor those who are not familiar with Open Croquet architecture, just want to mark key principals behind it in simple words.\n"
      },
      "date": 1655292841389
    },
    {
      "type": "edit",
      "id": "33cfc513b8da316f",
      "item": {
        "type": "markdown",
        "id": "33cfc513b8da316f",
        "text": "---\n\n## Krestianstvo Luminary for Open Croquet architecture and Virtual World Framework in peer-to-peer Web\n\nEveryone who is familiar with [Croquet architecture](https://en.wikipedia.org/wiki/Croquet_Project) are anticipating (waiting breathless) the updates for Open Croquet architecture from **Croquet V** by David A. Smith and [Croquet Studios](https://croquet.studio)!\n\nHowever, while working on [LiveCoding.space](https://www.krestianstvo.org/sdk3) project by Krestianstvo.org that is heavily based on [Virtual World Framework](https://en.wikipedia.org/wiki/Virtual_world_framework) (containing elements of Open Croquet architecture), I have started revising the current Reflector server.\n\nLet me introduce to you an ideas and early prototype of the **Krestianstvo Luminary** for Open Croquet architecture and Virtual World Framework. \n**Krestianstvo Luminary** potentially could replace Reflector server in flavour of using offline-first [Gun DB](https://gun.eco/docs/Introduction) pure distributed storage system. That allows instead of â€˜Reflectingâ€™ messages with centralised Croquetâ€™s time now, to â€˜Shiningâ€™ time on every connected node using Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), running in peer-to-peer Web. Also to secure all external messages streams by using peer-to-peer identities and [SEA](https://gun.eco/docs/SEA) cryptographic library for Gun DB. More over running Luminary on [AXE](https://gun.eco/docs/AXE#faq) blockchain.  \n**Krestianstvo Luminary** simply transforms the only server related Croquetâ€™s part - Reflector (taken from VWF version) into the pure peer-to-peer application, running on a clientâ€™s Web Browsers.  \n\n| | Croquet&nbsp;Reflector&nbsp;(VWF) | Krestianstvo Luminary |\n| --- | :---: | :---: |\n| **Architecture:** | Client-Server | Peer-to-Peer |\n| **Croquet time stamp:** | on server | on peer |\n| **Time now is:** | server machineâ€™s time | GunDB HAM state: combines timestamps, vector clocks, and a conflict resolution algorithm |\n| source code | new Date( ).getTime( ) | Gun.state.is ( node, property ) |\n| **Heartbeat messages:** | by server | by selected peer |\n| **Reflector app logic:** | on server | on peer |\n| **Hosting:** | dedicated server with Web Sockets | peerâ€™s Web Browsers connected through Daisy-chain Ad-hoc Mesh-network (for swapping in different transport layers: Web Sockets, WebRTC, etc.) |\n| **Securing the streams of messages:** | by server | by peer-to-peer identities |\n\n\nFor those who are not familiar with Open Croquet architecture, just want to mark key principals behind it in simple words.\n"
      },
      "date": 1655292996703
    },
    {
      "item": {
        "type": "html",
        "id": "980f55ed48518800",
        "text": "<img\n  width=\"100%\"\n  src=\"https://github.com/RalfBarkow/luminary/raw/master/assets/croquet-reflector.jpg\"\n>"
      },
      "id": "980f55ed48518800",
      "type": "add",
      "after": "3699bfc17cdbe53c",
      "date": 1655293003356
    },
    {
      "id": "980f55ed48518800",
      "type": "move",
      "order": [
        "5795e9078e1a176e",
        "2b4f2a80b92f1677",
        "6398138dea70bd9d",
        "33cfc513b8da316f",
        "980f55ed48518800",
        "3699bfc17cdbe53c"
      ],
      "date": 1655293008042,
      "error": {
        "type": "error",
        "msg": "Internal Server Error",
        "response": "Server Ignoring move. Try reload."
      }
    },
    {
      "type": "add",
      "id": "3699bfc17cdbe53c",
      "item": {
        "type": "markdown",
        "id": "3699bfc17cdbe53c",
        "text": " \n\n![croquet-reflector](/assets/croquet-reflector.jpg)\n\n### Croquet Architecture\n\nCroquet introduced the notion of virtual time for decentralised computations. Thinking on objects as stream of messages, which lead to deterministic computations on every connected node in decentralised network. All computations are done on every node by itself while interpreting an internal queue of messages, which are not replicated to the network. But these queues are synchronised by an external heartbeat messages coming from Reflector - a tiny server. Also any nodeâ€™s self generated messages, which should be distributed to other nodes are marked as external. They are explicitly routed to the Reflector, where the are stamped with the Reflectorâ€™s time now and are returned back to the node itself and all other nodes on the network. \nReflector is not only used for sending heartbeat messages, stamping external messages, but also it is used for holding the list of connected clients, list of running virtual world instances, bootstrapping new client connections.\n\n### Reflector \n\nSo, in Croquet architecture for decentralised networks, the Reflector while being a very tiny or even being a micro service - it remains a server. \nIt uses WebSockets for coordinating clients, world instances, providing â€˜now timeâ€™ for the clients, reflecting external messages.\n\nLetâ€™s look how it works in Virtual World Framework (VWF). I will use the available open source code from VWF, which I am using in LiveCoding.space project by Krestianstvo.org\n\nThatâ€™s a function returning time now by Reflector. Time is getting from a machine, running a Reflector server:\n(server code from **lib/reflector.js**)\n\n``` \nfunction GetNow( ) {\n    return new Date( ).getTime( ) / 1000.0;\n}\n``` \n\nThen it uses to make a stamp for a virtual world instance:\n\n```\nreturn ( GetNow( ) - this.start_time ) * this.rate\n```\n\nReflector send this time stamps using WebSockets. And on a client side VWF has a method for dispatching: \n(client code from **public/vwf.js**)\n\n```\nsocket.on( \"message\", function( message ) {\n  var fields = message;\n  â€¦.\n  fields.time = Number( fields.time );\n  fields.origin = \"reflector\";\n  queue.insert( fields, !fields.action );\n  â€¦.\n```\n\nLook at send and respond methods, where clients use WebSocket to send external messages back to the Reflector:\n```\n   var message = JSON.stringify( fields );\n   socket.send( message );\n```\n\n\n### Luminary\n\nNow, letâ€™s look at how Krestianstvo Luminary could identically replace the Reflector server.\n\n![luminary](/assets/luminary.jpg)\n\nFirst of all clients are never forced using WebSockets directly from the application itself for sending or receiving messages. Instead Gun DB responds for that functionality internally. All operations which previously relay on WebSocket connection are replaced by subscribing to updates and changes on a Gun DB nodes and properties.\nSo, instances, clients - are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\nClient, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a metronome (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜tickâ€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\nThe start time will be the state value of HAM at â€˜start_timeâ€™ property, of heartbeat node. Please notice, that actual Croquet timestamp is not calculated here, as it was in Reflector server. The timestamp used for the Croquet internal queue of messages will be calculated on reading of â€˜tickâ€™ by the VWF client in itâ€™s main application. \n\nHere is the simplified core version of dispatching â€˜tickâ€™ on VWF client main app, just to get the idea: (full code on **public/vwf.js**, links below)\n\n```\nlet instance = _LCSDB.get(vwf.namespace_);\n\ninstance.get('heartbeat').on(function (res) { \n   if(res.tick) {\n  let msg = self.stamp(res, start_time, rate);\n\n  queue.insert(fields, !fields.action);\n\n  }\n}\n\nthis.stamp = function(source, start_time, rate) {\n\n            let message = JSON.parse(source.tick);\n\n            message.state = Gun.state.is(source, 'tick');\n            message.start_time = start_time; //Gun.state.is(source, 'start_time');\n            message.rate = rate; //source.rate;\n\n            var time = ((message.state - message.start_time)*message.rate)/1000;\n\n            if (message.action == 'setState'){\n                time = ((_app.reflector.setStateTime - message.start_time)*message.rate)/1000;\n            }\n            message.time = Number( time );\n            message.origin = â€œreflector\";\n\n            return message\n        }\n\n```\n\nThe main point here is the calculation of Croquet time using Gunâ€™s HAM state:\n```\nGun.state.is ( node, property )\n```\n\nfor message:\n```\nmessage.state = Gun.state.is(source, â€˜tickâ€™); // time of updating tick\nmessage.start_time = Gun.state.is(source, â€˜start_time'); //start time of the instance heartbeat\nmessage.rate = source.rate;\nvar time = ((message.state - message.start_time)*message.rate)/1000;\n```\n\nSo, all peers will calculate exactly the same Croquet time on getting an update from Gun DB,  regardless of the time when they get this update (network delays, etc). \n\nAs you could imagine, sending external messages will be as simple as just writing the message by a peer to an instance heartbeat with a new messageâ€™s content. All connected peers and a peer itself will get that message, stamped with Croquet time, while they are subscribed on changes on heartbeat node (look above at **instance.get(â€˜heartbeatâ€™).on()** definition )\n```\ninstance.get('heartbeat').get('tick').put(JSON.stringify(newMsg));\n```\n\nActually thatâ€™s it!\n\n### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing metronome empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deplyed anywhere, anytime available on AXE blockchain.\n\n### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "after": "33cfc513b8da316f",
      "date": 1655293009725
    },
    {
      "type": "edit",
      "id": "980f55ed48518800",
      "item": {
        "type": "html",
        "id": "980f55ed48518800",
        "text": "<img\n  width=\"100%\"\n  src=\"https://github.com/RalfBarkow/luminary/raw/master/assets/croquet-reflector.jpg\"\n>"
      },
      "date": 1655293023290
    },
    {
      "type": "fork",
      "date": 1655293029752
    },
    {
      "type": "edit",
      "id": "3699bfc17cdbe53c",
      "item": {
        "type": "markdown",
        "id": "3699bfc17cdbe53c",
        "text": "### Croquet Architecture\n\nCroquet introduced the notion of virtual time for decentralised computations. Thinking on objects as stream of messages, which lead to deterministic computations on every connected node in decentralised network. All computations are done on every node by itself while interpreting an internal queue of messages, which are not replicated to the network. But these queues are synchronised by an external heartbeat messages coming from Reflector - a tiny server. Also any nodeâ€™s self generated messages, which should be distributed to other nodes are marked as external. They are explicitly routed to the Reflector, where the are stamped with the Reflectorâ€™s time now and are returned back to the node itself and all other nodes on the network. \nReflector is not only used for sending heartbeat messages, stamping external messages, but also it is used for holding the list of connected clients, list of running virtual world instances, bootstrapping new client connections.\n\n### Reflector \n\nSo, in Croquet architecture for decentralised networks, the Reflector while being a very tiny or even being a micro service - it remains a server. \nIt uses WebSockets for coordinating clients, world instances, providing â€˜now timeâ€™ for the clients, reflecting external messages.\n\nLetâ€™s look how it works in Virtual World Framework (VWF). I will use the available open source code from VWF, which I am using in LiveCoding.space project by Krestianstvo.org\n\nThatâ€™s a function returning time now by Reflector. Time is getting from a machine, running a Reflector server:\n(server code from **lib/reflector.js**)\n\n``` \nfunction GetNow( ) {\n    return new Date( ).getTime( ) / 1000.0;\n}\n``` \n\nThen it uses to make a stamp for a virtual world instance:\n\n```\nreturn ( GetNow( ) - this.start_time ) * this.rate\n```\n\nReflector send this time stamps using WebSockets. And on a client side VWF has a method for dispatching: \n(client code from **public/vwf.js**)\n\n```\nsocket.on( \"message\", function( message ) {\n  var fields = message;\n  â€¦.\n  fields.time = Number( fields.time );\n  fields.origin = \"reflector\";\n  queue.insert( fields, !fields.action );\n  â€¦.\n```\n\nLook at send and respond methods, where clients use WebSocket to send external messages back to the Reflector:\n```\n   var message = JSON.stringify( fields );\n   socket.send( message );\n```\n\n\n### Luminary\n\nNow, letâ€™s look at how Krestianstvo Luminary could identically replace the Reflector server.\n\n![luminary](/assets/luminary.jpg)\n\nFirst of all clients are never forced using WebSockets directly from the application itself for sending or receiving messages. Instead Gun DB responds for that functionality internally. All operations which previously relay on WebSocket connection are replaced by subscribing to updates and changes on a Gun DB nodes and properties.\nSo, instances, clients - are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\nClient, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a metronome (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜tickâ€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\nThe start time will be the state value of HAM at â€˜start_timeâ€™ property, of heartbeat node. Please notice, that actual Croquet timestamp is not calculated here, as it was in Reflector server. The timestamp used for the Croquet internal queue of messages will be calculated on reading of â€˜tickâ€™ by the VWF client in itâ€™s main application. \n\nHere is the simplified core version of dispatching â€˜tickâ€™ on VWF client main app, just to get the idea: (full code on **public/vwf.js**, links below)\n\n```\nlet instance = _LCSDB.get(vwf.namespace_);\n\ninstance.get('heartbeat').on(function (res) { \n   if(res.tick) {\n  let msg = self.stamp(res, start_time, rate);\n\n  queue.insert(fields, !fields.action);\n\n  }\n}\n\nthis.stamp = function(source, start_time, rate) {\n\n            let message = JSON.parse(source.tick);\n\n            message.state = Gun.state.is(source, 'tick');\n            message.start_time = start_time; //Gun.state.is(source, 'start_time');\n            message.rate = rate; //source.rate;\n\n            var time = ((message.state - message.start_time)*message.rate)/1000;\n\n            if (message.action == 'setState'){\n                time = ((_app.reflector.setStateTime - message.start_time)*message.rate)/1000;\n            }\n            message.time = Number( time );\n            message.origin = â€œreflector\";\n\n            return message\n        }\n\n```\n\nThe main point here is the calculation of Croquet time using Gunâ€™s HAM state:\n```\nGun.state.is ( node, property )\n```\n\nfor message:\n```\nmessage.state = Gun.state.is(source, â€˜tickâ€™); // time of updating tick\nmessage.start_time = Gun.state.is(source, â€˜start_time'); //start time of the instance heartbeat\nmessage.rate = source.rate;\nvar time = ((message.state - message.start_time)*message.rate)/1000;\n```\n\nSo, all peers will calculate exactly the same Croquet time on getting an update from Gun DB,  regardless of the time when they get this update (network delays, etc). \n\nAs you could imagine, sending external messages will be as simple as just writing the message by a peer to an instance heartbeat with a new messageâ€™s content. All connected peers and a peer itself will get that message, stamped with Croquet time, while they are subscribed on changes on heartbeat node (look above at **instance.get(â€˜heartbeatâ€™).on()** definition )\n```\ninstance.get('heartbeat').get('tick').put(JSON.stringify(newMsg));\n```\n\nActually thatâ€™s it!\n\n### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing metronome empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deplyed anywhere, anytime available on AXE blockchain.\n\n### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "date": 1655293047378
    },
    {
      "type": "edit",
      "id": "3699bfc17cdbe53c",
      "item": {
        "type": "markdown",
        "id": "3699bfc17cdbe53c",
        "text": "### Croquet Architecture\n\nCroquet introduced the notion of [[Virtual Time]] for decentralised computations. Thinking on objects as stream of messages, which lead to deterministic computations on every connected node in decentralised network. All computations are done on every node by itself while interpreting an internal queue of messages, which are not replicated to the network. But these queues are synchronised by an external heartbeat messages coming from Reflector - a tiny server. Also any nodeâ€™s self generated messages, which should be distributed to other nodes are marked as external. They are explicitly routed to the Reflector, where the are stamped with the Reflectorâ€™s time now and are returned back to the node itself and all other nodes on the network. \nReflector is not only used for sending heartbeat messages, stamping external messages, but also it is used for holding the list of connected clients, list of running virtual world instances, bootstrapping new client connections.\n\n### Reflector \n\nSo, in Croquet architecture for decentralised networks, the Reflector while being a very tiny or even being a micro service - it remains a server. \nIt uses WebSockets for coordinating clients, world instances, providing â€˜now timeâ€™ for the clients, reflecting external messages.\n\nLetâ€™s look how it works in Virtual World Framework (VWF). I will use the available open source code from VWF, which I am using in LiveCoding.space project by Krestianstvo.org\n\nThatâ€™s a function returning time now by Reflector. Time is getting from a machine, running a Reflector server:\n(server code from **lib/reflector.js**)\n\n``` \nfunction GetNow( ) {\n    return new Date( ).getTime( ) / 1000.0;\n}\n``` \n\nThen it uses to make a stamp for a virtual world instance:\n\n```\nreturn ( GetNow( ) - this.start_time ) * this.rate\n```\n\nReflector send this time stamps using WebSockets. And on a client side VWF has a method for dispatching: \n(client code from **public/vwf.js**)\n\n```\nsocket.on( \"message\", function( message ) {\n  var fields = message;\n  â€¦.\n  fields.time = Number( fields.time );\n  fields.origin = \"reflector\";\n  queue.insert( fields, !fields.action );\n  â€¦.\n```\n\nLook at send and respond methods, where clients use WebSocket to send external messages back to the Reflector:\n```\n   var message = JSON.stringify( fields );\n   socket.send( message );\n```\n\n\n### Luminary\n\nNow, letâ€™s look at how Krestianstvo Luminary could identically replace the Reflector server.\n\n![luminary](/assets/luminary.jpg)\n\nFirst of all clients are never forced using WebSockets directly from the application itself for sending or receiving messages. Instead Gun DB responds for that functionality internally. All operations which previously relay on WebSocket connection are replaced by subscribing to updates and changes on a Gun DB nodes and properties.\nSo, instances, clients - are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\nClient, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a metronome (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜tickâ€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\nThe start time will be the state value of HAM at â€˜start_timeâ€™ property, of heartbeat node. Please notice, that actual Croquet timestamp is not calculated here, as it was in Reflector server. The timestamp used for the Croquet internal queue of messages will be calculated on reading of â€˜tickâ€™ by the VWF client in itâ€™s main application. \n\nHere is the simplified core version of dispatching â€˜tickâ€™ on VWF client main app, just to get the idea: (full code on **public/vwf.js**, links below)\n\n```\nlet instance = _LCSDB.get(vwf.namespace_);\n\ninstance.get('heartbeat').on(function (res) { \n   if(res.tick) {\n  let msg = self.stamp(res, start_time, rate);\n\n  queue.insert(fields, !fields.action);\n\n  }\n}\n\nthis.stamp = function(source, start_time, rate) {\n\n            let message = JSON.parse(source.tick);\n\n            message.state = Gun.state.is(source, 'tick');\n            message.start_time = start_time; //Gun.state.is(source, 'start_time');\n            message.rate = rate; //source.rate;\n\n            var time = ((message.state - message.start_time)*message.rate)/1000;\n\n            if (message.action == 'setState'){\n                time = ((_app.reflector.setStateTime - message.start_time)*message.rate)/1000;\n            }\n            message.time = Number( time );\n            message.origin = â€œreflector\";\n\n            return message\n        }\n\n```\n\nThe main point here is the calculation of Croquet time using Gunâ€™s HAM state:\n```\nGun.state.is ( node, property )\n```\n\nfor message:\n```\nmessage.state = Gun.state.is(source, â€˜tickâ€™); // time of updating tick\nmessage.start_time = Gun.state.is(source, â€˜start_time'); //start time of the instance heartbeat\nmessage.rate = source.rate;\nvar time = ((message.state - message.start_time)*message.rate)/1000;\n```\n\nSo, all peers will calculate exactly the same Croquet time on getting an update from Gun DB,  regardless of the time when they get this update (network delays, etc). \n\nAs you could imagine, sending external messages will be as simple as just writing the message by a peer to an instance heartbeat with a new messageâ€™s content. All connected peers and a peer itself will get that message, stamped with Croquet time, while they are subscribed on changes on heartbeat node (look above at **instance.get(â€˜heartbeatâ€™).on()** definition )\n```\ninstance.get('heartbeat').get('tick').put(JSON.stringify(newMsg));\n```\n\nActually thatâ€™s it!\n\n### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing metronome empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deplyed anywhere, anytime available on AXE blockchain.\n\n### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "date": 1655293087613
    },
    {
      "type": "edit",
      "id": "3699bfc17cdbe53c",
      "item": {
        "type": "markdown",
        "id": "3699bfc17cdbe53c",
        "text": "### Croquet Architecture\n\nCroquet introduced the notion of [[Virtual Time]] for decentralised computations. Thinking on objects as stream of messages, which lead to deterministic computations on every connected node in decentralised network. All computations are done on every node by itself while interpreting an internal queue of messages, which are not replicated to the network. But these queues are synchronised by an external heartbeat messages coming from Reflector - a tiny server. Also any nodeâ€™s self generated messages, which should be distributed to other nodes are marked as external. They are explicitly routed to the Reflector, where the are stamped with the Reflectorâ€™s time now and are returned back to the node itself and all other nodes on the network. \nReflector is not only used for sending heartbeat messages, stamping external messages, but also it is used for holding the list of connected clients, list of running virtual world instances, bootstrapping new client connections.\n\n\n"
      },
      "date": 1655293122432
    },
    {
      "type": "add",
      "id": "d3c5d9c8882e321f",
      "item": {
        "type": "markdown",
        "id": "d3c5d9c8882e321f",
        "text": "### Reflector \n\nSo, in Croquet architecture for decentralised networks, the Reflector while being a very tiny or even being a micro service - it remains a server. \nIt uses WebSockets for coordinating clients, world instances, providing â€˜now timeâ€™ for the clients, reflecting external messages.\n\nLetâ€™s look how it works in Virtual World Framework (VWF). I will use the available open source code from VWF, which I am using in LiveCoding.space project by Krestianstvo.org\n\nThatâ€™s a function returning time now by Reflector. Time is getting from a machine, running a Reflector server:\n(server code from **lib/reflector.js**)\n\n``` \nfunction GetNow( ) {\n    return new Date( ).getTime( ) / 1000.0;\n}\n``` \n\nThen it uses to make a stamp for a virtual world instance:\n\n```\nreturn ( GetNow( ) - this.start_time ) * this.rate\n```\n\nReflector send this time stamps using WebSockets. And on a client side VWF has a method for dispatching: \n(client code from **public/vwf.js**)\n\n```\nsocket.on( \"message\", function( message ) {\n  var fields = message;\n  â€¦.\n  fields.time = Number( fields.time );\n  fields.origin = \"reflector\";\n  queue.insert( fields, !fields.action );\n  â€¦.\n```\n\nLook at send and respond methods, where clients use WebSocket to send external messages back to the Reflector:\n```\n   var message = JSON.stringify( fields );\n   socket.send( message );\n```\n\n\n### Luminary\n\nNow, letâ€™s look at how Krestianstvo Luminary could identically replace the Reflector server.\n\n![luminary](/assets/luminary.jpg)\n\nFirst of all clients are never forced using WebSockets directly from the application itself for sending or receiving messages. Instead Gun DB responds for that functionality internally. All operations which previously relay on WebSocket connection are replaced by subscribing to updates and changes on a Gun DB nodes and properties.\nSo, instances, clients - are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\nClient, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a metronome (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜tickâ€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\nThe start time will be the state value of HAM at â€˜start_timeâ€™ property, of heartbeat node. Please notice, that actual Croquet timestamp is not calculated here, as it was in Reflector server. The timestamp used for the Croquet internal queue of messages will be calculated on reading of â€˜tickâ€™ by the VWF client in itâ€™s main application. \n\nHere is the simplified core version of dispatching â€˜tickâ€™ on VWF client main app, just to get the idea: (full code on **public/vwf.js**, links below)\n\n```\nlet instance = _LCSDB.get(vwf.namespace_);\n\ninstance.get('heartbeat').on(function (res) { \n   if(res.tick) {\n  let msg = self.stamp(res, start_time, rate);\n\n  queue.insert(fields, !fields.action);\n\n  }\n}\n\nthis.stamp = function(source, start_time, rate) {\n\n            let message = JSON.parse(source.tick);\n\n            message.state = Gun.state.is(source, 'tick');\n            message.start_time = start_time; //Gun.state.is(source, 'start_time');\n            message.rate = rate; //source.rate;\n\n            var time = ((message.state - message.start_time)*message.rate)/1000;\n\n            if (message.action == 'setState'){\n                time = ((_app.reflector.setStateTime - message.start_time)*message.rate)/1000;\n            }\n            message.time = Number( time );\n            message.origin = â€œreflector\";\n\n            return message\n        }\n\n```\n\nThe main point here is the calculation of Croquet time using Gunâ€™s HAM state:\n```\nGun.state.is ( node, property )\n```\n\nfor message:\n```\nmessage.state = Gun.state.is(source, â€˜tickâ€™); // time of updating tick\nmessage.start_time = Gun.state.is(source, â€˜start_time'); //start time of the instance heartbeat\nmessage.rate = source.rate;\nvar time = ((message.state - message.start_time)*message.rate)/1000;\n```\n\nSo, all peers will calculate exactly the same Croquet time on getting an update from Gun DB,  regardless of the time when they get this update (network delays, etc). \n\nAs you could imagine, sending external messages will be as simple as just writing the message by a peer to an instance heartbeat with a new messageâ€™s content. All connected peers and a peer itself will get that message, stamped with Croquet time, while they are subscribed on changes on heartbeat node (look above at **instance.get(â€˜heartbeatâ€™).on()** definition )\n```\ninstance.get('heartbeat').get('tick').put(JSON.stringify(newMsg));\n```\n\nActually thatâ€™s it!\n\n### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing metronome empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deplyed anywhere, anytime available on AXE blockchain.\n\n### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "after": "3699bfc17cdbe53c",
      "date": 1655293124265
    },
    {
      "type": "edit",
      "id": "3699bfc17cdbe53c",
      "item": {
        "type": "markdown",
        "id": "3699bfc17cdbe53c",
        "text": "### Croquet Architecture\n\nCroquet introduced the notion of [[Virtual Time]] for decentralised computations. Thinking on objects as stream of messages, which lead to deterministic computations on every connected node in decentralised network. All computations are done on every node by itself while interpreting an internal queue of messages, which are not replicated to the network. But these queues are synchronised by an external heartbeat messages coming from [[Reflector]] â€“ a tiny server. Also any nodeâ€™s self generated messages, which should be distributed to other nodes are marked as external. They are explicitly routed to the Reflector, where the are stamped with the Reflectorâ€™s time now and are returned back to the node itself and all other nodes on the network. \nReflector is not only used for sending heartbeat messages, stamping external messages, but also it is used for holding the list of connected clients, list of running virtual world instances, bootstrapping new client connections.\n\n\n"
      },
      "date": 1655293136995
    },
    {
      "type": "edit",
      "id": "3699bfc17cdbe53c",
      "item": {
        "type": "markdown",
        "id": "3699bfc17cdbe53c",
        "text": "### Croquet Architecture\n\nCroquet introduced the notion of [[Virtual Time]] for decentralised computations. Thinking on objects as stream of messages, which lead to deterministic computations on every connected node in decentralised network. All computations are done on every node by itself while interpreting an internal queue of messages, which are not replicated to the network. But these queues are synchronised by an external heartbeat messages coming from [[Reflector]] â€“ a tiny server. Also any nodeâ€™s self generated messages, which should be distributed to other nodes are marked as external. They are explicitly routed to the Reflector, where the are stamped with the Reflectorâ€™s time now and are returned back to the node itself and all other nodes on the network. \n"
      },
      "date": 1655293160369
    },
    {
      "type": "add",
      "id": "2a767ebe0e974649",
      "item": {
        "type": "markdown",
        "id": "2a767ebe0e974649",
        "text": "Reflector is not only used for sending heartbeat messages, stamping external messages, but also it is used for holding the list of connected clients, list of running virtual world instances, bootstrapping new client connections.\n\n\n"
      },
      "after": "3699bfc17cdbe53c",
      "date": 1655293161454
    },
    {
      "type": "edit",
      "id": "d3c5d9c8882e321f",
      "item": {
        "type": "markdown",
        "id": "d3c5d9c8882e321f",
        "text": "### Reflector \n\nSo, in Croquet architecture for decentralised networks, the Reflector while being a very tiny or even being a micro service - it remains a server. It uses WebSockets for coordinating clients, world instances, providing â€˜now timeâ€™ for the clients, reflecting external messages.\n\nLetâ€™s look how it works in Virtual World Framework (VWF). I will use the available open source code from VWF, which I am using in LiveCoding.space project by Krestianstvo.org\n\nThatâ€™s a function returning time now by Reflector. Time is getting from a machine, running a Reflector server:\n(server code from **lib/reflector.js**)\n\n``` \nfunction GetNow( ) {\n    return new Date( ).getTime( ) / 1000.0;\n}\n``` \n\nThen it uses to make a stamp for a virtual world instance:\n\n```\nreturn ( GetNow( ) - this.start_time ) * this.rate\n```\n\nReflector send this time stamps using WebSockets. And on a client side VWF has a method for dispatching: \n(client code from **public/vwf.js**)\n\n```\nsocket.on( \"message\", function( message ) {\n  var fields = message;\n  â€¦.\n  fields.time = Number( fields.time );\n  fields.origin = \"reflector\";\n  queue.insert( fields, !fields.action );\n  â€¦.\n```\n\nLook at send and respond methods, where clients use WebSocket to send external messages back to the Reflector:\n```\n   var message = JSON.stringify( fields );\n   socket.send( message );\n```\n\n\n### Luminary\n\nNow, letâ€™s look at how Krestianstvo Luminary could identically replace the Reflector server.\n\n![luminary](/assets/luminary.jpg)\n\nFirst of all clients are never forced using WebSockets directly from the application itself for sending or receiving messages. Instead Gun DB responds for that functionality internally. All operations which previously relay on WebSocket connection are replaced by subscribing to updates and changes on a Gun DB nodes and properties.\nSo, instances, clients - are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\nClient, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a metronome (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜tickâ€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\nThe start time will be the state value of HAM at â€˜start_timeâ€™ property, of heartbeat node. Please notice, that actual Croquet timestamp is not calculated here, as it was in Reflector server. The timestamp used for the Croquet internal queue of messages will be calculated on reading of â€˜tickâ€™ by the VWF client in itâ€™s main application. \n\nHere is the simplified core version of dispatching â€˜tickâ€™ on VWF client main app, just to get the idea: (full code on **public/vwf.js**, links below)\n\n```\nlet instance = _LCSDB.get(vwf.namespace_);\n\ninstance.get('heartbeat').on(function (res) { \n   if(res.tick) {\n  let msg = self.stamp(res, start_time, rate);\n\n  queue.insert(fields, !fields.action);\n\n  }\n}\n\nthis.stamp = function(source, start_time, rate) {\n\n            let message = JSON.parse(source.tick);\n\n            message.state = Gun.state.is(source, 'tick');\n            message.start_time = start_time; //Gun.state.is(source, 'start_time');\n            message.rate = rate; //source.rate;\n\n            var time = ((message.state - message.start_time)*message.rate)/1000;\n\n            if (message.action == 'setState'){\n                time = ((_app.reflector.setStateTime - message.start_time)*message.rate)/1000;\n            }\n            message.time = Number( time );\n            message.origin = â€œreflector\";\n\n            return message\n        }\n\n```\n\nThe main point here is the calculation of Croquet time using Gunâ€™s HAM state:\n```\nGun.state.is ( node, property )\n```\n\nfor message:\n```\nmessage.state = Gun.state.is(source, â€˜tickâ€™); // time of updating tick\nmessage.start_time = Gun.state.is(source, â€˜start_time'); //start time of the instance heartbeat\nmessage.rate = source.rate;\nvar time = ((message.state - message.start_time)*message.rate)/1000;\n```\n\nSo, all peers will calculate exactly the same Croquet time on getting an update from Gun DB,  regardless of the time when they get this update (network delays, etc). \n\nAs you could imagine, sending external messages will be as simple as just writing the message by a peer to an instance heartbeat with a new messageâ€™s content. All connected peers and a peer itself will get that message, stamped with Croquet time, while they are subscribed on changes on heartbeat node (look above at **instance.get(â€˜heartbeatâ€™).on()** definition )\n```\ninstance.get('heartbeat').get('tick').put(JSON.stringify(newMsg));\n```\n\nActually thatâ€™s it!\n\n### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing metronome empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deplyed anywhere, anytime available on AXE blockchain.\n\n### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "date": 1655293189545
    },
    {
      "type": "edit",
      "id": "d3c5d9c8882e321f",
      "item": {
        "type": "markdown",
        "id": "d3c5d9c8882e321f",
        "text": "### Reflector \n\nSo, in Croquet architecture for decentralised networks, the Reflector while being a very tiny or even being a micro service - it remains a server. It uses WebSockets for coordinating clients, world instances, providing â€˜now timeâ€™ for the clients, reflecting external messages.\n\nLetâ€™s look how it works in Virtual World Framework (VWF). I will use the available open source code from VWF, which I am using in LiveCoding.space project by Krestianstvo.org\n\nThatâ€™s a function returning time now by Reflector. Time is getting from a machine, running a Reflector server:\n(server code from **lib/reflector.js**)\n\n``` \nfunction GetNow( ) {\n    return new Date( ).getTime( ) / 1000.0;\n}\n``` \n\nThen it uses to make a stamp for a virtual world instance:\n\n```\nreturn ( GetNow( ) - this.start_time ) * this.rate\n```\n\nReflector send this time stamps using WebSockets. And on a client side VWF has a method for dispatching: \n(client code from **public/vwf.js**)\n\n```\nsocket.on( \"message\", function( message ) {\n  var fields = message;\n  â€¦.\n  fields.time = Number( fields.time );\n  fields.origin = \"reflector\";\n  queue.insert( fields, !fields.action );\n  â€¦.\n```\n\nLook at send and respond methods, where clients use WebSocket to send external messages back to the Reflector:\n```\n   var message = JSON.stringify( fields );\n   socket.send( message );\n```\n\n\n\n"
      },
      "date": 1655293270447
    },
    {
      "type": "add",
      "id": "3b43549a033e3a17",
      "item": {
        "type": "markdown",
        "id": "3b43549a033e3a17",
        "text": "### Luminary\n\nNow, letâ€™s look at how Krestianstvo Luminary could identically replace the Reflector server.\n"
      },
      "after": "d3c5d9c8882e321f",
      "date": 1655293275247
    },
    {
      "item": {
        "type": "factory",
        "id": "904d819b95ccd02e"
      },
      "id": "904d819b95ccd02e",
      "type": "add",
      "after": "6873a40373efa5b7",
      "date": 1655293277132
    },
    {
      "type": "add",
      "id": "6873a40373efa5b7",
      "item": {
        "type": "markdown",
        "id": "6873a40373efa5b7",
        "text": "\n![luminary](/assets/luminary.jpg)\n\nFirst of all clients are never forced using WebSockets directly from the application itself for sending or receiving messages. Instead Gun DB responds for that functionality internally. All operations which previously relay on WebSocket connection are replaced by subscribing to updates and changes on a Gun DB nodes and properties.\nSo, instances, clients - are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\nClient, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a metronome (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜tickâ€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\nThe start time will be the state value of HAM at â€˜start_timeâ€™ property, of heartbeat node. Please notice, that actual Croquet timestamp is not calculated here, as it was in Reflector server. The timestamp used for the Croquet internal queue of messages will be calculated on reading of â€˜tickâ€™ by the VWF client in itâ€™s main application. \n\nHere is the simplified core version of dispatching â€˜tickâ€™ on VWF client main app, just to get the idea: (full code on **public/vwf.js**, links below)\n\n```\nlet instance = _LCSDB.get(vwf.namespace_);\n\ninstance.get('heartbeat').on(function (res) { \n   if(res.tick) {\n  let msg = self.stamp(res, start_time, rate);\n\n  queue.insert(fields, !fields.action);\n\n  }\n}\n\nthis.stamp = function(source, start_time, rate) {\n\n            let message = JSON.parse(source.tick);\n\n            message.state = Gun.state.is(source, 'tick');\n            message.start_time = start_time; //Gun.state.is(source, 'start_time');\n            message.rate = rate; //source.rate;\n\n            var time = ((message.state - message.start_time)*message.rate)/1000;\n\n            if (message.action == 'setState'){\n                time = ((_app.reflector.setStateTime - message.start_time)*message.rate)/1000;\n            }\n            message.time = Number( time );\n            message.origin = â€œreflector\";\n\n            return message\n        }\n\n```\n\nThe main point here is the calculation of Croquet time using Gunâ€™s HAM state:\n```\nGun.state.is ( node, property )\n```\n\nfor message:\n```\nmessage.state = Gun.state.is(source, â€˜tickâ€™); // time of updating tick\nmessage.start_time = Gun.state.is(source, â€˜start_time'); //start time of the instance heartbeat\nmessage.rate = source.rate;\nvar time = ((message.state - message.start_time)*message.rate)/1000;\n```\n\nSo, all peers will calculate exactly the same Croquet time on getting an update from Gun DB,  regardless of the time when they get this update (network delays, etc). \n\nAs you could imagine, sending external messages will be as simple as just writing the message by a peer to an instance heartbeat with a new messageâ€™s content. All connected peers and a peer itself will get that message, stamped with Croquet time, while they are subscribed on changes on heartbeat node (look above at **instance.get(â€˜heartbeatâ€™).on()** definition )\n```\ninstance.get('heartbeat').get('tick').put(JSON.stringify(newMsg));\n```\n\nActually thatâ€™s it!\n\n### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing metronome empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deplyed anywhere, anytime available on AXE blockchain.\n\n### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "after": "3b43549a033e3a17",
      "date": 1655293278420
    },
    {
      "type": "edit",
      "id": "904d819b95ccd02e",
      "item": {
        "type": "html",
        "id": "904d819b95ccd02e",
        "text": "<img \n  width=\"100%\"\n  src=\"https://github.com/RalfBarkow/luminary/raw/master/assets/luminary.jpg\"\n>"
      },
      "date": 1655293297750
    },
    {
      "id": "904d819b95ccd02e",
      "type": "move",
      "order": [
        "5795e9078e1a176e",
        "2b4f2a80b92f1677",
        "6398138dea70bd9d",
        "33cfc513b8da316f",
        "980f55ed48518800",
        "3699bfc17cdbe53c",
        "2a767ebe0e974649",
        "d3c5d9c8882e321f",
        "3b43549a033e3a17",
        "904d819b95ccd02e",
        "6873a40373efa5b7"
      ],
      "date": 1655293331342
    },
    {
      "type": "edit",
      "id": "6873a40373efa5b7",
      "item": {
        "type": "markdown",
        "id": "6873a40373efa5b7",
        "text": "First of all clients are never forced using WebSockets directly from the application itself for sending or receiving messages. Instead Gun DB responds for that functionality internally. All operations which previously relay on WebSocket connection are replaced by subscribing to updates and changes on a Gun DB nodes and properties.\nSo, instances, clients - are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\nClient, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a metronome (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜tickâ€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\nThe start time will be the state value of HAM at â€˜start_timeâ€™ property, of heartbeat node. Please notice, that actual Croquet timestamp is not calculated here, as it was in Reflector server. The timestamp used for the Croquet internal queue of messages will be calculated on reading of â€˜tickâ€™ by the VWF client in itâ€™s main application. \n\nHere is the simplified core version of dispatching â€˜tickâ€™ on VWF client main app, just to get the idea: (full code on **public/vwf.js**, links below)\n\n```\nlet instance = _LCSDB.get(vwf.namespace_);\n\ninstance.get('heartbeat').on(function (res) { \n   if(res.tick) {\n  let msg = self.stamp(res, start_time, rate);\n\n  queue.insert(fields, !fields.action);\n\n  }\n}\n\nthis.stamp = function(source, start_time, rate) {\n\n            let message = JSON.parse(source.tick);\n\n            message.state = Gun.state.is(source, 'tick');\n            message.start_time = start_time; //Gun.state.is(source, 'start_time');\n            message.rate = rate; //source.rate;\n\n            var time = ((message.state - message.start_time)*message.rate)/1000;\n\n            if (message.action == 'setState'){\n                time = ((_app.reflector.setStateTime - message.start_time)*message.rate)/1000;\n            }\n            message.time = Number( time );\n            message.origin = â€œreflector\";\n\n            return message\n        }\n\n```\n\nThe main point here is the calculation of Croquet time using Gunâ€™s HAM state:\n```\nGun.state.is ( node, property )\n```\n\nfor message:\n```\nmessage.state = Gun.state.is(source, â€˜tickâ€™); // time of updating tick\nmessage.start_time = Gun.state.is(source, â€˜start_time'); //start time of the instance heartbeat\nmessage.rate = source.rate;\nvar time = ((message.state - message.start_time)*message.rate)/1000;\n```\n\nSo, all peers will calculate exactly the same Croquet time on getting an update from Gun DB,  regardless of the time when they get this update (network delays, etc). \n\nAs you could imagine, sending external messages will be as simple as just writing the message by a peer to an instance heartbeat with a new messageâ€™s content. All connected peers and a peer itself will get that message, stamped with Croquet time, while they are subscribed on changes on heartbeat node (look above at **instance.get(â€˜heartbeatâ€™).on()** definition )\n```\ninstance.get('heartbeat').get('tick').put(JSON.stringify(newMsg));\n```\n\nActually thatâ€™s it!\n\n### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing metronome empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deplyed anywhere, anytime available on AXE blockchain.\n\n### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "date": 1655293338103
    },
    {
      "type": "edit",
      "id": "6873a40373efa5b7",
      "item": {
        "type": "markdown",
        "id": "6873a40373efa5b7",
        "text": "First of all clients are never forced using WebSockets directly from the application itself for sending or receiving messages. Instead Gun DB responds for that functionality internally. All operations which previously relay on WebSocket connection are replaced by subscribing to updates and changes on a Gun DB nodes and properties.\nSo, instances, clients â€“ are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\nClient, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a metronome (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜tickâ€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\nThe start time will be the state value of HAM at â€˜start_timeâ€™ property, of heartbeat node. Please notice, that actual Croquet timestamp is not calculated here, as it was in Reflector server. The timestamp used for the Croquet internal queue of messages will be calculated on reading of â€˜tickâ€™ by the VWF client in itâ€™s main application. \n\nHere is the simplified core version of dispatching â€˜tickâ€™ on VWF client main app, just to get the idea: (full code on **public/vwf.js**, links below)\n\n```\nlet instance = _LCSDB.get(vwf.namespace_);\n\ninstance.get('heartbeat').on(function (res) { \n   if(res.tick) {\n  let msg = self.stamp(res, start_time, rate);\n\n  queue.insert(fields, !fields.action);\n\n  }\n}\n\nthis.stamp = function(source, start_time, rate) {\n\n            let message = JSON.parse(source.tick);\n\n            message.state = Gun.state.is(source, 'tick');\n            message.start_time = start_time; //Gun.state.is(source, 'start_time');\n            message.rate = rate; //source.rate;\n\n            var time = ((message.state - message.start_time)*message.rate)/1000;\n\n            if (message.action == 'setState'){\n                time = ((_app.reflector.setStateTime - message.start_time)*message.rate)/1000;\n            }\n            message.time = Number( time );\n            message.origin = â€œreflector\";\n\n            return message\n        }\n\n```\n\nThe main point here is the calculation of Croquet time using Gunâ€™s HAM state:\n```\nGun.state.is ( node, property )\n```\n\nfor message:\n```\nmessage.state = Gun.state.is(source, â€˜tickâ€™); // time of updating tick\nmessage.start_time = Gun.state.is(source, â€˜start_time'); //start time of the instance heartbeat\nmessage.rate = source.rate;\nvar time = ((message.state - message.start_time)*message.rate)/1000;\n```\n\nSo, all peers will calculate exactly the same Croquet time on getting an update from Gun DB,  regardless of the time when they get this update (network delays, etc). \n\nAs you could imagine, sending external messages will be as simple as just writing the message by a peer to an instance heartbeat with a new messageâ€™s content. All connected peers and a peer itself will get that message, stamped with Croquet time, while they are subscribed on changes on heartbeat node (look above at **instance.get(â€˜heartbeatâ€™).on()** definition )\n```\ninstance.get('heartbeat').get('tick').put(JSON.stringify(newMsg));\n```\n\nActually thatâ€™s it!\n\n### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing metronome empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deplyed anywhere, anytime available on AXE blockchain.\n\n### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "date": 1655293371937
    },
    {
      "type": "edit",
      "id": "6873a40373efa5b7",
      "item": {
        "type": "markdown",
        "id": "6873a40373efa5b7",
        "text": "First of all clients are never forced using WebSockets directly from the application itself for sending or receiving messages. Instead Gun DB responds for that functionality internally. All operations which previously relay on WebSocket connection are replaced by subscribing to updates and changes on a Gun DB nodes and properties.\nSo, instances, clients â€“ are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\nClient, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a metronome (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜[[tick]]â€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\n"
      },
      "date": 1655293617569
    },
    {
      "type": "add",
      "id": "7ddbe985087f73ba",
      "item": {
        "type": "markdown",
        "id": "7ddbe985087f73ba",
        "text": "The start time will be the state value of HAM at â€˜start_timeâ€™ property, of heartbeat node. Please notice, that actual Croquet timestamp is not calculated here, as it was in Reflector server. The timestamp used for the Croquet internal queue of messages will be calculated on reading of â€˜tickâ€™ by the VWF client in itâ€™s main application. \n\nHere is the simplified core version of dispatching â€˜tickâ€™ on VWF client main app, just to get the idea: (full code on **public/vwf.js**, links below)\n\n```\nlet instance = _LCSDB.get(vwf.namespace_);\n\ninstance.get('heartbeat').on(function (res) { \n   if(res.tick) {\n  let msg = self.stamp(res, start_time, rate);\n\n  queue.insert(fields, !fields.action);\n\n  }\n}\n\nthis.stamp = function(source, start_time, rate) {\n\n            let message = JSON.parse(source.tick);\n\n            message.state = Gun.state.is(source, 'tick');\n            message.start_time = start_time; //Gun.state.is(source, 'start_time');\n            message.rate = rate; //source.rate;\n\n            var time = ((message.state - message.start_time)*message.rate)/1000;\n\n            if (message.action == 'setState'){\n                time = ((_app.reflector.setStateTime - message.start_time)*message.rate)/1000;\n            }\n            message.time = Number( time );\n            message.origin = â€œreflector\";\n\n            return message\n        }\n\n```\n\nThe main point here is the calculation of Croquet time using Gunâ€™s HAM state:\n```\nGun.state.is ( node, property )\n```\n\nfor message:\n```\nmessage.state = Gun.state.is(source, â€˜tickâ€™); // time of updating tick\nmessage.start_time = Gun.state.is(source, â€˜start_time'); //start time of the instance heartbeat\nmessage.rate = source.rate;\nvar time = ((message.state - message.start_time)*message.rate)/1000;\n```\n\nSo, all peers will calculate exactly the same Croquet time on getting an update from Gun DB,  regardless of the time when they get this update (network delays, etc). \n\nAs you could imagine, sending external messages will be as simple as just writing the message by a peer to an instance heartbeat with a new messageâ€™s content. All connected peers and a peer itself will get that message, stamped with Croquet time, while they are subscribed on changes on heartbeat node (look above at **instance.get(â€˜heartbeatâ€™).on()** definition )\n```\ninstance.get('heartbeat').get('tick').put(JSON.stringify(newMsg));\n```\n\nActually thatâ€™s it!\n\n### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing metronome empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deplyed anywhere, anytime available on AXE blockchain.\n\n### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "after": "6873a40373efa5b7",
      "date": 1655293618050
    },
    {
      "type": "edit",
      "id": "7ddbe985087f73ba",
      "item": {
        "type": "markdown",
        "id": "7ddbe985087f73ba",
        "text": "The start time will be the state value of HAM at â€˜start_timeâ€™ property, of heartbeat node. Please notice, that actual Croquet timestamp is not calculated here, as it was in Reflector server. The timestamp used for the Croquet internal queue of messages will be calculated on reading of â€˜tickâ€™ by the VWF client in itâ€™s main application. \n\nHere is the simplified core version of dispatching â€˜tickâ€™ on VWF client main app, just to get the idea: (full code on **public/vwf.js**, links below)\n\n```\nlet instance = _LCSDB.get(vwf.namespace_);\n\ninstance.get('heartbeat').on(function (res) { \n   if(res.tick) {\n  let msg = self.stamp(res, start_time, rate);\n\n  queue.insert(fields, !fields.action);\n\n  }\n}\n\nthis.stamp = function(source, start_time, rate) {\n\n            let message = JSON.parse(source.tick);\n\n            message.state = Gun.state.is(source, 'tick');\n            message.start_time = start_time; //Gun.state.is(source, 'start_time');\n            message.rate = rate; //source.rate;\n\n            var time = ((message.state - message.start_time)*message.rate)/1000;\n\n            if (message.action == 'setState'){\n                time = ((_app.reflector.setStateTime - message.start_time)*message.rate)/1000;\n            }\n            message.time = Number( time );\n            message.origin = â€œreflector\";\n\n            return message\n        }\n\n```\n\nThe main point here is the calculation of Croquet time using Gunâ€™s HAM state:\n```\nGun.state.is ( node, property )\n```\n\nfor message:\n```\nmessage.state = Gun.state.is(source, â€˜tickâ€™); // time of updating tick\nmessage.start_time = Gun.state.is(source, â€˜start_time'); //start time of the instance heartbeat\nmessage.rate = source.rate;\nvar time = ((message.state - message.start_time)*message.rate)/1000;\n```\n\nSo, all peers will calculate exactly the same Croquet time on getting an update from Gun DB,  regardless of the time when they get this update (network delays, etc). \n\nAs you could imagine, sending external messages will be as simple as just writing the message by a peer to an instance heartbeat with a new messageâ€™s content. All connected peers and a peer itself will get that message, stamped with Croquet time, while they are subscribed on changes on heartbeat node (look above at **instance.get(â€˜heartbeatâ€™).on()** definition )\n```\ninstance.get('heartbeat').get('tick').put(JSON.stringify(newMsg));\n```\n\nActually thatâ€™s it!\n\n\n"
      },
      "date": 1655293728740
    },
    {
      "type": "add",
      "id": "5814f736f0973188",
      "item": {
        "type": "markdown",
        "id": "5814f736f0973188",
        "text": "### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing metronome empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deplyed anywhere, anytime available on AXE blockchain.\n\n### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "after": "7ddbe985087f73ba",
      "date": 1655293734178
    },
    {
      "type": "edit",
      "id": "6873a40373efa5b7",
      "item": {
        "type": "markdown",
        "id": "6873a40373efa5b7",
        "text": "First of all clients are never forced using WebSockets directly from the application itself for sending or receiving messages. Instead Gun DB responds for that functionality internally. All operations which previously relay on WebSocket connection are replaced by subscribing to updates and changes on a Gun DB nodes and properties.\n"
      },
      "date": 1655293848534
    },
    {
      "type": "add",
      "id": "27de0c4121dbe74c",
      "item": {
        "type": "markdown",
        "id": "27de0c4121dbe74c",
        "text": "So, instances, clients â€“ are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\nClient, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a metronome (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜[[tick]]â€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\n"
      },
      "after": "6873a40373efa5b7",
      "date": 1655293850035
    },
    {
      "type": "edit",
      "id": "27de0c4121dbe74c",
      "item": {
        "type": "markdown",
        "id": "27de0c4121dbe74c",
        "text": "So, instances, clients â€“ are just Gun DB nodes, available to all connected peers. In that scene, the required Reflectorâ€™s application logic is moving from the server to the clients. As, every client on any moment of time could get actual information about instance he is connected to, clients on that instance, etc. Just requesting a node on Gun DB.\n\nNow, about time.\n\nInstead of using machineâ€™s new Date().getTime(), Krestianstvo Luminary uses state from Gunâ€™s [Hypothetical Amnesia Machine](https://gun.eco/docs/Hypothetical-Amnesia-Machine), which combines timestamps, vector clocks, and a conflict resolution algorithm. So, every written property on a Gunâ€™s node stamped with HAM. This state is identical for all peers. Thatâ€™s meaning that we could get this state just on any client.\nTaking in consideration that Gun DB guaranteers that, every change on every node or property will be delivered in right order to all peers. We could make a heartbeat node and subscribe peers to it updates.\n\nHere is the code for creating a heartbeat for VWF:\n\n```\nGun.chain.heartbeat = function (time, rate) {\n              // our gun instance\n              var gun = this;\n              gun.put({\n                  'start_time': 'start_time',\n                  'rate': 1\n              }).once(function (res) {\n                  // function to start the timer\n                  setInterval(function () {\n                      let message = {\n                          parameters: [],\n                          time: 'tick'\n                      };\n                      gun.get('tick').put(JSON.stringify(message));\n                  }, 50);\n              })\n  \n              // return gun so we can chain other methods off of it\n              return gun;\n          }\n\n```\n\n\n"
      },
      "date": 1655293863187
    },
    {
      "type": "add",
      "id": "7993df889363cabb",
      "item": {
        "type": "markdown",
        "id": "7993df889363cabb",
        "text": "Client, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a metronome (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n"
      },
      "after": "27de0c4121dbe74c",
      "date": 1655293869053
    },
    {
      "type": "add",
      "id": "9821d36f7a9c0630",
      "item": {
        "type": "markdown",
        "id": "9821d36f7a9c0630",
        "text": "\n```\nlet instance = _LCSDB.get(vwf.namespace_); //\ninstance.get('heartbeat').put({ tick: \"{}\" }).heartbeat(0.0, 1);\n```\n\nSo, every 50 ms, this client will writes to property â€˜[[tick]]â€™ the message content, thus changing it, so Gun HAM will move the state for this property, stamping it with the new unique value, from which the Croquet time will be calculated later.\n"
      },
      "after": "7993df889363cabb",
      "date": 1655293870925
    },
    {
      "type": "edit",
      "id": "7993df889363cabb",
      "item": {
        "type": "markdown",
        "id": "7993df889363cabb",
        "text": "Client, which start firstly or create a new virtual world instance, create heartbeat node for that instance and run a [[Metronome]] (that part could be run on Gun DB instance somewhere on the hosting server, for anytime availability):\n"
      },
      "date": 1655293880900
    },
    {
      "type": "edit",
      "id": "5814f736f0973188",
      "item": {
        "type": "markdown",
        "id": "5814f736f0973188",
        "text": "### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing [[Metronome]] empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deplyed anywhere, anytime available on AXE blockchain.\n\n### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "date": 1655293997207
    },
    {
      "type": "edit",
      "id": "5814f736f0973188",
      "item": {
        "type": "markdown",
        "id": "5814f736f0973188",
        "text": "### Conclusions\n\n* Reflector server is no longer required for running virtual worlds (any existed GunDB instance on a network fits, could know nothing about Croquet and clients)\n* clients, world instances, connecting logic are hold by a distributed DB\n* stamping messages are doing by clients themselves using Gunâ€™s HAM\n* one dedicated peer, producing [[Metronome]] empty messages for moving time forward (could be anywhere)\n\nAll advantages that Gun DB provides, could be applicable inside a Croquet Architecture. One of scenarios could be the use of [Gunâ€™s Timegraph](https://gun.eco/docs/Timegraph ). Thatâ€™s will allow to store and retrieve the history of messages for recording and replaying later. Using SEA Security, Encryption, & Authorization library, will allow to create a highly secure instanceâ€™s heartbeats using peer-to-peer identifies and being deployed anywhere, anytime available on AXE blockchain.\n\n\n"
      },
      "date": 1655294056439
    },
    {
      "type": "add",
      "id": "0777ec77addf27e1",
      "item": {
        "type": "markdown",
        "id": "0777ec77addf27e1",
        "text": "### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "after": "5814f736f0973188",
      "date": 1655294057461
    },
    {
      "type": "edit",
      "id": "0777ec77addf27e1",
      "item": {
        "type": "markdown",
        "id": "0777ec77addf27e1",
        "text": "### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \nThere are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n\n"
      },
      "date": 1655294090851
    },
    {
      "type": "add",
      "id": "5a84b907341d5a0f",
      "item": {
        "type": "markdown",
        "id": "5a84b907341d5a0f",
        "text": "### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\nNikolai Suslov"
      },
      "after": "0777ec77addf27e1",
      "date": 1655294092721
    },
    {
      "type": "edit",
      "id": "0777ec77addf27e1",
      "item": {
        "type": "markdown",
        "id": "0777ec77addf27e1",
        "text": "### Issues\n\nFor making a fully functional prototype, there are still an issues in porting Reflector application logic to a functional-reactive Gun DB architecture nature. That concerns to the procedure of connecting clients to a running instance. As it is connected with getting/setting instance state, pending messages and then replaying them on a new connected peers. But, all that is not critical, as does not affect the main idea behind Krestianstvo Luminary. \n"
      },
      "date": 1655294097125
    },
    {
      "type": "add",
      "id": "2728ea493e519d09",
      "item": {
        "type": "markdown",
        "id": "2728ea493e519d09",
        "text": "There are performance issues, as Gun DB is using [RAD storage adapter](https://gun.eco/docs/RAD). But configuring several RAD options could be helpful, concerning **opt.chunk** and **opt.until** (due to RAD or JSON parse time for each chunk).\n\n\n"
      },
      "after": "0777ec77addf27e1",
      "date": 1655294098666
    },
    {
      "type": "edit",
      "id": "5a84b907341d5a0f",
      "item": {
        "type": "markdown",
        "id": "5a84b907341d5a0f",
        "text": "### Source code\n\nThe source code for Luminary is available at [LiveCoding.space GitHub repository](https://github.com/NikolaySuslov/livecodingspace) under the [**master** branch](https://github.com/NikolaySuslov/livecodingspace/tree/master).\n\nThe [branch **â€˜luminary-partialâ€™**](https://github.com/NikolaySuslov/livecodingspace/tree/luminary-partial) contains working prototype of partial Luminary, when one master-client is chosen for reflector logic, it uses **Gun.state()** for stamping messages, as it was done in the original reflector app, and then distribute as updates to other peers through Gun DB.  \n\n\nThanks for reading and I will be gladfull if you will share your comments and visions on that.\n\n[[Nikolai Suslov]]"
      },
      "date": 1655294129184
    },
    {
      "type": "remove",
      "id": "2b4f2a80b92f1677",
      "date": 1655294175638
    },
    {
      "type": "edit",
      "id": "6398138dea70bd9d",
      "item": {
        "type": "markdown",
        "id": "6398138dea70bd9d",
        "text": "# Krestianstvo Luminary [https://github.com/NikolaySuslov/luminary github]\n\nThe source code of the current **Luminary** implementation mainly at [LiveCoding.space](https://livecoding.space) project repository:   \n\n- **Krestianstvo Luminary** functional prototype is avaliable to try out at https://livecoding.space  \n\n- **Source code** at [LiveCoding.space GitHub repository **master** branch](https://github.com/NikolaySuslov/livecodingspace)  \n\n- **Research paper** about Krestianstvo Luminary architecture here: [download / read](/paper/Luminary.pdf)"
      },
      "date": 1655294303797
    },
    {
      "type": "edit",
      "id": "6398138dea70bd9d",
      "item": {
        "type": "markdown",
        "id": "6398138dea70bd9d",
        "text": "# Krestianstvo Luminary \n\nThe source code [https://github.com/NikolaySuslov/luminary github] of the current **Luminary** implementation mainly at [LiveCoding.space](https://livecoding.space) project repository:   \n\n- **Krestianstvo Luminary** functional prototype is avaliable to try out at https://livecoding.space  \n\n- **Source code** at [LiveCoding.space GitHub repository **master** branch](https://github.com/NikolaySuslov/livecodingspace)  \n\n- **Research paper** about Krestianstvo Luminary architecture here: [download / read](/paper/Luminary.pdf)"
      },
      "date": 1655294329474
    },
    {
      "type": "edit",
      "id": "6398138dea70bd9d",
      "item": {
        "type": "markdown",
        "id": "6398138dea70bd9d",
        "text": "# Krestianstvo Luminary \n\nThe source code [https://github.com/NikolaySuslov/luminary github] of the current **Luminary** implementation mainly at [LiveCoding.space](https://livecoding.space) project repository:   \n\n- **Krestianstvo Luminary** functional prototype is avaliable to try out at https://livecoding.space  \n\n- **Source code** at [LiveCoding.space GitHub repository **master** branch](https://github.com/NikolaySuslov/livecodingspace)  \n\n- **Research paper** about Krestianstvo Luminary architecture here: [https://github.com/NikolaySuslov/luminary/blob/master/paper/Luminary.pdf pdf]"
      },
      "date": 1655294656072
    },
    {
      "type": "edit",
      "id": "6398138dea70bd9d",
      "item": {
        "type": "markdown",
        "id": "6398138dea70bd9d",
        "text": "# Krestianstvo Luminary \n\nThe source code [https://github.com/NikolaySuslov/luminary github] of the current **Luminary** implementation mainly at [LiveCoding.space](https://livecoding.space) project repository:   \n\n- **Krestianstvo Luminary** functional prototype is avaliable to try out at https://livecoding.space  \n\n- **Source code** at [LiveCoding.space GitHub repository **master** branch](https://github.com/NikolaySuslov/livecodingspace)  \n\n- **Research paper** about Krestianstvo Luminary architecture here: [https://raw.githubusercontent.com/NikolaySuslov/luminary/master/paper/Luminary.pdf pdf]"
      },
      "date": 1655294692561
    },
    {
      "type": "add",
      "id": "7885cba3df1e466e",
      "item": {
        "type": "paragraph",
        "id": "7885cba3df1e466e",
        "text": "croqueteer â€” heute um 15:43 Uhr\nKrestianstvo Luminary is built in the original Smalltalk version of Croquet that I designed much of. That was a critical system in informing our thinking about the next few iterations including the DoD Virtual World Framework that I also designed. The current Croquet addresses many shortcomings in the earlier systems including the introduction of model/view, a beautiful publish/subscribe communication model, live collaborative programming among many other things."
      },
      "after": "5795e9078e1a176e",
      "date": 1655301538331
    },
    {
      "type": "edit",
      "id": "7885cba3df1e466e",
      "item": {
        "type": "paragraph",
        "id": "7885cba3df1e466e",
        "text": "croqueteer â€” [https://discord.com/channels/694586717247635488/984210689503662140/986627069268099137 discord]\nKrestianstvo Luminary is built in the original Smalltalk version of Croquet that I designed much of. That was a critical system in informing our thinking about the next few iterations including the DoD Virtual World Framework that I also designed. The current Croquet addresses many shortcomings in the earlier systems including the introduction of model/view, a beautiful publish/subscribe communication model, live collaborative programming among many other things."
      },
      "date": 1655301562053
    },
    {
      "type": "edit",
      "id": "7885cba3df1e466e",
      "item": {
        "type": "paragraph",
        "id": "7885cba3df1e466e",
        "text": "croqueteer â€” [https://discord.com/channels/694586717247635488/984210689503662140/986627069268099137 discord]\nKrestianstvo Luminary is built in the original Smalltalk version of Croquet that I designed much of. That was a critical system in informing our thinking about the next few iterations including the DoD [[Virtual World Framework]] that I also designed. The current Croquet addresses many shortcomings in the earlier systems including the introduction of model/view, a beautiful publish/subscribe communication model, live collaborative programming among many other things."
      },
      "date": 1655301589217
    },
    {
      "type": "add",
      "id": "1981692c5c0d44f2",
      "item": {
        "type": "paragraph",
        "id": "1981692c5c0d44f2",
        "text": "codefrau ðŸ¦© â€” gestern um 17:52 Uhr\nLuminary is actually Javascript, built on VWF, but supports live coding (even in non-JS languages via Ohm), uses A-Frame for 3D and replaced reflectors with Gun DB. It's a pretty cool system but I'm not really familiar with it, you would have to ask Nikolay himself.\nRe reflectors, we have deployed reflectors world-wide, here in Los Angeles I get < 10ms latency, but if I even just ping Luminary's default reflector that's 200ms because it's somewhere in Europe and does not have a whole fleet nor does it do the automatic routing to the nearest reflector as we do (AFAIK). Besides that I'd argue our architecture is much less baroque than VWF (which is not Nikolay's fault, that was in the original project he forked). \n"
      },
      "after": "7885cba3df1e466e",
      "date": 1655331310015
    },
    {
      "type": "edit",
      "id": "1981692c5c0d44f2",
      "item": {
        "type": "paragraph",
        "id": "1981692c5c0d44f2",
        "text": "codefrau ðŸ¦© â€” [https://discord.com/channels/694586717247635488/984210689503662140/986659381410164757 discord]\nLuminary is actually Javascript, built on VWF, but supports live coding (even in non-JS languages via Ohm), uses A-Frame for 3D and replaced reflectors with Gun DB. It's a pretty cool system but I'm not really familiar with it, you would have to ask Nikolay himself.\nRe reflectors, we have deployed reflectors world-wide, here in Los Angeles I get < 10ms latency, but if I even just ping Luminary's default reflector that's 200ms because it's somewhere in Europe and does not have a whole fleet nor does it do the automatic routing to the nearest reflector as we do (AFAIK). Besides that I'd argue our architecture is much less baroque than VWF (which is not Nikolay's fault, that was in the original project he forked). \n"
      },
      "date": 1655331327275
    },
    {
      "type": "edit",
      "id": "1981692c5c0d44f2",
      "item": {
        "type": "paragraph",
        "id": "1981692c5c0d44f2",
        "text": "codefrau ðŸ¦© â€” [https://discord.com/channels/694586717247635488/984210689503662140/986659381410164757 discord]\nLuminary is actually Javascript, built on VWF, but supports live coding (even in non-JS languages via Ohm), uses A-Frame for 3D and replaced reflectors with [[Gun DB]]. It's a pretty cool system but I'm not really familiar with it, you would have to ask Nikolay himself.\nRe reflectors, we have deployed reflectors world-wide, here in Los Angeles I get < 10ms latency, but if I even just ping Luminary's default reflector that's 200ms because it's somewhere in Europe and does not have a whole fleet nor does it do the automatic routing to the nearest reflector as we do (AFAIK). Besides that I'd argue our architecture is much less baroque than VWF (which is not Nikolay's fault, that was in the original project he forked). \n"
      },
      "date": 1655331352864
    },
    {
      "type": "edit",
      "id": "1981692c5c0d44f2",
      "item": {
        "type": "paragraph",
        "id": "1981692c5c0d44f2",
        "text": "codefrau ðŸ¦© â€” [https://discord.com/channels/694586717247635488/984210689503662140/986659381410164757 discord]\nLuminary is actually Javascript, built on [[VWF]], but supports live coding (even in non-JS languages via Ohm), uses A-Frame for 3D and replaced reflectors with [[Gun DB]]. It's a pretty cool system but I'm not really familiar with it, you would have to ask Nikolay himself.\nRe reflectors, we have deployed reflectors world-wide, here in Los Angeles I get < 10ms latency, but if I even just ping Luminary's default reflector that's 200ms because it's somewhere in Europe and does not have a whole fleet nor does it do the automatic routing to the nearest reflector as we do (AFAIK). Besides that I'd argue our architecture is much less baroque than VWF (which is not Nikolay's fault, that was in the original project he forked). \n"
      },
      "date": 1655331408823
    },
    {
      "type": "add",
      "id": "4433dc8d8953c3b5",
      "item": {
        "type": "paragraph",
        "id": "4433dc8d8953c3b5",
        "text": "avinash â€” heute um 05:50 Uhr\nreplacing reflectors with gundb and democratizing the servers and gundb's plan to incentivize using AXE crypto seem to be the newer concepts Luminary adopted from an economics standpoint.\nhowever the usage of an older codebase and being a single person effort are detractions.\nalso the removal of reflectors in the newer versions and letting the users play out in a p2p fashion seemed an interesting idea. \ni have seen an example using webrtc in livecoding.space, which using webrtc transfers the audio and video from the webcam into the 3d space, would like to know if croquet has something similar as that is something that would be useful for what i'm trying to prototype. \n"
      },
      "after": "1981692c5c0d44f2",
      "date": 1655352948202
    },
    {
      "type": "edit",
      "id": "4433dc8d8953c3b5",
      "item": {
        "type": "paragraph",
        "id": "4433dc8d8953c3b5",
        "text": "avinash â€” [https://discord.com/channels/694586717247635488/984210689503662140/986840187764080650 discord]\nreplacing reflectors with gundb and democratizing the servers and gundb's plan to incentivize using AXE crypto seem to be the newer concepts Luminary adopted from an economics standpoint.\nhowever the usage of an older codebase and being a single person effort are detractions.\nalso the removal of reflectors in the newer versions and letting the users play out in a p2p fashion seemed an interesting idea. \ni have seen an example using webrtc in livecoding.space, which using webrtc transfers the audio and video from the webcam into the 3d space, would like to know if croquet has something similar as that is something that would be useful for what i'm trying to prototype. \n"
      },
      "date": 1655352969766
    },
    {
      "type": "edit",
      "id": "4433dc8d8953c3b5",
      "item": {
        "type": "paragraph",
        "id": "4433dc8d8953c3b5",
        "text": "avinash â€” [https://discord.com/channels/694586717247635488/984210689503662140/986840187764080650 discord]\nreplacing reflectors with gundb and democratizing the servers and gundb's plan to incentivize using AXE crypto seem to be the newer concepts Luminary adopted from an economics standpoint.\nhowever the usage of an older codebase and being a single person effort are detractions.\nalso the removal of reflectors in the newer versions and letting the users play out in a p2p fashion seemed an interesting idea. \ni have seen an example using webrtc in livecoding.space, which using webrtc transfers the audio and video from the webcam into the 3d space, would like to know if croquet has something similar as that is something that would be useful for what i'm trying to prototype. "
      },
      "date": 1655353134486
    },
    {
      "type": "add",
      "id": "876edcfaf3ab43fd",
      "item": {
        "type": "paragraph",
        "id": "876edcfaf3ab43fd",
        "text": "ccrraaiigg â€” 2022-05-15\nHi, I'm Craig Latta, a longtime livecoder with Smalltalk and now JavaScript. I'm working on some integrations with Croquet and Caffeine, a web IDE I've made with SqueakJS. Current areas are WebRTC and remote music collaboration. Onward!"
      },
      "after": "4433dc8d8953c3b5",
      "date": 1655353179413
    },
    {
      "type": "edit",
      "id": "876edcfaf3ab43fd",
      "item": {
        "type": "paragraph",
        "id": "876edcfaf3ab43fd",
        "text": "ccrraaiigg â€” 2022-05-15\nHi, I'm [[Craig Latta]], a longtime livecoder with Smalltalk and now JavaScript. I'm working on some integrations with Croquet and Caffeine, a web IDE I've made with SqueakJS. Current areas are WebRTC and remote music collaboration. Onward!"
      },
      "date": 1655353432937
    }
  ]
}