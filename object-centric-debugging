{
  "title": "Object-Centric Debugging",
  "story": [
    {
      "type": "paragraph",
      "id": "bdeacd35ee68191f",
      "text": "[[Object-centric debugging]] is a young technique arguing that focusing the scope of debugging on specific objects considerably eases the tracking and the understanding of hard bugs in Object-Oriented Programs (OOP). But it lacks fundamental bricks to be applicable in practice. Therefore, it has never been empirically evaluated. The objectives of the OCRE project are to study the fundamental and practical limits that hinder the implementation, the evaluation, and the adoption of object-centric debugging."
    },
    {
      "type": "pagefold",
      "id": "a8e4b2cde5c35182",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "e36dc3c7c681611e",
      "text": "Internship, Identifying and acquiring objects to debug object-oriented programs. RMoD team, 2022.\nInria Lille - Nord Europe, France. [https://rmod-files.lille.inria.fr/Jobs/2022-INTERNSHIP-identifying-objects.pdf pdf]"
    },
    {
      "type": "paragraph",
      "id": "4119a5accd74d6e6",
      "text": "RESSIA, Jorge, BERGEL, Alexandre and NIERSTRASZ, Oscar, 2012. Object-centric debugging. In: 2012 34th International Conference on Software Engineering (ICSE). June 2012. p. 485–495. DOI 10.1109/ICSE.2012.6227167. "
    },
    {
      "type": "markdown",
      "id": "850c8c238f03024c",
      "text": "> During the process of developing and maintaining a complex software system, developers pose detailed questions about the runtime behavior of the system. Source code views offer strictly limited insights, so developers often turn to tools like debuggers to inspect and interact with the running system. Unfortunately, traditional debuggers focus on the runtime stack as the key abstraction to support debugging operations, though the questions developers pose often have more to do with objects and their interactions. We propose object-centric debugging as an alternative approach to interacting with a running software system. We show how, by focusing on objects as the key abstraction, natural debugging operations can be defined to answer developer questions related to runtime behavior. We present a running prototype of an object-centric debugger, and demonstrate, with the help of a series of examples, how object-centric debugging offers more effective support for many typical developer tasks than a traditional stack-oriented debugger.\n"
    },
    {
      "type": "paragraph",
      "id": "dede6a9b09b005ed",
      "text": "\nHINKLE, Bob, JONES, Vicki and JOHNSON, Ralph E., 1993. Debugging Objects. In: The Smalltalk Report. IEEE Computer Society. 1993. p. 155–158. "
    },
    {
      "type": "markdown",
      "id": "1cf4530cc43ffa40",
      "text": "> This article will show how to solve this and similar problems by letting you modify code and add breakpoints that affect only one specific object, rather than all objects in a given class. Our solution relies on the use of a new kind of class and on some small but powerful variations on CompiledMethods and Compilers. Besides being useful in their own right, we feel these extensions again illustrate (as in our previous article, [1, 2]) how powerful the reflective features of Smalltalk are, as they allow the programmer to adapt and extend the environment to suit his or her needs. The solution described is specific to Smalltalk-80, since it relies on Smalltalk-80’s architecture for classes, metaclasses, the compiler, and compiled methods, and on the complete availability of source code for these system elements. As a result, our extensions may not apply to Smalltalk V environments, though something similar may be possible.\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Object-Centric Debugging",
        "story": []
      },
      "date": 1650790169268
    },
    {
      "item": {
        "type": "factory",
        "id": "e36dc3c7c681611e"
      },
      "id": "e36dc3c7c681611e",
      "type": "add",
      "date": 1650790174382
    },
    {
      "type": "edit",
      "id": "e36dc3c7c681611e",
      "item": {
        "type": "paragraph",
        "id": "e36dc3c7c681611e",
        "text": "[https://rmod-files.lille.inria.fr/Jobs/2022-INTERNSHIP-identifying-objects.pdf pdf]"
      },
      "date": 1650790184507
    },
    {
      "type": "edit",
      "id": "e36dc3c7c681611e",
      "item": {
        "type": "paragraph",
        "id": "e36dc3c7c681611e",
        "text": "Internship, Identifying and acquiring objects to debug object-oriented programs. RMoD team, 2022.\nInria Lille - Nord Europe, France[https://rmod-files.lille.inria.fr/Jobs/2022-INTERNSHIP-identifying-objects.pdf pdf]"
      },
      "date": 1650790209078
    },
    {
      "type": "edit",
      "id": "e36dc3c7c681611e",
      "item": {
        "type": "paragraph",
        "id": "e36dc3c7c681611e",
        "text": "Internship, Identifying and acquiring objects to debug object-oriented programs. RMoD team, 2022.\nInria Lille - Nord Europe, France. [https://rmod-files.lille.inria.fr/Jobs/2022-INTERNSHIP-identifying-objects.pdf pdf]"
      },
      "date": 1650790214897
    },
    {
      "item": {
        "type": "factory",
        "id": "bdeacd35ee68191f"
      },
      "id": "bdeacd35ee68191f",
      "type": "add",
      "after": "e36dc3c7c681611e",
      "date": 1650790226844
    },
    {
      "type": "edit",
      "id": "bdeacd35ee68191f",
      "item": {
        "type": "paragraph",
        "id": "bdeacd35ee68191f",
        "text": "Object-centric debugging is a young technique arguing that focusing the scope of debugging on specific objects considerably eases the tracking and the understanding of hard bugs in Object-Oriented Programs (OOP). But it lacks fundamental bricks to be applicable in practice. Therefore, it has never been empirically evaluated. The objectives of the OCRE project are to study the fundamental and practical limits that hinder the implementation, the evaluation, and the adoption of object-centric debugging."
      },
      "date": 1650790227864
    },
    {
      "id": "bdeacd35ee68191f",
      "type": "move",
      "order": [
        "bdeacd35ee68191f",
        "e36dc3c7c681611e"
      ],
      "date": 1650790248117
    },
    {
      "item": {
        "type": "factory",
        "id": "a8e4b2cde5c35182"
      },
      "id": "a8e4b2cde5c35182",
      "type": "add",
      "after": "e36dc3c7c681611e",
      "date": 1650790259851
    },
    {
      "type": "edit",
      "id": "a8e4b2cde5c35182",
      "item": {
        "type": "pagefold",
        "id": "a8e4b2cde5c35182",
        "text": "~"
      },
      "date": 1650790263570
    },
    {
      "id": "a8e4b2cde5c35182",
      "type": "move",
      "order": [
        "bdeacd35ee68191f",
        "a8e4b2cde5c35182",
        "e36dc3c7c681611e"
      ],
      "date": 1650790265693
    },
    {
      "type": "edit",
      "id": "bdeacd35ee68191f",
      "item": {
        "type": "paragraph",
        "id": "bdeacd35ee68191f",
        "text": "[[Object-centric debugging]] is a young technique arguing that focusing the scope of debugging on specific objects considerably eases the tracking and the understanding of hard bugs in Object-Oriented Programs (OOP). But it lacks fundamental bricks to be applicable in practice. Therefore, it has never been empirically evaluated. The objectives of the OCRE project are to study the fundamental and practical limits that hinder the implementation, the evaluation, and the adoption of object-centric debugging."
      },
      "date": 1650790278196
    },
    {
      "item": {
        "type": "factory",
        "id": "4119a5accd74d6e6"
      },
      "id": "4119a5accd74d6e6",
      "type": "add",
      "after": "e36dc3c7c681611e",
      "date": 1650790497814
    },
    {
      "type": "edit",
      "id": "4119a5accd74d6e6",
      "item": {
        "type": "paragraph",
        "id": "4119a5accd74d6e6",
        "text": "\nRESSIA, Jorge, BERGEL, Alexandre and NIERSTRASZ, Oscar, 2012. Object-centric debugging. In: 2012 34th International Conference on Software Engineering (ICSE). June 2012. p. 485–495. DOI 10.1109/ICSE.2012.6227167. During the process of developing and maintaining a complex software system, developers pose detailed questions about the runtime behavior of the system. Source code views offer strictly limited insights, so developers often turn to tools like debuggers to inspect and interact with the running system. Unfortunately, traditional debuggers focus on the runtime stack as the key abstraction to support debugging operations, though the questions developers pose often have more to do with objects and their interactions. We propose object-centric debugging as an alternative approach to interacting with a running software system. We show how, by focusing on objects as the key abstraction, natural debugging operations can be defined to answer developer questions related to runtime behavior. We present a running prototype of an object-centric debugger, and demonstrate, with the help of a series of examples, how object-centric debugging offers more effective support for many typical developer tasks than a traditional stack-oriented debugger.\n"
      },
      "date": 1650790500383
    },
    {
      "type": "edit",
      "id": "4119a5accd74d6e6",
      "item": {
        "type": "paragraph",
        "id": "4119a5accd74d6e6",
        "text": "RESSIA, Jorge, BERGEL, Alexandre and NIERSTRASZ, Oscar, 2012. Object-centric debugging. In: 2012 34th International Conference on Software Engineering (ICSE). June 2012. p. 485–495. DOI 10.1109/ICSE.2012.6227167. "
      },
      "date": 1650790507179
    },
    {
      "type": "add",
      "id": "850c8c238f03024c",
      "item": {
        "type": "paragraph",
        "id": "850c8c238f03024c",
        "text": "> During the process of developing and maintaining a complex software system, developers pose detailed questions about the runtime behavior of the system. Source code views offer strictly limited insights, so developers often turn to tools like debuggers to inspect and interact with the running system. Unfortunately, traditional debuggers focus on the runtime stack as the key abstraction to support debugging operations, though the questions developers pose often have more to do with objects and their interactions. We propose object-centric debugging as an alternative approach to interacting with a running software system. We show how, by focusing on objects as the key abstraction, natural debugging operations can be defined to answer developer questions related to runtime behavior. We present a running prototype of an object-centric debugger, and demonstrate, with the help of a series of examples, how object-centric debugging offers more effective support for many typical developer tasks than a traditional stack-oriented debugger.\n"
      },
      "after": "4119a5accd74d6e6",
      "date": 1650790508118
    },
    {
      "type": "edit",
      "id": "850c8c238f03024c",
      "item": {
        "type": "markdown",
        "id": "850c8c238f03024c",
        "text": "> During the process of developing and maintaining a complex software system, developers pose detailed questions about the runtime behavior of the system. Source code views offer strictly limited insights, so developers often turn to tools like debuggers to inspect and interact with the running system. Unfortunately, traditional debuggers focus on the runtime stack as the key abstraction to support debugging operations, though the questions developers pose often have more to do with objects and their interactions. We propose object-centric debugging as an alternative approach to interacting with a running software system. We show how, by focusing on objects as the key abstraction, natural debugging operations can be defined to answer developer questions related to runtime behavior. We present a running prototype of an object-centric debugger, and demonstrate, with the help of a series of examples, how object-centric debugging offers more effective support for many typical developer tasks than a traditional stack-oriented debugger.\n"
      },
      "date": 1650790509462
    },
    {
      "item": {
        "type": "factory",
        "id": "dede6a9b09b005ed"
      },
      "id": "dede6a9b09b005ed",
      "type": "add",
      "after": "850c8c238f03024c",
      "date": 1650790877188
    },
    {
      "type": "edit",
      "id": "dede6a9b09b005ed",
      "item": {
        "type": "paragraph",
        "id": "dede6a9b09b005ed",
        "text": "\nHINKLE, Bob, JONES, Vicki and JOHNSON, Ralph E., 1993. Debugging Objects. In: The Smalltalk Report. IEEE Computer Society. 1993. p. 155–158. "
      },
      "date": 1650790883196
    },
    {
      "type": "add",
      "id": "1cf4530cc43ffa40",
      "item": {
        "type": "paragraph",
        "id": "1cf4530cc43ffa40",
        "text": "> This article will show how to solve this and similar problems by letting you modify code and add breakpoints that affect only one specific object, rather than all objects in a given class. Our solution relies on the use of a new kind of class and on some small but powerful variations on CompiledMethods and Compilers. Besides being useful in their own right, we feel these extensions again illustrate (as in our previous article, [1, 2]) how powerful the reflective features of Smalltalk are, as they allow the programmer to adapt and extend the environment to suit his or her needs. The solution described is specific to Smalltalk-80, since it relies on Smalltalk-80’s architecture for classes, metaclasses, the compiler, and compiled methods, and on the complete availability of source code for these system elements. As a result, our extensions may not apply to Smalltalk V environments, though something similar may be possible.\n"
      },
      "after": "dede6a9b09b005ed",
      "date": 1650790886181
    },
    {
      "type": "edit",
      "id": "1cf4530cc43ffa40",
      "item": {
        "type": "markdown",
        "id": "1cf4530cc43ffa40",
        "text": "> This article will show how to solve this and similar problems by letting you modify code and add breakpoints that affect only one specific object, rather than all objects in a given class. Our solution relies on the use of a new kind of class and on some small but powerful variations on CompiledMethods and Compilers. Besides being useful in their own right, we feel these extensions again illustrate (as in our previous article, [1, 2]) how powerful the reflective features of Smalltalk are, as they allow the programmer to adapt and extend the environment to suit his or her needs. The solution described is specific to Smalltalk-80, since it relies on Smalltalk-80’s architecture for classes, metaclasses, the compiler, and compiled methods, and on the complete availability of source code for these system elements. As a result, our extensions may not apply to Smalltalk V environments, though something similar may be possible.\n"
      },
      "date": 1650790887519
    }
  ]
}