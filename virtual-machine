{
  "title": "Virtual Machine",
  "story": [
    {
      "type": "markdown",
      "id": "5244a21fb3f6ced4",
      "text": "A *[[Virtual Machine]]* is a synthetic computer. It behaves as a real machine would, if only there were such a machine. Because there isn't, people use a virtual machine to emulate the one they wish they really had. Virtual machines are interesting only because of what they execute. For a Smalltalk virtual machine, that something is called the *[[image]]*. --  LIU, Chamond, 2000. Smalltalk, objects, and design: the classic guide, now in paperback. Reprinted from the original 1996 ed. with minor corrections. San Jose: toExcel. ISBN 978-1-58348-490-6, p. 181\n"
    },
    {
      "type": "markdown",
      "id": "b06c89767b3e68a5",
      "text": "⇒ [[Image]]"
    },
    {
      "type": "pagefold",
      "id": "5562cd6fb18cfaaa",
      "text": "."
    },
    {
      "type": "html",
      "text": "A virtual machine, sense 1, is an abstraction that defines a [[Computing Model]]. Also called an [[Abstract Machine]].",
      "id": "acec170d86f7b4d400717cdc54d66832"
    },
    {
      "type": "html",
      "text": "\nA virtual machine, sense 2, is also an implementation, done over another virtual machine, sense 2, or directly into hardware, of a virtual machine, sense 1.",
      "id": "762cd42a5c9cfb8e77001a18e536ec93"
    },
    {
      "type": "html",
      "text": "\nIn recent years the term has come to have the connotation of a software platform that exists on multiple hardware platforms and provides an abstraction layer that allows programmers to write code without considering the hardware that it will run on.",
      "id": "989d0a5733d2879102b61d6c25f5efb5"
    },
    {
      "type": "html",
      "text": "\nExamples throughout the history of our field:",
      "id": "7edd9d4a94b6c227ca70a68ae62fb9fa"
    },
    {
      "type": "html",
      "text": "\nFor general-purpose [[Programming Language]]s:",
      "id": "10b31ef6e2bc8ca2e9941a870674db85"
    },
    {
      "type": "html",
      "text": " [[Java Virtual Machine]]",
      "id": "29be77a011f644ec8ed2c0e00c5963cb"
    },
    {
      "type": "html",
      "text": " Microsoft's [[Common Language Runtime]]",
      "id": "d0100d9b977993f914111883a377fa99"
    },
    {
      "type": "html",
      "text": " [[Pascal Language]] [[Pea Code]] (PCODE)",
      "id": "8d1d8fc0f98eef4288e063247ec48b82"
    },
    {
      "type": "html",
      "text": " [[Smalltalk Virtual Machine]]",
      "id": "60a4d7a3cf641f761b6bfc6c28375b19"
    },
    {
      "type": "html",
      "text": " [[Parrot Code]] [[Virtual Machine]]",
      "id": "cb1bdcfce03caad9e64e67e0d7426443"
    },
    {
      "type": "html",
      "text": " [[Self Language]] [[Virtual Machine]]",
      "id": "008a25584ef5b70e9d2b6647ceb001d3"
    },
    {
      "type": "html",
      "text": " [[Inferno Os]] [[Virtual Machine]] (Dis)",
      "id": "8cd0cdda0b66a62aec3f54454dc4380f"
    },
    {
      "type": "html",
      "text": " [[Low Level Virtual Machine]] (LLVM) ",
      "id": "27aafbcaf9fa4f10b0a24d3eec0009be"
    },
    {
      "type": "html",
      "text": "\nSpecial purpose machines:",
      "id": "1a5fb9328dc0a695e37e0dd3972556d1"
    },
    {
      "type": "html",
      "text": " [[Zed Machine]] (used to power the Infocom text adventures)",
      "id": "20fb2b5b864720f24eb258d94c7e4f72"
    },
    {
      "type": "html",
      "text": " Zend Engine 2 (runs [[Php Language]] bytecode)",
      "id": "2617e79f335dacc4c2d82edec48919cb"
    },
    {
      "type": "html",
      "text": "\nInteresting subtype of [[Virtual Machine]]:",
      "id": "be77303206975174c7b4ef994de8cf86"
    },
    {
      "type": "html",
      "text": " [[Safe Virtual Machine]] (guarantees, that code cannot violate its typing, thus enforcing security):",
      "id": "f4ff28e0a0862ee43f94092043134a71"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e85042ae4ea57b0b08425f1f91e84917"
    },
    {
      "type": "html",
      "text": "[[Ms Virtual Pc]] considered an example of [[Virtual Machine]] implementation?",
      "id": "b50a0f0689ee821412d2aa4bde842711"
    },
    {
      "type": "html",
      "text": "<i>I just added [[Virtual Computer]] to try to clarify the distinction, at least on this Wiki.</i>",
      "id": "a0616cbb7924236e28e4c8b5b9e5e588"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e85042ae4ea57b0b08425f1f91e84917"
    },
    {
      "type": "html",
      "text": "<i>Previous definitions</i>",
      "id": "5818f88d7914c65ba3c1415f8361fff5"
    },
    {
      "type": "html",
      "text": "\ndef.<b>Virtual Machine</b>: fancy name for computer program, see also: [[Turing Machine]]",
      "id": "35ea04cc9090856c002b6464d99633fe"
    },
    {
      "type": "html",
      "text": "\nA [[Virtual Machine]] is a program that translates a standard series of instruction codes into hardware specific [[Machine Language]]. In recent years the term has come to have the connotation of a software platform that exists on multiple hardware platforms and provides an abstraction layer that allows programmers to write code without considering the hardware that it will run on.",
      "id": "0e0e66ab6ec3c3e5df95c74c9db275eb"
    },
    {
      "type": "html",
      "text": "<i>That sounds more like a definition of a compiler/assembler than a [[Virtual Machine]]. Particularly in the context of an interpreter (or microcode), [[Machine Language]] instructions, while executed to perform the higher level functions, are not necessarily first emitted as the result of some translation process.  And I'm not sure about calling a [[Virtual Machine]] a program, instead it is the non-tangible specification of a device, which can be used only through an emulation program. </i>",
      "id": "e3ac24989b2153d972bc1e5462f8475a"
    },
    {
      "type": "html",
      "text": "\nAny interpreted language and most operating systems operate as virtual machines but the term has gained prominence in part due to the popularity of the [[Java Language]].",
      "id": "605660619dc910aee4b975b78f2ab442"
    },
    {
      "type": "html",
      "text": "<i>The term has gained prominence in the past, due to Pcode and [[Byte Codes]]</i>",
      "id": "639b63d496dd5d1bd96b9c1572d1fddc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e85042ae4ea57b0b08425f1f91e84917"
    },
    {
      "type": "html",
      "text": "What about the following definition:",
      "id": "8a9c93ebb05f919ea798503254f99ce9"
    },
    {
      "type": "html",
      "text": "\nA virtual machine is a hypothetical device that is capable of executing a\nspecific instruction set. Such an instruction set is commonly called [[Byte Code]].\nA common implementation strategy for programming\nlanguages is to compile code into instructions for a specialized [[Virtual Machine]].\nSubsequently, these instructions can be actually executed in a number of different ways:",
      "id": "fbe1d73a157b258e2b11e5e49b0a1097"
    },
    {
      "type": "html",
      "text": " Interpretation by software",
      "id": "53491aaf4fd950d0da10ca6554388456"
    },
    {
      "type": "html",
      "text": " Translation into the instruction set of a real processor",
      "id": "1392ebdd3f01793a3b0ab30333125b08"
    },
    {
      "type": "html",
      "text": " Direct interpretation in hardware\nIn the last case, the  virtual machine isn't \"virtual\" anymore, though the name\nmay still stick if there's a long history during which the machine was really",
      "id": "a89d67264e6ff31cb90b2f139fc72485"
    },
    {
      "type": "html",
      "text": "\"virtual\".",
      "id": "44ee6296769b66dad8df52db39db8203"
    },
    {
      "type": "html",
      "text": "\nConfusingly, the software interpreter for a virtual machine is itself also\nsometimes called a virtual machine. It is more correctly called a [[Byte Code Interpreter]].",
      "id": "9cf609bd76bbfd42f2c0d8cf47472d07"
    },
    {
      "type": "html",
      "text": "\nAn implementation strategy which compiles [[Byte Code]] into the instruction set of the real processor just prior to execution, is called [[Just In Time Compilation]].",
      "id": "0e98293e69cef50c4b7063841658cea2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e85042ae4ea57b0b08425f1f91e84917"
    },
    {
      "type": "html",
      "text": "Not all virtual machines are interpreters, not all virtual machines use a stack-based paradigm, and not all software interpreters (sic) for virtual machines are [[Byte Code Interpreter]]s. I suggest that we therefore broaden the definition of virtual machine.",
      "id": "4e3f97dec815ebc05532bac77040f2ee"
    },
    {
      "type": "html",
      "text": "\nAt [[Component Software Corporation]], we built a virtual machine that ran compiled code in a virtual machine that used a RISC-based register-intensive paradigm. The virtual machine was therefore a generic RISC engine for which we defined intermediate code (like that of a portable compiler). Compilers (we supported Smalltalk and [[Objective Cee]]) emitted intermediate code for each method, which was then persisted (instead of [[Byte Code]]s). Native code was compiled by a platform-specific code generator as each method was imported into the environment or compiled after being edited.",
      "id": "720919bfc4a1e7a67261b7436506622c"
    },
    {
      "type": "html",
      "text": "\nThus, the [[Component Virtual Machine]] always ran compiled code, it only required [[Just In Time Compilation]] for performs and similar exotica, and its performance was dramatically better than comparable byte-code approaches. The code generator for RISC machines (our prototype ran on MacII's and Sparc's) could generate blazing native code.",
      "id": "e936bee15922ae82fda603a07719be73"
    },
    {
      "type": "html",
      "text": "--[[Tom Stambaugh]]",
      "id": "f66cd504b0ead2afa1beaac866af5843"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e85042ae4ea57b0b08425f1f91e84917"
    },
    {
      "type": "html",
      "text": "I would like to point out that a virtual machine <b>can</b> be done in such a way to run fast, the [[Java Virtual Machine]] is not a very good example.",
      "id": "ca73fcf60c424a88c6e94ddd13be7cc4"
    },
    {
      "type": "html",
      "text": "\nFor example, being stack based is very nice in theory. It is a clean design and computer scientists love clean designs. But they <b>are</b> a bad idea. See this example of translating \"a = b + c\":",
      "id": "99159606b941b776c38613b17510e6fb"
    },
    {
      "type": "code",
      "text": "    push b         LS\n    push c         LS\n    add            LLS\n    pop a          LS",
      "id": "68101925042ac2c9eb5ccaa9b866207c"
    },
    {
      "type": "html",
      "text": "\nCompare with a more flexible approach, where operators can use memory directly for example:",
      "id": "9786b5b9c846e1f1ee5bdb7a9b50b360"
    },
    {
      "type": "code",
      "text": "    add b, c, a    LLS",
      "id": "a0d223d6d41860bec7a690770d67066d"
    },
    {
      "type": "html",
      "text": "\nPushes and pops have to store/load, because most of the time they are implemented with a piece of regular memory. This makes the stack-based example do 5 loads and 4 stores, spanning 4 instructions (think instruction decoding overhead). A saner (and not as clean, design-wise) way to do this is to have an 'add' operator that will add two memory locations and put the result in a third memory location. A single instruction, two loads, one store.",
      "id": "feb471f398a9fe900535bbfef8eedfa9"
    },
    {
      "type": "html",
      "text": "The stack example can be rewritten using modern compiler techniques and simplified to your 3-operand example.  [[Static Single Assignment Form]] is your friend!  I believe this is what most native-code [[Java Language]] compilers do, and with quite admirable results.  This allows a restoration of using the clean design of the stack, while factoring out the brutal realities of register-based architectures.  --[[Samuel Falvo]]",
      "id": "f38bbeed275a3b33152e805530d6b443"
    },
    {
      "type": "html",
      "text": "<i>This may be true for stack architectures made by register-familiar engineers, but true stack architectures (e.g., actual <b>hardware</b> that runs stack-oriented code, a la Forth CPUs) are actually notably faster than register-oriented architectures, by virtue of the fact that the interconnects to/from the ALU are fixed and substantially shorter, going through fewer gates, and therefore, can be driven at substantially higher clock rates (Chuck Moore's MuP21 achieved 500MIPS peak performance with 0.8u technology, for example).  Of course, that being said, implementing a stack virtual machine on a register architecture will slow things down considerably, just as implementing a register-based VM on a stack architecture will bog it down considerably.</i>",
      "id": "95e2645502249062067e587ccb16cafb"
    },
    {
      "type": "html",
      "text": "<i>Also, stack architectures with small, finite stack depths are able to be 'register-optimized' with moderate ease.  For example, anyone here can probably write an optimizing virtual machine implementation for the Steamer16 microprocessor that runs close to, if not at, native hardware speed on a register-based architecture.</i>",
      "id": "99a0a31bda120aefc864c3b15445fccf"
    },
    {
      "type": "html",
      "text": "\nDo this with other instructions (<i>complicate</i> them) and try it. Speed! Still less than native code, of course, but getting better. And those \"complex instructions\" have more context to them, so that a [[Just In Time Compiler]] could possibly have more success optimizing them. For example, a very complex instruction (think really stupidly complex, like a 'sort' operator!) could be compiled to a function call into some hand-optimized C or assembler code, as tight as you could want. This would be much faster than implementing it in the virtual machine.",
      "id": "bddd98390d4ba132e01359732748ebfe"
    },
    {
      "type": "html",
      "text": "\nFor an example of such a [[Virtual Machine]], look at [http://www.cs.bell-labs.com/cm/cs/who/rob/hotchips.html www.cs.bell-labs.com], by [[Rob Pike]]. --[[Pierre Phaneuf]]",
      "id": "851aa196334fff9648249208d19ca3c8"
    },
    {
      "type": "html",
      "text": "<i>Actually, this is very common (Sun just seems to miss all of these things).  If you look at IBM's BAL for the 360/370/390 lineage or MI for the AS/400 [[[As Four Hundred Machine Interface]]] you will see this kind of an approach.  IBM has always used an \"abstract\" assembler, which is to say that you aren't programming the processor in a direct fashion.  On the AS/400 all program objects run in a virtual machine environment.  On the mainframe this is less the case, but still close.  Many of the opcodes are optimized for minimum load/stores.  Also, you will tend to find \"higher level\" opcodes than in say pure RISC or other CISC assemblers.</i> -- [[Jeff Panici]]",
      "id": "d464df14a24b7bfc0fa883a102e4395f"
    },
    {
      "type": "html",
      "text": "\nIt's still not good enough for a <i>portable</i> virtual machine (not necessarily the goal of the IBM/3?0 group). See [http://sunir.org/apps/vm?RedCode sunir.org] and [http://sunir.org/apps/vm?RedCodeDesign sunir.org] for a discussion of this.",
      "id": "ba2826d6f7a4c9becb9b3ca87f51e774"
    },
    {
      "type": "html",
      "text": "\nI wonder if the best form for a VM instruction set might not be some sort of [[Static Single Assignment Form]]. SSA is elegant enough to satisfy the [[Computer Science]] propellerheads, and is easy to compile into good code - SSA is used as an intermediate form in many (most?) modern compilers. The only serious problem i can think of is running it by interpretation or fast compilation (where proper register allocation is too expensive); this might be ameliorated by doing some sort of register allocation at source-compile-time, and including the results as a hint to the interpreter. -- [[Tom Anderson]]",
      "id": "d4f140471175910b2281b95320bc2aad"
    },
    {
      "type": "html",
      "text": "\n[[Low Level Virtual Machine]] (LLVM) uses this, I believe. -- [[Jebadiah Moore]]",
      "id": "1d91b0439e6ded5d00b07c9c48498b4f"
    },
    {
      "type": "html",
      "text": "\nI think compressed [[Abstract Syntax Tree]]s might be better. I found a reference (although I'm not going to look right now) that showed that due to the growing latency gap between processors and disks, loading compressed abstract syntax trees off disk and compiling them on the fly was faster than <i>loading</i> a purely native program off disk. ",
      "id": "fda556578ce07362fac0e12f0e9addd0"
    },
    {
      "type": "html",
      "text": "\nThere was also another <i>operating system</i> ([[Inferno Os]]?) that stored all the programs and system libraries as ASTs and recompiled each function on the fly as it was invoked. They saw something like a magnitude speed improvement over purely native call (think <i>dynamic</i> constant folding). ",
      "id": "6b838b9ca47e349f6b6f0e603beea47d"
    },
    {
      "type": "html",
      "text": "Then again, [http://www.bytecodes.com www.bytecodes.com] claims their embedded JVM is comparable to embedded JVMs with JIT compilers because they can stuff the VM runtime into the instruction cache and most programs into the data cache. JIT compilers would thrash both caches very badly. -- [[Sunir Shah]]",
      "id": "180cce45dffc1a8b30f975fc4a8a6751"
    },
    {
      "type": "html",
      "text": "<i>True, but they also say \"Large desktop and server platforms with megabytes of memory to spare and processors running over 2 Gigahertz with 256K on-chip caches are better served by using the fully optimizing versions of server and desktop Just-In-Time Compilers (JITs) coupled with our EBCI Interpreters. JITs use our interpreters to jump start at a faster speed because JITs start out interpreting Java code before compiling it.\"</i>",
      "id": "538543c861463406d2a9efe322e973da"
    },
    {
      "type": "html",
      "text": "\nTAOS (now [[Tao Intent Os]]) was designed to operate on heterogenous clusters (eg a mix of PC and sparc hardware on an ethernet), so it defined programs in terms of a virtual processor (and so an associated [[Virtual Machine]]); it was translated into native code at load time. They say: \"It would be wrong to think that this slows the system down. Most processors are able to translate VP into native code faster than the VP code can be loaded from disk and sent across the network, so there is no visible overhead. Indeed, VP code is often more compact than the native code; therefore less disk space is used and code is loaded faster than if it were the native for the processor.\"",
      "id": "e2aae3f4a9880ef962602acf22d98fdd"
    },
    {
      "type": "html",
      "text": "\n[http://www.uruk.org/emu/Taos.html www.uruk.org]",
      "id": "37555a424675908c9b6601b76ebc1b15"
    },
    {
      "type": "html",
      "text": "-- [[Tom Anderson]]",
      "id": "d2ed5276432d2ad505c2223dd7c77dfe"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e85042ae4ea57b0b08425f1f91e84917"
    },
    {
      "type": "html",
      "text": "\nParrot has a register-based design for its JIT VM.",
      "id": "860aba07725a5eeef3fedf69de559cc7"
    },
    {
      "type": "html",
      "text": "\n[http://www.parrotcode.org/docs/overview.pod.html www.parrotcode.org]",
      "id": "05b3dcab9200e2eed8a55168c7d7b417"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e85042ae4ea57b0b08425f1f91e84917"
    },
    {
      "type": "html",
      "text": "\nOne of the world's earliest and most widely ported virtual machines is the z-code interpreter from Infocom.\nIn various incarnations it was used to implement the 35 or so text adventure games they released allowing\ntheir games, including the famous Zork Trilogy, to be platform independent. Z-code interpreters exist for platforms as diverse as the Commodore64, AppleII,\nPalmOS, KayproII, IBMPC, TRS-80 and the TI-89 calculator. A compiler for this virtual machine, Inform, is freely available\nalthough the original games were not written with this compiler.",
      "id": "9e56b21f4e22da01a188a93fd60d4f58"
    },
    {
      "type": "html",
      "text": "-- [[Dan Piponi]]",
      "id": "102cc82a37520be944890e45a846b299"
    },
    {
      "type": "html",
      "text": "\nUCSD Pascal was earlier and more widely ported, note. Mainframe emulators were widely used back in the 1960s to maintain backward compatibility. Z-code might hold a record for the product of EARLIEST * WIDELY_PORTED; back then it was unusual for anything at all to be widely ported.",
      "id": "b33e0e454615c569598088dd864d231f"
    },
    {
      "type": "html",
      "text": "(See [[Ucsd Pcode]])",
      "id": "4beba6e8732fbec1a70c24fff0b15729"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e85042ae4ea57b0b08425f1f91e84917"
    },
    {
      "type": "html",
      "text": "\nThere are probably more people served by [[Pick Language]] in [[Manufacturing System]]s and [[Human Relations System]]s, even now in 2006. On a [[Virtual Machine]] within many  corporate operating systems, including Windows, Unix, MVS. ",
      "id": "6f9ed26b5e8d3a0d987d3a3cb6a13250"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e85042ae4ea57b0b08425f1f91e84917"
    },
    {
      "type": "html",
      "text": "See also: [[Global Variables And Virtual Machines]]",
      "id": "4cef38d0f6562e5b3f2a9afd1dbb4faa"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e85042ae4ea57b0b08425f1f91e84917"
    },
    {
      "type": "html",
      "text": "[[Category Computer Architecture]] [[Category Operating System]] (because of the close associations)",
      "id": "9a642f88754ee90a7764a8eb20bcd9f1"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?VirtualMachine c2.com]",
      "id": "986795e65fda2eed4297b9e0ce899357"
    }
  ],
  "journal": [
    {
      "date": 1399816749000,
      "id": "d474d1d264778931367f3e94a366ccec",
      "type": "create",
      "item": {
        "title": "Virtual Machine",
        "story": [
          {
            "type": "html",
            "text": "A virtual machine, sense 1, is an abstraction that defines a [[Computing Model]]. Also called an [[Abstract Machine]].",
            "id": "acec170d86f7b4d400717cdc54d66832"
          },
          {
            "type": "html",
            "text": "\nA virtual machine, sense 2, is also an implementation, done over another virtual machine, sense 2, or directly into hardware, of a virtual machine, sense 1.",
            "id": "762cd42a5c9cfb8e77001a18e536ec93"
          },
          {
            "type": "html",
            "text": "\nIn recent years the term has come to have the connotation of a software platform that exists on multiple hardware platforms and provides an abstraction layer that allows programmers to write code without considering the hardware that it will run on.",
            "id": "989d0a5733d2879102b61d6c25f5efb5"
          },
          {
            "type": "html",
            "text": "\nExamples throughout the history of our field:",
            "id": "7edd9d4a94b6c227ca70a68ae62fb9fa"
          },
          {
            "type": "html",
            "text": "\nFor general-purpose [[Programming Language]]s:",
            "id": "10b31ef6e2bc8ca2e9941a870674db85"
          },
          {
            "type": "html",
            "text": " [[Java Virtual Machine]]",
            "id": "29be77a011f644ec8ed2c0e00c5963cb"
          },
          {
            "type": "html",
            "text": " Microsoft's [[Common Language Runtime]]",
            "id": "d0100d9b977993f914111883a377fa99"
          },
          {
            "type": "html",
            "text": " [[Pascal Language]] [[Pea Code]] (PCODE)",
            "id": "8d1d8fc0f98eef4288e063247ec48b82"
          },
          {
            "type": "html",
            "text": " [[Smalltalk Virtual Machine]]",
            "id": "60a4d7a3cf641f761b6bfc6c28375b19"
          },
          {
            "type": "html",
            "text": " [[Parrot Code]] [[Virtual Machine]]",
            "id": "cb1bdcfce03caad9e64e67e0d7426443"
          },
          {
            "type": "html",
            "text": " [[Self Language]] [[Virtual Machine]]",
            "id": "008a25584ef5b70e9d2b6647ceb001d3"
          },
          {
            "type": "html",
            "text": " [[Inferno Os]] [[Virtual Machine]] (Dis)",
            "id": "8cd0cdda0b66a62aec3f54454dc4380f"
          },
          {
            "type": "html",
            "text": " [[Low Level Virtual Machine]] (LLVM) ",
            "id": "27aafbcaf9fa4f10b0a24d3eec0009be"
          },
          {
            "type": "html",
            "text": "\nSpecial purpose machines:",
            "id": "1a5fb9328dc0a695e37e0dd3972556d1"
          },
          {
            "type": "html",
            "text": " [[Zed Machine]] (used to power the Infocom text adventures)",
            "id": "20fb2b5b864720f24eb258d94c7e4f72"
          },
          {
            "type": "html",
            "text": " Zend Engine 2 (runs [[Php Language]] bytecode)",
            "id": "2617e79f335dacc4c2d82edec48919cb"
          },
          {
            "type": "html",
            "text": "\nInteresting subtype of [[Virtual Machine]]:",
            "id": "be77303206975174c7b4ef994de8cf86"
          },
          {
            "type": "html",
            "text": " [[Safe Virtual Machine]] (guarantees, that code cannot violate its typing, thus enforcing security):",
            "id": "f4ff28e0a0862ee43f94092043134a71"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e85042ae4ea57b0b08425f1f91e84917"
          },
          {
            "type": "html",
            "text": "[[Ms Virtual Pc]] considered an example of [[Virtual Machine]] implementation?",
            "id": "b50a0f0689ee821412d2aa4bde842711"
          },
          {
            "type": "html",
            "text": "<i>I just added [[Virtual Computer]] to try to clarify the distinction, at least on this Wiki.</i>",
            "id": "a0616cbb7924236e28e4c8b5b9e5e588"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e85042ae4ea57b0b08425f1f91e84917"
          },
          {
            "type": "html",
            "text": "<i>Previous definitions</i>",
            "id": "5818f88d7914c65ba3c1415f8361fff5"
          },
          {
            "type": "html",
            "text": "\ndef.<b>Virtual Machine</b>: fancy name for computer program, see also: [[Turing Machine]]",
            "id": "35ea04cc9090856c002b6464d99633fe"
          },
          {
            "type": "html",
            "text": "\nA [[Virtual Machine]] is a program that translates a standard series of instruction codes into hardware specific [[Machine Language]]. In recent years the term has come to have the connotation of a software platform that exists on multiple hardware platforms and provides an abstraction layer that allows programmers to write code without considering the hardware that it will run on.",
            "id": "0e0e66ab6ec3c3e5df95c74c9db275eb"
          },
          {
            "type": "html",
            "text": "<i>That sounds more like a definition of a compiler/assembler than a [[Virtual Machine]]. Particularly in the context of an interpreter (or microcode), [[Machine Language]] instructions, while executed to perform the higher level functions, are not necessarily first emitted as the result of some translation process.  And I'm not sure about calling a [[Virtual Machine]] a program, instead it is the non-tangible specification of a device, which can be used only through an emulation program. </i>",
            "id": "e3ac24989b2153d972bc1e5462f8475a"
          },
          {
            "type": "html",
            "text": "\nAny interpreted language and most operating systems operate as virtual machines but the term has gained prominence in part due to the popularity of the [[Java Language]].",
            "id": "605660619dc910aee4b975b78f2ab442"
          },
          {
            "type": "html",
            "text": "<i>The term has gained prominence in the past, due to Pcode and [[Byte Codes]]</i>",
            "id": "639b63d496dd5d1bd96b9c1572d1fddc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e85042ae4ea57b0b08425f1f91e84917"
          },
          {
            "type": "html",
            "text": "What about the following definition:",
            "id": "8a9c93ebb05f919ea798503254f99ce9"
          },
          {
            "type": "html",
            "text": "\nA virtual machine is a hypothetical device that is capable of executing a\nspecific instruction set. Such an instruction set is commonly called [[Byte Code]].\nA common implementation strategy for programming\nlanguages is to compile code into instructions for a specialized [[Virtual Machine]].\nSubsequently, these instructions can be actually executed in a number of different ways:",
            "id": "fbe1d73a157b258e2b11e5e49b0a1097"
          },
          {
            "type": "html",
            "text": " Interpretation by software",
            "id": "53491aaf4fd950d0da10ca6554388456"
          },
          {
            "type": "html",
            "text": " Translation into the instruction set of a real processor",
            "id": "1392ebdd3f01793a3b0ab30333125b08"
          },
          {
            "type": "html",
            "text": " Direct interpretation in hardware\nIn the last case, the  virtual machine isn't \"virtual\" anymore, though the name\nmay still stick if there's a long history during which the machine was really",
            "id": "a89d67264e6ff31cb90b2f139fc72485"
          },
          {
            "type": "html",
            "text": "\"virtual\".",
            "id": "44ee6296769b66dad8df52db39db8203"
          },
          {
            "type": "html",
            "text": "\nConfusingly, the software interpreter for a virtual machine is itself also\nsometimes called a virtual machine. It is more correctly called a [[Byte Code Interpreter]].",
            "id": "9cf609bd76bbfd42f2c0d8cf47472d07"
          },
          {
            "type": "html",
            "text": "\nAn implementation strategy which compiles [[Byte Code]] into the instruction set of the real processor just prior to execution, is called [[Just In Time Compilation]].",
            "id": "0e98293e69cef50c4b7063841658cea2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e85042ae4ea57b0b08425f1f91e84917"
          },
          {
            "type": "html",
            "text": "Not all virtual machines are interpreters, not all virtual machines use a stack-based paradigm, and not all software interpreters (sic) for virtual machines are [[Byte Code Interpreter]]s. I suggest that we therefore broaden the definition of virtual machine.",
            "id": "4e3f97dec815ebc05532bac77040f2ee"
          },
          {
            "type": "html",
            "text": "\nAt [[Component Software Corporation]], we built a virtual machine that ran compiled code in a virtual machine that used a RISC-based register-intensive paradigm. The virtual machine was therefore a generic RISC engine for which we defined intermediate code (like that of a portable compiler). Compilers (we supported Smalltalk and [[Objective Cee]]) emitted intermediate code for each method, which was then persisted (instead of [[Byte Code]]s). Native code was compiled by a platform-specific code generator as each method was imported into the environment or compiled after being edited.",
            "id": "720919bfc4a1e7a67261b7436506622c"
          },
          {
            "type": "html",
            "text": "\nThus, the [[Component Virtual Machine]] always ran compiled code, it only required [[Just In Time Compilation]] for performs and similar exotica, and its performance was dramatically better than comparable byte-code approaches. The code generator for RISC machines (our prototype ran on MacII's and Sparc's) could generate blazing native code.",
            "id": "e936bee15922ae82fda603a07719be73"
          },
          {
            "type": "html",
            "text": "--[[Tom Stambaugh]]",
            "id": "f66cd504b0ead2afa1beaac866af5843"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e85042ae4ea57b0b08425f1f91e84917"
          },
          {
            "type": "html",
            "text": "I would like to point out that a virtual machine <b>can</b> be done in such a way to run fast, the [[Java Virtual Machine]] is not a very good example.",
            "id": "ca73fcf60c424a88c6e94ddd13be7cc4"
          },
          {
            "type": "html",
            "text": "\nFor example, being stack based is very nice in theory. It is a clean design and computer scientists love clean designs. But they <b>are</b> a bad idea. See this example of translating \"a = b + c\":",
            "id": "99159606b941b776c38613b17510e6fb"
          },
          {
            "type": "code",
            "text": "    push b         LS\n    push c         LS\n    add            LLS\n    pop a          LS",
            "id": "68101925042ac2c9eb5ccaa9b866207c"
          },
          {
            "type": "html",
            "text": "\nCompare with a more flexible approach, where operators can use memory directly for example:",
            "id": "9786b5b9c846e1f1ee5bdb7a9b50b360"
          },
          {
            "type": "code",
            "text": "    add b, c, a    LLS",
            "id": "a0d223d6d41860bec7a690770d67066d"
          },
          {
            "type": "html",
            "text": "\nPushes and pops have to store/load, because most of the time they are implemented with a piece of regular memory. This makes the stack-based example do 5 loads and 4 stores, spanning 4 instructions (think instruction decoding overhead). A saner (and not as clean, design-wise) way to do this is to have an 'add' operator that will add two memory locations and put the result in a third memory location. A single instruction, two loads, one store.",
            "id": "feb471f398a9fe900535bbfef8eedfa9"
          },
          {
            "type": "html",
            "text": "The stack example can be rewritten using modern compiler techniques and simplified to your 3-operand example.  [[Static Single Assignment Form]] is your friend!  I believe this is what most native-code [[Java Language]] compilers do, and with quite admirable results.  This allows a restoration of using the clean design of the stack, while factoring out the brutal realities of register-based architectures.  --[[Samuel Falvo]]",
            "id": "f38bbeed275a3b33152e805530d6b443"
          },
          {
            "type": "html",
            "text": "<i>This may be true for stack architectures made by register-familiar engineers, but true stack architectures (e.g., actual <b>hardware</b> that runs stack-oriented code, a la Forth CPUs) are actually notably faster than register-oriented architectures, by virtue of the fact that the interconnects to/from the ALU are fixed and substantially shorter, going through fewer gates, and therefore, can be driven at substantially higher clock rates (Chuck Moore's MuP21 achieved 500MIPS peak performance with 0.8u technology, for example).  Of course, that being said, implementing a stack virtual machine on a register architecture will slow things down considerably, just as implementing a register-based VM on a stack architecture will bog it down considerably.</i>",
            "id": "95e2645502249062067e587ccb16cafb"
          },
          {
            "type": "html",
            "text": "<i>Also, stack architectures with small, finite stack depths are able to be 'register-optimized' with moderate ease.  For example, anyone here can probably write an optimizing virtual machine implementation for the Steamer16 microprocessor that runs close to, if not at, native hardware speed on a register-based architecture.</i>",
            "id": "99a0a31bda120aefc864c3b15445fccf"
          },
          {
            "type": "html",
            "text": "\nDo this with other instructions (<i>complicate</i> them) and try it. Speed! Still less than native code, of course, but getting better. And those \"complex instructions\" have more context to them, so that a [[Just In Time Compiler]] could possibly have more success optimizing them. For example, a very complex instruction (think really stupidly complex, like a 'sort' operator!) could be compiled to a function call into some hand-optimized C or assembler code, as tight as you could want. This would be much faster than implementing it in the virtual machine.",
            "id": "bddd98390d4ba132e01359732748ebfe"
          },
          {
            "type": "html",
            "text": "\nFor an example of such a [[Virtual Machine]], look at [http://www.cs.bell-labs.com/cm/cs/who/rob/hotchips.html www.cs.bell-labs.com], by [[Rob Pike]]. --[[Pierre Phaneuf]]",
            "id": "851aa196334fff9648249208d19ca3c8"
          },
          {
            "type": "html",
            "text": "<i>Actually, this is very common (Sun just seems to miss all of these things).  If you look at IBM's BAL for the 360/370/390 lineage or MI for the AS/400 [[[As Four Hundred Machine Interface]]] you will see this kind of an approach.  IBM has always used an \"abstract\" assembler, which is to say that you aren't programming the processor in a direct fashion.  On the AS/400 all program objects run in a virtual machine environment.  On the mainframe this is less the case, but still close.  Many of the opcodes are optimized for minimum load/stores.  Also, you will tend to find \"higher level\" opcodes than in say pure RISC or other CISC assemblers.</i> -- [[Jeff Panici]]",
            "id": "d464df14a24b7bfc0fa883a102e4395f"
          },
          {
            "type": "html",
            "text": "\nIt's still not good enough for a <i>portable</i> virtual machine (not necessarily the goal of the IBM/3?0 group). See [http://sunir.org/apps/vm?RedCode sunir.org] and [http://sunir.org/apps/vm?RedCodeDesign sunir.org] for a discussion of this.",
            "id": "ba2826d6f7a4c9becb9b3ca87f51e774"
          },
          {
            "type": "html",
            "text": "\nI wonder if the best form for a VM instruction set might not be some sort of [[Static Single Assignment Form]]. SSA is elegant enough to satisfy the [[Computer Science]] propellerheads, and is easy to compile into good code - SSA is used as an intermediate form in many (most?) modern compilers. The only serious problem i can think of is running it by interpretation or fast compilation (where proper register allocation is too expensive); this might be ameliorated by doing some sort of register allocation at source-compile-time, and including the results as a hint to the interpreter. -- [[Tom Anderson]]",
            "id": "d4f140471175910b2281b95320bc2aad"
          },
          {
            "type": "html",
            "text": "\n[[Low Level Virtual Machine]] (LLVM) uses this, I believe. -- [[Jebadiah Moore]]",
            "id": "1d91b0439e6ded5d00b07c9c48498b4f"
          },
          {
            "type": "html",
            "text": "\nI think compressed [[Abstract Syntax Tree]]s might be better. I found a reference (although I'm not going to look right now) that showed that due to the growing latency gap between processors and disks, loading compressed abstract syntax trees off disk and compiling them on the fly was faster than <i>loading</i> a purely native program off disk. ",
            "id": "fda556578ce07362fac0e12f0e9addd0"
          },
          {
            "type": "html",
            "text": "\nThere was also another <i>operating system</i> ([[Inferno Os]]?) that stored all the programs and system libraries as ASTs and recompiled each function on the fly as it was invoked. They saw something like a magnitude speed improvement over purely native call (think <i>dynamic</i> constant folding). ",
            "id": "6b838b9ca47e349f6b6f0e603beea47d"
          },
          {
            "type": "html",
            "text": "\nThen again, [http://www.bytecodes.com www.bytecodes.com] claims their embedded JVM is comparable to embedded JVMs with JIT compilers because they can stuff the VM runtime into the instruction cache and most programs into the data cache. JIT compilers would thrash both caches very badly. -- [[Sunir Shah]]",
            "id": "180cce45dffc1a8b30f975fc4a8a6751"
          },
          {
            "type": "html",
            "text": "<i>True, but they also say \"Large desktop and server platforms with megabytes of memory to spare and processors running over 2 Gigahertz with 256K on-chip caches are better served by using the fully optimizing versions of server and desktop Just-In-Time Compilers (JITs) coupled with our EBCI Interpreters. JITs use our interpreters to jump start at a faster speed because JITs start out interpreting Java code before compiling it.\"</i>",
            "id": "538543c861463406d2a9efe322e973da"
          },
          {
            "type": "html",
            "text": "\nTAOS (now [[Tao Intent Os]]) was designed to operate on heterogenous clusters (eg a mix of PC and sparc hardware on an ethernet), so it defined programs in terms of a virtual processor (and so an associated [[Virtual Machine]]); it was translated into native code at load time. They say: \"It would be wrong to think that this slows the system down. Most processors are able to translate VP into native code faster than the VP code can be loaded from disk and sent across the network, so there is no visible overhead. Indeed, VP code is often more compact than the native code; therefore less disk space is used and code is loaded faster than if it were the native for the processor.\"",
            "id": "e2aae3f4a9880ef962602acf22d98fdd"
          },
          {
            "type": "html",
            "text": "\n[http://www.uruk.org/emu/Taos.html www.uruk.org]",
            "id": "37555a424675908c9b6601b76ebc1b15"
          },
          {
            "type": "html",
            "text": "-- [[Tom Anderson]]",
            "id": "d2ed5276432d2ad505c2223dd7c77dfe"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e85042ae4ea57b0b08425f1f91e84917"
          },
          {
            "type": "html",
            "text": "\nParrot has a register-based design for its JIT VM.",
            "id": "860aba07725a5eeef3fedf69de559cc7"
          },
          {
            "type": "html",
            "text": "\n[http://www.parrotcode.org/docs/overview.pod.html www.parrotcode.org]",
            "id": "05b3dcab9200e2eed8a55168c7d7b417"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e85042ae4ea57b0b08425f1f91e84917"
          },
          {
            "type": "html",
            "text": "\nOne of the world's earliest and most widely ported virtual machines is the z-code interpreter from Infocom.\nIn various incarnations it was used to implement the 35 or so text adventure games they released allowing\ntheir games, including the famous Zork Trilogy, to be platform independent. Z-code interpreters exist for platforms as diverse as the Commodore64, AppleII,\nPalmOS, KayproII, IBMPC, TRS-80 and the TI-89 calculator. A compiler for this virtual machine, Inform, is freely available\nalthough the original games were not written with this compiler.",
            "id": "9e56b21f4e22da01a188a93fd60d4f58"
          },
          {
            "type": "html",
            "text": "-- [[Dan Piponi]]",
            "id": "102cc82a37520be944890e45a846b299"
          },
          {
            "type": "html",
            "text": "\nUCSD Pascal was earlier and more widely ported, note. Mainframe emulators were widely used back in the 1960s to maintain backward compatibility. Z-code might hold a record for the product of EARLIEST * WIDELY_PORTED; back then it was unusual for anything at all to be widely ported.",
            "id": "b33e0e454615c569598088dd864d231f"
          },
          {
            "type": "html",
            "text": "(See [[Ucsd Pcode]])",
            "id": "4beba6e8732fbec1a70c24fff0b15729"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e85042ae4ea57b0b08425f1f91e84917"
          },
          {
            "type": "html",
            "text": "\nThere are probably more people served by [[Pick Language]] in [[Manufacturing System]]s and [[Human Relations System]]s, even now in 2006. On a [[Virtual Machine]] within many  corporate operating systems, including Windows, Unix, MVS. ",
            "id": "6f9ed26b5e8d3a0d987d3a3cb6a13250"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e85042ae4ea57b0b08425f1f91e84917"
          },
          {
            "type": "html",
            "text": "See also: [[Global Variables And Virtual Machines]]",
            "id": "4cef38d0f6562e5b3f2a9afd1dbb4faa"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e85042ae4ea57b0b08425f1f91e84917"
          },
          {
            "type": "html",
            "text": "[[Category Computer Architecture]] [[Category Operating System]] (because of the close associations)",
            "id": "9a642f88754ee90a7764a8eb20bcd9f1"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?VirtualMachine c2.com]",
            "id": "986795e65fda2eed4297b9e0ce899357"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1644485720511
    },
    {
      "id": "5244a21fb3f6ced4",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "5244a21fb3f6ced4",
        "text": "A *[[Virtual Machine]]* is a synthetic computer. It behaves as a real machine would, if only there were such a machine. Because there isn't, people use a virtual machine to emulate the one they wish they really had. Virtual machines are interesting only because of what they execute. For a Smalltalk virtual machine, that something is called the *[[image]]*."
      },
      "date": 1654363832939
    },
    {
      "item": {
        "type": "factory",
        "id": "5562cd6fb18cfaaa"
      },
      "id": "5562cd6fb18cfaaa",
      "type": "add",
      "after": "986795e65fda2eed4297b9e0ce899357",
      "date": 1654363921450
    },
    {
      "id": "5562cd6fb18cfaaa",
      "type": "move",
      "order": [
        "5244a21fb3f6ced4",
        "5562cd6fb18cfaaa",
        "acec170d86f7b4d400717cdc54d66832",
        "762cd42a5c9cfb8e77001a18e536ec93",
        "989d0a5733d2879102b61d6c25f5efb5",
        "7edd9d4a94b6c227ca70a68ae62fb9fa",
        "10b31ef6e2bc8ca2e9941a870674db85",
        "29be77a011f644ec8ed2c0e00c5963cb",
        "d0100d9b977993f914111883a377fa99",
        "8d1d8fc0f98eef4288e063247ec48b82",
        "60a4d7a3cf641f761b6bfc6c28375b19",
        "cb1bdcfce03caad9e64e67e0d7426443",
        "008a25584ef5b70e9d2b6647ceb001d3",
        "8cd0cdda0b66a62aec3f54454dc4380f",
        "27aafbcaf9fa4f10b0a24d3eec0009be",
        "1a5fb9328dc0a695e37e0dd3972556d1",
        "20fb2b5b864720f24eb258d94c7e4f72",
        "2617e79f335dacc4c2d82edec48919cb",
        "be77303206975174c7b4ef994de8cf86",
        "f4ff28e0a0862ee43f94092043134a71",
        "e85042ae4ea57b0b08425f1f91e84917",
        "b50a0f0689ee821412d2aa4bde842711",
        "a0616cbb7924236e28e4c8b5b9e5e588",
        "e85042ae4ea57b0b08425f1f91e84917",
        "5818f88d7914c65ba3c1415f8361fff5",
        "35ea04cc9090856c002b6464d99633fe",
        "0e0e66ab6ec3c3e5df95c74c9db275eb",
        "e3ac24989b2153d972bc1e5462f8475a",
        "605660619dc910aee4b975b78f2ab442",
        "639b63d496dd5d1bd96b9c1572d1fddc",
        "e85042ae4ea57b0b08425f1f91e84917",
        "8a9c93ebb05f919ea798503254f99ce9",
        "fbe1d73a157b258e2b11e5e49b0a1097",
        "53491aaf4fd950d0da10ca6554388456",
        "1392ebdd3f01793a3b0ab30333125b08",
        "a89d67264e6ff31cb90b2f139fc72485",
        "44ee6296769b66dad8df52db39db8203",
        "9cf609bd76bbfd42f2c0d8cf47472d07",
        "0e98293e69cef50c4b7063841658cea2",
        "e85042ae4ea57b0b08425f1f91e84917",
        "4e3f97dec815ebc05532bac77040f2ee",
        "720919bfc4a1e7a67261b7436506622c",
        "e936bee15922ae82fda603a07719be73",
        "f66cd504b0ead2afa1beaac866af5843",
        "e85042ae4ea57b0b08425f1f91e84917",
        "ca73fcf60c424a88c6e94ddd13be7cc4",
        "99159606b941b776c38613b17510e6fb",
        "68101925042ac2c9eb5ccaa9b866207c",
        "9786b5b9c846e1f1ee5bdb7a9b50b360",
        "a0d223d6d41860bec7a690770d67066d",
        "feb471f398a9fe900535bbfef8eedfa9",
        "f38bbeed275a3b33152e805530d6b443",
        "95e2645502249062067e587ccb16cafb",
        "99a0a31bda120aefc864c3b15445fccf",
        "bddd98390d4ba132e01359732748ebfe",
        "851aa196334fff9648249208d19ca3c8",
        "d464df14a24b7bfc0fa883a102e4395f",
        "ba2826d6f7a4c9becb9b3ca87f51e774",
        "d4f140471175910b2281b95320bc2aad",
        "1d91b0439e6ded5d00b07c9c48498b4f",
        "fda556578ce07362fac0e12f0e9addd0",
        "6b838b9ca47e349f6b6f0e603beea47d",
        "180cce45dffc1a8b30f975fc4a8a6751",
        "538543c861463406d2a9efe322e973da",
        "e2aae3f4a9880ef962602acf22d98fdd",
        "37555a424675908c9b6601b76ebc1b15",
        "d2ed5276432d2ad505c2223dd7c77dfe",
        "e85042ae4ea57b0b08425f1f91e84917",
        "860aba07725a5eeef3fedf69de559cc7",
        "05b3dcab9200e2eed8a55168c7d7b417",
        "e85042ae4ea57b0b08425f1f91e84917",
        "9e56b21f4e22da01a188a93fd60d4f58",
        "102cc82a37520be944890e45a846b299",
        "b33e0e454615c569598088dd864d231f",
        "4beba6e8732fbec1a70c24fff0b15729",
        "e85042ae4ea57b0b08425f1f91e84917",
        "6f9ed26b5e8d3a0d987d3a3cb6a13250",
        "e85042ae4ea57b0b08425f1f91e84917",
        "4cef38d0f6562e5b3f2a9afd1dbb4faa",
        "e85042ae4ea57b0b08425f1f91e84917",
        "9a642f88754ee90a7764a8eb20bcd9f1",
        "986795e65fda2eed4297b9e0ce899357"
      ],
      "date": 1654363932920
    },
    {
      "type": "edit",
      "id": "5244a21fb3f6ced4",
      "item": {
        "type": "markdown",
        "id": "5244a21fb3f6ced4",
        "text": "A *[[Virtual Machine]]* is a synthetic computer. It behaves as a real machine would, if only there were such a machine. Because there isn't, people use a virtual machine to emulate the one they wish they really had. Virtual machines are interesting only because of what they execute. For a Smalltalk virtual machine, that something is called the *[[image]]*. --  LIU, Chamond, 2000. Smalltalk, objects, and design: the classic guide, now in paperback. Reprinted from the original 1996 ed. with minor corrections. San Jose: toExcel. ISBN 978-1-58348-490-6, p. 181\n"
      },
      "date": 1654363933892
    },
    {
      "type": "edit",
      "id": "5562cd6fb18cfaaa",
      "item": {
        "type": "pagefold",
        "id": "5562cd6fb18cfaaa",
        "text": "."
      },
      "date": 1654363936828
    },
    {
      "type": "add",
      "id": "b06c89767b3e68a5",
      "item": {
        "type": "markdown",
        "id": "b06c89767b3e68a5",
        "text": "⇒ "
      },
      "after": "5244a21fb3f6ced4",
      "date": 1654416757197
    },
    {
      "type": "edit",
      "id": "b06c89767b3e68a5",
      "item": {
        "type": "markdown",
        "id": "b06c89767b3e68a5",
        "text": "⇒ [[Image]]"
      },
      "date": 1654416768584
    },
    {
      "type": "fork",
      "site": "http.wiki.ralfbarkow.ch"
    },
    {
      "type": "edit",
      "id": "180cce45dffc1a8b30f975fc4a8a6751",
      "item": {
        "type": "html",
        "text": "Then again, [http://www.bytecodes.com www.bytecodes.com] claims their embedded JVM is comparable to embedded JVMs with JIT compilers because they can stuff the VM runtime into the instruction cache and most programs into the data cache. JIT compilers would thrash both caches very badly. -- [[Sunir Shah]]",
        "id": "180cce45dffc1a8b30f975fc4a8a6751"
      },
      "date": 1655197722456
    }
  ]
}