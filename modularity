{
  "title": "Modularity",
  "story": [
    {
      "type": "paragraph",
      "id": "12467d0c83bf9f03",
      "text": "The entities constructed by programming are extremely complex. Accurate construction of large programs would be impossible without specific techniques for controlling this complexity. Most such techniques are based on finding ways to decompose a problem into almost independently solvable subproblems, allowing a programmer to concentrate on one subproblem at a time, ignoring the others. When the subproblems are solved, the programmer must be able to combine the solutions with a minimum of unanticipated interactions. To the extent that a decomposition succeeds in breaking a programming problem into manageable pieces, we say that the resulting program is [[modular]]; each part of the solution is called a [[Module]]. Well-designed programing languages provide features which support the construction of modular programs ."
    },
    {
      "type": "pagefold",
      "id": "1fff858690cccf98",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "c0ddd4c57cb31523",
      "text": "⇒ [[The Art of the Interpreter]], p. 1"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Modularity",
        "story": []
      },
      "date": 1655284831205
    },
    {
      "item": {
        "type": "factory",
        "id": "12467d0c83bf9f03"
      },
      "id": "12467d0c83bf9f03",
      "type": "add",
      "date": 1655284848144
    },
    {
      "type": "edit",
      "id": "12467d0c83bf9f03",
      "item": {
        "type": "paragraph",
        "id": "12467d0c83bf9f03",
        "text": "The entities constructed by programming are extremely complex.\nAccurate construction of large programs would be impossible without\nspecific techniques for controlling this complexity. Most such techniques\nare based on finding ways to decompose a problem into almost independently\nsolvabl e subproblems , allowing a programmer to concentrate on one\nsubproblem at a time , ignoring the others. When the subproblems are\nsolved , the programmer must be able to combine the solutions with a minimum\nof unanticipated interactions. To the extent that a decomposition succeeds\nin breaking a programming problem into manageable pieces , we say that the\nresulting program is modular ; each part of the solution is called a\nmodule . Well-designed programing languages provide features which support\nthe construction of modular programs ."
      },
      "date": 1655284850280
    },
    {
      "type": "edit",
      "id": "12467d0c83bf9f03",
      "item": {
        "type": "paragraph",
        "id": "12467d0c83bf9f03",
        "text": "The entities constructed by programming are extremely complex.\nAccurate construction of large programs would be impossible without\nspecific techniques for controlling this complexity. Most such techniques\nare based on finding ways to decompose a problem into almost independently\nsolvable subproblems , allowing a programmer to concentrate on one\nsubproblem at a time , ignoring the others. When the subproblems are\nsolved , the programmer must be able to combine the solutions with a minimum\nof unanticipated interactions. To the extent that a decomposition succeeds\nin breaking a programming problem into manageable pieces , we say that the\nresulting program is modular ; each part of the solution is called a\nmodule . Well-designed programing languages provide features which support\nthe construction of modular programs ."
      },
      "date": 1655284877148
    },
    {
      "type": "edit",
      "id": "12467d0c83bf9f03",
      "item": {
        "type": "paragraph",
        "id": "12467d0c83bf9f03",
        "text": "The entities constructed by programming are extremely complex.\nAccurate construction of large programs would be impossible without\nspecific techniques for controlling this complexity. Most such techniques\nare based on finding ways to decompose a problem into almost independently\nsolvable subproblems , allowing a programmer to concentrate on one\nsubproblem at a time , ignoring the others. When the subproblems are\nsolved , the programmer must be able to combine the solutions with a minimum\nof unanticipated interactions. To the extent that a decomposition succeeds\nin breaking a programming problem into manageable pieces , we say that the\nresulting program is [[modular]]; each part of the solution is called a [[module]] . Well-designed programing languages provide features which support\nthe construction of modular programs ."
      },
      "date": 1655284924692
    },
    {
      "type": "edit",
      "id": "12467d0c83bf9f03",
      "item": {
        "type": "paragraph",
        "id": "12467d0c83bf9f03",
        "text": "The entities constructed by programming are extremely complex.\nAccurate construction of large programs would be impossible without\nspecific techniques for controlling this complexity. Most such techniques\nare based on finding ways to decompose a problem into almost independently\nsolvable subproblems , allowing a programmer to concentrate on one\nsubproblem at a time , ignoring the others. When the subproblems are\nsolved , the programmer must be able to combine the solutions with a minimum\nof unanticipated interactions. To the extent that a decomposition succeeds\nin breaking a programming problem into manageable pieces , we say that the\nresulting program is [[modular]]; each part of the solution is called a [[module]]. Well-designed programing languages provide features which support\nthe construction of modular programs ."
      },
      "date": 1655284932060
    },
    {
      "type": "edit",
      "id": "12467d0c83bf9f03",
      "item": {
        "type": "paragraph",
        "id": "12467d0c83bf9f03",
        "text": "The entities constructed by programming are extremely complex.\nAccurate construction of large programs would be impossible without\nspecific techniques for controlling this complexity. Most such techniques\nare based on finding ways to decompose a problem into almost independently\nsolvable subproblems , allowing a programmer to concentrate on one\nsubproblem at a time , ignoring the others. When the subproblems are\nsolved , the programmer must be able to combine the solutions with a minimum\nof unanticipated interactions. To the extent that a decomposition succeeds\nin breaking a programming problem into manageable pieces , we say that the\nresulting program is [[modular]]; each part of the solution is called a [[Module]]. Well-designed programing languages provide features which support\nthe construction of modular programs ."
      },
      "date": 1655284962856
    },
    {
      "item": {
        "type": "factory",
        "id": "1fff858690cccf98"
      },
      "id": "1fff858690cccf98",
      "type": "add",
      "after": "12467d0c83bf9f03",
      "date": 1655284978818
    },
    {
      "type": "edit",
      "id": "1fff858690cccf98",
      "item": {
        "type": "pagefold",
        "id": "1fff858690cccf98",
        "text": "~"
      },
      "date": 1655284982488
    },
    {
      "item": {
        "type": "factory",
        "id": "c0ddd4c57cb31523"
      },
      "id": "c0ddd4c57cb31523",
      "type": "add",
      "after": "1fff858690cccf98",
      "date": 1655287983349
    },
    {
      "type": "edit",
      "id": "c0ddd4c57cb31523",
      "item": {
        "type": "paragraph",
        "id": "c0ddd4c57cb31523",
        "text": "⇒ [[The Art of the Interpreter]], p. "
      },
      "date": 1655287991358
    },
    {
      "type": "edit",
      "id": "c0ddd4c57cb31523",
      "item": {
        "type": "paragraph",
        "id": "c0ddd4c57cb31523",
        "text": "⇒ [[The Art of the Interpreter]], p. 1"
      },
      "date": 1655288050957
    },
    {
      "type": "edit",
      "id": "12467d0c83bf9f03",
      "item": {
        "type": "paragraph",
        "id": "12467d0c83bf9f03",
        "text": "The entities constructed by programming are extremely complex. Accurate construction of large programs would be impossible without specific techniques for controlling this complexity. Most such techniques are based on finding ways to decompose a problem into almost independently solvable subproblems, allowing a programmer to concentrate on one subproblem at a time, ignoring the others. When the subproblems are solved, the programmer must be able to combine the solutions with a minimum of unanticipated interactions. To the extent that a decomposition succeeds in breaking a programming problem into manageable pieces, we say that the resulting program is [[modular]]; each part of the solution is called a [[Module]]. Well-designed programing languages provide features which support the construction of modular programs ."
      },
      "date": 1655288156711
    }
  ]
}