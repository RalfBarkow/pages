{
  "title": "timer-precedence",
  "story": [
    {
      "type": "paragraph",
      "id": "369a95955e6f122a",
      "text": "I do hope you're just reading this article for the entertainment value, because if you really need this information it's time to reevaluate your life choices. Leave your job as a node contributor, instrumentation engineer, or whatever other tedious mess you've gotten yourself into, and pursue your dreams. Computers are awful. Work the land, start a woodcraft shoppe, maybe tend bar. Here be dragons. When you have a lot of timers going at once, the when exactly they are going to fire is one of the [[JavaScript Common Pitfalls]]."
    },
    {
      "type": "paragraph",
      "id": "41c4db75de061ece",
      "text": "If you're in Node, `process.nextTick(fn)` takes precedence. The way to think of it is that nextTick doesn't really fire on the next tick, it latches on to the end of the current tick. Preempting other asynchronous operations."
    },
    {
      "type": "code",
      "id": "1bb7569963fb5c97",
      "text": "var start = Date.now()\n\nfunction recursiveNextTick () {\n  process.nextTick(recursiveNextTick)\n}\n\nrecursiveNextTick()\n\n// Neither of these fire because we are\n// busy nextTicking\nsetImmediate(check('setImmediate 1'))\nsetTimeout(check('setTimeout 1'), 0)\n\nfunction check (name) {\n  return function () {\n    console.log(name + ' time: ' + process.hrtime())\n  }\n}\n"
    },
    {
      "type": "paragraph",
      "id": "88382f57fb0540e8",
      "text": "We've starved the event loop with nextTicks and nothing ever happens again, except an endless line of recursive nextTick function calls. Neither setImmediate or setTimeout ever call back."
    },
    {
      "type": "paragraph",
      "id": "c1aeb7a25cbe4acc",
      "text": "So, that's lame but it's easy to solve. Simply don't recursively call nextTick."
    },
    {
      "type": "paragraph",
      "id": "5e5b46b5d83f33a8",
      "text": "What about the order of setImmediate vs setTimeout? Well, it depends."
    },
    {
      "type": "code",
      "id": "1e126752238e103a",
      "text": "var wait = 0\nvar start = Date.now()\n\nsetImmediate(check('setImmediate 1'))\nsetTimeout(check('setTimeout 1'), 0)\nsetImmediate(check('setImmediate 2'))\nsetImmediate(check('setImmediate 3'))\nsetTimeout(check('setTimeout 2'), 0)\nsetTimeout(check('setTimeout 3'), 0)\n\nwhile(true) {\n  if (Date.now() - start > wait) break\n}\n\nfunction check (name) {\n  return function () {\n    console.log(name + ' time: ' + process.hrtime())\n  }\n}\n\n// Example output\n// setTimeout 1 time: 318799,422057454\n// setImmediate 1 time: 318799,423598869\n// setImmediate 2 time: 318799,424152249\n// setImmediate 3 time: 318799,424209859\n// setTimeout 2 time: 318799,424280131\n// setTimeout 3 time: 318799,424308713"
    },
    {
      "type": "paragraph",
      "id": "7b8c7f2adc008709",
      "text": "In node 0.10 the timeouts and immediates will interleave themselves in any order. The only guarantee is that for a single timer type they will all end up in order. In node 0.12+ all of the setImmediate's will fire at once, but they could be in between any step of the set timeouts. Now, if we wait for a moment after we set the timers before they fire..."
    },
    {
      "type": "code",
      "id": "ec44a3b5faeb95e8",
      "text": "var wait = 10 // Just 10 ms!\nvar start = Date.now()\n\nsetImmediate(check('setImmediate 1'))\nsetTimeout(check('setTimeout 1'), 0)\nsetImmediate(check('setImmediate 2'))\nsetImmediate(check('setImmediate 3'))\nsetTimeout(check('setTimeout 2'), 0)\nsetTimeout(check('setTimeout 3'), 0)\n\nwhile(true) {\n  if (Date.now() - start > wait) break\n}\n\nfunction check (name) {\n  return function () {\n    console.log(name + ' time: ' + process.hrtime())\n  }\n}\n\n// Consistent output\n// setTimeout 1 time: 319368,882589805\n// setTimeout 2 time: 319368,883911971\n// setTimeout 3 time: 319368,884485374\n// setImmediate 1 time: 319368,884904697\n// setImmediate 2 time: 319368,884962995\n// setImmediate 3 time: 319368,884991232"
    },
    {
      "type": "paragraph",
      "id": "73b0394dd0d57cd2",
      "text": "All of a sudden all three setTimeouts come in order first, before the setImmediate calls. By adding a little bit of synchronous processing time we ensure that the setTimeout timers are up before the function returns. Since the 'setTimeout' queue has higher precedence than the 'setImmediate' queue, when the timeouts are ready, they preempt the immediates!"
    },
    {
      "type": "paragraph",
      "id": "6cddc7460d93351f",
      "text": "We have the potential to introduce race conditions that are not only platform version dependent, but also execution time dependent. Have to serialize a larger than normal JSON blob? Well, it might reorder your timers. Whoops."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "timer-precedence",
        "story": []
      },
      "date": 1434085706744
    },
    {
      "item": {
        "type": "factory",
        "id": "2b9908b30ef5a8a7"
      },
      "id": "2b9908b30ef5a8a7",
      "type": "add",
      "date": 1434085728616
    },
    {
      "type": "remove",
      "id": "2b9908b30ef5a8a7",
      "date": 1434085871123
    },
    {
      "item": {
        "type": "factory",
        "id": "369a95955e6f122a"
      },
      "id": "369a95955e6f122a",
      "type": "add",
      "date": 1434090237011
    },
    {
      "type": "edit",
      "id": "369a95955e6f122a",
      "item": {
        "type": "paragraph",
        "id": "369a95955e6f122a",
        "text": "I do hope you're just reading this article for the entertainment value, because if you really need this information it's time to reevaluate your life choices. Leave your job as a node contributor, instrumentation engineer, or whatever other tedious mess you've gotten yourself into, and pursue your dreams. Computers are awful. Work the land, start a woodcraft shoppe, maybe tend bar. Here be dragons. When you have a lot of timers going at once, the when exactly they are going to fire is one of the [[JavaScript Common Pitfalls]]."
      },
      "date": 1434090853356
    },
    {
      "type": "add",
      "id": "41c4db75de061ece",
      "item": {
        "type": "paragraph",
        "id": "41c4db75de061ece",
        "text": "If you're in Node, `process.nextTick(fn)` takes precedence. The way to think of it is that nextTick doesn't really fire on the next tick, it latches on to the end of the current tick. Preempting other asynchronous operations."
      },
      "after": "369a95955e6f122a",
      "date": 1434090935674
    },
    {
      "item": {
        "type": "factory",
        "id": "1bb7569963fb5c97"
      },
      "id": "1bb7569963fb5c97",
      "type": "add",
      "after": "41c4db75de061ece",
      "date": 1434090937562
    },
    {
      "type": "edit",
      "id": "1bb7569963fb5c97",
      "item": {
        "type": "code",
        "id": "1bb7569963fb5c97",
        "text": "var start = Date.now()\n\nfunction recursiveNextTick () {\n  process.nextTick(recursiveNextTick)\n}\n\nrecursiveNextTick()\n\n// Neither of these fire because we are\n// busy nextTicking\nsetImmediate(check('setImmediate 1'))\nsetTimeout(check('setTimeout 1'), 0)\n\nfunction check (name) {\n  return function () {\n    console.log(name + ' time: ' + process.hrtime())\n  }\n}\n"
      },
      "date": 1434090964950
    },
    {
      "item": {
        "type": "factory",
        "id": "88382f57fb0540e8"
      },
      "id": "88382f57fb0540e8",
      "type": "add",
      "after": "1bb7569963fb5c97",
      "date": 1434090974197
    },
    {
      "type": "edit",
      "id": "88382f57fb0540e8",
      "item": {
        "type": "paragraph",
        "id": "88382f57fb0540e8",
        "text": "We've starved the event loop with nextTicks and nothing ever happens again, except an endless line of recursive nextTick function calls. Neither setImmediate or setTimeout ever call back."
      },
      "date": 1434091072527
    },
    {
      "type": "add",
      "id": "c1aeb7a25cbe4acc",
      "item": {
        "type": "paragraph",
        "id": "c1aeb7a25cbe4acc",
        "text": "So, that's lame but it's easy to solve. Simply don't recursively call nextTick."
      },
      "after": "88382f57fb0540e8",
      "date": 1434091156608
    },
    {
      "type": "add",
      "id": "5e5b46b5d83f33a8",
      "item": {
        "type": "paragraph",
        "id": "5e5b46b5d83f33a8",
        "text": "What about the order of setImmediate vs setTimeout? Well, it depends."
      },
      "after": "c1aeb7a25cbe4acc",
      "date": 1434091251423
    },
    {
      "item": {
        "type": "factory",
        "id": "1e126752238e103a"
      },
      "id": "1e126752238e103a",
      "type": "add",
      "after": "5e5b46b5d83f33a8",
      "date": 1434091579413
    },
    {
      "type": "edit",
      "id": "1e126752238e103a",
      "item": {
        "type": "code",
        "id": "1e126752238e103a",
        "text": "var wait = 0\nvar start = Date.now()\n\nsetImmediate(check('setImmediate 1'))\nsetTimeout(check('setTimeout 1'), 0)\nsetImmediate(check('setImmediate 2'))\nsetImmediate(check('setImmediate 3'))\nsetTimeout(check('setTimeout 2'), 0)\nsetTimeout(check('setTimeout 3'), 0)\n\nwhile(true) {\n  if (Date.now() - start > wait) break\n}\n\nfunction check (name) {\n  return function () {\n    console.log(name + ' time: ' + process.hrtime())\n  }\n}"
      },
      "date": 1434091584130
    },
    {
      "item": {
        "type": "factory",
        "id": "7b8c7f2adc008709"
      },
      "id": "7b8c7f2adc008709",
      "type": "add",
      "after": "1e126752238e103a",
      "date": 1434091591141
    },
    {
      "type": "edit",
      "id": "7b8c7f2adc008709",
      "item": {
        "type": "paragraph",
        "id": "7b8c7f2adc008709",
        "text": "In node 0.10 the timeouts and immediates will interleave themselves in any order. The only guarantee is that for a single timer type they will all end up in order. In node 0.12+ all of the setImmediate's will fire at once, but they could be in between any step of the set timeouts. Now, if we wait for a moment after we set the timers before they fire..."
      },
      "date": 1434091765120
    },
    {
      "item": {
        "type": "factory",
        "id": "ec44a3b5faeb95e8"
      },
      "id": "ec44a3b5faeb95e8",
      "type": "add",
      "after": "7b8c7f2adc008709",
      "date": 1434091769425
    },
    {
      "type": "edit",
      "id": "ec44a3b5faeb95e8",
      "item": {
        "type": "code",
        "id": "ec44a3b5faeb95e8",
        "text": "var wait = 10 // Just 10 ms!\nvar start = Date.now()\n\nsetImmediate(check('setImmediate 1'))\nsetTimeout(check('setTimeout 1'), 0)\nsetImmediate(check('setImmediate 2'))\nsetImmediate(check('setImmediate 3'))\nsetTimeout(check('setTimeout 2'), 0)\nsetTimeout(check('setTimeout 3'), 0)\n\nwhile(true) {\n  if (Date.now() - start > wait) break\n}\n\nfunction check (name) {\n  return function () {\n    console.log(name + ' time: ' + process.hrtime())\n  }\n}"
      },
      "date": 1434091921085
    },
    {
      "item": {
        "type": "factory",
        "id": "73b0394dd0d57cd2"
      },
      "id": "73b0394dd0d57cd2",
      "type": "add",
      "after": "ec44a3b5faeb95e8",
      "date": 1434091957703
    },
    {
      "type": "edit",
      "id": "73b0394dd0d57cd2",
      "item": {
        "type": "paragraph",
        "id": "73b0394dd0d57cd2",
        "text": "All of a sudden all three setTimeouts come in order first, before the setImmediate calls. By adding a little bit of synchronous processing time we ensure that the setTimeout timers are up before the function returns. Since the 'setTimeout' queue has higher precedence than the 'setImmediate' queue, when the timeouts are ready, they preempt the immediates!"
      },
      "date": 1434092126426
    },
    {
      "type": "edit",
      "id": "ec44a3b5faeb95e8",
      "item": {
        "type": "code",
        "id": "ec44a3b5faeb95e8",
        "text": "var wait = 10 // Just 10 ms!\nvar start = Date.now()\n\nsetImmediate(check('setImmediate 1'))\nsetTimeout(check('setTimeout 1'), 0)\nsetImmediate(check('setImmediate 2'))\nsetImmediate(check('setImmediate 3'))\nsetTimeout(check('setTimeout 2'), 0)\nsetTimeout(check('setTimeout 3'), 0)\n\nwhile(true) {\n  if (Date.now() - start > wait) break\n}\n\nfunction check (name) {\n  return function () {\n    console.log(name + ' time: ' + process.hrtime())\n  }\n}\n\n// Consistent output\n// setTimeout 1 time: 319368,882589805\n// setTimeout 2 time: 319368,883911971\n// setTimeout 3 time: 319368,884485374\n// setImmediate 1 time: 319368,884904697\n// setImmediate 2 time: 319368,884962995\n// setImmediate 3 time: 319368,884991232"
      },
      "date": 1434092193289
    },
    {
      "type": "edit",
      "id": "1e126752238e103a",
      "item": {
        "type": "code",
        "id": "1e126752238e103a",
        "text": "var wait = 0\nvar start = Date.now()\n\nsetImmediate(check('setImmediate 1'))\nsetTimeout(check('setTimeout 1'), 0)\nsetImmediate(check('setImmediate 2'))\nsetImmediate(check('setImmediate 3'))\nsetTimeout(check('setTimeout 2'), 0)\nsetTimeout(check('setTimeout 3'), 0)\n\nwhile(true) {\n  if (Date.now() - start > wait) break\n}\n\nfunction check (name) {\n  return function () {\n    console.log(name + ' time: ' + process.hrtime())\n  }\n}\n\n// Example output\n// setImmediate 1 time: 318803,12"
      },
      "date": 1434092334074
    },
    {
      "type": "edit",
      "id": "1e126752238e103a",
      "item": {
        "type": "code",
        "id": "1e126752238e103a",
        "text": "var wait = 0\nvar start = Date.now()\n\nsetImmediate(check('setImmediate 1'))\nsetTimeout(check('setTimeout 1'), 0)\nsetImmediate(check('setImmediate 2'))\nsetImmediate(check('setImmediate 3'))\nsetTimeout(check('setTimeout 2'), 0)\nsetTimeout(check('setTimeout 3'), 0)\n\nwhile(true) {\n  if (Date.now() - start > wait) break\n}\n\nfunction check (name) {\n  return function () {\n    console.log(name + ' time: ' + process.hrtime())\n  }\n}\n\n// Example output\n// setTimeout 1 time: 318799,422057454\n// setImmediate 1 time: 318799,423598869\n// setImmediate 2 time: 318799,424152249\n// setImmediate 3 time: 318799,424209859\n// setTimeout 2 time: 318799,424280131\n// setTimeout 3 time: 318799,424308713"
      },
      "date": 1434092388952
    },
    {
      "item": {
        "type": "factory",
        "id": "6cddc7460d93351f"
      },
      "id": "6cddc7460d93351f",
      "type": "add",
      "after": "73b0394dd0d57cd2",
      "date": 1434092399488
    },
    {
      "type": "edit",
      "id": "6cddc7460d93351f",
      "item": {
        "type": "paragraph",
        "id": "6cddc7460d93351f",
        "text": "We have the potential to introduce race conditions that are not only platform version dependent, but also execution time dependent. Have to serialize a larger than normal JSON blob? Well, it might reorder your timers."
      },
      "date": 1434092494639
    },
    {
      "type": "remove",
      "id": "c89f650150017b10",
      "date": 1434093329862
    },
    {
      "type": "edit",
      "id": "6cddc7460d93351f",
      "item": {
        "type": "paragraph",
        "id": "6cddc7460d93351f",
        "text": "We have the potential to introduce race conditions that are not only platform version dependent, but also execution time dependent. Have to serialize a larger than normal JSON blob? Well, it might reorder your timers. Whoops."
      },
      "date": 1434094008733
    },
    {
      "type": "fork",
      "site": "nrn.io",
      "date": 1652868785466
    }
  ]
}