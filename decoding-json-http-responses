{
  "title": "Decoding JSON HTTP Responses",
  "story": [
    {
      "type": "paragraph",
      "id": "6573146c03fef928",
      "text": "We’ve already seen how we can use Http.expectString to obtain a String from a server, and how we can use decodeString and a Decoder to translate a String into a list of Photo records for our Model."
    },
    {
      "type": "paragraph",
      "id": "91d540c410cefaab",
      "text": "Although we could use Http.expectString and decodeString to populate our Model in this way, there is another function in the Http module which will take care of both for us."
    },
    {
      "type": "markdown",
      "id": "229564fce51c98c9",
      "text": "# Http.expectJson "
    },
    {
      "type": "paragraph",
      "id": "7aa13f85ac0b29a7",
      "text": "The Http.expectJson function requests data from a server and then decodes it. Here is how the types of Http.expectString and Http.expectJson match up:"
    },
    {
      "type": "code",
      "id": "be1ffc36044a166e",
      "text": "expectString : (Result Http.Error String -> msg) -> Expect msg"
    },
    {
      "type": "code",
      "id": "393a9cffde571f24",
      "text": "expectJson : (Result Http.Error val -> msg) -> Decoder val -> Expect msg"
    },
    {
      "type": "paragraph",
      "id": "7aab88c45b3676a5",
      "text": "Comparing types like this suggests how these functions are similar and how they differ. They both accept a function to translate a Result into a msg. Both Result types have Http.Error as its Err type. However, where expectString takes no other arguments and always produces a String for its Result’s Ok type, getJson additionally accepts a Decoder val, and on success produces an Ok val result instead of Ok String."
    },
    {
      "type": "paragraph",
      "id": "1676243978b06e3f",
      "text": "As you might expect, if we give Http.expectJson a decoder of (list int) and the response it gets back is the JSON payload \"[1, 2, 3]\", then Http.get will successfully decode that into Ok (List Int). If decoding fails, we will instead get Err BadBody."
    },
    {
      "type": "markdown",
      "id": "f7475a27c785908e",
      "text": "# The BadBody Error"
    },
    {
      "type": "paragraph",
      "id": "6eb32de978330a6b",
      "text": "What’s BadBody? It’s a variant of that Http.Error type […] Http.Error is a custom type that describes various ways an HTTP request can fail. It looks like this:"
    },
    {
      "type": "code",
      "id": "afc5f25d831323a1",
      "text": "type Error\n    = BadUrl String\n    | Timeout\n    | NetworkError\n    | BadStatus Int\n    | BadBody String"
    },
    {
      "type": "paragraph",
      "id": "96ed6b8f82bdc8f3",
      "text": "The BadBody variant occurs when the body of the HTTP response failed to decode properly. Because Error is a custom type, we can run a case-expression on any Http.Error value — with different branches for Timeout, NetworkError, and so on — to do custom error handling based on what went wrong. "
    },
    {
      "type": "paragraph",
      "id": "8d200b2709a8bf92",
      "text": "Tip: The lower-level Http.request function lets you customize requests in greater depth than Http.get does.\n"
    },
    {
      "type": "paragraph",
      "id": "84ad8caa4bbfaad1",
      "text": "[…]"
    },
    {
      "type": "pagefold",
      "id": "a762146452923ac0",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "ad5e330021168bfd",
      "text": "FELDMAN, Richard, 2020. Elm in action. Shelter Island, NY: Manning. ISBN 978-1-61729-404-4, p.117–119"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Decoding JSON HTTP Responses",
        "story": []
      },
      "date": 1685608031719
    },
    {
      "item": {
        "type": "factory",
        "id": "6573146c03fef928"
      },
      "id": "6573146c03fef928",
      "type": "add",
      "date": 1685608040795
    },
    {
      "type": "edit",
      "id": "6573146c03fef928",
      "item": {
        "type": "paragraph",
        "id": "6573146c03fef928",
        "text": "We’ve already seen how we can use Http.expectString to obtain a String from a server, and how we can use decodeString and a Decoder to translate a String into a list of Photo records for our Model."
      },
      "date": 1685608042296
    },
    {
      "item": {
        "type": "factory",
        "id": "ad5e330021168bfd"
      },
      "id": "ad5e330021168bfd",
      "type": "add",
      "after": "6573146c03fef928",
      "date": 1685608087986
    },
    {
      "type": "edit",
      "id": "ad5e330021168bfd",
      "item": {
        "type": "paragraph",
        "id": "ad5e330021168bfd",
        "text": "\nFELDMAN, Richard, 2020. Elm in action. . Shelter Island, NY: Manning Publications Co. ISBN 978-1-61729-404-4. QA76.625 .F44 2020Simply put, the Elm programming language transforms the way you think about frontend web development. Elm’s legendary compiler is an incredible assistant, giving you the precise and user-friendly support you need to work efficiently. Elm applications have small bundle sizes that run faster than JavaScript frameworks and are famously easy to maintain as they grow. The catch? Elm isn’t JavaScript, so you’ll have some new skills to learn. “Elm in action” teaches you the Elm language along with a new approach to coding frontend applications. Chapter by chapter, you’ll create a full-featured photo-browsing app, learning as you go about Elm’s modular architecture, Elm testing, and how to work seamlessly with your favorite JavaScript libraries. You’ll especially appreciate author and Elm core team member Richard Feldman’s unique insights, based on his thousands of hours writing production code in Elm. When you’re done, you’ll have a toolbox of new development skills and a stunning web app for your portfolio\n"
      },
      "date": 1685608091003
    },
    {
      "item": {
        "type": "factory",
        "id": "a762146452923ac0"
      },
      "id": "a762146452923ac0",
      "type": "add",
      "after": "ad5e330021168bfd",
      "date": 1685608094285
    },
    {
      "id": "a762146452923ac0",
      "type": "move",
      "order": [
        "6573146c03fef928",
        "a762146452923ac0",
        "ad5e330021168bfd"
      ],
      "date": 1685608097765
    },
    {
      "type": "edit",
      "id": "a762146452923ac0",
      "item": {
        "type": "pagefold",
        "id": "a762146452923ac0",
        "text": "~"
      },
      "date": 1685608100758
    },
    {
      "type": "edit",
      "id": "ad5e330021168bfd",
      "item": {
        "type": "paragraph",
        "id": "ad5e330021168bfd",
        "text": "FELDMAN, Richard, 2020. Elm in action. Shelter Island, NY: Manning. ISBN 978-1-61729-404-4, p.117–119"
      },
      "date": 1685608211094
    },
    {
      "type": "add",
      "id": "91d540c410cefaab",
      "item": {
        "type": "paragraph",
        "id": "91d540c410cefaab",
        "text": "Although we could use Http.expectString and decodeString to populate our Model in this way, there is another function in the Http module which will take care of both for us."
      },
      "after": "6573146c03fef928",
      "date": 1685608244517
    },
    {
      "type": "add",
      "id": "229564fce51c98c9",
      "item": {
        "type": "paragraph",
        "id": "229564fce51c98c9",
        "text": "# HTTP.EXPECTJSON"
      },
      "after": "91d540c410cefaab",
      "date": 1685608258347
    },
    {
      "type": "edit",
      "id": "229564fce51c98c9",
      "item": {
        "type": "paragraph",
        "id": "229564fce51c98c9",
        "text": "# Http.expectJson "
      },
      "date": 1685608288769
    },
    {
      "type": "add",
      "id": "7aa13f85ac0b29a7",
      "item": {
        "type": "paragraph",
        "id": "7aa13f85ac0b29a7",
        "text": "The Http.expectJson function requests data from a server and then decodes it. Here is how the types of Http.expectString and Http.expectJson match up:"
      },
      "after": "229564fce51c98c9",
      "date": 1685608302966
    },
    {
      "type": "edit",
      "id": "229564fce51c98c9",
      "item": {
        "type": "markdown",
        "id": "229564fce51c98c9",
        "text": "# Http.expectJson "
      },
      "date": 1685608304108
    },
    {
      "item": {
        "type": "factory",
        "id": "be1ffc36044a166e"
      },
      "id": "be1ffc36044a166e",
      "type": "add",
      "after": "ad5e330021168bfd",
      "date": 1685608325432
    },
    {
      "id": "be1ffc36044a166e",
      "type": "move",
      "order": [
        "6573146c03fef928",
        "91d540c410cefaab",
        "229564fce51c98c9",
        "7aa13f85ac0b29a7",
        "be1ffc36044a166e",
        "a762146452923ac0",
        "ad5e330021168bfd"
      ],
      "date": 1685608327441
    },
    {
      "type": "edit",
      "id": "be1ffc36044a166e",
      "item": {
        "type": "code",
        "id": "be1ffc36044a166e",
        "text": "expectString : (Result Http.Error String -> msg) -> Expect msg expectJson : (Result Http.Error val -> msg) -> Decoder val -> Expect msg"
      },
      "date": 1685608329179
    },
    {
      "type": "edit",
      "id": "be1ffc36044a166e",
      "item": {
        "type": "code",
        "id": "be1ffc36044a166e",
        "text": "expectString : (Result Http.Error String -> msg) -> Expect msg \nexpectJson : (Result Http.Error val -> msg) -> Decoder val -> Expect msg"
      },
      "date": 1685608343472
    },
    {
      "item": {
        "type": "factory",
        "id": "393a9cffde571f24"
      },
      "id": "393a9cffde571f24",
      "type": "add",
      "after": "ad5e330021168bfd",
      "date": 1685608362256
    },
    {
      "id": "393a9cffde571f24",
      "type": "move",
      "order": [
        "6573146c03fef928",
        "91d540c410cefaab",
        "229564fce51c98c9",
        "7aa13f85ac0b29a7",
        "be1ffc36044a166e",
        "393a9cffde571f24",
        "a762146452923ac0",
        "ad5e330021168bfd"
      ],
      "date": 1685608364554
    },
    {
      "type": "edit",
      "id": "be1ffc36044a166e",
      "item": {
        "type": "code",
        "id": "be1ffc36044a166e",
        "text": "expectString : (Result Http.Error String -> msg) -> Expect msg"
      },
      "date": 1685608370249
    },
    {
      "type": "edit",
      "id": "393a9cffde571f24",
      "item": {
        "type": "code",
        "id": "393a9cffde571f24",
        "text": "expectJson : (Result Http.Error val -> msg) -> Decoder val -> Expect msg"
      },
      "date": 1685608372112
    },
    {
      "type": "add",
      "id": "7aab88c45b3676a5",
      "item": {
        "type": "paragraph",
        "id": "7aab88c45b3676a5",
        "text": "Comparing types like this suggests how these functions are similar and how they differ."
      },
      "after": "7aa13f85ac0b29a7",
      "date": 1685608400196
    },
    {
      "id": "7aab88c45b3676a5",
      "type": "move",
      "order": [
        "6573146c03fef928",
        "91d540c410cefaab",
        "229564fce51c98c9",
        "7aa13f85ac0b29a7",
        "be1ffc36044a166e",
        "393a9cffde571f24",
        "7aab88c45b3676a5",
        "a762146452923ac0",
        "ad5e330021168bfd"
      ],
      "date": 1685608403029
    },
    {
      "type": "add",
      "id": "44cb683bcb778019",
      "item": {
        "type": "paragraph",
        "id": "44cb683bcb778019",
        "text": "They both accept a function to translate a Result into a msg. Both Result types have Http.Error as its Err type. However, where expectString takes no other arguments and always produces a String for its Result’s Ok type, getJson additionally accepts a Decoder val, and on success produces an Ok val result instead of Ok String."
      },
      "after": "7aab88c45b3676a5",
      "date": 1685608424171
    },
    {
      "type": "add",
      "id": "1676243978b06e3f",
      "item": {
        "type": "paragraph",
        "id": "1676243978b06e3f",
        "text": "As you might expect, if we give Http.expectJson a decoder of (list int) and the response it gets back is the JSON payload \"[1, 2, 3]\", then Http.get will successfully decode that into Ok (List Int). If decoding fails, we will instead get Err BadPayload."
      },
      "after": "44cb683bcb778019",
      "date": 1685608465375
    },
    {
      "type": "remove",
      "id": "44cb683bcb778019",
      "date": 1685608650712
    },
    {
      "type": "edit",
      "id": "7aab88c45b3676a5",
      "item": {
        "type": "paragraph",
        "id": "7aab88c45b3676a5",
        "text": "Comparing types like this suggests how these functions are similar and how they differ. They both accept a function to translate a Result into a msg. Both Result types have Http.Error as its Err type. However, where expectString takes no other arguments and always produces a String for its Result’s Ok type, getJson additionally accepts a Decoder val, and on success produces an Ok val result instead of Ok String."
      },
      "date": 1685608653905
    },
    {
      "type": "edit",
      "id": "1676243978b06e3f",
      "item": {
        "type": "paragraph",
        "id": "1676243978b06e3f",
        "text": "As you might expect, if we give Http.expectJson a decoder of (list int) and the response it gets back is the JSON payload \"[1, 2, 3]\", then Http.get will successfully decode that into Ok (List Int). If decoding fails, we will instead get Err BadBody."
      },
      "date": 1685608758931
    },
    {
      "type": "add",
      "id": "f7475a27c785908e",
      "item": {
        "type": "paragraph",
        "id": "f7475a27c785908e",
        "text": "# The BadBody Error"
      },
      "after": "1676243978b06e3f",
      "date": 1685608802139
    },
    {
      "type": "add",
      "id": "6eb32de978330a6b",
      "item": {
        "type": "paragraph",
        "id": "6eb32de978330a6b",
        "text": "What’s BadBody? It’s a variant for that Http.Error type we said we’d get back to! (Sure enough, here we are getting back to it.) Http.Error is a custom type which describes various ways a HTTP request can fail. It looks like this:"
      },
      "after": "f7475a27c785908e",
      "date": 1685608833999
    },
    {
      "type": "edit",
      "id": "f7475a27c785908e",
      "item": {
        "type": "markdown",
        "id": "f7475a27c785908e",
        "text": "# The BadBody Error"
      },
      "date": 1685608835408
    },
    {
      "type": "edit",
      "id": "6eb32de978330a6b",
      "item": {
        "type": "paragraph",
        "id": "6eb32de978330a6b",
        "text": "What’s BadBody? It’s a variant of that Http.Error type we said we’d get back to! (Sure enough, here we are getting back to it.) Http.Error is a custom type that describes various ways ans HTTP request can fail. It looks like this:"
      },
      "date": 1685609393293
    },
    {
      "item": {
        "type": "factory",
        "id": "afc5f25d831323a1"
      },
      "id": "afc5f25d831323a1",
      "type": "add",
      "after": "ad5e330021168bfd",
      "date": 1685609403965
    },
    {
      "id": "afc5f25d831323a1",
      "type": "move",
      "order": [
        "6573146c03fef928",
        "91d540c410cefaab",
        "229564fce51c98c9",
        "7aa13f85ac0b29a7",
        "be1ffc36044a166e",
        "393a9cffde571f24",
        "7aab88c45b3676a5",
        "1676243978b06e3f",
        "f7475a27c785908e",
        "6eb32de978330a6b",
        "afc5f25d831323a1",
        "a762146452923ac0",
        "ad5e330021168bfd"
      ],
      "date": 1685609405954
    },
    {
      "type": "edit",
      "id": "afc5f25d831323a1",
      "item": {
        "type": "code",
        "id": "afc5f25d831323a1",
        "text": "type Error = BadUrl String | Timeout | NetworkError | BadStatus (Response String) | BadPayload String (Response String)"
      },
      "date": 1685609408899
    },
    {
      "type": "edit",
      "id": "afc5f25d831323a1",
      "item": {
        "type": "code",
        "id": "afc5f25d831323a1",
        "text": "type Error\n    = BadUrl String\n    | Timeout\n    | NetworkError\n    | BadStatus (Response String)\n    | BadPayload String (Response String)"
      },
      "date": 1685609441149
    },
    {
      "type": "edit",
      "id": "afc5f25d831323a1",
      "item": {
        "type": "code",
        "id": "afc5f25d831323a1",
        "text": "type Error\n    = BadUrl String\n    | Timeout\n    | NetworkError\n    | BadStatus Int\n    | BadBody String"
      },
      "date": 1685609475943
    },
    {
      "item": {
        "type": "factory",
        "id": "96ed6b8f82bdc8f3"
      },
      "id": "96ed6b8f82bdc8f3",
      "type": "add",
      "after": "ad5e330021168bfd",
      "date": 1685609659500
    },
    {
      "id": "96ed6b8f82bdc8f3",
      "type": "move",
      "order": [
        "6573146c03fef928",
        "91d540c410cefaab",
        "229564fce51c98c9",
        "7aa13f85ac0b29a7",
        "be1ffc36044a166e",
        "393a9cffde571f24",
        "7aab88c45b3676a5",
        "1676243978b06e3f",
        "f7475a27c785908e",
        "6eb32de978330a6b",
        "afc5f25d831323a1",
        "96ed6b8f82bdc8f3",
        "a762146452923ac0",
        "ad5e330021168bfd"
      ],
      "date": 1685609661076
    },
    {
      "type": "edit",
      "id": "96ed6b8f82bdc8f3",
      "item": {
        "type": "paragraph",
        "id": "96ed6b8f82bdc8f3",
        "text": "The BadBody variant occurs when the body of the HTTP response failed to decode properly. Because Error is a custom type, we can run a case-expression on any Http.Error value—with different branches for Timeout, NetworkError, and so on—to do custom error handling based on what went wrong. "
      },
      "date": 1685609662487
    },
    {
      "type": "edit",
      "id": "96ed6b8f82bdc8f3",
      "item": {
        "type": "paragraph",
        "id": "96ed6b8f82bdc8f3",
        "text": "The BadBody variant occurs when the body of the HTTP response failed to decode properly. Because Error is a custom type, we can run a case-expression on any Http.Error value — with different branches for Timeout, NetworkError, and so on — to do custom error handling based on what went wrong. "
      },
      "date": 1685609701932
    },
    {
      "type": "add",
      "id": "8d200b2709a8bf92",
      "item": {
        "type": "paragraph",
        "id": "8d200b2709a8bf92",
        "text": "Tip\n\nThe lower-level Http.request function lets you customize requests in greater depth than Http.get does.\n"
      },
      "after": "96ed6b8f82bdc8f3",
      "date": 1685609740524
    },
    {
      "type": "edit",
      "id": "8d200b2709a8bf92",
      "item": {
        "type": "paragraph",
        "id": "8d200b2709a8bf92",
        "text": "Tip: The lower-level Http.request function lets you customize requests in greater depth than Http.get does.\n"
      },
      "date": 1685609747354
    },
    {
      "type": "add",
      "id": "84ad8caa4bbfaad1",
      "item": {
        "type": "paragraph",
        "id": "84ad8caa4bbfaad1",
        "text": "[…]"
      },
      "after": "8d200b2709a8bf92",
      "date": 1685609775819
    },
    {
      "type": "edit",
      "id": "6eb32de978330a6b",
      "item": {
        "type": "paragraph",
        "id": "6eb32de978330a6b",
        "text": "What’s BadBody? It’s a variant of that Http.Error type […] Http.Error is a custom type that describes various ways ans HTTP request can fail. It looks like this:"
      },
      "date": 1685609824164
    },
    {
      "type": "edit",
      "id": "6eb32de978330a6b",
      "item": {
        "type": "paragraph",
        "id": "6eb32de978330a6b",
        "text": "What’s BadBody? It’s a variant of that Http.Error type […] Http.Error is a custom type that describes various ways an HTTP request can fail. It looks like this:"
      },
      "date": 1685609842859
    }
  ]
}