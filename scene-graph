{
  "title": "Scene Graph",
  "story": [
    {
      "type": "html",
      "text": "Most graphics APIs are state-based.  The program sets up drawing state in the display manager that defines the colour, font, translation, fill texture, etc. used by drawing operations.  This reduces the amount of data that needs to be passed across the kernel boundary or network for each drawing operation.",
      "id": "443531199fdf8f7a7f038772c209891b"
    },
    {
      "type": "html",
      "text": "<b>How do you make [[Structured Graphics]] composable?</b>",
      "id": "1d5183c755db26d879c0ff3af6870968"
    },
    {
      "type": "html",
      "text": "\nIf you are writing a graphics program that uses [[Structured Graphics]], you may want to define a composite shape and then draw it in different places on the display, at a different size, rotated or in a different colour. ",
      "id": "eff4ff90c7ddbe3ff4576e7635c7c566"
    },
    {
      "type": "html",
      "text": "\nTherefore:",
      "id": "2eee91ad6bde1a356a9892119a14c237"
    },
    {
      "type": "html",
      "text": "<b>Each [[Structured Graphics]] object should encapsulate a modification to the drawing state held in the display manager, such as the [[Single Transform]]. Composing graphical objects will cause the child to inherit the drawing state created by its tree of containers.</b>",
      "id": "5ff9f8c3525c31a57020016252b72353"
    },
    {
      "type": "html",
      "text": "\nDefine the visual objects using a [[Directed Acyclic Graph]] (DAG) in which the leaves represent primitive shapes and intermediate nodes either encapsulate a small, reversible change to the state of the display manager that is applied to a single subgraph or compose multiple subgraphs.",
      "id": "9a8e2d01294d2f91ff4549cf09581b39"
    },
    {
      "type": "html",
      "text": "\nDrawing is performed by walking over the graph in depth-first order, performing the following operations on the various types of nodes:",
      "id": "6c40c49fefdc5cfd93ae6cfed30cf01d"
    },
    {
      "type": "html",
      "text": " <i>Intermediate Nodes</i>:<br>apply the state change to the display manager, draw the subgraph, then reverse the state change in the display manager.",
      "id": "a9703b00011d21d5415e418269d87b99"
    },
    {
      "type": "html",
      "text": " <i>Composite Nodes</i>:<br>draw each of their subgraphs in turn.  Advanced systems can implement other composition operators, such as constructive area (or solid) geometry (CAG or CSG).",
      "id": "2fc1c737edf9e74ddae3223f32a37225"
    },
    {
      "type": "html",
      "text": " <i>Leaf Nodes</i>:<br>draw a primitive shape.  The drawing will be affected by all the state changes applied to the display manager while traversing the graph.",
      "id": "d0fd0fe985aa1088b87fe2b00e9ba210"
    },
    {
      "type": "html",
      "text": "\nA shape can be drawn multiple times, with different transformations and other properties, by defining it once and then linking it into different parts of the graph so that different transformations are applied to it each time it is visited during the graph traversal.",
      "id": "2a64421f513a87f406a01ab4a759a783"
    },
    {
      "type": "html",
      "text": "However, compared to a simple [[Structured Graphics]] framework, it is harder to map from the leaves of a Scene Graph to areas of the display, because arbitrary transformations can be applied to the shapes at the leaves of the graph.  These calculations are required to calculate minimim [[Refresh Rectangles]] or to implement interactivity. \nSuch mappings must be performed by walking over the graph, keeping track of transformations by performing the matrix multiplications in the visitor.  \nEven though this is computationally more expensive than algorithms required by a simple [[Structured Graphics]] framework, it can still reduce the drawing time significantly when used to calculate minimum [[Refresh Rectangles]].",
      "id": "0fe000c3df03c6b51ae93f19ce0a9712"
    },
    {
      "type": "html",
      "text": "A Scene Graph is often used as a high-level interface for assembling [[Compiled Graphic Commands]].",
      "id": "84d6c686729e219dbd5b3ad57400dcf4"
    },
    {
      "type": "html",
      "text": "A [[Render Graph]] is an optimisation of the Scene Graph model.",
      "id": "35732e29387773d625c60bf9105fab5d"
    },
    {
      "type": "html",
      "text": "This pattern is widely used in toolkits for 3D graphics.  In particular, Open<i></i>Inventor, [[Open Scene Graph]] and Java3D all use \nScene Graphs to structure scenes.  It is less widely used in 2D graphics.  Examples include the [[Morphic Interface]] framework in the [[Self Language]] and [[Squeak Smalltalk]], the [[Scene Beans]] and Jazz toolkits for Java, the [[Gnome Canvas]] display widget, and the SVG graphics file format defined by the W3C.",
      "id": "2c399d50380386b33bf66da1c7bd6aa7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7033cb91268bc95d480ff1e19a827e76"
    },
    {
      "type": "html",
      "text": "Also see [[Graphics Patterns]], [[Interactive Scene Graph]], [[Document Object Model]]",
      "id": "3a95d20297ac4c721c8367d065525994"
    },
    {
      "type": "html",
      "text": "\n[[Category Pattern]]",
      "id": "dab50fa963bc16a144315637f44cb722"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?SceneGraph c2.com]",
      "id": "ff8d5db0cb71f5828cbde2642e1c350a"
    }
  ],
  "journal": [
    {
      "date": 1238701393000,
      "id": "131a25237c06aa59c8a55263a690e2c4",
      "type": "create",
      "item": {
        "title": "Scene Graph",
        "story": [
          {
            "type": "html",
            "text": "Most graphics APIs are state-based.  The program sets up drawing state in the display manager that defines the colour, font, translation, fill texture, etc. used by drawing operations.  This reduces the amount of data that needs to be passed across the kernel boundary or network for each drawing operation.",
            "id": "443531199fdf8f7a7f038772c209891b"
          },
          {
            "type": "html",
            "text": "<b>How do you make [[Structured Graphics]] composable?</b>",
            "id": "1d5183c755db26d879c0ff3af6870968"
          },
          {
            "type": "html",
            "text": "\nIf you are writing a graphics program that uses [[Structured Graphics]], you may want to define a composite shape and then draw it in different places on the display, at a different size, rotated or in a different colour. ",
            "id": "eff4ff90c7ddbe3ff4576e7635c7c566"
          },
          {
            "type": "html",
            "text": "\nTherefore:",
            "id": "2eee91ad6bde1a356a9892119a14c237"
          },
          {
            "type": "html",
            "text": "<b>Each [[Structured Graphics]] object should encapsulate a modification to the drawing state held in the display manager, such as the [[Single Transform]]. Composing graphical objects will cause the child to inherit the drawing state created by its tree of containers.</b>",
            "id": "5ff9f8c3525c31a57020016252b72353"
          },
          {
            "type": "html",
            "text": "\nDefine the visual objects using a [[Directed Acyclic Graph]] (DAG) in which the leaves represent primitive shapes and intermediate nodes either encapsulate a small, reversible change to the state of the display manager that is applied to a single subgraph or compose multiple subgraphs.",
            "id": "9a8e2d01294d2f91ff4549cf09581b39"
          },
          {
            "type": "html",
            "text": "\nDrawing is performed by walking over the graph in depth-first order, performing the following operations on the various types of nodes:",
            "id": "6c40c49fefdc5cfd93ae6cfed30cf01d"
          },
          {
            "type": "html",
            "text": " <i>Intermediate Nodes</i>:<br>apply the state change to the display manager, draw the subgraph, then reverse the state change in the display manager.",
            "id": "a9703b00011d21d5415e418269d87b99"
          },
          {
            "type": "html",
            "text": " <i>Composite Nodes</i>:<br>draw each of their subgraphs in turn.  Advanced systems can implement other composition operators, such as constructive area (or solid) geometry (CAG or CSG).",
            "id": "2fc1c737edf9e74ddae3223f32a37225"
          },
          {
            "type": "html",
            "text": " <i>Leaf Nodes</i>:<br>draw a primitive shape.  The drawing will be affected by all the state changes applied to the display manager while traversing the graph.",
            "id": "d0fd0fe985aa1088b87fe2b00e9ba210"
          },
          {
            "type": "html",
            "text": "\nA shape can be drawn multiple times, with different transformations and other properties, by defining it once and then linking it into different parts of the graph so that different transformations are applied to it each time it is visited during the graph traversal.",
            "id": "2a64421f513a87f406a01ab4a759a783"
          },
          {
            "type": "html",
            "text": "\nHowever, compared to a simple [[Structured Graphics]] framework, it is harder to map from the leaves of a [[Scene Graph]] to areas of the display, because arbitrary transformations can be applied to the shapes at the leaves of the graph.  These calculations are required to calculate minimim [[Refresh Rectangles]] or to implement interactivity. \nSuch mappings must be performed by walking over the graph, keeping track of transformations by performing the matrix multiplications in the visitor.  \nEven though this is computationally more expensive than algorithms required by a simple [[Structured Graphics]] framework, it can still reduce the drawing time significantly when used to calculate minimum [[Refresh Rectangles]].",
            "id": "0fe000c3df03c6b51ae93f19ce0a9712"
          },
          {
            "type": "html",
            "text": "\nA [[Scene Graph]] is often used as a high-level interface for assembling [[Compiled Graphic Commands]].",
            "id": "84d6c686729e219dbd5b3ad57400dcf4"
          },
          {
            "type": "html",
            "text": "\nA [[Render Graph]] is an optimisation of the [[Scene Graph]] model.",
            "id": "35732e29387773d625c60bf9105fab5d"
          },
          {
            "type": "html",
            "text": "\nThis pattern is widely used in toolkits for 3D graphics.  In particular, Open<i></i>Inventor, [[Open Scene Graph]] and Java3D all use \n[[Scene Graph]]s to structure scenes.  It is less widely used in 2D graphics.  Examples include the [[Morphic Interface]] framework in the [[Self Language]] and [[Squeak Smalltalk]], the [[Scene Beans]] and Jazz toolkits for Java, the [[Gnome Canvas]] display widget, and the SVG graphics file format defined by the W3C.",
            "id": "2c399d50380386b33bf66da1c7bd6aa7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7033cb91268bc95d480ff1e19a827e76"
          },
          {
            "type": "html",
            "text": "Also see [[Graphics Patterns]], [[Interactive Scene Graph]], [[Document Object Model]]",
            "id": "3a95d20297ac4c721c8367d065525994"
          },
          {
            "type": "html",
            "text": "\n[[Category Pattern]]",
            "id": "dab50fa963bc16a144315637f44cb722"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?SceneGraph c2.com]",
            "id": "ff8d5db0cb71f5828cbde2642e1c350a"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1640690280290
    },
    {
      "type": "edit",
      "id": "0fe000c3df03c6b51ae93f19ce0a9712",
      "item": {
        "type": "html",
        "text": "However, compared to a simple [[Structured Graphics]] framework, it is harder to map from the leaves of a Scene Graph to areas of the display, because arbitrary transformations can be applied to the shapes at the leaves of the graph.  These calculations are required to calculate minimim [[Refresh Rectangles]] or to implement interactivity. \nSuch mappings must be performed by walking over the graph, keeping track of transformations by performing the matrix multiplications in the visitor.  \nEven though this is computationally more expensive than algorithms required by a simple [[Structured Graphics]] framework, it can still reduce the drawing time significantly when used to calculate minimum [[Refresh Rectangles]].",
        "id": "0fe000c3df03c6b51ae93f19ce0a9712"
      },
      "date": 1671717341329
    },
    {
      "type": "edit",
      "id": "84d6c686729e219dbd5b3ad57400dcf4",
      "item": {
        "type": "html",
        "text": "A Scene Graph is often used as a high-level interface for assembling [[Compiled Graphic Commands]].",
        "id": "84d6c686729e219dbd5b3ad57400dcf4"
      },
      "date": 1671717366112
    },
    {
      "type": "edit",
      "id": "35732e29387773d625c60bf9105fab5d",
      "item": {
        "type": "html",
        "text": "A [[Render Graph]] is an optimisation of the Scene Graph model.",
        "id": "35732e29387773d625c60bf9105fab5d"
      },
      "date": 1671717386655
    },
    {
      "type": "edit",
      "id": "2c399d50380386b33bf66da1c7bd6aa7",
      "item": {
        "type": "html",
        "text": "This pattern is widely used in toolkits for 3D graphics.  In particular, Open<i></i>Inventor, [[Open Scene Graph]] and Java3D all use \nScene Graphs to structure scenes.  It is less widely used in 2D graphics.  Examples include the [[Morphic Interface]] framework in the [[Self Language]] and [[Squeak Smalltalk]], the [[Scene Beans]] and Jazz toolkits for Java, the [[Gnome Canvas]] display widget, and the SVG graphics file format defined by the W3C.",
        "id": "2c399d50380386b33bf66da1c7bd6aa7"
      },
      "date": 1671717446304
    }
  ]
}