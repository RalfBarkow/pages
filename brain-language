{
  "title": "Brain Language",
  "story": [
    {
      "type": "html",
      "text": "Really nice language, with similarities to [[Smalltalk Language]], but [[Prototype Based]], and things from [[Lisp Language]] and [[Java Script]].",
      "id": "a9c33ad259fe0fa6a7934a4a36a699c4"
    },
    {
      "type": "html",
      "text": "\nStill in beta, but pretty functional, it's being developed by [[Manuel Tomis]]. I am just helping for testing, examples, &c...",
      "id": "d69c700f53a6636533d8f3fe8fdbec45"
    },
    {
      "type": "html",
      "text": "\nSee [http://brain.sourceforge.net/ brain.sourceforge.net] for more. I am sure you'll like it :)",
      "id": "720a9cba23b3338212828552ab046f25"
    },
    {
      "type": "html",
      "text": "-- [[David De Lis]] ",
      "id": "851658fbe955e9bd4d49fa189a6565bc"
    },
    {
      "type": "html",
      "text": "\nDon't you mean 'similarities to [[Self Language]]'?  The syntax seems a little kooky - what was wrong with Self's syntax?  <i>-- [[Richard Emerson]]</i>",
      "id": "0277c9b10662e5413d01f2670559ea3f"
    },
    {
      "type": "html",
      "text": "\nI agree -- the syntax is <i>kooky</i>. I'd like to learn more about the reasons for developing this language. Having spent two years working in a prototypical language (now dead), I'm always eager to learn about others. I'm assuming there are some shortcomings in [[Self Language]] that [[Brain Language]] is focusing on overcoming. What are they?",
      "id": "86584fcd3cfcfb383f200faa004bc518"
    },
    {
      "type": "html",
      "text": "\nOn a brief scan of the docs, I saw one point that really troubles me: \"If the method or property is found in the prototype then it is the prototype that becomes the receiver object of the message.\" If the prototype is the receiver, how do you override data members? I'm accustomed to the original object remaining the receiver so that further member lookups begin there. -- [[Greg Vaughn]]",
      "id": "268d1edf94e4cb28a9c9378bc691aeab"
    },
    {
      "type": "html",
      "text": "\nWhat does <i>kooky</i> mean? As far as I know from email interchange with the author (a young CSC student in Chyprus) he looked some books of Smalltalk and [[Java Script]] and liked it, so he started to make the [[Brain Language]]. I didn't know Self, although I did know a bit about Newtonscript. I'll point [[Manuel Tomis]] to this wiki and to the pages given on the [[Self Language]] page and see what he thinks. The language is slowly changing and even today I have some proposals for changes to send to him. It would be nice if people interested would get in touch with [[Manuel Tomis]], he will surely appreciate any and all input about [[Brain Language]].",
      "id": "8fb1734e887aae43ea038ede59e6ac73"
    },
    {
      "type": "html",
      "text": "\nAs for my own opinion, I like it because it's really clean, without some extra syntax commonly found in Smalltalk that usually remains void, &c.",
      "id": "6045c99733948d6952756aa658b00c7b"
    },
    {
      "type": "html",
      "text": "\nRegarding prototypes, you don't have to delegate, you can subtype. That means the new object is a clone of the first one but with added functionality or data... (properties)...",
      "id": "ef9e5769bd22f30167891ac239b7ad4e"
    },
    {
      "type": "html",
      "text": "\nThis is an example I am making myself for the examples section:",
      "id": "0842922e2080426d1ac88cd3c9748c5c"
    },
    {
      "type": "code",
      "text": " Person = object subtype\n  property: #name is: \"\"; -- defaults\n  property: #age  is: 0;",
      "id": "80ffb9447acf5bb4bc2e2e6bc65d281e"
    },
    {
      "type": "html",
      "text": "method:<br>#get_name is: {",
      "id": "c1062442c2790611d8ba68241b16d6cf"
    },
    {
      "type": "code",
      "text": "    self!name\n  };\n  method: #get_age is: {\n    self!age\n  };\n  method: #set_name: is: { |new_name|\n    self!name = new_name\n  };\n  method: #set_age: is: { |new_age|\n    self!age = new_age\n  };",
      "id": "62fb2287815db808d3f773d2e68bf9f1"
    },
    {
      "type": "html",
      "text": ".",
      "id": "619fda2dd48618bec551fa71bf839f9b"
    },
    {
      "type": "html",
      "text": "\nAnd then you can subtype or delegate Boy, Girl, Baby, &c... It's extremely clear, (specially written in this C++/Java look&feel... I am still looking the <i>right</i> style for this language.. any suggestions very appreciated :)",
      "id": "7ea280ed69fda0906afeddef4b9c0002"
    },
    {
      "type": "html",
      "text": "\nIf you have to override data members for an object, you should refactor it to be a subtype of its parent and not delegate that functionality to it. I see delegation like in legal matters. If a young boy does something bad, he is delegating the responsibility to his parents (until he is over 18/21 years-old) and thus the father/mother/legal tutor becomes fully receiver of the message (sent by Justice in this example...) I may be off-the-track, though...",
      "id": "cc5904e67901a9251073ce655a3f4140"
    },
    {
      "type": "html",
      "text": "\nHope this helps... -- [[David De Lis]]",
      "id": "ee9195dc171f0a8dacb499325c74627d"
    },
    {
      "type": "html",
      "text": "\nNewtonscript was actually the Self derived language I have experience in. I haven't had the chance to read through all the details of the docs, so correct me if I'm wrong about subtyping in [[Brain Language]]: a subtype of X is an object with X as it's prototype. Suppose you create a Baby class with your example Person as its prototype, and it does not override the getName method, but it does have it own name property. If you sent a getName message to Baby would it return the name from Person or Baby? My reading of the rule that the prototype becomes the receiver would mean that it would return name from Person, which is not what I would want. -- [[Greg Vaughn]]",
      "id": "934c31059737f6ff13cc91ae3c331fae"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c816cf787399f1369f58e38818bcb88f"
    },
    {
      "type": "html",
      "text": "\nActually Babies are down in the chain of my example... :-) That would only happen if Baby delegate its methods to Person. Problem here is how you model the whole thing: a baby IS-A person or a baby IS-LIKE a person? (using Scott Meyers' relationships (we've left HAS-A out))",
      "id": "ffc7beb948b6715f15bdffdde6edaa7e"
    },
    {
      "type": "html",
      "text": "\nIf a baby IS-A person, then:",
      "id": "0fd887a3f146552de49771eef8d50176"
    },
    {
      "type": "html",
      "text": "\nLet's suppose:",
      "id": "23d81ee2b0092c1a67261fe37d714a7d"
    },
    {
      "type": "code",
      "text": " Animal = object new.  -- an animal (''instance'' of object)\n -- Animal = object subtype. -- this would yield a specialization of object...\n Person = Animal subtype. -- a person IS-A animal\n Baby  = Person subtype. -- it would have all data and methods from Person.",
      "id": "566294a7cc06a136682d404423c7f96f"
    },
    {
      "type": "html",
      "text": "\nBut if Baby = Animal subtype property: #prototype is: #Person.",
      "id": "072da611aa09a8cacf00c196e95a9d9d"
    },
    {
      "type": "html",
      "text": "\nIn this case, we are stating that a Baby is an animal, the same way a Person is, that a Baby is not a Person, but that it behaves in a similar way... (IS-LIKE).  I think I remember Coplien or Meyers have a  discussion on C++ inheritance: IS-A is public inheritance, HAS-A is private inheritance and IS-LIKE is protected inheritance... or a permutation of the two last ones... I wonder is that right? Hope this makes things clearer... -- [[David De Lis]]",
      "id": "18ad4623d56a678f3cb33c7e15495ab4"
    },
    {
      "type": "html",
      "text": "\nSorry, but I still don't see it. I guess I should read the [[Brain Language]] docs more. It sounds to me from your example that the 'subtype' keyword is not the same as setting a prototype, which was the assumption I made above. Still if",
      "id": "b609232864d490e8a698af8ba14fa333"
    },
    {
      "type": "html",
      "text": "Baby = Animal subtype property:<br>#prototype is: #Person, property: #name is: \"Junior\"",
      "id": "8564b387cea8e51f743129c4571fe844"
    },
    {
      "type": "html",
      "text": "\nand I call Baby.getName() (or whatever the syntax is) will it return \"Junior\" or whatever name is defined as in Person? -- [[Greg Vaughn]]",
      "id": "60e69e64911e864e48a39a4a4e71a63b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c816cf787399f1369f58e38818bcb88f"
    },
    {
      "type": "html",
      "text": "\nAbout the question why I wrote [[Brain Language]]. About 2+ something years ago I decided to write a programming language, just for fun :) I started looking around on the net and i had a good look at languages like [[Java Language]], [[Python Language]], [[Scheme Language]], [[Smalltalk Language]], [[Self Language]], [[Pike Language]], [[Java Script]], [[Haskell Language]] and a few more. After trying some approaches I finally decided on the general design of [[Brain Language]] at the beginning of last year. [[Brain Language]] is obviously influenced a lot from [[Smalltalk Language]]/[[Self Language]]. Basically I liked the ideas behind those languages but there were also some things I didn't like, so I borrowed the general ideas about the syntax and the semantics, but I decided to do the rest the way I wanted to. So what are the differences between [[Brain Language]] and [[Self Language]]?",
      "id": "80ed637218d3e043cf0c3a0949011443"
    },
    {
      "type": "html",
      "text": "\nFirst of all there are some obvious syntactic differences ex. identifiers can contain dash, blocks and literals have kind of different (kooky ?:) syntax etc. Local variables in [[Brain Language]] are introduced with the var keyword. Besides the usual unary/binary/keyword message syntax, [[Brain Language]] has a block evaluation syntax (). This makes evaluating blocks more convenient rather than using <i>block value: ??? value: ??? value: ???</i>,  and allows blocks to be used like functions in other languages. You can access properties of objects with <i>object!property</i> syntax rather that the system creating special methods. There are also semantic differences: [[Brain Language]] supports [[Scheme Language]] style closures, and it does not have a non local exit ^ because it would make no sense given the semantics of blocks in [[Brain Language]]. In [[Brain Language]] all blocks are equals, that is there is no distinction between methods and blocks. Also [[Brain Language]] supports single delegation, instead of multiple delegation, because I thought the complexity wasn't worth it. One of the most important differences is that [[Brain Language]] libraries do not have much in common with the [[Self Language]] libraries (although again there are methods that have similar names).",
      "id": "3783d84489ddf59f8a8d46591020a768"
    },
    {
      "type": "html",
      "text": "\nLast but not least [[Self Language]] and [[Smalltalk Language]] usually come with a set of thousands of objects, which live in a persistent image. From what I saw [[Self Language]] is worth about 15 megabytes of download. I preferred to make [[Brain Language]] run more like a traditional scripting language like [[Perl Language]] or [[Python Language]].",
      "id": "f8250d1015fca42b6de37ae10786c2cc"
    },
    {
      "type": "html",
      "text": "\nNow about the (kooky :) semantics of [[Brain Language]] objects. Delegation in [[Brain Language]] means something like \"I don't understand this, will you do it for me?\". So why does the prototype become the self object?",
      "id": "4623b07cb2945434c138ec3299673f3a"
    },
    {
      "type": "html",
      "text": "\nThe first reason is that each object is supposed to work on it's own data, and is not supposed to know about the data in objects that it is the prototype of. Let's say that an object A has a property called <i>Data</i>. Let's say that this object is the prototype of another object B which also has a property called <i>Data</i>. Let's assume that a message <i>make-it-so</i> is sent to B, is not found, and is then found in A. I think that A's method <i>make-it-so</i> should work on it's own object's <i>Data</i> rather on B's data.",
      "id": "a7ead584b83419f0c70223a5cd0ee31c"
    },
    {
      "type": "html",
      "text": "\nA second reason for having these semantics is that you can have native objects (like strings/chars/numbers) as prototypes. For (a not very useful) example:",
      "id": "32cd18529c9fa51aa0b57e4ca7624d67"
    },
    {
      "type": "code",
      "text": " object!prototype = \"Hello World\".\n object reverse println.",
      "id": "8cdfd27b2b7caa79cdebcc53e7833b40"
    },
    {
      "type": "html",
      "text": "\nA third reason is that you can have different objects share the same prototypes properties (something like virtual inheritance in C++)",
      "id": "88094299ec44d9c941d8644e785a5c1a"
    },
    {
      "type": "html",
      "text": "\nAnd finally about the meaning of <i>subtype</i>. In [[Brain Language]] there is a concept of types, like for example all strings are considered to be of string type. When you add a method to an object, that method will automatically be added to all objects of the same type. What the subtype message does is that it clones an object and at the same time it makes it  to be of a new type. Think of it like creating a new species in the process of evolution :). The object will have all the properties and methods of the original object, but if you add a new method to it, it will be added only to itself and any objects that were cloned from it (that is objects  that are the same type with it).",
      "id": "f0e743cb3d20218f83999300ed9e2885"
    },
    {
      "type": "html",
      "text": "\nI hope that this information was useful. -- [[Manuel Tomis]]",
      "id": "e1dc917ab8b3c811809b143a4c7de685"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c816cf787399f1369f58e38818bcb88f"
    },
    {
      "type": "html",
      "text": "\nAha! I did read that rule about the prototype becoming the receiver properly. From my experience with [[Newton Script]], that seems terribly limiting. The fact that I could override data without overriding methods was very helpful. However, if I'm understanding subtypes correctly (I haven't experienced anything like it before), it looks like you can get the same sort of functionality at the memory expense of a clone. That wouldn't have been acceptable in the low-memory environment of the Newton, but it is probably fine on a desktop. The subtype sounds an awful lot like an instance of a class, but I thought this was a prototypical language :-)  -- [[Greg Vaughn]]",
      "id": "4d3c23118897e45cd8812661cd0c0ae0"
    },
    {
      "type": "html",
      "text": ":-) Well, every object in Brain (as Manuel has told me) has two parts: a data space and a methods space (think of boxes). Every object of a given type shares the methods box, while maintaining a private data box. Cloning a new object of that type simply creates a new data box... It's <i>like if</i> we had this:",
      "id": "f2f8d27b201c7a97c1e037f5d61ffcef"
    },
    {
      "type": "code",
      "text": "  [data|methods] == [data| *p],    p--> [methods]",
      "id": "22f1e4f3bb23ce68629f9277988606b1"
    },
    {
      "type": "code",
      "text": "  So ob1 = [data1| *p], ob2 = [data2| *p], etc...",
      "id": "0155b5c256c42bf21f29fdec3d4fb3ed"
    },
    {
      "type": "html",
      "text": "\nOn the other hand, if we subtype from an object, the new object had a methods box of its own, and it's effectively separated from it's parent object.",
      "id": "52915addf629db0fcf85b3d4e4455674"
    },
    {
      "type": "html",
      "text": "\nIf may be like inheritance in class-driven languages, but if o2 = o1 subtype, you can after this add methods and properties to both objects. They will share a common ground, but their behavior will be pretty different (so that could mean there's a virtual parent object would be there floating around... but there is not :-)",
      "id": "7869e0ef8fddd6dfa71200fcf219f7b8"
    },
    {
      "type": "html",
      "text": "\nBy the way, it's all down to using the appropriate idioms for the language. You can do it class-like by maintaining an immutable object as a template or you can create a dynamic world were objects just evolve as needed. [[Extreme Programming]] would probably be a good methodology for this, as [[Refactor Mercilessly]] and [[Do The Simplest Thing That Could Possibly Work]] sound pretty much like the above... I don't know many idioms myself (still learning). Manuel has already developed some of them, and I am sure many more are still buried in the language. I hope they'll pop up as the language evolves and our understanding of it grows. -- [[David De Lis]]",
      "id": "43ca88f133e6d0fa8e64cc10e8cde04e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c816cf787399f1369f58e38818bcb88f"
    },
    {
      "type": "html",
      "text": "[[Category Programming Language]]",
      "id": "59ccc90321021cbb8d0454cc192cfe0e"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?BrainLanguage c2.com]",
      "id": "2d5e661b15ed320dd71de1296d434d6e"
    }
  ],
  "journal": [
    {
      "date": 1103192958000,
      "id": "ccea6a2719bd23bd61da4424b8736002",
      "type": "create",
      "item": {
        "title": "Brain Language",
        "story": [
          {
            "type": "html",
            "text": "Really nice language, with similarities to [[Smalltalk Language]], but [[Prototype Based]], and things from [[Lisp Language]] and [[Java Script]].",
            "id": "a9c33ad259fe0fa6a7934a4a36a699c4"
          },
          {
            "type": "html",
            "text": "\nStill in beta, but pretty functional, it's being developed by [[Manuel Tomis]]. I am just helping for testing, examples, &c...",
            "id": "d69c700f53a6636533d8f3fe8fdbec45"
          },
          {
            "type": "html",
            "text": "\nSee [http://brain.sourceforge.net/ brain.sourceforge.net] for more. I am sure you'll like it :)",
            "id": "720a9cba23b3338212828552ab046f25"
          },
          {
            "type": "html",
            "text": "-- [[David De Lis]] ",
            "id": "851658fbe955e9bd4d49fa189a6565bc"
          },
          {
            "type": "html",
            "text": "\nDon't you mean 'similarities to [[Self Language]]'?  The syntax seems a little kooky - what was wrong with Self's syntax?  <i>-- [[Richard Emerson]]</i>",
            "id": "0277c9b10662e5413d01f2670559ea3f"
          },
          {
            "type": "html",
            "text": "\nI agree -- the syntax is <i>kooky</i>. I'd like to learn more about the reasons for developing this language. Having spent two years working in a prototypical language (now dead), I'm always eager to learn about others. I'm assuming there are some shortcomings in [[Self Language]] that [[Brain Language]] is focusing on overcoming. What are they?",
            "id": "86584fcd3cfcfb383f200faa004bc518"
          },
          {
            "type": "html",
            "text": "\nOn a brief scan of the docs, I saw one point that really troubles me: \"If the method or property is found in the prototype then it is the prototype that becomes the receiver object of the message.\" If the prototype is the receiver, how do you override data members? I'm accustomed to the original object remaining the receiver so that further member lookups begin there. -- [[Greg Vaughn]]",
            "id": "268d1edf94e4cb28a9c9378bc691aeab"
          },
          {
            "type": "html",
            "text": "\nWhat does <i>kooky</i> mean? As far as I know from email interchange with the author (a young CSC student in Chyprus) he looked some books of Smalltalk and [[Java Script]] and liked it, so he started to make the [[Brain Language]]. I didn't know Self, although I did know a bit about Newtonscript. I'll point [[Manuel Tomis]] to this wiki and to the pages given on the [[Self Language]] page and see what he thinks. The language is slowly changing and even today I have some proposals for changes to send to him. It would be nice if people interested would get in touch with [[Manuel Tomis]], he will surely appreciate any and all input about [[Brain Language]].",
            "id": "8fb1734e887aae43ea038ede59e6ac73"
          },
          {
            "type": "html",
            "text": "\nAs for my own opinion, I like it because it's really clean, without some extra syntax commonly found in Smalltalk that usually remains void, &c.",
            "id": "6045c99733948d6952756aa658b00c7b"
          },
          {
            "type": "html",
            "text": "\nRegarding prototypes, you don't have to delegate, you can subtype. That means the new object is a clone of the first one but with added functionality or data... (properties)...",
            "id": "ef9e5769bd22f30167891ac239b7ad4e"
          },
          {
            "type": "html",
            "text": "\nThis is an example I am making myself for the examples section:",
            "id": "0842922e2080426d1ac88cd3c9748c5c"
          },
          {
            "type": "code",
            "text": " Person = object subtype\n  property: #name is: \"\"; -- defaults\n  property: #age  is: 0;",
            "id": "80ffb9447acf5bb4bc2e2e6bc65d281e"
          },
          {
            "type": "html",
            "text": "method:<br>#get_name is: {",
            "id": "c1062442c2790611d8ba68241b16d6cf"
          },
          {
            "type": "code",
            "text": "    self!name\n  };\n  method: #get_age is: {\n    self!age\n  };\n  method: #set_name: is: { |new_name|\n    self!name = new_name\n  };\n  method: #set_age: is: { |new_age|\n    self!age = new_age\n  };",
            "id": "62fb2287815db808d3f773d2e68bf9f1"
          },
          {
            "type": "html",
            "text": ".",
            "id": "619fda2dd48618bec551fa71bf839f9b"
          },
          {
            "type": "html",
            "text": "\nAnd then you can subtype or delegate Boy, Girl, Baby, &c... It's extremely clear, (specially written in this C++/Java look&feel... I am still looking the <i>right</i> style for this language.. any suggestions very appreciated :)",
            "id": "7ea280ed69fda0906afeddef4b9c0002"
          },
          {
            "type": "html",
            "text": "\nIf you have to override data members for an object, you should refactor it to be a subtype of its parent and not delegate that functionality to it. I see delegation like in legal matters. If a young boy does something bad, he is delegating the responsibility to his parents (until he is over 18/21 years-old) and thus the father/mother/legal tutor becomes fully receiver of the message (sent by Justice in this example...) I may be off-the-track, though...",
            "id": "cc5904e67901a9251073ce655a3f4140"
          },
          {
            "type": "html",
            "text": "\nHope this helps... -- [[David De Lis]]",
            "id": "ee9195dc171f0a8dacb499325c74627d"
          },
          {
            "type": "html",
            "text": "\nNewtonscript was actually the Self derived language I have experience in. I haven't had the chance to read through all the details of the docs, so correct me if I'm wrong about subtyping in [[Brain Language]]: a subtype of X is an object with X as it's prototype. Suppose you create a Baby class with your example Person as its prototype, and it does not override the getName method, but it does have it own name property. If you sent a getName message to Baby would it return the name from Person or Baby? My reading of the rule that the prototype becomes the receiver would mean that it would return name from Person, which is not what I would want. -- [[Greg Vaughn]]",
            "id": "934c31059737f6ff13cc91ae3c331fae"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c816cf787399f1369f58e38818bcb88f"
          },
          {
            "type": "html",
            "text": "\nActually Babies are down in the chain of my example... :-) That would only happen if Baby delegate its methods to Person. Problem here is how you model the whole thing: a baby IS-A person or a baby IS-LIKE a person? (using Scott Meyers' relationships (we've left HAS-A out))",
            "id": "ffc7beb948b6715f15bdffdde6edaa7e"
          },
          {
            "type": "html",
            "text": "\nIf a baby IS-A person, then:",
            "id": "0fd887a3f146552de49771eef8d50176"
          },
          {
            "type": "html",
            "text": "\nLet's suppose:",
            "id": "23d81ee2b0092c1a67261fe37d714a7d"
          },
          {
            "type": "code",
            "text": " Animal = object new.  -- an animal (''instance'' of object)\n -- Animal = object subtype. -- this would yield a specialization of object...\n Person = Animal subtype. -- a person IS-A animal\n Baby  = Person subtype. -- it would have all data and methods from Person.",
            "id": "566294a7cc06a136682d404423c7f96f"
          },
          {
            "type": "html",
            "text": "\nBut if Baby = Animal subtype property: #prototype is: #Person.",
            "id": "072da611aa09a8cacf00c196e95a9d9d"
          },
          {
            "type": "html",
            "text": "\nIn this case, we are stating that a Baby is an animal, the same way a Person is, that a Baby is not a Person, but that it behaves in a similar way... (IS-LIKE).  I think I remember Coplien or Meyers have a  discussion on C++ inheritance: IS-A is public inheritance, HAS-A is private inheritance and IS-LIKE is protected inheritance... or a permutation of the two last ones... I wonder is that right? Hope this makes things clearer... -- [[David De Lis]]",
            "id": "18ad4623d56a678f3cb33c7e15495ab4"
          },
          {
            "type": "html",
            "text": "\nSorry, but I still don't see it. I guess I should read the [[Brain Language]] docs more. It sounds to me from your example that the 'subtype' keyword is not the same as setting a prototype, which was the assumption I made above. Still if",
            "id": "b609232864d490e8a698af8ba14fa333"
          },
          {
            "type": "html",
            "text": "Baby = Animal subtype property:<br>#prototype is: #Person, property: #name is: \"Junior\"",
            "id": "8564b387cea8e51f743129c4571fe844"
          },
          {
            "type": "html",
            "text": "\nand I call Baby.getName() (or whatever the syntax is) will it return \"Junior\" or whatever name is defined as in Person? -- [[Greg Vaughn]]",
            "id": "60e69e64911e864e48a39a4a4e71a63b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c816cf787399f1369f58e38818bcb88f"
          },
          {
            "type": "html",
            "text": "\nAbout the question why I wrote [[Brain Language]]. About 2+ something years ago I decided to write a programming language, just for fun :) I started looking around on the net and i had a good look at languages like [[Java Language]], [[Python Language]], [[Scheme Language]], [[Smalltalk Language]], [[Self Language]], [[Pike Language]], [[Java Script]], [[Haskell Language]] and a few more. After trying some approaches I finally decided on the general design of [[Brain Language]] at the beginning of last year. [[Brain Language]] is obviously influenced a lot from [[Smalltalk Language]]/[[Self Language]]. Basically I liked the ideas behind those languages but there were also some things I didn't like, so I borrowed the general ideas about the syntax and the semantics, but I decided to do the rest the way I wanted to. So what are the differences between [[Brain Language]] and [[Self Language]]?",
            "id": "80ed637218d3e043cf0c3a0949011443"
          },
          {
            "type": "html",
            "text": "\nFirst of all there are some obvious syntactic differences ex. identifiers can contain dash, blocks and literals have kind of different (kooky ?:) syntax etc. Local variables in [[Brain Language]] are introduced with the var keyword. Besides the usual unary/binary/keyword message syntax, [[Brain Language]] has a block evaluation syntax (). This makes evaluating blocks more convenient rather than using <i>block value: ??? value: ??? value: ???</i>,  and allows blocks to be used like functions in other languages. You can access properties of objects with <i>object!property</i> syntax rather that the system creating special methods. There are also semantic differences: [[Brain Language]] supports [[Scheme Language]] style closures, and it does not have a non local exit ^ because it would make no sense given the semantics of blocks in [[Brain Language]]. In [[Brain Language]] all blocks are equals, that is there is no distinction between methods and blocks. Also [[Brain Language]] supports single delegation, instead of multiple delegation, because I thought the complexity wasn't worth it. One of the most important differences is that [[Brain Language]] libraries do not have much in common with the [[Self Language]] libraries (although again there are methods that have similar names).",
            "id": "3783d84489ddf59f8a8d46591020a768"
          },
          {
            "type": "html",
            "text": "\nLast but not least [[Self Language]] and [[Smalltalk Language]] usually come with a set of thousands of objects, which live in a persistent image. From what I saw [[Self Language]] is worth about 15 megabytes of download. I preferred to make [[Brain Language]] run more like a traditional scripting language like [[Perl Language]] or [[Python Language]].",
            "id": "f8250d1015fca42b6de37ae10786c2cc"
          },
          {
            "type": "html",
            "text": "\nNow about the (kooky :) semantics of [[Brain Language]] objects. Delegation in [[Brain Language]] means something like \"I don't understand this, will you do it for me?\". So why does the prototype become the self object?",
            "id": "4623b07cb2945434c138ec3299673f3a"
          },
          {
            "type": "html",
            "text": "\nThe first reason is that each object is supposed to work on it's own data, and is not supposed to know about the data in objects that it is the prototype of. Let's say that an object A has a property called <i>Data</i>. Let's say that this object is the prototype of another object B which also has a property called <i>Data</i>. Let's assume that a message <i>make-it-so</i> is sent to B, is not found, and is then found in A. I think that A's method <i>make-it-so</i> should work on it's own object's <i>Data</i> rather on B's data.",
            "id": "a7ead584b83419f0c70223a5cd0ee31c"
          },
          {
            "type": "html",
            "text": "\nA second reason for having these semantics is that you can have native objects (like strings/chars/numbers) as prototypes. For (a not very useful) example:",
            "id": "32cd18529c9fa51aa0b57e4ca7624d67"
          },
          {
            "type": "code",
            "text": " object!prototype = \"Hello World\".\n object reverse println.",
            "id": "8cdfd27b2b7caa79cdebcc53e7833b40"
          },
          {
            "type": "html",
            "text": "\nA third reason is that you can have different objects share the same prototypes properties (something like virtual inheritance in C++)",
            "id": "88094299ec44d9c941d8644e785a5c1a"
          },
          {
            "type": "html",
            "text": "\nAnd finally about the meaning of <i>subtype</i>. In [[Brain Language]] there is a concept of types, like for example all strings are considered to be of string type. When you add a method to an object, that method will automatically be added to all objects of the same type. What the subtype message does is that it clones an object and at the same time it makes it  to be of a new type. Think of it like creating a new species in the process of evolution :). The object will have all the properties and methods of the original object, but if you add a new method to it, it will be added only to itself and any objects that were cloned from it (that is objects  that are the same type with it).",
            "id": "f0e743cb3d20218f83999300ed9e2885"
          },
          {
            "type": "html",
            "text": "\nI hope that this information was useful. -- [[Manuel Tomis]]",
            "id": "e1dc917ab8b3c811809b143a4c7de685"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c816cf787399f1369f58e38818bcb88f"
          },
          {
            "type": "html",
            "text": "\nAha! I did read that rule about the prototype becoming the receiver properly. From my experience with [[Newton Script]], that seems terribly limiting. The fact that I could override data without overriding methods was very helpful. However, if I'm understanding subtypes correctly (I haven't experienced anything like it before), it looks like you can get the same sort of functionality at the memory expense of a clone. That wouldn't have been acceptable in the low-memory environment of the Newton, but it is probably fine on a desktop. The subtype sounds an awful lot like an instance of a class, but I thought this was a prototypical language :-)  -- [[Greg Vaughn]]",
            "id": "4d3c23118897e45cd8812661cd0c0ae0"
          },
          {
            "type": "html",
            "text": ":-) Well, every object in Brain (as Manuel has told me) has two parts: a data space and a methods space (think of boxes). Every object of a given type shares the methods box, while maintaining a private data box. Cloning a new object of that type simply creates a new data box... It's <i>like if</i> we had this:",
            "id": "f2f8d27b201c7a97c1e037f5d61ffcef"
          },
          {
            "type": "code",
            "text": "  [data|methods] == [data| *p],    p--> [methods]",
            "id": "22f1e4f3bb23ce68629f9277988606b1"
          },
          {
            "type": "code",
            "text": "  So ob1 = [data1| *p], ob2 = [data2| *p], etc...",
            "id": "0155b5c256c42bf21f29fdec3d4fb3ed"
          },
          {
            "type": "html",
            "text": "\nOn the other hand, if we subtype from an object, the new object had a methods box of its own, and it's effectively separated from it's parent object.",
            "id": "52915addf629db0fcf85b3d4e4455674"
          },
          {
            "type": "html",
            "text": "\nIf may be like inheritance in class-driven languages, but if o2 = o1 subtype, you can after this add methods and properties to both objects. They will share a common ground, but their behavior will be pretty different (so that could mean there's a virtual parent object would be there floating around... but there is not :-)",
            "id": "7869e0ef8fddd6dfa71200fcf219f7b8"
          },
          {
            "type": "html",
            "text": "\nBy the way, it's all down to using the appropriate idioms for the language. You can do it class-like by maintaining an immutable object as a template or you can create a dynamic world were objects just evolve as needed. [[Extreme Programming]] would probably be a good methodology for this, as [[Refactor Mercilessly]] and [[Do The Simplest Thing That Could Possibly Work]] sound pretty much like the above... I don't know many idioms myself (still learning). Manuel has already developed some of them, and I am sure many more are still buried in the language. I hope they'll pop up as the language evolves and our understanding of it grows. -- [[David De Lis]]",
            "id": "43ca88f133e6d0fa8e64cc10e8cde04e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c816cf787399f1369f58e38818bcb88f"
          },
          {
            "type": "html",
            "text": "[[Category Programming Language]]",
            "id": "59ccc90321021cbb8d0454cc192cfe0e"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?BrainLanguage c2.com]",
            "id": "2d5e661b15ed320dd71de1296d434d6e"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1654469727041
    }
  ]
}