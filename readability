{
  "title": "Readability",
  "story": [
    {
      "type": "markdown",
      "id": "88147ab8395d5af8",
      "text": "# The Trouble with ‘Readability'"
    },
    {
      "type": "markdown",
      "id": "70cac9fba61b3c65",
      "text": "[http://akkartik.name/post/readable-bad Kartik Agaram's page] – We programmers love to talk about the value of readability in software. But all our rhetoric, even if it were practiced with diligence, suffers from a giant blind spot."
    },
    {
      "type": "markdown",
      "id": "5edd5147f7703428",
      "text": "## Exhibit A"
    },
    {
      "type": "markdown",
      "id": "a60f4611371fdbb2",
      "text": "Here's [[Douglas Crockford]] on programming style. \n"
    },
    {
      "type": "video",
      "id": "8316a238bf83738f",
      "text": "YOUTUBE taaEzHI9xyY\nCrockford on JavaScript - Section 8: Programming Style & Your Brain, 2011"
    },
    {
      "type": "markdown",
      "id": "7f10b05cf4f3c559",
      "text": "For the first half he explains why readability is important: because our brains do far more subconsciously than we tend to realize. The anecdotes are interesting and the presentation is engaging, but the premise is basically preaching to the choir. Of course I want my code to be readable. Sensei, show me how! \n"
    },
    {
      "type": "markdown",
      "id": "3a208bd15634f9c1",
      "text": "But when he gets to ‘how’, here is what we get: good names, comments and consistent indentation. Wait, what?! After all that discussion about how complex programs are, and how hard to understand, do we really expect to make a dent on *global* complexity with a few blunt, local rules? Does something not seem off? "
    },
    {
      "type": "markdown",
      "id": "8652cb7f13ad1006",
      "text": "## Exhibit B"
    },
    {
      "type": "markdown",
      "id": "373992a3638c91b8",
      "text": "[http://kotaku.com/5975610/the-exceptional-beauty-of-doom-3s-source-code Here]'s a paean to the software quality of Doom 3. It starts out with this utterly promising ideal:\n\n> “Local code should explain, or at least hint at, the overall system design.”\n\nUnfortunately we never hear about the 'overall system design' ever again. Instead we get.. good names, comments and indentation, culminating in the author's ideal of beauty:\n\n> “The two biggest things, for me at least, are stylistic indenting and maximum const-ness.”\n\nI think the fundamental reasons for the quality of Doom 3 have been missed. Observing superficial small-scale features will only take you so far in appreciating the large-scale beauty of a program. "
    },
    {
      "type": "markdown",
      "id": "9017a6564848db23",
      "text": "## ﻿Exhibit C\n"
    },
    {
      "type": "markdown",
      "id": "ce1de85bf240122c",
      "text": "Kernighan and Pike's classic [http://www.math.harvard.edu/computing/programming Practice of Programming], [https://web.archive.org/web/20160613163545/https://www.math.harvard.edu/computing/programming archive] takes mostly the code writer's part. For reading you're left again with guidelines in the small: names, comments and indentation. \n"
    },
    {
      "type": "markdown",
      "id": "9dc76c8d83a09914",
      "text": "## Discussion\n"
    },
    {
      "type": "markdown",
      "id": "82c231c86ce82b6b",
      "text": "I could go on and on. Everytime the discussion turns to readability we skip almost unconsciously to style guides and whatnot. Local rules for a fundamentally global problem.\n\n"
    },
    {
      "type": "markdown",
      "id": "4fd05dc7416e95d5",
      "text": "This blind spot is baked into the very phrase ‘[http://www.nczonline.net/blog/2012/02/13/book-review-the-art-of-readable-code readable code]’. ‘Code’ isn't an amorphous thing that you manage by the pound. You can't make software clean simply by making all the ‘code’ in it more clean. What we really ought to be thinking about is readable *programs*. Functions aren't readable in isolation, at least not in the most important way. The biggest aid to a function's readability is to convey where it fits in the larger program.\n"
    },
    {
      "type": "markdown",
      "id": "91ea240339548b2f",
      "text": "Nowhere is this more apparent than with names. All the above articles and more emphasize the value of names. But they all focus on naming conventions and rules of thumb to evaluate the quality of a *single name in isolation*. In practice, a series of locally well-chosen names gradually end up in overall cacophony. A program with a small harmonious vocabulary of names consistently used is hugely effective regardless of [http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#General_Naming_Rules whether its types and variables are visibly distinguished], [https://web.archive.org/web/20080701113040/https://google-styleguide.googlecode.com/svn/trunk/cppguide.xml archive]. To put it another way, the readability of a program can be hugely enhanced by *the names it doesn't use*.\n"
    },
    {
      "type": "markdown",
      "id": "319eb5f2d6f12904",
      "text": "Part of the problem is that talking about local features is easy. It's easy to teach the difference between a good name and a bad name. Once taught, the reader has the satisfaction of going off to judge names all around him. It's far harder to show a globally coherent design without losing the reader.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "2a859f2a687dc54f",
      "text": "Simple superficial rules can be applied to any program, but to learn from a well-designed program we must focus on what's unique to it, and not easily transferred to other programs in disparate domains. That again increases the odds of losing the reader.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "1df228b0420ab228",
      "text": "But the largest problem is that we programmers are often looking at the world from a parochial perspective: “I built this awesome program, I understand everything about it, and people keep bugging me to accept their crappy changes.” Style guides and conventions are basically tools for the insiders of a software project. If you already understand the global picture it makes sense to focus on the local irritations. But you won't be around forever. Eventually one of these newcomers will take charge of this project, and they'll make a mess [http://akkartik.name/naur.pdf if you didn't talk to them enough about the big picture] – pdf of P. Naur, “Programming as theory building,” Microprocessing and Microprogramming, vol. 15, no. 5, pp. 253–261, May 1985, doi: 10.1016/0165-6074(85)90032-8.\n\n\n"
    },
    {
      "type": "markdown",
      "id": "d485d211f1037a27",
      "text": "Lots of thought has gone into the small-scale best practices to help maintainers merge changes from others, but there's been no attempt at learning to communicate large-scale organization to newcomers. Perhaps this is a different skill entirely; if so, it needs a different name than ‘readability’. \n"
    },
    {
      "type": "markdown",
      "id": "e10e2e46b6380d6a",
      "text": "See [[Kartik Agaram]]."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Readability",
        "story": []
      },
      "date": 1633375600105
    },
    {
      "item": {
        "type": "factory",
        "id": "88147ab8395d5af8"
      },
      "id": "88147ab8395d5af8",
      "type": "add",
      "date": 1633375610908
    },
    {
      "type": "edit",
      "id": "88147ab8395d5af8",
      "item": {
        "type": "markdown",
        "id": "88147ab8395d5af8",
        "text": "The trouble with 'readability'\n\nWe programmers love to talk about the value of readability in software. But all our rhetoric, even if it were practiced with diligence, suffers from a giant blind spot. "
      },
      "date": 1633375619811
    },
    {
      "type": "edit",
      "id": "88147ab8395d5af8",
      "item": {
        "type": "markdown",
        "id": "88147ab8395d5af8",
        "text": "# The Trouble with ‘Readability'"
      },
      "date": 1633375641804
    },
    {
      "item": {
        "type": "factory",
        "id": "70cac9fba61b3c65"
      },
      "id": "70cac9fba61b3c65",
      "type": "add",
      "after": "88147ab8395d5af8",
      "date": 1633375643478
    },
    {
      "type": "edit",
      "id": "70cac9fba61b3c65",
      "item": {
        "type": "markdown",
        "id": "70cac9fba61b3c65",
        "text": "\n\n\n\nWe programmers love to talk about the value of readability in software. But all our rhetoric, even if it were practiced with diligence, suffers from a giant blind spot. "
      },
      "date": 1633375645592
    },
    {
      "item": {
        "type": "factory",
        "id": "5edd5147f7703428"
      },
      "id": "5edd5147f7703428",
      "type": "add",
      "after": "70cac9fba61b3c65",
      "date": 1633375668912
    },
    {
      "type": "edit",
      "id": "5edd5147f7703428",
      "item": {
        "type": "markdown",
        "id": "5edd5147f7703428",
        "text": "## Exhibit A"
      },
      "date": 1633375677122
    },
    {
      "type": "edit",
      "id": "70cac9fba61b3c65",
      "item": {
        "type": "markdown",
        "id": "70cac9fba61b3c65",
        "text": "We programmers love to talk about the value of readability in software. But all our rhetoric, even if it were practiced with diligence, suffers from a giant blind spot. [http://akkartik.name/post/readable-bad page]"
      },
      "date": 1633375695780
    },
    {
      "item": {
        "type": "factory",
        "id": "a60f4611371fdbb2"
      },
      "id": "a60f4611371fdbb2",
      "type": "add",
      "after": "5edd5147f7703428",
      "date": 1633375704937
    },
    {
      "type": "edit",
      "id": "a60f4611371fdbb2",
      "item": {
        "type": "markdown",
        "id": "a60f4611371fdbb2",
        "text": "Here's Douglas Crockford on programming style. For the first half he explains why readability is important: because our brains do far more subconsciously than we tend to realize. The anecdotes are interesting and the presentation is engaging, but the premise is basically preaching to the choir. Of course I want my code to be readable. Sensei, show me how! "
      },
      "date": 1633375709086
    },
    {
      "item": {
        "type": "factory",
        "id": "8316a238bf83738f"
      },
      "id": "8316a238bf83738f",
      "type": "add",
      "after": "a60f4611371fdbb2",
      "date": 1633375718492
    },
    {
      "type": "edit",
      "id": "8316a238bf83738f",
      "item": {
        "type": "video",
        "id": "8316a238bf83738f",
        "text": "YOUTUBE taaEzHI9xyY"
      },
      "date": 1633375729562
    },
    {
      "type": "edit",
      "id": "8316a238bf83738f",
      "item": {
        "type": "video",
        "id": "8316a238bf83738f",
        "text": "YOUTUBE taaEzHI9xyY\nCrockford on JavaScript - Section 8: Programming Style & Your Brain, 2011"
      },
      "date": 1633375756421
    },
    {
      "type": "edit",
      "id": "a60f4611371fdbb2",
      "item": {
        "type": "markdown",
        "id": "a60f4611371fdbb2",
        "text": "Here's Douglas Crockford on programming style. \n"
      },
      "date": 1633376096017
    },
    {
      "type": "add",
      "id": "7f10b05cf4f3c559",
      "item": {
        "type": "markdown",
        "id": "7f10b05cf4f3c559",
        "text": "For the first half he explains why readability is important: because our brains do far more subconsciously than we tend to realize. The anecdotes are interesting and the presentation is engaging, but the premise is basically preaching to the choir. Of course I want my code to be readable. Sensei, show me how! "
      },
      "after": "a60f4611371fdbb2",
      "date": 1633376106532
    },
    {
      "id": "8316a238bf83738f",
      "type": "move",
      "order": [
        "88147ab8395d5af8",
        "70cac9fba61b3c65",
        "5edd5147f7703428",
        "a60f4611371fdbb2",
        "8316a238bf83738f",
        "7f10b05cf4f3c559"
      ],
      "date": 1633376128696
    },
    {
      "type": "edit",
      "id": "7f10b05cf4f3c559",
      "item": {
        "type": "markdown",
        "id": "7f10b05cf4f3c559",
        "text": "For the first half he explains why readability is important: because our brains do far more subconsciously than we tend to realize. The anecdotes are interesting and the presentation is engaging, but the premise is basically preaching to the choir. Of course I want my code to be readable. Sensei, show me how! \n"
      },
      "date": 1633376169055
    },
    {
      "type": "add",
      "id": "3a208bd15634f9c1",
      "item": {
        "type": "markdown",
        "id": "3a208bd15634f9c1",
        "text": "But when he gets to ‘how’, here is what we get: good names, comments and consistent indentation. Wait, what?! After all that discussion about how complex programs are, and how hard to understand, do we really expect to make a dent on global complexity with a few blunt, local rules? Does something not seem off? "
      },
      "after": "7f10b05cf4f3c559",
      "date": 1633376170722
    },
    {
      "type": "edit",
      "id": "3a208bd15634f9c1",
      "item": {
        "type": "markdown",
        "id": "3a208bd15634f9c1",
        "text": "But when he gets to ‘how’, here is what we get: good names, comments and consistent indentation. Wait, what?! After all that discussion about how complex programs are, and how hard to understand, do we really expect to make a dent on *global* complexity with a few blunt, local rules? Does something not seem off? "
      },
      "date": 1633376199522
    },
    {
      "item": {
        "type": "factory",
        "id": "8652cb7f13ad1006"
      },
      "id": "8652cb7f13ad1006",
      "type": "add",
      "after": "3a208bd15634f9c1",
      "date": 1633423878590
    },
    {
      "type": "edit",
      "id": "8652cb7f13ad1006",
      "item": {
        "type": "markdown",
        "id": "8652cb7f13ad1006",
        "text": "## Exhibit B"
      },
      "date": 1633423902452
    },
    {
      "item": {
        "type": "factory",
        "id": "373992a3638c91b8"
      },
      "id": "373992a3638c91b8",
      "type": "add",
      "after": "8652cb7f13ad1006",
      "date": 1633423909308
    },
    {
      "type": "edit",
      "id": "373992a3638c91b8",
      "item": {
        "type": "markdown",
        "id": "373992a3638c91b8",
        "text": "[http://kotaku.com/5975610/the-exceptional-beauty-of-doom-3s-source-code Here]'s a paean to the software quality of Doom 3. It starts out with this utterly promising ideal:\n\n> “Local code should explain, or at least hint at, the overall system design.”\n\nUnfortunately we never hear about the 'overall system design' ever again. Instead we get.. good names, comments and indentation, culminating in the author's ideal of beauty:\n\n> “The two biggest things, for me at least, are stylistic indenting and maximum const-ness.”\n\nI think the fundamental reasons for the quality of Doom 3 have been missed. Observing superficial small-scale features will only take you so far in appreciating the large-scale beauty of a program. "
      },
      "date": 1633423944623
    },
    {
      "item": {
        "type": "factory",
        "id": "9017a6564848db23"
      },
      "id": "9017a6564848db23",
      "type": "add",
      "after": "373992a3638c91b8",
      "date": 1633441257038
    },
    {
      "type": "edit",
      "id": "9017a6564848db23",
      "item": {
        "type": "markdown",
        "id": "9017a6564848db23",
        "text": "## ﻿"
      },
      "date": 1633441263863
    },
    {
      "type": "edit",
      "id": "9017a6564848db23",
      "item": {
        "type": "markdown",
        "id": "9017a6564848db23",
        "text": "## ﻿Exhibit C"
      },
      "date": 1633441270667
    },
    {
      "type": "edit",
      "id": "9017a6564848db23",
      "item": {
        "type": "markdown",
        "id": "9017a6564848db23",
        "text": "## ﻿Exhibit C\n"
      },
      "date": 1633441280390
    },
    {
      "type": "add",
      "id": "ce1de85bf240122c",
      "item": {
        "type": "markdown",
        "id": "ce1de85bf240122c",
        "text": "Kernighan and Pike's classic Practice of Programming takes mostly the code writer's part. For reading you're left again with guidelines in the small: names, comments and indentation. "
      },
      "after": "9017a6564848db23",
      "date": 1633441282235
    },
    {
      "type": "edit",
      "id": "ce1de85bf240122c",
      "item": {
        "type": "markdown",
        "id": "ce1de85bf240122c",
        "text": "Kernighan and Pike's classic [http://www.math.harvard.edu/computing/programming Practice of Programming] takes mostly the code writer's part. For reading you're left again with guidelines in the small: names, comments and indentation. "
      },
      "date": 1633441304957
    },
    {
      "type": "edit",
      "id": "ce1de85bf240122c",
      "item": {
        "type": "markdown",
        "id": "ce1de85bf240122c",
        "text": "Kernighan and Pike's classic [http://www.math.harvard.edu/computing/programming Practice of Programming], [https://web.archive.org/web/20160613163545/https://www.math.harvard.edu/computing/programming archive] takes mostly the code writer's part. For reading you're left again with guidelines in the small: names, comments and indentation. "
      },
      "date": 1633441358293
    },
    {
      "type": "edit",
      "id": "ce1de85bf240122c",
      "item": {
        "type": "markdown",
        "id": "ce1de85bf240122c",
        "text": "Kernighan and Pike's classic [http://www.math.harvard.edu/computing/programming Practice of Programming], [https://web.archive.org/web/20160613163545/https://www.math.harvard.edu/computing/programming archive] takes mostly the code writer's part. For reading you're left again with guidelines in the small: names, comments and indentation. \n"
      },
      "date": 1633441376447
    },
    {
      "type": "add",
      "id": "9dc76c8d83a09914",
      "item": {
        "type": "markdown",
        "id": "9dc76c8d83a09914",
        "text": "## Discussion\n"
      },
      "after": "ce1de85bf240122c",
      "date": 1633441380787
    },
    {
      "type": "add",
      "id": "82c231c86ce82b6b",
      "item": {
        "type": "markdown",
        "id": "82c231c86ce82b6b",
        "text": "I could go on and on. Everytime the discussion turns to readability we skip almost unconsciously to style guides and whatnot. Local rules for a fundamentally global problem.\n\nThis blind spot is baked into the very phrase ‘readable code’. ‘Code’ isn't an amorphous thing that you manage by the pound. You can't make software clean simply by making all the ‘code’ in it more clean. What we really ought to be thinking about is readable programs. Functions aren't readable in isolation, at least not in the most important way. The biggest aid to a function's readability is to convey where it fits in the larger program.\n\nNowhere is this more apparent than with names. All the above articles and more emphasize the value of names. But they all focus on naming conventions and rules of thumb to evaluate the quality of a single name in isolation. In practice, a series of locally well-chosen names gradually end up in overall cacophony. A program with a small harmonious vocabulary of names consistently used is hugely effective regardless of whether its types and variables are visibly distinguished. To put it another way, the readability of a program can be hugely enhanced by the names it doesn't use.\n\nPart of the problem is that talking about local features is easy. It's easy to teach the difference between a good name and a bad name. Once taught, the reader has the satisfaction of going off to judge names all around him. It's far harder to show a globally coherent design without losing the reader.\n\nSimple superficial rules can be applied to any program, but to learn from a well-designed program we must focus on what's unique to it, and not easily transferred to other programs in disparate domains. That again increases the odds of losing the reader.\n\nBut the largest problem is that we programmers are often looking at the world from a parochial perspective: “I built this awesome program, I understand everything about it, and people keep bugging me to accept their crappy changes.” Style guides and conventions are basically tools for the insiders of a software project. If you already understand the global picture it makes sense to focus on the local irritations. But you won't be around forever. Eventually one of these newcomers will take charge of this project, and they'll make a mess if you didn't talk to them enough about the big picture.\n\nLots of thought has gone into the small-scale best practices to help maintainers merge changes from others, but there's been no attempt at learning to communicate large-scale organization to newcomers. Perhaps this is a different skill entirely; if so, it needs a different name than ‘readability’. "
      },
      "after": "9dc76c8d83a09914",
      "date": 1633441399671
    },
    {
      "type": "edit",
      "id": "82c231c86ce82b6b",
      "item": {
        "type": "markdown",
        "id": "82c231c86ce82b6b",
        "text": "I could go on and on. Everytime the discussion turns to readability we skip almost unconsciously to style guides and whatnot. Local rules for a fundamentally global problem.\n\nThis blind spot is baked into the very phrase ‘[http://www.nczonline.net/blog/2012/02/13/book-review-the-art-of-readable-code readable code]’. ‘Code’ isn't an amorphous thing that you manage by the pound. You can't make software clean simply by making all the ‘code’ in it more clean. What we really ought to be thinking about is readable programs. Functions aren't readable in isolation, at least not in the most important way. The biggest aid to a function's readability is to convey where it fits in the larger program.\n\nNowhere is this more apparent than with names. All the above articles and more emphasize the value of names. But they all focus on naming conventions and rules of thumb to evaluate the quality of a single name in isolation. In practice, a series of locally well-chosen names gradually end up in overall cacophony. A program with a small harmonious vocabulary of names consistently used is hugely effective regardless of whether its types and variables are visibly distinguished. To put it another way, the readability of a program can be hugely enhanced by the names it doesn't use.\n\nPart of the problem is that talking about local features is easy. It's easy to teach the difference between a good name and a bad name. Once taught, the reader has the satisfaction of going off to judge names all around him. It's far harder to show a globally coherent design without losing the reader.\n\nSimple superficial rules can be applied to any program, but to learn from a well-designed program we must focus on what's unique to it, and not easily transferred to other programs in disparate domains. That again increases the odds of losing the reader.\n\nBut the largest problem is that we programmers are often looking at the world from a parochial perspective: “I built this awesome program, I understand everything about it, and people keep bugging me to accept their crappy changes.” Style guides and conventions are basically tools for the insiders of a software project. If you already understand the global picture it makes sense to focus on the local irritations. But you won't be around forever. Eventually one of these newcomers will take charge of this project, and they'll make a mess if you didn't talk to them enough about the big picture.\n\nLots of thought has gone into the small-scale best practices to help maintainers merge changes from others, but there's been no attempt at learning to communicate large-scale organization to newcomers. Perhaps this is a different skill entirely; if so, it needs a different name than ‘readability’. "
      },
      "date": 1633441421919
    },
    {
      "type": "edit",
      "id": "82c231c86ce82b6b",
      "item": {
        "type": "markdown",
        "id": "82c231c86ce82b6b",
        "text": "I could go on and on. Everytime the discussion turns to readability we skip almost unconsciously to style guides and whatnot. Local rules for a fundamentally global problem.\n\n"
      },
      "date": 1633441491281
    },
    {
      "type": "add",
      "id": "4fd05dc7416e95d5",
      "item": {
        "type": "markdown",
        "id": "4fd05dc7416e95d5",
        "text": "This blind spot is baked into the very phrase ‘[http://www.nczonline.net/blog/2012/02/13/book-review-the-art-of-readable-code readable code]’. ‘Code’ isn't an amorphous thing that you manage by the pound. You can't make software clean simply by making all the ‘code’ in it more clean. What we really ought to be thinking about is readable *programs*. Functions aren't readable in isolation, at least not in the most important way. The biggest aid to a function's readability is to convey where it fits in the larger program.\n"
      },
      "after": "82c231c86ce82b6b",
      "date": 1633441501834
    },
    {
      "type": "add",
      "id": "91ea240339548b2f",
      "item": {
        "type": "markdown",
        "id": "91ea240339548b2f",
        "text": "Nowhere is this more apparent than with names. All the above articles and more emphasize the value of names. But they all focus on naming conventions and rules of thumb to evaluate the quality of a single name in isolation. In practice, a series of locally well-chosen names gradually end up in overall cacophony. A program with a small harmonious vocabulary of names consistently used is hugely effective regardless of whether its types and variables are visibly distinguished. To put it another way, the readability of a program can be hugely enhanced by the names it doesn't use.\n"
      },
      "after": "4fd05dc7416e95d5",
      "date": 1633441547356
    },
    {
      "type": "add",
      "id": "319eb5f2d6f12904",
      "item": {
        "type": "markdown",
        "id": "319eb5f2d6f12904",
        "text": "\nPart of the problem is that talking about local features is easy. It's easy to teach the difference between a good name and a bad name. Once taught, the reader has the satisfaction of going off to judge names all around him. It's far harder to show a globally coherent design without losing the reader.\n\nSimple superficial rules can be applied to any program, but to learn from a well-designed program we must focus on what's unique to it, and not easily transferred to other programs in disparate domains. That again increases the odds of losing the reader.\n\nBut the largest problem is that we programmers are often looking at the world from a parochial perspective: “I built this awesome program, I understand everything about it, and people keep bugging me to accept their crappy changes.” Style guides and conventions are basically tools for the insiders of a software project. If you already understand the global picture it makes sense to focus on the local irritations. But you won't be around forever. Eventually one of these newcomers will take charge of this project, and they'll make a mess if you didn't talk to them enough about the big picture.\n\nLots of thought has gone into the small-scale best practices to help maintainers merge changes from others, but there's been no attempt at learning to communicate large-scale organization to newcomers. Perhaps this is a different skill entirely; if so, it needs a different name than ‘readability’. "
      },
      "after": "91ea240339548b2f",
      "date": 1633441561405
    },
    {
      "type": "edit",
      "id": "91ea240339548b2f",
      "item": {
        "type": "markdown",
        "id": "91ea240339548b2f",
        "text": "Nowhere is this more apparent than with names. All the above articles and more emphasize the value of names. But they all focus on naming conventions and rules of thumb to evaluate the quality of a *single name in isolation*. In practice, a series of locally well-chosen names gradually end up in overall cacophony. A program with a small harmonious vocabulary of names consistently used is hugely effective regardless of [http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#General_Naming_Rules whether its types and variables are visibly distinguished]. To put it another way, the readability of a program can be hugely enhanced by the names it doesn't use.\n"
      },
      "date": 1633441607866
    },
    {
      "type": "edit",
      "id": "91ea240339548b2f",
      "item": {
        "type": "markdown",
        "id": "91ea240339548b2f",
        "text": "Nowhere is this more apparent than with names. All the above articles and more emphasize the value of names. But they all focus on naming conventions and rules of thumb to evaluate the quality of a *single name in isolation*. In practice, a series of locally well-chosen names gradually end up in overall cacophony. A program with a small harmonious vocabulary of names consistently used is hugely effective regardless of [http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#General_Naming_Rules whether its types and variables are visibly distinguished], [https://web.archive.org/web/20080701113040/https://google-styleguide.googlecode.com/svn/trunk/cppguide.xml archive]. To put it another way, the readability of a program can be hugely enhanced by the names it doesn't use.\n"
      },
      "date": 1633441700186
    },
    {
      "type": "edit",
      "id": "91ea240339548b2f",
      "item": {
        "type": "markdown",
        "id": "91ea240339548b2f",
        "text": "Nowhere is this more apparent than with names. All the above articles and more emphasize the value of names. But they all focus on naming conventions and rules of thumb to evaluate the quality of a *single name in isolation*. In practice, a series of locally well-chosen names gradually end up in overall cacophony. A program with a small harmonious vocabulary of names consistently used is hugely effective regardless of [http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#General_Naming_Rules whether its types and variables are visibly distinguished], [https://web.archive.org/web/20080701113040/https://google-styleguide.googlecode.com/svn/trunk/cppguide.xml archive]. To put it another way, the readability of a program can be hugely enhanced by *the names it doesn't use*.\n"
      },
      "date": 1633441742106
    },
    {
      "type": "edit",
      "id": "319eb5f2d6f12904",
      "item": {
        "type": "markdown",
        "id": "319eb5f2d6f12904",
        "text": "Part of the problem is that talking about local features is easy. It's easy to teach the difference between a good name and a bad name. Once taught, the reader has the satisfaction of going off to judge names all around him. It's far harder to show a globally coherent design without losing the reader.\n\nSimple superficial rules can be applied to any program, but to learn from a well-designed program we must focus on what's unique to it, and not easily transferred to other programs in disparate domains. That again increases the odds of losing the reader.\n\nBut the largest problem is that we programmers are often looking at the world from a parochial perspective: “I built this awesome program, I understand everything about it, and people keep bugging me to accept their crappy changes.” Style guides and conventions are basically tools for the insiders of a software project. If you already understand the global picture it makes sense to focus on the local irritations. But you won't be around forever. Eventually one of these newcomers will take charge of this project, and they'll make a mess if you didn't talk to them enough about the big picture.\n\n\n"
      },
      "date": 1633441848393
    },
    {
      "type": "add",
      "id": "d485d211f1037a27",
      "item": {
        "type": "markdown",
        "id": "d485d211f1037a27",
        "text": "Lots of thought has gone into the small-scale best practices to help maintainers merge changes from others, but there's been no attempt at learning to communicate large-scale organization to newcomers. Perhaps this is a different skill entirely; if so, it needs a different name than ‘readability’. "
      },
      "after": "319eb5f2d6f12904",
      "date": 1633441851329
    },
    {
      "type": "edit",
      "id": "319eb5f2d6f12904",
      "item": {
        "type": "markdown",
        "id": "319eb5f2d6f12904",
        "text": "Part of the problem is that talking about local features is easy. It's easy to teach the difference between a good name and a bad name. Once taught, the reader has the satisfaction of going off to judge names all around him. It's far harder to show a globally coherent design without losing the reader.\n\n\n"
      },
      "date": 1633441854726
    },
    {
      "type": "add",
      "id": "2a859f2a687dc54f",
      "item": {
        "type": "markdown",
        "id": "2a859f2a687dc54f",
        "text": "Simple superficial rules can be applied to any program, but to learn from a well-designed program we must focus on what's unique to it, and not easily transferred to other programs in disparate domains. That again increases the odds of losing the reader.\n\n\n"
      },
      "after": "319eb5f2d6f12904",
      "date": 1633441858132
    },
    {
      "type": "add",
      "id": "1df228b0420ab228",
      "item": {
        "type": "markdown",
        "id": "1df228b0420ab228",
        "text": "But the largest problem is that we programmers are often looking at the world from a parochial perspective: “I built this awesome program, I understand everything about it, and people keep bugging me to accept their crappy changes.” Style guides and conventions are basically tools for the insiders of a software project. If you already understand the global picture it makes sense to focus on the local irritations. But you won't be around forever. Eventually one of these newcomers will take charge of this project, and they'll make a mess [http://akkartik.name/naur.pdf if you didn't talk to them enough about the big picture].\n\n\n"
      },
      "after": "2a859f2a687dc54f",
      "date": 1633441884060
    },
    {
      "type": "edit",
      "id": "1df228b0420ab228",
      "item": {
        "type": "markdown",
        "id": "1df228b0420ab228",
        "text": "But the largest problem is that we programmers are often looking at the world from a parochial perspective: “I built this awesome program, I understand everything about it, and people keep bugging me to accept their crappy changes.” Style guides and conventions are basically tools for the insiders of a software project. If you already understand the global picture it makes sense to focus on the local irritations. But you won't be around forever. Eventually one of these newcomers will take charge of this project, and they'll make a mess [http://akkartik.name/naur.pdf if you didn't talk to them enough about the big picture] – pdf.\n\n\n"
      },
      "date": 1633441895044
    },
    {
      "type": "edit",
      "id": "1df228b0420ab228",
      "item": {
        "type": "markdown",
        "id": "1df228b0420ab228",
        "text": "But the largest problem is that we programmers are often looking at the world from a parochial perspective: “I built this awesome program, I understand everything about it, and people keep bugging me to accept their crappy changes.” Style guides and conventions are basically tools for the insiders of a software project. If you already understand the global picture it makes sense to focus on the local irritations. But you won't be around forever. Eventually one of these newcomers will take charge of this project, and they'll make a mess [http://akkartik.name/naur.pdf if you didn't talk to them enough about the big picture] – pdf of P. Naur, “Programming as theory building,” Microprocessing and Microprogramming, vol. 15, no. 5, pp. 253–261, May 1985, doi: 10.1016/0165-6074(85)90032-8.\n\n\n"
      },
      "date": 1633442146425
    },
    {
      "type": "edit",
      "id": "70cac9fba61b3c65",
      "item": {
        "type": "markdown",
        "id": "70cac9fba61b3c65",
        "text": "http://akkartik.name/post/readable-bad page] – We programmers love to talk about the value of readability in software. But all our rhetoric, even if it were practiced with diligence, suffers from a giant blind spot. ["
      },
      "date": 1633444904311
    },
    {
      "type": "edit",
      "id": "70cac9fba61b3c65",
      "item": {
        "type": "markdown",
        "id": "70cac9fba61b3c65",
        "text": "[http://akkartik.name/post/readable-bad page] – We programmers love to talk about the value of readability in software. But all our rhetoric, even if it were practiced with diligence, suffers from a giant blind spot."
      },
      "date": 1633444914841
    },
    {
      "type": "edit",
      "id": "70cac9fba61b3c65",
      "item": {
        "type": "markdown",
        "id": "70cac9fba61b3c65",
        "text": "[http://akkartik.name/post/readable-bad Kartik Agaram's page] – We programmers love to talk about the value of readability in software. But all our rhetoric, even if it were practiced with diligence, suffers from a giant blind spot."
      },
      "date": 1633444961217
    },
    {
      "type": "edit",
      "id": "d485d211f1037a27",
      "item": {
        "type": "markdown",
        "id": "d485d211f1037a27",
        "text": "Lots of thought has gone into the small-scale best practices to help maintainers merge changes from others, but there's been no attempt at learning to communicate large-scale organization to newcomers. Perhaps this is a different skill entirely; if so, it needs a different name than ‘readability’. \n"
      },
      "date": 1633444986586
    },
    {
      "type": "add",
      "id": "e10e2e46b6380d6a",
      "item": {
        "type": "markdown",
        "id": "e10e2e46b6380d6a",
        "text": "See [[Kartik Agaram]]."
      },
      "after": "d485d211f1037a27",
      "date": 1633444993530
    },
    {
      "type": "edit",
      "id": "a60f4611371fdbb2",
      "item": {
        "type": "markdown",
        "id": "a60f4611371fdbb2",
        "text": "Here's [[Douglas Crockford]] on programming style. \n"
      },
      "date": 1633446055347
    }
  ]
}