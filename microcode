{
  "title": "Microcode",
  "story": [
    {
      "type": "paragraph",
      "id": "998e5dcb80d659d0",
      "text": "Machine instructions are generally considered the basic steps that a computer performs. However, each instruction usually requires multiple operations inside the processor. [https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html post]"
    },
    {
      "type": "paragraph",
      "id": "ecb9e7b0a6972af0",
      "text": "For instance, an ADD instruction may involve computing the memory address, accessing the value, moving the value to the Arithmetic-Logic Unit (ALU), computing the sum, and storing the result in a register. One of the hardest parts of computer design is creating the control logic that signals the appropriate parts of the processor for each step of an instruction. The straightforward approach is to build a circuit from flip-flops and gates that moves through the various steps and generates the control signals. However, this circuitry is complicated and error-prone."
    },
    {
      "type": "paragraph",
      "id": "cdfccb6755f294fd",
      "text": "In 1951, [[Maurice Wilkes]] came up with the idea of microcode: instead of building the control circuitry from complex logic gates, the control logic could be replaced with another layer of code (i. e. microcode) stored in a special memory called a control store. To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode. In other words, microcode forms another layer between the machine instructions and the hardware. The main advantage of microcode is that it turns the processor's control logic into a programming task instead of a difficult logic design task. Microcode also permits complex instructions and a large instruction set to be implemented without making the processor more complex (apart from the size of the microcode). Finally, it is generally easier to fix a bug in microcode than in circuit logic."
    },
    {
      "type": "paragraph",
      "id": "1b6095c4e898607a",
      "text": "Early computers didn't use microcode, largely due to the lack of good storage technologies to hold the microcode. This changed in the 1960s; for example IBM made extensive use of microcode in the System/360 (1964). ([[Ken Shirriff]] has written about \"Simulating the IBM 360/50 mainframe from its microcode\" [https://www.righto.com/2022/01/ibm360model50.html post].) But early microprocessors didn't use microcode, returning to hard-coded control logic with logic gates. This logic was generally more compact and ran faster than microcode, since the circuitry could be optimized. Since space was at a premium in early microprocessors and the instruction sets were relatively simple, this tradeoff made sense. But as microprocessor instruction sets became complex and transistors became cheaper, microcode became appealing. This led to the use of microcode in the Intel 8086 (1978) and 8088 (1979) and Motorola 68000 (1979), for instance."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Microcode",
        "story": []
      },
      "date": 1679638601951
    },
    {
      "item": {
        "type": "factory",
        "id": "998e5dcb80d659d0"
      },
      "id": "998e5dcb80d659d0",
      "type": "add",
      "date": 1679638610710
    },
    {
      "type": "edit",
      "id": "998e5dcb80d659d0",
      "item": {
        "type": "paragraph",
        "id": "998e5dcb80d659d0",
        "text": "Machine instructions are generally considered the basic steps that a computer performs. However, each instruction usually requires multiple operations inside the processor. For instance, an ADD instruction may involve computing the memory address, accessing the value, moving the value to the Arithmetic-Logic Unit (ALU), computing the sum, and storing the result in a register. One of the hardest parts of computer design is creating the control logic that signals the appropriate parts of the processor for each step of an instruction. The straightforward approach is to build a circuit from flip-flops and gates that moves through the various steps and generates the control signals. However, this circuitry is complicated and error-prone."
      },
      "date": 1679638613717
    },
    {
      "type": "edit",
      "id": "998e5dcb80d659d0",
      "item": {
        "type": "paragraph",
        "id": "998e5dcb80d659d0",
        "text": "Machine instructions are generally considered the basic steps that a computer performs. However, each instruction usually requires multiple operations inside the processor. [https://www.righto.com/2022/11/how-8086-processors-microcode-engine.html post]"
      },
      "date": 1679638632069
    },
    {
      "type": "add",
      "id": "ecb9e7b0a6972af0",
      "item": {
        "type": "paragraph",
        "id": "ecb9e7b0a6972af0",
        "text": "For instance, an ADD instruction may involve computing the memory address, accessing the value, moving the value to the Arithmetic-Logic Unit (ALU), computing the sum, and storing the result in a register. One of the hardest parts of computer design is creating the control logic that signals the appropriate parts of the processor for each step of an instruction. The straightforward approach is to build a circuit from flip-flops and gates that moves through the various steps and generates the control signals. However, this circuitry is complicated and error-prone."
      },
      "after": "998e5dcb80d659d0",
      "date": 1679638632599
    },
    {
      "item": {
        "type": "factory",
        "id": "cdfccb6755f294fd"
      },
      "id": "cdfccb6755f294fd",
      "type": "add",
      "after": "ecb9e7b0a6972af0",
      "date": 1679638678154
    },
    {
      "type": "edit",
      "id": "cdfccb6755f294fd",
      "item": {
        "type": "paragraph",
        "id": "cdfccb6755f294fd",
        "text": "In 1951, Maurice Wilkes came up with the idea of microcode: instead of building the control circuitry from complex logic gates, the control logic could be replaced with another layer of code (i. e. microcode) stored in a special memory called a control store. To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode. In other words, microcode forms another layer between the machine instructions and the hardware. The main advantage of microcode is that it turns the processor's control logic into a programming task instead of a difficult logic design task. Microcode also permits complex instructions and a large instruction set to be implemented without making the processor more complex (apart from the size of the microcode). Finally, it is generally easier to fix a bug in microcode than in circuit logic."
      },
      "date": 1679638679747
    },
    {
      "type": "edit",
      "id": "cdfccb6755f294fd",
      "item": {
        "type": "paragraph",
        "id": "cdfccb6755f294fd",
        "text": "In 1951, [[Maurice Wilkes]] came up with the idea of microcode: instead of building the control circuitry from complex logic gates, the control logic could be replaced with another layer of code (i. e. microcode) stored in a special memory called a control store. To execute a machine instruction, the computer internally executes several simpler micro-instructions, specified by the microcode. In other words, microcode forms another layer between the machine instructions and the hardware. The main advantage of microcode is that it turns the processor's control logic into a programming task instead of a difficult logic design task. Microcode also permits complex instructions and a large instruction set to be implemented without making the processor more complex (apart from the size of the microcode). Finally, it is generally easier to fix a bug in microcode than in circuit logic."
      },
      "date": 1679638696513
    },
    {
      "item": {
        "type": "factory",
        "id": "1b6095c4e898607a"
      },
      "id": "1b6095c4e898607a",
      "type": "add",
      "after": "cdfccb6755f294fd",
      "date": 1679638754313
    },
    {
      "type": "edit",
      "id": "1b6095c4e898607a",
      "item": {
        "type": "paragraph",
        "id": "1b6095c4e898607a",
        "text": "Early computers didn't use microcode, largely due to the lack of good storage technologies to hold the microcode. This changed in the 1960s; for example IBM made extensive use of microcode in the System/360 (1964). (I've written about that here.) But early microprocessors didn't use microcode, returning to hard-coded control logic with logic gates.3 This logic was generally more compact and ran faster than microcode, since the circuitry could be optimized. Since space was at a premium in early microprocessors and the instruction sets were relatively simple, this tradeoff made sense. But as microprocessor instruction sets became complex and transistors became cheaper, microcode became appealing. This led to the use of microcode in the Intel 8086 (1978) and 8088 (1979) and Motorola 68000 (1979), for instance."
      },
      "date": 1679638762207
    },
    {
      "type": "edit",
      "id": "1b6095c4e898607a",
      "item": {
        "type": "paragraph",
        "id": "1b6095c4e898607a",
        "text": "Early computers didn't use microcode, largely due to the lack of good storage technologies to hold the microcode. This changed in the 1960s; for example IBM made extensive use of microcode in the System/360 (1964). ([[Ken Shirriff]] has written about that here.) But early microprocessors didn't use microcode, returning to hard-coded control logic with logic gates. This logic was generally more compact and ran faster than microcode, since the circuitry could be optimized. Since space was at a premium in early microprocessors and the instruction sets were relatively simple, this tradeoff made sense. But as microprocessor instruction sets became complex and transistors became cheaper, microcode became appealing. This led to the use of microcode in the Intel 8086 (1978) and 8088 (1979) and Motorola 68000 (1979), for instance."
      },
      "date": 1679638838720
    },
    {
      "type": "edit",
      "id": "1b6095c4e898607a",
      "item": {
        "type": "paragraph",
        "id": "1b6095c4e898607a",
        "text": "Early computers didn't use microcode, largely due to the lack of good storage technologies to hold the microcode. This changed in the 1960s; for example IBM made extensive use of microcode in the System/360 (1964). ([[Ken Shirriff]] has written about [Simulating the IBM 360/50 mainframe from its microcode].) But early microprocessors didn't use microcode, returning to hard-coded control logic with logic gates. This logic was generally more compact and ran faster than microcode, since the circuitry could be optimized. Since space was at a premium in early microprocessors and the instruction sets were relatively simple, this tradeoff made sense. But as microprocessor instruction sets became complex and transistors became cheaper, microcode became appealing. This led to the use of microcode in the Intel 8086 (1978) and 8088 (1979) and Motorola 68000 (1979), for instance."
      },
      "date": 1679638903566
    },
    {
      "type": "edit",
      "id": "1b6095c4e898607a",
      "item": {
        "type": "paragraph",
        "id": "1b6095c4e898607a",
        "text": "Early computers didn't use microcode, largely due to the lack of good storage technologies to hold the microcode. This changed in the 1960s; for example IBM made extensive use of microcode in the System/360 (1964). ([[Ken Shirriff]] has written about \"Simulating the IBM 360/50 mainframe from its microcode\" [https://www.righto.com/2022/01/ibm360model50.html post].) But early microprocessors didn't use microcode, returning to hard-coded control logic with logic gates. This logic was generally more compact and ran faster than microcode, since the circuitry could be optimized. Since space was at a premium in early microprocessors and the instruction sets were relatively simple, this tradeoff made sense. But as microprocessor instruction sets became complex and transistors became cheaper, microcode became appealing. This led to the use of microcode in the Intel 8086 (1978) and 8088 (1979) and Motorola 68000 (1979), for instance."
      },
      "date": 1679638948135
    }
  ]
}