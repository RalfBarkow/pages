{
  "title": "Node style callback",
  "story": [
    {
      "type": "paragraph",
      "id": "6affeb4cd61e4212",
      "text": "Community convention eases the cognitive burden on all of us. The less that is unique about an api, the less we have to learn to use it effectively. One of the most effective conventions introduced by the Node community, and adopted across JavaScript thanks largely to NPM, is the \"Node style callback\". When exposing a Node style callback api to our users we are making a promise that we are doing things the way they expect, and getting the details wrong is one of the [[JavaScript common pitfalls]]."
    },
    {
      "type": "paragraph",
      "id": "f51ca75f45e52ac5",
      "text": "The callback is the last argument. No matter how many arguments are passed, even if it's a variable argument API, it has to be the last one."
    },
    {
      "type": "paragraph",
      "id": "cb3fea91c5ec8e92",
      "text": "The callback will be called exactly once. Even if there are multiple error conditions. Wrap it using the 'once' library if you don't want to worry about it."
    },
    {
      "type": "paragraph",
      "id": "5b63dd49064c4a8e",
      "text": "The first argument to the callback is null if everything succeeded, or an error if it failed. The API will NOT throw an error asynchronously (because the calling code can't catch it, and that's mean)."
    },
    {
      "type": "paragraph",
      "id": "026bdc9caa9693d7",
      "text": "The second argument should be the main results, additional arguments may be passed with supplementary stuff. The 80% use case shouldn't have to know there are more arguments, when possible."
    },
    {
      "type": "paragraph",
      "id": "e2d1e0f81500e476",
      "text": "The callback will always be called asynchronously. Lest you release [http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony Zalgo]."
    },
    {
      "type": "paragraph",
      "id": "58d1f3d1cf0626a8",
      "text": "Some of these requirements may seem silly in one case or another, but before this became a community convention it was anarchy. In the old west of the web, chaos reigned, each api would take a different number of functions passed in different ways, sometimes as objects with \"error\" and \"success\" functions as properties, sometimes as the first function. Some API's would throw uncatchable errors."
    },
    {
      "type": "paragraph",
      "id": "8ee0e24f7c0988d8",
      "text": "The value of the Node Style Callback isn't really that it's a nice way to create an asynchronous API (though it is pretty nice). It's that by buying in and building APIs like this, when other people use our module it just works like they expect. And we get the same out of their modules. No digging in the documentation to find out how to pass an error handler so we can figure out why this damn library is hanging forever and never calling me back."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Node style callback",
        "story": []
      },
      "date": 1433225677319
    },
    {
      "item": {
        "type": "factory",
        "id": "6affeb4cd61e4212"
      },
      "id": "6affeb4cd61e4212",
      "type": "add",
      "date": 1433225681393
    },
    {
      "type": "edit",
      "id": "6affeb4cd61e4212",
      "item": {
        "type": "paragraph",
        "id": "6affeb4cd61e4212",
        "text": "Community convention eases the cognitive burden on all of us. The less that is unique about an api, the less we have to learn to use it effectively. One of the most effective conventions introduced by the Node community, and adopted across JavaScript thanks largely to NPM, is the \"Node style callback\". When exposing a Node style callback api to our users we are making a promise that we are doing things the way they expect, and getting the details wrong is one of the [[JavaScript common pitfalls]]."
      },
      "date": 1433226094186
    },
    {
      "item": {
        "type": "factory",
        "id": "f51ca75f45e52ac5"
      },
      "id": "f51ca75f45e52ac5",
      "type": "add",
      "after": "6affeb4cd61e4212",
      "date": 1433226100248
    },
    {
      "type": "edit",
      "id": "f51ca75f45e52ac5",
      "item": {
        "type": "paragraph",
        "id": "f51ca75f45e52ac5",
        "text": "The callback is the last argument."
      },
      "date": 1433226172284
    },
    {
      "type": "add",
      "id": "cb3fea91c5ec8e92",
      "item": {
        "type": "paragraph",
        "id": "cb3fea91c5ec8e92",
        "text": "The callback will be called exactly once."
      },
      "after": "f51ca75f45e52ac5",
      "date": 1433226184778
    },
    {
      "type": "add",
      "id": "5b63dd49064c4a8e",
      "item": {
        "type": "paragraph",
        "id": "5b63dd49064c4a8e",
        "text": "The first argument to the callback is null if everything succeeded, or an error if it failed. The API will NOT throw an error asynchronously."
      },
      "after": "cb3fea91c5ec8e92",
      "date": 1433226250473
    },
    {
      "type": "add",
      "id": "026bdc9caa9693d7",
      "item": {
        "type": "paragraph",
        "id": "026bdc9caa9693d7",
        "text": "The second argument should be the main results, additional arguments may be passed with supplementary stuff."
      },
      "after": "5b63dd49064c4a8e",
      "date": 1433226388073
    },
    {
      "type": "add",
      "id": "e2d1e0f81500e476",
      "item": {
        "type": "paragraph",
        "id": "e2d1e0f81500e476",
        "text": "The callback will always be called asynchronously."
      },
      "after": "026bdc9caa9693d7",
      "date": 1433226460378
    },
    {
      "type": "add",
      "id": "58d1f3d1cf0626a8",
      "item": {
        "type": "paragraph",
        "id": "58d1f3d1cf0626a8",
        "text": "Some of these requirements may seem silly in one case or another, but before this became a community convention it was anarchy. In the old west of the web, chaos reigned, each api would take a different number of functions passed in different ways, sometimes as objects with \"error\" and \"success\" functions as properties, sometimes as the first function. Some API's would throw uncatchable errors."
      },
      "after": "e2d1e0f81500e476",
      "date": 1433226654803
    },
    {
      "type": "add",
      "id": "8ee0e24f7c0988d8",
      "item": {
        "type": "paragraph",
        "id": "8ee0e24f7c0988d8",
        "text": "The value of the Node Style Callback isn't really that it's a nice way to create an asynchronous API (though it is pretty nice). It's that by buying in and building APIs like this, when other people use our module it just works like they expect. And we get the same out of their modules. No digging in the documentation to find out how to pass an error handler so we can figure out why this damn library is hanging forever and never calling me back."
      },
      "after": "58d1f3d1cf0626a8",
      "date": 1433226883007
    },
    {
      "type": "edit",
      "id": "f51ca75f45e52ac5",
      "item": {
        "type": "paragraph",
        "id": "f51ca75f45e52ac5",
        "text": "The callback is the last argument. No matter how many arguments are passed, even if it's a variable argument API, it has to be the last one."
      },
      "date": 1433227361576
    },
    {
      "type": "edit",
      "id": "cb3fea91c5ec8e92",
      "item": {
        "type": "paragraph",
        "id": "cb3fea91c5ec8e92",
        "text": "The callback will be called exactly once. Even if there are multiple error conditions. Wrap it using the 'once' library if you don't want to worry about it."
      },
      "date": 1433227454249
    },
    {
      "type": "edit",
      "id": "5b63dd49064c4a8e",
      "item": {
        "type": "paragraph",
        "id": "5b63dd49064c4a8e",
        "text": "The first argument to the callback is null if everything succeeded, or an error if it failed. The API will NOT throw an error asynchronously (because the calling code can't catch it, and that's mean)."
      },
      "date": 1433227511153
    },
    {
      "type": "edit",
      "id": "026bdc9caa9693d7",
      "item": {
        "type": "paragraph",
        "id": "026bdc9caa9693d7",
        "text": "The second argument should be the main results, additional arguments may be passed with supplementary stuff. The 80% use case shouldn't have to know there are more arguments, when possible."
      },
      "date": 1433227625408
    },
    {
      "type": "edit",
      "id": "e2d1e0f81500e476",
      "item": {
        "type": "paragraph",
        "id": "e2d1e0f81500e476",
        "text": "The callback will always be called asynchronously. Lest you release [http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony Zalgo]."
      },
      "date": 1433227694338
    },
    {
      "type": "fork",
      "site": "nrn.io",
      "date": 1652868574004
    }
  ]
}