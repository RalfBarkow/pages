{
  "title": "Reflective",
  "story": [
    {
      "type": "reference",
      "site": "localhost:3000",
      "slug": "reflective-capabilities",
      "title": "Reflective Capabilities",
      "text": "Since [[Smalltalk]] is so dynamic, everything occurs at run-time, including programming. Because of this dynamicity and uniformity, it supports a set of advanced reflective capabilities that allows easy implementation of IDEs. For example, browsing the code can be achieved by introspection through a sequence of 4 messages: (1) send a message to the environment to get the list of packages; (2) send a message to a given package to get its classes; (3) send a message to a class to get the list of its methods; (4) send a message to a method to get its source"
    },
    {
      "type": "reference",
      "site": "localhost:3000",
      "slug": "a-reflective-language",
      "title": "A Reflective Language",
      "text": "RIVARD, Fred. Smalltalk: [[A Reflective Language]]. In: Proceedings of REFLECTION. 1996. S. 21-38. [http://ftp.linux62.org/~glibersat/publis/Riva96.pdf pdf]",
      "id": "0672f4821458fa2d"
    },
    {
      "type": "markdown",
      "id": "ab1b1e33fcd29bac",
      "text": "> […] Programmers gain confidence that facilities that are not already available in a given environment can easily be constructed. Current systems make it easy to define data types like complex or arbitrary precision numbers. New object types becomeas “first class” as those built into the language. A big part of the appeal of object-oriented programming is that programmers believe that, if they really wanted to, they could [[Redefine the World]]."
    },
    {
      "type": "reference",
      "site": "localhost:3000",
      "slug": "reflective-wiki",
      "title": "Reflective Wiki",
      "text": "Spawned from Wiki Placename Problem by this comment:",
      "id": "4c39203c6e7839d2"
    },
    {
      "type": "markdown",
      "id": "2b17928dbb424703",
      "text": "> […], a \"reflective\" Wiki which could be used to alter its own source code […]"
    },
    {
      "type": "graphviz",
      "id": "1edca9867e95038f",
      "text": "DOT FROM two-level-diagram\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Reflective",
        "story": []
      },
      "date": 1701884532806
    },
    {
      "type": "add",
      "item": {
        "type": "reference",
        "site": "localhost:3000",
        "slug": "reflective-capabilities",
        "title": "Reflective Capabilities",
        "text": "Since Smalltalk is so dynamic, everything occurs at [[run-time]], including programming. Because of this dynamicity and uniformity, it supports a set of advanced reflective capabilities that allows easy implementation of IDEs. For example, browsing the code can be achieved by introspection through a sequence of 4 messages: (1) send a message to the environment to get the list of packages; (2) send a message to a given package to get its classes; (3) send a message to a class to get the list of its methods; (4) send a message to a method to get its source"
      },
      "date": 1701884535643
    },
    {
      "id": "0672f4821458fa2d",
      "type": "add",
      "item": {
        "type": "reference",
        "site": "localhost:3000",
        "slug": "a-reflective-language",
        "title": "A Reflective Language",
        "text": "RIVARD, Fred. Smalltalk: [[A Reflective Language]]. In: Proceedings of REFLECTION. 1996. S. 21-38. [http://ftp.linux62.org/~glibersat/publis/Riva96.pdf pdf]",
        "id": "0672f4821458fa2d"
      },
      "date": 1701884551329
    },
    {
      "id": "4c39203c6e7839d2",
      "type": "add",
      "item": {
        "type": "reference",
        "site": "localhost:3000",
        "slug": "reflective-wiki",
        "title": "Reflective Wiki",
        "text": "Spawned from [[Wiki Placename Problem]] by this comment:",
        "id": "4c39203c6e7839d2"
      },
      "after": "0672f4821458fa2d",
      "date": 1701884556467
    },
    {
      "id": "8f5e5accbb6c77d8087fb233f13538c5",
      "type": "add",
      "item": {
        "type": "html",
        "text": "<i>Actually, a \"reflective\" Wiki which could be used to alter its own source code would be a very worthwhile thing. On the other hand, it is also most definitely and absolutely certainly a stupid idea and one that couldn't possibly work, ever ever. On the gripping hand an [[Object Oriented Wiki]] could certainly work. Combine that with [[Mana Mana]] and one might have a [[Tar Baby]]. Hmm.</i> -- [[Peter Merel]]",
        "id": "8f5e5accbb6c77d8087fb233f13538c5"
      },
      "after": "4c39203c6e7839d2",
      "attribution": {
        "page": "Reflective Wiki"
      },
      "date": 1701884584369
    },
    {
      "type": "edit",
      "id": "8f5e5accbb6c77d8087fb233f13538c5",
      "item": {
        "type": "html",
        "text": "[…], a \"reflective\" Wiki which could be used to alter its own source code […]",
        "id": "8f5e5accbb6c77d8087fb233f13538c5"
      },
      "date": 1701884617120
    },
    {
      "type": "edit",
      "item": {
        "type": "reference",
        "site": "localhost:3000",
        "slug": "reflective-capabilities",
        "title": "Reflective Capabilities",
        "text": "Since Smalltalk is so dynamic, everything occurs at run-time, including programming. Because of this dynamicity and uniformity, it supports a set of advanced reflective capabilities that allows easy implementation of IDEs. For example, browsing the code can be achieved by introspection through a sequence of 4 messages: (1) send a message to the environment to get the list of packages; (2) send a message to a given package to get its classes; (3) send a message to a class to get the list of its methods; (4) send a message to a method to get its source"
      },
      "date": 1701884695783
    },
    {
      "type": "remove",
      "id": "8f5e5accbb6c77d8087fb233f13538c5",
      "date": 1701885194682
    },
    {
      "type": "edit",
      "id": "be0a54768475091e",
      "item": {
        "type": "markdown",
        "id": "be0a54768475091e",
        "text": "> […], a \"reflective\" Wiki which could be used to alter its own source code […]"
      },
      "date": 1701885198754
    },
    {
      "item": {
        "type": "factory",
        "id": "ab1b1e33fcd29bac"
      },
      "id": "ab1b1e33fcd29bac",
      "type": "add",
      "after": "4c39203c6e7839d2",
      "date": 1701899141209
    },
    {
      "type": "edit",
      "id": "ab1b1e33fcd29bac",
      "item": {
        "type": "markdown",
        "id": "ab1b1e33fcd29bac",
        "text": "> […] Programmers gain confidence that facilities that are not already available in a given environment can easily be constructed. Current systemsmake it easy to define data types like complex or arbitrary precision numbers. New object types becomeas “first class” as those built into the language. A big part of the appeal of objectoriented programming is that programmers believe that, if they really wanted to, they could redefine the world."
      },
      "date": 1701899148914
    },
    {
      "id": "ab1b1e33fcd29bac",
      "type": "move",
      "order": [
        "undefined",
        "0672f4821458fa2d",
        "ab1b1e33fcd29bac",
        "4c39203c6e7839d2"
      ],
      "date": 1701899187453,
      "error": {
        "type": "error",
        "msg": "Internal Server Error",
        "response": "Server Ignoring move. Try reload."
      }
    },
    {
      "type": "fork",
      "date": 1701899189379
    },
    {
      "id": "8f5e5accbb6c77d8087fb233f13538c5",
      "type": "add",
      "item": {
        "type": "html",
        "text": "<i>Actually, a \"reflective\" Wiki which could be used to alter its own source code would be a very worthwhile thing. On the other hand, it is also most definitely and absolutely certainly a stupid idea and one that couldn't possibly work, ever ever. On the gripping hand an [[Object Oriented Wiki]] could certainly work. Combine that with [[Mana Mana]] and one might have a [[Tar Baby]]. Hmm.</i> -- [[Peter Merel]]",
        "id": "8f5e5accbb6c77d8087fb233f13538c5"
      },
      "after": "4c39203c6e7839d2",
      "attribution": {
        "page": "Reflective Wiki"
      },
      "date": 1701899230090
    },
    {
      "type": "edit",
      "id": "8f5e5accbb6c77d8087fb233f13538c5",
      "item": {
        "type": "html",
        "text": "[…], a \"reflective\" Wiki which could be used to alter its own source code […]",
        "id": "8f5e5accbb6c77d8087fb233f13538c5"
      },
      "date": 1701899251759
    },
    {
      "type": "remove",
      "id": "8f5e5accbb6c77d8087fb233f13538c5",
      "date": 1701899259302
    },
    {
      "item": {
        "type": "factory",
        "id": "2b17928dbb424703"
      },
      "id": "2b17928dbb424703",
      "type": "add",
      "after": "4c39203c6e7839d2",
      "date": 1701899260489
    },
    {
      "type": "edit",
      "id": "2b17928dbb424703",
      "item": {
        "type": "markdown",
        "id": "2b17928dbb424703",
        "text": "> […], a \"reflective\" Wiki which could be used to alter its own source code […]"
      },
      "date": 1701899263333
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1701899390004
    },
    {
      "type": "edit",
      "item": {
        "type": "reference",
        "site": "localhost:3000",
        "slug": "reflective-capabilities",
        "title": "Reflective Capabilities",
        "text": "Since [[Smalltalk]] is so dynamic, everything occurs at run-time, including programming. Because of this dynamicity and uniformity, it supports a set of advanced reflective capabilities that allows easy implementation of IDEs. For example, browsing the code can be achieved by introspection through a sequence of 4 messages: (1) send a message to the environment to get the list of packages; (2) send a message to a given package to get its classes; (3) send a message to a class to get the list of its methods; (4) send a message to a method to get its source"
      },
      "date": 1701899438208
    },
    {
      "item": {
        "type": "factory",
        "id": "1413672f4a02c53b"
      },
      "id": "1413672f4a02c53b",
      "type": "add",
      "after": "2b17928dbb424703",
      "date": 1701899609778
    },
    {
      "item": {
        "type": "factory",
        "id": "1edca9867e95038f"
      },
      "id": "1edca9867e95038f",
      "type": "add",
      "after": "1413672f4a02c53b",
      "date": 1701899614561
    },
    {
      "type": "edit",
      "id": "1edca9867e95038f",
      "item": {
        "type": "graphviz",
        "id": "1edca9867e95038f",
        "text": "DOT FROM two-level-diagram\n"
      },
      "date": 1701899617456
    },
    {
      "type": "remove",
      "id": "1413672f4a02c53b",
      "date": 1701899624173
    },
    {
      "type": "edit",
      "id": "4c39203c6e7839d2",
      "item": {
        "type": "reference",
        "site": "localhost:3000",
        "slug": "reflective-wiki",
        "title": "Reflective Wiki",
        "text": "Spawned from Wiki Placename Problem by this comment:",
        "id": "4c39203c6e7839d2"
      },
      "date": 1701899794828
    },
    {
      "type": "edit",
      "id": "ab1b1e33fcd29bac",
      "item": {
        "type": "markdown",
        "id": "ab1b1e33fcd29bac",
        "text": "> […] Programmers gain confidence that facilities that are not already available in a given environment can easily be constructed. Current systems make it easy to define data types like complex or arbitrary precision numbers. New object types becomeas “first class” as those built into the language. A big part of the appeal of objectoriented programming is that programmers believe that, if they really wanted to, they could redefine the world."
      },
      "date": 1701899900320
    },
    {
      "type": "edit",
      "id": "ab1b1e33fcd29bac",
      "item": {
        "type": "markdown",
        "id": "ab1b1e33fcd29bac",
        "text": "> […] Programmers gain confidence that facilities that are not already available in a given environment can easily be constructed. Current systems make it easy to define data types like complex or arbitrary precision numbers. New object types becomeas “first class” as those built into the language. A big part of the appeal of object-oriented programming is that programmers believe that, if they really wanted to, they could redefine the world."
      },
      "date": 1701899920928
    },
    {
      "item": {
        "type": "factory",
        "id": "13a0f16c578eead1"
      },
      "id": "13a0f16c578eead1",
      "type": "add",
      "after": "1edca9867e95038f",
      "date": 1701899954248
    },
    {
      "type": "edit",
      "id": "13a0f16c578eead1",
      "item": {
        "type": "paragraph",
        "id": "13a0f16c578eead1",
        "text": "[[Redefine the World]]"
      },
      "date": 1701899958710
    },
    {
      "type": "remove",
      "id": "13a0f16c578eead1",
      "date": 1701899993897
    },
    {
      "type": "edit",
      "id": "ab1b1e33fcd29bac",
      "item": {
        "type": "markdown",
        "id": "ab1b1e33fcd29bac",
        "text": "> […] Programmers gain confidence that facilities that are not already available in a given environment can easily be constructed. Current systems make it easy to define data types like complex or arbitrary precision numbers. New object types becomeas “first class” as those built into the language. A big part of the appeal of object-oriented programming is that programmers believe that, if they really wanted to, they could [[Redefine the World]]."
      },
      "date": 1701900000814
    }
  ]
}