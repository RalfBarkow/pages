{
  "title": "cypher.js",
  "story": [
    {
      "type": "code",
      "id": "cbfea75e014416c8",
      "text": "export let left, right\nexport function parse(text, log=()=>{}) {\n  const r = {}, x = {}             // rules defined and traced\n  left = '', right = text          // text parsed and pending\n  let branch = []                  // abstract syntax tree in progress\n  const tree = [branch]\n\n  // Non-Terminal Symbols\n\n  r.match = () => x.sp() && x.term('match') && x.node() && x.chain() && x.eot()\n  r.node = () => x.ch('(') && x.elem()  && x.ch(')')\n  r.chain = () => any(() => x.rel() && x.node() && x.chain())\n  r.rel = () => one(() => x.in(), () => x.out(), () => x.both())\n  r.in = () => x.term('<-') && opt(() => x.ch('[') && x.elem() && x.ch(']')) && x.ch('-')\n  r.out = () => x.ch('-') && opt(() => x.ch('[') && x.elem() && x.ch(']')) && x.term('->')\n  r.both = () => x.ch('-') && opt(() => x.ch('[') && x.elem() && x.ch(']')) && x.ch('-')\n  r.elem = () => opt(() => x.bind()) && opt(() => x.ch(':') && x.type()) && opt(() => x.prop())\n  r.prop = () => x.ch('{') && x.word() && x.ch(':')  && x.expr() && x.ch('}')\n  r.expr = () => x.strn()\n  r.bind = () => x.word()\n  r.type = () => x.word()\n\n  // Terminal Symbols\n\n  r.word = () => match(/^[A-Za-z][A-Za-z0-9_]*/) && x.sp()\n  r.term = want => right.startsWith(want) && accept(want.length) && keep(want) && x.sp()\n  r.strn = () => x.ch('\"') && match(/^[^\"]{0,20}/) && x.ch('\"') && x.sp()\n  r.ch = char => right.startsWith(char) && accept(1) && keep(char) && x.sp()\n  r.sp = () => match(/^\\s*/)\n  r.eot = () => !right.length\n\n  // Parse Instrumentation\n\n  for (const op in r) {\n    x[op] = (...args) => {\n      log(`${left}%c${op}%c${right}`,\"color:red\",\"color:black\");\n      const here = branch\n      branch = [op]\n      const success = r[op](...args)\n      if (success) here.push(branch)\n      branch = here\n      return success\n    }\n  }\n\n  // Parser State Updates\n\n  function match(regex) {\n    const m = right.match(regex)\n    m && accept(m[0].length) && keep(m[0])\n    return !!m\n  }\n\n  function keep(text) {\n    branch.push(text)\n    return true\n  }\n\n  function accept(n) {\n    left += right.substring(0,n)\n    right = right.substring(n)\n    return true\n  }\n\n  // Backtracking Operators\n\n  function any (rule) { // rule zero or more times\n    const save = [left,right]\n    if (rule()) {\n      any(rule)\n    } else {\n      [left,right] = save\n    }\n    return true\n  }\n\n  function opt (rule) { // rule zero or one times\n    const save = [left,right]\n    if (!rule()) {\n      [left,right] = save\n    }\n    return true\n  }\n\n  function one (...rules) { // first rule of many\n    const save = [left,right]\n    for (const rule of rules) {\n      if(rule()) {return true}\n      [left,right] = save\n    }\n    false\n  }\n\n  x.match()\n  return tree\n}\n\nexport function gen(level, tree, code, log=()=>{}) {\n  const tab = () => ' |'.repeat(level)\n  switch (tree[0]) {\n    case 'sp':\n    case 'ch':\n    case 'term':\n      break\n    case 'bind':\n    case 'type':\n      log(tab(), tree[0], `\"${tree[1][1]}\"`)\n      code[tree[0]] = tree[1][1]\n      break\n    case 'prop':\n      log(tab(), tree[0], `\"${tree[2][1]}\"`, tree[4][1][2])\n      code[tree[0]] = [tree[2][1], tree[4][1][2]]\n      break\n    case 'node':\n    case 'rel':\n    case 'chain': \n      log(tab(), tree[0])\n      {const sub = {}\n      code[tree[0]] = sub\n      for (const branch of tree.slice(1)) gen(level+1,branch,sub,log)}\n      break\n    case 'in':\n    case 'out':\n    case 'both':\n      log(tab(), tree[0])\n      code['dir'] = tree[0]\n      for (const branch of tree.slice(1)) gen(level+1,branch,code,log)\n      break\n    case 'match':\n    case 'elem':\n      log(tab(), tree[0])\n      for (const branch of tree.slice(1)) gen(level+1,branch,code,log)\n      break\n    case 'eot':\n      log(tab(), 'end')\n      break\n    default:\n      log(tab(), 'unknown', tree[0])\n  }\n  return code\n}\n\nexport function check(tally, code, errors) {\n  if(code?.node?.type && errors) {\n    if(!tally.nodes[code.node.type]) {\n      errors.push(`No node of type \"${code.node.type}\" in the graph.`)\n    }\n  }\n  if(code?.rel?.type && errors) {\n    if(!tally.rels[code.rel.type]) {\n      errors.push(`No relation of type \"${code.rel.type}\" in the graph.`)\n    }\n  }\n  if(Object.keys(code.chain).length) {\n    check(tally,code.chain, errors)\n  }\n\n}\n\nexport function apply(graph, code) {\n  const nodes = graph.nodes\n  const rels = graph.rels\n  const results = []\n  for (const node of nodes) {\n    chain(node, code, {})\n  }\n  return results\n\n  function chain(node, code, maybe) {\n    if ((!code.node.type || node.type == code.node.type) &&\n        (!code.node.prop || node.props[code.node.prop[0]] == code.node.prop[1])) {\n      if (code.node.bind)\n        maybe[code.node.bind] = node\n      if (code.chain.rel) {\n        if (['in','both'].includes(code.chain.rel.dir))\n          links(node.in, 'from')\n        if (['out','both'].includes(code.chain.rel.dir))\n          links(node.out, 'to')\n      } else {\n        results.push(maybe)\n      }\n    }\n\n    function links(rids, dir) {\n      rids.forEach(rid => {\n        if ((!code.chain.rel.type || rels[rid].type == code.chain.rel.type) &&\n           (!code.chain.rel.prop || rels[rid].props[code.chain.rel.prop[0]] == code.chain.rel.prop[1])) {\n          maybe = {...maybe}\n          if (code.chain.rel.bind)\n            maybe[code.chain.rel.bind] = rels[rid]\n          chain(nodes[rels[rid][dir]], code.chain, maybe)\n        }\n      })\n    }\n  }\n}\n\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "cypher.js",
        "story": []
      },
      "date": 1664083426200
    },
    {
      "item": {
        "type": "factory",
        "id": "cbfea75e014416c8"
      },
      "id": "cbfea75e014416c8",
      "type": "add",
      "date": 1664083428077
    },
    {
      "type": "edit",
      "id": "cbfea75e014416c8",
      "item": {
        "type": "code",
        "id": "cbfea75e014416c8",
        "text": "export let left, right\nexport function parse(text, log=()=>{}) {\n  const r = {}, x = {}             // rules defined and traced\n  left = '', right = text          // text parsed and pending\n  let branch = []                  // abstract syntax tree in progress\n  const tree = [branch]\n\n  // Non-Terminal Symbols\n\n  r.match = () => x.sp() && x.term('match') && x.node() && x.chain() && x.eot()\n  r.node = () => x.ch('(') && x.elem()  && x.ch(')')\n  r.chain = () => any(() => x.rel() && x.node() && x.chain())\n  r.rel = () => one(() => x.in(), () => x.out(), () => x.both())\n  r.in = () => x.term('<-') && opt(() => x.ch('[') && x.elem() && x.ch(']')) && x.ch('-')\n  r.out = () => x.ch('-') && opt(() => x.ch('[') && x.elem() && x.ch(']')) && x.term('->')\n  r.both = () => x.ch('-') && opt(() => x.ch('[') && x.elem() && x.ch(']')) && x.ch('-')\n  r.elem = () => opt(() => x.bind()) && opt(() => x.ch(':') && x.type()) && opt(() => x.prop())\n  r.prop = () => x.ch('{') && x.word() && x.ch(':')  && x.expr() && x.ch('}')\n  r.expr = () => x.strn()\n  r.bind = () => x.word()\n  r.type = () => x.word()\n\n  // Terminal Symbols\n\n  r.word = () => match(/^[A-Za-z][A-Za-z0-9_]*/) && x.sp()\n  r.term = want => right.startsWith(want) && accept(want.length) && keep(want) && x.sp()\n  r.strn = () => x.ch('\"') && match(/^[^\"]{0,20}/) && x.ch('\"') && x.sp()\n  r.ch = char => right.startsWith(char) && accept(1) && keep(char) && x.sp()\n  r.sp = () => match(/^\\s*/)\n  r.eot = () => !right.length\n\n  // Parse Instrumentation\n\n  for (const op in r) {\n    x[op] = (...args) => {\n      log(`${left}%c${op}%c${right}`,\"color:red\",\"color:black\");\n      const here = branch\n      branch = [op]\n      const success = r[op](...args)\n      if (success) here.push(branch)\n      branch = here\n      return success\n    }\n  }\n\n  // Parser State Updates\n\n  function match(regex) {\n    const m = right.match(regex)\n    m && accept(m[0].length) && keep(m[0])\n    return !!m\n  }\n\n  function keep(text) {\n    branch.push(text)\n    return true\n  }\n\n  function accept(n) {\n    left += right.substring(0,n)\n    right = right.substring(n)\n    return true\n  }\n\n  // Backtracking Operators\n\n  function any (rule) { // rule zero or more times\n    const save = [left,right]\n    if (rule()) {\n      any(rule)\n    } else {\n      [left,right] = save\n    }\n    return true\n  }\n\n  function opt (rule) { // rule zero or one times\n    const save = [left,right]\n    if (!rule()) {\n      [left,right] = save\n    }\n    return true\n  }\n\n  function one (...rules) { // first rule of many\n    const save = [left,right]\n    for (const rule of rules) {\n      if(rule()) {return true}\n      [left,right] = save\n    }\n    false\n  }\n\n  x.match()\n  return tree\n}\n\nexport function gen(level, tree, code, log=()=>{}) {\n  const tab = () => ' |'.repeat(level)\n  switch (tree[0]) {\n    case 'sp':\n    case 'ch':\n    case 'term':\n      break\n    case 'bind':\n    case 'type':\n      log(tab(), tree[0], `\"${tree[1][1]}\"`)\n      code[tree[0]] = tree[1][1]\n      break\n    case 'prop':\n      log(tab(), tree[0], `\"${tree[2][1]}\"`, tree[4][1][2])\n      code[tree[0]] = [tree[2][1], tree[4][1][2]]\n      break\n    case 'node':\n    case 'rel':\n    case 'chain': \n      log(tab(), tree[0])\n      {const sub = {}\n      code[tree[0]] = sub\n      for (const branch of tree.slice(1)) gen(level+1,branch,sub,log)}\n      break\n    case 'in':\n    case 'out':\n    case 'both':\n      log(tab(), tree[0])\n      code['dir'] = tree[0]\n      for (const branch of tree.slice(1)) gen(level+1,branch,code,log)\n      break\n    case 'match':\n    case 'elem':\n      log(tab(), tree[0])\n      for (const branch of tree.slice(1)) gen(level+1,branch,code,log)\n      break\n    case 'eot':\n      log(tab(), 'end')\n      break\n    default:\n      log(tab(), 'unknown', tree[0])\n  }\n  return code\n}\n\nexport function check(tally, code, errors) {\n  if(code?.node?.type && errors) {\n    if(!tally.nodes[code.node.type]) {\n      errors.push(`No node of type \"${code.node.type}\" in the graph.`)\n    }\n  }\n  if(code?.rel?.type && errors) {\n    if(!tally.rels[code.rel.type]) {\n      errors.push(`No relation of type \"${code.rel.type}\" in the graph.`)\n    }\n  }\n  if(Object.keys(code.chain).length) {\n    check(tally,code.chain, errors)\n  }\n\n}\n\nexport function apply(graph, code) {\n  const nodes = graph.nodes\n  const rels = graph.rels\n  const results = []\n  for (const node of nodes) {\n    chain(node, code, {})\n  }\n  return results\n\n  function chain(node, code, maybe) {\n    if ((!code.node.type || node.type == code.node.type) &&\n        (!code.node.prop || node.props[code.node.prop[0]] == code.node.prop[1])) {\n      if (code.node.bind)\n        maybe[code.node.bind] = node\n      if (code.chain.rel) {\n        if (['in','both'].includes(code.chain.rel.dir))\n          links(node.in, 'from')\n        if (['out','both'].includes(code.chain.rel.dir))\n          links(node.out, 'to')\n      } else {\n        results.push(maybe)\n      }\n    }\n\n    function links(rids, dir) {\n      rids.forEach(rid => {\n        if ((!code.chain.rel.type || rels[rid].type == code.chain.rel.type) &&\n           (!code.chain.rel.prop || rels[rid].props[code.chain.rel.prop[0]] == code.chain.rel.prop[1])) {\n          maybe = {...maybe}\n          if (code.chain.rel.bind)\n            maybe[code.chain.rel.bind] = rels[rid]\n          chain(nodes[rels[rid][dir]], code.chain, maybe)\n        }\n      })\n    }\n  }\n}\n\n"
      },
      "date": 1664083430317
    }
  ]
}