{
  "title": "Chain Of Responsibility Pattern",
  "story": [
    {
      "type": "html",
      "text": "<b>Intent:</b> Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.\nThere is a potentially variable number of \"handler\" objects and a stream of requests that must be handled. Need to efficiently process the requests without hard-wiring handler relationships and precedence, or request-to-handler mappings.",
      "id": "000b7a9ee6740c3633ea980f11992033"
    },
    {
      "type": "html",
      "text": "<b>Discussion:</b>\nThe pattern chains the receiving objects together, and then passes any request messages from object to object until it reaches an object capable of handling the message. The number and type of handler objects isn't known a priori, they can be configured dynamically. The chaining mechanism uses recursive composition to allow an unlimited number of handlers to be linked.",
      "id": "fd62b13a0ac0512a42b634ebf375b441"
    },
    {
      "type": "html",
      "text": "Chain of Responsibility simplifies object interconnections. Instead of senders and receivers maintaining references to all candidate receivers, each sender keeps a single reference to the head of the chain, and each receiver keeps a single reference to its immediate successor in the chain.",
      "id": "df129ad1b59504c123c3cc6c7be27da6"
    },
    {
      "type": "html",
      "text": "\nMake sure there exists a \"safety net\" to \"catch\" any requests which go unhandled.",
      "id": "70c174fc5b2e2d9053bf7a75b91343ca"
    },
    {
      "type": "html",
      "text": "\nDo not use Chain of Responsibility when each request is only handled by one handler, or, when the client object knows which service object should handle the request.",
      "id": "5d772fbcb8f8025b4771ed78616feadb"
    },
    {
      "type": "html",
      "text": "<b>Example:</b>\nThe Chain of Responsibility pattern avoids coupling the sender of a request to the receiver by giving more than one object a chance to handle the request. Mechanical coin sorting banks use the Chain of Responsibility. Rather than having a separate slot for each coin denomination coupled with a receptacle for the denomination, a single slot is used. When the coin is dropped, the coin is routed to the appropriate receptacle by the mechanical mechanisms within the bank. [Michael Duell, \"Non-software examples of software design patterns\", Object Magazine, July 1997, p54]",
      "id": "df2064bf153b64842e0eb0c4d27c4bb2"
    },
    {
      "type": "html",
      "text": "<b>Rules of thumb:</b>\nChain of Responsibility, [[Command Pattern]], [[Mediator Pattern]], and [[Observer Pattern]], address how you can decouple senders and receivers, but with different trade-offs. Chain of Responsibility passes a sender request along a chain of potential receivers.",
      "id": "7291f3c7cbbe77c57e4996dc6ca7baf6"
    },
    {
      "type": "html",
      "text": "\nChain of Responsibility can use [[Command Pattern]] to represent requests as objects. [GOF, p349]",
      "id": "0a4a71b5e58530e41b089cf07de5c4f2"
    },
    {
      "type": "html",
      "text": "\nChain of Responsibility is often applied in conjunction with [[Composite Pattern]]. There, a component's parent can act as its successor. [GOF, p232]",
      "id": "654245968fee4893d390291570de3490"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2becad613be88c4e15426279d4e83b4b"
    },
    {
      "type": "html",
      "text": "<b>Examples</b>",
      "id": "d8432f53bb145ba99be4b8e07f098bea"
    },
    {
      "type": "html",
      "text": "\nApache Jakarta Chain: [http://jakarta.apache.org/commons/chain/ jakarta.apache.org] it is in [[Java Language]]",
      "id": "a1cb25215b511a7f6e282c531c3767a0"
    },
    {
      "type": "html",
      "text": "\nThe $PATH environment variable on unix machines.",
      "id": "c536c20fdf612f459efee4e8590a3ade"
    },
    {
      "type": "html",
      "text": "\n[http://wiki.cs.uiuc.edu/patternStories/ChainOfResponsibilityPattern wiki.cs.uiuc.edu]",
      "id": "d733a39192c0f7d28264f427a60b7513"
    },
    {
      "type": "html",
      "text": "\nNet<b></b>Beans Multi<b></b>File<b></b>System [http://www.netbeans.org/download/apis/org/openide/filesystems/MultiFileSystem.html www.netbeans.org]",
      "id": "eb5fcafed0d4d2b0938465ec5925e8a0"
    },
    {
      "type": "html",
      "text": "\"Plan 9 has union directories: directories made of several directories all bound to the same name. The directories making up a union directory are ordered in a list. When the bindings are made (see bind(1)), flags specify whether a newly bound member goes at the head or the tail of the list or completely replaces the list. To look up a name in a union directory, each member directory is searched in list order until the name is found. A bind flag specifies whether file creation is allowed in a member directory: a file created in the union directory goes in the first member directory in list order that allows creation, if any. \" [http://plan9.bell-labs.com/magic/man2html/1/intro plan9.bell-labs.com]",
      "id": "93a5e5634ae3126480329c66c45b60fe"
    },
    {
      "type": "html",
      "text": "\nThe [[Power Plant]] framework used (uses?) this pattern to dispatch events from the actual target (button) up to its super-'commanders' (window, application).",
      "id": "ad3958b86bcb41a1288e633612569214"
    },
    {
      "type": "html",
      "text": "\n[[Dot Net Remoting]] uses \"sink chains\" to implement its remoting channels.  On the client side, a method-call message gets passed to a <i>formatter sink</i>, which serializes it to the network format then passes it along to a <i>transport sink</i> that takes care of sending it out to the network.  On the server side, an incoming network message is read by the <i>transport sink</i>, which passes it to a <i>formatter sink</i> for deserialization, which passes it to a <i>dispatcher sink</i> which makes the actual method call and then returns the results back though the server chain, the network, and then the client chain.  Additional sinks can be inserted between the standard chain elements to provide additional processing (logging, encryption, translation, forwarding, replication, load-balancing, etc.) without requiring any changes to the existing sink or channel implementations.",
      "id": "de942d28a2e740e88b592fdb5ee01ffa"
    },
    {
      "type": "html",
      "text": "\nAxis ([http://ws.apache.org/axis/java/index.html ws.apache.org]) Handlers and Chains",
      "id": "3a94b40e979a368960da98317960385a"
    },
    {
      "type": "html",
      "text": "\n[[Amiga Os]] \"input.device\" represented the central clearing house for all input events, including game, mouse, and keyboard-related events.  The system's GUI, intuition.library, merely sits on the input.device's handler list as any other program would (albeit at a priority of 50).  Screen blankers often detected system-wide events, and UI recorder programs would use input.device to record events as they came through.  Accessibility programs would use input.device to synthesize some UI events in response to others.",
      "id": "74e3ceaf32b10f655ea04d0f0445eecd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2becad613be88c4e15426279d4e83b4b"
    },
    {
      "type": "html",
      "text": "\nNote that each node along the chain of responsibility must be able to either directly handle or forward the request. If the \"request\" is coded directly as, for instance, a C++ method call, then every node along the chain must define that method call, with non-handling nodes merely re-invoking the method on the parent. To avoid having each node define methods for all possible requests, in a static language like C++, requires that a Command pattern be used, where an actual object encapsulates the \"request\". Note however that using a command object to pass around requests on the chain of responsibility is less efficient than using the language's built in command mechanism (i.e. direct method invocation), because command parameters (i.e. method arguments) must then be manually encoded by the sender, passed along the chain, and decoded at the receiver.",
      "id": "fafd02e6b307d98c3af41dc311963f8e"
    },
    {
      "type": "html",
      "text": "\nThis is a difficult tradeoff between syntactic conciseness and execution speed (using the language's built in method invocation) on the one hand, and class bloat on the other hand (requiring each class along the chain to support all message types).",
      "id": "e4f705abb323694fdc1a04da61f43a38"
    },
    {
      "type": "html",
      "text": "\nIf requests don't need to follow arbitrarily long chains of responsibility, a better  pattern to use might be Mediator, so that only the mediator node needs to know about all possible requests coming from its child nodes, and these requests could be coded as native language methods, affording clarity and speed. No other nodes in the entire system need to be \"polluted\" with these only locally-relevant methods. In other words, the Mediator abstracts communication by being the central hub, so only it needs know about all messages. The [[Chain Of Responsibility]] abstracts communication by passing a message along a chain; but in a static language like C++ the \"passing\" of an anonymous \"message\" requires use of a less efficient Command pattern, or support in all nodes for all message types (in which case the messages are no longer \"anonymous\").. ",
      "id": "6d1916d881af01c17667b5046a651cb0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2becad613be88c4e15426279d4e83b4b"
    },
    {
      "type": "html",
      "text": "\nFrom my point of view, this pattern also seems to say why [[Exceptions Are Our Friends]]. Run-time errors, or exceptions, are realised in a module, and that module should raise the error to its caller. But in turn, the caller should then raise the same exception to its caller, giving each parent the chance to handle the exception, before terminating the application. One of the reasons why writing decent error handling routines in languages like [[Visual Basic]] is so difficult. -- [[Matt Ryall]]",
      "id": "2b56d8049577680a52c41f96623134b5"
    },
    {
      "type": "html",
      "text": "<b>Concur.</b> Hardware control is pretty much designed this way. Unless there is a completely predictive way to handle a particular hardware error you gotta inform the caller that the widget under control has failed in some way. The decision on what to do about the failure is put off to the very highest level you can get away with. In process automation it typically ends up firing an alarm for an operator to deal with.",
      "id": "755aaa5f6be01f81daa19dca161103aa"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2becad613be88c4e15426279d4e83b4b"
    },
    {
      "type": "html",
      "text": "\nAhem.  Isn't class inheritance in [[Object Oriented Languages]] such as [[Java Language]] and [[Smalltalk Language]] a more common application of this pattern?  When a method is called on an object, the method dispatch system first tries to find the method on the object being called, then on it's parent, etc. on up the tree.",
      "id": "d85bfd4351d7a9288c4345d61fe6b90a"
    },
    {
      "type": "html",
      "text": "\nNot totally.  Inheritance functions more like a message broker.  The runtime locates a function to call and calls it.  Chain of Responsibility functions more like a message bus.  Each receiving object is given a chance to handle the message or pass it along.  Inheritance can be made to function in this way by using \"base\" or \"super\" calls, but it is not as natural a fit as separate handler classes and it constrains the inheritance tree. -- [[David Sidlinger]]",
      "id": "b31acfe4f72c69cd24d9d718e15ca030"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2becad613be88c4e15426279d4e83b4b"
    },
    {
      "type": "html",
      "text": "How can we deal with explosion of classes when using [[Chain Of Responsibility]]? -- Bala Paranj",
      "id": "3cd9fc93d19bd2e8cf2ce47fa45bba98"
    },
    {
      "type": "html",
      "text": "\nThis is not a problem. The decision of being responsible for the handling of a request is made per object, not per class. So you could have an arbitrary number of objects in the chain, all of the same class, while handling different requests. If different classes are necessary, they would be necessary anyways, [[Chain Of Responsibility]] or not. -- Timo Reitz",
      "id": "115edaf37f8e8957dad9bc34cd0062a1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2becad613be88c4e15426279d4e83b4b"
    },
    {
      "type": "html",
      "text": "Is it not that \"non-resumptive exception handling\" in modern object oriented languages, like C++ and Java, follow [[Chain Of Responsibility Pattern]] pattern? When an exception is thrown, the exception handlers are looked-up for a match. The exception object is passed till a matching handler is found. So, can it be assumed that exception handling follows [[Chain Of Responsibility Pattern]]? - S G Ganesh ",
      "id": "01c7f62217120ca294782c9d16f64be4"
    },
    {
      "type": "html",
      "text": "<i>The sender is decoupled from the receiver, certainly, but there is no explicit instance of the pattern. Who needs a pattern when you have a feature? ([[Design Patterns Are Missing Language Features]]).</i>",
      "id": "2b77e5e8b48ee63adf7b1d15adad4c8c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2becad613be88c4e15426279d4e83b4b"
    },
    {
      "type": "html",
      "text": "To paraphrase Malcolm Reynolds - \"Do you know what the chain of responsibilty is here? It's the chain I go get and beat you with to show you who's responsible.\"",
      "id": "9c76b1efb00ae0da33e9436f77f298cc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2becad613be88c4e15426279d4e83b4b"
    },
    {
      "type": "html",
      "text": "I have always wondered why GOF says that the successor would be the parent node when combining CoR with Composite.  It has always been more natural to me to think of the children nodes as the successor, or is this because I am locked into a \"Decision Tree\" paradigm? - Francis Anderson",
      "id": "128c596ddc1ec0949af441d4f8b38897"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2becad613be88c4e15426279d4e83b4b"
    },
    {
      "type": "html",
      "text": "I see this pattern as a design-oriented if-then-else statement.  When I am tempted to write a long string of if and else clauses with anything but trivial conditions or one-line bodies, I first look to this pattern to see if it will help clean up the code. - [[Skip Sailors]]",
      "id": "edd93e5c806abfa723af1436808d8d29"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2becad613be88c4e15426279d4e83b4b"
    },
    {
      "type": "html",
      "text": "[[Category Pattern]], [[Category Behavioral Patterns]]",
      "id": "86df043b038636144bf3cfed73d35096"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ChainOfResponsibilityPattern c2.com]",
      "id": "8e2b5a5589405227486335fd99027e95"
    }
  ],
  "journal": [
    {
      "date": 1404852852000,
      "id": "c796aff40c2aa069121bfb4e7881efd3",
      "type": "create",
      "item": {
        "title": "Chain Of Responsibility Pattern",
        "story": [
          {
            "type": "html",
            "text": "<b>Intent:</b> Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.\nThere is a potentially variable number of \"handler\" objects and a stream of requests that must be handled. Need to efficiently process the requests without hard-wiring handler relationships and precedence, or request-to-handler mappings.",
            "id": "000b7a9ee6740c3633ea980f11992033"
          },
          {
            "type": "html",
            "text": "<b>Discussion:</b>\nThe pattern chains the receiving objects together, and then passes any request messages from object to object until it reaches an object capable of handling the message. The number and type of handler objects isn't known a priori, they can be configured dynamically. The chaining mechanism uses recursive composition to allow an unlimited number of handlers to be linked.",
            "id": "fd62b13a0ac0512a42b634ebf375b441"
          },
          {
            "type": "html",
            "text": "\nChain of Responsibility simplifies object interconnections. Instead of senders and receivers maintaining references to all candidate receivers, each sender keeps a single reference to the head of the chain, and each receiver keeps a single reference to its immediate successor in the chain.",
            "id": "df129ad1b59504c123c3cc6c7be27da6"
          },
          {
            "type": "html",
            "text": "\nMake sure there exists a \"safety net\" to \"catch\" any requests which go unhandled.",
            "id": "70c174fc5b2e2d9053bf7a75b91343ca"
          },
          {
            "type": "html",
            "text": "\nDo not use Chain of Responsibility when each request is only handled by one handler, or, when the client object knows which service object should handle the request.",
            "id": "5d772fbcb8f8025b4771ed78616feadb"
          },
          {
            "type": "html",
            "text": "<b>Example:</b>\nThe Chain of Responsibility pattern avoids coupling the sender of a request to the receiver by giving more than one object a chance to handle the request. Mechanical coin sorting banks use the Chain of Responsibility. Rather than having a separate slot for each coin denomination coupled with a receptacle for the denomination, a single slot is used. When the coin is dropped, the coin is routed to the appropriate receptacle by the mechanical mechanisms within the bank. [Michael Duell, \"Non-software examples of software design patterns\", Object Magazine, July 1997, p54]",
            "id": "df2064bf153b64842e0eb0c4d27c4bb2"
          },
          {
            "type": "html",
            "text": "<b>Rules of thumb:</b>\nChain of Responsibility, [[Command Pattern]], [[Mediator Pattern]], and [[Observer Pattern]], address how you can decouple senders and receivers, but with different trade-offs. Chain of Responsibility passes a sender request along a chain of potential receivers.",
            "id": "7291f3c7cbbe77c57e4996dc6ca7baf6"
          },
          {
            "type": "html",
            "text": "\nChain of Responsibility can use [[Command Pattern]] to represent requests as objects. [GOF, p349]",
            "id": "0a4a71b5e58530e41b089cf07de5c4f2"
          },
          {
            "type": "html",
            "text": "\nChain of Responsibility is often applied in conjunction with [[Composite Pattern]]. There, a component's parent can act as its successor. [GOF, p232]",
            "id": "654245968fee4893d390291570de3490"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2becad613be88c4e15426279d4e83b4b"
          },
          {
            "type": "html",
            "text": "<b>Examples</b>",
            "id": "d8432f53bb145ba99be4b8e07f098bea"
          },
          {
            "type": "html",
            "text": "\nApache Jakarta Chain: [http://jakarta.apache.org/commons/chain/ jakarta.apache.org] it is in [[Java Language]]",
            "id": "a1cb25215b511a7f6e282c531c3767a0"
          },
          {
            "type": "html",
            "text": "\nThe $PATH environment variable on unix machines.",
            "id": "c536c20fdf612f459efee4e8590a3ade"
          },
          {
            "type": "html",
            "text": "\n[http://wiki.cs.uiuc.edu/patternStories/ChainOfResponsibilityPattern wiki.cs.uiuc.edu]",
            "id": "d733a39192c0f7d28264f427a60b7513"
          },
          {
            "type": "html",
            "text": "\nNet<b></b>Beans Multi<b></b>File<b></b>System [http://www.netbeans.org/download/apis/org/openide/filesystems/MultiFileSystem.html www.netbeans.org]",
            "id": "eb5fcafed0d4d2b0938465ec5925e8a0"
          },
          {
            "type": "html",
            "text": "\"Plan 9 has union directories: directories made of several directories all bound to the same name. The directories making up a union directory are ordered in a list. When the bindings are made (see bind(1)), flags specify whether a newly bound member goes at the head or the tail of the list or completely replaces the list. To look up a name in a union directory, each member directory is searched in list order until the name is found. A bind flag specifies whether file creation is allowed in a member directory: a file created in the union directory goes in the first member directory in list order that allows creation, if any. \" [http://plan9.bell-labs.com/magic/man2html/1/intro plan9.bell-labs.com]",
            "id": "93a5e5634ae3126480329c66c45b60fe"
          },
          {
            "type": "html",
            "text": "\nThe [[Power Plant]] framework used (uses?) this pattern to dispatch events from the actual target (button) up to its super-'commanders' (window, application).",
            "id": "ad3958b86bcb41a1288e633612569214"
          },
          {
            "type": "html",
            "text": "\n[[Dot Net Remoting]] uses \"sink chains\" to implement its remoting channels.  On the client side, a method-call message gets passed to a <i>formatter sink</i>, which serializes it to the network format then passes it along to a <i>transport sink</i> that takes care of sending it out to the network.  On the server side, an incoming network message is read by the <i>transport sink</i>, which passes it to a <i>formatter sink</i> for deserialization, which passes it to a <i>dispatcher sink</i> which makes the actual method call and then returns the results back though the server chain, the network, and then the client chain.  Additional sinks can be inserted between the standard chain elements to provide additional processing (logging, encryption, translation, forwarding, replication, load-balancing, etc.) without requiring any changes to the existing sink or channel implementations.",
            "id": "de942d28a2e740e88b592fdb5ee01ffa"
          },
          {
            "type": "html",
            "text": "\nAxis ([http://ws.apache.org/axis/java/index.html ws.apache.org]) Handlers and Chains",
            "id": "3a94b40e979a368960da98317960385a"
          },
          {
            "type": "html",
            "text": "\n[[Amiga Os]] \"input.device\" represented the central clearing house for all input events, including game, mouse, and keyboard-related events.  The system's GUI, intuition.library, merely sits on the input.device's handler list as any other program would (albeit at a priority of 50).  Screen blankers often detected system-wide events, and UI recorder programs would use input.device to record events as they came through.  Accessibility programs would use input.device to synthesize some UI events in response to others.",
            "id": "74e3ceaf32b10f655ea04d0f0445eecd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2becad613be88c4e15426279d4e83b4b"
          },
          {
            "type": "html",
            "text": "\nNote that each node along the chain of responsibility must be able to either directly handle or forward the request. If the \"request\" is coded directly as, for instance, a C++ method call, then every node along the chain must define that method call, with non-handling nodes merely re-invoking the method on the parent. To avoid having each node define methods for all possible requests, in a static language like C++, requires that a Command pattern be used, where an actual object encapsulates the \"request\". Note however that using a command object to pass around requests on the chain of responsibility is less efficient than using the language's built in command mechanism (i.e. direct method invocation), because command parameters (i.e. method arguments) must then be manually encoded by the sender, passed along the chain, and decoded at the receiver.",
            "id": "fafd02e6b307d98c3af41dc311963f8e"
          },
          {
            "type": "html",
            "text": "\nThis is a difficult tradeoff between syntactic conciseness and execution speed (using the language's built in method invocation) on the one hand, and class bloat on the other hand (requiring each class along the chain to support all message types).",
            "id": "e4f705abb323694fdc1a04da61f43a38"
          },
          {
            "type": "html",
            "text": "\nIf requests don't need to follow arbitrarily long chains of responsibility, a better  pattern to use might be Mediator, so that only the mediator node needs to know about all possible requests coming from its child nodes, and these requests could be coded as native language methods, affording clarity and speed. No other nodes in the entire system need to be \"polluted\" with these only locally-relevant methods. In other words, the Mediator abstracts communication by being the central hub, so only it needs know about all messages. The [[Chain Of Responsibility]] abstracts communication by passing a message along a chain; but in a static language like C++ the \"passing\" of an anonymous \"message\" requires use of a less efficient Command pattern, or support in all nodes for all message types (in which case the messages are no longer \"anonymous\").. ",
            "id": "6d1916d881af01c17667b5046a651cb0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2becad613be88c4e15426279d4e83b4b"
          },
          {
            "type": "html",
            "text": "\nFrom my point of view, this pattern also seems to say why [[Exceptions Are Our Friends]]. Run-time errors, or exceptions, are realised in a module, and that module should raise the error to its caller. But in turn, the caller should then raise the same exception to its caller, giving each parent the chance to handle the exception, before terminating the application. One of the reasons why writing decent error handling routines in languages like [[Visual Basic]] is so difficult. -- [[Matt Ryall]]",
            "id": "2b56d8049577680a52c41f96623134b5"
          },
          {
            "type": "html",
            "text": "<b>Concur.</b> Hardware control is pretty much designed this way. Unless there is a completely predictive way to handle a particular hardware error you gotta inform the caller that the widget under control has failed in some way. The decision on what to do about the failure is put off to the very highest level you can get away with. In process automation it typically ends up firing an alarm for an operator to deal with.",
            "id": "755aaa5f6be01f81daa19dca161103aa"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2becad613be88c4e15426279d4e83b4b"
          },
          {
            "type": "html",
            "text": "\nAhem.  Isn't class inheritance in [[Object Oriented Languages]] such as [[Java Language]] and [[Smalltalk Language]] a more common application of this pattern?  When a method is called on an object, the method dispatch system first tries to find the method on the object being called, then on it's parent, etc. on up the tree.",
            "id": "d85bfd4351d7a9288c4345d61fe6b90a"
          },
          {
            "type": "html",
            "text": "\nNot totally.  Inheritance functions more like a message broker.  The runtime locates a function to call and calls it.  Chain of Responsibility functions more like a message bus.  Each receiving object is given a chance to handle the message or pass it along.  Inheritance can be made to function in this way by using \"base\" or \"super\" calls, but it is not as natural a fit as separate handler classes and it constrains the inheritance tree. -- [[David Sidlinger]]",
            "id": "b31acfe4f72c69cd24d9d718e15ca030"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2becad613be88c4e15426279d4e83b4b"
          },
          {
            "type": "html",
            "text": "How can we deal with explosion of classes when using [[Chain Of Responsibility]]? -- Bala Paranj",
            "id": "3cd9fc93d19bd2e8cf2ce47fa45bba98"
          },
          {
            "type": "html",
            "text": "\nThis is not a problem. The decision of being responsible for the handling of a request is made per object, not per class. So you could have an arbitrary number of objects in the chain, all of the same class, while handling different requests. If different classes are necessary, they would be necessary anyways, [[Chain Of Responsibility]] or not. -- Timo Reitz",
            "id": "115edaf37f8e8957dad9bc34cd0062a1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2becad613be88c4e15426279d4e83b4b"
          },
          {
            "type": "html",
            "text": "Is it not that \"non-resumptive exception handling\" in modern object oriented languages, like C++ and Java, follow [[Chain Of Responsibility Pattern]] pattern? When an exception is thrown, the exception handlers are looked-up for a match. The exception object is passed till a matching handler is found. So, can it be assumed that exception handling follows [[Chain Of Responsibility Pattern]]? - S G Ganesh ",
            "id": "01c7f62217120ca294782c9d16f64be4"
          },
          {
            "type": "html",
            "text": "<i>The sender is decoupled from the receiver, certainly, but there is no explicit instance of the pattern. Who needs a pattern when you have a feature? ([[Design Patterns Are Missing Language Features]]).</i>",
            "id": "2b77e5e8b48ee63adf7b1d15adad4c8c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2becad613be88c4e15426279d4e83b4b"
          },
          {
            "type": "html",
            "text": "To paraphrase Malcolm Reynolds - \"Do you know what the chain of responsibilty is here? It's the chain I go get and beat you with to show you who's responsible.\"",
            "id": "9c76b1efb00ae0da33e9436f77f298cc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2becad613be88c4e15426279d4e83b4b"
          },
          {
            "type": "html",
            "text": "I have always wondered why GOF says that the successor would be the parent node when combining CoR with Composite.  It has always been more natural to me to think of the children nodes as the successor, or is this because I am locked into a \"Decision Tree\" paradigm? - Francis Anderson",
            "id": "128c596ddc1ec0949af441d4f8b38897"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2becad613be88c4e15426279d4e83b4b"
          },
          {
            "type": "html",
            "text": "I see this pattern as a design-oriented if-then-else statement.  When I am tempted to write a long string of if and else clauses with anything but trivial conditions or one-line bodies, I first look to this pattern to see if it will help clean up the code. - [[Skip Sailors]]",
            "id": "edd93e5c806abfa723af1436808d8d29"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2becad613be88c4e15426279d4e83b4b"
          },
          {
            "type": "html",
            "text": "[[Category Pattern]], [[Category Behavioral Patterns]]",
            "id": "86df043b038636144bf3cfed73d35096"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ChainOfResponsibilityPattern c2.com]",
            "id": "8e2b5a5589405227486335fd99027e95"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1635358953982
    },
    {
      "type": "edit",
      "id": "df129ad1b59504c123c3cc6c7be27da6",
      "item": {
        "type": "html",
        "text": "Chain of Responsibility simplifies object interconnections. Instead of senders and receivers maintaining references to all candidate receivers, each sender keeps a single reference to the head of the chain, and each receiver keeps a single reference to its immediate successor in the chain.",
        "id": "df129ad1b59504c123c3cc6c7be27da6"
      },
      "date": 1635359102278
    }
  ]
}