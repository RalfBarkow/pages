{
  "title": "Bynase Protocol",
  "story": [
    {
      "type": "markdown",
      "id": "02ef5f86268de351",
      "text": "Bynase is a BiologicallyInspired protocol that small computers use to signal values amongst themselves. The primary value of Bynase is that it drives system designers into novel tradeoffs with analogies in biological systems as well as the largest of computer networks. [https://c2.com/cybords/wiki.cgi?BynaseProtocol c2]\n\nA second value of Bynase is that it encourages casual small-scale hardware/software projects. See the BynaseEcosystem for information about the amateur scientific exploration of biologically inspired design. "
    },
    {
      "type": "paragraph",
      "id": "8bb9baf9b86bd36d",
      "text": "See [[Biologically Inspired Cybords]]"
    },
    {
      "type": "markdown",
      "id": "cbe85b93289157c3",
      "text": "Bynase in a nutshell:\n\nElectrical Signals\n\nBynase computers pull the capacitative load on a wire high or low for a few processor clock ticks and then disconnect for many many thousands of clocks before repeating the process. The exact number of clocks that pulling happens is determined based on the strength of the the particular pin drivers and can vary with variation in electrical design.\n\nBynase does not use any passive pull-ups or pull-downs. The Atmel AVR designs have internal pull-ups that must be disabled.\n\nPulse Timing\n\nComputers drive pulses without regard to anything else happening on the wire. Pulse frequency is roughly equivalent to the NTSC horizontal sweep rate of 15kHz. Higher rates make for a more dominant signal when multiple computers are driving the same net.\n\nStatistical Encoding\n\nValues are driven onto a net by choosing proportionally high or low drive for subsequent pulses. Conceptually this is as simple as:\n\n  while true\n    if value < random\n      pulse low\n    else\n      pulse high\n\nNote: this is not a positional number system where subsequent bits represent progressively larger (or smaller) weight. Every pulse sent is equally likely to influence a receiver by the same amount.\n\nStatistical Measurement\n\nA receiver samples the signal on a net and accumulates a progressively better estimate of the value present. For example, 100 samples can yield an accumulation between 0 and 100 inclusively.\n\n  result = 0\n  for 100 times\n    if input is high\n      result = result + 1\n\nA receiver does not know which transmitter has most recently pulsed the net. As such, when multiple transmitters compete, the receiver detects a weighted average of the transmitted signal.\n\nDirectional Coupling\n\nThe Bynase driver delays sampling input until the last possible moment before pulsing its own signal and thus obliterating any other computer's signal. This strategy allows two computers to signal each other on a single wire. Crosstalk will be minimized when the two computers signal at the same rate.\n\nSpectral Properties\n\nA receiver integrates both the signal and the statistical \"noise\" used to carry it. We choose to use \"noise\" that has no frequency components with periods longer than typical integration periods. In this way most noise cancels out in the receiver's integrator. The Bynase driver uses an InvertedCounter as a high-frequency noise generator.\n\nAn alternative would be to use an ErrorDiffusion process in place of what is essentially a static dither. This is the approach used by PulseDensityModulation used by, so called, one-bit D-to-A converters in high end compact disk players.\n\nLimit Cases\n\nIn the limit, probability 0 => always low and probability 1 => always high. We achieve these limits by slightly reducing the range of the inverted counter. Specifically we skip zero so an 8-bit counter has only 255, not 256, states, and that value < random evaluates to produce pulse low for all values of random when value is zero.\n\nAlternate Reconstruction\n\nWe have considered alternative methods to reconstruction other than linear integration. One study, FastBynase, produced some simulations that inform all versions of Bynase with some very clear pictures.\n\nIn this one, the first trace (red) is the signal to be encoded, the second (blue) is the noise from the InvertedCounter used to dither the signal, and, the third (green) is the signal as it might appear on the wire if there were no other signals present. The remaining waveforms are specific to the FastBynase reconstruction.\n\nBynase takes inspiration from molecular signaling systems where concentrations encode values. While Bynase is not particularly good at signaling high-speed events, Bynase designs tend to be immune to occasional and short-lived errors. Bynase systems have the feel of hybrid computers (mixed analog and digital) except that the digital component is distributed among all of the \"analog\" elements.\n\n \n\tLast edited March 30, 2008\nReturn to WelcomeVisitors "
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Bynase Protocol",
        "story": []
      },
      "date": 1663228676526
    },
    {
      "item": {
        "type": "factory",
        "id": "02ef5f86268de351"
      },
      "id": "02ef5f86268de351",
      "type": "add",
      "date": 1663228678520
    },
    {
      "type": "edit",
      "id": "02ef5f86268de351",
      "item": {
        "type": "paragraph",
        "id": "02ef5f86268de351",
        "text": "– https://c2.com/cybords/wiki.cgi?BynaseProtocol"
      },
      "date": 1663228681334
    },
    {
      "type": "edit",
      "id": "02ef5f86268de351",
      "item": {
        "type": "markdown",
        "id": "02ef5f86268de351",
        "text": "– https://c2.com/cybords/wiki.cgi?BynaseProtocol"
      },
      "date": 1663228684293
    },
    {
      "type": "edit",
      "id": "02ef5f86268de351",
      "item": {
        "type": "markdown",
        "id": "02ef5f86268de351",
        "text": "Bynase is a BiologicallyInspired protocol that small computers use to signal values amongst themselves. The primary value of Bynase is that it drives system designers into novel tradeoffs with analogies in biological systems as well as the largest of computer networks. [ https://c2.com/cybords/wiki.cgi?BynaseProtocol c2]\n\nA second value of Bynase is that it encourages casual small-scale hardware/software projects. See the BynaseEcosystem for information about the amateur scientific exploration of biologically inspired design. "
      },
      "date": 1663228717969
    },
    {
      "type": "edit",
      "id": "02ef5f86268de351",
      "item": {
        "type": "markdown",
        "id": "02ef5f86268de351",
        "text": "Bynase is a BiologicallyInspired protocol that small computers use to signal values amongst themselves. The primary value of Bynase is that it drives system designers into novel tradeoffs with analogies in biological systems as well as the largest of computer networks. [https://c2.com/cybords/wiki.cgi?BynaseProtocol c2]\n\nA second value of Bynase is that it encourages casual small-scale hardware/software projects. See the BynaseEcosystem for information about the amateur scientific exploration of biologically inspired design. "
      },
      "date": 1663228723828
    },
    {
      "id": "8bb9baf9b86bd36d",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "8bb9baf9b86bd36d",
        "text": "See [[Biologically Inspired Cybords]]"
      },
      "after": "02ef5f86268de351",
      "date": 1663228760082
    },
    {
      "item": {
        "type": "factory",
        "id": "cbe85b93289157c3"
      },
      "id": "cbe85b93289157c3",
      "type": "add",
      "after": "8bb9baf9b86bd36d",
      "date": 1663228806814
    },
    {
      "type": "edit",
      "id": "cbe85b93289157c3",
      "item": {
        "type": "markdown",
        "id": "cbe85b93289157c3",
        "text": "Bynase in a nutshell:\n\nElectrical Signals\n\nBynase computers pull the capacitative load on a wire high or low for a few processor clock ticks and then disconnect for many many thousands of clocks before repeating the process. The exact number of clocks that pulling happens is determined based on the strength of the the particular pin drivers and can vary with variation in electrical design.\n\nBynase does not use any passive pull-ups or pull-downs. The Atmel AVR designs have internal pull-ups that must be disabled.\n\nPulse Timing\n\nComputers drive pulses without regard to anything else happening on the wire. Pulse frequency is roughly equivalent to the NTSC horizontal sweep rate of 15kHz. Higher rates make for a more dominant signal when multiple computers are driving the same net.\n\nStatistical Encoding\n\nValues are driven onto a net by choosing proportionally high or low drive for subsequent pulses. Conceptually this is as simple as:\n\n  while true\n    if value < random\n      pulse low\n    else\n      pulse high\n\nNote: this is not a positional number system where subsequent bits represent progressively larger (or smaller) weight. Every pulse sent is equally likely to influence a receiver by the same amount.\n\nStatistical Measurement\n\nA receiver samples the signal on a net and accumulates a progressively better estimate of the value present. For example, 100 samples can yield an accumulation between 0 and 100 inclusively.\n\n  result = 0\n  for 100 times\n    if input is high\n      result = result + 1\n\nA receiver does not know which transmitter has most recently pulsed the net. As such, when multiple transmitters compete, the receiver detects a weighted average of the transmitted signal.\n\nDirectional Coupling\n\nThe Bynase driver delays sampling input until the last possible moment before pulsing its own signal and thus obliterating any other computer's signal. This strategy allows two computers to signal each other on a single wire. Crosstalk will be minimized when the two computers signal at the same rate.\n\nSpectral Properties\n\nA receiver integrates both the signal and the statistical \"noise\" used to carry it. We choose to use \"noise\" that has no frequency components with periods longer than typical integration periods. In this way most noise cancels out in the receiver's integrator. The Bynase driver uses an InvertedCounter as a high-frequency noise generator.\n\nAn alternative would be to use an ErrorDiffusion process in place of what is essentially a static dither. This is the approach used by PulseDensityModulation used by, so called, one-bit D-to-A converters in high end compact disk players.\n\nLimit Cases\n\nIn the limit, probability 0 => always low and probability 1 => always high. We achieve these limits by slightly reducing the range of the inverted counter. Specifically we skip zero so an 8-bit counter has only 255, not 256, states, and that value < random evaluates to produce pulse low for all values of random when value is zero.\n\nAlternate Reconstruction\n\nWe have considered alternative methods to reconstruction other than linear integration. One study, FastBynase, produced some simulations that inform all versions of Bynase with some very clear pictures.\n\nIn this one, the first trace (red) is the signal to be encoded, the second (blue) is the noise from the InvertedCounter used to dither the signal, and, the third (green) is the signal as it might appear on the wire if there were no other signals present. The remaining waveforms are specific to the FastBynase reconstruction.\n\nBynase takes inspiration from molecular signaling systems where concentrations encode values. While Bynase is not particularly good at signaling high-speed events, Bynase designs tend to be immune to occasional and short-lived errors. Bynase systems have the feel of hybrid computers (mixed analog and digital) except that the digital component is distributed among all of the \"analog\" elements.\n\n \n\tLast edited March 30, 2008\nReturn to WelcomeVisitors "
      },
      "date": 1663228809027
    }
  ]
}