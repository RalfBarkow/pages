{
  "title": "Parsing Expression Grammar",
  "story": [
    {
      "type": "reference",
      "id": "f87aeb789549cb2d",
      "site": "wiki.ralfbarkow.ch",
      "slug": "petitparser",
      "title": "PetitParser",
      "text": "[https://www.lukas-renggli.ch/blog/petitparser-1 Writing Parsers with PetitParser] – [[Lukas Renggli]]"
    },
    {
      "type": "markdown",
      "id": "31f98b1f1c3577a2",
      "text": "*Parsing Expression Grammars* (PEGs) provide ordered choice. Unlike in parser combinators, the ordered choice of PEGs always follows the first matching alternative and ignores other alternatives. Valid input always results in exactly one parse-tree, the result of a parse is never ambiguous."
    },
    {
      "type": "paragraph",
      "id": "08c6befe549f4b43",
      "text": "Also see [https://en.wikipedia.org/wiki/Parsing_expression_grammar wikipedia]"
    },
    {
      "type": "markdown",
      "id": "520f8c9fc5215709",
      "text": "> In computer science, a parsing expression grammar (PEG), is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by [[Bryan Ford]] in 2004 and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Parsing Expression Grammar",
        "story": []
      },
      "date": 1639148922573
    },
    {
      "item": {
        "type": "factory",
        "id": "f87aeb789549cb2d"
      },
      "id": "f87aeb789549cb2d",
      "type": "add",
      "date": 1639148927653
    },
    {
      "type": "edit",
      "id": "f87aeb789549cb2d",
      "item": {
        "type": "reference",
        "id": "f87aeb789549cb2d",
        "site": "wiki.ralfbarkow.ch",
        "slug": "petitparser",
        "title": "PetitParser",
        "text": "[https://www.lukas-renggli.ch/blog/petitparser-1 Writing Parsers with PetitParser] – [[Lukas Renggli]]"
      },
      "date": 1639148932728
    },
    {
      "id": "31f98b1f1c3577a2",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "31f98b1f1c3577a2",
        "text": "1. *Scannerless Parsers* combine what is usually done by two independent tools (scanner and parser) into one. This makes writing a grammar much simpler and avoids common problems when grammars are composed.\n1. *Parser Combinators* are building blocks for parsers modeled as a graph of composable objects; they are modular and maintainable, and can be changed, recomposed, transformed and reflected upon.\n1. *Parsing Expression Grammars* (PEGs) provide ordered choice. Unlike in parser combinators, the ordered choice of PEGs always follows the first matching alternative and ignores other alternatives. Valid input always results in exactly one parse-tree, the result of a parse is never ambiguous.\n1. *Packrat Parsers* give linear parse time guarantees and avoid common problems with left-recursion in PEGs."
      },
      "after": "f87aeb789549cb2d",
      "date": 1639148980102
    },
    {
      "type": "edit",
      "id": "31f98b1f1c3577a2",
      "item": {
        "type": "markdown",
        "id": "31f98b1f1c3577a2",
        "text": "*Parsing Expression Grammars* (PEGs) provide ordered choice. Unlike in parser combinators, the ordered choice of PEGs always follows the first matching alternative and ignores other alternatives. Valid input always results in exactly one parse-tree, the result of a parse is never ambiguous."
      },
      "date": 1639148990450
    },
    {
      "item": {
        "type": "factory",
        "id": "08c6befe549f4b43"
      },
      "id": "08c6befe549f4b43",
      "type": "add",
      "after": "31f98b1f1c3577a2",
      "date": 1639149216604
    },
    {
      "type": "edit",
      "id": "08c6befe549f4b43",
      "item": {
        "type": "paragraph",
        "id": "08c6befe549f4b43",
        "text": "Also see [https://en.wikipedia.org/wiki/Parsing_expression_grammar wikipedia]"
      },
      "date": 1639149228583
    },
    {
      "item": {
        "type": "factory",
        "id": "520f8c9fc5215709"
      },
      "id": "520f8c9fc5215709",
      "type": "add",
      "after": "08c6befe549f4b43",
      "date": 1639149241264
    },
    {
      "type": "edit",
      "id": "520f8c9fc5215709",
      "item": {
        "type": "markdown",
        "id": "520f8c9fc5215709",
        "text": "> In computer science, a parsing expression grammar (PEG), is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by Bryan Ford in 2004[1] and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser.\n\nUnlike CFGs, PEGs cannot be ambiguous; if a string parses, it has exactly one valid parse tree. It is conjectured that there exist context-free languages that cannot be recognized by a PEG, but this is not yet proven.[1] PEGs are well-suited to parsing computer languages (and artificial human languages such as Lojban), but not natural languages where the performance of PEG algorithms is comparable to general CFG algorithms such as the Earley algorithm.[2] "
      },
      "date": 1639149245454
    },
    {
      "type": "edit",
      "id": "520f8c9fc5215709",
      "item": {
        "type": "markdown",
        "id": "520f8c9fc5215709",
        "text": "> In computer science, a parsing expression grammar (PEG), is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by Bryan Ford in 2004[1] and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser."
      },
      "date": 1639149273042
    },
    {
      "type": "edit",
      "id": "520f8c9fc5215709",
      "item": {
        "type": "markdown",
        "id": "520f8c9fc5215709",
        "text": "> In computer science, a parsing expression grammar (PEG), is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by [[Bryan Ford]] in 2004 and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser."
      },
      "date": 1661861099120
    }
  ]
}