{
  "title": "Parsing Expression Grammar",
  "story": [
    {
      "type": "markdown",
      "id": "31f98b1f1c3577a2",
      "text": "*Parsing Expression Grammars* (PEGs) provide ordered choice. Unlike in parser combinators, the ordered choice of PEGs always follows the first matching alternative and ignores other alternatives. Valid input always results in exactly one parse-tree, the result of a parse is never ambiguous."
    },
    {
      "type": "paragraph",
      "id": "08c6befe549f4b43",
      "text": "Also see [https://en.wikipedia.org/wiki/Parsing_expression_grammar wikipedia]"
    },
    {
      "type": "markdown",
      "id": "520f8c9fc5215709",
      "text": "> In computer science, a parsing expression grammar (PEG), is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by [[Bryan Ford]] in 2004 and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser."
    },
    {
      "type": "paragraph",
      "id": "95ad795c2a69f522",
      "text": "Parsing expression grammars (PEGs) developed by Ford [For04] are an alternative, recognition-based formal foundation for language syntax. PEGs are stylistically similar to CFGs with regular expression-like features, similarly to the Extended Backus-Naur Form ([[EBNF]]) notation [Wir77, ISO96]. The key difference is that in place of the unordered choice operator | used to indicate alternative expansions for a non-terminal in EBNF, PEGs use the prioritized choice operator / . This operator lists alternative patterns to be tested in order, unconditionally using the first successful match. The EBNF rules"
    },
    {
      "type": "code",
      "id": "242d0fab5d7103b7",
      "text": "A → ab | a \nA → a  | ab"
    },
    {
      "type": "paragraph",
      "id": "2747de3380868aba",
      "text": "are equivalent in CFGs, but the PEG rules"
    },
    {
      "type": "code",
      "id": "1c552918c1fb0fb3",
      "text": "A ← ab / a \nA ← a  / ab"
    },
    {
      "type": "paragraph",
      "id": "8917cd352fead6e6",
      "text": "are different. The second alternative in the latter PEG rule will never succeed because the first choice is always taken if the input string to be recognized begins with ’a’ ."
    },
    {
      "type": "paragraph",
      "id": "a93ea3b5ba788c68",
      "text": "A PEG may be viewed as a formal description of a top-down parser."
    },
    {
      "type": "paragraph",
      "id": "0be13efd0533992d",
      "text": "[…] Table 3.1: PEG operators"
    },
    {
      "type": "pagefold",
      "id": "41ef5350f649dee0",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "4c087976f293f802",
      "text": "[[Jan Kurs]], „[[Parsing For Agile Modeling]]“, Wayback Machine, 20. Januar 2022. [https://web.archive.org/web/20220120191851/http://scg.unibe.ch/archive/phd/kurs-phd.pdf pdf], p. 24–25."
    },
    {
      "type": "reference",
      "id": "f87aeb789549cb2d",
      "site": "wiki.ralfbarkow.ch",
      "slug": "petitparser",
      "title": "PetitParser",
      "text": "[https://www.lukas-renggli.ch/blog/petitparser-1 Writing Parsers with PetitParser] – [[Lukas Renggli]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Parsing Expression Grammar",
        "story": []
      },
      "date": 1639148922573
    },
    {
      "item": {
        "type": "factory",
        "id": "f87aeb789549cb2d"
      },
      "id": "f87aeb789549cb2d",
      "type": "add",
      "date": 1639148927653
    },
    {
      "type": "edit",
      "id": "f87aeb789549cb2d",
      "item": {
        "type": "reference",
        "id": "f87aeb789549cb2d",
        "site": "wiki.ralfbarkow.ch",
        "slug": "petitparser",
        "title": "PetitParser",
        "text": "[https://www.lukas-renggli.ch/blog/petitparser-1 Writing Parsers with PetitParser] – [[Lukas Renggli]]"
      },
      "date": 1639148932728
    },
    {
      "id": "31f98b1f1c3577a2",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "31f98b1f1c3577a2",
        "text": "1. *Scannerless Parsers* combine what is usually done by two independent tools (scanner and parser) into one. This makes writing a grammar much simpler and avoids common problems when grammars are composed.\n1. *Parser Combinators* are building blocks for parsers modeled as a graph of composable objects; they are modular and maintainable, and can be changed, recomposed, transformed and reflected upon.\n1. *Parsing Expression Grammars* (PEGs) provide ordered choice. Unlike in parser combinators, the ordered choice of PEGs always follows the first matching alternative and ignores other alternatives. Valid input always results in exactly one parse-tree, the result of a parse is never ambiguous.\n1. *Packrat Parsers* give linear parse time guarantees and avoid common problems with left-recursion in PEGs."
      },
      "after": "f87aeb789549cb2d",
      "date": 1639148980102
    },
    {
      "type": "edit",
      "id": "31f98b1f1c3577a2",
      "item": {
        "type": "markdown",
        "id": "31f98b1f1c3577a2",
        "text": "*Parsing Expression Grammars* (PEGs) provide ordered choice. Unlike in parser combinators, the ordered choice of PEGs always follows the first matching alternative and ignores other alternatives. Valid input always results in exactly one parse-tree, the result of a parse is never ambiguous."
      },
      "date": 1639148990450
    },
    {
      "item": {
        "type": "factory",
        "id": "08c6befe549f4b43"
      },
      "id": "08c6befe549f4b43",
      "type": "add",
      "after": "31f98b1f1c3577a2",
      "date": 1639149216604
    },
    {
      "type": "edit",
      "id": "08c6befe549f4b43",
      "item": {
        "type": "paragraph",
        "id": "08c6befe549f4b43",
        "text": "Also see [https://en.wikipedia.org/wiki/Parsing_expression_grammar wikipedia]"
      },
      "date": 1639149228583
    },
    {
      "item": {
        "type": "factory",
        "id": "520f8c9fc5215709"
      },
      "id": "520f8c9fc5215709",
      "type": "add",
      "after": "08c6befe549f4b43",
      "date": 1639149241264
    },
    {
      "type": "edit",
      "id": "520f8c9fc5215709",
      "item": {
        "type": "markdown",
        "id": "520f8c9fc5215709",
        "text": "> In computer science, a parsing expression grammar (PEG), is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by Bryan Ford in 2004[1] and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser.\n\nUnlike CFGs, PEGs cannot be ambiguous; if a string parses, it has exactly one valid parse tree. It is conjectured that there exist context-free languages that cannot be recognized by a PEG, but this is not yet proven.[1] PEGs are well-suited to parsing computer languages (and artificial human languages such as Lojban), but not natural languages where the performance of PEG algorithms is comparable to general CFG algorithms such as the Earley algorithm.[2] "
      },
      "date": 1639149245454
    },
    {
      "type": "edit",
      "id": "520f8c9fc5215709",
      "item": {
        "type": "markdown",
        "id": "520f8c9fc5215709",
        "text": "> In computer science, a parsing expression grammar (PEG), is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by Bryan Ford in 2004[1] and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser."
      },
      "date": 1639149273042
    },
    {
      "type": "edit",
      "id": "520f8c9fc5215709",
      "item": {
        "type": "markdown",
        "id": "520f8c9fc5215709",
        "text": "> In computer science, a parsing expression grammar (PEG), is a type of analytic formal grammar, i.e. it describes a formal language in terms of a set of rules for recognizing strings in the language. The formalism was introduced by [[Bryan Ford]] in 2004 and is closely related to the family of top-down parsing languages introduced in the early 1970s. Syntactically, PEGs also look similar to context-free grammars (CFGs), but they have a different interpretation: the choice operator selects the first match in PEG, while it is ambiguous in CFG. This is closer to how string recognition tends to be done in practice, e.g. by a recursive descent parser."
      },
      "date": 1661861099120
    },
    {
      "item": {
        "type": "factory",
        "id": "95ad795c2a69f522"
      },
      "id": "95ad795c2a69f522",
      "type": "add",
      "after": "520f8c9fc5215709",
      "date": 1662050988355
    },
    {
      "type": "edit",
      "id": "95ad795c2a69f522",
      "item": {
        "type": "paragraph",
        "id": "95ad795c2a69f522",
        "text": "Parsing expression grammars (PEGs) developed by Ford [For04] are an alternative, recognition-based formal foundation for language syntax. PEGs are stylistically similar to CFGs with regular expression-like features, similarly to the Extended Backus-Naur Form (EBNF) notation [Wir77, ISO96]. The key difference is that in place of the unordered choice operator | used to indicate alternative expansions for a non-terminal in EBNF, PEGs use the prioritized choice operator / . This operator lists alternative patterns to be tested in order, unconditionally using the first successful match. The EBNF rules"
      },
      "date": 1662050999808
    },
    {
      "type": "edit",
      "id": "95ad795c2a69f522",
      "item": {
        "type": "paragraph",
        "id": "95ad795c2a69f522",
        "text": "Parsing expression grammars (PEGs) developed by Ford [For04] are an alternative, recognition-based formal foundation for language syntax. PEGs are stylistically similar to CFGs with regular expression-like features, similarly to the Extended Backus-Naur Form ([[EBNF]]) notation [Wir77, ISO96]. The key difference is that in place of the unordered choice operator | used to indicate alternative expansions for a non-terminal in EBNF, PEGs use the prioritized choice operator / . This operator lists alternative patterns to be tested in order, unconditionally using the first successful match. The EBNF rules"
      },
      "date": 1662051028212
    },
    {
      "item": {
        "type": "factory",
        "id": "242d0fab5d7103b7"
      },
      "id": "242d0fab5d7103b7",
      "type": "add",
      "after": "95ad795c2a69f522",
      "date": 1662051067069
    },
    {
      "type": "edit",
      "id": "242d0fab5d7103b7",
      "item": {
        "type": "code",
        "id": "242d0fab5d7103b7",
        "text": "A → ab|a \nA → a | ab"
      },
      "date": 1662051084396
    },
    {
      "type": "edit",
      "id": "242d0fab5d7103b7",
      "item": {
        "type": "code",
        "id": "242d0fab5d7103b7",
        "text": "A → ab | a \nA → a  | ab"
      },
      "date": 1662051106762
    },
    {
      "item": {
        "type": "factory",
        "id": "2747de3380868aba"
      },
      "id": "2747de3380868aba",
      "type": "add",
      "after": "242d0fab5d7103b7",
      "date": 1662051116098
    },
    {
      "type": "edit",
      "id": "2747de3380868aba",
      "item": {
        "type": "paragraph",
        "id": "2747de3380868aba",
        "text": "are equivalent in CFGs, but the PEG rules"
      },
      "date": 1662051118906
    },
    {
      "item": {
        "type": "factory",
        "id": "1c552918c1fb0fb3"
      },
      "id": "1c552918c1fb0fb3",
      "type": "add",
      "after": "2747de3380868aba",
      "date": 1662051127213
    },
    {
      "type": "edit",
      "id": "1c552918c1fb0fb3",
      "item": {
        "type": "code",
        "id": "1c552918c1fb0fb3",
        "text": "A ← ab / a \nA ← a  / ab"
      },
      "date": 1662051145801
    },
    {
      "item": {
        "type": "factory",
        "id": "8917cd352fead6e6"
      },
      "id": "8917cd352fead6e6",
      "type": "add",
      "after": "1c552918c1fb0fb3",
      "date": 1662051165543
    },
    {
      "type": "edit",
      "id": "8917cd352fead6e6",
      "item": {
        "type": "paragraph",
        "id": "8917cd352fead6e6",
        "text": "are different. The second alternative in the latter PEG rule will never succeed because the first choice is always taken if the input string to be recognized begins with ’a’ ."
      },
      "date": 1662051167544
    },
    {
      "item": {
        "type": "factory",
        "id": "a93ea3b5ba788c68"
      },
      "id": "a93ea3b5ba788c68",
      "type": "add",
      "after": "8917cd352fead6e6",
      "date": 1662051200937
    },
    {
      "type": "edit",
      "id": "a93ea3b5ba788c68",
      "item": {
        "type": "paragraph",
        "id": "a93ea3b5ba788c68",
        "text": "A PEG may be viewed as a formal description of a top-down parser."
      },
      "date": 1662051203107
    },
    {
      "item": {
        "type": "factory",
        "id": "0be13efd0533992d"
      },
      "id": "0be13efd0533992d",
      "type": "add",
      "after": "a93ea3b5ba788c68",
      "date": 1662051232737
    },
    {
      "type": "edit",
      "id": "0be13efd0533992d",
      "item": {
        "type": "paragraph",
        "id": "0be13efd0533992d",
        "text": "[…] Table 3.1: PEG operators"
      },
      "date": 1662051247232
    },
    {
      "item": {
        "type": "factory",
        "id": "41ef5350f649dee0"
      },
      "id": "41ef5350f649dee0",
      "type": "add",
      "after": "0be13efd0533992d",
      "date": 1662051267676
    },
    {
      "type": "edit",
      "id": "41ef5350f649dee0",
      "item": {
        "type": "pagefold",
        "id": "41ef5350f649dee0",
        "text": "~"
      },
      "date": 1662051271788
    },
    {
      "id": "4c087976f293f802",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "4c087976f293f802",
        "text": "[[Jan Kurs]], „[[Parsing For Agile Modeling]]“, Wayback Machine, 20. Januar 2022. [https://web.archive.org/web/20220120191851/http://scg.unibe.ch/archive/phd/kurs-phd.pdf pdf], p. 22."
      },
      "after": "41ef5350f649dee0",
      "date": 1662051362414
    },
    {
      "type": "edit",
      "id": "4c087976f293f802",
      "item": {
        "type": "paragraph",
        "id": "4c087976f293f802",
        "text": "[[Jan Kurs]], „[[Parsing For Agile Modeling]]“, Wayback Machine, 20. Januar 2022. [https://web.archive.org/web/20220120191851/http://scg.unibe.ch/archive/phd/kurs-phd.pdf pdf], p. 24–25."
      },
      "date": 1662051393919
    },
    {
      "id": "f87aeb789549cb2d",
      "type": "move",
      "order": [
        "31f98b1f1c3577a2",
        "08c6befe549f4b43",
        "520f8c9fc5215709",
        "95ad795c2a69f522",
        "242d0fab5d7103b7",
        "2747de3380868aba",
        "1c552918c1fb0fb3",
        "8917cd352fead6e6",
        "a93ea3b5ba788c68",
        "0be13efd0533992d",
        "41ef5350f649dee0",
        "4c087976f293f802",
        "f87aeb789549cb2d"
      ],
      "date": 1696415241452
    }
  ]
}