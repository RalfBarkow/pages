{
  "title": "Vanilla Web",
  "story": [
    {
      "type": "reference",
      "id": "0ae1a7c946b4a07b",
      "site": "wiki.ralfbarkow.ch",
      "slug": "golo-roden",
      "title": "Golo Roden",
      "text": "is the founder and CTO of the native web GmbH. He is involved in the design and development of web and cloud applications and APIs, with a focus on event-driven and service-based distributed architectures. His guiding principle is that software development is not an end in itself, but must always follow an underlying technicality. [https://www.heise.de/blog/Vanilla-Web-Der-Frontend-Trend-2024-9611002.html blog] (de)"
    },
    {
      "type": "paragraph",
      "id": "7f50ba6ab9897efb",
      "text": "Imagine you are planning the development of a new web or cloud-based software and you have already decided on all the technologies to be used in the backend, but regarding the frontend you are still not quite sure whether you should rely on one of the established top dogs, i.e. a framework such as React, Angular or perhaps Vue, or whether you should opt for one of the newer and smaller frameworks such as Svelte or SolidJS. And not only is this question not new, but above all there is no real answer because no matter which framework you ultimately decide on, you always tie yourself into a vendor lockin and at the same time you never have the guarantee that the respective framework will actually still exist in a few years, that it will still be further developed, that it will still be maintained and so on."
    },
    {
      "type": "paragraph",
      "id": "6c9f33b1df1dc362",
      "text": "And there doesn't really seem to be a silver bullet on how to approach the topic of web UI development at all, because otherwise it wouldn't feel like a completely new framework is released every few weeks and unfortunately this is not only the case with the framework, there is also a whole range of tools that you need, starting with the typescript compiler, a precompiler for SASS or LESS in conjunction with a package manager such as NPM or yarn, an build tool such as Vite, perhaps a separate bundler and so on and so forth. And if you feel like me then you have long since lost interest in this kind of web development and it all feels like it's not getting any better but only getting worse."
    },
    {
      "type": "paragraph",
      "id": "27734aea21cca5e3",
      "text": "New tools are constantly being added and the whole [[Ease]] that was typical of web development many years ago is unfortunately now a really long time ago and the question then arises as to where all this is supposed to lead would it not be long overdue to pause and ask ourselves whether we haven't been going in the wrong direction for years and how we could perhaps make the whole thing much better and that's exactly what this video is about."
    },
    {
      "type": "paragraph",
      "id": "218e4cb625b80184",
      "text": "I just mentioned it, web development used to be different, web development used to be lightweight, it was enough to change a few characters in the text editor, save them in the web browser, reload them once and that was it, and it didn't matter whether you were editing HTML or CSS or Javascript, all three languages worked without a [[Compiler]] and without separate tooling. That was the big difference to desktop development about 25 years ago, where you always had to rely on a compiler and therefore always had to wait until you could actually try out the changes to the source code and that was one of the things that fascinated me (Golo Roden) about the web from the beginning, this simplicity, which was reduced to the essentials and when I look at it now compared to today, it's no longer fun at all because you can't just write a bit of HTML, you need jsx or some other abstraction for which you then need a special precompiler. A dedicated precompiler that needs to be installed via NPM, for which you need node, which in turn should be installed via the node version Manager NVM and that's already four technologies that you only need to be able to write HTML and we haven't even talked about CSS or let alone JavaScript and we haven't even talked about the whole surrounding ecosystem with linting with formatting with testing and so on and to make a long story short, Front-end web development is no longer really fun, at least for me personally, and the sad thing is that much of what we do today is no longer necessary because the web and web browsers can now do most of it natively and that is a really bitter realization in recent years and decades we have completely lost sight of why we use all these frameworks and tools at all and we have become so used to using them that we only question whether they are really necessary. That we only ever question whether the chosen tool or library is the right one, but never whether we still need the tool or library itself at all and that is currently changing or I personally have the impression that there will be so much momentum on this issue now in 2024 that web development itself will change fundamentally in the next 12 months. The result of that could be that we can leave the whole thing with a much more stable and, above all, much more reliable technology stack in the long term and I would like to briefly outline what that might look like below."
    },
    {
      "type": "paragraph",
      "id": "972e1532c0e21583",
      "text": "If you ask developers what the main reason is for them to rely on a framework like React, Angular or something else, the answer is usually that you can use it to define and orchestrate components, i.e. develop independent, self-contained and, above all, reusable code units that you can then put together modularly to form a large whole, be it a website or a web application. And it is about the latter, i.e. the orchestration of elements, which is the core task of HTML, i.e. we actually only need a way to create our own HTML elements in order to extend what HTML can do anyway with our own individual components, and this is exactly what the so-called custom elements make possible. A [[Custom Element]] is nothing more than a few HTML elements defined by JavaScript, which you can then use just like the standard HTML elements, i.e. you don't need a special framework to create a reusable HTML [[Component]] that doesn't yet exist, it simply works in HTML by default."
    },
    {
      "type": "paragraph",
      "id": "7c2ec33f52ce20ba",
      "text": "Now you might argue that HTML is only half the battle. Components should usually also have their own style and then you probably also want to make sure that the styles of different components don't get in each other's way, i.e. that each component has its own and cleanly separated area for CSS and for this the concept of CSS modules has now been established in various frameworks, but this in turn requires a corresponding bundler or a precompiler, which supports the concept of CSS modules in the first place and then translates them accordingly and the point here is that this would not even be necessary because the browser can manage its own scopes for CSS by default, so that you can simply assign a self-contained area for CSS to each user-defined element, the whole thing is then called [[Shadow DOM]] and because user-defined elements and the Shadow DOM harmonize so nicely with each other, these two technologies are the basis for what is usually called [[Web Components]], and strictly speaking there is also the HTML element template, but basically web components enable exactly what you want to use an additional framework for, namely the definition of reusable components including a separate scopes for CSS."
    },
    {
      "type": "paragraph",
      "id": "5459837d9468165c",
      "text": "Maybe you're saying that's all well and good, but Web Components aren't exactly new, after all, they've been around since 2011 and maybe they're even quite nice, but it's not really fun to write them because the API for Web Components is pretty antiquated and you know what, I'm totally with you there."
    },
    {
      "type": "paragraph",
      "id": "1f733ef5ef47e3ac",
      "text": "But fortunately, there are quite good abstractions for Web Components that make the whole thing much more accessible, and I personally think of the [[Lit]] framework, for example, which we've already seen in action in one of our livestreams, and if you didn't see it back then, you can find the link to it here in the info card above. Of course, you can argue that this is somehow not the purpose of the thing, because then you would be dependent on a framework again and that is true for now, but unlike React, Angular and Co. you don't write components with Lit that only work with the respective framework, but you create a universally valid component that can run with all frameworks or even without a framework, because it runs natively in the browser and I personally find that much better."
    },
    {
      "type": "paragraph",
      "id": "b6c1d281ef1be985",
      "text": "Now I mentioned at the beginning that the build step bothers me and if we now rely on Lit as a framework, then of course we have a build step again, at least that's what I thought until recently, but that's not the case. Lit can be executed completely at runtime, which means that I don't have to use a compiler and that makes the whole thing even more pleasant when you realize that you don't even have to install Lit via NPM, but can simply load it via import from a CDN and if you say that this is stupid because then you have to rely on version numbers in the import URL everywhere, then that's true, unless you use a so-called [[Import Map]] [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap mdn], which by the way is another feature of modern browsers that is simply there."
    },
    {
      "type": "paragraph",
      "id": "f8ae32a5bb00243a",
      "text": "With such an import map, you can define centrally that there should be an import called lit, for example, and to which URL it should be resolved, and then you simply work with Lit in each of your scripts as if it were installed locally via NPM and you control the version centrally via the import map. Problem solved, completely without NPM and above all without a build step."
    },
    {
      "type": "paragraph",
      "id": "3504fee699197195",
      "text": "And the whole thing works because it has been possible for a few years now, thanks to the ability to load JavaScript code dynamically at runtime as an ECMAScript module. And of course you can also say that this is completely impractical, because then my application consists of lots of small individual files and this creates a lot of HTTP overhead when loading and I agree with you in principle, but the question is how bad is this really, so does every nanosecond or millisecond really matter for the website or web application that you are building, or does it really not matter?"
    },
    {
      "type": "paragraph",
      "id": "13ac183afc4af3d9",
      "text": "There will certainly be cases in which this is ultra important, e.g. because of SEO, that everything is loaded as quickly as possible with a few requests, but there will also be cases in which this is completely irrelevant because the application is not public facing at all, for example, but is only made available to private users in a private group anyway, where the whole thing is not so decisive, e.g. on the intranet, at least one could think about this distinction."
    },
    {
      "type": "paragraph",
      "id": "88cc6898ec799b55",
      "text": "This means that we can define components up to this point, we can orchestrate components, we can do the whole thing with a convenient API, we have scopes of CSS, we have centralized management of imports and all without a single compile or build step."
    },
    {
      "type": "paragraph",
      "id": "facffd63e90775e9",
      "text": "But what if you don't want to define the CSS inline in a web component, because not all developers like the approach of having HTML CSS and Javascript in one file, some want to outsource the CSS and that's one of the advantages of CSS modules, that it just works that way and the whole thing works natively with CSS Module Scripts without CSS modules."
    },
    {
      "type": "paragraph",
      "id": "94f370d9b7876fda",
      "text": "You've probably never heard of [[CSS Module Scripts]], but that doesn't matter, because you're learning about it through me today, and the whole thing is based on the concept of what's called constructible stylesheets, which is most likely another term you've never heard of, but these two techniques together allow you to do exactly what you'd like, namely scoped CSS with a Shadow DOM, but the whole thing in a separate CSS file that you can load into the JavaScript code. And speaking of CSS, if you now say, all well and good, but you would actually like to have sass or less or something like that, then you can also ask the question here why? And the common standard answer to this question is that it is mainly about the possibility of writing the CSS definitions nested inside each other."
    },
    {
      "type": "paragraph",
      "id": "c9d481a06561f819",
      "text": "And you know what CSS has been doing this natively for a short time now, i.e. CSS now supports native nesting and apart from that also a few other very nice things that were previously reserved for SASS and Co and so you can actually save these preprocessors, by the way, the same applies to the topic of theming because that can also be done quite well natively namely with the help of CSS variables. And of course not everything works automatically equivalent as you know it from React, Angular and Co. above all, these frameworks also provide a certain structure for the application, although this admittedly varies greatly from framework to framework, but it can now be surprisingly much easier with the native board means of the browser and, as I said, the whole thing saves you everything that goes in the direction of compiler, bundlers and the like and so far this has been going a bit under the keyword buildless but for my taste this focuses too much only on the aspect that you no longer have to compile; I personally think it is therefore much better to speak of [[Vanilla Web]] analogous to Vanilla JavaScript. And that means as much as natively without additional libraries and frameworks simply getting by with what is offered by default without great extras and why is it called Vanilla as far as I know because vanilla is supposedly the most unspectacular ice cream flavor without great extras but which is still somehow more or less liked by everyone."
    },
    {
      "type": "paragraph",
      "id": "6d342443d18e4d9e",
      "text": "The bottom line is that I'm perhaps not telling you too much that's new because a lot of what I've talked about so far has actually been around for a number of years but and that's the crux of the matter all these technologies are there they exist but at least so far I don't have the feeling that the individual pieces of the puzzle are being put together on a larger scale and that many developers are simply sticking with the framework they know from the past out of habit. But as I said, I'm starting to get the feeling that this could change this year and yes, of course, that would be another switch to another approach, but the nice thing about it would be that it could be the last switch of this kind because, as I said, the whole thing could prove to be somewhat more reliable and sustainable than the typical web UI frameworks we have encountered in recent years."
    },
    {
      "type": "paragraph",
      "id": "3a7d65cb666b09d7",
      "text": "By the way, what unfortunately throws a spanner in the works is typescript because there is the somewhat strange proposal from Microsoft to simply view the type annotations of typescript in Javascript as comments if you want to know more about this, see their infocard but so far you still need a compiler in any case that doesn't necessarily have to be the original typescript compiler something like esbild for example, that does the job in case of doubt, but you still need some build step unless you do without the typescript own syntax for type definitions and switch here e.g. to JS Doc and if necessary just to the manual writing of tsd files then you could even do without the typescript compiler but would still have a reasonable type safety and appropriate support in the IDE."
    },
    {
      "type": "paragraph",
      "id": "9122d68c246bedc4",
      "text": "A big proponent of this approach is the team behind Svelt because  for Svelt 4 exactly this approach with JSDoc was announced  but it remains exciting to see what the whole thing will actually end up with."
    },
    {
      "type": "paragraph",
      "id": "c6c295fc09866cb9",
      "text": "The bottom line for you is that your preferred JavaScript framework with all its tools is no longer as absolutely irreplaceable as you may have assumed in recent years. I can only advise you to take a look at all the technologies and concepts mentioned and experiment with them a little and, above all, question whether the framework and tooling of your choice offers any real advantages, or whether it might even be too much of a good thing for one task or another; because as I said, I could well imagine that I will be changing a little over the course of this year, and if you don't want to do this alone, but would like to review and question your technology stack together with someone, then get in touch with us [https://www.thenativeweb.io/ www.thenativeweb.io] and you'll find the link and contact details at the bottom of the video description. Take care, stay well and see you next time. Bye."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Vanilla Web",
        "story": []
      },
      "date": 1711119812397
    },
    {
      "item": {
        "type": "factory",
        "id": "0ae1a7c946b4a07b"
      },
      "id": "0ae1a7c946b4a07b",
      "type": "add",
      "date": 1711119816480
    },
    {
      "type": "edit",
      "id": "0ae1a7c946b4a07b",
      "item": {
        "type": "reference",
        "id": "0ae1a7c946b4a07b",
        "site": "wiki.ralfbarkow.ch",
        "slug": "golo-roden",
        "title": "Golo Roden",
        "text": "Golo Roden is the founder and CTO of the native web GmbH. He is involved in the design and development of web and cloud applications and APIs, with a focus on event-driven and service-based distributed architectures. His guiding principle is that software development is not an end in itself, but must always follow an underlying technicality. [https://www.heise.de/blog/Vanilla-Web-Der-Frontend-Trend-2024-9611002.html blog] (de)"
      },
      "date": 1711119819005
    },
    {
      "type": "edit",
      "id": "0ae1a7c946b4a07b",
      "item": {
        "type": "reference",
        "id": "0ae1a7c946b4a07b",
        "site": "wiki.ralfbarkow.ch",
        "slug": "golo-roden",
        "title": "Golo Roden",
        "text": "is the founder and CTO of the native web GmbH. He is involved in the design and development of web and cloud applications and APIs, with a focus on event-driven and service-based distributed architectures. His guiding principle is that software development is not an end in itself, but must always follow an underlying technicality. [https://www.heise.de/blog/Vanilla-Web-Der-Frontend-Trend-2024-9611002.html blog] (de)"
      },
      "date": 1711119824881
    },
    {
      "type": "fork",
      "site": "wiki.ralfbarkow.ch",
      "date": 1711123576130
    },
    {
      "id": "7f50ba6ab9897efb",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "7f50ba6ab9897efb",
        "text": "stell dir vor du planst die Entwicklung einer neuen Web oder Cloud basierten Software und im Backend hast du alle zu verwendenen Technologien bereits entschieden nur im Frontend bist du dir noch nicht so ganz sicher solltest du eher auf einen der etablierten Platzhirsche setzen also auf ein Framework wie react angular oder vielleicht auch view oder solltest du dich eher für eines der neueren und kleineren Frameworks entscheiden wie z.B swelt oder solid JS und diese Frage die ist nicht nur nicht neu diese Frage Frage kennt vor allem auch keine richtige Antwort denn völlig egal für welches Framework du dich letztlich entscheidest du bindest dich immer das heißt du handelst dir immer einen vendor lockin ein und du hast zugleich aber nie die Garantie dass es das jeweilige Framework in ein paar Jahren auch tatsächlich noch geben wird dass es noch weiterentwickelt werden wird dass es noch gepflegt werden wird und so weiter"
      },
      "after": "0ae1a7c946b4a07b",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711123617006
    },
    {
      "type": "edit",
      "id": "7f50ba6ab9897efb",
      "item": {
        "type": "paragraph",
        "id": "7f50ba6ab9897efb",
        "text": "Imagine you are planning the development of a new web or cloud based software and in the backend you have already decided on all the technologies to be used, only in the frontend you are not quite sure yet should you rather rely on one of the established top dogs like react angular or maybe view or should you rather opt for one of the newer and smaller frameworks like e.g. swelt or solid JS. B swelt or solid JS and this question is not only not new, this question above all has no real answer because no matter which framework you ultimately decide on, you always bind yourself, which means you always get a vendor lockin and at the same time you never have the guarantee that the respective framework will actually still exist in a few years that it will still be further developed that it will still be maintained and so on"
      },
      "date": 1711123625188
    },
    {
      "type": "edit",
      "id": "7f50ba6ab9897efb",
      "item": {
        "type": "paragraph",
        "id": "7f50ba6ab9897efb",
        "text": "Imagine you are planning the development of a new web or cloud-based software and you have already decided on all the technologies to be used in the backend, but you are still not quite sure whether you should rely on one of the established top dogs, i.e. a framework such as react angular or perhaps view, or whether you should opt for one of the newer and smaller frameworks such as swelt or solid JS. And not only is this question not new, but above all there is no real answer because no matter which framework you ultimately decide on, you always tie yourself into a vendor lockin and at the same time you never have the guarantee that the respective framework will actually still exist in a few years, that it will still be further developed, that it will still be maintained and so on."
      },
      "date": 1711123731353
    },
    {
      "id": "6c9f33b1df1dc362",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "6c9f33b1df1dc362",
        "text": "und ein Königsweg wie man das Thema Web UI Entwicklung überhaupt angeht den scheint es auch nicht so wirklich zu geben denn sonst würde nicht gefühlt alle paar Wochen in komplett komplett neues Framework erscheinen und leider geht ja das nicht nur beim Framework so hinzu kommt nämlich noch eine ganze Reihe an Werkzeugen die du auch noch benötigst angefangen beim typescript Compiler über einen precompiler für SAS oder L in Verbindung mit einem Package Manager wie NPM oder yarn ein Bildtool wie z.B wieed vielleicht noch ein gesonderter Bandler und so weiter und so fort und wenn es dir dir da geht wie mir dann hast du auf diese Art der Webentwicklung schon lange keine Lust mehr und das alles wird gefühlt nicht besser sondern immer nur noch schlimmer"
      },
      "after": "7f50ba6ab9897efb",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711123756142
    },
    {
      "type": "edit",
      "id": "6c9f33b1df1dc362",
      "item": {
        "type": "paragraph",
        "id": "6c9f33b1df1dc362",
        "text": "And there doesn't really seem to be a silver bullet on how to approach the topic of web UI development at all, because otherwise it wouldn't feel like a completely new framework is released every few weeks and unfortunately this is not only the case with the framework, there is also a whole range of tools that you need, starting with the typescript compiler, a precompiler for SAS or L in conjunction with a package manager such as NPM or yarn, an image tool such as Vite, perhaps a separate bandler and so on and so forth. B wieed maybe a separate bandler and so on and so forth and if you feel like me then you have long since lost interest in this kind of web development and it all feels like it's not getting any better but only getting worse"
      },
      "date": 1711123824946
    },
    {
      "type": "edit",
      "id": "6c9f33b1df1dc362",
      "item": {
        "type": "paragraph",
        "id": "6c9f33b1df1dc362",
        "text": "And there doesn't really seem to be a silver bullet on how to approach the topic of web UI development at all, because otherwise it wouldn't feel like a completely new framework is released every few weeks and unfortunately this is not only the case with the framework, there is also a whole range of tools that you need, starting with the typescript compiler, a precompiler for SASS or LESS in conjunction with a package manager such as NPM or yarn, an build tool such as Vite, perhaps a separate bundler and so on and so forth. A nd if you feel like me then you have long since lost interest in this kind of web development and it all feels like it's not getting any better but only getting worse."
      },
      "date": 1711123935909
    },
    {
      "type": "edit",
      "id": "6c9f33b1df1dc362",
      "item": {
        "type": "paragraph",
        "id": "6c9f33b1df1dc362",
        "text": "And there doesn't really seem to be a silver bullet on how to approach the topic of web UI development at all, because otherwise it wouldn't feel like a completely new framework is released every few weeks and unfortunately this is not only the case with the framework, there is also a whole range of tools that you need, starting with the typescript compiler, a precompiler for SASS or LESS in conjunction with a package manager such as NPM or yarn, an build tool such as Vite, perhaps a separate bundler and so on and so forth. And if you feel like me then you have long since lost interest in this kind of web development and it all feels like it's not getting any better but only getting worse.\n\nTranslated with www.DeepL.com/Translator (free version)"
      },
      "date": 1711123949867
    },
    {
      "type": "edit",
      "id": "6c9f33b1df1dc362",
      "item": {
        "type": "paragraph",
        "id": "6c9f33b1df1dc362",
        "text": "And there doesn't really seem to be a silver bullet on how to approach the topic of web UI development at all, because otherwise it wouldn't feel like a completely new framework is released every few weeks and unfortunately this is not only the case with the framework, there is also a whole range of tools that you need, starting with the typescript compiler, a precompiler for SASS or LESS in conjunction with a package manager such as NPM or yarn, an build tool such as Vite, perhaps a separate bundler and so on and so forth. And if you feel like me then you have long since lost interest in this kind of web development and it all feels like it's not getting any better but only getting worse."
      },
      "date": 1711123955271
    },
    {
      "id": "27734aea21cca5e3",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "27734aea21cca5e3",
        "text": "Ständig kommen neue Werkzeuge hinzu und die ganze [[Leichtigkeit]] die vor vielen Jahren mal typisch für die Webentwicklung war das ist leider inzwischen echt lange her und da stellt sich dann die Frage wo soll das denn alles noch hinführen wäre es nicht längst überfällig da mal inne zu halten und sich mal zu fragen ob wir nicht seit Jahren in eine gänzlich falsche Richtung laufen und wie man das ganze nicht vielleicht deutlich besser machen könnte und genau darum geht es heute in diesem Video in diesem Sinne hallo und herzlich willkommen zu unserem neuen weekly und by the way ein schönes und frohes neues Jahr"
      },
      "after": "6c9f33b1df1dc362",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711123989345
    },
    {
      "type": "edit",
      "id": "27734aea21cca5e3",
      "item": {
        "type": "paragraph",
        "id": "27734aea21cca5e3",
        "text": "New tools are constantly being added and the whole [[Ease]] that was typical of web development many years ago is unfortunately now a really long time ago and the question then arises as to where all this is supposed to lead would it not be long overdue to pause and ask ourselves whether we haven't been going in the wrong direction for years and how we could perhaps make the whole thing much better and that's exactly what this video is about today in this meaning hello and welcome to our new weekly and by the way a happy new year"
      },
      "date": 1711124025347
    },
    {
      "type": "edit",
      "id": "27734aea21cca5e3",
      "item": {
        "type": "paragraph",
        "id": "27734aea21cca5e3",
        "text": "New tools are constantly being added and the whole [[Ease]] that was typical of web development many years ago is unfortunately now a really long time ago and the question then arises as to where all this is supposed to lead would it not be long overdue to pause and ask ourselves whether we haven't been going in the wrong direction for years and how we could perhaps make the whole thing much better and that's exactly what this video is about."
      },
      "date": 1711124043181
    },
    {
      "id": "218e4cb625b80184",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "218e4cb625b80184",
        "text": "ja und ich habe es gerade schon angesprochen Webentwicklung war mal anders Webentwicklung war mal leichtgewichtig da hat es genügt in dem Texteditor ein paar Zeichen zu ändern zu speichern im Webbrowser einmal neu zu laden und das war's und da war es völlig egal ob man da gerade HTML oder CSS oder Javascript bearbeitet hat alle drei Sprachen kamen ohne ein [[Compiler]] und ohne gesondertes tooling aus und das war damals so vor ungefähr 25 Jahren der große Unterschied zur desktopentwicklung wo man immer auf einen Compiler angewiesen war und daher auch immer entsprechend warten musste bevor man die Änderungen am Quellcode dann auch tatsächlich ausprobieren konnte und das war mal einer der Punkte die mich von Anfang an am Web fasziniert hatten diese auf das Wesentliche reduzierte Einfachheit und wenn ich mir das jetzt im Vergleich zu heute anschaue dann macht das inzwischen über überhaupt keinen Spaß mehr da kann man nicht einfach mal ein bisschen HTML schreiben sondern man braucht direkt jsx oder irgendeine andere Abstraktion für die man dann ein dedizierten precompiler benötigt der über NPM installiert werden muss wofür man dann wiederum noe braucht was man an seinerseits wiederum über den noe Version Manager NVM installieren sollte und das sind jetzt schon vier Technologien die man letztlich aber nur dafür braucht um HTML schreiben zu können und da haben wir noch nicht über CSS oder geschweige den JavaScript gesprochen und auch noch noch nicht über das ganze umgebende Ökosystem mit linting mit formatting mit testing und so weiter und um es kurz zu machen Frontend Web Entwicklung macht zumindest mir persönlich keinen wirklichen Spaß mehr ja und das traurige ist ganz vieles von dem was wir da heute alles veranstalten das wäre überhaupt nicht mehr notwendig weil das Web bzw die Webbrowser das meiste inzwischen nativ beherrschen wir haben und das ist eine echt bittere Erkenntnis in den vergangenen Jahren und Jahrzehnten vollkommen aus den Augen verloren warum wir all diese Frameworks und Werkzeuge überhaupt einsetzen und wir haben uns so sehr an die Tatsache gewöhnt dass wir sie einsetzen dass wir immer nur hinterfragen ob das gewählte Tool ob die gewählte Bibliothek ob das das richtige ist aber nie ob wir das Tool oder die Bibliothek an sich überhaupt noch brauchen und das ändert sich gerade bzw ich persönlich habe den Eindruck dass jetzt im Jahr 2024 genug momentum in diese Frage kommt dass sich weblung an Webentwicklung an sich in den nächsten 12 Monaten durchaus grundlegend verändern könnte und das Ergebnis davon könnte sein dass wir mit einem deutlich stabileren und vor allem langfristig auch mit einem deutlich verlässlicheren technologiestck aus der ganzen Sache hinausgehen können und wie das aussehen könnte das möchte ich Dir jetzt im Folgenden mal kurz skizzieren"
      },
      "after": "27734aea21cca5e3",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711124228270
    },
    {
      "type": "edit",
      "id": "218e4cb625b80184",
      "item": {
        "type": "paragraph",
        "id": "218e4cb625b80184",
        "text": "I just mentioned it, web development used to be different, web development used to be lightweight, it was enough to change a few characters in the text editor, save them in the web browser, reload them once and that was it, and it didn't matter whether you were editing HTML or CSS or Javascript, all three languages worked without a [[Compiler]] and without separate tooling. That was the big difference to desktop development about 25 years ago, where you always had to rely on a compiler and therefore always had to wait until you could actually try out the changes to the source code and that was one of the things that fascinated me (Golo Roden) about the web from the beginning, this simplicity, which was reduced to the essentials and when I look at it now compared to today, it's no longer fun at all because you can't just write a bit of HTML, you need jsx or some other abstraction for which you then need a special precompiler. A dedicated precompiler that needs to be installed via NPM, for which you need node, which in turn should be installed via the node version Manager NVM and that's already four technologies that you only need to be able to write HTML and we haven't even talked about CSS or let alone JavaScript and we haven't even talked about the whole surrounding ecosystem with linting with formatting with testing and so on and to make a long story short, Front-end web development is no longer really fun, at least for me personally, and the sad thing is that much of what we do today is no longer necessary because the web and web browsers can now do most of it natively and that is a really bitter realization in recent years and decades we have completely lost sight of why we use all these frameworks and tools at all and we have become so used to using them that we only question whether they are really necessary. That we only ever question whether the chosen tool or library is the right one, but never whether we still need the tool or library itself at all and that is currently changing or I personally have the impression that there will be so much momentum on this issue now in 2024 that web development itself will change fundamentally in the next 12 months. The result of that could be that we can leave the whole thing with a much more stable and, above all, much more reliable technology stack in the long term and I would like to briefly outline what that might look like below."
      },
      "date": 1711124468241
    },
    {
      "id": "972e1532c0e21583",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "972e1532c0e21583",
        "text": "wenn man EntwicklerInnen und Entwickler fragt was der Hauptgrund für sie ist auf ein Framework wie react angular oder sonst was zu setzen dann ist die Antwort üblicherweise dass man damit mit Komponenten definieren und orchestrieren können also eigenständige in sich abgeschlossene und vor allem wiederverwendbare Einheiten von Code zu entwickeln die man dann modular zu einem großen Ganzen zusammenfügen kann sei es als Webseite oder als Webanwendung und der Punkt ist letzteres also das orchestrieren von Elementen das ist die Kernaufgabe von HTML das heißt wir brauchen eigentlich nur einen Weg um eigene htmlelemente zu erzeugen um quasi das was HTML von Haus aus sowieso schon kann um unsere eigenen individuellen Komponenten zu erweitern na ja und genau das ermöglichen die sogenannten custom Elements. Ein [[Custom Element]] ist nämlich nichts anderes als ein paar JavaScript definiertes eigenes HTML Element dass du im Anschluss genauso wie die von Haus aus verfügbaren htmlelemente verwenden kannst das heißt um eine wieder verwendbare HTML [[Komponente]] zu erstellen die es noch nicht gibt brauchst du kein dediziertes Framework sondern das funktioniert in HTML einfach so von Haus aus"
      },
      "after": "218e4cb625b80184",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711124478934
    },
    {
      "type": "edit",
      "id": "972e1532c0e21583",
      "item": {
        "type": "paragraph",
        "id": "972e1532c0e21583",
        "text": "If you ask developers what the main reason is for them to rely on a framework like React, Angular or something else, the answer is usually that you can use it to define and orchestrate components, i.e. develop independent, self-contained and, above all, reusable code units that you can then put together modularly to form a large whole, be it a website or a web application. And it is about the latter, i.e. the orchestration of elements, which is the core task of HTML, i.e. we actually only need a way to create our own HTML elements in order to extend what HTML can do anyway with our own individual components, and this is exactly what the so-called custom elements make possible. A [[Custom Element]] is nothing more than a few HTML elements defined by JavaScript, which you can then use just like the standard HTML elements, i.e. you don't need a special framework to create a reusable HTML [[Component]] that doesn't yet exist, it simply works in HTML by default."
      },
      "date": 1711124592229
    },
    {
      "id": "7c2ec33f52ce20ba",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "7c2ec33f52ce20ba",
        "text": "nun magst Du vielleicht einwenden dass HTML ja nur die halbe Miete sei Komponenten sollen üblicherweise auch ihren eigenen Style bekommen na ja und da möchtest du wahrscheinlich dann auch gerne sichergehen dass sich die Styles von unterschiedlichen Komponenten nicht gegenseitig in die Quere kommen also mit anderen Worten dass jede Komponente sozusagen ihren eigenen und sauber abgeschotteten Bereich für CSS hat und dafür hat sich in diversen Frameworks inzwischen das Konzept von CSS modules etabliert aber das wiederum setzt einen entsprechenden Bandler bzw einen precompiler voraus der das Konzept von CSS modules überhaupt erstmal unterstützt und der das dann entsprechend übersetzt und der Punkt ist dabei aber auch hier dass das gar nicht notwendig wäre denn der Browser kann nativ eigene Scopes für CSS verwalten sod dass man jedem custom Element einen in sich geschlossenen Bereich für CSS einfach zuweisen kann das ganze nennt sich dann [[Shadow Dom]] und weil custom Elements und das shadowom weil die so schön miteinander harmonieren sind diese beiden Technologien die Basis für das was in der Regel als webcomponents bezeichnet wird und da kommt dann streng genommen noch das HTML Element Template hinzu aber im Grunde ermöglichen webcomponents eben genau das wofür man ja ach so gerne ein zusätzliches Framework verwendet nämlich das Definieren von wiederverwendbaren Komponenten einschließlich eines eigenen Scopes für CSS"
      },
      "after": "972e1532c0e21583",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711124599967
    },
    {
      "type": "edit",
      "id": "7c2ec33f52ce20ba",
      "item": {
        "type": "paragraph",
        "id": "7c2ec33f52ce20ba",
        "text": "Now you might argue that HTML is only half the battle Components should usually also have their own style and then you probably also want to make sure that the styles of different components don't get in each other's way, i.e. that each component has its own and cleanly separated area for CSS and for this the concept of CSS modules has now been established in various frameworks, but this in turn requires a corresponding bundler or a precompiler, which supports the concept of CSS modules in the first place and then translates them accordingly and the point here is that this would not even be necessary because the browser can manage its own scopes for CSS by default, so that you can simply assign a self-contained area for CSS to each user-defined element, the whole thing is then called [[Shadow Dom]] and because user-defined elements and the Shadow DOM harmonize so nicely with each other, these two technologies are the basis for what is usually called [[Shadow Dom]]. The basis for what is usually called web components, and strictly speaking there is also the HTML element template, but basically web components enable exactly what you want to use an additional framework for, namely the definition of reusable components including a separate area for CSS."
      },
      "date": 1711124656446
    },
    {
      "type": "edit",
      "id": "7c2ec33f52ce20ba",
      "item": {
        "type": "paragraph",
        "id": "7c2ec33f52ce20ba",
        "text": "Now you might argue that HTML is only half the battle Components should usually also have their own style and then you probably also want to make sure that the styles of different components don't get in each other's way, i.e. that each component has its own and cleanly separated area for CSS and for this the concept of CSS modules has now been established in various frameworks, but this in turn requires a corresponding bundler or a precompiler, which supports the concept of CSS modules in the first place and then translates them accordingly and the point here is that this would not even be necessary because the browser can manage its own scopes for CSS by default, so that you can simply assign a self-contained area for CSS to each user-defined element, the whole thing is then called [[Shadow DOM]] and because user-defined elements and the Shadow DOM harmonize so nicely with each other, these two technologies are the basis for what is usually called [[Wweb Components]], and strictly speaking there is also the HTML element template, but basically web components enable exactly what you want to use an additional framework for, namely the definition of reusable components including a separate area for CSS."
      },
      "date": 1711124704135
    },
    {
      "type": "edit",
      "id": "7c2ec33f52ce20ba",
      "item": {
        "type": "paragraph",
        "id": "7c2ec33f52ce20ba",
        "text": "Now you might argue that HTML is only half the battle Components should usually also have their own style and then you probably also want to make sure that the styles of different components don't get in each other's way, i.e. that each component has its own and cleanly separated area for CSS and for this the concept of CSS modules has now been established in various frameworks, but this in turn requires a corresponding bundler or a precompiler, which supports the concept of CSS modules in the first place and then translates them accordingly and the point here is that this would not even be necessary because the browser can manage its own scopes for CSS by default, so that you can simply assign a self-contained area for CSS to each user-defined element, the whole thing is then called [[Shadow DOM]] and because user-defined elements and the Shadow DOM harmonize so nicely with each other, these two technologies are the basis for what is usually called [[Wweb Components]], and strictly speaking there is also the HTML element template, but basically web components enable exactly what you want to use an additional framework for, namely the definition of reusable components including a separate scopes for CSS."
      },
      "date": 1711124737143
    },
    {
      "id": "5459837d9468165c",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "5459837d9468165c",
        "text": "und vielleicht sagst du jetzt das ist ja schön und gut aber webcomponents sind nicht gerade neu immerhin gibt es die schon seit 2011 und vielleicht sind die ja sogar auch ganz nett aber so wirklich Spaß macht das dann halt doch nicht sie zu schreiben weil die API für webcomponents ziemlich antiquiert daherkommen und weißt du was da bin ich absolut bei dir"
      },
      "after": "7c2ec33f52ce20ba",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711124740622
    },
    {
      "type": "edit",
      "id": "7c2ec33f52ce20ba",
      "item": {
        "type": "paragraph",
        "id": "7c2ec33f52ce20ba",
        "text": "Now you might argue that HTML is only half the battle Components should usually also have their own style and then you probably also want to make sure that the styles of different components don't get in each other's way, i.e. that each component has its own and cleanly separated area for CSS and for this the concept of CSS modules has now been established in various frameworks, but this in turn requires a corresponding bundler or a precompiler, which supports the concept of CSS modules in the first place and then translates them accordingly and the point here is that this would not even be necessary because the browser can manage its own scopes for CSS by default, so that you can simply assign a self-contained area for CSS to each user-defined element, the whole thing is then called [[Shadow DOM]] and because user-defined elements and the Shadow DOM harmonize so nicely with each other, these two technologies are the basis for what is usually called [[Web Components]], and strictly speaking there is also the HTML element template, but basically web components enable exactly what you want to use an additional framework for, namely the definition of reusable components including a separate scopes for CSS."
      },
      "date": 1711124753142
    },
    {
      "type": "edit",
      "id": "5459837d9468165c",
      "item": {
        "type": "paragraph",
        "id": "5459837d9468165c",
        "text": "Maybe you're saying that's all well and good, but Web Components aren't exactly new, after all, they've been around since 2011 and maybe they're even quite nice, but it's not really fun to write them because the API for Web Components is pretty antiquated and you know what, I'm totally with you there."
      },
      "date": 1711124797597
    },
    {
      "id": "1f733ef5ef47e3ac",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "1f733ef5ef47e3ac",
        "text": "aber zum Glück gibt es für webcomponents ganz gute Abstraktionen die das ganze deutlich zugänglicher machen und da fällt mir persönlich z.B das Framework [[Lit]] ein das wir auch schon einmal in einem unserer Livestreams in Aktion erlebt haben und falls du den damals nicht gesehen hast dann findest du den Link dorthin noch einmal hier oben in der infocard da magst Du natürlich nun auch einwenden dass das doch irgendwie nicht der Sinn der Sache sei weil man damit ja doch wieder auf ein Framework setzen würde und das ist auch erstmal durchaus richtig aber anders als bei react angular und Co schreibt man mit Lid eben keine Komponenten die dann wieder nur mit dem jeweiligen Framework funktionieren sondern man schafft eine algemeingültige Komponente die mit allen Frameworks oder eben auch ganz ohne Framework Lauf ist weil sie nativ im Browser läuft und das finde ich persönlich schon mal deutlich besser"
      },
      "after": "5459837d9468165c",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711124804881
    },
    {
      "type": "edit",
      "id": "1f733ef5ef47e3ac",
      "item": {
        "type": "paragraph",
        "id": "1f733ef5ef47e3ac",
        "text": "But fortunately, there are quite good abstractions for Web Components that make the whole thing much more accessible, and I personally think of the [[Lit]] framework, for example, which we've already seen in action in one of our livestreams, and if you didn't see it back then, you can find the link to it here in the info card above. Of course, you can argue that this is somehow not the purpose of the thing, because then you would be dependent on a framework again and that is true for now, but unlike React, Angular and Co. you don't write components with Lit that only work with the respective framework, but you create a universally valid component that can run with all frameworks or even without a framework, because it runs natively in the browser and I personally find that much better."
      },
      "date": 1711125090518
    },
    {
      "id": "b6c1d281ef1be985",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "b6c1d281ef1be985",
        "text": "nun hatte ich ja anfangs erwähnt dass mich der bildschritt stört und wenn wir nun auf LD als Framework setzen dann haben wir natürlich wieder einen bildschritt das ist das zumindest was ich bis vor kurzem gedacht habe aber dem ist gar nicht so LD kann nämlich komplett zur Laufzeit ausgeführt werden das heißt ich muss keinen Compiler benutzen und das macht das Ganze direkt viel angenehmer noch angenehmer wird es übrigens wenn man feststellt dass man LD dazu noch nicht mal über NPM installieren muss sondern das einfach per Import aus einem CDN laden kann und wenn du da nun wiederum sagst das sei doch blöd weil man dann wieder überall von Versionsnummern in der Import URL Abhänge dann stimmt das außer du verwendest eine sogenannte [[Import Map]] [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap mdn] was übrigens ein weiteres Feature von modernen Browsern ist was einfach so da ist"
      },
      "after": "1f733ef5ef47e3ac",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711125130268
    },
    {
      "type": "edit",
      "id": "b6c1d281ef1be985",
      "item": {
        "type": "paragraph",
        "id": "b6c1d281ef1be985",
        "text": "Now I mentioned at the beginning that the build step bothers me and if we now rely on Lit as a framework, then of course we have a build step again, at least that's what I thought until recently, but that's not the case. Lit can be executed completely at runtime, which means that I don't have to use a compiler and that makes the whole thing even more pleasant when you realize that you don't even have to install Lit via NPM, but can simply load it via import from a CDN and if you say that this is stupid because then you have to rely on version numbers in the import URL everywhere, then that's true, unless you use a so-called [[import map]] [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap mdn], which by the way is another feature of modern browsers that is simply there."
      },
      "date": 1711125235539
    },
    {
      "type": "edit",
      "id": "b6c1d281ef1be985",
      "item": {
        "type": "paragraph",
        "id": "b6c1d281ef1be985",
        "text": "Now I mentioned at the beginning that the build step bothers me and if we now rely on Lit as a framework, then of course we have a build step again, at least that's what I thought until recently, but that's not the case. Lit can be executed completely at runtime, which means that I don't have to use a compiler and that makes the whole thing even more pleasant when you realize that you don't even have to install Lit via NPM, but can simply load it via import from a CDN and if you say that this is stupid because then you have to rely on version numbers in the import URL everywhere, then that's true, unless you use a so-called [[Import Map]] [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap mdn], which by the way is another feature of modern browsers that is simply there."
      },
      "date": 1711125251557
    },
    {
      "id": "f8ae32a5bb00243a",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "f8ae32a5bb00243a",
        "text": "mit so einer Import Map kannst du nämlich ein einziges Mal zentral festlegen dass es z.B einen Import namens lit geben soll und auf welche URL der dann aufgelöst werden soll und danach arbeitest du einfach in jedem deiner Skripte mit LD als wäre es lokal über NPM installiert und die Version kontrollierst du zentral über die Import Map Problem gelöst komplett ohne NPM und vor allem ohne bildschritt"
      },
      "after": "b6c1d281ef1be985",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711125356937
    },
    {
      "type": "edit",
      "id": "f8ae32a5bb00243a",
      "item": {
        "type": "paragraph",
        "id": "f8ae32a5bb00243a",
        "text": "With such an import map, you can define centrally that there should be an import called lit, for example, and to which URL it should be resolved, and then you simply work with Lit in each of your scripts as if it were installed locally via NPM and you control the version centrally via the import map. Problem solved, completely without NPM and above all without a build step."
      },
      "date": 1711125434105
    },
    {
      "id": "3504fee699197195",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "3504fee699197195",
        "text": "und das ganze funktioniert dank der Möglichkeit seit ein paar Jahren Javascript Code dynamisch zur Laufzeit als cmascriptmodul einfach so Nachladen zu können und da kann man natürlich auch wieder sagen das ist doch aber völlig unpraktikabel denn dann besteht meine Anwendung ja nachher aus zahlreichen ganz vielen kleinen einzelnen Dateien und das produziert ganz viel HTTP Overhead beim Laden und auch da stimme ich Dir grundsätzlich zu aber die Frage ist doch wie schlimm ist das denn wirklich also kommt es bei der Webseite od der Webanwendung die du baust wirklich auf jede nano oder Millisekunde an oder ist das eigentlich eher egal"
      },
      "after": "f8ae32a5bb00243a",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711125438421
    },
    {
      "type": "edit",
      "id": "3504fee699197195",
      "item": {
        "type": "paragraph",
        "id": "3504fee699197195",
        "text": "And the whole thing has been working for a few years now thanks to the ability to dynamically load Javascript code at runtime as an ECMAScript module and of course you can also say that this is completely impractical because then my application consists of many small individual files and that creates a lot of HTTP overhead when loading and I agree with you in principle, but the question is, how bad is that really, so does every nanosecond or millisecond really matter for the website or web application you are building, or does it really not matter?"
      },
      "date": 1711125541924
    },
    {
      "id": "13ac183afc4af3d9",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "13ac183afc4af3d9",
        "text": "und da wird es sicherlich Fälle geben in denen das z.B wegen SEO ultra wichtig ist das mit wenigen requests alles möglichst schnell geladen wird es wird aber auch Fälle geben in denen das völlig egal ist weil die Anwendung z.B gar nicht public facing sind sondern ohnehin nur in einer privaten Gruppe privaten Anwenderinnen und Anwendern zur Verfügung gestellt werden wo das Ganze gar nicht so entscheidend ist z.B im Intranet zumindest könnte man über diese Unterscheidung ja mal nachdenken"
      },
      "after": "3504fee699197195",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711125570251
    },
    {
      "type": "edit",
      "id": "13ac183afc4af3d9",
      "item": {
        "type": "paragraph",
        "id": "13ac183afc4af3d9",
        "text": "There will certainly be cases in which this is ultra important, e.g. because of SEO, that everything is loaded as quickly as possible with a few requests, but there will also be cases in which this is completely irrelevant because the application is not public facing at all, for example, but is only made available to private users in a private group anyway, where the whole thing is not so decisive, e.g. on the intranet, at least one could think about this distinction."
      },
      "date": 1711125614459
    },
    {
      "id": "88cc6898ec799b55",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "88cc6898ec799b55",
        "text": "das heißt bis hierhin können wir also Komponenten definieren Komponenten orchestrieren wir können das ganze mit einer komfortablen API machen wir haben gescop des CSS wir haben eine zentrale Verwaltung von den imports und das ganze ohne einen einzigen compile oder bildschritt"
      },
      "after": "13ac183afc4af3d9",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711125619911
    },
    {
      "type": "edit",
      "id": "88cc6898ec799b55",
      "item": {
        "type": "paragraph",
        "id": "88cc6898ec799b55",
        "text": "This means that we can define components up to this point, we can orchestrate components, we can do the whole thing with a convenient API, we have scopes of CSS, we have centralized management of imports and all without a single compile or build step."
      },
      "date": 1711125657408
    },
    {
      "id": "facffd63e90775e9",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "facffd63e90775e9",
        "text": "was ist aber wenn du das CSS nicht inline in einer webcomponent definieren möchtest denn nicht alle Entwicklerin Entwickler mögen den Ansatz HTML CSS und Javascript alles in einer Datei zu haben manche Lagern das CSS ja auch ganz gerne aus und das ist ja gerade einer der Vorteile von CSS modules dass das nämlich einfach so funktioniert und das ganze funktioniert mit CSS Module Scripts auch nativ ganz ohne CSS modules"
      },
      "after": "88cc6898ec799b55",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711125686296
    },
    {
      "type": "edit",
      "id": "facffd63e90775e9",
      "item": {
        "type": "paragraph",
        "id": "facffd63e90775e9",
        "text": "But what if you don't want to define the CSS inline in a web component, because not all developers like the approach of having HTML CSS and Javascript in one file, some want to outsource the CSS and that's one of the advantages of CSS modules, that it just works that way and the whole thing works natively with CSS Module Scripts without CSS modules."
      },
      "date": 1711125757706
    },
    {
      "id": "94f370d9b7876fda",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "94f370d9b7876fda",
        "text": "vermutlich hast du von [[CSS Module Scripts]] noch nie gehört aber das macht nichts denn davon erfährst Du ja jetzt heute durch mich und das ganze basiert auf dem Konzept der sogenannten constructtiable Style Sheets was mit einer sehr hohen Wahrscheinlichkeit noch so ein Begriff ist von dem du noch nie gehört hast aber diese beiden Techniken gemeinsam ermöglichen eben genau das was Du gerne haben möchtest nämlich gescopedes CSS mit einem Shadow Dom aber das Ganze eben in einer gesonderten CSS Datei die man in den Javascript Code hineinladen kann und apropos CSS wenn du jetzt sagst na ja schön und gut aber du hättest dann doch eigentlich ganz gerne sass oder L oder irgendwas ähnliches dann kann man auch hier mal die Frage stellen wofür denn eigentlich und die gängige Standardantwort auf diese Frage lautet dass es dabei hauptsächlich um die Möglichkeit geht die CSS Definitionen ineinander verschachtelt schreiben zu können"
      },
      "after": "facffd63e90775e9",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711125764743
    },
    {
      "type": "edit",
      "id": "94f370d9b7876fda",
      "item": {
        "type": "paragraph",
        "id": "94f370d9b7876fda",
        "text": "You've probably never heard of [[CSS Module Scripts]], but that doesn't matter, because you're learning about it through me today, and the whole thing is based on the concept of what's called The whole thing is based on the concept of what's called constructible stylesheets, which is most likely another term you've never heard of, but these two techniques together allow you to do exactly what you'd like, namely scoped CSS with a shadow domain, but the whole thing in a separate CSS file that you can load into the Javascript code and speaking of CSS, if you now say, all well and good, but you would actually like to have sass or L or something like that, then you can also ask the question here why and the common standard answer to this question is that it is mainly about the possibility of writing the CSS definitions nested inside each other."
      },
      "date": 1711125799995
    },
    {
      "type": "edit",
      "id": "94f370d9b7876fda",
      "item": {
        "type": "paragraph",
        "id": "94f370d9b7876fda",
        "text": "You've probably never heard of [[CSS Module Scripts]], but that doesn't matter, because you're learning about it through me today, and the whole thing is based on the concept of what's called constructible stylesheets, which is most likely another term you've never heard of, but these two techniques together allow you to do exactly what you'd like, namely scoped CSS with a shadow domain, but the whole thing in a separate CSS file that you can load into the Javascript code and speaking of CSS, if you now say, all well and good, but you would actually like to have sass or L or something like that, then you can also ask the question here why and the common standard answer to this question is that it is mainly about the possibility of writing the CSS definitions nested inside each other."
      },
      "date": 1711125836021
    },
    {
      "type": "edit",
      "id": "94f370d9b7876fda",
      "item": {
        "type": "paragraph",
        "id": "94f370d9b7876fda",
        "text": "You've probably never heard of [[CSS Module Scripts]], but that doesn't matter, because you're learning about it through me today, and the whole thing is based on the concept of what's called constructible stylesheets, which is most likely another term you've never heard of, but these two techniques together allow you to do exactly what you'd like, namely scoped CSS with a Shadow DOM, but the whole thing in a separate CSS file that you can load into the JavaScript code. And speaking of CSS, if you now say, all well and good, but you would actually like to have sass or less or something like that, then you can also ask the question here why? And the common standard answer to this question is that it is mainly about the possibility of writing the CSS definitions nested inside each other."
      },
      "date": 1711125911975
    },
    {
      "id": "c9d481a06561f819",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "c9d481a06561f819",
        "text": "und weißt du was das geht in CSS seit kurz von Haus aus das heißt CSS unterstützt inzwischen natives nesting und abgesehen davon auch noch ein paar andere sehr schöne Sachen die bislang SAS und Co vorbehalten waren und damit kann man sich diese präprozessoren dann eigentlich auch sparen ähnliches gilt übrigens auch für das Thema Theming denn auch das lässt sich ganz gut nativ erledigen nämlich mit Hilfe von CSS Variablen und natürlich funktioniert nicht einfach alles automagisch Äquivalent wie man das aus react angular und Co kennt vor allem geben diese Frameworks ja auch eine gewisse Struktur für die Anwendung vor wobei das zugegebenermaßen auch von Framework zu Framework sehr stark schwankt aber es lässt sich inzwischen doch erstaunlich viel mit den nativen Boardmitteln des Browsers nachbilden und man spart sich bei der ganzen Geschichte eben wie gesagt alles was in Richtung Compiler bundler und Co geht und das läuft bislang so ein bisschen unter dem Schlagwort bildless aber das fokussiert für meinen Geschmack zu sehr nur auf den Aspekt dass man nicht mehr kompilieren muss ich persönlich finde es daher deutlich besser von [[Vanilla Web]] zu sprechen analog zu Vanilla JavaScript und das bedeutet so viel wie nativ ohne zusätzliche Bibliotheken und Frameworks einfach mit dem auskommend was von Haus aus geboten wird halt ohne großartige Extras und warum heißt das Vanilla soweit ich weiß deshalb weil Vanille angeblich die unspektakulärste Eissorte ist eben ohne großartige Extras die aber von allen auch trotzdem irgendwie mehr oder weniger gemocht wird"
      },
      "after": "94f370d9b7876fda",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711125920468
    },
    {
      "type": "edit",
      "id": "c9d481a06561f819",
      "item": {
        "type": "paragraph",
        "id": "c9d481a06561f819",
        "text": "And you know what CSS has been doing this natively for a short time now, i.e. CSS now supports native nesting and apart from that also a few other very nice things that were previously reserved for SAS and Co and so you can actually save these preprocessors, by the way, the same applies to the topic of theming because that can also be done quite well natively namely with the help of CSS variables and of course not everything works automatically equivalent as you know it from react angular and Co. above all, these frameworks also provide a certain structure for the application, although this admittedly varies greatly from framework to framework, but it can now be surprisingly much with the native board means of the browser and, as I said, the whole thing saves you everything that goes in the direction of compiler bundlers and the like and so far this has been going a bit under the keyword bildless but for my taste this focuses too much only on the aspect that you no longer have to compile I personally think it is therefore much better to speak of [[Vanilla Web]] analogous to Vanilla JavaScript and that means as much as natively without additional libraries and frameworks simply getting by with what is offered by default without great extras and why is it called Vanilla as far as I know because vanilla is supposedly the most unspectacular ice cream flavor without great extras but which is still somehow more or less liked by everyone."
      },
      "date": 1711125948231
    },
    {
      "type": "edit",
      "id": "c9d481a06561f819",
      "item": {
        "type": "paragraph",
        "id": "c9d481a06561f819",
        "text": "And you know what CSS has been doing this natively for a short time now, i.e. CSS now supports native nesting and apart from that also a few other very nice things that were previously reserved for SASS and Co and so you can actually save these preprocessors, by the way, the same applies to the topic of theming because that can also be done quite well natively namely with the help of CSS variables and of course not everything works automatically equivalent as you know it from react angular and Co. above all, these frameworks also provide a certain structure for the application, although this admittedly varies greatly from framework to framework, but it can now be surprisingly much with the native board means of the browser and, as I said, the whole thing saves you everything that goes in the direction of compiler bundlers and the like and so far this has been going a bit under the keyword bildless but for my taste this focuses too much only on the aspect that you no longer have to compile I personally think it is therefore much better to speak of [[Vanilla Web]] analogous to Vanilla JavaScript and that means as much as natively without additional libraries and frameworks simply getting by with what is offered by default without great extras and why is it called Vanilla as far as I know because vanilla is supposedly the most unspectacular ice cream flavor without great extras but which is still somehow more or less liked by everyone."
      },
      "date": 1711125991094
    },
    {
      "type": "edit",
      "id": "c9d481a06561f819",
      "item": {
        "type": "paragraph",
        "id": "c9d481a06561f819",
        "text": "And you know what CSS has been doing this natively for a short time now, i.e. CSS now supports native nesting and apart from that also a few other very nice things that were previously reserved for SASS and Co and so you can actually save these preprocessors, by the way, the same applies to the topic of theming because that can also be done quite well natively namely with the help of CSS variables and of course not everything works automatically equivalent as you know it from React, Angular and Co. above all, these frameworks also provide a certain structure for the application, although this admittedly varies greatly from framework to framework, but it can now be surprisingly much easier with the native board means of the browser and, as I said, the whole thing saves you everything that goes in the direction of compiler, bundlers and the like and so far this has been going a bit under the keyword buildless but for my taste this focuses too much only on the aspect that you no longer have to compile; I personally think it is therefore much better to speak of [[Vanilla Web]] analogous to Vanilla JavaScript. And that means as much as natively without additional libraries and frameworks simply getting by with what is offered by default without great extras and why is it called Vanilla as far as I know because vanilla is supposedly the most unspectacular ice cream flavor without great extras but which is still somehow more or less liked by everyone."
      },
      "date": 1711126163426
    },
    {
      "id": "6d342443d18e4d9e",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "6d342443d18e4d9e",
        "text": "ja und unterm Strich erzähle ich dir damit vielleicht gar nicht so sehr allzu viel Neues denn vieles von dem was ich bis jetzt angesprochen habe das gibt tatsächlich schon seit etlichen Jahren aber und das ist der springende Punkt all diese Technologien sind vorhanden sie existieren aber zumindest bislang habe ich zumindest nicht das Gefühl dass die einzelnen Puzzleteile im größeren Stil mal zusammengefügt werden und dass viele EntwicklerInnen Entwickler einfach noch aus Gewohnheit bei dem Framework bleiben was sie aus der Vergangenheit kennen aber da habe ich eben wie gesagt langsam das das Gefühl dass ich das in diesem Jahr ändern könnte und ja natürlich das wäre mal wieder eine Umstellung auf wieder einen anderen Ansatz aber das schöne wäre an der Sache es könnte die letzte Umstellung dieser Art sein weil sich das ganze wie gesagt als etwas verlässlicher und nachhaltiger erweisen könnte als die typischen Web UI Frameworks denen wir in den vergangenen Jahren begegnet sind"
      },
      "after": "c9d481a06561f819",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711126173463
    },
    {
      "type": "edit",
      "id": "6d342443d18e4d9e",
      "item": {
        "type": "paragraph",
        "id": "6d342443d18e4d9e",
        "text": "The bottom line is that I'm perhaps not telling you too much that's new because a lot of what I've talked about so far has actually been around for a number of years but and that's the crux of the matter all these technologies are there they exist but at least so far I don't have the feeling that the individual pieces of the puzzle are being put together on a larger scale and that many developers are simply sticking with the framework they know from the past out of habit. framework they know from the past, but as I said, I'm starting to get the feeling that I could change that this year and yes, of course, that would be another switch to another approach, but the nice thing about it would be that it could be the last switch of this kind because, as I said, the whole thing could prove to be somewhat more reliable and sustainable than the typical web UI frameworks we have encountered in recent years."
      },
      "date": 1711126213177
    },
    {
      "type": "edit",
      "id": "6d342443d18e4d9e",
      "item": {
        "type": "paragraph",
        "id": "6d342443d18e4d9e",
        "text": "The bottom line is that I'm perhaps not telling you too much that's new because a lot of what I've talked about so far has actually been around for a number of years but and that's the crux of the matter all these technologies are there they exist but at least so far I don't have the feeling that the individual pieces of the puzzle are being put together on a larger scale and that many developers are simply sticking with the framework they know from the past out of habit. But as I said, I'm starting to get the feeling that this could change this year and yes, of course, that would be another switch to another approach, but the nice thing about it would be that it could be the last switch of this kind because, as I said, the whole thing could prove to be somewhat more reliable and sustainable than the typical web UI frameworks we have encountered in recent years."
      },
      "date": 1711126288128
    },
    {
      "id": "3a7d65cb666b09d7",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "3a7d65cb666b09d7",
        "text": "und übrigens was alldem leider einen ziemlichen Strich durch die Rechnung macht ist typescript denn da gibt es zwar den etwas merkwürdigen Vorschlag von Microsoft die typannotationen von typescript in Javascript einfach als Kommentare anzusehen falls Du dazu mehr wissen willst sie ihr infocard aber bislang braucht man auf jeden Fall noch einen Compiler das muss dann nicht unbedingt der originale typescript Compiler sein sowas wie esbild z.B das erledigt den Job im Zweifelsfall auch aber irgendeinen bildschritt braucht man halt doch noch es sei denn man verzichtet auf die typescript eigene Syntax für typdefinitionen und weicht hier z.B auf JS Doc und zur Not halt auf das manuelle Schreiben von tsd Dateien aus dann könnte man sogar auf den typescript Compiler verzichten hätte aber trotzdem eine vernünftige Typsicherheit und entsprechende Unterstützung in der IDE"
      },
      "after": "6d342443d18e4d9e",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711126292536
    },
    {
      "type": "edit",
      "id": "3a7d65cb666b09d7",
      "item": {
        "type": "paragraph",
        "id": "3a7d65cb666b09d7",
        "text": "By the way, what unfortunately throws a spanner in the works is typescript because there is the somewhat strange proposal from Microsoft to simply view the type annotations of typescript in Javascript as comments if you want to know more about this, see their infocard but so far you still need a compiler in any case that doesn't necessarily have to be the original typescript compiler something like esbild for example. B that does the job in case of doubt, but you still need some image step unless you do without the typescript own syntax for type definitions and switch here e.g. to JS Doc and if necessary just to the manual writing of tsd files then you could even do without the typescript compiler but would still have a reasonable type safety and appropriate support in the IDE."
      },
      "date": 1711126339587
    },
    {
      "id": "9122d68c246bedc4",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "9122d68c246bedc4",
        "text": "und ein großer Verfechter dieses Ansatzes ist übrigens das Team hinter swelt denn für SW 4 wurde genau dieser Ansatz mit JS dog angekündigt aber das bleibt spannend da mal zu gucken worauf das Ganze am Ende tatsächlich hinauslaufen wird"
      },
      "after": "3a7d65cb666b09d7",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711126344993
    },
    {
      "type": "edit",
      "id": "9122d68c246bedc4",
      "item": {
        "type": "paragraph",
        "id": "9122d68c246bedc4",
        "text": "A big proponent of this approach is the team behind Svelt because  for a new version exactly this approach with JSDoc was announced  but it remains exciting to see what the whole thing will actually end up with."
      },
      "date": 1711126528845
    },
    {
      "id": "c6c295fc09866cb9",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "c6c295fc09866cb9",
        "text": "und für dich heißt das unterm Strich vor allem eins das von dir bevorzugte JavaScript Framework einschließlich dem ganzen tooling drumherum mag nicht mehr so absolut unersetzlich sein wie du das vielleicht in den vergangenen Jahren angenommen hast ich kann dir nur raten guck dir all die genannten Technologien und Konzepte mal an EXP experimentiere damit mal ein bisschen herum und hinterfrage vor allem ob das Framework und das tooling deiner Wahl einen wirklichen Nutzen bringt oder ob das vielleicht für die eine oder andere Aufgabe eigentlich zu viel des Guten ist denn wie gesagt ich könnte mir gut vorstellen dass ich da im Laufe dieses Jahres ein bisschen was ändern wird und wenn du das nicht alleine machen willst sondern du deinen technologiestack gerne mal mit jemandem gemeinsam reviewen und hinterfragen möchtest dann melde dich bei uns [https://www.thenativeweb.io/ www.thenativeweb.io] und den Link und die Kontaktdaten die findest du auch unten noch mal in der Videobeschreibung und in dem Sinne pass gut auf Dich auf bleib gesund und dann bis zum nächsten Mal ciao"
      },
      "after": "9122d68c246bedc4",
      "attribution": {
        "page": "2024-03-22",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1711126541061
    },
    {
      "type": "edit",
      "id": "c6c295fc09866cb9",
      "item": {
        "type": "paragraph",
        "id": "c6c295fc09866cb9",
        "text": "The bottom line for you is that your preferred JavaScript framework with all its tools is no longer as absolutely irreplaceable as you may have assumed in recent years. I can only advise you to take a look at all the technologies and concepts mentioned and experiment with them a little and, above all, question whether the framework and tooling of your choice offers any real advantages, or whether it might even be too much of a good thing for one task or another; because as I said, I could well imagine that I will be changing a little over the course of this year, and if you don't want to do this alone, but would like to review and question your technology stack together with someone, then get in touch with us [https: //www. thenativeweb.io/ www.thenativeweb.io] and you'll find the link and contact details at the bottom of the video description. Take care, stay well and see you next time. Bye."
      },
      "date": 1711126730940
    },
    {
      "type": "edit",
      "id": "c6c295fc09866cb9",
      "item": {
        "type": "paragraph",
        "id": "c6c295fc09866cb9",
        "text": "The bottom line for you is that your preferred JavaScript framework with all its tools is no longer as absolutely irreplaceable as you may have assumed in recent years. I can only advise you to take a look at all the technologies and concepts mentioned and experiment with them a little and, above all, question whether the framework and tooling of your choice offers any real advantages, or whether it might even be too much of a good thing for one task or another; because as I said, I could well imagine that I will be changing a little over the course of this year, and if you don't want to do this alone, but would like to review and question your technology stack together with someone, then get in touch with us [https://www.thenativeweb.io/ www.thenativeweb.io] and you'll find the link and contact details at the bottom of the video description. Take care, stay well and see you next time. Bye."
      },
      "date": 1711126742202
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1711126815447
    },
    {
      "type": "edit",
      "id": "7f50ba6ab9897efb",
      "item": {
        "type": "paragraph",
        "id": "7f50ba6ab9897efb",
        "text": "Imagine you are planning the development of a new web or cloud-based software and you have already decided on all the technologies to be used in the backend, but you are still not quite sure whether you should rely on one of the established top dogs, i.e. a framework such as React, Angular or perhaps Vue, or whether you should opt for one of the newer and smaller frameworks such as Svelt or Solid JS. And not only is this question not new, but above all there is no real answer because no matter which framework you ultimately decide on, you always tie yourself into a vendor lockin and at the same time you never have the guarantee that the respective framework will actually still exist in a few years, that it will still be further developed, that it will still be maintained and so on."
      },
      "date": 1711127245791
    },
    {
      "type": "edit",
      "id": "7f50ba6ab9897efb",
      "item": {
        "type": "paragraph",
        "id": "7f50ba6ab9897efb",
        "text": "Imagine you are planning the development of a new web or cloud-based software and you have already decided on all the technologies to be used in the backend, but you are still not quite sure whether you should rely on one of the established top dogs, i.e. a framework such as React, Angular or perhaps Vue, or whether you should opt for one of the newer and smaller frameworks such as Svelte or Solid JS. And not only is this question not new, but above all there is no real answer because no matter which framework you ultimately decide on, you always tie yourself into a vendor lockin and at the same time you never have the guarantee that the respective framework will actually still exist in a few years, that it will still be further developed, that it will still be maintained and so on."
      },
      "date": 1711127274155
    },
    {
      "type": "edit",
      "id": "7f50ba6ab9897efb",
      "item": {
        "type": "paragraph",
        "id": "7f50ba6ab9897efb",
        "text": "Imagine you are planning the development of a new web or cloud-based software and you have already decided on all the technologies to be used in the backend, but you are still not quite sure whether you should rely on one of the established top dogs, i.e. a framework such as React, Angular or perhaps Vue, or whether you should opt for one of the newer and smaller frameworks such as Svelte or SolidJS. And not only is this question not new, but above all there is no real answer because no matter which framework you ultimately decide on, you always tie yourself into a vendor lockin and at the same time you never have the guarantee that the respective framework will actually still exist in a few years, that it will still be further developed, that it will still be maintained and so on."
      },
      "date": 1711127316841
    },
    {
      "type": "edit",
      "id": "7f50ba6ab9897efb",
      "item": {
        "type": "paragraph",
        "id": "7f50ba6ab9897efb",
        "text": "Imagine you are planning the development of a new web or cloud-based software and you have already decided on all the technologies to be used in the backend, but regarding the frontend you are still not quite sure whether you should rely on one of the established top dogs, i.e. a framework such as React, Angular or perhaps Vue, or whether you should opt for one of the newer and smaller frameworks such as Svelte or SolidJS. And not only is this question not new, but above all there is no real answer because no matter which framework you ultimately decide on, you always tie yourself into a vendor lockin and at the same time you never have the guarantee that the respective framework will actually still exist in a few years, that it will still be further developed, that it will still be maintained and so on."
      },
      "date": 1711127482745
    },
    {
      "type": "edit",
      "id": "7c2ec33f52ce20ba",
      "item": {
        "type": "paragraph",
        "id": "7c2ec33f52ce20ba",
        "text": "Now you might argue that HTML is only half the battle. Components should usually also have their own style and then you probably also want to make sure that the styles of different components don't get in each other's way, i.e. that each component has its own and cleanly separated area for CSS and for this the concept of CSS modules has now been established in various frameworks, but this in turn requires a corresponding bundler or a precompiler, which supports the concept of CSS modules in the first place and then translates them accordingly and the point here is that this would not even be necessary because the browser can manage its own scopes for CSS by default, so that you can simply assign a self-contained area for CSS to each user-defined element, the whole thing is then called [[Shadow DOM]] and because user-defined elements and the Shadow DOM harmonize so nicely with each other, these two technologies are the basis for what is usually called [[Web Components]], and strictly speaking there is also the HTML element template, but basically web components enable exactly what you want to use an additional framework for, namely the definition of reusable components including a separate scopes for CSS."
      },
      "date": 1711127863073
    },
    {
      "type": "edit",
      "id": "3504fee699197195",
      "item": {
        "type": "paragraph",
        "id": "3504fee699197195",
        "text": "And the whole thing works as it has been possible for a few years now thanks to the ability to dynamically load Javascript code at runtime as an ECMAScript module and of course you can also say that this is completely impractical because then my application consists of many small individual files and that creates a lot of HTTP overhead when loading and I agree with you in principle, but the question is, how bad is that really, so does every nanosecond or millisecond really matter for the website or web application you are building, or does it really not matter?"
      },
      "date": 1711128123951
    },
    {
      "type": "edit",
      "id": "3504fee699197195",
      "item": {
        "type": "paragraph",
        "id": "3504fee699197195",
        "text": "And the whole thing works because it has been possible for a few years now, thanks to the ability to load JavaScript code dynamically at runtime as an ECMAScript module. And of course you can also say that this is completely impractical, because then my application consists of lots of small individual files and this creates a lot of HTTP overhead when loading and I agree with you in principle, but the question is how bad is this really, so does every nanosecond or millisecond really matter for the website or web application that you are building, or does it really not matter?"
      },
      "date": 1711128198761
    },
    {
      "type": "edit",
      "id": "c9d481a06561f819",
      "item": {
        "type": "paragraph",
        "id": "c9d481a06561f819",
        "text": "And you know what CSS has been doing this natively for a short time now, i.e. CSS now supports native nesting and apart from that also a few other very nice things that were previously reserved for SASS and Co and so you can actually save these preprocessors, by the way, the same applies to the topic of theming because that can also be done quite well natively namely with the help of CSS variables. And of course not everything works automatically equivalent as you know it from React, Angular and Co. above all, these frameworks also provide a certain structure for the application, although this admittedly varies greatly from framework to framework, but it can now be surprisingly much easier with the native board means of the browser and, as I said, the whole thing saves you everything that goes in the direction of compiler, bundlers and the like and so far this has been going a bit under the keyword buildless but for my taste this focuses too much only on the aspect that you no longer have to compile; I personally think it is therefore much better to speak of [[Vanilla Web]] analogous to Vanilla JavaScript. And that means as much as natively without additional libraries and frameworks simply getting by with what is offered by default without great extras and why is it called Vanilla as far as I know because vanilla is supposedly the most unspectacular ice cream flavor without great extras but which is still somehow more or less liked by everyone."
      },
      "date": 1711128423470
    },
    {
      "type": "edit",
      "id": "3a7d65cb666b09d7",
      "item": {
        "type": "paragraph",
        "id": "3a7d65cb666b09d7",
        "text": "By the way, what unfortunately throws a spanner in the works is typescript because there is the somewhat strange proposal from Microsoft to simply view the type annotations of typescript in Javascript as comments if you want to know more about this, see their infocard but so far you still need a compiler in any case that doesn't necessarily have to be the original typescript compiler something like esbild for example, that does the job in case of doubt, but you still need some image step unless you do without the typescript own syntax for type definitions and switch here e.g. to JS Doc and if necessary just to the manual writing of tsd files then you could even do without the typescript compiler but would still have a reasonable type safety and appropriate support in the IDE."
      },
      "date": 1711128610942
    },
    {
      "type": "edit",
      "id": "3a7d65cb666b09d7",
      "item": {
        "type": "paragraph",
        "id": "3a7d65cb666b09d7",
        "text": "By the way, what unfortunately throws a spanner in the works is typescript because there is the somewhat strange proposal from Microsoft to simply view the type annotations of typescript in Javascript as comments if you want to know more about this, see their infocard but so far you still need a compiler in any case that doesn't necessarily have to be the original typescript compiler something like esbild for example, that does the job in case of doubt, but you still need some build step unless you do without the typescript own syntax for type definitions and switch here e.g. to JS Doc and if necessary just to the manual writing of tsd files then you could even do without the typescript compiler but would still have a reasonable type safety and appropriate support in the IDE."
      },
      "date": 1711128628363
    },
    {
      "type": "edit",
      "id": "9122d68c246bedc4",
      "item": {
        "type": "paragraph",
        "id": "9122d68c246bedc4",
        "text": "A big proponent of this approach is the team behind Svelt because  for Svelt 4 exactly this approach with JSDoc was announced  but it remains exciting to see what the whole thing will actually end up with."
      },
      "date": 1711128654135
    }
  ]
}