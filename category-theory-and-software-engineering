{
  "title": "Category Theory and Software Engineering",
  "story": [
    {
      "type": "markdown",
      "id": "19efe2a21e491919",
      "text": "As explained in [[My Journey towards category theory]] I see category theory as the organizing principle behind functional programming (FP). Most of the points here will be about FP.\n\n"
    },
    {
      "type": "markdown",
      "id": "cd7c0510370ca03d",
      "text": "FP is manifested in traditional programming languages such as Lisp and Haskell. It has a prominent influence on mainstream programming. For example, Apple introduced the Swift programming language. Kotlin has several functional features and has a growing adoption in the Java community.\n "
    },
    {
      "type": "html",
      "id": "92cb7c3bcaf92ede",
      "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by Eric Meijer, which shares features with [[Functional Reactive Programming]]. \n"
    },
    {
      "type": "markdown",
      "id": "4233066d15a83b7e",
      "text": "Learning functional programming, especially Haskell, seems daunting for programmers who are experienced in traditional [[Programming Paradigms]]. Many constructs look like overly arcane and terse operations, like APL. For example [[Functors from the Perspective of an Imperative Programmer]] look like complicated containers and monads are just monoids in the category of endofunctors (see [[Monad Tutorials]]). [[Point Free Style]] leads to overly terse code. Static typing imposes structure on code which may be perceived as overly rigid (see [[Static vs Dynamic Typing]]).\n\n"
    },
    {
      "type": "markdown",
      "id": "0c7b119e080687f7",
      "text": "[[Joseph Goguen]] argued for category theory in software engineering."
    },
    {
      "type": "markdown",
      "id": "b33f3287c090551a",
      "text": "The terms covariance and contravariance in object-oriented subtyping [https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Etymology come from category theory]. "
    },
    {
      "type": "markdown",
      "id": "7155e478de0e873e",
      "text": "[[Compositionality]] is an important concept in [https://idsc.ethz.ch/education/lectures/applied-compositional-thinking.html engineering] and specifically software engineering."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Category Theory and Software Engineering",
        "story": []
      },
      "date": 1676445586833
    },
    {
      "item": {
        "type": "factory",
        "id": "19efe2a21e491919"
      },
      "id": "19efe2a21e491919",
      "type": "add",
      "date": 1676447738897
    },
    {
      "type": "edit",
      "id": "19efe2a21e491919",
      "item": {
        "type": "markdown",
        "id": "19efe2a21e491919",
        "text": "As explained in [[My Journey towards category theory]] I see category theory as the organizing principle behind functional programming (FP). Most of the points here will be about FP.\n\n"
      },
      "date": 1676447838455
    },
    {
      "item": {
        "type": "factory",
        "id": "cd7c0510370ca03d"
      },
      "id": "cd7c0510370ca03d",
      "type": "add",
      "after": "19efe2a21e491919",
      "date": 1676447890873
    },
    {
      "type": "edit",
      "id": "cd7c0510370ca03d",
      "item": {
        "type": "markdown",
        "id": "cd7c0510370ca03d",
        "text": "FP is manifested in traditional programming languages such as Lisp and Haskell. It has a prominent influence on mainstream programming. Apple introduced the swift "
      },
      "date": 1676447960514
    },
    {
      "type": "edit",
      "id": "cd7c0510370ca03d",
      "item": {
        "type": "markdown",
        "id": "cd7c0510370ca03d",
        "text": "FP is manifested in traditional programming languages such as Lisp and Haskell. It has a prominent influence on mainstream programming. For example, Apple introduced the Swift programming language. Kotlin has several functional features and has a growing adoption in the Java community.\n "
      },
      "date": 1676448070102
    },
    {
      "item": {
        "type": "factory",
        "id": "d7287734e313a249"
      },
      "id": "d7287734e313a249",
      "type": "add",
      "after": "cd7c0510370ca03d",
      "date": 1676448132769
    },
    {
      "type": "remove",
      "id": "d7287734e313a249",
      "date": 1676448146100
    },
    {
      "item": {
        "type": "factory",
        "id": "92cb7c3bcaf92ede"
      },
      "id": "92cb7c3bcaf92ede",
      "type": "add",
      "after": "cd7c0510370ca03d",
      "date": 1676448207417
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These "
      },
      "date": 1676448374485
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. "
      },
      "date": 1676448496587
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. "
      },
      "date": 1676448629922
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by "
      },
      "date": 1676448719869
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by Eric Meijer. \n"
      },
      "date": 1676448789586
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by Eric Meijer, which shares features with [[Functional Reactive Programming]]. \n"
      },
      "date": 1676448945804
    },
    {
      "item": {
        "type": "factory",
        "id": "b33f3287c090551a"
      },
      "id": "b33f3287c090551a",
      "type": "add",
      "after": "92cb7c3bcaf92ede",
      "date": 1676448992906
    },
    {
      "type": "edit",
      "id": "b33f3287c090551a",
      "item": {
        "type": "markdown",
        "id": "b33f3287c090551a",
        "text": "Covariance "
      },
      "date": 1676449001185
    },
    {
      "type": "edit",
      "id": "b33f3287c090551a",
      "item": {
        "type": "markdown",
        "id": "b33f3287c090551a",
        "text": "Covariance and contravariance "
      },
      "date": 1676449087678
    },
    {
      "type": "edit",
      "id": "b33f3287c090551a",
      "item": {
        "type": "markdown",
        "id": "b33f3287c090551a",
        "text": "The terms covariance and contravariance in object-oriented subtyping [come from category theory]. "
      },
      "date": 1676449140216
    },
    {
      "type": "edit",
      "id": "b33f3287c090551a",
      "item": {
        "type": "markdown",
        "id": "b33f3287c090551a",
        "text": "The terms covariance and contravariance in object-oriented subtyping [https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Etymology come from category theory]. "
      },
      "date": 1676449160388
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "## Test\nMost of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by Eric Meijer, which shares features with [[Functional Reactive Programming]]. \n"
      },
      "date": 1676449181402
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "<h3> Test\nMost of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by Eric Meijer, which shares features with [[Functional Reactive Programming]]. \n"
      },
      "date": 1676449228534
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "<h3> Test\n\nMost of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by Eric Meijer, which shares features with [[Functional Reactive Programming]]. \n"
      },
      "date": 1676449232600
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by Eric Meijer, which shares features with [[Functional Reactive Programming]]. \n"
      },
      "date": 1676449239810
    },
    {
      "item": {
        "type": "factory",
        "id": "dcdea910d920813e"
      },
      "id": "dcdea910d920813e",
      "type": "add",
      "after": "b33f3287c090551a",
      "date": 1676449244908
    },
    {
      "type": "edit",
      "id": "dcdea910d920813e",
      "item": {
        "type": "html",
        "id": "dcdea910d920813e",
        "text": "<h3> Dies ist ein Test"
      },
      "date": 1676449254136
    },
    {
      "id": "dcdea910d920813e",
      "type": "move",
      "order": [
        "19efe2a21e491919",
        "cd7c0510370ca03d",
        "92cb7c3bcaf92ede",
        "dcdea910d920813e",
        "b33f3287c090551a"
      ],
      "date": 1676449257845
    },
    {
      "type": "edit",
      "id": "dcdea910d920813e",
      "item": {
        "type": "html",
        "id": "dcdea910d920813e",
        "text": "<h3> Random points on how Category Theory found its way into computer science"
      },
      "date": 1676449305051
    },
    {
      "item": {
        "type": "factory",
        "id": "e4b25c1367963dc0"
      },
      "id": "e4b25c1367963dc0",
      "type": "add",
      "after": "b33f3287c090551a",
      "date": 1676449370277
    },
    {
      "type": "remove",
      "id": "e4b25c1367963dc0",
      "date": 1676449392873
    },
    {
      "item": {
        "type": "factory",
        "id": "4233066d15a83b7e"
      },
      "id": "4233066d15a83b7e",
      "type": "add",
      "after": "b33f3287c090551a",
      "date": 1676526471627
    },
    {
      "type": "edit",
      "id": "4233066d15a83b7e",
      "item": {
        "type": "markdown",
        "id": "4233066d15a83b7e",
        "text": "Learning functional programming, especially Haskell, seems daunting for programmers who are experienced in traditional [[Programming Paradigms]]. Many constructs look like overly arcane and terse operations, like APL. For example [[Functors from the Perspective of an Imperative Programmer]] look like complicated containers. [[Point Free Style]] leads to overly terse code.\n"
      },
      "date": 1676526835591
    },
    {
      "id": "4233066d15a83b7e",
      "type": "move",
      "order": [
        "19efe2a21e491919",
        "cd7c0510370ca03d",
        "92cb7c3bcaf92ede",
        "4233066d15a83b7e",
        "dcdea910d920813e",
        "b33f3287c090551a"
      ],
      "date": 1676526840262
    },
    {
      "type": "edit",
      "id": "4233066d15a83b7e",
      "item": {
        "type": "markdown",
        "id": "4233066d15a83b7e",
        "text": "Learning functional programming, especially Haskell, seems daunting for programmers who are experienced in traditional [[Programming Paradigms]]. Many constructs look like overly arcane and terse operations, like APL. For example [[Functors from the Perspective of an Imperative Programmer]] look like complicated containers. [[Point Free Style]] leads to overly terse code. Static typing imposes structure on code which may be perceived as overly rigid (see [[Static vs Dynamic Typing]]).\n\n"
      },
      "date": 1676527622401
    },
    {
      "type": "edit",
      "id": "4233066d15a83b7e",
      "item": {
        "type": "markdown",
        "id": "4233066d15a83b7e",
        "text": "Learning functional programming, especially Haskell, seems daunting for programmers who are experienced in traditional [[Programming Paradigms]]. Many constructs look like overly arcane and terse operations, like APL. For example [[Functors from the Perspective of an Imperative Programmer]] look like complicated containers and monads are just monoids in the category of endofunctors (see [[Monad Tutorials]]). [[Point Free Style]] leads to overly terse code. Static typing imposes structure on code which may be perceived as overly rigid (see [[Static vs Dynamic Typing]]).\n\n"
      },
      "date": 1676532417313
    },
    {
      "item": {
        "type": "factory",
        "id": "0c7b119e080687f7"
      },
      "id": "0c7b119e080687f7",
      "type": "add",
      "after": "b33f3287c090551a",
      "date": 1676533499392
    },
    {
      "type": "edit",
      "id": "0c7b119e080687f7",
      "item": {
        "type": "markdown",
        "id": "0c7b119e080687f7",
        "text": "[[Joseph Goguen]] argued for category theory in software engineering."
      },
      "date": 1676533525068
    },
    {
      "id": "0c7b119e080687f7",
      "type": "move",
      "order": [
        "19efe2a21e491919",
        "cd7c0510370ca03d",
        "92cb7c3bcaf92ede",
        "4233066d15a83b7e",
        "0c7b119e080687f7",
        "dcdea910d920813e",
        "b33f3287c090551a"
      ],
      "date": 1676533528267
    },
    {
      "type": "remove",
      "id": "dcdea910d920813e",
      "date": 1676535856777
    },
    {
      "item": {
        "type": "factory",
        "id": "7155e478de0e873e"
      },
      "id": "7155e478de0e873e",
      "type": "add",
      "after": "b33f3287c090551a",
      "date": 1676536792928
    },
    {
      "type": "edit",
      "id": "7155e478de0e873e",
      "item": {
        "type": "markdown",
        "id": "7155e478de0e873e",
        "text": "[[Compositionality]] is an important concept in engineering and specifically software engineering."
      },
      "date": 1676536832016
    },
    {
      "type": "edit",
      "id": "7155e478de0e873e",
      "item": {
        "type": "markdown",
        "id": "7155e478de0e873e",
        "text": "[[Compositionality]] is an important concept in [https://idsc.ethz.ch/education/lectures/applied-compositional-thinking.html engineering] and specifically software engineering."
      },
      "date": 1676536915420
    },
    {
      "type": "fork",
      "site": "johannes.tries.fed.wiki",
      "date": 1676670310060
    }
  ]
}