{
  "title": "Category Theory and Software Engineering",
  "story": [
    {
      "type": "markdown",
      "id": "19efe2a21e491919",
      "text": "As explained in [[My Journey towards category theory]] [[Johannes Drever]] see category theory as the organizing principle behind functional programming (FP). Most of the points here will be about FP.\n\n"
    },
    {
      "type": "markdown",
      "id": "cd7c0510370ca03d",
      "text": "FP is manifested in traditional programming languages such as Lisp and Haskell. It has a prominent influence on mainstream programming. For example, Apple introduced the Swift programming language. Kotlin has several functional features and has a growing adoption in the Java community.\n "
    },
    {
      "type": "html",
      "id": "92cb7c3bcaf92ede",
      "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by Eric Meijer, which shares features with [[Functional Reactive Programming]]. \n"
    },
    {
      "type": "markdown",
      "id": "b33f3287c090551a",
      "text": "Covariance "
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Category Theory and Software Engineering",
        "story": []
      },
      "date": 1676445586833
    },
    {
      "item": {
        "type": "factory",
        "id": "19efe2a21e491919"
      },
      "id": "19efe2a21e491919",
      "type": "add",
      "date": 1676447738897
    },
    {
      "type": "edit",
      "id": "19efe2a21e491919",
      "item": {
        "type": "markdown",
        "id": "19efe2a21e491919",
        "text": "As explained in [[My Journey towards category theory]] I see category theory as the organizing principle behind functional programming (FP). Most of the points here will be about FP.\n\n"
      },
      "date": 1676447838455
    },
    {
      "item": {
        "type": "factory",
        "id": "cd7c0510370ca03d"
      },
      "id": "cd7c0510370ca03d",
      "type": "add",
      "after": "19efe2a21e491919",
      "date": 1676447890873
    },
    {
      "type": "edit",
      "id": "cd7c0510370ca03d",
      "item": {
        "type": "markdown",
        "id": "cd7c0510370ca03d",
        "text": "FP is manifested in traditional programming languages such as Lisp and Haskell. It has a prominent influence on mainstream programming. Apple introduced the swift "
      },
      "date": 1676447960514
    },
    {
      "type": "edit",
      "id": "cd7c0510370ca03d",
      "item": {
        "type": "markdown",
        "id": "cd7c0510370ca03d",
        "text": "FP is manifested in traditional programming languages such as Lisp and Haskell. It has a prominent influence on mainstream programming. For example, Apple introduced the Swift programming language. Kotlin has several functional features and has a growing adoption in the Java community.\n "
      },
      "date": 1676448070102
    },
    {
      "item": {
        "type": "factory",
        "id": "d7287734e313a249"
      },
      "id": "d7287734e313a249",
      "type": "add",
      "after": "cd7c0510370ca03d",
      "date": 1676448132769
    },
    {
      "type": "remove",
      "id": "d7287734e313a249",
      "date": 1676448146100
    },
    {
      "item": {
        "type": "factory",
        "id": "92cb7c3bcaf92ede"
      },
      "id": "92cb7c3bcaf92ede",
      "type": "add",
      "after": "cd7c0510370ca03d",
      "date": 1676448207417
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These "
      },
      "date": 1676448374485
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. "
      },
      "date": 1676448496587
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. "
      },
      "date": 1676448629922
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by "
      },
      "date": 1676448719869
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by Eric Meijer. \n"
      },
      "date": 1676448789586
    },
    {
      "type": "edit",
      "id": "92cb7c3bcaf92ede",
      "item": {
        "type": "html",
        "id": "92cb7c3bcaf92ede",
        "text": "Most of programming tasks are related to develop functions which return a specific result. This case is traditionally modeled with Turing Machines in theoretical computer sciences. However, there is a number of cases where the program should not terminate, for example operating systems and servers. These programs are known as stream processors. While Büchi-Automata exist as models for these cases, they are not widely known and used by software engineers. FP offers theoretical models in these cases. [https://reactivex.io/ ReactiveX] is a framework available in many programming languages, developed by Eric Meijer, which shares features with [[Functional Reactive Programming]]. \n"
      },
      "date": 1676448945804
    },
    {
      "item": {
        "type": "factory",
        "id": "b33f3287c090551a"
      },
      "id": "b33f3287c090551a",
      "type": "add",
      "after": "92cb7c3bcaf92ede",
      "date": 1676448992906
    },
    {
      "type": "edit",
      "id": "b33f3287c090551a",
      "item": {
        "type": "markdown",
        "id": "b33f3287c090551a",
        "text": "Covariance "
      },
      "date": 1676449001185
    },
    {
      "type": "fork",
      "site": "johannes.tries.fed.wiki",
      "date": 1676449092506
    },
    {
      "type": "edit",
      "id": "19efe2a21e491919",
      "item": {
        "type": "markdown",
        "id": "19efe2a21e491919",
        "text": "As explained in [[My Journey towards category theory]] [[Johannes Drever]] see category theory as the organizing principle behind functional programming (FP). Most of the points here will be about FP.\n\n"
      },
      "date": 1676449104396
    }
  ]
}