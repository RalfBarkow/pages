{
  "title": "Distributed Hash Tables",
  "story": [
    {
      "type": "paragraph",
      "id": "d47a1726891566a5",
      "text": "\nFREEDMAN, Michael J. and MAZIÉRES, David, 2003. Sloppy Hashing and Self-Organizing Clusters. In: KAASHOEK, M. Frans and STOICA, Ion (eds.), Peer-to-Peer Systems II. Online. Berlin, Heidelberg: Springer Berlin Heidelberg. p. 45–55. Lecture Notes in Computer Science. [Accessed 22 August 2022]. ISBN 978-3-540-40724-9. \n"
    },
    {
      "type": "paragraph",
      "id": "6fc3e9be49fb6118",
      "text": "The academic community has implemented a number of distributed hash tables (DHTs) as efficient, scalable, and robust peer-to-peer infrastructures. However, we should ask whether DHTs are well-suited for the desired applications of the wider Internet population. For example, can DHTs be used to implement filesharing, by far the most popular peer-to-peer application? Or could DHTs replace proprietary content distribution networks (CDNs), such as Akamai, with a more democratic client caching scheme that speeds up any web site and saves it from flash crowds at no cost to the server operator?"
    },
    {
      "type": "markdown",
      "id": "5ebfa688f8d2b6eb",
      "text": "## A Sloppy Storage Layer"
    },
    {
      "type": "paragraph",
      "id": "8e30e265c650ab0e",
      "text": "A traditional DHT exposes two functions. put (key, value) stores a value at the specified m-bit key, and get (key) returns this stored value, just as in a normal hash table. Only one value can be stored under a key at any given time. DHTs assume that these keys are uniformly distributed in order to balance load among participating nodes. Additionally, DHTs typically replicate popular key/value pairs after multiple get requests for the same key."
    },
    {
      "type": "paragraph",
      "id": "f28764092c942cac",
      "text": "[…] DHTs are well-suited for keys with a single writer and multiple readers. Unfortunately,file-sharing and web-caching systems have multiple readers and writers. As discussed in the introduction, a plain hash table is the wrong abstraction for such applications."
    },
    {
      "type": "paragraph",
      "id": "afb3634cad649979",
      "text": "[…] More concretely, Coral manages values as follows. When a node stores data locally, it inserts a pointer to that data into the DSHT by executing put (key, addr ). For example, the key in a distributed web cache would be hash(URL). The inserting node calls find closer node(key) until it locates the first node whose list stored under key is full, or it reaches the node closest to key. If this located node is full, we backtrack one hop on the lookup path. This target node appends addr with a timestamp to the (possibly new) list stored under key. We expect records to expire quickly enough to keep the fraction of stale pointers below 50%."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Distributed Hash Tables",
        "story": []
      },
      "date": 1661187260477
    },
    {
      "item": {
        "type": "factory",
        "id": "d47a1726891566a5"
      },
      "id": "d47a1726891566a5",
      "type": "add",
      "date": 1661187270937
    },
    {
      "type": "edit",
      "id": "d47a1726891566a5",
      "item": {
        "type": "paragraph",
        "id": "d47a1726891566a5",
        "text": "\nFREEDMAN, Michael J. and MAZIÉRES, David, 2003. Sloppy Hashing and Self-Organizing Clusters. In: KAASHOEK, M. Frans and STOICA, Ion (eds.), Peer-to-Peer Systems II. Online. Berlin, Heidelberg: Springer Berlin Heidelberg. p. 45–55. Lecture Notes in Computer Science. [Accessed 22 August 2022]. ISBN 978-3-540-40724-9. \n"
      },
      "date": 1661187273440
    },
    {
      "item": {
        "type": "factory",
        "id": "6fc3e9be49fb6118"
      },
      "id": "6fc3e9be49fb6118",
      "type": "add",
      "after": "d47a1726891566a5",
      "date": 1661187303922
    },
    {
      "type": "edit",
      "id": "6fc3e9be49fb6118",
      "item": {
        "type": "paragraph",
        "id": "6fc3e9be49fb6118",
        "text": "The academic community has implemented a number of distributed hash tables (DHTs) as efficient,scalable,and robust peer-to-peer infrastructures. However, we should ask whether DHTs are well-suited for the desired applications of the wider Internet population. For example,can DHTs be used to implement filesharing,by far the most popular peer-to-peer application? Or could DHTs replace proprietary content distribution networks (CDNs),such as Akamai,with a more democratic client caching scheme that speeds up any web site and saves it from flash crowds at no cost to the server operator?"
      },
      "date": 1661187305251
    },
    {
      "type": "edit",
      "id": "6fc3e9be49fb6118",
      "item": {
        "type": "paragraph",
        "id": "6fc3e9be49fb6118",
        "text": "The academic community has implemented a number of distributed hash tables (DHTs) as efficient,scalable,and robust peer-to-peer infrastructures. However, we should ask whether DHTs are well-suited for the desired applications of the wider Internet population. For example, can DHTs be used to implement filesharing, by far the most popular peer-to-peer application? Or could DHTs replace proprietary content distribution networks (CDNs),such as Akamai,with a more democratic client caching scheme that speeds up any web site and saves it from flash crowds at no cost to the server operator?"
      },
      "date": 1661187321419
    },
    {
      "type": "edit",
      "id": "6fc3e9be49fb6118",
      "item": {
        "type": "paragraph",
        "id": "6fc3e9be49fb6118",
        "text": "The academic community has implemented a number of distributed hash tables (DHTs) as efficient,scalable,and robust peer-to-peer infrastructures. However, we should ask whether DHTs are well-suited for the desired applications of the wider Internet population. For example, can DHTs be used to implement filesharing, by far the most popular peer-to-peer application? Or could DHTs replace proprietary content distribution networks (CDNs), such as Akamai,with a more democratic client caching scheme that speeds up any web site and saves it from flash crowds at no cost to the server operator?"
      },
      "date": 1661187330728
    },
    {
      "type": "edit",
      "id": "6fc3e9be49fb6118",
      "item": {
        "type": "paragraph",
        "id": "6fc3e9be49fb6118",
        "text": "The academic community has implemented a number of distributed hash tables (DHTs) as efficient,scalable,and robust peer-to-peer infrastructures. However, we should ask whether DHTs are well-suited for the desired applications of the wider Internet population. For example, can DHTs be used to implement filesharing, by far the most popular peer-to-peer application? Or could DHTs replace proprietary content distribution networks (CDNs), such as Akamai, with a more democratic client caching scheme that speeds up any web site and saves it from flash crowds at no cost to the server operator?"
      },
      "date": 1661187336353
    },
    {
      "item": {
        "type": "factory",
        "id": "5ebfa688f8d2b6eb"
      },
      "id": "5ebfa688f8d2b6eb",
      "type": "add",
      "after": "6fc3e9be49fb6118",
      "date": 1661187412509
    },
    {
      "type": "edit",
      "id": "5ebfa688f8d2b6eb",
      "item": {
        "type": "paragraph",
        "id": "5ebfa688f8d2b6eb",
        "text": "## A Sloppy Storage Layer"
      },
      "date": 1661187415935
    },
    {
      "type": "edit",
      "id": "5ebfa688f8d2b6eb",
      "item": {
        "type": "markdown",
        "id": "5ebfa688f8d2b6eb",
        "text": "## A Sloppy Storage Layer"
      },
      "date": 1661187418251
    },
    {
      "item": {
        "type": "factory",
        "id": "8e30e265c650ab0e"
      },
      "id": "8e30e265c650ab0e",
      "type": "add",
      "after": "5ebfa688f8d2b6eb",
      "date": 1661187430394
    },
    {
      "type": "edit",
      "id": "8e30e265c650ab0e",
      "item": {
        "type": "paragraph",
        "id": "8e30e265c650ab0e",
        "text": "A traditional DHT exposes two functions. put (key, value)storesavalueatthe specified m-bit key,and get (key) returns this stored value,just as in a normal hash table. Only one value can be stored under a key at any given time. DHTs assume that these keys are uniformly distributed in order to balance load among participating nodes. Additionally,DHTs typically replicate popular key/value pairs after multiple get requests for the same key."
      },
      "date": 1661187432549
    },
    {
      "type": "edit",
      "id": "8e30e265c650ab0e",
      "item": {
        "type": "paragraph",
        "id": "8e30e265c650ab0e",
        "text": "A traditional DHT exposes two functions. put (key, value) stores a value at the specified m-bit key, and get (key) returns this stored value, just as in a normal hash table. Only one value can be stored under a key at any given time. DHTs assume that these keys are uniformly distributed in order to balance load among participating nodes. Additionally, DHTs typically replicate popular key/value pairs after multiple get requests for the same key."
      },
      "date": 1661187467627
    },
    {
      "item": {
        "type": "factory",
        "id": "f28764092c942cac"
      },
      "id": "f28764092c942cac",
      "type": "add",
      "after": "8e30e265c650ab0e",
      "date": 1661187493568
    },
    {
      "type": "edit",
      "id": "f28764092c942cac",
      "item": {
        "type": "paragraph",
        "id": "f28764092c942cac",
        "text": "[…] DHTs are well-suited for keys with a single writer and multiple readers. Unfortunately,file-sharing and web-caching systems have multiple readers and writers. As discussed in the introduction, a plain hash table is the wrong abstraction for such applications."
      },
      "date": 1661187505853
    },
    {
      "item": {
        "type": "factory",
        "id": "afb3634cad649979"
      },
      "id": "afb3634cad649979",
      "type": "add",
      "after": "f28764092c942cac",
      "date": 1661187543094
    },
    {
      "type": "edit",
      "id": "afb3634cad649979",
      "item": {
        "type": "paragraph",
        "id": "afb3634cad649979",
        "text": "[…] More concretely,Coral manages values as follows. When a node stores data locally,it inserts a pointer to that data into the DSHT by executing put (key, addr ). For example, the key in a distributed web cache would be hash(URL). The inserting node calls find closer node(key) until it locates the first node whose list stored under key is full, or it reaches the node closest to key. If this located node is full, we backtrack one hop on the lookup path. This target node appends addr with a timestamp to the (possibly new) list stored under key. We expect records to expire quickly enough to keep the fraction of stale pointers below 50%."
      },
      "date": 1661187567812
    },
    {
      "type": "edit",
      "id": "6fc3e9be49fb6118",
      "item": {
        "type": "paragraph",
        "id": "6fc3e9be49fb6118",
        "text": "The academic community has implemented a number of distributed hash tables (DHTs) as efficient, scalable, and robust peer-to-peer infrastructures. However, we should ask whether DHTs are well-suited for the desired applications of the wider Internet population. For example, can DHTs be used to implement filesharing, by far the most popular peer-to-peer application? Or could DHTs replace proprietary content distribution networks (CDNs), such as Akamai, with a more democratic client caching scheme that speeds up any web site and saves it from flash crowds at no cost to the server operator?"
      },
      "date": 1661187666113
    },
    {
      "type": "edit",
      "id": "afb3634cad649979",
      "item": {
        "type": "paragraph",
        "id": "afb3634cad649979",
        "text": "[…] More concretely, Coral manages values as follows. When a node stores data locally,it inserts a pointer to that data into the DSHT by executing put (key, addr ). For example, the key in a distributed web cache would be hash(URL). The inserting node calls find closer node(key) until it locates the first node whose list stored under key is full, or it reaches the node closest to key. If this located node is full, we backtrack one hop on the lookup path. This target node appends addr with a timestamp to the (possibly new) list stored under key. We expect records to expire quickly enough to keep the fraction of stale pointers below 50%."
      },
      "date": 1661187757457
    },
    {
      "type": "edit",
      "id": "afb3634cad649979",
      "item": {
        "type": "paragraph",
        "id": "afb3634cad649979",
        "text": "[…] More concretely, Coral manages values as follows. When a node stores data locally, it inserts a pointer to that data into the DSHT by executing put (key, addr ). For example, the key in a distributed web cache would be hash(URL). The inserting node calls find closer node(key) until it locates the first node whose list stored under key is full, or it reaches the node closest to key. If this located node is full, we backtrack one hop on the lookup path. This target node appends addr with a timestamp to the (possibly new) list stored under key. We expect records to expire quickly enough to keep the fraction of stale pointers below 50%."
      },
      "date": 1661187765514
    }
  ]
}