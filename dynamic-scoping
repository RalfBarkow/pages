{
  "title": "Dynamic Scoping",
  "story": [
    {
      "type": "html",
      "text": "<i>What is [[Dynamic Scoping]] and [[Lexical Scoping]]?</i>",
      "id": "5f5dd0122abd2bd4aac1c98ba92ff946"
    },
    {
      "type": "html",
      "text": "\nScoping itself is how you search for a variable with a given name. A variable has a <i>scope</i> which is the whole area in which that variable can be accessed by name. If there is a reference to a variable \"a\" then how does the compiler or interpreter find it?",
      "id": "b903a4477cf93207ce31e4e2b57ed0f6"
    },
    {
      "type": "html",
      "text": "\nIn lexical scoping (and if you're the interpreter), you search in the local function (the function which is running now), then you search in the function (or scope) in which that function was <i>defined,</i> then you search in the function (scope) in which <i>that</i> function was defined, and so forth. \"Lexical\" here refers to <i>text,</i> in that you can find out what variable is being referred to by looking at the nesting of scopes in the program text.",
      "id": "a15c8954203a713c1a5dc30c0b9a2252"
    },
    {
      "type": "html",
      "text": "\nIn <i>dynamic</i> scoping, by contrast, you search in the local function first, then you search in the function that <i>called</i> the local function, then you search in the function that called <i>that</i> function, and so on, up the call stack. \"Dynamic\" refers to <i>change,</i> in that the call stack can be different every time a given function is called, and so the function might hit different variables depending on where it is called from.",
      "id": "98820d7c02085bdfc7bdb88f4510802d"
    },
    {
      "type": "html",
      "text": "\nDynamic scoping is useful as a substitute for globally scoped variables. A function can say \"let current_numeric_base = 16; call other functions;\" and the other functions will all print in hexadecimal. Then when they return, and the base-setting function returns, the base will return to whatever it was. ",
      "id": "e96ca124b18b4a8d3e0e8811d36a501b"
    },
    {
      "type": "html",
      "text": "\nIt can also have a use similar to a [[Context Object]], as in [[Java Servlet]]s and EJB APIs, holding state for a series of subroutines.",
      "id": "684c481ebf1e260f67b6e87a4d66c828"
    },
    {
      "type": "html",
      "text": "\nThe two most popular methods for implementing [[Dynamic Scoping]] are [[Deep Binding]] and [[Shallow Binding]].",
      "id": "d0f03e4481bfe81e2b9faf15fce18d80"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
    },
    {
      "type": "html",
      "text": "\nSee [[Guy Steele]] and [[Gerald Sussman]]'s paper [[The Art Of The Interpreter]] for discussion of static vs dynamic scoping and more.",
      "id": "1e2bd7998c8455319fc307b3bf424452"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
    },
    {
      "type": "html",
      "text": "[The following is somewhat specific to [[Lisp Scheme Differences]] and the use of dynamic variables in [[Common Lisp]].]",
      "id": "4a68c1c06f1b806a979246ba83031e36"
    },
    {
      "type": "html",
      "text": "\nWhat does dynamic scoping do for *standard-output* that a temporary assignment to a global does not? I presume that it would be simple enough to write a macro that saves the old value, assigns a new one, executes a form, and restores the old value before returning the value of the form?\nWouldn't such a macro simply be implementing dynamic scoping in terms of lexical scoping?",
      "id": "63a559f6483fb9b9c5f430d099bc4e07"
    },
    {
      "type": "html",
      "text": "<i>[[Guy Steele]]'s original papers on the [[Scheme Language]] papers showed that dynamically scoped variables are equivalent to the controlled use of global variables. So yes, writing a macro to save, change and restore arbitrary global variables actually implements dynamic scoping. Global variables don't really have lexical scope, however, so it's not \"in terms of\" lexical scoping. Unfortunately, dynamic scoping (along with global variables) begins to break down in multi-threaded situations.</i>",
      "id": "2db16f06d9b5f35930b45715e03ed218"
    },
    {
      "type": "html",
      "text": "<i>If you just save the variable, assign to it, and restore it, it won't be thread safe, and it will require a special binding construct. Real [[Special Variable]]s work with any binding construct: LET, MULTIPLE-VALUE-BIND, WITH-OPEN-FILE, etc; the special nature of the binding is remembered as a property of the symbol and applied accordingly. And in Lisp implementations that support threads, the bindings are thread-specific! Implementing thread-specific storage is not trivial. If you assign to *standard-output*, you have a race condition. Assignment is not binding.</i>",
      "id": "58ed9bbcbc97fd6b9839ba039aeada8e"
    },
    {
      "type": "html",
      "text": "\nI agree with [[Alain Picard]] that sometimes dynamic scope is what you want. (Though I don't want it as often as he does, since global *PRINT-BASE* in particular has caused me problems. I wish the print base were an attribute of streams, instead of a global variable.) But [[Sunir Shah]]'s original proposal [on [[Lisp Scheme Differences]]] was to use dynamic scoping to replace all lexical scoping. That would be a very bad idea, most of all because it would replace the clean semantics of closures with semantics so twisted that closures couldn't be used in non-trivial code without creating horrible maintenance problems. -- [[Bill Newman]]",
      "id": "3d74e949abc5421e2c1fe0c043e99a2a"
    },
    {
      "type": "html",
      "text": "<i>Bill, *PRINT-BASE* et al are <b>special</b>, not <b>global</b>. There is a world of difference. -- ap</i>",
      "id": "732372ad9f883acbbbd6e9efeb37a3e5"
    },
    {
      "type": "html",
      "text": "\nYeah. I think what Bill is talking about, though (and he can refactor his words and delete my comment if I'm wrong) is that *print-base* et al apply to output on <i>every</i> stream, instead of being individually settable on each. For example, I have an application which uses the printer to serialize data into a database: suppose that the debugger binds *print-length* to something non-nil for human readability, then the programmer calls my SAVE-OBJECT function on a list from the break loop, so it saves something which will later be unREADable. Basically, SAVE-OBJECT has to be very careful to rebind all the printer-related variables to known-good values.",
      "id": "dcf3ba3cd6fed643c0d27d940583c4c0"
    },
    {
      "type": "html",
      "text": "<i>This is exactly why your application should re-bind the required variable at a low point in the call stack, rather than depend on what may accidentally be in existence. The WITH-STANDARD-IO-SYNTAX is provided specifically for this purpose. -- ap</i>",
      "id": "34324784ee7d536ea66684836a2f0997"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
    },
    {
      "type": "html",
      "text": "<i>I find that dynamic scoping makes spaghetti code out of modular code. Everything depends on order of execution, and it quickly becomes impossible to understand what's going on without a debugger open. Just an opinion, however... --Anthony</i>",
      "id": "488fe9db6c2c4f87a22696dca6696ccf"
    },
    {
      "type": "html",
      "text": "\nLexical scoping is easier to program with, and is necessary for safe closures, callbacks, [[Call With Current Continuation]], [[Higher Order Function]]s etc.",
      "id": "783c41dddcf2404480a49370d36a46cb"
    },
    {
      "type": "html",
      "text": "<i>Consider variables like *standard-output*, *print-base*, *break-on-signals*, etc... Dynamic scoping has the </i>potentiality<i> of turning code into a mess, but, hey, all powerful constructs are like that. It's certainly a much less dangerous feature than, say, call-cc, which is so powerful it prevents a reasonable implementation of UNWIND-PROTECT. -- [[Alain Picard]]</i>",
      "id": "809fe6cd5b084c23c049d497d42d9541"
    },
    {
      "type": "html",
      "text": "\nHmm. I was under the impression that 'dynamic-wind' solved these issues, although it is a fairly recent addition if I'm not mistaken. -- [[William Underwood]]",
      "id": "ba88d0dc5126c8038ee37577f2ad49b5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
    },
    {
      "type": "html",
      "text": "\nRichard Stallman makes a good case for dynamic scoping in his paper on emacs:\n[http://www.gnu.org/software/emacs/emacs-paper.html#SEC17 www.gnu.org]",
      "id": "8e577d93182f912a067aaa750a20b5f1"
    },
    {
      "type": "html",
      "text": "\nIncidentally, emacs ships with macros that support lexical scoping in emacs lisp (emacs lisp variabels are dynamically scoped by default, though lexical scoping turned on on a per-file basis is supported since version 24)  This would suggest that dynamic scoping is the more general of the two - or is it possible to implement dynamic scoping in a lexically scoped language in a similar way?",
      "id": "2468d3b9b7edf316433c9cac6642cae2"
    },
    {
      "type": "html",
      "text": "<i>Possibly.  A trivial, but non-threasafe, implementation follows in pseudocode (because I don't know lisp) which is based on lisp and perl six and should probably be rewritten.  Also, since Assembly has neither, yet is used to implement both several times, your argument may be irrelevant.</i>",
      "id": "2f14aacc40be32f65f85b87a6800576b"
    },
    {
      "type": "code",
      "text": "     define-macro-variable dynamic-names = []\n     defmacro \"defdyn\" (a : Name, (optional \"=\", value = NULL))\n      defvar code = q:code{\n         defvar #{a}-dynamic-list = [\"value\"];\n      }\n      dynamic-names += a\n      (type-of a) = Dynamic[(err (type-of value) (infer-type-of-slot a))]\n      return code\n    defmacro [X] (a : Slot[Dynamic[X]])\n      return {(head #{a}-dynamic-list)}\n    defmacro \"enter-dynamic-scope\"\n      return (reduce dynamic-names q:code{} (lambda (a : Code, b : Name)\n        a + q:code { #{b}-dynamic-list = (cons (head #{b}-dynamic-list) #{b}-dynamic-list);}))\n    defmacro \"leave-dynamic-scope\"\n      return (reduce dynamic-names q:code{} (lambda (a : Code, b : Name)\n        a + q:code { #{b}-dynamic-list = (tail #{b}-dynamic-list)}))\n        ",
      "id": "f138e111c910cdcf8314083f6ba73ed3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
    },
    {
      "type": "html",
      "text": "\nMoved to [[Dynamic Scoping In Smalltalk]]",
      "id": "8709a606008047cc17ef256d9a87e7b8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
    },
    {
      "type": "html",
      "text": "\nSee [[Dynamic Closure]], [[Lexical Scoping]], [[Scoping Rules]], [[Scope And Closures]], [[Special Variable]]",
      "id": "65153e23883b95a5a5a3885726b197a9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
    },
    {
      "type": "html",
      "text": "[[Category Coding Conventions]]",
      "id": "88006314a414fb844e53540093726f7f"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?DynamicScoping c2.com]",
      "id": "f88625b710649795d19a2d9e3d29ba82"
    }
  ],
  "journal": [
    {
      "date": 1372143102000,
      "id": "cb440d5ae0a5971dd9db4ee1086ff30d",
      "type": "create",
      "item": {
        "title": "Dynamic Scoping",
        "story": [
          {
            "type": "html",
            "text": "<i>What is [[Dynamic Scoping]] and [[Lexical Scoping]]?</i>",
            "id": "5f5dd0122abd2bd4aac1c98ba92ff946"
          },
          {
            "type": "html",
            "text": "\nScoping itself is how you search for a variable with a given name. A variable has a <i>scope</i> which is the whole area in which that variable can be accessed by name. If there is a reference to a variable \"a\" then how does the compiler or interpreter find it?",
            "id": "b903a4477cf93207ce31e4e2b57ed0f6"
          },
          {
            "type": "html",
            "text": "\nIn lexical scoping (and if you're the interpreter), you search in the local function (the function which is running now), then you search in the function (or scope) in which that function was <i>defined,</i> then you search in the function (scope) in which <i>that</i> function was defined, and so forth. \"Lexical\" here refers to <i>text,</i> in that you can find out what variable is being referred to by looking at the nesting of scopes in the program text.",
            "id": "a15c8954203a713c1a5dc30c0b9a2252"
          },
          {
            "type": "html",
            "text": "\nIn <i>dynamic</i> scoping, by contrast, you search in the local function first, then you search in the function that <i>called</i> the local function, then you search in the function that called <i>that</i> function, and so on, up the call stack. \"Dynamic\" refers to <i>change,</i> in that the call stack can be different every time a given function is called, and so the function might hit different variables depending on where it is called from.",
            "id": "98820d7c02085bdfc7bdb88f4510802d"
          },
          {
            "type": "html",
            "text": "\nDynamic scoping is useful as a substitute for globally scoped variables. A function can say \"let current_numeric_base = 16; call other functions;\" and the other functions will all print in hexadecimal. Then when they return, and the base-setting function returns, the base will return to whatever it was. ",
            "id": "e96ca124b18b4a8d3e0e8811d36a501b"
          },
          {
            "type": "html",
            "text": "\nIt can also have a use similar to a [[Context Object]], as in [[Java Servlet]]s and EJB APIs, holding state for a series of subroutines.",
            "id": "684c481ebf1e260f67b6e87a4d66c828"
          },
          {
            "type": "html",
            "text": "\nThe two most popular methods for implementing [[Dynamic Scoping]] are [[Deep Binding]] and [[Shallow Binding]].",
            "id": "d0f03e4481bfe81e2b9faf15fce18d80"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
          },
          {
            "type": "html",
            "text": "\nSee [[Guy Steele]] and [[Gerald Sussman]]'s paper [[The Art Of The Interpreter]] for discussion of static vs dynamic scoping and more.",
            "id": "1e2bd7998c8455319fc307b3bf424452"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
          },
          {
            "type": "html",
            "text": "[The following is somewhat specific to [[Lisp Scheme Differences]] and the use of dynamic variables in [[Common Lisp]].]",
            "id": "4a68c1c06f1b806a979246ba83031e36"
          },
          {
            "type": "html",
            "text": "\nWhat does dynamic scoping do for *standard-output* that a temporary assignment to a global does not? I presume that it would be simple enough to write a macro that saves the old value, assigns a new one, executes a form, and restores the old value before returning the value of the form?\nWouldn't such a macro simply be implementing dynamic scoping in terms of lexical scoping?",
            "id": "63a559f6483fb9b9c5f430d099bc4e07"
          },
          {
            "type": "html",
            "text": "<i>[[Guy Steele]]'s original papers on the [[Scheme Language]] papers showed that dynamically scoped variables are equivalent to the controlled use of global variables. So yes, writing a macro to save, change and restore arbitrary global variables actually implements dynamic scoping. Global variables don't really have lexical scope, however, so it's not \"in terms of\" lexical scoping. Unfortunately, dynamic scoping (along with global variables) begins to break down in multi-threaded situations.</i>",
            "id": "2db16f06d9b5f35930b45715e03ed218"
          },
          {
            "type": "html",
            "text": "<i>If you just save the variable, assign to it, and restore it, it won't be thread safe, and it will require a special binding construct. Real [[Special Variable]]s work with any binding construct: LET, MULTIPLE-VALUE-BIND, WITH-OPEN-FILE, etc; the special nature of the binding is remembered as a property of the symbol and applied accordingly. And in Lisp implementations that support threads, the bindings are thread-specific! Implementing thread-specific storage is not trivial. If you assign to *standard-output*, you have a race condition. Assignment is not binding.</i>",
            "id": "58ed9bbcbc97fd6b9839ba039aeada8e"
          },
          {
            "type": "html",
            "text": "\nI agree with [[Alain Picard]] that sometimes dynamic scope is what you want. (Though I don't want it as often as he does, since global *PRINT-BASE* in particular has caused me problems. I wish the print base were an attribute of streams, instead of a global variable.) But [[Sunir Shah]]'s original proposal [on [[Lisp Scheme Differences]]] was to use dynamic scoping to replace all lexical scoping. That would be a very bad idea, most of all because it would replace the clean semantics of closures with semantics so twisted that closures couldn't be used in non-trivial code without creating horrible maintenance problems. -- [[Bill Newman]]",
            "id": "3d74e949abc5421e2c1fe0c043e99a2a"
          },
          {
            "type": "html",
            "text": "<i>Bill, *PRINT-BASE* et al are <b>special</b>, not <b>global</b>. There is a world of difference. -- ap</i>",
            "id": "732372ad9f883acbbbd6e9efeb37a3e5"
          },
          {
            "type": "html",
            "text": "\nYeah. I think what Bill is talking about, though (and he can refactor his words and delete my comment if I'm wrong) is that *print-base* et al apply to output on <i>every</i> stream, instead of being individually settable on each. For example, I have an application which uses the printer to serialize data into a database: suppose that the debugger binds *print-length* to something non-nil for human readability, then the programmer calls my SAVE-OBJECT function on a list from the break loop, so it saves something which will later be unREADable. Basically, SAVE-OBJECT has to be very careful to rebind all the printer-related variables to known-good values.",
            "id": "dcf3ba3cd6fed643c0d27d940583c4c0"
          },
          {
            "type": "html",
            "text": "<i>This is exactly why your application should re-bind the required variable at a low point in the call stack, rather than depend on what may accidentally be in existence. The WITH-STANDARD-IO-SYNTAX is provided specifically for this purpose. -- ap</i>",
            "id": "34324784ee7d536ea66684836a2f0997"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
          },
          {
            "type": "html",
            "text": "<i>I find that dynamic scoping makes spaghetti code out of modular code. Everything depends on order of execution, and it quickly becomes impossible to understand what's going on without a debugger open. Just an opinion, however... --Anthony</i>",
            "id": "488fe9db6c2c4f87a22696dca6696ccf"
          },
          {
            "type": "html",
            "text": "\nLexical scoping is easier to program with, and is necessary for safe closures, callbacks, [[Call With Current Continuation]], [[Higher Order Function]]s etc.",
            "id": "783c41dddcf2404480a49370d36a46cb"
          },
          {
            "type": "html",
            "text": "<i>Consider variables like *standard-output*, *print-base*, *break-on-signals*, etc... Dynamic scoping has the </i>potentiality<i> of turning code into a mess, but, hey, all powerful constructs are like that. It's certainly a much less dangerous feature than, say, call-cc, which is so powerful it prevents a reasonable implementation of UNWIND-PROTECT. -- [[Alain Picard]]</i>",
            "id": "809fe6cd5b084c23c049d497d42d9541"
          },
          {
            "type": "html",
            "text": "\nHmm. I was under the impression that 'dynamic-wind' solved these issues, although it is a fairly recent addition if I'm not mistaken. -- [[William Underwood]]",
            "id": "ba88d0dc5126c8038ee37577f2ad49b5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
          },
          {
            "type": "html",
            "text": "\nRichard Stallman makes a good case for dynamic scoping in his paper on emacs:\n[http://www.gnu.org/software/emacs/emacs-paper.html#SEC17 www.gnu.org]",
            "id": "8e577d93182f912a067aaa750a20b5f1"
          },
          {
            "type": "html",
            "text": "\nIncidentally, emacs ships with macros that support lexical scoping in emacs lisp (emacs lisp variabels are dynamically scoped by default, though lexical scoping turned on on a per-file basis is supported since version 24)  This would suggest that dynamic scoping is the more general of the two - or is it possible to implement dynamic scoping in a lexically scoped language in a similar way?",
            "id": "2468d3b9b7edf316433c9cac6642cae2"
          },
          {
            "type": "html",
            "text": "<i>Possibly.  A trivial, but non-threasafe, implementation follows in pseudocode (because I don't know lisp) which is based on lisp and perl six and should probably be rewritten.  Also, since Assembly has neither, yet is used to implement both several times, your argument may be irrelevant.</i>",
            "id": "2f14aacc40be32f65f85b87a6800576b"
          },
          {
            "type": "code",
            "text": "     define-macro-variable dynamic-names = []\n     defmacro \"defdyn\" (a : Name, (optional \"=\", value = NULL))\n      defvar code = q:code{\n         defvar #{a}-dynamic-list = [\"value\"];\n      }\n      dynamic-names += a\n      (type-of a) = Dynamic[(err (type-of value) (infer-type-of-slot a))]\n      return code\n    defmacro [X] (a : Slot[Dynamic[X]])\n      return {(head #{a}-dynamic-list)}\n    defmacro \"enter-dynamic-scope\"\n      return (reduce dynamic-names q:code{} (lambda (a : Code, b : Name)\n        a + q:code { #{b}-dynamic-list = (cons (head #{b}-dynamic-list) #{b}-dynamic-list);}))\n    defmacro \"leave-dynamic-scope\"\n      return (reduce dynamic-names q:code{} (lambda (a : Code, b : Name)\n        a + q:code { #{b}-dynamic-list = (tail #{b}-dynamic-list)}))\n        ",
            "id": "f138e111c910cdcf8314083f6ba73ed3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
          },
          {
            "type": "html",
            "text": "\nMoved to [[Dynamic Scoping In Smalltalk]]",
            "id": "8709a606008047cc17ef256d9a87e7b8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
          },
          {
            "type": "html",
            "text": "\nSee [[Dynamic Closure]], [[Lexical Scoping]], [[Scoping Rules]], [[Scope And Closures]], [[Special Variable]]",
            "id": "65153e23883b95a5a5a3885726b197a9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a7ed1ba8a1e4035dc5ff264bafbd57cd"
          },
          {
            "type": "html",
            "text": "[[Category Coding Conventions]]",
            "id": "88006314a414fb844e53540093726f7f"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?DynamicScoping c2.com]",
            "id": "f88625b710649795d19a2d9e3d29ba82"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1674055401926
    }
  ]
}