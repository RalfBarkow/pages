{
  "title": "Brainfuck Language",
  "story": [
    {
      "type": "html",
      "text": "The [[Bad Word]] police deleted this page. Unfortunately for them, it's about a [[Programming Language]] and so [[On Topic]].",
      "id": "293cc4fde55332c5d5a33655117d2f5c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91b0168d26f2ea618e5571b664b13bb6"
    },
    {
      "type": "html",
      "text": "Brainfuck is an [[Esoteric Programming Language]]. As a language, has some very good points:",
      "id": "300db25e608c35dc7e75557c86dfbfcf"
    },
    {
      "type": "html",
      "text": " Fast learning curve",
      "id": "49a6d701669e9a2670482059251d1e1f"
    },
    {
      "type": "html",
      "text": " Easy syntax",
      "id": "886e22955623639605f4025cc3e8ac96"
    },
    {
      "type": "html",
      "text": " 200 byte compiler",
      "id": "66f9f9f7c6a0d69ac9432df438f7a03f"
    },
    {
      "type": "html",
      "text": " No trouble finding it on google (unlike with [[Forth Language]], unless \"put forth\" and \"go forth\" are excluded; very few people say brainfuck in normal non-programming web sites)",
      "id": "58230c50c3d2e9441313aeb921537434"
    },
    {
      "type": "html",
      "text": " Hmm you might land on some sort of brain fetish site though",
      "id": "143171cc0b01d4a494d3534a51abf5ad"
    },
    {
      "type": "html",
      "text": " One character per command. Easy to tokenize",
      "id": "4e16c217733520feea6ddd84fe18bbdb"
    },
    {
      "type": "html",
      "text": " Makes a great learning language :)",
      "id": "35a00850d6240b6ba2ac498aceacd5f9"
    },
    {
      "type": "html",
      "text": " Code reuse is facilitated by an utter lack of variables and subroutines.",
      "id": "852c90ec90aa84f6998f58d528d3bb28"
    },
    {
      "type": "html",
      "text": " It is [[Turing Complete]], and making a C-to-brainfuck compiler would make your programs very portable in object format.",
      "id": "fc593f8f361214244d310fd7f7832b02"
    },
    {
      "type": "html",
      "text": "\nAnd one or two bad ones:",
      "id": "ae7a99575746e2fd5f92b0cbffdd1a49"
    },
    {
      "type": "html",
      "text": " Unfortunate name when you're trying to have a serious discussion.",
      "id": "2fcb1337b488a50ad809733c41ac5ed9"
    },
    {
      "type": "html",
      "text": " Huge loss of time.",
      "id": "d62cac541eaeea557bfce612c2071782"
    },
    {
      "type": "html",
      "text": "\nHere is a simple brainfuck program:",
      "id": "01931b9149d776dcc2de5b83c6ed598f"
    },
    {
      "type": "code",
      "text": " ,[.[-],]",
      "id": "a1f1a9591e520b2867e42f141d53ee91"
    },
    {
      "type": "html",
      "text": "\nIt will work like Unix cat(1), echoing back all input characters until it reaches EOF.",
      "id": "888449da124116818c8ce8ab88eb4795"
    },
    {
      "type": "html",
      "text": "<i>I can't see why the example is not just ,[.,] neither why it has the [-] -- [[Eduardo Madrid]]</i>",
      "id": "4e37350de89580ea5a0d35d0f9aa1e56"
    },
    {
      "type": "html",
      "text": "\nClearing the cell each time makes the program work on implementations that leave the current cell unchanged on reading EOF as well as those that set the cell to 0 on EOF, thus increasing the portability. -- [[Daniel Cristofani]]",
      "id": "16b07a387b558b18de9bb0eb360970d4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91b0168d26f2ea618e5571b664b13bb6"
    },
    {
      "type": "html",
      "text": " [http://www.nvg.ntnu.no/amiga/source/div/brainfuck.readme www.nvg.ntnu.no] -- amiga original",
      "id": "6c688a0f0ac98872491087c2d3480175"
    },
    {
      "type": "html",
      "text": " [http://www.muppetlabs.com/~breadbox/bf/ www.muppetlabs.com] -- programs and language description",
      "id": "d2e552d464ef05b990c7825ae07ff838"
    },
    {
      "type": "html",
      "text": " [http://esoteric.sange.fi/brainfuck/ esoteric.sange.fi] -- an archive of implementations, programs, and IDE's for brainfuck",
      "id": "8352f6332d7993d3a912e06ff5e325f3"
    },
    {
      "type": "html",
      "text": " [http://koeln.ccc.de/projekte/brainfuck/index-e.html koeln.ccc.de] -- tools",
      "id": "7eb867f32211d13e0c16240d63b44360"
    },
    {
      "type": "html",
      "text": " [http://www.ecs.soton.ac.uk/~sdh300/stuffage/bf.net/ www.ecs.soton.ac.uk] -- dot-net version",
      "id": "d8399108dd86fb41517e36164d72a328"
    },
    {
      "type": "html",
      "text": " [http://esoteric.sange.fi/ENSI/ esoteric.sange.fi] -- some standards on the language",
      "id": "ea3e67433b06b4425b72f1e5cd7ee3e1"
    },
    {
      "type": "html",
      "text": " [http://www.iwriteiam.nl/Ha_BF.html www.iwriteiam.nl]",
      "id": "b839da5c37bb237d1078f148683f3d5f"
    },
    {
      "type": "html",
      "text": " [http://www.hevanet.com/cristofd/brainfuck/ www.hevanet.com] -- more programs and things.",
      "id": "fb5d0ead1e33a6ece7aaa1dfec7e44de"
    },
    {
      "type": "html",
      "text": " [http://e.a.la/code/a2bf/index.shtml e.a.la] -- fast ASCII-2-Brainf*ck converter",
      "id": "143f146ab2c7b9236a48d42193d750fc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91b0168d26f2ea618e5571b664b13bb6"
    },
    {
      "type": "html",
      "text": "Languages inspired by Brainfuck",
      "id": "90ec563270e10b71244d0e1a87032d4e"
    },
    {
      "type": "html",
      "text": " [[Path Language]] hybridizes Brainfuck with [[Befunge Language]] obtaining a 2-D execution space. A loop <i>looks</i> like a loop in this language.",
      "id": "6be45546f1ed5ae35c3e1cb1909d70c1"
    },
    {
      "type": "html",
      "text": " [[Snusp Language]] uses skip-if-zero ('?') to replace [[Path Language]]'s four conditional direction operators for a minimalist design and a cleaner look.",
      "id": "7b1baa2e9ea73cc8aa1b0e2183367ecc"
    },
    {
      "type": "html",
      "text": " [[Lnusp Language]] gets rid of the bloat (?!) in Snusp and Path.",
      "id": "e80724248ef59a03150d4f2f43945087"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91b0168d26f2ea618e5571b664b13bb6"
    },
    {
      "type": "html",
      "text": "<b>Syntax:</b>",
      "id": "71e5f41d55142d3f47e5383e0b100edf"
    },
    {
      "type": "html",
      "text": "<b>[</b> (opening square bracket):<br><i>while(mem[ptr]) { </i>",
      "id": "e0c9be10586c82c087e04a678a4c2e0c"
    },
    {
      "type": "html",
      "text": "<b>]</b> (closing square bracket):<br><i> } </i>",
      "id": "80af5cac67297a09545ebc9ffdcf3690"
    },
    {
      "type": "html",
      "text": "<b><</b> (less):<br><i>ptr--; </i>",
      "id": "f5f2e4b6c3d30ef326797641f0c1f3fc"
    },
    {
      "type": "html",
      "text": "<b>></b> (greater):<br><i>ptr++; </i>",
      "id": "3c2205eedd470e92ddd0600572e3755e"
    },
    {
      "type": "html",
      "text": "<b>+</b> (plus):<br><i>mem[ptr]++; </i>",
      "id": "85abb9009bae81c3a398378fc5d7a67b"
    },
    {
      "type": "html",
      "text": "<b>-</b> (minus):<br><i>mem[ptr]--; </i>",
      "id": "4af7c0c5a34ce6135ba6b401c2a67633"
    },
    {
      "type": "html",
      "text": "<b>.</b> (period):<br><i>putchar(mem[ptr]); </i>",
      "id": "511584c67268cd0cb2ce738394493fb7"
    },
    {
      "type": "html",
      "text": "<b>,</b> (comma):<br><i>mem[ptr]=getchar(); </i>",
      "id": "752cc5aeb8ec7f4df9169f9691f92202"
    },
    {
      "type": "html",
      "text": "\nWhen you make your own language, it is always a good test of usability to try and make a brainfuck interpreter in it. This shouldn't take more than a few hours under most circumstances.",
      "id": "8480fd60eb3ea738325ed04be102b682"
    },
    {
      "type": "html",
      "text": "...although there are a few little issues that trip implementors up with astonishing frequency; it would be wise to consult this document, and the two that it links to near the top, first:\n[http://www.hevanet.com/cristofd/brainfuck/epistle.html www.hevanet.com]",
      "id": "1a1138a28b861408be85f47b479dbc18"
    },
    {
      "type": "html",
      "text": "(Don't worry, they're brief.)",
      "id": "30c12666a4c029840ec66db75e4171a6"
    },
    {
      "type": "html",
      "text": "\nSomething from that epistle; every character not part of the language is insignificant whitespace. That's nice for [[Literate Programming]] (if it wasn't for the reserving of . and - that is!)",
      "id": "1c48265984e72ff61ea8d3f1e43a998d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91b0168d26f2ea618e5571b664b13bb6"
    },
    {
      "type": "html",
      "text": "How would you implement the following 2 (perhaps this might give me a bit more insight on how to do very simple code-structures with a Turing Machine, given these, any program could probably be built).",
      "id": "53ae2de79f7e8fad98007c9bd478ec23"
    },
    {
      "type": "html",
      "text": " given x: mem[0]",
      "id": "919d51d27d3bcee9f0edaec1b63c6777"
    },
    {
      "type": "html",
      "text": " given ptr = 0\nimplement:",
      "id": "70dde5dc71a9bdb6712422901e7a7784"
    },
    {
      "type": "code",
      "text": " if (x > 0)\n  x = 1\n else\n  x = 2",
      "id": "4f76ead5924b6ba38952d927e1cdeb80"
    },
    {
      "type": "html",
      "text": "(Answer: I'd do [>+<[-]]++>[<->-]< ; this assumes mem[1] is zero and uses it as a temp, and also that mem[0] is not negative, which is the best policy in my view.)",
      "id": "6be6a5b16a64e4cf4b32414f8fbeb79f"
    },
    {
      "type": "html",
      "text": "([[-]-<]>++ looks better to me.)",
      "id": "7964a5765e5912b1eb748b55cab16613"
    },
    {
      "type": "html",
      "text": "(Some problems with that. One, if x>0 it tries to read mem[-1], which should ideally be a fatal runtime error and is likely to be one in practice. Two, if x==0 it stores 2 in mem[1], not in mem[0]. Three, when it's finished we have lost track of the pointer, which is likely to be problematic in the context of a larger program. Though if we left enough structure around, we could re-establish the pointer's location - e.g.:",
      "id": "65937d521b48b0fa03efdd22204c9e49"
    },
    {
      "type": "html",
      "text": ">+<[[-]->-]>[->]<<++\nwhich assumes that mem[1] and mem[2] are both zero.)",
      "id": "3927cf8f2380cd0b82e01b7f9c779d3c"
    },
    {
      "type": "html",
      "text": "(with a Turing machine this would be something like:",
      "id": "9e12c7dea21b21a60a2bc906614e8062"
    },
    {
      "type": "html",
      "text": " 0 2 R 7",
      "id": "7e3aadeb4be70d62cf19d049ced7e7a7"
    },
    {
      "type": "html",
      "text": " 1 1 R 7",
      "id": "574f5c4119d01e75493ba31aa778b547"
    },
    {
      "type": "html",
      "text": " 2 1 R 7",
      "id": "fb4ac520b86671e621d5283876c428be"
    },
    {
      "type": "html",
      "text": " 3 1 R 7",
      "id": "326689642af59ee44cfc9cf4c074e388"
    },
    {
      "type": "code",
      "text": " etc.",
      "id": "2e5740c1e3c017605b75a0a7e73e7ead"
    },
    {
      "type": "html",
      "text": "\nNotice that a Turing machine has nothing in common with brainfuck except the memory model and the fact of being [[Turing Complete]].",
      "id": "72f3d4909ac1d2a45faf8dcfcf261ba1"
    },
    {
      "type": "html",
      "text": "<i>Not even the memory model is the same. A [[Turing Machine]] tape's squares may only contain one of a fixed finite alphabet of symbols, while a Brainfuck tape's squares store arbitrarily large (implementation details notwithstanding) natural numbers. Really, the Brainfuck tape is more like an inexhaustible supply of registers.</i>",
      "id": "fafac0181571cd629022ee19732cc19d"
    },
    {
      "type": "html",
      "text": "<i>Not exactly. Unlimited-range cells are a feature of Frans Faase's dialect of brainfuck, and of his dialect only. If we were going to talk about an ideal brainfuck language independent of any implementations, we would need to base it on Urban M�ller's original readme file, and based on that we would say: a brainfuck tape's squares store bytes (implementation details notwithstanding).</i>",
      "id": "b9d18b2262a66a4556bca0f09afd5039"
    },
    {
      "type": "html",
      "text": "\nSum ar: zero to infinity, negative infinity to positive infinity, or 8 bits 0 to 255, or wrapped around or not wrapped around. Another thing would be whether there is more memery left of the starting place.",
      "id": "ccb824fb328d2bd450392bd46ce478cf"
    },
    {
      "type": "html",
      "text": "<i>There isn't more memory left of the starting place in the original implementations, or in most later implementations, there's nothing in the documentation to suggest there might be, and no careful programmer will move the pointer there deliberately. So it's a particularly useless \"feature\" to add to an implementation.</i>",
      "id": "6217da290ae07890f94e26cfea902eab"
    },
    {
      "type": "html",
      "text": ")",
      "id": "2665f8876319dbc846f46356401f425f"
    },
    {
      "type": "html",
      "text": "\nOr",
      "id": "516f47fc29c686ca0e376eaba51fd1f3"
    },
    {
      "type": "html",
      "text": " given x: mem[a]",
      "id": "f95cbfe7669f13a54b86ded2c8cc9247"
    },
    {
      "type": "html",
      "text": " given y: mem[a + 1] (for some a)\nimplement:  ",
      "id": "8d8b82e4c715a0fa407535c49d97a2fb"
    },
    {
      "type": "code",
      "text": " z = &x",
      "id": "c05e05fa6fdba897d34a95fa6629a55a"
    },
    {
      "type": "html",
      "text": "(Not clear on that. If you mean something like \"find the value of the pointer\", there's no way to do that - if your program needs that information, it'll have to keep track of where it moves the pointer to. Also note that the array elements are likely to be bytes, so the address may not fit in one. I think the best move is probably to avoid using absolute addressing schemes where possible.",
      "id": "e2ab41ac1c156f8596055ad458553df1"
    },
    {
      "type": "html",
      "text": "\nIf you mean something else, please restate.)",
      "id": "9cb73b45250d12f600af70746239d1a3"
    },
    {
      "type": "html",
      "text": "(Ditto re: Turing machines.)",
      "id": "ddb7f1341af9b8b54ad2ee90ec637b60"
    },
    {
      "type": "html",
      "text": "\nAlso, where is the program stored? Are program and data completely separated?",
      "id": "009a19df504b8a0f3298faeb52735579"
    },
    {
      "type": "html",
      "text": "(Answer: Yes. At least in theory; in some implementations you can violate this.)(Ditto re: Turing.)",
      "id": "77c095d4056178fcad39bde5732277b4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91b0168d26f2ea618e5571b664b13bb6"
    },
    {
      "type": "html",
      "text": "See also [[Turing Tarpit]], [[Functional Tarpit]]",
      "id": "1d2d40ec52b8742e8fa791cb781e0678"
    },
    {
      "type": "html",
      "text": "\nI've seen #s, :s, \\s, etc. in bf code before. What do they do?",
      "id": "dd76fe4eddcada40bc982be0f97cbe50"
    },
    {
      "type": "code",
      "text": "        Ex.:\n              #>>>-<<<[[>+>+<<-]>[>]+[<]>-[[>]<+[<]>-]<<]>>-[>]#>>>+++++[>+++<-] (Code taken from a quine)",
      "id": "78b32fb99b20cc001d2dc07075f8c351"
    },
    {
      "type": "html",
      "text": "<i>I don't think it does anything. If it was taken from a quine, it was just because the program outputs that, they decided to also add that to the program. In ABF, the # switch with temporary register but I don't think that is standard or anything else does that.</i>",
      "id": "d7ec4f0b4b8b3f40214a9bd6c059f712"
    },
    {
      "type": "html",
      "text": "<i>Various people have made implementation-specific extensions to brainfuck, which suggests to me that they didn't get the point. The # command has a certain degree of legitimacy, though, for two reasons: One, it's used for debugging, rather than as an integral part of programs. (Its action is to print the values of the first ten cells of the array, in decimal, and a ^ mark on the next line to indicate the pointer's location; and it doesn't even do that unless you set a \"debug\" command-line option in the interpreter.)</i>",
      "id": "8929404795610998ba370f08657ed955"
    },
    {
      "type": "html",
      "text": "<i>The second reason is that it was made by Urban M�ller, who invented the brainfuck language.</i>",
      "id": "b922a4ea6f4260326925e5409bae65a9"
    },
    {
      "type": "html",
      "text": "<i>Since it's clearly undesirable to have a proliferation of special commands, any brainfuck implementor who wants to include any kind of \"print internal state, for debugging\" function should use # as the command for it. Likewise it'd be a good choice for marking breakpoints, for implementations that feature them.</i>",
      "id": "b572cd99b058ad74ca13da656d256175"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91b0168d26f2ea618e5571b664b13bb6"
    },
    {
      "type": "html",
      "text": "\nThere's a stupider kid on the block: [[Whitespace Language]]",
      "id": "b8174ff1eeacc90f917f2bf3fa278486"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "91b0168d26f2ea618e5571b664b13bb6"
    },
    {
      "type": "html",
      "text": "[[Category Programming Language]]",
      "id": "da5151df4e87524ae41fe3d17de74566"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?BrainfuckLanguage c2.com]",
      "id": "acb84c1b7a5333e625f1e32271b558df"
    }
  ],
  "journal": [
    {
      "date": 1401691533000,
      "id": "034b08caff6ca2649df8708113e110f0",
      "type": "create",
      "item": {
        "title": "Brainfuck Language",
        "story": [
          {
            "type": "html",
            "text": "The [[Bad Word]] police deleted this page. Unfortunately for them, it's about a [[Programming Language]] and so [[On Topic]].",
            "id": "293cc4fde55332c5d5a33655117d2f5c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91b0168d26f2ea618e5571b664b13bb6"
          },
          {
            "type": "html",
            "text": "Brainfuck is an [[Esoteric Programming Language]]. As a language, has some very good points:",
            "id": "300db25e608c35dc7e75557c86dfbfcf"
          },
          {
            "type": "html",
            "text": " Fast learning curve",
            "id": "49a6d701669e9a2670482059251d1e1f"
          },
          {
            "type": "html",
            "text": " Easy syntax",
            "id": "886e22955623639605f4025cc3e8ac96"
          },
          {
            "type": "html",
            "text": " 200 byte compiler",
            "id": "66f9f9f7c6a0d69ac9432df438f7a03f"
          },
          {
            "type": "html",
            "text": " No trouble finding it on google (unlike with [[Forth Language]], unless \"put forth\" and \"go forth\" are excluded; very few people say brainfuck in normal non-programming web sites)",
            "id": "58230c50c3d2e9441313aeb921537434"
          },
          {
            "type": "html",
            "text": " Hmm you might land on some sort of brain fetish site though",
            "id": "143171cc0b01d4a494d3534a51abf5ad"
          },
          {
            "type": "html",
            "text": " One character per command. Easy to tokenize",
            "id": "4e16c217733520feea6ddd84fe18bbdb"
          },
          {
            "type": "html",
            "text": " Makes a great learning language :)",
            "id": "35a00850d6240b6ba2ac498aceacd5f9"
          },
          {
            "type": "html",
            "text": " Code reuse is facilitated by an utter lack of variables and subroutines.",
            "id": "852c90ec90aa84f6998f58d528d3bb28"
          },
          {
            "type": "html",
            "text": " It is [[Turing Complete]], and making a C-to-brainfuck compiler would make your programs very portable in object format.",
            "id": "fc593f8f361214244d310fd7f7832b02"
          },
          {
            "type": "html",
            "text": "\nAnd one or two bad ones:",
            "id": "ae7a99575746e2fd5f92b0cbffdd1a49"
          },
          {
            "type": "html",
            "text": " Unfortunate name when you're trying to have a serious discussion.",
            "id": "2fcb1337b488a50ad809733c41ac5ed9"
          },
          {
            "type": "html",
            "text": " Huge loss of time.",
            "id": "d62cac541eaeea557bfce612c2071782"
          },
          {
            "type": "html",
            "text": "\nHere is a simple brainfuck program:",
            "id": "01931b9149d776dcc2de5b83c6ed598f"
          },
          {
            "type": "code",
            "text": " ,[.[-],]",
            "id": "a1f1a9591e520b2867e42f141d53ee91"
          },
          {
            "type": "html",
            "text": "\nIt will work like Unix cat(1), echoing back all input characters until it reaches EOF.",
            "id": "888449da124116818c8ce8ab88eb4795"
          },
          {
            "type": "html",
            "text": "<i>I can't see why the example is not just ,[.,] neither why it has the [-] -- [[Eduardo Madrid]]</i>",
            "id": "4e37350de89580ea5a0d35d0f9aa1e56"
          },
          {
            "type": "html",
            "text": "\nClearing the cell each time makes the program work on implementations that leave the current cell unchanged on reading EOF as well as those that set the cell to 0 on EOF, thus increasing the portability. -- [[Daniel Cristofani]]",
            "id": "16b07a387b558b18de9bb0eb360970d4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91b0168d26f2ea618e5571b664b13bb6"
          },
          {
            "type": "html",
            "text": " [http://www.nvg.ntnu.no/amiga/source/div/brainfuck.readme www.nvg.ntnu.no] -- amiga original",
            "id": "6c688a0f0ac98872491087c2d3480175"
          },
          {
            "type": "html",
            "text": " [http://www.muppetlabs.com/~breadbox/bf/ www.muppetlabs.com] -- programs and language description",
            "id": "d2e552d464ef05b990c7825ae07ff838"
          },
          {
            "type": "html",
            "text": " [http://esoteric.sange.fi/brainfuck/ esoteric.sange.fi] -- an archive of implementations, programs, and IDE's for brainfuck",
            "id": "8352f6332d7993d3a912e06ff5e325f3"
          },
          {
            "type": "html",
            "text": " [http://koeln.ccc.de/projekte/brainfuck/index-e.html koeln.ccc.de] -- tools",
            "id": "7eb867f32211d13e0c16240d63b44360"
          },
          {
            "type": "html",
            "text": " [http://www.ecs.soton.ac.uk/~sdh300/stuffage/bf.net/ www.ecs.soton.ac.uk] -- dot-net version",
            "id": "d8399108dd86fb41517e36164d72a328"
          },
          {
            "type": "html",
            "text": " [http://esoteric.sange.fi/ENSI/ esoteric.sange.fi] -- some standards on the language",
            "id": "ea3e67433b06b4425b72f1e5cd7ee3e1"
          },
          {
            "type": "html",
            "text": " [http://www.iwriteiam.nl/Ha_BF.html www.iwriteiam.nl]",
            "id": "b839da5c37bb237d1078f148683f3d5f"
          },
          {
            "type": "html",
            "text": " [http://www.hevanet.com/cristofd/brainfuck/ www.hevanet.com] -- more programs and things.",
            "id": "fb5d0ead1e33a6ece7aaa1dfec7e44de"
          },
          {
            "type": "html",
            "text": " [http://e.a.la/code/a2bf/index.shtml e.a.la] -- fast ASCII-2-Brainf*ck converter",
            "id": "143f146ab2c7b9236a48d42193d750fc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91b0168d26f2ea618e5571b664b13bb6"
          },
          {
            "type": "html",
            "text": "Languages inspired by Brainfuck",
            "id": "90ec563270e10b71244d0e1a87032d4e"
          },
          {
            "type": "html",
            "text": " [[Path Language]] hybridizes Brainfuck with [[Befunge Language]] obtaining a 2-D execution space. A loop <i>looks</i> like a loop in this language.",
            "id": "6be45546f1ed5ae35c3e1cb1909d70c1"
          },
          {
            "type": "html",
            "text": " [[Snusp Language]] uses skip-if-zero ('?') to replace [[Path Language]]'s four conditional direction operators for a minimalist design and a cleaner look.",
            "id": "7b1baa2e9ea73cc8aa1b0e2183367ecc"
          },
          {
            "type": "html",
            "text": " [[Lnusp Language]] gets rid of the bloat (?!) in Snusp and Path.",
            "id": "e80724248ef59a03150d4f2f43945087"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91b0168d26f2ea618e5571b664b13bb6"
          },
          {
            "type": "html",
            "text": "<b>Syntax:</b>",
            "id": "71e5f41d55142d3f47e5383e0b100edf"
          },
          {
            "type": "html",
            "text": "<b>[</b> (opening square bracket):<br><i>while(mem[ptr]) { </i>",
            "id": "e0c9be10586c82c087e04a678a4c2e0c"
          },
          {
            "type": "html",
            "text": "<b>]</b> (closing square bracket):<br><i> } </i>",
            "id": "80af5cac67297a09545ebc9ffdcf3690"
          },
          {
            "type": "html",
            "text": "<b><</b> (less):<br><i>ptr--; </i>",
            "id": "f5f2e4b6c3d30ef326797641f0c1f3fc"
          },
          {
            "type": "html",
            "text": "<b>></b> (greater):<br><i>ptr++; </i>",
            "id": "3c2205eedd470e92ddd0600572e3755e"
          },
          {
            "type": "html",
            "text": "<b>+</b> (plus):<br><i>mem[ptr]++; </i>",
            "id": "85abb9009bae81c3a398378fc5d7a67b"
          },
          {
            "type": "html",
            "text": "<b>-</b> (minus):<br><i>mem[ptr]--; </i>",
            "id": "4af7c0c5a34ce6135ba6b401c2a67633"
          },
          {
            "type": "html",
            "text": "<b>.</b> (period):<br><i>putchar(mem[ptr]); </i>",
            "id": "511584c67268cd0cb2ce738394493fb7"
          },
          {
            "type": "html",
            "text": "<b>,</b> (comma):<br><i>mem[ptr]=getchar(); </i>",
            "id": "752cc5aeb8ec7f4df9169f9691f92202"
          },
          {
            "type": "html",
            "text": "\nWhen you make your own language, it is always a good test of usability to try and make a brainfuck interpreter in it. This shouldn't take more than a few hours under most circumstances.",
            "id": "8480fd60eb3ea738325ed04be102b682"
          },
          {
            "type": "html",
            "text": "...although there are a few little issues that trip implementors up with astonishing frequency; it would be wise to consult this document, and the two that it links to near the top, first:\n[http://www.hevanet.com/cristofd/brainfuck/epistle.html www.hevanet.com]",
            "id": "1a1138a28b861408be85f47b479dbc18"
          },
          {
            "type": "html",
            "text": "(Don't worry, they're brief.)",
            "id": "30c12666a4c029840ec66db75e4171a6"
          },
          {
            "type": "html",
            "text": "\nSomething from that epistle; every character not part of the language is insignificant whitespace. That's nice for [[Literate Programming]] (if it wasn't for the reserving of . and - that is!)",
            "id": "1c48265984e72ff61ea8d3f1e43a998d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91b0168d26f2ea618e5571b664b13bb6"
          },
          {
            "type": "html",
            "text": "How would you implement the following 2 (perhaps this might give me a bit more insight on how to do very simple code-structures with a Turing Machine, given these, any program could probably be built).",
            "id": "53ae2de79f7e8fad98007c9bd478ec23"
          },
          {
            "type": "html",
            "text": " given x: mem[0]",
            "id": "919d51d27d3bcee9f0edaec1b63c6777"
          },
          {
            "type": "html",
            "text": " given ptr = 0\nimplement:",
            "id": "70dde5dc71a9bdb6712422901e7a7784"
          },
          {
            "type": "code",
            "text": " if (x > 0)\n  x = 1\n else\n  x = 2",
            "id": "4f76ead5924b6ba38952d927e1cdeb80"
          },
          {
            "type": "html",
            "text": "(Answer: I'd do [>+<[-]]++>[<->-]< ; this assumes mem[1] is zero and uses it as a temp, and also that mem[0] is not negative, which is the best policy in my view.)",
            "id": "6be6a5b16a64e4cf4b32414f8fbeb79f"
          },
          {
            "type": "html",
            "text": "([[-]-<]>++ looks better to me.)",
            "id": "7964a5765e5912b1eb748b55cab16613"
          },
          {
            "type": "html",
            "text": "(Some problems with that. One, if x>0 it tries to read mem[-1], which should ideally be a fatal runtime error and is likely to be one in practice. Two, if x==0 it stores 2 in mem[1], not in mem[0]. Three, when it's finished we have lost track of the pointer, which is likely to be problematic in the context of a larger program. Though if we left enough structure around, we could re-establish the pointer's location - e.g.:",
            "id": "65937d521b48b0fa03efdd22204c9e49"
          },
          {
            "type": "html",
            "text": ">+<[[-]->-]>[->]<<++\nwhich assumes that mem[1] and mem[2] are both zero.)",
            "id": "3927cf8f2380cd0b82e01b7f9c779d3c"
          },
          {
            "type": "html",
            "text": "(with a Turing machine this would be something like:",
            "id": "9e12c7dea21b21a60a2bc906614e8062"
          },
          {
            "type": "html",
            "text": " 0 2 R 7",
            "id": "7e3aadeb4be70d62cf19d049ced7e7a7"
          },
          {
            "type": "html",
            "text": " 1 1 R 7",
            "id": "574f5c4119d01e75493ba31aa778b547"
          },
          {
            "type": "html",
            "text": " 2 1 R 7",
            "id": "fb4ac520b86671e621d5283876c428be"
          },
          {
            "type": "html",
            "text": " 3 1 R 7",
            "id": "326689642af59ee44cfc9cf4c074e388"
          },
          {
            "type": "code",
            "text": " etc.",
            "id": "2e5740c1e3c017605b75a0a7e73e7ead"
          },
          {
            "type": "html",
            "text": "\nNotice that a Turing machine has nothing in common with brainfuck except the memory model and the fact of being [[Turing Complete]].",
            "id": "72f3d4909ac1d2a45faf8dcfcf261ba1"
          },
          {
            "type": "html",
            "text": "<i>Not even the memory model is the same. A [[Turing Machine]] tape's squares may only contain one of a fixed finite alphabet of symbols, while a Brainfuck tape's squares store arbitrarily large (implementation details notwithstanding) natural numbers. Really, the Brainfuck tape is more like an inexhaustible supply of registers.</i>",
            "id": "fafac0181571cd629022ee19732cc19d"
          },
          {
            "type": "html",
            "text": "<i>Not exactly. Unlimited-range cells are a feature of Frans Faase's dialect of brainfuck, and of his dialect only. If we were going to talk about an ideal brainfuck language independent of any implementations, we would need to base it on Urban M�ller's original readme file, and based on that we would say: a brainfuck tape's squares store bytes (implementation details notwithstanding).</i>",
            "id": "b9d18b2262a66a4556bca0f09afd5039"
          },
          {
            "type": "html",
            "text": "\nSum ar: zero to infinity, negative infinity to positive infinity, or 8 bits 0 to 255, or wrapped around or not wrapped around. Another thing would be whether there is more memery left of the starting place.",
            "id": "ccb824fb328d2bd450392bd46ce478cf"
          },
          {
            "type": "html",
            "text": "<i>There isn't more memory left of the starting place in the original implementations, or in most later implementations, there's nothing in the documentation to suggest there might be, and no careful programmer will move the pointer there deliberately. So it's a particularly useless \"feature\" to add to an implementation.</i>",
            "id": "6217da290ae07890f94e26cfea902eab"
          },
          {
            "type": "html",
            "text": ")",
            "id": "2665f8876319dbc846f46356401f425f"
          },
          {
            "type": "html",
            "text": "\nOr",
            "id": "516f47fc29c686ca0e376eaba51fd1f3"
          },
          {
            "type": "html",
            "text": " given x: mem[a]",
            "id": "f95cbfe7669f13a54b86ded2c8cc9247"
          },
          {
            "type": "html",
            "text": " given y: mem[a + 1] (for some a)\nimplement:  ",
            "id": "8d8b82e4c715a0fa407535c49d97a2fb"
          },
          {
            "type": "code",
            "text": " z = &x",
            "id": "c05e05fa6fdba897d34a95fa6629a55a"
          },
          {
            "type": "html",
            "text": "(Not clear on that. If you mean something like \"find the value of the pointer\", there's no way to do that - if your program needs that information, it'll have to keep track of where it moves the pointer to. Also note that the array elements are likely to be bytes, so the address may not fit in one. I think the best move is probably to avoid using absolute addressing schemes where possible.",
            "id": "e2ab41ac1c156f8596055ad458553df1"
          },
          {
            "type": "html",
            "text": "\nIf you mean something else, please restate.)",
            "id": "9cb73b45250d12f600af70746239d1a3"
          },
          {
            "type": "html",
            "text": "(Ditto re: Turing machines.)",
            "id": "ddb7f1341af9b8b54ad2ee90ec637b60"
          },
          {
            "type": "html",
            "text": "\nAlso, where is the program stored? Are program and data completely separated?",
            "id": "009a19df504b8a0f3298faeb52735579"
          },
          {
            "type": "html",
            "text": "(Answer: Yes. At least in theory; in some implementations you can violate this.)(Ditto re: Turing.)",
            "id": "77c095d4056178fcad39bde5732277b4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91b0168d26f2ea618e5571b664b13bb6"
          },
          {
            "type": "html",
            "text": "See also [[Turing Tarpit]], [[Functional Tarpit]]",
            "id": "1d2d40ec52b8742e8fa791cb781e0678"
          },
          {
            "type": "html",
            "text": "\nI've seen #s, :s, \\s, etc. in bf code before. What do they do?",
            "id": "dd76fe4eddcada40bc982be0f97cbe50"
          },
          {
            "type": "code",
            "text": "        Ex.:\n              #>>>-<<<[[>+>+<<-]>[>]+[<]>-[[>]<+[<]>-]<<]>>-[>]#>>>+++++[>+++<-] (Code taken from a quine)",
            "id": "78b32fb99b20cc001d2dc07075f8c351"
          },
          {
            "type": "html",
            "text": "<i>I don't think it does anything. If it was taken from a quine, it was just because the program outputs that, they decided to also add that to the program. In ABF, the # switch with temporary register but I don't think that is standard or anything else does that.</i>",
            "id": "d7ec4f0b4b8b3f40214a9bd6c059f712"
          },
          {
            "type": "html",
            "text": "<i>Various people have made implementation-specific extensions to brainfuck, which suggests to me that they didn't get the point. The # command has a certain degree of legitimacy, though, for two reasons: One, it's used for debugging, rather than as an integral part of programs. (Its action is to print the values of the first ten cells of the array, in decimal, and a ^ mark on the next line to indicate the pointer's location; and it doesn't even do that unless you set a \"debug\" command-line option in the interpreter.)</i>",
            "id": "8929404795610998ba370f08657ed955"
          },
          {
            "type": "html",
            "text": "<i>The second reason is that it was made by Urban M�ller, who invented the brainfuck language.</i>",
            "id": "b922a4ea6f4260326925e5409bae65a9"
          },
          {
            "type": "html",
            "text": "<i>Since it's clearly undesirable to have a proliferation of special commands, any brainfuck implementor who wants to include any kind of \"print internal state, for debugging\" function should use # as the command for it. Likewise it'd be a good choice for marking breakpoints, for implementations that feature them.</i>",
            "id": "b572cd99b058ad74ca13da656d256175"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91b0168d26f2ea618e5571b664b13bb6"
          },
          {
            "type": "html",
            "text": "\nThere's a stupider kid on the block: [[Whitespace Language]]",
            "id": "b8174ff1eeacc90f917f2bf3fa278486"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "91b0168d26f2ea618e5571b664b13bb6"
          },
          {
            "type": "html",
            "text": "[[Category Programming Language]]",
            "id": "da5151df4e87524ae41fe3d17de74566"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?BrainfuckLanguage c2.com]",
            "id": "acb84c1b7a5333e625f1e32271b558df"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1707798530982
    }
  ]
}