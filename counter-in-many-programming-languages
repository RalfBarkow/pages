{
  "title": "Counter In Many Programming Languages",
  "story": [
    {
      "type": "html",
      "text": "The Problem (Originally from [[Python Vs Ruby]]):",
      "id": "4fd84d1bf4aad23eebe975e1179ae4f0"
    },
    {
      "type": "html",
      "text": " A counter may be initialised with a value or defaults to an initial value of 1.  When called, it:",
      "id": "efa8e1ecbe12547464f1ce3ca00d7935"
    },
    {
      "type": "html",
      "text": " returns its current value; and",
      "id": "3d9e84f082d9171d8ddac563fcfc1d4b"
    },
    {
      "type": "html",
      "text": " increments its current value",
      "id": "27d5e6767a120d1584ad13510f0e6cd3"
    },
    {
      "type": "html",
      "text": " The exact internal implementation is less important than the output behaviour - feel free to set current value to 1 less than the value given if you feel that pre-incrementing gives a cleaner implementation in your language.",
      "id": "58119ceb56d3cefb6de4ff0aea406e4e"
    },
    {
      "type": "html",
      "text": " The counter should be such that any number of individual counters can be instantiated.",
      "id": "2fad201b0358fb8169331bad9ba3f665"
    },
    {
      "type": "html",
      "text": " If the counter is unable to handle integers of arbitrary size, this should be stated.",
      "id": "a3e1465982ccb6256bf9a4dfb04e7e86"
    },
    {
      "type": "html",
      "text": "\nOf particular interest, of course, is the counter's behavior when an overflow condition exists.  Some languages mentioned below do not provide fixed-precision numeric types; thus overflow doesn't happen (until you run out of memory--shortly after the universe collapses in on itself).  Others provide only fixed-precision types (and thus risk overflow); though in many cases the amount of precision provided [[Should Be]] more than adequate for most applications.  (But if it isn't...)  None seems to handle an overflow condition gracefully, except [[Lisp Language]], [[Python Language]], and [[Ruby Language]], whose integers will be automatically ([[Under The Hood]]) upgraded to bignums when fixnum range is exceeded.  The [[Sml Language]] (Basis Library) supports fixed width integers with overflow causing an exception (e.g. the Int32 module), fixed width unsigned integers with modular arithmetic (e.g. the Word32 module), and arbitrary precision integers (the [[Int Inf]] module).   (See [[Type Migration]])",
      "id": "b269cf66ad0e57ca0c8f1f50de03eb6d"
    },
    {
      "type": "html",
      "text": "\nSee also: [[Accumulator Generator]]",
      "id": "8a123d57cb601e9eea262d88126ad692"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "Intel 80X86/Pentium <b>[[Assembly Language]]</b>:",
      "id": "3e7caeeeef12fff65006dd29e4cfe109"
    },
    {
      "type": "code",
      "text": " ;;; counter.asm",
      "id": "628356035e35cf82190dab81ace6ea62"
    },
    {
      "type": "code",
      "text": " %assign SYS_EXIT  1",
      "id": "e9df576643198ac813447e10c9ca6404"
    },
    {
      "type": "code",
      "text": "  ;; -------------------------\n  ;; data segment\n  ;; -------------------------",
      "id": "25590f4e41c7dd6b717fad5e7e0ca31c"
    },
    {
      "type": "code",
      "text": "  section  .data\n counter      dw  1\n countstring  dd  0\n        \n  ;; -------------------------\n  ;; code area\n  ;; -------------------------",
      "id": "55de6b93492d8cb713ce5b9cdc875eaa"
    },
    {
      "type": "code",
      "text": "  section  .text\n  global  _start",
      "id": "fe78b44a8f4496fddf24ee7d77b2e4bd"
    },
    {
      "type": "html",
      "text": "_start:<br>call  incCounter",
      "id": "68b82056bcfba14b7d631d361d55f1b7"
    },
    {
      "type": "code",
      "text": "        \n  ;; exit()",
      "id": "32b02b63b8cdd20dae3156c526d7858a"
    },
    {
      "type": "code",
      "text": "  mov  eax,SYS_EXIT\n  mov  ebx,0\n  int  0x80    ; final system call",
      "id": "405fcd895339ff8c61e55e1bab310264"
    },
    {
      "type": "code",
      "text": " ;-----------------------------------\n ;incCounter: prints current value\n ;and increments counter\n ;Registers modified:EAX,EBX,ECX,EDX\n ;-----------------------------------",
      "id": "6a25cdd96af50b17baf294217a9ab70b"
    },
    {
      "type": "code",
      "text": " incCounter:",
      "id": "2e82c9411670dabcc2f316466ec87e6e"
    },
    {
      "type": "code",
      "text": " ;;calculate ascii string to print\n        mov             edx,0                 ; keep track of number of digits\n        mov             ax,[counter]          ; get the current value of the counter\n        lea             ecx,[countstring + 3] ; load location to store string in, starting at last byte\n        mov             dl,10                 ; print a base ten number \n                                              ; of no more than four digits by finding\n nextdig: div             dl                    ; the ascii code of the LSD, storing it\n        add             ah,48\n        mov             [ecx],ah\n        inc             edx\n        cmp             al,0\n        je              icprint               ; if this is the last digit, print it\n        cmp             edx,4\n        je              icprint               ; if this is the fourth digit, print it\n        dec             ecx\n        xor             ah,ah\n        jmp             nextdig",
      "id": "1f387f40239687cce69f509fec274561"
    },
    {
      "type": "html",
      "text": "icprint:<br>",
      "id": "9a8807a955db104fff6192c750e06eea"
    },
    {
      "type": "code",
      "text": "        mov             eax,SYs_WRITE\n        mov             ebx,STDOUT\n        int             0x80",
      "id": "5f4c38b1012af413ea8acb1d6d17c010"
    },
    {
      "type": "code",
      "text": " ;; increment the counter\n        add             word [counter],1",
      "id": "c62954301a18512b05e140e49ff44746"
    },
    {
      "type": "code",
      "text": "        ret",
      "id": "45733f78bf258e15b49990e29d66f7e5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Cee Language]]</b> (C9x):",
      "id": "a852ac6f1d8199dc8e0d0c9f19b21412"
    },
    {
      "type": "html",
      "text": "\nOverflows when the type long long overflows; as long long int is guaranteed to be at least 64 bits, this won't be for a while.",
      "id": "4febb4e1af6d1eadd1da0a248fd5cb10"
    },
    {
      "type": "html",
      "text": "\nPseudo-OO; to the extent that you can do OO in C.  ",
      "id": "a90f88b5b3d10ebf98fbf36bd36cf04e"
    },
    {
      "type": "html",
      "text": "\nDoesn't do any error checking.",
      "id": "f8fb73df5d871e33fb44530732f76140"
    },
    {
      "type": "code",
      "text": " struct Counter {\n     long long int value_;\n };",
      "id": "8393e377b407b5ef0e6506d2c093af08"
    },
    {
      "type": "code",
      "text": " void counterInit (struct Counter *ctr) {\n     ctr->value_ = 1;\n }",
      "id": "28337df32980e922dffdd44b99293e72"
    },
    {
      "type": "code",
      "text": " void counterInitToValue (struct Counter *ctr, long long int value) {\n     ctr->value_ = value;\n }",
      "id": "e2a4999c169efd383e263d7af3f93ee2"
    },
    {
      "type": "code",
      "text": " long long int counterNext (struct Counter *ctr) {\n     return ctr->value_++;\n }",
      "id": "494b90c0e7048ce6129fd2108505d77f"
    },
    {
      "type": "code",
      "text": " int main (void) \n {\n     struct Counter *ctr1 = malloc(sizeof (struct Counter));\n     struct Counter *ctr2 = malloc(sizeof (struct Counter));",
      "id": "bf1e29bca746897455b8d7301ce7a199"
    },
    {
      "type": "code",
      "text": "     counterInit (ctr1);\n     counterInitToValue (ctr2,5000);\n     printf (\"Ctr 1: %d\\n\", counterNext(ctr1));\n     printf (\"Ctr 1: %d\\n\", counterNext(ctr1));\n     printf (\"Ctr 2: %d\\n\", counterNext(ctr2));\n     printf (\"Ctr 1: %d\\n\", counterNext(ctr1));\n     printf (\"Ctr 2: %d\\n\", counterNext(ctr2));\n     printf (\"Ctr 2: %d\\n\", counterNext(ctr2));",
      "id": "16c1fe8d6a83b8435bacdffde4f16668"
    },
    {
      "type": "code",
      "text": "     return 0;\n }",
      "id": "749be55f04496101cc38616717d081ef"
    },
    {
      "type": "html",
      "text": ">>> Ctr 1:<br>1",
      "id": "867252db4f53310736fcbdf07f7c3d4a"
    },
    {
      "type": "html",
      "text": ">>> Ctr 1:<br>2",
      "id": "a6d75a995e9d0d214791bbe565af0f23"
    },
    {
      "type": "html",
      "text": ">>> Ctr 2:<br>5000",
      "id": "4313bbb5b69cdfb1a3a65e52af0b276a"
    },
    {
      "type": "html",
      "text": ">>> Ctr 1:<br>3",
      "id": "e4093f01d94a6f50da6412b34a29aa80"
    },
    {
      "type": "html",
      "text": ">>> Ctr 2:<br>5001",
      "id": "367b838bbf61ba0b5d3cc4e2cb621420"
    },
    {
      "type": "html",
      "text": ">>> Ctr 2:<br>5002",
      "id": "96b2e5a6b7f60ecd7ade12192e394df6"
    },
    {
      "type": "html",
      "text": "\nNot very interesting; but does kinda show why OO is cool, and exposes lots of the dirty work that the programmer needs to do in a low-level language like C.",
      "id": "dd58b179ee2b39c3df72cbd8a1c586b0"
    },
    {
      "type": "html",
      "text": "''How does this show how OO is cool? This does not smell like an idiomatic C example. -- [[Anonymous Donor]]",
      "id": "fbc582422ec7507c27860786c09d2729"
    },
    {
      "type": "html",
      "text": "\nI think he's trying to say that this would be a lot more impressive if it <i>was</i> OO, but it just looks hackish in C.",
      "id": "03d9aa7118c5e3bff005c4e2e1bc673f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Cee Plus Plus]]</b>:",
      "id": "be0ebe8aa9b52f2cb2bc17494c04decd"
    },
    {
      "type": "html",
      "text": "\njust plain C++; not an example of [[Templates Gone Mad]].  We'll use just plain old ints:",
      "id": "e4336e4b2ae87008b2d57a1469f4216b"
    },
    {
      "type": "code",
      "text": " // Each counter will be an instantiation of the Counter class\n class Counter \n {\n   private:\n     int val_;\n   public:\n     Counter (int val = 1) : val_(val) {}\n     int next () {\n        return val_++;\n     } \n  };",
      "id": "68d3ea52bdbba69f0ab8cd0af2f6fb04"
    },
    {
      "type": "html",
      "text": "\nOr, if you prefer the type of the counter to be a parameter,",
      "id": "085323ac77bd4922345d589882f36f6c"
    },
    {
      "type": "code",
      "text": " // Each counter will be an instantiation of the Counter template class,\n // specialized on a numeric type (typically int or some bignum class)\n template <class T>\n class Counter \n {\n   private:\n     T val_;\n   public:\n     Counter (T val = 1) : val_(val) {}\n     T next () {\n        return val_++;\n     } \n  };",
      "id": "9729ba0d7bf1eca3578f995dce77cff7"
    },
    {
      "type": "html",
      "text": "\n[[Cee Plus Plus Eleven]] version using lambdas:",
      "id": "a872e924cbb4060a717e57c8bd121053"
    },
    {
      "type": "code",
      "text": " #include <functional>",
      "id": "f304cc4d495ac52e943d4932719b7845"
    },
    {
      "type": "code",
      "text": " template <class T>\n auto Counter(T val = 1) -> std::function<T()> {\n   return [=]() mutable { return val++; };\n }",
      "id": "4e0b04d2cb0cba8dbd7fb17d9c63d31e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Common Lisp]]</b>:",
      "id": "cf33d985fce02e78f8c541d96214c815"
    },
    {
      "type": "html",
      "text": "\none simple possibility: ",
      "id": "91bc46feb6188d8f3fb68adf884c5390"
    },
    {
      "type": "code",
      "text": " ;; Each counter is a lambda closure\n (setf counter1 (let ((n 2)) (lambda () (incf n))))\n (setf counter2 (let ((n 0)) (lambda () (incf n))))\n CL-USER> (funcall counter1)\n 3\n CL-USER> (funcall counter2)\n 1\n CL-USER> (funcall counter1)\n 4\n CL-USER> (funcall counter2)\n 2",
      "id": "2c98658c56e59213601718353decba9e"
    },
    {
      "type": "html",
      "text": "\nThis may look a little odd to people used to thinking about 'factories' or objects to abstract this sort of thing.  Due to first-class functions and the properties of closure, a simple form produces a function object which behaves like the above counters.",
      "id": "3fe02c55548ce39d9758a1bd0f400234"
    },
    {
      "type": "html",
      "text": "\nAnother possibility (there are others as well, of course).  Wrapped up as a counter-factory function:",
      "id": "0e08ef0594342b8b321fecfbfbf47479"
    },
    {
      "type": "code",
      "text": " ;; Counters are created by a wrapper around a lambda closure\n (defun make-counter (&optional (n 1))\n   (lambda ()\n     (prog1 n (incf n))))",
      "id": "f6686a7c78fa4dfac768597d0fe87671"
    },
    {
      "type": "code",
      "text": " (setf counter (make-counter 3))\n (setf counter2 (make-counter))",
      "id": "e7b64e6959a03c0fca9668c14a0ac298"
    },
    {
      "type": "code",
      "text": " CL-USER> (funcall counter)\n 3\n CL-USER> (funcall counter2)\n 1\n CL-USER> (funcall counter)\n 4\n CL-USER> (funcall counter2)\n 2",
      "id": "2e5062a10ea8fa026e23cf30d5cafd6e"
    },
    {
      "type": "html",
      "text": "\nThere is a trade-off here.  The second approach abstracts the 'counter' idea behind a 'factory' function to use the analogy of this page.  However, you may need to look at the definition of make-counter to remember what the semantics are (this is true of all the factory approaches on this page).  The simple lambda form is more verbose, but still concise and has the advantage that you know exactly what is happening by looking at a single line of code.  The choice of what is better depends on the context in which it is used.",
      "id": "7d994815c4da50c8e493bb36296203da"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Csharp Language]]</b> ",
      "id": "9a417018783ad26ad22d069de2e088c0"
    },
    {
      "type": "code",
      "text": " using System;",
      "id": "be197217193dd7315ed462052ad82ddf"
    },
    {
      "type": "code",
      "text": " class Test\n {\n     static Func<int> F()\n     {\n         int x = 0;\n         return delegate { return ++x; };\n     }",
      "id": "70f5974d054555e4128d4bf8d44194db"
    },
    {
      "type": "code",
      "text": "     static void Main()\n     {\n        var d = F();\n        Console.Write''''''Line(d());\n        Console.Write''''''Line(d());\n        Console.Write''''''Line(d());\n     }\n }",
      "id": "d8cc8656f6dc22895e7730b8aaa388a0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "Dodo [http://dodo.sourceforge.net dodo.sourceforge.net]",
      "id": "39aab3ba4c2cdc8c81458bd2ac6480e4"
    },
    {
      "type": "code",
      "text": " yield int counter(int n)\n {\n   loop:\n      return n\n      ++.n.\n }\n def c() = counter(5)",
      "id": "716f3972ab621a1edd31c9d42f01dc3e"
    },
    {
      "type": "html",
      "text": "Or equivalently",
      "id": "d447caa6bdd21b8760b28388bf35b7ea"
    },
    {
      "type": "code",
      "text": " def c() = for (n in 5...).value",
      "id": "8d62ce2ed449cde9d8687675c61ff5e1"
    },
    {
      "type": "html",
      "text": "Io-style",
      "id": "c1b24b1b7be5ee19da2f7e66f4d6b1ee"
    },
    {
      "type": "code",
      "text": " def c = new struct()\n {\n    int counter = 1\n    method Next: Next()\n    {\n       .value = counter\n       ++.counter\n    } -> value int.\n }\n c.Next()    # 1\n c.Next()    # 2\n def k = new c(counter: 400)",
      "id": "2414282a02bd76b84287068ea9a8fcea"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Forth Language]]</b>:",
      "id": "410956b5c38ef04498786a59511face5"
    },
    {
      "type": "code",
      "text": " ( This is similar in the underlying implementation to the C++ example.\n   The defining word init-counter is like a constructor, where the create\n   part sets up an object's data and the does> part defines a class method.\n   The individual counters are like objects; multiple data, single method. )",
      "id": "3190a878facb0787ed19585459e829ce"
    },
    {
      "type": "html",
      "text": "init-counter ( n \"name\" -- )   create ,",
      "id": "04a9ad5f7e720e8821ffe0f3c6523e8c"
    },
    {
      "type": "code",
      "text": "   does> ( -- n++ )   dup >r  @  dup 1+  r> ! ;\n \\ or: does>  dup @  dup 1+ rot ! ;\n \\ or: does>  dup @  1 rot +! ;\n \\ or: does>  1 over +!  @ 1- ;  \\ omit '1-' for ( ++n )",
      "id": "586a7ae22d097489e35fb485a61507c8"
    },
    {
      "type": "html",
      "text": "counter ( \"name\" -- )   1 init-counter ;",
      "id": "f7f618a21c7710b0f1d71535d06c0e67"
    },
    {
      "type": "code",
      "text": " counter counter1\n counter counter2\n 10 init-counter counter3\n counter1 .\n >>> 1\n counter1 .\n >>> 2\n counter1 .\n >>> 3\n counter2 .  counter2 .  counter2 .\n >>> 1 2 3\n counter3 .  counter3 .  counter3 .\n >>> 10 11 12",
      "id": "c08b20534ba0d9f2572aef18ed83c7f9"
    },
    {
      "type": "html",
      "text": "\nNote that [[Forth Language]] doesn't support default argument values, so this implementation provides two words: <i>init-counter</i> which accepts an argument and <i>counter</i> which calls <i>init-counter</i> with an argument of 1.  Also, this suffers overflow problems similar to C++ and Java.",
      "id": "7abe26669825b68d88b8a350d72961be"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Haskell Language]]</b>:",
      "id": "bb83ebbb638f12387346b8be7f157802"
    },
    {
      "type": "code",
      "text": " import Data.IORef -- Haskell Hierarchical Libraries (GHC 5.04 and later & new versions of Hugs)\n -- \"import IOExts\" under the ancient hslibs",
      "id": "5eb4c5c64fbb50159a82389ab03f352b"
    },
    {
      "type": "html",
      "text": "makeCounter  ::<br>(Num n) => n -> IO (n -> IO n)",
      "id": "13e4c88b079e23b0a84b40137bbddc02"
    },
    {
      "type": "code",
      "text": " makeCounter  n = do r <- newIORef n\n                     return (counter r)\n     where counter r i = do modifyIORef r (+i)\n                            readIORef r",
      "id": "4459247c84739116b5eae82d2b76c589"
    },
    {
      "type": "code",
      "text": " Main> counter <- makeCounter 10\n Main> counter 33\n 43\n Main> counter 10\n 53",
      "id": "99d9143691cd92aaa2efc813f4a0b051"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "HQ9++",
      "id": "cf48701062fdb298e1a3e0cc0827194b"
    },
    {
      "type": "code",
      "text": " +",
      "id": "e3c9f47756494553f11e5e4caf5c4855"
    },
    {
      "type": "html",
      "text": "<i>This fails the definition of the test, since HQ9++ has only one counter, like its predecessor. (The object instantiated by ++ also should not be confused with the concurrent increment operations.)</i>",
      "id": "f95b2162abf3356a2a9817556f6e1774"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Icon Language]]</b>:",
      "id": "56215a6866af8d5795d84ff1b276d5eb"
    },
    {
      "type": "code",
      "text": "   # Each counter is a co-expression (coroutine-expression\n   local counter1, counter2\n   counter1 := create (1 to 1000)   # create co-expressions\n   counter2 := create (1 to 1000)",
      "id": "0319089fc517c5d7506eafba451bc593"
    },
    {
      "type": "code",
      "text": "   # Each activation with \"@\" returns old value and steps to next value\n   write(@counter1)\n   write(@counter1)\n   write(@counter1)\n   write(@counter2)",
      "id": "caf0ac7fa3e85792df73a2c49e2d8f60"
    },
    {
      "type": "html",
      "text": "produces",
      "id": "481bb9e4301e8180ce5ad844016506f6"
    },
    {
      "type": "code",
      "text": "   1\n   2\n   3\n   1",
      "id": "f87f68731946a3c7ed06491234aea030"
    },
    {
      "type": "html",
      "text": "\nIcon is particularly good at coroutines (and what it calls \"co-expressions\", as here). It's hard to see getting any simpler and more direct than this.",
      "id": "22c23b53906d7ad234ffbb06e828a5d0"
    },
    {
      "type": "html",
      "text": "\nNote that if you want it to start at something other than 1, you just say so, since this doesn't need to be wrapped in a function:",
      "id": "4ea49b6d2f9ccc42199bdf5472e82c17"
    },
    {
      "type": "code",
      "text": "   counter1 := create (n to 1000)",
      "id": "73477b2e229377c64f508440fe4d09de"
    },
    {
      "type": "html",
      "text": "Wrapping it in a function definition would make it <b>more</b> complicated rather than less. ",
      "id": "a1c2de8e73c11122c7bdb9683581456e"
    },
    {
      "type": "html",
      "text": "\nHowever, it should still be encapsulated in real code that used it more than once:",
      "id": "be58244d54475158fe5e57b078043036"
    },
    {
      "type": "code",
      "text": "   procedure makecounter(n)\n      /n := 1                      # supply default value if missing\n      return create (n to 1000)\n   end\n   procedure main()\n      local counter1, counter2\n      counter1 := makecounter()\n      counter2 := makecounter(1)\n      write(@counter1)\n      write(@counter1)\n      write(@counter1)\n      write(@counter2)\n   end",
      "id": "74a35b2eb2409705763b2cabe42fa017"
    },
    {
      "type": "html",
      "text": "<i>How would an Icon version look with no upper bound (or do I misunderstand the role of 1000 in above)? I mean a counter that does not overflow (i.e. will increment until memory is exhausted, if needed.)  Do you have to give an upper bound in Icon?  Do you have arbitrary precision types?  If not, what happens when you overflow?  I'm not bashing Icon here, I don't know anything about it --- so I am curious.</i>",
      "id": "613f7cd8f717c7679323aa05d01e4baf"
    },
    {
      "type": "html",
      "text": "\nIcon supports bignums, but not seamlessly the way that Scheme and some Lisps do, and the \"n to m\" mechanism unfortunately in particular does not seem to allow bignums to be used. I don't know why, since that seems stupid and easy to rectify in the design. There may be an alternate sequence mechanisms for bignums, I'm not sure.",
      "id": "af42155df67606ea25ea4c97b20b75d7"
    },
    {
      "type": "html",
      "text": "\nYou do not have to specify an upper bound, e.g. there is a \"seq()\" call that means \"1,2,3...\" without limit. I don't believe that it allows you to use the \"to\" mechanism without an upper bound; e.g. it would be sensible to allow \"(1 to)\" and assume the close paren meant \"no upper bound\", but that's not what it does, so you need to switch to \"seq()\". (Which itself optionally allows a lower and upper bound.)",
      "id": "15e40d3e1f4f24a47df53aad5ffbb9e6"
    },
    {
      "type": "html",
      "text": "\nThe language is built around \"success\" and \"failure\" events in places where most languages use boolean values, so e.g. loops continue until something inside the loop conditional <b>or</b> body <b>fails</b>, and then the loop stops. This supports goal-directed evaluation (backtracking) fairly seamlessly.",
      "id": "4108327c015f404e7beedc7c1f855986"
    },
    {
      "type": "html",
      "text": "\nI mention this because that is what I would expect to happen instead of overflow: the sequence generator should <b>fail</b>, and so would any enclosing conditional or loop or whatever; it would not be a silent failure as happens in e.g. C.",
      "id": "f84724e1a3a0ccd5e2afd49e3d4f1217"
    },
    {
      "type": "html",
      "text": "<i>Interesting.  One of these days I will have to look at Icon properly.  Do you have a feel for how these 'events' relate to the common lisp condition system?</i>",
      "id": "d1e0c14deda789570c1935a2197184ed"
    },
    {
      "type": "html",
      "text": "\nIt's a bit similar in feel, but the important difference is that Icon <b>fail</b> is a normal failure, not an error failure. For instance, one would loop searching for a character in a string, doing something with each match, and when the <b>find</b> finally failed, the search would terminate, and so would the loop. No error involved.",
      "id": "d9c29b575f5d122eba710ade1396b6e6"
    },
    {
      "type": "html",
      "text": "\nIcon doesn't have a boolean type at all; this kind of normal failure is used everywhere in the language that you'd ordinarily expect to see boolean #f/NIL/false, resulting in a powerful approach to pattern matching.",
      "id": "34610444f4c1b6682d51b1a6f23e5579"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Java Language]]</b>:",
      "id": "87562f718f193a7c20cdd87f75d6d274"
    },
    {
      "type": "code",
      "text": " // Each counter is an object instantiation of a class wrapping an int\n public class Counter \n {\n   private int value;\n   public Counter () { \n     this(1);\n   }\n   public Counter (int initialValue)  {\n     value = initialValue;\n   }\n   public int next () {\n     return value++;\n   } \n }",
      "id": "dca39f043c61d76fd313a02d858150ca"
    },
    {
      "type": "html",
      "text": "\nBoth the C++ and Java variants have a potential [[Fixed Quantity Overflow Bug]]. The counter below, however, is only limited by the available memory.",
      "id": "9851141c5e3e51b838b326b19eded454"
    },
    {
      "type": "code",
      "text": " import java.math.Big''''''Integer;",
      "id": "d236ff5715c0517137b2ea1ba0a2d73e"
    },
    {
      "type": "code",
      "text": " public class Big''''''Counter \n {\n   private Big''''''Integer value;\n   public Big''''''Counter () { \n     this(Big''''''Integer.ONE);\n   }\n   public Big''''''Counter (Big''''''Integer initialValue)  {\n     value = initialValue;\n   }\n   public Big''''''Integer next () {\n     Big''''''Integer returnValue = value;\n     value = value.add(Big''''''Integer.ONE);\n     return returnValue;\n   } \n }",
      "id": "12e480607048ac8c0aac62804d26b513"
    },
    {
      "type": "html",
      "text": "\nWhat do you guys think of [[Mike Cowlishaw]]'s [[Big Decimal]] proposal (JSR 13) - [http://www.jcp.org/en/jsr/detail?id=13 www.jcp.org] ? We used an early implementation of this on a project, and it seemed to work very well. --[[Paul Morrison]] ",
      "id": "e4b47e263351804c29cecdafae04d20d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Java Script]]</b>:",
      "id": "79aa5ad6a42550cc324834b065b2ba74"
    },
    {
      "type": "code",
      "text": " function counter(x) {\n   var c = x==undefined ? 1 : x;\n   return function () { return c++ }\n }",
      "id": "15cfbf58b2db5b8c97945bb73ff26e59"
    },
    {
      "type": "html",
      "text": "<i>Note: you can't use </i>c = x || 1<i> because it won't let you initialize a counter starting at zero.</i>",
      "id": "a5d032dae2561a320e5dd0971c136d52"
    },
    {
      "type": "html",
      "text": "\nThe count overflows when it exceeds the precision of a double-precision floating point mantissa.",
      "id": "2eaff5b93d26ea2b59a00e596a2c9303"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "[[Lisp One Point Five]]:",
      "id": "720ac8acc8f94d1673f99ac557bd7636"
    },
    {
      "type": "code",
      "text": "  define ((\n    (make-counter (lambda (x) (function (lambda () (setq x (+ x 1)) x))))\n  ))",
      "id": "00619b718fdad7a6a71ed3e714892dbb"
    },
    {
      "type": "html",
      "text": "\nThe initial value of the counter must be specified.  The integers could not get arbitrarily large.  The 7090 was a 36 bit machine, so I'm guessing this would break when the counter got past 2^35-1.  I don't know what would happen in this case.",
      "id": "29e04ea41a5675de6bfb296346b28e62"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>m4</b>:",
      "id": "b104f2580b4f564034368f4ee4f16b30"
    },
    {
      "type": "code",
      "text": " define(`defcounter',\n `define(`@counter_$1',ifelse(`$2',,0,`$2'))'dnl\n `define(`$1',\n  `define(`@counter_$1',incr(defn(`@counter_$1')))defn(`@counter_$1')')')",
      "id": "520a416489321a0f7175abc3e9b560eb"
    },
    {
      "type": "html",
      "text": "\nusage:",
      "id": "64200b87fa7ba499f23268893f9ac4ff"
    },
    {
      "type": "code",
      "text": " defcounter(c1)dnl\n defcounter(c2, 5000)dnl\n c1 c1 c2 c1 c2 c2     dnl Output: 1 2 5001 3 5002 5003",
      "id": "5bcc49f31bdd94251798251305b9da72"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Nemerle Language]]</b>:",
      "id": "d07a3befb9bca6ac4152fe57e6febd31"
    },
    {
      "type": "code",
      "text": " using System.Console;",
      "id": "4a55c1d91028c05d87fe15a39765c1ef"
    },
    {
      "type": "code",
      "text": " module Counter {\n     makeCounter(from: long): void -> long {\n         mutable n = from -1l;\n         fun() {++n; n}\n     }",
      "id": "3e260ea00dd5b4108102ec39142ca064"
    },
    {
      "type": "code",
      "text": "     // parameterless overload to provide default behaviour\n     makeCounter(): void -> long {\n         makeCounter(1l)\n     }",
      "id": "4fae8b2a97f241375baa4c95fb537276"
    },
    {
      "type": "html",
      "text": "Main():<br>void {",
      "id": "1e20bb2765f10567fcf5af937e902608"
    },
    {
      "type": "code",
      "text": "         def counter = makeCounter();\n         def counter5 = makeCounter(5l);",
      "id": "c745b8345be626c4080f908cd13881ef"
    },
    {
      "type": "code",
      "text": "         Write''''''Line(counter());\n         Write''''''Line(counter5());\n         Write''''''Line(counter());\n         Write''''''Line(counter5());\n         Write''''''Line(counter());\n         Write''''''Line(counter5());\n     }\n }",
      "id": "41a2915651e00f3dac96194847c0207a"
    },
    {
      "type": "html",
      "text": "\noutput:",
      "id": "4896ee41a880ee04b1e5f7f67dced49f"
    },
    {
      "type": "code",
      "text": " $ ./counter.exe\n 1\n 5\n 2\n 6\n 3\n 7",
      "id": "000804e3a38c20c34ae7ec531990ec91"
    },
    {
      "type": "html",
      "text": "\nthe long type is a 64bit integer, so it will overflow, but it'll at least take a while to do so...",
      "id": "401a0c254d9f0812a6638f86c296be07"
    },
    {
      "type": "html",
      "text": "\nor, i've just discovered that mono provides a [[Big Integer]] class, in the Mono.Math namespace (which is inexplicably contained in the Mono.Security assembly), which lets you write a counter that won't overflow, with the usual memory/cpu usage tradeoffs that bignums involve. --[[Mike Roome]]",
      "id": "f4c07f92ec85067b922801946049b686"
    },
    {
      "type": "html",
      "text": "\nYou can also use an approach similar to the first lisp version, and just create it directly with a lambda:",
      "id": "82812b41f63e7842463025f81f752e88"
    },
    {
      "type": "code",
      "text": " using System.Console;\n module M {\n     Main(): void {\n         def counter1 = {mutable n = 2; fun() {++n; n}}\n         def counter2 = {mutable n = 0; fun() {++n; n}}\n         Write''''''Line(counter1());\n         Write''''''Line(counter2());\n         Write''''''Line(counter1());\n         Write''''''Line(counter2());\n         Write''''''Line(counter1());\n         Write''''''Line(counter2())\n     }\n }",
      "id": "f4f1973cac54b17a2d4354c7a59ece51"
    },
    {
      "type": "html",
      "text": "\noutput:",
      "id": "4896ee41a880ee04b1e5f7f67dced49f"
    },
    {
      "type": "code",
      "text": " $ ./ncounter.exe\n 3\n 1\n 4\n 2\n 5\n 3",
      "id": "6651f64da162a013ec1a89e44d4366c2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Ocaml Language]]</b>:",
      "id": "207b8b76f1adca161b96adfe0cb54243"
    },
    {
      "type": "code",
      "text": " (* OCaml's partial application semantics prevent purely optional\n    arguments from appearing at the end, so we have to put an extra\n    \"unit\" argument at the end. *)\n let counter ?(n = 1) () =\n   let r = ref (n-1) in\n   fun () -> begin\n     incr r; !r\n   end",
      "id": "2c8913925197dbbcee207d82ab7d934a"
    },
    {
      "type": "html",
      "text": "\nThen:",
      "id": "8a0dfb9a5a1508e7a79628ac34a8fa91"
    },
    {
      "type": "code",
      "text": " # let x = counter ();;\n val x : unit -> int = <fun>\n # let y = counter ();;\n val y : unit -> int = <fun>\n # let z = counter ~n:5 ();;\n val z : unit -> int = <fun>\n # x ();;\n - : int = 1\n # x ();;\n - : int = 2\n # y ();;\n - : int = 1\n # z ();;\n - : int = 5\n # x ();;\n - : int = 3\n # y ();;\n - : int = 2\n # z ();;\n - : int = 6",
      "id": "b2becc08420ba47fec296dff33c786d4"
    },
    {
      "type": "html",
      "text": "\nThis overflows at the same time OCaml's integers do.  If you want arbitrary-precision arithmetic, you can use the Num module:",
      "id": "966dd32b4707934e91fb8b00cc3f289a"
    },
    {
      "type": "code",
      "text": " let counter ?(n = num_of_int 1) () =\n   let r = ref (pred_num n) in\n   fun () -> begin\n     incr_num r; !r\n   end",
      "id": "7bca6723cf8898ad2117418e0fdc5428"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Perl Language]]</b>:",
      "id": "68e504e17f65038d39e4200472e616d1"
    },
    {
      "type": "html",
      "text": "\nThere is more than one way to do it (of course), this one uses closures.",
      "id": "ffa54b85f6a3fae7013eca9b1674e3aa"
    },
    {
      "type": "html",
      "text": "sub Counter { my $n = @_ ? shift() :<br>1; sub { $n++ } }",
      "id": "3a846000efd5d2fe95a841f8a491104a"
    },
    {
      "type": "code",
      "text": " $counter = Counter;\n $counter5 = Counter 5;",
      "id": "0396c46e69948ba14cf52e23252329e7"
    },
    {
      "type": "code",
      "text": " print $counter->();   # prints 1\n print $counter->();   # prints 2\n print $counter5->();  # prints 5\n print $counter5->();  # prints 6\n print $counter->();   # prints 3",
      "id": "c43784041a15f18d880dac443ec2691f"
    },
    {
      "type": "html",
      "text": "<i>But wait! If you call now, we'll throw in the following absolutely free! ...</i>",
      "id": "5707f91a958278711b9a7e6caf279aff"
    },
    {
      "type": "code",
      "text": " $leadingzeros = Counter '000000000100';  #generates 000000000100, 000000000101, ...",
      "id": "43eb90795e6de15cc5844e40046eb944"
    },
    {
      "type": "code",
      "text": " $letters = Counter 'a';  # generates a, b, ... z, aa, ab, ...",
      "id": "c63f5165d71540f34788c49ea2f25324"
    },
    {
      "type": "code",
      "text": " $reallylongnumber = Counter '1'; # will generate count to as many digits as needed (till long after the sun burns out...)",
      "id": "adb9f225f8c32f79395c9a39f94ae3a1"
    },
    {
      "type": "html",
      "text": "\nYou can even start with a really long number:",
      "id": "f53e7cb60a3f5b47e4031cab68d9b9a0"
    },
    {
      "type": "code",
      "text": " $anotherlongnumber = Counter '1000000000000000000000000000000';",
      "id": "82387df146dcbe8d98b22f8fb6d94ef8"
    },
    {
      "type": "html",
      "text": "\nOr you can generate something like serial numbers.",
      "id": "ccf6e190c5bed75287952a0ddf7ac5af"
    },
    {
      "type": "code",
      "text": " $serialnumber = Counter 'ITEM000100';  # will produce ITEM000100, ITEM000101, ...",
      "id": "15f38345a64c7e9fc2a6c99c124754b8"
    },
    {
      "type": "html",
      "text": "(The magic auto-increment is documented in perlop.)",
      "id": "8811c3539dbbc07aaf3ca3e779311ddb"
    },
    {
      "type": "html",
      "text": "\nAlso, in the best traditions of modularity and bloat, here is the subclassable OO version.",
      "id": "495504aa60120d73bb39a45372f95d29"
    },
    {
      "type": "code",
      "text": " sub Counter::new { my ($c, $n) = @_; bless(\\$n, $c) }\n sub Counter::inc { my $self = shift; $$self++ }",
      "id": "0a17c16d8e202ec2bc64d0d662ce5e4b"
    },
    {
      "type": "code",
      "text": " $c = Counter->new(\"ITEM000\");\n print $c->inc, \"\\n\";\n print $c->inc, \"\\n\";",
      "id": "d66eae9b3b4be091253e612daad326be"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Python Language]]</b>: ",
      "id": "c93f3ba7f7031a5b8048e255f0727948"
    },
    {
      "type": "code",
      "text": " # Each counter is a coroutine counting with an int or long\n def Counter(n=1):\n     while 1:\n         yield n\n   n += 1",
      "id": "483a0d793fe12becacd51361c19ccafc"
    },
    {
      "type": "code",
      "text": " counter1 = Counter(3).next\n counter2 = Counter().next\n print counter1()\n >>> 3\n print counter2()\n >>> 1\n print counter1()\n >>> 4\n print counter2()\n >>> 2\n >>> clong1 = Counter(sys.maxint).next\n >>> clong1()\n 2147483647\n >>> clong1()\n 2147483648L\n >>> clong2 = Counter(sys.maxint**8).next\n >>> clong2()\n 452312846898269724422641179697543667450922081019251166843171382875033436161L",
      "id": "9b05c56470e13cc40039864a80fd35b2"
    },
    {
      "type": "html",
      "text": "The value of <i>n</i> automatically becomes an arbitrarily <i>long</i> integer beyond <i>sys.maxint</i>.  ",
      "id": "4929f42b0c35abee7ab3cc44aaf4076a"
    },
    {
      "type": "html",
      "text": "\nAn older solution:",
      "id": "c7c4981a91a760d801d758cc600efec1"
    },
    {
      "type": "code",
      "text": " class Counter:\n     def __init__(self, n=0):\n         self.n = n\n     def __call__(self):\n         self.n += 1\n         return self.n",
      "id": "113cb6aec7154d8f99e552075d31d4c1"
    },
    {
      "type": "code",
      "text": " >>> clong = Counter(sys.maxint-1)\n >>> print clong() # 2147483647\n >>> print clong() # 2147483648\n >>> print clong() # 2147483649",
      "id": "ff6dc611a816b44163f2842babab9bfa"
    },
    {
      "type": "html",
      "text": "\nThe short solution (requires a recent Python):",
      "id": "6f109488112fd031b36b412558521b5b"
    },
    {
      "type": "code",
      "text": " >>> import itertools\n >>> counter = itertools.count(1).next\n >>> counter()\n 1\n >>> counter()\n 2",
      "id": "6948ac0f2dc1f567c535ecaffe6ecdab"
    },
    {
      "type": "html",
      "text": "Alas the count wraps-around at sys.maxint.",
      "id": "f5d2ea3e9fc6507b38ff22c9c68a1d48"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Ruby Language]]</b>:",
      "id": "6907bfde22821df7970c575a5805ac23"
    },
    {
      "type": "code",
      "text": " def Counter(n=1)\n     proc do\n   result = n\n   n = n + 1\n   result\n     end\n end",
      "id": "2fbdcea39eb10f032820e9874943a6db"
    },
    {
      "type": "code",
      "text": " counter = Counter(3)\n counter2 = Counter()\n print counter.call()\n >>> 3\n print counter2.call()\n >>> 1\n print counter.call()\n >>> 4\n print counter2.call()\n >>> 2",
      "id": "f54399d304db961e52ae88023ddc9cfa"
    },
    {
      "type": "html",
      "text": "\nOr if you don't mind incrementing the counter before rather than after (like that Lisp version up above):",
      "id": "ba0cbafe9fc7e618fc6bfb5ce4a77569"
    },
    {
      "type": "code",
      "text": " def counter(n=0)  lambda {n += 1};  end",
      "id": "89d01296619ec04387ad6bc296328c4b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Ruby Language]]</b>, more traditional OO style:",
      "id": "a3b1d71355f8a41b4da33cd2744291a0"
    },
    {
      "type": "code",
      "text": "  class Counter\n      def initialize(n = 1) @value = n-1 end\n      def incr!() @value += 1; @value end\n      def value() @value+1 end\n  end",
      "id": "2a684f66a508a184c655ef7c685faa5a"
    },
    {
      "type": "html",
      "text": "\nThis also lets you get the current value of the counter without incrementing it.",
      "id": "f0bfa824f4eb3c47f57bb724ce742025"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Scheme Language]]</b>:",
      "id": "4f173a4ae0ce3fdb3c22c0e156ad9016"
    },
    {
      "type": "code",
      "text": " (define (make-counter . x)\n   ; validate argument\n   (let ((count (if (and\n                     (not (null? x))\n                     (integer? (car x)))\n                    (car x)\n                    1)))\n   ; return counter closure  \n     (lambda ()\n       (let ((current-count count))\n         (set! count (+ 1 count))\n         current-count))))",
      "id": "6049845aebdbc5238cbf0adbc20930a8"
    },
    {
      "type": "html",
      "text": "\nUsage:",
      "id": "579f0daebb2026359dcd861274652536"
    },
    {
      "type": "code",
      "text": " > (define counter (make-counter))\n > (counter)\n 1\n > (counter)\n 2\n > (counter)\n 3\n > (define counter2 (make-counter 10))\n > (counter2)\n 10\n > (counter2)\n 11\n > (counter2)\n 12\n > (define counter3 (make-counter 10.1))\n > (counter3)\n 1\n > (counter3)\n 2\n > (counter3)\n 3",
      "id": "0985ed1231d781ff3543bdb2ac68b626"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Sml Language]]</b>:",
      "id": "756630e9c3b4ef183d49ec6ebd7e0684"
    },
    {
      "type": "html",
      "text": "\nBelow is an interactive session with the SML/NJ compiler.  The\nlines starting with a dash contain the code.  The other lines\nhave been printed by the compiler.",
      "id": "99a8b6ee1bd8521052d18997c542eb5d"
    },
    {
      "type": "html",
      "text": "Standard ML of New Jersey v110.57 [built:<br>Fri Feb 10 21:37:49 2006]",
      "id": "b18627ed438bff44a34c296d01ba7221"
    },
    {
      "type": "code",
      "text": "  - val newCounter = (fn c => fn () => !c before c := !c + (1:IntInf.int)) o ref ;\n  [autoloading]\n  [library $SMLNJ-LIB/Util/smlnj-lib.cm is stable]\n  [library $basis.cm(=$SMLNJ-BASIS)/basis.cm is stable]\n  [autoloading done]\n  val newCounter = fn : IntInf.int -> unit -> IntInf.int\n  - val counterA = newCounter 1 ;\n  val counterA = fn : unit -> IntInf.int\n  - val counterB = newCounter 10000000000000000000 ;\n  val counterB = fn : unit -> IntInf.int\n  - counterA () ;\n  val it = 1 : IntInf.int\n  - counterB () ;\n  val it = 10000000000000000000 : IntInf.int\n  - counterA () ;\n  val it = 2 : IntInf.int\n  - counterB () ;\n  val it = 10000000000000000001 : IntInf.int\n  - counterB () ;\n  val it = 10000000000000000002 : IntInf.int\n  - counterA () ;\n  val it = 3 : IntInf.int",
      "id": "44ecf10879da91889976578c370a8109"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Verilog Hdl]]</b>:",
      "id": "44cc304bf79073ad784ea62528ba5b07"
    },
    {
      "type": "code",
      "text": " // 7 bit up counter synchronous active high reset and initial value\n // overflow output\n // positive edge triggered clock\n module Counter(clk,reset,load,init_value,count,overflow);\n parameter WIDTH=7; // number of bits",
      "id": "afa83f00b326248bd83fa881d236a5cd"
    },
    {
      "type": "code",
      "text": " input clk, reset, load;\n input [WIDTH-1:0] init_value;\n output [WIDTH-1:0] count;\n output overflow;",
      "id": "0850e40a362ffe07a53441856d22e3ab"
    },
    {
      "type": "code",
      "text": " reg [WIDTH-1:0] count;\n reg overflow;",
      "id": "9bdd44593bed05cf8cdceefb1cfb09be"
    },
    {
      "type": "code",
      "text": " always @(posedge clk) begin\n   if (reset) begin\n     count <= 1;\n     overflow <= 0;\n   end else if (load) begin\n     count <= init_value;\n     overflow <= 0;\n   end else begin     \n     if (&(count))\n       overflow <= 1;\n     count <= count + 1;\n   end",
      "id": "0384f6d6aa877da2a082a02ad7275f29"
    },
    {
      "type": "code",
      "text": " endmodule",
      "id": "d0f09ea9d67c137b10ac05badb5f88d2"
    },
    {
      "type": "code",
      "text": " Counter       count1(...); // 7-bit counter (default)\n Counter #(23) count2(...); // 23-bit counter\n Counter #(531) count3(...); // 531-bit counter (might cause timing problems ...)",
      "id": "3801c54940aca0393cac0874b6171d2e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Vhdl Language]]</b>:",
      "id": "b2a2808e5f126c31e570e0582f53d402"
    },
    {
      "type": "code",
      "text": "    -- 7-bit synchronous up-counter with asynchronous active-high reset\n    library ieee;\n    use ieee.std_logic_1164.all;\n    use ieee.std_logic_arith.all;\n    use ieee.std_logic_unsigned.all;",
      "id": "f5c99397229a1ef783a1e6ce65a577ca"
    },
    {
      "type": "code",
      "text": "    -- the interface of the counter\n    entity counter is\n      port(\n        CLK    : in std_logic;\n        RST    : in std_logic;",
      "id": "14b65ca24dc6d88d4be52902818e8021"
    },
    {
      "type": "html",
      "text": "O\t\t:<br>out std_logic_vector(6 downto 0));",
      "id": "427542b7ec6aa3625f0ead388e0d38ed"
    },
    {
      "type": "code",
      "text": "    end entity;",
      "id": "d680d11c84d59c210f6afb84255fc2a2"
    },
    {
      "type": "code",
      "text": "    -- the rtl architecture of the entity. One entity can have multiple\n    -- architectures, the appropriate architecture being selected at\n    -- instantation.\n    architecture rtl of counter is\n      signal value    : std_logic_vector(6 downto 0);\n    begin\n      -- sequential process\n      process (CLK,RST)\n      begin\n        -- reset logic\n        if (RST = '1') then\n          value <= (others => '0');",
      "id": "c314cc2ee649ffccb3c4af722ba17cfc"
    },
    {
      "type": "code",
      "text": "        -- increment counter on the rising edge of the clock\n        elsif (rising_edge(CLK)) then\n          value <= value + 1;\n        end if;\n      end process;",
      "id": "c1783d432306e8dc0dfced2916a0e7ed"
    },
    {
      "type": "code",
      "text": "      -- concurrent statement to output the counter value\n      O <= value;\n    end rtl;",
      "id": "c9abc152e75a98db63fdf2102f31af6b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Extended Object Tcl]]</b>",
      "id": "3c596c36c2e84479544dd02047b2b78a"
    },
    {
      "type": "html",
      "text": "\nSomeone else can provide an interesting version for the pure [[Tool Command Language]].",
      "id": "f3556abe2d1a57d4fded24fa394352c2"
    },
    {
      "type": "code",
      "text": " Class Counter -parameter {count 1}",
      "id": "9b9c5064dad4e546dcb20c2a9ba46688"
    },
    {
      "type": "code",
      "text": " Counter instproc next {} {\n    my instvar count",
      "id": "fc93ff6cb53d28e2c9ab4f29e9d59e6e"
    },
    {
      "type": "code",
      "text": "    set result $count\n    incr count\n    return $result\n }",
      "id": "1f160650cbe3fd234922ef784c61afb8"
    },
    {
      "type": "html",
      "text": "\nHow to use it:",
      "id": "1079532c8c5f13555ae76c977cdf472f"
    },
    {
      "type": "code",
      "text": " Counter basicCounter\n puts [basicCounter next]",
      "id": "4d52da9a044cc95b8c47b4370614c09f"
    },
    {
      "type": "code",
      "text": " ==> 1",
      "id": "71a2e61c3687ff4f417615a035772314"
    },
    {
      "type": "code",
      "text": " Counter basicCounter -count 5\n puts [basicCounter next]",
      "id": "1fff76b576f62ddd09481ca70f2a3445"
    },
    {
      "type": "code",
      "text": " ==> 5 ",
      "id": "53d2df3f49a0a42b4df3ae7d89fdb03a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "[[My Future Language]]",
      "id": "8828cce5002df91b957dbfb331e3ac32"
    },
    {
      "type": "code",
      "text": " counter :=\n   | n | \\ n...Infinity",
      "id": "d06819fe0fae9c2b8064dae0934e4658"
    },
    {
      "type": "code",
      "text": " #counter is defined as\n #      if given one argument (pattern-matching ''a l�'' MlLanguage, also RubyLanguage syntax lookalike ;))\n #         , the function (\\ = lambda)\n #            which returns the value that n...Infinity generates\n #             (where x...y is a generator ''a l�'' IconLanguage)\n #(Usage is:\n # myVar := counter(1)\n # print myVar\n # print myVar",
      "id": "cac7735cc269017bd99d11990f0cc70e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "[[Io Language]]:",
      "id": "4cd48abeb992f3da226d9718ce847074"
    },
    {
      "type": "code",
      "text": " counter := Object clone do(\n   count := 1\n   withValue := method(n, count := n)\n   count := method(\n     count = count + 1\n     count - 1\n   )\n )",
      "id": "83a8e820185ed82ada0aed2de337d770"
    },
    {
      "type": "code",
      "text": " c1 := counter clone\n c1 count print\n c1 count print",
      "id": "10e1396657f3a9b8ad996a9df49cce18"
    },
    {
      "type": "code",
      "text": " c2 := counter clone withValue(100)\n c2 count print\n c2 count print",
      "id": "bb8550481df90166214b9665fbbc64a6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Php Language]]</b> 5.3+",
      "id": "b3689d21ca80debdd1cf29ef1d74436e"
    },
    {
      "type": "code",
      "text": " function Counter($val = 1) {\n   return function() use (&$val) { return $val++; };\n }",
      "id": "8e09ecb2ee3ac007b3872affc7694cdd"
    },
    {
      "type": "html",
      "text": "\n[[Php Language]] pre-5.3 version ;)",
      "id": "f3090e4dba91e554771db82e60e42834"
    },
    {
      "type": "code",
      "text": " function Counter($val = 1) {\n   return create_function('', 'static $val = '.$val.'; return $val++;');\n }",
      "id": "596e786dfc664a8e14105f65257e67c0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "<b>[[Objective Cee]]</b>\nusing Blocks on MacOSX 10.6+",
      "id": "5ad5f1757d726489b726bc5b4ac0d8a7"
    },
    {
      "type": "code",
      "text": " typedef int (^IntGenerator)();\n IntGenerator Counter(int val) {\n   __block int _val = val;\n   return [[^() { return _val++; } copy] autorelease];\n }",
      "id": "2ea4010aab4310848c7a1863fb711f50"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "[[Go Language]]",
      "id": "f685619e2ed0d04e99ca1645bdeda4e2"
    },
    {
      "type": "code",
      "text": " func Counter(val int) func() int {\n   return func() int {\n     val++\n     return val\n   }\n }",
      "id": "b8ee531a6035406ba392332d45091c12"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "[[Swift Language]]",
      "id": "a666d867762ee6694de8cd16d81634eb"
    },
    {
      "type": "html",
      "text": "\nfunc Counter(var val: Int) -> () -> Int {",
      "id": "53b460acb78f50d4ca5c02105d49c729"
    },
    {
      "type": "code",
      "text": "  return {\n    val++\n    return val\n  }",
      "id": "8099825e89f1bad7ac3bb4f62cb6646a"
    },
    {
      "type": "html",
      "text": "}",
      "id": "a4fd9b962dd580c8d0c5cec013f98c76"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "See [[Array Sum In Many Programming Languages]], [[Dot Product In Many Programming Languages]], [[Ward Number In Many Programming Languages]], [[Hello World In Many Programming Languages]]",
      "id": "2eb8c996e7b908d37baefa00ba17b69a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
    },
    {
      "type": "html",
      "text": "[[Category In Many Programming Languages]]",
      "id": "2a4bceaac337aa0af443027b17775760"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?CounterInManyProgrammingLanguages c2.com]",
      "id": "f9c293ff8030901aa79eaebaf1ab9509"
    }
  ],
  "journal": [
    {
      "date": 1402923235000,
      "id": "5a06427a7a2f5e607687d649390d8814",
      "type": "create",
      "item": {
        "title": "Counter In Many Programming Languages",
        "story": [
          {
            "type": "html",
            "text": "The Problem (Originally from [[Python Vs Ruby]]):",
            "id": "4fd84d1bf4aad23eebe975e1179ae4f0"
          },
          {
            "type": "html",
            "text": " A counter may be initialised with a value or defaults to an initial value of 1.  When called, it:",
            "id": "efa8e1ecbe12547464f1ce3ca00d7935"
          },
          {
            "type": "html",
            "text": " returns its current value; and",
            "id": "3d9e84f082d9171d8ddac563fcfc1d4b"
          },
          {
            "type": "html",
            "text": " increments its current value",
            "id": "27d5e6767a120d1584ad13510f0e6cd3"
          },
          {
            "type": "html",
            "text": " The exact internal implementation is less important than the output behaviour - feel free to set current value to 1 less than the value given if you feel that pre-incrementing gives a cleaner implementation in your language.",
            "id": "58119ceb56d3cefb6de4ff0aea406e4e"
          },
          {
            "type": "html",
            "text": " The counter should be such that any number of individual counters can be instantiated.",
            "id": "2fad201b0358fb8169331bad9ba3f665"
          },
          {
            "type": "html",
            "text": " If the counter is unable to handle integers of arbitrary size, this should be stated.",
            "id": "a3e1465982ccb6256bf9a4dfb04e7e86"
          },
          {
            "type": "html",
            "text": "\nOf particular interest, of course, is the counter's behavior when an overflow condition exists.  Some languages mentioned below do not provide fixed-precision numeric types; thus overflow doesn't happen (until you run out of memory--shortly after the universe collapses in on itself).  Others provide only fixed-precision types (and thus risk overflow); though in many cases the amount of precision provided [[Should Be]] more than adequate for most applications.  (But if it isn't...)  None seems to handle an overflow condition gracefully, except [[Lisp Language]], [[Python Language]], and [[Ruby Language]], whose integers will be automatically ([[Under The Hood]]) upgraded to bignums when fixnum range is exceeded.  The [[Sml Language]] (Basis Library) supports fixed width integers with overflow causing an exception (e.g. the Int32 module), fixed width unsigned integers with modular arithmetic (e.g. the Word32 module), and arbitrary precision integers (the [[Int Inf]] module).   (See [[Type Migration]])",
            "id": "b269cf66ad0e57ca0c8f1f50de03eb6d"
          },
          {
            "type": "html",
            "text": "\nSee also: [[Accumulator Generator]]",
            "id": "8a123d57cb601e9eea262d88126ad692"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "Intel 80X86/Pentium <b>[[Assembly Language]]</b>:",
            "id": "3e7caeeeef12fff65006dd29e4cfe109"
          },
          {
            "type": "code",
            "text": " ;;; counter.asm",
            "id": "628356035e35cf82190dab81ace6ea62"
          },
          {
            "type": "code",
            "text": " %assign SYS_EXIT  1",
            "id": "e9df576643198ac813447e10c9ca6404"
          },
          {
            "type": "code",
            "text": "  ;; -------------------------\n  ;; data segment\n  ;; -------------------------",
            "id": "25590f4e41c7dd6b717fad5e7e0ca31c"
          },
          {
            "type": "code",
            "text": "  section  .data\n counter      dw  1\n countstring  dd  0\n        \n  ;; -------------------------\n  ;; code area\n  ;; -------------------------",
            "id": "55de6b93492d8cb713ce5b9cdc875eaa"
          },
          {
            "type": "code",
            "text": "  section  .text\n  global  _start",
            "id": "fe78b44a8f4496fddf24ee7d77b2e4bd"
          },
          {
            "type": "html",
            "text": "_start:<br>call  incCounter",
            "id": "68b82056bcfba14b7d631d361d55f1b7"
          },
          {
            "type": "code",
            "text": "        \n  ;; exit()",
            "id": "32b02b63b8cdd20dae3156c526d7858a"
          },
          {
            "type": "code",
            "text": "  mov  eax,SYS_EXIT\n  mov  ebx,0\n  int  0x80    ; final system call",
            "id": "405fcd895339ff8c61e55e1bab310264"
          },
          {
            "type": "code",
            "text": " ;-----------------------------------\n ;incCounter: prints current value\n ;and increments counter\n ;Registers modified:EAX,EBX,ECX,EDX\n ;-----------------------------------",
            "id": "6a25cdd96af50b17baf294217a9ab70b"
          },
          {
            "type": "code",
            "text": " incCounter:",
            "id": "2e82c9411670dabcc2f316466ec87e6e"
          },
          {
            "type": "code",
            "text": " ;;calculate ascii string to print\n        mov             edx,0                 ; keep track of number of digits\n        mov             ax,[counter]          ; get the current value of the counter\n        lea             ecx,[countstring + 3] ; load location to store string in, starting at last byte\n        mov             dl,10                 ; print a base ten number \n                                              ; of no more than four digits by finding\n nextdig: div             dl                    ; the ascii code of the LSD, storing it\n        add             ah,48\n        mov             [ecx],ah\n        inc             edx\n        cmp             al,0\n        je              icprint               ; if this is the last digit, print it\n        cmp             edx,4\n        je              icprint               ; if this is the fourth digit, print it\n        dec             ecx\n        xor             ah,ah\n        jmp             nextdig",
            "id": "1f387f40239687cce69f509fec274561"
          },
          {
            "type": "html",
            "text": "icprint:<br>",
            "id": "9a8807a955db104fff6192c750e06eea"
          },
          {
            "type": "code",
            "text": "        mov             eax,SYs_WRITE\n        mov             ebx,STDOUT\n        int             0x80",
            "id": "5f4c38b1012af413ea8acb1d6d17c010"
          },
          {
            "type": "code",
            "text": " ;; increment the counter\n        add             word [counter],1",
            "id": "c62954301a18512b05e140e49ff44746"
          },
          {
            "type": "code",
            "text": "        ret",
            "id": "45733f78bf258e15b49990e29d66f7e5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Cee Language]]</b> (C9x):",
            "id": "a852ac6f1d8199dc8e0d0c9f19b21412"
          },
          {
            "type": "html",
            "text": "\nOverflows when the type long long overflows; as long long int is guaranteed to be at least 64 bits, this won't be for a while.",
            "id": "4febb4e1af6d1eadd1da0a248fd5cb10"
          },
          {
            "type": "html",
            "text": "\nPseudo-OO; to the extent that you can do OO in C.  ",
            "id": "a90f88b5b3d10ebf98fbf36bd36cf04e"
          },
          {
            "type": "html",
            "text": "\nDoesn't do any error checking.",
            "id": "f8fb73df5d871e33fb44530732f76140"
          },
          {
            "type": "code",
            "text": " struct Counter {\n     long long int value_;\n };",
            "id": "8393e377b407b5ef0e6506d2c093af08"
          },
          {
            "type": "code",
            "text": " void counterInit (struct Counter *ctr) {\n     ctr->value_ = 1;\n }",
            "id": "28337df32980e922dffdd44b99293e72"
          },
          {
            "type": "code",
            "text": " void counterInitToValue (struct Counter *ctr, long long int value) {\n     ctr->value_ = value;\n }",
            "id": "e2a4999c169efd383e263d7af3f93ee2"
          },
          {
            "type": "code",
            "text": " long long int counterNext (struct Counter *ctr) {\n     return ctr->value_++;\n }",
            "id": "494b90c0e7048ce6129fd2108505d77f"
          },
          {
            "type": "code",
            "text": " int main (void) \n {\n     struct Counter *ctr1 = malloc(sizeof (struct Counter));\n     struct Counter *ctr2 = malloc(sizeof (struct Counter));",
            "id": "bf1e29bca746897455b8d7301ce7a199"
          },
          {
            "type": "code",
            "text": "     counterInit (ctr1);\n     counterInitToValue (ctr2,5000);\n     printf (\"Ctr 1: %d\\n\", counterNext(ctr1));\n     printf (\"Ctr 1: %d\\n\", counterNext(ctr1));\n     printf (\"Ctr 2: %d\\n\", counterNext(ctr2));\n     printf (\"Ctr 1: %d\\n\", counterNext(ctr1));\n     printf (\"Ctr 2: %d\\n\", counterNext(ctr2));\n     printf (\"Ctr 2: %d\\n\", counterNext(ctr2));",
            "id": "16c1fe8d6a83b8435bacdffde4f16668"
          },
          {
            "type": "code",
            "text": "     return 0;\n }",
            "id": "749be55f04496101cc38616717d081ef"
          },
          {
            "type": "html",
            "text": ">>> Ctr 1:<br>1",
            "id": "867252db4f53310736fcbdf07f7c3d4a"
          },
          {
            "type": "html",
            "text": ">>> Ctr 1:<br>2",
            "id": "a6d75a995e9d0d214791bbe565af0f23"
          },
          {
            "type": "html",
            "text": ">>> Ctr 2:<br>5000",
            "id": "4313bbb5b69cdfb1a3a65e52af0b276a"
          },
          {
            "type": "html",
            "text": ">>> Ctr 1:<br>3",
            "id": "e4093f01d94a6f50da6412b34a29aa80"
          },
          {
            "type": "html",
            "text": ">>> Ctr 2:<br>5001",
            "id": "367b838bbf61ba0b5d3cc4e2cb621420"
          },
          {
            "type": "html",
            "text": ">>> Ctr 2:<br>5002",
            "id": "96b2e5a6b7f60ecd7ade12192e394df6"
          },
          {
            "type": "html",
            "text": "\nNot very interesting; but does kinda show why OO is cool, and exposes lots of the dirty work that the programmer needs to do in a low-level language like C.",
            "id": "dd58b179ee2b39c3df72cbd8a1c586b0"
          },
          {
            "type": "html",
            "text": "''How does this show how OO is cool? This does not smell like an idiomatic C example. -- [[Anonymous Donor]]",
            "id": "fbc582422ec7507c27860786c09d2729"
          },
          {
            "type": "html",
            "text": "\nI think he's trying to say that this would be a lot more impressive if it <i>was</i> OO, but it just looks hackish in C.",
            "id": "03d9aa7118c5e3bff005c4e2e1bc673f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Cee Plus Plus]]</b>:",
            "id": "be0ebe8aa9b52f2cb2bc17494c04decd"
          },
          {
            "type": "html",
            "text": "\njust plain C++; not an example of [[Templates Gone Mad]].  We'll use just plain old ints:",
            "id": "e4336e4b2ae87008b2d57a1469f4216b"
          },
          {
            "type": "code",
            "text": " // Each counter will be an instantiation of the Counter class\n class Counter \n {\n   private:\n     int val_;\n   public:\n     Counter (int val = 1) : val_(val) {}\n     int next () {\n        return val_++;\n     } \n  };",
            "id": "68d3ea52bdbba69f0ab8cd0af2f6fb04"
          },
          {
            "type": "html",
            "text": "\nOr, if you prefer the type of the counter to be a parameter,",
            "id": "085323ac77bd4922345d589882f36f6c"
          },
          {
            "type": "code",
            "text": " // Each counter will be an instantiation of the Counter template class,\n // specialized on a numeric type (typically int or some bignum class)\n template <class T>\n class Counter \n {\n   private:\n     T val_;\n   public:\n     Counter (T val = 1) : val_(val) {}\n     T next () {\n        return val_++;\n     } \n  };",
            "id": "9729ba0d7bf1eca3578f995dce77cff7"
          },
          {
            "type": "html",
            "text": "\n[[Cee Plus Plus Eleven]] version using lambdas:",
            "id": "a872e924cbb4060a717e57c8bd121053"
          },
          {
            "type": "code",
            "text": " #include <functional>",
            "id": "f304cc4d495ac52e943d4932719b7845"
          },
          {
            "type": "code",
            "text": " template <class T>\n auto Counter(T val = 1) -> std::function<T()> {\n   return [=]() mutable { return val++; };\n }",
            "id": "4e0b04d2cb0cba8dbd7fb17d9c63d31e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Common Lisp]]</b>:",
            "id": "cf33d985fce02e78f8c541d96214c815"
          },
          {
            "type": "html",
            "text": "\none simple possibility: ",
            "id": "91bc46feb6188d8f3fb68adf884c5390"
          },
          {
            "type": "code",
            "text": " ;; Each counter is a lambda closure\n (setf counter1 (let ((n 2)) (lambda () (incf n))))\n (setf counter2 (let ((n 0)) (lambda () (incf n))))\n CL-USER> (funcall counter1)\n 3\n CL-USER> (funcall counter2)\n 1\n CL-USER> (funcall counter1)\n 4\n CL-USER> (funcall counter2)\n 2",
            "id": "2c98658c56e59213601718353decba9e"
          },
          {
            "type": "html",
            "text": "\nThis may look a little odd to people used to thinking about 'factories' or objects to abstract this sort of thing.  Due to first-class functions and the properties of closure, a simple form produces a function object which behaves like the above counters.",
            "id": "3fe02c55548ce39d9758a1bd0f400234"
          },
          {
            "type": "html",
            "text": "\nAnother possibility (there are others as well, of course).  Wrapped up as a counter-factory function:",
            "id": "0e08ef0594342b8b321fecfbfbf47479"
          },
          {
            "type": "code",
            "text": " ;; Counters are created by a wrapper around a lambda closure\n (defun make-counter (&optional (n 1))\n   (lambda ()\n     (prog1 n (incf n))))",
            "id": "f6686a7c78fa4dfac768597d0fe87671"
          },
          {
            "type": "code",
            "text": " (setf counter (make-counter 3))\n (setf counter2 (make-counter))",
            "id": "e7b64e6959a03c0fca9668c14a0ac298"
          },
          {
            "type": "code",
            "text": " CL-USER> (funcall counter)\n 3\n CL-USER> (funcall counter2)\n 1\n CL-USER> (funcall counter)\n 4\n CL-USER> (funcall counter2)\n 2",
            "id": "2e5062a10ea8fa026e23cf30d5cafd6e"
          },
          {
            "type": "html",
            "text": "\nThere is a trade-off here.  The second approach abstracts the 'counter' idea behind a 'factory' function to use the analogy of this page.  However, you may need to look at the definition of make-counter to remember what the semantics are (this is true of all the factory approaches on this page).  The simple lambda form is more verbose, but still concise and has the advantage that you know exactly what is happening by looking at a single line of code.  The choice of what is better depends on the context in which it is used.",
            "id": "7d994815c4da50c8e493bb36296203da"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Csharp Language]]</b> ",
            "id": "9a417018783ad26ad22d069de2e088c0"
          },
          {
            "type": "code",
            "text": " using System;",
            "id": "be197217193dd7315ed462052ad82ddf"
          },
          {
            "type": "code",
            "text": " class Test\n {\n     static Func<int> F()\n     {\n         int x = 0;\n         return delegate { return ++x; };\n     }",
            "id": "70f5974d054555e4128d4bf8d44194db"
          },
          {
            "type": "code",
            "text": "     static void Main()\n     {\n        var d = F();\n        Console.Write''''''Line(d());\n        Console.Write''''''Line(d());\n        Console.Write''''''Line(d());\n     }\n }",
            "id": "d8cc8656f6dc22895e7730b8aaa388a0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "Dodo [http://dodo.sourceforge.net dodo.sourceforge.net]",
            "id": "39aab3ba4c2cdc8c81458bd2ac6480e4"
          },
          {
            "type": "code",
            "text": " yield int counter(int n)\n {\n   loop:\n      return n\n      ++.n.\n }\n def c() = counter(5)",
            "id": "716f3972ab621a1edd31c9d42f01dc3e"
          },
          {
            "type": "html",
            "text": "Or equivalently",
            "id": "d447caa6bdd21b8760b28388bf35b7ea"
          },
          {
            "type": "code",
            "text": " def c() = for (n in 5...).value",
            "id": "8d62ce2ed449cde9d8687675c61ff5e1"
          },
          {
            "type": "html",
            "text": "Io-style",
            "id": "c1b24b1b7be5ee19da2f7e66f4d6b1ee"
          },
          {
            "type": "code",
            "text": " def c = new struct()\n {\n    int counter = 1\n    method Next: Next()\n    {\n       .value = counter\n       ++.counter\n    } -> value int.\n }\n c.Next()    # 1\n c.Next()    # 2\n def k = new c(counter: 400)",
            "id": "2414282a02bd76b84287068ea9a8fcea"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Forth Language]]</b>:",
            "id": "410956b5c38ef04498786a59511face5"
          },
          {
            "type": "code",
            "text": " ( This is similar in the underlying implementation to the C++ example.\n   The defining word init-counter is like a constructor, where the create\n   part sets up an object's data and the does> part defines a class method.\n   The individual counters are like objects; multiple data, single method. )",
            "id": "3190a878facb0787ed19585459e829ce"
          },
          {
            "type": "html",
            "text": "init-counter ( n \"name\" -- )   create ,",
            "id": "04a9ad5f7e720e8821ffe0f3c6523e8c"
          },
          {
            "type": "code",
            "text": "   does> ( -- n++ )   dup >r  @  dup 1+  r> ! ;\n \\ or: does>  dup @  dup 1+ rot ! ;\n \\ or: does>  dup @  1 rot +! ;\n \\ or: does>  1 over +!  @ 1- ;  \\ omit '1-' for ( ++n )",
            "id": "586a7ae22d097489e35fb485a61507c8"
          },
          {
            "type": "html",
            "text": "counter ( \"name\" -- )   1 init-counter ;",
            "id": "f7f618a21c7710b0f1d71535d06c0e67"
          },
          {
            "type": "code",
            "text": " counter counter1\n counter counter2\n 10 init-counter counter3\n counter1 .\n >>> 1\n counter1 .\n >>> 2\n counter1 .\n >>> 3\n counter2 .  counter2 .  counter2 .\n >>> 1 2 3\n counter3 .  counter3 .  counter3 .\n >>> 10 11 12",
            "id": "c08b20534ba0d9f2572aef18ed83c7f9"
          },
          {
            "type": "html",
            "text": "\nNote that [[Forth Language]] doesn't support default argument values, so this implementation provides two words: <i>init-counter</i> which accepts an argument and <i>counter</i> which calls <i>init-counter</i> with an argument of 1.  Also, this suffers overflow problems similar to C++ and Java.",
            "id": "7abe26669825b68d88b8a350d72961be"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Haskell Language]]</b>:",
            "id": "bb83ebbb638f12387346b8be7f157802"
          },
          {
            "type": "code",
            "text": " import Data.IORef -- Haskell Hierarchical Libraries (GHC 5.04 and later & new versions of Hugs)\n -- \"import IOExts\" under the ancient hslibs",
            "id": "5eb4c5c64fbb50159a82389ab03f352b"
          },
          {
            "type": "html",
            "text": "makeCounter  ::<br>(Num n) => n -> IO (n -> IO n)",
            "id": "13e4c88b079e23b0a84b40137bbddc02"
          },
          {
            "type": "code",
            "text": " makeCounter  n = do r <- newIORef n\n                     return (counter r)\n     where counter r i = do modifyIORef r (+i)\n                            readIORef r",
            "id": "4459247c84739116b5eae82d2b76c589"
          },
          {
            "type": "code",
            "text": " Main> counter <- makeCounter 10\n Main> counter 33\n 43\n Main> counter 10\n 53",
            "id": "99d9143691cd92aaa2efc813f4a0b051"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "HQ9++",
            "id": "cf48701062fdb298e1a3e0cc0827194b"
          },
          {
            "type": "code",
            "text": " +",
            "id": "e3c9f47756494553f11e5e4caf5c4855"
          },
          {
            "type": "html",
            "text": "<i>This fails the definition of the test, since HQ9++ has only one counter, like its predecessor. (The object instantiated by ++ also should not be confused with the concurrent increment operations.)</i>",
            "id": "f95b2162abf3356a2a9817556f6e1774"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Icon Language]]</b>:",
            "id": "56215a6866af8d5795d84ff1b276d5eb"
          },
          {
            "type": "code",
            "text": "   # Each counter is a co-expression (coroutine-expression\n   local counter1, counter2\n   counter1 := create (1 to 1000)   # create co-expressions\n   counter2 := create (1 to 1000)",
            "id": "0319089fc517c5d7506eafba451bc593"
          },
          {
            "type": "code",
            "text": "   # Each activation with \"@\" returns old value and steps to next value\n   write(@counter1)\n   write(@counter1)\n   write(@counter1)\n   write(@counter2)",
            "id": "caf0ac7fa3e85792df73a2c49e2d8f60"
          },
          {
            "type": "html",
            "text": "produces",
            "id": "481bb9e4301e8180ce5ad844016506f6"
          },
          {
            "type": "code",
            "text": "   1\n   2\n   3\n   1",
            "id": "f87f68731946a3c7ed06491234aea030"
          },
          {
            "type": "html",
            "text": "\nIcon is particularly good at coroutines (and what it calls \"co-expressions\", as here). It's hard to see getting any simpler and more direct than this.",
            "id": "22c23b53906d7ad234ffbb06e828a5d0"
          },
          {
            "type": "html",
            "text": "\nNote that if you want it to start at something other than 1, you just say so, since this doesn't need to be wrapped in a function:",
            "id": "4ea49b6d2f9ccc42199bdf5472e82c17"
          },
          {
            "type": "code",
            "text": "   counter1 := create (n to 1000)",
            "id": "73477b2e229377c64f508440fe4d09de"
          },
          {
            "type": "html",
            "text": "Wrapping it in a function definition would make it <b>more</b> complicated rather than less. ",
            "id": "a1c2de8e73c11122c7bdb9683581456e"
          },
          {
            "type": "html",
            "text": "\nHowever, it should still be encapsulated in real code that used it more than once:",
            "id": "be58244d54475158fe5e57b078043036"
          },
          {
            "type": "code",
            "text": "   procedure makecounter(n)\n      /n := 1                      # supply default value if missing\n      return create (n to 1000)\n   end\n   procedure main()\n      local counter1, counter2\n      counter1 := makecounter()\n      counter2 := makecounter(1)\n      write(@counter1)\n      write(@counter1)\n      write(@counter1)\n      write(@counter2)\n   end",
            "id": "74a35b2eb2409705763b2cabe42fa017"
          },
          {
            "type": "html",
            "text": "<i>How would an Icon version look with no upper bound (or do I misunderstand the role of 1000 in above)? I mean a counter that does not overflow (i.e. will increment until memory is exhausted, if needed.)  Do you have to give an upper bound in Icon?  Do you have arbitrary precision types?  If not, what happens when you overflow?  I'm not bashing Icon here, I don't know anything about it --- so I am curious.</i>",
            "id": "613f7cd8f717c7679323aa05d01e4baf"
          },
          {
            "type": "html",
            "text": "\nIcon supports bignums, but not seamlessly the way that Scheme and some Lisps do, and the \"n to m\" mechanism unfortunately in particular does not seem to allow bignums to be used. I don't know why, since that seems stupid and easy to rectify in the design. There may be an alternate sequence mechanisms for bignums, I'm not sure.",
            "id": "af42155df67606ea25ea4c97b20b75d7"
          },
          {
            "type": "html",
            "text": "\nYou do not have to specify an upper bound, e.g. there is a \"seq()\" call that means \"1,2,3...\" without limit. I don't believe that it allows you to use the \"to\" mechanism without an upper bound; e.g. it would be sensible to allow \"(1 to)\" and assume the close paren meant \"no upper bound\", but that's not what it does, so you need to switch to \"seq()\". (Which itself optionally allows a lower and upper bound.)",
            "id": "15e40d3e1f4f24a47df53aad5ffbb9e6"
          },
          {
            "type": "html",
            "text": "\nThe language is built around \"success\" and \"failure\" events in places where most languages use boolean values, so e.g. loops continue until something inside the loop conditional <b>or</b> body <b>fails</b>, and then the loop stops. This supports goal-directed evaluation (backtracking) fairly seamlessly.",
            "id": "4108327c015f404e7beedc7c1f855986"
          },
          {
            "type": "html",
            "text": "\nI mention this because that is what I would expect to happen instead of overflow: the sequence generator should <b>fail</b>, and so would any enclosing conditional or loop or whatever; it would not be a silent failure as happens in e.g. C.",
            "id": "f84724e1a3a0ccd5e2afd49e3d4f1217"
          },
          {
            "type": "html",
            "text": "<i>Interesting.  One of these days I will have to look at Icon properly.  Do you have a feel for how these 'events' relate to the common lisp condition system?</i>",
            "id": "d1e0c14deda789570c1935a2197184ed"
          },
          {
            "type": "html",
            "text": "\nIt's a bit similar in feel, but the important difference is that Icon <b>fail</b> is a normal failure, not an error failure. For instance, one would loop searching for a character in a string, doing something with each match, and when the <b>find</b> finally failed, the search would terminate, and so would the loop. No error involved.",
            "id": "d9c29b575f5d122eba710ade1396b6e6"
          },
          {
            "type": "html",
            "text": "\nIcon doesn't have a boolean type at all; this kind of normal failure is used everywhere in the language that you'd ordinarily expect to see boolean #f/NIL/false, resulting in a powerful approach to pattern matching.",
            "id": "34610444f4c1b6682d51b1a6f23e5579"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Java Language]]</b>:",
            "id": "87562f718f193a7c20cdd87f75d6d274"
          },
          {
            "type": "code",
            "text": " // Each counter is an object instantiation of a class wrapping an int\n public class Counter \n {\n   private int value;\n   public Counter () { \n     this(1);\n   }\n   public Counter (int initialValue)  {\n     value = initialValue;\n   }\n   public int next () {\n     return value++;\n   } \n }",
            "id": "dca39f043c61d76fd313a02d858150ca"
          },
          {
            "type": "html",
            "text": "\nBoth the C++ and Java variants have a potential [[Fixed Quantity Overflow Bug]]. The counter below, however, is only limited by the available memory.",
            "id": "9851141c5e3e51b838b326b19eded454"
          },
          {
            "type": "code",
            "text": " import java.math.Big''''''Integer;",
            "id": "d236ff5715c0517137b2ea1ba0a2d73e"
          },
          {
            "type": "code",
            "text": " public class Big''''''Counter \n {\n   private Big''''''Integer value;\n   public Big''''''Counter () { \n     this(Big''''''Integer.ONE);\n   }\n   public Big''''''Counter (Big''''''Integer initialValue)  {\n     value = initialValue;\n   }\n   public Big''''''Integer next () {\n     Big''''''Integer returnValue = value;\n     value = value.add(Big''''''Integer.ONE);\n     return returnValue;\n   } \n }",
            "id": "12e480607048ac8c0aac62804d26b513"
          },
          {
            "type": "html",
            "text": "\nWhat do you guys think of [[Mike Cowlishaw]]'s [[Big Decimal]] proposal (JSR 13) - [http://www.jcp.org/en/jsr/detail?id=13 www.jcp.org] ? We used an early implementation of this on a project, and it seemed to work very well. --[[Paul Morrison]] ",
            "id": "e4b47e263351804c29cecdafae04d20d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Java Script]]</b>:",
            "id": "79aa5ad6a42550cc324834b065b2ba74"
          },
          {
            "type": "code",
            "text": " function counter(x) {\n   var c = x==undefined ? 1 : x;\n   return function () { return c++ }\n }",
            "id": "15cfbf58b2db5b8c97945bb73ff26e59"
          },
          {
            "type": "html",
            "text": "<i>Note: you can't use </i>c = x || 1<i> because it won't let you initialize a counter starting at zero.</i>",
            "id": "a5d032dae2561a320e5dd0971c136d52"
          },
          {
            "type": "html",
            "text": "\nThe count overflows when it exceeds the precision of a double-precision floating point mantissa.",
            "id": "2eaff5b93d26ea2b59a00e596a2c9303"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "[[Lisp One Point Five]]:",
            "id": "720ac8acc8f94d1673f99ac557bd7636"
          },
          {
            "type": "code",
            "text": "  define ((\n    (make-counter (lambda (x) (function (lambda () (setq x (+ x 1)) x))))\n  ))",
            "id": "00619b718fdad7a6a71ed3e714892dbb"
          },
          {
            "type": "html",
            "text": "\nThe initial value of the counter must be specified.  The integers could not get arbitrarily large.  The 7090 was a 36 bit machine, so I'm guessing this would break when the counter got past 2^35-1.  I don't know what would happen in this case.",
            "id": "29e04ea41a5675de6bfb296346b28e62"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>m4</b>:",
            "id": "b104f2580b4f564034368f4ee4f16b30"
          },
          {
            "type": "code",
            "text": " define(`defcounter',\n `define(`@counter_$1',ifelse(`$2',,0,`$2'))'dnl\n `define(`$1',\n  `define(`@counter_$1',incr(defn(`@counter_$1')))defn(`@counter_$1')')')",
            "id": "520a416489321a0f7175abc3e9b560eb"
          },
          {
            "type": "html",
            "text": "\nusage:",
            "id": "64200b87fa7ba499f23268893f9ac4ff"
          },
          {
            "type": "code",
            "text": " defcounter(c1)dnl\n defcounter(c2, 5000)dnl\n c1 c1 c2 c1 c2 c2     dnl Output: 1 2 5001 3 5002 5003",
            "id": "5bcc49f31bdd94251798251305b9da72"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Nemerle Language]]</b>:",
            "id": "d07a3befb9bca6ac4152fe57e6febd31"
          },
          {
            "type": "code",
            "text": " using System.Console;",
            "id": "4a55c1d91028c05d87fe15a39765c1ef"
          },
          {
            "type": "code",
            "text": " module Counter {\n     makeCounter(from: long): void -> long {\n         mutable n = from -1l;\n         fun() {++n; n}\n     }",
            "id": "3e260ea00dd5b4108102ec39142ca064"
          },
          {
            "type": "code",
            "text": "     // parameterless overload to provide default behaviour\n     makeCounter(): void -> long {\n         makeCounter(1l)\n     }",
            "id": "4fae8b2a97f241375baa4c95fb537276"
          },
          {
            "type": "html",
            "text": "Main():<br>void {",
            "id": "1e20bb2765f10567fcf5af937e902608"
          },
          {
            "type": "code",
            "text": "         def counter = makeCounter();\n         def counter5 = makeCounter(5l);",
            "id": "c745b8345be626c4080f908cd13881ef"
          },
          {
            "type": "code",
            "text": "         Write''''''Line(counter());\n         Write''''''Line(counter5());\n         Write''''''Line(counter());\n         Write''''''Line(counter5());\n         Write''''''Line(counter());\n         Write''''''Line(counter5());\n     }\n }",
            "id": "41a2915651e00f3dac96194847c0207a"
          },
          {
            "type": "html",
            "text": "\noutput:",
            "id": "4896ee41a880ee04b1e5f7f67dced49f"
          },
          {
            "type": "code",
            "text": " $ ./counter.exe\n 1\n 5\n 2\n 6\n 3\n 7",
            "id": "000804e3a38c20c34ae7ec531990ec91"
          },
          {
            "type": "html",
            "text": "\nthe long type is a 64bit integer, so it will overflow, but it'll at least take a while to do so...",
            "id": "401a0c254d9f0812a6638f86c296be07"
          },
          {
            "type": "html",
            "text": "\nor, i've just discovered that mono provides a [[Big Integer]] class, in the Mono.Math namespace (which is inexplicably contained in the Mono.Security assembly), which lets you write a counter that won't overflow, with the usual memory/cpu usage tradeoffs that bignums involve. --[[Mike Roome]]",
            "id": "f4c07f92ec85067b922801946049b686"
          },
          {
            "type": "html",
            "text": "\nYou can also use an approach similar to the first lisp version, and just create it directly with a lambda:",
            "id": "82812b41f63e7842463025f81f752e88"
          },
          {
            "type": "code",
            "text": " using System.Console;\n module M {\n     Main(): void {\n         def counter1 = {mutable n = 2; fun() {++n; n}}\n         def counter2 = {mutable n = 0; fun() {++n; n}}\n         Write''''''Line(counter1());\n         Write''''''Line(counter2());\n         Write''''''Line(counter1());\n         Write''''''Line(counter2());\n         Write''''''Line(counter1());\n         Write''''''Line(counter2())\n     }\n }",
            "id": "f4f1973cac54b17a2d4354c7a59ece51"
          },
          {
            "type": "html",
            "text": "\noutput:",
            "id": "4896ee41a880ee04b1e5f7f67dced49f"
          },
          {
            "type": "code",
            "text": " $ ./ncounter.exe\n 3\n 1\n 4\n 2\n 5\n 3",
            "id": "6651f64da162a013ec1a89e44d4366c2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Ocaml Language]]</b>:",
            "id": "207b8b76f1adca161b96adfe0cb54243"
          },
          {
            "type": "code",
            "text": " (* OCaml's partial application semantics prevent purely optional\n    arguments from appearing at the end, so we have to put an extra\n    \"unit\" argument at the end. *)\n let counter ?(n = 1) () =\n   let r = ref (n-1) in\n   fun () -> begin\n     incr r; !r\n   end",
            "id": "2c8913925197dbbcee207d82ab7d934a"
          },
          {
            "type": "html",
            "text": "\nThen:",
            "id": "8a0dfb9a5a1508e7a79628ac34a8fa91"
          },
          {
            "type": "code",
            "text": " # let x = counter ();;\n val x : unit -> int = <fun>\n # let y = counter ();;\n val y : unit -> int = <fun>\n # let z = counter ~n:5 ();;\n val z : unit -> int = <fun>\n # x ();;\n - : int = 1\n # x ();;\n - : int = 2\n # y ();;\n - : int = 1\n # z ();;\n - : int = 5\n # x ();;\n - : int = 3\n # y ();;\n - : int = 2\n # z ();;\n - : int = 6",
            "id": "b2becc08420ba47fec296dff33c786d4"
          },
          {
            "type": "html",
            "text": "\nThis overflows at the same time OCaml's integers do.  If you want arbitrary-precision arithmetic, you can use the Num module:",
            "id": "966dd32b4707934e91fb8b00cc3f289a"
          },
          {
            "type": "code",
            "text": " let counter ?(n = num_of_int 1) () =\n   let r = ref (pred_num n) in\n   fun () -> begin\n     incr_num r; !r\n   end",
            "id": "7bca6723cf8898ad2117418e0fdc5428"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Perl Language]]</b>:",
            "id": "68e504e17f65038d39e4200472e616d1"
          },
          {
            "type": "html",
            "text": "\nThere is more than one way to do it (of course), this one uses closures.",
            "id": "ffa54b85f6a3fae7013eca9b1674e3aa"
          },
          {
            "type": "html",
            "text": "sub Counter { my $n = @_ ? shift() :<br>1; sub { $n++ } }",
            "id": "3a846000efd5d2fe95a841f8a491104a"
          },
          {
            "type": "code",
            "text": " $counter = Counter;\n $counter5 = Counter 5;",
            "id": "0396c46e69948ba14cf52e23252329e7"
          },
          {
            "type": "code",
            "text": " print $counter->();   # prints 1\n print $counter->();   # prints 2\n print $counter5->();  # prints 5\n print $counter5->();  # prints 6\n print $counter->();   # prints 3",
            "id": "c43784041a15f18d880dac443ec2691f"
          },
          {
            "type": "html",
            "text": "<i>But wait! If you call now, we'll throw in the following absolutely free! ...</i>",
            "id": "5707f91a958278711b9a7e6caf279aff"
          },
          {
            "type": "code",
            "text": " $leadingzeros = Counter '000000000100';  #generates 000000000100, 000000000101, ...",
            "id": "43eb90795e6de15cc5844e40046eb944"
          },
          {
            "type": "code",
            "text": " $letters = Counter 'a';  # generates a, b, ... z, aa, ab, ...",
            "id": "c63f5165d71540f34788c49ea2f25324"
          },
          {
            "type": "code",
            "text": " $reallylongnumber = Counter '1'; # will generate count to as many digits as needed (till long after the sun burns out...)",
            "id": "adb9f225f8c32f79395c9a39f94ae3a1"
          },
          {
            "type": "html",
            "text": "\nYou can even start with a really long number:",
            "id": "f53e7cb60a3f5b47e4031cab68d9b9a0"
          },
          {
            "type": "code",
            "text": " $anotherlongnumber = Counter '1000000000000000000000000000000';",
            "id": "82387df146dcbe8d98b22f8fb6d94ef8"
          },
          {
            "type": "html",
            "text": "\nOr you can generate something like serial numbers.",
            "id": "ccf6e190c5bed75287952a0ddf7ac5af"
          },
          {
            "type": "code",
            "text": " $serialnumber = Counter 'ITEM000100';  # will produce ITEM000100, ITEM000101, ...",
            "id": "15f38345a64c7e9fc2a6c99c124754b8"
          },
          {
            "type": "html",
            "text": "(The magic auto-increment is documented in perlop.)",
            "id": "8811c3539dbbc07aaf3ca3e779311ddb"
          },
          {
            "type": "html",
            "text": "\nAlso, in the best traditions of modularity and bloat, here is the subclassable OO version.",
            "id": "495504aa60120d73bb39a45372f95d29"
          },
          {
            "type": "code",
            "text": " sub Counter::new { my ($c, $n) = @_; bless(\\$n, $c) }\n sub Counter::inc { my $self = shift; $$self++ }",
            "id": "0a17c16d8e202ec2bc64d0d662ce5e4b"
          },
          {
            "type": "code",
            "text": " $c = Counter->new(\"ITEM000\");\n print $c->inc, \"\\n\";\n print $c->inc, \"\\n\";",
            "id": "d66eae9b3b4be091253e612daad326be"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Python Language]]</b>: ",
            "id": "c93f3ba7f7031a5b8048e255f0727948"
          },
          {
            "type": "code",
            "text": " # Each counter is a coroutine counting with an int or long\n def Counter(n=1):\n     while 1:\n         yield n\n   n += 1",
            "id": "483a0d793fe12becacd51361c19ccafc"
          },
          {
            "type": "code",
            "text": " counter1 = Counter(3).next\n counter2 = Counter().next\n print counter1()\n >>> 3\n print counter2()\n >>> 1\n print counter1()\n >>> 4\n print counter2()\n >>> 2\n >>> clong1 = Counter(sys.maxint).next\n >>> clong1()\n 2147483647\n >>> clong1()\n 2147483648L\n >>> clong2 = Counter(sys.maxint**8).next\n >>> clong2()\n 452312846898269724422641179697543667450922081019251166843171382875033436161L",
            "id": "9b05c56470e13cc40039864a80fd35b2"
          },
          {
            "type": "html",
            "text": "The value of <i>n</i> automatically becomes an arbitrarily <i>long</i> integer beyond <i>sys.maxint</i>.  ",
            "id": "4929f42b0c35abee7ab3cc44aaf4076a"
          },
          {
            "type": "html",
            "text": "\nAn older solution:",
            "id": "c7c4981a91a760d801d758cc600efec1"
          },
          {
            "type": "code",
            "text": " class Counter:\n     def __init__(self, n=0):\n         self.n = n\n     def __call__(self):\n         self.n += 1\n         return self.n",
            "id": "113cb6aec7154d8f99e552075d31d4c1"
          },
          {
            "type": "code",
            "text": " >>> clong = Counter(sys.maxint-1)\n >>> print clong() # 2147483647\n >>> print clong() # 2147483648\n >>> print clong() # 2147483649",
            "id": "ff6dc611a816b44163f2842babab9bfa"
          },
          {
            "type": "html",
            "text": "\nThe short solution (requires a recent Python):",
            "id": "6f109488112fd031b36b412558521b5b"
          },
          {
            "type": "code",
            "text": " >>> import itertools\n >>> counter = itertools.count(1).next\n >>> counter()\n 1\n >>> counter()\n 2",
            "id": "6948ac0f2dc1f567c535ecaffe6ecdab"
          },
          {
            "type": "html",
            "text": "Alas the count wraps-around at sys.maxint.",
            "id": "f5d2ea3e9fc6507b38ff22c9c68a1d48"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Ruby Language]]</b>:",
            "id": "6907bfde22821df7970c575a5805ac23"
          },
          {
            "type": "code",
            "text": " def Counter(n=1)\n     proc do\n   result = n\n   n = n + 1\n   result\n     end\n end",
            "id": "2fbdcea39eb10f032820e9874943a6db"
          },
          {
            "type": "code",
            "text": " counter = Counter(3)\n counter2 = Counter()\n print counter.call()\n >>> 3\n print counter2.call()\n >>> 1\n print counter.call()\n >>> 4\n print counter2.call()\n >>> 2",
            "id": "f54399d304db961e52ae88023ddc9cfa"
          },
          {
            "type": "html",
            "text": "\nOr if you don't mind incrementing the counter before rather than after (like that Lisp version up above):",
            "id": "ba0cbafe9fc7e618fc6bfb5ce4a77569"
          },
          {
            "type": "code",
            "text": " def counter(n=0)  lambda {n += 1};  end",
            "id": "89d01296619ec04387ad6bc296328c4b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Ruby Language]]</b>, more traditional OO style:",
            "id": "a3b1d71355f8a41b4da33cd2744291a0"
          },
          {
            "type": "code",
            "text": "  class Counter\n      def initialize(n = 1) @value = n-1 end\n      def incr!() @value += 1; @value end\n      def value() @value+1 end\n  end",
            "id": "2a684f66a508a184c655ef7c685faa5a"
          },
          {
            "type": "html",
            "text": "\nThis also lets you get the current value of the counter without incrementing it.",
            "id": "f0bfa824f4eb3c47f57bb724ce742025"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Scheme Language]]</b>:",
            "id": "4f173a4ae0ce3fdb3c22c0e156ad9016"
          },
          {
            "type": "code",
            "text": " (define (make-counter . x)\n   ; validate argument\n   (let ((count (if (and\n                     (not (null? x))\n                     (integer? (car x)))\n                    (car x)\n                    1)))\n   ; return counter closure  \n     (lambda ()\n       (let ((current-count count))\n         (set! count (+ 1 count))\n         current-count))))",
            "id": "6049845aebdbc5238cbf0adbc20930a8"
          },
          {
            "type": "html",
            "text": "\nUsage:",
            "id": "579f0daebb2026359dcd861274652536"
          },
          {
            "type": "code",
            "text": " > (define counter (make-counter))\n > (counter)\n 1\n > (counter)\n 2\n > (counter)\n 3\n > (define counter2 (make-counter 10))\n > (counter2)\n 10\n > (counter2)\n 11\n > (counter2)\n 12\n > (define counter3 (make-counter 10.1))\n > (counter3)\n 1\n > (counter3)\n 2\n > (counter3)\n 3",
            "id": "0985ed1231d781ff3543bdb2ac68b626"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Sml Language]]</b>:",
            "id": "756630e9c3b4ef183d49ec6ebd7e0684"
          },
          {
            "type": "html",
            "text": "\nBelow is an interactive session with the SML/NJ compiler.  The\nlines starting with a dash contain the code.  The other lines\nhave been printed by the compiler.",
            "id": "99a8b6ee1bd8521052d18997c542eb5d"
          },
          {
            "type": "html",
            "text": "Standard ML of New Jersey v110.57 [built:<br>Fri Feb 10 21:37:49 2006]",
            "id": "b18627ed438bff44a34c296d01ba7221"
          },
          {
            "type": "code",
            "text": "  - val newCounter = (fn c => fn () => !c before c := !c + (1:IntInf.int)) o ref ;\n  [autoloading]\n  [library $SMLNJ-LIB/Util/smlnj-lib.cm is stable]\n  [library $basis.cm(=$SMLNJ-BASIS)/basis.cm is stable]\n  [autoloading done]\n  val newCounter = fn : IntInf.int -> unit -> IntInf.int\n  - val counterA = newCounter 1 ;\n  val counterA = fn : unit -> IntInf.int\n  - val counterB = newCounter 10000000000000000000 ;\n  val counterB = fn : unit -> IntInf.int\n  - counterA () ;\n  val it = 1 : IntInf.int\n  - counterB () ;\n  val it = 10000000000000000000 : IntInf.int\n  - counterA () ;\n  val it = 2 : IntInf.int\n  - counterB () ;\n  val it = 10000000000000000001 : IntInf.int\n  - counterB () ;\n  val it = 10000000000000000002 : IntInf.int\n  - counterA () ;\n  val it = 3 : IntInf.int",
            "id": "44ecf10879da91889976578c370a8109"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Verilog Hdl]]</b>:",
            "id": "44cc304bf79073ad784ea62528ba5b07"
          },
          {
            "type": "code",
            "text": " // 7 bit up counter synchronous active high reset and initial value\n // overflow output\n // positive edge triggered clock\n module Counter(clk,reset,load,init_value,count,overflow);\n parameter WIDTH=7; // number of bits",
            "id": "afa83f00b326248bd83fa881d236a5cd"
          },
          {
            "type": "code",
            "text": " input clk, reset, load;\n input [WIDTH-1:0] init_value;\n output [WIDTH-1:0] count;\n output overflow;",
            "id": "0850e40a362ffe07a53441856d22e3ab"
          },
          {
            "type": "code",
            "text": " reg [WIDTH-1:0] count;\n reg overflow;",
            "id": "9bdd44593bed05cf8cdceefb1cfb09be"
          },
          {
            "type": "code",
            "text": " always @(posedge clk) begin\n   if (reset) begin\n     count <= 1;\n     overflow <= 0;\n   end else if (load) begin\n     count <= init_value;\n     overflow <= 0;\n   end else begin     \n     if (&(count))\n       overflow <= 1;\n     count <= count + 1;\n   end",
            "id": "0384f6d6aa877da2a082a02ad7275f29"
          },
          {
            "type": "code",
            "text": " endmodule",
            "id": "d0f09ea9d67c137b10ac05badb5f88d2"
          },
          {
            "type": "code",
            "text": " Counter       count1(...); // 7-bit counter (default)\n Counter #(23) count2(...); // 23-bit counter\n Counter #(531) count3(...); // 531-bit counter (might cause timing problems ...)",
            "id": "3801c54940aca0393cac0874b6171d2e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Vhdl Language]]</b>:",
            "id": "b2a2808e5f126c31e570e0582f53d402"
          },
          {
            "type": "code",
            "text": "    -- 7-bit synchronous up-counter with asynchronous active-high reset\n    library ieee;\n    use ieee.std_logic_1164.all;\n    use ieee.std_logic_arith.all;\n    use ieee.std_logic_unsigned.all;",
            "id": "f5c99397229a1ef783a1e6ce65a577ca"
          },
          {
            "type": "code",
            "text": "    -- the interface of the counter\n    entity counter is\n      port(\n        CLK    : in std_logic;\n        RST    : in std_logic;",
            "id": "14b65ca24dc6d88d4be52902818e8021"
          },
          {
            "type": "html",
            "text": "O\t\t:<br>out std_logic_vector(6 downto 0));",
            "id": "427542b7ec6aa3625f0ead388e0d38ed"
          },
          {
            "type": "code",
            "text": "    end entity;",
            "id": "d680d11c84d59c210f6afb84255fc2a2"
          },
          {
            "type": "code",
            "text": "    -- the rtl architecture of the entity. One entity can have multiple\n    -- architectures, the appropriate architecture being selected at\n    -- instantation.\n    architecture rtl of counter is\n      signal value    : std_logic_vector(6 downto 0);\n    begin\n      -- sequential process\n      process (CLK,RST)\n      begin\n        -- reset logic\n        if (RST = '1') then\n          value <= (others => '0');",
            "id": "c314cc2ee649ffccb3c4af722ba17cfc"
          },
          {
            "type": "code",
            "text": "        -- increment counter on the rising edge of the clock\n        elsif (rising_edge(CLK)) then\n          value <= value + 1;\n        end if;\n      end process;",
            "id": "c1783d432306e8dc0dfced2916a0e7ed"
          },
          {
            "type": "code",
            "text": "      -- concurrent statement to output the counter value\n      O <= value;\n    end rtl;",
            "id": "c9abc152e75a98db63fdf2102f31af6b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Extended Object Tcl]]</b>",
            "id": "3c596c36c2e84479544dd02047b2b78a"
          },
          {
            "type": "html",
            "text": "\nSomeone else can provide an interesting version for the pure [[Tool Command Language]].",
            "id": "f3556abe2d1a57d4fded24fa394352c2"
          },
          {
            "type": "code",
            "text": " Class Counter -parameter {count 1}",
            "id": "9b9c5064dad4e546dcb20c2a9ba46688"
          },
          {
            "type": "code",
            "text": " Counter instproc next {} {\n    my instvar count",
            "id": "fc93ff6cb53d28e2c9ab4f29e9d59e6e"
          },
          {
            "type": "code",
            "text": "    set result $count\n    incr count\n    return $result\n }",
            "id": "1f160650cbe3fd234922ef784c61afb8"
          },
          {
            "type": "html",
            "text": "\nHow to use it:",
            "id": "1079532c8c5f13555ae76c977cdf472f"
          },
          {
            "type": "code",
            "text": " Counter basicCounter\n puts [basicCounter next]",
            "id": "4d52da9a044cc95b8c47b4370614c09f"
          },
          {
            "type": "code",
            "text": " ==> 1",
            "id": "71a2e61c3687ff4f417615a035772314"
          },
          {
            "type": "code",
            "text": " Counter basicCounter -count 5\n puts [basicCounter next]",
            "id": "1fff76b576f62ddd09481ca70f2a3445"
          },
          {
            "type": "code",
            "text": " ==> 5 ",
            "id": "53d2df3f49a0a42b4df3ae7d89fdb03a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "[[My Future Language]]",
            "id": "8828cce5002df91b957dbfb331e3ac32"
          },
          {
            "type": "code",
            "text": " counter :=\n   | n | \\ n...Infinity",
            "id": "d06819fe0fae9c2b8064dae0934e4658"
          },
          {
            "type": "code",
            "text": " #counter is defined as\n #      if given one argument (pattern-matching ''a l�'' MlLanguage, also RubyLanguage syntax lookalike ;))\n #         , the function (\\ = lambda)\n #            which returns the value that n...Infinity generates\n #             (where x...y is a generator ''a l�'' IconLanguage)\n #(Usage is:\n # myVar := counter(1)\n # print myVar\n # print myVar",
            "id": "cac7735cc269017bd99d11990f0cc70e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "[[Io Language]]:",
            "id": "4cd48abeb992f3da226d9718ce847074"
          },
          {
            "type": "code",
            "text": " counter := Object clone do(\n   count := 1\n   withValue := method(n, count := n)\n   count := method(\n     count = count + 1\n     count - 1\n   )\n )",
            "id": "83a8e820185ed82ada0aed2de337d770"
          },
          {
            "type": "code",
            "text": " c1 := counter clone\n c1 count print\n c1 count print",
            "id": "10e1396657f3a9b8ad996a9df49cce18"
          },
          {
            "type": "code",
            "text": " c2 := counter clone withValue(100)\n c2 count print\n c2 count print",
            "id": "bb8550481df90166214b9665fbbc64a6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Php Language]]</b> 5.3+",
            "id": "b3689d21ca80debdd1cf29ef1d74436e"
          },
          {
            "type": "code",
            "text": " function Counter($val = 1) {\n   return function() use (&$val) { return $val++; };\n }",
            "id": "8e09ecb2ee3ac007b3872affc7694cdd"
          },
          {
            "type": "html",
            "text": "\n[[Php Language]] pre-5.3 version ;)",
            "id": "f3090e4dba91e554771db82e60e42834"
          },
          {
            "type": "code",
            "text": " function Counter($val = 1) {\n   return create_function('', 'static $val = '.$val.'; return $val++;');\n }",
            "id": "596e786dfc664a8e14105f65257e67c0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "<b>[[Objective Cee]]</b>\nusing Blocks on MacOSX 10.6+",
            "id": "5ad5f1757d726489b726bc5b4ac0d8a7"
          },
          {
            "type": "code",
            "text": " typedef int (^IntGenerator)();\n IntGenerator Counter(int val) {\n   __block int _val = val;\n   return [[^() { return _val++; } copy] autorelease];\n }",
            "id": "2ea4010aab4310848c7a1863fb711f50"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "[[Go Language]]",
            "id": "f685619e2ed0d04e99ca1645bdeda4e2"
          },
          {
            "type": "code",
            "text": " func Counter(val int) func() int {\n   return func() int {\n     val++\n     return val\n   }\n }",
            "id": "b8ee531a6035406ba392332d45091c12"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "[[Swift Language]]",
            "id": "a666d867762ee6694de8cd16d81634eb"
          },
          {
            "type": "html",
            "text": "\nfunc Counter(var val: Int) -> () -> Int {",
            "id": "53b460acb78f50d4ca5c02105d49c729"
          },
          {
            "type": "code",
            "text": "  return {\n    val++\n    return val\n  }",
            "id": "8099825e89f1bad7ac3bb4f62cb6646a"
          },
          {
            "type": "html",
            "text": "}",
            "id": "a4fd9b962dd580c8d0c5cec013f98c76"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "See [[Array Sum In Many Programming Languages]], [[Dot Product In Many Programming Languages]], [[Ward Number In Many Programming Languages]], [[Hello World In Many Programming Languages]]",
            "id": "2eb8c996e7b908d37baefa00ba17b69a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "583bd5bcaa7ba06b8ae0e6eec7e92123"
          },
          {
            "type": "html",
            "text": "[[Category In Many Programming Languages]]",
            "id": "2a4bceaac337aa0af443027b17775760"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?CounterInManyProgrammingLanguages c2.com]",
            "id": "f9c293ff8030901aa79eaebaf1ab9509"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1708036029862
    }
  ]
}