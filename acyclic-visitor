{
  "title": "Acyclic Visitor",
  "story": [
    {
      "type": "html",
      "text": "[[Category Pattern]], a variation of [[Visitor Pattern]]:",
      "id": "b98083e1bebeb7ac08ffad80816a6816"
    },
    {
      "type": "html",
      "text": "\nDocumented in [[Pattern Languages Of Program Design]] volume three (1997), chapter 7.",
      "id": "6f9bf0e1e3bb50edc329c455c8b0513f"
    },
    {
      "type": "html",
      "text": "\nAvailable online as [http://www.objectmentor.com/publications/acv.pdf www.objectmentor.com]",
      "id": "35ff189f2500f745ed47727088358eae"
    },
    {
      "type": "html",
      "text": "\nIt is discussed and developed in [[Modern Cee Plus Plus Design]] chapter 10.",
      "id": "1dc37f3f1d235d3b15d8f68cca38732a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "570a8423c2a96c7b6bcf0b9191db3536"
    },
    {
      "type": "html",
      "text": "\"The <b>Acyclic Visitor</b> pattern allows new functions to be added to existing class hierarchies without affecting those hierarchies, and without creating the dependency cycles that are inherent to the [[Gang Of Four]] [[Visitor Pattern]].\"",
      "id": "dc3e792323859a22dc2707ac1368664f"
    },
    {
      "type": "html",
      "text": "[...quoted with light editing.]",
      "id": "52dc6437b253d35372b31b4c6a791f66"
    },
    {
      "type": "html",
      "text": "----__\n[[Acyclic Visitor]]:",
      "id": "1d32860902f708da9d39f3c5a69f3a4f"
    },
    {
      "type": "html",
      "text": "\nThe receiver of the Visitor dynamic_casts the Visitor to determine\nif it is the type of Visitor it will accept, and if so, passes itself to\nthe Visitor.",
      "id": "f5bef0a455ba44845c8e5736686d25c3"
    },
    {
      "type": "html",
      "text": "\nHow is this better than:",
      "id": "edda408b78b237489acea4ec2ef0668e"
    },
    {
      "type": "html",
      "text": "\nAn operation or class that will only operate on a specific subtype\ndynamic_casts the instance to determine if it is of that subtype.",
      "id": "4b8d378ec0896896855834b8f230cd97"
    },
    {
      "type": "html",
      "text": "\nThe Visitor pattern has two purposes:",
      "id": "7449b054fdf1e9171894740fe7237e18"
    },
    {
      "type": "html",
      "text": "\n1) Enumeration -> as target of an iteration through a collection of a known set of subtypes",
      "id": "b8ed905d13bcc1927dedc27387df3d54"
    },
    {
      "type": "html",
      "text": "\n2) Type Determination ([[Capability Query]]) -> determine which subtype we are currently examining.",
      "id": "e3d86d648ba772acf25f43c640c30705"
    },
    {
      "type": "html",
      "text": "\nIf there is no need for an enumeration target, and a dynamic_cast is acceptable\nfor the Capability Query, there is no need for the Visitor Pattern.",
      "id": "a1e2e94dd08cde99e514ea45d16c8269"
    },
    {
      "type": "html",
      "text": "\nDoes anybody want to comment on this observation?  Does it make sense?",
      "id": "c92ed0e332ad8a6119e2f08c9cdff39b"
    },
    {
      "type": "html",
      "text": "--[[Dirck Blaskey]]",
      "id": "97a871d4452e96554349798d7cfd7116"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "570a8423c2a96c7b6bcf0b9191db3536"
    },
    {
      "type": "html",
      "text": "I developed [[Acyclic Visitor]] independently in designing class frameworks. ([[John Vlissides]] also developed a variation in [[Visitor In Frameworks]].)",
      "id": "3fcb55e74302e40de3c6f290222d54fc"
    },
    {
      "type": "html",
      "text": "\nIn a particular [[User Interface]] framework, a state machine ([[State Pattern]]) controlled the software's progress through a dialogue with the user. When the user acts, this can cause an event ([[Command Pattern]]) to be sent to the state machine, causing it to change to the next state in the dialogue. But what events might a state receive? And how might it handle these events? Answer: It depends on the application. But I can't recompile the framework every time someone wants to create a custom event in a new application. That's that nasty cyclic dependency.",
      "id": "d1f8ee33932e3896f27d30a3f5af81cb"
    },
    {
      "type": "html",
      "text": "\nSo I pushed the issue of event-handling onto the application. For each event class the application defined, it needed a corresponding event receiver class. If a particular state needed to respond to a particular kind of event, the state class would inherit from the appropriate receiver. The event would then [[Dynamic Cast]] to the corresponding receiver class, executing the event if the cast was successful.",
      "id": "ba95b9b1c24374111bd777bb13130d1c"
    },
    {
      "type": "html",
      "text": "\nIn another instance, I was creating a diagnostic framework. Diagnostic tests inherited from a test base class ([[Strategy Pattern]]). Each class of test would generate test-specific status, which could be relayed to the user. But the application needs to be able to use application-specific test classes, with application-specific status classes. And the diagnostic framework needs to be completely decoupled from the UI, which may even have its own completely separate framework.",
      "id": "99fd9895e9a2b5115d13882dae5d2fd0"
    },
    {
      "type": "html",
      "text": "\nSo for each status class, there is a corresponding status receiver class. Each status class knows what kind of receiver can grok it, and [[Dynamic Cast]]s to it. One status message, one [[Dynamic Cast]]. At least it's better than a list of twenty [[Dynamic Cast]]s in a gigantic if-then-elseif, as the UI code hunts around for a kind of status it knows about.",
      "id": "148470ea8602c39e398f18182553e258"
    },
    {
      "type": "html",
      "text": "--[[Tim King]]",
      "id": "5c0609f9bc4bdb90e10eb46e157722c2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "570a8423c2a96c7b6bcf0b9191db3536"
    },
    {
      "type": "html",
      "text": "\nI recently refactored my way into a situation identical to that Tim describes (quite a testament to the magic of\nrefactoring): State + Command compelled Visitor, and then I had a peloton of cycles to get rid of.",
      "id": "3280d34101bff014fba38b9167eee367"
    },
    {
      "type": "html",
      "text": "\nIt turns out that [[Acyclic Visitor]] as written, translated into [[Java Language]], still has a cycle between each element-\nVisitor pair. Element subclasses (commands) refer to each Visitor subclass (state) via an interface; each \nVisitor interface must refer to an element subclass, and we have a cycle. The cycle doesn't affect the framework,\nbut I don't like to tolerate even little local ones.The cycle can be easily removed by having\nVisitors refer to elements via interfaces, but I had a large number of elements, they were quite simple,\nand the code bloat of having an interface for each element seemed excessive.",
      "id": "82a3205ccac880d3a4fc65c60d0d4fea"
    },
    {
      "type": "html",
      "text": "\nLooking for better solutions I came across [[Uncle Bob]]'s Java version,\n[http://www.objectmentor.com/resources/articles/visitor www.objectmentor.com] ,\nwhich has the same issue, perhaps indicated by the bidirectional arrows in the diagram, although not explicitly\ndiscussed. (I believe the issue almost goes away in [[Cee Plus Plus]] if the elements and Visitors see each others' declarations\nbut not their definitions, but I haven't worked through it.)",
      "id": "58fbf85ce318ca0c4335fb6d9f5005f0"
    },
    {
      "type": "html",
      "text": "\nI settled for using reflection, more or less as described in\n[http://www.javaworld.com/javaworld/javatips/jw-javatip98.html www.javaworld.com] . This completely removes any knowledge of the whole\nbusiness from the elements. The reflective dispatch can be done in one place in a Visitor superclass. The result\nis quite economical and easy to follow. The only hitch is that because the visit methods are only called via\nreflection, code checkers think they're unused.",
      "id": "aae1e45e9bdbef3a2c58cd8bce470d35"
    },
    {
      "type": "html",
      "text": "-- [[Dave Schweisguth]]",
      "id": "09a62d95061b4198ee89b6d44e946177"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "570a8423c2a96c7b6bcf0b9191db3536"
    },
    {
      "type": "html",
      "text": "[[Category Pattern]] [[Category Java]] [[Category Cpp]]",
      "id": "47803d1e94f31c739f701edf3054b9fb"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?AcyclicVisitor c2.com]",
      "id": "b9adeca17f26ece4104c89315168483f"
    }
  ],
  "journal": [
    {
      "date": 1336336744000,
      "id": "1d19b3df6584bd57d0077871db626674",
      "type": "create",
      "item": {
        "title": "Acyclic Visitor",
        "story": [
          {
            "type": "html",
            "text": "[[Category Pattern]], a variation of [[Visitor Pattern]]:",
            "id": "b98083e1bebeb7ac08ffad80816a6816"
          },
          {
            "type": "html",
            "text": "\nDocumented in [[Pattern Languages Of Program Design]] volume three (1997), chapter 7.",
            "id": "6f9bf0e1e3bb50edc329c455c8b0513f"
          },
          {
            "type": "html",
            "text": "\nAvailable online as [http://www.objectmentor.com/publications/acv.pdf www.objectmentor.com]",
            "id": "35ff189f2500f745ed47727088358eae"
          },
          {
            "type": "html",
            "text": "\nIt is discussed and developed in [[Modern Cee Plus Plus Design]] chapter 10.",
            "id": "1dc37f3f1d235d3b15d8f68cca38732a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "570a8423c2a96c7b6bcf0b9191db3536"
          },
          {
            "type": "html",
            "text": "\"The <b>Acyclic Visitor</b> pattern allows new functions to be added to existing class hierarchies without affecting those hierarchies, and without creating the dependency cycles that are inherent to the [[Gang Of Four]] [[Visitor Pattern]].\"",
            "id": "dc3e792323859a22dc2707ac1368664f"
          },
          {
            "type": "html",
            "text": "[...quoted with light editing.]",
            "id": "52dc6437b253d35372b31b4c6a791f66"
          },
          {
            "type": "html",
            "text": "----__\n[[Acyclic Visitor]]:",
            "id": "1d32860902f708da9d39f3c5a69f3a4f"
          },
          {
            "type": "html",
            "text": "\nThe receiver of the Visitor dynamic_casts the Visitor to determine\nif it is the type of Visitor it will accept, and if so, passes itself to\nthe Visitor.",
            "id": "f5bef0a455ba44845c8e5736686d25c3"
          },
          {
            "type": "html",
            "text": "\nHow is this better than:",
            "id": "edda408b78b237489acea4ec2ef0668e"
          },
          {
            "type": "html",
            "text": "\nAn operation or class that will only operate on a specific subtype\ndynamic_casts the instance to determine if it is of that subtype.",
            "id": "4b8d378ec0896896855834b8f230cd97"
          },
          {
            "type": "html",
            "text": "\nThe Visitor pattern has two purposes:",
            "id": "7449b054fdf1e9171894740fe7237e18"
          },
          {
            "type": "html",
            "text": "\n1) Enumeration -> as target of an iteration through a collection of a known set of subtypes",
            "id": "b8ed905d13bcc1927dedc27387df3d54"
          },
          {
            "type": "html",
            "text": "\n2) Type Determination ([[Capability Query]]) -> determine which subtype we are currently examining.",
            "id": "e3d86d648ba772acf25f43c640c30705"
          },
          {
            "type": "html",
            "text": "\nIf there is no need for an enumeration target, and a dynamic_cast is acceptable\nfor the Capability Query, there is no need for the Visitor Pattern.",
            "id": "a1e2e94dd08cde99e514ea45d16c8269"
          },
          {
            "type": "html",
            "text": "\nDoes anybody want to comment on this observation?  Does it make sense?",
            "id": "c92ed0e332ad8a6119e2f08c9cdff39b"
          },
          {
            "type": "html",
            "text": "--[[Dirck Blaskey]]",
            "id": "97a871d4452e96554349798d7cfd7116"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "570a8423c2a96c7b6bcf0b9191db3536"
          },
          {
            "type": "html",
            "text": "I developed [[Acyclic Visitor]] independently in designing class frameworks. ([[John Vlissides]] also developed a variation in [[Visitor In Frameworks]].)",
            "id": "3fcb55e74302e40de3c6f290222d54fc"
          },
          {
            "type": "html",
            "text": "\nIn a particular [[User Interface]] framework, a state machine ([[State Pattern]]) controlled the software's progress through a dialogue with the user. When the user acts, this can cause an event ([[Command Pattern]]) to be sent to the state machine, causing it to change to the next state in the dialogue. But what events might a state receive? And how might it handle these events? Answer: It depends on the application. But I can't recompile the framework every time someone wants to create a custom event in a new application. That's that nasty cyclic dependency.",
            "id": "d1f8ee33932e3896f27d30a3f5af81cb"
          },
          {
            "type": "html",
            "text": "\nSo I pushed the issue of event-handling onto the application. For each event class the application defined, it needed a corresponding event receiver class. If a particular state needed to respond to a particular kind of event, the state class would inherit from the appropriate receiver. The event would then [[Dynamic Cast]] to the corresponding receiver class, executing the event if the cast was successful.",
            "id": "ba95b9b1c24374111bd777bb13130d1c"
          },
          {
            "type": "html",
            "text": "\nIn another instance, I was creating a diagnostic framework. Diagnostic tests inherited from a test base class ([[Strategy Pattern]]). Each class of test would generate test-specific status, which could be relayed to the user. But the application needs to be able to use application-specific test classes, with application-specific status classes. And the diagnostic framework needs to be completely decoupled from the UI, which may even have its own completely separate framework.",
            "id": "99fd9895e9a2b5115d13882dae5d2fd0"
          },
          {
            "type": "html",
            "text": "\nSo for each status class, there is a corresponding status receiver class. Each status class knows what kind of receiver can grok it, and [[Dynamic Cast]]s to it. One status message, one [[Dynamic Cast]]. At least it's better than a list of twenty [[Dynamic Cast]]s in a gigantic if-then-elseif, as the UI code hunts around for a kind of status it knows about.",
            "id": "148470ea8602c39e398f18182553e258"
          },
          {
            "type": "html",
            "text": "--[[Tim King]]",
            "id": "5c0609f9bc4bdb90e10eb46e157722c2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "570a8423c2a96c7b6bcf0b9191db3536"
          },
          {
            "type": "html",
            "text": "\nI recently refactored my way into a situation identical to that Tim describes (quite a testament to the magic of\nrefactoring): State + Command compelled Visitor, and then I had a peloton of cycles to get rid of.",
            "id": "3280d34101bff014fba38b9167eee367"
          },
          {
            "type": "html",
            "text": "\nIt turns out that [[Acyclic Visitor]] as written, translated into [[Java Language]], still has a cycle between each element-\nVisitor pair. Element subclasses (commands) refer to each Visitor subclass (state) via an interface; each \nVisitor interface must refer to an element subclass, and we have a cycle. The cycle doesn't affect the framework,\nbut I don't like to tolerate even little local ones.The cycle can be easily removed by having\nVisitors refer to elements via interfaces, but I had a large number of elements, they were quite simple,\nand the code bloat of having an interface for each element seemed excessive.",
            "id": "82a3205ccac880d3a4fc65c60d0d4fea"
          },
          {
            "type": "html",
            "text": "\nLooking for better solutions I came across [[Uncle Bob]]'s Java version,\n[http://www.objectmentor.com/resources/articles/visitor www.objectmentor.com] ,\nwhich has the same issue, perhaps indicated by the bidirectional arrows in the diagram, although not explicitly\ndiscussed. (I believe the issue almost goes away in [[Cee Plus Plus]] if the elements and Visitors see each others' declarations\nbut not their definitions, but I haven't worked through it.)",
            "id": "58fbf85ce318ca0c4335fb6d9f5005f0"
          },
          {
            "type": "html",
            "text": "\nI settled for using reflection, more or less as described in\n[http://www.javaworld.com/javaworld/javatips/jw-javatip98.html www.javaworld.com] . This completely removes any knowledge of the whole\nbusiness from the elements. The reflective dispatch can be done in one place in a Visitor superclass. The result\nis quite economical and easy to follow. The only hitch is that because the visit methods are only called via\nreflection, code checkers think they're unused.",
            "id": "aae1e45e9bdbef3a2c58cd8bce470d35"
          },
          {
            "type": "html",
            "text": "-- [[Dave Schweisguth]]",
            "id": "09a62d95061b4198ee89b6d44e946177"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "570a8423c2a96c7b6bcf0b9191db3536"
          },
          {
            "type": "html",
            "text": "[[Category Pattern]] [[Category Java]] [[Category Cpp]]",
            "id": "47803d1e94f31c739f701edf3054b9fb"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?AcyclicVisitor c2.com]",
            "id": "b9adeca17f26ece4104c89315168483f"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1708264910990
    }
  ]
}