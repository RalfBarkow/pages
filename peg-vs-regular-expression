{
  "title": "PEG vs Regular Expression",
  "story": [
    {
      "type": "paragraph",
      "id": "795540f7210cc670",
      "text": "As a [[Regular Expression]] \\[.*\\] matches the longest possible text between '[' and ']'. As a [[PEG]] it never matches anything, because a PEG is deterministic: .* consumes the rest of the input, so \\] never matches. As a PEG this needs to be written as: \\[ ( !\\] . )* \\] (or \\[ @ \\]). [https://nim-lang.org/docs/pegs.html#peg-syntax-and-semantics-peg-vs-regular-expression page]\n\nNote that the regular expression does not behave as intended either: in the example * should not be greedy, so \\[.*?\\] should be used instead."
    },
    {
      "type": "pagefold",
      "id": "d9c36b485063f855",
      "text": "~"
    },
    {
      "type": "reference",
      "id": "27907b12ceff0e2d",
      "site": "wiki.ralfbarkow.ch",
      "slug": "regexp-metacharacters",
      "title": "RegExp Metacharacters",
      "text": "We use the javascript implementation of RegExp to evaluate regular expressions. Most letters stand for themselves when matching but there are exceptions. Here is a list we have adapted from \"Learn RegEx\". [https://github.com/ziishaned/learn-regex#1-basic-matchers site]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "PEG vs Regular Expression",
        "story": []
      },
      "date": 1696434250426
    },
    {
      "item": {
        "type": "factory",
        "id": "795540f7210cc670"
      },
      "id": "795540f7210cc670",
      "type": "add",
      "date": 1696434251845
    },
    {
      "type": "edit",
      "id": "795540f7210cc670",
      "item": {
        "type": "paragraph",
        "id": "795540f7210cc670",
        "text": "As a regular expression \\[.*\\] matches the longest possible text between '[' and ']'. As a PEG it never matches anything, because a PEG is deterministic: .* consumes the rest of the input, so \\] never matches. As a PEG this needs to be written as: \\[ ( !\\] . )* \\] (or \\[ @ \\]).\n\nNote that the regular expression does not behave as intended either: in the example * should not be greedy, so \\[.*?\\] should be used instead."
      },
      "date": 1696434253384
    },
    {
      "type": "edit",
      "id": "795540f7210cc670",
      "item": {
        "type": "paragraph",
        "id": "795540f7210cc670",
        "text": "As a regular expression \\[.*\\] matches the longest possible text between '[' and ']'. As a PEG it never matches anything, because a PEG is deterministic: .* consumes the rest of the input, so \\] never matches. As a PEG this needs to be written as: \\[ ( !\\] . )* \\] (or \\[ @ \\]). [https://nim-lang.org/docs/pegs.html#peg-syntax-and-semantics-peg-vs-regular-expression page]\n\nNote that the regular expression does not behave as intended either: in the example * should not be greedy, so \\[.*?\\] should be used instead."
      },
      "date": 1696434313319
    },
    {
      "type": "edit",
      "id": "795540f7210cc670",
      "item": {
        "type": "paragraph",
        "id": "795540f7210cc670",
        "text": "As a [[Regular Expression]] \\[.*\\] matches the longest possible text between '[' and ']'. As a PEG it never matches anything, because a PEG is deterministic: .* consumes the rest of the input, so \\] never matches. As a PEG this needs to be written as: \\[ ( !\\] . )* \\] (or \\[ @ \\]). [https://nim-lang.org/docs/pegs.html#peg-syntax-and-semantics-peg-vs-regular-expression page]\n\nNote that the regular expression does not behave as intended either: in the example * should not be greedy, so \\[.*?\\] should be used instead."
      },
      "date": 1696434464383
    },
    {
      "item": {
        "type": "factory",
        "id": "d9c36b485063f855"
      },
      "id": "d9c36b485063f855",
      "type": "add",
      "after": "795540f7210cc670",
      "date": 1696434488812
    },
    {
      "type": "edit",
      "id": "d9c36b485063f855",
      "item": {
        "type": "pagefold",
        "id": "d9c36b485063f855",
        "text": "~"
      },
      "date": 1696434492229
    },
    {
      "item": {
        "type": "factory",
        "id": "27907b12ceff0e2d"
      },
      "id": "27907b12ceff0e2d",
      "type": "add",
      "after": "d9c36b485063f855",
      "date": 1696434494263
    },
    {
      "type": "edit",
      "id": "27907b12ceff0e2d",
      "item": {
        "type": "reference",
        "id": "27907b12ceff0e2d",
        "site": "wiki.ralfbarkow.ch",
        "slug": "regexp-metacharacters",
        "title": "RegExp Metacharacters",
        "text": "We use the javascript implementation of RegExp to evaluate regular expressions. Most letters stand for themselves when matching but there are exceptions. Here is a list we have adapted from \"Learn RegEx\". [https://github.com/ziishaned/learn-regex#1-basic-matchers site]"
      },
      "date": 1696434497930
    },
    {
      "type": "edit",
      "id": "795540f7210cc670",
      "item": {
        "type": "paragraph",
        "id": "795540f7210cc670",
        "text": "As a [[Regular Expression]] \\[.*\\] matches the longest possible text between '[' and ']'. As a [[PEG]] it never matches anything, because a PEG is deterministic: .* consumes the rest of the input, so \\] never matches. As a PEG this needs to be written as: \\[ ( !\\] . )* \\] (or \\[ @ \\]). [https://nim-lang.org/docs/pegs.html#peg-syntax-and-semantics-peg-vs-regular-expression page]\n\nNote that the regular expression does not behave as intended either: in the example * should not be greedy, so \\[.*?\\] should be used instead."
      },
      "date": 1696434526537
    }
  ]
}