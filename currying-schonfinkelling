{
  "title": "Currying Schonfinkelling",
  "story": [
    {
      "type": "html",
      "text": "It's really just called currying, but that's not a [[Wiki Name]]. Currying is a property of functions discovered by Moses Schoenfinkel in 1924. However at the time, [[Haskell Curry]] got most of the good press about [[Functional Programming]] so it was named after him. The term itself was supposedly invented by [[Christopher Strachey]].",
      "id": "280b9b4479d82ff76ed9a40f171577f0"
    },
    {
      "type": "html",
      "text": " [http://www.cs.nott.ac.uk/~gmh/faq.html#currying www.cs.nott.ac.uk]",
      "id": "80c29a9f43edbb280798064753a96d31"
    },
    {
      "type": "html",
      "text": "<i>If you read the FAQ, you'll see that the property described (the isomorphism of AxB->C with A->B->C) was a \"well known fact\" well before Schoenfinkel and Curry. Their contributions were apparently in the area of the [[Ess And Kay Combinators]].</i>",
      "id": "e609fbeeaaccb13c03683cf5762ff192"
    },
    {
      "type": "html",
      "text": "\nCurrying is the concept that functions of multiple arguments are really just [[Higher Order Function]]s which take one argument and return functions. In a sort of Javaish syntax, Here are examples:",
      "id": "9710b3c2fedfaaff02bde79421eaae59"
    },
    {
      "type": "code",
      "text": " // two arg version\n int sum(int a, int b) { return (a+b); }",
      "id": "be779bc3697ca2a7dcb9cda1c5c0758f"
    },
    {
      "type": "code",
      "text": " // one arg version\n int sum(int a) { return int sum1(int b) { return (a+b); } }",
      "id": "3f5d39bc173bc4e14290cffb36720c63"
    },
    {
      "type": "code",
      "text": " // optimised multiplication\n int mult(int a, int b) {\n   select (a) {\n    case -1: return int neg(int b)  { return -b;  }\n     case  0: return int zero(int b) { return  0;  } \n    case  1: return int ident(int b){ return  b;  }\n    default: return int std(int b)  { return a*b; }\n  }\n }",
      "id": "bf1b26263e7408ef5eff80104e83925b"
    },
    {
      "type": "html",
      "text": "\nIn fact you could write that in <i>legitimate</i> [[Java Script]]:",
      "id": "341776421a7515b39a5da1048652f106"
    },
    {
      "type": "code",
      "text": " // two arg version\n var sum = function(a, b) { return (a+b); }",
      "id": "2d1378948d7e2c7dd762517881271164"
    },
    {
      "type": "code",
      "text": " // one arg version\n var sum = function(a) { return function(b) { return (a+b); }}\n // Which would be used as, e.g.,\n var plusfour = sum(4);\n var six = plusfour(2);\n var alsosix = sum(4)(2);",
      "id": "f2bb9d59888d300596e383060908d7d0"
    },
    {
      "type": "code",
      "text": " // optimised multiplication\n function mult(a) {\n   switch(a)\n   {\n   case -1: return function(b) { return -b; }\n   case 0: return function(b) { return 0; }\n   case 1: return function(b) { return b; }\n   default: return function(b) { return a*b; }\n   }\n }\n var answer = mult(6)(9);",
      "id": "f9c626910801fd67d0c8dde9e276db10"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c7b3b80bedc88d0433c428ec3e81fb1d"
    },
    {
      "type": "html",
      "text": "\"And why would I care?\"  <--  That's what I was thinking when I read this.  ;->",
      "id": "aa14ee249dc963770f9526dd2ca786d0"
    },
    {
      "type": "html",
      "text": "<b>But now I see an application of this:</b>",
      "id": "d8aed667c4321e98fbe2f7689db4a7e2"
    },
    {
      "type": "html",
      "text": "\nThis idea is used quite heavily in the [[Synthesis Os]]. You see, if the value of \"a\" is known at one point in the run, and we intend to add lots of \"b\" values to it, then [[Synthesis Os]] calls \"sum(int a)\", which generates the code to do \"sum1(int b)\" -- where 'a' is a constant. This is called [[Partial Evaluation]]. It gives [[Synthesis Os]] a <b>substantial</b> performance boost, as it can do code optimization based on the value of 'a'. Like, if 'a' happens to be zero, it generates/returns the code \"int sum1(int b) { return b; }\", optimizing the addition right out. Likewise, if 'a' is one, it generates/returns the function \"int sum1(int b) { return ++b; }\". Fast. Very fast. (See the paper on [[Synthesis Os]].  It claims \"10 times faster than Unix.\") -- [[Jeff Grigg]]",
      "id": "234d17a393a1378ce1d3d2482740daaf"
    },
    {
      "type": "html",
      "text": "<i>\"And why would I care?\"</i>",
      "id": "61d5bd9a4696f524428cd98db0fcbd92"
    },
    {
      "type": "html",
      "text": "\nBecause it makes programming much easier and programs much easier to understand.  For example, here's a piece of Haskell code to double all elements of a list:",
      "id": "e024c121863323076934ba8a5b2bb961"
    },
    {
      "type": "code",
      "text": " double aList = map (* 2) aList",
      "id": "cd39721390e599d3a81f3e163cda4d98"
    },
    {
      "type": "html",
      "text": "That is, to double a list, apply \"* 2\" to each element -- the * operator has been curried.",
      "id": "c7c559c5bd87778b507d44bc7d36f533"
    },
    {
      "type": "html",
      "text": "\nAnd this definition can itself be curried, so that:",
      "id": "b3765e556a3dc84084522f192511d68b"
    },
    {
      "type": "code",
      "text": " double = map (* 2)",
      "id": "3956844ba2758bcfbae77014f2a755fc"
    },
    {
      "type": "html",
      "text": "-- [[Nat Pryce]]",
      "id": "a980d3f8cd3a586ffa092dfa34c33e47"
    },
    {
      "type": "html",
      "text": "\nIs that really that much easier to understand than",
      "id": "92997a563c97f1df43f779131ace9935"
    },
    {
      "type": "code",
      "text": " @alist = map {$_ * 2} @alist;",
      "id": "423f9692e5c0210c6a725b550d0f7062"
    },
    {
      "type": "html",
      "text": "...But that code does not define a new function.",
      "id": "3aa3b622e7c8718b5eb884460d1f3dd9"
    },
    {
      "type": "html",
      "text": "<i>But it does define a [[Perl Language]] block, which, if I understand correctly, is a code object with a lot of the same properties as a scheme closure.</i>",
      "id": "bc2e9a6b91cef19089a15d54bfa18815"
    },
    {
      "type": "html",
      "text": "(No, it doesn't; it defines an array, \"@alist\". <i>But it does so in terms of the block '{$_ * 2}', which is in effect an anonymous function</i>)",
      "id": "a75039cd79f9b6c30e9be5639f571091"
    },
    {
      "type": "html",
      "text": "\nTo elaborate:",
      "id": "f98359dc413388cafd857b55f6542fbc"
    },
    {
      "type": "code",
      "text": " double = map (* 2)",
      "id": "3956844ba2758bcfbae77014f2a755fc"
    },
    {
      "type": "code",
      "text": " list1 = [1, 2, 3, 4, 5]\n list2 = [10, 20, 30, 40, 50]",
      "id": "55f8f4f373aef3e5b22ec5a491631990"
    },
    {
      "type": "code",
      "text": " double list1\n >[2, 4, 6, 8, 10]",
      "id": "369f99f2ca3bf03da51f0fe3d8d2cf60"
    },
    {
      "type": "code",
      "text": " double list2\n >[20, 40, 60, 80, 100]",
      "id": "61771277b5550a72fb7e4e09a10e00ac"
    },
    {
      "type": "html",
      "text": "\nIn the [[Fortran Language]] this particular (and many similar problems) can be reduced to ",
      "id": "7542ca549b223a2432a095ff73266b89"
    },
    {
      "type": "code",
      "text": "  A = A * 2",
      "id": "681838c2989c472e5e0597e1311c2e88"
    },
    {
      "type": "html",
      "text": "where A is a arbitrarily shaped array. But that is not the point.",
      "id": "b66a22c35acce8ac896041aa8efdb651"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c7b3b80bedc88d0433c428ec3e81fb1d"
    },
    {
      "type": "html",
      "text": "You can curry objects too.",
      "id": "46686c005af996ae377f857cbfe164f8"
    },
    {
      "type": "html",
      "text": "\nFor example, instead of sending",
      "id": "19cb8e3b662607fae3b54e1d2304d11b"
    },
    {
      "type": "html",
      "text": "window drawCircleAt:<br>10@10 Colour: #red",
      "id": "84129800c441afc499ba59a929de23e7"
    },
    {
      "type": "html",
      "text": "window drawCircleAt:<br>20@20 Colour: #red",
      "id": "c407e610d81571a75d31424ad2740f54"
    },
    {
      "type": "html",
      "text": "window drawCircleAt:<br>30@30 Colour: #red",
      "id": "d5aaac26c394b6e9aa566582a4f900d0"
    },
    {
      "type": "html",
      "text": "you can curry away the Colour argument, making a new object called a pen.",
      "id": "cfbbb00372a4bbb0c7703b499ff0cc45"
    },
    {
      "type": "html",
      "text": "pen := window pen colour:<br>#red",
      "id": "02e65fff260ef4b89bb9630f94187f7b"
    },
    {
      "type": "html",
      "text": "pen drawCircleAt:<br>10@10",
      "id": "fa0dc3207c85ba8149748a2472a74825"
    },
    {
      "type": "html",
      "text": "pen drawCircleAt:<br>20@20",
      "id": "cab5dbb53029eb0d508d3c301f5fd3b5"
    },
    {
      "type": "html",
      "text": "pen drawCircleAt:<br>30@30",
      "id": "4d8ad2ce55d8decbe69ad2215cbb6c6b"
    },
    {
      "type": "html",
      "text": "[[Curried Object]] is a generalisation of a number of other patterns, like [[Abstract Session]], [[Iterator Pattern]], as well as pens in graphics systems.",
      "id": "fbc4362907f712b66204ed50f6cf9794"
    },
    {
      "type": "html",
      "text": "-- [[James Noble]]",
      "id": "3c5418c653caa853948bef400db19235"
    },
    {
      "type": "html",
      "text": "<i>Given historical precedent, [[Abstract Session]], [[Iterator Pattern]], and graphics system pens are more like specialisations of, or at least attempts to emulate aspects of, curried objects.</i>\nOther patterns seem to be trying to hark back to currying; for example, is [[Visitor Pattern]] much more than curried traversal?",
      "id": "537f9fe8a741c4dc0d06b78bb6259464"
    },
    {
      "type": "html",
      "text": "<i>I sometimes get the feeling that one of the things that has been forgotten (or at least, </i>was<i> forgotten: there seems to be some attempt to recapture the idea in recent times) by the designers of OO languages is that functions are objects, too. A lot of [[Design Pattern]]s - [[Visitor Pattern]], [[Strategy Pattern]], [[Decorator Pattern]], [[Adapter Pattern]], ... - seem like techniques for transporting <b>functions</b> from one object to another. Currying recognises that functions can be <b>constructed</b> in a series of steps.</i>",
      "id": "d746916a837ef2e4616f15f54cb74ba0"
    },
    {
      "type": "html",
      "text": "\nThank you. There is quite a lot of information on this wiki about this. One starting point is the work of [[Thomas Kuehne]] in [[Functional Pattern System For Object Oriented Design]]. There is also the work FC++ ([[Functoids In Cpp]]), an attempt to implement in [[Cee Plus Plus]] a lot of things found in [[Haskell Language]]. -- [[John Fletcher]]",
      "id": "6593605a81c03c2794e1be1d9fbd5367"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c7b3b80bedc88d0433c428ec3e81fb1d"
    },
    {
      "type": "html",
      "text": "[[Category Functional Programming]]",
      "id": "470e5790e0ba2d3bfe9f512b18ca5ed9"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?CurryingSchonfinkelling c2.com]",
      "id": "e39bbd23be8f8fe53b540b0c85dde56b"
    }
  ],
  "journal": [
    {
      "date": 1336306610000,
      "id": "887424d0c33a15d74841230dddcf2577",
      "type": "create",
      "item": {
        "title": "Currying Schonfinkelling",
        "story": [
          {
            "type": "html",
            "text": "It's really just called currying, but that's not a [[Wiki Name]]. Currying is a property of functions discovered by Moses Schoenfinkel in 1924. However at the time, [[Haskell Curry]] got most of the good press about [[Functional Programming]] so it was named after him. The term itself was supposedly invented by [[Christopher Strachey]].",
            "id": "280b9b4479d82ff76ed9a40f171577f0"
          },
          {
            "type": "html",
            "text": " [http://www.cs.nott.ac.uk/~gmh/faq.html#currying www.cs.nott.ac.uk]",
            "id": "80c29a9f43edbb280798064753a96d31"
          },
          {
            "type": "html",
            "text": "<i>If you read the FAQ, you'll see that the property described (the isomorphism of AxB->C with A->B->C) was a \"well known fact\" well before Schoenfinkel and Curry. Their contributions were apparently in the area of the [[Ess And Kay Combinators]].</i>",
            "id": "e609fbeeaaccb13c03683cf5762ff192"
          },
          {
            "type": "html",
            "text": "\nCurrying is the concept that functions of multiple arguments are really just [[Higher Order Function]]s which take one argument and return functions. In a sort of Javaish syntax, Here are examples:",
            "id": "9710b3c2fedfaaff02bde79421eaae59"
          },
          {
            "type": "code",
            "text": " // two arg version\n int sum(int a, int b) { return (a+b); }",
            "id": "be779bc3697ca2a7dcb9cda1c5c0758f"
          },
          {
            "type": "code",
            "text": " // one arg version\n int sum(int a) { return int sum1(int b) { return (a+b); } }",
            "id": "3f5d39bc173bc4e14290cffb36720c63"
          },
          {
            "type": "code",
            "text": " // optimised multiplication\n int mult(int a, int b) {\n   select (a) {\n    case -1: return int neg(int b)  { return -b;  }\n     case  0: return int zero(int b) { return  0;  } \n    case  1: return int ident(int b){ return  b;  }\n    default: return int std(int b)  { return a*b; }\n  }\n }",
            "id": "bf1b26263e7408ef5eff80104e83925b"
          },
          {
            "type": "html",
            "text": "\nIn fact you could write that in <i>legitimate</i> [[Java Script]]:",
            "id": "341776421a7515b39a5da1048652f106"
          },
          {
            "type": "code",
            "text": " // two arg version\n var sum = function(a, b) { return (a+b); }",
            "id": "2d1378948d7e2c7dd762517881271164"
          },
          {
            "type": "code",
            "text": " // one arg version\n var sum = function(a) { return function(b) { return (a+b); }}\n // Which would be used as, e.g.,\n var plusfour = sum(4);\n var six = plusfour(2);\n var alsosix = sum(4)(2);",
            "id": "f2bb9d59888d300596e383060908d7d0"
          },
          {
            "type": "code",
            "text": " // optimised multiplication\n function mult(a) {\n   switch(a)\n   {\n   case -1: return function(b) { return -b; }\n   case 0: return function(b) { return 0; }\n   case 1: return function(b) { return b; }\n   default: return function(b) { return a*b; }\n   }\n }\n var answer = mult(6)(9);",
            "id": "f9c626910801fd67d0c8dde9e276db10"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c7b3b80bedc88d0433c428ec3e81fb1d"
          },
          {
            "type": "html",
            "text": "\"And why would I care?\"  <--  That's what I was thinking when I read this.  ;->",
            "id": "aa14ee249dc963770f9526dd2ca786d0"
          },
          {
            "type": "html",
            "text": "<b>But now I see an application of this:</b>",
            "id": "d8aed667c4321e98fbe2f7689db4a7e2"
          },
          {
            "type": "html",
            "text": "\nThis idea is used quite heavily in the [[Synthesis Os]]. You see, if the value of \"a\" is known at one point in the run, and we intend to add lots of \"b\" values to it, then [[Synthesis Os]] calls \"sum(int a)\", which generates the code to do \"sum1(int b)\" -- where 'a' is a constant. This is called [[Partial Evaluation]]. It gives [[Synthesis Os]] a <b>substantial</b> performance boost, as it can do code optimization based on the value of 'a'. Like, if 'a' happens to be zero, it generates/returns the code \"int sum1(int b) { return b; }\", optimizing the addition right out. Likewise, if 'a' is one, it generates/returns the function \"int sum1(int b) { return ++b; }\". Fast. Very fast. (See the paper on [[Synthesis Os]].  It claims \"10 times faster than Unix.\") -- [[Jeff Grigg]]",
            "id": "234d17a393a1378ce1d3d2482740daaf"
          },
          {
            "type": "html",
            "text": "<i>\"And why would I care?\"</i>",
            "id": "61d5bd9a4696f524428cd98db0fcbd92"
          },
          {
            "type": "html",
            "text": "\nBecause it makes programming much easier and programs much easier to understand.  For example, here's a piece of Haskell code to double all elements of a list:",
            "id": "e024c121863323076934ba8a5b2bb961"
          },
          {
            "type": "code",
            "text": " double aList = map (* 2) aList",
            "id": "cd39721390e599d3a81f3e163cda4d98"
          },
          {
            "type": "html",
            "text": "That is, to double a list, apply \"* 2\" to each element -- the * operator has been curried.",
            "id": "c7c559c5bd87778b507d44bc7d36f533"
          },
          {
            "type": "html",
            "text": "\nAnd this definition can itself be curried, so that:",
            "id": "b3765e556a3dc84084522f192511d68b"
          },
          {
            "type": "code",
            "text": " double = map (* 2)",
            "id": "3956844ba2758bcfbae77014f2a755fc"
          },
          {
            "type": "html",
            "text": "-- [[Nat Pryce]]",
            "id": "a980d3f8cd3a586ffa092dfa34c33e47"
          },
          {
            "type": "html",
            "text": "\nIs that really that much easier to understand than",
            "id": "92997a563c97f1df43f779131ace9935"
          },
          {
            "type": "code",
            "text": " @alist = map {$_ * 2} @alist;",
            "id": "423f9692e5c0210c6a725b550d0f7062"
          },
          {
            "type": "html",
            "text": "...But that code does not define a new function.",
            "id": "3aa3b622e7c8718b5eb884460d1f3dd9"
          },
          {
            "type": "html",
            "text": "<i>But it does define a [[Perl Language]] block, which, if I understand correctly, is a code object with a lot of the same properties as a scheme closure.</i>",
            "id": "bc2e9a6b91cef19089a15d54bfa18815"
          },
          {
            "type": "html",
            "text": "(No, it doesn't; it defines an array, \"@alist\". <i>But it does so in terms of the block '{$_ * 2}', which is in effect an anonymous function</i>)",
            "id": "a75039cd79f9b6c30e9be5639f571091"
          },
          {
            "type": "html",
            "text": "\nTo elaborate:",
            "id": "f98359dc413388cafd857b55f6542fbc"
          },
          {
            "type": "code",
            "text": " double = map (* 2)",
            "id": "3956844ba2758bcfbae77014f2a755fc"
          },
          {
            "type": "code",
            "text": " list1 = [1, 2, 3, 4, 5]\n list2 = [10, 20, 30, 40, 50]",
            "id": "55f8f4f373aef3e5b22ec5a491631990"
          },
          {
            "type": "code",
            "text": " double list1\n >[2, 4, 6, 8, 10]",
            "id": "369f99f2ca3bf03da51f0fe3d8d2cf60"
          },
          {
            "type": "code",
            "text": " double list2\n >[20, 40, 60, 80, 100]",
            "id": "61771277b5550a72fb7e4e09a10e00ac"
          },
          {
            "type": "html",
            "text": "\nIn the [[Fortran Language]] this particular (and many similar problems) can be reduced to ",
            "id": "7542ca549b223a2432a095ff73266b89"
          },
          {
            "type": "code",
            "text": "  A = A * 2",
            "id": "681838c2989c472e5e0597e1311c2e88"
          },
          {
            "type": "html",
            "text": "where A is a arbitrarily shaped array. But that is not the point.",
            "id": "b66a22c35acce8ac896041aa8efdb651"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c7b3b80bedc88d0433c428ec3e81fb1d"
          },
          {
            "type": "html",
            "text": "You can curry objects too.",
            "id": "46686c005af996ae377f857cbfe164f8"
          },
          {
            "type": "html",
            "text": "\nFor example, instead of sending",
            "id": "19cb8e3b662607fae3b54e1d2304d11b"
          },
          {
            "type": "html",
            "text": "window drawCircleAt:<br>10@10 Colour: #red",
            "id": "84129800c441afc499ba59a929de23e7"
          },
          {
            "type": "html",
            "text": "window drawCircleAt:<br>20@20 Colour: #red",
            "id": "c407e610d81571a75d31424ad2740f54"
          },
          {
            "type": "html",
            "text": "window drawCircleAt:<br>30@30 Colour: #red",
            "id": "d5aaac26c394b6e9aa566582a4f900d0"
          },
          {
            "type": "html",
            "text": "you can curry away the Colour argument, making a new object called a pen.",
            "id": "cfbbb00372a4bbb0c7703b499ff0cc45"
          },
          {
            "type": "html",
            "text": "pen := window pen colour:<br>#red",
            "id": "02e65fff260ef4b89bb9630f94187f7b"
          },
          {
            "type": "html",
            "text": "pen drawCircleAt:<br>10@10",
            "id": "fa0dc3207c85ba8149748a2472a74825"
          },
          {
            "type": "html",
            "text": "pen drawCircleAt:<br>20@20",
            "id": "cab5dbb53029eb0d508d3c301f5fd3b5"
          },
          {
            "type": "html",
            "text": "pen drawCircleAt:<br>30@30",
            "id": "4d8ad2ce55d8decbe69ad2215cbb6c6b"
          },
          {
            "type": "html",
            "text": "[[Curried Object]] is a generalisation of a number of other patterns, like [[Abstract Session]], [[Iterator Pattern]], as well as pens in graphics systems.",
            "id": "fbc4362907f712b66204ed50f6cf9794"
          },
          {
            "type": "html",
            "text": "-- [[James Noble]]",
            "id": "3c5418c653caa853948bef400db19235"
          },
          {
            "type": "html",
            "text": "<i>Given historical precedent, [[Abstract Session]], [[Iterator Pattern]], and graphics system pens are more like specialisations of, or at least attempts to emulate aspects of, curried objects.</i>\nOther patterns seem to be trying to hark back to currying; for example, is [[Visitor Pattern]] much more than curried traversal?",
            "id": "537f9fe8a741c4dc0d06b78bb6259464"
          },
          {
            "type": "html",
            "text": "<i>I sometimes get the feeling that one of the things that has been forgotten (or at least, </i>was<i> forgotten: there seems to be some attempt to recapture the idea in recent times) by the designers of OO languages is that functions are objects, too. A lot of [[Design Pattern]]s - [[Visitor Pattern]], [[Strategy Pattern]], [[Decorator Pattern]], [[Adapter Pattern]], ... - seem like techniques for transporting <b>functions</b> from one object to another. Currying recognises that functions can be <b>constructed</b> in a series of steps.</i>",
            "id": "d746916a837ef2e4616f15f54cb74ba0"
          },
          {
            "type": "html",
            "text": "\nThank you. There is quite a lot of information on this wiki about this. One starting point is the work of [[Thomas Kuehne]] in [[Functional Pattern System For Object Oriented Design]]. There is also the work FC++ ([[Functoids In Cpp]]), an attempt to implement in [[Cee Plus Plus]] a lot of things found in [[Haskell Language]]. -- [[John Fletcher]]",
            "id": "6593605a81c03c2794e1be1d9fbd5367"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c7b3b80bedc88d0433c428ec3e81fb1d"
          },
          {
            "type": "html",
            "text": "[[Category Functional Programming]]",
            "id": "470e5790e0ba2d3bfe9f512b18ca5ed9"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?CurryingSchonfinkelling c2.com]",
            "id": "e39bbd23be8f8fe53b540b0c85dde56b"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1645024170041
    }
  ]
}