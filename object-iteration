{
  "title": "Object iteration",
  "story": [
    {
      "type": "paragraph",
      "id": "1f24f4fcab850c19",
      "text": "One extremely common thing you want to be able to do in JavaScript is iterate over objects. There are a lot of different ways you can do this, and they have subtly different results. As with most things where the are a proliferation of different ways to do the same thing that all end up slightly differently, object iteration is one of the [[JavaScript common pitfalls]]. This page only looks at how object iteration works in the common es5 environments. If you support ie8 and before, this isn't helpful."
    },
    {
      "type": "paragraph",
      "id": "3b5f21c46b03537e",
      "text": "For our purposes there are essentially for different kinds of properties. Normal own properties, inherited properties, nonenumerable properties, and properties that are both inherited and nonenumerable."
    },
    {
      "type": "paragraph",
      "id": "20540de7245c8171",
      "text": "The first are properties that are actually on the object we have a reference to, and haven't been explicitly set to be nonenumerable. This is mostly the stuff we have added to an object ourselves. My favorite way to iterate over these things is `Object.keys`"
    },
    {
      "type": "code",
      "id": "606245a173ce5518",
      "text": "var junker = new Car('Jalopy')\n\nfunction Car (name) {\n  Object.defineProperty(this, 'name', { value: name, enumerable: false })\n}\n\nCar.prototype.honk = function () {\n  console.log('Aoogah aoogah!')\n}\n\njunker.mileage = 300000\n\nconsole.log(Object.keys(junker)) // [ 'mileage' ]"
    },
    {
      "type": "paragraph",
      "id": "06d89497bac651a9",
      "text": "The second are properties that are available via the prototype chain. These are properties like \"class\" style methods from object constructors we have defined, or methods on objects we have newed up from libraries we required. My favorite way to include these in our iteration is the \"for in\" loop."
    },
    {
      "type": "code",
      "id": "f513b65a720f6809",
      "text": "var junker = new Car('Jalopy')\n\nfunction Car (name) {\n  Object.defineProperty(this, 'name', { value: name, enumerable: false })\n}\n\nCar.prototype.honk = function () {\n  console.log('Aoogah aoogah!')\n}\n\njunker.mileage = 300000\n\nfor (var i in junker) {\n  console.log(i)\n}\n// mileage\n// honk\n"
    },
    {
      "type": "paragraph",
      "id": "74fb6f01892f0b93",
      "text": "The third are properties we have defined via \"Object.defineProperty\" to be nonenumerable, maybe to hide private information on an object, or define a one off method that shouldn't be accessed by code iterating over an object. This is also the responsible way for third party code to define properties on objects they don't control the usage of. If you want to get properties defined directly on an object regardless of enumerable status, use `Object.getOwnPropertyNames`."
    },
    {
      "type": "code",
      "id": "ed5883a127ee5473",
      "text": "var junker = new Car('Jalopy')\n\nfunction Car (name) {\n  Object.defineProperty(this, 'name', { value: name, enumerable: false })\n}\n\nCar.prototype.honk = function () {\n  console.log('Aoogah aoogah!')\n}\n\njunker.mileage = 300000\n\nconsole.log(Object.getOwnPropertyNames(junker))\n// [ 'mileage', 'name' ]\n"
    },
    {
      "type": "paragraph",
      "id": "d6e9ca2ca4444677",
      "text": "The last are generally properties from built in base class prototypes, like '.toString' that is defined on all objects that inherit from Object.prototype, or '.map' on arrays. There isn't a straight forward way to get all of these properties at once, which is probably ok, since it is pretty rare to want them all. Here's how you'd do it if you need it:"
    },
    {
      "type": "code",
      "id": "6d5f4507db8a8ff5",
      "text": "var junker = new Car('Jalopy')\n\nfunction Car (name) {\n  Object.defineProperty(this, 'name', { value: name, enumerable: false })\n}\n\nCar.prototype.honk = function () {\n  console.log('Aoogah aoogah!')\n}\n\njunker.mileage = 300000\n\nconsole.log(Object.getOwnPropertyNames(junker))\n\nvar step = junker\nwhile (step = Object.getPrototypeOf(step)) {\n  console.log(Object.getOwnPropertyNames(step))\n}\n\n//[ 'name', 'mileage' ]\n//[ 'constructor', 'honk' ]\n//[ 'constructor',\n//  'toString',\n//  'toLocaleString',\n//  'valueOf',\n//  'hasOwnProperty',\n//  'isPrototypeOf',\n//  'propertyIsEnumerable',\n//  '__defineGetter__',\n//  '__lookupGetter__',\n//  '__defineSetter__',\n//  '__lookupSetter__',\n//  '__proto__' ]\n"
    },
    {
      "type": "paragraph",
      "id": "a13d44a4365b88de",
      "text": "These all do pretty sensible things now. It wasn't always so. In es3 there wasn't such a thing as nonenumerable, or `Object.keys`... So be happy that very few people really have to support es3 environments anymore. If you do, sorry, sucks to be you."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Object iteration",
        "story": []
      },
      "date": 1433137774652
    },
    {
      "item": {
        "type": "factory",
        "id": "1f24f4fcab850c19"
      },
      "id": "1f24f4fcab850c19",
      "type": "add",
      "date": 1433137776705
    },
    {
      "type": "edit",
      "id": "1f24f4fcab850c19",
      "item": {
        "type": "paragraph",
        "id": "1f24f4fcab850c19",
        "text": "One extremely common thing you want to be able to do in JavaScript is iterate over objects. There are a lot of different ways you can do this, and they have subtly different results. As with most things where the are a proliferation of different ways to do the same thing that all end up slightly differently, object iteration is one of the [[JavaScript common pitfalls]]."
      },
      "date": 1433137887140
    },
    {
      "item": {
        "type": "factory",
        "id": "d3f6002df5874d17"
      },
      "id": "d3f6002df5874d17",
      "type": "add",
      "after": "1f24f4fcab850c19",
      "date": 1433137895529
    },
    {
      "type": "remove",
      "id": "d3f6002df5874d17",
      "date": 1433137975935
    },
    {
      "type": "add",
      "id": "3b5f21c46b03537e",
      "item": {
        "type": "paragraph",
        "id": "3b5f21c46b03537e",
        "text": "For our purposes there are essentially for different kinds of properties. Normal own properties, inherited properties, noniterable properties, and properties that are both inherited and noniterable."
      },
      "after": "1f24f4fcab850c19",
      "date": 1433138102332
    },
    {
      "type": "add",
      "id": "20540de7245c8171",
      "item": {
        "type": "paragraph",
        "id": "20540de7245c8171",
        "text": "The first are properties that are actually on the object we have a reference to, and haven't been explicitly set to be noniterable. This is most of the stuff we have added to an object ourselves."
      },
      "after": "3b5f21c46b03537e",
      "date": 1433138117341
    },
    {
      "type": "add",
      "id": "06d89497bac651a9",
      "item": {
        "type": "paragraph",
        "id": "06d89497bac651a9",
        "text": "The second are properties that are available via the prototype chain. These are properties like \"class\" style methods from object constructors we have defined, or methods on objects we have newed up from libraries we required."
      },
      "after": "20540de7245c8171",
      "date": 1433138257893
    },
    {
      "type": "add",
      "id": "d6e9ca2ca4444677",
      "item": {
        "type": "paragraph",
        "id": "d6e9ca2ca4444677",
        "text": "The last are generally properties from built in base class prototypes, like '.toString' that is defined on all objects that inherit from Object.prototype, or '.map' on arrays."
      },
      "after": "06d89497bac651a9",
      "date": 1433138334394
    },
    {
      "type": "add",
      "id": "74fb6f01892f0b93",
      "item": {
        "type": "paragraph",
        "id": "74fb6f01892f0b93",
        "text": "The third are properties we have defined via \"Object.define\" to be noniterable, maybe to hide private information on an object, or define a one off method that shouldn't be accessed by code iterating over an object. This is also the responsible way for third party code to define properties on objects they don't control the usage of."
      },
      "after": "06d89497bac651a9",
      "date": 1433138496305
    },
    {
      "type": "edit",
      "id": "20540de7245c8171",
      "item": {
        "type": "paragraph",
        "id": "20540de7245c8171",
        "text": "The first are properties that are actually on the object we have a reference to, and haven't been explicitly set to be noniterable. This is mostly the stuff we have added to an object ourselves. My favorite way to iterate over these things is `Object.keys`"
      },
      "date": 1433139113079
    },
    {
      "item": {
        "type": "factory",
        "id": "606245a173ce5518"
      },
      "id": "606245a173ce5518",
      "type": "add",
      "after": "d6e9ca2ca4444677",
      "date": 1433139216508
    },
    {
      "type": "move",
      "order": [
        "1f24f4fcab850c19",
        "3b5f21c46b03537e",
        "20540de7245c8171",
        "606245a173ce5518",
        "06d89497bac651a9",
        "74fb6f01892f0b93",
        "d6e9ca2ca4444677"
      ],
      "id": "606245a173ce5518",
      "date": 1433139219516
    },
    {
      "type": "edit",
      "id": "606245a173ce5518",
      "item": {
        "type": "code",
        "id": "606245a173ce5518",
        "text": "var junker = new Car('Jalopy')\n\nfunction Car (name) {\n  Object.defineProperty(this, 'name', { value: name, enumerable: false })\n}\n\nCar.prototype.honk = function () {\n  console.log('Aoogah aoogah!')\n}\n\njunker.milage = 300000\n\nconsole.log(Object.keys(junker)) // [ 'milage' ]"
      },
      "date": 1433139226531
    },
    {
      "type": "edit",
      "id": "606245a173ce5518",
      "item": {
        "type": "code",
        "id": "606245a173ce5518",
        "text": "var junker = new Car('Jalopy')\n\nfunction Car (name) {\n  Object.defineProperty(this, 'name', { value: name, enumerable: false })\n}\n\nCar.prototype.honk = function () {\n  console.log('Aoogah aoogah!')\n}\n\njunker.mileage = 300000\n\nconsole.log(Object.keys(junker)) // [ 'mileage' ]"
      },
      "date": 1433139392200
    },
    {
      "type": "edit",
      "id": "06d89497bac651a9",
      "item": {
        "type": "paragraph",
        "id": "06d89497bac651a9",
        "text": "The second are properties that are available via the prototype chain. These are properties like \"class\" style methods from object constructors we have defined, or methods on objects we have newed up from libraries we required. My favorite way to include these in our iteration is the \"for in\" loop."
      },
      "date": 1433139460812
    },
    {
      "type": "edit",
      "id": "3b5f21c46b03537e",
      "item": {
        "type": "paragraph",
        "id": "3b5f21c46b03537e",
        "text": "For our purposes there are essentially for different kinds of properties. Normal own properties, inherited properties, nonenumerable properties, and properties that are both inherited and nonenumerable."
      },
      "date": 1433139500647
    },
    {
      "type": "edit",
      "id": "20540de7245c8171",
      "item": {
        "type": "paragraph",
        "id": "20540de7245c8171",
        "text": "The first are properties that are actually on the object we have a reference to, and haven't been explicitly set to be nonenumerable. This is mostly the stuff we have added to an object ourselves. My favorite way to iterate over these things is `Object.keys`"
      },
      "date": 1433139512646
    },
    {
      "type": "edit",
      "id": "74fb6f01892f0b93",
      "item": {
        "type": "paragraph",
        "id": "74fb6f01892f0b93",
        "text": "The third are properties we have defined via \"Object.defineProperty\" to be nonenumerable, maybe to hide private information on an object, or define a one off method that shouldn't be accessed by code iterating over an object. This is also the responsible way for third party code to define properties on objects they don't control the usage of."
      },
      "date": 1433139522922
    },
    {
      "item": {
        "type": "factory",
        "id": "f513b65a720f6809"
      },
      "id": "f513b65a720f6809",
      "type": "add",
      "after": "d6e9ca2ca4444677",
      "date": 1433139595160
    },
    {
      "type": "move",
      "order": [
        "1f24f4fcab850c19",
        "3b5f21c46b03537e",
        "20540de7245c8171",
        "606245a173ce5518",
        "06d89497bac651a9",
        "f513b65a720f6809",
        "74fb6f01892f0b93",
        "d6e9ca2ca4444677"
      ],
      "id": "f513b65a720f6809",
      "date": 1433139597942
    },
    {
      "type": "edit",
      "id": "f513b65a720f6809",
      "item": {
        "type": "code",
        "id": "f513b65a720f6809",
        "text": "var junker = new Car('Jalopy')\n\nfunction Car (name) {\n  Object.defineProperty(this, 'name', { value: name, enumerable: false })\n}\n\nCar.prototype.honk = function () {\n  console.log('Aoogah aoogah!')\n}\n\njunker.mileage = 300000\n\nfor (var i in junker) {\n  console.log(i)\n}\n// mileage\n// honk\n"
      },
      "date": 1433139606762
    },
    {
      "type": "edit",
      "id": "74fb6f01892f0b93",
      "item": {
        "type": "paragraph",
        "id": "74fb6f01892f0b93",
        "text": "The third are properties we have defined via \"Object.defineProperty\" to be nonenumerable, maybe to hide private information on an object, or define a one off method that shouldn't be accessed by code iterating over an object. This is also the responsible way for third party code to define properties on objects they don't control the usage of. If you want to get properties defined directly on an object regardless of enumerable status, use `Object.getOwnPropertyNames`."
      },
      "date": 1433139834209
    },
    {
      "item": {
        "type": "factory",
        "id": "ef1dff1e8be09962"
      },
      "id": "ef1dff1e8be09962",
      "type": "add",
      "after": "d6e9ca2ca4444677",
      "date": 1433139835597
    },
    {
      "type": "move",
      "order": [
        "1f24f4fcab850c19",
        "3b5f21c46b03537e",
        "20540de7245c8171",
        "606245a173ce5518",
        "06d89497bac651a9",
        "f513b65a720f6809",
        "74fb6f01892f0b93",
        "ef1dff1e8be09962",
        "d6e9ca2ca4444677"
      ],
      "id": "ef1dff1e8be09962",
      "date": 1433139838007
    },
    {
      "type": "edit",
      "id": "ef1dff1e8be09962",
      "item": {
        "type": "paragraph",
        "id": "ef1dff1e8be09962",
        "text": "var junker = new Car('Jalopy')\n\nfunction Car (name) {\n  Object.defineProperty(this, 'name', { value: name, enumerable: false })\n}\n\nCar.prototype.honk = function () {\n  console.log('Aoogah aoogah!')\n}\n\njunker.mileage = 300000\n\nconsole.log(Object.getOwnPropertyNames(junker))\n// [ 'mileage', 'name' ]\n"
      },
      "date": 1433139884504
    },
    {
      "type": "remove",
      "id": "ef1dff1e8be09962",
      "date": 1433139891723
    },
    {
      "item": {
        "type": "factory",
        "id": "ed5883a127ee5473"
      },
      "id": "ed5883a127ee5473",
      "type": "add",
      "after": "d6e9ca2ca4444677",
      "date": 1433139893004
    },
    {
      "type": "edit",
      "id": "ed5883a127ee5473",
      "item": {
        "type": "code",
        "id": "ed5883a127ee5473",
        "text": "var junker = new Car('Jalopy')\n\nfunction Car (name) {\n  Object.defineProperty(this, 'name', { value: name, enumerable: false })\n}\n\nCar.prototype.honk = function () {\n  console.log('Aoogah aoogah!')\n}\n\njunker.mileage = 300000\n\nconsole.log(Object.getOwnPropertyNames(junker))\n// [ 'mileage', 'name' ]\n"
      },
      "date": 1433139900747
    },
    {
      "type": "move",
      "order": [
        "1f24f4fcab850c19",
        "3b5f21c46b03537e",
        "20540de7245c8171",
        "606245a173ce5518",
        "06d89497bac651a9",
        "f513b65a720f6809",
        "74fb6f01892f0b93",
        "ed5883a127ee5473",
        "d6e9ca2ca4444677"
      ],
      "id": "ed5883a127ee5473",
      "date": 1433139904177
    },
    {
      "type": "edit",
      "id": "d6e9ca2ca4444677",
      "item": {
        "type": "paragraph",
        "id": "d6e9ca2ca4444677",
        "text": "The last are generally properties from built in base class prototypes, like '.toString' that is defined on all objects that inherit from Object.prototype, or '.map' on arrays. There isn't a straight forward way to get all of these properties at once, which is probably ok, since it is pretty rare to want them all. Here's how you'd do it if you need it:"
      },
      "date": 1433140359539
    },
    {
      "item": {
        "type": "factory",
        "id": "6d5f4507db8a8ff5"
      },
      "id": "6d5f4507db8a8ff5",
      "type": "add",
      "after": "d6e9ca2ca4444677",
      "date": 1433140697014
    },
    {
      "type": "edit",
      "id": "6d5f4507db8a8ff5",
      "item": {
        "type": "code",
        "id": "6d5f4507db8a8ff5",
        "text": "var junker = new Car('Jalopy')\n\nfunction Car (name) {\n  Object.defineProperty(this, 'name', { value: name, enumerable: false })\n}\n\nCar.prototype.honk = function () {\n  console.log('Aoogah aoogah!')\n}\n\njunker.mileage = 300000\n\nconsole.log(Object.getOwnPropertyNames(junker))\n\nvar step = junker\nwhile (step = Object.getPrototypeOf(step)) {\n  console.log(Object.getOwnPropertyNames(step))\n}\n\n//[ 'name', 'mileage' ]\n//[ 'constructor', 'honk' ]\n//[ 'constructor',\n//  'toString',\n//  'toLocaleString',\n//  'valueOf',\n//  'hasOwnProperty',\n//  'isPrototypeOf',\n//  'propertyIsEnumerable',\n//  '__defineGetter__',\n//  '__lookupGetter__',\n//  '__defineSetter__',\n//  '__lookupSetter__',\n//  '__proto__' ]\n"
      },
      "date": 1433140721367
    },
    {
      "item": {
        "type": "factory",
        "id": "a13d44a4365b88de"
      },
      "id": "a13d44a4365b88de",
      "type": "add",
      "after": "6d5f4507db8a8ff5",
      "date": 1433140835237
    },
    {
      "type": "edit",
      "id": "a13d44a4365b88de",
      "item": {
        "type": "paragraph",
        "id": "a13d44a4365b88de",
        "text": "These all do pretty sensible things now. It wasn't always so. In es3 there wasn't such a thing as nonenumerable, or `Object.keys`... So be happy that very few people really have to support es3 environments anymore. If you do, sorry, sucks to be you."
      },
      "date": 1433141017071
    },
    {
      "type": "edit",
      "id": "1f24f4fcab850c19",
      "item": {
        "type": "paragraph",
        "id": "1f24f4fcab850c19",
        "text": "One extremely common thing you want to be able to do in JavaScript is iterate over objects. There are a lot of different ways you can do this, and they have subtly different results. As with most things where the are a proliferation of different ways to do the same thing that all end up slightly differently, object iteration is one of the [[JavaScript common pitfalls]]. This page only looks at how object iteration works in the common es5 environments. If you support ie8 and before, this isn't helpful."
      },
      "date": 1433141222134
    },
    {
      "type": "fork",
      "site": "nrn.io",
      "date": 1652868570111
    }
  ]
}