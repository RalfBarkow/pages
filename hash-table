{
  "title": "Hash Table",
  "story": [
    {
      "type": "html",
      "text": "A [[Hash Table]] is a data structure for storing key/value pairs; that is, an implementation\nof the [[Dictionary Data Structure]]. Hash tables can be startlingly efficient; insertion and\nretrieval take expected O(1) time (at least for some sorts of [[Hash Table]]). The downside:\nthat word \"expected\" (if you are unlucky, everything can become O(N) instead), and highish\noverhead cost (so that for very small tables, something much simpler may work better).",
      "id": "7ae8a38c341f0410559abc726ad20039"
    },
    {
      "type": "html",
      "text": "\nThe basic idea behind hash tables is very simple. Imagine for a moment that all your\nkeys are small integers: say, none larger than 1000. Then you can just build an array\nwith 1000 elements, and insertion and retrieval just go via direct lookup, obviously\nO(1). Unfortunately, in practice your keys might be strings or 1000-digit numbers or\nsomething worse, so you define a <i>hash function</i> which maps each key to a small integer;\nthen, to look up a given key, you feed it through the hash function and then do a\ndirect table lookup as before.",
      "id": "c9fa1e9fe20db588e470cd8a6b17da2f"
    },
    {
      "type": "html",
      "text": "\nThe difference between a hash table and a plain lookup table, then, is that",
      "id": "f381898d0fee3be9f651c8ec854c5a3b"
    },
    {
      "type": "html",
      "text": "(1) you have to apply the hash function to the key before using it (adding\nsome overhead cost), and then (2) multiple keys might be sent to the same\nhash value by the hash function (so you need a way to deal with that).",
      "id": "93d535e75e0c4db5090559d8ccac6092"
    },
    {
      "type": "html",
      "text": "\nLet's think about #2. There are two main strategies. <i>Open hashing</i>, also\ncalled open addressing, says:\nwhen the table entry you need for a new key/value pair is already occupied,\nfind another unused entry somehow and put it there. <i>Closed hashing</i> says:\neach entry in the table is a secondary data structure (usually a linked list,\nbut there are other possibilities) containing the actual data, and this\ndata structure can be extended without limit. [<b>Caution</b>: some people use\nthe term \"open hashing\" to mean what I've called \"closed hashing\" here!\nThe usage here is in accordance with that in [[The Art Of Computer Programming]] and\n[[Introduction To Algorithms]], both of which are recommended references if you\nwant to know more about hash tables.]",
      "id": "a3394a38005e0f3c9aca55ec5913762e"
    },
    {
      "type": "html",
      "text": "\nWith open hashing, a new problem can arise: perhaps there isn't an unused\nentry anywhere in the table. The table can fill up. This isn't an issue with\nclosed hashing, but that has a different problem as the number of items stored\nin the table increases: those secondary data structures can start to get large,\nso that insertion and lookup times are no longer O(1). The usual answer is the same\nin both cases: allow the table to grow. If you always double its size (or,\nmore generally, always increase its size by at least a fixed constant factor)\nthen the cost of doing this is O(1) amortized.",
      "id": "60c11a79b15ca280f0f1c0f2d247a430"
    },
    {
      "type": "html",
      "text": "\nDepending on the strategy used for finding unused entries, an open-addressing\nhash table may become slow as the table gets close to being full. Typically,\nunsuccessful searches are particularly bad. So it is wise to grow the table\nbefore it is completely full.",
      "id": "6be523a266d11b7ea86ab862c8e20c52"
    },
    {
      "type": "html",
      "text": "\nThere are other sorts of [[Dictionary Data Structure]]s: notably, the many varieties\nof a [[Binary Tree]]. They may be preferable if you need a guarantee on the worst-case\naccess time, or if you want operations such as \"find all keys between a and b\"\nto be efficient. When hash tables are possible at all, though, their typical\nperformance is better than that of tree-based data structures. ",
      "id": "46d402659af5482a426547c84cce6155"
    },
    {
      "type": "html",
      "text": "\nA hash table is a data structure for storing key/value pairs. A dictionary data structure is often made using a hash table. Don't confuse the two. Usually, dictionaries are made using a hash table, but not always. Sometimes, a [[Binary Tree]] or other [[Data Structures]] may be used. The runtime-performance of a hash table is fast. Insert and remove operations are expected to be O(1). A hash table is almost the only data structure where adding and looking up takes order 1.",
      "id": "3fba7d7578674303cda961b419992631"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "afea4af782915b2f0471b767b967eab8"
    },
    {
      "type": "html",
      "text": "Also see: [http://www.nist.gov/dads/HTML/hashtab.html www.nist.gov]",
      "id": "4c774fc2e13fc247b516ffae3606b122"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "afea4af782915b2f0471b767b967eab8"
    },
    {
      "type": "html",
      "text": "[[Category Data Structure]]",
      "id": "9a9dce3d6801991eff7a6290e46cd512"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?HashTable c2.com]",
      "id": "9941e981cd85d6a92ed56deef54e00e3"
    }
  ],
  "journal": [
    {
      "date": 1092089036000,
      "id": "312d6a0efe84ebb7e96c1047791bb070",
      "type": "create",
      "item": {
        "title": "Hash Table",
        "story": [
          {
            "type": "html",
            "text": "A [[Hash Table]] is a data structure for storing key/value pairs; that is, an implementation\nof the [[Dictionary Data Structure]]. Hash tables can be startlingly efficient; insertion and\nretrieval take expected O(1) time (at least for some sorts of [[Hash Table]]). The downside:\nthat word \"expected\" (if you are unlucky, everything can become O(N) instead), and highish\noverhead cost (so that for very small tables, something much simpler may work better).",
            "id": "7ae8a38c341f0410559abc726ad20039"
          },
          {
            "type": "html",
            "text": "\nThe basic idea behind hash tables is very simple. Imagine for a moment that all your\nkeys are small integers: say, none larger than 1000. Then you can just build an array\nwith 1000 elements, and insertion and retrieval just go via direct lookup, obviously\nO(1). Unfortunately, in practice your keys might be strings or 1000-digit numbers or\nsomething worse, so you define a <i>hash function</i> which maps each key to a small integer;\nthen, to look up a given key, you feed it through the hash function and then do a\ndirect table lookup as before.",
            "id": "c9fa1e9fe20db588e470cd8a6b17da2f"
          },
          {
            "type": "html",
            "text": "\nThe difference between a hash table and a plain lookup table, then, is that",
            "id": "f381898d0fee3be9f651c8ec854c5a3b"
          },
          {
            "type": "html",
            "text": "(1) you have to apply the hash function to the key before using it (adding\nsome overhead cost), and then (2) multiple keys might be sent to the same\nhash value by the hash function (so you need a way to deal with that).",
            "id": "93d535e75e0c4db5090559d8ccac6092"
          },
          {
            "type": "html",
            "text": "\nLet's think about #2. There are two main strategies. <i>Open hashing</i>, also\ncalled open addressing, says:\nwhen the table entry you need for a new key/value pair is already occupied,\nfind another unused entry somehow and put it there. <i>Closed hashing</i> says:\neach entry in the table is a secondary data structure (usually a linked list,\nbut there are other possibilities) containing the actual data, and this\ndata structure can be extended without limit. [<b>Caution</b>: some people use\nthe term \"open hashing\" to mean what I've called \"closed hashing\" here!\nThe usage here is in accordance with that in [[The Art Of Computer Programming]] and\n[[Introduction To Algorithms]], both of which are recommended references if you\nwant to know more about hash tables.]",
            "id": "a3394a38005e0f3c9aca55ec5913762e"
          },
          {
            "type": "html",
            "text": "\nWith open hashing, a new problem can arise: perhaps there isn't an unused\nentry anywhere in the table. The table can fill up. This isn't an issue with\nclosed hashing, but that has a different problem as the number of items stored\nin the table increases: those secondary data structures can start to get large,\nso that insertion and lookup times are no longer O(1). The usual answer is the same\nin both cases: allow the table to grow. If you always double its size (or,\nmore generally, always increase its size by at least a fixed constant factor)\nthen the cost of doing this is O(1) amortized.",
            "id": "60c11a79b15ca280f0f1c0f2d247a430"
          },
          {
            "type": "html",
            "text": "\nDepending on the strategy used for finding unused entries, an open-addressing\nhash table may become slow as the table gets close to being full. Typically,\nunsuccessful searches are particularly bad. So it is wise to grow the table\nbefore it is completely full.",
            "id": "6be523a266d11b7ea86ab862c8e20c52"
          },
          {
            "type": "html",
            "text": "\nThere are other sorts of [[Dictionary Data Structure]]s: notably, the many varieties\nof a [[Binary Tree]]. They may be preferable if you need a guarantee on the worst-case\naccess time, or if you want operations such as \"find all keys between a and b\"\nto be efficient. When hash tables are possible at all, though, their typical\nperformance is better than that of tree-based data structures. ",
            "id": "46d402659af5482a426547c84cce6155"
          },
          {
            "type": "html",
            "text": "\nA hash table is a data structure for storing key/value pairs. A dictionary data structure is often made using a hash table. Don't confuse the two. Usually, dictionaries are made using a hash table, but not always. Sometimes, a [[Binary Tree]] or other [[Data Structures]] may be used. The runtime-performance of a hash table is fast. Insert and remove operations are expected to be O(1). A hash table is almost the only data structure where adding and looking up takes order 1.",
            "id": "3fba7d7578674303cda961b419992631"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "afea4af782915b2f0471b767b967eab8"
          },
          {
            "type": "html",
            "text": "Also see: [http://www.nist.gov/dads/HTML/hashtab.html www.nist.gov]",
            "id": "4c774fc2e13fc247b516ffae3606b122"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "afea4af782915b2f0471b767b967eab8"
          },
          {
            "type": "html",
            "text": "[[Category Data Structure]]",
            "id": "9a9dce3d6801991eff7a6290e46cd512"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?HashTable c2.com]",
            "id": "9941e981cd85d6a92ed56deef54e00e3"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1628111898221
    }
  ]
}