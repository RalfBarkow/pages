{
  "title": "2022-08-02",
  "story": [
    {
      "type": "paragraph",
      "id": "e8454c9cfb4a1d6b",
      "text": "SCHÖNWÄLDER-KUNTZE, Tatjana, WILLE, Katrin, HÖLSCHER, Thomas and SPENCER-BROWN, G., 2009. [[George Spencer Brown]]: eine Einführung in die “[[Laws of Form]].” . 2., überarb. Aufl. Wiesbaden: VS Verl. für Sozialwissenschaften. Lehrbuch. ISBN 978-3-531-16105-1. \n"
    },
    {
      "type": "markdown",
      "id": "be07065a3cef35db",
      "text": "## Interpretation of the development of the book"
    },
    {
      "type": "markdown",
      "id": "7a71b38064a76d07",
      "text": "The *[[Laws of Form]]* are divided into twelve chapters, each with its own headings and its own notes, which appear at the end of the main text. The main focus is on the main text, i.e. the appendices are not taken into account here. In my opinion, the order of the chapters is neither motivated by the fact that the next one could be derived from the previous one in a logical sense, nor does it correspond to a composition with prefixes and suffixes. Rather, it can be shown that each chapter, as the previous one, prepares the following ones insofar as first it is 'carried out' in a processual way, which is then reflected upon and conceptualized, and only then can be presented in a descriptive way. The following chapters reflect, explicate and formalize parts of the processes that are carried out in the preceding chapters. But at the same time, they also limit the possibilities that appear by definition. \n\nThus, one connection is to give form to what has already been 'accomplished'. A further connection between the chapters is to be seen in the fact that subsequent chapters actually realize one or more of the potential development possibilities that have been created in advance, and thus also allow new things to emerge throughout."
    },
    {
      "type": "paragraph",
      "id": "93fc7d8e1343c237",
      "text": "The first, the eighth and the twelfth chapters are special because they focus on the laws of form, of auften', in a specific way: the first chapter as a provision of the preconditions and description of form per se; the eighth as a generalized reflection on the connection between the complete representation of the form of the first distinction (primary arithmetic) on the one hand and the connections between representing indications (primary algebra), which in turn become visible in this representation, on the other hand. The twelfth chapter can be read as a (semiotic) variation of the second chapter and thus as another representation of the form of the first distinction."
    },
    {
      "type": "paragraph",
      "id": "cff7f5a5e10d7bf9",
      "text": "The sequence within the first chapter reflects the described procedure of other parts of the book 'in nuce': It begins with the explicit presupposition of two ideas by Spencer Brown, the 'idea of distinction' and the 'idea of indication'. The first of the two ideas is then defined, i.e. conceptualized, and explained by means of an example. Two axioms follow, which formulate laws, which are to apply to the repetition of the second, up to then not yet defined presupposition - the idea of indication. Here the hint is defined, as it were, by its use, which is permitted or made possible by the axioms or the laws. At the same time, it becomes clear in the text of the first chapter that the distinction of the two ideas 'distinction' and 'indication' is owed to a certain differentiating perspective, i.e. that they could also be interpreted as two 'properties' of a single act. Every indication-giving act is at the same time a distinction and every distinction-giving act is also an indication in and of itself."
    },
    {
      "type": "paragraph",
      "id": "bcc14275e2bc1774",
      "text": "This simplification of different facets of a process, with the resulting possible differentiation of different aspects of a process on the one hand and the simultaneous view of the 'undifferentiatedness' on the other hand, is an essential methodological moment of the Laws ofForm . The progress of the book in the first chapters can be described analogously: First it is 'made', then different aspects are named and thus introduced as different. In the further use it then turns out that the difference on the basal level, on which the Laws of Form play, does not yet make sense at all, and so the differences between the aspects are partially retracted. On the other hand, it turns out to be useful to stabilize certain differences - depending on what purpose they serve, what is shown with them. In this way, it becomes clear that what seems to be newly introduced has emerged out of the stabilizing use of a possible differentiation of what already exists."
    },
    {
      "type": "paragraph",
      "id": "762d216382952371",
      "text": "The representational scheme that the book follows can be described as a varying repetition of the following stages, some of which are often only implicit: (1) Positioning or stating a difference, for example, by using different terms. (2 a) Followed by a cancellation of the difference by explicit requests to (re)equate what is named. (2 b) Followed by an explication of the introduced distinction by a request to imitate it or by a definition which is subsequently formalized. (3 a) This is followed by explicit requests to the reader to use what has been introduced according to established laws or rules, i.e. also in the formalized form. (3 b) Formulation of rules to retract already made distinctions, to abolish differences. (4) Implicit invitation to the exegete: See what all arises or can arise when it comes to use and how and what is thereby prompted and what distinctions are relevant at what point. (5) or again (1) Selection, naming, explicitation and use of further differences relevant in the respective context."
    },
    {
      "type": "paragraph",
      "id": "3d21941474a95c5e",
      "text": "A strict assignment of the individual chapters to the various stages is not possible for the following reasons: the further back in the book the chapter is placed, the more complex the contents and forms are represented by individual characters, while at the same time specializing in very specific aspects that are relevant in the respective contexts. Parallel to this, however, more and more differences are retracted as not (anymore) rele vant. Increasingly, several of these stages of parts of the chapter contents are passed through in parallel. The intermediate titles in the Laws of Form, for example, have the function of explicitly naming the new aspect, even if the canon, rule or theorem is about properties that have been known for a long time or have already appeared differently."
    },
    {
      "type": "paragraph",
      "id": "8e3291141b3f38e8",
      "text": "⇒ 2. Content development up to primary algebra (chapter 1 - 5)"
    },
    {
      "type": "pagefold",
      "id": "3e5e59bca3f3c8aa",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "91498117e80fdbca",
      "text": "NOR: Truth Table, True Distinction – https://www.emerald.com/insight/content/doi/10.1108/978-1-83982-610-820211005/full/html"
    },
    {
      "type": "markdown",
      "id": "7a42ca00a3c5680e",
      "text": "Towards a Phenomenology of Schematization. [https://www.ingentaconnect.com/content/imp/chk/2017/00000024/f0020003/art00010 page], [https://www.ingentaconnect.com/content/imp/chk/2017/00000024/f0020003/art00010 pdf]"
    },
    {
      "type": "paragraph",
      "id": "72b438f4ff35b967",
      "text": "Кузнецов В.Ю. Различие, производящее различие (Difference producing difference). [https://www.iphras.ru/uplfile/root/news/archive_events/2015/14_05_15_pod/Kuznecov.pdf pdf] (ru)"
    },
    {
      "type": "paragraph",
      "id": "ebf0b75c4b4faa88",
      "text": "According to Bateson, \"A 'bit' of information can be defined as a distinguishable difference (a difference that makes a difference). Such a difference, moving along a circuit and undergoing successive transformations in it, is an elementary idea. [1, p. 337; cf. pp. 294, 339, 418, 421.] Another, later version of the translation, also suggested by Dmitry Fedotov, is \"indifferent distinction\" [14]. [14, с. 9]. However, it is worth paying attention to the almost literal, literal meaning of this term (\"difference producing difference\") to see and be able to describe the unfolding dynamics of this process in human communication. For example, [[Niklas Luhmann]] formulates, with reference to Bateson, \"Information is nothing other than an event which promotes the binding of distinctions, a distinction which creates a distinction\" [9, 117]. [9, с. 117]."
    },
    {
      "type": "paragraph",
      "id": "78b21e8cdd0bf4c2",
      "text": "The distinction must be made, fulfilled-as a distinction. In doing so, the distinction will also bear witness to the world. \"Every distinction represents the world by the fact that its other side represents that which is not observed at the moment. \"Distinction is perfect continence, \"1 as Spencer-Brown lapidarily puts it [17, p. 1].\" [7, с. 57]. Constantly elusive traces are also noticed through the effects of distinction. \"There is no trace itself, its own trace. Heidegger is just saying that difference could not appear as difference itself (Lichtung des Unterschiedes kann deshalb auch nicht bedeuten, daß der Unterschied als der Unterschied erscheint). The trace of this trace, which (is) difference, especially could neither appear nor be named as itself, that is, in its presence.\" [6, с. 94]."
    },
    {
      "type": "paragraph",
      "id": "4228a888e0d04b2f",
      "text": "The most apparently elementary or atomic (that is, indecomposable into phases, stages, etc.) procedures or operations through which the entire complex of intellectual actions is ultimately performed are two - distinction and identification. Because of their fundamental nature, they are very difficult to fix directly and directly; their action, however, is quite possible to trace on a particular material by the effects they produce. It is their interdependence, feasibility practically at any point of conceptual space and effective efficiency that presuppose their condition of possibility the principle of unity of the world, understood as the potential traceability of universal connections, and the interrelated principle of unity of culture, understood as the potential ability to constitute these or those connections, provided by the entire arsenal of sociocultural means and mechanisms. The effectiveness of the operations of distinction and identification, as well as their fundamental divergence from the presumably present - classical identity and difference [cf. 4; 5; 16], can be demonstrated quite clearly on the material of language, time and consciousness."
    },
    {
      "type": "paragraph",
      "id": "0dad1da9f7188841",
      "text": "The situation with language is perhaps most graphic, since language represents a discriminating distinction. \"Symbolic systems - means of cognition and communication - can exercise their structuring power only because they are structured. Symbolic power is the power to construct reality by establishing an epistemological order: the immediate worldview (and especially the sense of the social world) implies what Durkheim called logical conformism, that is, \"a homogeneous perception of time, space, number, reason, which makes possible agreement between minds. [2, с. 89]. Language is a kind of difference machine [cf. 3], which was established as early as by Sossur2, who \"is first of all the one who postulated the arbitrariness of the sign and the differential character of the sign as the basis of general semiology and, in particular, of linguistics. And, as we know, these two motifs - arbitrariness and differential character - are, from his point of view, inseparable. Arbitrariness can only be because the system of signs is set by difference, not by the completeness of terms. The elements of meaning function not because of the compressed force of the nuclei, but because of the network of oppositions that distinguish them and relate them to one another. \"Arbitrariness and differential character,\" as Sossure says, \"are two correlative qualities.\" [6, с. 32]. Hence Sossur's direct interpretation of the research tasks in relation to language: \"Science and is concerned with the play of these meaningful differences\". [12, с. 23]. But the integrity of language - mediated and mediating - unfolds in time, fixing also the duration of processes."
    },
    {
      "type": "paragraph",
      "id": "58c8b83ca6d3d024",
      "text": "Indeed, the correspondence of phenomenologically grasped representations of one event in time, as Merleau-Ponty emphasizes, does not shrink into \"a certain ideal unity, as Kant wanted it\". [10, p. 278], since it itself is perceived only through and through its mappings. \"'Moments'... do not exist sequentially, but differentiate one from another... We are not dealing here with a multiplicity of phenomena, but with a single phenomenon of expiration (ecoulement). Time is a single movement, consistent with itself in all its parts, like a gesture that encompasses all the muscular contractions necessary for its realization. [10, с. 279]. Dynamic temporal flow smoothly and fluidly, but inexorably and unstoppably shifts and displaces plans and horizons of perception. In other words, the unity of the temporal flow is determined by the composition of identification and distinction operations performed by consciousness."
    },
    {
      "type": "paragraph",
      "id": "761f2c8e198b4139",
      "text": "The differentiating differentiation of consciousness allows us to distinguish (and identify) - including moments of time - through the inevitable fixation by means of language as a kind of distinguishing machine: \"both explicit and implicit philosophical-hermeneutical conceptualizations of time in the course of justifying their own achievements (in particular, in the course of justifying the consistency of the criteria for conceptualizing time) have to appeal to language either, in the first case, as a source of the lasting meanings of time, or, in the second case, as a way of identifying temporal experience\". [15, с. 120]. And it is the experience of discernment that constitutes consciousness. \"Identification, recognition, recognition, recognition (all synonyms) presuppose recognition, distinguishing an object, process, etc., from the general 'mass' of objects, from the totality of other processes. The experience of recognition is the experience of selection, which involves distinguishing colors, shapes, spatial positions, etc. of an object. It is this distinction that \"prepares\" synthesis and then identification. [11, с. 59]."
    },
    {
      "type": "paragraph",
      "id": "c1ac818ba0fcfae6",
      "text": "The opposition of identity/difference (presumably independently present), which continues to prevail more or less explicitly not only in classical but also in post-classical philosophy (up to and including Deleuze and Derrida), seems therefore appropriate to be replaced by the concept of inextricably interrelated procedures or operations of distinguishing and identifying (through certain means of \"differences that produce differences\"), only through the action of which identities and differences can be understood one way or another."
    },
    {
      "type": "pagefold",
      "id": "8e3d2426dac00592",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "82947701bb2dc4c6",
      "text": "[[Affiliation]] ⇒ [[MpAffiliation]]"
    },
    {
      "type": "paragraph",
      "id": "6141c6c8b9a284fd",
      "text": "[[ThirtyTwoBitRegister]]"
    },
    {
      "type": "code",
      "id": "91c12a62501fec74",
      "text": "bitXor: aThirtTwoBitRegister\n\t\"Replace my contents with the bitwise exclusive OR of the given register and my current contents.\"\n\n\thi := hi bitXor: aThirtTwoBitRegister hi.\n\tlow := low bitXor: aThirtTwoBitRegister low."
    },
    {
      "type": "markdown",
      "id": "15e0766561395daa",
      "text": "## whatIsAPrimitive"
    },
    {
      "type": "paragraph",
      "id": "49cda41d17a3dd76",
      "text": "\t\"Some messages in the system are responded to primitively. A primitive   \n\tresponse is performed directly by the interpreter rather than by evaluating   \n\texpressions in a method. The methods for these messages indicate the   \n\tpresence of a primitive response by including <primitive: xx> or \n\t<primitive: 79 error: ec>before the first expression in the method.  "
    },
    {
      "type": "paragraph",
      "id": "8baf8991c1d374c2",
      "text": "In the second case, ec is a special temporary variable that holds an error code. \n\tIn the VM primitive, failure is indicated by a variable called primFailCode being \n\tnon-zero. On activating a method with a failing primitive, if the index is in \n\tbounds of the \tprimitiveFailCodes array in the VMspecialObjectsArray then the \n\tfailure code substitutes the symbol in the \tprimitiveFailCodes array, otherwise \n\tit supplies the integer value.\n\t  \n\t"
    },
    {
      "type": "paragraph",
      "id": "1e611c3ff09d7261",
      "text": "Primitives exist for several reasons. Certain basic or 'primitive' \n\toperations cannot be performed in any other way. Smalltalk without \n\tprimitives can move values from one variable to another, but cannot add two \n\tSmallIntegers together. Many methods for arithmetic and comparison \n\tbetween numbers are primitives. Some primitives allow Smalltalk to \n\tcommunicate with I/O devices such as the disk, the display, and the keyboard. \n\tSome primitives exist only to make the system run faster; each does the same \n\tthing as a certain Smalltalk method, and its implementation as a primitive is \n\toptional.  \n\t  \n\t"
    },
    {
      "type": "paragraph",
      "id": "bf6614d73e0998ad",
      "text": "When the Smalltalk interpreter begins to execute a method which specifies a \n\tprimitive response, it tries to perform the primitive action and to return a \n\tresult. If the routine in the interpreter for this primitive is successful, \n\tit will return a value and the expressions in the method will not be evaluated. \n\tIf the primitive routine is not successful, the primitive 'fails', and the \n\tSmalltalk expressions in the method are executed instead. These \n\texpressions are evaluated as though the primitive routine had not been \n\tcalled.  \n\t  \n\t"
    },
    {
      "type": "paragraph",
      "id": "6a0cb87eadd4f491",
      "text": "The Smalltalk code that is evaluated when a primitive fails usually \n\tanticipates why that primitive might fail. If the primitive is optional, the \n\texpressions in the method do exactly what the primitive would have done (See \n\tNumber @). If the primitive only works on certain classes of arguments, the \n\tSmalltalk code tries to coerce the argument or appeals to a superclass to find \n\ta more general way of doing the operation (see SmallInteger +). If the \n\tprimitive is never supposed to fail, the expressions signal an error (see \n\tSmallInteger asFloat).  \n\t  \n\t"
    },
    {
      "type": "paragraph",
      "id": "17084d96b8dce091",
      "text": "Each method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\t"
    },
    {
      "type": "paragraph",
      "id": "56077cc2159acd48",
      "text": "If a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\t"
    },
    {
      "type": "paragraph",
      "id": "f2243294321d7f14",
      "text": "For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\"\n\t\n\t\n\n\t"
    },
    {
      "type": "code",
      "id": "67e0f3510a3a551a",
      "text": "self error: 'comment only'"
    },
    {
      "type": "pagefold",
      "id": "a7047f62fcfd223e",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "fe115d720eb9317d",
      "text": "Example for Objects calling each other’s methods recursively. [https://stackoverflow.com/questions/36811921/example-for-objects-calling-each-other-s-methods-recursively#36828935 stackoverflow]"
    },
    {
      "type": "pagefold",
      "id": "352551ed737e54d0",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "d5d263e4cefc55e2",
      "text": "⇒ [[Possibility Waves]] ⇒ [[Möglichkeitswellen]] "
    },
    {
      "type": "markdown",
      "id": "5c1a8716b40d2287",
      "text": "single-input not gates – https://scholar.google.com/scholar?hl=de&as_sdt=0%2C5&q=%22single-input+not+gates%22&btnG="
    },
    {
      "type": "markdown",
      "id": "d83ade2794b1e67a",
      "text": "STOJANOVIC, Milan N., MITCHELL, Tiffany Elizabeth and STEFANOVIC, Darko, 2002. Deoxyribozyme-Based Logic Gates. Journal of the American Chemical Society. Online. 1 April 2002. Vol. 124, no. 14, p. 3555–3561. [https://pubs.acs.org/doi/abs/10.1021/ja016756v doi]"
    },
    {
      "type": "markdown",
      "id": "12d20ed4877efd82",
      "text": "> We report herein a set of deoxyribozyme-based logic gates capable of generating any Boolean function. We construct basic NOT and AND gates, followed by the more complex XOR gate. These gates were constructed through a modular design that combines molecular beacon stem-loops with hammerhead-type deoxyribozymes. Importantly, as the gates have oligonucleotides as both inputs and output, they open the possibility of communication between various computation elements in solution. The operation of these gates is conveniently connected to a fluorescent readout. "
    },
    {
      "type": "pagefold",
      "id": "795e806766b5ebbe",
      "text": "Resilience"
    },
    {
      "type": "paragraph",
      "id": "37157591b972e621",
      "text": "⇒ [[Measuring Resilience in the Assumed City]]"
    },
    {
      "type": "pagefold",
      "id": "aadf6e3a64e0a89b",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "bd17198a165a1ead",
      "text": "⇒ [[ZTimestamp]]"
    },
    {
      "type": "paragraph",
      "id": "71109e9f8ee77643",
      "text": "⇒ [[Containment]] ⇒ [[RBMessageNode]]"
    },
    {
      "type": "code",
      "id": "18ad666721e10926",
      "text": "RBMessageNode>>#isContainmentReplacement:"
    },
    {
      "type": "code",
      "id": "24f52e4338d0b841",
      "text": "RBMessageNode>>#replaceContainmentSourceWith:"
    },
    {
      "type": "paragraph",
      "id": "82c3c093eb97250c",
      "text": "cf. Limbo, slicing with the help of a syntax tree."
    },
    {
      "type": "markdown",
      "id": "40e9dd31b10d8dc9",
      "text": "[[George Fairbanks]] (2007), Design Fragments. [https://apps.dtic.mil/sti/pdfs/ADA469340.pdf pdf]"
    },
    {
      "type": "pagefold",
      "id": "f5b128318b9f8bb2",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "dfc063b1a0d23f54",
      "text": "\nSALIH, Husam, ABDELWAHAB, Hammam and ABDALLAH, Areej, 2017. Automation design for a syrup production line using Siemens PLC S7-1200 and TIA Portal software. In: 2017 International Conference on Communication, Control, Computing and Electronics Engineering (ICCCCEE). January 2017. p. 1–5. DOI 10.1109/ICCCCEE.2017.7866702. \n> In the world of Automation Industrial, Programmable Logic Controllers (PLCs) are the dominant types of automatic controllers, and so engineers are racing to develop the best software to give it the ultimate abilities to maximize the outcome. Basically, for understanding the concepts of controlling any process. Mathematical modeling is a mandatory procedure and hence this paper describes a method to model tank systems in order to control the input flow and the output flow. This paper also discusses the use of the Siemens PLC S7-1200 as the system controller with provision of the algorithm and the equipment needed. This paper describes the general concepts of controlling liquid flows and capacity in tanks as this process is useful in the automation industrial field. The proposed system is implemented with simple equipment in order to demonstrate the concept of the process and how it is controlled.\n – https://ieeexplore.ieee.org/abstract/document/7866702?casa_token=P2KhR-1JHBIAAAAA:vM4p4n95PJGb8FDbSH8SS_A6i_3XoPouWRJIOniLnOZTlF4jGJZg_V8ReMhAw0JiDh3eWTKoA-U"
    },
    {
      "type": "markdown",
      "id": "b83efdba7d2fccec",
      "text": "\nHUI, Henry and MCLAUGHLIN, Kieran, 2018. Investigating Current PLC Security Issues Regarding Siemens S7 Communications and TIA Portal. Online. 1 August 2018. [Accessed 2 August 2022]. DOI 10.14236/ewic/ICS2018.8. \n> Programmable Logic Controllers (PLCs) are the essential components in many Industrial Control Systems that control physical processes. However, in recent years the security flaws of these devices have come under scrutiny, particularly since the widely discussed Stuxnet attack. To help the industry state-of-the-art to move forward and to provide information required to improve the security for these controllers, this work investigates potential exploits of the Siemens S7-1211C controllers and the Totally Integrated Automation (TIA) engineering software. Using Windbg and Scapy, the anti-replay mechanism of the Siemens proprietary communication protocol, S7CommPlus, and the Profinet Discovery and Basic Configuration Protocol are found to be vulnerable. Attacks like session stealing, phantom PLC, cross connecting controllers and denial of S7 connections are demonstrated. The lack of authentication and consequent exploitation of the S7-ACK packet, an application layer packet for the S7CommPlus protocol, is highlighted as a key issue in this investigation.\n – https://www.scienceopen.com/hosted-document?doi=10.14236/ewic/ICS2018.8"
    },
    {
      "type": "markdown",
      "id": "29a372def491e282",
      "text": "Design and Simulation of Elevator Emergency System Based on TIA Portal V15.1. [https://iopscience.iop.org/article/10.1088/1742-6596/1802/4/042089/meta doi]"
    },
    {
      "type": "markdown",
      "id": "9957547c0a258065",
      "text": "> The main control system of the elevator can issue different instructions for the operation of the elevator according to the different needs of users, so as to achieve the purpose of transporting people and goods efficiently. With the continuous development of China's elevator industry and the significant increase of elevator installed capacity[1], In practical engineering, higher requirements are put forward for elevator safety. In this regard, based on Siemens Portal platform, this paper designs an automatic control emergency system including overweight, over travel protection, door opening and closing protection, to assist the main control system to maintain the normal operation of the elevator. The proposed scheme is simulated in the Elevator Simulation platform, and the results show that the emergency system can effectively prevent the wrong operation during the operation of the elevator, and greatly improve the safety of the elevator. At the same time, because the system is written in LAD language and has good readability and portability, it can be widely used in the elevator master control system with Siemens PLC as the main controller."
    },
    {
      "type": "paragraph",
      "id": "383f2206861451ce",
      "text": "[…] elevator simulation platform of Deprol company […]"
    },
    {
      "type": "markdown",
      "id": "ff9ddafea58f678c",
      "text": "– https://iopscience.iop.org/article/10.1088/1742-6596/2212/1/012010/meta"
    },
    {
      "type": "markdown",
      "id": "289b590b234f9532",
      "text": "> Digital twins are rapidly establishing themselves as a necessary step in digital change also in the design of automated and robotic manufacturing systems. The digital twin serves as an interface between physical industrial products and digital worlds. This allows you to map the continuous availability of data throughout the lifecycle from product planning and development, production and commissioning to use and recycling. An important step towards this goal is to create digital twins of the components in order to create a database usable for the design of new production systems in a virtual environment. One of the possibilities of using the digital twins is testing and virtual commissioning of production systems. Instead of the classic CAD model, the digital twin replaces a detailed digital image of individual components, including their full functionality. The Digital Twin comprises the CAD model, kinematic behavior model a most important is the logical behavior model. Our goal is to create a digital twin component of the production system, integrate a CAD model, create a kinematic model and a logical behavior model. This digital twin will have signals assigned to it for logical behavior. The result is the verification and testing of the information exchange between the virtual control system and the virtual model, using the Software-in-the-Loop method and the Tecnomatix Process Simulate software environment on the digital twin side and the Siemens TIA Portal with PLC SIM Advanced on the controller side. The result of the knowledge is that the exchange of information is functional and usable for virtual commissioning."
    },
    {
      "type": "paragraph",
      "id": "f5062c3e80adbc5f",
      "text": "Tecnomatix Process Simulate"
    },
    {
      "type": "markdown",
      "id": "ac2432289954941f",
      "text": "Siemens Tecnomatix Process Simulate. [https://www.engusa.com/en/product/siemens-tecnomatix-process-simulate page]"
    },
    {
      "type": "markdown",
      "id": "506b1dcd4e64b3af",
      "text": "Methods for Reliable Simulation-Based PLC Code Verification. [https://ieeexplore.ieee.org/abstract/document/6121945 page]"
    },
    {
      "type": "markdown",
      "id": "739bd27619159743",
      "text": "> Simulation-based programmable logic controller (PLC) code verification is a part of [[virtual commissioning]], where the control code is verified against a virtual prototype of an application. With today's general [[OPC]] interface, it is easy to connect a PLC to a simulation tool for, e.g., verification purposes. However, there are some problems with this approach that can lead to an unreliable verification result. In this paper, four major problems with the OPC interface are described, and two possible solutions to the problems are presented: a general IEC 61131-3-based software solution, and a new OPC standard solution."
    },
    {
      "type": "paragraph",
      "id": "2d086fa0534dc18a",
      "text": "⇒ [[Process Simulate]] "
    },
    {
      "type": "paragraph",
      "id": "8631d84a1bab2d51",
      "text": "IEC 61131-3 Ladder Diagram (LD)"
    },
    {
      "type": "paragraph",
      "id": "d1c5d60e3d89cd76",
      "text": "LI, Dandan, CAI, Qixian and PEI, Feng, 2010. The new interconversion algorithm between ladder diagram and instruction list. In: 2010 IEEE International Conference on Intelligent Computing and Intelligent Systems. Online. Xiamen, China: IEEE. October 2010. p. 820–823. [Accessed 2 August 2022]. ISBN 978-1-4244-6582-8. DOI 10.1109/ICICISYS.2010.5658297. \n"
    },
    {
      "type": "markdown",
      "id": "8b2ab5cae2ff1bf0",
      "text": "> In the application of PLC (Programmable Logic Controller), ladder diagram is visual and easy to control by engineering staff, besides, instruction list is easily convert into assembly language program, so they are favored by technicians, so that the research of interconversion between ladder diagram and instruction list become a key technique in development of PLC. The conversion algorithm in present is maps ladder diagram to AOV graph, then it realizes the interconversion between ladder diagram and instruction list by sorting AOV graph, but efficient of the algorithm is lower. A new algorithm about interconversion between ladder diagram and instruction list based on forest and binary tree is presented in this paper by the research and analysis of ladder diagram's language and instruction list on PLC. At first it maps ladder diagram to forest, and then it establishes a binary tree to represent ladder diagram logical relationship with forest At last it realizes the exchange of PLC ladder diagram and instruction list by traversing binary tree. The algorithm is simple and rapid, its correctness and feasibility are verified in programming software platform of PLC."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2022-08-02",
        "story": []
      },
      "date": 1659417405974
    },
    {
      "item": {
        "type": "factory",
        "id": "e8454c9cfb4a1d6b"
      },
      "id": "e8454c9cfb4a1d6b",
      "type": "add",
      "date": 1659417407358
    },
    {
      "type": "edit",
      "id": "e8454c9cfb4a1d6b",
      "item": {
        "type": "paragraph",
        "id": "e8454c9cfb4a1d6b",
        "text": "\nSCHÖNWÄLDER-KUNTZE, Tatjana, WILLE, Katrin, HÖLSCHER, Thomas and SPENCER-BROWN, G., 2009. George Spencer Brown: eine Einführung in die “Laws of Form.” . 2., überarb. Aufl. Wiesbaden: VS Verl. für Sozialwissenschaften. Lehrbuch. ISBN 978-3-531-16105-1. \n"
      },
      "date": 1659417410165
    },
    {
      "type": "edit",
      "id": "e8454c9cfb4a1d6b",
      "item": {
        "type": "paragraph",
        "id": "e8454c9cfb4a1d6b",
        "text": "SCHÖNWÄLDER-KUNTZE, Tatjana, WILLE, Katrin, HÖLSCHER, Thomas and SPENCER-BROWN, G., 2009. [[George Spencer Brown]]: eine Einführung in die “[[Laws of Form]].” . 2., überarb. Aufl. Wiesbaden: VS Verl. für Sozialwissenschaften. Lehrbuch. ISBN 978-3-531-16105-1. \n"
      },
      "date": 1659417433408
    },
    {
      "item": {
        "type": "factory",
        "id": "3e5e59bca3f3c8aa"
      },
      "id": "3e5e59bca3f3c8aa",
      "type": "add",
      "after": "e8454c9cfb4a1d6b",
      "date": 1659417756888
    },
    {
      "type": "edit",
      "id": "3e5e59bca3f3c8aa",
      "item": {
        "type": "pagefold",
        "id": "3e5e59bca3f3c8aa",
        "text": "– https://www.emerald.com/insight/content/doi/10.1108/978-1-83982-610-820211005/full/html"
      },
      "date": 1659417766059
    },
    {
      "type": "edit",
      "id": "3e5e59bca3f3c8aa",
      "item": {
        "type": "pagefold",
        "id": "3e5e59bca3f3c8aa",
        "text": "~"
      },
      "date": 1659417772574
    },
    {
      "item": {
        "type": "factory",
        "id": "91498117e80fdbca"
      },
      "id": "91498117e80fdbca",
      "type": "add",
      "after": "3e5e59bca3f3c8aa",
      "date": 1659417774007
    },
    {
      "item": {
        "type": "factory",
        "id": "be07065a3cef35db"
      },
      "id": "be07065a3cef35db",
      "type": "add",
      "after": "91498117e80fdbca",
      "date": 1659417903028
    },
    {
      "id": "be07065a3cef35db",
      "type": "move",
      "order": [
        "e8454c9cfb4a1d6b",
        "be07065a3cef35db",
        "3e5e59bca3f3c8aa",
        "91498117e80fdbca"
      ],
      "date": 1659417904618
    },
    {
      "type": "edit",
      "id": "be07065a3cef35db",
      "item": {
        "type": "paragraph",
        "id": "be07065a3cef35db",
        "text": "## Interpretation of the development of the book"
      },
      "date": 1659417914056
    },
    {
      "type": "edit",
      "id": "be07065a3cef35db",
      "item": {
        "type": "markdown",
        "id": "be07065a3cef35db",
        "text": "## Interpretation of the development of the book"
      },
      "date": 1659417915663
    },
    {
      "item": {
        "type": "factory",
        "id": "7a71b38064a76d07"
      },
      "id": "7a71b38064a76d07",
      "type": "add",
      "after": "91498117e80fdbca",
      "date": 1659417941812
    },
    {
      "id": "7a71b38064a76d07",
      "type": "move",
      "order": [
        "e8454c9cfb4a1d6b",
        "be07065a3cef35db",
        "7a71b38064a76d07",
        "3e5e59bca3f3c8aa",
        "91498117e80fdbca"
      ],
      "date": 1659417944354
    },
    {
      "type": "edit",
      "id": "7a71b38064a76d07",
      "item": {
        "type": "paragraph",
        "id": "7a71b38064a76d07",
        "text": "The Laws of Form are divided into twelve chapters, each with its own headings and its own notes, which appear at the end of the main text. The main focus is on the main text, i.e. the appendices are not taken into account here. In my opinion, the order of the chapters is neither motivated by the fact that the next one could be derived from the previous one in a logical sense, nor does it correspond to a composition with prefixes and suffixes. Rather, it can be shown that each chapter, as the previous one, prepares the following ones insofar as first it is 'carried out' in a processual way, which is then reflected upon and conceptualized, and only then can be presented in a descriptive way. The following chapters reflect, explicate and formalize parts of the processes that are carried out in the preceding chapters. But at the same time, they also limit the possibilities that appear by definition. \n\nThus, one connection is to give form to what has already been 'accomplished'. A further connection between the chapters is to be seen in the fact that subsequent chapters actually realize one or more of the potential development possibilities that have been created in advance, and thus also allow new things to emerge throughout."
      },
      "date": 1659417946611
    },
    {
      "type": "edit",
      "id": "7a71b38064a76d07",
      "item": {
        "type": "paragraph",
        "id": "7a71b38064a76d07",
        "text": "The *[[Laws of Form]]* are divided into twelve chapters, each with its own headings and its own notes, which appear at the end of the main text. The main focus is on the main text, i.e. the appendices are not taken into account here. In my opinion, the order of the chapters is neither motivated by the fact that the next one could be derived from the previous one in a logical sense, nor does it correspond to a composition with prefixes and suffixes. Rather, it can be shown that each chapter, as the previous one, prepares the following ones insofar as first it is 'carried out' in a processual way, which is then reflected upon and conceptualized, and only then can be presented in a descriptive way. The following chapters reflect, explicate and formalize parts of the processes that are carried out in the preceding chapters. But at the same time, they also limit the possibilities that appear by definition. \n\nThus, one connection is to give form to what has already been 'accomplished'. A further connection between the chapters is to be seen in the fact that subsequent chapters actually realize one or more of the potential development possibilities that have been created in advance, and thus also allow new things to emerge throughout."
      },
      "date": 1659417959280
    },
    {
      "type": "edit",
      "id": "7a71b38064a76d07",
      "item": {
        "type": "markdown",
        "id": "7a71b38064a76d07",
        "text": "The *[[Laws of Form]]* are divided into twelve chapters, each with its own headings and its own notes, which appear at the end of the main text. The main focus is on the main text, i.e. the appendices are not taken into account here. In my opinion, the order of the chapters is neither motivated by the fact that the next one could be derived from the previous one in a logical sense, nor does it correspond to a composition with prefixes and suffixes. Rather, it can be shown that each chapter, as the previous one, prepares the following ones insofar as first it is 'carried out' in a processual way, which is then reflected upon and conceptualized, and only then can be presented in a descriptive way. The following chapters reflect, explicate and formalize parts of the processes that are carried out in the preceding chapters. But at the same time, they also limit the possibilities that appear by definition. \n\nThus, one connection is to give form to what has already been 'accomplished'. A further connection between the chapters is to be seen in the fact that subsequent chapters actually realize one or more of the potential development possibilities that have been created in advance, and thus also allow new things to emerge throughout."
      },
      "date": 1659417962435
    },
    {
      "item": {
        "type": "factory",
        "id": "93fc7d8e1343c237"
      },
      "id": "93fc7d8e1343c237",
      "type": "add",
      "after": "91498117e80fdbca",
      "date": 1659418015034
    },
    {
      "id": "93fc7d8e1343c237",
      "type": "move",
      "order": [
        "e8454c9cfb4a1d6b",
        "be07065a3cef35db",
        "7a71b38064a76d07",
        "93fc7d8e1343c237",
        "3e5e59bca3f3c8aa",
        "91498117e80fdbca"
      ],
      "date": 1659418017140
    },
    {
      "type": "edit",
      "id": "93fc7d8e1343c237",
      "item": {
        "type": "paragraph",
        "id": "93fc7d8e1343c237",
        "text": "The first, the eighth and the twelfth chapters are special because they focus on the laws of form, of auften', in a specific way: the first chapter as a provision of the preconditions and description of form per se; the eighth as a generalized reflection on the connection between the complete representation of the form of the first distinction (primary arithmetic) on the one hand and the connections between representing indications (primary algebra), which in turn become visible in this representation, on the other hand. The twelfth chapter can be read as a (semiotic) variation of the second chapter and thus as another representation of the form of the first distinction."
      },
      "date": 1659418021247
    },
    {
      "type": "edit",
      "id": "91498117e80fdbca",
      "item": {
        "type": "paragraph",
        "id": "91498117e80fdbca",
        "text": "– https://www.emerald.com/insight/content/doi/10.1108/978-1-83982-610-820211005/full/html"
      },
      "date": 1659418034348
    },
    {
      "type": "edit",
      "id": "91498117e80fdbca",
      "item": {
        "type": "markdown",
        "id": "91498117e80fdbca",
        "text": "– https://www.emerald.com/insight/content/doi/10.1108/978-1-83982-610-820211005/full/html"
      },
      "date": 1659418035521
    },
    {
      "type": "edit",
      "id": "91498117e80fdbca",
      "item": {
        "type": "markdown",
        "id": "91498117e80fdbca",
        "text": "NOR: Truth Table, True Distinction – https://www.emerald.com/insight/content/doi/10.1108/978-1-83982-610-820211005/full/html"
      },
      "date": 1659418128611
    },
    {
      "item": {
        "type": "factory",
        "id": "cff7f5a5e10d7bf9"
      },
      "id": "cff7f5a5e10d7bf9",
      "type": "add",
      "after": "91498117e80fdbca",
      "date": 1659418160525
    },
    {
      "id": "cff7f5a5e10d7bf9",
      "type": "move",
      "order": [
        "e8454c9cfb4a1d6b",
        "be07065a3cef35db",
        "7a71b38064a76d07",
        "93fc7d8e1343c237",
        "cff7f5a5e10d7bf9",
        "3e5e59bca3f3c8aa",
        "91498117e80fdbca"
      ],
      "date": 1659418162654
    },
    {
      "type": "edit",
      "id": "cff7f5a5e10d7bf9",
      "item": {
        "type": "paragraph",
        "id": "cff7f5a5e10d7bf9",
        "text": "The sequence within the first chapter reflects the described procedure of other parts of the book 'in nuce': It begins with the explicit presupposition of two ideas by Spencer Brown, the 'idea of distinction' and the 'idea of indication'. The first of the two ideas is then defined, i.e. conceptualized, and explained by means of an example. Two axioms follow, which formulate laws, which are to apply to the repetition of the second, up to then not yet defined presupposition - the idea of indication. Here the hint is defined, as it were, by its use, which is permitted or made possible by the axioms or the laws. At the same time, it becomes clear in the text of the first chapter that the distinction of the two ideas 'distinction' and 'indication' is owed to a certain differentiating perspective, i.e. that they could also be interpreted as two 'properties' of a single act. Every indication-giving act is at the same time a distinction and every distinction-giving act is also an indication in and of itself."
      },
      "date": 1659418164389
    },
    {
      "type": "add",
      "id": "bcc14275e2bc1774",
      "item": {
        "type": "paragraph",
        "id": "bcc14275e2bc1774",
        "text": "This simplification of different facets of a process, with the resulting possible differentiation of different aspects of a process on the one hand and the simultaneous view of the 'undifferentiatedness' on the other hand, is an essential methodological moment of the Laws ofForm . The progress of the book in the first chapters can be described analogously: First it is 'made', then different aspects are named and thus introduced as different. In the further use it then turns out that the difference on the basal level, on which the Laws of Form play, does not yet make sense at all, and so the differences between the aspects are partially retracted. On the other hand, it turns out to be useful to stabilize certain differences - depending on what purpose they serve, what is shown with them. In this way, it becomes clear that what seems to be newly introduced has emerged out of the stabilizing use of a possible differentiation of what already exists."
      },
      "after": "cff7f5a5e10d7bf9",
      "date": 1659418201494
    },
    {
      "type": "add",
      "id": "762d216382952371",
      "item": {
        "type": "paragraph",
        "id": "762d216382952371",
        "text": "The representational scheme that the book follows can be described as a varying repetition of the following stages, some of which are often only implicit: (1) Positioning or stating a difference, for example, by using different terms. (2 a) Followed by a cancellation of the difference by explicit requests to (re)equate what is named. (2 b) Followed by an explication of the introduced distinction by a request to imitate it or by a definition which is subsequently formalized. (3 a) 1In the following, explicit requests are made to the reader to use what has been introduced according to laws or rules that have been established, i.e. also in the formalized form. (3 b) Formulation of rules to retract already made distinctions, to abolish differences. (4) Implicit invitation to the exegete: See what all arises or can arise when it comes to use and how and what is thereby prompted and what distinctions are relevant at what point. (5) or again (1) Selection, naming, explicitation and use of further differences relevant in the respective context."
      },
      "after": "bcc14275e2bc1774",
      "date": 1659418238149
    },
    {
      "type": "edit",
      "id": "762d216382952371",
      "item": {
        "type": "paragraph",
        "id": "762d216382952371",
        "text": "The representational scheme that the book follows can be described as a varying repetition of the following stages, some of which are often only implicit: (1) Positioning or stating a difference, for example, by using different terms. (2 a) Followed by a cancellation of the difference by explicit requests to (re)equate what is named. (2 b) Followed by an explication of the introduced distinction by a request to imitate it or by a definition which is subsequently formalized. (3 a) This is followed by explicit requests to the reader to use what has been introduced according to established laws or rules, i.e. also in the formalized form. (3 b) Formulation of rules to retract already made distinctions, to abolish differences. (4) Implicit invitation to the exegete: See what all arises or can arise when it comes to use and how and what is thereby prompted and what distinctions are relevant at what point. (5) or again (1) Selection, naming, explicitation and use of further differences relevant in the respective context."
      },
      "date": 1659418294345
    },
    {
      "type": "add",
      "id": "3d21941474a95c5e",
      "item": {
        "type": "paragraph",
        "id": "3d21941474a95c5e",
        "text": "A strict assignment of the individual chapters to the various stages is not possible for the following reasons: the further back in the book the chapter is placed, the more complex the contents and forms are represented by individual characters, while at the same time specializing in very specific aspects that are relevant in the respective contexts. Parallel to this, however, more and more differences are retracted as not (anymore) rele vant. Increasingly, several of these stages of parts of the chapter contents are passed through in parallel. The intermediate titles in the Laws of Form, for example, have the function of explicitly naming the new aspect, even if the canon, rule or theorem is about properties that have been known for a long time or have already appeared differently."
      },
      "after": "762d216382952371",
      "date": 1659418362569
    },
    {
      "type": "add",
      "id": "8e3291141b3f38e8",
      "item": {
        "type": "paragraph",
        "id": "8e3291141b3f38e8",
        "text": "2. content development up to primary algebra (chapter I - 5)"
      },
      "after": "3d21941474a95c5e",
      "date": 1659418380956
    },
    {
      "type": "edit",
      "id": "8e3291141b3f38e8",
      "item": {
        "type": "paragraph",
        "id": "8e3291141b3f38e8",
        "text": "⇒ 2. Content development up to primary algebra (chapter I - 5)"
      },
      "date": 1659418393883
    },
    {
      "type": "edit",
      "id": "8e3291141b3f38e8",
      "item": {
        "type": "paragraph",
        "id": "8e3291141b3f38e8",
        "text": "⇒ 2. Content development up to primary algebra (chapter 1 - 5)"
      },
      "date": 1659418401795
    },
    {
      "item": {
        "type": "factory",
        "id": "7a42ca00a3c5680e"
      },
      "id": "7a42ca00a3c5680e",
      "type": "add",
      "after": "91498117e80fdbca",
      "date": 1659418440109
    },
    {
      "type": "edit",
      "id": "7a42ca00a3c5680e",
      "item": {
        "type": "paragraph",
        "id": "7a42ca00a3c5680e",
        "text": "Towards a Phenomenology of Schematization – "
      },
      "date": 1659418444582
    },
    {
      "type": "edit",
      "id": "7a42ca00a3c5680e",
      "item": {
        "type": "paragraph",
        "id": "7a42ca00a3c5680e",
        "text": "Towards a Phenomenology of Schematization – https://www.ingentaconnect.com/content/imp/chk/2017/00000024/f0020003/art00010"
      },
      "date": 1659418452289
    },
    {
      "type": "edit",
      "id": "7a42ca00a3c5680e",
      "item": {
        "type": "markdown",
        "id": "7a42ca00a3c5680e",
        "text": "Towards a Phenomenology of Schematization – https://www.ingentaconnect.com/content/imp/chk/2017/00000024/f0020003/art00010"
      },
      "date": 1659418453061
    },
    {
      "type": "edit",
      "id": "7a42ca00a3c5680e",
      "item": {
        "type": "markdown",
        "id": "7a42ca00a3c5680e",
        "text": "Towards a Phenomenology of Schematization. [https://www.ingentaconnect.com/content/imp/chk/2017/00000024/f0020003/art00010 page], [https://www.ingentaconnect.com/content/imp/chk/2017/00000024/f0020003/art00010 pdf]"
      },
      "date": 1659418526558
    },
    {
      "item": {
        "type": "factory",
        "id": "72b438f4ff35b967"
      },
      "id": "72b438f4ff35b967",
      "type": "add",
      "after": "7a42ca00a3c5680e",
      "date": 1659418670698
    },
    {
      "type": "edit",
      "id": "72b438f4ff35b967",
      "item": {
        "type": "paragraph",
        "id": "72b438f4ff35b967",
        "text": "– ["
      },
      "date": 1659418678748
    },
    {
      "type": "edit",
      "id": "72b438f4ff35b967",
      "item": {
        "type": "paragraph",
        "id": "72b438f4ff35b967",
        "text": "– [https://www.iphras.ru/uplfile/root/news/archive_events/2015/14_05_15_pod/Kuznecov.pdf pdf]"
      },
      "date": 1659418698095
    },
    {
      "type": "edit",
      "id": "72b438f4ff35b967",
      "item": {
        "type": "paragraph",
        "id": "72b438f4ff35b967",
        "text": "Кузнецов В.Ю. Различие, производящее различие. [https://www.iphras.ru/uplfile/root/news/archive_events/2015/14_05_15_pod/Kuznecov.pdf pdf]"
      },
      "date": 1659418746917
    },
    {
      "type": "edit",
      "id": "72b438f4ff35b967",
      "item": {
        "type": "paragraph",
        "id": "72b438f4ff35b967",
        "text": "Кузнецов В.Ю. Различие, производящее различие. (Difference producing difference)[https://www.iphras.ru/uplfile/root/news/archive_events/2015/14_05_15_pod/Kuznecov.pdf pdf]"
      },
      "date": 1659418763253
    },
    {
      "type": "edit",
      "id": "72b438f4ff35b967",
      "item": {
        "type": "paragraph",
        "id": "72b438f4ff35b967",
        "text": "Кузнецов В.Ю. Различие, производящее различие. (Difference producing difference) [https://www.iphras.ru/uplfile/root/news/archive_events/2015/14_05_15_pod/Kuznecov.pdf pdf]"
      },
      "date": 1659418768293
    },
    {
      "item": {
        "type": "factory",
        "id": "ebf0b75c4b4faa88"
      },
      "id": "ebf0b75c4b4faa88",
      "type": "add",
      "after": "72b438f4ff35b967",
      "date": 1659418796563
    },
    {
      "type": "edit",
      "id": "ebf0b75c4b4faa88",
      "item": {
        "type": "paragraph",
        "id": "ebf0b75c4b4faa88",
        "text": "According to Bateson, \"A 'bit' of information can be defined as a distinguishable difference (a difference that makes a difference). Such a difference, moving along a circuit and undergoing successive transformations in it, is an elementary idea. [1, p. 337; cf. pp. 294, 339, 418, 421.] Another, later version of the translation, also suggested by Dmitry Fedotov, is \"indifferent distinction\" [14]. [14, с. 9]. However, it is worth paying attention to the almost literal, literal meaning of this term (\"difference producing difference\") to see and be able to describe the unfolding dynamics of this process in human communication. For example, Niklas Luhmann formulates, with reference to Bateson, \"Information is nothing other than an event which promotes the binding of distinctions, a distinction which creates a distinction\" [9, 117]. [9, с. 117]."
      },
      "date": 1659418798061
    },
    {
      "type": "edit",
      "id": "ebf0b75c4b4faa88",
      "item": {
        "type": "paragraph",
        "id": "ebf0b75c4b4faa88",
        "text": "According to Bateson, \"A 'bit' of information can be defined as a distinguishable difference (a difference that makes a difference). Such a difference, moving along a circuit and undergoing successive transformations in it, is an elementary idea. [1, p. 337; cf. pp. 294, 339, 418, 421.] Another, later version of the translation, also suggested by Dmitry Fedotov, is \"indifferent distinction\" [14]. [14, с. 9]. However, it is worth paying attention to the almost literal, literal meaning of this term (\"difference producing difference\") to see and be able to describe the unfolding dynamics of this process in human communication. For example, [[Niklas Luhmann]] formulates, with reference to Bateson, \"Information is nothing other than an event which promotes the binding of distinctions, a distinction which creates a distinction\" [9, 117]. [9, с. 117]."
      },
      "date": 1659418839737
    },
    {
      "item": {
        "type": "factory",
        "id": "78b21e8cdd0bf4c2"
      },
      "id": "78b21e8cdd0bf4c2",
      "type": "add",
      "after": "ebf0b75c4b4faa88",
      "date": 1659418857527
    },
    {
      "type": "edit",
      "id": "78b21e8cdd0bf4c2",
      "item": {
        "type": "paragraph",
        "id": "78b21e8cdd0bf4c2",
        "text": "The distinction must be made, fulfilled-as a distinction. In doing so, the distinction will also bear witness to the world. \"Every distinction represents the world by the fact that its other side represents that which is not observed at the moment. \"Distinction is perfect continence, \"1 as Spencer-Brown lapidarily puts it [17, p. 1].\" [7, с. 57]. Constantly elusive traces are also noticed through the effects of distinction. \"There is no trace itself, its own trace. Heidegger is just saying that difference could not appear as difference itself (Lichtung des Unterschiedes kann deshalb auch nicht bedeuten, daß der Unterschied als der Unterschied erscheint). The trace of this trace, which (is) difference, especially could neither appear nor be named as itself, that is, in its presence.\" [6, с. 94]."
      },
      "date": 1659418858880
    },
    {
      "item": {
        "type": "factory",
        "id": "4228a888e0d04b2f"
      },
      "id": "4228a888e0d04b2f",
      "type": "add",
      "after": "78b21e8cdd0bf4c2",
      "date": 1659418908392
    },
    {
      "type": "edit",
      "id": "4228a888e0d04b2f",
      "item": {
        "type": "paragraph",
        "id": "4228a888e0d04b2f",
        "text": "The most apparently elementary or atomic (that is, indecomposable into phases, stages, etc.) procedures or operations through which the entire complex of intellectual actions is ultimately performed are two - distinction and identification. Because of their fundamental nature, they are very difficult to fix directly and directly; their action, however, is quite possible to trace on a particular material by the effects they produce. It is their interdependence, feasibility practically at any point of conceptual space and effective efficiency that presuppose their condition of possibility the principle of unity of the world, understood as the potential traceability of universal connections, and the interrelated principle of unity of culture, understood as the potential ability to constitute these or those connections, provided by the entire arsenal of sociocultural means and mechanisms. The effectiveness of the operations of distinction and identification, as well as their fundamental divergence from the presumably present - classical identity and difference [cf. 4; 5; 16], can be demonstrated quite clearly on the material of language, time and consciousness."
      },
      "date": 1659418910160
    },
    {
      "item": {
        "type": "factory",
        "id": "0dad1da9f7188841"
      },
      "id": "0dad1da9f7188841",
      "type": "add",
      "after": "4228a888e0d04b2f",
      "date": 1659418964594
    },
    {
      "type": "edit",
      "id": "0dad1da9f7188841",
      "item": {
        "type": "paragraph",
        "id": "0dad1da9f7188841",
        "text": "The situation with language is perhaps most graphic, since language represents a discriminating distinction. \"Symbolic systems - means of cognition and communication - can exercise their structuring power only because they are structured. Symbolic power is the power to construct reality by establishing an epistemological order: the immediate worldview (and especially the sense of the social world) implies what Durkheim called logical conformism, that is, \"a homogeneous perception of time, space, number, reason, which makes possible agreement between minds. [2, с. 89]. Language is a kind of difference machine [cf. 3], which was established as early as by Sossur2, who \"is first of all the one who postulated the arbitrariness of the sign and the differential character of the sign as the basis of general semiology and, in particular, of linguistics. And, as we know, these two motifs - arbitrariness and differential character - are, from his point of view, inseparable. Arbitrariness can only be because the system of signs is set by difference, not by the completeness of terms. The elements of meaning function not because of the compressed force of the nuclei, but because of the network of oppositions that distinguish them and relate them to one another. \"Arbitrariness and differential character,\" as Sossure says, \"are two correlative qualities.\" [6, с. 32]. Hence Sossur's direct interpretation of the research tasks in relation to language: \"Science and is concerned with the play of these meaningful differences\". [12, с. 23]. But the integrity of language - mediated and mediating - unfolds in time, fixing also the duration of processes."
      },
      "date": 1659418966156
    },
    {
      "item": {
        "type": "factory",
        "id": "58c8b83ca6d3d024"
      },
      "id": "58c8b83ca6d3d024",
      "type": "add",
      "after": "0dad1da9f7188841",
      "date": 1659419044611
    },
    {
      "type": "edit",
      "id": "58c8b83ca6d3d024",
      "item": {
        "type": "paragraph",
        "id": "58c8b83ca6d3d024",
        "text": "Indeed, the correspondence of phenomenologically grasped representations of one event in time, as Merleau-Ponty emphasizes, does not shrink into \"a certain ideal unity, as Kant wanted it\". [10, p. 278], since it itself is perceived only through and through its mappings. \"'Moments'... do not exist sequentially, but differentiate one from another... We are not dealing here with a multiplicity of phenomena, but with a single phenomenon of expiration (ecoulement). Time is a single movement, consistent with itself in all its parts, like a gesture that encompasses all the muscular contractions necessary for its realization. [10, с. 279]. Dynamic temporal flow smoothly and fluidly, but inexorably and unstoppably shifts and displaces plans and horizons of perception. In other words, the unity of the temporal flow is determined by the composition of identification and distinction operations performed by consciousness."
      },
      "date": 1659419046654
    },
    {
      "item": {
        "type": "factory",
        "id": "761f2c8e198b4139"
      },
      "id": "761f2c8e198b4139",
      "type": "add",
      "after": "58c8b83ca6d3d024",
      "date": 1659419108714
    },
    {
      "type": "edit",
      "id": "761f2c8e198b4139",
      "item": {
        "type": "paragraph",
        "id": "761f2c8e198b4139",
        "text": "The differentiating differentiation of consciousness allows us to distinguish (and identify) - including moments of time3 - through the inevitable fixation by means of language as a kind of distinguishing machine: \"both explicit and implicit philosophical-hermeneutical conceptualizations of time in the course of justifying their own achievements (in particular, in the course of justifying the consistency of the criteria for conceptualizing time) have to appeal to language either, in the first case, as a source of the lasting meanings of time, or, in the second case, as a way of identifying temporal experience\". [15, с. 120]. And it is the experience of discernment that constitutes consciousness. \"Identification, recognition, recognition, recognition (all synonyms) presuppose recognition, distinguishing an object, process, etc., from the general 'mass' of objects, from the totality of other processes. The experience of recognition is the experience of selection, which involves distinguishing colors, shapes, spatial positions, etc. of an object. It is this distinction that \"prepares\" synthesis and then identification. [11, с. 59]."
      },
      "date": 1659419110581
    },
    {
      "type": "edit",
      "id": "761f2c8e198b4139",
      "item": {
        "type": "paragraph",
        "id": "761f2c8e198b4139",
        "text": "The differentiating differentiation of consciousness allows us to distinguish (and identify) - including moments of time - through the inevitable fixation by means of language as a kind of distinguishing machine: \"both explicit and implicit philosophical-hermeneutical conceptualizations of time in the course of justifying their own achievements (in particular, in the course of justifying the consistency of the criteria for conceptualizing time) have to appeal to language either, in the first case, as a source of the lasting meanings of time, or, in the second case, as a way of identifying temporal experience\". [15, с. 120]. And it is the experience of discernment that constitutes consciousness. \"Identification, recognition, recognition, recognition (all synonyms) presuppose recognition, distinguishing an object, process, etc., from the general 'mass' of objects, from the totality of other processes. The experience of recognition is the experience of selection, which involves distinguishing colors, shapes, spatial positions, etc. of an object. It is this distinction that \"prepares\" synthesis and then identification. [11, с. 59]."
      },
      "date": 1659419124797
    },
    {
      "item": {
        "type": "factory",
        "id": "c1ac818ba0fcfae6"
      },
      "id": "c1ac818ba0fcfae6",
      "type": "add",
      "after": "761f2c8e198b4139",
      "date": 1659419172036
    },
    {
      "type": "edit",
      "id": "c1ac818ba0fcfae6",
      "item": {
        "type": "paragraph",
        "id": "c1ac818ba0fcfae6",
        "text": "The opposition of identity/difference (presumably independently present), which continues to prevail more or less explicitly not only in classical but also in post-classical philosophy (up to and including Deleuze and Derrida), seems therefore appropriate to be replaced by the concept of inextricably interrelated procedures or operations of distinguishing and identifying (through certain means of \"differences that produce differences\"), only through the action of which identities and differences can be understood one way or another."
      },
      "date": 1659419173914
    },
    {
      "type": "edit",
      "id": "72b438f4ff35b967",
      "item": {
        "type": "paragraph",
        "id": "72b438f4ff35b967",
        "text": "Кузнецов В.Ю. Различие, производящее различие. (Difference producing difference) [https://www.iphras.ru/uplfile/root/news/archive_events/2015/14_05_15_pod/Kuznecov.pdf pdf] (ru)"
      },
      "date": 1659419298762
    },
    {
      "type": "edit",
      "id": "72b438f4ff35b967",
      "item": {
        "type": "paragraph",
        "id": "72b438f4ff35b967",
        "text": "Кузнецов В.Ю. Различие, производящее различие (Difference producing difference). [https://www.iphras.ru/uplfile/root/news/archive_events/2015/14_05_15_pod/Kuznecov.pdf pdf] (ru)"
      },
      "date": 1659419315016
    },
    {
      "item": {
        "type": "factory",
        "id": "8e3d2426dac00592"
      },
      "id": "8e3d2426dac00592",
      "type": "add",
      "after": "c1ac818ba0fcfae6",
      "date": 1659419631228
    },
    {
      "type": "edit",
      "id": "8e3d2426dac00592",
      "item": {
        "type": "pagefold",
        "id": "8e3d2426dac00592",
        "text": "~"
      },
      "date": 1659419634238
    },
    {
      "item": {
        "type": "factory",
        "id": "82947701bb2dc4c6"
      },
      "id": "82947701bb2dc4c6",
      "type": "add",
      "after": "8e3d2426dac00592",
      "date": 1659419636063
    },
    {
      "type": "edit",
      "id": "82947701bb2dc4c6",
      "item": {
        "type": "paragraph",
        "id": "82947701bb2dc4c6",
        "text": "[[MpAffiliation]]"
      },
      "date": 1659419640098
    },
    {
      "item": {
        "type": "factory",
        "id": "fe115d720eb9317d"
      },
      "id": "fe115d720eb9317d",
      "type": "add",
      "after": "82947701bb2dc4c6",
      "date": 1659420073348
    },
    {
      "type": "edit",
      "id": "fe115d720eb9317d",
      "item": {
        "type": "paragraph",
        "id": "fe115d720eb9317d",
        "text": "– https://stackoverflow.com/questions/36811921/example-for-objects-calling-each-other-s-methods-recursively#36828935"
      },
      "date": 1659420076170
    },
    {
      "type": "edit",
      "id": "fe115d720eb9317d",
      "item": {
        "type": "markdown",
        "id": "fe115d720eb9317d",
        "text": "– https://stackoverflow.com/questions/36811921/example-for-objects-calling-each-other-s-methods-recursively#36828935"
      },
      "date": 1659420077530
    },
    {
      "type": "edit",
      "id": "fe115d720eb9317d",
      "item": {
        "type": "markdown",
        "id": "fe115d720eb9317d",
        "text": "Example for Objects calling each other’s methods recursively. [https://stackoverflow.com/questions/36811921/example-for-objects-calling-each-other-s-methods-recursively#36828935 stackoverflow]"
      },
      "date": 1659420184638
    },
    {
      "type": "fork",
      "date": 1659420241097
    },
    {
      "item": {
        "type": "factory",
        "id": "15e0766561395daa"
      },
      "id": "15e0766561395daa",
      "type": "add",
      "after": "fe115d720eb9317d",
      "date": 1659420243563
    },
    {
      "type": "edit",
      "id": "15e0766561395daa",
      "item": {
        "type": "paragraph",
        "id": "15e0766561395daa",
        "text": "whatIsAPrimitive\n\t\"Some messages in the system are responded to primitively. A primitive   \n\tresponse is performed directly by the interpreter rather than by evaluating   \n\texpressions in a method. The methods for these messages indicate the   \n\tpresence of a primitive response by including <primitive: xx> or \n\t<primitive: 79 error: ec>before the first expression in the method.   \n\t\n\tIn the second case, ec is a special temporary variable that holds an error code. \n\tIn the VM primitive, failure is indicated by a variable called primFailCode being \n\tnon-zero. On activating a method with a failing primitive, if the index is in \n\tbounds of the \tprimitiveFailCodes array in the VMspecialObjectsArray then the \n\tfailure code substitutes the symbol in the \tprimitiveFailCodes array, otherwise \n\tit supplies the integer value.\n\t  \n\tPrimitives exist for several reasons. Certain basic or 'primitive' \n\toperations cannot be performed in any other way. Smalltalk without \n\tprimitives can move values from one variable to another, but cannot add two \n\tSmallIntegers together. Many methods for arithmetic and comparison \n\tbetween numbers are primitives. Some primitives allow Smalltalk to \n\tcommunicate with I/O devices such as the disk, the display, and the keyboard. \n\tSome primitives exist only to make the system run faster; each does the same \n\tthing as a certain Smalltalk method, and its implementation as a primitive is \n\toptional.  \n\t  \n\tWhen the Smalltalk interpreter begins to execute a method which specifies a \n\tprimitive response, it tries to perform the primitive action and to return a \n\tresult. If the routine in the interpreter for this primitive is successful, \n\tit will return a value and the expressions in the method will not be evaluated. \n\tIf the primitive routine is not successful, the primitive 'fails', and the \n\tSmalltalk expressions in the method are executed instead. These \n\texpressions are evaluated as though the primitive routine had not been \n\tcalled.  \n\t  \n\tThe Smalltalk code that is evaluated when a primitive fails usually \n\tanticipates why that primitive might fail. If the primitive is optional, the \n\texpressions in the method do exactly what the primitive would have done (See \n\tNumber @). If the primitive only works on certain classes of arguments, the \n\tSmalltalk code tries to coerce the argument or appeals to a superclass to find \n\ta more general way of doing the operation (see SmallInteger +). If the \n\tprimitive is never supposed to fail, the expressions signal an error (see \n\tSmallInteger asFloat).  \n\t  \n\tEach method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\tIf a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\tFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\"\n\t\n\t\n\n\tself error: 'comment only'"
      },
      "date": 1659420245222
    },
    {
      "type": "edit",
      "id": "15e0766561395daa",
      "item": {
        "type": "paragraph",
        "id": "15e0766561395daa",
        "text": "## whatIsAPrimitive"
      },
      "date": 1659420281188
    },
    {
      "type": "add",
      "id": "49cda41d17a3dd76",
      "item": {
        "type": "paragraph",
        "id": "49cda41d17a3dd76",
        "text": "\t\"Some messages in the system are responded to primitively. A primitive   \n\tresponse is performed directly by the interpreter rather than by evaluating   \n\texpressions in a method. The methods for these messages indicate the   \n\tpresence of a primitive response by including <primitive: xx> or \n\t<primitive: 79 error: ec>before the first expression in the method.   \n\t\n\tIn the second case, ec is a special temporary variable that holds an error code. \n\tIn the VM primitive, failure is indicated by a variable called primFailCode being \n\tnon-zero. On activating a method with a failing primitive, if the index is in \n\tbounds of the \tprimitiveFailCodes array in the VMspecialObjectsArray then the \n\tfailure code substitutes the symbol in the \tprimitiveFailCodes array, otherwise \n\tit supplies the integer value.\n\t  \n\tPrimitives exist for several reasons. Certain basic or 'primitive' \n\toperations cannot be performed in any other way. Smalltalk without \n\tprimitives can move values from one variable to another, but cannot add two \n\tSmallIntegers together. Many methods for arithmetic and comparison \n\tbetween numbers are primitives. Some primitives allow Smalltalk to \n\tcommunicate with I/O devices such as the disk, the display, and the keyboard. \n\tSome primitives exist only to make the system run faster; each does the same \n\tthing as a certain Smalltalk method, and its implementation as a primitive is \n\toptional.  \n\t  \n\tWhen the Smalltalk interpreter begins to execute a method which specifies a \n\tprimitive response, it tries to perform the primitive action and to return a \n\tresult. If the routine in the interpreter for this primitive is successful, \n\tit will return a value and the expressions in the method will not be evaluated. \n\tIf the primitive routine is not successful, the primitive 'fails', and the \n\tSmalltalk expressions in the method are executed instead. These \n\texpressions are evaluated as though the primitive routine had not been \n\tcalled.  \n\t  \n\tThe Smalltalk code that is evaluated when a primitive fails usually \n\tanticipates why that primitive might fail. If the primitive is optional, the \n\texpressions in the method do exactly what the primitive would have done (See \n\tNumber @). If the primitive only works on certain classes of arguments, the \n\tSmalltalk code tries to coerce the argument or appeals to a superclass to find \n\ta more general way of doing the operation (see SmallInteger +). If the \n\tprimitive is never supposed to fail, the expressions signal an error (see \n\tSmallInteger asFloat).  \n\t  \n\tEach method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\tIf a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\tFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\"\n\t\n\t\n\n\tself error: 'comment only'"
      },
      "after": "15e0766561395daa",
      "date": 1659420281684
    },
    {
      "type": "edit",
      "id": "15e0766561395daa",
      "item": {
        "type": "markdown",
        "id": "15e0766561395daa",
        "text": "## whatIsAPrimitive"
      },
      "date": 1659420283431
    },
    {
      "type": "edit",
      "id": "49cda41d17a3dd76",
      "item": {
        "type": "paragraph",
        "id": "49cda41d17a3dd76",
        "text": "\t\"Some messages in the system are responded to primitively. A primitive   \n\tresponse is performed directly by the interpreter rather than by evaluating   \n\texpressions in a method. The methods for these messages indicate the   \n\tpresence of a primitive response by including <primitive: xx> or \n\t<primitive: 79 error: ec>before the first expression in the method.  "
      },
      "date": 1659420313815
    },
    {
      "type": "add",
      "id": "8baf8991c1d374c2",
      "item": {
        "type": "paragraph",
        "id": "8baf8991c1d374c2",
        "text": "In the second case, ec is a special temporary variable that holds an error code. \n\tIn the VM primitive, failure is indicated by a variable called primFailCode being \n\tnon-zero. On activating a method with a failing primitive, if the index is in \n\tbounds of the \tprimitiveFailCodes array in the VMspecialObjectsArray then the \n\tfailure code substitutes the symbol in the \tprimitiveFailCodes array, otherwise \n\tit supplies the integer value.\n\t  \n\t"
      },
      "after": "49cda41d17a3dd76",
      "date": 1659420324466
    },
    {
      "type": "add",
      "id": "1e611c3ff09d7261",
      "item": {
        "type": "paragraph",
        "id": "1e611c3ff09d7261",
        "text": "Primitives exist for several reasons. Certain basic or 'primitive' \n\toperations cannot be performed in any other way. Smalltalk without \n\tprimitives can move values from one variable to another, but cannot add two \n\tSmallIntegers together. Many methods for arithmetic and comparison \n\tbetween numbers are primitives. Some primitives allow Smalltalk to \n\tcommunicate with I/O devices such as the disk, the display, and the keyboard. \n\tSome primitives exist only to make the system run faster; each does the same \n\tthing as a certain Smalltalk method, and its implementation as a primitive is \n\toptional.  \n\t  \n\tWhen the Smalltalk interpreter begins to execute a method which specifies a \n\tprimitive response, it tries to perform the primitive action and to return a \n\tresult. If the routine in the interpreter for this primitive is successful, \n\tit will return a value and the expressions in the method will not be evaluated. \n\tIf the primitive routine is not successful, the primitive 'fails', and the \n\tSmalltalk expressions in the method are executed instead. These \n\texpressions are evaluated as though the primitive routine had not been \n\tcalled.  \n\t  \n\tThe Smalltalk code that is evaluated when a primitive fails usually \n\tanticipates why that primitive might fail. If the primitive is optional, the \n\texpressions in the method do exactly what the primitive would have done (See \n\tNumber @). If the primitive only works on certain classes of arguments, the \n\tSmalltalk code tries to coerce the argument or appeals to a superclass to find \n\ta more general way of doing the operation (see SmallInteger +). If the \n\tprimitive is never supposed to fail, the expressions signal an error (see \n\tSmallInteger asFloat).  \n\t  \n\tEach method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\tIf a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\tFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\"\n\t\n\t\n\n\tself error: 'comment only'"
      },
      "after": "8baf8991c1d374c2",
      "date": 1659420326495
    },
    {
      "type": "edit",
      "id": "1e611c3ff09d7261",
      "item": {
        "type": "paragraph",
        "id": "1e611c3ff09d7261",
        "text": "Primitives exist for several reasons. Certain basic or 'primitive' \n\toperations cannot be performed in any other way. Smalltalk without \n\tprimitives can move values from one variable to another, but cannot add two \n\tSmallIntegers together. Many methods for arithmetic and comparison \n\tbetween numbers are primitives. Some primitives allow Smalltalk to \n\tcommunicate with I/O devices such as the disk, the display, and the keyboard. \n\tSome primitives exist only to make the system run faster; each does the same \n\tthing as a certain Smalltalk method, and its implementation as a primitive is \n\toptional.  \n\t  \n\t"
      },
      "date": 1659420339815
    },
    {
      "type": "add",
      "id": "bf6614d73e0998ad",
      "item": {
        "type": "paragraph",
        "id": "bf6614d73e0998ad",
        "text": "When the Smalltalk interpreter begins to execute a method which specifies a \n\tprimitive response, it tries to perform the primitive action and to return a \n\tresult. If the routine in the interpreter for this primitive is successful, \n\tit will return a value and the expressions in the method will not be evaluated. \n\tIf the primitive routine is not successful, the primitive 'fails', and the \n\tSmalltalk expressions in the method are executed instead. These \n\texpressions are evaluated as though the primitive routine had not been \n\tcalled.  \n\t  \n\t"
      },
      "after": "1e611c3ff09d7261",
      "date": 1659420345924
    },
    {
      "type": "add",
      "id": "6a0cb87eadd4f491",
      "item": {
        "type": "paragraph",
        "id": "6a0cb87eadd4f491",
        "text": "The Smalltalk code that is evaluated when a primitive fails usually \n\tanticipates why that primitive might fail. If the primitive is optional, the \n\texpressions in the method do exactly what the primitive would have done (See \n\tNumber @). If the primitive only works on certain classes of arguments, the \n\tSmalltalk code tries to coerce the argument or appeals to a superclass to find \n\ta more general way of doing the operation (see SmallInteger +). If the \n\tprimitive is never supposed to fail, the expressions signal an error (see \n\tSmallInteger asFloat).  \n\t  \n\tEach method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\tIf a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\tFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\"\n\t\n\t\n\n\tself error: 'comment only'"
      },
      "after": "bf6614d73e0998ad",
      "date": 1659420347018
    },
    {
      "type": "edit",
      "id": "6a0cb87eadd4f491",
      "item": {
        "type": "paragraph",
        "id": "6a0cb87eadd4f491",
        "text": "The Smalltalk code that is evaluated when a primitive fails usually \n\tanticipates why that primitive might fail. If the primitive is optional, the \n\texpressions in the method do exactly what the primitive would have done (See \n\tNumber @). If the primitive only works on certain classes of arguments, the \n\tSmalltalk code tries to coerce the argument or appeals to a superclass to find \n\ta more general way of doing the operation (see SmallInteger +). If the \n\tprimitive is never supposed to fail, the expressions signal an error (see \n\tSmallInteger asFloat).  \n\t  \n\t"
      },
      "date": 1659420368176
    },
    {
      "type": "add",
      "id": "17084d96b8dce091",
      "item": {
        "type": "paragraph",
        "id": "17084d96b8dce091",
        "text": "Each method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\tIf a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\tFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\"\n\t\n\t\n\n\tself error: 'comment only'"
      },
      "after": "6a0cb87eadd4f491",
      "date": 1659420369375
    },
    {
      "item": {
        "type": "factory",
        "id": "67e0f3510a3a551a"
      },
      "id": "67e0f3510a3a551a",
      "type": "add",
      "after": "17084d96b8dce091",
      "date": 1659420386041
    },
    {
      "type": "edit",
      "id": "17084d96b8dce091",
      "item": {
        "type": "paragraph",
        "id": "17084d96b8dce091",
        "text": "Each method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\tIf a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\tFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\"\n\t\n\t\n\n\t"
      },
      "date": 1659420394695
    },
    {
      "type": "edit",
      "id": "67e0f3510a3a551a",
      "item": {
        "type": "code",
        "id": "67e0f3510a3a551a",
        "text": "self error: 'comment only'"
      },
      "date": 1659420395635
    },
    {
      "type": "edit",
      "id": "17084d96b8dce091",
      "item": {
        "type": "paragraph",
        "id": "17084d96b8dce091",
        "text": "Each method that specifies a primitive has a comment in it. If the primitive is \n\toptional, the comment will say 'Optional'. An optional primitive that is not \n\timplemented always fails, and the Smalltalk expressions do the work \n\tinstead.  \n\t \n\t"
      },
      "date": 1659420420895
    },
    {
      "type": "add",
      "id": "56077cc2159acd48",
      "item": {
        "type": "paragraph",
        "id": "56077cc2159acd48",
        "text": "If a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\tFor the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\"\n\t\n\t\n\n\t"
      },
      "after": "17084d96b8dce091",
      "date": 1659420422019
    },
    {
      "type": "edit",
      "id": "56077cc2159acd48",
      "item": {
        "type": "paragraph",
        "id": "56077cc2159acd48",
        "text": "If a primitive is not optional, the comment will say, 'Essential'. Some \n\tmethods will have the comment, 'No Lookup'. See Object \n\thowToModifyPrimitives for an explanation of special selectors which are \n\tnot looked up.  \n\t  \n\t"
      },
      "date": 1659420430344
    },
    {
      "type": "add",
      "id": "f2243294321d7f14",
      "item": {
        "type": "paragraph",
        "id": "f2243294321d7f14",
        "text": "For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated \n\tin Float, the primitive constructs and returns a 16-bit \n\tLargePositiveInteger when the result warrants it. Returning 16-bit \n\tLargePositiveIntegers from these primitives instead of failing is \n\toptional in the same sense that the LargePositiveInteger arithmetic \n\tprimitives are optional. The comments in the SmallInteger primitives say, \n\t'Fails if result is not a SmallInteger', even though the implementor has the \n\toption to construct a LargePositiveInteger. For further information on \n\tprimitives, see the 'Primitive Methods' part of the chapter on the formal \n\tspecification of the interpreter in the Smalltalk book.\"\n\t\n\t\n\n\t"
      },
      "after": "56077cc2159acd48",
      "date": 1659420430882
    },
    {
      "id": "fe115d720eb9317d",
      "type": "move",
      "order": [
        "e8454c9cfb4a1d6b",
        "be07065a3cef35db",
        "7a71b38064a76d07",
        "93fc7d8e1343c237",
        "cff7f5a5e10d7bf9",
        "bcc14275e2bc1774",
        "762d216382952371",
        "3d21941474a95c5e",
        "8e3291141b3f38e8",
        "3e5e59bca3f3c8aa",
        "91498117e80fdbca",
        "7a42ca00a3c5680e",
        "72b438f4ff35b967",
        "ebf0b75c4b4faa88",
        "78b21e8cdd0bf4c2",
        "4228a888e0d04b2f",
        "0dad1da9f7188841",
        "58c8b83ca6d3d024",
        "761f2c8e198b4139",
        "c1ac818ba0fcfae6",
        "8e3d2426dac00592",
        "82947701bb2dc4c6",
        "15e0766561395daa",
        "49cda41d17a3dd76",
        "8baf8991c1d374c2",
        "1e611c3ff09d7261",
        "bf6614d73e0998ad",
        "6a0cb87eadd4f491",
        "17084d96b8dce091",
        "56077cc2159acd48",
        "f2243294321d7f14",
        "67e0f3510a3a551a",
        "fe115d720eb9317d"
      ],
      "date": 1659420481461
    },
    {
      "item": {
        "type": "factory",
        "id": "a7047f62fcfd223e"
      },
      "id": "a7047f62fcfd223e",
      "type": "add",
      "after": "fe115d720eb9317d",
      "date": 1659420483630
    },
    {
      "type": "edit",
      "id": "a7047f62fcfd223e",
      "item": {
        "type": "pagefold",
        "id": "a7047f62fcfd223e",
        "text": "~"
      },
      "date": 1659420486551
    },
    {
      "id": "a7047f62fcfd223e",
      "type": "move",
      "order": [
        "e8454c9cfb4a1d6b",
        "be07065a3cef35db",
        "7a71b38064a76d07",
        "93fc7d8e1343c237",
        "cff7f5a5e10d7bf9",
        "bcc14275e2bc1774",
        "762d216382952371",
        "3d21941474a95c5e",
        "8e3291141b3f38e8",
        "3e5e59bca3f3c8aa",
        "91498117e80fdbca",
        "7a42ca00a3c5680e",
        "72b438f4ff35b967",
        "ebf0b75c4b4faa88",
        "78b21e8cdd0bf4c2",
        "4228a888e0d04b2f",
        "0dad1da9f7188841",
        "58c8b83ca6d3d024",
        "761f2c8e198b4139",
        "c1ac818ba0fcfae6",
        "8e3d2426dac00592",
        "82947701bb2dc4c6",
        "15e0766561395daa",
        "49cda41d17a3dd76",
        "8baf8991c1d374c2",
        "1e611c3ff09d7261",
        "bf6614d73e0998ad",
        "6a0cb87eadd4f491",
        "17084d96b8dce091",
        "56077cc2159acd48",
        "f2243294321d7f14",
        "67e0f3510a3a551a",
        "a7047f62fcfd223e",
        "fe115d720eb9317d"
      ],
      "date": 1659420488988
    },
    {
      "type": "add",
      "id": "6141c6c8b9a284fd",
      "item": {
        "type": "paragraph",
        "id": "6141c6c8b9a284fd",
        "text": "ThirtyTwoBitRegister"
      },
      "after": "82947701bb2dc4c6",
      "date": 1659420578800
    },
    {
      "item": {
        "type": "factory",
        "id": "91c12a62501fec74"
      },
      "id": "91c12a62501fec74",
      "type": "add",
      "after": "fe115d720eb9317d",
      "date": 1659420592949
    },
    {
      "id": "91c12a62501fec74",
      "type": "move",
      "order": [
        "e8454c9cfb4a1d6b",
        "be07065a3cef35db",
        "7a71b38064a76d07",
        "93fc7d8e1343c237",
        "cff7f5a5e10d7bf9",
        "bcc14275e2bc1774",
        "762d216382952371",
        "3d21941474a95c5e",
        "8e3291141b3f38e8",
        "3e5e59bca3f3c8aa",
        "91498117e80fdbca",
        "7a42ca00a3c5680e",
        "72b438f4ff35b967",
        "ebf0b75c4b4faa88",
        "78b21e8cdd0bf4c2",
        "4228a888e0d04b2f",
        "0dad1da9f7188841",
        "58c8b83ca6d3d024",
        "761f2c8e198b4139",
        "c1ac818ba0fcfae6",
        "8e3d2426dac00592",
        "82947701bb2dc4c6",
        "6141c6c8b9a284fd",
        "91c12a62501fec74",
        "15e0766561395daa",
        "49cda41d17a3dd76",
        "8baf8991c1d374c2",
        "1e611c3ff09d7261",
        "bf6614d73e0998ad",
        "6a0cb87eadd4f491",
        "17084d96b8dce091",
        "56077cc2159acd48",
        "f2243294321d7f14",
        "67e0f3510a3a551a",
        "a7047f62fcfd223e",
        "fe115d720eb9317d"
      ],
      "date": 1659420598308
    },
    {
      "type": "edit",
      "id": "91c12a62501fec74",
      "item": {
        "type": "code",
        "id": "91c12a62501fec74",
        "text": "bitXor: aThirtTwoBitRegister\n\t\"Replace my contents with the bitwise exclusive OR of the given register and my current contents.\"\n\n\thi := hi bitXor: aThirtTwoBitRegister hi.\n\tlow := low bitXor: aThirtTwoBitRegister low."
      },
      "date": 1659420600167
    },
    {
      "type": "edit",
      "id": "6141c6c8b9a284fd",
      "item": {
        "type": "paragraph",
        "id": "6141c6c8b9a284fd",
        "text": "[[ThirtyTwoBitRegister]]"
      },
      "date": 1659420636941
    },
    {
      "item": {
        "type": "factory",
        "id": "352551ed737e54d0"
      },
      "id": "352551ed737e54d0",
      "type": "add",
      "after": "fe115d720eb9317d",
      "date": 1659430216670
    },
    {
      "type": "edit",
      "id": "352551ed737e54d0",
      "item": {
        "type": "pagefold",
        "id": "352551ed737e54d0",
        "text": "~"
      },
      "date": 1659430220717
    },
    {
      "item": {
        "type": "factory",
        "id": "d5d263e4cefc55e2"
      },
      "id": "d5d263e4cefc55e2",
      "type": "add",
      "after": "352551ed737e54d0",
      "date": 1659430222406
    },
    {
      "type": "edit",
      "id": "d5d263e4cefc55e2",
      "item": {
        "type": "paragraph",
        "id": "d5d263e4cefc55e2",
        "text": "Das Verhalten von Schaltkreisen kann als Fortpflanzung logischer Werte (binäre Zustände) durch ein Netz von Gattern, die diese logischen Werte ändern, indem sie sie entweder invertieren (Gatter mit nur einem Eingang) oder kombinieren (Gatter mit mehreren Eingängen oder/und).  Bei dieser Sichtweise wird eine externe, objektive Metapher verwendet, bei der beobachtet wird, wie die Ausbreitung von scheinbaren Objekten (Bits) deren Zustand (hoch/niedrig) beeinflusst.\n"
      },
      "date": 1659430225008
    },
    {
      "type": "edit",
      "id": "d5d263e4cefc55e2",
      "item": {
        "type": "paragraph",
        "id": "d5d263e4cefc55e2",
        "text": "[[Möglichkeitswellen]] Das Verhalten von Schaltkreisen kann als Fortpflanzung logischer Werte (binäre Zustände) durch ein Netz von Gattern, die diese logischen Werte ändern, indem sie sie entweder invertieren (Gatter mit nur einem Eingang) oder kombinieren (Gatter mit mehreren Eingängen oder/und).  Bei dieser Sichtweise wird eine externe, objektive Metapher verwendet, bei der beobachtet wird, wie die Ausbreitung von scheinbaren Objekten (Bits) deren Zustand (hoch/niedrig) beeinflusst.\n"
      },
      "date": 1659430246297
    },
    {
      "type": "edit",
      "id": "d5d263e4cefc55e2",
      "item": {
        "type": "paragraph",
        "id": "d5d263e4cefc55e2",
        "text": "[[Möglichkeitswellen]] "
      },
      "date": 1659430252299
    },
    {
      "type": "add",
      "id": "75b3e5c31ef00452",
      "item": {
        "type": "paragraph",
        "id": "75b3e5c31ef00452",
        "text": "Das Verhalten von Schaltkreisen kann als Fortpflanzung logischer Werte (binäre Zustände) durch ein Netz von Gattern, die diese logischen Werte ändern, indem sie sie entweder invertieren (Gatter mit nur einem Eingang) oder kombinieren (Gatter mit mehreren Eingängen oder/und).  Bei dieser Sichtweise wird eine externe, objektive Metapher verwendet, bei der beobachtet wird, wie die Ausbreitung von scheinbaren Objekten (Bits) deren Zustand (hoch/niedrig) beeinflusst.\n"
      },
      "after": "d5d263e4cefc55e2",
      "date": 1659430255941
    },
    {
      "id": "75b3e5c31ef00452",
      "type": "remove",
      "date": 1659430259610
    },
    {
      "type": "edit",
      "id": "d5d263e4cefc55e2",
      "item": {
        "type": "paragraph",
        "id": "d5d263e4cefc55e2",
        "text": "– [[Possibility Waves]] [[Möglichkeitswellen]] "
      },
      "date": 1659430278947
    },
    {
      "type": "edit",
      "id": "d5d263e4cefc55e2",
      "item": {
        "type": "paragraph",
        "id": "d5d263e4cefc55e2",
        "text": "⇒ [[Possibility Waves]] ⇒ [[Möglichkeitswellen]] "
      },
      "date": 1659430291546
    },
    {
      "item": {
        "type": "factory",
        "id": "d83ade2794b1e67a"
      },
      "id": "d83ade2794b1e67a",
      "type": "add",
      "after": "d5d263e4cefc55e2",
      "date": 1659430452431
    },
    {
      "type": "edit",
      "id": "d83ade2794b1e67a",
      "item": {
        "type": "paragraph",
        "id": "d83ade2794b1e67a",
        "text": "– https://pubs.acs.org/doi/abs/10.1021/ja016756v"
      },
      "date": 1659430457907
    },
    {
      "type": "add",
      "id": "5c1a8716b40d2287",
      "item": {
        "type": "paragraph",
        "id": "5c1a8716b40d2287",
        "text": "single-input not gates"
      },
      "after": "d5d263e4cefc55e2",
      "date": 1659430478425
    },
    {
      "type": "edit",
      "id": "d83ade2794b1e67a",
      "item": {
        "type": "markdown",
        "id": "d83ade2794b1e67a",
        "text": "– https://pubs.acs.org/doi/abs/10.1021/ja016756v"
      },
      "date": 1659430591107
    },
    {
      "item": {
        "type": "factory",
        "id": "12d20ed4877efd82"
      },
      "id": "12d20ed4877efd82",
      "type": "add",
      "after": "d83ade2794b1e67a",
      "date": 1659430702167
    },
    {
      "type": "edit",
      "id": "12d20ed4877efd82",
      "item": {
        "type": "markdown",
        "id": "12d20ed4877efd82",
        "text": "> We report herein a set of deoxyribozyme-based logic gates capable of generating any Boolean function. We construct basic NOT and AND gates, followed by the more complex XOR gate. These gates were constructed through a modular design that combines molecular beacon stem-loops with hammerhead-type deoxyribozymes. Importantly, as the gates have oligonucleotides as both inputs and output, they open the possibility of communication between various computation elements in solution. The operation of these gates is conveniently connected to a fluorescent readout. "
      },
      "date": 1659430705990
    },
    {
      "type": "edit",
      "id": "d83ade2794b1e67a",
      "item": {
        "type": "markdown",
        "id": "d83ade2794b1e67a",
        "text": "STOJANOVIC, Milan N., MITCHELL, Tiffany Elizabeth and STEFANOVIC, Darko, 2002. Deoxyribozyme-Based Logic Gates. Journal of the American Chemical Society. Online. 1 April 2002. Vol. 124, no. 14, p. 3555–3561. [https://pubs.acs.org/doi/abs/10.1021/ja016756v doi]"
      },
      "date": 1659430800903
    },
    {
      "type": "edit",
      "id": "5c1a8716b40d2287",
      "item": {
        "type": "paragraph",
        "id": "5c1a8716b40d2287",
        "text": "single-input not gates – https://scholar.google.com/scholar?hl=de&as_sdt=0%2C5&q=%22single-input+not+gates%22&btnG="
      },
      "date": 1659430898900
    },
    {
      "type": "edit",
      "id": "5c1a8716b40d2287",
      "item": {
        "type": "markdown",
        "id": "5c1a8716b40d2287",
        "text": "single-input not gates – https://scholar.google.com/scholar?hl=de&as_sdt=0%2C5&q=%22single-input+not+gates%22&btnG="
      },
      "date": 1659430899965
    },
    {
      "item": {
        "type": "factory",
        "id": "795e806766b5ebbe"
      },
      "id": "795e806766b5ebbe",
      "type": "add",
      "after": "12d20ed4877efd82",
      "date": 1659431414416
    },
    {
      "type": "edit",
      "id": "795e806766b5ebbe",
      "item": {
        "type": "pagefold",
        "id": "795e806766b5ebbe",
        "text": "~"
      },
      "date": 1659431417479
    },
    {
      "item": {
        "type": "factory",
        "id": "c503b69da193d91e"
      },
      "id": "c503b69da193d91e",
      "type": "add",
      "after": "795e806766b5ebbe",
      "date": 1659431419417
    },
    {
      "type": "edit",
      "id": "c503b69da193d91e",
      "item": {
        "type": "paragraph",
        "id": "c503b69da193d91e",
        "text": "\nCHEEK, Wesley and CHMUTINA, Ksenia, 2022. Measuring Resilience in the Assumed City. International Journal of Disaster Risk Science. Online. June 2022. Vol. 13, no. 3, p. 317–329. [Accessed 2 August 2022]. DOI 10.1007/s13753-022-00410-9. "
      },
      "date": 1659431425532
    },
    {
      "type": "add",
      "id": "2b6a237339f42513",
      "item": {
        "type": "paragraph",
        "id": "2b6a237339f42513",
        "text": "> **Abstract**. The malleable nature of both the idea of a city and the idea of resilience raises an important question—why measure? Resilience is assumed to be located in the physical infrastructure of specific places or as a quality of the people located there. For disasters, we are often trying to conceptualize, measure, or render legible resilience in physical structures. But what is it that we are trying to measure, and is the idea of a city reflected in these measurements? If cities are organized around something other than resilience, is resilience their natural by-product? What is necessitating the need for increased—and measured—resilience? Using interpretive policy analysis, we explored five well known disaster resilience frameworks (UNDRR’s Making Cities Resilient Campaign, UN-Habitat’s City Resilience Profiling Programme, The World Bank and GFDRR’s Resilient Cities Program, Arup and The Rockefeller Foundation’s City Resilience Index, and The Rockefeller Foundation’s 100 Resilient Cities) to identify the working definition of “city” and of “resilience.” We conclude that if the demand for cities to become more resilient is an acknowledgment of the risk produced by globalized urbanization, then the call itself is an indictment of the current state of our cities.\n"
      },
      "after": "c503b69da193d91e",
      "date": 1659431437126
    },
    {
      "type": "edit",
      "id": "2b6a237339f42513",
      "item": {
        "type": "markdown",
        "id": "2b6a237339f42513",
        "text": "> **Abstract**. The malleable nature of both the idea of a city and the idea of resilience raises an important question—why measure? Resilience is assumed to be located in the physical infrastructure of specific places or as a quality of the people located there. For disasters, we are often trying to conceptualize, measure, or render legible resilience in physical structures. But what is it that we are trying to measure, and is the idea of a city reflected in these measurements? If cities are organized around something other than resilience, is resilience their natural by-product? What is necessitating the need for increased—and measured—resilience? Using interpretive policy analysis, we explored five well known disaster resilience frameworks (UNDRR’s Making Cities Resilient Campaign, UN-Habitat’s City Resilience Profiling Programme, The World Bank and GFDRR’s Resilient Cities Program, Arup and The Rockefeller Foundation’s City Resilience Index, and The Rockefeller Foundation’s 100 Resilient Cities) to identify the working definition of “city” and of “resilience.” We conclude that if the demand for cities to become more resilient is an acknowledgment of the risk produced by globalized urbanization, then the call itself is an indictment of the current state of our cities.\n"
      },
      "date": 1659431438275
    },
    {
      "type": "edit",
      "id": "c503b69da193d91e",
      "item": {
        "type": "paragraph",
        "id": "c503b69da193d91e",
        "text": "CHEEK, Wesley and CHMUTINA, Ksenia, 2022. Measuring Resilience in the Assumed City. International Journal of Disaster Risk Science. Online. June 2022. Vol. 13, no. 3, p. 317–329. [Accessed 2 August 2022]. DOI 10.1007/s13753-022-00410-9. "
      },
      "date": 1659431482493
    },
    {
      "id": "c503b69da193d91e",
      "type": "remove",
      "date": 1659431564811
    },
    {
      "id": "2b6a237339f42513",
      "type": "remove",
      "date": 1659431569278
    },
    {
      "item": {
        "type": "factory",
        "id": "37157591b972e621"
      },
      "id": "37157591b972e621",
      "type": "add",
      "after": "795e806766b5ebbe",
      "date": 1659431571266
    },
    {
      "type": "edit",
      "id": "37157591b972e621",
      "item": {
        "type": "paragraph",
        "id": "37157591b972e621",
        "text": "[[Measuring Resilience in the Assumed City]]"
      },
      "date": 1659431578811
    },
    {
      "type": "edit",
      "id": "795e806766b5ebbe",
      "item": {
        "type": "pagefold",
        "id": "795e806766b5ebbe",
        "text": "Resilience"
      },
      "date": 1659431580648
    },
    {
      "type": "edit",
      "id": "37157591b972e621",
      "item": {
        "type": "paragraph",
        "id": "37157591b972e621",
        "text": "⇒ [[Measuring Resilience in the Assumed City]]"
      },
      "date": 1659431593913
    },
    {
      "type": "edit",
      "id": "82947701bb2dc4c6",
      "item": {
        "type": "paragraph",
        "id": "82947701bb2dc4c6",
        "text": "[[Affiliation]] [[MpAffiliation]]"
      },
      "date": 1659433474830
    },
    {
      "type": "edit",
      "id": "82947701bb2dc4c6",
      "item": {
        "type": "paragraph",
        "id": "82947701bb2dc4c6",
        "text": "[[Affiliation]] ⇒ [[MpAffiliation]]"
      },
      "date": 1659433485940
    },
    {
      "item": {
        "type": "factory",
        "id": "aadf6e3a64e0a89b"
      },
      "id": "aadf6e3a64e0a89b",
      "type": "add",
      "after": "37157591b972e621",
      "date": 1659433738236
    },
    {
      "type": "edit",
      "id": "aadf6e3a64e0a89b",
      "item": {
        "type": "pagefold",
        "id": "aadf6e3a64e0a89b",
        "text": "~"
      },
      "date": 1659433740523
    },
    {
      "item": {
        "type": "factory",
        "id": "bd17198a165a1ead"
      },
      "id": "bd17198a165a1ead",
      "type": "add",
      "after": "aadf6e3a64e0a89b",
      "date": 1659433742439
    },
    {
      "type": "edit",
      "id": "bd17198a165a1ead",
      "item": {
        "type": "paragraph",
        "id": "bd17198a165a1ead",
        "text": "[[ZTimestamp]]"
      },
      "date": 1659433746092
    },
    {
      "item": {
        "type": "factory",
        "id": "71109e9f8ee77643"
      },
      "id": "71109e9f8ee77643",
      "type": "add",
      "after": "bd17198a165a1ead",
      "date": 1659434427301
    },
    {
      "type": "edit",
      "id": "71109e9f8ee77643",
      "item": {
        "type": "paragraph",
        "id": "71109e9f8ee77643",
        "text": "[[RBMessageNode]]"
      },
      "date": 1659434431267
    },
    {
      "type": "edit",
      "id": "71109e9f8ee77643",
      "item": {
        "type": "paragraph",
        "id": "71109e9f8ee77643",
        "text": "[[Containment]] – [[RBMessageNode]]"
      },
      "date": 1659434828559
    },
    {
      "type": "edit",
      "id": "bd17198a165a1ead",
      "item": {
        "type": "paragraph",
        "id": "bd17198a165a1ead",
        "text": "⇒ [[ZTimestamp]]"
      },
      "date": 1659434836826
    },
    {
      "type": "edit",
      "id": "71109e9f8ee77643",
      "item": {
        "type": "paragraph",
        "id": "71109e9f8ee77643",
        "text": "⇒ [[Containment]] ⇒ [[RBMessageNode]]"
      },
      "date": 1659434844874
    },
    {
      "item": {
        "type": "factory",
        "id": "18ad666721e10926"
      },
      "id": "18ad666721e10926",
      "type": "add",
      "after": "71109e9f8ee77643",
      "date": 1659434920896
    },
    {
      "type": "edit",
      "id": "18ad666721e10926",
      "item": {
        "type": "code",
        "id": "18ad666721e10926",
        "text": "RBMessageNode>>#isContainmentReplacement:"
      },
      "date": 1659434923915
    },
    {
      "item": {
        "type": "factory",
        "id": "24f52e4338d0b841"
      },
      "id": "24f52e4338d0b841",
      "type": "add",
      "after": "18ad666721e10926",
      "date": 1659434929574
    },
    {
      "type": "edit",
      "id": "24f52e4338d0b841",
      "item": {
        "type": "code",
        "id": "24f52e4338d0b841",
        "text": "RBMessageNode>>#replaceContainmentSourceWith:"
      },
      "date": 1659434931882
    },
    {
      "item": {
        "type": "factory",
        "id": "82c3c093eb97250c"
      },
      "id": "82c3c093eb97250c",
      "type": "add",
      "after": "24f52e4338d0b841",
      "date": 1659435003291
    },
    {
      "type": "edit",
      "id": "82c3c093eb97250c",
      "item": {
        "type": "paragraph",
        "id": "82c3c093eb97250c",
        "text": "cf. Limbo, slicing with the help of a syntax tree."
      },
      "date": 1659435019724
    },
    {
      "item": {
        "type": "factory",
        "id": "40e9dd31b10d8dc9"
      },
      "id": "40e9dd31b10d8dc9",
      "type": "add",
      "after": "82c3c093eb97250c",
      "date": 1659435109815
    },
    {
      "type": "edit",
      "id": "40e9dd31b10d8dc9",
      "item": {
        "type": "paragraph",
        "id": "40e9dd31b10d8dc9",
        "text": "– https://apps.dtic.mil/sti/pdfs/ADA469340.pdf"
      },
      "date": 1659435113748
    },
    {
      "type": "edit",
      "id": "40e9dd31b10d8dc9",
      "item": {
        "type": "markdown",
        "id": "40e9dd31b10d8dc9",
        "text": "– https://apps.dtic.mil/sti/pdfs/ADA469340.pdf"
      },
      "date": 1659435115119
    },
    {
      "type": "edit",
      "id": "40e9dd31b10d8dc9",
      "item": {
        "type": "markdown",
        "id": "40e9dd31b10d8dc9",
        "text": "Design Fragments. [https://apps.dtic.mil/sti/pdfs/ADA469340.pdf pdf]"
      },
      "date": 1659435147862
    },
    {
      "type": "edit",
      "id": "40e9dd31b10d8dc9",
      "item": {
        "type": "markdown",
        "id": "40e9dd31b10d8dc9",
        "text": "[[George Fairbanks]], Design Fragments. [https://apps.dtic.mil/sti/pdfs/ADA469340.pdf pdf]"
      },
      "date": 1659435162792
    },
    {
      "type": "edit",
      "id": "40e9dd31b10d8dc9",
      "item": {
        "type": "markdown",
        "id": "40e9dd31b10d8dc9",
        "text": "[[George Fairbanks]] (2007), Design Fragments. [https://apps.dtic.mil/sti/pdfs/ADA469340.pdf pdf]"
      },
      "date": 1659435175197
    },
    {
      "item": {
        "type": "factory",
        "id": "f5b128318b9f8bb2"
      },
      "id": "f5b128318b9f8bb2",
      "type": "add",
      "after": "40e9dd31b10d8dc9",
      "date": 1659435295823
    },
    {
      "type": "edit",
      "id": "f5b128318b9f8bb2",
      "item": {
        "type": "pagefold",
        "id": "f5b128318b9f8bb2",
        "text": "~"
      },
      "date": 1659435298779
    },
    {
      "item": {
        "type": "factory",
        "id": "dfc063b1a0d23f54"
      },
      "id": "dfc063b1a0d23f54",
      "type": "add",
      "after": "f5b128318b9f8bb2",
      "date": 1659435300493
    },
    {
      "type": "edit",
      "id": "dfc063b1a0d23f54",
      "item": {
        "type": "paragraph",
        "id": "dfc063b1a0d23f54",
        "text": "– https://ieeexplore.ieee.org/abstract/document/7866702?casa_token=P2KhR-1JHBIAAAAA:vM4p4n95PJGb8FDbSH8SS_A6i_3XoPouWRJIOniLnOZTlF4jGJZg_V8ReMhAw0JiDh3eWTKoA-U"
      },
      "date": 1659435303680
    },
    {
      "type": "edit",
      "id": "dfc063b1a0d23f54",
      "item": {
        "type": "markdown",
        "id": "dfc063b1a0d23f54",
        "text": "– https://ieeexplore.ieee.org/abstract/document/7866702?casa_token=P2KhR-1JHBIAAAAA:vM4p4n95PJGb8FDbSH8SS_A6i_3XoPouWRJIOniLnOZTlF4jGJZg_V8ReMhAw0JiDh3eWTKoA-U"
      },
      "date": 1659435304857
    },
    {
      "type": "edit",
      "id": "dfc063b1a0d23f54",
      "item": {
        "type": "markdown",
        "id": "dfc063b1a0d23f54",
        "text": "\nSALIH, Husam, ABDELWAHAB, Hammam and ABDALLAH, Areej, 2017. Automation design for a syrup production line using Siemens PLC S7-1200 and TIA Portal software. In: 2017 International Conference on Communication, Control, Computing and Electronics Engineering (ICCCCEE). January 2017. p. 1–5. DOI 10.1109/ICCCCEE.2017.7866702. \n> In the world of Automation Industrial, Programmable Logic Controllers (PLCs) are the dominant types of automatic controllers, and so engineers are racing to develop the best software to give it the ultimate abilities to maximize the outcome. Basically, for understanding the concepts of controlling any process. Mathematical modeling is a mandatory procedure and hence this paper describes a method to model tank systems in order to control the input flow and the output flow. This paper also discusses the use of the Siemens PLC S7-1200 as the system controller with provision of the algorithm and the equipment needed. This paper describes the general concepts of controlling liquid flows and capacity in tanks as this process is useful in the automation industrial field. The proposed system is implemented with simple equipment in order to demonstrate the concept of the process and how it is controlled.\n – https://ieeexplore.ieee.org/abstract/document/7866702?casa_token=P2KhR-1JHBIAAAAA:vM4p4n95PJGb8FDbSH8SS_A6i_3XoPouWRJIOniLnOZTlF4jGJZg_V8ReMhAw0JiDh3eWTKoA-U"
      },
      "date": 1659435672858
    },
    {
      "item": {
        "type": "factory",
        "id": "b83efdba7d2fccec"
      },
      "id": "b83efdba7d2fccec",
      "type": "add",
      "after": "dfc063b1a0d23f54",
      "date": 1659435804445
    },
    {
      "type": "edit",
      "id": "b83efdba7d2fccec",
      "item": {
        "type": "paragraph",
        "id": "b83efdba7d2fccec",
        "text": "– https://www.scienceopen.com/hosted-document?doi=10.14236/ewic/ICS2018.8"
      },
      "date": 1659435811673
    },
    {
      "type": "edit",
      "id": "b83efdba7d2fccec",
      "item": {
        "type": "markdown",
        "id": "b83efdba7d2fccec",
        "text": "– https://www.scienceopen.com/hosted-document?doi=10.14236/ewic/ICS2018.8"
      },
      "date": 1659435812834
    },
    {
      "type": "edit",
      "id": "b83efdba7d2fccec",
      "item": {
        "type": "markdown",
        "id": "b83efdba7d2fccec",
        "text": "\nHUI, Henry and MCLAUGHLIN, Kieran, 2018. Investigating Current PLC Security Issues Regarding Siemens S7 Communications and TIA Portal. Online. 1 August 2018. [Accessed 2 August 2022]. DOI 10.14236/ewic/ICS2018.8. \n> Programmable Logic Controllers (PLCs) are the essential components in many Industrial Control Systems that control physical processes. However, in recent years the security flaws of these devices have come under scrutiny, particularly since the widely discussed Stuxnet attack. To help the industry state-of-the-art to move forward and to provide information required to improve the security for these controllers, this work investigates potential exploits of the Siemens S7-1211C controllers and the Totally Integrated Automation (TIA) engineering software. Using Windbg and Scapy, the anti-replay mechanism of the Siemens proprietary communication protocol, S7CommPlus, and the Profinet Discovery and Basic Configuration Protocol are found to be vulnerable. Attacks like session stealing, phantom PLC, cross connecting controllers and denial of S7 connections are demonstrated. The lack of authentication and consequent exploitation of the S7-ACK packet, an application layer packet for the S7CommPlus protocol, is highlighted as a key issue in this investigation.\n – https://www.scienceopen.com/hosted-document?doi=10.14236/ewic/ICS2018.8"
      },
      "date": 1659435920339
    },
    {
      "item": {
        "type": "factory",
        "id": "29a372def491e282"
      },
      "id": "29a372def491e282",
      "type": "add",
      "after": "b83efdba7d2fccec",
      "date": 1659444622919
    },
    {
      "type": "edit",
      "id": "29a372def491e282",
      "item": {
        "type": "paragraph",
        "id": "29a372def491e282",
        "text": "– https://iopscience.iop.org/article/10.1088/1742-6596/1802/4/042089/meta"
      },
      "date": 1659444629545
    },
    {
      "type": "edit",
      "id": "29a372def491e282",
      "item": {
        "type": "markdown",
        "id": "29a372def491e282",
        "text": "– https://iopscience.iop.org/article/10.1088/1742-6596/1802/4/042089/meta"
      },
      "date": 1659444631056
    },
    {
      "item": {
        "type": "factory",
        "id": "9957547c0a258065"
      },
      "id": "9957547c0a258065",
      "type": "add",
      "after": "29a372def491e282",
      "date": 1659444716901
    },
    {
      "type": "edit",
      "id": "9957547c0a258065",
      "item": {
        "type": "markdown",
        "id": "9957547c0a258065",
        "text": "> The main control system of the elevator can issue different instructions for the operation of the elevator according to the different needs of users, so as to achieve the purpose of transporting people and goods efficiently. With the continuous development of China's elevator industry and the significant increase of elevator installed capacity[1], In practical engineering, higher requirements are put forward for elevator safety. In this regard, based on Siemens Portal platform, this paper designs an automatic control emergency system including overweight, over travel protection, door opening and closing protection, to assist the main control system to maintain the normal operation of the elevator. The proposed scheme is simulated in the Elevator Simulation platform, and the results show that the emergency system can effectively prevent the wrong operation during the operation of the elevator, and greatly improve the safety of the elevator. At the same time, because the system is written in LAD language and has good readability and portability, it can be widely used in the elevator master control system with Siemens PLC as the main controller."
      },
      "date": 1659444719778
    },
    {
      "item": {
        "type": "factory",
        "id": "383f2206861451ce"
      },
      "id": "383f2206861451ce",
      "type": "add",
      "after": "9957547c0a258065",
      "date": 1659444821742
    },
    {
      "type": "edit",
      "id": "383f2206861451ce",
      "item": {
        "type": "paragraph",
        "id": "383f2206861451ce",
        "text": "[…] elevator simulation platform of Deprol company […]"
      },
      "date": 1659444831981
    },
    {
      "type": "edit",
      "id": "29a372def491e282",
      "item": {
        "type": "markdown",
        "id": "29a372def491e282",
        "text": "Design and Simulation of Elevator Emergency System Based on TIA Portal V15.1. [https://iopscience.iop.org/article/10.1088/1742-6596/1802/4/042089/meta doi]"
      },
      "date": 1659444977055
    },
    {
      "item": {
        "type": "factory",
        "id": "ff9ddafea58f678c"
      },
      "id": "ff9ddafea58f678c",
      "type": "add",
      "after": "383f2206861451ce",
      "date": 1659445123172
    },
    {
      "type": "edit",
      "id": "ff9ddafea58f678c",
      "item": {
        "type": "paragraph",
        "id": "ff9ddafea58f678c",
        "text": "– https://iopscience.iop.org/article/10.1088/1742-6596/2212/1/012010/meta"
      },
      "date": 1659445126181
    },
    {
      "type": "edit",
      "id": "ff9ddafea58f678c",
      "item": {
        "type": "markdown",
        "id": "ff9ddafea58f678c",
        "text": "– https://iopscience.iop.org/article/10.1088/1742-6596/2212/1/012010/meta"
      },
      "date": 1659445127322
    },
    {
      "item": {
        "type": "factory",
        "id": "289b590b234f9532"
      },
      "id": "289b590b234f9532",
      "type": "add",
      "after": "ff9ddafea58f678c",
      "date": 1659445188082
    },
    {
      "type": "edit",
      "id": "289b590b234f9532",
      "item": {
        "type": "markdown",
        "id": "289b590b234f9532",
        "text": "> Digital twins are rapidly establishing themselves as a necessary step in digital change also in the design of automated and robotic manufacturing systems. The digital twin serves as an interface between physical industrial products and digital worlds. This allows you to map the continuous availability of data throughout the lifecycle from product planning and development, production and commissioning to use and recycling. An important step towards this goal is to create digital twins of the components in order to create a database usable for the design of new production systems in a virtual environment. One of the possibilities of using the digital twins is testing and virtual commissioning of production systems. Instead of the classic CAD model, the digital twin replaces a detailed digital image of individual components, including their full functionality. The Digital Twin comprises the CAD model, kinematic behavior model a most important is the logical behavior model. Our goal is to create a digital twin component of the production system, integrate a CAD model, create a kinematic model and a logical behavior model. This digital twin will have signals assigned to it for logical behavior. The result is the verification and testing of the information exchange between the virtual control system and the virtual model, using the Software-in-the-Loop method and the Tecnomatix Process Simulate software environment on the digital twin side and the Siemens TIA Portal with PLC SIM Advanced on the controller side. The result of the knowledge is that the exchange of information is functional and usable for virtual commissioning."
      },
      "date": 1659445191243
    },
    {
      "item": {
        "type": "factory",
        "id": "f5062c3e80adbc5f"
      },
      "id": "f5062c3e80adbc5f",
      "type": "add",
      "after": "289b590b234f9532",
      "date": 1659445267206
    },
    {
      "type": "edit",
      "id": "f5062c3e80adbc5f",
      "item": {
        "type": "paragraph",
        "id": "f5062c3e80adbc5f",
        "text": "Tecnomatix Process Simulate"
      },
      "date": 1659445270776
    },
    {
      "item": {
        "type": "factory",
        "id": "ac2432289954941f"
      },
      "id": "ac2432289954941f",
      "type": "add",
      "after": "f5062c3e80adbc5f",
      "date": 1659445366149
    },
    {
      "type": "edit",
      "id": "ac2432289954941f",
      "item": {
        "type": "paragraph",
        "id": "ac2432289954941f",
        "text": "– https://www.engusa.com/en/product/siemens-tecnomatix-process-simulate"
      },
      "date": 1659445369080
    },
    {
      "type": "edit",
      "id": "ac2432289954941f",
      "item": {
        "type": "markdown",
        "id": "ac2432289954941f",
        "text": "– https://www.engusa.com/en/product/siemens-tecnomatix-process-simulate"
      },
      "date": 1659445370394
    },
    {
      "item": {
        "type": "factory",
        "id": "506b1dcd4e64b3af"
      },
      "id": "506b1dcd4e64b3af",
      "type": "add",
      "after": "ac2432289954941f",
      "date": 1659446076624
    },
    {
      "type": "edit",
      "id": "506b1dcd4e64b3af",
      "item": {
        "type": "paragraph",
        "id": "506b1dcd4e64b3af",
        "text": "– https://ieeexplore.ieee.org/abstract/document/6121945?casa_token=hznrEnBRGSUAAAAA:6vFDYDBMLZyxZjjdCfmV1Saaf7tdZByOV05U72WdZY0l4sKdC_qA19VOBkt31wHNVb36abUJwzE"
      },
      "date": 1659446080086
    },
    {
      "type": "edit",
      "id": "506b1dcd4e64b3af",
      "item": {
        "type": "markdown",
        "id": "506b1dcd4e64b3af",
        "text": "– https://ieeexplore.ieee.org/abstract/document/6121945?casa_token=hznrEnBRGSUAAAAA:6vFDYDBMLZyxZjjdCfmV1Saaf7tdZByOV05U72WdZY0l4sKdC_qA19VOBkt31wHNVb36abUJwzE"
      },
      "date": 1659446081173
    },
    {
      "item": {
        "type": "factory",
        "id": "739bd27619159743"
      },
      "id": "739bd27619159743",
      "type": "add",
      "after": "506b1dcd4e64b3af",
      "date": 1659446114673
    },
    {
      "type": "edit",
      "id": "739bd27619159743",
      "item": {
        "type": "markdown",
        "id": "739bd27619159743",
        "text": "> Simulation-based programmable logic controller (PLC) code verification is a part of virtual commissioning, where the control code is verified against a virtual prototype of an application. With today's general OPC interface, it is easy to connect a PLC to a simulation tool for, e.g., verification purposes. However, there are some problems with this approach that can lead to an unreliable verification result. In this paper, four major problems with the OPC interface are described, and two possible solutions to the problems are presented: a general IEC 61131-3-based software solution, and a new OPC standard solution."
      },
      "date": 1659446118481
    },
    {
      "type": "edit",
      "id": "506b1dcd4e64b3af",
      "item": {
        "type": "markdown",
        "id": "506b1dcd4e64b3af",
        "text": "Methods for Reliable Simulation-Based PLC Code Verification. – [https://ieeexplore.ieee.org/abstract/document/6121945 page]"
      },
      "date": 1659450927183
    },
    {
      "type": "edit",
      "id": "506b1dcd4e64b3af",
      "item": {
        "type": "markdown",
        "id": "506b1dcd4e64b3af",
        "text": "Methods for Reliable Simulation-Based PLC Code Verification. [https://ieeexplore.ieee.org/abstract/document/6121945 page]"
      },
      "date": 1659450966889
    },
    {
      "type": "edit",
      "id": "739bd27619159743",
      "item": {
        "type": "markdown",
        "id": "739bd27619159743",
        "text": "> Simulation-based programmable logic controller (PLC) code verification is a part of \"virtual commissioning\", where the control code is verified against a virtual prototype of an application. With today's general OPC interface, it is easy to connect a PLC to a simulation tool for, e.g., verification purposes. However, there are some problems with this approach that can lead to an unreliable verification result. In this paper, four major problems with the OPC interface are described, and two possible solutions to the problems are presented: a general IEC 61131-3-based software solution, and a new OPC standard solution."
      },
      "date": 1659451213233
    },
    {
      "type": "edit",
      "id": "739bd27619159743",
      "item": {
        "type": "markdown",
        "id": "739bd27619159743",
        "text": "> Simulation-based programmable logic controller (PLC) code verification is a part of [[virtual commissioning]], where the control code is verified against a virtual prototype of an application. With today's general OPC interface, it is easy to connect a PLC to a simulation tool for, e.g., verification purposes. However, there are some problems with this approach that can lead to an unreliable verification result. In this paper, four major problems with the OPC interface are described, and two possible solutions to the problems are presented: a general IEC 61131-3-based software solution, and a new OPC standard solution."
      },
      "date": 1659451224157
    },
    {
      "type": "edit",
      "id": "ac2432289954941f",
      "item": {
        "type": "markdown",
        "id": "ac2432289954941f",
        "text": "Siemens Tecnomatix Process Simulate. [https://www.engusa.com/en/product/siemens-tecnomatix-process-simulate page]"
      },
      "date": 1659459094561
    },
    {
      "item": {
        "type": "factory",
        "id": "2d086fa0534dc18a"
      },
      "id": "2d086fa0534dc18a",
      "type": "add",
      "after": "739bd27619159743",
      "date": 1659459331407
    },
    {
      "type": "edit",
      "id": "2d086fa0534dc18a",
      "item": {
        "type": "paragraph",
        "id": "2d086fa0534dc18a",
        "text": "– [https://media.plm.automation.siemens.com/tecnomatix/interactive/Siemens-PLM-Tecnomatix-Process-Simulate-fs-X7.pdf pdf]"
      },
      "date": 1659459341798
    },
    {
      "type": "edit",
      "id": "2d086fa0534dc18a",
      "item": {
        "type": "paragraph",
        "id": "2d086fa0534dc18a",
        "text": "Process Simulate– [https://media.plm.automation.siemens.com/tecnomatix/interactive/Siemens-PLM-Tecnomatix-Process-Simulate-fs-X7.pdf pdf]"
      },
      "date": 1659459361974
    },
    {
      "type": "edit",
      "id": "2d086fa0534dc18a",
      "item": {
        "type": "paragraph",
        "id": "2d086fa0534dc18a",
        "text": "Process Simulate. Manufacturing process verification in powerful 3D environment. [https://media.plm.automation.siemens.com/tecnomatix/interactive/Siemens-PLM-Tecnomatix-Process-Simulate-fs-X7.pdf pdf]"
      },
      "date": 1659459379818
    },
    {
      "type": "edit",
      "id": "2d086fa0534dc18a",
      "item": {
        "type": "paragraph",
        "id": "2d086fa0534dc18a",
        "text": "[[Process Simulate]]. Manufacturing process verification in powerful 3D environment. [https://media.plm.automation.siemens.com/tecnomatix/interactive/Siemens-PLM-Tecnomatix-Process-Simulate-fs-X7.pdf pdf]"
      },
      "date": 1659459505455
    },
    {
      "type": "edit",
      "id": "2d086fa0534dc18a",
      "item": {
        "type": "paragraph",
        "id": "2d086fa0534dc18a",
        "text": "⇒ [[Process Simulate]]. Manufacturing process verification in powerful 3D environment. [https://media.plm.automation.siemens.com/tecnomatix/interactive/Siemens-PLM-Tecnomatix-Process-Simulate-fs-X7.pdf pdf]"
      },
      "date": 1659459517891
    },
    {
      "type": "edit",
      "id": "2d086fa0534dc18a",
      "item": {
        "type": "paragraph",
        "id": "2d086fa0534dc18a",
        "text": "⇒ [[Process Simulate]]. "
      },
      "date": 1659459537130
    },
    {
      "type": "edit",
      "id": "2d086fa0534dc18a",
      "item": {
        "type": "paragraph",
        "id": "2d086fa0534dc18a",
        "text": "⇒ [[Process Simulate]] "
      },
      "date": 1659459544580
    },
    {
      "type": "edit",
      "id": "739bd27619159743",
      "item": {
        "type": "markdown",
        "id": "739bd27619159743",
        "text": "> Simulation-based programmable logic controller (PLC) code verification is a part of [[virtual commissioning]], where the control code is verified against a virtual prototype of an application. With today's general [[OPC]] interface, it is easy to connect a PLC to a simulation tool for, e.g., verification purposes. However, there are some problems with this approach that can lead to an unreliable verification result. In this paper, four major problems with the OPC interface are described, and two possible solutions to the problems are presented: a general IEC 61131-3-based software solution, and a new OPC standard solution."
      },
      "date": 1659460644252
    },
    {
      "item": {
        "type": "factory",
        "id": "8631d84a1bab2d51"
      },
      "id": "8631d84a1bab2d51",
      "type": "add",
      "after": "2d086fa0534dc18a",
      "date": 1659468516445
    },
    {
      "type": "edit",
      "id": "8631d84a1bab2d51",
      "item": {
        "type": "paragraph",
        "id": "8631d84a1bab2d51",
        "text": "IEC 61131-3 Ladder Diagram (LD)"
      },
      "date": 1659468525384
    },
    {
      "item": {
        "type": "factory",
        "id": "d1c5d60e3d89cd76"
      },
      "id": "d1c5d60e3d89cd76",
      "type": "add",
      "after": "8631d84a1bab2d51",
      "date": 1659469905787
    },
    {
      "type": "edit",
      "id": "d1c5d60e3d89cd76",
      "item": {
        "type": "paragraph",
        "id": "d1c5d60e3d89cd76",
        "text": "LI, Dandan, CAI, Qixian and PEI, Feng, 2010. The new interconversion algorithm between ladder diagram and instruction list. In: 2010 IEEE International Conference on Intelligent Computing and Intelligent Systems. Online. Xiamen, China: IEEE. October 2010. p. 820–823. [Accessed 2 August 2022]. ISBN 978-1-4244-6582-8. DOI 10.1109/ICICISYS.2010.5658297. \n"
      },
      "date": 1659469913062
    },
    {
      "item": {
        "type": "factory",
        "id": "8b2ab5cae2ff1bf0"
      },
      "id": "8b2ab5cae2ff1bf0",
      "type": "add",
      "after": "d1c5d60e3d89cd76",
      "date": 1659469943436
    },
    {
      "type": "edit",
      "id": "8b2ab5cae2ff1bf0",
      "item": {
        "type": "markdown",
        "id": "8b2ab5cae2ff1bf0",
        "text": "> In the application of PLC (Programmable Logic Controller), ladder diagram is visual and easy to control by engineering staff, besides, instruction list is easily convert into assembly language program, so they are favored by technicians, so that the research of interconversion between ladder diagram and instruction list become a key technique in development of PLC. The conversion algorithm in present is maps ladder diagram to AOV graph, then it realizes the interconversion between ladder diagram and instruction list by sorting AOV graph, but efficient of the algorithm is lower. A new algorithm about interconversion between ladder diagram and instruction list based on forest and binary tree is presented in this paper by the research and analysis of ladder diagram's language and instruction list on PLC. At first it maps ladder diagram to forest, and then it establishes a binary tree to represent ladder diagram logical relationship with forest At last it realizes the exchange of PLC ladder diagram and instruction list by traversing binary tree. The algorithm is simple and rapid, its correctness and feasibility are verified in programming software platform of PLC."
      },
      "date": 1659469946992
    }
  ]
}