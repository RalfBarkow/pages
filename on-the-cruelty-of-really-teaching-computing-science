{
  "title": "On the Cruelty of Really Teaching Computing Science",
  "story": [
    {
      "type": "markdown",
      "id": "3a0aaa3fd005cfb1",
      "text": "Edsger W. Dijkstra (1989) \"On the Cruelty of Really Teaching Computing Science\" Comm. ACM, Vol.32, no.12 pp.1398-1404 doi:10.1145/76380.76381 – [https://steve.psy.gla.ac.uk/educ/dijkstra.html page]"
    },
    {
      "type": "markdown",
      "id": "3764e87728545145",
      "text": "P. J. Denning, “A debate on teaching computing science,” Commun. ACM, vol. 32, no. 12, pp. 1397–1414, 1989, doi: 10.1145/76380.76381.\n\nAt the ACM Computer Science Conference in February 1988, Edsger Dijkstra gave an invited talk called “On the Cruelty of Really Teaching Computing Science.” \n"
    },
    {
      "type": "pagefold",
      "id": "9996082efb151b69",
      "text": "Part B. Scientific and educational consequences"
    },
    {
      "type": "markdown",
      "id": "2329727d2dcbf291",
      "text": "> And now comes the second – and hardest – part of my talk: the scientific and educational consequences of the above. The educational consequences are, of course, the hairier ones, so let’s postpone their discussion and stay for a while with computing science itself. What is computing? And what is a science of computing about?"
    },
    {
      "type": "markdown",
      "id": "ed723736451e5934",
      "text": "The only thing computers can do for us is manipulate symbols and produce the results of such manipulations. From our observations so far, we should remember that this is a discrete world and that both the number of symbols involved and the scope of manipulations performed are many orders of magnitude greater than we can imagine: They are completely beyond our imagination and therefore we must not try to imagine them.\n"
    },
    {
      "type": "markdown",
      "id": "d2c7575e29b3404a",
      "text": "But before a computer is ready to perform a class of meaningful manipulations – or calculations, if you will – we must write a program. What is a program? Several answers are possible. We can think of the program as that which transforms the general-purpose computer into a special symbol manipulator without the need to change a single wire (this was a vast improvement over machines with problem-dependent switchboards). Edsger W. Dijkstra prefers to describe it the other way around: The program is an abstract symbol manipulator that can be turned into a concrete one by giving it a computer. After all, the purpose of programs is no longer to instruct our machines; nowadays the purpose of machines is to execute our programs.\n"
    },
    {
      "type": "markdown",
      "id": "0e793b90cdf4d7d2",
      "text": "So we need to design abstract symbol manipulators. We all know what they look like: They look like programs or, to use a more general terminology, usually pretty complicated formulas from a formal system. It's really helpful to think of a program as a formula. First, it puts the programmer's job in perspective: he has to derive that formula. Second, it explains why the world of mathematics all but ignored the challenge of programming: programs were so much longer formulas than it was used to that it didn't even recognize them as such. Now back to the programmer's task: he has to derive this formula, he has to derive this program. We know only one reliable way to do that, namely by symbol manipulation. And now the circle is closed: We construct our mechanical symbol manipulators with the help of human symbol manipulation.\n"
    },
    {
      "type": "markdown",
      "id": "f33f85da421a9b06",
      "text": "Computer science is therefore concerned – and always will be – with the interplay of machine and human symbol manipulation, usually referred to as \"computing\" and \"programming\" respectively. An immediate advantage of this insight is that it exposes \"automatic programming\" as a contradiction in terms. Another advantage is that it gives us a clear indication of where computer science should be placed on the world map of intellectual disciplines: in the direction of formal mathematics and applied logic, but ultimately far beyond, because computer science is interested in the effective use of formal methods, and on a much, much larger scale than we have yet experienced. Since there is no serious endeavor these days without a TLA (= Three-Letter Acronym), Dijkstra proposes that we adopt FMI (= Formal Methods Initiative) for computer science, and to be on the safe side, we had better follow the shining example of our leaders and make it a trademark.\n"
    },
    {
      "type": "markdown",
      "id": "e3a4256310795ec3",
      "text": "In the long run, Dijkstra expects computer science to surpass its parent disciplines, mathematics and logic, by realizing a significant part of Leibniz's dream of offering symbolic computation as an alternative to human thought. (Please note the difference between \"emulating\" and \"offering an alternative\": Alternatives may be better.)"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "On the Cruelty of Really Teaching Computing Science",
        "story": []
      },
      "date": 1631810848156
    },
    {
      "item": {
        "type": "factory",
        "id": "3764e87728545145"
      },
      "id": "3764e87728545145",
      "type": "add",
      "date": 1631810849497
    },
    {
      "type": "edit",
      "id": "3764e87728545145",
      "item": {
        "type": "markdown",
        "id": "3764e87728545145",
        "text": "https://www.psy.gla.ac.uk/~steve/educ/dijk/EWD1036.v4.pdf"
      },
      "date": 1631810851965
    },
    {
      "item": {
        "type": "factory",
        "id": "2329727d2dcbf291"
      },
      "id": "2329727d2dcbf291",
      "type": "add",
      "after": "3764e87728545145",
      "date": 1631811459079
    },
    {
      "type": "edit",
      "id": "2329727d2dcbf291",
      "item": {
        "type": "markdown",
        "id": "2329727d2dcbf291",
        "text": "Scientific and Educational Consequences"
      },
      "date": 1631811469237
    },
    {
      "item": {
        "type": "factory",
        "id": "9996082efb151b69"
      },
      "id": "9996082efb151b69",
      "type": "add",
      "after": "2329727d2dcbf291",
      "date": 1631811471180
    },
    {
      "type": "edit",
      "id": "9996082efb151b69",
      "item": {
        "type": "pagefold",
        "id": "9996082efb151b69",
        "text": "Scientific and Educational Consequences"
      },
      "date": 1631811473711
    },
    {
      "id": "2329727d2dcbf291",
      "type": "move",
      "order": [
        "3764e87728545145",
        "9996082efb151b69",
        "2329727d2dcbf291"
      ],
      "date": 1631811477195
    },
    {
      "type": "edit",
      "id": "2329727d2dcbf291",
      "item": {
        "type": "markdown",
        "id": "2329727d2dcbf291",
        "text": "> And now comes the second --and hardest-- part of my talk: the scientific and educational consequences of the above. The educational consequences are, of course, the hairier ones, so let’s postpone their discussion and stay for a while with computing science itself. What is computing? And what is a science of computing about?"
      },
      "date": 1631811509841
    },
    {
      "type": "edit",
      "id": "2329727d2dcbf291",
      "item": {
        "type": "markdown",
        "id": "2329727d2dcbf291",
        "text": "> And now comes the second – and hardest – part of my talk: the scientific and educational consequences of the above. The educational consequences are, of course, the hairier ones, so let’s postpone their discussion and stay for a while with computing science itself. What is computing? And what is a science of computing about?"
      },
      "date": 1631811521936
    },
    {
      "item": {
        "type": "factory",
        "id": "ed723736451e5934"
      },
      "id": "ed723736451e5934",
      "type": "add",
      "after": "2329727d2dcbf291",
      "date": 1631811579391
    },
    {
      "type": "edit",
      "id": "ed723736451e5934",
      "item": {
        "type": "markdown",
        "id": "ed723736451e5934",
        "text": "\nThe only thing computers can do for us is manipulate symbols and produce the results of such manipulations. From our observations so far, we should remember that this is a discrete world and that both the number of symbols involved and the scope of manipulations performed are many orders of magnitude greater than we can imagine: They are completely beyond our imagination and therefore we must not try to imagine them."
      },
      "date": 1631811582855
    },
    {
      "type": "edit",
      "id": "ed723736451e5934",
      "item": {
        "type": "markdown",
        "id": "ed723736451e5934",
        "text": "The only thing computers can do for us is manipulate symbols and produce the results of such manipulations. From our observations so far, we should remember that this is a discrete world and that both the number of symbols involved and the scope of manipulations performed are many orders of magnitude greater than we can imagine: They are completely beyond our imagination and therefore we must not try to imagine them.\n"
      },
      "date": 1631811613435
    },
    {
      "type": "add",
      "id": "d2c7575e29b3404a",
      "item": {
        "type": "markdown",
        "id": "d2c7575e29b3404a",
        "text": "But before a computer is ready to perform a class of meaningful manipulations - or calculations, if you will - we must write a program. What is a program? Several answers are possible. We can think of the program as that which transforms the general-purpose computer into a special symbol manipulator without the need to change a single wire (this was a vast improvement over machines with problem-dependent switchboards). I prefer to describe it the other way around: The program is an abstract symbol manipulator that can be turned into a concrete one by giving it a computer. After all, the purpose of programs is no longer to instruct our machines; nowadays the purpose of machines is to execute our programs."
      },
      "after": "ed723736451e5934",
      "date": 1631811614583
    },
    {
      "type": "edit",
      "id": "d2c7575e29b3404a",
      "item": {
        "type": "markdown",
        "id": "d2c7575e29b3404a",
        "text": "But before a computer is ready to perform a class of meaningful manipulations – or calculations, if you will – we must write a program. What is a program? Several answers are possible. We can think of the program as that which transforms the general-purpose computer into a special symbol manipulator without the need to change a single wire (this was a vast improvement over machines with problem-dependent switchboards). I prefer to describe it the other way around: The program is an abstract symbol manipulator that can be turned into a concrete one by giving it a computer. After all, the purpose of programs is no longer to instruct our machines; nowadays the purpose of machines is to execute our programs."
      },
      "date": 1631811630165
    },
    {
      "type": "edit",
      "id": "d2c7575e29b3404a",
      "item": {
        "type": "markdown",
        "id": "d2c7575e29b3404a",
        "text": "But before a computer is ready to perform a class of meaningful manipulations – or calculations, if you will – we must write a program. What is a program? Several answers are possible. We can think of the program as that which transforms the general-purpose computer into a special symbol manipulator without the need to change a single wire (this was a vast improvement over machines with problem-dependent switchboards). Edsger W. Dijkstra prefers to describe it the other way around: The program is an abstract symbol manipulator that can be turned into a concrete one by giving it a computer. After all, the purpose of programs is no longer to instruct our machines; nowadays the purpose of machines is to execute our programs."
      },
      "date": 1631811662069
    },
    {
      "type": "edit",
      "id": "d2c7575e29b3404a",
      "item": {
        "type": "markdown",
        "id": "d2c7575e29b3404a",
        "text": "But before a computer is ready to perform a class of meaningful manipulations – or calculations, if you will – we must write a program. What is a program? Several answers are possible. We can think of the program as that which transforms the general-purpose computer into a special symbol manipulator without the need to change a single wire (this was a vast improvement over machines with problem-dependent switchboards). Edsger W. Dijkstra prefers to describe it the other way around: The program is an abstract symbol manipulator that can be turned into a concrete one by giving it a computer. After all, the purpose of programs is no longer to instruct our machines; nowadays the purpose of machines is to execute our programs.\n"
      },
      "date": 1631811714147
    },
    {
      "type": "add",
      "id": "0e793b90cdf4d7d2",
      "item": {
        "type": "markdown",
        "id": "0e793b90cdf4d7d2",
        "text": "So we need to design abstract symbol manipulators. We all know what they look like: They look like programs or, to use a more general terminology, usually pretty complicated formulas from a formal system. It's really helpful to think of a program as a formula. First, it puts the programmer's job in perspective: he has to derive that formula. Second, it explains why the world of mathematics all but ignored the challenge of programming: programs were so much longer formulas than it was used to that it didn't even recognize them as such. Now back to the programmer's task: he has to derive this formula, he has to derive this program. We know only one reliable way to do that, namely by symbol manipulation. And now the circle is closed: We construct our mechanical symbol manipulators with the help of human symbol manipulation."
      },
      "after": "d2c7575e29b3404a",
      "date": 1631811715722
    },
    {
      "type": "edit",
      "id": "0e793b90cdf4d7d2",
      "item": {
        "type": "markdown",
        "id": "0e793b90cdf4d7d2",
        "text": "So we need to design abstract symbol manipulators. We all know what they look like: They look like programs or, to use a more general terminology, usually pretty complicated formulas from a formal system. It's really helpful to think of a program as a formula. First, it puts the programmer's job in perspective: he has to derive that formula. Second, it explains why the world of mathematics all but ignored the challenge of programming: programs were so much longer formulas than it was used to that it didn't even recognize them as such. Now back to the programmer's task: he has to derive this formula, he has to derive this program. We know only one reliable way to do that, namely by symbol manipulation. And now the circle is closed: We construct our mechanical symbol manipulators with the help of human symbol manipulation.\n"
      },
      "date": 1631811790952
    },
    {
      "type": "add",
      "id": "f33f85da421a9b06",
      "item": {
        "type": "markdown",
        "id": "f33f85da421a9b06",
        "text": "Computer science is therefore concerned - and always will be - with the interplay of machine and human symbol manipulation, usually referred to as \"computing\" and \"programming\" respectively. An immediate advantage of this insight is that it exposes \"automatic programming\" as a contradiction in terms. Another advantage is that it gives us a clear indication of where computer science should be placed on the world map of intellectual disciplines: in the direction of formal mathematics and applied logic, but ultimately far beyond, because computer science is interested in the effective use of formal methods, and on a much, much larger scale than we have yet experienced. Since there is no serious endeavor these days without a TLA (= Three-Letter Acronym), I propose that we adopt FMI (= Formal Methods Initiative) for computer science, and to be on the safe side, we had better follow the shining example of our leaders and make it a trademark."
      },
      "after": "0e793b90cdf4d7d2",
      "date": 1631811792996
    },
    {
      "type": "edit",
      "id": "f33f85da421a9b06",
      "item": {
        "type": "markdown",
        "id": "f33f85da421a9b06",
        "text": "Computer science is therefore concerned – and always will be – with the interplay of machine and human symbol manipulation, usually referred to as \"computing\" and \"programming\" respectively. An immediate advantage of this insight is that it exposes \"automatic programming\" as a contradiction in terms. Another advantage is that it gives us a clear indication of where computer science should be placed on the world map of intellectual disciplines: in the direction of formal mathematics and applied logic, but ultimately far beyond, because computer science is interested in the effective use of formal methods, and on a much, much larger scale than we have yet experienced. Since there is no serious endeavor these days without a TLA (= Three-Letter Acronym), I propose that we adopt FMI (= Formal Methods Initiative) for computer science, and to be on the safe side, we had better follow the shining example of our leaders and make it a trademark."
      },
      "date": 1631811804686
    },
    {
      "type": "edit",
      "id": "3764e87728545145",
      "item": {
        "type": "markdown",
        "id": "3764e87728545145",
        "text": "https://www.psy.gla.ac.uk/~steve/educ/dijk/EWD1036.v4.pdf\n"
      },
      "date": 1631811871452
    },
    {
      "type": "add",
      "id": "d2575a5ca5c1406c",
      "item": {
        "type": "markdown",
        "id": "d2575a5ca5c1406c",
        "text": "https://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1036.PDF"
      },
      "after": "3764e87728545145",
      "date": 1631811872608
    },
    {
      "type": "edit",
      "id": "f33f85da421a9b06",
      "item": {
        "type": "markdown",
        "id": "f33f85da421a9b06",
        "text": "Computer science is therefore concerned – and always will be – with the interplay of machine and human symbol manipulation, usually referred to as \"computing\" and \"programming\" respectively. An immediate advantage of this insight is that it exposes \"automatic programming\" as a contradiction in terms. Another advantage is that it gives us a clear indication of where computer science should be placed on the world map of intellectual disciplines: in the direction of formal mathematics and applied logic, but ultimately far beyond, because computer science is interested in the effective use of formal methods, and on a much, much larger scale than we have yet experienced. Since there is no serious endeavor these days without a TLA (= Three-Letter Acronym), Dijkstra proposes that we adopt FMI (= Formal Methods Initiative) for computer science, and to be on the safe side, we had better follow the shining example of our leaders and make it a trademark."
      },
      "date": 1631811924012
    },
    {
      "type": "edit",
      "id": "f33f85da421a9b06",
      "item": {
        "type": "markdown",
        "id": "f33f85da421a9b06",
        "text": "Computer science is therefore concerned – and always will be – with the interplay of machine and human symbol manipulation, usually referred to as \"computing\" and \"programming\" respectively. An immediate advantage of this insight is that it exposes \"automatic programming\" as a contradiction in terms. Another advantage is that it gives us a clear indication of where computer science should be placed on the world map of intellectual disciplines: in the direction of formal mathematics and applied logic, but ultimately far beyond, because computer science is interested in the effective use of formal methods, and on a much, much larger scale than we have yet experienced. Since there is no serious endeavor these days without a TLA (= Three-Letter Acronym), Dijkstra proposes that we adopt FMI (= Formal Methods Initiative) for computer science, and to be on the safe side, we had better follow the shining example of our leaders and make it a trademark.\n"
      },
      "date": 1631811970923
    },
    {
      "type": "add",
      "id": "e3a4256310795ec3",
      "item": {
        "type": "markdown",
        "id": "e3a4256310795ec3",
        "text": "\nIn the long run, I expect computer science to surpass its parent disciplines, mathematics and logic, by realizing a significant part of Leibniz's dream of offering symbolic computation as an alternative to human thought. (Please note the difference between \"emulating\" and \"offering an alternative\": Alternatives may be better.)"
      },
      "after": "f33f85da421a9b06",
      "date": 1631811972509
    },
    {
      "type": "edit",
      "id": "e3a4256310795ec3",
      "item": {
        "type": "markdown",
        "id": "e3a4256310795ec3",
        "text": "In the long run, Dijkstra expects computer science to surpass its parent disciplines, mathematics and logic, by realizing a significant part of Leibniz's dream of offering symbolic computation as an alternative to human thought. (Please note the difference between \"emulating\" and \"offering an alternative\": Alternatives may be better.)"
      },
      "date": 1631811998270
    },
    {
      "type": "edit",
      "id": "3764e87728545145",
      "item": {
        "type": "markdown",
        "id": "3764e87728545145",
        "text": "P. J. Denning, “A debate on teaching computing science,” Commun. ACM, vol. 32, no. 12, pp. 1397–1414, 1989, doi: 10.1145/76380.76381.\n\nhttps://www.psy.gla.ac.uk/~steve/educ/dijk/EWD1036.v4.pdf\n"
      },
      "date": 1631812379814
    },
    {
      "type": "remove",
      "id": "d2575a5ca5c1406c",
      "date": 1631812393927
    },
    {
      "type": "edit",
      "id": "3764e87728545145",
      "item": {
        "type": "markdown",
        "id": "3764e87728545145",
        "text": "P. J. Denning, “A debate on teaching computing science,” Commun. ACM, vol. 32, no. 12, pp. 1397–1414, 1989, doi: 10.1145/76380.76381.\n\n"
      },
      "date": 1631812398987
    },
    {
      "type": "edit",
      "id": "3764e87728545145",
      "item": {
        "type": "markdown",
        "id": "3764e87728545145",
        "text": "P. J. Denning, “A debate on teaching computing science,” Commun. ACM, vol. 32, no. 12, pp. 1397–1414, 1989, doi: 10.1145/76380.76381.\n\nAt the ACM Computer Science Conference last February, Edsger Dijkstra gave an invited talk called “On the Cruelty \n"
      },
      "date": 1631812444548
    },
    {
      "type": "edit",
      "id": "3764e87728545145",
      "item": {
        "type": "markdown",
        "id": "3764e87728545145",
        "text": "P. J. Denning, “A debate on teaching computing science,” Commun. ACM, vol. 32, no. 12, pp. 1397–1414, 1989, doi: 10.1145/76380.76381.\n\nAt the ACM Computer Science Conference last February, Edsger Dijkstra gave an invited talk called “On the Cruelty of Really Teaching Computing Science.” "
      },
      "date": 1631812487567
    },
    {
      "type": "edit",
      "id": "3764e87728545145",
      "item": {
        "type": "markdown",
        "id": "3764e87728545145",
        "text": "P. J. Denning, “A debate on teaching computing science,” Commun. ACM, vol. 32, no. 12, pp. 1397–1414, 1989, doi: 10.1145/76380.76381.\n\nAt the ACM Computer Science Conference in February 1988, Edsger Dijkstra gave an invited talk called “On the Cruelty of Really Teaching Computing Science.” "
      },
      "date": 1631812854060
    },
    {
      "type": "edit",
      "id": "3764e87728545145",
      "item": {
        "type": "markdown",
        "id": "3764e87728545145",
        "text": "P. J. Denning, “A debate on teaching computing science,” Commun. ACM, vol. 32, no. 12, pp. 1397–1414, 1989, doi: 10.1145/76380.76381.\n\nAt the ACM Computer Science Conference in February 1988, Edsger Dijkstra gave an invited talk called “On the Cruelty of Really Teaching Computing Science.” \n"
      },
      "date": 1631812879880
    },
    {
      "type": "add",
      "id": "3a0aaa3fd005cfb1",
      "item": {
        "type": "markdown",
        "id": "3a0aaa3fd005cfb1",
        "text": "Edsger W. Dijkstra (1989) \"On the Cruelty of Really Teaching Computing Science\" Comm. ACM, Vol.32, no.12 pp.1398-1404 doi:10.1145/76380.76381"
      },
      "after": "3764e87728545145",
      "date": 1631812892648
    },
    {
      "id": "3a0aaa3fd005cfb1",
      "type": "move",
      "order": [
        "3a0aaa3fd005cfb1",
        "3764e87728545145",
        "9996082efb151b69",
        "2329727d2dcbf291",
        "ed723736451e5934",
        "d2c7575e29b3404a",
        "0e793b90cdf4d7d2",
        "f33f85da421a9b06",
        "e3a4256310795ec3"
      ],
      "date": 1631812894504
    },
    {
      "type": "edit",
      "id": "3a0aaa3fd005cfb1",
      "item": {
        "type": "markdown",
        "id": "3a0aaa3fd005cfb1",
        "text": "Edsger W. Dijkstra (1989) \"On the Cruelty of Really Teaching Computing Science\" Comm. ACM, Vol.32, no.12 pp.1398-1404 doi:10.1145/76380.76381 – [https://steve.psy.gla.ac.uk/educ/dijkstra.html page]"
      },
      "date": 1631812954252
    },
    {
      "type": "edit",
      "id": "9996082efb151b69",
      "item": {
        "type": "pagefold",
        "id": "9996082efb151b69",
        "text": "Part B. Scientific and educational consequences"
      },
      "date": 1631812979789
    }
  ]
}