{
  "title": "Hoisting",
  "story": [
    {
      "type": "paragraph",
      "id": "4e2be2e71e92b480",
      "text": "In JavaScript all function statements defined in a scope are read and made available before the rest of the code in that scope is executed. Variables declarations are also read in before hand and made available, but assignments to those variables aren't done until execution reaches them."
    },
    {
      "type": "paragraph",
      "id": "7022d563d286037a",
      "text": "This gives the appearance that function statements and variable declaration are 'hoisted' above everything else in that scope, hoisting above being a metaphor for happening beforehand. This is really handy for some things. The declaration hosting avoids a whole class of silly bugs that could happen if it wasn't done. And the function statement hoisting lets you organize the main flow of your code at the top of a scope, and all the utility code down below (even after the return)."
    },
    {
      "type": "paragraph",
      "id": "39737e0ef0457249",
      "text": "However, the two hoisting effects don't play well together in some cases. Say you have a utility function that has an external variable it uses to keep track of some state?"
    },
    {
      "type": "code",
      "id": "49c8b51dd9885a86",
      "text": "// WARNING: Hoisting bug.\nincrement()\nincrement()\nincrement()\nlog() // NaN\n\n// UTILITY CODE BELOW\n\nvar count = 0\nfunction increment () {\n  count += 1\n}\n\nfunction log () {\n  console.log(count)\n}"
    },
    {
      "type": "paragraph",
      "id": "fa6b82e73852a691",
      "text": "Our log is telling us that count is not a number, but no error occurs. Well, that is surprising. It seems like we are adding 1 to 0 three times. in reality, we add 1 to undefined, because the assignment to 0 doesn't happen until after the rest of our code executes!"
    },
    {
      "type": "code",
      "id": "1c40d09de09891bb",
      "text": "// WARNING: Hoisting bug.\nincrement()\nincrement()\nincrement()\nlog() // NaN\n\n// UTILITY CODE BELOW\n\nvar count = 0\n\nlog() // 0\n\nfunction increment () {\n  count += 1\n}\n\nfunction log () {\n  console.log(count)\n}"
    },
    {
      "type": "paragraph",
      "id": "5d049de7681000d4",
      "text": "Pretty clear when you look at it that way, but damn can it be a subtle one to find sometimes. Especially when you're switching back and forth between asynchronous and synchronous calls of these functions."
    },
    {
      "type": "code",
      "id": "d61a235777a781ef",
      "text": "setTimeout(function () {\n  increment()\n  increment()\n  increment()\n  log() // 3\n}, 0)\n\n// UTILITY CODE BELOW\n\nvar count = 0\nfunction increment () {\n  count += 1\n}\n\nfunction log () {\n  console.log(count)\n}"
    },
    {
      "type": "paragraph",
      "id": "5794ec7b14a6fb0e",
      "text": "So, despite some negative points for code organization, declare and initialize variables at the top of your scope. It will save you some pain down the road in ways that you might not even notice."
    },
    {
      "type": "code",
      "id": "a3681b901b882281",
      "text": "// It may not be clear why this\n// variable is here, but it's\n// worth needing to look for it.\nvar count = 0\n\nincrement()\nincrement()\nincrement()\nlog() // 3\n\n// UTILITY CODE BELOW\n\nfunction increment () {\n  count += 1\n}\n\nfunction log () {\n  console.log(count)\n}"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Hoisting",
        "story": []
      },
      "date": 1431366748412
    },
    {
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "4e2be2e71e92b480",
        "text": "In JavaScript all function statements defined in a scope are read and made available before the rest of the code in that scope is executed. Variables declarations are also read in before hand and made available, but assignments to those variables aren't done until execution reaches them."
      },
      "id": "4e2be2e71e92b480",
      "date": 1431366753410
    },
    {
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "7022d563d286037a",
        "text": "This gives the appearance that function statements and variable declaration are 'hoisted' above everything else in that scope, hoisting above being a metaphor for happening beforehand. This is really handy for some things. The declaration hosting avoids a whole class of silly bugs that could happen if it wasn't done. And the function statement hoisting lets you organize the main flow of your code at the top of a scope, and all the utility code down below (even after the return)."
      },
      "after": "4e2be2e71e92b480",
      "id": "7022d563d286037a",
      "date": 1431366758269
    },
    {
      "item": {
        "type": "factory",
        "id": "39737e0ef0457249"
      },
      "id": "39737e0ef0457249",
      "type": "add",
      "after": "7022d563d286037a",
      "date": 1431366800669
    },
    {
      "type": "edit",
      "id": "39737e0ef0457249",
      "item": {
        "type": "paragraph",
        "id": "39737e0ef0457249",
        "text": "However, the two hoisting effects don't play well together in some cases. Say you have a utility function that has an external variable it uses to keep track of some state?"
      },
      "date": 1431366886472
    },
    {
      "item": {
        "type": "factory",
        "id": "49c8b51dd9885a86"
      },
      "id": "49c8b51dd9885a86",
      "type": "add",
      "after": "39737e0ef0457249",
      "date": 1431367240154
    },
    {
      "type": "edit",
      "id": "49c8b51dd9885a86",
      "item": {
        "type": "code",
        "id": "49c8b51dd9885a86",
        "text": "increment()\nincrement()\nincrement()\nlog()\n\n// UTILITY CODE BELOW\n\nvar count = 0\nfunction increment () {\n  count += 1\n}\n\nfunction log () {\n  console.log(count)\n}"
      },
      "date": 1431367246576
    },
    {
      "item": {
        "type": "factory",
        "id": "a5535e4eedb4bad8"
      },
      "id": "a5535e4eedb4bad8",
      "type": "add",
      "after": "49c8b51dd9885a86",
      "date": 1431367250442
    },
    {
      "type": "remove",
      "id": "a5535e4eedb4bad8",
      "date": 1431367265069
    },
    {
      "type": "edit",
      "id": "49c8b51dd9885a86",
      "item": {
        "type": "code",
        "id": "49c8b51dd9885a86",
        "text": "// WARNING: Hoisting bug.\nincrement()\nincrement()\nincrement()\nlog() // NaN\n\n// UTILITY CODE BELOW\n\nvar count = 0\nfunction increment () {\n  count += 1\n}\n\nfunction log () {\n  console.log(count)\n}"
      },
      "date": 1431367331974
    },
    {
      "item": {
        "type": "factory",
        "id": "fa6b82e73852a691"
      },
      "id": "fa6b82e73852a691",
      "type": "add",
      "after": "49c8b51dd9885a86",
      "date": 1431367454652
    },
    {
      "type": "edit",
      "id": "fa6b82e73852a691",
      "item": {
        "type": "paragraph",
        "id": "fa6b82e73852a691",
        "text": "Our log is telling us that count is not a number, but no error occurs. Well, that is surprising. It seems like we are adding 1 to 0 three times. in reality, we add 1 to undefined, because the assignment to 0 doesn't happen until after the rest of our code executes!"
      },
      "date": 1431367607141
    },
    {
      "item": {
        "type": "factory",
        "id": "67ca93c26d871859"
      },
      "id": "67ca93c26d871859",
      "type": "add",
      "after": "fa6b82e73852a691",
      "date": 1431367683041
    },
    {
      "type": "edit",
      "id": "67ca93c26d871859",
      "item": {
        "type": "paragraph",
        "id": "67ca93c26d871859",
        "text": "// WARNING: Hoisting bug.\nincrement()\nincrement()\nincrement()\nlog() // NaN\n\n// UTILITY CODE BELOW\n\nvar count = 0\n\nlog() // 0\n\nfunction increment () {\n  count += 1\n}\n\nfunction log () {\n  console.log(count)\n}"
      },
      "date": 1431367688984
    },
    {
      "type": "remove",
      "id": "67ca93c26d871859",
      "date": 1431367698746
    },
    {
      "item": {
        "type": "factory",
        "id": "1c40d09de09891bb"
      },
      "id": "1c40d09de09891bb",
      "type": "add",
      "after": "fa6b82e73852a691",
      "date": 1431367700072
    },
    {
      "type": "edit",
      "id": "1c40d09de09891bb",
      "item": {
        "type": "code",
        "id": "1c40d09de09891bb",
        "text": "// WARNING: Hoisting bug.\nincrement()\nincrement()\nincrement()\nlog() // NaN\n\n// UTILITY CODE BELOW\n\nvar count = 0\n\nlog() // 0\n\nfunction increment () {\n  count += 1\n}\n\nfunction log () {\n  console.log(count)\n}"
      },
      "date": 1431367704849
    },
    {
      "item": {
        "type": "factory",
        "id": "5d049de7681000d4"
      },
      "id": "5d049de7681000d4",
      "type": "add",
      "after": "1c40d09de09891bb",
      "date": 1431367794785
    },
    {
      "type": "edit",
      "id": "5d049de7681000d4",
      "item": {
        "type": "paragraph",
        "id": "5d049de7681000d4",
        "text": "Pretty clear when you look at it that way, but damn can it be a subtle one to find sometimes. Especially when you're switching back and forth between asynchronous and synchronous calls of these functions."
      },
      "date": 1431367887848
    },
    {
      "item": {
        "type": "factory",
        "id": "501056076603b361"
      },
      "id": "501056076603b361",
      "type": "add",
      "after": "5d049de7681000d4",
      "date": 1431368002607
    },
    {
      "type": "remove",
      "id": "501056076603b361",
      "date": 1431368010614
    },
    {
      "item": {
        "type": "factory",
        "id": "d61a235777a781ef"
      },
      "id": "d61a235777a781ef",
      "type": "add",
      "after": "5d049de7681000d4",
      "date": 1431368014065
    },
    {
      "type": "edit",
      "id": "d61a235777a781ef",
      "item": {
        "type": "code",
        "id": "d61a235777a781ef",
        "text": "setTimeout(function () {\n  increment()\n  increment()\n  increment()\n  log() // 3\n}, 0)\n\n// UTILITY CODE BELOW\n\nvar count = 0\nfunction increment () {\n  count += 1\n}\n\nfunction log () {\n  console.log(count)\n}"
      },
      "date": 1431368018052
    },
    {
      "item": {
        "type": "factory",
        "id": "5794ec7b14a6fb0e"
      },
      "id": "5794ec7b14a6fb0e",
      "type": "add",
      "after": "d61a235777a781ef",
      "date": 1431368041550
    },
    {
      "type": "edit",
      "id": "5794ec7b14a6fb0e",
      "item": {
        "type": "paragraph",
        "id": "5794ec7b14a6fb0e",
        "text": "So, despite some negative points for code organization, declare and initialize variables at the top of your scope. It will save you some pain down the road in ways that you might not even notice."
      },
      "date": 1431368099746
    },
    {
      "item": {
        "type": "factory",
        "id": "a3681b901b882281"
      },
      "id": "a3681b901b882281",
      "type": "add",
      "after": "5794ec7b14a6fb0e",
      "date": 1431368195772
    },
    {
      "type": "edit",
      "id": "a3681b901b882281",
      "item": {
        "type": "code",
        "id": "a3681b901b882281",
        "text": "// It may not be clear why this\n// variable is here, but it's\n// worth needing to look for it.\nvar count = 0\n\nincrement()\nincrement()\nincrement()\nlog() // 3\n\n// UTILITY CODE BELOW\n\nfunction increment () {\n  count += 1\n}\n\nfunction log () {\n  console.log(count)\n}"
      },
      "date": 1431368201175
    },
    {
      "type": "fork",
      "site": "nrn.io",
      "date": 1652868397744
    }
  ]
}