{
  "title": "Re Factor",
  "story": [
    {
      "type": "html",
      "text": "I've run across this word a bunch of times and I sort of have a feel for what it means (vaguely) but ...",
      "id": "e301f4a9319a9f28edb9e1d552615377"
    },
    {
      "type": "html",
      "text": "\nAnybody care to define [[What Is Refactoring]]?",
      "id": "3b9445617cba709c5f56ec7d70af9063"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "\nRefactor means to alter factors which produce desired outcomes. A source code is composed of factors. One can change the factors while maintaining integrity. Factors also come across in math where, for example, you can factor 6432 into 32 * 3 * 67. You can refactor into 8 * 12 * 67 and you will have the same product but different factors. The rationale for wanting different factors varies.",
      "id": "12eb3afa519d53c939b763b12d077a21"
    },
    {
      "type": "html",
      "text": "-- PW",
      "id": "710611961d01048721d0848296e64f6a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "<i>In general, refactoring is modifying the code base to ensure that each thing is done [[Once And Only Once]]. If something is done multiple times, each of those times should be replaced by a call to the one routine that does the thing well and doesn't do anything else. If closely related things are done at places scattered throughout the code base, they should be pulled together into a single routine.</i>",
      "id": "2cd84611c31d541011eabc9d2b7619cc"
    },
    {
      "type": "html",
      "text": "-- [[William Grosso]]",
      "id": "adf4e4d772345bdf35442ebb8661ea25"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "\nI'll take a stab at it, but [[Ralph Johnson]] could probably provide a canonical definition. Refactoring is the process of taking an object design and rearranging it in various ways to make the design more flexible and/or reusable. There are several reasons you might want to do this, efficiency and maintainability being probably the most important.",
      "id": "4db20004384e93d030bbf08380e6493f"
    },
    {
      "type": "html",
      "text": "\nA common method of refactoring is to refactor along inheritance lines. For instance, let's suppose that in a design review you find out that two classes in your system that do not share a common superclass both implement very similar or identical behavior. It would be advantageous to then [[Re Factor]] these two classes by moving the common behavior into a shared superclass, and then changing the classes so that they descend from that class. You can also [[Re Factor]] by simply moving methods from concrete subclasses up the hierarchy to more abstract superclasses as you see the need.",
      "id": "92301cb8a0fc861b5b2b5e830442bf42"
    },
    {
      "type": "html",
      "text": "\nYou can also [[Re Factor]] along composition lines. If you find that a class is implementing two different sets of responsibilities that do not interact with each other much, or that use two subsets of the attributes of the original class, you may want to refactor that class into two different classes, one of which perhaps contains the other.",
      "id": "147bbada60342b7e7ffe17b3f64df3e7"
    },
    {
      "type": "html",
      "text": "\n[[Don Roberts]] and [[John Brant]] have been working on a tool for Smalltalk called the Refactory [[http://st-www.cs.uiuc.edu/users/brant/Refactory/RefactoringBrowser.html st-www.cs.uiuc.edu]] that makes this kind of thing easy. (Although it's already much easier to do in Smalltalk than in C++).",
      "id": "7fd49db061146f364b049a274cc50c69"
    },
    {
      "type": "html",
      "text": "-- [[Kyle Brown]]",
      "id": "caf3e3565d5de4a2f7a8ce61640c66f3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "Suppose you want to convert a class that uses case statements into one that uses the [[State Pattern]]. Or suppose you want to convert a class that hard codes the classes of its products into one that uses factory methods, and then you decide to pull those factory methods out into an abstract factory. These are all examples of refactoring a program.",
      "id": "3991c0605d325ac4d1ef09e535ae2170"
    },
    {
      "type": "html",
      "text": "\nA refactoring is a change to a program that only affects the way it is organized, not its behavior. Some people call them restructurings or \"behavior preserving transformations\". They are especially common when you are creating a framework, because a lot of reusability bugs can be fixed by refactoring your framework. -- [[Ralph Johnson]]",
      "id": "10a6627401e81354dc3aa23bf87438c9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "\nI like Ralph's definition. Two other kinds of refactoring are the cycle-breaking in [[Multiple Inheritance Is Not Evil]] and the business of building parameterized types as generics. -- [[Peter Merel]]",
      "id": "a347645ba503caee4d806c9fe1e1b57f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "See Also: [[Refactoring And Rewriting]] (which contrasts the two).",
      "id": "1e33f41674297d8f49b4b34bc2a63ec1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "I used to find \"refactoring\" a weird and awkward phrase, because to me it was a word borrowed and changed from algebra, and I never felt I was doing algebra when I was programming. In algebra, you \"factor\" (x^2 - y^2) into (x+y)*(x-y). You could think of \"refactoring\" as any permitted rearrangement in any direction. So you could refactor (x+y)*(x-y) back into the longer version. \nYou could turn 5*a + b*a into (5+b) * a, or vice versa (where \"*\" indicates multiplication).",
      "id": "4e4c1c66406e6c69a4596375c023ed39"
    },
    {
      "type": "html",
      "text": "\nSometime this year, it stopped being weird to me, and started to be natural. I started seeing 5*a + b*a as 3 operations on 6 things. (5+b)*a is 2 operations on 4 things. The 5+b thing is different from the 5*a things, etc. You can see the jump to OO programming.",
      "id": "1a3e1b5d1becb78b0a148ac3bf210145"
    },
    {
      "type": "html",
      "text": "Let's take the case of",
      "id": "7d03a240fe24c97e9f1925ab0cd591a5"
    },
    {
      "type": "html",
      "text": "<b>A.method1() = ... b.doThis(); b.doThat(); ...</b>",
      "id": "d765fb1b1b28a015798254a44ac67de0"
    },
    {
      "type": "html",
      "text": "\nI change the code to",
      "id": "bd37a7ba6e3b3672d77f76579cfe67ad"
    },
    {
      "type": "html",
      "text": "<b>B.doThisThat() = doThis(); doThat().</b>",
      "id": "8084c3d813614ac75aa8cd4e3e7b6f18"
    },
    {
      "type": "html",
      "text": "<b>A.method1() = ... b.doThisThat(); ...</b>",
      "id": "0f55a78a50fecf25c96535bc868ec6eb"
    },
    {
      "type": "html",
      "text": "\nThat change corresponds (in my mind, anyway) exactly to the (5+b)*a refactoring. Nowadays, I see a method and a class as a set of parentheses, and when I move code out of one method or class to another, I visualize it just as moving symbols from one set of parentheses to another. Of course, the net effect of the computation has to be the same, or as Ralph said, it has to be a behavior preserving transformation.",
      "id": "7bd32ce1bb7d72c6da8914263b93d846"
    },
    {
      "type": "html",
      "text": "-- [[Alistair Cockburn]]",
      "id": "5133562f3b1118b0c3b33c9b8c38764a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "The definition above does an excellent job of explaining WHAT it means to refactor, but it doesn't explain WHY. If it ain't broke, don't fix it. And if a refactoring truly preserves the semantics, it ain't gonna fix nothin no how anyway.",
      "id": "15f7d76fec50dec3f28c9d9f45c07914"
    },
    {
      "type": "html",
      "text": "\nYou want to refactor when the code is broken, but it isn't broken on the particular axis called \"what results the program computes\". Here are some of the defects I fix by refactoring:",
      "id": "2e4a77c0672b48e800d6b0a20e5da42c"
    },
    {
      "type": "html",
      "text": " Unify duplicate code",
      "id": "76a26196fe087868684218a07819e4ad"
    },
    {
      "type": "html",
      "text": " Make the code read better (typically introducing more \"why\")",
      "id": "a826cc3d7987ddb7fc444e72c0cf7acb"
    },
    {
      "type": "html",
      "text": " Remove unused indirection",
      "id": "84fa8bc0767efd1701feb6004fed8309"
    },
    {
      "type": "html",
      "text": " Isolate existing logic from a needed change",
      "id": "24c597f78766a663b2c0660b5a6e83d6"
    },
    {
      "type": "html",
      "text": " Replace one algorithm with another",
      "id": "52d17d1cc1f0fdde6d8bd61b642d0c2d"
    },
    {
      "type": "html",
      "text": " Make the program run faster",
      "id": "776a02d33fcbc7f10cc2cc8f29710d7f"
    },
    {
      "type": "html",
      "text": "-- [[Kent Beck]]",
      "id": "20d4c7bb0b1005d350693eb2a15e5744"
    },
    {
      "type": "html",
      "text": "<i>Respectfully beg to differ. Alistair gives a why. Remember those pictures you draw with the multiple lines from one class to another, being replaced by fewer? That's the same as Alistair's 5*a + b*a</i> ",
      "id": "3481ad616437ae2c16dbe0992316e4ac"
    },
    {
      "type": "html",
      "text": "<b>reducing</b> ",
      "id": "93b366ac02ecb757771c8965a88ce81b"
    },
    {
      "type": "html",
      "text": "<i>to (5+b)*a. In algebra, you get points for reducing the expression to what the professor thinks is most elegant/simple/whatever. In refactoring, you have to match [[Ward And Kent]]. -- [[Ron Jeffries]]</i>",
      "id": "18228fcd521bc947220c16f56d203c6c"
    },
    {
      "type": "html",
      "text": "\nBeg to differ on your differing. Respectfully, of course. Alistair doesn't give a \"why\" that a programmer under fire can remember. Refactoring is not just aimlessly moving code around between the infinite permutations of a program that behave identically. It is there to add qualities to the code that weren't there before. Reduced duplication, greater simplicity, easier reading, better performance - these are some of the qualities you can add through refactoring.",
      "id": "5f1bc2f3638c75acce4cfc1a7d32e22a"
    },
    {
      "type": "html",
      "text": "\nOf course, sometimes you take out one of these qualities to set up your next semantics changing transformation, and that's refactoring, too. -- [[Kent Beck]]",
      "id": "c3120529cf0a0bbafde85a88a409ce11"
    },
    {
      "type": "html",
      "text": "\nAs long as we are all begging and being respectful and differing, I'll begfully respect to differ. I think, with Kent, I didn't give a 'why' - I only tried to give a 'what'. Unlike Kent, I believe the description",
      "id": "a54694f498b3aa8a7806970a83eaa3d7"
    },
    {
      "type": "html",
      "text": "<i>\"aimlessly moving code around between the infinite permutations of a program that behave identically\"</i>\nwould have to be considered valid refactoring. Now we can get on to, Why Are We Doing This? I would ask back, why do I care to unify duplicate code? That is a What begging for a Why if ever I saw one. What a waste of time. There had better be something nagging me to cause me to go in and touch already working code. Find the what is nagging, and you'll find some why's. \"Things that are different in the code after you refactor a particular thing in a particular way\" will not count as Why. You need to have punishment, reward, emotion in the answer. Ron's [[Brownie Point Metric]] works as a sample - \"the professor gives a better grade if I aimlessly move this code around but end up with what s/he considers more glamorous.\" A more likely industrial version is, \"I'll do less work total when adding this function if I first refactor this code to remove duplicate code.\" or \"it works, but isn't fast enough, so I'll refactor this algorithm to get it faster.\" But now we are out of the opening question, What does this thing [[Re Factor]] mean?\" and into \"Why would I care to [[Refactor Mercilessly]]?\" -- [[Alistair Cockburn]]",
      "id": "7ecf6ef75451ef846e6ff8a559dc635a"
    },
    {
      "type": "html",
      "text": "<i>You've definitely given me a different respect for begging.</i>",
      "id": "4898187ccef7bcca16f756faa322940a"
    },
    {
      "type": "html",
      "text": "\nWe do all of these things... refactoring, do-the-simplest-thing, etc... so that the code can fit in our heads. Everything we do to improve the code ultimately boils down to that. -- [[Wayne Conrad]]",
      "id": "436748bfca471159072900b6ed73d122"
    },
    {
      "type": "html",
      "text": "<i>I think of refactoring as an effort to get the code towards [[Extreme Normal Form]]. Of course, [[Extreme Normal Form]] can be a little vague to get your head around, so we have intermediate principles of good code, such as: [[Once And Only Once]], [[Law Of Demeter]], [[Self Documenting Code]], and maybe [[Shield Pattern]], too.</i>",
      "id": "03c89037badfc07b3e97a020062b4353"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "Of the \"Fixed defects\" list, the only one which surprised me was \"Replace one algorithm with another\". I see refactoring as moving code around rather than writing new code, even if the new code has the same effect as the old code. -- [[Dave Harris]]",
      "id": "57811c4d3132f998758b6254fa946562"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "[[Martin Fowler]] has a very good intro to refactoring paper on his website [[http://www2.awl.com/cseng/titles/0-201-89542-0/refactor/index.html www2.awl.com]]. -- [[Michael Feathers]]",
      "id": "4da3891b57f0a55c6383aabeded2e7f1"
    },
    {
      "type": "html",
      "text": "(Not any more, the book's published and he removed the content)",
      "id": "74040c15aef8812c1f890bec4a187202"
    },
    {
      "type": "html",
      "text": "\nI've recently updated it to include my some work in progress from my book. I've listed a good number of refactorings with motivation and step by step mechanics. I'd appreciate comments. You can reach it from my homepage --[[Martin Fowler]]",
      "id": "309f997ca31f424695c9487d6022b7cb"
    },
    {
      "type": "html",
      "text": "\nThe place to go now for Martin's info on refactoring is (surprise) [http://www.refactoring.com/ www.refactoring.com]",
      "id": "1708f5b36cdedf47c8a410f1fb2ed364"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "One thing that I've been wondering. It seems that many refactorings I've heard of involve taking one big thing and splitting it into several smaller things, or taking methods and moving them from one class to another. It seems that the tendency is to make things simpler where simple means that the number of classes may increase, but the number of methods on each class decreases. I know that there are refactorings where the opposite is true, but the seem less common. Doesn't it seem that there is a \"direction\" in many refactorings? Like entropy?",
      "id": "aa3d6e8b296e54a55d5e9361cdb00262"
    },
    {
      "type": "html",
      "text": "<i>Here's my way of thinking about it. Without refactoring, software gains entropy over time. Ongoing refactoring reduces the added entropy, so the code remains clear, elegant, and maintainable as it evolves.</i>",
      "id": "0a5ba92bb42a2659d97eabbfe05008ad"
    },
    {
      "type": "html",
      "text": "\nI have this weird vision of OO systems having energy states. Imagine a grid where each (x,y) point is a class and the z-value is the number of methods on the class, or the number of statements per method. Would we expect well-factored systems to have less average height and a smoother terrain? I have this feeling that under some conception there are refactorings that make a graph \"hug the ground.\" --[[Michael Feathers]]",
      "id": "dba7aafcbd7c78e4cfa03c4c0bf7e95b"
    },
    {
      "type": "html",
      "text": "\nI like this analogy, though like you I'm not sure I believe it. At least not always.",
      "id": "a62708baac79406ac2b9198461c3ec33"
    },
    {
      "type": "html",
      "text": "\nSee [[Refactoring Adding Complexity]]. -- [[Ron Jeffries]]",
      "id": "86f4574d8809b0951195b8b249d88a34"
    },
    {
      "type": "html",
      "text": "\nVery interesting energy theory, think of it as compression - You have this code A here and this almost the same code B here stored at separate places in a tree structure. Since they share a lot of common things they can simply be moved around in the tree structure (your main program is just links to code A and B, these links change accordingly) and be replaced with branch C which have small leafs called a and b (your main program would have links to C, leaf a and leaf b now). We have now lowered the energy needed to transmit the whole tree over some kind of link since it occupies less space in total (we do not need to transmit as much bytes). Still the real valuable energy in the tree is preserved. Repeat this procedure until nothing more can be compressed. You end up with everything being random noise, which is pure energy and also the smallest (simplest?) possible representation of your program. -- [[Anders Hedberg]]",
      "id": "c64b04b6ad974f7e43b608e7023d0bee"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "To provide the discussion with a 'why', one reason to refactor is <i>time</i>. I was once on a project where we had about twenty components. Each of them had lots of duplicate code. We had a urge to reduce it to save us the time and it took to make a change and duplicate and test the tedious effort across all twenty components.",
      "id": "4f1d62613377bf1ac79394de89a81a0f"
    },
    {
      "type": "html",
      "text": "\nWe refactored it to the best of our ability, but some of it was un-refactorable - in the context of consolidating duplicate code into a single maintainable base - for purely technical reasons. Every developer who came on board seemed to have the urge to refactor it more. At one point we just created a white paper that described why we made the refactoring decisions we made, and handed it to them when they got that 'look'.",
      "id": "72d5d46d8d79ec64cad465b036b225d7"
    },
    {
      "type": "html",
      "text": "\nIn this case, our 'why' had partly to do with elegance, and mostly to do with saving precious time. -- [[Philip Eskelin]]",
      "id": "9c68892814b89d859591d47b8ffe7461"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "\n[[Martin Fowler]]'s book on the topic ([[Refactoring Improving The Design Of Existing Code]]) has been published. I just bought a copy yesterday (6/15/99) at [[Java One]]. It looks terrific. -- [[Glenn Vanderburg]]",
      "id": "3016294cb3422c932108013f86bc0914"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "\nHere's an (amusing) example of why it's important to refactor when changing or extending class hierarchies to ensure that responsibilities are implemented [[Once And Only Once]] in the appropriate part of the class hierarchy:",
      "id": "b6396c73a993e0b538c1f1daa8a43b83"
    },
    {
      "type": "html",
      "text": "<i>[Nat's original link seems to have died, so the link isn't his.]</i>\n[http://www.snopes.com/humor/nonsense/kangaroo.htm www.snopes.com] -- [[Nat Pryce]]",
      "id": "9ee761b9fbe5871c1420e884f549c0df"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "\nI think that one of the better justifications for refactoring comes from Complexity Science. By refactoring we effectively control chaos, which otherwise sooner or later eats up the system. Refactoring, just like Design 'Patterns' introduces symmetries and brevity - humans' main tool for dealing with complexity. -- Alex Iskold",
      "id": "f77d14a355c33a4798783f4cff82e22e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "To complement - not contradict - the above discussion, we also refactor to retain the intelligibility of our designs, so that we can continue to develop them as required. A design which is no longer intelligible is no longer viable - the only options are refactoring, redesign or a freeze on all future development, as appropriate. -- [[Steve Merrick]]",
      "id": "d3a5ff8d075960f5684be25fe177e98b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "\nAn explanation that has stuck with me since my first conversation with a good friend about [[Extreme Programming]] was this: When you find that you have code that you need to change, and it is hard to do it, there is a large 'Vector of Change'. By refactoring (and using [[Unit Test]]s to make sure that the refactored code is equivalent), you can reduce the vector of change to the point where implementing the change is trivial.",
      "id": "cd21214eba8e08bbb178b0b7469b922f"
    },
    {
      "type": "html",
      "text": "\nThis is similar to the above energy state metaphor, but introduces something that isn't made clear (but could be implied from) the energy metaphor : When you refactor code to facilitate implementing a change, you make it easier to make a similar change in the future.",
      "id": "686aeaf6222f94c42f27417f89e666b6"
    },
    {
      "type": "html",
      "text": "\nWhat follows from this is an assumption that when you are maintaining the code in the future, changes that are requested/needed will be easy to make, because similar changes have been made in the past, and the code was suitably refactored. -- [[Stephen Thorne]]",
      "id": "a9d5bae0064650114ef7bbf2b4b90e62"
    },
    {
      "type": "html",
      "text": "\nWhy?",
      "id": "2e05868a20ba18e49f30fcba23d9fd39"
    },
    {
      "type": "html",
      "text": " Learning is for me the far most important \"why to refactor\", rewriting chunks of code will give better insights into the system. Information streams from the fingers to the brain.",
      "id": "bc42cd359b7f92801ce02b9867233596"
    },
    {
      "type": "html",
      "text": " Before writing any actual code nothing really matters, so you got to bootstrap yourself. While your building on the original foundation you realize that it isn't suitable anymore so you refactor.",
      "id": "074d4fdccee36e164e736c9d489d2bbd"
    },
    {
      "type": "html",
      "text": " Refactoring is bit like backtracking, for life on this planet that's the only way to get somewhere.",
      "id": "2ff49bcd0fe03ea6d388513bee1fba20"
    },
    {
      "type": "html",
      "text": "-- Phililp Van Bogaert",
      "id": "57d8378a9d7fc9b5b0db3c1520e4da3d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "If a program is the product of its factors (components), and you want to change that product, it's easier to understand and change one of the factors than to change everything at once. When that's not feasible, refactoring may make it feasible. -- Marty White",
      "id": "9a8de7132523c4f5998b10e3f8c97921"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "See Also: [[When To Stop Refactoring]], [[Slow Down To Speed Up]], [[Amazing Refactoring Challenge]], [[What Is Refactoring]], [[History Of Refactoring]], [[What Isa Factor]], [[How To Refactor]]",
      "id": "91de540a71121dc44da70bbb77933c56"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "2ca94ed579fd02d7113a621a5603c026"
    },
    {
      "type": "html",
      "text": "[[Category Refactoring]]",
      "id": "3c485d4525364e8a492d8d7bac019b62"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ReFactor c2.com]",
      "id": "910e446450d7f861d6e931d222b48c20"
    }
  ],
  "journal": [
    {
      "date": 1346139524000,
      "id": "72d0fccf4f72d254bc5010ffddc2badc",
      "type": "create",
      "item": {
        "title": "Re Factor",
        "story": [
          {
            "type": "html",
            "text": "I've run across this word a bunch of times and I sort of have a feel for what it means (vaguely) but ...",
            "id": "e301f4a9319a9f28edb9e1d552615377"
          },
          {
            "type": "html",
            "text": "\nAnybody care to define [[What Is Refactoring]]?",
            "id": "3b9445617cba709c5f56ec7d70af9063"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "\nRefactor means to alter factors which produce desired outcomes. A source code is composed of factors. One can change the factors while maintaining integrity. Factors also come across in math where, for example, you can factor 6432 into 32 * 3 * 67. You can refactor into 8 * 12 * 67 and you will have the same product but different factors. The rationale for wanting different factors varies.",
            "id": "12eb3afa519d53c939b763b12d077a21"
          },
          {
            "type": "html",
            "text": "-- PW",
            "id": "710611961d01048721d0848296e64f6a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "<i>In general, refactoring is modifying the code base to ensure that each thing is done [[Once And Only Once]]. If something is done multiple times, each of those times should be replaced by a call to the one routine that does the thing well and doesn't do anything else. If closely related things are done at places scattered throughout the code base, they should be pulled together into a single routine.</i>",
            "id": "2cd84611c31d541011eabc9d2b7619cc"
          },
          {
            "type": "html",
            "text": "-- [[William Grosso]]",
            "id": "adf4e4d772345bdf35442ebb8661ea25"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "\nI'll take a stab at it, but [[Ralph Johnson]] could probably provide a canonical definition. Refactoring is the process of taking an object design and rearranging it in various ways to make the design more flexible and/or reusable. There are several reasons you might want to do this, efficiency and maintainability being probably the most important.",
            "id": "4db20004384e93d030bbf08380e6493f"
          },
          {
            "type": "html",
            "text": "\nA common method of refactoring is to refactor along inheritance lines. For instance, let's suppose that in a design review you find out that two classes in your system that do not share a common superclass both implement very similar or identical behavior. It would be advantageous to then [[Re Factor]] these two classes by moving the common behavior into a shared superclass, and then changing the classes so that they descend from that class. You can also [[Re Factor]] by simply moving methods from concrete subclasses up the hierarchy to more abstract superclasses as you see the need.",
            "id": "92301cb8a0fc861b5b2b5e830442bf42"
          },
          {
            "type": "html",
            "text": "\nYou can also [[Re Factor]] along composition lines. If you find that a class is implementing two different sets of responsibilities that do not interact with each other much, or that use two subsets of the attributes of the original class, you may want to refactor that class into two different classes, one of which perhaps contains the other.",
            "id": "147bbada60342b7e7ffe17b3f64df3e7"
          },
          {
            "type": "html",
            "text": "\n[[Don Roberts]] and [[John Brant]] have been working on a tool for Smalltalk called the Refactory [[http://st-www.cs.uiuc.edu/users/brant/Refactory/RefactoringBrowser.html st-www.cs.uiuc.edu]] that makes this kind of thing easy. (Although it's already much easier to do in Smalltalk than in C++).",
            "id": "7fd49db061146f364b049a274cc50c69"
          },
          {
            "type": "html",
            "text": "-- [[Kyle Brown]]",
            "id": "caf3e3565d5de4a2f7a8ce61640c66f3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "Suppose you want to convert a class that uses case statements into one that uses the [[State Pattern]]. Or suppose you want to convert a class that hard codes the classes of its products into one that uses factory methods, and then you decide to pull those factory methods out into an abstract factory. These are all examples of refactoring a program.",
            "id": "3991c0605d325ac4d1ef09e535ae2170"
          },
          {
            "type": "html",
            "text": "\nA refactoring is a change to a program that only affects the way it is organized, not its behavior. Some people call them restructurings or \"behavior preserving transformations\". They are especially common when you are creating a framework, because a lot of reusability bugs can be fixed by refactoring your framework. -- [[Ralph Johnson]]",
            "id": "10a6627401e81354dc3aa23bf87438c9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "\nI like Ralph's definition. Two other kinds of refactoring are the cycle-breaking in [[Multiple Inheritance Is Not Evil]] and the business of building parameterized types as generics. -- [[Peter Merel]]",
            "id": "a347645ba503caee4d806c9fe1e1b57f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "See Also: [[Refactoring And Rewriting]] (which contrasts the two).",
            "id": "1e33f41674297d8f49b4b34bc2a63ec1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "I used to find \"refactoring\" a weird and awkward phrase, because to me it was a word borrowed and changed from algebra, and I never felt I was doing algebra when I was programming. In algebra, you \"factor\" (x^2 - y^2) into (x+y)*(x-y). You could think of \"refactoring\" as any permitted rearrangement in any direction. So you could refactor (x+y)*(x-y) back into the longer version. \nYou could turn 5*a + b*a into (5+b) * a, or vice versa (where \"*\" indicates multiplication).",
            "id": "4e4c1c66406e6c69a4596375c023ed39"
          },
          {
            "type": "html",
            "text": "\nSometime this year, it stopped being weird to me, and started to be natural. I started seeing 5*a + b*a as 3 operations on 6 things. (5+b)*a is 2 operations on 4 things. The 5+b thing is different from the 5*a things, etc. You can see the jump to OO programming.",
            "id": "1a3e1b5d1becb78b0a148ac3bf210145"
          },
          {
            "type": "html",
            "text": "Let's take the case of",
            "id": "7d03a240fe24c97e9f1925ab0cd591a5"
          },
          {
            "type": "html",
            "text": "<b>A.method1() = ... b.doThis(); b.doThat(); ...</b>",
            "id": "d765fb1b1b28a015798254a44ac67de0"
          },
          {
            "type": "html",
            "text": "\nI change the code to",
            "id": "bd37a7ba6e3b3672d77f76579cfe67ad"
          },
          {
            "type": "html",
            "text": "<b>B.doThisThat() = doThis(); doThat().</b>",
            "id": "8084c3d813614ac75aa8cd4e3e7b6f18"
          },
          {
            "type": "html",
            "text": "<b>A.method1() = ... b.doThisThat(); ...</b>",
            "id": "0f55a78a50fecf25c96535bc868ec6eb"
          },
          {
            "type": "html",
            "text": "\nThat change corresponds (in my mind, anyway) exactly to the (5+b)*a refactoring. Nowadays, I see a method and a class as a set of parentheses, and when I move code out of one method or class to another, I visualize it just as moving symbols from one set of parentheses to another. Of course, the net effect of the computation has to be the same, or as Ralph said, it has to be a behavior preserving transformation.",
            "id": "7bd32ce1bb7d72c6da8914263b93d846"
          },
          {
            "type": "html",
            "text": "-- [[Alistair Cockburn]]",
            "id": "5133562f3b1118b0c3b33c9b8c38764a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "The definition above does an excellent job of explaining WHAT it means to refactor, but it doesn't explain WHY. If it ain't broke, don't fix it. And if a refactoring truly preserves the semantics, it ain't gonna fix nothin no how anyway.",
            "id": "15f7d76fec50dec3f28c9d9f45c07914"
          },
          {
            "type": "html",
            "text": "\nYou want to refactor when the code is broken, but it isn't broken on the particular axis called \"what results the program computes\". Here are some of the defects I fix by refactoring:",
            "id": "2e4a77c0672b48e800d6b0a20e5da42c"
          },
          {
            "type": "html",
            "text": " Unify duplicate code",
            "id": "76a26196fe087868684218a07819e4ad"
          },
          {
            "type": "html",
            "text": " Make the code read better (typically introducing more \"why\")",
            "id": "a826cc3d7987ddb7fc444e72c0cf7acb"
          },
          {
            "type": "html",
            "text": " Remove unused indirection",
            "id": "84fa8bc0767efd1701feb6004fed8309"
          },
          {
            "type": "html",
            "text": " Isolate existing logic from a needed change",
            "id": "24c597f78766a663b2c0660b5a6e83d6"
          },
          {
            "type": "html",
            "text": " Replace one algorithm with another",
            "id": "52d17d1cc1f0fdde6d8bd61b642d0c2d"
          },
          {
            "type": "html",
            "text": " Make the program run faster",
            "id": "776a02d33fcbc7f10cc2cc8f29710d7f"
          },
          {
            "type": "html",
            "text": "-- [[Kent Beck]]",
            "id": "20d4c7bb0b1005d350693eb2a15e5744"
          },
          {
            "type": "html",
            "text": "<i>Respectfully beg to differ. Alistair gives a why. Remember those pictures you draw with the multiple lines from one class to another, being replaced by fewer? That's the same as Alistair's 5*a + b*a</i> ",
            "id": "3481ad616437ae2c16dbe0992316e4ac"
          },
          {
            "type": "html",
            "text": "<b>reducing</b> ",
            "id": "93b366ac02ecb757771c8965a88ce81b"
          },
          {
            "type": "html",
            "text": "<i>to (5+b)*a. In algebra, you get points for reducing the expression to what the professor thinks is most elegant/simple/whatever. In refactoring, you have to match [[Ward And Kent]]. -- [[Ron Jeffries]]</i>",
            "id": "18228fcd521bc947220c16f56d203c6c"
          },
          {
            "type": "html",
            "text": "\nBeg to differ on your differing. Respectfully, of course. Alistair doesn't give a \"why\" that a programmer under fire can remember. Refactoring is not just aimlessly moving code around between the infinite permutations of a program that behave identically. It is there to add qualities to the code that weren't there before. Reduced duplication, greater simplicity, easier reading, better performance - these are some of the qualities you can add through refactoring.",
            "id": "5f1bc2f3638c75acce4cfc1a7d32e22a"
          },
          {
            "type": "html",
            "text": "\nOf course, sometimes you take out one of these qualities to set up your next semantics changing transformation, and that's refactoring, too. -- [[Kent Beck]]",
            "id": "c3120529cf0a0bbafde85a88a409ce11"
          },
          {
            "type": "html",
            "text": "\nAs long as we are all begging and being respectful and differing, I'll begfully respect to differ. I think, with Kent, I didn't give a 'why' - I only tried to give a 'what'. Unlike Kent, I believe the description",
            "id": "a54694f498b3aa8a7806970a83eaa3d7"
          },
          {
            "type": "html",
            "text": "<i>\"aimlessly moving code around between the infinite permutations of a program that behave identically\"</i>\nwould have to be considered valid refactoring. Now we can get on to, Why Are We Doing This? I would ask back, why do I care to unify duplicate code? That is a What begging for a Why if ever I saw one. What a waste of time. There had better be something nagging me to cause me to go in and touch already working code. Find the what is nagging, and you'll find some why's. \"Things that are different in the code after you refactor a particular thing in a particular way\" will not count as Why. You need to have punishment, reward, emotion in the answer. Ron's [[Brownie Point Metric]] works as a sample - \"the professor gives a better grade if I aimlessly move this code around but end up with what s/he considers more glamorous.\" A more likely industrial version is, \"I'll do less work total when adding this function if I first refactor this code to remove duplicate code.\" or \"it works, but isn't fast enough, so I'll refactor this algorithm to get it faster.\" But now we are out of the opening question, What does this thing [[Re Factor]] mean?\" and into \"Why would I care to [[Refactor Mercilessly]]?\" -- [[Alistair Cockburn]]",
            "id": "7ecf6ef75451ef846e6ff8a559dc635a"
          },
          {
            "type": "html",
            "text": "<i>You've definitely given me a different respect for begging.</i>",
            "id": "4898187ccef7bcca16f756faa322940a"
          },
          {
            "type": "html",
            "text": "\nWe do all of these things... refactoring, do-the-simplest-thing, etc... so that the code can fit in our heads. Everything we do to improve the code ultimately boils down to that. -- [[Wayne Conrad]]",
            "id": "436748bfca471159072900b6ed73d122"
          },
          {
            "type": "html",
            "text": "<i>I think of refactoring as an effort to get the code towards [[Extreme Normal Form]]. Of course, [[Extreme Normal Form]] can be a little vague to get your head around, so we have intermediate principles of good code, such as: [[Once And Only Once]], [[Law Of Demeter]], [[Self Documenting Code]], and maybe [[Shield Pattern]], too.</i>",
            "id": "03c89037badfc07b3e97a020062b4353"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "Of the \"Fixed defects\" list, the only one which surprised me was \"Replace one algorithm with another\". I see refactoring as moving code around rather than writing new code, even if the new code has the same effect as the old code. -- [[Dave Harris]]",
            "id": "57811c4d3132f998758b6254fa946562"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "[[Martin Fowler]] has a very good intro to refactoring paper on his website [[http://www2.awl.com/cseng/titles/0-201-89542-0/refactor/index.html www2.awl.com]]. -- [[Michael Feathers]]",
            "id": "4da3891b57f0a55c6383aabeded2e7f1"
          },
          {
            "type": "html",
            "text": "(Not any more, the book's published and he removed the content)",
            "id": "74040c15aef8812c1f890bec4a187202"
          },
          {
            "type": "html",
            "text": "\nI've recently updated it to include my some work in progress from my book. I've listed a good number of refactorings with motivation and step by step mechanics. I'd appreciate comments. You can reach it from my homepage --[[Martin Fowler]]",
            "id": "309f997ca31f424695c9487d6022b7cb"
          },
          {
            "type": "html",
            "text": "\nThe place to go now for Martin's info on refactoring is (surprise) [http://www.refactoring.com/ www.refactoring.com]",
            "id": "1708f5b36cdedf47c8a410f1fb2ed364"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "One thing that I've been wondering. It seems that many refactorings I've heard of involve taking one big thing and splitting it into several smaller things, or taking methods and moving them from one class to another. It seems that the tendency is to make things simpler where simple means that the number of classes may increase, but the number of methods on each class decreases. I know that there are refactorings where the opposite is true, but the seem less common. Doesn't it seem that there is a \"direction\" in many refactorings? Like entropy?",
            "id": "aa3d6e8b296e54a55d5e9361cdb00262"
          },
          {
            "type": "html",
            "text": "<i>Here's my way of thinking about it. Without refactoring, software gains entropy over time. Ongoing refactoring reduces the added entropy, so the code remains clear, elegant, and maintainable as it evolves.</i>",
            "id": "0a5ba92bb42a2659d97eabbfe05008ad"
          },
          {
            "type": "html",
            "text": "\nI have this weird vision of OO systems having energy states. Imagine a grid where each (x,y) point is a class and the z-value is the number of methods on the class, or the number of statements per method. Would we expect well-factored systems to have less average height and a smoother terrain? I have this feeling that under some conception there are refactorings that make a graph \"hug the ground.\" --[[Michael Feathers]]",
            "id": "dba7aafcbd7c78e4cfa03c4c0bf7e95b"
          },
          {
            "type": "html",
            "text": "\nI like this analogy, though like you I'm not sure I believe it. At least not always.",
            "id": "a62708baac79406ac2b9198461c3ec33"
          },
          {
            "type": "html",
            "text": "\nSee [[Refactoring Adding Complexity]]. -- [[Ron Jeffries]]",
            "id": "86f4574d8809b0951195b8b249d88a34"
          },
          {
            "type": "html",
            "text": "\nVery interesting energy theory, think of it as compression - You have this code A here and this almost the same code B here stored at separate places in a tree structure. Since they share a lot of common things they can simply be moved around in the tree structure (your main program is just links to code A and B, these links change accordingly) and be replaced with branch C which have small leafs called a and b (your main program would have links to C, leaf a and leaf b now). We have now lowered the energy needed to transmit the whole tree over some kind of link since it occupies less space in total (we do not need to transmit as much bytes). Still the real valuable energy in the tree is preserved. Repeat this procedure until nothing more can be compressed. You end up with everything being random noise, which is pure energy and also the smallest (simplest?) possible representation of your program. -- [[Anders Hedberg]]",
            "id": "c64b04b6ad974f7e43b608e7023d0bee"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "To provide the discussion with a 'why', one reason to refactor is <i>time</i>. I was once on a project where we had about twenty components. Each of them had lots of duplicate code. We had a urge to reduce it to save us the time and it took to make a change and duplicate and test the tedious effort across all twenty components.",
            "id": "4f1d62613377bf1ac79394de89a81a0f"
          },
          {
            "type": "html",
            "text": "\nWe refactored it to the best of our ability, but some of it was un-refactorable - in the context of consolidating duplicate code into a single maintainable base - for purely technical reasons. Every developer who came on board seemed to have the urge to refactor it more. At one point we just created a white paper that described why we made the refactoring decisions we made, and handed it to them when they got that 'look'.",
            "id": "72d5d46d8d79ec64cad465b036b225d7"
          },
          {
            "type": "html",
            "text": "\nIn this case, our 'why' had partly to do with elegance, and mostly to do with saving precious time. -- [[Philip Eskelin]]",
            "id": "9c68892814b89d859591d47b8ffe7461"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "\n[[Martin Fowler]]'s book on the topic ([[Refactoring Improving The Design Of Existing Code]]) has been published. I just bought a copy yesterday (6/15/99) at [[Java One]]. It looks terrific. -- [[Glenn Vanderburg]]",
            "id": "3016294cb3422c932108013f86bc0914"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "\nHere's an (amusing) example of why it's important to refactor when changing or extending class hierarchies to ensure that responsibilities are implemented [[Once And Only Once]] in the appropriate part of the class hierarchy:",
            "id": "b6396c73a993e0b538c1f1daa8a43b83"
          },
          {
            "type": "html",
            "text": "<i>[Nat's original link seems to have died, so the link isn't his.]</i>\n[http://www.snopes.com/humor/nonsense/kangaroo.htm www.snopes.com] -- [[Nat Pryce]]",
            "id": "9ee761b9fbe5871c1420e884f549c0df"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "\nI think that one of the better justifications for refactoring comes from Complexity Science. By refactoring we effectively control chaos, which otherwise sooner or later eats up the system. Refactoring, just like Design 'Patterns' introduces symmetries and brevity - humans' main tool for dealing with complexity. -- Alex Iskold",
            "id": "f77d14a355c33a4798783f4cff82e22e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "To complement - not contradict - the above discussion, we also refactor to retain the intelligibility of our designs, so that we can continue to develop them as required. A design which is no longer intelligible is no longer viable - the only options are refactoring, redesign or a freeze on all future development, as appropriate. -- [[Steve Merrick]]",
            "id": "d3a5ff8d075960f5684be25fe177e98b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "\nAn explanation that has stuck with me since my first conversation with a good friend about [[Extreme Programming]] was this: When you find that you have code that you need to change, and it is hard to do it, there is a large 'Vector of Change'. By refactoring (and using [[Unit Test]]s to make sure that the refactored code is equivalent), you can reduce the vector of change to the point where implementing the change is trivial.",
            "id": "cd21214eba8e08bbb178b0b7469b922f"
          },
          {
            "type": "html",
            "text": "\nThis is similar to the above energy state metaphor, but introduces something that isn't made clear (but could be implied from) the energy metaphor : When you refactor code to facilitate implementing a change, you make it easier to make a similar change in the future.",
            "id": "686aeaf6222f94c42f27417f89e666b6"
          },
          {
            "type": "html",
            "text": "\nWhat follows from this is an assumption that when you are maintaining the code in the future, changes that are requested/needed will be easy to make, because similar changes have been made in the past, and the code was suitably refactored. -- [[Stephen Thorne]]",
            "id": "a9d5bae0064650114ef7bbf2b4b90e62"
          },
          {
            "type": "html",
            "text": "\nWhy?",
            "id": "2e05868a20ba18e49f30fcba23d9fd39"
          },
          {
            "type": "html",
            "text": " Learning is for me the far most important \"why to refactor\", rewriting chunks of code will give better insights into the system. Information streams from the fingers to the brain.",
            "id": "bc42cd359b7f92801ce02b9867233596"
          },
          {
            "type": "html",
            "text": " Before writing any actual code nothing really matters, so you got to bootstrap yourself. While your building on the original foundation you realize that it isn't suitable anymore so you refactor.",
            "id": "074d4fdccee36e164e736c9d489d2bbd"
          },
          {
            "type": "html",
            "text": " Refactoring is bit like backtracking, for life on this planet that's the only way to get somewhere.",
            "id": "2ff49bcd0fe03ea6d388513bee1fba20"
          },
          {
            "type": "html",
            "text": "-- Phililp Van Bogaert",
            "id": "57d8378a9d7fc9b5b0db3c1520e4da3d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "If a program is the product of its factors (components), and you want to change that product, it's easier to understand and change one of the factors than to change everything at once. When that's not feasible, refactoring may make it feasible. -- Marty White",
            "id": "9a8de7132523c4f5998b10e3f8c97921"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "See Also: [[When To Stop Refactoring]], [[Slow Down To Speed Up]], [[Amazing Refactoring Challenge]], [[What Is Refactoring]], [[History Of Refactoring]], [[What Isa Factor]], [[How To Refactor]]",
            "id": "91de540a71121dc44da70bbb77933c56"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "2ca94ed579fd02d7113a621a5603c026"
          },
          {
            "type": "html",
            "text": "[[Category Refactoring]]",
            "id": "3c485d4525364e8a492d8d7bac019b62"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ReFactor c2.com]",
            "id": "910e446450d7f861d6e931d222b48c20"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1628088191342
    }
  ]
}