{
  "title": "Double Dispatch",
  "story": [
    {
      "type": "html",
      "text": "Say you have three kinds of figures that you want to print on four kinds of printers. The message",
      "id": "53dbf3a641b81c356d920b06b4d44c2c"
    },
    {
      "type": "html",
      "text": "circleFigure printOn:<br>laserPrinter",
      "id": "c6d2a303477124465a27ce12b2c0fc77"
    },
    {
      "type": "html",
      "text": "must dispatch on both the Figure and Printer hierarchies. One does this by defining methods like",
      "id": "52a361454fb9c642f7866bb9d9e1f70c"
    },
    {
      "type": "html",
      "text": "printOn:<br>aPrinter",
      "id": "131b7377b3ca9cee5a6901afc296d794"
    },
    {
      "type": "html",
      "text": "aPrinter printCircle:<br>self",
      "id": "bb0ef6225cbc5fe9cd0c469329e1e3e6"
    },
    {
      "type": "html",
      "text": "in the Figure hierarchy and methods like",
      "id": "2e22ef24a750a81189921792ca67c04a"
    },
    {
      "type": "html",
      "text": "printCircle:<br>aCircle",
      "id": "c5b25b042ca14b38cb345b7519036caf"
    },
    {
      "type": "code",
      "text": "    ... circle printing stuff ...",
      "id": "4a986b2405d807d3c5b9b84bfe2c5190"
    },
    {
      "type": "html",
      "text": "in the Printer hierarchy.",
      "id": "eb43e7bfd8951de03d6e3537512b1fb7"
    },
    {
      "type": "html",
      "text": "\nAn elaboration of the above example in Java is at [[Double Dispatch Example]].",
      "id": "baec682755e68c3ff4b246958431a891"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b7acc2549b7426aabb45c296e3880bdd"
    },
    {
      "type": "html",
      "text": "\nIsn't this what the [[Gang Of Four]] [[Visitor Pattern]] does? And [[Common Lisp]] has built into the language via its [[Generic Function]]s?",
      "id": "2aae5ff553ac910b0b30bd6d12fd4eb0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b7acc2549b7426aabb45c296e3880bdd"
    },
    {
      "type": "html",
      "text": "[[Dan Ingalls]] wrote this technique up for one of the early OOPSLAs. The program committee almost rejected the paper because the idea was considered obvious, or insufficiently scientific, or something like that.",
      "id": "d8956b3a973c1d46b13438efc74e08a3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b7acc2549b7426aabb45c296e3880bdd"
    },
    {
      "type": "html",
      "text": "It was one of my favorite OOPSLA papers, and it was because OOPSLA doesn't publish papers like that any more that I wanted to start a conference on patterns, where an idea will not be rejected just because it was in [[Ivan Sutherland]]'s PhD thesis.",
      "id": "f55ec4d69fff3e5e1acedd67e8aa3620"
    },
    {
      "type": "html",
      "text": "-- [[Ralph Johnson]]",
      "id": "62a86e8c79dbfeb0a32321843599b6d8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b7acc2549b7426aabb45c296e3880bdd"
    },
    {
      "type": "html",
      "text": "[[Boy This Stuff Makes Me Feel Stupid]] ... Would someone be willing to create a more verbose example? (hopefully in Java or C++) Perhaps it would make more sense (to me at least) if there were more code that a person could step through.",
      "id": "90018ba57aba2baaa73a6334b91bcbdc"
    },
    {
      "type": "html",
      "text": "<i>See [[Double Dispatch Example]]</i>",
      "id": "02b6a5656cfe4a9bbe07f99a9ae7db47"
    },
    {
      "type": "html",
      "text": "<i>See [http://forum.java.sun.com/read/16789542/q_tzLgu-LxJkAAagM forum.java.sun.com] ([[Broken Link]]) for a \"simple\" example of a case where [[Multiple Dispatch]] is the \"expected\" behaviour in Java, and why it is puzzling that such behaviour doesn't actually occur in Java.</i>",
      "id": "bcfef2e0a166eeeff9dfbe42a1a8194a"
    },
    {
      "type": "html",
      "text": "\nItem 31 in [[More Effective Cee Plus Plus]] is \"Making functions virtual with respect to more than one object\", i.e., [[Multiple Dispatch]]. Actually, he concentrates on double dispatch, and only waves his hands at dispatching on n > 2 objects. At 24 pages, it is one of the longest items in the book. Meyers discusses several alternative approaches to implementation, and the advantages and (mostly) disadvantages of each. He comes up with a workable way of doing it, while making you appreciate what the compiler does for you in single dispatch and making you wish you were using a language that did all this for you.",
      "id": "ec93f280631692aa22be0449f431c5a4"
    },
    {
      "type": "html",
      "text": "<i>Meyers' stimulating article is rather old now, and one can do much better in several respects... As you point out, he sticks to double dispatch. Also he uses typeid(T).name() as his type identifier key, which is not actually guaranteed to be unique, and he requires all user functions to down cast their arguments, and does not consider different base types for the same argument slots, etc. etc.</i>",
      "id": "d6efa87af141344f65f3bc614f855d37"
    },
    {
      "type": "html",
      "text": "<i>Most importantly, Meyers does not tackle the problem of how to find the correct polymorphic match when the calling signature does not exactly match one of the candidate functions. But then I don't think the template trickery that enables us to do this nowadays was around when he wrote [[More Effective Cee Plus Plus]].</i>",
      "id": "6aca38b1aa824cb31b814acc4521d6b2"
    },
    {
      "type": "html",
      "text": "\n[[Andrei Alexandrescu]]'s book on [[Modern Cee Plus Plus Design]] contains a chapter titled \"Multimethods\" that discusses several schemes to implement [[Double Dispatch]] in standard [[Cee Plus Plus]].",
      "id": "8f33072f6988bb2b9d4c3671c0f33e80"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b7acc2549b7426aabb45c296e3880bdd"
    },
    {
      "type": "html",
      "text": "\n[[Double Dispatch]] is a way of working around a lack of [[Multi Methods]], and as such, could be considered a [[Language Smell]].",
      "id": "898a41046288387d50cb136d35e3d57c"
    },
    {
      "type": "html",
      "text": "<i>I personally prefer some sort of table lookup. It is easier to manage and view a bunch of these in tables than in linear code IMO. Plus, with tables you can have/add X-way dispatching if need be without significant structure alteration for each new dimension. </i>",
      "id": "bf94eb18626c28f8463529aed607909b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b7acc2549b7426aabb45c296e3880bdd"
    },
    {
      "type": "html",
      "text": "\n[[Double Dispatch]] may work well with different basic types of objects, but what about objects of the same basic type and essentially functionality?",
      "id": "d3b93e1f6a56aee726c762ae89702cdb"
    },
    {
      "type": "html",
      "text": "\nTake for example a simple primitive collision system; you may have spheres, bounding boxes, lines, points etc. and you would like to be able to test every primitive type against every other primitive type, with the possibility of adding in new primitives in the future without modifying existing code (maybe in conjunction with the [[Bridge Pattern]]?). I have a big err with this situation, where does the actual 'doing' code go? Or is this incorrect usage of [[Double Dispatch]] and should something else be used (like the [[Visitor Pattern]])? Any thoughts?",
      "id": "18efa2d951af346c4cfafc99130d306b"
    },
    {
      "type": "html",
      "text": "---",
      "id": "55dc009de32b709325d65e96333090b5"
    },
    {
      "type": "html",
      "text": "\nThe doing code is all you have to write!!! (in an ideal world)... and it goes in the obvious place....",
      "id": "b59bf2d589f7c7147e0560b975882b3a"
    },
    {
      "type": "code",
      "text": "    collide(Sphere& sphere, Box& box) { /* do sphere box collision here */  }\n    collide(Sphere& sphere, Line& line) { /* do sphere line collision here */  }",
      "id": "e095fcf6247227986fbb0cc98bc520ea"
    },
    {
      "type": "html",
      "text": "etc",
      "id": "6c5da657c498c9e3f02378eef2b713ba"
    },
    {
      "type": "html",
      "text": "\nthen the calling code just collides two shapes, and the right 'doing' is automatically done!",
      "id": "6046c45f04ed928e90102e76bbe82fad"
    },
    {
      "type": "code",
      "text": "    Shape shape1 = *new Sphere, shape2 = *new Box;\n    collide(shape1, shape2);",
      "id": "e945654eb85416c5d01bc451106cf865"
    },
    {
      "type": "html",
      "text": "-- [[Bill Weston]]",
      "id": "9366d28b1c1a9d9d4c52f86ce30c1252"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b7acc2549b7426aabb45c296e3880bdd"
    },
    {
      "type": "html",
      "text": "<i>Can you say something more about what you mean by \"a simple primitive collision system\"? Suppose you have classes Sphere, Box, Line and Point. Do you want to define operations on these, and then be able to add new geometric classes that participate in these operations?</i>",
      "id": "6254d2fa87dcf7d9c8946e8c581ed0d2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b7acc2549b7426aabb45c296e3880bdd"
    },
    {
      "type": "html",
      "text": "\nThere is a concept - a pattern I \"have\" - that I'm struggling to name. After encountering [[Double Dispatch]] enough times here that I needed to understand what it meant. I read most of this page, sure that [[Double Dispatch]] meant something truly interesting, but completely baffled what that could be - so I checked the [[Double Dispatch Example]] page. Upon seeing the six lines of code in the client class, it is completely obvious how to implement [[Double Dispatch]].",
      "id": "112b82eadb563b78b6b137beb67b1860"
    },
    {
      "type": "html",
      "text": "\nI have a sort of block where I can't understand certain patterns by description because they are so obvious and I'm expecting some sort of deeper meaning. Then when I realized what they are, I realize it's something I've done dozens of times.",
      "id": "7f263fb05241c227313a4121afdc3192"
    },
    {
      "type": "html",
      "text": "\nI wonder if this dooms me to cowboy programmer status for eternity. I guess I'd make a crappy academic, too.",
      "id": "48d0247108e4f69ed4f02d2acd5eba09"
    },
    {
      "type": "html",
      "text": "\nI haven't learned the language of language architects. I have found educational texts to be condescending, irrelevant, or possessing too much noise for the signal. I've learned everything I know about programming from language reference texts and working examples while working out my immediate problems.",
      "id": "6e72eeeb15caf1e7c709f6535de6cd7f"
    },
    {
      "type": "html",
      "text": "\nI do have this to ask: Why would you want [[Multi Methods]] for solving this sort of problem? It seems terribly disorganized compared to the alternative. I don't understand how the multimethods version is easier/better/faster/intuitive/maintainable.",
      "id": "9027092d859fb46e45593278368855dc"
    },
    {
      "type": "html",
      "text": "\nTaking the printer example, you define a set of drawing primitives (the least likely to change axis), and you define a printer interface so that each printer implementation can draw each primitive.",
      "id": "65559ff39ab826abba6439c985ccfa56"
    },
    {
      "type": "html",
      "text": "\nEach time you add a different type of printer, the new drawing code goes there in the new printer class. Organized.",
      "id": "6aa769b125fa4f3628e438bb98e9b1d9"
    },
    {
      "type": "html",
      "text": "\nWith multimethods, you would have one class that had the cartesian product (printers x shapes) of methods for rendering on different printers. Is this fear of adding classes?",
      "id": "6544d13c27bfe389c3c534ede0e7226e"
    },
    {
      "type": "html",
      "text": "\nI suspect I'm somehow missing the point.",
      "id": "f431b9b5a2f1133f55d7e5cdb82730da"
    },
    {
      "type": "html",
      "text": "-- [[Anonymous Donor]]",
      "id": "24ca1c58feb9bcdd6f75b0da880df658"
    },
    {
      "type": "html",
      "text": "\nWell, you've at least misunderstood [[Multi Methods]]. You've touched on three ways of approaching a task that varies according to the types of two objects (a printer, and a shape). (You talked about drawing primitives, but it's actually about shape objects of some sort -- this is critical, and may be at the heart of your misunderstanding.) Each one of these approaches involves a function or method for each valid combination of printer and shape. The differences are in how the code is arranged, and how much code the programmer has to write to get control dispatched to the correct function.",
      "id": "da8aa638e961bb06fc5f391aa79afcd4"
    },
    {
      "type": "html",
      "text": "\nWe'll assume that the printers all have a common base class (APrinter), and the shapes also have a common base class (AShape).",
      "id": "e719eb96b1de651f2d40d9c086efade6"
    },
    {
      "type": "html",
      "text": "\nIn the simplest case, as you say, you extend the printer interface with a separate function per shape that it can render. Now, given some code where you have a printer object, and a shape object. But the code only knows the printer object to be of type APrinter (assuming a statically typed language), and the shape object to be of type AShape. How do you, or the compiler, know which printer method to call? That's the crux of the problem. You need to select the method based on the run-time types, not the static types, of <i>two</i> objects.",
      "id": "0c527fe3004ed2458ca180da18aab499"
    },
    {
      "type": "html",
      "text": "\n[[Double Dispatch]] is a pattern for solving this problem in a typical OO language that can dispatch only on one object's type. It requires a bit of extra work by the programmer.",
      "id": "16f52e73d244eb5d4c01fc9274d1814f"
    },
    {
      "type": "html",
      "text": "\n[[Multi Methods]] are inherently polymorphic on multiple objects, so you simply write a method for each specific combination of derived types that you want to support, and call them in a straightforward way. In the code, it looks like you're passing an APrinter and an AShape to a function. The language system does the hard work for you, and selects the specific multimethod that's a closest match, according to whatever rules the particular language uses.",
      "id": "4f1f439705b28a3646ce808bc0d6411c"
    },
    {
      "type": "html",
      "text": "\nDoes that explanation help?",
      "id": "1253e11ab31ab6f3b78eec9b926a151b"
    },
    {
      "type": "html",
      "text": "-- [[Dan Muller]]",
      "id": "395a15127faa823ac4b06cb5d33f1409"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b7acc2549b7426aabb45c296e3880bdd"
    },
    {
      "type": "html",
      "text": "\nAn approach to [[Double Dispatch]] using the [[Visitor Pattern]] has been patented in the [[United States]].  See [[Ibm Double Dispatch Patent]].",
      "id": "537e16a496c967023c8b1a2c44f36170"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b7acc2549b7426aabb45c296e3880bdd"
    },
    {
      "type": "html",
      "text": "See also [[Multiple Dispatch]], [[Message Oriented Programming]]",
      "id": "e57e95039d8c3aaa977ebbd62575264d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b7acc2549b7426aabb45c296e3880bdd"
    },
    {
      "type": "html",
      "text": "[[Category Polymorphism]] [[Category Conditionals And Dispatching]]",
      "id": "dc6308e3bc16221f8e305982ad19f847"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?DoubleDispatch c2.com]",
      "id": "ec1c0c027b7937cc03158b31a611fd24"
    }
  ],
  "journal": [
    {
      "date": 1208161893000,
      "id": "0ea4864edaece77ff0593106b610be72",
      "type": "create",
      "item": {
        "title": "Double Dispatch",
        "story": [
          {
            "type": "html",
            "text": "Say you have three kinds of figures that you want to print on four kinds of printers. The message",
            "id": "53dbf3a641b81c356d920b06b4d44c2c"
          },
          {
            "type": "html",
            "text": "circleFigure printOn:<br>laserPrinter",
            "id": "c6d2a303477124465a27ce12b2c0fc77"
          },
          {
            "type": "html",
            "text": "must dispatch on both the Figure and Printer hierarchies. One does this by defining methods like",
            "id": "52a361454fb9c642f7866bb9d9e1f70c"
          },
          {
            "type": "html",
            "text": "printOn:<br>aPrinter",
            "id": "131b7377b3ca9cee5a6901afc296d794"
          },
          {
            "type": "html",
            "text": "aPrinter printCircle:<br>self",
            "id": "bb0ef6225cbc5fe9cd0c469329e1e3e6"
          },
          {
            "type": "html",
            "text": "in the Figure hierarchy and methods like",
            "id": "2e22ef24a750a81189921792ca67c04a"
          },
          {
            "type": "html",
            "text": "printCircle:<br>aCircle",
            "id": "c5b25b042ca14b38cb345b7519036caf"
          },
          {
            "type": "code",
            "text": "    ... circle printing stuff ...",
            "id": "4a986b2405d807d3c5b9b84bfe2c5190"
          },
          {
            "type": "html",
            "text": "in the Printer hierarchy.",
            "id": "eb43e7bfd8951de03d6e3537512b1fb7"
          },
          {
            "type": "html",
            "text": "\nAn elaboration of the above example in Java is at [[Double Dispatch Example]].",
            "id": "baec682755e68c3ff4b246958431a891"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b7acc2549b7426aabb45c296e3880bdd"
          },
          {
            "type": "html",
            "text": "\nIsn't this what the [[Gang Of Four]] [[Visitor Pattern]] does? And [[Common Lisp]] has built into the language via its [[Generic Function]]s?",
            "id": "2aae5ff553ac910b0b30bd6d12fd4eb0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b7acc2549b7426aabb45c296e3880bdd"
          },
          {
            "type": "html",
            "text": "[[Dan Ingalls]] wrote this technique up for one of the early OOPSLAs. The program committee almost rejected the paper because the idea was considered obvious, or insufficiently scientific, or something like that.",
            "id": "d8956b3a973c1d46b13438efc74e08a3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b7acc2549b7426aabb45c296e3880bdd"
          },
          {
            "type": "html",
            "text": "It was one of my favorite OOPSLA papers, and it was because OOPSLA doesn't publish papers like that any more that I wanted to start a conference on patterns, where an idea will not be rejected just because it was in [[Ivan Sutherland]]'s PhD thesis.",
            "id": "f55ec4d69fff3e5e1acedd67e8aa3620"
          },
          {
            "type": "html",
            "text": "-- [[Ralph Johnson]]",
            "id": "62a86e8c79dbfeb0a32321843599b6d8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b7acc2549b7426aabb45c296e3880bdd"
          },
          {
            "type": "html",
            "text": "[[Boy This Stuff Makes Me Feel Stupid]] ... Would someone be willing to create a more verbose example? (hopefully in Java or C++) Perhaps it would make more sense (to me at least) if there were more code that a person could step through.",
            "id": "90018ba57aba2baaa73a6334b91bcbdc"
          },
          {
            "type": "html",
            "text": "<i>See [[Double Dispatch Example]]</i>",
            "id": "02b6a5656cfe4a9bbe07f99a9ae7db47"
          },
          {
            "type": "html",
            "text": "<i>See [http://forum.java.sun.com/read/16789542/q_tzLgu-LxJkAAagM forum.java.sun.com] ([[Broken Link]]) for a \"simple\" example of a case where [[Multiple Dispatch]] is the \"expected\" behaviour in Java, and why it is puzzling that such behaviour doesn't actually occur in Java.</i>",
            "id": "bcfef2e0a166eeeff9dfbe42a1a8194a"
          },
          {
            "type": "html",
            "text": "\nItem 31 in [[More Effective Cee Plus Plus]] is \"Making functions virtual with respect to more than one object\", i.e., [[Multiple Dispatch]]. Actually, he concentrates on double dispatch, and only waves his hands at dispatching on n > 2 objects. At 24 pages, it is one of the longest items in the book. Meyers discusses several alternative approaches to implementation, and the advantages and (mostly) disadvantages of each. He comes up with a workable way of doing it, while making you appreciate what the compiler does for you in single dispatch and making you wish you were using a language that did all this for you.",
            "id": "ec93f280631692aa22be0449f431c5a4"
          },
          {
            "type": "html",
            "text": "<i>Meyers' stimulating article is rather old now, and one can do much better in several respects... As you point out, he sticks to double dispatch. Also he uses typeid(T).name() as his type identifier key, which is not actually guaranteed to be unique, and he requires all user functions to down cast their arguments, and does not consider different base types for the same argument slots, etc. etc.</i>",
            "id": "d6efa87af141344f65f3bc614f855d37"
          },
          {
            "type": "html",
            "text": "<i>Most importantly, Meyers does not tackle the problem of how to find the correct polymorphic match when the calling signature does not exactly match one of the candidate functions. But then I don't think the template trickery that enables us to do this nowadays was around when he wrote [[More Effective Cee Plus Plus]].</i>",
            "id": "6aca38b1aa824cb31b814acc4521d6b2"
          },
          {
            "type": "html",
            "text": "\n[[Andrei Alexandrescu]]'s book on [[Modern Cee Plus Plus Design]] contains a chapter titled \"Multimethods\" that discusses several schemes to implement [[Double Dispatch]] in standard [[Cee Plus Plus]].",
            "id": "8f33072f6988bb2b9d4c3671c0f33e80"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b7acc2549b7426aabb45c296e3880bdd"
          },
          {
            "type": "html",
            "text": "\n[[Double Dispatch]] is a way of working around a lack of [[Multi Methods]], and as such, could be considered a [[Language Smell]].",
            "id": "898a41046288387d50cb136d35e3d57c"
          },
          {
            "type": "html",
            "text": "<i>I personally prefer some sort of table lookup. It is easier to manage and view a bunch of these in tables than in linear code IMO. Plus, with tables you can have/add X-way dispatching if need be without significant structure alteration for each new dimension. </i>",
            "id": "bf94eb18626c28f8463529aed607909b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b7acc2549b7426aabb45c296e3880bdd"
          },
          {
            "type": "html",
            "text": "\n[[Double Dispatch]] may work well with different basic types of objects, but what about objects of the same basic type and essentially functionality?",
            "id": "d3b93e1f6a56aee726c762ae89702cdb"
          },
          {
            "type": "html",
            "text": "\nTake for example a simple primitive collision system; you may have spheres, bounding boxes, lines, points etc. and you would like to be able to test every primitive type against every other primitive type, with the possibility of adding in new primitives in the future without modifying existing code (maybe in conjunction with the [[Bridge Pattern]]?). I have a big err with this situation, where does the actual 'doing' code go? Or is this incorrect usage of [[Double Dispatch]] and should something else be used (like the [[Visitor Pattern]])? Any thoughts?",
            "id": "18efa2d951af346c4cfafc99130d306b"
          },
          {
            "type": "html",
            "text": "---",
            "id": "55dc009de32b709325d65e96333090b5"
          },
          {
            "type": "html",
            "text": "\nThe doing code is all you have to write!!! (in an ideal world)... and it goes in the obvious place....",
            "id": "b59bf2d589f7c7147e0560b975882b3a"
          },
          {
            "type": "code",
            "text": "    collide(Sphere& sphere, Box& box) { /* do sphere box collision here */  }\n    collide(Sphere& sphere, Line& line) { /* do sphere line collision here */  }",
            "id": "e095fcf6247227986fbb0cc98bc520ea"
          },
          {
            "type": "html",
            "text": "etc",
            "id": "6c5da657c498c9e3f02378eef2b713ba"
          },
          {
            "type": "html",
            "text": "\nthen the calling code just collides two shapes, and the right 'doing' is automatically done!",
            "id": "6046c45f04ed928e90102e76bbe82fad"
          },
          {
            "type": "code",
            "text": "    Shape shape1 = *new Sphere, shape2 = *new Box;\n    collide(shape1, shape2);",
            "id": "e945654eb85416c5d01bc451106cf865"
          },
          {
            "type": "html",
            "text": "-- [[Bill Weston]]",
            "id": "9366d28b1c1a9d9d4c52f86ce30c1252"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b7acc2549b7426aabb45c296e3880bdd"
          },
          {
            "type": "html",
            "text": "<i>Can you say something more about what you mean by \"a simple primitive collision system\"? Suppose you have classes Sphere, Box, Line and Point. Do you want to define operations on these, and then be able to add new geometric classes that participate in these operations?</i>",
            "id": "6254d2fa87dcf7d9c8946e8c581ed0d2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b7acc2549b7426aabb45c296e3880bdd"
          },
          {
            "type": "html",
            "text": "\nThere is a concept - a pattern I \"have\" - that I'm struggling to name. After encountering [[Double Dispatch]] enough times here that I needed to understand what it meant. I read most of this page, sure that [[Double Dispatch]] meant something truly interesting, but completely baffled what that could be - so I checked the [[Double Dispatch Example]] page. Upon seeing the six lines of code in the client class, it is completely obvious how to implement [[Double Dispatch]].",
            "id": "112b82eadb563b78b6b137beb67b1860"
          },
          {
            "type": "html",
            "text": "\nI have a sort of block where I can't understand certain patterns by description because they are so obvious and I'm expecting some sort of deeper meaning. Then when I realized what they are, I realize it's something I've done dozens of times.",
            "id": "7f263fb05241c227313a4121afdc3192"
          },
          {
            "type": "html",
            "text": "\nI wonder if this dooms me to cowboy programmer status for eternity. I guess I'd make a crappy academic, too.",
            "id": "48d0247108e4f69ed4f02d2acd5eba09"
          },
          {
            "type": "html",
            "text": "\nI haven't learned the language of language architects. I have found educational texts to be condescending, irrelevant, or possessing too much noise for the signal. I've learned everything I know about programming from language reference texts and working examples while working out my immediate problems.",
            "id": "6e72eeeb15caf1e7c709f6535de6cd7f"
          },
          {
            "type": "html",
            "text": "\nI do have this to ask: Why would you want [[Multi Methods]] for solving this sort of problem? It seems terribly disorganized compared to the alternative. I don't understand how the multimethods version is easier/better/faster/intuitive/maintainable.",
            "id": "9027092d859fb46e45593278368855dc"
          },
          {
            "type": "html",
            "text": "\nTaking the printer example, you define a set of drawing primitives (the least likely to change axis), and you define a printer interface so that each printer implementation can draw each primitive.",
            "id": "65559ff39ab826abba6439c985ccfa56"
          },
          {
            "type": "html",
            "text": "\nEach time you add a different type of printer, the new drawing code goes there in the new printer class. Organized.",
            "id": "6aa769b125fa4f3628e438bb98e9b1d9"
          },
          {
            "type": "html",
            "text": "\nWith multimethods, you would have one class that had the cartesian product (printers x shapes) of methods for rendering on different printers. Is this fear of adding classes?",
            "id": "6544d13c27bfe389c3c534ede0e7226e"
          },
          {
            "type": "html",
            "text": "\nI suspect I'm somehow missing the point.",
            "id": "f431b9b5a2f1133f55d7e5cdb82730da"
          },
          {
            "type": "html",
            "text": "-- [[Anonymous Donor]]",
            "id": "24ca1c58feb9bcdd6f75b0da880df658"
          },
          {
            "type": "html",
            "text": "\nWell, you've at least misunderstood [[Multi Methods]]. You've touched on three ways of approaching a task that varies according to the types of two objects (a printer, and a shape). (You talked about drawing primitives, but it's actually about shape objects of some sort -- this is critical, and may be at the heart of your misunderstanding.) Each one of these approaches involves a function or method for each valid combination of printer and shape. The differences are in how the code is arranged, and how much code the programmer has to write to get control dispatched to the correct function.",
            "id": "da8aa638e961bb06fc5f391aa79afcd4"
          },
          {
            "type": "html",
            "text": "\nWe'll assume that the printers all have a common base class (APrinter), and the shapes also have a common base class (AShape).",
            "id": "e719eb96b1de651f2d40d9c086efade6"
          },
          {
            "type": "html",
            "text": "\nIn the simplest case, as you say, you extend the printer interface with a separate function per shape that it can render. Now, given some code where you have a printer object, and a shape object. But the code only knows the printer object to be of type APrinter (assuming a statically typed language), and the shape object to be of type AShape. How do you, or the compiler, know which printer method to call? That's the crux of the problem. You need to select the method based on the run-time types, not the static types, of <i>two</i> objects.",
            "id": "0c527fe3004ed2458ca180da18aab499"
          },
          {
            "type": "html",
            "text": "\n[[Double Dispatch]] is a pattern for solving this problem in a typical OO language that can dispatch only on one object's type. It requires a bit of extra work by the programmer.",
            "id": "16f52e73d244eb5d4c01fc9274d1814f"
          },
          {
            "type": "html",
            "text": "\n[[Multi Methods]] are inherently polymorphic on multiple objects, so you simply write a method for each specific combination of derived types that you want to support, and call them in a straightforward way. In the code, it looks like you're passing an APrinter and an AShape to a function. The language system does the hard work for you, and selects the specific multimethod that's a closest match, according to whatever rules the particular language uses.",
            "id": "4f1f439705b28a3646ce808bc0d6411c"
          },
          {
            "type": "html",
            "text": "\nDoes that explanation help?",
            "id": "1253e11ab31ab6f3b78eec9b926a151b"
          },
          {
            "type": "html",
            "text": "-- [[Dan Muller]]",
            "id": "395a15127faa823ac4b06cb5d33f1409"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b7acc2549b7426aabb45c296e3880bdd"
          },
          {
            "type": "html",
            "text": "\nAn approach to [[Double Dispatch]] using the [[Visitor Pattern]] has been patented in the [[United States]].  See [[Ibm Double Dispatch Patent]].",
            "id": "537e16a496c967023c8b1a2c44f36170"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b7acc2549b7426aabb45c296e3880bdd"
          },
          {
            "type": "html",
            "text": "See also [[Multiple Dispatch]], [[Message Oriented Programming]]",
            "id": "e57e95039d8c3aaa977ebbd62575264d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b7acc2549b7426aabb45c296e3880bdd"
          },
          {
            "type": "html",
            "text": "[[Category Polymorphism]] [[Category Conditionals And Dispatching]]",
            "id": "dc6308e3bc16221f8e305982ad19f847"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?DoubleDispatch c2.com]",
            "id": "ec1c0c027b7937cc03158b31a611fd24"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1699944127337
    }
  ]
}