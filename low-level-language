{
  "title": "Low Level Language",
  "story": [
    {
      "type": "html",
      "text": "There is no formal distinction between a low level and a high level languages, but a number of differences can be noted.",
      "id": "5cd023f973db0d87368d0bac6c7da02e"
    },
    {
      "type": "html",
      "text": "\nA high-level language is an advanced computer programming that abstracts details of the underlying hardware , may be designed for a specific job, and is easier to understand. A line of code in a higher level language expands into multiple machine code instruction. Low level languages were developed first, and high level languages came along later. Today, there are dozens of high-level languages; some examples include BASIC, FORTRAN, Java, C++ and Pascal. ",
      "id": "01c1fca97a788eb922a1bf8eda380ada"
    },
    {
      "type": "html",
      "text": "\nLow-level languages have the advantage that the programmer is able to tune the code to be smaller or more efficient, and that more system-dependent features are sometimes available. Their use is often a necessity when writing [[Device Drivers]] or [[Embedded Software]]. They have the disadvantage that they are often unportable, and usually harder to program in, both in the sense that the programmer has to pay more attention to fine details, and in the sense that it takes more [[Lines Of Code]] to achieve the same result. \nAs a concrete example, data types in a low level language might represent 8, 16 or 32 bit wide integers, whereas a high level language might feature human-friendly Currency and Date types. Low level languages are always static, and never have garbage collection.",
      "id": "9d2ae31ba62fa9e7ee4da6a7e2da972e"
    },
    {
      "type": "html",
      "text": "\nThe classic and uncontroversial  example of a low level language is [[Assembly Language]]. Assembly is a mnemonic-based low-level language replacing  binary machine-code instructions, which are very hard to remember, write down, or correct, with short codes (mnemonics) chosen to remind the programmer of the instructions they represent. For example, the binary-code instruction that means ‘store the contents of the accumulator’ may be represented with the mnemonic STA (st/ore a/ccumulator)",
      "id": "5a2913edbad66848c7e2ebdc946b01f9"
    },
    {
      "type": "html",
      "text": "\nA low level language may be defined by the presence of hardware orientated features as well as the absence of  high level constructs. Assembler is considered low level, although it usually include a macro facility, that allows single lines of code to expand into multiple machine code instructions.",
      "id": "7a60a3a3eff282f3cac8fdb7efb16c12"
    },
    {
      "type": "html",
      "text": "\nAlthough C ([[Cee Language]]) has a many of the high level constructs typical of a 1970s language (cf [[Pascal Language]]), it is sometimes considered low level (or low-level-high-level, or medium level...) because it allows bit-orientated operations, direct memory access, and raw pointers, (unlike, for instance [[Haskell Language]], where there is no concept of storing data). An argument against C being low level is that, standard ANSI C has lower level counterparts, such as [[Cee Minus Minus]]., and lower level forerunner such as [[Bee Language]] and BCPL. C++ ([[Cee Plus Plus]]) adds further high level features to C, without losing the low level features; however, systems programmers often prefer C for its explicit, WYSIWYG qualities.",
      "id": "cfadda5eea82db0ba3176c7eb6fe2f93"
    },
    {
      "type": "html",
      "text": "\nIt might seem odd that C, considered as a low level language, is highly portable. Part of the answer is that since the 1970s, hardware has often been designed with eventual programming in C in mind - for instance with a flat [[Memory Model]], and word lengths in multiples of 8 bits. Conversely, C itself has been extended to exploit hardware innovations such as widespread parallelism (eg. [[Unified Parallel Cee]], Cilk).",
      "id": "94ca506fe79ae412396a01bf53dec619"
    },
    {
      "type": "html",
      "text": "\nAssembler can be inlined in a number of otherwise high level languages, at the expense of less portability. Achieving portability is a motivation for removing low level features from a languages, notably in the case of Java, which runs on a [[Virtual Machine]]. In fact virtualisation means that the level of a language depends on how it is used in situ, and not just on the language itself: C or assembler running in a virtual box will not have genuine access to hardware. Conversely, a language becomes lower level if running on tailored hardware, as in the [[Lisp Machine]]. The [[Forth Language]] is sometimes considered low level, because of its syntaxless approach, and resemblance to a virtual machine code, although, like Lisp, it is highly extensible.",
      "id": "b81b2606f03e6ebdd2987fb5b0056bea"
    },
    {
      "type": "html",
      "text": "\nPortable languages like Java may use [[Byte Code]] or something else as an [[Intermediate Language]]. Intermediate languages usually aren't meant to be hand written, but there is a certain overlap between low level languages and intermediate ones. See [[Cee As An Intermediate Language]].",
      "id": "bb9f32c06e0361ebf5cc86cd229d6d3c"
    },
    {
      "type": "html",
      "text": "\nAny language that is low level enough to allow full control of the underlying hardware is general purpose (in theory: it might well be a poor choice for some projects) Some high level languages are general purpose, while others are intended to solve particular problems: for example, BASIC was designed to be easily learnt by first-time programmers; COBOL is used to write programs solving business problems; and FORTRAN is used for programs solving scientific and mathematical problems.",
      "id": "542063000128941a9ef9fe35cc65a838"
    },
    {
      "type": "html",
      "text": "\nSee also: [[High Level Language]], [[Intermediate Language]]",
      "id": "b8607bba5147d4601e1ac48cfd525591"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c7e01335166d8dd27514c3a64cf7655a"
    },
    {
      "type": "html",
      "text": "[[Category Abstraction]] [[Category Programming Language]], [[Category Machine Orientation]]",
      "id": "1c98303bd02ca993103ec42b8372eaad"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?LowLevelLanguage c2.com]",
      "id": "60aa83034dd253bb3e6523646baf004f"
    }
  ],
  "journal": [
    {
      "date": 1417030810000,
      "id": "80188c6d8207e6b03121027e126eefbc",
      "type": "create",
      "item": {
        "title": "Low Level Language",
        "story": [
          {
            "type": "html",
            "text": "There is no formal distinction between a low level and a high level languages, but a number of differences can be noted.",
            "id": "5cd023f973db0d87368d0bac6c7da02e"
          },
          {
            "type": "html",
            "text": "\nA high-level language is an advanced computer programming that abstracts details of the underlying hardware , may be designed for a specific job, and is easier to understand. A line of code in a higher level language expands into multiple machine code instruction. Low level languages were developed first, and high level languages came along later. Today, there are dozens of high-level languages; some examples include BASIC, FORTRAN, Java, C++ and Pascal. ",
            "id": "01c1fca97a788eb922a1bf8eda380ada"
          },
          {
            "type": "html",
            "text": "\nLow-level languages have the advantage that the programmer is able to tune the code to be smaller or more efficient, and that more system-dependent features are sometimes available. Their use is often a necessity when writing [[Device Drivers]] or [[Embedded Software]]. They have the disadvantage that they are often unportable, and usually harder to program in, both in the sense that the programmer has to pay more attention to fine details, and in the sense that it takes more [[Lines Of Code]] to achieve the same result. \nAs a concrete example, data types in a low level language might represent 8, 16 or 32 bit wide integers, whereas a high level language might feature human-friendly Currency and Date types. Low level languages are always static, and never have garbage collection.",
            "id": "9d2ae31ba62fa9e7ee4da6a7e2da972e"
          },
          {
            "type": "html",
            "text": "\nThe classic and uncontroversial  example of a low level language is [[Assembly Language]]. Assembly is a mnemonic-based low-level language replacing  binary machine-code instructions, which are very hard to remember, write down, or correct, with short codes (mnemonics) chosen to remind the programmer of the instructions they represent. For example, the binary-code instruction that means ‘store the contents of the accumulator’ may be represented with the mnemonic STA (st/ore a/ccumulator)",
            "id": "5a2913edbad66848c7e2ebdc946b01f9"
          },
          {
            "type": "html",
            "text": "\nA low level language may be defined by the presence of hardware orientated features as well as the absence of  high level constructs. Assembler is considered low level, although it usually include a macro facility, that allows single lines of code to expand into multiple machine code instructions.",
            "id": "7a60a3a3eff282f3cac8fdb7efb16c12"
          },
          {
            "type": "html",
            "text": "\nAlthough C ([[Cee Language]]) has a many of the high level constructs typical of a 1970s language (cf [[Pascal Language]]), it is sometimes considered low level (or low-level-high-level, or medium level...) because it allows bit-orientated operations, direct memory access, and raw pointers, (unlike, for instance [[Haskell Language]], where there is no concept of storing data). An argument against C being low level is that, standard ANSI C has lower level counterparts, such as [[Cee Minus Minus]]., and lower level forerunner such as [[Bee Language]] and BCPL. C++ ([[Cee Plus Plus]]) adds further high level features to C, without losing the low level features; however, systems programmers often prefer C for its explicit, WYSIWYG qualities.",
            "id": "cfadda5eea82db0ba3176c7eb6fe2f93"
          },
          {
            "type": "html",
            "text": "\nIt might seem odd that C, considered as a low level language, is highly portable. Part of the answer is that since the 1970s, hardware has often been designed with eventual programming in C in mind - for instance with a flat [[Memory Model]], and word lengths in multiples of 8 bits. Conversely, C itself has been extended to exploit hardware innovations such as widespread parallelism (eg. [[Unified Parallel Cee]], Cilk).",
            "id": "94ca506fe79ae412396a01bf53dec619"
          },
          {
            "type": "html",
            "text": "\nAssembler can be inlined in a number of otherwise high level languages, at the expense of less portability. Achieving portability is a motivation for removing low level features from a languages, notably in the case of Java, which runs on a [[Virtual Machine]]. In fact virtualisation means that the level of a language depends on how it is used in situ, and not just on the language itself: C or assembler running in a virtual box will not have genuine access to hardware. Conversely, a language becomes lower level if running on tailored hardware, as in the [[Lisp Machine]]. The [[Forth Language]] is sometimes considered low level, because of its syntaxless approach, and resemblance to a virtual machine code, although, like Lisp, it is highly extensible.",
            "id": "b81b2606f03e6ebdd2987fb5b0056bea"
          },
          {
            "type": "html",
            "text": "\nPortable languages like Java may use [[Byte Code]] or something else as an [[Intermediate Language]]. Intermediate languages usually aren't meant to be hand written, but there is a certain overlap between low level languages and intermediate ones. See [[Cee As An Intermediate Language]].",
            "id": "bb9f32c06e0361ebf5cc86cd229d6d3c"
          },
          {
            "type": "html",
            "text": "\nAny language that is low level enough to allow full control of the underlying hardware is general purpose (in theory: it might well be a poor choice for some projects) Some high level languages are general purpose, while others are intended to solve particular problems: for example, BASIC was designed to be easily learnt by first-time programmers; COBOL is used to write programs solving business problems; and FORTRAN is used for programs solving scientific and mathematical problems.",
            "id": "542063000128941a9ef9fe35cc65a838"
          },
          {
            "type": "html",
            "text": "\nSee also: [[High Level Language]], [[Intermediate Language]]",
            "id": "b8607bba5147d4601e1ac48cfd525591"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c7e01335166d8dd27514c3a64cf7655a"
          },
          {
            "type": "html",
            "text": "[[Category Abstraction]] [[Category Programming Language]], [[Category Machine Orientation]]",
            "id": "1c98303bd02ca993103ec42b8372eaad"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?LowLevelLanguage c2.com]",
            "id": "60aa83034dd253bb3e6523646baf004f"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1708035598455
    }
  ]
}