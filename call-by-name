{
  "title": "Call By Name",
  "story": [
    {
      "type": "html",
      "text": "A technical answer to the question \"[[What Isa Thunk]]?\" is that function arguments are evaluated in the called function, a la Algol 60 ([[Algol Sixty]]).",
      "id": "06d4efddcf3ef474775cc665997e7f56"
    },
    {
      "type": "html",
      "text": "\nAs an example:  When calling a function, if you pass a pointer to hooha() as the first parameter, then <i>every time</i> that first parameter is referenced in the function, hooha() will be called.  If hooha() does different things each time it's called (like rand() does), this can cause trouble.  It's a feature of some programming languages (anyone care to build a list?).",
      "id": "9eb29ab324dec02359a31019ecdfd650"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "\nI believe the original use of <i>thunk</i> comes from [[Algol Language]].  Algol 60 had the irritating misfeature of [[Call By Name]] arguments; when you called a function <i>Foo(1+2)</i> and it referred to its argument, it was forced to reevaluate 1+2 over and over again. ",
      "id": "bcd50b37f4db8744e020ea34e97dfd74"
    },
    {
      "type": "html",
      "text": "\nA thunk is a function pointer packaged up with some data, so you can call 1+2 in the caller's environment.  This was <i>so</i> annoying to compiler writers and users both that no other language to my knowledge has followed Algol's questionable lead here; even functional languages like Haskell, which has probably the most non-standard calling conventions of any modern language, evaluate their arguments at most once.",
      "id": "c20fa8b1c2973025597562fac25cf47b"
    },
    {
      "type": "html",
      "text": "-- [[Graham Hughes]]",
      "id": "b7c4ac50a439c8c5e0cc181f2b9b500a"
    },
    {
      "type": "html",
      "text": "<b>This misfeature was exploited in [[Jensens Device]]</b>",
      "id": "563224862f1942e9ded0f6e26f76e607"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "'Misfeature' is an interesting word.  I think that to refer to call-by-name as a misfeature of Algol is not 100% fair.  It seems to me that the problem was not the provision of [[Call By Name]], but rather the failure to provide [[Call By Reference]]. This meant that one was forced to use [[Call By Name]] in situations where it shouldn't have been necessary.  Also there are a few situations where [[Call By Name]] simply does not do the job that [[Call By Reference]] does.  (SWAP(i, a[i]) is the standard example).  If Algol had provided 3 options, namely call by value, name, AND reference then I doubt that anyone would have described [[Call By Name]] as a misfeature.",
      "id": "fbe178eaaeccc7b1e0f106365004644e"
    },
    {
      "type": "html",
      "text": "\nIn the few situations where it is appropriate, [[Call By Name]] is extremely useful.  You can achieve much the same effect in languages where it is possible to pass a function, or a pointer to a function, as a parameter, but this is at the expense of having to define a function for every expression you want to pass as a parameter.  I have never come across another language where the power of [[Call By Name]] is available to the programmer in such a direct and elegant way as in Algol.",
      "id": "27d47d0667d8454190160284dd0369b7"
    },
    {
      "type": "html",
      "text": "-- Michael Davis",
      "id": "04dc13e6febe14a710c4cd74d263e29d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "\nIf I remember correctly from previous work and education, the point of a Thunk is to delay evaluation of the thing thunked.  You can use this idea to emulate a sort of lazy evaluation.  Indeed, I think that is how it was first done in Lisp. -- [[Chris Booth]]",
      "id": "a459f173b6c70bda08dbd676e7f37415"
    },
    {
      "type": "html",
      "text": "<i>Like blocks in Smalltalk, then? -- [[John Clonts]]</i>",
      "id": "c94e8425d73fb8f9a5af92c9f0b5bdb9"
    },
    {
      "type": "html",
      "text": "\nYes, exactly.",
      "id": "d1b8015d7493fad59b8ef764bceb093d"
    },
    {
      "type": "html",
      "text": "\n[[Smalltalk Blocks Are Thunks In Disguise]]",
      "id": "4f5b26f64ed6ed7ab13e585c931db560"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "\nI remember a professor once telling me that thunks were named after the sound made by a chain of activation records on the call stack.  Although it could it could have been some other X and Y for X=activation record and Y=call stack.  It was a long time ago. -- [[Michael Feathers]]",
      "id": "354dac265ce8a6597fcf28c75f4b93a0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "\nYes, and I have also read that the word 'thunk' was invented in the early hours of the morning after members of the Algol team had been up for hours struggling with how to implement call-by-name.  They had thought that information about the textual form of the parameter would be needed at run-time, causingvarious implementation problems.  Then eventually someone realised that it was possible to determine the relevant information at compile time, and put it into a function.  Thus the relevant information did not have to be thought out at run-time: there was a function holding the necessary information that the compiler had already thunk out at compile time. -- Michael Davis",
      "id": "238b3032a278ec637484fb5e7b128552"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "\nThis one created the hardest to find bug I have ever had.",
      "id": "498f9ab394c1f237442321f262c2cfbb"
    },
    {
      "type": "html",
      "text": "\nI called a routine like so :- myfunc(blah, bloo, rand());",
      "id": "b0f16399ce33824652ecccffc197cf98"
    },
    {
      "type": "html",
      "text": "\nHave you ever notice how your mind has an implicit hardwired expectation that the value of a parameter doesn't mystically change between read only references? ",
      "id": "a3d2e5c8588df5a96bfa691529e5532c"
    },
    {
      "type": "html",
      "text": "\nWell, with call-by-name, every time I referred to the third parameter it reevaluated rand() to a different random number.",
      "id": "6d59482e751823d129ef4612fbf2f1a5"
    },
    {
      "type": "html",
      "text": "\nBah!",
      "id": "b74a027a62eed9434735bcee16c19e45"
    },
    {
      "type": "html",
      "text": "\nDelayed evaluation would be a Good Thing, but [[Call By Name]] was evil.",
      "id": "ebbbbe18b1e5b774e65bb43bf544b939"
    },
    {
      "type": "html",
      "text": "-- [[John Carter]]",
      "id": "0bedee5b2a73ed0531fba082beb147e0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "\nI beg to differ.  This is an example where call-by-name was inappropriate: that doesn't mean it was evil in general.  There have been contexts in which I have WANTED a random number generator to produce different results on each evaluation, and have had to implement this in a more cumbersome way than I could have had call-by-name been available. -- Michael Davis",
      "id": "955cf854acd4ee17255854cddde2c9a5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "\n[[Call By Name]] was the result of putting the pure [[Beta Reduction]] rules of\nthe [[Lambda Calculus]] into an eagerly evaluated and impure programming language.\nNowadays, we have the call-by-value lambda-calculus, which models (unsurprisingly) [[Call By Value]].",
      "id": "1609bec28142a37c9a7d53422e27c551"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "\nIt could be pointed out that [[Call By Value]] can be implemented explicitly in a [[Call By Name]] language by binding the value of the argument to a local variable, then using that in lieu of the argument. Similarly, [[Call By Reference]] can be implemented explicitly by passing a pointer (if the language has them) and binding it locally. Of course, this is something of an ugly hack, and doesn't help when you expect [[Call By Value]] semantics by default. Even if you do think to do it, it is an extra step in the code, one which could all to easily be forgotten about in later code maintenance. That, plus the extra overhead of using thunks, makes it an undesirable as a default method of parameter passing. -- [[Jay Osako]]",
      "id": "f3f86f29a3c1e258f71e7e15c6963d76"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "I agree with Michael Davis.  When I wrote my own LISP interpreter many years ago (when they were hard to come by outside universities) I incorporated into it a call-by-name possibility along the lines of the Algol thunk.  However my default is the usual call-by-binding which is neither call-by-value nor call-by-reference exactly, but an argument must be preceded by the atom NAME to be called by name.  There is a distinction between call-by-reference in e.g. C and call-by-name as in Algol60. Call-by-binding has a call-by-reference flavour in that altering a list argument by surgery e.g. using NCONC or REPLACD, changes the value of the external variable.  It is like call-by-value in that the pointer of the external variable cannot be changed inside the function.  That can be done using call-by-name.  I still use this call-by-name facility to good effect e.g. in investigations of recursion in Church's Lambda Calculus.  An example of a more practical use is in setting properties of many atoms according to a standard format. -- Nick Thomas",
      "id": "d9be2b36d14a1eb13fbc13e3ae2abb31"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "[[Graham Hughes]] wrote: \"no other language to my knowledge has followed Algol's questionable lead here; even functional languages like Haskell, which has probably the most non-standard calling conventions of any modern language, evaluate their arguments at most once\".",
      "id": "8098da4cabd1f5c4c0e732c4f2def352"
    },
    {
      "type": "html",
      "text": "\nI remember that Simula (as Algol's son) allows call by name, but only if a parameter is explicitly declared with the \"name\" keyword. -- Gian Carlo Macchi",
      "id": "4a94b55c01230e0820c7d29fb4c72f9a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "The [[Cee Preprocessor]] uses call by name in the extreme. Not only does it re-evaluate arguments at every occurrence, it even reparses statements. For example, an argument \"a + b\", used in expression \"arg * 2\" makes it evaluate a + 2b, not 2(a+b).",
      "id": "56a2abbd33b0934443fb4cf0450bbf63"
    },
    {
      "type": "html",
      "text": "\nReinder",
      "id": "35f979f884b1953214607510d8faa662"
    },
    {
      "type": "html",
      "text": "<i>Of course, because you told him so. If you want parentheses, you have to write parentheses. a+b*2 != (a+b)*2</i>",
      "id": "b0d8857b1c29680c644375c324831b41"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "\"Algol 60 had the irritating misfeature of [[Call By Name]] arguments:\" -- Sorry, but I strongly disagree with the former statement. In my concept, call by name is one of the most powerful features of Algol60, timely expected for in newer programming languages. Finally, C#, VB.net and lately announced to be present in Java in the form of Lambda Calculus.",
      "id": "7d252a82b149f8d1276147363e43bf48"
    },
    {
      "type": "html",
      "text": "\nCarlos Lauterbach.",
      "id": "8a94e938fd41f999bdf12fcebfb054e0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "d35abb5f3d15f4abeb9b09f13251a779"
    },
    {
      "type": "html",
      "text": "[[Category Language Feature]] [[Category Algol]]",
      "id": "1b61e774cebe4e3f8a79ef6f683cae71"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?CallByName c2.com]",
      "id": "582f3e0ae8cce41ed92a73d82338a868"
    }
  ],
  "journal": [
    {
      "date": 1406639214000,
      "id": "a32d9c5ebe0fc46587b0ade8a43d3cb9",
      "type": "create",
      "item": {
        "title": "Call By Name",
        "story": [
          {
            "type": "html",
            "text": "A technical answer to the question \"[[What Isa Thunk]]?\" is that function arguments are evaluated in the called function, a la Algol 60 ([[Algol Sixty]]).",
            "id": "06d4efddcf3ef474775cc665997e7f56"
          },
          {
            "type": "html",
            "text": "\nAs an example:  When calling a function, if you pass a pointer to hooha() as the first parameter, then <i>every time</i> that first parameter is referenced in the function, hooha() will be called.  If hooha() does different things each time it's called (like rand() does), this can cause trouble.  It's a feature of some programming languages (anyone care to build a list?).",
            "id": "9eb29ab324dec02359a31019ecdfd650"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "\nI believe the original use of <i>thunk</i> comes from [[Algol Language]].  Algol 60 had the irritating misfeature of [[Call By Name]] arguments; when you called a function <i>Foo(1+2)</i> and it referred to its argument, it was forced to reevaluate 1+2 over and over again. ",
            "id": "bcd50b37f4db8744e020ea34e97dfd74"
          },
          {
            "type": "html",
            "text": "\nA thunk is a function pointer packaged up with some data, so you can call 1+2 in the caller's environment.  This was <i>so</i> annoying to compiler writers and users both that no other language to my knowledge has followed Algol's questionable lead here; even functional languages like Haskell, which has probably the most non-standard calling conventions of any modern language, evaluate their arguments at most once.",
            "id": "c20fa8b1c2973025597562fac25cf47b"
          },
          {
            "type": "html",
            "text": "-- [[Graham Hughes]]",
            "id": "b7c4ac50a439c8c5e0cc181f2b9b500a"
          },
          {
            "type": "html",
            "text": "<b>This misfeature was exploited in [[Jensens Device]]</b>",
            "id": "563224862f1942e9ded0f6e26f76e607"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "'Misfeature' is an interesting word.  I think that to refer to call-by-name as a misfeature of Algol is not 100% fair.  It seems to me that the problem was not the provision of [[Call By Name]], but rather the failure to provide [[Call By Reference]]. This meant that one was forced to use [[Call By Name]] in situations where it shouldn't have been necessary.  Also there are a few situations where [[Call By Name]] simply does not do the job that [[Call By Reference]] does.  (SWAP(i, a[i]) is the standard example).  If Algol had provided 3 options, namely call by value, name, AND reference then I doubt that anyone would have described [[Call By Name]] as a misfeature.",
            "id": "fbe178eaaeccc7b1e0f106365004644e"
          },
          {
            "type": "html",
            "text": "\nIn the few situations where it is appropriate, [[Call By Name]] is extremely useful.  You can achieve much the same effect in languages where it is possible to pass a function, or a pointer to a function, as a parameter, but this is at the expense of having to define a function for every expression you want to pass as a parameter.  I have never come across another language where the power of [[Call By Name]] is available to the programmer in such a direct and elegant way as in Algol.",
            "id": "27d47d0667d8454190160284dd0369b7"
          },
          {
            "type": "html",
            "text": "-- Michael Davis",
            "id": "04dc13e6febe14a710c4cd74d263e29d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "\nIf I remember correctly from previous work and education, the point of a Thunk is to delay evaluation of the thing thunked.  You can use this idea to emulate a sort of lazy evaluation.  Indeed, I think that is how it was first done in Lisp. -- [[Chris Booth]]",
            "id": "a459f173b6c70bda08dbd676e7f37415"
          },
          {
            "type": "html",
            "text": "<i>Like blocks in Smalltalk, then? -- [[John Clonts]]</i>",
            "id": "c94e8425d73fb8f9a5af92c9f0b5bdb9"
          },
          {
            "type": "html",
            "text": "\nYes, exactly.",
            "id": "d1b8015d7493fad59b8ef764bceb093d"
          },
          {
            "type": "html",
            "text": "\n[[Smalltalk Blocks Are Thunks In Disguise]]",
            "id": "4f5b26f64ed6ed7ab13e585c931db560"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "\nI remember a professor once telling me that thunks were named after the sound made by a chain of activation records on the call stack.  Although it could it could have been some other X and Y for X=activation record and Y=call stack.  It was a long time ago. -- [[Michael Feathers]]",
            "id": "354dac265ce8a6597fcf28c75f4b93a0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "\nYes, and I have also read that the word 'thunk' was invented in the early hours of the morning after members of the Algol team had been up for hours struggling with how to implement call-by-name.  They had thought that information about the textual form of the parameter would be needed at run-time, causingvarious implementation problems.  Then eventually someone realised that it was possible to determine the relevant information at compile time, and put it into a function.  Thus the relevant information did not have to be thought out at run-time: there was a function holding the necessary information that the compiler had already thunk out at compile time. -- Michael Davis",
            "id": "238b3032a278ec637484fb5e7b128552"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "\nThis one created the hardest to find bug I have ever had.",
            "id": "498f9ab394c1f237442321f262c2cfbb"
          },
          {
            "type": "html",
            "text": "\nI called a routine like so :- myfunc(blah, bloo, rand());",
            "id": "b0f16399ce33824652ecccffc197cf98"
          },
          {
            "type": "html",
            "text": "\nHave you ever notice how your mind has an implicit hardwired expectation that the value of a parameter doesn't mystically change between read only references? ",
            "id": "a3d2e5c8588df5a96bfa691529e5532c"
          },
          {
            "type": "html",
            "text": "\nWell, with call-by-name, every time I referred to the third parameter it reevaluated rand() to a different random number.",
            "id": "6d59482e751823d129ef4612fbf2f1a5"
          },
          {
            "type": "html",
            "text": "\nBah!",
            "id": "b74a027a62eed9434735bcee16c19e45"
          },
          {
            "type": "html",
            "text": "\nDelayed evaluation would be a Good Thing, but [[Call By Name]] was evil.",
            "id": "ebbbbe18b1e5b774e65bb43bf544b939"
          },
          {
            "type": "html",
            "text": "-- [[John Carter]]",
            "id": "0bedee5b2a73ed0531fba082beb147e0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "\nI beg to differ.  This is an example where call-by-name was inappropriate: that doesn't mean it was evil in general.  There have been contexts in which I have WANTED a random number generator to produce different results on each evaluation, and have had to implement this in a more cumbersome way than I could have had call-by-name been available. -- Michael Davis",
            "id": "955cf854acd4ee17255854cddde2c9a5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "\n[[Call By Name]] was the result of putting the pure [[Beta Reduction]] rules of\nthe [[Lambda Calculus]] into an eagerly evaluated and impure programming language.\nNowadays, we have the call-by-value lambda-calculus, which models (unsurprisingly) [[Call By Value]].",
            "id": "1609bec28142a37c9a7d53422e27c551"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "\nIt could be pointed out that [[Call By Value]] can be implemented explicitly in a [[Call By Name]] language by binding the value of the argument to a local variable, then using that in lieu of the argument. Similarly, [[Call By Reference]] can be implemented explicitly by passing a pointer (if the language has them) and binding it locally. Of course, this is something of an ugly hack, and doesn't help when you expect [[Call By Value]] semantics by default. Even if you do think to do it, it is an extra step in the code, one which could all to easily be forgotten about in later code maintenance. That, plus the extra overhead of using thunks, makes it an undesirable as a default method of parameter passing. -- [[Jay Osako]]",
            "id": "f3f86f29a3c1e258f71e7e15c6963d76"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "I agree with Michael Davis.  When I wrote my own LISP interpreter many years ago (when they were hard to come by outside universities) I incorporated into it a call-by-name possibility along the lines of the Algol thunk.  However my default is the usual call-by-binding which is neither call-by-value nor call-by-reference exactly, but an argument must be preceded by the atom NAME to be called by name.  There is a distinction between call-by-reference in e.g. C and call-by-name as in Algol60. Call-by-binding has a call-by-reference flavour in that altering a list argument by surgery e.g. using NCONC or REPLACD, changes the value of the external variable.  It is like call-by-value in that the pointer of the external variable cannot be changed inside the function.  That can be done using call-by-name.  I still use this call-by-name facility to good effect e.g. in investigations of recursion in Church's Lambda Calculus.  An example of a more practical use is in setting properties of many atoms according to a standard format. -- Nick Thomas",
            "id": "d9be2b36d14a1eb13fbc13e3ae2abb31"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "[[Graham Hughes]] wrote: \"no other language to my knowledge has followed Algol's questionable lead here; even functional languages like Haskell, which has probably the most non-standard calling conventions of any modern language, evaluate their arguments at most once\".",
            "id": "8098da4cabd1f5c4c0e732c4f2def352"
          },
          {
            "type": "html",
            "text": "\nI remember that Simula (as Algol's son) allows call by name, but only if a parameter is explicitly declared with the \"name\" keyword. -- Gian Carlo Macchi",
            "id": "4a94b55c01230e0820c7d29fb4c72f9a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "The [[Cee Preprocessor]] uses call by name in the extreme. Not only does it re-evaluate arguments at every occurrence, it even reparses statements. For example, an argument \"a + b\", used in expression \"arg * 2\" makes it evaluate a + 2b, not 2(a+b).",
            "id": "56a2abbd33b0934443fb4cf0450bbf63"
          },
          {
            "type": "html",
            "text": "\nReinder",
            "id": "35f979f884b1953214607510d8faa662"
          },
          {
            "type": "html",
            "text": "<i>Of course, because you told him so. If you want parentheses, you have to write parentheses. a+b*2 != (a+b)*2</i>",
            "id": "b0d8857b1c29680c644375c324831b41"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "\"Algol 60 had the irritating misfeature of [[Call By Name]] arguments:\" -- Sorry, but I strongly disagree with the former statement. In my concept, call by name is one of the most powerful features of Algol60, timely expected for in newer programming languages. Finally, C#, VB.net and lately announced to be present in Java in the form of Lambda Calculus.",
            "id": "7d252a82b149f8d1276147363e43bf48"
          },
          {
            "type": "html",
            "text": "\nCarlos Lauterbach.",
            "id": "8a94e938fd41f999bdf12fcebfb054e0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "d35abb5f3d15f4abeb9b09f13251a779"
          },
          {
            "type": "html",
            "text": "[[Category Language Feature]] [[Category Algol]]",
            "id": "1b61e774cebe4e3f8a79ef6f683cae71"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?CallByName c2.com]",
            "id": "582f3e0ae8cce41ed92a73d82338a868"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1644989220354
    }
  ]
}