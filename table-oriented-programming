{
  "title": "Table Oriented Programming",
  "story": [
    {
      "type": "html",
      "text": "Abbreviated \"TOP\" in some places.",
      "id": "6157c87e71a23b44873850e25b8745e0"
    },
    {
      "type": "html",
      "text": "\nLanguages or techniques that tend to view data as relational tables (or relational-influenced) and behavior as operations on such tables. Sometimes code is put into the table \"cells\". In many ways it is a kind of [[Collection Oriented Programming]].",
      "id": "93eb4d55110171fe0f8a81b1eeb7f091"
    },
    {
      "type": "html",
      "text": "\nSome [[Relational Weenie]]s, such as [[Top Mind]], feel that [[Table Oriented Programming]] is a direct competitor to [[Object Oriented Programming]]. Others feel that they are orthogonal. Past debates to try to settle this issue never came to a consensus.",
      "id": "6aa92981a29f35d0aafcd8f85b6d9abe"
    },
    {
      "type": "html",
      "text": "\nRelationship with SQL: Although few seem to believe SQL is the ideal query language to build TOP or anything else around (see [[Sql Flaws]]), its entrenchment in the industry suggests that TOP standards or tools either be built around SQL, or at least support it as an option.",
      "id": "f54856107a419219743d1adbd1a9d03c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "<b>Relational tables</b>  are not required, just a decision table. This is nothing more than an Arbitrary redefinition of language to hide the fact these are decision tables which are as old as programming it's self. ",
      "id": "efd807b7a291c0c36c8a4863844aad9c"
    },
    {
      "type": "html",
      "text": "{Nobody claimed it's brand new. See bottom illustration re Ada Lovelace. And it's not just about \"decision tables\". Decision tables are one component/technique of it, as described below. Also note that by some measures, the existing RDBMS are not \"true\" relational either. If that was a key goal, then one may want to focus on \"Relational Oriented Programming\" instead. However, I don't believe that would require overhauling most the general TOP techniques. If you believe otherwise, I'd like to see an example scenario. Hopefully that wouldn't rekindle the \"bag\" debate ([[Bag Versus Set Controversy Roadmap]]).}",
      "id": "f58f0540507cdf5a7103a34f6888ba9d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "<b>Discussion</b>",
      "id": "604ff3c2338c10c46bcb611c71ae0601"
    },
    {
      "type": "html",
      "text": "<b>Is there anything new here? Isn't this standard, Microsoft favored, [[Record Set]] based Programming? (See Fowler's PoEAA)</b>",
      "id": "731a44be2445e96d3d6d372bdf668dbb"
    },
    {
      "type": "html",
      "text": "\nOne open issue is whether the \"tableness\" should be directly built into a language, or instead be an add-on library to existing languages.",
      "id": "70b3571e0102e9fe28247fbd3dd33813"
    },
    {
      "type": "html",
      "text": "<i>It's not really an open issue, since what it should be isn't relevant... what's relevant is what it is, and most major languages do not have table support built in, it's always in the libraries. Arguing about what should be is pointless.</i>",
      "id": "738e11b36f7b6c52c11249ad46d54f38"
    },
    {
      "type": "html",
      "text": "\nIt is a name given to programming using a database and some procedural code. The term is an invention of [[Top Mind]] (\"top\"), and as such there are no communities, conferences, journals, publications, associations, consortia or well-known papers devoted to [[Table Oriented Programming]].",
      "id": "3ed9aa5c082b5bf0be2fa4270e280e1c"
    },
    {
      "type": "html",
      "text": " I have seen a book with something like \"table oriented programming\" in the title, and it talked about using logic tables for programming, somewhat similar to [[Control Table]]s, but with a heavier reliance on Booleans. However, I have not been able to find it online anywhere so far. It was published approximately in 1970 and the author was something like \"Goldstein\". But, I do kind of consider myself the \"[[Alan Kay]] of T.O.P.\" in that although I did not invent it, I did (attempt to) define, describe, and evangelize it. And I have seen it fairly often in the [[Ex Base]] community when I did [[Ex Base]] consulting at multiple companies; it just never had a clear name/identity. Real programmers were \"doing it\" even though they did not call it T.O.P. --[[Top Mind]]",
      "id": "18b0251a8de2d44f0120cba41bc1e1ae"
    },
    {
      "type": "html",
      "text": "<i>I still have no idea what [[Table Oriented Programming]] is. If it is simply code that uses [[Relational Algebra]], well I don't get why the syntax matters (i.e. procedural or object-oriented).</i>",
      "id": "08f38c9c82db074cead2917a25c84576"
    },
    {
      "type": "html",
      "text": "\nWhat it is, is a name for using a database and some procedural code to put up crud screens, while doing most of the work with SQL. Nothing special, basic first year programming stuff.",
      "id": "4813368ec6e8cb295fc128c1d8535524"
    },
    {
      "type": "html",
      "text": "{I don't know, most colleges tend to teach code-centric techniques, not data-centric techniques regardless of \"year\". And I see only a weak relationship with [[Crud Screen]]s, which is mostly a UI issue, not an underlying structure issue (although TOP tends to blur the tools used by both ends). And, Microsoft's approach is not very table-oriented in my observation. It tends to follow the flavor of the day. For example, the built-in \"objects\" of [[Microsoft Access]] (queries, macros, reports, etc.) could have been stored in a table-oriented way; in which case they could be queried just like any other table instead of for-each object iteration to access them via code. [[Fox Pro]] partially followed the TOP path, I would note. -t}",
      "id": "b0ff150756a81cb390dce90afa21bab0"
    },
    {
      "type": "html",
      "text": "<i>OO tends to do things in code that would be in tables under TOP. Generally one is more likely to store taxonomies, relationships, and structures in tables rather than in code under TOP. Inheritance is putting a taxonomy in code, for example. In TOP thinking this is a no-no because taxonomies are relative to use.</i>",
      "id": "730db96842a36fa26805af4052f934ee"
    },
    {
      "type": "html",
      "text": "\nIt sounds like [[Prolog Language]] would be an example of [[Table Oriented Programming]]: everything is represented as nary relations (tables) and code is represented as logical statements (with some procedural pollution) about those relations.",
      "id": "f7dbe1dbfc95f3240112d2ebe8571917"
    },
    {
      "type": "html",
      "text": "<i>[[Prolog Language]] and [[Relational Language]]s share many things in common.</i>",
      "id": "3b54acfe41e1653f2ffefd816dc2af29"
    },
    {
      "type": "html",
      "text": "\nWhat is it that distinguishes a [[Relational Language]] and [[Table Oriented Programming]] from [[Prolog Language]]?",
      "id": "0d0716dde7a6cf8fbae3d2440511d1da"
    },
    {
      "type": "html",
      "text": " Prolog has recursive queries, and hence is [[Turing Equivalent]], whereas [[Relational Language]]s do not and are not. Further, in Prolog relations are free form and highly dynamic; one need not create table headers before creating data tuples, and related to that, tables with many rows are comparatively rare in Prolog, while tables with single row are rare in [[Relational Language]]s. Prolog has much more general support for relations, but is vastly slower for the kinds of applications that RDBMS systems are typically used for. The two areas have an important theoretical link, but are largely non-overlapping in pragma. (Related: [[Dynamic Relational]])",
      "id": "16e6f17b24568722437c9dd385b78313"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "\nCharacteristics of [[Table Oriented Programming]]:",
      "id": "c4953495720c371f599f7162b0b954db"
    },
    {
      "type": "html",
      "text": " Heavy use of [[Data Dictionary]]s ",
      "id": "23a0671fe94cbd9471e59e9c36a9bc9f"
    },
    {
      "type": "html",
      "text": " Heavy use of [[Control Table]]s and table editors ([[Table Browser]]s) to store and manage business rules, categories, logic, configuration, and meta-data. ",
      "id": "f527dae6efe80834c2ff03583a91a01d"
    },
    {
      "type": "html",
      "text": " Closely related to [[Control Table]]s (above) is the belief that often it's best to manage code in tables <b>instead of files</b>. This often leads to criticism of file systems and file-oriented development tools. TOP proponents tend to find file systems \"primitive\". For examples, see [[International Ui Example]] and [[Separation And Grouping Are Archaic Concepts]] (source-code management discussion).",
      "id": "3b9a33904e1fe511a6c07aa390b1f5a4"
    },
    {
      "type": "html",
      "text": " A reliance on SQL or query languages to do a large part or majority of the processing.",
      "id": "2c423d8396fcb29ecc97e4bafd1fb2a5"
    },
    {
      "type": "html",
      "text": " Languages that are well-integrated with query languages and possibly table editors and [[Table Browser]]s.",
      "id": "fb2336fcb1e77cf3875f56e56eff05f7"
    },
    {
      "type": "html",
      "text": " Languages that support \"local\" and internal tables and/or query systems so that the boundary or conversion effort between local and RDBMS is relatively small.",
      "id": "f75ece6effdeb678ebcbb261d9cd8dfd"
    },
    {
      "type": "html",
      "text": " Tends to view tables as a near-universal data structure and de-emphasizes arrays, linked lists, pointer graphs, object graphs, etc. (See [[Are Tables General Purpose Structures]].)",
      "id": "a5c336f3262c289a016a049eb2c3bcae"
    },
    {
      "type": "html",
      "text": " A belief that tables bring about uniformity ",
      "id": "0bf68768caa814398aef6c06cf0d7002"
    },
    {
      "type": "html",
      "text": " A belief that tables better match human physiology and/or psychology (or at least a large enough percent of the population and/or application to make it a viable tool).",
      "id": "2321b658f3cd0a48e0d302f6f75b6005"
    },
    {
      "type": "html",
      "text": " A belief that APIs or their equivalent would be simpler and better if they used existing table-oriented standards and conventions. Example: [[Kiss Web Services]] is merely a web wrapper around SQL.",
      "id": "b5a2ccb1ed33b845464a03759c01eccd"
    },
    {
      "type": "html",
      "text": " Variations-on-a-theme tend to be represented as rows in tables or [[Control Tables]], often one row per variation, instead of code, such as where sub-classing in OOP and case/switch statements would otherwise be used. Blanks or nulls may represent \"parent\" or \"default\". ",
      "id": "a284733d563c61fb7bc324e3c209b972"
    },
    {
      "type": "html",
      "text": " Values [[Higher Order Function]]s used with collection-oriented idioms (although existing tools often don't support this well.) Imagine SQL similar to:",
      "id": "69715c0cd20fd08d581633477ab1dab1"
    },
    {
      "type": "code",
      "text": "      /* execute mySubroutine for each result row */\n      SELECT mySubroutine(st.columnA, st.ColumnB) \n      FROM stuff AS st\n      WHERE foo = bar  ",
      "id": "7899988e18eee4226524692877921204"
    },
    {
      "type": "html",
      "text": "\nIt is not intended to be a \"Boolean concept\", but rather a continuum. And it may not embrace SQL as the \"ultimate\" relational query language, but perhaps respects it as a \"good enough\" standard. Also, adherence to \"strict\" relational (as interpreted) may vary widely between supporters.",
      "id": "ad9a628e2933a63fad2bf9ea8c6ed018"
    },
    {
      "type": "html",
      "text": "\nThe industry sometimes uses the term \"data oriented\" or \"data-driven\" for systems and tools tied heavily to SQL and RDBMS.",
      "id": "72c793c50bf46cad7f8414d07a644303"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "<b>Q:</b> How do you justify that 'beliefs' are characteristic to a programming style? ",
      "id": "4ff7ee3a1cd910c47e4b9ae9da9eb385"
    },
    {
      "type": "html",
      "text": "<i>Good point. Some of the above perhaps belong below, in the \"Belief Policies\". I'll put refactoring on my to-do list.</i>",
      "id": "5bb1faf63b3c3f6bb0afd81ef0e3d1c8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "<b>Belief policies behind T.O.P.</b>",
      "id": "78a7cafdc6110a4eebfc8df3a00d5161"
    },
    {
      "type": "html",
      "text": "\n1. [[Data And Code Are The Same Thing]]. Programming code is simply a manifestation (view) of structures ([[Code Avoidance]]). To an interpreter, code is just data. [[Little Language]] is a productivity and abstraction technique to define a mini domain-specific language. With TOP, one is essentially doing the same kind of thing by creating a \"little interpreter\", a domain-specific interpreter. (However, it will usually have a more declarative feel than actual interpreter code.)",
      "id": "3dd64ecf9eea632f90cb76bbe329d127"
    },
    {
      "type": "html",
      "text": "<i>No one seems interested that code-centric approaches emphasize something different than data-centric approaches. I am having trouble putting this into words, but my experience tell me data-centric approaches yield data driven programs. TOP smells (to me) like data driven programming. In my experience, placing an emphasis on the data over the code created simpler, elegant designs that worked better than the structured, code-centric approaches. May the wiki please speak to this? I also note that [[Data Driven]] is a link into a sister site (which speaks to [[Data Driven]] testing); why such a vacuum here?</i> - jme",
      "id": "17ebbc6886b4659bfe4c14285a717309"
    },
    {
      "type": "html",
      "text": " When you say \"data driven\", do you mean [http://foldoc.org/foldoc.cgi?query=data+driven foldoc.org]? It doesn't sound like it.",
      "id": "be4085c9c9bf4e9b2970af1bfcf3e50b"
    },
    {
      "type": "html",
      "text": " <i>Data driven could also mean [[Collection Oriented Programming]]. There are many other \"types\" of collections (data structures) besides tables. Thus, [[Table Oriented Programming]] is more specific.</i>",
      "id": "f12f5ccd89292af1f785db434a638e1e"
    },
    {
      "type": "html",
      "text": "\n2. If we focus on data structures, then we should focus on finding the best structuring methods.",
      "id": "3b866aa6714cdedbd883e5bcf816edba"
    },
    {
      "type": "html",
      "text": " <i>Which raises the question: Best at what, exactly?</i>",
      "id": "3fb9fa9f366f83eaf083052b21d04f97"
    },
    {
      "type": "html",
      "text": " Perhaps this relates to [[Are Tables General Purpose Structures]]",
      "id": "7a48490e6d44afee6f9e0d85035697a6"
    },
    {
      "type": "html",
      "text": " It could also be said to relate to the age-old \"navigational\" ([[Navigational Database]]) versus relational structuring techniques. Codd and Bachman (sp?) battled it out in the mid 70's, and it still seems to be simmering with OO/XML versus relational today.",
      "id": "069f9ab46bf2cc7f51bdedb6fe8fdda7"
    },
    {
      "type": "html",
      "text": "\n3. The best data structuring method appears to be relational in most cases.  ",
      "id": "b3298310a31a3cfff13749efd0c00e91"
    },
    {
      "type": "html",
      "text": "(In practice, existing tools are not up to a full-blown table-centric approach, so compromises are in order.)",
      "id": "3507b08d8b8025a80e9c4fc23e96e1ba"
    },
    {
      "type": "html",
      "text": "\n4. There are more pre-package-able data-centric idioms than behavioral-centric idioms [[Data Idiom And Behavior Idiom Quantity]]. And thus if we shift our design to be data-centric, we can take advantage of these existing idioms to avoid reinventing the wheel and avoid relearning the idiom systems.",
      "id": "9ce425b4d33371399da18485b3e6fad9"
    },
    {
      "type": "html",
      "text": "\n5. <b>The Eyes Have It</b> - Information in tabular form is easier for most humans to relate to and digest. For example, patterns can be visually spotted in tables that would be more difficult in other approaches. Some kind of [[Table Browser]] and/or query language can be also used to transform tables (or views) to emphasize certain aspects. Contrast this with textual code which is pretty much stuck in the format that the original author provided. You are thus at the mercy of the originator's view. (Code browsers are essentially graph browsers, which sort of fill in the same kind of need, but \"navigational\" structures are generally more difficult to \"re-project\", and this is one of the reasons why [[Navigational Database]]s fell out of favor.)",
      "id": "01c86cfbb6b28d233ab6535014e08b15"
    },
    {
      "type": "html",
      "text": " I disagree with your premises / assumptions. (1) \"Navigational\" is about <b>API</b>, not about <b>structure</b>. One can certainly represent, transform, and query even [[Directed Graph]]s - which are about as 'navigational' as a 'structure' can feasibly get - in non-navigational manners. [[Navigational Database]] fell out of favor not so much because they used graphs/trees, but rather because they didn't much support whole-graph queries, joins, updates, and views. Navigational APIs view and surgically manipulate a database through a straw. (2) There are some interesting ways of organizing code in [[Graphical Programming Language]]s, Smalltalk IDEs, etc. that should be found among your \"other approaches\" but that seem to have been ignored, which makes your claim about tabular approaches quite dubious. Organizing code such that it's in much smaller chunks with implicit context such that they can be organized and rearranged at convenience is certainly feasible and worthy of pursuit, but you seem to suggest a dichotomy between 'tabular' vs. 'textual in files'.",
      "id": "1c5f6195c037c8d2cc922fd964e72b49"
    },
    {
      "type": "html",
      "text": " <i>Regarding (2), They have not really caught on, and I'm generally comparing the more common techniques to TOP. Feel free to create a topic to sing the praises of GPL's. Regarding (1), see [[Table Oriented Programming Discussion]].</i>",
      "id": "a6029887901db5cc4ca71463351ad6d6"
    },
    {
      "type": "html",
      "text": "\n6. Having [[More Than One Way To Present It]] is a good thing. With query tools and table browsers, it's relatively easy to transform one's view of table-ized info into a form more conducive to the task at hand. Contrast this with text files where you are more or less limited to the author's grouping and presentation of code. (Fancy IDE's can be more flexible, but they are essentially confirming [[Greencodds Tenth Rule Of Programming]].)",
      "id": "99b1e0438fa756690751dd15f0aa2d21"
    },
    {
      "type": "html",
      "text": "\n7. Tables are easier for most <b>power-users</b> to grok compared to linguistic-centric approaches, in part because of the ubiquity of spread-sheets. See [[Compiling Versus Meta Data Aid]].",
      "id": "283260562f29d6704290cb246c11eebb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "<b>One area where OO and procedural languages do not operate as well as relational are in operations done over collections or sets of the same object.</b>",
      "id": "27bc7679eb2652bc8ded3d89ffcfd99d"
    },
    {
      "type": "html",
      "text": "\nThe ways that OO, procedural, and functional languages support operations over collections are:",
      "id": "6e940fd00d96487d1924fc9cd82d4463"
    },
    {
      "type": "html",
      "text": " Write a separate loop (typically a for loop, but other variants are also used) for each operation and manually verify each loop is identical. A unique function or set of steps is embedded within the loop.",
      "id": "34fe05f4020c3d3de2b4a70836f01f06"
    },
    {
      "type": "html",
      "text": " Write a single loop but pass it a function as a parameter; each function must have the same signature. This can be done directly with functions in assembly, C, and C++ although the syntax is relatively obscure; one can use the \"...\" syntax or K&R C to avoid much or all of the signature restrictions. For OO languages, the function may be embedded in a function class and class member variables my be used in lieu of function parameters using a variant of the Visitor pattern.",
      "id": "3d97db1e283fe0ed4692fc793f6f2e3f"
    },
    {
      "type": "html",
      "text": " Use an [[Internal Iterator]] or [[External Iterator]] to iterate over the collection; the logic to be applied is inlined in the code.",
      "id": "3bc75975664039629b9f51afe2678e9f"
    },
    {
      "type": "html",
      "text": " Use [[Higher Order Function]]s (like mapcar/apply, fold/foldr/reduce) to iterate over the container (or reduce it), passing in a function to perform the necessary operation. For example, suppose we could execute a function for each record by having constructs borrowed from SQL such as ([[Page Anchor]]: exec_1):",
      "id": "c7a9eca25ee0016ba00b7a10d6f87d18"
    },
    {
      "type": "code",
      "text": "       EXECUTE myRoutine(columnA, columnB) FROM myTable WHERE x > y",
      "id": "df84ff0886a842cd239f12af26551a10"
    },
    {
      "type": "code",
      "text": "       // This version makes references clearer:",
      "id": "836ed2bd99bafce72099d52a97597c9a"
    },
    {
      "type": "code",
      "text": "       EXECUTE myRoutine(m.columnA, m.columnB) FROM myTable AS m WHERE m.x > m.y",
      "id": "ff2771b975f077c78460d8e0386c9995"
    },
    {
      "type": "html",
      "text": " (In practice, most systems don't directly support the above, but we can rely on similar constructs by convention.)",
      "id": "816b3a0a02634f1e46b6f530a951719c"
    },
    {
      "type": "html",
      "text": "\nIn comparison, SQL treats data inherently as a collection. All operations have the loop built into the language, compiler, or library so that the programmer does not need to explicitly code the loop nor take any unusual steps to pass a function to a loop.",
      "id": "3fcabbfab3584f459eae8b09e7974279"
    },
    {
      "type": "html",
      "text": "<i>Unfortunately, SQL isn't sufficient as a programming language for most tasks, so one must pull the data into memory and process with a real language, which puts us back to using loops and functions, or [[Higher Order Function]]s to process the data. Keep in mind that SQL is probably far from the ideal TOP language.</i>",
      "id": "fe58b30c6a8cc1bc02e7729663e33c9b"
    },
    {
      "type": "html",
      "text": "\nLanguage constructs and examples that support passing a function into a common loop:",
      "id": "087d6646b1db6d6a7a94be4b5ec6a26c"
    },
    {
      "type": "html",
      "text": " C++ STL for_each template",
      "id": "84e7362e723f2493ea6485012a4ca6b8"
    },
    {
      "type": "html",
      "text": " [[Java Script]] [Note: Using \"for in\" in [[Java Script]] loops over the properties of the object, not over it's elements, so for(each in a<b></b>List) won't work.]",
      "id": "2b2811edaaf3213eef79f8d18c8fb613"
    },
    {
      "type": "code",
      "text": "  Array.prototype.map=function(to''''''Run){\n  for(var index=0;index<this.length;index++)\n    to''''''Run(this[index]);\n  }",
      "id": "8099b6db12dec825f202db122093986b"
    },
    {
      "type": "code",
      "text": "  Array.prototype.filter=function(is''''''Condition){\n  var result = new Array();\n  for(var index=0;index<this.length;index++)\n    if(is''''''Condition(this[index]))\n    result.push(this[index]);\n  return result;\n  }",
      "id": "5b6a2f1cca266dd2d93638ca2ec78d56"
    },
    {
      "type": "html",
      "text": "To run over a collection, use the following:",
      "id": "789f3a30b00a10f7a870366a8f087aba"
    },
    {
      "type": "code",
      "text": "  a''''''List.map(function(each){each.Do''''''Something()});",
      "id": "b3c4409d91c95d0ef9926c8cb25eafe6"
    },
    {
      "type": "html",
      "text": "or",
      "id": "8787897d159fd6c9e39aa87537a4f3b1"
    },
    {
      "type": "code",
      "text": "  var the''''''Matches = a''''''List.filter(function(each){return each == \"some condition\"});",
      "id": "00c214fa0c53b815b28cca873f315838"
    },
    {
      "type": "html",
      "text": " [[Higher Order Function]]s in [[Functional Programming Language]]s and [[Multi Paradigm Languages]]",
      "id": "60b35f8df32f943345430a9224a4ad84"
    },
    {
      "type": "html",
      "text": " Smalltalk blocks",
      "id": "32840a77d0027c12d378c9b78235d6bb"
    },
    {
      "type": "html",
      "text": "a<b></b>List do:<br>[:each | each do<b></b>Something].",
      "id": "dde44c0cf571577e54a1a9f880260282"
    },
    {
      "type": "html",
      "text": "or",
      "id": "8787897d159fd6c9e39aa87537a4f3b1"
    },
    {
      "type": "code",
      "text": "  |the''''''Matches|\n  the''''''Matches := a''''''List select: [:each | each = 'some condition'].",
      "id": "e013c7064f189089d8fc65a33a869842"
    },
    {
      "type": "html",
      "text": " Java [[Inner Class]]es",
      "id": "907298e25246588a84763a47eeb2eb7c"
    },
    {
      "type": "html",
      "text": " foreach in [[Csharp Language]] and [[Java Language]] 1.5",
      "id": "ccef46d2792a4c9c64e46aa1f28e9623"
    },
    {
      "type": "html",
      "text": "\nEither way, they remove the need to ever have to manually write loops. Since you are passing functions to these methods, no other parameters are needed.",
      "id": "1ec8b57e9a5d6a4e37364e807e161ce4"
    },
    {
      "type": "html",
      "text": "<i>Why can one not merely derive a user collection class from some base collection class and from the class to be contained in the collection and have the user collection class then expose all methods from the base collection class? Without writing any additional code, one could call a method on the user collection class and it would automatically iterate through its collection, calling the same method on each member. For example, I could create a collection of text boxes and then call a Set<b></b>Background<b></b>Color(<b></b>new<b></b>Color) method on the collection and it would set the background color on all text boxes in the collection. -- [[Wayne Mack]]</i>",
      "id": "59d32ef757ec70889152e0a4b47471c5"
    },
    {
      "type": "html",
      "text": "[<i>Consider that that is easily done by a generic for<b></b>each or do method like so....</i>]",
      "id": "a3df2b8742553e4f67e40604f4e0b525"
    },
    {
      "type": "html",
      "text": "[<i>aTextBoxCollection.for<b></b>Each(function(each){each.backGroundColor=\"new<b></b>Color\"});</i>]",
      "id": "bf16fb092da38235082d5b9f06b40cf9"
    },
    {
      "type": "html",
      "text": "[<i>You don't really want specific methods as you suggest, you want generic ones that can take functions as parameters to specialize their behavior, they are much more flexible and require much less code to be written over the long run. A collection should not be concerned with the particulars of an operation, only that the operation needs to be applied to all it's members or some of it's members. Therefore we leave the operation open for extension by making the operation a parameter, and only write the loops on the collection.</i>]",
      "id": "4a2a634807a65165fefb39095ccef0e5"
    },
    {
      "type": "html",
      "text": "[One can and many do. I wouldn't inherit implementation from both the collection and the member classes, though. I might inherit implementation from the collection and interface from the member if that interface makes sense in the context of a collection. Usually I just use a collection that has a for<b></b>Each() method and pass it a closure/block/inner class instance that performs the desired behavior.]",
      "id": "fbb110097468374b15fb4b8c195a40af"
    },
    {
      "type": "html",
      "text": "\nWould you care to expand on why it is advantageous to implement methods on a collection outside of a collection class? (I guess the little light bulb just didn't go off in my head when I read the above comments.)",
      "id": "3558d494e0828df7eba402be64a46992"
    },
    {
      "type": "html",
      "text": "[I assume you mean the methods passed to \"forEach()\"? If so, those methods don't operate on a collection. They operate on members of a collection. \"forEach()\" makes them operate on every member of a collection.]",
      "id": "188bd60cd495d80de371e0b6fbb003b2"
    },
    {
      "type": "html",
      "text": "(Aside, I'm going to start to refactor the top of this section to eliminate bulk. If I lose any important content, please refactor back in.)",
      "id": "9b3d58c0b4dcc3511cd5c1c18af51934"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "\nJust an idea. It would be interesting to see a language that could do something like:",
      "id": "b210582fe8d8deeacb7905277438882a"
    },
    {
      "type": "code",
      "text": "  tableX.doStrategy() where [condition]",
      "id": "d012087438ecffa8aaad9ef7e840d1ce"
    },
    {
      "type": "html",
      "text": "This would be more or less equivalent to:",
      "id": "0ff3637dd0527a96ec3e2be786cd6f7b"
    },
    {
      "type": "code",
      "text": "  r = sqlQuery(\"select doStrategy from tableX where [condition]\")\n  while (row = getNext(r)) {\n    execute(row['doStrategy']);\n  }",
      "id": "9d27859029755e72864d8823f68b31de"
    },
    {
      "type": "html",
      "text": "Based roughly on concepts discussed in [[Eval Vs Polymorphism]].",
      "id": "32597e5e132b68dbd1b68d5dea98609b"
    },
    {
      "type": "html",
      "text": "That's why people rave about smalltalk's collections: that's exactly what you can do. Likewise, there are several libraries which wrap java's collections which let you do the same thing, and the whole thing is trivially easy with Lisp. Add [[List Comprehension]]s to the mix, and you even get the set algebra: \"[ doStrategy x y | x <- tableX, y <- tableY, condition x y]\".",
      "id": "18ebfc51e60848b879bcbec10d19f6cc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "\nThis might be a good place to start a discussion on what [[Bucky Pope]] of [[Ibm Thomas Jay Watson Research Center]] used to call \"class codes\" - maybe it has since reappeared under a new name. He noticed that you very often find code like:",
      "id": "c43e07d60556155e95f3c826bff12ee4"
    },
    {
      "type": "code",
      "text": "  IF PROVINCE = 'NB' OR PROVINCE = 'PEI' OR PROVINCE = 'NS'...",
      "id": "001097330ff488699ef2ddf18da2b89b"
    },
    {
      "type": "html",
      "text": "in programs. If you have many occurrences of this kind of thing, it becomes very hard to maintain. He advocated storing the attributes that you are interested in in tables, so this code becomes something like:",
      "id": "b0c6e7277b5ca570378158e01225bda2"
    },
    {
      "type": "code",
      "text": "  LOOK UP PROVINCE\n  IF PROVINCE IS MARITIME ...",
      "id": "2519347739e9d31d065a14e092142fbf"
    },
    {
      "type": "html",
      "text": "While this looks obvious in hindsight, especially to [[Table Oriented Programming]] people, it is surprising how often you see statements like the former in business applications. They just seem to grow, and it's hard to stamp them out once they take root!",
      "id": "d3abe19eb2bac913d2d3fa1f068c3560"
    },
    {
      "type": "html",
      "text": "\nI have just come across the [[Control Table]] page - it sounds very similar.",
      "id": "c7087e3602852e15efd791c27307a5ed"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "If someone were looking to design a new [[Top Based Language]], what would you consider to be necessary, what would you consider desirable, and what would you wish to avoid?",
      "id": "c5703c928617b7de3a395457f7e224ac"
    },
    {
      "type": "html",
      "text": "\nFirst-class relational operators would seem an obvious one, but would you implement them as a [[Relational Algebra]] or a relational calculus, or a combination of both?",
      "id": "3b28a2bdc96ad002e43416694773b9c2"
    },
    {
      "type": "html",
      "text": "\nWhat else would you want? Transaction management? List comprehensions? Shaped arrays? First-class [[Stored Procedures]], including possibly [[Recursively Stored Procedures]] (i.e., inner functions)? Higher-order functions (presumably operating on the [[Stored Procedures]])? would functions be both represented and implemented as tables, homoiconically (see [[Homoiconic Languages]])? What sort of syntax and semantics would you want?",
      "id": "f6aefd0221cf01104bd4ea51b05d82fc"
    },
    {
      "type": "html",
      "text": "\nIt also occurs to me that if you can have [[Recursively Stored Procedures]], and if you save a stored procedure's lexical environment in a table along with the code, and invoke it at need, you would have a [[Lexical Closure]] - which, since [[Closures And Objects Are Equivalent]], shows that the two paradigms must, on at least a theoretical level, be compatible. Similarly, if you can store a function's successor for later invocation, you could have continuations, in which case you wouldn't necessarily need the inner functions. Of course, using a table for this purpose implies the existence of persistent continuations, which is [[Just Wrong]]...",
      "id": "653e121d8bf5dc924fa1cd5fa65fbbea"
    },
    {
      "type": "html",
      "text": "<i>One has to be careful to design something that can be both big and small. For example, one should perhaps be able to use such a language or kit with [[Minimal Table]] abilities, but also plug in DB2 or Oracle if needed without code overhaul. I also think that as much as possible should be in libraries instead of hard-wired into the language. Thus, ideally the language would offer meta-language abilities so as to easily extend it. I would like to see Lisp reworked to be more palatable to the \"masses\". Java grew popular partly because it borrowed from people's C/C++ familiarity (for good or bad).</i>",
      "id": "e0aded129a03c306512f7c72e9916d94"
    },
    {
      "type": "html",
      "text": "\nGoddess Eris, it just occurred to me! TOP isn't a paradigm - it's a [[Meta Object Protocol]]! [[Top Mop]]! ;) -- [[Jay Osako]]",
      "id": "38a9eb5751064a565022c4c2602e4a49"
    },
    {
      "type": "html",
      "text": "<i>Well, I suppose everything could be defined in terms of [[Meta Object Protocols]], or any other [[Turing Complete]] paradigm for that matter. OO just has a psychological tilt toward behavior instead of declarative techniques and is not \"bound\" to relational rules. In the end it is all about psychology. -- top</i>",
      "id": "acd7de8f57ddb6bb170e742a789fe0ea"
    },
    {
      "type": "html",
      "text": "\nRelated: [[Masp Brainstorming]]",
      "id": "1cc1d12f5f460fd993c96051989028e8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "<b>Spreadsheet-Influenced Ideas</b>",
      "id": "3f3373794a95e8aec1daabc03d509941"
    },
    {
      "type": "html",
      "text": "\nI once got an email from a fellow table fan who suggested using spreadsheets, or at least a spreadsheet-like interface for programming. Initially I was not very warm to the idea, but looking for better ways to combine nimble tables with code, I am now warming up to the idea.",
      "id": "58b4de766b019685f6d7a77f2a63492a"
    },
    {
      "type": "html",
      "text": "\nMost spreadsheets allow text to flow into adjacent cells as long as there is nothing in those adjacent cells. Thus, long programming text will not cause problems. And, the cells can be used for indentation, which can avoid the [[Tab Munging]] problem that pure text keeps facing. If a section of code is indented 3 cells, then it is always indented 3 cells regardless of what edits it. Tabs versus spaces is no longer an issue.",
      "id": "7bee3295d24eff3cb15f77f58fec5fda"
    },
    {
      "type": "html",
      "text": "\nBut the biggest benefit is the ability to embed and define smaller tables inside \"code\". Think of them as \"table closures\".",
      "id": "730ff8a58cf5a42b3852618ccd39a5c7"
    },
    {
      "type": "html",
      "text": "\nHere is an example. First the non-spreadsheet version of the code:",
      "id": "d5d6f92aba1caa1dd026a83c5e8e278f"
    },
    {
      "type": "code",
      "text": "  // define column headers",
      "id": "7c00c11e8b7281a36c752d4e36283494"
    },
    {
      "type": "code",
      "text": "  addColumnHeader(\"Name\");\n  addColumnHeader(\"Student ID\");\n  if (authorized) {\n    addColumnHeader(\"SSN\");\n  }\n  addColumnHeader(\"Grade - GPA\");",
      "id": "0b57e7ad479af6525ce7d8a42f7ff664"
    },
    {
      "type": "code",
      "text": "  // loop for each student",
      "id": "739872f20f0a83281c9a9db09a65aae6"
    },
    {
      "type": "code",
      "text": "  while (row = getNextStudent()) {\n     outNewRow();\n     outColumn(row['name'], left, '');\n     if (authorized) {\n       outColumn(row['SSN'],'center','');\n     }\n     outColumn(row['studentID'],'right',''); \n     outColumn(row['GPA'],'right','#9.999'); \n  }",
      "id": "963071ace120fc09c6255a6288dc69e5"
    },
    {
      "type": "html",
      "text": "Spreadsheet version:",
      "id": "8a7c029a61d3323f1754501a0b5a41b7"
    },
    {
      "type": "code",
      "text": " A...B........C............D..........E........F\n ...............................................\n table rptCols // report column definitions\n ....F''''''ldName..Descript.....Alignment..Format...H''''''ideOption\n ....name.....Name.........left\n ....SSN...................center..............Yes\n ....studentID.............center\n ....GPA......Grade.-.GPA..right......#9.999\n end.table\n .\n loop on table rtpCols where not H''''''ideOption and authorized\n ....addColumnHeader(Descript)\n end loop\n .\n loop on table Students \n ....outNewRow()\n ....loop on table rptCols where not H''''''ideOption and authorized \n .............outColumn(&F''''''ldName, &Align, &Format)\n ....end loop\n end loop",
      "id": "e6589c189db74ac13184855789ef6fd8"
    },
    {
      "type": "html",
      "text": "(Dots only to prevent [[Tab Munging]])",
      "id": "2e159d944b1e7b683fd5f9d767e55621"
    },
    {
      "type": "html",
      "text": "\nThis is rough pseudo-code and not necessarily meant to promote a certain style of syntax. Also, in a real spreadsheet we would be able to see the cell grid, which would make the table much more clear. The \"loop on table\" structure is similar to [[Cold Fusion]]'s <CFloop query=\"foo\"> tag, which allows column scope within the tag. (However, perhaps such a feature should be allowed to be turned off if desired.) The instantiation of result set \"Students\" is not shown in either example. We may be able to factor the \"where\" criteria to one spot.",
      "id": "bdfc3ba0b1e39f36e088ab1f22e19649"
    },
    {
      "type": "html",
      "text": "\nBenefits:",
      "id": "2a80ba943e7e576275b0614b96e39c68"
    },
    {
      "type": "html",
      "text": " No quotes needed in table",
      "id": "4b928efc482c36f8b8663faeb8a78758"
    },
    {
      "type": "html",
      "text": " Stuff is aligned to help see patterns",
      "id": "fd00dfb23e5a4467bf6bd44bad2fbfa3"
    },
    {
      "type": "html",
      "text": " Adding new report fields can be done at one spot instead of two.",
      "id": "09345b6eca6abc384da1dcdae5cf9e0d"
    },
    {
      "type": "html",
      "text": " I personally find it better [[Separation Of Concerns]] and cleaner. Stuff about what is displayed is not mixed in with details on how to display it. The first half is declarative and the second half imperative for the most part.",
      "id": "40e225199699ff9f2b475f7b7a2111aa"
    },
    {
      "type": "html",
      "text": "\nI imagine some adjustments or additions would have to be made to spreadsheets to make them more useful for code editing and viewing. For example, one may have to keep resizing the cell (column) widths in order to view portions of the current screen. Maybe this can be automated. for example, pressing F6 may stretch all cells to fit all the information in the current screen, and pressing shift-F6 puts it back the way it was. Even in the example it is obvious that the indentation (cell width) for viewing tables tends to be different than the best for viewing code. Keep in mind that most spreadsheets display the current cell's contents at top, so that if any single cell is too large to show, it is relatively easy to put the cursor on it in order to see its full contents at top. ",
      "id": "4fc5ef0fce05fae1f12e930323ac546d"
    },
    {
      "type": "html",
      "text": "\nMaybe some way can be devised to alternate between a grid view and text mode in the same module (virtual or real). Maybe the browser can have \"start grid\"...\"end grid\" and \"start text\"...\"end text\" markers of some kind, and the editor would display that section in accordance. In an editor, it could kind of resemble the \"bands\" found in many report writers. One could slide the bands larger or smaller as needed, and a check-box in the band bar would determine whether it is a grid or text band. This would allow text where it is best used and grids where it is best used, but have them intermixed in the same view rather than going back and forth between the grid screen and the text screen that most approaches currently require. -- top",
      "id": "06a35dd77996f930015755796dc33f06"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "<b>[[Multi Threading]]</b>",
      "id": "50a243dabd2d3e3bb5a9d6ada6f6aa0e"
    },
    {
      "type": "html",
      "text": "\n[[Table Oriented Programming]] reduces the need for multi-threaded programming. One can launch independent processes or sub-processes that communicate entirely via tables. Most table engines and RDBMS have concurrency management built in, either with row and table locks, and/or with transactions. Since these are available in the table engine, adding them to a language is kind of a violation of [[Once And Only Once]]. However, this may not be effective for certain embedded or timing-sensitive applications. See [[Are Rdbms Slow]] for more on timing issues.",
      "id": "d317776e23b1e714f58bd53035e8ea05"
    },
    {
      "type": "html",
      "text": "  <i>WOW, that quite a claim. You do realize that Mulithreading  is about avoiding  process overhead right? And you know that not all threads need to share data, or that when they do it is always best to avoid threads right? An you are aware that message passing via queues tends to do the same thing right? And you know about pipes and  commercial messaging products like MQSeries right?  If you are using tables only to pass non persistent data there is something wrong with your design. If you are doing it to ensure delivery then you should consider if your protocol really needs to be stateful.</i> ",
      "id": "1035f2726c9f556ba157d57137868cf4"
    },
    {
      "type": "html",
      "text": " I'm not sure what you are getting at. Perhaps this discussion belongs under [[Table Oriented Synchronization]].",
      "id": "5a841bf4cd4bd204e08fa1515433d1bb"
    },
    {
      "type": "html",
      "text": "<i>This seems to be assuming that the database is necessarily provided by an external process. Integrating it with the language is likely to be both more efficient and more convenient, and personally I'd much rather do this in a language with good support for concurrency (say [[Erlang Language]] using the [[Mnesia Database]]), than try to avoid [[Multi Threading]]. -- [[David Sarah Hopwood]]</i>",
      "id": "96dba9b0fc88abf58ecb19a0040aa176"
    },
    {
      "type": "html",
      "text": "\nPerhaps, but then you lose multi-language ability. If you \"share\", every language then does not have to invent and perfect it all from scratch.",
      "id": "aeea3c5a6160668fff00914baa0ad79f"
    },
    {
      "type": "html",
      "text": "<i>Suppose we use n programming languages in a project, one of which acts as a hub to integrate components written in the other languages and to access a database. If the database is external, then the hub language is effectively SQL. I'm just suggesting using a real programming language as the hub instead. The number of inter-language interfaces is the same: n-1 in each case. -- dh</i>",
      "id": "27358d9121e0acdcd32bafafbff448f8"
    },
    {
      "type": "html",
      "text": "\nWhy would it be called the \"hub\" then?",
      "id": "2ca64ab7afba6d6eab6b31ad82aa33c9"
    },
    {
      "type": "html",
      "text": "<i>The central node in a star (a.k.a. [[Hub And Spoke]]) network is usually called the hub. \"Pivot\" would be another possible term. We use a star network because we don't want n*(n-1)/2 inter-language interfaces.</i>",
      "id": "48bd6e34dfc5ed2dfc8f1de25dccba5b"
    },
    {
      "type": "html",
      "text": "{So the only difference between that and a network is that the edge nodes are not allowed to talk directly to each other? Is that the only distinguishing feature you are suggesting? If not, what are the other distinguishing features?}",
      "id": "aaa9c19c1fd613085f89ef7f06d4fb65"
    },
    {
      "type": "html",
      "text": "\nOr use [[Flow Based Programming]], which can link together modules written in different languages, as well as reusable components that drive different services, e.g. SQL. In the first FBP implementation we had a reusable stream-to-stream component that drove the standard IBM Sort (or any vendor Sort that used the same call interface) - it was <i>much</i> more friendly than using the vanilla Sort because you could change the key on the fly, route data around it, etc. Similar comments apply to a reusable SQL component. -- [[Paul Morrison]]",
      "id": "477251f666e49b682b8a905a1da404d3"
    },
    {
      "type": "html",
      "text": "\nRelated, and perhaps a merge candidate: [[Table Oriented Synchronization]]",
      "id": "5e795a729ed5b2f1e447441408a41a50"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "<b>Tables All The Way Down</b>",
      "id": "e32db0667f4735b69f0f3d0db316620e"
    },
    {
      "type": "html",
      "text": "\nFrom [[When Do Schemas And Classes Deviate]]:",
      "id": "1ca7aeed890e81cf4dc05fadd53d4faa"
    },
    {
      "type": "html",
      "text": "\nRe: <i>nobody has managed to design a [[Table Oriented Programming]] language that's \"tables all the way down\", like [[Small Talk]] is objects.</i>",
      "id": "b2c68c2bc57e6e59759a77143314a5d9"
    },
    {
      "type": "html",
      "text": "\nTables are best used as a larger-scale structure than objects. Rather than everything <i>be</i> a table, a \"pure table\" arrangement would probably look more like everything is <i>in</i> a table one way or another. For example, every variable might be a row in a Variables table, every function defined in a Function table, etc. ",
      "id": "461f56d8c852bdad7c0092c22790ffef"
    },
    {
      "type": "html",
      "text": "\nThings like Microsoft's semi-generic bytecode interpreter ([[Common Language Runtime]]) is essentially a database, just not a relational database. A TOP approach would change that fact and toss the underlying [[Navigational Database]] for such a thing. But, [[Moores Law]] has not quite caught up yet. Source code is only one view among many possible of programs. It is about divorcing presentation from meaning, as described in [[Code Avoidance]]. ",
      "id": "935f2c0f7b7add210ca2e7767799b7a3"
    },
    {
      "type": "html",
      "text": "\nFurther, [[Dynamic Relational]] may be required to keep it flexible enough to be practical. So far there are no completely dynamic implementations. After all, Smalltalk is dynamic. Relational can be too. ",
      "id": "0a4687abd1cea9eae57cb764b8fb12c8"
    },
    {
      "type": "html",
      "text": "\nAnother issue is that maybe a yin-yang kind of relationship may be better than a single atomic \"type\". See [[Yin Yang Versus Singlism]] and [[Formulas Plus Attributes]].",
      "id": "48e5d47af91be2c2ddd675a364042525"
    },
    {
      "type": "html",
      "text": "-- top",
      "id": "d9151b45a1808fec9b43c444be6bd72f"
    },
    {
      "type": "html",
      "text": "<i>But I would be interested in seeing an implementation of a tables-all-the-way-down system. How could you represent functions? Functions lend themselves to hierarchical containment. Mathematically, a function is a mapping from a set to a set, and a table is a set, so could you map a table to another table? Could you have virtual tables that have an infinite number of rows (say for real-numbered values) and implement this mapping? I'm just pontificating here... this would be interesting to figure out.</i>",
      "id": "ba2380c2bbd8d832d1fd03d410e97671"
    },
    {
      "type": "html",
      "text": "\nUsing the mathematical definition of a function, a TOP language is almost trivial. A function is really a set of ordered pairs <a, b>, where a is a member of the domain (a set) and b is a member of the range (another set). This can be represented as a table with the two columns (domain, range). Functions of arity > 1 would just be represented as a table (arg1, arg2, arg3, ..., result).",
      "id": "a9263de946dacccf6d2610ffb200601e"
    },
    {
      "type": "html",
      "text": "\nThe problem is, the [[Set Theory]] definition of a function is very difficult to work with on a daily basis. You don't want to have to explicitly specify outputs for every input; that defeats the purpose of a computer. Go use a paper-and-pencil spreadsheet.",
      "id": "f534432c515c1b9216f9ec29da6aed70"
    },
    {
      "type": "html",
      "text": "\nInstead, most functions are defined as compositions - possibly recursive - of other functions. This is fairly easy to see in Lisp notation: (factorial n) = (cond ((= n 1) 1) (T (* n (factorial (- n 1))))). There're some tricky bits, like the conditional and the use of recursion, but these are all covered by [[Denotational Semantics]].",
      "id": "2704672d73105326e6cf892afa471c15"
    },
    {
      "type": "html",
      "text": "\nSomething like this is very hard to represent as a table. It's fundamentally hierarchical: functions are made of compositions of functions, which are themselves made of compositions of functions, etc. And for reasons of practicality, most of these intermediate compositions are unnamed. They're also denoted positionally by their position in the argument list. When you try to stuff this into a table, you basically end up with a [[Tree In Sql]].",
      "id": "dc8544dc27b2af829e93b39a31d328d2"
    },
    {
      "type": "html",
      "text": "<i>There is no need to </i>implement<i> a function as a table by listing every (argument, result) pair. A function could be represented like a table, i.e. every object </i>looks<i> like a table. After all SQL views look like a table, but are none (being views into one). Looking at a function as a table it would be easy (and difficult in other approaches) to get the domain and range of a function. Of course no every query on an function-table could be computed effectively let alone efficiently.</i>",
      "id": "c12c1476fb54f12c0159c2f4e606fb67"
    },
    {
      "type": "html",
      "text": "<i>I find it a worthwhile idea to combine such an approach with e.g. a [[Set Oriented Programming]] approach based on [[Prolog Language]]. Handling small set (in memory) and large sets (database) uniformly (possibly annotated with hints about size and atomicity) could provide a very elegant and safe way to implement critical financial applications.</i>",
      "id": "31448f83be35a0e767ce583e4aabf0f2"
    },
    {
      "type": "html",
      "text": "-- [[Gunnar Zarncke]]",
      "id": "7708f62d394716ca85493a10120f351c"
    },
    {
      "type": "html",
      "text": "\nPS. <i>It seems, this (same approach for large and small sets) has already been done: See [[Haskell Db]].</i> -- .gz\nPPS. See [[Prolog For Massive Data]]",
      "id": "e9af43db9cdcda42273bcbfb39e99114"
    },
    {
      "type": "html",
      "text": "\nThere is one exception: [[Continuation Passing Style]]. In CPS, every function call must appear in tail position, so no argument is itself a composition of function applications. The tree has been flattened out and labels assigned to every intermediate node, which is just what we need to store the full composition in a table. I'm very curious about a table-based CPS intermediate representation: it looks like there's a full mapping from CPS to relational tables, and this also encodes the complete call graph of the program. Closure analysis may be tricky though; most CPS representations store environment information in the lexical structure of the CPS representation, which would be lost on conversion to tables. If that can be encoded too, however, then you'll have the complete liveness graph of all registers encoded in the intermediate representation. This would let you do really efficient inter-procedural register allocation. -- [[Jonathan Tang]]",
      "id": "4422c4136132936a0f750172ee4945dd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "\nKeep in mind, a table is just one of several [[Ways To Express Relations]].",
      "id": "5554d1a327eb77bfbe0cc07d91011075"
    },
    {
      "type": "html",
      "text": "<i>Everything is probably equivalent to everything, if we want to go that route.</i>",
      "id": "c070818c789c42ef135c49c2ffb3375d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "\nI wonder if the compile-time-type-checking view is in direct conflict with TOP. A good portion of TOPs challengers are pro-[[Static Typing]] it seems. Heavy pre-run checking requires finding ways to limit the variations of \"queries\" or dispatching in order for the compiler to \"reason\" about them. Such tools lean toward hierarchies in order to limit the search tree on \"types\" and related variations. However, if one finds trees inherently limiting, the alternatives don't seem to offer enough regularity compared to trees to do pre-run pass-or-fail analysis. My view is that this simply reflects the real unescapable nature of the world ([[Life Isa Big Messy Graph]]) and that tree-based checking is a false and messy security. You can't compile the whole world. -- top",
      "id": "ad03906def1798693b18bfc4142041c2"
    },
    {
      "type": "html",
      "text": "<i>It's not in conflict or required; it's orthogonal. This is obvious if you have a sufficiently expressive type system. See also [[Four Out Of Five Rule]]. -- [[David Sarah Hopwood]]</i>",
      "id": "ffb822080e188862fe1eef15781ac654"
    },
    {
      "type": "html",
      "text": "\nI doubt there is such as thing as \"sufficiently expressive type system\", as described in [[There Are No Types]].",
      "id": "fd6fac638129be45b956f8b1691c54f8"
    },
    {
      "type": "html",
      "text": "<i>By \"sufficiently expressive type system\", I was talking about type systems that exist in practice, for example [[Soft Typing]] in [[Mr Spidey]].</i>",
      "id": "b81c3eefedb0f9aa09782f4b9e31774b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "\nLooks like someone's trying to cash-in: [http://www.tablecode.com/founders.htm www.tablecode.com]. And it's not [[Top Mind]].",
      "id": "bbc03d6fc4841c3575f621be4ed8f6d0"
    },
    {
      "type": "html",
      "text": "\nYou guys can fight over it. Lemme know who wins.",
      "id": "95277326a9d08c0362f3a8c00f85e320"
    },
    {
      "type": "html",
      "text": "<i>The patents often talk about \"objects in tables\". As long as nobody calls them objects, no problem. However, they also talks about \"code in tables\". Does this mean that \"Eval(myColumn)\" has been patented?</i>",
      "id": "834709dd2d1c5ce1e833bf02ff078ff1"
    },
    {
      "type": "html",
      "text": " Currently, the \"patent\" is merely a patent <i>application</i>, not a granted patent. And it is, as far as I can tell, utter [[Bull Shit]]; [[Top Mind]]s stuff appears to be [[Prior Art]] for much of it.",
      "id": "fd90d6c99fcb0b77f34c99d14c8d3863"
    },
    {
      "type": "html",
      "text": "\nAnyway, the guy claims to have \"invented\" [[Table Oriented Programming]]. While I can find references to him on the web that are earlier than 2004; I can't find anything older than last year on TOP.",
      "id": "d3bad43c23928463292e85ed40fe036e"
    },
    {
      "type": "html",
      "text": "\n[[The Pragmatic Programmer]] reportedly has content on the topic as well.",
      "id": "494a98ac7967fcc5164a279bab0f6b77"
    },
    {
      "type": "html",
      "text": "\n[[Joel On Software]] has a thread about this: [http://discuss.joelonsoftware.com/default.asp?joel.3.166265 discuss.joelonsoftware.com]",
      "id": "1da59dcd510c6956f1e953f3fe495884"
    },
    {
      "type": "html",
      "text": "\nThe Diabs have a paper up on ACM; the list of references is embarrassing: [http://portal.acm.org/citation.cfm?id=1094855.1094930#references portal.acm.org]",
      "id": "86f5b3a81ae2509b3cd1f009fa6b60e1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "\nWhile it isn't [[Table Oriented Programming]] per se (and I imagine that there is much prior art in [[Common Lisp Object System]] for this), a paper that [[Top Mind]] might find interesting:",
      "id": "873970000cbddc42adc5530373d02f44"
    },
    {
      "type": "html",
      "text": "\n[http://www.informatik.uni-ulm.de/rs/mitarbeiter/ch/publ/Heinlein:Goerigk:Kiel.Inf:2004.pdf www.informatik.uni-ulm.de]",
      "id": "93e7559cf4b05a8f9d2952cd2df53bbb"
    },
    {
      "type": "html",
      "text": "<i>Perhaps this link could go under [[Eval Vs Polymorphism]].</i>",
      "id": "ac83907ce83fa0bdaf55db612175fc55"
    },
    {
      "type": "html",
      "text": " A better location would be a more general page on dispatch techniques. Like many other things, the stuff in that paper is largely orthogonal to eval.",
      "id": "ede86108cacf5e53d5abb8da0c825b89"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "\nTop,",
      "id": "44a5030b17dd9e85484d9727f45a21bd"
    },
    {
      "type": "html",
      "text": "\nI'm curious: Did you edit the following article on [[Wiki Pedia]]? [http://en.wikipedia.org/wiki/Table-Oriented_Programming en.wikipedia.org]",
      "id": "4631467bd54553bf460da3b42cbd63cd"
    },
    {
      "type": "html",
      "text": "\nI didn't see any of your usual IPs (dslextreme) in the edit list, and you didn't post with a recognizable username. I <i>did</i> notice, however, your fingerprints on [http://en.wikipedia.org/wiki/Design_pattern_%28computer_science%29 en.wikipedia.org] and I'm curious: Why do you think that design patterns have anything to do with the OO-vs-relational debate? Were one to embrace TOP whole-hog; I'm <i>certain</i> that higher-level patterns would emerge. Many view design patterns as only relevant to OO; in my experience they are applicable to almost any programming paradigm. -- [[Scott Johnson]] (who edits Wikipedia as [http://en.wikipedia.org/wiki/User:EngineerScotty en.wikipedia.org], btw...)",
      "id": "8fbd610a8cc4956d1a03e148f5167a37"
    },
    {
      "type": "html",
      "text": "<i>I actually did not create the Table Oriented Programming topic over there. However, I do remember encountering it and making changes quite a long while back. I forgot all about it until you mentioned it. -- top</i>",
      "id": "09e9227775ec3b3592cabf83c0ebc17e"
    },
    {
      "type": "html",
      "text": "\nI see you did delete some vandalism from the page (vandalism which uttered your name in vain)... do you still prefer to not have your real name published? -- sj",
      "id": "eb06a4beff012aca5186ce813c20657c"
    },
    {
      "type": "html",
      "text": " He's been stating that preference for many years; there's no reason to assume that his policy has some built-in time limit that will expire at some random point. :-) -- Doug",
      "id": "01e68fbebfec89050143884c5f6a4e2f"
    },
    {
      "type": "html",
      "text": " If you go to the tablizer website, and look at the bottom of the pages, you'll see the following:",
      "id": "a1018f903ff49fa5172e2e9f184ff165"
    },
    {
      "type": "html",
      "text": " \"...Material  Copyright 1998...2005 by Findy Services and [Top's First Initial and Last Name]\"",
      "id": "46adc6573ad8da9c4f1edf3cee805b23"
    },
    {
      "type": "html",
      "text": "Plus, there seem to be quite a few guys on the net who try and \"out\" topmind wherever they can... if Top wants to keep his real name a secret, he does a rather poor job of it. :) <i> -- First letter S...</i> :-)",
      "id": "7da99287fa1db74f30fd358773a75812"
    },
    {
      "type": "html",
      "text": " <i>That's not the point. We all know what his real name is, and he knows that, and isn't trying to keep it a secret as such, he just does not like to be addressed by his real name, because it makes it overwhelmingly obvious who he is, as opposed to it simply being possible to find out his real name. Since his given rationale is to avoid threatening his career, this seems reasonable to me; a potential employer will search on his real name, <b>not</b> on [[Top Mind]], so his approach works perfectly well for that kind of thing. -- Doug</i>",
      "id": "1f5eaccca0013a5f91ff7e03efe432ea"
    },
    {
      "type": "html",
      "text": " Although, typing Top's real name into google produces the tablizer page as the first couple of results... -- sj",
      "id": "e7c3a6a59473c3c5ef4078d201ced4a2"
    },
    {
      "type": "html",
      "text": "Discussion moved to [[Real Names Please]].",
      "id": "1986ea8f1a8ec0cb90172ae2faa9cee2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "\nFor those of us sick of writing and manually managing essentially tabular data in an object-oriented language like C++, I'm interested in pursuing a [[Template Metaprogramming]] approach to auto-building tuples, tables of tuples, and indices within the C++ runtime, and maybe a [[Template Metaprogramming]] supported query language, too. Might be something boost-worthy. However, I ain't tacklin' that one alone. My main use of tables is when I need to index the same data N-ways from sunday, I almost always end up writing them by hand, and I rarely use joins (though I know how to go about it after writing the C++ version for [[Every Combination In Many Programming Languages]]).",
      "id": "ba97859e9a9e57841b8e49e030c85491"
    },
    {
      "type": "html",
      "text": "<i>The [[Sq Lite]] libraries are C-based. Perhaps you can incorporate them into your code.</i>",
      "id": "8b28ca30300be14162ac32210824bbd6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "\nWhen I coined \"table-oriented programming\", this is NOT what I had in mind: [[Befunge Language]] ([http://en.wikipedia.org/wiki/Befunge en.wikipedia.org])",
      "id": "ddcf7f6968e98d089a961af8b67271cf"
    },
    {
      "type": "html",
      "text": "\nThat is more like \"grid-oriented programming\". Grids are like 2D positional arrays and tables are like 2D associative arrays.",
      "id": "409a3d4a17f2bcb6f9005808e01c48df"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "Re: Quote: \"A belief that tables better match human physiology and/or psychology (or at least a large enough percent of the population to make it a viable tool).\"",
      "id": "c7e2e3f8020079dd3bd8d8b20327c7ed"
    },
    {
      "type": "html",
      "text": "\nPsychology has nothing to do with tables. Human psychology is oriented around depression, happiness, food, replication, sadness. The relational model was created to organize data effienciently and sensibly, not to tie in psychology of the human brain.  in fact one problem with bad programmers is that they let their emotions get in the way of truth - and truth is what computers are all about. If you want to model the human brain you'd be best looking into artificial intelligence and fuzzy logic. The relational model is very un-human and un-animal. It is infact extremely \"true or false\" oriented, centered more around the CPU \"bit\" where there is <b>0</b> or <b>1</b>.   Bringing psychology and anthropomorphisms into programming is extremely dangerous, because databases are not about human psychology. Databases are about correct data retrieval (would you want erroneous data?) that can be accessed efficiently and did I already say it, <b>correctly</b>.  Tables (relations) were invented so that data would be accessible in an efficient and correct manner. And by efficient I don't mean that your database is \"fast\", I mean efficient organization of data where one can look up how many customers live in so and so state or province without having to write tons of code (normalization helps significantly there). It has nothing to do with psychology. It's about accessing the data in the most efficient manner. And once again, by efficiency I do not mean the clock time.",
      "id": "c47ea280625fa0fe591f374defa1f4d8"
    },
    {
      "type": "html",
      "text": "<i>\"Psychology\" involves lots of things. Emotions is one of them. But there's also the \"perceptual\" side, that borders on physiology. I wish there was a better name for the aspect that we are considering here, but I haven't found it. Most people would agree that \"psychology affects grokkability\". Somewhere on this wiki is a discussion about whether relational is a \"natural\" property of our universe, like Pi, or whether it's somehow tied to human nature and human qualities. I suspect it's the latter. Machines and math don't \"care\" either way. Relational is merely a [[Useful Lie]] for humans. As far as \"correctness\", I'd use some form of relational even if it didn't have referential integrity etc. That's a nice bonus, but not the single magical factor. -t</i>",
      "id": "a09bcf2dc235ef84f2609e846859c63f"
    },
    {
      "type": "html",
      "text": "\nYou ought to do some research as to why the relational model was invented. It was invented to organize data, especially repetitive similarly structured data.  The relational model (tables) are tied to data, not some natural property of humans, but the natural properties of data. The natural properties of data are: often you will see repetitive entries (by repetitive I mean they all fit into a table - for data that doesn't have a common structure, that's where relational fails.. for example a GUI with a button, a panel, and a window - these don't all fit easily into a table and are better as single structures or objects (unless you had 3400 buttons on the screen that needed to be searched)). ",
      "id": "28a26010b432da39cd7f31f7f7db98c3"
    },
    {
      "type": "html",
      "text": "<i>I agree about the factoring part, but navigational ([[Navigational Database]]) can also be used to factor out repetition. Thus, relational has no monopoly there. I disagree that a table-oriented GUI is not possible. I even gave an example in [[Non Oop Gui Methodologies]]. Hardware wasn't up to the task when GUI's started, but may be now. Further, [[Dynamic Relational]] may be a better fit for such anyhow rather than the Oracle clones we have now. Further, a lot of \"kinds\" of widgets can be rolled up into just two \"types\" of widgets: singular and compound. The difference between a label, link, click-able image, and button are not sufficient to make them separate \"kinds\" of things. If I want to make an image click-able, I don't want to have to change it's type, I merely want to be able to be able to add clicking behavior/attributes to it. Viewing them through the smorgasbord model [see...damn-i-forgot-name] may give us more flexibility and combinations.  I agree that hard \"types\" may be a [[Useful Lie]], especially for newbies, but does not add to flexibility and reuse.</i>",
      "id": "39578fe26427e3505b880031f33e3afb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "[[Microsoft Access]] is \"proof by popularity\" that [[Table Oriented Programming]] works: entire small and medium-sized applications are often written in Access without using a single line of code (other than expressions, such as \">id\"), or at least very little. Many Access programmers don't even know VBA. That being said, I would do many things different if designing a better TOP C.R.U.D. thing-a-matic, the primary one being making all the application configuration, queries, settings, macros, etc. be full-blown tables that can be queried and analyzed by the DBMS like any other table can, not the proprietary hidden binary structures that MS often uses. It may have originally been done for efficiency reasons. For example, to allow lots of open-ended \"cells\", a Memo type would have to be used often, and these tend to be slow. More efficient auto-sizing would have to be explored. Existing RDBMS are tuned for data usage patterns, not config attributes. Table-based management of query parameters would also help. -t",
      "id": "4f42cc8669c951fa0aab8623827973d5"
    },
    {
      "type": "html",
      "text": "<i>At best, [[Microsoft Access]] is \"proof by popularity\" that desktop DBMSes using [[Query By Example]] and reasonably-usable built-in form and report painters plus an included implementation of [[Visual Basic]] for scripting and marketed by [[Micro Soft]] can be popular.  It says nothing about [[Table Oriented Programming]], whatever that is.  Arguably, what is being called \"[[Table Oriented Programming]]\" here is nothing more than using the [[Relational Model]], or something resembling it, to build applications.</i>",
      "id": "1f0ac7de2f707f3af778b9a181635578"
    },
    {
      "type": "html",
      "text": "\nI'm not talking about form and report painters, for basic (and esthetically ugly) apps can be built without ever touching them. Perhaps what I'm getting at is [[Attribute Oriented Programming]], which is a close relative of TOP. An entire app can be built by merely filling in attributes and attribute tables. Most if not all of the things in Access could be turned into tables or queries on tables, and many of them are. For example, the \"switchboard\" (menu panel) wizard creates a switchboard [[Control Table]], which is internally used to control the switchboard. The macro commands are also presented to the user as a table/grid (although I don't know if it's implemented as a table under the hood). And I've built basic [[Control Table]] based report writers for [[Ex Base]] with sub-grouping/totalling back in the ASCII days. Basic forms can also be done that way, if you don't mind meek aesthetics. Let's review:",
      "id": "e1ceb1dec175495786120bb50d5c34e8"
    },
    {
      "type": "html",
      "text": " Queries  Designed primarily via a [[Query By Example]]-based grid interface. These can be Select, Update, Insert, etc. queries. One can also edit queries as direct SQL if desired.",
      "id": "5ecc14df3b550f652d687f156368d769"
    },
    {
      "type": "html",
      "text": " Macros  Attribute-driven in macro designer grid. Could be or perhaps is table-ized under-the-hood. (Conditional expressions are also possible, but awkward in Access.) It's almost like a CRUD-oriented Assembler language, which is fine for short lists of commands.",
      "id": "0330a58a19a734d0a09f3811c43940a3"
    },
    {
      "type": "html",
      "text": " Menu Panels (\"switchboard\")  Table-driven under the hood. A wizard puts a GUI dialog interface over this table.",
      "id": "fcfbb04f39cdd69b6cb8a9d400d2f461"
    },
    {
      "type": "html",
      "text": " Data entry forms  One can use \"raw\" edit table views, or the drag-and-drop VB-like painter tools. However, these can also be done via table-driven interfaces, although MS-Access doesn't. (You'll just have to take my word for it.)",
      "id": "24264bfb512206e32a563c007308744c"
    },
    {
      "type": "html",
      "text": " Report writer  Access can \"auto-guess\" from edit table views, but otherwise uses a report painter. I built a table-driven report-writer back in the DOS days. It used a [[Data Dictionary]] with additional attributes for sub-grouping options, which somewhat resembled Access's query-builder when the \"totaling\" row is switched on.\nThus, all the basics of typical [[Crud Screen]] apps can be table- and query-based. Application programming code and screen/form painters are <i>not</i> necessary. (But even painter tools can store the design in tables. [[Fox Pro]] did this more or less under the hood.) Again, I'm not suggesting one always take the 100% TOP road. I'm only pointing out it's possible. A good many apps can be around 70%. Generally the low-use and internal forms and reports are made using TOP, and the high-use critical ones are more carefully tweaked and micro-managed using or assisted by application code. -top",
      "id": "1e5524780750a251c899a9f5e2155cd1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "\nIt is exceedingly unclear to me what [[Table Oriented Programming]] really 'means'. Proposed: ",
      "id": "67d235760bcc4e0a0463d0599589bb4c"
    },
    {
      "type": "html",
      "text": " Definition 1: Tables, Sets, or Relations are [[First Class]], and so are relational operations on these (union, join, select, etc.), and relations are used (idiomatically) instead of [[Composite Pattern]] for data. By [[First Class]], I mean: table-values may be anonymous, stored to variables in the language ([[Rel Var]]s), communicated as arguments, and returned. Consequences of using TOP under this definition:",
      "id": "9ab2ff37c40f9a38ec42ba614c4874a4"
    },
    {
      "type": "html",
      "text": " [[Table Oriented Programming]] is fully compatible with [[Object Oriented Programming]], [[Functional Programming]], [[Functional Reactive Programming]], [[Dataflow Programming]], etc. Some extensions are required mostly to support relational operations, and the language-implementation might do well to provide some automated optimizations (both query-optimizations, and storage/indexing optimizations for the ",
      "id": "606fc89ae95dbbf41b536c0b401fc40b"
    },
    {
      "type": "html",
      "text": " Need for [[Visitor Pattern]] is diminished.",
      "id": "9cd8866b213af47579ae3466267840e1"
    },
    {
      "type": "html",
      "text": " With tables being anonymous, it can be somewhat difficult to define relationships between 'tables' variables, such as [[Foreign Key]]s and [[Cascading Delete]] and consistency requirements. This is suitable for [[Dynamic Typing]], but one may wish to expand to something even broader for [[Static Typing]]: [[First Class]] 'database' objects where the [[Type System]] recognizes as a primitive values that can encompass <i>many</i> tables along with the relationships between them. ",
      "id": "869f6ac0656c53719ffff23244a11780"
    },
    {
      "type": "html",
      "text": " [[Persistent Language]] feature is possible, but occurs more along the lines of persistent [[Object Oriented]] language.",
      "id": "f47e0afa7033e3f4a60d05bc5bff586b"
    },
    {
      "type": "html",
      "text": " Integration with external RDBMS is unlikely, or at best 'indirect' (i.e. loading queries from remote tables into a local table-value, ideally lazily or at-need). It will likely require some mapping effort on the edge of the system (e.g. via a [[Foreign Function Interface]]). But if [[Persistent Language]] feature allows automatic re-establishment of communications, this problem will be greatly reduced.",
      "id": "2087bd5f1dafc1a368807f71069ebe60"
    },
    {
      "type": "html",
      "text": " Tables are subject to [[Object Capability Model]] security. That is, tables can be \"hidden\" within the process, fully encapsulated, inaccessible to DBAs and such unless made available through an IDE or debugger. Even if they are accessible, such tables will have semantics that depend heavily on context and who is using the table, so a DBA would need much detailed knowledge of the application to make sense of the multitude of tables.",
      "id": "26ca6437103fe2bbb2b2b0fb5f9c264e"
    },
    {
      "type": "html",
      "text": " Mutable-state communication can be avoided ([[Kill Mutable State]]) in favor of passing about immutable table values between components and processing them using pure functions. This can reduce need for ACID transactions, though some sort of [[Software Transactional Memory]] is still appropriate for the little mutable-state remaining. Whatever solution is used to protect mutable state for other variables is likely to protect mutable state for tables.",
      "id": "4766cf0eec19dfce93a230d0f1d29914"
    },
    {
      "type": "html",
      "text": " Definition 2: Tables, Sets, or Relations are [[Second Class]] (or at least used as such by [[Table Oriented Programming]]). That is, you can name these [[Rel Var]]s in a \"global\" space, as part of a program definition. You might be able to create temporary views or tables for processing (i.e. functions that take tables as arguments), but either you cannot return tables, or such [[First Class]] use of tables (i.e. creating a process that loops forever passing tables as arguments and assigning result-tables to local variables) is idiomatically discouraged by [[Table Oriented Programming]] in favor of communicating between components by shared-state mutation on globally identified tables. Consequences of using TOP under this definition:",
      "id": "8d25ba43e1e1960c04fc2d626881ebf6"
    },
    {
      "type": "html",
      "text": " Communication between components primarily by shared state in common tables closely matches the [[Blackboard Metaphor]] and [[Linda Tuple Spaces]] designs. Process-composition occurs as a flat architecture attached to a common database. Tables are used for [[Remote Procedure Call]], [[Inter Process Communication]], etc. Related: [[Table Oriented Synchronization]].",
      "id": "20cc7c1f136d87560f72f02fd3904769"
    },
    {
      "type": "html",
      "text": " Since all tables are named, their number doesn't vary wildly during program execution, and the names are in a global space, it is easy to describe and establish constraint-relationships between [[Rel Var]]s (including [[Foreign Key]], [[Cascading Delete]], etc.) that are often associated with RDBMS.",
      "id": "aca9bef55452be5afff71e32689a1a5f"
    },
    {
      "type": "html",
      "text": " Multiple instances of the same application need semantics for whether all instances share the same tables, or each application gets its own table. One might annotate this sort of information as part of defining the global [[Rel Var]]s (even going so far as to say a particular [[Rel Var]] corresponds to a particular [[Uniform Resource Identifier]] for an RDBMS). It may be that some tables are marked 'volatile' - gone with the wind the moment the application is killed.",
      "id": "edcd50f33028fe742b258acdfecd933b"
    },
    {
      "type": "html",
      "text": " Easy integration with RDBMS and local DBs (like [[Sq Lite]]). Easy persistence via such integration.",
      "id": "373ab1aea4d4a21cdd32e8853079b8a4"
    },
    {
      "type": "html",
      "text": " DBAs can get easy access to all the tables. Since they're \"global\", the table semantics are pretty much independent of context. This allows DBAs to easily understand and maintain tables. ",
      "id": "bae928a2c040d1bcb213918c9fdb186d"
    },
    {
      "type": "html",
      "text": " Challenged to handle two or more databases or data sources - distributed queries and distributed transactions to work with more than one RDBMS will be a serious challenge for implementors. This encourages the 'store everything into one uber-massive organization-global RDBMS' design. Ideally, it would even be world-global, but the security issues of this architecture forbid that.",
      "id": "ce4d89b340a25165706ec55b4969707f"
    },
    {
      "type": "html",
      "text": " Security-challenged architecture. By default, everyone has access to any table they can name. This is problematic given the above-described propensity to grow into truly organization-global tables. People have attempted to erect various forms of egg-shell security - i.e. passwords and such - to protect tables and data. If any component of a TOP application is compromised, in general all tables it has authority to interact with are compromised.",
      "id": "ddb97dfb2a602c37f27d136d39cae22a"
    },
    {
      "type": "html",
      "text": " The use of tables for [[Table Oriented Synchronization]] purposes creates considerable extra 'cleanup' and burden for the applications. It is rare that resources are sufficient to keep a complete history of everything every process does. More relevantly, general forms of [[Garbage Collection]] won't be able to take out tables in a global space, so it will be up to the processes to selectively delete rows from the global tables after taking the appropriate actions. All this exacerbates the egg-shell security problem, since any compromised process will have access to various shared IPC tables and can therefore compromise communications between all other processes. ",
      "id": "3a5140f6e1849cd2ea75c5b83998ca76"
    },
    {
      "type": "html",
      "text": " Transactions and persistence over tables, as they are, do not include the processes or communications. This can create some challenges if one wishes to perform <i>behaviors</i> atomically and persistently - all at once or not at all. This leads to patterns as seen in [[Mnesia Database]], where one creates tables that essentially track what each process is doing, what it plans to do next. This requires a great deal of explicit effort and explicit interactions with tables. Further, if persistence is the goal, then the table in question cannot be local and volatile to the application - it must be part of an RDBMS. (For security, this table at least could be local to an application to avoid granting other processes the ability to directly compromise program behavior.)",
      "id": "6d40af2dbc39908e5b56671e1b979f91"
    },
    {
      "type": "html",
      "text": " It is not possible for two or more independent processes or applications to coordinate a behaviors atomically: communication occurs through the database, but process A cannot see what process B is attempting to do atomically until AFTER process B commits its intent to the database. Because processes do not compose or coordinate atomically, each process will need to be monolithic in nature - i.e. process A will need to <i>include</i> the features of process B. Since monolithic processes need much more authority than fine-grained processes, they contribute to egg-shell security issues.",
      "id": "12fa96c2188bda9117e1ab2fb672eef3"
    },
    {
      "type": "html",
      "text": "\nIt has been my impression that what [[Top Mind]] really means when he discusses '[[Table Oriented Programming]]' is more along the lines of Definition 2. It isn't particularly compatible with [[Object Oriented Programming]], and it's a closer fit to the sort of situations he describes (i.e. relying on external RDBMS systems, procedural+relational, using RDBMS for persistence, etc.).",
      "id": "7f3b4d7fdfb1c02cca684e64c4ea92fe"
    },
    {
      "type": "html",
      "text": "<i>It has been my impression that what [[Top Mind]] really means when he discusses '[[Table Oriented Programming]]' is [[Ex Base]].</i>",
      "id": "447fff3b45234363f983ae99e2fbd099"
    },
    {
      "type": "html",
      "text": " [[Ex Base]] is a \"taste\" of a TOP-friendly language. I honed many of my TOP skills in it and I saw other [[Ex Base]] fans do the same. However, it still has a lot of warts in my opinion. I once kicked around a re-worked version of [[Ex Base]], but realized that a flexible enough general language with good libraries could do almost the same without having to hard-wire DB idioms into it. -t",
      "id": "a8cff65d02adf01b6052509458f35ebe"
    },
    {
      "type": "html",
      "text": "\nMaybe so. Either way, it seems to be a relatively limited vision of a programming model.",
      "id": "34b9267ccf8bf24c4f1ad951ad00e5d5"
    },
    {
      "type": "html",
      "text": "<i>Indeed.  It's more of a coding style than a programming model.</i>",
      "id": "248437fa762b4471634fd9da7ed2dafd"
    },
    {
      "type": "html",
      "text": "{The programming model can make TOP simpler and smoother, but I agree that it's not really about programming languages. However, one of you is a \"linguistical thinker\" I believe, and to such a person, everything may be \"about language\" because they think in language terms. I'm not sure how to translate this into linguistic-speak. If I was going to make the \"ultimate TOP language\", first we'd have to settle on whether we maximize for integration with existing RDBMS and SQL, or focus on an \"ideal\" (or alternative) relational system. And this includes deciding on compiler/type-heavy or dynamic-friendly designs. Ideally, a language or libraries would support \"local tables\" to supplement RDBMS usage that have language scoping rules more or less like arrays. (They can be emulated using nested maps and some API's that support a query language.) This is closer to the \"first class\" description above. As far as \"sharing\", at this point, I am happy to stick with [[Table Oriented Synchronization]] for concurrency issues. -t}",
      "id": "8f88f6c3304fe8537ba1df267f56537c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "After reading this page, I still do not really understand TOP. Thus, I will as a comparitive question. Programming only with functions is possible. Functions can be expressed as an ordered pairs, for example f(i)=i*i where 0<i<4 is the set {{1,1}, {2,4}, {3,9}}, which fits nicely into a table of two columns and three rows. Is this a trivial example TOP? --[[Edwin Earl Ross]]",
      "id": "5d206eb4542e3500fecd93b1001e931c"
    },
    {
      "type": "html",
      "text": "<i>Rather than strive for a hard-bordered definition, which will probably result in an endless [[Laynes Law]] battle, I'll try to present more examples in topics such as [[Viewing Algorithms As Collection Processing]].</i>",
      "id": "d9b2e64f8695bf4029159049c3b4b4ff"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "image",
      "url": "http://translab.burundi.sk/pix/33-1.gif",
      "text": "translab.burundi.sk",
      "id": "bc03f0afc790ef3c8c17d06fb4ccc903"
    },
    {
      "type": "html",
      "text": "[[Ada Lovelace]], the first Table Oriented Programmer?:\n",
      "id": "de2b004cf0b31b74c05d13bb8def641f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "See: [[Kay Language]], [[Array Oriented Language]], [[Control Table]], [[Data Dictionary]], [[Relational Database]], [[Fox Pro]], [[Set Theory]], [[Relational Algebra]], [[Source Code In Database]], [[Business Rules Metabase]], [[Set Oriented Programming]], [[Collection Oriented Programming]], [[Programming Paradigm]], [[Payroll Example]], [[Table Oriented Programming Discussion]], [[Embrace Sql]]",
      "id": "e9d4b9dff1f4397a13191cad64cf502c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8574409e7c491e53026a24b3bb6d4461"
    },
    {
      "type": "html",
      "text": "[[Category Programming Language]], [[Category Info Packaging]], [[Category Database]], [[Category Table]] [[Category Data Orientation]]",
      "id": "65d4ba373823efb73daa8e2f2f0b611a"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?TableOrientedProgramming c2.com]",
      "id": "7571083952605cc7880763b89d35776e"
    }
  ],
  "journal": [
    {
      "date": 1416946148000,
      "id": "4db79772529379e1f8abf5728c6ad7af",
      "type": "create",
      "item": {
        "title": "Table Oriented Programming",
        "story": [
          {
            "type": "html",
            "text": "Abbreviated \"TOP\" in some places.",
            "id": "6157c87e71a23b44873850e25b8745e0"
          },
          {
            "type": "html",
            "text": "\nLanguages or techniques that tend to view data as relational tables (or relational-influenced) and behavior as operations on such tables. Sometimes code is put into the table \"cells\". In many ways it is a kind of [[Collection Oriented Programming]].",
            "id": "93eb4d55110171fe0f8a81b1eeb7f091"
          },
          {
            "type": "html",
            "text": "\nSome [[Relational Weenie]]s, such as [[Top Mind]], feel that [[Table Oriented Programming]] is a direct competitor to [[Object Oriented Programming]]. Others feel that they are orthogonal. Past debates to try to settle this issue never came to a consensus.",
            "id": "6aa92981a29f35d0aafcd8f85b6d9abe"
          },
          {
            "type": "html",
            "text": "\nRelationship with SQL: Although few seem to believe SQL is the ideal query language to build TOP or anything else around (see [[Sql Flaws]]), its entrenchment in the industry suggests that TOP standards or tools either be built around SQL, or at least support it as an option.",
            "id": "f54856107a419219743d1adbd1a9d03c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "<b>Relational tables</b>  are not required, just a decision table. This is nothing more than an Arbitrary redefinition of language to hide the fact these are decision tables which are as old as programming it's self. ",
            "id": "efd807b7a291c0c36c8a4863844aad9c"
          },
          {
            "type": "html",
            "text": "{Nobody claimed it's brand new. See bottom illustration re Ada Lovelace. And it's not just about \"decision tables\". Decision tables are one component/technique of it, as described below. Also note that by some measures, the existing RDBMS are not \"true\" relational either. If that was a key goal, then one may want to focus on \"Relational Oriented Programming\" instead. However, I don't believe that would require overhauling most the general TOP techniques. If you believe otherwise, I'd like to see an example scenario. Hopefully that wouldn't rekindle the \"bag\" debate ([[Bag Versus Set Controversy Roadmap]]).}",
            "id": "f58f0540507cdf5a7103a34f6888ba9d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "<b>Discussion</b>",
            "id": "604ff3c2338c10c46bcb611c71ae0601"
          },
          {
            "type": "html",
            "text": "<b>Is there anything new here? Isn't this standard, Microsoft favored, [[Record Set]] based Programming? (See Fowler's PoEAA)</b>",
            "id": "731a44be2445e96d3d6d372bdf668dbb"
          },
          {
            "type": "html",
            "text": "\nOne open issue is whether the \"tableness\" should be directly built into a language, or instead be an add-on library to existing languages.",
            "id": "70b3571e0102e9fe28247fbd3dd33813"
          },
          {
            "type": "html",
            "text": "<i>It's not really an open issue, since what it should be isn't relevant... what's relevant is what it is, and most major languages do not have table support built in, it's always in the libraries. Arguing about what should be is pointless.</i>",
            "id": "738e11b36f7b6c52c11249ad46d54f38"
          },
          {
            "type": "html",
            "text": "\nIt is a name given to programming using a database and some procedural code. The term is an invention of [[Top Mind]] (\"top\"), and as such there are no communities, conferences, journals, publications, associations, consortia or well-known papers devoted to [[Table Oriented Programming]].",
            "id": "3ed9aa5c082b5bf0be2fa4270e280e1c"
          },
          {
            "type": "html",
            "text": " I have seen a book with something like \"table oriented programming\" in the title, and it talked about using logic tables for programming, somewhat similar to [[Control Table]]s, but with a heavier reliance on Booleans. However, I have not been able to find it online anywhere so far. It was published approximately in 1970 and the author was something like \"Goldstein\". But, I do kind of consider myself the \"[[Alan Kay]] of T.O.P.\" in that although I did not invent it, I did (attempt to) define, describe, and evangelize it. And I have seen it fairly often in the [[Ex Base]] community when I did [[Ex Base]] consulting at multiple companies; it just never had a clear name/identity. Real programmers were \"doing it\" even though they did not call it T.O.P. --[[Top Mind]]",
            "id": "18b0251a8de2d44f0120cba41bc1e1ae"
          },
          {
            "type": "html",
            "text": "<i>I still have no idea what [[Table Oriented Programming]] is. If it is simply code that uses [[Relational Algebra]], well I don't get why the syntax matters (i.e. procedural or object-oriented).</i>",
            "id": "08f38c9c82db074cead2917a25c84576"
          },
          {
            "type": "html",
            "text": "\nWhat it is, is a name for using a database and some procedural code to put up crud screens, while doing most of the work with SQL. Nothing special, basic first year programming stuff.",
            "id": "4813368ec6e8cb295fc128c1d8535524"
          },
          {
            "type": "html",
            "text": "{I don't know, most colleges tend to teach code-centric techniques, not data-centric techniques regardless of \"year\". And I see only a weak relationship with [[Crud Screen]]s, which is mostly a UI issue, not an underlying structure issue (although TOP tends to blur the tools used by both ends). And, Microsoft's approach is not very table-oriented in my observation. It tends to follow the flavor of the day. For example, the built-in \"objects\" of [[Microsoft Access]] (queries, macros, reports, etc.) could have been stored in a table-oriented way; in which case they could be queried just like any other table instead of for-each object iteration to access them via code. [[Fox Pro]] partially followed the TOP path, I would note. -t}",
            "id": "b0ff150756a81cb390dce90afa21bab0"
          },
          {
            "type": "html",
            "text": "<i>OO tends to do things in code that would be in tables under TOP. Generally one is more likely to store taxonomies, relationships, and structures in tables rather than in code under TOP. Inheritance is putting a taxonomy in code, for example. In TOP thinking this is a no-no because taxonomies are relative to use.</i>",
            "id": "730db96842a36fa26805af4052f934ee"
          },
          {
            "type": "html",
            "text": "\nIt sounds like [[Prolog Language]] would be an example of [[Table Oriented Programming]]: everything is represented as nary relations (tables) and code is represented as logical statements (with some procedural pollution) about those relations.",
            "id": "f7dbe1dbfc95f3240112d2ebe8571917"
          },
          {
            "type": "html",
            "text": "<i>[[Prolog Language]] and [[Relational Language]]s share many things in common.</i>",
            "id": "3b54acfe41e1653f2ffefd816dc2af29"
          },
          {
            "type": "html",
            "text": "\nWhat is it that distinguishes a [[Relational Language]] and [[Table Oriented Programming]] from [[Prolog Language]]?",
            "id": "0d0716dde7a6cf8fbae3d2440511d1da"
          },
          {
            "type": "html",
            "text": " Prolog has recursive queries, and hence is [[Turing Equivalent]], whereas [[Relational Language]]s do not and are not. Further, in Prolog relations are free form and highly dynamic; one need not create table headers before creating data tuples, and related to that, tables with many rows are comparatively rare in Prolog, while tables with single row are rare in [[Relational Language]]s. Prolog has much more general support for relations, but is vastly slower for the kinds of applications that RDBMS systems are typically used for. The two areas have an important theoretical link, but are largely non-overlapping in pragma. (Related: [[Dynamic Relational]])",
            "id": "16e6f17b24568722437c9dd385b78313"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "\nCharacteristics of [[Table Oriented Programming]]:",
            "id": "c4953495720c371f599f7162b0b954db"
          },
          {
            "type": "html",
            "text": " Heavy use of [[Data Dictionary]]s ",
            "id": "23a0671fe94cbd9471e59e9c36a9bc9f"
          },
          {
            "type": "html",
            "text": " Heavy use of [[Control Table]]s and table editors ([[Table Browser]]s) to store and manage business rules, categories, logic, configuration, and meta-data. ",
            "id": "f527dae6efe80834c2ff03583a91a01d"
          },
          {
            "type": "html",
            "text": " Closely related to [[Control Table]]s (above) is the belief that often it's best to manage code in tables <b>instead of files</b>. This often leads to criticism of file systems and file-oriented development tools. TOP proponents tend to find file systems \"primitive\". For examples, see [[International Ui Example]] and [[Separation And Grouping Are Archaic Concepts]] (source-code management discussion).",
            "id": "3b9a33904e1fe511a6c07aa390b1f5a4"
          },
          {
            "type": "html",
            "text": " A reliance on SQL or query languages to do a large part or majority of the processing.",
            "id": "2c423d8396fcb29ecc97e4bafd1fb2a5"
          },
          {
            "type": "html",
            "text": " Languages that are well-integrated with query languages and possibly table editors and [[Table Browser]]s.",
            "id": "fb2336fcb1e77cf3875f56e56eff05f7"
          },
          {
            "type": "html",
            "text": " Languages that support \"local\" and internal tables and/or query systems so that the boundary or conversion effort between local and RDBMS is relatively small.",
            "id": "f75ece6effdeb678ebcbb261d9cd8dfd"
          },
          {
            "type": "html",
            "text": " Tends to view tables as a near-universal data structure and de-emphasizes arrays, linked lists, pointer graphs, object graphs, etc. (See [[Are Tables General Purpose Structures]].)",
            "id": "a5c336f3262c289a016a049eb2c3bcae"
          },
          {
            "type": "html",
            "text": " A belief that tables bring about uniformity ",
            "id": "0bf68768caa814398aef6c06cf0d7002"
          },
          {
            "type": "html",
            "text": " A belief that tables better match human physiology and/or psychology (or at least a large enough percent of the population and/or application to make it a viable tool).",
            "id": "2321b658f3cd0a48e0d302f6f75b6005"
          },
          {
            "type": "html",
            "text": " A belief that APIs or their equivalent would be simpler and better if they used existing table-oriented standards and conventions. Example: [[Kiss Web Services]] is merely a web wrapper around SQL.",
            "id": "b5a2ccb1ed33b845464a03759c01eccd"
          },
          {
            "type": "html",
            "text": " Variations-on-a-theme tend to be represented as rows in tables or [[Control Tables]], often one row per variation, instead of code, such as where sub-classing in OOP and case/switch statements would otherwise be used. Blanks or nulls may represent \"parent\" or \"default\". ",
            "id": "a284733d563c61fb7bc324e3c209b972"
          },
          {
            "type": "html",
            "text": " Values [[Higher Order Function]]s used with collection-oriented idioms (although existing tools often don't support this well.) Imagine SQL similar to:",
            "id": "69715c0cd20fd08d581633477ab1dab1"
          },
          {
            "type": "code",
            "text": "      /* execute mySubroutine for each result row */\n      SELECT mySubroutine(st.columnA, st.ColumnB) \n      FROM stuff AS st\n      WHERE foo = bar  ",
            "id": "7899988e18eee4226524692877921204"
          },
          {
            "type": "html",
            "text": "\nIt is not intended to be a \"Boolean concept\", but rather a continuum. And it may not embrace SQL as the \"ultimate\" relational query language, but perhaps respects it as a \"good enough\" standard. Also, adherence to \"strict\" relational (as interpreted) may vary widely between supporters.",
            "id": "ad9a628e2933a63fad2bf9ea8c6ed018"
          },
          {
            "type": "html",
            "text": "\nThe industry sometimes uses the term \"data oriented\" or \"data-driven\" for systems and tools tied heavily to SQL and RDBMS.",
            "id": "72c793c50bf46cad7f8414d07a644303"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "<b>Q:</b> How do you justify that 'beliefs' are characteristic to a programming style? ",
            "id": "4ff7ee3a1cd910c47e4b9ae9da9eb385"
          },
          {
            "type": "html",
            "text": "<i>Good point. Some of the above perhaps belong below, in the \"Belief Policies\". I'll put refactoring on my to-do list.</i>",
            "id": "5bb1faf63b3c3f6bb0afd81ef0e3d1c8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "<b>Belief policies behind T.O.P.</b>",
            "id": "78a7cafdc6110a4eebfc8df3a00d5161"
          },
          {
            "type": "html",
            "text": "\n1. [[Data And Code Are The Same Thing]]. Programming code is simply a manifestation (view) of structures ([[Code Avoidance]]). To an interpreter, code is just data. [[Little Language]] is a productivity and abstraction technique to define a mini domain-specific language. With TOP, one is essentially doing the same kind of thing by creating a \"little interpreter\", a domain-specific interpreter. (However, it will usually have a more declarative feel than actual interpreter code.)",
            "id": "3dd64ecf9eea632f90cb76bbe329d127"
          },
          {
            "type": "html",
            "text": "<i>No one seems interested that code-centric approaches emphasize something different than data-centric approaches. I am having trouble putting this into words, but my experience tell me data-centric approaches yield data driven programs. TOP smells (to me) like data driven programming. In my experience, placing an emphasis on the data over the code created simpler, elegant designs that worked better than the structured, code-centric approaches. May the wiki please speak to this? I also note that [[Data Driven]] is a link into a sister site (which speaks to [[Data Driven]] testing); why such a vacuum here?</i> - jme",
            "id": "17ebbc6886b4659bfe4c14285a717309"
          },
          {
            "type": "html",
            "text": " When you say \"data driven\", do you mean [http://foldoc.org/foldoc.cgi?query=data+driven foldoc.org]? It doesn't sound like it.",
            "id": "be4085c9c9bf4e9b2970af1bfcf3e50b"
          },
          {
            "type": "html",
            "text": " <i>Data driven could also mean [[Collection Oriented Programming]]. There are many other \"types\" of collections (data structures) besides tables. Thus, [[Table Oriented Programming]] is more specific.</i>",
            "id": "f12f5ccd89292af1f785db434a638e1e"
          },
          {
            "type": "html",
            "text": "\n2. If we focus on data structures, then we should focus on finding the best structuring methods.",
            "id": "3b866aa6714cdedbd883e5bcf816edba"
          },
          {
            "type": "html",
            "text": " <i>Which raises the question: Best at what, exactly?</i>",
            "id": "3fb9fa9f366f83eaf083052b21d04f97"
          },
          {
            "type": "html",
            "text": " Perhaps this relates to [[Are Tables General Purpose Structures]]",
            "id": "7a48490e6d44afee6f9e0d85035697a6"
          },
          {
            "type": "html",
            "text": " It could also be said to relate to the age-old \"navigational\" ([[Navigational Database]]) versus relational structuring techniques. Codd and Bachman (sp?) battled it out in the mid 70's, and it still seems to be simmering with OO/XML versus relational today.",
            "id": "069f9ab46bf2cc7f51bdedb6fe8fdda7"
          },
          {
            "type": "html",
            "text": "\n3. The best data structuring method appears to be relational in most cases.  ",
            "id": "b3298310a31a3cfff13749efd0c00e91"
          },
          {
            "type": "html",
            "text": "(In practice, existing tools are not up to a full-blown table-centric approach, so compromises are in order.)",
            "id": "3507b08d8b8025a80e9c4fc23e96e1ba"
          },
          {
            "type": "html",
            "text": "\n4. There are more pre-package-able data-centric idioms than behavioral-centric idioms [[Data Idiom And Behavior Idiom Quantity]]. And thus if we shift our design to be data-centric, we can take advantage of these existing idioms to avoid reinventing the wheel and avoid relearning the idiom systems.",
            "id": "9ce425b4d33371399da18485b3e6fad9"
          },
          {
            "type": "html",
            "text": "\n5. <b>The Eyes Have It</b> - Information in tabular form is easier for most humans to relate to and digest. For example, patterns can be visually spotted in tables that would be more difficult in other approaches. Some kind of [[Table Browser]] and/or query language can be also used to transform tables (or views) to emphasize certain aspects. Contrast this with textual code which is pretty much stuck in the format that the original author provided. You are thus at the mercy of the originator's view. (Code browsers are essentially graph browsers, which sort of fill in the same kind of need, but \"navigational\" structures are generally more difficult to \"re-project\", and this is one of the reasons why [[Navigational Database]]s fell out of favor.)",
            "id": "01c86cfbb6b28d233ab6535014e08b15"
          },
          {
            "type": "html",
            "text": " I disagree with your premises / assumptions. (1) \"Navigational\" is about <b>API</b>, not about <b>structure</b>. One can certainly represent, transform, and query even [[Directed Graph]]s - which are about as 'navigational' as a 'structure' can feasibly get - in non-navigational manners. [[Navigational Database]] fell out of favor not so much because they used graphs/trees, but rather because they didn't much support whole-graph queries, joins, updates, and views. Navigational APIs view and surgically manipulate a database through a straw. (2) There are some interesting ways of organizing code in [[Graphical Programming Language]]s, Smalltalk IDEs, etc. that should be found among your \"other approaches\" but that seem to have been ignored, which makes your claim about tabular approaches quite dubious. Organizing code such that it's in much smaller chunks with implicit context such that they can be organized and rearranged at convenience is certainly feasible and worthy of pursuit, but you seem to suggest a dichotomy between 'tabular' vs. 'textual in files'.",
            "id": "1c5f6195c037c8d2cc922fd964e72b49"
          },
          {
            "type": "html",
            "text": " <i>Regarding (2), They have not really caught on, and I'm generally comparing the more common techniques to TOP. Feel free to create a topic to sing the praises of GPL's. Regarding (1), see [[Table Oriented Programming Discussion]].</i>",
            "id": "a6029887901db5cc4ca71463351ad6d6"
          },
          {
            "type": "html",
            "text": "\n6. Having [[More Than One Way To Present It]] is a good thing. With query tools and table browsers, it's relatively easy to transform one's view of table-ized info into a form more conducive to the task at hand. Contrast this with text files where you are more or less limited to the author's grouping and presentation of code. (Fancy IDE's can be more flexible, but they are essentially confirming [[Greencodds Tenth Rule Of Programming]].)",
            "id": "99b1e0438fa756690751dd15f0aa2d21"
          },
          {
            "type": "html",
            "text": "\n7. Tables are easier for most <b>power-users</b> to grok compared to linguistic-centric approaches, in part because of the ubiquity of spread-sheets. See [[Compiling Versus Meta Data Aid]].",
            "id": "283260562f29d6704290cb246c11eebb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "<b>One area where OO and procedural languages do not operate as well as relational are in operations done over collections or sets of the same object.</b>",
            "id": "27bc7679eb2652bc8ded3d89ffcfd99d"
          },
          {
            "type": "html",
            "text": "\nThe ways that OO, procedural, and functional languages support operations over collections are:",
            "id": "6e940fd00d96487d1924fc9cd82d4463"
          },
          {
            "type": "html",
            "text": " Write a separate loop (typically a for loop, but other variants are also used) for each operation and manually verify each loop is identical. A unique function or set of steps is embedded within the loop.",
            "id": "34fe05f4020c3d3de2b4a70836f01f06"
          },
          {
            "type": "html",
            "text": " Write a single loop but pass it a function as a parameter; each function must have the same signature. This can be done directly with functions in assembly, C, and C++ although the syntax is relatively obscure; one can use the \"...\" syntax or K&R C to avoid much or all of the signature restrictions. For OO languages, the function may be embedded in a function class and class member variables my be used in lieu of function parameters using a variant of the Visitor pattern.",
            "id": "3d97db1e283fe0ed4692fc793f6f2e3f"
          },
          {
            "type": "html",
            "text": " Use an [[Internal Iterator]] or [[External Iterator]] to iterate over the collection; the logic to be applied is inlined in the code.",
            "id": "3bc75975664039629b9f51afe2678e9f"
          },
          {
            "type": "html",
            "text": " Use [[Higher Order Function]]s (like mapcar/apply, fold/foldr/reduce) to iterate over the container (or reduce it), passing in a function to perform the necessary operation. For example, suppose we could execute a function for each record by having constructs borrowed from SQL such as ([[Page Anchor]]: exec_1):",
            "id": "c7a9eca25ee0016ba00b7a10d6f87d18"
          },
          {
            "type": "code",
            "text": "       EXECUTE myRoutine(columnA, columnB) FROM myTable WHERE x > y",
            "id": "df84ff0886a842cd239f12af26551a10"
          },
          {
            "type": "code",
            "text": "       // This version makes references clearer:",
            "id": "836ed2bd99bafce72099d52a97597c9a"
          },
          {
            "type": "code",
            "text": "       EXECUTE myRoutine(m.columnA, m.columnB) FROM myTable AS m WHERE m.x > m.y",
            "id": "ff2771b975f077c78460d8e0386c9995"
          },
          {
            "type": "html",
            "text": " (In practice, most systems don't directly support the above, but we can rely on similar constructs by convention.)",
            "id": "816b3a0a02634f1e46b6f530a951719c"
          },
          {
            "type": "html",
            "text": "\nIn comparison, SQL treats data inherently as a collection. All operations have the loop built into the language, compiler, or library so that the programmer does not need to explicitly code the loop nor take any unusual steps to pass a function to a loop.",
            "id": "3fcabbfab3584f459eae8b09e7974279"
          },
          {
            "type": "html",
            "text": "<i>Unfortunately, SQL isn't sufficient as a programming language for most tasks, so one must pull the data into memory and process with a real language, which puts us back to using loops and functions, or [[Higher Order Function]]s to process the data. Keep in mind that SQL is probably far from the ideal TOP language.</i>",
            "id": "fe58b30c6a8cc1bc02e7729663e33c9b"
          },
          {
            "type": "html",
            "text": "\nLanguage constructs and examples that support passing a function into a common loop:",
            "id": "087d6646b1db6d6a7a94be4b5ec6a26c"
          },
          {
            "type": "html",
            "text": " C++ STL for_each template",
            "id": "84e7362e723f2493ea6485012a4ca6b8"
          },
          {
            "type": "html",
            "text": " [[Java Script]] [Note: Using \"for in\" in [[Java Script]] loops over the properties of the object, not over it's elements, so for(each in a<b></b>List) won't work.]",
            "id": "2b2811edaaf3213eef79f8d18c8fb613"
          },
          {
            "type": "code",
            "text": "  Array.prototype.map=function(to''''''Run){\n  for(var index=0;index<this.length;index++)\n    to''''''Run(this[index]);\n  }",
            "id": "8099b6db12dec825f202db122093986b"
          },
          {
            "type": "code",
            "text": "  Array.prototype.filter=function(is''''''Condition){\n  var result = new Array();\n  for(var index=0;index<this.length;index++)\n    if(is''''''Condition(this[index]))\n    result.push(this[index]);\n  return result;\n  }",
            "id": "5b6a2f1cca266dd2d93638ca2ec78d56"
          },
          {
            "type": "html",
            "text": "To run over a collection, use the following:",
            "id": "789f3a30b00a10f7a870366a8f087aba"
          },
          {
            "type": "code",
            "text": "  a''''''List.map(function(each){each.Do''''''Something()});",
            "id": "b3c4409d91c95d0ef9926c8cb25eafe6"
          },
          {
            "type": "html",
            "text": "or",
            "id": "8787897d159fd6c9e39aa87537a4f3b1"
          },
          {
            "type": "code",
            "text": "  var the''''''Matches = a''''''List.filter(function(each){return each == \"some condition\"});",
            "id": "00c214fa0c53b815b28cca873f315838"
          },
          {
            "type": "html",
            "text": " [[Higher Order Function]]s in [[Functional Programming Language]]s and [[Multi Paradigm Languages]]",
            "id": "60b35f8df32f943345430a9224a4ad84"
          },
          {
            "type": "html",
            "text": " Smalltalk blocks",
            "id": "32840a77d0027c12d378c9b78235d6bb"
          },
          {
            "type": "html",
            "text": "a<b></b>List do:<br>[:each | each do<b></b>Something].",
            "id": "dde44c0cf571577e54a1a9f880260282"
          },
          {
            "type": "html",
            "text": "or",
            "id": "8787897d159fd6c9e39aa87537a4f3b1"
          },
          {
            "type": "code",
            "text": "  |the''''''Matches|\n  the''''''Matches := a''''''List select: [:each | each = 'some condition'].",
            "id": "e013c7064f189089d8fc65a33a869842"
          },
          {
            "type": "html",
            "text": " Java [[Inner Class]]es",
            "id": "907298e25246588a84763a47eeb2eb7c"
          },
          {
            "type": "html",
            "text": " foreach in [[Csharp Language]] and [[Java Language]] 1.5",
            "id": "ccef46d2792a4c9c64e46aa1f28e9623"
          },
          {
            "type": "html",
            "text": "\nEither way, they remove the need to ever have to manually write loops. Since you are passing functions to these methods, no other parameters are needed.",
            "id": "1ec8b57e9a5d6a4e37364e807e161ce4"
          },
          {
            "type": "html",
            "text": "<i>Why can one not merely derive a user collection class from some base collection class and from the class to be contained in the collection and have the user collection class then expose all methods from the base collection class? Without writing any additional code, one could call a method on the user collection class and it would automatically iterate through its collection, calling the same method on each member. For example, I could create a collection of text boxes and then call a Set<b></b>Background<b></b>Color(<b></b>new<b></b>Color) method on the collection and it would set the background color on all text boxes in the collection. -- [[Wayne Mack]]</i>",
            "id": "59d32ef757ec70889152e0a4b47471c5"
          },
          {
            "type": "html",
            "text": "[<i>Consider that that is easily done by a generic for<b></b>each or do method like so....</i>]",
            "id": "a3df2b8742553e4f67e40604f4e0b525"
          },
          {
            "type": "html",
            "text": "[<i>aTextBoxCollection.for<b></b>Each(function(each){each.backGroundColor=\"new<b></b>Color\"});</i>]",
            "id": "bf16fb092da38235082d5b9f06b40cf9"
          },
          {
            "type": "html",
            "text": "[<i>You don't really want specific methods as you suggest, you want generic ones that can take functions as parameters to specialize their behavior, they are much more flexible and require much less code to be written over the long run. A collection should not be concerned with the particulars of an operation, only that the operation needs to be applied to all it's members or some of it's members. Therefore we leave the operation open for extension by making the operation a parameter, and only write the loops on the collection.</i>]",
            "id": "4a2a634807a65165fefb39095ccef0e5"
          },
          {
            "type": "html",
            "text": "[One can and many do. I wouldn't inherit implementation from both the collection and the member classes, though. I might inherit implementation from the collection and interface from the member if that interface makes sense in the context of a collection. Usually I just use a collection that has a for<b></b>Each() method and pass it a closure/block/inner class instance that performs the desired behavior.]",
            "id": "fbb110097468374b15fb4b8c195a40af"
          },
          {
            "type": "html",
            "text": "\nWould you care to expand on why it is advantageous to implement methods on a collection outside of a collection class? (I guess the little light bulb just didn't go off in my head when I read the above comments.)",
            "id": "3558d494e0828df7eba402be64a46992"
          },
          {
            "type": "html",
            "text": "[I assume you mean the methods passed to \"forEach()\"? If so, those methods don't operate on a collection. They operate on members of a collection. \"forEach()\" makes them operate on every member of a collection.]",
            "id": "188bd60cd495d80de371e0b6fbb003b2"
          },
          {
            "type": "html",
            "text": "(Aside, I'm going to start to refactor the top of this section to eliminate bulk. If I lose any important content, please refactor back in.)",
            "id": "9b3d58c0b4dcc3511cd5c1c18af51934"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "\nJust an idea. It would be interesting to see a language that could do something like:",
            "id": "b210582fe8d8deeacb7905277438882a"
          },
          {
            "type": "code",
            "text": "  tableX.doStrategy() where [condition]",
            "id": "d012087438ecffa8aaad9ef7e840d1ce"
          },
          {
            "type": "html",
            "text": "This would be more or less equivalent to:",
            "id": "0ff3637dd0527a96ec3e2be786cd6f7b"
          },
          {
            "type": "code",
            "text": "  r = sqlQuery(\"select doStrategy from tableX where [condition]\")\n  while (row = getNext(r)) {\n    execute(row['doStrategy']);\n  }",
            "id": "9d27859029755e72864d8823f68b31de"
          },
          {
            "type": "html",
            "text": "Based roughly on concepts discussed in [[Eval Vs Polymorphism]].",
            "id": "32597e5e132b68dbd1b68d5dea98609b"
          },
          {
            "type": "html",
            "text": "That's why people rave about smalltalk's collections: that's exactly what you can do. Likewise, there are several libraries which wrap java's collections which let you do the same thing, and the whole thing is trivially easy with Lisp. Add [[List Comprehension]]s to the mix, and you even get the set algebra: \"[ doStrategy x y | x <- tableX, y <- tableY, condition x y]\".",
            "id": "18ebfc51e60848b879bcbec10d19f6cc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "\nThis might be a good place to start a discussion on what [[Bucky Pope]] of [[Ibm Thomas Jay Watson Research Center]] used to call \"class codes\" - maybe it has since reappeared under a new name. He noticed that you very often find code like:",
            "id": "c43e07d60556155e95f3c826bff12ee4"
          },
          {
            "type": "code",
            "text": "  IF PROVINCE = 'NB' OR PROVINCE = 'PEI' OR PROVINCE = 'NS'...",
            "id": "001097330ff488699ef2ddf18da2b89b"
          },
          {
            "type": "html",
            "text": "in programs. If you have many occurrences of this kind of thing, it becomes very hard to maintain. He advocated storing the attributes that you are interested in in tables, so this code becomes something like:",
            "id": "b0c6e7277b5ca570378158e01225bda2"
          },
          {
            "type": "code",
            "text": "  LOOK UP PROVINCE\n  IF PROVINCE IS MARITIME ...",
            "id": "2519347739e9d31d065a14e092142fbf"
          },
          {
            "type": "html",
            "text": "While this looks obvious in hindsight, especially to [[Table Oriented Programming]] people, it is surprising how often you see statements like the former in business applications. They just seem to grow, and it's hard to stamp them out once they take root!",
            "id": "d3abe19eb2bac913d2d3fa1f068c3560"
          },
          {
            "type": "html",
            "text": "\nI have just come across the [[Control Table]] page - it sounds very similar.",
            "id": "c7087e3602852e15efd791c27307a5ed"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "If someone were looking to design a new [[Top Based Language]], what would you consider to be necessary, what would you consider desirable, and what would you wish to avoid?",
            "id": "c5703c928617b7de3a395457f7e224ac"
          },
          {
            "type": "html",
            "text": "\nFirst-class relational operators would seem an obvious one, but would you implement them as a [[Relational Algebra]] or a relational calculus, or a combination of both?",
            "id": "3b28a2bdc96ad002e43416694773b9c2"
          },
          {
            "type": "html",
            "text": "\nWhat else would you want? Transaction management? List comprehensions? Shaped arrays? First-class [[Stored Procedures]], including possibly [[Recursively Stored Procedures]] (i.e., inner functions)? Higher-order functions (presumably operating on the [[Stored Procedures]])? would functions be both represented and implemented as tables, homoiconically (see [[Homoiconic Languages]])? What sort of syntax and semantics would you want?",
            "id": "f6aefd0221cf01104bd4ea51b05d82fc"
          },
          {
            "type": "html",
            "text": "\nIt also occurs to me that if you can have [[Recursively Stored Procedures]], and if you save a stored procedure's lexical environment in a table along with the code, and invoke it at need, you would have a [[Lexical Closure]] - which, since [[Closures And Objects Are Equivalent]], shows that the two paradigms must, on at least a theoretical level, be compatible. Similarly, if you can store a function's successor for later invocation, you could have continuations, in which case you wouldn't necessarily need the inner functions. Of course, using a table for this purpose implies the existence of persistent continuations, which is [[Just Wrong]]...",
            "id": "653e121d8bf5dc924fa1cd5fa65fbbea"
          },
          {
            "type": "html",
            "text": "<i>One has to be careful to design something that can be both big and small. For example, one should perhaps be able to use such a language or kit with [[Minimal Table]] abilities, but also plug in DB2 or Oracle if needed without code overhaul. I also think that as much as possible should be in libraries instead of hard-wired into the language. Thus, ideally the language would offer meta-language abilities so as to easily extend it. I would like to see Lisp reworked to be more palatable to the \"masses\". Java grew popular partly because it borrowed from people's C/C++ familiarity (for good or bad).</i>",
            "id": "e0aded129a03c306512f7c72e9916d94"
          },
          {
            "type": "html",
            "text": "\nGoddess Eris, it just occurred to me! TOP isn't a paradigm - it's a [[Meta Object Protocol]]! [[Top Mop]]! ;) -- [[Jay Osako]]",
            "id": "38a9eb5751064a565022c4c2602e4a49"
          },
          {
            "type": "html",
            "text": "<i>Well, I suppose everything could be defined in terms of [[Meta Object Protocols]], or any other [[Turing Complete]] paradigm for that matter. OO just has a psychological tilt toward behavior instead of declarative techniques and is not \"bound\" to relational rules. In the end it is all about psychology. -- top</i>",
            "id": "acd7de8f57ddb6bb170e742a789fe0ea"
          },
          {
            "type": "html",
            "text": "\nRelated: [[Masp Brainstorming]]",
            "id": "1cc1d12f5f460fd993c96051989028e8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "<b>Spreadsheet-Influenced Ideas</b>",
            "id": "3f3373794a95e8aec1daabc03d509941"
          },
          {
            "type": "html",
            "text": "\nI once got an email from a fellow table fan who suggested using spreadsheets, or at least a spreadsheet-like interface for programming. Initially I was not very warm to the idea, but looking for better ways to combine nimble tables with code, I am now warming up to the idea.",
            "id": "58b4de766b019685f6d7a77f2a63492a"
          },
          {
            "type": "html",
            "text": "\nMost spreadsheets allow text to flow into adjacent cells as long as there is nothing in those adjacent cells. Thus, long programming text will not cause problems. And, the cells can be used for indentation, which can avoid the [[Tab Munging]] problem that pure text keeps facing. If a section of code is indented 3 cells, then it is always indented 3 cells regardless of what edits it. Tabs versus spaces is no longer an issue.",
            "id": "7bee3295d24eff3cb15f77f58fec5fda"
          },
          {
            "type": "html",
            "text": "\nBut the biggest benefit is the ability to embed and define smaller tables inside \"code\". Think of them as \"table closures\".",
            "id": "730ff8a58cf5a42b3852618ccd39a5c7"
          },
          {
            "type": "html",
            "text": "\nHere is an example. First the non-spreadsheet version of the code:",
            "id": "d5d6f92aba1caa1dd026a83c5e8e278f"
          },
          {
            "type": "code",
            "text": "  // define column headers",
            "id": "7c00c11e8b7281a36c752d4e36283494"
          },
          {
            "type": "code",
            "text": "  addColumnHeader(\"Name\");\n  addColumnHeader(\"Student ID\");\n  if (authorized) {\n    addColumnHeader(\"SSN\");\n  }\n  addColumnHeader(\"Grade - GPA\");",
            "id": "0b57e7ad479af6525ce7d8a42f7ff664"
          },
          {
            "type": "code",
            "text": "  // loop for each student",
            "id": "739872f20f0a83281c9a9db09a65aae6"
          },
          {
            "type": "code",
            "text": "  while (row = getNextStudent()) {\n     outNewRow();\n     outColumn(row['name'], left, '');\n     if (authorized) {\n       outColumn(row['SSN'],'center','');\n     }\n     outColumn(row['studentID'],'right',''); \n     outColumn(row['GPA'],'right','#9.999'); \n  }",
            "id": "963071ace120fc09c6255a6288dc69e5"
          },
          {
            "type": "html",
            "text": "Spreadsheet version:",
            "id": "8a7c029a61d3323f1754501a0b5a41b7"
          },
          {
            "type": "code",
            "text": " A...B........C............D..........E........F\n ...............................................\n table rptCols // report column definitions\n ....F''''''ldName..Descript.....Alignment..Format...H''''''ideOption\n ....name.....Name.........left\n ....SSN...................center..............Yes\n ....studentID.............center\n ....GPA......Grade.-.GPA..right......#9.999\n end.table\n .\n loop on table rtpCols where not H''''''ideOption and authorized\n ....addColumnHeader(Descript)\n end loop\n .\n loop on table Students \n ....outNewRow()\n ....loop on table rptCols where not H''''''ideOption and authorized \n .............outColumn(&F''''''ldName, &Align, &Format)\n ....end loop\n end loop",
            "id": "e6589c189db74ac13184855789ef6fd8"
          },
          {
            "type": "html",
            "text": "(Dots only to prevent [[Tab Munging]])",
            "id": "2e159d944b1e7b683fd5f9d767e55621"
          },
          {
            "type": "html",
            "text": "\nThis is rough pseudo-code and not necessarily meant to promote a certain style of syntax. Also, in a real spreadsheet we would be able to see the cell grid, which would make the table much more clear. The \"loop on table\" structure is similar to [[Cold Fusion]]'s <CFloop query=\"foo\"> tag, which allows column scope within the tag. (However, perhaps such a feature should be allowed to be turned off if desired.) The instantiation of result set \"Students\" is not shown in either example. We may be able to factor the \"where\" criteria to one spot.",
            "id": "bdfc3ba0b1e39f36e088ab1f22e19649"
          },
          {
            "type": "html",
            "text": "\nBenefits:",
            "id": "2a80ba943e7e576275b0614b96e39c68"
          },
          {
            "type": "html",
            "text": " No quotes needed in table",
            "id": "4b928efc482c36f8b8663faeb8a78758"
          },
          {
            "type": "html",
            "text": " Stuff is aligned to help see patterns",
            "id": "fd00dfb23e5a4467bf6bd44bad2fbfa3"
          },
          {
            "type": "html",
            "text": " Adding new report fields can be done at one spot instead of two.",
            "id": "09345b6eca6abc384da1dcdae5cf9e0d"
          },
          {
            "type": "html",
            "text": " I personally find it better [[Separation Of Concerns]] and cleaner. Stuff about what is displayed is not mixed in with details on how to display it. The first half is declarative and the second half imperative for the most part.",
            "id": "40e225199699ff9f2b475f7b7a2111aa"
          },
          {
            "type": "html",
            "text": "\nI imagine some adjustments or additions would have to be made to spreadsheets to make them more useful for code editing and viewing. For example, one may have to keep resizing the cell (column) widths in order to view portions of the current screen. Maybe this can be automated. for example, pressing F6 may stretch all cells to fit all the information in the current screen, and pressing shift-F6 puts it back the way it was. Even in the example it is obvious that the indentation (cell width) for viewing tables tends to be different than the best for viewing code. Keep in mind that most spreadsheets display the current cell's contents at top, so that if any single cell is too large to show, it is relatively easy to put the cursor on it in order to see its full contents at top. ",
            "id": "4fc5ef0fce05fae1f12e930323ac546d"
          },
          {
            "type": "html",
            "text": "\nMaybe some way can be devised to alternate between a grid view and text mode in the same module (virtual or real). Maybe the browser can have \"start grid\"...\"end grid\" and \"start text\"...\"end text\" markers of some kind, and the editor would display that section in accordance. In an editor, it could kind of resemble the \"bands\" found in many report writers. One could slide the bands larger or smaller as needed, and a check-box in the band bar would determine whether it is a grid or text band. This would allow text where it is best used and grids where it is best used, but have them intermixed in the same view rather than going back and forth between the grid screen and the text screen that most approaches currently require. -- top",
            "id": "06a35dd77996f930015755796dc33f06"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "<b>[[Multi Threading]]</b>",
            "id": "50a243dabd2d3e3bb5a9d6ada6f6aa0e"
          },
          {
            "type": "html",
            "text": "\n[[Table Oriented Programming]] reduces the need for multi-threaded programming. One can launch independent processes or sub-processes that communicate entirely via tables. Most table engines and RDBMS have concurrency management built in, either with row and table locks, and/or with transactions. Since these are available in the table engine, adding them to a language is kind of a violation of [[Once And Only Once]]. However, this may not be effective for certain embedded or timing-sensitive applications. See [[Are Rdbms Slow]] for more on timing issues.",
            "id": "d317776e23b1e714f58bd53035e8ea05"
          },
          {
            "type": "html",
            "text": "  <i>WOW, that quite a claim. You do realize that Mulithreading  is about avoiding  process overhead right? And you know that not all threads need to share data, or that when they do it is always best to avoid threads right? An you are aware that message passing via queues tends to do the same thing right? And you know about pipes and  commercial messaging products like MQSeries right?  If you are using tables only to pass non persistent data there is something wrong with your design. If you are doing it to ensure delivery then you should consider if your protocol really needs to be stateful.</i> ",
            "id": "1035f2726c9f556ba157d57137868cf4"
          },
          {
            "type": "html",
            "text": " I'm not sure what you are getting at. Perhaps this discussion belongs under [[Table Oriented Synchronization]].",
            "id": "5a841bf4cd4bd204e08fa1515433d1bb"
          },
          {
            "type": "html",
            "text": "<i>This seems to be assuming that the database is necessarily provided by an external process. Integrating it with the language is likely to be both more efficient and more convenient, and personally I'd much rather do this in a language with good support for concurrency (say [[Erlang Language]] using the [[Mnesia Database]]), than try to avoid [[Multi Threading]]. -- [[David Sarah Hopwood]]</i>",
            "id": "96dba9b0fc88abf58ecb19a0040aa176"
          },
          {
            "type": "html",
            "text": "\nPerhaps, but then you lose multi-language ability. If you \"share\", every language then does not have to invent and perfect it all from scratch.",
            "id": "aeea3c5a6160668fff00914baa0ad79f"
          },
          {
            "type": "html",
            "text": "<i>Suppose we use n programming languages in a project, one of which acts as a hub to integrate components written in the other languages and to access a database. If the database is external, then the hub language is effectively SQL. I'm just suggesting using a real programming language as the hub instead. The number of inter-language interfaces is the same: n-1 in each case. -- dh</i>",
            "id": "27358d9121e0acdcd32bafafbff448f8"
          },
          {
            "type": "html",
            "text": "\nWhy would it be called the \"hub\" then?",
            "id": "2ca64ab7afba6d6eab6b31ad82aa33c9"
          },
          {
            "type": "html",
            "text": "<i>The central node in a star (a.k.a. [[Hub And Spoke]]) network is usually called the hub. \"Pivot\" would be another possible term. We use a star network because we don't want n*(n-1)/2 inter-language interfaces.</i>",
            "id": "48bd6e34dfc5ed2dfc8f1de25dccba5b"
          },
          {
            "type": "html",
            "text": "{So the only difference between that and a network is that the edge nodes are not allowed to talk directly to each other? Is that the only distinguishing feature you are suggesting? If not, what are the other distinguishing features?}",
            "id": "aaa9c19c1fd613085f89ef7f06d4fb65"
          },
          {
            "type": "html",
            "text": "\nOr use [[Flow Based Programming]], which can link together modules written in different languages, as well as reusable components that drive different services, e.g. SQL. In the first FBP implementation we had a reusable stream-to-stream component that drove the standard IBM Sort (or any vendor Sort that used the same call interface) - it was <i>much</i> more friendly than using the vanilla Sort because you could change the key on the fly, route data around it, etc. Similar comments apply to a reusable SQL component. -- [[Paul Morrison]]",
            "id": "477251f666e49b682b8a905a1da404d3"
          },
          {
            "type": "html",
            "text": "\nRelated, and perhaps a merge candidate: [[Table Oriented Synchronization]]",
            "id": "5e795a729ed5b2f1e447441408a41a50"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "<b>Tables All The Way Down</b>",
            "id": "e32db0667f4735b69f0f3d0db316620e"
          },
          {
            "type": "html",
            "text": "\nFrom [[When Do Schemas And Classes Deviate]]:",
            "id": "1ca7aeed890e81cf4dc05fadd53d4faa"
          },
          {
            "type": "html",
            "text": "\nRe: <i>nobody has managed to design a [[Table Oriented Programming]] language that's \"tables all the way down\", like [[Small Talk]] is objects.</i>",
            "id": "b2c68c2bc57e6e59759a77143314a5d9"
          },
          {
            "type": "html",
            "text": "\nTables are best used as a larger-scale structure than objects. Rather than everything <i>be</i> a table, a \"pure table\" arrangement would probably look more like everything is <i>in</i> a table one way or another. For example, every variable might be a row in a Variables table, every function defined in a Function table, etc. ",
            "id": "461f56d8c852bdad7c0092c22790ffef"
          },
          {
            "type": "html",
            "text": "\nThings like Microsoft's semi-generic bytecode interpreter ([[Common Language Runtime]]) is essentially a database, just not a relational database. A TOP approach would change that fact and toss the underlying [[Navigational Database]] for such a thing. But, [[Moores Law]] has not quite caught up yet. Source code is only one view among many possible of programs. It is about divorcing presentation from meaning, as described in [[Code Avoidance]]. ",
            "id": "935f2c0f7b7add210ca2e7767799b7a3"
          },
          {
            "type": "html",
            "text": "\nFurther, [[Dynamic Relational]] may be required to keep it flexible enough to be practical. So far there are no completely dynamic implementations. After all, Smalltalk is dynamic. Relational can be too. ",
            "id": "0a4687abd1cea9eae57cb764b8fb12c8"
          },
          {
            "type": "html",
            "text": "\nAnother issue is that maybe a yin-yang kind of relationship may be better than a single atomic \"type\". See [[Yin Yang Versus Singlism]] and [[Formulas Plus Attributes]].",
            "id": "48e5d47af91be2c2ddd675a364042525"
          },
          {
            "type": "html",
            "text": "-- top",
            "id": "d9151b45a1808fec9b43c444be6bd72f"
          },
          {
            "type": "html",
            "text": "<i>But I would be interested in seeing an implementation of a tables-all-the-way-down system. How could you represent functions? Functions lend themselves to hierarchical containment. Mathematically, a function is a mapping from a set to a set, and a table is a set, so could you map a table to another table? Could you have virtual tables that have an infinite number of rows (say for real-numbered values) and implement this mapping? I'm just pontificating here... this would be interesting to figure out.</i>",
            "id": "ba2380c2bbd8d832d1fd03d410e97671"
          },
          {
            "type": "html",
            "text": "\nUsing the mathematical definition of a function, a TOP language is almost trivial. A function is really a set of ordered pairs <a, b>, where a is a member of the domain (a set) and b is a member of the range (another set). This can be represented as a table with the two columns (domain, range). Functions of arity > 1 would just be represented as a table (arg1, arg2, arg3, ..., result).",
            "id": "a9263de946dacccf6d2610ffb200601e"
          },
          {
            "type": "html",
            "text": "\nThe problem is, the [[Set Theory]] definition of a function is very difficult to work with on a daily basis. You don't want to have to explicitly specify outputs for every input; that defeats the purpose of a computer. Go use a paper-and-pencil spreadsheet.",
            "id": "f534432c515c1b9216f9ec29da6aed70"
          },
          {
            "type": "html",
            "text": "\nInstead, most functions are defined as compositions - possibly recursive - of other functions. This is fairly easy to see in Lisp notation: (factorial n) = (cond ((= n 1) 1) (T (* n (factorial (- n 1))))). There're some tricky bits, like the conditional and the use of recursion, but these are all covered by [[Denotational Semantics]].",
            "id": "2704672d73105326e6cf892afa471c15"
          },
          {
            "type": "html",
            "text": "\nSomething like this is very hard to represent as a table. It's fundamentally hierarchical: functions are made of compositions of functions, which are themselves made of compositions of functions, etc. And for reasons of practicality, most of these intermediate compositions are unnamed. They're also denoted positionally by their position in the argument list. When you try to stuff this into a table, you basically end up with a [[Tree In Sql]].",
            "id": "dc8544dc27b2af829e93b39a31d328d2"
          },
          {
            "type": "html",
            "text": "<i>There is no need to </i>implement<i> a function as a table by listing every (argument, result) pair. A function could be represented like a table, i.e. every object </i>looks<i> like a table. After all SQL views look like a table, but are none (being views into one). Looking at a function as a table it would be easy (and difficult in other approaches) to get the domain and range of a function. Of course no every query on an function-table could be computed effectively let alone efficiently.</i>",
            "id": "c12c1476fb54f12c0159c2f4e606fb67"
          },
          {
            "type": "html",
            "text": "<i>I find it a worthwhile idea to combine such an approach with e.g. a [[Set Oriented Programming]] approach based on [[Prolog Language]]. Handling small set (in memory) and large sets (database) uniformly (possibly annotated with hints about size and atomicity) could provide a very elegant and safe way to implement critical financial applications.</i>",
            "id": "31448f83be35a0e767ce583e4aabf0f2"
          },
          {
            "type": "html",
            "text": "-- [[Gunnar Zarncke]]",
            "id": "7708f62d394716ca85493a10120f351c"
          },
          {
            "type": "html",
            "text": "\nPS. <i>It seems, this (same approach for large and small sets) has already been done: See [[Haskell Db]].</i> -- .gz\nPPS. See [[Prolog For Massive Data]]",
            "id": "e9af43db9cdcda42273bcbfb39e99114"
          },
          {
            "type": "html",
            "text": "\nThere is one exception: [[Continuation Passing Style]]. In CPS, every function call must appear in tail position, so no argument is itself a composition of function applications. The tree has been flattened out and labels assigned to every intermediate node, which is just what we need to store the full composition in a table. I'm very curious about a table-based CPS intermediate representation: it looks like there's a full mapping from CPS to relational tables, and this also encodes the complete call graph of the program. Closure analysis may be tricky though; most CPS representations store environment information in the lexical structure of the CPS representation, which would be lost on conversion to tables. If that can be encoded too, however, then you'll have the complete liveness graph of all registers encoded in the intermediate representation. This would let you do really efficient inter-procedural register allocation. -- [[Jonathan Tang]]",
            "id": "4422c4136132936a0f750172ee4945dd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "\nKeep in mind, a table is just one of several [[Ways To Express Relations]].",
            "id": "5554d1a327eb77bfbe0cc07d91011075"
          },
          {
            "type": "html",
            "text": "<i>Everything is probably equivalent to everything, if we want to go that route.</i>",
            "id": "c070818c789c42ef135c49c2ffb3375d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "\nI wonder if the compile-time-type-checking view is in direct conflict with TOP. A good portion of TOPs challengers are pro-[[Static Typing]] it seems. Heavy pre-run checking requires finding ways to limit the variations of \"queries\" or dispatching in order for the compiler to \"reason\" about them. Such tools lean toward hierarchies in order to limit the search tree on \"types\" and related variations. However, if one finds trees inherently limiting, the alternatives don't seem to offer enough regularity compared to trees to do pre-run pass-or-fail analysis. My view is that this simply reflects the real unescapable nature of the world ([[Life Isa Big Messy Graph]]) and that tree-based checking is a false and messy security. You can't compile the whole world. -- top",
            "id": "ad03906def1798693b18bfc4142041c2"
          },
          {
            "type": "html",
            "text": "<i>It's not in conflict or required; it's orthogonal. This is obvious if you have a sufficiently expressive type system. See also [[Four Out Of Five Rule]]. -- [[David Sarah Hopwood]]</i>",
            "id": "ffb822080e188862fe1eef15781ac654"
          },
          {
            "type": "html",
            "text": "\nI doubt there is such as thing as \"sufficiently expressive type system\", as described in [[There Are No Types]].",
            "id": "fd6fac638129be45b956f8b1691c54f8"
          },
          {
            "type": "html",
            "text": "<i>By \"sufficiently expressive type system\", I was talking about type systems that exist in practice, for example [[Soft Typing]] in [[Mr Spidey]].</i>",
            "id": "b81c3eefedb0f9aa09782f4b9e31774b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "\nLooks like someone's trying to cash-in: [http://www.tablecode.com/founders.htm www.tablecode.com]. And it's not [[Top Mind]].",
            "id": "bbc03d6fc4841c3575f621be4ed8f6d0"
          },
          {
            "type": "html",
            "text": "\nYou guys can fight over it. Lemme know who wins.",
            "id": "95277326a9d08c0362f3a8c00f85e320"
          },
          {
            "type": "html",
            "text": "<i>The patents often talk about \"objects in tables\". As long as nobody calls them objects, no problem. However, they also talks about \"code in tables\". Does this mean that \"Eval(myColumn)\" has been patented?</i>",
            "id": "834709dd2d1c5ce1e833bf02ff078ff1"
          },
          {
            "type": "html",
            "text": " Currently, the \"patent\" is merely a patent <i>application</i>, not a granted patent. And it is, as far as I can tell, utter [[Bull Shit]]; [[Top Mind]]s stuff appears to be [[Prior Art]] for much of it.",
            "id": "fd90d6c99fcb0b77f34c99d14c8d3863"
          },
          {
            "type": "html",
            "text": "\nAnyway, the guy claims to have \"invented\" [[Table Oriented Programming]]. While I can find references to him on the web that are earlier than 2004; I can't find anything older than last year on TOP.",
            "id": "d3bad43c23928463292e85ed40fe036e"
          },
          {
            "type": "html",
            "text": "\n[[The Pragmatic Programmer]] reportedly has content on the topic as well.",
            "id": "494a98ac7967fcc5164a279bab0f6b77"
          },
          {
            "type": "html",
            "text": "\n[[Joel On Software]] has a thread about this: [http://discuss.joelonsoftware.com/default.asp?joel.3.166265 discuss.joelonsoftware.com]",
            "id": "1da59dcd510c6956f1e953f3fe495884"
          },
          {
            "type": "html",
            "text": "\nThe Diabs have a paper up on ACM; the list of references is embarrassing: [http://portal.acm.org/citation.cfm?id=1094855.1094930#references portal.acm.org]",
            "id": "86f5b3a81ae2509b3cd1f009fa6b60e1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "\nWhile it isn't [[Table Oriented Programming]] per se (and I imagine that there is much prior art in [[Common Lisp Object System]] for this), a paper that [[Top Mind]] might find interesting:",
            "id": "873970000cbddc42adc5530373d02f44"
          },
          {
            "type": "html",
            "text": "\n[http://www.informatik.uni-ulm.de/rs/mitarbeiter/ch/publ/Heinlein:Goerigk:Kiel.Inf:2004.pdf www.informatik.uni-ulm.de]",
            "id": "93e7559cf4b05a8f9d2952cd2df53bbb"
          },
          {
            "type": "html",
            "text": "<i>Perhaps this link could go under [[Eval Vs Polymorphism]].</i>",
            "id": "ac83907ce83fa0bdaf55db612175fc55"
          },
          {
            "type": "html",
            "text": " A better location would be a more general page on dispatch techniques. Like many other things, the stuff in that paper is largely orthogonal to eval.",
            "id": "ede86108cacf5e53d5abb8da0c825b89"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "\nTop,",
            "id": "44a5030b17dd9e85484d9727f45a21bd"
          },
          {
            "type": "html",
            "text": "\nI'm curious: Did you edit the following article on [[Wiki Pedia]]? [http://en.wikipedia.org/wiki/Table-Oriented_Programming en.wikipedia.org]",
            "id": "4631467bd54553bf460da3b42cbd63cd"
          },
          {
            "type": "html",
            "text": "\nI didn't see any of your usual IPs (dslextreme) in the edit list, and you didn't post with a recognizable username. I <i>did</i> notice, however, your fingerprints on [http://en.wikipedia.org/wiki/Design_pattern_%28computer_science%29 en.wikipedia.org] and I'm curious: Why do you think that design patterns have anything to do with the OO-vs-relational debate? Were one to embrace TOP whole-hog; I'm <i>certain</i> that higher-level patterns would emerge. Many view design patterns as only relevant to OO; in my experience they are applicable to almost any programming paradigm. -- [[Scott Johnson]] (who edits Wikipedia as [http://en.wikipedia.org/wiki/User:EngineerScotty en.wikipedia.org], btw...)",
            "id": "8fbd610a8cc4956d1a03e148f5167a37"
          },
          {
            "type": "html",
            "text": "<i>I actually did not create the Table Oriented Programming topic over there. However, I do remember encountering it and making changes quite a long while back. I forgot all about it until you mentioned it. -- top</i>",
            "id": "09e9227775ec3b3592cabf83c0ebc17e"
          },
          {
            "type": "html",
            "text": "\nI see you did delete some vandalism from the page (vandalism which uttered your name in vain)... do you still prefer to not have your real name published? -- sj",
            "id": "eb06a4beff012aca5186ce813c20657c"
          },
          {
            "type": "html",
            "text": " He's been stating that preference for many years; there's no reason to assume that his policy has some built-in time limit that will expire at some random point. :-) -- Doug",
            "id": "01e68fbebfec89050143884c5f6a4e2f"
          },
          {
            "type": "html",
            "text": " If you go to the tablizer website, and look at the bottom of the pages, you'll see the following:",
            "id": "a1018f903ff49fa5172e2e9f184ff165"
          },
          {
            "type": "html",
            "text": " \"...Material  Copyright 1998...2005 by Findy Services and [Top's First Initial and Last Name]\"",
            "id": "46adc6573ad8da9c4f1edf3cee805b23"
          },
          {
            "type": "html",
            "text": "Plus, there seem to be quite a few guys on the net who try and \"out\" topmind wherever they can... if Top wants to keep his real name a secret, he does a rather poor job of it. :) <i> -- First letter S...</i> :-)",
            "id": "7da99287fa1db74f30fd358773a75812"
          },
          {
            "type": "html",
            "text": " <i>That's not the point. We all know what his real name is, and he knows that, and isn't trying to keep it a secret as such, he just does not like to be addressed by his real name, because it makes it overwhelmingly obvious who he is, as opposed to it simply being possible to find out his real name. Since his given rationale is to avoid threatening his career, this seems reasonable to me; a potential employer will search on his real name, <b>not</b> on [[Top Mind]], so his approach works perfectly well for that kind of thing. -- Doug</i>",
            "id": "1f5eaccca0013a5f91ff7e03efe432ea"
          },
          {
            "type": "html",
            "text": " Although, typing Top's real name into google produces the tablizer page as the first couple of results... -- sj",
            "id": "e7c3a6a59473c3c5ef4078d201ced4a2"
          },
          {
            "type": "html",
            "text": "Discussion moved to [[Real Names Please]].",
            "id": "1986ea8f1a8ec0cb90172ae2faa9cee2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "\nFor those of us sick of writing and manually managing essentially tabular data in an object-oriented language like C++, I'm interested in pursuing a [[Template Metaprogramming]] approach to auto-building tuples, tables of tuples, and indices within the C++ runtime, and maybe a [[Template Metaprogramming]] supported query language, too. Might be something boost-worthy. However, I ain't tacklin' that one alone. My main use of tables is when I need to index the same data N-ways from sunday, I almost always end up writing them by hand, and I rarely use joins (though I know how to go about it after writing the C++ version for [[Every Combination In Many Programming Languages]]).",
            "id": "ba97859e9a9e57841b8e49e030c85491"
          },
          {
            "type": "html",
            "text": "<i>The [[Sq Lite]] libraries are C-based. Perhaps you can incorporate them into your code.</i>",
            "id": "8b28ca30300be14162ac32210824bbd6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "\nWhen I coined \"table-oriented programming\", this is NOT what I had in mind: [[Befunge Language]] ([http://en.wikipedia.org/wiki/Befunge en.wikipedia.org])",
            "id": "ddcf7f6968e98d089a961af8b67271cf"
          },
          {
            "type": "html",
            "text": "\nThat is more like \"grid-oriented programming\". Grids are like 2D positional arrays and tables are like 2D associative arrays.",
            "id": "409a3d4a17f2bcb6f9005808e01c48df"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "Re: Quote: \"A belief that tables better match human physiology and/or psychology (or at least a large enough percent of the population to make it a viable tool).\"",
            "id": "c7e2e3f8020079dd3bd8d8b20327c7ed"
          },
          {
            "type": "html",
            "text": "\nPsychology has nothing to do with tables. Human psychology is oriented around depression, happiness, food, replication, sadness. The relational model was created to organize data effienciently and sensibly, not to tie in psychology of the human brain.  in fact one problem with bad programmers is that they let their emotions get in the way of truth - and truth is what computers are all about. If you want to model the human brain you'd be best looking into artificial intelligence and fuzzy logic. The relational model is very un-human and un-animal. It is infact extremely \"true or false\" oriented, centered more around the CPU \"bit\" where there is <b>0</b> or <b>1</b>.   Bringing psychology and anthropomorphisms into programming is extremely dangerous, because databases are not about human psychology. Databases are about correct data retrieval (would you want erroneous data?) that can be accessed efficiently and did I already say it, <b>correctly</b>.  Tables (relations) were invented so that data would be accessible in an efficient and correct manner. And by efficient I don't mean that your database is \"fast\", I mean efficient organization of data where one can look up how many customers live in so and so state or province without having to write tons of code (normalization helps significantly there). It has nothing to do with psychology. It's about accessing the data in the most efficient manner. And once again, by efficiency I do not mean the clock time.",
            "id": "c47ea280625fa0fe591f374defa1f4d8"
          },
          {
            "type": "html",
            "text": "<i>\"Psychology\" involves lots of things. Emotions is one of them. But there's also the \"perceptual\" side, that borders on physiology. I wish there was a better name for the aspect that we are considering here, but I haven't found it. Most people would agree that \"psychology affects grokkability\". Somewhere on this wiki is a discussion about whether relational is a \"natural\" property of our universe, like Pi, or whether it's somehow tied to human nature and human qualities. I suspect it's the latter. Machines and math don't \"care\" either way. Relational is merely a [[Useful Lie]] for humans. As far as \"correctness\", I'd use some form of relational even if it didn't have referential integrity etc. That's a nice bonus, but not the single magical factor. -t</i>",
            "id": "a09bcf2dc235ef84f2609e846859c63f"
          },
          {
            "type": "html",
            "text": "\nYou ought to do some research as to why the relational model was invented. It was invented to organize data, especially repetitive similarly structured data.  The relational model (tables) are tied to data, not some natural property of humans, but the natural properties of data. The natural properties of data are: often you will see repetitive entries (by repetitive I mean they all fit into a table - for data that doesn't have a common structure, that's where relational fails.. for example a GUI with a button, a panel, and a window - these don't all fit easily into a table and are better as single structures or objects (unless you had 3400 buttons on the screen that needed to be searched)). ",
            "id": "28a26010b432da39cd7f31f7f7db98c3"
          },
          {
            "type": "html",
            "text": "<i>I agree about the factoring part, but navigational ([[Navigational Database]]) can also be used to factor out repetition. Thus, relational has no monopoly there. I disagree that a table-oriented GUI is not possible. I even gave an example in [[Non Oop Gui Methodologies]]. Hardware wasn't up to the task when GUI's started, but may be now. Further, [[Dynamic Relational]] may be a better fit for such anyhow rather than the Oracle clones we have now. Further, a lot of \"kinds\" of widgets can be rolled up into just two \"types\" of widgets: singular and compound. The difference between a label, link, click-able image, and button are not sufficient to make them separate \"kinds\" of things. If I want to make an image click-able, I don't want to have to change it's type, I merely want to be able to be able to add clicking behavior/attributes to it. Viewing them through the smorgasbord model [see...damn-i-forgot-name] may give us more flexibility and combinations.  I agree that hard \"types\" may be a [[Useful Lie]], especially for newbies, but does not add to flexibility and reuse.</i>",
            "id": "39578fe26427e3505b880031f33e3afb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "[[Microsoft Access]] is \"proof by popularity\" that [[Table Oriented Programming]] works: entire small and medium-sized applications are often written in Access without using a single line of code (other than expressions, such as \">id\"), or at least very little. Many Access programmers don't even know VBA. That being said, I would do many things different if designing a better TOP C.R.U.D. thing-a-matic, the primary one being making all the application configuration, queries, settings, macros, etc. be full-blown tables that can be queried and analyzed by the DBMS like any other table can, not the proprietary hidden binary structures that MS often uses. It may have originally been done for efficiency reasons. For example, to allow lots of open-ended \"cells\", a Memo type would have to be used often, and these tend to be slow. More efficient auto-sizing would have to be explored. Existing RDBMS are tuned for data usage patterns, not config attributes. Table-based management of query parameters would also help. -t",
            "id": "4f42cc8669c951fa0aab8623827973d5"
          },
          {
            "type": "html",
            "text": "<i>At best, [[Microsoft Access]] is \"proof by popularity\" that desktop DBMSes using [[Query By Example]] and reasonably-usable built-in form and report painters plus an included implementation of [[Visual Basic]] for scripting and marketed by [[Micro Soft]] can be popular.  It says nothing about [[Table Oriented Programming]], whatever that is.  Arguably, what is being called \"[[Table Oriented Programming]]\" here is nothing more than using the [[Relational Model]], or something resembling it, to build applications.</i>",
            "id": "1f0ac7de2f707f3af778b9a181635578"
          },
          {
            "type": "html",
            "text": "\nI'm not talking about form and report painters, for basic (and esthetically ugly) apps can be built without ever touching them. Perhaps what I'm getting at is [[Attribute Oriented Programming]], which is a close relative of TOP. An entire app can be built by merely filling in attributes and attribute tables. Most if not all of the things in Access could be turned into tables or queries on tables, and many of them are. For example, the \"switchboard\" (menu panel) wizard creates a switchboard [[Control Table]], which is internally used to control the switchboard. The macro commands are also presented to the user as a table/grid (although I don't know if it's implemented as a table under the hood). And I've built basic [[Control Table]] based report writers for [[Ex Base]] with sub-grouping/totalling back in the ASCII days. Basic forms can also be done that way, if you don't mind meek aesthetics. Let's review:",
            "id": "e1ceb1dec175495786120bb50d5c34e8"
          },
          {
            "type": "html",
            "text": " Queries  Designed primarily via a [[Query By Example]]-based grid interface. These can be Select, Update, Insert, etc. queries. One can also edit queries as direct SQL if desired.",
            "id": "5ecc14df3b550f652d687f156368d769"
          },
          {
            "type": "html",
            "text": " Macros  Attribute-driven in macro designer grid. Could be or perhaps is table-ized under-the-hood. (Conditional expressions are also possible, but awkward in Access.) It's almost like a CRUD-oriented Assembler language, which is fine for short lists of commands.",
            "id": "0330a58a19a734d0a09f3811c43940a3"
          },
          {
            "type": "html",
            "text": " Menu Panels (\"switchboard\")  Table-driven under the hood. A wizard puts a GUI dialog interface over this table.",
            "id": "fcfbb04f39cdd69b6cb8a9d400d2f461"
          },
          {
            "type": "html",
            "text": " Data entry forms  One can use \"raw\" edit table views, or the drag-and-drop VB-like painter tools. However, these can also be done via table-driven interfaces, although MS-Access doesn't. (You'll just have to take my word for it.)",
            "id": "24264bfb512206e32a563c007308744c"
          },
          {
            "type": "html",
            "text": " Report writer  Access can \"auto-guess\" from edit table views, but otherwise uses a report painter. I built a table-driven report-writer back in the DOS days. It used a [[Data Dictionary]] with additional attributes for sub-grouping options, which somewhat resembled Access's query-builder when the \"totaling\" row is switched on.\nThus, all the basics of typical [[Crud Screen]] apps can be table- and query-based. Application programming code and screen/form painters are <i>not</i> necessary. (But even painter tools can store the design in tables. [[Fox Pro]] did this more or less under the hood.) Again, I'm not suggesting one always take the 100% TOP road. I'm only pointing out it's possible. A good many apps can be around 70%. Generally the low-use and internal forms and reports are made using TOP, and the high-use critical ones are more carefully tweaked and micro-managed using or assisted by application code. -top",
            "id": "1e5524780750a251c899a9f5e2155cd1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "\nIt is exceedingly unclear to me what [[Table Oriented Programming]] really 'means'. Proposed: ",
            "id": "67d235760bcc4e0a0463d0599589bb4c"
          },
          {
            "type": "html",
            "text": " Definition 1: Tables, Sets, or Relations are [[First Class]], and so are relational operations on these (union, join, select, etc.), and relations are used (idiomatically) instead of [[Composite Pattern]] for data. By [[First Class]], I mean: table-values may be anonymous, stored to variables in the language ([[Rel Var]]s), communicated as arguments, and returned. Consequences of using TOP under this definition:",
            "id": "9ab2ff37c40f9a38ec42ba614c4874a4"
          },
          {
            "type": "html",
            "text": " [[Table Oriented Programming]] is fully compatible with [[Object Oriented Programming]], [[Functional Programming]], [[Functional Reactive Programming]], [[Dataflow Programming]], etc. Some extensions are required mostly to support relational operations, and the language-implementation might do well to provide some automated optimizations (both query-optimizations, and storage/indexing optimizations for the ",
            "id": "606fc89ae95dbbf41b536c0b401fc40b"
          },
          {
            "type": "html",
            "text": " Need for [[Visitor Pattern]] is diminished.",
            "id": "9cd8866b213af47579ae3466267840e1"
          },
          {
            "type": "html",
            "text": " With tables being anonymous, it can be somewhat difficult to define relationships between 'tables' variables, such as [[Foreign Key]]s and [[Cascading Delete]] and consistency requirements. This is suitable for [[Dynamic Typing]], but one may wish to expand to something even broader for [[Static Typing]]: [[First Class]] 'database' objects where the [[Type System]] recognizes as a primitive values that can encompass <i>many</i> tables along with the relationships between them. ",
            "id": "869f6ac0656c53719ffff23244a11780"
          },
          {
            "type": "html",
            "text": " [[Persistent Language]] feature is possible, but occurs more along the lines of persistent [[Object Oriented]] language.",
            "id": "f47e0afa7033e3f4a60d05bc5bff586b"
          },
          {
            "type": "html",
            "text": " Integration with external RDBMS is unlikely, or at best 'indirect' (i.e. loading queries from remote tables into a local table-value, ideally lazily or at-need). It will likely require some mapping effort on the edge of the system (e.g. via a [[Foreign Function Interface]]). But if [[Persistent Language]] feature allows automatic re-establishment of communications, this problem will be greatly reduced.",
            "id": "2087bd5f1dafc1a368807f71069ebe60"
          },
          {
            "type": "html",
            "text": " Tables are subject to [[Object Capability Model]] security. That is, tables can be \"hidden\" within the process, fully encapsulated, inaccessible to DBAs and such unless made available through an IDE or debugger. Even if they are accessible, such tables will have semantics that depend heavily on context and who is using the table, so a DBA would need much detailed knowledge of the application to make sense of the multitude of tables.",
            "id": "26ca6437103fe2bbb2b2b0fb5f9c264e"
          },
          {
            "type": "html",
            "text": " Mutable-state communication can be avoided ([[Kill Mutable State]]) in favor of passing about immutable table values between components and processing them using pure functions. This can reduce need for ACID transactions, though some sort of [[Software Transactional Memory]] is still appropriate for the little mutable-state remaining. Whatever solution is used to protect mutable state for other variables is likely to protect mutable state for tables.",
            "id": "4766cf0eec19dfce93a230d0f1d29914"
          },
          {
            "type": "html",
            "text": " Definition 2: Tables, Sets, or Relations are [[Second Class]] (or at least used as such by [[Table Oriented Programming]]). That is, you can name these [[Rel Var]]s in a \"global\" space, as part of a program definition. You might be able to create temporary views or tables for processing (i.e. functions that take tables as arguments), but either you cannot return tables, or such [[First Class]] use of tables (i.e. creating a process that loops forever passing tables as arguments and assigning result-tables to local variables) is idiomatically discouraged by [[Table Oriented Programming]] in favor of communicating between components by shared-state mutation on globally identified tables. Consequences of using TOP under this definition:",
            "id": "8d25ba43e1e1960c04fc2d626881ebf6"
          },
          {
            "type": "html",
            "text": " Communication between components primarily by shared state in common tables closely matches the [[Blackboard Metaphor]] and [[Linda Tuple Spaces]] designs. Process-composition occurs as a flat architecture attached to a common database. Tables are used for [[Remote Procedure Call]], [[Inter Process Communication]], etc. Related: [[Table Oriented Synchronization]].",
            "id": "20cc7c1f136d87560f72f02fd3904769"
          },
          {
            "type": "html",
            "text": " Since all tables are named, their number doesn't vary wildly during program execution, and the names are in a global space, it is easy to describe and establish constraint-relationships between [[Rel Var]]s (including [[Foreign Key]], [[Cascading Delete]], etc.) that are often associated with RDBMS.",
            "id": "aca9bef55452be5afff71e32689a1a5f"
          },
          {
            "type": "html",
            "text": " Multiple instances of the same application need semantics for whether all instances share the same tables, or each application gets its own table. One might annotate this sort of information as part of defining the global [[Rel Var]]s (even going so far as to say a particular [[Rel Var]] corresponds to a particular [[Uniform Resource Identifier]] for an RDBMS). It may be that some tables are marked 'volatile' - gone with the wind the moment the application is killed.",
            "id": "edcd50f33028fe742b258acdfecd933b"
          },
          {
            "type": "html",
            "text": " Easy integration with RDBMS and local DBs (like [[Sq Lite]]). Easy persistence via such integration.",
            "id": "373ab1aea4d4a21cdd32e8853079b8a4"
          },
          {
            "type": "html",
            "text": " DBAs can get easy access to all the tables. Since they're \"global\", the table semantics are pretty much independent of context. This allows DBAs to easily understand and maintain tables. ",
            "id": "bae928a2c040d1bcb213918c9fdb186d"
          },
          {
            "type": "html",
            "text": " Challenged to handle two or more databases or data sources - distributed queries and distributed transactions to work with more than one RDBMS will be a serious challenge for implementors. This encourages the 'store everything into one uber-massive organization-global RDBMS' design. Ideally, it would even be world-global, but the security issues of this architecture forbid that.",
            "id": "ce4d89b340a25165706ec55b4969707f"
          },
          {
            "type": "html",
            "text": " Security-challenged architecture. By default, everyone has access to any table they can name. This is problematic given the above-described propensity to grow into truly organization-global tables. People have attempted to erect various forms of egg-shell security - i.e. passwords and such - to protect tables and data. If any component of a TOP application is compromised, in general all tables it has authority to interact with are compromised.",
            "id": "ddb97dfb2a602c37f27d136d39cae22a"
          },
          {
            "type": "html",
            "text": " The use of tables for [[Table Oriented Synchronization]] purposes creates considerable extra 'cleanup' and burden for the applications. It is rare that resources are sufficient to keep a complete history of everything every process does. More relevantly, general forms of [[Garbage Collection]] won't be able to take out tables in a global space, so it will be up to the processes to selectively delete rows from the global tables after taking the appropriate actions. All this exacerbates the egg-shell security problem, since any compromised process will have access to various shared IPC tables and can therefore compromise communications between all other processes. ",
            "id": "3a5140f6e1849cd2ea75c5b83998ca76"
          },
          {
            "type": "html",
            "text": " Transactions and persistence over tables, as they are, do not include the processes or communications. This can create some challenges if one wishes to perform <i>behaviors</i> atomically and persistently - all at once or not at all. This leads to patterns as seen in [[Mnesia Database]], where one creates tables that essentially track what each process is doing, what it plans to do next. This requires a great deal of explicit effort and explicit interactions with tables. Further, if persistence is the goal, then the table in question cannot be local and volatile to the application - it must be part of an RDBMS. (For security, this table at least could be local to an application to avoid granting other processes the ability to directly compromise program behavior.)",
            "id": "6d40af2dbc39908e5b56671e1b979f91"
          },
          {
            "type": "html",
            "text": " It is not possible for two or more independent processes or applications to coordinate a behaviors atomically: communication occurs through the database, but process A cannot see what process B is attempting to do atomically until AFTER process B commits its intent to the database. Because processes do not compose or coordinate atomically, each process will need to be monolithic in nature - i.e. process A will need to <i>include</i> the features of process B. Since monolithic processes need much more authority than fine-grained processes, they contribute to egg-shell security issues.",
            "id": "12fa96c2188bda9117e1ab2fb672eef3"
          },
          {
            "type": "html",
            "text": "\nIt has been my impression that what [[Top Mind]] really means when he discusses '[[Table Oriented Programming]]' is more along the lines of Definition 2. It isn't particularly compatible with [[Object Oriented Programming]], and it's a closer fit to the sort of situations he describes (i.e. relying on external RDBMS systems, procedural+relational, using RDBMS for persistence, etc.).",
            "id": "7f3b4d7fdfb1c02cca684e64c4ea92fe"
          },
          {
            "type": "html",
            "text": "<i>It has been my impression that what [[Top Mind]] really means when he discusses '[[Table Oriented Programming]]' is [[Ex Base]].</i>",
            "id": "447fff3b45234363f983ae99e2fbd099"
          },
          {
            "type": "html",
            "text": " [[Ex Base]] is a \"taste\" of a TOP-friendly language. I honed many of my TOP skills in it and I saw other [[Ex Base]] fans do the same. However, it still has a lot of warts in my opinion. I once kicked around a re-worked version of [[Ex Base]], but realized that a flexible enough general language with good libraries could do almost the same without having to hard-wire DB idioms into it. -t",
            "id": "a8cff65d02adf01b6052509458f35ebe"
          },
          {
            "type": "html",
            "text": "\nMaybe so. Either way, it seems to be a relatively limited vision of a programming model.",
            "id": "34b9267ccf8bf24c4f1ad951ad00e5d5"
          },
          {
            "type": "html",
            "text": "<i>Indeed.  It's more of a coding style than a programming model.</i>",
            "id": "248437fa762b4471634fd9da7ed2dafd"
          },
          {
            "type": "html",
            "text": "{The programming model can make TOP simpler and smoother, but I agree that it's not really about programming languages. However, one of you is a \"linguistical thinker\" I believe, and to such a person, everything may be \"about language\" because they think in language terms. I'm not sure how to translate this into linguistic-speak. If I was going to make the \"ultimate TOP language\", first we'd have to settle on whether we maximize for integration with existing RDBMS and SQL, or focus on an \"ideal\" (or alternative) relational system. And this includes deciding on compiler/type-heavy or dynamic-friendly designs. Ideally, a language or libraries would support \"local tables\" to supplement RDBMS usage that have language scoping rules more or less like arrays. (They can be emulated using nested maps and some API's that support a query language.) This is closer to the \"first class\" description above. As far as \"sharing\", at this point, I am happy to stick with [[Table Oriented Synchronization]] for concurrency issues. -t}",
            "id": "8f88f6c3304fe8537ba1df267f56537c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "After reading this page, I still do not really understand TOP. Thus, I will as a comparitive question. Programming only with functions is possible. Functions can be expressed as an ordered pairs, for example f(i)=i*i where 0<i<4 is the set {{1,1}, {2,4}, {3,9}}, which fits nicely into a table of two columns and three rows. Is this a trivial example TOP? --[[Edwin Earl Ross]]",
            "id": "5d206eb4542e3500fecd93b1001e931c"
          },
          {
            "type": "html",
            "text": "<i>Rather than strive for a hard-bordered definition, which will probably result in an endless [[Laynes Law]] battle, I'll try to present more examples in topics such as [[Viewing Algorithms As Collection Processing]].</i>",
            "id": "d9b2e64f8695bf4029159049c3b4b4ff"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "image",
            "url": "http://translab.burundi.sk/pix/33-1.gif",
            "text": "translab.burundi.sk",
            "id": "bc03f0afc790ef3c8c17d06fb4ccc903"
          },
          {
            "type": "html",
            "text": "[[Ada Lovelace]], the first Table Oriented Programmer?:\n",
            "id": "de2b004cf0b31b74c05d13bb8def641f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "See: [[Kay Language]], [[Array Oriented Language]], [[Control Table]], [[Data Dictionary]], [[Relational Database]], [[Fox Pro]], [[Set Theory]], [[Relational Algebra]], [[Source Code In Database]], [[Business Rules Metabase]], [[Set Oriented Programming]], [[Collection Oriented Programming]], [[Programming Paradigm]], [[Payroll Example]], [[Table Oriented Programming Discussion]], [[Embrace Sql]]",
            "id": "e9d4b9dff1f4397a13191cad64cf502c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8574409e7c491e53026a24b3bb6d4461"
          },
          {
            "type": "html",
            "text": "[[Category Programming Language]], [[Category Info Packaging]], [[Category Database]], [[Category Table]] [[Category Data Orientation]]",
            "id": "65d4ba373823efb73daa8e2f2f0b611a"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?TableOrientedProgramming c2.com]",
            "id": "7571083952605cc7880763b89d35776e"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1699944466488
    }
  ]
}