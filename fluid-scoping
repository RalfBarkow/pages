{
  "title": "Fluid Scoping",
  "story": [
    {
      "type": "reference",
      "id": "2eee513281a5c283",
      "site": "clive.tries.fed.wiki",
      "slug": "is-it-safe-to-add-fluid-scopes-to-an-ocap-language",
      "title": "Is it safe to add fluid scopes to an OCap language?",
      "text": "YOUTUBE nLti4CPkv4k"
    },
    {
      "type": "video",
      "id": "d2058e6c95cb5ac3",
      "text": "YOUTUBE nLti4CPkv4k\nDiscussion at FRIAM led by [[Mark Miller]].\n\n"
    },
    {
      "type": "paragraph",
      "id": "50473fb07906535a",
      "text": "[…] \n[https://youtu.be/nLti4CPkv4k?t=1190 19:48]\n[…] the key Insight in the invention of fluid scoping by the [[Scheme]] Community is that the access to the [[Fluid Variable]] was itself governed by [[Lexical Scope]]."
    },
    {
      "type": "reference",
      "id": "adee39a9319600e8",
      "site": "language.sfw.c2.com",
      "slug": "scheme-language",
      "title": "Scheme Language",
      "text": "Lisp done right, according to some. Others prefer [[Common Lisp]], right at the other end of the oversimplified/baroque - or, if you prefer, elegant/full-featured - axis. Standard Scheme as defined by the [[Revised Report On Algorithmic Language Scheme]] is deliberately minimalistic. [[Scheme Requests For Implementation]] provide de facto standards for often needed (and often requested) features and extensions, like record types, multi-threading, exception handling and localization."
    },
    {
      "type": "pagefold",
      "id": "7efaab711d235222",
      "text": "~"
    },
    {
      "type": "reference",
      "id": "0b1b4578d39821dc",
      "site": "language.sfw.c2.com",
      "slug": "free-variable",
      "title": "Free Variable",
      "text": "Note: The following is not a definition of <i>actual</i> [[Free Variable]]s as seen in mathematics, but that of top level lexically scoped variables."
    },
    {
      "type": "reference",
      "id": "5d45b394aaf98568",
      "site": "language.sfw.c2.com",
      "slug": "scoping-rules",
      "title": "Scoping Rules",
      "text": "The <i>scoping rules</i> of a [[Programming Language]] dictate how [[Free Variable]]s - symbol names which are found in the body of a scope (a function, macro, class, whatever) but not defined there - are resolved."
    },
    {
      "type": "reference",
      "id": "66785ac69852eb93",
      "site": "language.sfw.c2.com",
      "slug": "special-variable",
      "title": "Special Variable",
      "text": "The term \"special variable\" is [[Common Lisp]] jargon which means \"dynamically scoped variable\". Which in turn is Lisp jargon that means a variable whose binding has [[Indefinite Scope]] and [[Dynamic Extent]] (and is hence a [[Dynamic Binding]])."
    },
    {
      "type": "reference",
      "id": "ddf5b73b1d930c83",
      "site": "language.sfw.c2.com",
      "slug": "indefinite-scope",
      "title": "Indefinite Scope",
      "text": "Indefinite scope is a name resolution rule which is not contained by [[Lexical Scope]]. When the program refers to an object using an indefinitely scoped name, the reference is resolved not by looking for the closest physically surrounding construct which lexically binds that name, but rather a broader search strategy. The binding may either exist in the global environment, or may have been established in some distant part of the program in an expression which invoked the current expression directly, or through any number of intermediate frames. To this "
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Fluid Scoping",
        "story": []
      },
      "date": 1674053762371
    },
    {
      "id": "50473fb07906535a",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "50473fb07906535a",
        "text": "[…] \n[https://youtu.be/nLti4CPkv4k?t=1190 19:48]\nuh bindings yeah yeah and that that was the key Insight in the invention of [[Fluid Scoping]] by the scheme Community is that the access to the fluid variable was itself governed by lexical scope"
      },
      "date": 1674053766295
    },
    {
      "id": "d2058e6c95cb5ac3",
      "type": "add",
      "item": {
        "type": "video",
        "id": "d2058e6c95cb5ac3",
        "text": "YOUTUBE nLti4CPkv4k\nDiscussion at FRIAM led by Mark Miller.\n\n"
      },
      "date": 1674053772478
    },
    {
      "item": {
        "type": "factory",
        "id": "2eee513281a5c283"
      },
      "id": "2eee513281a5c283",
      "type": "add",
      "after": "50473fb07906535a",
      "date": 1674053789754
    },
    {
      "type": "edit",
      "id": "2eee513281a5c283",
      "item": {
        "type": "reference",
        "id": "2eee513281a5c283",
        "site": "clive.tries.fed.wiki",
        "slug": "is-it-safe-to-add-fluid-scopes-to-an-ocap-language",
        "title": "Is it safe to add fluid scopes to an OCap language?",
        "text": "YOUTUBE nLti4CPkv4k"
      },
      "date": 1674053793250
    },
    {
      "id": "2eee513281a5c283",
      "type": "move",
      "order": [
        "2eee513281a5c283",
        "d2058e6c95cb5ac3",
        "50473fb07906535a"
      ],
      "date": 1674053795897
    },
    {
      "type": "edit",
      "id": "d2058e6c95cb5ac3",
      "item": {
        "type": "video",
        "id": "d2058e6c95cb5ac3",
        "text": "YOUTUBE nLti4CPkv4k\nDiscussion at FRIAM led by [[Mark Miller]].\n\n"
      },
      "date": 1674053814721
    },
    {
      "type": "edit",
      "id": "50473fb07906535a",
      "item": {
        "type": "paragraph",
        "id": "50473fb07906535a",
        "text": "[…] \n[https://youtu.be/nLti4CPkv4k?t=1190 19:48]\nuh bindings yeah yeah and that that was the key Insight in the invention of [[Fluid Scoping]] by the [[Scheme]] Community is that the access to the fluid variable was itself governed by [[Lexical Scope]]."
      },
      "date": 1674053903359
    },
    {
      "type": "edit",
      "id": "50473fb07906535a",
      "item": {
        "type": "paragraph",
        "id": "50473fb07906535a",
        "text": "[…] \n[https://youtu.be/nLti4CPkv4k?t=1190 19:48]\nuh bindings yeah yeah and that that was the key Insight in the invention of fluid scoping by the [[Scheme]] Community is that the access to the fluid variable was itself governed by [[Lexical Scope]]."
      },
      "date": 1674054018638
    },
    {
      "type": "edit",
      "id": "50473fb07906535a",
      "item": {
        "type": "paragraph",
        "id": "50473fb07906535a",
        "text": "[…] \n[https://youtu.be/nLti4CPkv4k?t=1190 19:48]\nuh bindings yeah yeah and that that was the key Insight in the invention of fluid scoping by the [[Scheme]] Community is that the access to the [[Fluid Variable]] was itself governed by [[Lexical Scope]]."
      },
      "date": 1674054041479
    },
    {
      "type": "edit",
      "id": "50473fb07906535a",
      "item": {
        "type": "paragraph",
        "id": "50473fb07906535a",
        "text": "[…] \n[https://youtu.be/nLti4CPkv4k?t=1190 19:48]\n[…] the key Insight in the invention of fluid scoping by the [[Scheme]] Community is that the access to the [[Fluid Variable]] was itself governed by [[Lexical Scope]]."
      },
      "date": 1674055010484
    },
    {
      "id": "0b1b4578d39821dc",
      "type": "add",
      "item": {
        "type": "reference",
        "id": "0b1b4578d39821dc",
        "site": "language.sfw.c2.com",
        "slug": "free-variable",
        "title": "Free Variable",
        "text": "Note: The following is not a definition of <i>actual</i> [[Free Variable]]s as seen in mathematics, but that of top level lexically scoped variables."
      },
      "after": "50473fb07906535a",
      "date": 1674055645309
    },
    {
      "id": "5d45b394aaf98568",
      "type": "add",
      "item": {
        "type": "reference",
        "id": "5d45b394aaf98568",
        "site": "language.sfw.c2.com",
        "slug": "scoping-rules",
        "title": "Scoping Rules",
        "text": "The <i>scoping rules</i> of a [[Programming Language]] dictate how [[Free Variable]]s - symbol names which are found in the body of a scope (a function, macro, class, whatever) but not defined there - are resolved."
      },
      "after": "0b1b4578d39821dc",
      "date": 1674055649374
    },
    {
      "item": {
        "type": "factory",
        "id": "7efaab711d235222"
      },
      "id": "7efaab711d235222",
      "type": "add",
      "after": "5d45b394aaf98568",
      "date": 1674055655059
    },
    {
      "type": "edit",
      "id": "7efaab711d235222",
      "item": {
        "type": "pagefold",
        "id": "7efaab711d235222",
        "text": "~"
      },
      "date": 1674055657947
    },
    {
      "id": "7efaab711d235222",
      "type": "move",
      "order": [
        "2eee513281a5c283",
        "d2058e6c95cb5ac3",
        "50473fb07906535a",
        "7efaab711d235222",
        "0b1b4578d39821dc",
        "5d45b394aaf98568"
      ],
      "date": 1674055660089
    },
    {
      "item": {
        "type": "factory",
        "id": "adee39a9319600e8"
      },
      "id": "adee39a9319600e8",
      "type": "add",
      "after": "5d45b394aaf98568",
      "date": 1674055744611
    },
    {
      "type": "edit",
      "id": "adee39a9319600e8",
      "item": {
        "type": "reference",
        "id": "adee39a9319600e8",
        "site": "language.sfw.c2.com",
        "slug": "scheme-language",
        "title": "Scheme Language",
        "text": "Lisp done right, according to some. Others prefer [[Common Lisp]], right at the other end of the oversimplified/baroque - or, if you prefer, elegant/full-featured - axis. Standard Scheme as defined by the [[Revised Report On Algorithmic Language Scheme]] is deliberately minimalistic. [[Scheme Requests For Implementation]] provide de facto standards for often needed (and often requested) features and extensions, like record types, multi-threading, exception handling and localization."
      },
      "date": 1674055748343
    },
    {
      "id": "adee39a9319600e8",
      "type": "move",
      "order": [
        "2eee513281a5c283",
        "d2058e6c95cb5ac3",
        "50473fb07906535a",
        "adee39a9319600e8",
        "7efaab711d235222",
        "0b1b4578d39821dc",
        "5d45b394aaf98568"
      ],
      "date": 1674055750999
    },
    {
      "item": {
        "type": "factory",
        "id": "66785ac69852eb93"
      },
      "id": "66785ac69852eb93",
      "type": "add",
      "after": "5d45b394aaf98568",
      "date": 1674056336335
    },
    {
      "type": "edit",
      "id": "66785ac69852eb93",
      "item": {
        "type": "reference",
        "id": "66785ac69852eb93",
        "site": "language.sfw.c2.com",
        "slug": "special-variable",
        "title": "Special Variable",
        "text": "The term \"special variable\" is [[Common Lisp]] jargon which means \"dynamically scoped variable\". Which in turn is Lisp jargon that means a variable whose binding has [[Indefinite Scope]] and [[Dynamic Extent]] (and is hence a [[Dynamic Binding]])."
      },
      "date": 1674056339472
    },
    {
      "item": {
        "type": "factory",
        "id": "ddf5b73b1d930c83"
      },
      "id": "ddf5b73b1d930c83",
      "type": "add",
      "after": "66785ac69852eb93",
      "date": 1674056419124
    },
    {
      "type": "edit",
      "id": "ddf5b73b1d930c83",
      "item": {
        "type": "reference",
        "id": "ddf5b73b1d930c83",
        "site": "language.sfw.c2.com",
        "slug": "indefinite-scope",
        "title": "Indefinite Scope",
        "text": "Indefinite scope is a name resolution rule which is not contained by [[Lexical Scope]]. When the program refers to an object using an indefinitely scoped name, the reference is resolved not by looking for the closest physically surrounding construct which lexically binds that name, but rather a broader search strategy. The binding may either exist in the global environment, or may have been established in some distant part of the program in an expression which invoked the current expression directly, or through any number of intermediate frames. To this "
      },
      "date": 1674056422109
    }
  ]
}