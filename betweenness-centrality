{
  "title": "Betweenness Centrality",
  "story": [
    {
      "type": "paragraph",
      "id": "4c621f31d19f6704",
      "text": "LEE, Min-Joong, CHOI, Sunghee and CHUNG, Chin-Wan, 2016. Efficient algorithms for updating betweenness centrality in fully dynamic graphs. Information Sciences. 2016. Vol. 326, p. 278–296. [http://islab.kaist.ac.kr/1-s2.0-S0020025515005617-main.pdf pdf]\n"
    },
    {
      "type": "paragraph",
      "id": "562099e7737ad2f1",
      "text": "Betweenness centrality of a vertex (edge) in a graph is a measure for the relative participation of the vertex (edge) in the shortest paths in the graph. Betweenness centrality is widely used in various areas such as biology, transportation, and social networks. In this paper, we study the update problem of betweenness centrality in fully dynamic graphs. The proposed update algorithm substantially reduces the number of shortest paths which should be re-computed when a graph is changed. In addition, we adapt a community detection algorithm using the proposed algorithm to show how much benefit can be obtained from the proposed algorithm in a practical application. Experimental results on real graphs show that the proposed algorithm efficiently update betweenness centrality and detect communities in a graph."
    },
    {
      "type": "paragraph",
      "id": "b2b6d340e4fb710f",
      "text": "[…] Consider an [[Edge Insertion]] example in Fig. 1."
    },
    {
      "type": "image",
      "id": "9ee08a924da78a95",
      "text": "Fig. 1. Graph update example (numbers are edge weights).",
      "size": "wide",
      "width": 419,
      "height": 135,
      "url": "/assets/plugins/image/93c305698825f122d63f8859b57c393c.jpg"
    },
    {
      "type": "paragraph",
      "id": "d7282c640aaba32f",
      "text": "[…] We want to figure out which shortest paths are changed due to the insertion of edge e(v6, v8). Let G be the original graph and G^U be the updated graph of G. It is trivial to see that the shortest path between v6 and v8 is changed. In addition, the shortest paths, which include the original shortest path between v6 and v8, are changed (e.g., the shortest path between v5 and v8). Let us assume that we have an index structure which stores all the shortest paths in the graph. Then we may easily identify such shortest paths. However, some shortest paths in the graph are changed although they did not include the original shortest path between v6 and v8. The shortest path between v1 and v11 in G did not include the former shortest path between v6 and v8, but it is changed to include the inserted edge e(v6, v8). Such shortest paths cannot be easily identified even if we store all the shortest paths in a graph in an index."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Betweenness Centrality",
        "story": []
      },
      "date": 1709812414160
    },
    {
      "item": {
        "type": "factory",
        "id": "4c621f31d19f6704"
      },
      "id": "4c621f31d19f6704",
      "type": "add",
      "date": 1709812416148
    },
    {
      "type": "edit",
      "id": "4c621f31d19f6704",
      "item": {
        "type": "paragraph",
        "id": "4c621f31d19f6704",
        "text": "\nLEE, Min-Joong, CHOI, Sunghee and CHUNG, Chin-Wan, 2016. Efficient algorithms for updating betweenness centrality in fully dynamic graphs. Information Sciences. 2016. Vol. 326, p. 278–296. \n"
      },
      "date": 1709812418471
    },
    {
      "type": "edit",
      "id": "4c621f31d19f6704",
      "item": {
        "type": "paragraph",
        "id": "4c621f31d19f6704",
        "text": "LEE, Min-Joong, CHOI, Sunghee and CHUNG, Chin-Wan, 2016. Efficient algorithms for updating betweenness centrality in fully dynamic graphs. Information Sciences. 2016. Vol. 326, p. 278–296. [http://islab.kaist.ac.kr/1-s2.0-S0020025515005617-main.pdf pdf]\n"
      },
      "date": 1709812449458
    },
    {
      "item": {
        "type": "factory",
        "id": "562099e7737ad2f1"
      },
      "id": "562099e7737ad2f1",
      "type": "add",
      "after": "4c621f31d19f6704",
      "date": 1709812476184
    },
    {
      "type": "edit",
      "id": "562099e7737ad2f1",
      "item": {
        "type": "paragraph",
        "id": "562099e7737ad2f1",
        "text": "Betweenness centrality of a vertex (edge) in a graph is a measure for the relative participation of the vertex (edge) in the shortest paths in the graph. Betweenness centrality is widely used in various areas such as biology, transportation, and social networks. In this paper, we study the update problem of betweenness centrality in fully dynamic graphs. The proposed update algorithm substantially reduces the number of shortest paths which should be re-computed when a graph is changed. In addition, we adapt a community detection algorithm using the proposed algorithm to show how much benefit can be obtained from the proposed algorithm in a practical application. Experimental results on real graphs show that the proposed algorithm efficiently update betweenness centrality and detect communities in a graph"
      },
      "date": 1709812478536
    },
    {
      "type": "edit",
      "id": "562099e7737ad2f1",
      "item": {
        "type": "paragraph",
        "id": "562099e7737ad2f1",
        "text": "Betweenness centrality of a vertex (edge) in a graph is a measure for the relative participation of the vertex (edge) in the shortest paths in the graph. Betweenness centrality is widely used in various areas such as biology, transportation, and social networks. In this paper, we study the update problem of betweenness centrality in fully dynamic graphs. The proposed update algorithm substantially reduces the number of shortest paths which should be re-computed when a graph is changed. In addition, we adapt a community detection algorithm using the proposed algorithm to show how much benefit can be obtained from the proposed algorithm in a practical application. Experimental results on real graphs show that the proposed algorithm efficiently update betweenness centrality and detect communities in a graph."
      },
      "date": 1709812508777
    },
    {
      "item": {
        "type": "factory",
        "id": "b2b6d340e4fb710f"
      },
      "id": "b2b6d340e4fb710f",
      "type": "add",
      "after": "562099e7737ad2f1",
      "date": 1709812542501
    },
    {
      "type": "edit",
      "id": "b2b6d340e4fb710f",
      "item": {
        "type": "paragraph",
        "id": "b2b6d340e4fb710f",
        "text": "[…] Consider an [[Edge Insertion example in Fig. 1."
      },
      "date": 1709812565000
    },
    {
      "item": {
        "type": "factory",
        "id": "9ee08a924da78a95"
      },
      "id": "9ee08a924da78a95",
      "type": "add",
      "after": "b2b6d340e4fb710f",
      "date": 1709812633552
    },
    {
      "type": "edit",
      "id": "9ee08a924da78a95",
      "item": {
        "type": "image",
        "id": "9ee08a924da78a95",
        "text": "Graph update example",
        "size": "wide",
        "width": 419,
        "height": 135,
        "url": "/assets/plugins/image/93c305698825f122d63f8859b57c393c.jpg"
      },
      "date": 1709812656923
    },
    {
      "type": "edit",
      "id": "9ee08a924da78a95",
      "item": {
        "type": "image",
        "id": "9ee08a924da78a95",
        "text": "Fig. 1. Graph update example (numbers are edge weights).",
        "size": "wide",
        "width": 419,
        "height": 135,
        "url": "/assets/plugins/image/93c305698825f122d63f8859b57c393c.jpg"
      },
      "date": 1709812702820
    },
    {
      "type": "edit",
      "id": "b2b6d340e4fb710f",
      "item": {
        "type": "paragraph",
        "id": "b2b6d340e4fb710f",
        "text": "[…] Consider an [[Edge Insertion]] example in Fig. 1."
      },
      "date": 1709812708009
    },
    {
      "item": {
        "type": "factory",
        "id": "d7282c640aaba32f"
      },
      "id": "d7282c640aaba32f",
      "type": "add",
      "after": "9ee08a924da78a95",
      "date": 1709812779329
    },
    {
      "type": "edit",
      "id": "d7282c640aaba32f",
      "item": {
        "type": "paragraph",
        "id": "d7282c640aaba32f",
        "text": "[…] We want to figure out which shortest paths are changed due to the insertion of edge e(v6, v8). Let G betheoriginalgraphandGU be the updated graph of G. It is trivial to see that the shortest path between v6 and v8 is changed. In addition, the shortest paths, which include the original shortest path between v6 and v8, are changed (e.g., the shortest path between v5 and v8). Let us assume that we have an index structure which stores all the shortest paths in the graph. Then we may easily identify such shortest paths. However, some shortest paths in the graph are changed although they did not include the original shortest path between v6 and v8. The shortest path between v1 and v11 in G did not include the former shortest path between v6 and v8, but it is changed to include the inserted edge e(v6, v8). Such shortest paths cannot be easily identified even if we store all the shortest paths in a graph in an index."
      },
      "date": 1709812783456
    },
    {
      "type": "edit",
      "id": "d7282c640aaba32f",
      "item": {
        "type": "paragraph",
        "id": "d7282c640aaba32f",
        "text": "[…] We want to figure out which shortest paths are changed due to the insertion of edge e(v6, v8). Let G be the original graph and GU be the updated graph of G. It is trivial to see that the shortest path between v6 and v8 is changed. In addition, the shortest paths, which include the original shortest path between v6 and v8, are changed (e.g., the shortest path between v5 and v8). Let us assume that we have an index structure which stores all the shortest paths in the graph. Then we may easily identify such shortest paths. However, some shortest paths in the graph are changed although they did not include the original shortest path between v6 and v8. The shortest path between v1 and v11 in G did not include the former shortest path between v6 and v8, but it is changed to include the inserted edge e(v6, v8). Such shortest paths cannot be easily identified even if we store all the shortest paths in a graph in an index."
      },
      "date": 1709812841682
    },
    {
      "type": "edit",
      "id": "d7282c640aaba32f",
      "item": {
        "type": "paragraph",
        "id": "d7282c640aaba32f",
        "text": "[…] We want to figure out which shortest paths are changed due to the insertion of edge e(v6, v8). Let G be the original graph and G^U be the updated graph of G. It is trivial to see that the shortest path between v6 and v8 is changed. In addition, the shortest paths, which include the original shortest path between v6 and v8, are changed (e.g., the shortest path between v5 and v8). Let us assume that we have an index structure which stores all the shortest paths in the graph. Then we may easily identify such shortest paths. However, some shortest paths in the graph are changed although they did not include the original shortest path between v6 and v8. The shortest path between v1 and v11 in G did not include the former shortest path between v6 and v8, but it is changed to include the inserted edge e(v6, v8). Such shortest paths cannot be easily identified even if we store all the shortest paths in a graph in an index."
      },
      "date": 1709812871045
    }
  ]
}