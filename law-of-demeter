{
  "title": "Law Of Demeter",
  "story": [
    {
      "type": "html",
      "text": "The [[Law Of Demeter]] specifies a style guideline: \"Only talk to your immediate friends.\" E.g. one never calls a method on an object you got from another call nor on a global object. This helps a lot later when you [[Re Factor]] the code.",
      "id": "c7fb4c82e93b13feea9a6e88de1ecf87"
    },
    {
      "type": "html",
      "text": "\n[http://www.ccs.neu.edu/research/demeter/papers/law-of-demeter/oopsla88-law-of-demeter.pdf www.ccs.neu.edu]",
      "id": "39166795b2aed714e72c7834681064c8"
    },
    {
      "type": "html",
      "text": "\n[[Peter Van Rooijen]] posted the following description of the [[Law Of Demeter]] to Usenet:",
      "id": "fdae362e644325b540280166516e6565"
    },
    {
      "type": "html",
      "text": " You can play with yourself.",
      "id": "f807faa30f0edbb7c559ca4d47ef040f"
    },
    {
      "type": "html",
      "text": " You can play with your own toys (but you can't take them apart),",
      "id": "c7b8bafd795f7d7283818dd621875968"
    },
    {
      "type": "html",
      "text": " You can play with toys that were given to you.",
      "id": "775833b5c7afbeac0540107bffabd4ff"
    },
    {
      "type": "html",
      "text": " And you can play with toys you've made yourself.",
      "id": "18e988ef0f937b9b276fd30f75c8efba"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "\nExplanation in plain English:",
      "id": "6ce70cbe7d6c9cbe14eb9f2ac882192a"
    },
    {
      "type": "html",
      "text": " Your method can call other methods in its class directly",
      "id": "967e313fff65d587c2494295e77b92ab"
    },
    {
      "type": "html",
      "text": " Your method can call methods on its own fields directly (but not on the fields' fields)",
      "id": "c5621dea7c98496166149e360ff08b0b"
    },
    {
      "type": "html",
      "text": " When your method takes parameters, your method can call methods on those parameters directly.",
      "id": "e13be80740ce71c62f7f53942dd7c163"
    },
    {
      "type": "html",
      "text": " When your method creates local objects, that method can call methods on the local objects.",
      "id": "1904863a748e28ffaf954ef464a38982"
    },
    {
      "type": "html",
      "text": "\nbut",
      "id": "b388fb981fe1f881cc9745c8bf7d9d96"
    },
    {
      "type": "html",
      "text": " One should not call methods on a global object (but it can be passed as a parameter ?)",
      "id": "716aaec3c860a87c9e584b15f7295002"
    },
    {
      "type": "html",
      "text": " One should not have a chain of messages a.getB().getC().doSomething() in some class other than a's class.",
      "id": "36fb3eab6f57f5180f49ffc021d56813"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "<i>One should not have a chain of messages a.getB().getC().doSomething() in some class other than a's class.</i>",
      "id": "08a47898cddc95a00a48779bc321223c"
    },
    {
      "type": "html",
      "text": "\nI have a slight problem with this.  Even if you limit calls to a.getB().getC().doSomething() to within class 'a', aren't you still violating the principle in terms of 'b' since 'a' is calling b.getC().doSomething() ?",
      "id": "6389e2e5c7798126f3675b6439222c4f"
    },
    {
      "type": "html",
      "text": "\nSo 'b' needs a method called doSomething() that calls c.doSomething() and then 'a' needs a method called doSomething that calls b.doSomething()",
      "id": "45159e9935776cbdf4b29a04ea9e9cda"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "Here's an exact quote briefly summarizing the topic from a slide for a university course found on the web, maybe it'll help clarify the historical confusion on this page:",
      "id": "b916598c9d6f167c37f7e8ef2d4c3bc7"
    },
    {
      "type": "html",
      "text": "\nLaw of Demeter",
      "id": "e5d3b92df6e92cd87c258ac65a269a33"
    },
    {
      "type": "html",
      "text": " governs the communication structure within an object-oriented design",
      "id": "c24625ac85505ea890593aaf4c04ad24"
    },
    {
      "type": "html",
      "text": " restricts message-sending statements in method implementations",
      "id": "319c0d8a49f756d1b0ff8a4e99a166fd"
    },
    {
      "type": "html",
      "text": " only talk to your immediate friends",
      "id": "6899155083d17e750d15c27de6f383e1"
    },
    {
      "type": "html",
      "text": " message target can only be one of the following objects:",
      "id": "17c7ee8c7ef5b841b611514d83eaea31"
    },
    {
      "type": "html",
      "text": "1 the method's object itself (C++, Java, C#:<br>this; Smalltalk: self, super; VB.NET: Me)",
      "id": "48491d0106b39bbe11cd06725068569f"
    },
    {
      "type": "html",
      "text": " an object that is an argument in the method's signature",
      "id": "0831ed482027593c1de345252d08651d"
    },
    {
      "type": "html",
      "text": " an object referred to by the object's attribute",
      "id": "c2c41fdea168e77963a910d87bd305fd"
    },
    {
      "type": "html",
      "text": " an object created by the method",
      "id": "8e616a464732a6d6c82191deff3b47dc"
    },
    {
      "type": "html",
      "text": " an object referred to by a global variable",
      "id": "f240b3b22a52b5fcd703da9bcee53b14"
    },
    {
      "type": "html",
      "text": "<i>Note: format changed by a [[Wiki Gnome]]. Original at [http://isys.uni-klu.ac.at/ISYS/Courses/02WS/sete/folien/Fse0207_DFDConcepts.pdf isys.uni-klu.ac.at] (Google HTML version, strip everything before www.isys for address of original PDF).</i>",
      "id": "a7222f3d96e1e374bf7282a04137e41d"
    },
    {
      "type": "html",
      "text": "\nAn alternative take (trying to improve) is proposed in [[Law Of Demeter Revisited]].",
      "id": "5bad56744b4dad21e88ab3b843d0e050"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "\nBefore reading further please see [[Law Of Demeter Vs Information Hiding]], [[Law Of Demeter Makes Unit Tests Easier]], [[Law Of Demeter Is Hard To Understand]], [[Law Of Demeter Is Too Restrictive]], [[Law Of Demeter And Coupling]].",
      "id": "47b2f79805bbeb72dc70910783fe4b10"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "The Demeter literature talks about the introduction of <b>lots</b> of additional small methods, which started getting unwieldy to add manually, and is part of why the Demeter tools exists, so they can be autogenerated as needed.",
      "id": "5e6949bbb674fe85154b86ed9fd167fa"
    },
    {
      "type": "html",
      "text": "\nThis gets into issues of propagation of results of partial computations, which is a whole other area of Demeter called \"propagation patterns\" (not be confused with \"design patterns\"). Beyond the straightforward stuff, trying to go \"full\" Demeter without the niceties of the \"full\" Demeter system has lots of not niceties\" associated with it because without Demeter's tool-support you can't so easily propagate what is needed where in an orthogonal fashion. -- [[Anonymous Donor]]",
      "id": "1ebe307b8e9b2e3b52022ade21d9f6d9"
    },
    {
      "type": "html",
      "text": "<i>I don't see this as a problem. I think [[Few Short Methods Per Class]] and lack of [[Fear Of Adding Classes]] fits [[Law Of Demeter]]. -- [[Guillermo Schwarz]]</i>",
      "id": "90eb4f415da3e7f407613c1ef4c13bdd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "\nLoD can be regarded as the principle of assuming \"least structural knowledge\" (something its creator calls \"Structure-shy programming\"). The idea is to assume knowledge of no object's internal structure other than your own immediate self.",
      "id": "29754754163a17f12f733bc8bec007d0"
    },
    {
      "type": "html",
      "text": "\nWhen an object is encapsulating structural knowledge and you try to take advantage of that, your object method is making a rigid assumption about the traversal path to access that knowledgehen they represent facets of the problem domain.'' ",
      "id": "a3e7a9fdf8844cc99ca3d2e67ec694de"
    },
    {
      "type": "html",
      "text": "<i>If a fundamental structural relationship in the domain really does change then its almost certain that a clients requirements of the interface will also change and thus the facade provided by the outer objects hasn't bought you anything other than an extra layer (or even several layers) of code to maintain. Conversely, a structural change that is not domain oriented should be hidden behind a bridge where it cannot affect the exposed structure.</i>",
      "id": "c8cba12062774f33f2aaef10b0bcca05"
    },
    {
      "type": "html",
      "text": "<i>Structural relationships between objects are a powerful abstraction mechanism in their own right, and thus a powerful force for simplicity when used in the right place -- Paul Campbell</i>",
      "id": "e3228c37fddaae8733665e2bd00f2558"
    },
    {
      "type": "html",
      "text": "\nThe Law of Demeter is (or might be in some designs) related to the [[Visitor Pattern]]: if you have to do something to object X at the end of a long chain of composites and accessors, the wrong way is digging up X yourself and perform the operation directly; one of the good ways is having a Visitor look for object X with the collaboration of all involved objects.",
      "id": "b463ace1d0508968988328d0f3d3c04e"
    },
    {
      "type": "html",
      "text": "\nIt is much less brittle because you don't need to know the details of the data structure; the visitor only needs to visit X to do its job. The visitor can also seek objects satisfying some condition. ",
      "id": "3dfc78c5d4795de180342d95d50aa852"
    },
    {
      "type": "html",
      "text": "\nThe use of a visitor in this case is motivated by the fact that the intermediate objects don't know (and probably have no business knowing) how to do the special operation you want, but they can be expected to support a generic visitor.",
      "id": "99df06b0b9238f642f3e5c6d0346227c"
    },
    {
      "type": "html",
      "text": "\nSome work by [[Karl Lieberherr]] (see his university page) has the purpose of generating the visitor infrastructure from object graphs; it can perhaps be considered an instance of [[Aspect Oriented Programming]] (the aspect of visiting messy object graphs). -- [[Lorenzo Gatti]]",
      "id": "8ee74fac50eb795fc887c98730c7ce9d"
    },
    {
      "type": "html",
      "text": "\nPerhaps what is needed is a hierarchical composite - Pass the Person node to a Find<b></b>Whatever<b></b>Visitor class whose result is the value you need. Then <i>person deductionProfiles last stateTaxDeduction amount</i> each class may need a method that reports what elements are composites and leafs and a method to indicate what kind of composite it is, but you've removed the need for at least a part of this problem. The ImA() <i>(or Kind<b></b>Of() )</i>, My<b></b>Leaves<b></b>Are() and My<b></b>Composites<b></b>Are() methods work well in testing as well if you've forgotten what is in your composite. Of course, this is more code that you may not need. -- [[Wyatt Matthews]].",
      "id": "9e6561dc7db9a4ec1072c81a995ef73b"
    },
    {
      "type": "html",
      "text": "\n[[Object Queries]] and the [[Adapter Pattern]] are two ways to implement the [[Law Of Demeter]]. -- [[Dave Orme]]",
      "id": "f2e7f485c4d31510fee0ec0eb1bbfb60"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "<i> You'll likely find similar code all over the system</i> - That repetition is itself sufficient reason to refactor. [[Once And Only Once]]. We don't need Demeter to tell us that. -- [[Dave Harris]]",
      "id": "c2ba76c42cf03cae01649b1da2c69377"
    },
    {
      "type": "html",
      "text": "\nMy XP formulation about [[Shield Pattern]] is described in [[Bridge Pattern Is Just Good Factoring]]. When we see a method like:",
      "id": "3b38f9ce2d56a4a1c09bb99491b48b68"
    },
    {
      "type": "code",
      "text": "  person profiles identityProfile lastName",
      "id": "d4ad7089d2a946bd843c2279789bec4d"
    },
    {
      "type": "html",
      "text": "we tend to replace it with",
      "id": "68eb80c191b675b1fd80f259f3a4a3d9"
    },
    {
      "type": "code",
      "text": "  person lastName",
      "id": "5a3c4646820e0dbc621f2e299d08fa72"
    },
    {
      "type": "html",
      "text": "with the appropriate definition of lastName in Person. Apply recursively. If you look at this from the viewpoint of [[Shield Pattern]], you can say we do it because the handling of profiles is up to Person. We just think it makes the code look nicer ;-> (I oversimplify for effect, of course.) -- [[Ron Jeffries]]",
      "id": "eff88dd789839911523d7248dc32da21"
    },
    {
      "type": "html",
      "text": "<i>I also create:</i>",
      "id": "0cbff8595fd43d954225454ef8268574"
    },
    {
      "type": "code",
      "text": "  person identityProfile",
      "id": "3616165dbcf7695c931a0a00b498394f"
    },
    {
      "type": "html",
      "text": "<i>as</i>",
      "id": "6e876db804e53db0cb18d0f22246bea0"
    },
    {
      "type": "code",
      "text": "  ^self profiles identityProfile",
      "id": "bcc11117d10b6b7c3c42bec135f29736"
    },
    {
      "type": "html",
      "text": "<i>Of course you see that kind of code all the time in Smalltalk, but very few times in Java.</i>",
      "id": "5395ff0487355d274236b918bc207260"
    },
    {
      "type": "html",
      "text": "-- [[Guillermo Schwarz]]",
      "id": "6e1f038ad05bd239f039c89873939670"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "\nSometimes different just think it makes the code look nicer ;-> (I oversimplify for effect, of course.) -- [[Ron Jeffries]]",
      "id": "ecd801ada1a597003e76b92d02d3c29e"
    },
    {
      "type": "html",
      "text": "<i>I also create:</i>",
      "id": "0cbff8595fd43d954225454ef8268574"
    },
    {
      "type": "code",
      "text": "  person identityProfile",
      "id": "3616165dbcf7695c931a0a00b498394f"
    },
    {
      "type": "html",
      "text": "<i>as</i>",
      "id": "6e876db804e53db0cb18d0f22246bea0"
    },
    {
      "type": "code",
      "text": "  ^self profiles identityProfile",
      "id": "bcc11117d10b6b7c3c42bec135f29736"
    },
    {
      "type": "html",
      "text": "<i>Of course you see that kind of code all the time in Smalltalk, but very few times in Java.</i>",
      "id": "5395ff0487355d274236b918bc207260"
    },
    {
      "type": "html",
      "text": "-- [[Guillermo Schwarz]]",
      "id": "6e1f038ad05bd239f039c89873939670"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "\nSometimes different clients need different types of access. With regard to the dog mentioned above: A vet may very well want to violate a dog's encapsulation and manipulate its legs directly. So it seems like the [[Law Of Demeter]], as an axiom, is flat out opposed to any sort of inspection/reflection business.",
      "id": "0a20e2d80b433f4263448a9a21363e6e"
    },
    {
      "type": "html",
      "text": "<i>Reflection doesn't necessarily violate the [[Law Of Demeter]] if you keep in mind the \"principle of least structural knowledge\" definition. You're supposed to encapsulate structural knowledge in a few places in the code; nothing in reflection would necessarily contradict that. Now, if you make assumptions about what to look for when inspecting, that would need to be modified if the access path/interface changes, then that very well could be a violation of the [[Law Of Demeter]].</i>",
      "id": "23dfa3ff900d6528e46e7ec0b76dd77b"
    },
    {
      "type": "html",
      "text": "\nSee also: [[Interface Market]]",
      "id": "7171323a7a38b3d90c693e7819aabaca"
    },
    {
      "type": "html",
      "text": "\nA vet should be able to manipulate the Dog's leg as it is a 'visible interface'. He, however, can manipulate the Dog's intestinal parasites only via an available interface, i.e. the mouth, by the introduction of worming tables. To do otherwise, i.e. to operate, would break the 'rules'. -- [[Nick Adie]]",
      "id": "161036fc9197efb777d5a7ece93e7089"
    },
    {
      "type": "html",
      "text": "\nIn fact we can make the Leg interface visible only to the Vet. E.g. Dog exposes Leg objects via its allow_manipulation_by(Vet) method which only accepts a Vet. This method, if the Dog is not using the Leg, passes the Leg to the Vet by calling the allowed_to_manipulate(Leg) method, hence the interfaces must hold good if the interface check holds good.  For real safety the Dog could pass a proxy instead which it can release at any point, that way the Vet cannot manipulate the Leg if the Dog does not like it. It occurred to me that following the laws of Demeter effectively prohibits return statements from methods. I find that banishing return statements from my code and solving problems without them has excellent effects on readability and flexibility of classes. In effect it forces two-way contracts between objects, which seems to be beneficial. Unlike the following post, I have found this extends to Collections and [[Value Objects]]. Factories, however, do seem to need to return objects.",
      "id": "b19312433b3413afc8d19a610c293e99"
    },
    {
      "type": "html",
      "text": "-- [[Mike Amy]]",
      "id": "a4fc8d00d41aee3b80b224e23f184de8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "\nI've had success applying the Law of Demeter by allowing exceptions for three kinds of class:",
      "id": "b2b85b3303fb3620157f69d5ab29ddd7"
    },
    {
      "type": "html",
      "text": " Collections (as described above)",
      "id": "66232e706d3704d881554a9a4852aaa2"
    },
    {
      "type": "html",
      "text": " [[Value Object]]s (especially as I follow [[Value Objects Should Be Immutable]])",
      "id": "b36e819b6589f1202d531977aaf9b924"
    },
    {
      "type": "html",
      "text": " Factories (and any object that returns another object and does <i>not</i> keep its own reference to the returned object).",
      "id": "cd59327bf1b51d2146547acfa60f54fb"
    },
    {
      "type": "html",
      "text": "\nSo, in my code the Law of Demeter only applies to [[Reference Object]]s that embody domain knowledge. This has been very successful in making code easy to read, easy to test and easy to change. The use of automatic refactoring tools helps a great deal with the \"easy to change\" aspect, so I'm not sure how well this would work in a more manual coding environment. -- [[Nat Pryce]]",
      "id": "81073755442bf5aab1d97b4aef744f66"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "See [[Demeter Goddess]] to see where this name came from.",
      "id": "003a565105c85960c16c5a54b976f97f"
    },
    {
      "type": "html",
      "text": " <i>Wikipedia is not a dictionary, but I'd be interested in what the connection with the goddess is.</i>",
      "id": "420a4c6e5c4985ed1eb02c156db04675"
    },
    {
      "type": "html",
      "text": " Taken from [http://www.ccs.neu.edu/home/lieber/LoD.html: www.ccs.neu.edu] 2003 was the 15 Year Anniversary of the Law of Demeter: The Law of Demeter is a simple style rule for designing [[Object Oriented]] systems. \"Only talk to your immediate friends\" is the motto. The style rule was first proposed at Northeastern University in the fall of 1987 and popularized in books by Booch, Budd, Coleman, Larman, Page-Jones, Rumbaugh and others. A 2000 book that describes it well is The Pragmatic Programmer by [[Andrew Hunt]] and [[David Thomas]]. The name \"Law of Demeter\" was chosen because the style rule was discovered while working on the The Demeter Project which ever since was strongly influenced by the Law of Demeter. The Demeter Project develops tools that make it easier to follow the Law of Demeter. (Demeter = Greek Goddess of Agriculture; grow software in small steps) For example, \"only talk to your immediate friends that share the same concerns\" leads to tools for Aspect-Oriented Software Development.",
      "id": "1ba51aa6facb322d21f557467dd06c27"
    },
    {
      "type": "html",
      "text": "\nI wonder [[Can Law Of Demeter Be Refactored Automatically]]?",
      "id": "8d9a77ad8c913547dd919e4c92a93f2f"
    },
    {
      "type": "html",
      "text": "See also: [[Encapsulation Is Hierarchical]], [[Tree Oriented Perspective]], [[Tell Dont Ask]], [[Shield Pattern]], [[Capability Computing]], [[Law Of Demeter Example]], [[Alternate Hard And Soft Layers]], [[Shearing Layers]].",
      "id": "189e6c585598511f726bd359d22c05a6"
    },
    {
      "type": "html",
      "text": "\nOther references:",
      "id": "af13caad7cdd2c61ebeaa7813a62aee0"
    },
    {
      "type": "html",
      "text": " [http://www.ccs.neu.edu/home/lieber/LoD.html www.ccs.neu.edu]",
      "id": "5d680694f24e2be033d446579cebbd31"
    },
    {
      "type": "html",
      "text": " [http://www.enteract.com/~bradapp/docs/demeter-intro.html www.enteract.com]",
      "id": "ce4b8aec508dbf326de6e6a2f11f5b20"
    },
    {
      "type": "html",
      "text": " [Lieberherr89] Lieberherr, Karl. J. and Holland, I. Assuring good style for object-oriented programs IEEE Software, September 1989, pp 38-48",
      "id": "d617b1f9cb424f25a5a9a50641bb2caf"
    },
    {
      "type": "html",
      "text": " [Lieberherr96] Karl Lieberherr, Adaptive Object Oriented Software - The Demeter Method, PWS Publishing Co., Boston, 1996.",
      "id": "8feb83b7bb6e4879fa3dc7cf9240b469"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "\nWe think it's possible to try <i>too</i> hard to avoid violating this rule. For example, adding in 'convenience' methods, which act as bridges, or over-zealous\nuse of the [[Shield Pattern]].",
      "id": "38070f638405b375dd322c54f6e7751b"
    },
    {
      "type": "html",
      "text": "\nWe've just finished a pair-programming session where we've found that taking <i>out</i> these convenience methods helps to reveal\n[[Feature Envy]], which in turn indicates refactorings which otherwise would have remained hidden. ",
      "id": "80fc3371e5c86f089ade4b0f43d61f64"
    },
    {
      "type": "html",
      "text": "\nAnd finally, there's no problem breaking [[Law Of Demeter]] in tests, right? -- [[Malcolm Sparks]], [[Eamon Walshe]] (pairing)",
      "id": "75a217c04978782d02203b658f091c70"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "\nIOW: do not call",
      "id": "8afc30fe4cd2b5792dc61647080cf0be"
    },
    {
      "type": "code",
      "text": "  foo.getBar().doSomething()",
      "id": "7f901081bf58ce065465dae32efa5bdc"
    },
    {
      "type": "html",
      "text": "\ninstead, implement doSomething() on Foo by having it call bar. ",
      "id": "a4c2ca65baafb0ee5382580db8e4c874"
    },
    {
      "type": "html",
      "text": " from the caller's point of view, the thing that you are interested in is \"what does bar do?\"",
      "id": "59e0639d5875b6796f690de8496de8e5"
    },
    {
      "type": "html",
      "text": " from Bar's point of view, I don't want people monkeying about with my contents without me knowing about it. Maybe bar always needs to do a thing before and after foo does something.",
      "id": "94eb2750e1afaf22689d5fdda2b319a4"
    },
    {
      "type": "html",
      "text": "\nI would like a [[Java Language]] feature allowing you to do this declaratively.",
      "id": "7e175fe9a30f70b6dad35f80b5af2b29"
    },
    {
      "type": "code",
      "text": "  class Foo implements IBar {\n  // all calls to IBar methods on Foo get implemented by calls to this variable  \n  IBar myIbar implements IBar;",
      "id": "651ee17be825ef006b770087867082b9"
    },
    {
      "type": "code",
      "text": "  // except for barMethod, which I implement here explicitly\n  void barMethod3() {...}\n  }",
      "id": "33fe11cb2d407a83e67e549c3d25f157"
    },
    {
      "type": "html",
      "text": "\nthe compiler would generate methods barMethod1(), barMethod2(), barMethod4() etc.",
      "id": "d5b662a4b9321e6ef11a72a38834eee9"
    },
    {
      "type": "html",
      "text": "<i>Or you could just use Objective-C or Smalltalk...</i>",
      "id": "f5acfedf66b667a34fc297ef77db3243"
    },
    {
      "type": "html",
      "text": "<i>Is this generally refuting the technique of \"pathing\", such as that commonly found in [[Java Script]] DOM references where you get long references? They tend to look like:</i>",
      "id": "63a5723c902263103157cb02a5cb6248"
    },
    {
      "type": "code",
      "text": "  todds.parents.dogs.bitee.brothers.house.garage.door.open();",
      "id": "00f859082ad30c84f27cdaae7940dffa"
    },
    {
      "type": "html",
      "text": "\nWell, in that case the structure may actually be important.  But often it's still better to get a hold of objects via id references...",
      "id": "0a9297def30adee49d431d15ec564178"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "Trying to come up with a more simple (non-foobar) example, is this correct?",
      "id": "0e2804edf9b2585efa5cc455d14a7f30"
    },
    {
      "type": "code",
      "text": "  currentPerson.Account.Deposit(500)  <-- bad\n  Account.Deposit(currentPerson, 500)  <-- good",
      "id": "3f6c5d308104589195d75193a32be837"
    },
    {
      "type": "html",
      "text": "Reason:",
      "id": "d9a20dd47e942c0b329dc587584a46ff"
    },
    {
      "type": "code",
      "text": "  Account may need to be initialized before it can be accessed\n  Say currentPerson.Account = null, will throw null reference exception in bad code\n  In good code, Deposit method can check if null and setup a new one before depositing",
      "id": "06b55471d39a429284103569bbfd5594"
    },
    {
      "type": "html",
      "text": "---- ",
      "id": "43de89a3183e617bd6a029e7104d9dfd"
    },
    {
      "type": "code",
      "text": "    currentPerson.give(500)    <-- best\n  Reason:\n    LawOfDemeter implies you shouldn't care how currentPerson stores his money, just that he gets it.\n    You do not care if he puts it in a bankAccount, usedSock, hiddenSafe, or \n    happens to be a 'CEO extends person' who calls myInvestmentManager.handleMoneyForMe(500)",
      "id": "7d025aa59327cd269e1eb23545d9a2d2"
    },
    {
      "type": "code",
      "text": "  -- AnonymousStudent (reading this page taught me all I needed to know to understand this, you guys are educational!)",
      "id": "48c132573a109d7d2b6f764002f948e2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "In a banking system you would give money to someone's account not to them, so far from being bad, navigating via the account object would convey essential semantics for example in the case the person had multiple accounts. If you have a canonical domain model then the all object relationships convey essential semantics about the information that is being represented. If you bridge those relationships before presenting access to client code then that information is lost. The fact that you could afford to bridge it implies that the structural information wasn't needed and hence your model wasn't canonical. If your model is non-canonical then refactor it so it is - don't bridge it. Of course your client code will then be dependent on the structure of your model but that is essential in order for the it add value to the system. Hence so long as your model is canonical with respect to the problem domain then [[Law Of Demeter]] is an anachronism.",
      "id": "0d81bb6d20bec3c1f426174ef07227b5"
    },
    {
      "type": "code",
      "text": "  -- Paul Campbell",
      "id": "cdb75cb526795e484bb60e3f6f148888"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "\nWhat about when you want to look something up in a dictionary with more than one index in something like Java? You could define a pair object with a comparable interface on it, but that requires writing a new class for each different number of indices. I think a more natural way of doing this is curried dictionaries, like [[Hash Map]]<[[First Index]], [[Hash Map]]<[[Second Index]], Value>>. Then when looking up you do dictionary.get(firstIndex).get(secondIndex). ",
      "id": "3127dee34a882212cfb67db149866993"
    },
    {
      "type": "html",
      "text": " Does this break [[Law Of Demeter]]",
      "id": "b6881e07f98c27c029ac7acc7b7ed88d"
    },
    {
      "type": "html",
      "text": " If so, what's the better way of doing it?",
      "id": "c6717bc8af7e568b8449c76673c94597"
    },
    {
      "type": "code",
      "text": "  Seems to me that repeatedly typing dictionary.get(firstIndex).get(secondIndex) each time you access something is at least annoying and error-prone, and maybe even a CodeSmell to use OnceAndOnlyOnce (am I correct?).\n  My guess at a better way would be something like:",
      "id": "d623aa59a765182630c6f5b18775c35b"
    },
    {
      "type": "code",
      "text": "  class myComplexDict {\n    private myMap = new hashMap<firstIndexType, HashMap<secondIndexType, Value>>;\n    public Value get(firstIndex, secondIndex) {\n      return this.myMap.get(firstIndex).get(secondIndex);\n    }\n  }",
      "id": "de0cda21aaaae73bcfedfd11ea8b01d7"
    },
    {
      "type": "code",
      "text": "  This also gives you more freedom to change implementation if Java suddenly decides to implement a 'multiDimensionMap<K[], V>' in some future specification (Or if your pairwise coder comes up with something better). (Is that a good thing? or OverEngineering ?)\n  I don't think it breaks LawOfDemeter 'because of using two dots', gathering from this page, the LOD seems to be less strict for 'primitive' datatypes like this.\n  -- AnonymousStudent (again!)",
      "id": "c6fca73e907376af14e97b4ac8bfaea5"
    },
    {
      "type": "html",
      "text": "<i>I agree with the student. A \"dictionary with more than one index\" <b>is</b> just a single-index dictionary with the index being a tuple of indices. --Salvatore</i>",
      "id": "ba9663e028e019d0a7e7a9fa6f099a7d"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "[[Is Law Of Demeter Overspecified On Cee Two]]",
      "id": "afc4b0698469dffaebc0e28884aad65f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "'Tis a silly law with diminishing returns on model complexity. Interesting, but irrelevant except in remarkably simple cases.",
      "id": "7764741387fea6be22700d89879123b0"
    },
    {
      "type": "html",
      "text": "\nSee [[Contractive Delegation]].",
      "id": "fc87f6c020f4a464f266e561d91a098d"
    },
    {
      "type": "html",
      "text": "---\nI would tend to agree that going knee-deep in child calls etc is a bad idea, but one of the benefits of coding to an interface is that you know what you're getting back. It's not the name of the methods or properties that are significant in a contract... it's the type of interface (or primitive) that comes back.  If that's specified in the contract, then it's safe to call a method of it.. say like .toString() (or [[To String]](), depending on your flavor).  This is true for unit testing as well since you're using the known contract... that's why we have them.. so we know what we're getting and what we can do with it. someone somewhere who takes this too literally is losing sight of what programs are for... and it's not to make pretty source code for programmers.",
      "id": "10d36aa5689652f8755092fd10d441c7"
    },
    {
      "type": "html",
      "text": "-- anonymous dave",
      "id": "645713ef40b6f0e78c3ac6fd93719d23"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "An interesting corollary is: “Don't chain bang,” that is don't write ruby code like",
      "id": "3b78649261d8bab0cd04bc102667465a"
    },
    {
      "type": "code",
      "text": "  list.flatten!.uniq!.compact!",
      "id": "df3c9a73f3292b62529ce1a4c57217b9"
    },
    {
      "type": "html",
      "text": "\nThe naive assumption is that each method would return the list, which was modified in place. But in fact, each method may return nil, causing the next method call to raise a [[No Method Error]].",
      "id": "620a207ecf93a3a1b2c62ac77ebf80fa"
    },
    {
      "type": "html",
      "text": "-- [[Joseph Holsten]]",
      "id": "657d257648ac9790177414f34e8a1265"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "a2388ca36f60e159024c87dc3fd3c2d5"
    },
    {
      "type": "html",
      "text": "[[Category Modeling Laws And Principles]]",
      "id": "24abb391638da5ea9905cfb19721a180"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?LawOfDemeter c2.com]",
      "id": "5ae8639eee0fe8d275608a150535472c"
    }
  ],
  "journal": [
    {
      "date": 1417625563000,
      "id": "b1282756a3a0d8f6f9ad02e81944b77f",
      "type": "create",
      "item": {
        "title": "Law Of Demeter",
        "story": [
          {
            "type": "html",
            "text": "The [[Law Of Demeter]] specifies a style guideline: \"Only talk to your immediate friends.\" E.g. one never calls a method on an object you got from another call nor on a global object. This helps a lot later when you [[Re Factor]] the code.",
            "id": "c7fb4c82e93b13feea9a6e88de1ecf87"
          },
          {
            "type": "html",
            "text": "\n[http://www.ccs.neu.edu/research/demeter/papers/law-of-demeter/oopsla88-law-of-demeter.pdf www.ccs.neu.edu]",
            "id": "39166795b2aed714e72c7834681064c8"
          },
          {
            "type": "html",
            "text": "\n[[Peter Van Rooijen]] posted the following description of the [[Law Of Demeter]] to Usenet:",
            "id": "fdae362e644325b540280166516e6565"
          },
          {
            "type": "html",
            "text": " You can play with yourself.",
            "id": "f807faa30f0edbb7c559ca4d47ef040f"
          },
          {
            "type": "html",
            "text": " You can play with your own toys (but you can't take them apart),",
            "id": "c7b8bafd795f7d7283818dd621875968"
          },
          {
            "type": "html",
            "text": " You can play with toys that were given to you.",
            "id": "775833b5c7afbeac0540107bffabd4ff"
          },
          {
            "type": "html",
            "text": " And you can play with toys you've made yourself.",
            "id": "18e988ef0f937b9b276fd30f75c8efba"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "\nExplanation in plain English:",
            "id": "6ce70cbe7d6c9cbe14eb9f2ac882192a"
          },
          {
            "type": "html",
            "text": " Your method can call other methods in its class directly",
            "id": "967e313fff65d587c2494295e77b92ab"
          },
          {
            "type": "html",
            "text": " Your method can call methods on its own fields directly (but not on the fields' fields)",
            "id": "c5621dea7c98496166149e360ff08b0b"
          },
          {
            "type": "html",
            "text": " When your method takes parameters, your method can call methods on those parameters directly.",
            "id": "e13be80740ce71c62f7f53942dd7c163"
          },
          {
            "type": "html",
            "text": " When your method creates local objects, that method can call methods on the local objects.",
            "id": "1904863a748e28ffaf954ef464a38982"
          },
          {
            "type": "html",
            "text": "\nbut",
            "id": "b388fb981fe1f881cc9745c8bf7d9d96"
          },
          {
            "type": "html",
            "text": " One should not call methods on a global object (but it can be passed as a parameter ?)",
            "id": "716aaec3c860a87c9e584b15f7295002"
          },
          {
            "type": "html",
            "text": " One should not have a chain of messages a.getB().getC().doSomething() in some class other than a's class.",
            "id": "36fb3eab6f57f5180f49ffc021d56813"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "<i>One should not have a chain of messages a.getB().getC().doSomething() in some class other than a's class.</i>",
            "id": "08a47898cddc95a00a48779bc321223c"
          },
          {
            "type": "html",
            "text": "\nI have a slight problem with this.  Even if you limit calls to a.getB().getC().doSomething() to within class 'a', aren't you still violating the principle in terms of 'b' since 'a' is calling b.getC().doSomething() ?",
            "id": "6389e2e5c7798126f3675b6439222c4f"
          },
          {
            "type": "html",
            "text": "\nSo 'b' needs a method called doSomething() that calls c.doSomething() and then 'a' needs a method called doSomething that calls b.doSomething()",
            "id": "45159e9935776cbdf4b29a04ea9e9cda"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "Here's an exact quote briefly summarizing the topic from a slide for a university course found on the web, maybe it'll help clarify the historical confusion on this page:",
            "id": "b916598c9d6f167c37f7e8ef2d4c3bc7"
          },
          {
            "type": "html",
            "text": "\nLaw of Demeter",
            "id": "e5d3b92df6e92cd87c258ac65a269a33"
          },
          {
            "type": "html",
            "text": " governs the communication structure within an object-oriented design",
            "id": "c24625ac85505ea890593aaf4c04ad24"
          },
          {
            "type": "html",
            "text": " restricts message-sending statements in method implementations",
            "id": "319c0d8a49f756d1b0ff8a4e99a166fd"
          },
          {
            "type": "html",
            "text": " only talk to your immediate friends",
            "id": "6899155083d17e750d15c27de6f383e1"
          },
          {
            "type": "html",
            "text": " message target can only be one of the following objects:",
            "id": "17c7ee8c7ef5b841b611514d83eaea31"
          },
          {
            "type": "html",
            "text": "1 the method's object itself (C++, Java, C#:<br>this; Smalltalk: self, super; VB.NET: Me)",
            "id": "48491d0106b39bbe11cd06725068569f"
          },
          {
            "type": "html",
            "text": " an object that is an argument in the method's signature",
            "id": "0831ed482027593c1de345252d08651d"
          },
          {
            "type": "html",
            "text": " an object referred to by the object's attribute",
            "id": "c2c41fdea168e77963a910d87bd305fd"
          },
          {
            "type": "html",
            "text": " an object created by the method",
            "id": "8e616a464732a6d6c82191deff3b47dc"
          },
          {
            "type": "html",
            "text": " an object referred to by a global variable",
            "id": "f240b3b22a52b5fcd703da9bcee53b14"
          },
          {
            "type": "html",
            "text": "<i>Note: format changed by a [[Wiki Gnome]]. Original at [http://isys.uni-klu.ac.at/ISYS/Courses/02WS/sete/folien/Fse0207_DFDConcepts.pdf isys.uni-klu.ac.at] (Google HTML version, strip everything before www.isys for address of original PDF).</i>",
            "id": "a7222f3d96e1e374bf7282a04137e41d"
          },
          {
            "type": "html",
            "text": "\nAn alternative take (trying to improve) is proposed in [[Law Of Demeter Revisited]].",
            "id": "5bad56744b4dad21e88ab3b843d0e050"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "\nBefore reading further please see [[Law Of Demeter Vs Information Hiding]], [[Law Of Demeter Makes Unit Tests Easier]], [[Law Of Demeter Is Hard To Understand]], [[Law Of Demeter Is Too Restrictive]], [[Law Of Demeter And Coupling]].",
            "id": "47b2f79805bbeb72dc70910783fe4b10"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "The Demeter literature talks about the introduction of <b>lots</b> of additional small methods, which started getting unwieldy to add manually, and is part of why the Demeter tools exists, so they can be autogenerated as needed.",
            "id": "5e6949bbb674fe85154b86ed9fd167fa"
          },
          {
            "type": "html",
            "text": "\nThis gets into issues of propagation of results of partial computations, which is a whole other area of Demeter called \"propagation patterns\" (not be confused with \"design patterns\"). Beyond the straightforward stuff, trying to go \"full\" Demeter without the niceties of the \"full\" Demeter system has lots of not niceties\" associated with it because without Demeter's tool-support you can't so easily propagate what is needed where in an orthogonal fashion. -- [[Anonymous Donor]]",
            "id": "1ebe307b8e9b2e3b52022ade21d9f6d9"
          },
          {
            "type": "html",
            "text": "<i>I don't see this as a problem. I think [[Few Short Methods Per Class]] and lack of [[Fear Of Adding Classes]] fits [[Law Of Demeter]]. -- [[Guillermo Schwarz]]</i>",
            "id": "90eb4f415da3e7f407613c1ef4c13bdd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "\nLoD can be regarded as the principle of assuming \"least structural knowledge\" (something its creator calls \"Structure-shy programming\"). The idea is to assume knowledge of no object's internal structure other than your own immediate self.",
            "id": "29754754163a17f12f733bc8bec007d0"
          },
          {
            "type": "html",
            "text": "\nWhen an object is encapsulating structural knowledge and you try to take advantage of that, your object method is making a rigid assumption about the traversal path to access that knowledgehen they represent facets of the problem domain.'' ",
            "id": "a3e7a9fdf8844cc99ca3d2e67ec694de"
          },
          {
            "type": "html",
            "text": "<i>If a fundamental structural relationship in the domain really does change then its almost certain that a clients requirements of the interface will also change and thus the facade provided by the outer objects hasn't bought you anything other than an extra layer (or even several layers) of code to maintain. Conversely, a structural change that is not domain oriented should be hidden behind a bridge where it cannot affect the exposed structure.</i>",
            "id": "c8cba12062774f33f2aaef10b0bcca05"
          },
          {
            "type": "html",
            "text": "<i>Structural relationships between objects are a powerful abstraction mechanism in their own right, and thus a powerful force for simplicity when used in the right place -- Paul Campbell</i>",
            "id": "e3228c37fddaae8733665e2bd00f2558"
          },
          {
            "type": "html",
            "text": "\nThe Law of Demeter is (or might be in some designs) related to the [[Visitor Pattern]]: if you have to do something to object X at the end of a long chain of composites and accessors, the wrong way is digging up X yourself and perform the operation directly; one of the good ways is having a Visitor look for object X with the collaboration of all involved objects.",
            "id": "b463ace1d0508968988328d0f3d3c04e"
          },
          {
            "type": "html",
            "text": "\nIt is much less brittle because you don't need to know the details of the data structure; the visitor only needs to visit X to do its job. The visitor can also seek objects satisfying some condition. ",
            "id": "3dfc78c5d4795de180342d95d50aa852"
          },
          {
            "type": "html",
            "text": "\nThe use of a visitor in this case is motivated by the fact that the intermediate objects don't know (and probably have no business knowing) how to do the special operation you want, but they can be expected to support a generic visitor.",
            "id": "99df06b0b9238f642f3e5c6d0346227c"
          },
          {
            "type": "html",
            "text": "\nSome work by [[Karl Lieberherr]] (see his university page) has the purpose of generating the visitor infrastructure from object graphs; it can perhaps be considered an instance of [[Aspect Oriented Programming]] (the aspect of visiting messy object graphs). -- [[Lorenzo Gatti]]",
            "id": "8ee74fac50eb795fc887c98730c7ce9d"
          },
          {
            "type": "html",
            "text": "\nPerhaps what is needed is a hierarchical composite - Pass the Person node to a Find<b></b>Whatever<b></b>Visitor class whose result is the value you need. Then <i>person deductionProfiles last stateTaxDeduction amount</i> each class may need a method that reports what elements are composites and leafs and a method to indicate what kind of composite it is, but you've removed the need for at least a part of this problem. The ImA() <i>(or Kind<b></b>Of() )</i>, My<b></b>Leaves<b></b>Are() and My<b></b>Composites<b></b>Are() methods work well in testing as well if you've forgotten what is in your composite. Of course, this is more code that you may not need. -- [[Wyatt Matthews]].",
            "id": "9e6561dc7db9a4ec1072c81a995ef73b"
          },
          {
            "type": "html",
            "text": "\n[[Object Queries]] and the [[Adapter Pattern]] are two ways to implement the [[Law Of Demeter]]. -- [[Dave Orme]]",
            "id": "f2e7f485c4d31510fee0ec0eb1bbfb60"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "<i> You'll likely find similar code all over the system</i> - That repetition is itself sufficient reason to refactor. [[Once And Only Once]]. We don't need Demeter to tell us that. -- [[Dave Harris]]",
            "id": "c2ba76c42cf03cae01649b1da2c69377"
          },
          {
            "type": "html",
            "text": "\nMy XP formulation about [[Shield Pattern]] is described in [[Bridge Pattern Is Just Good Factoring]]. When we see a method like:",
            "id": "3b38f9ce2d56a4a1c09bb99491b48b68"
          },
          {
            "type": "code",
            "text": "  person profiles identityProfile lastName",
            "id": "d4ad7089d2a946bd843c2279789bec4d"
          },
          {
            "type": "html",
            "text": "we tend to replace it with",
            "id": "68eb80c191b675b1fd80f259f3a4a3d9"
          },
          {
            "type": "code",
            "text": "  person lastName",
            "id": "5a3c4646820e0dbc621f2e299d08fa72"
          },
          {
            "type": "html",
            "text": "with the appropriate definition of lastName in Person. Apply recursively. If you look at this from the viewpoint of [[Shield Pattern]], you can say we do it because the handling of profiles is up to Person. We just think it makes the code look nicer ;-> (I oversimplify for effect, of course.) -- [[Ron Jeffries]]",
            "id": "eff88dd789839911523d7248dc32da21"
          },
          {
            "type": "html",
            "text": "<i>I also create:</i>",
            "id": "0cbff8595fd43d954225454ef8268574"
          },
          {
            "type": "code",
            "text": "  person identityProfile",
            "id": "3616165dbcf7695c931a0a00b498394f"
          },
          {
            "type": "html",
            "text": "<i>as</i>",
            "id": "6e876db804e53db0cb18d0f22246bea0"
          },
          {
            "type": "code",
            "text": "  ^self profiles identityProfile",
            "id": "bcc11117d10b6b7c3c42bec135f29736"
          },
          {
            "type": "html",
            "text": "<i>Of course you see that kind of code all the time in Smalltalk, but very few times in Java.</i>",
            "id": "5395ff0487355d274236b918bc207260"
          },
          {
            "type": "html",
            "text": "-- [[Guillermo Schwarz]]",
            "id": "6e1f038ad05bd239f039c89873939670"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "\nSometimes different just think it makes the code look nicer ;-> (I oversimplify for effect, of course.) -- [[Ron Jeffries]]",
            "id": "ecd801ada1a597003e76b92d02d3c29e"
          },
          {
            "type": "html",
            "text": "<i>I also create:</i>",
            "id": "0cbff8595fd43d954225454ef8268574"
          },
          {
            "type": "code",
            "text": "  person identityProfile",
            "id": "3616165dbcf7695c931a0a00b498394f"
          },
          {
            "type": "html",
            "text": "<i>as</i>",
            "id": "6e876db804e53db0cb18d0f22246bea0"
          },
          {
            "type": "code",
            "text": "  ^self profiles identityProfile",
            "id": "bcc11117d10b6b7c3c42bec135f29736"
          },
          {
            "type": "html",
            "text": "<i>Of course you see that kind of code all the time in Smalltalk, but very few times in Java.</i>",
            "id": "5395ff0487355d274236b918bc207260"
          },
          {
            "type": "html",
            "text": "-- [[Guillermo Schwarz]]",
            "id": "6e1f038ad05bd239f039c89873939670"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "\nSometimes different clients need different types of access. With regard to the dog mentioned above: A vet may very well want to violate a dog's encapsulation and manipulate its legs directly. So it seems like the [[Law Of Demeter]], as an axiom, is flat out opposed to any sort of inspection/reflection business.",
            "id": "0a20e2d80b433f4263448a9a21363e6e"
          },
          {
            "type": "html",
            "text": "<i>Reflection doesn't necessarily violate the [[Law Of Demeter]] if you keep in mind the \"principle of least structural knowledge\" definition. You're supposed to encapsulate structural knowledge in a few places in the code; nothing in reflection would necessarily contradict that. Now, if you make assumptions about what to look for when inspecting, that would need to be modified if the access path/interface changes, then that very well could be a violation of the [[Law Of Demeter]].</i>",
            "id": "23dfa3ff900d6528e46e7ec0b76dd77b"
          },
          {
            "type": "html",
            "text": "\nSee also: [[Interface Market]]",
            "id": "7171323a7a38b3d90c693e7819aabaca"
          },
          {
            "type": "html",
            "text": "\nA vet should be able to manipulate the Dog's leg as it is a 'visible interface'. He, however, can manipulate the Dog's intestinal parasites only via an available interface, i.e. the mouth, by the introduction of worming tables. To do otherwise, i.e. to operate, would break the 'rules'. -- [[Nick Adie]]",
            "id": "161036fc9197efb777d5a7ece93e7089"
          },
          {
            "type": "html",
            "text": "\nIn fact we can make the Leg interface visible only to the Vet. E.g. Dog exposes Leg objects via its allow_manipulation_by(Vet) method which only accepts a Vet. This method, if the Dog is not using the Leg, passes the Leg to the Vet by calling the allowed_to_manipulate(Leg) method, hence the interfaces must hold good if the interface check holds good.  For real safety the Dog could pass a proxy instead which it can release at any point, that way the Vet cannot manipulate the Leg if the Dog does not like it. It occurred to me that following the laws of Demeter effectively prohibits return statements from methods. I find that banishing return statements from my code and solving problems without them has excellent effects on readability and flexibility of classes. In effect it forces two-way contracts between objects, which seems to be beneficial. Unlike the following post, I have found this extends to Collections and [[Value Objects]]. Factories, however, do seem to need to return objects.",
            "id": "b19312433b3413afc8d19a610c293e99"
          },
          {
            "type": "html",
            "text": "-- [[Mike Amy]]",
            "id": "a4fc8d00d41aee3b80b224e23f184de8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "\nI've had success applying the Law of Demeter by allowing exceptions for three kinds of class:",
            "id": "b2b85b3303fb3620157f69d5ab29ddd7"
          },
          {
            "type": "html",
            "text": " Collections (as described above)",
            "id": "66232e706d3704d881554a9a4852aaa2"
          },
          {
            "type": "html",
            "text": " [[Value Object]]s (especially as I follow [[Value Objects Should Be Immutable]])",
            "id": "b36e819b6589f1202d531977aaf9b924"
          },
          {
            "type": "html",
            "text": " Factories (and any object that returns another object and does <i>not</i> keep its own reference to the returned object).",
            "id": "cd59327bf1b51d2146547acfa60f54fb"
          },
          {
            "type": "html",
            "text": "\nSo, in my code the Law of Demeter only applies to [[Reference Object]]s that embody domain knowledge. This has been very successful in making code easy to read, easy to test and easy to change. The use of automatic refactoring tools helps a great deal with the \"easy to change\" aspect, so I'm not sure how well this would work in a more manual coding environment. -- [[Nat Pryce]]",
            "id": "81073755442bf5aab1d97b4aef744f66"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "See [[Demeter Goddess]] to see where this name came from.",
            "id": "003a565105c85960c16c5a54b976f97f"
          },
          {
            "type": "html",
            "text": " <i>Wikipedia is not a dictionary, but I'd be interested in what the connection with the goddess is.</i>",
            "id": "420a4c6e5c4985ed1eb02c156db04675"
          },
          {
            "type": "html",
            "text": " Taken from [http://www.ccs.neu.edu/home/lieber/LoD.html: www.ccs.neu.edu] 2003 was the 15 Year Anniversary of the Law of Demeter: The Law of Demeter is a simple style rule for designing [[Object Oriented]] systems. \"Only talk to your immediate friends\" is the motto. The style rule was first proposed at Northeastern University in the fall of 1987 and popularized in books by Booch, Budd, Coleman, Larman, Page-Jones, Rumbaugh and others. A 2000 book that describes it well is The Pragmatic Programmer by [[Andrew Hunt]] and [[David Thomas]]. The name \"Law of Demeter\" was chosen because the style rule was discovered while working on the The Demeter Project which ever since was strongly influenced by the Law of Demeter. The Demeter Project develops tools that make it easier to follow the Law of Demeter. (Demeter = Greek Goddess of Agriculture; grow software in small steps) For example, \"only talk to your immediate friends that share the same concerns\" leads to tools for Aspect-Oriented Software Development.",
            "id": "1ba51aa6facb322d21f557467dd06c27"
          },
          {
            "type": "html",
            "text": "\nI wonder [[Can Law Of Demeter Be Refactored Automatically]]?",
            "id": "8d9a77ad8c913547dd919e4c92a93f2f"
          },
          {
            "type": "html",
            "text": "See also: [[Encapsulation Is Hierarchical]], [[Tree Oriented Perspective]], [[Tell Dont Ask]], [[Shield Pattern]], [[Capability Computing]], [[Law Of Demeter Example]], [[Alternate Hard And Soft Layers]], [[Shearing Layers]].",
            "id": "189e6c585598511f726bd359d22c05a6"
          },
          {
            "type": "html",
            "text": "\nOther references:",
            "id": "af13caad7cdd2c61ebeaa7813a62aee0"
          },
          {
            "type": "html",
            "text": " [http://www.ccs.neu.edu/home/lieber/LoD.html www.ccs.neu.edu]",
            "id": "5d680694f24e2be033d446579cebbd31"
          },
          {
            "type": "html",
            "text": " [http://www.enteract.com/~bradapp/docs/demeter-intro.html www.enteract.com]",
            "id": "ce4b8aec508dbf326de6e6a2f11f5b20"
          },
          {
            "type": "html",
            "text": " [Lieberherr89] Lieberherr, Karl. J. and Holland, I. Assuring good style for object-oriented programs IEEE Software, September 1989, pp 38-48",
            "id": "d617b1f9cb424f25a5a9a50641bb2caf"
          },
          {
            "type": "html",
            "text": " [Lieberherr96] Karl Lieberherr, Adaptive Object Oriented Software - The Demeter Method, PWS Publishing Co., Boston, 1996.",
            "id": "8feb83b7bb6e4879fa3dc7cf9240b469"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "\nWe think it's possible to try <i>too</i> hard to avoid violating this rule. For example, adding in 'convenience' methods, which act as bridges, or over-zealous\nuse of the [[Shield Pattern]].",
            "id": "38070f638405b375dd322c54f6e7751b"
          },
          {
            "type": "html",
            "text": "\nWe've just finished a pair-programming session where we've found that taking <i>out</i> these convenience methods helps to reveal\n[[Feature Envy]], which in turn indicates refactorings which otherwise would have remained hidden. ",
            "id": "80fc3371e5c86f089ade4b0f43d61f64"
          },
          {
            "type": "html",
            "text": "\nAnd finally, there's no problem breaking [[Law Of Demeter]] in tests, right? -- [[Malcolm Sparks]], [[Eamon Walshe]] (pairing)",
            "id": "75a217c04978782d02203b658f091c70"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "\nIOW: do not call",
            "id": "8afc30fe4cd2b5792dc61647080cf0be"
          },
          {
            "type": "code",
            "text": "  foo.getBar().doSomething()",
            "id": "7f901081bf58ce065465dae32efa5bdc"
          },
          {
            "type": "html",
            "text": "\ninstead, implement doSomething() on Foo by having it call bar. ",
            "id": "a4c2ca65baafb0ee5382580db8e4c874"
          },
          {
            "type": "html",
            "text": " from the caller's point of view, the thing that you are interested in is \"what does bar do?\"",
            "id": "59e0639d5875b6796f690de8496de8e5"
          },
          {
            "type": "html",
            "text": " from Bar's point of view, I don't want people monkeying about with my contents without me knowing about it. Maybe bar always needs to do a thing before and after foo does something.",
            "id": "94eb2750e1afaf22689d5fdda2b319a4"
          },
          {
            "type": "html",
            "text": "\nI would like a [[Java Language]] feature allowing you to do this declaratively.",
            "id": "7e175fe9a30f70b6dad35f80b5af2b29"
          },
          {
            "type": "code",
            "text": "  class Foo implements IBar {\n  // all calls to IBar methods on Foo get implemented by calls to this variable  \n  IBar myIbar implements IBar;",
            "id": "651ee17be825ef006b770087867082b9"
          },
          {
            "type": "code",
            "text": "  // except for barMethod, which I implement here explicitly\n  void barMethod3() {...}\n  }",
            "id": "33fe11cb2d407a83e67e549c3d25f157"
          },
          {
            "type": "html",
            "text": "\nthe compiler would generate methods barMethod1(), barMethod2(), barMethod4() etc.",
            "id": "d5b662a4b9321e6ef11a72a38834eee9"
          },
          {
            "type": "html",
            "text": "<i>Or you could just use Objective-C or Smalltalk...</i>",
            "id": "f5acfedf66b667a34fc297ef77db3243"
          },
          {
            "type": "html",
            "text": "<i>Is this generally refuting the technique of \"pathing\", such as that commonly found in [[Java Script]] DOM references where you get long references? They tend to look like:</i>",
            "id": "63a5723c902263103157cb02a5cb6248"
          },
          {
            "type": "code",
            "text": "  todds.parents.dogs.bitee.brothers.house.garage.door.open();",
            "id": "00f859082ad30c84f27cdaae7940dffa"
          },
          {
            "type": "html",
            "text": "\nWell, in that case the structure may actually be important.  But often it's still better to get a hold of objects via id references...",
            "id": "0a9297def30adee49d431d15ec564178"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "Trying to come up with a more simple (non-foobar) example, is this correct?",
            "id": "0e2804edf9b2585efa5cc455d14a7f30"
          },
          {
            "type": "code",
            "text": "  currentPerson.Account.Deposit(500)  <-- bad\n  Account.Deposit(currentPerson, 500)  <-- good",
            "id": "3f6c5d308104589195d75193a32be837"
          },
          {
            "type": "html",
            "text": "Reason:",
            "id": "d9a20dd47e942c0b329dc587584a46ff"
          },
          {
            "type": "code",
            "text": "  Account may need to be initialized before it can be accessed\n  Say currentPerson.Account = null, will throw null reference exception in bad code\n  In good code, Deposit method can check if null and setup a new one before depositing",
            "id": "06b55471d39a429284103569bbfd5594"
          },
          {
            "type": "html",
            "text": "---- ",
            "id": "43de89a3183e617bd6a029e7104d9dfd"
          },
          {
            "type": "code",
            "text": "    currentPerson.give(500)    <-- best\n  Reason:\n    LawOfDemeter implies you shouldn't care how currentPerson stores his money, just that he gets it.\n    You do not care if he puts it in a bankAccount, usedSock, hiddenSafe, or \n    happens to be a 'CEO extends person' who calls myInvestmentManager.handleMoneyForMe(500)",
            "id": "7d025aa59327cd269e1eb23545d9a2d2"
          },
          {
            "type": "code",
            "text": "  -- AnonymousStudent (reading this page taught me all I needed to know to understand this, you guys are educational!)",
            "id": "48c132573a109d7d2b6f764002f948e2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "In a banking system you would give money to someone's account not to them, so far from being bad, navigating via the account object would convey essential semantics for example in the case the person had multiple accounts. If you have a canonical domain model then the all object relationships convey essential semantics about the information that is being represented. If you bridge those relationships before presenting access to client code then that information is lost. The fact that you could afford to bridge it implies that the structural information wasn't needed and hence your model wasn't canonical. If your model is non-canonical then refactor it so it is - don't bridge it. Of course your client code will then be dependent on the structure of your model but that is essential in order for the it add value to the system. Hence so long as your model is canonical with respect to the problem domain then [[Law Of Demeter]] is an anachronism.",
            "id": "0d81bb6d20bec3c1f426174ef07227b5"
          },
          {
            "type": "code",
            "text": "  -- Paul Campbell",
            "id": "cdb75cb526795e484bb60e3f6f148888"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "\nWhat about when you want to look something up in a dictionary with more than one index in something like Java? You could define a pair object with a comparable interface on it, but that requires writing a new class for each different number of indices. I think a more natural way of doing this is curried dictionaries, like [[Hash Map]]<[[First Index]], [[Hash Map]]<[[Second Index]], Value>>. Then when looking up you do dictionary.get(firstIndex).get(secondIndex). ",
            "id": "3127dee34a882212cfb67db149866993"
          },
          {
            "type": "html",
            "text": " Does this break [[Law Of Demeter]]",
            "id": "b6881e07f98c27c029ac7acc7b7ed88d"
          },
          {
            "type": "html",
            "text": " If so, what's the better way of doing it?",
            "id": "c6717bc8af7e568b8449c76673c94597"
          },
          {
            "type": "code",
            "text": "  Seems to me that repeatedly typing dictionary.get(firstIndex).get(secondIndex) each time you access something is at least annoying and error-prone, and maybe even a CodeSmell to use OnceAndOnlyOnce (am I correct?).\n  My guess at a better way would be something like:",
            "id": "d623aa59a765182630c6f5b18775c35b"
          },
          {
            "type": "code",
            "text": "  class myComplexDict {\n    private myMap = new hashMap<firstIndexType, HashMap<secondIndexType, Value>>;\n    public Value get(firstIndex, secondIndex) {\n      return this.myMap.get(firstIndex).get(secondIndex);\n    }\n  }",
            "id": "de0cda21aaaae73bcfedfd11ea8b01d7"
          },
          {
            "type": "code",
            "text": "  This also gives you more freedom to change implementation if Java suddenly decides to implement a 'multiDimensionMap<K[], V>' in some future specification (Or if your pairwise coder comes up with something better). (Is that a good thing? or OverEngineering ?)\n  I don't think it breaks LawOfDemeter 'because of using two dots', gathering from this page, the LOD seems to be less strict for 'primitive' datatypes like this.\n  -- AnonymousStudent (again!)",
            "id": "c6fca73e907376af14e97b4ac8bfaea5"
          },
          {
            "type": "html",
            "text": "<i>I agree with the student. A \"dictionary with more than one index\" <b>is</b> just a single-index dictionary with the index being a tuple of indices. --Salvatore</i>",
            "id": "ba9663e028e019d0a7e7a9fa6f099a7d"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "[[Is Law Of Demeter Overspecified On Cee Two]]",
            "id": "afc4b0698469dffaebc0e28884aad65f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "'Tis a silly law with diminishing returns on model complexity. Interesting, but irrelevant except in remarkably simple cases.",
            "id": "7764741387fea6be22700d89879123b0"
          },
          {
            "type": "html",
            "text": "\nSee [[Contractive Delegation]].",
            "id": "fc87f6c020f4a464f266e561d91a098d"
          },
          {
            "type": "html",
            "text": "---\nI would tend to agree that going knee-deep in child calls etc is a bad idea, but one of the benefits of coding to an interface is that you know what you're getting back. It's not the name of the methods or properties that are significant in a contract... it's the type of interface (or primitive) that comes back.  If that's specified in the contract, then it's safe to call a method of it.. say like .toString() (or [[To String]](), depending on your flavor).  This is true for unit testing as well since you're using the known contract... that's why we have them.. so we know what we're getting and what we can do with it. someone somewhere who takes this too literally is losing sight of what programs are for... and it's not to make pretty source code for programmers.",
            "id": "10d36aa5689652f8755092fd10d441c7"
          },
          {
            "type": "html",
            "text": "-- anonymous dave",
            "id": "645713ef40b6f0e78c3ac6fd93719d23"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "An interesting corollary is: “Don't chain bang,” that is don't write ruby code like",
            "id": "3b78649261d8bab0cd04bc102667465a"
          },
          {
            "type": "code",
            "text": "  list.flatten!.uniq!.compact!",
            "id": "df3c9a73f3292b62529ce1a4c57217b9"
          },
          {
            "type": "html",
            "text": "\nThe naive assumption is that each method would return the list, which was modified in place. But in fact, each method may return nil, causing the next method call to raise a [[No Method Error]].",
            "id": "620a207ecf93a3a1b2c62ac77ebf80fa"
          },
          {
            "type": "html",
            "text": "-- [[Joseph Holsten]]",
            "id": "657d257648ac9790177414f34e8a1265"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "a2388ca36f60e159024c87dc3fd3c2d5"
          },
          {
            "type": "html",
            "text": "[[Category Modeling Laws And Principles]]",
            "id": "24abb391638da5ea9905cfb19721a180"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?LawOfDemeter c2.com]",
            "id": "5ae8639eee0fe8d275608a150535472c"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1679740783700
    }
  ]
}