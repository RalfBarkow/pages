{
  "title": "Special Variable",
  "story": [
    {
      "type": "html",
      "text": "The term \"special variable\" is [[Common Lisp]] jargon which means \"dynamically scoped variable\". Which in turn is Lisp jargon that means a variable whose binding has [[Indefinite Scope]] and [[Dynamic Extent]] (and is hence a [[Dynamic Binding]]).",
      "id": "1e1cd6a30165e6f9ce223e44e68039fd"
    },
    {
      "type": "html",
      "text": "\nThe [[Dynamic Binding]] means that a special variable can acquire a value on entry into a lexical scope, and when that lexical scope terminates, the previous value of that variable is restored. There is no permanent association of that binding with an instance of the lexical scope, as in the case of a lexical variable. This saving and restoring is carried out implicitly by ordinary binding constructs like LET, which normally work with lexical variables.  ",
      "id": "bed936e0a999825e610f92fa341618f0"
    },
    {
      "type": "html",
      "text": "\n[[Indefinite Scope]] means that the binding between the symbol and value is not lexically established, but rather established in a global environment (but see notes about multithreading below). This means that if, for instance, one function establishes a value (via [[Dynamic Binding]]) for a special variable, and then calls another function, that other function can evaluate that special variable to obtain the value established by the former function, and can also assign to that variable to communicate a new value back to that function. The two are not nested in any way, and can be in separately compiled parts of the program. (For \"function\", substitute \"expression\", actually. [[Dynamic Binding]] s are associated with binding construct expressions, not function bodies. In one body, you can have nested bindings for the same variable).",
      "id": "0beefbf13239c1b5ca876a8f8b55c012"
    },
    {
      "type": "html",
      "text": "\nFor example the standard special variable *print-base* controls the base for printing integers. We can temporarily override it to make some code output in hex instead.",
      "id": "b94dc5daccbc2cb7fa41769ec6601179"
    },
    {
      "type": "code",
      "text": "  (defun print-some-numbers ()\n    (print 10)\n    (print 20)\n    (print 30))",
      "id": "0ed8817d978f06b2deafcecedd718809"
    },
    {
      "type": "code",
      "text": "  (print-some-numbers) ;; output is 10 20 30 on separate lines",
      "id": "98c36c2d18ecb8410ffc5d40485ce18e"
    },
    {
      "type": "code",
      "text": "  (let ((*print-base* 16)) (print-some-numbers)) ;; output is A 14 1E",
      "id": "9132890549f050b555ab1d6855000cf6"
    },
    {
      "type": "code",
      "text": "  (print-some-numbers) ;; output is 10 20 30 again",
      "id": "5dac10eadc28fe8941a61e6e11d5780a"
    },
    {
      "type": "html",
      "text": "\nIn Lisps that support threading (which includes every commercial, proprietary implementation), the dynamic bindings of special variables are thread-specific. Thus special variables provide a convenient abstraction for thread-specific storage.  If one thread overrides *print-base* to print something in hex, that won't affect I/O concurrently happening in another thread. However, if two threads use the same [[Special Variable]] and don't establish their own [[Dynamic Binding]] for it, then they are sharing the same global binding! This sharing is fine as long as it is read-only; for example, it can be used to establish a default value for some parameter that can be overriden locally to change a thread's behavior.",
      "id": "bc7977fcc283f4f7b7cadb1269de31b1"
    },
    {
      "type": "html",
      "text": "\nOne useful way to think of dynamic variables is to pretend that they are invisible parameters which go into every function, and are passed down again, without any requirement of cooperation from the function writer. If you have a lot of state information that needs to be passed around, and even travel through external functions that call you back, special variables can significantly reduce the complexity of your code.",
      "id": "91c60bc42615e6ba23a7a64e772d7e6b"
    },
    {
      "type": "html",
      "text": "\nThey can parameterize the behavior of a module in a disciplined way; they are \"tamed\" global variables that support concurrency and re-entrance.",
      "id": "71a7d3ebe8bc41a89296567d2b205c3e"
    },
    {
      "type": "html",
      "text": "\nHere is a [[Stupid Xml Project]] called XVCL which re-invents macros and special variables. The main ideas are: XML is subject to substitution of variant parts into invariant templates (i.e. macro processing) and that substitution values can be passed through intermediate frames without the involvement of their parameter list (special variables). [http://fxvcl.sourceforge.net/home.htm fxvcl.sourceforge.net]",
      "id": "667c906f2c28fcc213e563c872a43d68"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8384b04b68f1768e3e2a80c0d95d70cb"
    },
    {
      "type": "html",
      "text": "\nSee also [[Scope And Closures]] and [[Dynamic Scoping]]",
      "id": "273eb2e34a90177dc0aed858a9c85a5b"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?SpecialVariable c2.com]",
      "id": "6fec27c8c5f4540e3b6978f1c94ff3fc"
    }
  ],
  "journal": [
    {
      "date": 1050014749000,
      "id": "94f43a5c21794f53aa57103078c47606",
      "type": "create",
      "item": {
        "title": "Special Variable",
        "story": [
          {
            "type": "html",
            "text": "The term \"special variable\" is [[Common Lisp]] jargon which means \"dynamically scoped variable\". Which in turn is Lisp jargon that means a variable whose binding has [[Indefinite Scope]] and [[Dynamic Extent]] (and is hence a [[Dynamic Binding]]).",
            "id": "1e1cd6a30165e6f9ce223e44e68039fd"
          },
          {
            "type": "html",
            "text": "\nThe [[Dynamic Binding]] means that a special variable can acquire a value on entry into a lexical scope, and when that lexical scope terminates, the previous value of that variable is restored. There is no permanent association of that binding with an instance of the lexical scope, as in the case of a lexical variable. This saving and restoring is carried out implicitly by ordinary binding constructs like LET, which normally work with lexical variables.  ",
            "id": "bed936e0a999825e610f92fa341618f0"
          },
          {
            "type": "html",
            "text": "\n[[Indefinite Scope]] means that the binding between the symbol and value is not lexically established, but rather established in a global environment (but see notes about multithreading below). This means that if, for instance, one function establishes a value (via [[Dynamic Binding]]) for a special variable, and then calls another function, that other function can evaluate that special variable to obtain the value established by the former function, and can also assign to that variable to communicate a new value back to that function. The two are not nested in any way, and can be in separately compiled parts of the program. (For \"function\", substitute \"expression\", actually. [[Dynamic Binding]] s are associated with binding construct expressions, not function bodies. In one body, you can have nested bindings for the same variable).",
            "id": "0beefbf13239c1b5ca876a8f8b55c012"
          },
          {
            "type": "html",
            "text": "\nFor example the standard special variable *print-base* controls the base for printing integers. We can temporarily override it to make some code output in hex instead.",
            "id": "b94dc5daccbc2cb7fa41769ec6601179"
          },
          {
            "type": "code",
            "text": "  (defun print-some-numbers ()\n    (print 10)\n    (print 20)\n    (print 30))",
            "id": "0ed8817d978f06b2deafcecedd718809"
          },
          {
            "type": "code",
            "text": "  (print-some-numbers) ;; output is 10 20 30 on separate lines",
            "id": "98c36c2d18ecb8410ffc5d40485ce18e"
          },
          {
            "type": "code",
            "text": "  (let ((*print-base* 16)) (print-some-numbers)) ;; output is A 14 1E",
            "id": "9132890549f050b555ab1d6855000cf6"
          },
          {
            "type": "code",
            "text": "  (print-some-numbers) ;; output is 10 20 30 again",
            "id": "5dac10eadc28fe8941a61e6e11d5780a"
          },
          {
            "type": "html",
            "text": "\nIn Lisps that support threading (which includes every commercial, proprietary implementation), the dynamic bindings of special variables are thread-specific. Thus special variables provide a convenient abstraction for thread-specific storage.  If one thread overrides *print-base* to print something in hex, that won't affect I/O concurrently happening in another thread. However, if two threads use the same [[Special Variable]] and don't establish their own [[Dynamic Binding]] for it, then they are sharing the same global binding! This sharing is fine as long as it is read-only; for example, it can be used to establish a default value for some parameter that can be overriden locally to change a thread's behavior.",
            "id": "bc7977fcc283f4f7b7cadb1269de31b1"
          },
          {
            "type": "html",
            "text": "\nOne useful way to think of dynamic variables is to pretend that they are invisible parameters which go into every function, and are passed down again, without any requirement of cooperation from the function writer. If you have a lot of state information that needs to be passed around, and even travel through external functions that call you back, special variables can significantly reduce the complexity of your code.",
            "id": "91c60bc42615e6ba23a7a64e772d7e6b"
          },
          {
            "type": "html",
            "text": "\nThey can parameterize the behavior of a module in a disciplined way; they are \"tamed\" global variables that support concurrency and re-entrance.",
            "id": "71a7d3ebe8bc41a89296567d2b205c3e"
          },
          {
            "type": "html",
            "text": "\nHere is a [[Stupid Xml Project]] called XVCL which re-invents macros and special variables. The main ideas are: XML is subject to substitution of variant parts into invariant templates (i.e. macro processing) and that substitution values can be passed through intermediate frames without the involvement of their parameter list (special variables). [http://fxvcl.sourceforge.net/home.htm fxvcl.sourceforge.net]",
            "id": "667c906f2c28fcc213e563c872a43d68"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8384b04b68f1768e3e2a80c0d95d70cb"
          },
          {
            "type": "html",
            "text": "\nSee also [[Scope And Closures]] and [[Dynamic Scoping]]",
            "id": "273eb2e34a90177dc0aed858a9c85a5b"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?SpecialVariable c2.com]",
            "id": "6fec27c8c5f4540e3b6978f1c94ff3fc"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1674056342399
    }
  ]
}