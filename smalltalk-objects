{
  "title": "Smalltalk Objects",
  "story": [
    {
      "type": "paragraph",
      "id": "3f5b3f695acc29ef",
      "text": "Now that we have this structure of forms connected to each other by two sided links we call distinctions, how does this relate to Smalltalk objects? Are objects more like a form, or more like a distinction? And in particular, what is the approach that best fits a reference finder?"
    },
    {
      "type": "paragraph",
      "id": "b3ea087750941046",
      "text": "On one hand, objects are distinctions in that they impose a boundary that forces us to send messages in order to interact with them. But, at the same time, the object contains its local names such as instance names. So, in as much as the object is a distinction, it also contains a form where all such local names exist."
    },
    {
      "type": "paragraph",
      "id": "df79af4bc83ec2d1",
      "text": "Again, we find that objects exhibit dual behavior. However, we could try to model actual objects in terms of forms and/or distinctions. Which approach is best?"
    },
    {
      "type": "paragraph",
      "id": "3def23a1b655ef21",
      "text": "If we decided to model objects in terms of a distinction, then we would want to cross into it every time we needed to traverse its contents. In part, we take that for granted when we send messages, because Smalltalk is already providing for the automatic crossing of the object’s boundary. Thinking of an object as a distinction, thus, does not seem very convincing for our purposes."
    },
    {
      "type": "markdown",
      "id": "f0fad4997f8707ec",
      "text": "So perhaps we should think of an object as a form with an implicit distinction around it, something like a read only form. We do not need write capabilities to travel from object to object anyway. Let’s try this out, and make a subclass of `Form` called `ObjectForm`. Since it is not meant to allow object modification, messages like `distinguish:` and `confuse:` can easily be implemented in terms of `self shouldNotImplement`."
    },
    {
      "type": "markdown",
      "id": "516bd856a7762caa",
      "text": "But what about messages like `[[cross]]:`? How are we going to allow access to the object’s distinctions? What would the instance name distinctions hold in this case? What are the names of the distinctions inside an object’s form, from this point of view?"
    },
    {
      "type": "paragraph",
      "id": "2a3b41d9d9dc430b",
      "text": "[…]"
    },
    {
      "type": "paragraph",
      "id": "338da3d67a3730de",
      "text": "⇒ [[Collaborations and Emergent Properties]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Smalltalk Objects",
        "story": []
      },
      "date": 1660221934627
    },
    {
      "item": {
        "type": "factory",
        "id": "3f5b3f695acc29ef"
      },
      "id": "3f5b3f695acc29ef",
      "type": "add",
      "date": 1660221935826
    },
    {
      "item": {
        "type": "factory",
        "id": "2a3b41d9d9dc430b"
      },
      "id": "2a3b41d9d9dc430b",
      "type": "add",
      "after": "3f5b3f695acc29ef",
      "date": 1660221938419
    },
    {
      "type": "edit",
      "id": "3f5b3f695acc29ef",
      "item": {
        "type": "paragraph",
        "id": "3f5b3f695acc29ef",
        "text": "Now that we have this structure of forms connected to each other by two sided links we call distinctions, how does this relate to Smalltalk objects? Are objects more like a form, or more like a distinction? And in particular, what is the approach that best fits a reference finder?"
      },
      "date": 1660221939430
    },
    {
      "type": "edit",
      "id": "2a3b41d9d9dc430b",
      "item": {
        "type": "paragraph",
        "id": "2a3b41d9d9dc430b",
        "text": "[…]"
      },
      "date": 1660221941614
    },
    {
      "type": "add",
      "id": "b3ea087750941046",
      "item": {
        "type": "paragraph",
        "id": "b3ea087750941046",
        "text": "On one hand, objects are distinctions in that they impose a boundary that forces us to send messages in order to interact with them. But, at the same time, the object contains its local names such as instance names. So, in as much as the object is a distinction, it also contains a form where all such local names exist."
      },
      "after": "3f5b3f695acc29ef",
      "date": 1660221981696
    },
    {
      "type": "add",
      "id": "df79af4bc83ec2d1",
      "item": {
        "type": "paragraph",
        "id": "df79af4bc83ec2d1",
        "text": "Again, we find that objects exhibit dual behavior. However, we could try to model actual objects in terms of forms and/or distinctions. Which approach is best?"
      },
      "after": "b3ea087750941046",
      "date": 1660222005792
    },
    {
      "type": "add",
      "id": "3def23a1b655ef21",
      "item": {
        "type": "paragraph",
        "id": "3def23a1b655ef21",
        "text": "If we decided to model objects in terms of a distinction, then we would want to cross into it every time we needed to traverse its contents. In part, we take that for granted when we send messages, because Smalltalk is already providing for the automatic crossing of the object’s boundary. Thinking of an object as a distinction, thus, does not seem very convincing for our purposes."
      },
      "after": "df79af4bc83ec2d1",
      "date": 1660222019430
    },
    {
      "type": "add",
      "id": "f0fad4997f8707ec",
      "item": {
        "type": "paragraph",
        "id": "f0fad4997f8707ec",
        "text": "So perhaps we should think of an object as a form with an implicit distinction around it, something like a read only form. We do not need write capabilities"
      },
      "after": "3def23a1b655ef21",
      "date": 1660222054187
    },
    {
      "type": "edit",
      "id": "f0fad4997f8707ec",
      "item": {
        "type": "paragraph",
        "id": "f0fad4997f8707ec",
        "text": "So perhaps we should think of an object as a form with an implicit distinction around it, something like a read only form. We do not need write capabilities to travel from object to object anyway. Let’s try this out, and make a subclass of `Form` called `ObjectForm`. Since it is not meant to allow object modification, messages like distinguish: and confuse: can easily be implemented in terms of self shouldNotImplement."
      },
      "date": 1660222089051
    },
    {
      "type": "edit",
      "id": "f0fad4997f8707ec",
      "item": {
        "type": "markdown",
        "id": "f0fad4997f8707ec",
        "text": "So perhaps we should think of an object as a form with an implicit distinction around it, something like a read only form. We do not need write capabilities to travel from object to object anyway. Let’s try this out, and make a subclass of `Form` called `ObjectForm`. Since it is not meant to allow object modification, messages like distinguish: and confuse: can easily be implemented in terms of self shouldNotImplement."
      },
      "date": 1660222092056
    },
    {
      "type": "edit",
      "id": "f0fad4997f8707ec",
      "item": {
        "type": "markdown",
        "id": "f0fad4997f8707ec",
        "text": "So perhaps we should think of an object as a form with an implicit distinction around it, something like a read only form. We do not need write capabilities to travel from object to object anyway. Let’s try this out, and make a subclass of `Form` called `ObjectForm`. Since it is not meant to allow object modification, messages like `distinguish:` and `confuse:` can easily be implemented in terms of `self shouldNotImplement`."
      },
      "date": 1660222123241
    },
    {
      "type": "add",
      "id": "338da3d67a3730de",
      "item": {
        "type": "paragraph",
        "id": "338da3d67a3730de",
        "text": "– [[Collaborations and Emergent Properties]]"
      },
      "after": "2a3b41d9d9dc430b",
      "date": 1660222211786
    },
    {
      "type": "edit",
      "id": "338da3d67a3730de",
      "item": {
        "type": "paragraph",
        "id": "338da3d67a3730de",
        "text": "⇒ [[Collaborations and Emergent Properties]]"
      },
      "date": 1660222226409
    },
    {
      "id": "516bd856a7762caa",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "516bd856a7762caa",
        "text": "> But what about messages like `[[cross]]:`? How are we going to allow access to the object’s distinctions? What would the instance name distinctions hold in this case? What are the names of the distinctions inside an object’s form, from this point of view? ⇒ [[Smalltalk Objects]]"
      },
      "after": "f0fad4997f8707ec",
      "date": 1660811193312
    },
    {
      "type": "edit",
      "id": "516bd856a7762caa",
      "item": {
        "type": "markdown",
        "id": "516bd856a7762caa",
        "text": "But what about messages like `[[cross]]:`? How are we going to allow access to the object’s distinctions? What would the instance name distinctions hold in this case? What are the names of the distinctions inside an object’s form, from this point of view?"
      },
      "date": 1660811203768
    }
  ]
}