{
  "title": "ModelCC",
  "story": [
    {
      "type": "paragraph",
      "id": "4f486ad32b1c2439",
      "text": "We introduce [[ModelCC]], a model-based tool for language specification. ModelCC acts as a parser generator that decouples language specification from language processing, hence avoiding many of the problems caused by grammar-driven parsers and parser generators."
    },
    {
      "type": "markdown",
      "id": "c07a57253ad51f28",
      "text": "Besides the model-based approach, the main functional advantages of using ModelCC over other existing tools such as lex /yacc, YAJCo, or [[ANTLR]] are the following: \n* Apart from regular expressions, ModelCC allows the usage of pattern matching classes, which can be coded for specific purposes. For example, a dictionary-based matcher, in contrast to a regular expression-based matcher, could be used for detecting verbal forms in ModelCC. \n* ModelCC supports multiple composition constructions. There is no need to bring the BNF-like notation recursion of enumeration specifications to the model. \n* ModelCC offers a generic associativity and priority mechanism instead of a specific and limited operator specification mechanism. It supports creating operator-alike constructions as complex as needed. For example, it allows the usage of non terminal symbols as operators and defining n-ary operators.\n* ModelCC provides mechanisms that allow the developer to solve most language ambiguities. For example, expression nesting ambiguities can be solved by using associativities and priorities, and if-then-optional else sentence nesting ambiguities can be solved by using composition restrictions."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "ModelCC",
        "story": []
      },
      "date": 1656004970973
    },
    {
      "id": "4f486ad32b1c2439",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "4f486ad32b1c2439",
        "text": "In this paper, we introduce [[ModelCC]], a model-based tool for language specification. ModelCC acts as a parser generator that decouples language specification from language processing, hence avoiding many of the problems caused by grammar-driven parsers and parser generators."
      },
      "date": 1656004973470
    },
    {
      "type": "edit",
      "id": "4f486ad32b1c2439",
      "item": {
        "type": "paragraph",
        "id": "4f486ad32b1c2439",
        "text": "We introduce [[ModelCC]], a model-based tool for language specification. ModelCC acts as a parser generator that decouples language specification from language processing, hence avoiding many of the problems caused by grammar-driven parsers and parser generators."
      },
      "date": 1656004997380
    },
    {
      "item": {
        "type": "factory",
        "id": "c07a57253ad51f28"
      },
      "id": "c07a57253ad51f28",
      "type": "add",
      "after": "4f486ad32b1c2439",
      "date": 1656006390873
    },
    {
      "type": "edit",
      "id": "c07a57253ad51f28",
      "item": {
        "type": "paragraph",
        "id": "c07a57253ad51f28",
        "text": "Besides the model-based approach, the main functional advantages of using ModelCC over other existing tools such as lex /yacc, YAJCo,orANTLR are the following: – Apart from regular expressions, ModelCC allows the usage of pattern matching classes, which can be coded for specific purposes. For example, a dictionary-based matcher, in contrast to a regular expression-based matcher, could be used for detecting verbal forms in ModelCC. – ModelCC supports multiple composition constructions. There is no need to bring the BNF-like notation recursion of enumeration specifications to the model. – ModelCC offers a generic associativity and priority mechanism instead of a specific and limited operator specification mechanism. It supports creating"
      },
      "date": 1656006393306
    },
    {
      "type": "edit",
      "id": "c07a57253ad51f28",
      "item": {
        "type": "markdown",
        "id": "c07a57253ad51f28",
        "text": "Besides the model-based approach, the main functional advantages of using ModelCC over other existing tools such as lex /yacc, YAJCo,orANTLR are the following: – Apart from regular expressions, ModelCC allows the usage of pattern matching classes, which can be coded for specific purposes. For example, a dictionary-based matcher, in contrast to a regular expression-based matcher, could be used for detecting verbal forms in ModelCC. – ModelCC supports multiple composition constructions. There is no need to bring the BNF-like notation recursion of enumeration specifications to the model. – ModelCC offers a generic associativity and priority mechanism instead of a specific and limited operator specification mechanism. It supports creating"
      },
      "date": 1656006395220
    },
    {
      "type": "edit",
      "id": "c07a57253ad51f28",
      "item": {
        "type": "markdown",
        "id": "c07a57253ad51f28",
        "text": "Besides the model-based approach, the main functional advantages of using ModelCC over other existing tools such as lex /yacc, YAJCo,orANTLR are the following: \n* Apart from regular expressions, ModelCC allows the usage of pattern matching classes, which can be coded for specific purposes. For example, a dictionary-based matcher, in contrast to a regular expression-based matcher, could be used for detecting verbal forms in ModelCC. – ModelCC supports multiple composition constructions. There is no need to bring the BNF-like notation recursion of enumeration specifications to the model. – ModelCC offers a generic associativity and priority mechanism instead of a specific and limited operator specification mechanism. It supports creating"
      },
      "date": 1656006405956
    },
    {
      "type": "edit",
      "id": "c07a57253ad51f28",
      "item": {
        "type": "markdown",
        "id": "c07a57253ad51f28",
        "text": "Besides the model-based approach, the main functional advantages of using ModelCC over other existing tools such as lex /yacc, YAJCo,orANTLR are the following: \n* Apart from regular expressions, ModelCC allows the usage of pattern matching classes, which can be coded for specific purposes. For example, a dictionary-based matcher, in contrast to a regular expression-based matcher, could be used for detecting verbal forms in ModelCC. * ModelCC supports multiple composition constructions. There is no need to bring the BNF-like notation recursion of enumeration specifications to the model. – ModelCC offers a generic associativity and priority mechanism instead of a specific and limited operator specification mechanism. It supports creating"
      },
      "date": 1656006416451
    },
    {
      "type": "edit",
      "id": "c07a57253ad51f28",
      "item": {
        "type": "markdown",
        "id": "c07a57253ad51f28",
        "text": "Besides the model-based approach, the main functional advantages of using ModelCC over other existing tools such as lex /yacc, YAJCo,orANTLR are the following: \n* Apart from regular expressions, ModelCC allows the usage of pattern matching classes, which can be coded for specific purposes. For example, a dictionary-based matcher, in contrast to a regular expression-based matcher, could be used for detecting verbal forms in ModelCC. \n* ModelCC supports multiple composition constructions. There is no need to bring the BNF-like notation recursion of enumeration specifications to the model. – ModelCC offers a generic associativity and priority mechanism instead of a specific and limited operator specification mechanism. It supports creating"
      },
      "date": 1656006423770
    },
    {
      "type": "edit",
      "id": "c07a57253ad51f28",
      "item": {
        "type": "markdown",
        "id": "c07a57253ad51f28",
        "text": "Besides the model-based approach, the main functional advantages of using ModelCC over other existing tools such as lex /yacc, YAJCo,orANTLR are the following: \n* Apart from regular expressions, ModelCC allows the usage of pattern matching classes, which can be coded for specific purposes. For example, a dictionary-based matcher, in contrast to a regular expression-based matcher, could be used for detecting verbal forms in ModelCC. \n* ModelCC supports multiple composition constructions. There is no need to bring the BNF-like notation recursion of enumeration specifications to the model. \n* ModelCC offers a generic associativity and priority mechanism instead of a specific and limited operator specification mechanism. It supports creating"
      },
      "date": 1656006438073
    },
    {
      "type": "edit",
      "id": "c07a57253ad51f28",
      "item": {
        "type": "markdown",
        "id": "c07a57253ad51f28",
        "text": "Besides the model-based approach, the main functional advantages of using ModelCC over other existing tools such as lex /yacc, YAJCo,orANTLR are the following: \n* Apart from regular expressions, ModelCC allows the usage of pattern matching classes, which can be coded for specific purposes. For example, a dictionary-based matcher, in contrast to a regular expression-based matcher, could be used for detecting verbal forms in ModelCC. \n* ModelCC supports multiple composition constructions. There is no need to bring the BNF-like notation recursion of enumeration specifications to the model. \n* ModelCC offers a generic associativity and priority mechanism instead of a specific and limited operator specification mechanism. It supports creating operator-alike constructions as complex as needed. For example, it allows the usage of non terminal symbols as operators and defining n-ary operators."
      },
      "date": 1656006454774
    },
    {
      "type": "edit",
      "id": "c07a57253ad51f28",
      "item": {
        "type": "markdown",
        "id": "c07a57253ad51f28",
        "text": "Besides the model-based approach, the main functional advantages of using ModelCC over other existing tools such as lex /yacc, YAJCo,or [[ANTLR]] are the following: \n* Apart from regular expressions, ModelCC allows the usage of pattern matching classes, which can be coded for specific purposes. For example, a dictionary-based matcher, in contrast to a regular expression-based matcher, could be used for detecting verbal forms in ModelCC. \n* ModelCC supports multiple composition constructions. There is no need to bring the BNF-like notation recursion of enumeration specifications to the model. \n* ModelCC offers a generic associativity and priority mechanism instead of a specific and limited operator specification mechanism. It supports creating operator-alike constructions as complex as needed. For example, it allows the usage of non terminal symbols as operators and defining n-ary operators."
      },
      "date": 1656006480961
    },
    {
      "item": {
        "type": "factory",
        "id": "12ad83b4f55c66de"
      },
      "id": "12ad83b4f55c66de",
      "type": "add",
      "after": "c07a57253ad51f28",
      "date": 1656006508551
    },
    {
      "type": "remove",
      "id": "12ad83b4f55c66de",
      "date": 1656006518254
    },
    {
      "type": "edit",
      "id": "c07a57253ad51f28",
      "item": {
        "type": "markdown",
        "id": "c07a57253ad51f28",
        "text": "Besides the model-based approach, the main functional advantages of using ModelCC over other existing tools such as lex /yacc, YAJCo,or [[ANTLR]] are the following: \n* Apart from regular expressions, ModelCC allows the usage of pattern matching classes, which can be coded for specific purposes. For example, a dictionary-based matcher, in contrast to a regular expression-based matcher, could be used for detecting verbal forms in ModelCC. \n* ModelCC supports multiple composition constructions. There is no need to bring the BNF-like notation recursion of enumeration specifications to the model. \n* ModelCC offers a generic associativity and priority mechanism instead of a specific and limited operator specification mechanism. It supports creating operator-alike constructions as complex as needed. For example, it allows the usage of non terminal symbols as operators and defining n-ary operators.\n* ModelCC provides mechanisms that allow the developer to solve most language ambiguities. For example, expression nesting ambiguities can be solved by using associativities and priorities, and if-then-optional else sentence nesting ambiguities can be solved by using composition restrictions."
      },
      "date": 1656006527713
    },
    {
      "type": "edit",
      "id": "c07a57253ad51f28",
      "item": {
        "type": "markdown",
        "id": "c07a57253ad51f28",
        "text": "Besides the model-based approach, the main functional advantages of using ModelCC over other existing tools such as lex /yacc, YAJCo, or [[ANTLR]] are the following: \n* Apart from regular expressions, ModelCC allows the usage of pattern matching classes, which can be coded for specific purposes. For example, a dictionary-based matcher, in contrast to a regular expression-based matcher, could be used for detecting verbal forms in ModelCC. \n* ModelCC supports multiple composition constructions. There is no need to bring the BNF-like notation recursion of enumeration specifications to the model. \n* ModelCC offers a generic associativity and priority mechanism instead of a specific and limited operator specification mechanism. It supports creating operator-alike constructions as complex as needed. For example, it allows the usage of non terminal symbols as operators and defining n-ary operators.\n* ModelCC provides mechanisms that allow the developer to solve most language ambiguities. For example, expression nesting ambiguities can be solved by using associativities and priorities, and if-then-optional else sentence nesting ambiguities can be solved by using composition restrictions."
      },
      "date": 1656006552761
    }
  ]
}