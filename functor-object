{
  "title": "Functor Object",
  "story": [
    {
      "type": "html",
      "text": "<i>A [[Functor Object]] is an object that acts as a function, and can be operated upon like an object.</i>",
      "id": "a21ac0c4ac28b2c4bff8dce6eca1eb29"
    },
    {
      "type": "html",
      "text": "\nSee [[Functional Pattern System For Object Oriented Design]].",
      "id": "d9ff7208fefd60d9947f05a09f5a1ae9"
    },
    {
      "type": "html",
      "text": "\nIn many languages which support these, there is a conventionally named method that executes or computes the function, for example \"run()\" in [[Ee Language]], or \"operator()\" in [[Cee Plus Plus]].",
      "id": "e9c5e3cf99995987d0b7505c59c98e17"
    },
    {
      "type": "html",
      "text": "\nThere are a variety of programming constructs that manipulate functions rather than objects. These include [[Higher Order Function]]s, [[Curried Function]]s, [[Internal Iteration]] and callback mechanisms among others. In order to use these constructs effectively it is necessary to be able to capture references to functions rather than just call them. ",
      "id": "96f3be9e176d03ebbc8f87486480fa8c"
    },
    {
      "type": "html",
      "text": "<b>Therefore:</b>",
      "id": "cf68c36ceba1eac9e135cc6cb001ae32"
    },
    {
      "type": "html",
      "text": "(In strongly typed languages) Create a family of interfaces that describe function call signatures. Use generic programming, generic types (like Java's Object) or naming conventions to insulate users and implementers of these interfaces from each other. Program [[Higher Order Function]]s and other functional clients in terms of this interface. Implement adapter classes that can make the methods of ordinary objects available to these functional clients. Use block closures in Smalltalk, inner classes in Java and the ->* syntax in C++. Program objects whose behavior is to be parameterized using [[Higher Order Function]]s that are coded against the [[Functor Object Interface]].",
      "id": "0ccd9e1a982b355d90fa8b848c84bb38"
    },
    {
      "type": "html",
      "text": "<b>Resulting context:</b>",
      "id": "6d4c576cc5a8aec087bd0abae4479571"
    },
    {
      "type": "html",
      "text": "\nClients can parameterize objects that implement [[Higher Order Function]]s by creating [[Functor Object]]s and passing them in. We expect to find [[Higher Order Function]]s only in [[Functional Programming Language]]s, but they are actually found in more mundane settings as function pointers. The quicksort function in the standard C library is, in fact, a [[Higher Order Function]] as are callback mechanisms of all sorts. [[Internal Iteration]] is another common use for [[Functor Object]]s and is a recurring theme in [[Object Functional Patterns]]. The existence of [[Functor Object]]s makes it possible to implement a variety of other patterns including [[Curried Functor]]s, [[Generic Function]]s using [[Functor Object]]s to implement Specialized<b></b>Functions, [[Lazy Evaluation]] of [[Functor Object]]s, and other [[Object Functional Patterns]].",
      "id": "2b824a1b7525739e41efc76e3b4c3a63"
    },
    {
      "type": "html",
      "text": "\nSince [[Functor Object]]s are an enabling mechanism for [[Lazy Evaluation]] some of the caveats for [[Lazy Evaluation]] should be noted here. [[Lazy Evaluation]] makes it impossible to know the exact order in which operations will be executed and in fact makes it possible for some operations not to be executed at all. It is therefore important to ensure that the [[Functor Object]]s that may be lazily evaluated do not rely on state that may change during the time when [[Lazy Evaluation]] may occur and that it does not change state that is relied on by other operations that may occur during the same time period. [[Functor Object]]s that can have side-effects are called Procedure Objects by [[Thomas Kuehne]]. These are very useful but some care must be taken with the timing of their side-effects.",
      "id": "de59803cedb61f7ce699e726d91d3660"
    },
    {
      "type": "html",
      "text": "<b>Variations:</b>",
      "id": "59a5383fb44678b2e75f92a5434bfe2b"
    },
    {
      "type": "html",
      "text": "<i>Argument binding</i>: The basic [[Functor Object]] is supplied with its parameters at invocation time. It is possible, however, to separate argument application from invocation. The [[Python Language]] uses default argument values to make this separation. In other languages it is possible to create [[Functor Object]]s that can appear to store parameter values until invocation time. This is the enabling infrastructure for [[Curried Functor]]s.",
      "id": "02727bf1b06c253704c814584ebecad3"
    },
    {
      "type": "html",
      "text": "<i>Keyword parameters</i>: Argument application can be further generalized by providing a mechanism for supplying parameters by name. This could be done through named methods or through keyword strings. Such an application can produce a new object - a form of [[Curried Functor]].",
      "id": "0c90f67061d0659de1527d72ea8a3621"
    },
    {
      "type": "html",
      "text": "<i>Default parameters</i>: A [[Functor Object]] can also come with some parameters pre-applied. In this case the defaults can be overridden by some form of argument binding before the [[Functor Object]] is actually invoked.",
      "id": "e8b14c2aa7b84322a42ab8d9e7887875"
    },
    {
      "type": "html",
      "text": "<i>Multiple results</i>: A [[Functor Object]] can potentially calculate more than one result. In this case use [[Command Query Separation]] to separate invocation of the [[Functor Object]] from the queries that return its various results. ",
      "id": "12d081d92d10c5ac4e6a9ee54c00b70f"
    },
    {
      "type": "html",
      "text": "<i>Composed [[Functor Object]]s</i>: A [[Functor Object]] may represent a [[Higher Order Function]] that can be parameterized with another [[Functor Object]]. For instance a [[Functor Object]] may be parameterized with a predicate that will short-circuit the [[Function Object]] unless some condition is true. This is especially valuable for use in [[Internal Iteration]].",
      "id": "690a61d49dcfe6b796f9e20377e09a0d"
    },
    {
      "type": "html",
      "text": "<b>Known Uses:</b>",
      "id": "bbdae1b71a5d89b52d5c604b74b7d592"
    },
    {
      "type": "html",
      "text": "\nC++ STL (Standard Template Library) -- [[Stl Function Objects]]",
      "id": "995c151c6a0b67564b91cfdd593520c9"
    },
    {
      "type": "html",
      "text": "\nIn the C++ [[Standard Template Library]], a \"[[Function Object]]\" is an instance of a class that implements \"operator()\". As such, its usage is syntactically indistinguishable from a [[Function Pointer]] - a property that lets [[Function Object]]s and [[Function Pointer]]s be used interchangeably in template-based [[Generic Algorithms]].",
      "id": "2c30f05541f2d264953b2b6d32b48cb3"
    },
    {
      "type": "html",
      "text": "\nThe benefit of using objects instead of [[Function Pointer]]s is that the compiler can inline methods with [[Function Object]]s.",
      "id": "5e42c54995121e491ff090dde6af64a4"
    },
    {
      "type": "html",
      "text": "[See [[Stl Function Objects]] for discussion.]",
      "id": "8a68d87e186dacaad9d8ec5e21628b38"
    },
    {
      "type": "html",
      "text": "<b>See also:</b> [[Functor Object Example]], [[Blocks In Java]], [[Functional Programming In Cpp]]",
      "id": "086e2ffda237d5f66574e86a8fb848ce"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e76950a28b8d9a5eb09dc9a83d16beed"
    },
    {
      "type": "html",
      "text": "<b>Discussion:</b>",
      "id": "69717dfe4f058fce028fbf7d2efdb112"
    },
    {
      "type": "html",
      "text": "\nThe name, [[Functor Object]], is a very poor one. A [[Functor Object]] is an object that acts as a function, and can be operated upon like an object. As such, they are akin to mathematical functionals such as the [[Dirac Delta Function]], or mathematical operators such as the derivative or the [[Fourier Transform]].",
      "id": "efb84d4f1f011d956f7b35accecd4df5"
    },
    {
      "type": "html",
      "text": "\nIn <i>[[Category Theory]]</i>, the field of mathematics where the term <i>Functor</i> originates, a <i>Functor</i> is a mapping from one <i>Category</i> to another that respects <i>Morphism</i>s [functions].  For example, consider the <i>Category</i> of <i>[[Topological Space]]</i>s and <i>[[Continuous Map]]</i>s. The <i>H</i>omologyMorphism H_1 sends this <i>Category</i> to that of <i>[[Abelian Group]]</i>s and <i>[[Homo Morphism]]</i>s.  This means that if I have the following series of continuous topological maps:",
      "id": "4c90c9c0ee7b5a4609e6e1372f4c13a7"
    },
    {
      "type": "code",
      "text": "           f             g\n    S  ---------> T ----------> U,",
      "id": "e3643ea1f3a7c4ed676ed34f035564db"
    },
    {
      "type": "html",
      "text": "\nI also get the series of homomorphisms:",
      "id": "b7375d5653ad107d8bd7e5940195f0e2"
    },
    {
      "type": "code",
      "text": "         H_1(f)        H_1(g)\n  H_1(S) -----> H_1(T) ------> H_1(U),",
      "id": "2da12d9c2c3004520b8981b7b4553d30"
    },
    {
      "type": "html",
      "text": "\nand H_1(gf) = H_1(g)H_1(f).",
      "id": "02d920016f909775aff91c692a817072"
    },
    {
      "type": "html",
      "text": "\nYou don't need to understand that; my point is that <i>Functor</i>s act on the entire problem domain, not just on functions or upon arguments. The only example I can think of right now is this.",
      "id": "e86da6c6bce4b4499a9455e2b616060e"
    },
    {
      "type": "html",
      "text": "\nConsider the <i>Category</i> of <i>Object</i>s and <i>Algorithm</i>s for functions whose results depend on no hidden variables. For example, real numbers and the sine function, but not decks of cards and a random shuffle function. Then, define the memoize functor to take objects to themselves, and algorithms to their memoized versions. The is a valid map from that category to itself - the memoized algorithm uses hidden variables, but the results do not.",
      "id": "9faf0a53d1f1e505d7a0ef44db944921"
    },
    {
      "type": "html",
      "text": "-- [[Eric Jablow]]",
      "id": "f01a8f2e8aed9ca5b75e6aca63a41762"
    },
    {
      "type": "html",
      "text": "<i>A [[Functor Object]] is an object that acts as a function, and can be operated upon like an object.</i>",
      "id": "a21ac0c4ac28b2c4bff8dce6eca1eb29"
    },
    {
      "type": "html",
      "text": "\nI think this would mean that it was very <i>well</i> named? The word <i>functor</i> comes from the latin from Latin <i>f�nctio</i>, which means performance of a function. A synonym for <i>functor</i> is <i>function</i>. In [[Computer Science]], it is very much like a lambda and sometimes no different than a <i>function</i>. In fact, even in Category Theory the use <i>theory of functors</i> and <i>function theory</i> analogously. -- [[Robert Di Falco]]",
      "id": "28284ce38708a7b31564a25afd325f73"
    },
    {
      "type": "html",
      "text": "<i>In </i>[[Category Theory]]<i>, the field of mathematics where the term </i>Functor<i> originates</i>",
      "id": "7ff64672927c90c806d5c55e96386b3a"
    },
    {
      "type": "html",
      "text": "\nThis isn't true. Category Theory like many other branches of science and mathematics uses the term <i>functor</i> but it did not <i>originate</i> in abstract algebra -- at least that's not what my research says. Even if it did originate in Category Theory with set-valued functors or functory category, it wouldn't matter. In this case, we are talking about <i>functors</i> as they exist in programming languages where for decades, a <i>functor</i> has analogous to a <i>function</i>. -- [[Robert Di Falco]]",
      "id": "099a8c1121946f5a85fbeb013b431fb5"
    },
    {
      "type": "html",
      "text": "\nThe term <i>functor</i> as used in Category Theory was originally borrowed from Carnap, and has been used unambiguously in mathematics at least since 1950. Anyway, there is a well established use of the term in computer science, specifically in the [[Sml Language]], where a <i>functor</i> is a parametric structure. Because of that, [[Functor Object]] seems to be a poorly chosen name. For a similar concept the [[Common Lisp Object System]] uses the more descriptive term <i>funcallable instance</i>. What's wrong with [[Function Object]], besides the fact that its [[Wiki Name]] is already taken? --",
      "id": "e4712d79d71e2b087c572a1c745ad29d"
    },
    {
      "type": "html",
      "text": "\n[[Jim Coplien]] uses the word 'functor' in his book '[[Advanced Cee Plus Plus]]'. If you've got a gripe with it ask him. -- [[Phil Goodwin]]",
      "id": "c039387d0646ca2788cba6d820be109f"
    },
    {
      "type": "html",
      "text": "\nTrue, as Phil knows there are tons of synonyms for this such as: functor, functoid, function object, lexical closure, closure, code-block, and so on. There is a lot of history for functor and functiod, especially regarding enclosing functions in objects. -- [[Robert Di Falco]]",
      "id": "34b72c17ab2868eccb41ade2317a649e"
    },
    {
      "type": "html",
      "text": "\n[[Andrei Alexandrescu]] uses the term [[Callable Entity]] in his book [[Modern Cee Plus Plus Design]] to refer to C-like functions, pointers or references to C-like functions, objects that define an operator(), or the result of applying operator.* or operator->* with a pointer to a member function in the right-hand side of the expression.",
      "id": "196cc7efe11607f208d6f04979333a17"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e76950a28b8d9a5eb09dc9a83d16beed"
    },
    {
      "type": "html",
      "text": "\nLet me see, when would I use this? Oh yes, when I need a function pointer. Nice to see an OO solution ;). -- [[Richard Henderson]].",
      "id": "de4ebe5d50b054881cc1c14965bcc35b"
    },
    {
      "type": "html",
      "text": "<i>I appreciate your humor, and at the same hope everyone who reads it understands the irony. A [[Functor Object]] (or [[Lambda Expression]], [[Lexical Closure]], [[Code Block]], etc) includes a snapshot of its context (for example, a frame within which to bind its arguments and a safe place to answer its results). A naked function pointer, unless written very carefully, does not. It is certainly true that a [[Functor Object]] can be constructed in, for example, [[Cee Plus Plus]] using a function pointer -- some might argue that this was the impetus for [[Cee Plus Plus]] -- but a function pointer by itself is NOT a [[Functor Object]].</i>",
      "id": "e7add16b6606d205941e10fea95c91ac"
    },
    {
      "type": "html",
      "text": "\nNo indeed, and I was only half-joking. I really do need safe function pointer-like behaviour. Specifically this provides a perfect analog of a connecting wire which explicitly connects two objects that don't need to know details about each other. Each adapts to the other by \"requesting\" a connection. Previously I used external adapter objects but this is much lighter weight and generally lovely [[Micro Architecture]].",
      "id": "fd2533568b48d40928270f06fab8360b"
    },
    {
      "type": "html",
      "text": "\nIs there a restriction on the degree of independence that a functor has from its parent? I'm jumping on its adapter properties, but the Factory pattern is not so far away in that there is an equivalent interaction.",
      "id": "f3e6c583727b5b58ba852b1a1350efa8"
    },
    {
      "type": "html",
      "text": "<i>One of the first things I built from these, in Java, was a [[Pluggable Adaptor]] module, following the example in Smalltalk. I find this an elegant and powerful \"[[Connecting Wire]]\" - once you try it, you'll never turn back. -- [[Tom Stambaugh]]</i>",
      "id": "4862bce6b82cef48d40d394475031bc3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e76950a28b8d9a5eb09dc9a83d16beed"
    },
    {
      "type": "html",
      "text": "Functors may also inform a factory about what they can do - either by proxy, or directly, allowing the factory to select the \"optimum\" functor from a collection of functors, using hints provided by the invoker of the factory...",
      "id": "925ba5de5f43d49b964c313c434def61"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e76950a28b8d9a5eb09dc9a83d16beed"
    },
    {
      "type": "html",
      "text": "When a language forces you to emulate simple functional values using a much more complicated object mechanism it is basically an instance of the [[Abstraction Inversion]] [[Anti Pattern]]. I'm not saying that it would not make sense to emulate functional values using the object mechanism in an OO language that doesn't provide first class functional values, but I'm saying that the language effectively forces [[Abstraction Inversion]]. Consider the following example:",
      "id": "12495444a6b9b476214693a0d002e012"
    },
    {
      "type": "html",
      "text": "Scheme:<br>((lambda (x) x) 1)",
      "id": "b085b99c947f971b224d514141fb539b"
    },
    {
      "type": "html",
      "text": "Java:<br>new Function() {",
      "id": "96aba726120ae70c280634d05efc1c56"
    },
    {
      "type": "code",
      "text": "              public Object with(Object x) {\n                return x;\n              }}.with(new Integer(1))",
      "id": "c41f74aad2fec0429046bb905fe56177"
    },
    {
      "type": "html",
      "text": "\nEven if the manifest typing would be removed from the Java version, there would still be an unnecessary indirection in the Java version. The dispatch to the with-method happens indirectly, which is not necessary as the necessary indirection is already provided by the use of the functional value. -- [[Vesa Karvonen]]",
      "id": "9982de6b48630c829af173b3f8562133"
    },
    {
      "type": "html",
      "text": "\nOf course, Java's not exactly a good example of a proper OO language, Smalltalk does it with pure objects while remaining as simple as the Scheme equivalent.",
      "id": "bca204cfa1b3af02bd8c35590bce04d7"
    },
    {
      "type": "html",
      "text": "[:x | x ] value:<br>1",
      "id": "9e6e532c72ca11bdf80434877d107188"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e76950a28b8d9a5eb09dc9a83d16beed"
    },
    {
      "type": "html",
      "text": "Another issue worth mentioning is that [[Functor Object]] is strongly related to the [[Strategy Pattern]]. [[Functor Object]] essentially differs from the [[Strategy Pattern]] in that a [[Functor Object]] is less specific to a particular situation and that a [[Functor Object]] always contains just one entry point. Both [[Strategy Pattern]] and [[Functor Object]] are essentially \"just parameterization\". The most likely reason why they are given the high status as patterns in OO languages is that behavioral parameterization using functional values is not necessarily immediately obvious in OO languages that do not support first class functional values. -- [[Vesa Karvonen]]",
      "id": "10b5c0a28d102b3d8be4c4e00a713b47"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e76950a28b8d9a5eb09dc9a83d16beed"
    },
    {
      "type": "html",
      "text": "I would like to note that \"functor\" is a misnomer. It already has a meaning of \"a morphism from category to category\", which is approximately what a template is in C++ parlance. -- [[Panu Kalliokoski]]",
      "id": "f731527eb55bbb3cf1d52f1691fd4eb5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e76950a28b8d9a5eb09dc9a83d16beed"
    },
    {
      "type": "html",
      "text": "functor has a long history in discussions of Prolog predicates in terms of the 'functor' and the 'arity' of predicates. -- [[Robert Shiplett]]",
      "id": "ac3adb4eb7696d4e17463d227a2d1f16"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e76950a28b8d9a5eb09dc9a83d16beed"
    },
    {
      "type": "html",
      "text": "Someone created this page to discuss objects that combine dates/ranges with monetary amounts - moved to [[Date And Value Object]].",
      "id": "12c0dffde8394d114fb6cc0f92d558c8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e76950a28b8d9a5eb09dc9a83d16beed"
    },
    {
      "type": "html",
      "text": "\nDiscussion of [[Value Object]]s (like [[Money Amount]]) requiring garbage collection ([[Algorithms That Demand Garbage Collection]]) moved to <b>Do [[Value Objects Require Garbage Collection]]?</b>.",
      "id": "04c6d7434a9f8735d72e6635052fc959"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "e76950a28b8d9a5eb09dc9a83d16beed"
    },
    {
      "type": "html",
      "text": "[[Category Object Functional Patterns]] [[Category Coding Conventions]]",
      "id": "f936d1bf6b4dc2ef0f75e481ebc0a635"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?FunctorObject c2.com]",
      "id": "586f0e9608822bb3e6911ea4a14d4652"
    }
  ],
  "journal": [
    {
      "date": 1410379255000,
      "id": "1e148ad05d16a2f651cd0b03363e4733",
      "type": "create",
      "item": {
        "title": "Functor Object",
        "story": [
          {
            "type": "html",
            "text": "<i>A [[Functor Object]] is an object that acts as a function, and can be operated upon like an object.</i>",
            "id": "a21ac0c4ac28b2c4bff8dce6eca1eb29"
          },
          {
            "type": "html",
            "text": "\nSee [[Functional Pattern System For Object Oriented Design]].",
            "id": "d9ff7208fefd60d9947f05a09f5a1ae9"
          },
          {
            "type": "html",
            "text": "\nIn many languages which support these, there is a conventionally named method that executes or computes the function, for example \"run()\" in [[Ee Language]], or \"operator()\" in [[Cee Plus Plus]].",
            "id": "e9c5e3cf99995987d0b7505c59c98e17"
          },
          {
            "type": "html",
            "text": "\nThere are a variety of programming constructs that manipulate functions rather than objects. These include [[Higher Order Function]]s, [[Curried Function]]s, [[Internal Iteration]] and callback mechanisms among others. In order to use these constructs effectively it is necessary to be able to capture references to functions rather than just call them. ",
            "id": "96f3be9e176d03ebbc8f87486480fa8c"
          },
          {
            "type": "html",
            "text": "<b>Therefore:</b>",
            "id": "cf68c36ceba1eac9e135cc6cb001ae32"
          },
          {
            "type": "html",
            "text": "(In strongly typed languages) Create a family of interfaces that describe function call signatures. Use generic programming, generic types (like Java's Object) or naming conventions to insulate users and implementers of these interfaces from each other. Program [[Higher Order Function]]s and other functional clients in terms of this interface. Implement adapter classes that can make the methods of ordinary objects available to these functional clients. Use block closures in Smalltalk, inner classes in Java and the ->* syntax in C++. Program objects whose behavior is to be parameterized using [[Higher Order Function]]s that are coded against the [[Functor Object Interface]].",
            "id": "0ccd9e1a982b355d90fa8b848c84bb38"
          },
          {
            "type": "html",
            "text": "<b>Resulting context:</b>",
            "id": "6d4c576cc5a8aec087bd0abae4479571"
          },
          {
            "type": "html",
            "text": "\nClients can parameterize objects that implement [[Higher Order Function]]s by creating [[Functor Object]]s and passing them in. We expect to find [[Higher Order Function]]s only in [[Functional Programming Language]]s, but they are actually found in more mundane settings as function pointers. The quicksort function in the standard C library is, in fact, a [[Higher Order Function]] as are callback mechanisms of all sorts. [[Internal Iteration]] is another common use for [[Functor Object]]s and is a recurring theme in [[Object Functional Patterns]]. The existence of [[Functor Object]]s makes it possible to implement a variety of other patterns including [[Curried Functor]]s, [[Generic Function]]s using [[Functor Object]]s to implement Specialized<b></b>Functions, [[Lazy Evaluation]] of [[Functor Object]]s, and other [[Object Functional Patterns]].",
            "id": "2b824a1b7525739e41efc76e3b4c3a63"
          },
          {
            "type": "html",
            "text": "\nSince [[Functor Object]]s are an enabling mechanism for [[Lazy Evaluation]] some of the caveats for [[Lazy Evaluation]] should be noted here. [[Lazy Evaluation]] makes it impossible to know the exact order in which operations will be executed and in fact makes it possible for some operations not to be executed at all. It is therefore important to ensure that the [[Functor Object]]s that may be lazily evaluated do not rely on state that may change during the time when [[Lazy Evaluation]] may occur and that it does not change state that is relied on by other operations that may occur during the same time period. [[Functor Object]]s that can have side-effects are called Procedure Objects by [[Thomas Kuehne]]. These are very useful but some care must be taken with the timing of their side-effects.",
            "id": "de59803cedb61f7ce699e726d91d3660"
          },
          {
            "type": "html",
            "text": "<b>Variations:</b>",
            "id": "59a5383fb44678b2e75f92a5434bfe2b"
          },
          {
            "type": "html",
            "text": "<i>Argument binding</i>: The basic [[Functor Object]] is supplied with its parameters at invocation time. It is possible, however, to separate argument application from invocation. The [[Python Language]] uses default argument values to make this separation. In other languages it is possible to create [[Functor Object]]s that can appear to store parameter values until invocation time. This is the enabling infrastructure for [[Curried Functor]]s.",
            "id": "02727bf1b06c253704c814584ebecad3"
          },
          {
            "type": "html",
            "text": "<i>Keyword parameters</i>: Argument application can be further generalized by providing a mechanism for supplying parameters by name. This could be done through named methods or through keyword strings. Such an application can produce a new object - a form of [[Curried Functor]].",
            "id": "0c90f67061d0659de1527d72ea8a3621"
          },
          {
            "type": "html",
            "text": "<i>Default parameters</i>: A [[Functor Object]] can also come with some parameters pre-applied. In this case the defaults can be overridden by some form of argument binding before the [[Functor Object]] is actually invoked.",
            "id": "e8b14c2aa7b84322a42ab8d9e7887875"
          },
          {
            "type": "html",
            "text": "<i>Multiple results</i>: A [[Functor Object]] can potentially calculate more than one result. In this case use [[Command Query Separation]] to separate invocation of the [[Functor Object]] from the queries that return its various results. ",
            "id": "12d081d92d10c5ac4e6a9ee54c00b70f"
          },
          {
            "type": "html",
            "text": "<i>Composed [[Functor Object]]s</i>: A [[Functor Object]] may represent a [[Higher Order Function]] that can be parameterized with another [[Functor Object]]. For instance a [[Functor Object]] may be parameterized with a predicate that will short-circuit the [[Function Object]] unless some condition is true. This is especially valuable for use in [[Internal Iteration]].",
            "id": "690a61d49dcfe6b796f9e20377e09a0d"
          },
          {
            "type": "html",
            "text": "<b>Known Uses:</b>",
            "id": "bbdae1b71a5d89b52d5c604b74b7d592"
          },
          {
            "type": "html",
            "text": "\nC++ STL (Standard Template Library) -- [[Stl Function Objects]]",
            "id": "995c151c6a0b67564b91cfdd593520c9"
          },
          {
            "type": "html",
            "text": "\nIn the C++ [[Standard Template Library]], a \"[[Function Object]]\" is an instance of a class that implements \"operator()\". As such, its usage is syntactically indistinguishable from a [[Function Pointer]] - a property that lets [[Function Object]]s and [[Function Pointer]]s be used interchangeably in template-based [[Generic Algorithms]].",
            "id": "2c30f05541f2d264953b2b6d32b48cb3"
          },
          {
            "type": "html",
            "text": "\nThe benefit of using objects instead of [[Function Pointer]]s is that the compiler can inline methods with [[Function Object]]s.",
            "id": "5e42c54995121e491ff090dde6af64a4"
          },
          {
            "type": "html",
            "text": "[See [[Stl Function Objects]] for discussion.]",
            "id": "8a68d87e186dacaad9d8ec5e21628b38"
          },
          {
            "type": "html",
            "text": "<b>See also:</b> [[Functor Object Example]], [[Blocks In Java]], [[Functional Programming In Cpp]]",
            "id": "086e2ffda237d5f66574e86a8fb848ce"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e76950a28b8d9a5eb09dc9a83d16beed"
          },
          {
            "type": "html",
            "text": "<b>Discussion:</b>",
            "id": "69717dfe4f058fce028fbf7d2efdb112"
          },
          {
            "type": "html",
            "text": "\nThe name, [[Functor Object]], is a very poor one. A [[Functor Object]] is an object that acts as a function, and can be operated upon like an object. As such, they are akin to mathematical functionals such as the [[Dirac Delta Function]], or mathematical operators such as the derivative or the [[Fourier Transform]].",
            "id": "efb84d4f1f011d956f7b35accecd4df5"
          },
          {
            "type": "html",
            "text": "\nIn <i>[[Category Theory]]</i>, the field of mathematics where the term <i>Functor</i> originates, a <i>Functor</i> is a mapping from one <i>Category</i> to another that respects <i>Morphism</i>s [functions].  For example, consider the <i>Category</i> of <i>[[Topological Space]]</i>s and <i>[[Continuous Map]]</i>s. The <i>H</i>omologyMorphism H_1 sends this <i>Category</i> to that of <i>[[Abelian Group]]</i>s and <i>[[Homo Morphism]]</i>s.  This means that if I have the following series of continuous topological maps:",
            "id": "4c90c9c0ee7b5a4609e6e1372f4c13a7"
          },
          {
            "type": "code",
            "text": "           f             g\n    S  ---------> T ----------> U,",
            "id": "e3643ea1f3a7c4ed676ed34f035564db"
          },
          {
            "type": "html",
            "text": "\nI also get the series of homomorphisms:",
            "id": "b7375d5653ad107d8bd7e5940195f0e2"
          },
          {
            "type": "code",
            "text": "         H_1(f)        H_1(g)\n  H_1(S) -----> H_1(T) ------> H_1(U),",
            "id": "2da12d9c2c3004520b8981b7b4553d30"
          },
          {
            "type": "html",
            "text": "\nand H_1(gf) = H_1(g)H_1(f).",
            "id": "02d920016f909775aff91c692a817072"
          },
          {
            "type": "html",
            "text": "\nYou don't need to understand that; my point is that <i>Functor</i>s act on the entire problem domain, not just on functions or upon arguments. The only example I can think of right now is this.",
            "id": "e86da6c6bce4b4499a9455e2b616060e"
          },
          {
            "type": "html",
            "text": "\nConsider the <i>Category</i> of <i>Object</i>s and <i>Algorithm</i>s for functions whose results depend on no hidden variables. For example, real numbers and the sine function, but not decks of cards and a random shuffle function. Then, define the memoize functor to take objects to themselves, and algorithms to their memoized versions. The is a valid map from that category to itself - the memoized algorithm uses hidden variables, but the results do not.",
            "id": "9faf0a53d1f1e505d7a0ef44db944921"
          },
          {
            "type": "html",
            "text": "-- [[Eric Jablow]]",
            "id": "f01a8f2e8aed9ca5b75e6aca63a41762"
          },
          {
            "type": "html",
            "text": "<i>A [[Functor Object]] is an object that acts as a function, and can be operated upon like an object.</i>",
            "id": "a21ac0c4ac28b2c4bff8dce6eca1eb29"
          },
          {
            "type": "html",
            "text": "\nI think this would mean that it was very <i>well</i> named? The word <i>functor</i> comes from the latin from Latin <i>f�nctio</i>, which means performance of a function. A synonym for <i>functor</i> is <i>function</i>. In [[Computer Science]], it is very much like a lambda and sometimes no different than a <i>function</i>. In fact, even in Category Theory the use <i>theory of functors</i> and <i>function theory</i> analogously. -- [[Robert Di Falco]]",
            "id": "28284ce38708a7b31564a25afd325f73"
          },
          {
            "type": "html",
            "text": "<i>In </i>[[Category Theory]]<i>, the field of mathematics where the term </i>Functor<i> originates</i>",
            "id": "7ff64672927c90c806d5c55e96386b3a"
          },
          {
            "type": "html",
            "text": "\nThis isn't true. Category Theory like many other branches of science and mathematics uses the term <i>functor</i> but it did not <i>originate</i> in abstract algebra -- at least that's not what my research says. Even if it did originate in Category Theory with set-valued functors or functory category, it wouldn't matter. In this case, we are talking about <i>functors</i> as they exist in programming languages where for decades, a <i>functor</i> has analogous to a <i>function</i>. -- [[Robert Di Falco]]",
            "id": "099a8c1121946f5a85fbeb013b431fb5"
          },
          {
            "type": "html",
            "text": "\nThe term <i>functor</i> as used in Category Theory was originally borrowed from Carnap, and has been used unambiguously in mathematics at least since 1950. Anyway, there is a well established use of the term in computer science, specifically in the [[Sml Language]], where a <i>functor</i> is a parametric structure. Because of that, [[Functor Object]] seems to be a poorly chosen name. For a similar concept the [[Common Lisp Object System]] uses the more descriptive term <i>funcallable instance</i>. What's wrong with [[Function Object]], besides the fact that its [[Wiki Name]] is already taken? --",
            "id": "e4712d79d71e2b087c572a1c745ad29d"
          },
          {
            "type": "html",
            "text": "\n[[Jim Coplien]] uses the word 'functor' in his book '[[Advanced Cee Plus Plus]]'. If you've got a gripe with it ask him. -- [[Phil Goodwin]]",
            "id": "c039387d0646ca2788cba6d820be109f"
          },
          {
            "type": "html",
            "text": "\nTrue, as Phil knows there are tons of synonyms for this such as: functor, functoid, function object, lexical closure, closure, code-block, and so on. There is a lot of history for functor and functiod, especially regarding enclosing functions in objects. -- [[Robert Di Falco]]",
            "id": "34b72c17ab2868eccb41ade2317a649e"
          },
          {
            "type": "html",
            "text": "\n[[Andrei Alexandrescu]] uses the term [[Callable Entity]] in his book [[Modern Cee Plus Plus Design]] to refer to C-like functions, pointers or references to C-like functions, objects that define an operator(), or the result of applying operator.* or operator->* with a pointer to a member function in the right-hand side of the expression.",
            "id": "196cc7efe11607f208d6f04979333a17"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e76950a28b8d9a5eb09dc9a83d16beed"
          },
          {
            "type": "html",
            "text": "\nLet me see, when would I use this? Oh yes, when I need a function pointer. Nice to see an OO solution ;). -- [[Richard Henderson]].",
            "id": "de4ebe5d50b054881cc1c14965bcc35b"
          },
          {
            "type": "html",
            "text": "<i>I appreciate your humor, and at the same hope everyone who reads it understands the irony. A [[Functor Object]] (or [[Lambda Expression]], [[Lexical Closure]], [[Code Block]], etc) includes a snapshot of its context (for example, a frame within which to bind its arguments and a safe place to answer its results). A naked function pointer, unless written very carefully, does not. It is certainly true that a [[Functor Object]] can be constructed in, for example, [[Cee Plus Plus]] using a function pointer -- some might argue that this was the impetus for [[Cee Plus Plus]] -- but a function pointer by itself is NOT a [[Functor Object]].</i>",
            "id": "e7add16b6606d205941e10fea95c91ac"
          },
          {
            "type": "html",
            "text": "\nNo indeed, and I was only half-joking. I really do need safe function pointer-like behaviour. Specifically this provides a perfect analog of a connecting wire which explicitly connects two objects that don't need to know details about each other. Each adapts to the other by \"requesting\" a connection. Previously I used external adapter objects but this is much lighter weight and generally lovely [[Micro Architecture]].",
            "id": "fd2533568b48d40928270f06fab8360b"
          },
          {
            "type": "html",
            "text": "\nIs there a restriction on the degree of independence that a functor has from its parent? I'm jumping on its adapter properties, but the Factory pattern is not so far away in that there is an equivalent interaction.",
            "id": "f3e6c583727b5b58ba852b1a1350efa8"
          },
          {
            "type": "html",
            "text": "<i>One of the first things I built from these, in Java, was a [[Pluggable Adaptor]] module, following the example in Smalltalk. I find this an elegant and powerful \"[[Connecting Wire]]\" - once you try it, you'll never turn back. -- [[Tom Stambaugh]]</i>",
            "id": "4862bce6b82cef48d40d394475031bc3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e76950a28b8d9a5eb09dc9a83d16beed"
          },
          {
            "type": "html",
            "text": "Functors may also inform a factory about what they can do - either by proxy, or directly, allowing the factory to select the \"optimum\" functor from a collection of functors, using hints provided by the invoker of the factory...",
            "id": "925ba5de5f43d49b964c313c434def61"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e76950a28b8d9a5eb09dc9a83d16beed"
          },
          {
            "type": "html",
            "text": "When a language forces you to emulate simple functional values using a much more complicated object mechanism it is basically an instance of the [[Abstraction Inversion]] [[Anti Pattern]]. I'm not saying that it would not make sense to emulate functional values using the object mechanism in an OO language that doesn't provide first class functional values, but I'm saying that the language effectively forces [[Abstraction Inversion]]. Consider the following example:",
            "id": "12495444a6b9b476214693a0d002e012"
          },
          {
            "type": "html",
            "text": "Scheme:<br>((lambda (x) x) 1)",
            "id": "b085b99c947f971b224d514141fb539b"
          },
          {
            "type": "html",
            "text": "Java:<br>new Function() {",
            "id": "96aba726120ae70c280634d05efc1c56"
          },
          {
            "type": "code",
            "text": "              public Object with(Object x) {\n                return x;\n              }}.with(new Integer(1))",
            "id": "c41f74aad2fec0429046bb905fe56177"
          },
          {
            "type": "html",
            "text": "\nEven if the manifest typing would be removed from the Java version, there would still be an unnecessary indirection in the Java version. The dispatch to the with-method happens indirectly, which is not necessary as the necessary indirection is already provided by the use of the functional value. -- [[Vesa Karvonen]]",
            "id": "9982de6b48630c829af173b3f8562133"
          },
          {
            "type": "html",
            "text": "\nOf course, Java's not exactly a good example of a proper OO language, Smalltalk does it with pure objects while remaining as simple as the Scheme equivalent.",
            "id": "bca204cfa1b3af02bd8c35590bce04d7"
          },
          {
            "type": "html",
            "text": "[:x | x ] value:<br>1",
            "id": "9e6e532c72ca11bdf80434877d107188"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e76950a28b8d9a5eb09dc9a83d16beed"
          },
          {
            "type": "html",
            "text": "Another issue worth mentioning is that [[Functor Object]] is strongly related to the [[Strategy Pattern]]. [[Functor Object]] essentially differs from the [[Strategy Pattern]] in that a [[Functor Object]] is less specific to a particular situation and that a [[Functor Object]] always contains just one entry point. Both [[Strategy Pattern]] and [[Functor Object]] are essentially \"just parameterization\". The most likely reason why they are given the high status as patterns in OO languages is that behavioral parameterization using functional values is not necessarily immediately obvious in OO languages that do not support first class functional values. -- [[Vesa Karvonen]]",
            "id": "10b5c0a28d102b3d8be4c4e00a713b47"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e76950a28b8d9a5eb09dc9a83d16beed"
          },
          {
            "type": "html",
            "text": "I would like to note that \"functor\" is a misnomer. It already has a meaning of \"a morphism from category to category\", which is approximately what a template is in C++ parlance. -- [[Panu Kalliokoski]]",
            "id": "f731527eb55bbb3cf1d52f1691fd4eb5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e76950a28b8d9a5eb09dc9a83d16beed"
          },
          {
            "type": "html",
            "text": "functor has a long history in discussions of Prolog predicates in terms of the 'functor' and the 'arity' of predicates. -- [[Robert Shiplett]]",
            "id": "ac3adb4eb7696d4e17463d227a2d1f16"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e76950a28b8d9a5eb09dc9a83d16beed"
          },
          {
            "type": "html",
            "text": "Someone created this page to discuss objects that combine dates/ranges with monetary amounts - moved to [[Date And Value Object]].",
            "id": "12c0dffde8394d114fb6cc0f92d558c8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e76950a28b8d9a5eb09dc9a83d16beed"
          },
          {
            "type": "html",
            "text": "\nDiscussion of [[Value Object]]s (like [[Money Amount]]) requiring garbage collection ([[Algorithms That Demand Garbage Collection]]) moved to <b>Do [[Value Objects Require Garbage Collection]]?</b>.",
            "id": "04c6d7434a9f8735d72e6635052fc959"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "e76950a28b8d9a5eb09dc9a83d16beed"
          },
          {
            "type": "html",
            "text": "[[Category Object Functional Patterns]] [[Category Coding Conventions]]",
            "id": "f936d1bf6b4dc2ef0f75e481ebc0a635"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?FunctorObject c2.com]",
            "id": "586f0e9608822bb3e6911ea4a14d4652"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1644991116323
    }
  ]
}