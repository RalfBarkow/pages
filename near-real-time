{
  "title": "Near Real Time",
  "story": [
    {
      "type": "html",
      "text": "<i>Near Real Time</i> means effectively [[Real Time]] but without guarantees of hitting specific deadlines. Also known as <i>soft real time</i> (as opposed to <i>hard real time</i>).",
      "id": "fbd3b288a4702b0b1185a35fe1270b06"
    },
    {
      "type": "html",
      "text": "\nFor example [[Erlang Language]] is used in [[Near Real Time]] telecommunications and Internet applications, e.g. in switches, etc. It is a dynamic language with a [[Non Real Time]] garbage collector. It does not have specific deadline capability, but it effectively works in practice.",
      "id": "6972341061143b584f4ecd3eee36f79f"
    },
    {
      "type": "html",
      "text": "\nThis does not imply that a [[Near Real Time]] system that works in practice could work in true [[Real Time]]. You cannot count on it to do so.",
      "id": "3f4174ace83c97de3454aa921af0abbb"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ecac98412878b1b85bc8b1971db0214c"
    },
    {
      "type": "html",
      "text": "The term <i>Near Real Time</i> is also sometimes used to mean that users see data that is only a few seconds old. (But purists favor the above definition.)",
      "id": "d70381d3fbe5927ced58783932398657"
    },
    {
      "type": "html",
      "text": "<i>Actually, purists use \"real time\" and \"other.\" If it isn't truly real time then it isn't. There is no substitute.</i>",
      "id": "020e7e13adb2831be16fc356684ec7c7"
    },
    {
      "type": "html",
      "text": "\nAs a purist, I use the phrase <i>soft [[Real Time]]</i> to refer to conditions where we can make <i>probabilistic</i> guarantees about delay - e.g. when we can assert that delays are bounded by a Poisson distribution or Bell curve. This seems to be a much stronger assertion than '[[Near Real Time]]', since it still involves a useful guarantee even without the 'hard' deadline boundaries.",
      "id": "b29b3a04380c6e9bd1b57bcb4c2f9ede"
    },
    {
      "type": "html",
      "text": "<i>You, sir, are simply not a purist in any sense of the word. If a system has fully predictive latency then it is real time. If it does not then it isn't -- that's how real time systems are defined. Period. There is no \"near real time,\" no \"soft real time,\" no \"probabilistic real time,\" nor any other blather. It's real time or it ain't.</i>",
      "id": "6964df5f4310ba4dbf6356e6e2b6abd0"
    },
    {
      "type": "html",
      "text": "\nNot even 'hard [[Real Time]]' systems have <i>\"fully predictive latency\"</i>. They have upper bounds, and sometimes lower bounds. Latencies are never fully deterministic down to the hardware layer. Issues such as metastability and clock drift prevent such a thing. I'm a purist in the sense that I won't call a system [[Real Time]] unless it can be proven; in the industry, unfortunately, the word gets bandied about even for aviation software without any formal analysis. I would guess you're not involved with [[Real Time]] systems of any sort, just contributing here to 'out-pure' me for kicks and grins.",
      "id": "089c8387ba65927a7fa2e23b9a7a83ed"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ecac98412878b1b85bc8b1971db0214c"
    },
    {
      "type": "html",
      "text": "The use of this term within the purist category of \"other\" is a recognition of necessary processing and presenting time frames. Illustration: We cannot observe the Universe in \"[[Real Time]]\" because of physical separation distances involved. In the computing sense, [[Near Real Time]] is a recognition of this taking into consideration that what we observe is in reality a \"playback\" of the real thing, since it has been through a process of encoding-storage and decoding-presentation and the attendant time requred for the operations. -- [[Donald Noyes]].20110706",
      "id": "3ec2a1a886863b96c53c1d3b0be043c3"
    },
    {
      "type": "html",
      "text": "\n[[Real Time]] does not mean <i>zero latency</i>. It means <i>controlled latency</i>. Delays are acceptable where we can make guarantees about them and still meet system timing requirements. We do not say '[[Near Real Time]]' when we have delay; we say it when we cannot <i>bound</i> the delay. ",
      "id": "8d5d5bd4d1b3d7ea00c723477cbf5a75"
    },
    {
      "type": "html",
      "text": "\nA video camera cannot observe the universe. It can only observe the light that strikes the sensitive elements on the camera. That light might carry information about locations distant and in the past. We can call such a system '[[Real Time]]' if the information in the video is processed at the same rate it is obtained, such that we can guarantee the delay between receiving a frame and updating our information, as opposed to requiring a later batch effort. ",
      "id": "3c1aa819c202c281dadae29a3f6b850b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ecac98412878b1b85bc8b1971db0214c"
    },
    {
      "type": "html",
      "text": "<b>Consider this:</b>",
      "id": "d1139f92a19aa54117baee92f2d43965"
    },
    {
      "type": "html",
      "text": "\nI am sure that segments and intervals of time can be reproduced to appear in dependable and predictable manner such as to be effective in part, but I am speaking of [[Near Real Time]] in such a manner as to allow information and control interchange <b>two-way-simultaneous</b> in packets which are <i>longer in duration than the magnitudes of the two-way delay</i>. ",
      "id": "bfd3468678b4305032bcdefec5c3c186"
    },
    {
      "type": "html",
      "text": "\nThis is if response requires processing before response, or is dependent in the case of control on the receiving end's process response to changes commanded. It he interchange is over great distances and the command increments are small (less than complete sequences and not autonoumus or semi-autonomous), task completions are difficult, or severely drawn out. Such is the case in controlling a robotic vehicle say at a distance of Mars. Instead of commands, one must depend upon sequences with local feedback and control or near autonomous decision and control. Other real-time problems occur when both processing units misunderstand or only partly process the information being exchanged, as in when the receiving party begins a return exchange before processing the complete message from the sending party. This most often results in an interrupted or halted exchange. ",
      "id": "10f1192c2806d76fffcf9af2f8e3b026"
    },
    {
      "type": "html",
      "text": "<i>It is true that, as we increase delay or risk of disruption, we must simultaneously increase autonomy. That doesn't mean we can't have [[Real Time]], but we do need to specify our actions on appropriate time scales. For example, light-speed round-trip to Mars is 11 to 44 minutes depending on relative orbital, so at that level we would need to schedule actions that take on the order of at least a couple hours to complete. Currently, of course, we are limited to an orbiting communication satellite above Mars, so our real communication delays are up to a day, and thus even longer missions are required. Low-level teleop (move arm 3cm to left) would be grossly inefficient and unsafe, but we could provide a route or patrol mission. Any code we transmit for autonomous behavior can potentially make real-time decisions at a much finer scale.</i>",
      "id": "1e2840e179c8ad36f701a7355c21d081"
    },
    {
      "type": "html",
      "text": "<i>Anyhow, it seems you conflate '[[Real Time]]' with 'interactive'. From connotation, that is understandable - we almost always use '[[Real Time]]' in reference to interactive systems. But the meanings are different: [[Real Time]] is simply about meeting timing constraints. Those timing constraints might be microseconds, or might be hours. Granted, we could never meet the temporal requirements for teleoperation of a Mars rover... but choosing sane requirements is a separate issue.</i>",
      "id": "e88e37a920ad855293fbb231e3f1055c"
    },
    {
      "type": "html",
      "text": "\nNot only are timing constraints important, but also the dependency on time as a function in rates of change, as in the failed mission which was the result of confusing english and metric expressions of velocity to determine the magnitude and timing of the velocity change component of the mission. Requirements may be separately and singly understood, but when employed in connection with another component using differing usages in length, velocity and acceleration the result of which, in this particular critical operation, resulted in an unrecoverable and destructive result. ",
      "id": "1d4a6917216d090980798444c0456c9e"
    },
    {
      "type": "html",
      "text": "<i>Clearly communicating requirements is important, but I'm not sure what it has to do with the topic of this page.</i>",
      "id": "f79d6cae39513e939bdf623134d70a92"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "ecac98412878b1b85bc8b1971db0214c"
    },
    {
      "type": "html",
      "text": "See: [[Delay Tolerant Networking]] ",
      "id": "2609e628fdf240fde354533e8c6430a0"
    },
    {
      "type": "html",
      "text": "\n[[Category Time]]",
      "id": "fd380f08e9117163a8406b7b73fa9f96"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?NearRealTime c2.com]",
      "id": "8d3d46dc0edf69dc56a2f97cf9fb7b0d"
    }
  ],
  "journal": [
    {
      "date": 1310360933000,
      "id": "91eb9c3654ed55e3ec51748f7fe49ca3",
      "type": "create",
      "item": {
        "title": "Near Real Time",
        "story": [
          {
            "type": "html",
            "text": "<i>Near Real Time</i> means effectively [[Real Time]] but without guarantees of hitting specific deadlines. Also known as <i>soft real time</i> (as opposed to <i>hard real time</i>).",
            "id": "fbd3b288a4702b0b1185a35fe1270b06"
          },
          {
            "type": "html",
            "text": "\nFor example [[Erlang Language]] is used in [[Near Real Time]] telecommunications and Internet applications, e.g. in switches, etc. It is a dynamic language with a [[Non Real Time]] garbage collector. It does not have specific deadline capability, but it effectively works in practice.",
            "id": "6972341061143b584f4ecd3eee36f79f"
          },
          {
            "type": "html",
            "text": "\nThis does not imply that a [[Near Real Time]] system that works in practice could work in true [[Real Time]]. You cannot count on it to do so.",
            "id": "3f4174ace83c97de3454aa921af0abbb"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ecac98412878b1b85bc8b1971db0214c"
          },
          {
            "type": "html",
            "text": "The term <i>Near Real Time</i> is also sometimes used to mean that users see data that is only a few seconds old. (But purists favor the above definition.)",
            "id": "d70381d3fbe5927ced58783932398657"
          },
          {
            "type": "html",
            "text": "<i>Actually, purists use \"real time\" and \"other.\" If it isn't truly real time then it isn't. There is no substitute.</i>",
            "id": "020e7e13adb2831be16fc356684ec7c7"
          },
          {
            "type": "html",
            "text": "\nAs a purist, I use the phrase <i>soft [[Real Time]]</i> to refer to conditions where we can make <i>probabilistic</i> guarantees about delay - e.g. when we can assert that delays are bounded by a Poisson distribution or Bell curve. This seems to be a much stronger assertion than '[[Near Real Time]]', since it still involves a useful guarantee even without the 'hard' deadline boundaries.",
            "id": "b29b3a04380c6e9bd1b57bcb4c2f9ede"
          },
          {
            "type": "html",
            "text": "<i>You, sir, are simply not a purist in any sense of the word. If a system has fully predictive latency then it is real time. If it does not then it isn't -- that's how real time systems are defined. Period. There is no \"near real time,\" no \"soft real time,\" no \"probabilistic real time,\" nor any other blather. It's real time or it ain't.</i>",
            "id": "6964df5f4310ba4dbf6356e6e2b6abd0"
          },
          {
            "type": "html",
            "text": "\nNot even 'hard [[Real Time]]' systems have <i>\"fully predictive latency\"</i>. They have upper bounds, and sometimes lower bounds. Latencies are never fully deterministic down to the hardware layer. Issues such as metastability and clock drift prevent such a thing. I'm a purist in the sense that I won't call a system [[Real Time]] unless it can be proven; in the industry, unfortunately, the word gets bandied about even for aviation software without any formal analysis. I would guess you're not involved with [[Real Time]] systems of any sort, just contributing here to 'out-pure' me for kicks and grins.",
            "id": "089c8387ba65927a7fa2e23b9a7a83ed"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ecac98412878b1b85bc8b1971db0214c"
          },
          {
            "type": "html",
            "text": "The use of this term within the purist category of \"other\" is a recognition of necessary processing and presenting time frames. Illustration: We cannot observe the Universe in \"[[Real Time]]\" because of physical separation distances involved. In the computing sense, [[Near Real Time]] is a recognition of this taking into consideration that what we observe is in reality a \"playback\" of the real thing, since it has been through a process of encoding-storage and decoding-presentation and the attendant time requred for the operations. -- [[Donald Noyes]].20110706",
            "id": "3ec2a1a886863b96c53c1d3b0be043c3"
          },
          {
            "type": "html",
            "text": "\n[[Real Time]] does not mean <i>zero latency</i>. It means <i>controlled latency</i>. Delays are acceptable where we can make guarantees about them and still meet system timing requirements. We do not say '[[Near Real Time]]' when we have delay; we say it when we cannot <i>bound</i> the delay. ",
            "id": "8d5d5bd4d1b3d7ea00c723477cbf5a75"
          },
          {
            "type": "html",
            "text": "\nA video camera cannot observe the universe. It can only observe the light that strikes the sensitive elements on the camera. That light might carry information about locations distant and in the past. We can call such a system '[[Real Time]]' if the information in the video is processed at the same rate it is obtained, such that we can guarantee the delay between receiving a frame and updating our information, as opposed to requiring a later batch effort. ",
            "id": "3c1aa819c202c281dadae29a3f6b850b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ecac98412878b1b85bc8b1971db0214c"
          },
          {
            "type": "html",
            "text": "<b>Consider this:</b>",
            "id": "d1139f92a19aa54117baee92f2d43965"
          },
          {
            "type": "html",
            "text": "\nI am sure that segments and intervals of time can be reproduced to appear in dependable and predictable manner such as to be effective in part, but I am speaking of [[Near Real Time]] in such a manner as to allow information and control interchange <b>two-way-simultaneous</b> in packets which are <i>longer in duration than the magnitudes of the two-way delay</i>. ",
            "id": "bfd3468678b4305032bcdefec5c3c186"
          },
          {
            "type": "html",
            "text": "\nThis is if response requires processing before response, or is dependent in the case of control on the receiving end's process response to changes commanded. It he interchange is over great distances and the command increments are small (less than complete sequences and not autonoumus or semi-autonomous), task completions are difficult, or severely drawn out. Such is the case in controlling a robotic vehicle say at a distance of Mars. Instead of commands, one must depend upon sequences with local feedback and control or near autonomous decision and control. Other real-time problems occur when both processing units misunderstand or only partly process the information being exchanged, as in when the receiving party begins a return exchange before processing the complete message from the sending party. This most often results in an interrupted or halted exchange. ",
            "id": "10f1192c2806d76fffcf9af2f8e3b026"
          },
          {
            "type": "html",
            "text": "<i>It is true that, as we increase delay or risk of disruption, we must simultaneously increase autonomy. That doesn't mean we can't have [[Real Time]], but we do need to specify our actions on appropriate time scales. For example, light-speed round-trip to Mars is 11 to 44 minutes depending on relative orbital, so at that level we would need to schedule actions that take on the order of at least a couple hours to complete. Currently, of course, we are limited to an orbiting communication satellite above Mars, so our real communication delays are up to a day, and thus even longer missions are required. Low-level teleop (move arm 3cm to left) would be grossly inefficient and unsafe, but we could provide a route or patrol mission. Any code we transmit for autonomous behavior can potentially make real-time decisions at a much finer scale.</i>",
            "id": "1e2840e179c8ad36f701a7355c21d081"
          },
          {
            "type": "html",
            "text": "<i>Anyhow, it seems you conflate '[[Real Time]]' with 'interactive'. From connotation, that is understandable - we almost always use '[[Real Time]]' in reference to interactive systems. But the meanings are different: [[Real Time]] is simply about meeting timing constraints. Those timing constraints might be microseconds, or might be hours. Granted, we could never meet the temporal requirements for teleoperation of a Mars rover... but choosing sane requirements is a separate issue.</i>",
            "id": "e88e37a920ad855293fbb231e3f1055c"
          },
          {
            "type": "html",
            "text": "\nNot only are timing constraints important, but also the dependency on time as a function in rates of change, as in the failed mission which was the result of confusing english and metric expressions of velocity to determine the magnitude and timing of the velocity change component of the mission. Requirements may be separately and singly understood, but when employed in connection with another component using differing usages in length, velocity and acceleration the result of which, in this particular critical operation, resulted in an unrecoverable and destructive result. ",
            "id": "1d4a6917216d090980798444c0456c9e"
          },
          {
            "type": "html",
            "text": "<i>Clearly communicating requirements is important, but I'm not sure what it has to do with the topic of this page.</i>",
            "id": "f79d6cae39513e939bdf623134d70a92"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "ecac98412878b1b85bc8b1971db0214c"
          },
          {
            "type": "html",
            "text": "See: [[Delay Tolerant Networking]] ",
            "id": "2609e628fdf240fde354533e8c6430a0"
          },
          {
            "type": "html",
            "text": "\n[[Category Time]]",
            "id": "fd380f08e9117163a8406b7b73fa9f96"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?NearRealTime c2.com]",
            "id": "8d3d46dc0edf69dc56a2f97cf9fb7b0d"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1654019083376
    }
  ]
}