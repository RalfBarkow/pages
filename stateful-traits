{
  "title": "Stateful Traits",
  "story": [
    {
      "type": "markdown",
      "id": "7acbaf3741791509",
      "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by [[Multiple Inheritance]] and [[Mixins]]. \n"
    },
    {
      "type": "markdown",
      "id": "70aba56e6a576481",
      "text": "Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code.\n\n"
    },
    {
      "type": "markdown",
      "id": "b8d2450159894137",
      "text": "Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports **stateful traits**. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: **the client retains control of the composition**. \n"
    },
    {
      "type": "markdown",
      "id": "cb0436bfd575113c",
      "text": "Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. \n"
    },
    {
      "type": "markdown",
      "id": "eca71925f55ad48a",
      "text": "**Naming conflicts are avoided**, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy. [https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4 doi]"
    },
    {
      "type": "paragraph",
      "id": "d8ffea1571861f7d",
      "text": "Traits are pure units of reuse consisting only of methods [SDNB03,DNS+06]. Traits can be composed to either form other traits or classes. They are recognized for their potential in supporting better composition and reuse, hence their integration in newer versions of languages such as Perl 6, Squeak [IKM+97], Scala [sca], Slate [Sla] and Fortress [for]. Although traits were originally designed for dynamically-typed languages, there has been considerable interest in applying traits to statically-typed languages as well [FR03, SD05, NDS06]."
    },
    {
      "type": "markdown",
      "id": "07106d49f9c92641",
      "text": "**Traits make it possible for inheritance to be used to [[reflect]] conceptual hierarchy rather than for code reuse.** Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations. At the same time, traits largely avoid the fragility problems introduced by approaches based on multiple inheritance and mixins, since traits are entirely divorced from the inheritance hierarchy."
    },
    {
      "type": "paragraph",
      "id": "89a46201060542fa",
      "text": "[…]"
    },
    {
      "type": "paragraph",
      "id": "d10b950be26e3564",
      "text": "Conceptually, however, the lack of state means that virtually all traits are incomplete, since just about any useful trait will require some accessors. Furthermore, the mechanism of required methods is abused to cover for the lack of state. As a consequence, the required interface of a trait is cluttered with noise that impedes the understanding and consequently the reuse of a trait. Even if the missing state and accessors can be generated, many clients will consist of “shell classes” — classes that do nothing but compose traits with boilerplate glue code. Furthermore, if the required accessors are made public (as is the case in the Smalltalk implementation), encapsulation is unnecessarily violated in the client classes. Finally, if a trait is ever modified to include additional state, new required accessors will be propagated to all client traits and classes, thus introducing a form of fragility that traits were intended to avoid!"
    },
    {
      "type": "paragraph",
      "id": "8658d93fd19b05ec",
      "text": "This paper describes stateful traits, an extension of stateless traits in which a single variable access operator is introduced to give clients of traits control over the visibility of instance variables. The approach is faithful to the guiding principle of stateless traits in which the client of a trait has full control over the composition. It is this principle that is the key to avoiding fragility in the face of change, since no implicit conflict resolution rules come into play when a trait is modified. "
    },
    {
      "type": "paragraph",
      "id": "64b3682410f8c269",
      "text": "In a nutshell, instance variables are private to a trait. The client can decide, however, at composition time to access instance variables offered by a used trait, or to merge variables offered by multiple traits. In this paper we present an analysis of the limitations of stateless traits and we present our approach to achieving stateful traits. We describe and compare two implementation strategies, and we briefly describe our experience with an illustrative case study. "
    },
    {
      "type": "paragraph",
      "id": "5dc6949bdeaa7fc0",
      "text": "The structure of this paper is as follows: First we review stateless traits [SDNB03, DNS+06]. In Section 3 we discuss the limitations of stateless traits. In Section 4 we introduce stateful traits, which support the introduction of state in traits. Section 5 outlines some details of the implementation of stateful traits. In Section 6 we present a small case study in which we compare the results of refactoring the Smalltalk collections hierarchy with both stateless and stateful traits. In Section 7 we discuss some of the broader consequences of the design of stateful traits. Section 8 discusses related work. Section 9 concludes the paper."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Stateful Traits",
        "story": []
      },
      "date": 1662261515683
    },
    {
      "item": {
        "type": "factory",
        "id": "7acbaf3741791509"
      },
      "id": "7acbaf3741791509",
      "type": "add",
      "date": 1662261523421
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "paragraph",
        "id": "7acbaf3741791509",
        "text": "– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261528054
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261529350
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "Traits offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports stateful traits. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. Naming conflicts are avoided, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261674483
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports stateful traits. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. Naming conflicts are avoided, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261684852
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports **stateful traits**. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. Naming conflicts are avoided, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261743417
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports **stateful traits**. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: **the client retains control of the composition**. Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. **Naming conflicts are avoided**, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261812815
    },
    {
      "item": {
        "type": "factory",
        "id": "d8ffea1571861f7d"
      },
      "id": "d8ffea1571861f7d",
      "type": "add",
      "after": "7acbaf3741791509",
      "date": 1662261877179
    },
    {
      "type": "edit",
      "id": "d8ffea1571861f7d",
      "item": {
        "type": "paragraph",
        "id": "d8ffea1571861f7d",
        "text": "Traits are pure units of reuse consisting only of methods [SDNB03,DNS+06]. Traits can be composed to either form other traits or classes. They are recognized for their potential in supporting better composition and reuse, hence their integration in newer versions of languages such as Perl 6, Squeak [IKM+97], Scala [sca], Slate [Sla] and Fortress [for]. Although traits were originally designed for dynamically-typed languages, there has been considerable interest in applying traits to statically-typed languages as well [FR03, SD05, NDS06]."
      },
      "date": 1662261879266
    },
    {
      "item": {
        "type": "factory",
        "id": "07106d49f9c92641"
      },
      "id": "07106d49f9c92641",
      "type": "add",
      "after": "d8ffea1571861f7d",
      "date": 1662261909813
    },
    {
      "type": "edit",
      "id": "07106d49f9c92641",
      "item": {
        "type": "paragraph",
        "id": "07106d49f9c92641",
        "text": "Traits make it possible for inheritance to be used to reflect conceptual hierarchy rather than for code reuse. Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations."
      },
      "date": 1662261912601
    },
    {
      "type": "edit",
      "id": "07106d49f9c92641",
      "item": {
        "type": "paragraph",
        "id": "07106d49f9c92641",
        "text": "**Traits make it possible for inheritance to be used to reflect conceptual hierarchy rather than for code reuse.** Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations."
      },
      "date": 1662261935877
    },
    {
      "type": "edit",
      "id": "07106d49f9c92641",
      "item": {
        "type": "markdown",
        "id": "07106d49f9c92641",
        "text": "**Traits make it possible for inheritance to be used to reflect conceptual hierarchy rather than for code reuse.** Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations."
      },
      "date": 1662261937202
    },
    {
      "type": "edit",
      "id": "07106d49f9c92641",
      "item": {
        "type": "markdown",
        "id": "07106d49f9c92641",
        "text": "**Traits make it possible for inheritance to be used to reflect conceptual hierarchy rather than for code reuse.** Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations. At the same time, traits largely avoid the fragility problems introduced by approaches based on multiple inheritance and mixins, since traits are entirely divorced from the inheritance hierarchy."
      },
      "date": 1662262027126
    },
    {
      "type": "edit",
      "id": "07106d49f9c92641",
      "item": {
        "type": "markdown",
        "id": "07106d49f9c92641",
        "text": "**Traits make it possible for inheritance to be used to [[reflect]] conceptual hierarchy rather than for code reuse.** Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations. At the same time, traits largely avoid the fragility problems introduced by approaches based on multiple inheritance and mixins, since traits are entirely divorced from the inheritance hierarchy."
      },
      "date": 1662262101839
    },
    {
      "item": {
        "type": "factory",
        "id": "89a46201060542fa"
      },
      "id": "89a46201060542fa",
      "type": "add",
      "after": "07106d49f9c92641",
      "date": 1662264000024
    },
    {
      "type": "edit",
      "id": "89a46201060542fa",
      "item": {
        "type": "paragraph",
        "id": "89a46201060542fa",
        "text": "[…]"
      },
      "date": 1662264003929
    },
    {
      "type": "add",
      "id": "d10b950be26e3564",
      "item": {
        "type": "paragraph",
        "id": "d10b950be26e3564",
        "text": "Conceptually, however, the lack of state means that virtually all traits are incomplete, since just about any useful trait will require some accessors. Furthermore, the mechanism of required methods is abused to cover for the lack of state. As a consequence, the required interface of a trait is cluttered with noise that impedes the understanding and consequently the reuse of a trait. Even if the missing state and accessors can be generated, many clients will consist of “shell classes” — classes that do nothing but compose traits with boilerplate glue code. Furthermore, if the required accessors are made public (as is the case in the Smalltalk implementation), encapsulation is unnecessarily violated in the client classes. Finally, if a trait is ever modified to include additional state, new required accessors will be propagated to all client traits and classes, thus introducing a form of fragility that traits were intended to avoid!"
      },
      "after": "89a46201060542fa",
      "date": 1662264004903
    },
    {
      "type": "add",
      "id": "8658d93fd19b05ec",
      "item": {
        "type": "paragraph",
        "id": "8658d93fd19b05ec",
        "text": "This paper describes stateful traits, an extension of stateless traits in which a single variable access operator is introduced to give clients of traits control over the visibility of instance variables. The approach is faithful to the guiding principle of stateless traits in which the client of a trait has full control over the composition. It is this principle that is the key to avoiding fragility in the face of change, since no implicit conflict resolution rules come into play when a trait is modified. In a nutshell, instance variables are private to a trait. The client can decide, however, at composition time to access instance variables offered by a used trait, or to merge variables offered by multiple traits. In this paper we present an analysis of the limitations of stateless traits and we present our approach to achieving stateful traits. We describe and compare two implementation strategies, and we briefly describe our experience with an illustrative case study. The structure of this paper is as follows: First we review stateless traits [SDNB03, DNS+06]. In Section 3 we discuss the limitations of stateless traits. In Section 4 we introduce stateful traits, which support the introduction of state in traits. Section 5 outlines some details of the implementation of stateful traits. In Section 6 we present a small case study in which we compare the results of refactoring the Smalltalk collections hierarchy with both stateless and stateful traits. In Section 7 we discuss some of the broader consequences of the design of stateful traits. Section 8 discusses related work. Section 9 concludes the paper."
      },
      "after": "d10b950be26e3564",
      "date": 1662264101115
    },
    {
      "type": "edit",
      "id": "8658d93fd19b05ec",
      "item": {
        "type": "paragraph",
        "id": "8658d93fd19b05ec",
        "text": "This paper describes stateful traits, an extension of stateless traits in which a single variable access operator is introduced to give clients of traits control over the visibility of instance variables. The approach is faithful to the guiding principle of stateless traits in which the client of a trait has full control over the composition. It is this principle that is the key to avoiding fragility in the face of change, since no implicit conflict resolution rules come into play when a trait is modified. "
      },
      "date": 1662264114517
    },
    {
      "type": "add",
      "id": "64b3682410f8c269",
      "item": {
        "type": "paragraph",
        "id": "64b3682410f8c269",
        "text": "In a nutshell, instance variables are private to a trait. The client can decide, however, at composition time to access instance variables offered by a used trait, or to merge variables offered by multiple traits. In this paper we present an analysis of the limitations of stateless traits and we present our approach to achieving stateful traits. We describe and compare two implementation strategies, and we briefly describe our experience with an illustrative case study. The structure of this paper is as follows: First we review stateless traits [SDNB03, DNS+06]. In Section 3 we discuss the limitations of stateless traits. In Section 4 we introduce stateful traits, which support the introduction of state in traits. Section 5 outlines some details of the implementation of stateful traits. In Section 6 we present a small case study in which we compare the results of refactoring the Smalltalk collections hierarchy with both stateless and stateful traits. In Section 7 we discuss some of the broader consequences of the design of stateful traits. Section 8 discusses related work. Section 9 concludes the paper."
      },
      "after": "8658d93fd19b05ec",
      "date": 1662264117087
    },
    {
      "type": "edit",
      "id": "64b3682410f8c269",
      "item": {
        "type": "paragraph",
        "id": "64b3682410f8c269",
        "text": "In a nutshell, instance variables are private to a trait. The client can decide, however, at composition time to access instance variables offered by a used trait, or to merge variables offered by multiple traits. In this paper we present an analysis of the limitations of stateless traits and we present our approach to achieving stateful traits. We describe and compare two implementation strategies, and we briefly describe our experience with an illustrative case study. "
      },
      "date": 1662264128758
    },
    {
      "type": "add",
      "id": "5dc6949bdeaa7fc0",
      "item": {
        "type": "paragraph",
        "id": "5dc6949bdeaa7fc0",
        "text": "The structure of this paper is as follows: First we review stateless traits [SDNB03, DNS+06]. In Section 3 we discuss the limitations of stateless traits. In Section 4 we introduce stateful traits, which support the introduction of state in traits. Section 5 outlines some details of the implementation of stateful traits. In Section 6 we present a small case study in which we compare the results of refactoring the Smalltalk collections hierarchy with both stateless and stateful traits. In Section 7 we discuss some of the broader consequences of the design of stateful traits. Section 8 discusses related work. Section 9 concludes the paper."
      },
      "after": "64b3682410f8c269",
      "date": 1662264129717
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. \n"
      },
      "date": 1662443411125
    },
    {
      "type": "add",
      "id": "70aba56e6a576481",
      "item": {
        "type": "markdown",
        "id": "70aba56e6a576481",
        "text": "Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports **stateful traits**. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: **the client retains control of the composition**. Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. **Naming conflicts are avoided**, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "after": "7acbaf3741791509",
      "date": 1662443413262
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and [[mixins]]. \n"
      },
      "date": 1662443419374
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and [[Mixins]]. \n"
      },
      "date": 1662443426413
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by [[multiple inheritance]] and [[Mixins]]. \n"
      },
      "date": 1662443441324
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by [[Multiple Inheritance]] and [[Mixins]]. \n"
      },
      "date": 1662443450050
    },
    {
      "type": "edit",
      "id": "70aba56e6a576481",
      "item": {
        "type": "markdown",
        "id": "70aba56e6a576481",
        "text": "Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code.\n\n"
      },
      "date": 1662443478931
    },
    {
      "type": "add",
      "id": "b8d2450159894137",
      "item": {
        "type": "markdown",
        "id": "b8d2450159894137",
        "text": "Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports **stateful traits**. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: **the client retains control of the composition**. Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. **Naming conflicts are avoided**, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "after": "70aba56e6a576481",
      "date": 1662443479609
    },
    {
      "type": "edit",
      "id": "b8d2450159894137",
      "item": {
        "type": "markdown",
        "id": "b8d2450159894137",
        "text": "Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports **stateful traits**. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: **the client retains control of the composition**. \n"
      },
      "date": 1662443506030
    },
    {
      "type": "add",
      "id": "cb0436bfd575113c",
      "item": {
        "type": "markdown",
        "id": "cb0436bfd575113c",
        "text": "Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. **Naming conflicts are avoided**, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "after": "b8d2450159894137",
      "date": 1662443506436
    },
    {
      "type": "edit",
      "id": "cb0436bfd575113c",
      "item": {
        "type": "markdown",
        "id": "cb0436bfd575113c",
        "text": "Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. \n"
      },
      "date": 1662443526345
    },
    {
      "type": "add",
      "id": "eca71925f55ad48a",
      "item": {
        "type": "markdown",
        "id": "eca71925f55ad48a",
        "text": "**Naming conflicts are avoided**, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "after": "cb0436bfd575113c",
      "date": 1662443526760
    },
    {
      "type": "edit",
      "id": "eca71925f55ad48a",
      "item": {
        "type": "markdown",
        "id": "eca71925f55ad48a",
        "text": "**Naming conflicts are avoided**, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy. [https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4 doi]"
      },
      "date": 1662443553115
    }
  ]
}