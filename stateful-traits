{
  "title": "Stateful Traits",
  "story": [
    {
      "type": "markdown",
      "id": "7acbaf3741791509",
      "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports **stateful traits**. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: **the client retains control of the composition**. Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. **Naming conflicts are avoided**, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
    },
    {
      "type": "paragraph",
      "id": "d8ffea1571861f7d",
      "text": "Traits are pure units of reuse consisting only of methods [SDNB03,DNS+06]. Traits can be composed to either form other traits or classes. They are recognized for their potential in supporting better composition and reuse, hence their integration in newer versions of languages such as Perl 6, Squeak [IKM+97], Scala [sca], Slate [Sla] and Fortress [for]. Although traits were originally designed for dynamically-typed languages, there has been considerable interest in applying traits to statically-typed languages as well [FR03, SD05, NDS06]."
    },
    {
      "type": "markdown",
      "id": "07106d49f9c92641",
      "text": "**Traits make it possible for inheritance to be used to [[reflect]] conceptual hierarchy rather than for code reuse.** Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations. At the same time, traits largely avoid the fragility problems introduced by approaches based on multiple inheritance and mixins, since traits are entirely divorced from the inheritance hierarchy."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Stateful Traits",
        "story": []
      },
      "date": 1662261515683
    },
    {
      "item": {
        "type": "factory",
        "id": "7acbaf3741791509"
      },
      "id": "7acbaf3741791509",
      "type": "add",
      "date": 1662261523421
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "paragraph",
        "id": "7acbaf3741791509",
        "text": "– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261528054
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261529350
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "Traits offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports stateful traits. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. Naming conflicts are avoided, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261674483
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports stateful traits. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. Naming conflicts are avoided, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261684852
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports **stateful traits**. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. Naming conflicts are avoided, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261743417
    },
    {
      "type": "edit",
      "id": "7acbaf3741791509",
      "item": {
        "type": "markdown",
        "id": "7acbaf3741791509",
        "text": "[[Traits]] offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. Although these limitations are largely mitigated by proper tool support, we seek a cleaner solution that supports **stateful traits**. The key difficulty is how to handle conflicts that arise when composed traits contribute instance variables whose names clash. We present a solution that is faithful to the guiding principle of stateless traits: **the client retains control of the composition**. Stateful traits consist of a minimal  extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. **Naming conflicts are avoided**, and variables of disjoint traits can be explicitly merged by clients. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.– https://link.springer.com/chapter/10.1007/978-3-540-71836-9_4"
      },
      "date": 1662261812815
    },
    {
      "item": {
        "type": "factory",
        "id": "d8ffea1571861f7d"
      },
      "id": "d8ffea1571861f7d",
      "type": "add",
      "after": "7acbaf3741791509",
      "date": 1662261877179
    },
    {
      "type": "edit",
      "id": "d8ffea1571861f7d",
      "item": {
        "type": "paragraph",
        "id": "d8ffea1571861f7d",
        "text": "Traits are pure units of reuse consisting only of methods [SDNB03,DNS+06]. Traits can be composed to either form other traits or classes. They are recognized for their potential in supporting better composition and reuse, hence their integration in newer versions of languages such as Perl 6, Squeak [IKM+97], Scala [sca], Slate [Sla] and Fortress [for]. Although traits were originally designed for dynamically-typed languages, there has been considerable interest in applying traits to statically-typed languages as well [FR03, SD05, NDS06]."
      },
      "date": 1662261879266
    },
    {
      "item": {
        "type": "factory",
        "id": "07106d49f9c92641"
      },
      "id": "07106d49f9c92641",
      "type": "add",
      "after": "d8ffea1571861f7d",
      "date": 1662261909813
    },
    {
      "type": "edit",
      "id": "07106d49f9c92641",
      "item": {
        "type": "paragraph",
        "id": "07106d49f9c92641",
        "text": "Traits make it possible for inheritance to be used to reflect conceptual hierarchy rather than for code reuse. Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations."
      },
      "date": 1662261912601
    },
    {
      "type": "edit",
      "id": "07106d49f9c92641",
      "item": {
        "type": "paragraph",
        "id": "07106d49f9c92641",
        "text": "**Traits make it possible for inheritance to be used to reflect conceptual hierarchy rather than for code reuse.** Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations."
      },
      "date": 1662261935877
    },
    {
      "type": "edit",
      "id": "07106d49f9c92641",
      "item": {
        "type": "markdown",
        "id": "07106d49f9c92641",
        "text": "**Traits make it possible for inheritance to be used to reflect conceptual hierarchy rather than for code reuse.** Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations."
      },
      "date": 1662261937202
    },
    {
      "type": "edit",
      "id": "07106d49f9c92641",
      "item": {
        "type": "markdown",
        "id": "07106d49f9c92641",
        "text": "**Traits make it possible for inheritance to be used to reflect conceptual hierarchy rather than for code reuse.** Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations. At the same time, traits largely avoid the fragility problems introduced by approaches based on multiple inheritance and mixins, since traits are entirely divorced from the inheritance hierarchy."
      },
      "date": 1662262027126
    },
    {
      "type": "edit",
      "id": "07106d49f9c92641",
      "item": {
        "type": "markdown",
        "id": "07106d49f9c92641",
        "text": "**Traits make it possible for inheritance to be used to [[reflect]] conceptual hierarchy rather than for code reuse.** Duplicated code can be factored out as traits, rather than being jimmied into a class hierarchy in awkward locations. At the same time, traits largely avoid the fragility problems introduced by approaches based on multiple inheritance and mixins, since traits are entirely divorced from the inheritance hierarchy."
      },
      "date": 1662262101839
    }
  ]
}