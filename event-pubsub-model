{
  "title": "Event Pub/Sub Model",
  "story": [
    {
      "type": "markdown",
      "id": "318c33493af1ca8b",
      "text": "[[Croquet]] switched from message proxies (FarRefs in old Croquet) to an [[Event Pub/Sub Model]] in JS Croquet:\n> Re Smalltalk: the \"island\" in the old Croquet is equivalent to the \"VM\" in new Croquet. And as before, you cannot interact with that shared state directly but only via messages, which are routed via a reflector server. Also, that shared state is transmitted to a each new participant as they join. And to make time-dependent processes you use future messages.\nThe actual programming experience is quite different however, in particular since we switched from message proxies (FarRefs in o-- ld Croquet) to an event pub/sub model in JS Croquet. [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] \n\nThe Croquet VM sits on top of JS â€“ it's a very lightweight isolation layer so your code inside of it actually executes at full speed. Croquet controls the inputs and execution inside of that VM and thereby keeps the state in sync across all clients in the same session. It's not fully isolated though, for efficiency your model code in the VM is executed in the same JS context as your view code (that's how you can have a direct reference from a view outside the VM to a model inside the VM). It relies on cooperation from you as a developer â€“ you must ensure that your views only read from models, and that your models do not access anything outside of the VM, because that would cause divergence of the state between clients.\n\nWe have a node.js build internally but frankly it doesn't make much sense to run Croquet on a server, its whole raison d'Ãªtre is to allow purely client-side multiplayer. Right now we are busy with other stuff. If there is a business need for the node client ping us. â€”  codefrau ðŸ¦© via [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (2022-05-19)\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Event Pub/Sub Model",
        "story": []
      },
      "date": 1661395124293
    },
    {
      "id": "e2eb6d8e2e2a03bf",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "e2eb6d8e2e2a03bf",
        "text": "* same proxy model to work with the remote Smalltalk image\n* **Note**: [[Croquet]] switched from message proxies (FarRefs in old Croquet) to an [[Event Pub/Sub Model]] in JS Croquet:\n> Re Smalltalk: the \"island\" in the old Croquet is equivalent to the \"VM\" in new Croquet. And as before, you cannot interact with that shared state directly but only via messages, which are routed via a reflector server. Also, that shared state is transmitted to a each new participant as they join. And to make time-dependent processes you use future messages.\nThe actual programming experience is quite different however, in particular since we switched from message proxies (FarRefs in old Croquet) to an event pub/sub model in JS Croquet. [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (search for \"proxy\")\n>\n> The Croquet VM sits on top of JS â€“ it's a very lightweight isolation layer so your code inside of it actually executes at full speed. Croquet controls the inputs and execution inside of that VM and thereby keeps the state in sync across all clients in the same session. It's not fully isolated though, for efficiency your model code in the VM is executed in the same JS context as your view code (that's how you can have a direct reference from a view outside the VM to a model inside the VM). It relies on cooperation from you as a developer â€“ you must ensure that your views only read from models, and that your models do not access anything outside of the VM, because that would cause divergence of the state between clients.\nWe have a node.js build internally but frankly it doesn't make much sense to run Croquet on a server, its whole raison d'Ãªtre is to allow purely client-side multiplayer. Right now we are busy with other stuff. If there is a business need for the node client ping us.\n"
      },
      "date": 1661395209043
    },
    {
      "type": "edit",
      "id": "e2eb6d8e2e2a03bf",
      "item": {
        "type": "markdown",
        "id": "e2eb6d8e2e2a03bf",
        "text": "* same proxy model to work with the remote Smalltalk image\n"
      },
      "date": 1661395229035
    },
    {
      "id": "e2eb6d8e2e2a03bf",
      "type": "remove",
      "date": 1661395233019
    },
    {
      "type": "add",
      "id": "318c33493af1ca8b",
      "item": {
        "type": "markdown",
        "id": "318c33493af1ca8b",
        "text": "* **Note**: [[Croquet]] switched from message proxies (FarRefs in old Croquet) to an [[Event Pub/Sub Model]] in JS Croquet:\n> Re Smalltalk: the \"island\" in the old Croquet is equivalent to the \"VM\" in new Croquet. And as before, you cannot interact with that shared state directly but only via messages, which are routed via a reflector server. Also, that shared state is transmitted to a each new participant as they join. And to make time-dependent processes you use future messages.\nThe actual programming experience is quite different however, in particular since we switched from message proxies (FarRefs in old Croquet) to an event pub/sub model in JS Croquet. [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (search for \"proxy\")\n>\n> The Croquet VM sits on top of JS â€“ it's a very lightweight isolation layer so your code inside of it actually executes at full speed. Croquet controls the inputs and execution inside of that VM and thereby keeps the state in sync across all clients in the same session. It's not fully isolated though, for efficiency your model code in the VM is executed in the same JS context as your view code (that's how you can have a direct reference from a view outside the VM to a model inside the VM). It relies on cooperation from you as a developer â€“ you must ensure that your views only read from models, and that your models do not access anything outside of the VM, because that would cause divergence of the state between clients.\nWe have a node.js build internally but frankly it doesn't make much sense to run Croquet on a server, its whole raison d'Ãªtre is to allow purely client-side multiplayer. Right now we are busy with other stuff. If there is a business need for the node client ping us.\n"
      },
      "after": "e2eb6d8e2e2a03bf",
      "date": 1661395233488
    },
    {
      "type": "edit",
      "id": "318c33493af1ca8b",
      "item": {
        "type": "markdown",
        "id": "318c33493af1ca8b",
        "text": "[[Croquet]] switched from message proxies (FarRefs in old Croquet) to an [[Event Pub/Sub Model]] in JS Croquet:\n> Re Smalltalk: the \"island\" in the old Croquet is equivalent to the \"VM\" in new Croquet. And as before, you cannot interact with that shared state directly but only via messages, which are routed via a reflector server. Also, that shared state is transmitted to a each new participant as they join. And to make time-dependent processes you use future messages.\nThe actual programming experience is quite different however, in particular since we switched from message proxies (FarRefs in old Croquet) to an event pub/sub model in JS Croquet. [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (search for \"proxy\")\n>\n> The Croquet VM sits on top of JS â€“ it's a very lightweight isolation layer so your code inside of it actually executes at full speed. Croquet controls the inputs and execution inside of that VM and thereby keeps the state in sync across all clients in the same session. It's not fully isolated though, for efficiency your model code in the VM is executed in the same JS context as your view code (that's how you can have a direct reference from a view outside the VM to a model inside the VM). It relies on cooperation from you as a developer â€“ you must ensure that your views only read from models, and that your models do not access anything outside of the VM, because that would cause divergence of the state between clients.\nWe have a node.js build internally but frankly it doesn't make much sense to run Croquet on a server, its whole raison d'Ãªtre is to allow purely client-side multiplayer. Right now we are busy with other stuff. If there is a business need for the node client ping us.\n"
      },
      "date": 1661395246343
    },
    {
      "type": "edit",
      "id": "318c33493af1ca8b",
      "item": {
        "type": "markdown",
        "id": "318c33493af1ca8b",
        "text": "[[Croquet]] switched from message proxies (FarRefs in old Croquet) to an [[Event Pub/Sub Model]] in JS Croquet:\n> Re Smalltalk: the \"island\" in the old Croquet is equivalent to the \"VM\" in new Croquet. And as before, you cannot interact with that shared state directly but only via messages, which are routed via a reflector server. Also, that shared state is transmitted to a each new participant as they join. And to make time-dependent processes you use future messages.\nThe actual programming experience is quite different however, in particular since we switched from message proxies (FarRefs in old Croquet) to an event pub/sub model in JS Croquet. [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (search for \"proxy\")\n>\n> The Croquet VM sits on top of JS â€“ it's a very lightweight isolation layer so your code inside of it actually executes at full speed. Croquet controls the inputs and execution inside of that VM and thereby keeps the state in sync across all clients in the same session. It's not fully isolated though, for efficiency your model code in the VM is executed in the same JS context as your view code (that's how you can have a direct reference from a view outside the VM to a model inside the VM). It relies on cooperation from you as a developer â€“ you must ensure that your views only read from models, and that your models do not access anything outside of the VM, because that would cause divergence of the state between clients.\nWe have a node.js build internally but frankly it doesn't make much sense to run Croquet on a server, its whole raison d'Ãªtre is to allow purely client-side multiplayer. Right now we are busy with other stuff. If there is a business need for the node client ping us.\n-- codefrau ðŸ¦© â€” 2022-05-19\n"
      },
      "date": 1661395328634
    },
    {
      "type": "edit",
      "id": "318c33493af1ca8b",
      "item": {
        "type": "markdown",
        "id": "318c33493af1ca8b",
        "text": "[[Croquet]] switched from message proxies (FarRefs in old Croquet) to an [[Event Pub/Sub Model]] in JS Croquet:\n> Re Smalltalk: the \"island\" in the old Croquet is equivalent to the \"VM\" in new Croquet. And as before, you cannot interact with that shared state directly but only via messages, which are routed via a reflector server. Also, that shared state is transmitted to a each new participant as they join. And to make time-dependent processes you use future messages.\nThe actual programming experience is quite different however, in particular since we switched from message proxies (FarRefs in old Croquet) to an event pub/sub model in JS Croquet. [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (search for \"proxy\")\n>\n> The Croquet VM sits on top of JS â€“ it's a very lightweight isolation layer so your code inside of it actually executes at full speed. Croquet controls the inputs and execution inside of that VM and thereby keeps the state in sync across all clients in the same session. It's not fully isolated though, for efficiency your model code in the VM is executed in the same JS context as your view code (that's how you can have a direct reference from a view outside the VM to a model inside the VM). It relies on cooperation from you as a developer â€“ you must ensure that your views only read from models, and that your models do not access anything outside of the VM, because that would cause divergence of the state between clients.\nWe have a node.js build internally but frankly it doesn't make much sense to run Croquet on a server, its whole raison d'Ãªtre is to allow purely client-side multiplayer. Right now we are busy with other stuff. If there is a business need for the node client ping us.\nâ€”  codefrau ðŸ¦© via [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (2022-05-19)\n"
      },
      "date": 1661395387483
    },
    {
      "type": "edit",
      "id": "318c33493af1ca8b",
      "item": {
        "type": "markdown",
        "id": "318c33493af1ca8b",
        "text": "[[Croquet]] switched from message proxies (FarRefs in old Croquet) to an [[Event Pub/Sub Model]] in JS Croquet:\n> Re Smalltalk: the \"island\" in the old Croquet is equivalent to the \"VM\" in new Croquet. And as before, you cannot interact with that shared state directly but only via messages, which are routed via a reflector server. Also, that shared state is transmitted to a each new participant as they join. And to make time-dependent processes you use future messages.\nThe actual programming experience is quite different however, in particular since we switched from message proxies (FarRefs in old Croquet) to an event pub/sub model in JS Croquet. [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (search for \"proxy\")\n>\n> The Croquet VM sits on top of JS â€“ it's a very lightweight isolation layer so your code inside of it actually executes at full speed. Croquet controls the inputs and execution inside of that VM and thereby keeps the state in sync across all clients in the same session. It's not fully isolated though, for efficiency your model code in the VM is executed in the same JS context as your view code (that's how you can have a direct reference from a view outside the VM to a model inside the VM). It relies on cooperation from you as a developer â€“ you must ensure that your views only read from models, and that your models do not access anything outside of the VM, because that would cause divergence of the state between clients.\nWe have a node.js build internally but frankly it doesn't make much sense to run Croquet on a server, its whole raison d'Ãªtre is to allow purely client-side multiplayer. Right now we are busy with other stuff. If there is a business need for the node client ping us.\n\nâ€”  codefrau ðŸ¦© via [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (2022-05-19)\n"
      },
      "date": 1661395401633
    },
    {
      "type": "edit",
      "id": "318c33493af1ca8b",
      "item": {
        "type": "markdown",
        "id": "318c33493af1ca8b",
        "text": "[[Croquet]] switched from message proxies (FarRefs in old Croquet) to an [[Event Pub/Sub Model]] in JS Croquet:\n> Re Smalltalk: the \"island\" in the old Croquet is equivalent to the \"VM\" in new Croquet. And as before, you cannot interact with that shared state directly but only via messages, which are routed via a reflector server. Also, that shared state is transmitted to a each new participant as they join. And to make time-dependent processes you use future messages.\nThe actual programming experience is quite different however, in particular since we switched from message proxies (FarRefs in old Croquet) to an event pub/sub model in JS Croquet. [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (search for \"proxy\")\n>\n> The Croquet VM sits on top of JS â€“ it's a very lightweight isolation layer so your code inside of it actually executes at full speed. Croquet controls the inputs and execution inside of that VM and thereby keeps the state in sync across all clients in the same session. It's not fully isolated though, for efficiency your model code in the VM is executed in the same JS context as your view code (that's how you can have a direct reference from a view outside the VM to a model inside the VM). It relies on cooperation from you as a developer â€“ you must ensure that your views only read from models, and that your models do not access anything outside of the VM, because that would cause divergence of the state between clients.\nWe have a node.js build internally but frankly it doesn't make much sense to run Croquet on a server, its whole raison d'Ãªtre is to allow purely client-side multiplayer. Right now we are busy with other stuff. If there is a business need for the node client ping us. â€”  codefrau ðŸ¦© via [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (2022-05-19)\n"
      },
      "date": 1661395421940
    },
    {
      "type": "edit",
      "id": "318c33493af1ca8b",
      "item": {
        "type": "markdown",
        "id": "318c33493af1ca8b",
        "text": "[[Croquet]] switched from message proxies (FarRefs in old Croquet) to an [[Event Pub/Sub Model]] in JS Croquet:\n> Re Smalltalk: the \"island\" in the old Croquet is equivalent to the \"VM\" in new Croquet. And as before, you cannot interact with that shared state directly but only via messages, which are routed via a reflector server. Also, that shared state is transmitted to a each new participant as they join. And to make time-dependent processes you use future messages.\nThe actual programming experience is quite different however, in particular since we switched from message proxies (FarRefs in old Croquet) to an event pub/sub model in JS Croquet. [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] \n>\n> The Croquet VM sits on top of JS â€“ it's a very lightweight isolation layer so your code inside of it actually executes at full speed. Croquet controls the inputs and execution inside of that VM and thereby keeps the state in sync across all clients in the same session. It's not fully isolated though, for efficiency your model code in the VM is executed in the same JS context as your view code (that's how you can have a direct reference from a view outside the VM to a model inside the VM). It relies on cooperation from you as a developer â€“ you must ensure that your views only read from models, and that your models do not access anything outside of the VM, because that would cause divergence of the state between clients.\nWe have a node.js build internally but frankly it doesn't make much sense to run Croquet on a server, its whole raison d'Ãªtre is to allow purely client-side multiplayer. Right now we are busy with other stuff. If there is a business need for the node client ping us. â€”  codefrau ðŸ¦© via [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (2022-05-19)\n"
      },
      "date": 1661434900315
    },
    {
      "type": "edit",
      "id": "318c33493af1ca8b",
      "item": {
        "type": "markdown",
        "id": "318c33493af1ca8b",
        "text": "[[Croquet]] switched from message proxies (FarRefs in old Croquet) to an [[Event Pub/Sub Model]] in JS Croquet:\n> Re Smalltalk: the \"island\" in the old Croquet is equivalent to the \"VM\" in new Croquet. And as before, you cannot interact with that shared state directly but only via messages, which are routed via a reflector server. Also, that shared state is transmitted to a each new participant as they join. And to make time-dependent processes you use future messages.\nThe actual programming experience is quite different however, in particular since we switched from message proxies (FarRefs in o-- ld Croquet) to an event pub/sub model in JS Croquet. [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] \n\nThe Croquet VM sits on top of JS â€“ it's a very lightweight isolation layer so your code inside of it actually executes at full speed. Croquet controls the inputs and execution inside of that VM and thereby keeps the state in sync across all clients in the same session. It's not fully isolated though, for efficiency your model code in the VM is executed in the same JS context as your view code (that's how you can have a direct reference from a view outside the VM to a model inside the VM). It relies on cooperation from you as a developer â€“ you must ensure that your views only read from models, and that your models do not access anything outside of the VM, because that would cause divergence of the state between clients.\nWe have a node.js build internally but frankly it doesn't make much sense to run Croquet on a server, its whole raison d'Ãªtre is to allow purely client-side multiplayer. Right now we are busy with other stuff. If there is a business need for the node client ping us. â€”  codefrau ðŸ¦© via [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (2022-05-19)\n"
      },
      "date": 1661434916496
    },
    {
      "type": "edit",
      "id": "318c33493af1ca8b",
      "item": {
        "type": "markdown",
        "id": "318c33493af1ca8b",
        "text": "[[Croquet]] switched from message proxies (FarRefs in old Croquet) to an [[Event Pub/Sub Model]] in JS Croquet:\n> Re Smalltalk: the \"island\" in the old Croquet is equivalent to the \"VM\" in new Croquet. And as before, you cannot interact with that shared state directly but only via messages, which are routed via a reflector server. Also, that shared state is transmitted to a each new participant as they join. And to make time-dependent processes you use future messages.\nThe actual programming experience is quite different however, in particular since we switched from message proxies (FarRefs in o-- ld Croquet) to an event pub/sub model in JS Croquet. [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] \n\nThe Croquet VM sits on top of JS â€“ it's a very lightweight isolation layer so your code inside of it actually executes at full speed. Croquet controls the inputs and execution inside of that VM and thereby keeps the state in sync across all clients in the same session. It's not fully isolated though, for efficiency your model code in the VM is executed in the same JS context as your view code (that's how you can have a direct reference from a view outside the VM to a model inside the VM). It relies on cooperation from you as a developer â€“ you must ensure that your views only read from models, and that your models do not access anything outside of the VM, because that would cause divergence of the state between clients.\n\nWe have a node.js build internally but frankly it doesn't make much sense to run Croquet on a server, its whole raison d'Ãªtre is to allow purely client-side multiplayer. Right now we are busy with other stuff. If there is a business need for the node client ping us. â€”  codefrau ðŸ¦© via [https://discord.com/channels/694586717247635488/966071402526543924/976952399556132885 discord] (2022-05-19)\n"
      },
      "date": 1661434961045
    }
  ]
}