{
  "title": "Meta Object Protocol",
  "story": [
    {
      "type": "html",
      "text": "<i>The essence of a Metaobject Protocol is simple: every aspect of a program's mapping down onto the lower level substrate (i.e. its compilation and runtime support) is controlled by some object or set of objects following a well-defined protocol. These objects are called <b>metaobjects</b>, because they are about the mapping of the program, rather than objects in the program's primary subject domain. Client programmers can replace one or more of these objects with specialized ones to affect specific aspects of the implementation of specific parts of their program. </i>",
      "id": "1a2e0561d60eefe353ae60ea5939037b"
    },
    {
      "type": "html",
      "text": " [http://www.parc.xerox.com/spl/projects/oi/workshop-94/foil/main.html#plpll:mops www.parc.xerox.com]",
      "id": "a0df12021d6459487817183f67e96535"
    },
    {
      "type": "html",
      "text": "\nAlso see Andreas Paepcke, \"User-Level Language Crafting\": [http://citeseer.ist.psu.edu/paepcke93userlevel.html citeseer.ist.psu.edu]",
      "id": "c811e18d074662be074039fddce4e6f8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "65d2d673f89bcaa1eba82b3335e23d9e"
    },
    {
      "type": "html",
      "text": "How about: make your interpreter (or compiler) available in your program,\nso that you can change rules for method lookup, variable scoping or whatever\nelse you want in your program. This makes sense, sometimes -- for instance,\na better stack tracer that elides calls to the standard library.",
      "id": "2401a1b9710b4a1fc1f9054629832cbe"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "65d2d673f89bcaa1eba82b3335e23d9e"
    },
    {
      "type": "html",
      "text": "Let me take my stab, having (tried to) read the book:",
      "id": "46b36b4d2a6fd08622ccb84f09e8b7fd"
    },
    {
      "type": "html",
      "text": "The core of the Metaobject Protocol is to replace the most basic constructs of a language (in the case of OO languages, this would consist of things like how polymorphism is defined, how to treat inheritance (multiple and single), etc.) and make them so they can be configured and changed.",
      "id": "298bbc1594cf3d3e4508acd59b089460"
    },
    {
      "type": "html",
      "text": "\nFrom what I recall, this was important to the implementers of the [[Common Lisp Object System]] because they wanted to maintain backwards compatibility with many Lisp implementations, each of which had its own rules regarding inheritance, etc.",
      "id": "f553b947cc1eb7cd94addc0400c118f0"
    },
    {
      "type": "html",
      "text": "-- [[Hank Roark]]",
      "id": "db923bf0eb580c9f97c46dac736e3a4c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "65d2d673f89bcaa1eba82b3335e23d9e"
    },
    {
      "type": "html",
      "text": "Perhaps you can get more from an example. This link gives an implementation of an Eiffel inspired [[Design By Contract]] extension to the [[Common Lisp Object System]]. A number of the basic mechanism of the OO language are overridden and augmented to do class invariant checking, pre- and post-conditions etc.",
      "id": "d10c13d833143fb34b9dc4d8f78239ce"
    },
    {
      "type": "html",
      "text": "\n[http://www.muc.de/~hoelzl/tools/dbc/dbc.lisp www.muc.de]  ",
      "id": "00f9d15710af56e3a562c4d5b8943391"
    },
    {
      "type": "html",
      "text": "-- Lieven Marchand <mal@bewoner.dma.be>",
      "id": "d436e27d8d31084c4b74dce50eded42f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "65d2d673f89bcaa1eba82b3335e23d9e"
    },
    {
      "type": "html",
      "text": "At first glance, it might seem weird to change how something like method \nlookup works.  But consider an analogy with something more pedestrian: overriding inherited\nmethods.  Sometimes you completely replace the superclass' implementation,\nbut just as often you <i>augment</i> it.  ",
      "id": "5ba403e5b693c7e9122ec60c40eeb1ec"
    },
    {
      "type": "html",
      "text": "\nThis is why a metaobject protocol is of interest to people working on \n[[Aspect Oriented Programming]].  Without a MOP, aspects have to be implemented\nby <i>weaving</i>, which involves modifying the application source code.  A\nMOP permits another strategy: extending the runtime object system to \ndetect those situations when an aspect is applicable, and interpose the\naspect's functionality.  You still need a tool to interpret the aspects,\nbut the tool is much simpler with a MOP.  --[[Glenn Vanderburg]]",
      "id": "521bdb92e7d50ced4e9307a579a332d9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "65d2d673f89bcaa1eba82b3335e23d9e"
    },
    {
      "type": "html",
      "text": "I would include not just \"every aspect\" nor even \"most basic constructs\" but anything at the virtual machine level. For example, if you can control your memory manager by switching garbage collection on and off, requesting a collection, explicitly freeing objects etc, I'd call that a MOP. -- [[Dave Harris]]",
      "id": "252888c0445767e4b8aeb80bca5f2826"
    },
    {
      "type": "html",
      "text": "\nI'm not sure I would. It's a Meta <i>Object</i> Protocol, and garbage collection\nseems more low level and wider in scope than that (in other words those effects\nare system wide, not really <i>[replacing] one or more of these objects with specialized ones to affect specific aspects of the implementation of specific parts of their program. </i>)",
      "id": "ce5e992f66448525a0bdae5918720d37"
    },
    {
      "type": "code",
      "text": " -- PaulHudson",
      "id": "2d2bcffd10e57cbd2bbad7d92df95130"
    },
    {
      "type": "html",
      "text": "\nDave, the people at Xerox who like to talk about this stuff a lot (I don't \nknow whether they're responsible for it or not, but they sure do like to \ntalk about it :-) treat a MOP as a special case of a more general concept:\n[[Open Implementation]].  I think what you're talking about fits in the more \ngeneral space.  --[[Glenn Vanderburg]]",
      "id": "8832ebf6f396f53ff613aa897936066f"
    },
    {
      "type": "html",
      "text": "\nMaybe. I was thinking the garbage collector was an object in its own right, belonging to the meta level, and accessed through a protocol, so meta object protocol seemed to fit. Consider allocators in C++. Probably I'm wrong, but I'll leave the discussion in case it helps someone else. -- [[Dave Harris]]",
      "id": "6683b5c1e1ddfdd44a60fef1857bcc91"
    },
    {
      "type": "html",
      "text": "<i>No, you were thinking that \"anything at the virtual machine level\" is MOP; GC was just an \"example\".  Even if you're right about GC, Glenn's comment about \"a more general concept\" fits the bill.</i>",
      "id": "e4512ca9b042ab4e807b67391f86efc7"
    },
    {
      "type": "html",
      "text": "\nExcerpt from [[The Art Of The Meta Object Protocol]]",
      "id": "adac9cf701e5f6d327449636b465ae65"
    },
    {
      "type": "html",
      "text": "In a language based upon [our] metaobject protocols, the language implementation itself is structured as an object-oriented program. This allows us to exploit the power of object-oriented programming techniques to to make the language implementation adjustable and flexible. In effect, the resulting implementation does not represent a single point in the overall space of language designs, but an entire region within that space.",
      "id": "76fe399911b5c16196acc6300070c869"
    },
    {
      "type": "html",
      "text": "\nSee Also:",
      "id": "f4799f583a6aec04dd55014e7b50e1ec"
    },
    {
      "type": "html",
      "text": "\n[http://www.parc.xerox.com/spl/projects/mops/default.html www.parc.xerox.com] [[[Broken Link]] -- 2006-08-16]",
      "id": "6d32beda9f06db4f380eb5d5825c247c"
    },
    {
      "type": "html",
      "text": "\n[http://www.elwood.com/alu/mop/index.html www.elwood.com] [[[Broken Link]] -- 2006-08-16]",
      "id": "da58a21fbec94767bfb62c125f169d4e"
    },
    {
      "type": "html",
      "text": "\n[[Dildar Marhas]]",
      "id": "8d5265099d9b7b5d51f22cafaab8c26b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "65d2d673f89bcaa1eba82b3335e23d9e"
    },
    {
      "type": "html",
      "text": "[[Pattie Maes]] has written some wonderful papers about this topic.",
      "id": "0183ce8df4ec2a37d62e228cef8d4258"
    },
    {
      "type": "html",
      "text": "\nMy view is that a Metaobject Protocol is a fundamentally important attribute of a [[Causally Reflective System]]. These systems virtually always have the ability to treat at least some memory as both code and data. In a Unix environment, this amounts to being able to execute from the data segment or write to the code segment, or both.",
      "id": "e688805a302e8a7f3a1982b7250f0a6d"
    },
    {
      "type": "html",
      "text": "\nAn application written, naively, in C or C++ and running on Unix is typically [[Not Reflective]]. The application has very limited or no ability to perform computations on itself. For example, its current process state or variable bindings are not accessible to it.",
      "id": "3f96407e92f87467365b47034bb12a24"
    },
    {
      "type": "html",
      "text": "\nSome systems are [[Descriptively Reflective]]. Early examples of this were the C++-based object databases, such as [[Object Store]] and Ontos. A [[Descriptively Reflective]] system contains a description of itself, and may even use that description, but changing that description merely breaks the system.",
      "id": "86e43024fb476d9b0fe4d265550fabc4"
    },
    {
      "type": "html",
      "text": "\nThe category of systems that I find interesting are [[Causally Reflective]] systems, such as [[Common Lisp]] and Smalltalk. A [[Causally Reflective]] system is written in terms of itself. It contains a description of its own behavior, and uses that description to control its behavior, so that a change to that description changes its behavior.",
      "id": "3b90d9c0bd7b310073569d0c3198d3ab"
    },
    {
      "type": "html",
      "text": "\nI suspect that an enterprising PhD candidate could, if it has not already been done, write a thesis proving the hypothesis that a [[Causally Reflective]] system must have a metaobject protocol.",
      "id": "bf634a7cf7dcfe331aa347ffdf529049"
    },
    {
      "type": "html",
      "text": "-- [[Tom Stambaugh]]",
      "id": "0a660cc835f872a5d03d87fc110f9434"
    },
    {
      "type": "html",
      "text": "\nMOP and causal reflectivity are rather obviously orthogonal -- causally reflective systems need not expose their descriptions or allow them to be modified, and the descriptions of non-reflective systems can be exposed and modified. And if all you mean is that a causally reflective system necessarily has a description that can be formalized as a data object that the system can interpret -- well, that's how it was just defined, so it wouldn't take a PhD thesis to demonstrate it.",
      "id": "7eb5a5c2143e0b15bb22671d2e566d54"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "65d2d673f89bcaa1eba82b3335e23d9e"
    },
    {
      "type": "html",
      "text": "Another source of information on [[Meta Class]] programming and Meta Object Protocols\nis the book \"Putting Metaclasses to Work\".  They even have some simulation code",
      "id": "4fe7cd9a139428d1217c5b95a4da8ba3"
    },
    {
      "type": "html",
      "text": "(written in Java) showing their MOP at work (located at [http://www.amazon.com/exec/obidos/tg/detail/-/0201433052 www.amazon.com]).",
      "id": "0fae1309fddbeb77829344776c5cc740"
    },
    {
      "type": "html",
      "text": "--[[Thomas Enebo]]",
      "id": "4a2dde441c91a766ec13c605680565d4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "65d2d673f89bcaa1eba82b3335e23d9e"
    },
    {
      "type": "html",
      "text": "A metaobject protocol certainly seems powerful.  An obvious example would be (I guess) C++ operator overloading, where you can define what otherwise ordinary language elements do to a particular class.  Or the java.lang.reflect package in Java, where you can do computation on the structure of your program.  (For example, some cool self-configuring systems like [[Java Beans]] work by scanning the names of your class's methods for particular naming conventions.)",
      "id": "33e2cde75b751dccf6b0adcca85d9b68"
    },
    {
      "type": "html",
      "text": "<i>Operator overloading is no different from overloading any other method name -- it has nothing to do with MOP.  Nor does introspection.</i>",
      "id": "bcdc6f6862172b002d040fbd8b1283a8"
    },
    {
      "type": "html",
      "text": "\nBut these sorts of features and capabilities are the enemy of learnable, [[Readable Code]], and I find that they are rarely used judiciously.",
      "id": "a6b4eb5a49451191b2f8003a9f496c1c"
    },
    {
      "type": "html",
      "text": "-- [[Rus Heywood]]",
      "id": "a693a9c8626898486f528cf123052759"
    },
    {
      "type": "html",
      "text": "\nWell, one example where MOP is often used is to provide persistency.  See for example PLOB! (persistent\nlisp objects) or the DEF-VIEW-CLASS macro provided with Xanaly's lisp.  Both these systems let you\ncreate CLOS objects whose metaclass is not STANDARD-CLASS, but rather a new, persistent class.\nThe degree of integration into \"normal lisp\" provided by these tools is simply astounding.  I would call\nthat a judicious use indeed.  All extremely powerful tools, (and is MOP ever one!) require extreme care\nand competence by the craftsman.",
      "id": "318c341aa4cf33ca35a8917dc4defc63"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "65d2d673f89bcaa1eba82b3335e23d9e"
    },
    {
      "type": "html",
      "text": "See also:\n[[Accessor Events]], [[Advantages Of Exposing Run Time Engine]], [[One More Level Of Indirection]]",
      "id": "a550c721c2ac3be5ee522912263cea78"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "65d2d673f89bcaa1eba82b3335e23d9e"
    },
    {
      "type": "html",
      "text": "[[Category Aspect Orientation]]",
      "id": "ce84b07b17ea83b91a0d39c0d956ced0"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?MetaObjectProtocol c2.com]",
      "id": "3ad63f9f06b097dcb31bb036850f38dd"
    }
  ],
  "journal": [
    {
      "date": 1416499739000,
      "id": "b912ecc6f745641a7e1e48f519926bfe",
      "type": "create",
      "item": {
        "title": "Meta Object Protocol",
        "story": [
          {
            "type": "html",
            "text": "<i>The essence of a Metaobject Protocol is simple: every aspect of a program's mapping down onto the lower level substrate (i.e. its compilation and runtime support) is controlled by some object or set of objects following a well-defined protocol. These objects are called <b>metaobjects</b>, because they are about the mapping of the program, rather than objects in the program's primary subject domain. Client programmers can replace one or more of these objects with specialized ones to affect specific aspects of the implementation of specific parts of their program. </i>",
            "id": "1a2e0561d60eefe353ae60ea5939037b"
          },
          {
            "type": "html",
            "text": " [http://www.parc.xerox.com/spl/projects/oi/workshop-94/foil/main.html#plpll:mops www.parc.xerox.com]",
            "id": "a0df12021d6459487817183f67e96535"
          },
          {
            "type": "html",
            "text": "\nAlso see Andreas Paepcke, \"User-Level Language Crafting\": [http://citeseer.ist.psu.edu/paepcke93userlevel.html citeseer.ist.psu.edu]",
            "id": "c811e18d074662be074039fddce4e6f8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "65d2d673f89bcaa1eba82b3335e23d9e"
          },
          {
            "type": "html",
            "text": "How about: make your interpreter (or compiler) available in your program,\nso that you can change rules for method lookup, variable scoping or whatever\nelse you want in your program. This makes sense, sometimes -- for instance,\na better stack tracer that elides calls to the standard library.",
            "id": "2401a1b9710b4a1fc1f9054629832cbe"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "65d2d673f89bcaa1eba82b3335e23d9e"
          },
          {
            "type": "html",
            "text": "Let me take my stab, having (tried to) read the book:",
            "id": "46b36b4d2a6fd08622ccb84f09e8b7fd"
          },
          {
            "type": "html",
            "text": "The core of the Metaobject Protocol is to replace the most basic constructs of a language (in the case of OO languages, this would consist of things like how polymorphism is defined, how to treat inheritance (multiple and single), etc.) and make them so they can be configured and changed.",
            "id": "298bbc1594cf3d3e4508acd59b089460"
          },
          {
            "type": "html",
            "text": "\nFrom what I recall, this was important to the implementers of the [[Common Lisp Object System]] because they wanted to maintain backwards compatibility with many Lisp implementations, each of which had its own rules regarding inheritance, etc.",
            "id": "f553b947cc1eb7cd94addc0400c118f0"
          },
          {
            "type": "html",
            "text": "-- [[Hank Roark]]",
            "id": "db923bf0eb580c9f97c46dac736e3a4c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "65d2d673f89bcaa1eba82b3335e23d9e"
          },
          {
            "type": "html",
            "text": "Perhaps you can get more from an example. This link gives an implementation of an Eiffel inspired [[Design By Contract]] extension to the [[Common Lisp Object System]]. A number of the basic mechanism of the OO language are overridden and augmented to do class invariant checking, pre- and post-conditions etc.",
            "id": "d10c13d833143fb34b9dc4d8f78239ce"
          },
          {
            "type": "html",
            "text": "\n[http://www.muc.de/~hoelzl/tools/dbc/dbc.lisp www.muc.de]  ",
            "id": "00f9d15710af56e3a562c4d5b8943391"
          },
          {
            "type": "html",
            "text": "-- Lieven Marchand <mal@bewoner.dma.be>",
            "id": "d436e27d8d31084c4b74dce50eded42f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "65d2d673f89bcaa1eba82b3335e23d9e"
          },
          {
            "type": "html",
            "text": "At first glance, it might seem weird to change how something like method \nlookup works.  But consider an analogy with something more pedestrian: overriding inherited\nmethods.  Sometimes you completely replace the superclass' implementation,\nbut just as often you <i>augment</i> it.  ",
            "id": "5ba403e5b693c7e9122ec60c40eeb1ec"
          },
          {
            "type": "html",
            "text": "\nThis is why a metaobject protocol is of interest to people working on \n[[Aspect Oriented Programming]].  Without a MOP, aspects have to be implemented\nby <i>weaving</i>, which involves modifying the application source code.  A\nMOP permits another strategy: extending the runtime object system to \ndetect those situations when an aspect is applicable, and interpose the\naspect's functionality.  You still need a tool to interpret the aspects,\nbut the tool is much simpler with a MOP.  --[[Glenn Vanderburg]]",
            "id": "521bdb92e7d50ced4e9307a579a332d9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "65d2d673f89bcaa1eba82b3335e23d9e"
          },
          {
            "type": "html",
            "text": "I would include not just \"every aspect\" nor even \"most basic constructs\" but anything at the virtual machine level. For example, if you can control your memory manager by switching garbage collection on and off, requesting a collection, explicitly freeing objects etc, I'd call that a MOP. -- [[Dave Harris]]",
            "id": "252888c0445767e4b8aeb80bca5f2826"
          },
          {
            "type": "html",
            "text": "\nI'm not sure I would. It's a Meta <i>Object</i> Protocol, and garbage collection\nseems more low level and wider in scope than that (in other words those effects\nare system wide, not really <i>[replacing] one or more of these objects with specialized ones to affect specific aspects of the implementation of specific parts of their program. </i>)",
            "id": "ce5e992f66448525a0bdae5918720d37"
          },
          {
            "type": "code",
            "text": " -- PaulHudson",
            "id": "2d2bcffd10e57cbd2bbad7d92df95130"
          },
          {
            "type": "html",
            "text": "\nDave, the people at Xerox who like to talk about this stuff a lot (I don't \nknow whether they're responsible for it or not, but they sure do like to \ntalk about it :-) treat a MOP as a special case of a more general concept:\n[[Open Implementation]].  I think what you're talking about fits in the more \ngeneral space.  --[[Glenn Vanderburg]]",
            "id": "8832ebf6f396f53ff613aa897936066f"
          },
          {
            "type": "html",
            "text": "\nMaybe. I was thinking the garbage collector was an object in its own right, belonging to the meta level, and accessed through a protocol, so meta object protocol seemed to fit. Consider allocators in C++. Probably I'm wrong, but I'll leave the discussion in case it helps someone else. -- [[Dave Harris]]",
            "id": "6683b5c1e1ddfdd44a60fef1857bcc91"
          },
          {
            "type": "html",
            "text": "<i>No, you were thinking that \"anything at the virtual machine level\" is MOP; GC was just an \"example\".  Even if you're right about GC, Glenn's comment about \"a more general concept\" fits the bill.</i>",
            "id": "e4512ca9b042ab4e807b67391f86efc7"
          },
          {
            "type": "html",
            "text": "\nExcerpt from [[The Art Of The Meta Object Protocol]]",
            "id": "adac9cf701e5f6d327449636b465ae65"
          },
          {
            "type": "html",
            "text": "In a language based upon [our] metaobject protocols, the language implementation itself is structured as an object-oriented program. This allows us to exploit the power of object-oriented programming techniques to to make the language implementation adjustable and flexible. In effect, the resulting implementation does not represent a single point in the overall space of language designs, but an entire region within that space.",
            "id": "76fe399911b5c16196acc6300070c869"
          },
          {
            "type": "html",
            "text": "\nSee Also:",
            "id": "f4799f583a6aec04dd55014e7b50e1ec"
          },
          {
            "type": "html",
            "text": "\n[http://www.parc.xerox.com/spl/projects/mops/default.html www.parc.xerox.com] [[[Broken Link]] -- 2006-08-16]",
            "id": "6d32beda9f06db4f380eb5d5825c247c"
          },
          {
            "type": "html",
            "text": "\n[http://www.elwood.com/alu/mop/index.html www.elwood.com] [[[Broken Link]] -- 2006-08-16]",
            "id": "da58a21fbec94767bfb62c125f169d4e"
          },
          {
            "type": "html",
            "text": "\n[[Dildar Marhas]]",
            "id": "8d5265099d9b7b5d51f22cafaab8c26b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "65d2d673f89bcaa1eba82b3335e23d9e"
          },
          {
            "type": "html",
            "text": "[[Pattie Maes]] has written some wonderful papers about this topic.",
            "id": "0183ce8df4ec2a37d62e228cef8d4258"
          },
          {
            "type": "html",
            "text": "\nMy view is that a Metaobject Protocol is a fundamentally important attribute of a [[Causally Reflective System]]. These systems virtually always have the ability to treat at least some memory as both code and data. In a Unix environment, this amounts to being able to execute from the data segment or write to the code segment, or both.",
            "id": "e688805a302e8a7f3a1982b7250f0a6d"
          },
          {
            "type": "html",
            "text": "\nAn application written, naively, in C or C++ and running on Unix is typically [[Not Reflective]]. The application has very limited or no ability to perform computations on itself. For example, its current process state or variable bindings are not accessible to it.",
            "id": "3f96407e92f87467365b47034bb12a24"
          },
          {
            "type": "html",
            "text": "\nSome systems are [[Descriptively Reflective]]. Early examples of this were the C++-based object databases, such as [[Object Store]] and Ontos. A [[Descriptively Reflective]] system contains a description of itself, and may even use that description, but changing that description merely breaks the system.",
            "id": "86e43024fb476d9b0fe4d265550fabc4"
          },
          {
            "type": "html",
            "text": "\nThe category of systems that I find interesting are [[Causally Reflective]] systems, such as [[Common Lisp]] and Smalltalk. A [[Causally Reflective]] system is written in terms of itself. It contains a description of its own behavior, and uses that description to control its behavior, so that a change to that description changes its behavior.",
            "id": "3b90d9c0bd7b310073569d0c3198d3ab"
          },
          {
            "type": "html",
            "text": "\nI suspect that an enterprising PhD candidate could, if it has not already been done, write a thesis proving the hypothesis that a [[Causally Reflective]] system must have a metaobject protocol.",
            "id": "bf634a7cf7dcfe331aa347ffdf529049"
          },
          {
            "type": "html",
            "text": "-- [[Tom Stambaugh]]",
            "id": "0a660cc835f872a5d03d87fc110f9434"
          },
          {
            "type": "html",
            "text": "\nMOP and causal reflectivity are rather obviously orthogonal -- causally reflective systems need not expose their descriptions or allow them to be modified, and the descriptions of non-reflective systems can be exposed and modified. And if all you mean is that a causally reflective system necessarily has a description that can be formalized as a data object that the system can interpret -- well, that's how it was just defined, so it wouldn't take a PhD thesis to demonstrate it.",
            "id": "7eb5a5c2143e0b15bb22671d2e566d54"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "65d2d673f89bcaa1eba82b3335e23d9e"
          },
          {
            "type": "html",
            "text": "Another source of information on [[Meta Class]] programming and Meta Object Protocols\nis the book \"Putting Metaclasses to Work\".  They even have some simulation code",
            "id": "4fe7cd9a139428d1217c5b95a4da8ba3"
          },
          {
            "type": "html",
            "text": "(written in Java) showing their MOP at work (located at [http://www.amazon.com/exec/obidos/tg/detail/-/0201433052 www.amazon.com]).",
            "id": "0fae1309fddbeb77829344776c5cc740"
          },
          {
            "type": "html",
            "text": "--[[Thomas Enebo]]",
            "id": "4a2dde441c91a766ec13c605680565d4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "65d2d673f89bcaa1eba82b3335e23d9e"
          },
          {
            "type": "html",
            "text": "A metaobject protocol certainly seems powerful.  An obvious example would be (I guess) C++ operator overloading, where you can define what otherwise ordinary language elements do to a particular class.  Or the java.lang.reflect package in Java, where you can do computation on the structure of your program.  (For example, some cool self-configuring systems like [[Java Beans]] work by scanning the names of your class's methods for particular naming conventions.)",
            "id": "33e2cde75b751dccf6b0adcca85d9b68"
          },
          {
            "type": "html",
            "text": "<i>Operator overloading is no different from overloading any other method name -- it has nothing to do with MOP.  Nor does introspection.</i>",
            "id": "bcdc6f6862172b002d040fbd8b1283a8"
          },
          {
            "type": "html",
            "text": "\nBut these sorts of features and capabilities are the enemy of learnable, [[Readable Code]], and I find that they are rarely used judiciously.",
            "id": "a6b4eb5a49451191b2f8003a9f496c1c"
          },
          {
            "type": "html",
            "text": "-- [[Rus Heywood]]",
            "id": "a693a9c8626898486f528cf123052759"
          },
          {
            "type": "html",
            "text": "\nWell, one example where MOP is often used is to provide persistency.  See for example PLOB! (persistent\nlisp objects) or the DEF-VIEW-CLASS macro provided with Xanaly's lisp.  Both these systems let you\ncreate CLOS objects whose metaclass is not STANDARD-CLASS, but rather a new, persistent class.\nThe degree of integration into \"normal lisp\" provided by these tools is simply astounding.  I would call\nthat a judicious use indeed.  All extremely powerful tools, (and is MOP ever one!) require extreme care\nand competence by the craftsman.",
            "id": "318c341aa4cf33ca35a8917dc4defc63"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "65d2d673f89bcaa1eba82b3335e23d9e"
          },
          {
            "type": "html",
            "text": "See also:\n[[Accessor Events]], [[Advantages Of Exposing Run Time Engine]], [[One More Level Of Indirection]]",
            "id": "a550c721c2ac3be5ee522912263cea78"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "65d2d673f89bcaa1eba82b3335e23d9e"
          },
          {
            "type": "html",
            "text": "[[Category Aspect Orientation]]",
            "id": "ce84b07b17ea83b91a0d39c0d956ced0"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?MetaObjectProtocol c2.com]",
            "id": "3ad63f9f06b097dcb31bb036850f38dd"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1645326893695
    }
  ]
}