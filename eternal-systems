{
  "title": "Eternal Systems",
  "story": [
    {
      "type": "markdown",
      "id": "8657642fcb671342",
      "text": "Software inevitably changes, but our development methods, programming languages, development environments and run-time systems provide little that acknowledges this fact. There is a general assumption behind most tools and methods that one is building a closed, internally consistent application, which will not significantly change after deployment. Anticipated evolution can be built in to some extent, for example by applying well-known design patterns, but unanticipated changes in requirements are hard to accommodate without reengineering the system, redeploying it, and possible migrating persistent data.\n\n"
    },
    {
      "type": "markdown",
      "id": "ba9d7e2e55c1bfdd",
      "text": "The vision of an __eternal software-intensive system__ is that of a system that can survive such unanticipated changes with little or no human intervention at the lowest level [1]. We claim that this vision can only be realized if __software evolution__ is supported in a fundamental way in our platforms, run-time environments and development environments [2]. Specifically, what does this entail?\n\n"
    },
    {
      "type": "markdown",
      "id": "88ff3f4850822cfa",
      "text": "First of all, we need to provide __platforms__ in terms of programming languages and run-time environments that make it possible to manipulate and operate on change as a first-class entity. This in turn implies that an eternal system is not only model-driven, but actually __self-aware__ — it must have a first-class representation of itself available to enable change. To control the scope of change, change itself should be represented as a first-class, high-level entity. And to manage change over time, the history of the system must also be accessible and first-class (see Section 3). Second, a self-aware eternal system must be capable of analyzing itself, and in particular of recognizing __emergent properties__. This means that the evolution of the static and dynamic models must be monitored, and the resulting data be analyzed as the system is running (see Section 4). \n"
    },
    {
      "type": "markdown",
      "id": "3f888e4f3c785338",
      "text": "Third, to enable continuous evolution, a self-aware eternal system must close the gap between the development and deployment views of itself. Domain models, usage models, and features, for example, must be made explicit in the system to facilitate change (see Section 5).\n"
    },
    {
      "type": "markdown",
      "id": "685328481a49026b",
      "text": "Finally, concrete incentives are needed to bring research and practice closer together (see Section 6)."
    },
    {
      "type": "pagefold",
      "id": "3c942882e312357c",
      "text": "References"
    },
    {
      "type": "markdown",
      "id": "197e603470b3036d",
      "text": "[1] M. Wirsing and M. H. (editors), “Report of the Beyond the Horizon thematic group 6 on Software Intensive Systems,” 2006.\n"
    },
    {
      "type": "markdown",
      "id": "383a21693bf06e40",
      "text": "[2] O. Nierstrasz, “[[Software evolution as the key to productivity]],” in Radical Innovations of Software and Systems Engineering in the Future (A. K. M. Wirsing and S. Balsamo, eds.), vol. 2941 of LNCS, pp. 274–282, Springer-Verlag, 2004.\n"
    },
    {
      "type": "pagefold",
      "id": "5fdd9c71bac2e14f",
      "text": "~"
    },
    {
      "type": "markdown",
      "id": "752248d31e486ead",
      "text": "Next: [[Self-Aware Platforms for Eternal Systems]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Eternal Systems",
        "story": []
      },
      "date": 1633630790477
    },
    {
      "item": {
        "type": "factory",
        "id": "8657642fcb671342"
      },
      "id": "8657642fcb671342",
      "type": "add",
      "date": 1633630799076
    },
    {
      "type": "edit",
      "id": "8657642fcb671342",
      "item": {
        "type": "markdown",
        "id": "8657642fcb671342",
        "text": "\nSoftware inevitably changes, but our development methods, programming languages, development environments and run-time systems provide lit- tle that acknowledges this fact. There is a general assumption behind most tools and methods that one is building a closed, internally consistent application, which will not significantly change after deployment. Antici- pated evolution can be built in to some extent, for example by applying well-known design patterns, but unanticipated changes in requirements are hard to accommodate without reengineering the system, redeploying it, and possible migrating persistent data.\nThe vision of an eternal software-intensive system is that of a system that can survive such unanticipated changes with little or no human interven- tion at the lowest level [1]. We claim that this vision can only be realized if software evolution is supported in a fundamental way in our platforms, run- time environments and development environments [2]. Specifically, what does this entail?\nFirst of all, we need to provide platforms in terms of programming lan- guages and run-time environments that make it possible to manipulate and operate on change as a first-class entity. This in turn implies that an eternal system is not only model-driven, but actually self-aware — it must have a first-class representation of itself available to enable change. To control the scope of change, change itself should be represented as a first-class, high-level entity. And to manage change over time, the history of the system must also be accessible and first-class (see Section 3). Second, a self-aware eternal system must be capable of analyzing itself, and in particular of recognizing emergent properties. This means that the evolution of the static and dynamic models must be monitored, and the resulting data be analyzed as the system is running (see Section 4). Third, to enable continuous evolution, a self-aware eternal system must close the gap between the development and deployment views of itself. Domain models, usage models, and features, for example, must be made explicit in the system to facilitate change (see Section 5).\nFinally, concrete incentives are needed to bring research and practice closer together (see Section 6)."
      },
      "date": 1633630801543
    },
    {
      "type": "edit",
      "id": "8657642fcb671342",
      "item": {
        "type": "markdown",
        "id": "8657642fcb671342",
        "text": "Software inevitably changes, but our development methods, programming languages, development environments and run-time systems provide lit- tle that acknowledges this fact. There is a general assumption behind most tools and methods that one is building a closed, internally consistent application, which will not significantly change after deployment. Antici- pated evolution can be built in to some extent, for example by applying well-known design patterns, but unanticipated changes in requirements are hard to accommodate without reengineering the system, redeploying it, and possible migrating persistent data.\nThe vision of an eternal software-intensive system is that of a system that can survive such unanticipated changes with little or no human interven- tion at the lowest level [1]. We claim that this vision can only be realized if software evolution is supported in a fundamental way in our platforms, run- time environments and development environments [2]. Specifically, what does this entail?\nFirst of all, we need to provide platforms in terms of programming lan- guages and run-time environments that make it possible to manipulate and operate on change as a first-class entity. This in turn implies that an eternal system is not only model-driven, but actually self-aware — it must have a first-class representation of itself available to enable change. To control the scope of change, change itself should be represented as a first-class, high-level entity. And to manage change over time, the history of the system must also be accessible and first-class (see Section 3). Second, a self-aware eternal system must be capable of analyzing itself, and in particular of recognizing emergent properties. This means that the evolution of the static and dynamic models must be monitored, and the resulting data be analyzed as the system is running (see Section 4). Third, to enable continuous evolution, a self-aware eternal system must close the gap between the development and deployment views of itself. Domain models, usage models, and features, for example, must be made explicit in the system to facilitate change (see Section 5).\nFinally, concrete incentives are needed to bring research and practice closer together (see Section 6)."
      },
      "date": 1633630812112
    },
    {
      "type": "edit",
      "id": "8657642fcb671342",
      "item": {
        "type": "markdown",
        "id": "8657642fcb671342",
        "text": "Software inevitably changes, but our development methods, programming languages, development environments and run-time systems provide lit- tle that acknowledges this fact. There is a general assumption behind most tools and methods that one is building a closed, internally consistent application, which will not significantly change after deployment. Anticipated evolution can be built in to some extent, for example by applying well-known design patterns, but unanticipated changes in requirements are hard to accommodate without reengineering the system, redeploying it, and possible migrating persistent data.\n\n"
      },
      "date": 1633630847409
    },
    {
      "type": "add",
      "id": "ba9d7e2e55c1bfdd",
      "item": {
        "type": "markdown",
        "id": "ba9d7e2e55c1bfdd",
        "text": "The vision of an eternal software-intensive system is that of a system that can survive such unanticipated changes with little or no human interven- tion at the lowest level [1]. We claim that this vision can only be realized if software evolution is supported in a fundamental way in our platforms, run- time environments and development environments [2]. Specifically, what does this entail?\n\n"
      },
      "after": "8657642fcb671342",
      "date": 1633630850190
    },
    {
      "type": "add",
      "id": "88ff3f4850822cfa",
      "item": {
        "type": "markdown",
        "id": "88ff3f4850822cfa",
        "text": "First of all, we need to provide platforms in terms of programming lan- guages and run-time environments that make it possible to manipulate and operate on change as a first-class entity. This in turn implies that an eternal system is not only model-driven, but actually self-aware — it must have a first-class representation of itself available to enable change. To control the scope of change, change itself should be represented as a first-class, high-level entity. And to manage change over time, the history of the system must also be accessible and first-class (see Section 3). Second, a self-aware eternal system must be capable of analyzing itself, and in particular of recognizing emergent properties. This means that the evolution of the static and dynamic models must be monitored, and the resulting data be analyzed as the system is running (see Section 4). Third, to enable continuous evolution, a self-aware eternal system must close the gap between the development and deployment views of itself. Domain models, usage models, and features, for example, must be made explicit in the system to facilitate change (see Section 5).\nFinally, concrete incentives are needed to bring research and practice closer together (see Section 6)."
      },
      "after": "ba9d7e2e55c1bfdd",
      "date": 1633630863318
    },
    {
      "type": "edit",
      "id": "8657642fcb671342",
      "item": {
        "type": "markdown",
        "id": "8657642fcb671342",
        "text": "Software inevitably changes, but our development methods, programming languages, development environments and run-time systems provide little that acknowledges this fact. There is a general assumption behind most tools and methods that one is building a closed, internally consistent application, which will not significantly change after deployment. Anticipated evolution can be built in to some extent, for example by applying well-known design patterns, but unanticipated changes in requirements are hard to accommodate without reengineering the system, redeploying it, and possible migrating persistent data.\n\n"
      },
      "date": 1633630888098
    },
    {
      "type": "edit",
      "id": "ba9d7e2e55c1bfdd",
      "item": {
        "type": "markdown",
        "id": "ba9d7e2e55c1bfdd",
        "text": "The vision of an __eternal software-intensive system__ is that of a system that can survive such unanticipated changes with little or no human intervention at the lowest level [1]. We claim that this vision can only be realized if __software evolution__ is supported in a fundamental way in our platforms, run-time environments and development environments [2]. Specifically, what does this entail?\n\n"
      },
      "date": 1633630922807
    },
    {
      "type": "edit",
      "id": "88ff3f4850822cfa",
      "item": {
        "type": "markdown",
        "id": "88ff3f4850822cfa",
        "text": "First of all, we need to provide __platforms__ in terms of programming languages and run-time environments that make it possible to manipulate and operate on change as a first-class entity. This in turn implies that an eternal system is not only model-driven, but actually __self-aware__ — it must have a first-class representation of itself available to enable change. To control the scope of change, change itself should be represented as a first-class, high-level entity. And to manage change over time, the history of the system must also be accessible and first-class (see Section 3). Second, a self-aware eternal system must be capable of analyzing itself, and in particular of recognizing emergent properties. This means that the evolution of the static and dynamic models must be monitored, and the resulting data be analyzed as the system is running (see Section 4). Third, to enable continuous evolution, a self-aware eternal system must close the gap between the development and deployment views of itself. Domain models, usage models, and features, for example, must be made explicit in the system to facilitate change (see Section 5).\n"
      },
      "date": 1633631012954
    },
    {
      "type": "add",
      "id": "685328481a49026b",
      "item": {
        "type": "markdown",
        "id": "685328481a49026b",
        "text": "Finally, concrete incentives are needed to bring research and practice closer together (see Section 6)."
      },
      "after": "88ff3f4850822cfa",
      "date": 1633631017725
    },
    {
      "type": "edit",
      "id": "88ff3f4850822cfa",
      "item": {
        "type": "markdown",
        "id": "88ff3f4850822cfa",
        "text": "First of all, we need to provide __platforms__ in terms of programming languages and run-time environments that make it possible to manipulate and operate on change as a first-class entity. This in turn implies that an eternal system is not only model-driven, but actually __self-aware__ — it must have a first-class representation of itself available to enable change. To control the scope of change, change itself should be represented as a first-class, high-level entity. And to manage change over time, the history of the system must also be accessible and first-class (see Section 3). Second, a self-aware eternal system must be capable of analyzing itself, and in particular of recognizing emergent properties. This means that the evolution of the static and dynamic models must be monitored, and the resulting data be analyzed as the system is running (see Section 4). \n"
      },
      "date": 1633631025795
    },
    {
      "type": "add",
      "id": "3f888e4f3c785338",
      "item": {
        "type": "markdown",
        "id": "3f888e4f3c785338",
        "text": "Third, to enable continuous evolution, a self-aware eternal system must close the gap between the development and deployment views of itself. Domain models, usage models, and features, for example, must be made explicit in the system to facilitate change (see Section 5).\n"
      },
      "after": "88ff3f4850822cfa",
      "date": 1633631032324
    },
    {
      "type": "edit",
      "id": "88ff3f4850822cfa",
      "item": {
        "type": "markdown",
        "id": "88ff3f4850822cfa",
        "text": "First of all, we need to provide __platforms__ in terms of programming languages and run-time environments that make it possible to manipulate and operate on change as a first-class entity. This in turn implies that an eternal system is not only model-driven, but actually __self-aware__ — it must have a first-class representation of itself available to enable change. To control the scope of change, change itself should be represented as a first-class, high-level entity. And to manage change over time, the history of the system must also be accessible and first-class (see Section 3). Second, a self-aware eternal system must be capable of analyzing itself, and in particular of recognizing __emergent properties__. This means that the evolution of the static and dynamic models must be monitored, and the resulting data be analyzed as the system is running (see Section 4). \n"
      },
      "date": 1633631046007
    },
    {
      "item": {
        "type": "factory",
        "id": "3c942882e312357c"
      },
      "id": "3c942882e312357c",
      "type": "add",
      "after": "685328481a49026b",
      "date": 1633631326858
    },
    {
      "type": "edit",
      "id": "3c942882e312357c",
      "item": {
        "type": "pagefold",
        "id": "3c942882e312357c",
        "text": "References"
      },
      "date": 1633631334860
    },
    {
      "item": {
        "type": "factory",
        "id": "197e603470b3036d"
      },
      "id": "197e603470b3036d",
      "type": "add",
      "after": "3c942882e312357c",
      "date": 1633631336289
    },
    {
      "type": "edit",
      "id": "197e603470b3036d",
      "item": {
        "type": "markdown",
        "id": "197e603470b3036d",
        "text": "[1] M. Wirsing and M. H. (editors), “Report of the Beyond the Horizon thematic group 6 on Software Intensive Systems,” 2006."
      },
      "date": 1633631342435
    },
    {
      "type": "edit",
      "id": "197e603470b3036d",
      "item": {
        "type": "markdown",
        "id": "197e603470b3036d",
        "text": "[1] M. Wirsing and M. H. (editors), “Report of the Beyond the Horizon thematic group 6 on Software Intensive Systems,” 2006.\n"
      },
      "date": 1633631441932
    },
    {
      "type": "add",
      "id": "383a21693bf06e40",
      "item": {
        "type": "markdown",
        "id": "383a21693bf06e40",
        "text": "[2] O. Nierstrasz, “Software evolution as the key to productivity,” in Radical Innovations of Software and Systems Engineering in the Future (A. K. M. Wirsing and S. Balsamo, eds.), vol. 2941 of LNCS, pp. 274–282, Springer-Verlag, 2004."
      },
      "after": "197e603470b3036d",
      "date": 1633631448222
    },
    {
      "type": "edit",
      "id": "383a21693bf06e40",
      "item": {
        "type": "markdown",
        "id": "383a21693bf06e40",
        "text": "[2] O. Nierstrasz, “Software evolution as the key to productivity,” in Radical Innovations of Software and Systems Engineering in the Future (A. K. M. Wirsing and S. Balsamo, eds.), vol. 2941 of LNCS, pp. 274–282, Springer-Verlag, 2004.\n"
      },
      "date": 1633631587536
    },
    {
      "type": "add",
      "id": "fd62da6b63be9359",
      "item": {
        "type": "markdown",
        "id": "fd62da6b63be9359",
        "text": "See [[Software Evolution as the Key to Productivity]]"
      },
      "after": "383a21693bf06e40",
      "date": 1633631592890
    },
    {
      "type": "edit",
      "id": "383a21693bf06e40",
      "item": {
        "type": "markdown",
        "id": "383a21693bf06e40",
        "text": "[2] O. Nierstrasz, “[[Software evolution as the key to productivity]],” in Radical Innovations of Software and Systems Engineering in the Future (A. K. M. Wirsing and S. Balsamo, eds.), vol. 2941 of LNCS, pp. 274–282, Springer-Verlag, 2004.\n"
      },
      "date": 1633631782238
    },
    {
      "type": "remove",
      "id": "fd62da6b63be9359",
      "date": 1633631785933
    },
    {
      "type": "fork",
      "date": 1633640988812
    },
    {
      "item": {
        "type": "factory",
        "id": "5fdd9c71bac2e14f"
      },
      "id": "5fdd9c71bac2e14f",
      "type": "add",
      "after": "383a21693bf06e40",
      "date": 1633640990910
    },
    {
      "type": "edit",
      "id": "5fdd9c71bac2e14f",
      "item": {
        "type": "pagefold",
        "id": "5fdd9c71bac2e14f",
        "text": "~"
      },
      "date": 1633641000220
    },
    {
      "item": {
        "type": "factory",
        "id": "752248d31e486ead"
      },
      "id": "752248d31e486ead",
      "type": "add",
      "after": "5fdd9c71bac2e14f",
      "date": 1633641001984
    },
    {
      "type": "edit",
      "id": "752248d31e486ead",
      "item": {
        "type": "markdown",
        "id": "752248d31e486ead",
        "text": "Next: [[Self-Aware Platforms for Eternal Systems]]"
      },
      "date": 1633641011637
    }
  ]
}