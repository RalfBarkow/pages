{
  "title": "Scope And Closures",
  "story": [
    {
      "type": "html",
      "text": "<b>[This page should probably refactored with the pages [[Lexical Scoping]], [[Dynamic Scoping]], [[Lexical Closure]] and maybe [[Special Variable]] and [[Dynamic Extent]].]</b>",
      "id": "9ac74d4e596713f788e20b1704480268"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8e87ee8183331d0123a2ca32f50f82a8"
    },
    {
      "type": "html",
      "text": "<i>I am in need to explain these terms in another context since I haven't found good explanations elsewhere. I hope some people find this useful. The discussion is based on [[Java Language]] for the time being.</i> -- [[Pascal Costanza]]",
      "id": "01532a871197e2aee0caaf7b6e94e36c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8e87ee8183331d0123a2ca32f50f82a8"
    },
    {
      "type": "html",
      "text": "<b>Lexical scoping</b>",
      "id": "197870a25200d88e477a77f69cfc4cf9"
    },
    {
      "type": "html",
      "text": "\nA programming language is said to be lexically scoped if names for variables and methods are looked up according to the textual arrangement of their definitions. So in the following example, the methods getSecurityManager and setSecurityManager always refers to the variable globalSecurityManager as defined in the class Security<b></b>Manager, because this is their shared scope.",
      "id": "90c4e15c8be40e3e0932f091f1cce88a"
    },
    {
      "type": "code",
      "text": " class Security''''''Manager {",
      "id": "a1e65015a0730bcef4febd2727b10ce6"
    },
    {
      "type": "code",
      "text": "  static Security''''''Manager globalSecurityManager;",
      "id": "594f5fff9cef21efe454225b098d7850"
    },
    {
      "type": "code",
      "text": "  static Security''''''Manager getSecurityManager() {\n  return globalSecurityManager;\n  }",
      "id": "1558de5da99568314f94e6771304f7db"
    },
    {
      "type": "code",
      "text": "  static void setSecurityManager(Security''''''Manager sm) {\n  globalSecurityManager = sm;\n  }\n }",
      "id": "140b7f48d87169b58c11f5242aaa37dc"
    },
    {
      "type": "html",
      "text": "(This is, of course, not a faithful implementation of the Java API specification of a class with a similar name. ;)",
      "id": "dc61509dc911f123514ece506a0a17fd"
    },
    {
      "type": "html",
      "text": "\nSo especially when one of those methods is called in another context, you cannot accidentally \"override\" this variable. See the following example.",
      "id": "99ca035b291292d10d8fb1d80678e93f"
    },
    {
      "type": "code",
      "text": " class My''''''Class {",
      "id": "caf83c0674c0ccad52b197baa33939ca"
    },
    {
      "type": "code",
      "text": "  void myMethod() {\n  Security''''''Manager globalSecurityManager;\n  Security''''''Manager.setSecurityManager(new Security''''''Manager());\n  }\n }",
      "id": "8cae8ed243162a39ad5b9265ed9d15ce"
    },
    {
      "type": "html",
      "text": "Here, the call to Security<b></b>Manager.setSecurityManager does not change the local variable of myMethod, but still the static variable with the same name in the class Security<b></b>Manager, as intended by the programmer of that class.",
      "id": "b4b8aa131bdb46c01f2882354f970c63"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8e87ee8183331d0123a2ca32f50f82a8"
    },
    {
      "type": "html",
      "text": "<b>Dynamic Scoping</b>",
      "id": "1929e0e4462d8d55575870d70fe7a662"
    },
    {
      "type": "html",
      "text": "\nWell, lexical scoping is the standard behavior in Java and almost all programming languages nowadays, so why bother to give this the funny name \"lexical scoping\"? Because there are some languages available that additionally offer \"dynamic scoping\". With dynamic scoping, the call to Security<b></b>Manager.setSecurityManager would in fact change the local variable and not the static one in class Security<b></b>Manager. This is because a dynamically scoped variable is looked up in the call stack that is active at the moment when a name needs to be resolved and found in the most recent stack frame. How on earth could this ever be a useful behavior? Here is another example: consider a class that defines a \"special\", i.e. dynamically scoped variable \"debug\" as follows. (Of course, this is an \"extension\" to Java made up on the spot.)",
      "id": "b15171a4aa3c479c7d7dc6b27b5a4a7e"
    },
    {
      "type": "code",
      "text": " class Debug''''''Support {",
      "id": "1937f37e25c3fc6c71de33f1988d9fb5"
    },
    {
      "type": "code",
      "text": "  special static boolean debug = false;",
      "id": "40f96036075db280d6f424e44eab1876"
    },
    {
      "type": "code",
      "text": " }",
      "id": "58a2ee56f1c312112e5d3e1f4bb5ac85"
    },
    {
      "type": "html",
      "text": "Now a programmer can choose to temporarily switch debugging on and/or off by introducing a new definition for this variable as follows.",
      "id": "6a562d75db6d646435047608bb486cf5"
    },
    {
      "type": "code",
      "text": " class My''''''Class {",
      "id": "caf83c0674c0ccad52b197baa33939ca"
    },
    {
      "type": "code",
      "text": "  void myMethod() {\n  \n  boolean debug = true;",
      "id": "6689f0ce58903d619ba8bbfb06b2e071"
    },
    {
      "type": "code",
      "text": "  // everything from here is being debugged",
      "id": "5de8fe0db2e9ff74a84f8c039ea30556"
    },
    {
      "type": "code",
      "text": "  callOtherStuff();",
      "id": "3a50e0d90a87df820cab16df9b5c7f9e"
    },
    {
      "type": "code",
      "text": "  // after exit from this method,\n  // debug is reset to its previous state\n  // because the local variable goes out of scope\n  \n  }\n }",
      "id": "4352c0ea56b639aca5af0a389611a87e"
    },
    {
      "type": "html",
      "text": "What's interesting here is that the new definition for debug introduced in myMethod affects all code called within the dynamic scope of this definition. So everything that is called within callOtherStuff also sees debug as being set to true. (Unless, of course, it is again overridden by another definition for debug.)",
      "id": "99c8617268ad8eb8f0b22151e0dcfc4f"
    },
    {
      "type": "html",
      "text": "\nYou might think of a straightforward way to simulate this in Java, but this is most likely not correct because you need to think of too many special cases. For example, here is a straightforward but erroneous implementation in pure Java.",
      "id": "85b64c666e908c59bcab210d5cf8229f"
    },
    {
      "type": "code",
      "text": " class My''''''Class {",
      "id": "caf83c0674c0ccad52b197baa33939ca"
    },
    {
      "type": "code",
      "text": "  void myMethod() {\n  \n  Debug''''''Support.debug = true;",
      "id": "cc6c01fd78b39a5e3b1bca9591685a7b"
    },
    {
      "type": "code",
      "text": "  callOtherStuff();",
      "id": "3a50e0d90a87df820cab16df9b5c7f9e"
    },
    {
      "type": "code",
      "text": "  Debug''''''Support.debug = false;",
      "id": "223ceb3ce17e350765bb7e8c71074c0a"
    },
    {
      "type": "code",
      "text": "  }\n }",
      "id": "94000a8377780b2ab23b053e24b0ff9f"
    },
    {
      "type": "html",
      "text": "This code makes the implicit assumption that debug was set to false beforehand. However, in the general case you do not know the actual value stored in the debug variable, so you would have to write the following.",
      "id": "f9d561375e96ceaff801914d55dbe420"
    },
    {
      "type": "code",
      "text": " class My''''''Class {",
      "id": "caf83c0674c0ccad52b197baa33939ca"
    },
    {
      "type": "code",
      "text": "  void myMethod() {\n  \n  boolean previousDebugState = Debug''''''Support.debug;\n  Debug''''''Support.debug = true;",
      "id": "f5e811faeaadf686a2e7e24c61a2f4ca"
    },
    {
      "type": "code",
      "text": "  callOtherStuff();",
      "id": "3a50e0d90a87df820cab16df9b5c7f9e"
    },
    {
      "type": "code",
      "text": "  Debug''''''Support.debug = previousDebugState;",
      "id": "6bf905001dd274b1b67c1b7024578e42"
    },
    {
      "type": "code",
      "text": "  }\n }",
      "id": "94000a8377780b2ab23b053e24b0ff9f"
    },
    {
      "type": "html",
      "text": "Well, and then there's the possibility that callOtherStuff throws an exception and in this case, the reset code would not be executed. So you would have to provide a try-finally block accordingly. Furthermore, you most likely would need to store the debug state in a [[Thread Local Variable]], and not a global one. What about synchronization? And so it goes on and on and on. You see that manually implementing dynamic scopes in Java is very tedious and dynamically scoped variables as a built-in feature of the language would provide a much easier way to handle such cases.",
      "id": "c00c37555885e1918414398dfc5508d7"
    },
    {
      "type": "html",
      "text": "\n[[Common Lisp]] offers dynamically scoped variables if they are explicitly defined as such (by means of defparameter or defvar), and they are called \"special variables\". Furthermore, there is the convention in the Common Lisp community to always name them with preceding and succeeding stars. So the name for the debug variable of the example given above in equivalent Common Lisp code would be *debug*. (Common Lispers heavily rely on this convention, so you should really abide by it!)",
      "id": "214b2e77082770952574ee7181e4f28c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8e87ee8183331d0123a2ca32f50f82a8"
    },
    {
      "type": "html",
      "text": "<b>Closures and lexical closures</b>",
      "id": "1e9c16ca4b3087aca384ae1bec491de2"
    },
    {
      "type": "html",
      "text": "\nAssume that Java had methods as first-class data types (like delegates in [[Csharp Language]] or function pointers in [[Cee Language]] or [[Cee Plus Plus]]). Assume further that you could declare a method in the local scope of another method. Then you could, for example, write the following.",
      "id": "38c025ac16f380a8676f6873d20b4e86"
    },
    {
      "type": "code",
      "text": " function createAdder(int n) {",
      "id": "bd2ec3754ea5ffeac6562c1581c6b1b2"
    },
    {
      "type": "code",
      "text": "  // define a method\n  int adder(int k) {\n  n = n + k;\n  return n;\n  }",
      "id": "36b92bd4fa1c52c3cea6cf96a66e02e5"
    },
    {
      "type": "code",
      "text": "  // return it as a result  \n  return adder;\n }",
      "id": "d0d1ae433596c024134afaac703e477d"
    },
    {
      "type": "html",
      "text": "Now you can call this method in order to yield an adder with a start value as follows...",
      "id": "23bfcec02d381625de7e36d479fad723"
    },
    {
      "type": "code",
      "text": " f = createAdder(5);",
      "id": "999c4bb2600e90332a97fac00a898485"
    },
    {
      "type": "html",
      "text": "...and afterwards call f repeatedly to increment the start value and return it...",
      "id": "c984b1af96f3b460bb255080d4868860"
    },
    {
      "type": "code",
      "text": " f(6) => yields 11 (5 + 6)\n f(7) => yields 18 (11 + 7)\n f(6) => yields 24 (18 + 6)",
      "id": "f6458d6d6ae00bede756603059bf75b9"
    },
    {
      "type": "html",
      "text": "...and so on. Another call to createAdder would return a fresh adder.",
      "id": "9c8a68d5faaa0d2f92b00b1f9164aead"
    },
    {
      "type": "code",
      "text": " f2 = createAdder(6);",
      "id": "d7f7170e8a0e07c56766d5d45916791c"
    },
    {
      "type": "code",
      "text": " f2(6) => yields 12 (6 + 6)\n f2(5) => yields 17 (12 + 5)",
      "id": "f79b9497c006cdb16d2febe91a09992e"
    },
    {
      "type": "html",
      "text": "...and so on.",
      "id": "bec22ac7b0a2f6cdbb09cd31684d03a9"
    },
    {
      "type": "html",
      "text": "\nWhat happens here in detail? We have already seen that the method createAdder defines the method adder inside of its scope. What's interesting here is that method adder refers to the parameter n that is passed to createAdder. When the method adder is returned as a result by createAdder, this binding to the parameter n is retained. The method adder is said to \"close over\" parameter n; it is said to be a \"closure\". The term \"lexical closure\" is used when a closure preserves lexical scoping, i.e. when the variable references cannot accidentally be overridden by other local definitions (see above). Since almost all languages with closures offer lexical closures by now, it's usually safe to use the terms \"closures\" and \"lexical closures\" synonymously.",
      "id": "8f4e888bbb316e836af5c8c0d673c16e"
    },
    {
      "type": "html",
      "text": "\nNote that the closure is retained even after createAdder has completed and the stack has no reference to n anymore. This is the very reason why closures and local method definitions have not been added to the Java programming language (and other C-like languages): because of their implementation schemes for local variables, these languages would not be able to guarantee safe access to arbitrary variables in the lexical scope in the case of closures.",
      "id": "ee958e56d7e862ecd3632bb5fb28d4ef"
    },
    {
      "type": "html",
      "text": "(Java's [[Inner Class]]es are a variation on the theme of closures. They are, in fact, able to access some variables in their lexical scope, but only if these variables are declared as final. Again, access to non-final variables would not be safe in the general case. The reason is that a local variable would not exist anymore after a stack frame has been cleared on exit of the respective method, so a write access to such a variable would fail. On the other hand, final variables can safely be copied around because they don't need to keep track of possible changes to their values - and this is exactly how Java implements closures over final variables: it just copies them to fields that are implicitly created for inner classes.)",
      "id": "474e386ed21e8f380eb6d1eb1fc7de4b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8e87ee8183331d0123a2ca32f50f82a8"
    },
    {
      "type": "html",
      "text": "<b>Summary</b>",
      "id": "7169351727cea942ac10058f92eb643b"
    },
    {
      "type": "html",
      "text": "\nIn the early days, lexical scoping was a distinguishing feature of [[Algol Language]] and its descendants, whereas early implementations of [[Lisp Language]] were purely dynamically scoped. [[Scheme Language]] has introduced lexical scoping and lexical closures to the Lisp world, and [[Common Lisp]] has incorporated these notions as defaults as well. Since there are cases where dynamic scoping is very useful, [[Common Lisp]] still additionally offers dynamic scoping for specially declared [[Special Variable]]s.",
      "id": "4b063ce81c6174c8a22964b9172f5096"
    },
    {
      "type": "html",
      "text": "<i>I don't know what other languages offer both lexical and dynamic scoping.</i>",
      "id": "298a6864fe5f9d7a50754f0386910995"
    },
    {
      "type": "html",
      "text": "\n[[Perl Language]] does; my() variables are lexicals, whereas local() variables are dynamically scoped.",
      "id": "124a45b7a0bcd864bbfd219b3cf15bd7"
    },
    {
      "type": "html",
      "text": "\n[[Io Language]] does; variables are dynamicly bound to their objects (not their calling context) by default, but blocks can be used for lexical scoping.",
      "id": "6d0c2919e149cc61796f581f92149262"
    },
    {
      "type": "html",
      "text": "\n[[Emacs Lisp]] supports it since version 24.",
      "id": "2a65838fdb7d6a641c7f5ddf9b51858e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "8e87ee8183331d0123a2ca32f50f82a8"
    },
    {
      "type": "html",
      "text": "See also [[Category Closure]], [[Lexical Closure]], [[What Is Closure]], [[Scoping Rules]]",
      "id": "aed0de1b0b7672e4b18b3fb24fd9a68a"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ScopeAndClosures c2.com]",
      "id": "50e636bc7596d0678e55e946f30a3354"
    }
  ],
  "journal": [
    {
      "date": 1359986922000,
      "id": "bbfd053f99708432a234a4a6f20299e9",
      "type": "create",
      "item": {
        "title": "Scope And Closures",
        "story": [
          {
            "type": "html",
            "text": "<b>[This page should probably refactored with the pages [[Lexical Scoping]], [[Dynamic Scoping]], [[Lexical Closure]] and maybe [[Special Variable]] and [[Dynamic Extent]].]</b>",
            "id": "9ac74d4e596713f788e20b1704480268"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8e87ee8183331d0123a2ca32f50f82a8"
          },
          {
            "type": "html",
            "text": "<i>I am in need to explain these terms in another context since I haven't found good explanations elsewhere. I hope some people find this useful. The discussion is based on [[Java Language]] for the time being.</i> -- [[Pascal Costanza]]",
            "id": "01532a871197e2aee0caaf7b6e94e36c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8e87ee8183331d0123a2ca32f50f82a8"
          },
          {
            "type": "html",
            "text": "<b>Lexical scoping</b>",
            "id": "197870a25200d88e477a77f69cfc4cf9"
          },
          {
            "type": "html",
            "text": "\nA programming language is said to be lexically scoped if names for variables and methods are looked up according to the textual arrangement of their definitions. So in the following example, the methods getSecurityManager and setSecurityManager always refers to the variable globalSecurityManager as defined in the class Security<b></b>Manager, because this is their shared scope.",
            "id": "90c4e15c8be40e3e0932f091f1cce88a"
          },
          {
            "type": "code",
            "text": " class Security''''''Manager {",
            "id": "a1e65015a0730bcef4febd2727b10ce6"
          },
          {
            "type": "code",
            "text": "  static Security''''''Manager globalSecurityManager;",
            "id": "594f5fff9cef21efe454225b098d7850"
          },
          {
            "type": "code",
            "text": "  static Security''''''Manager getSecurityManager() {\n  return globalSecurityManager;\n  }",
            "id": "1558de5da99568314f94e6771304f7db"
          },
          {
            "type": "code",
            "text": "  static void setSecurityManager(Security''''''Manager sm) {\n  globalSecurityManager = sm;\n  }\n }",
            "id": "140b7f48d87169b58c11f5242aaa37dc"
          },
          {
            "type": "html",
            "text": "(This is, of course, not a faithful implementation of the Java API specification of a class with a similar name. ;)",
            "id": "dc61509dc911f123514ece506a0a17fd"
          },
          {
            "type": "html",
            "text": "\nSo especially when one of those methods is called in another context, you cannot accidentally \"override\" this variable. See the following example.",
            "id": "99ca035b291292d10d8fb1d80678e93f"
          },
          {
            "type": "code",
            "text": " class My''''''Class {",
            "id": "caf83c0674c0ccad52b197baa33939ca"
          },
          {
            "type": "code",
            "text": "  void myMethod() {\n  Security''''''Manager globalSecurityManager;\n  Security''''''Manager.setSecurityManager(new Security''''''Manager());\n  }\n }",
            "id": "8cae8ed243162a39ad5b9265ed9d15ce"
          },
          {
            "type": "html",
            "text": "Here, the call to Security<b></b>Manager.setSecurityManager does not change the local variable of myMethod, but still the static variable with the same name in the class Security<b></b>Manager, as intended by the programmer of that class.",
            "id": "b4b8aa131bdb46c01f2882354f970c63"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8e87ee8183331d0123a2ca32f50f82a8"
          },
          {
            "type": "html",
            "text": "<b>Dynamic Scoping</b>",
            "id": "1929e0e4462d8d55575870d70fe7a662"
          },
          {
            "type": "html",
            "text": "\nWell, lexical scoping is the standard behavior in Java and almost all programming languages nowadays, so why bother to give this the funny name \"lexical scoping\"? Because there are some languages available that additionally offer \"dynamic scoping\". With dynamic scoping, the call to Security<b></b>Manager.setSecurityManager would in fact change the local variable and not the static one in class Security<b></b>Manager. This is because a dynamically scoped variable is looked up in the call stack that is active at the moment when a name needs to be resolved and found in the most recent stack frame. How on earth could this ever be a useful behavior? Here is another example: consider a class that defines a \"special\", i.e. dynamically scoped variable \"debug\" as follows. (Of course, this is an \"extension\" to Java made up on the spot.)",
            "id": "b15171a4aa3c479c7d7dc6b27b5a4a7e"
          },
          {
            "type": "code",
            "text": " class Debug''''''Support {",
            "id": "1937f37e25c3fc6c71de33f1988d9fb5"
          },
          {
            "type": "code",
            "text": "  special static boolean debug = false;",
            "id": "40f96036075db280d6f424e44eab1876"
          },
          {
            "type": "code",
            "text": " }",
            "id": "58a2ee56f1c312112e5d3e1f4bb5ac85"
          },
          {
            "type": "html",
            "text": "Now a programmer can choose to temporarily switch debugging on and/or off by introducing a new definition for this variable as follows.",
            "id": "6a562d75db6d646435047608bb486cf5"
          },
          {
            "type": "code",
            "text": " class My''''''Class {",
            "id": "caf83c0674c0ccad52b197baa33939ca"
          },
          {
            "type": "code",
            "text": "  void myMethod() {\n  \n  boolean debug = true;",
            "id": "6689f0ce58903d619ba8bbfb06b2e071"
          },
          {
            "type": "code",
            "text": "  // everything from here is being debugged",
            "id": "5de8fe0db2e9ff74a84f8c039ea30556"
          },
          {
            "type": "code",
            "text": "  callOtherStuff();",
            "id": "3a50e0d90a87df820cab16df9b5c7f9e"
          },
          {
            "type": "code",
            "text": "  // after exit from this method,\n  // debug is reset to its previous state\n  // because the local variable goes out of scope\n  \n  }\n }",
            "id": "4352c0ea56b639aca5af0a389611a87e"
          },
          {
            "type": "html",
            "text": "What's interesting here is that the new definition for debug introduced in myMethod affects all code called within the dynamic scope of this definition. So everything that is called within callOtherStuff also sees debug as being set to true. (Unless, of course, it is again overridden by another definition for debug.)",
            "id": "99c8617268ad8eb8f0b22151e0dcfc4f"
          },
          {
            "type": "html",
            "text": "\nYou might think of a straightforward way to simulate this in Java, but this is most likely not correct because you need to think of too many special cases. For example, here is a straightforward but erroneous implementation in pure Java.",
            "id": "85b64c666e908c59bcab210d5cf8229f"
          },
          {
            "type": "code",
            "text": " class My''''''Class {",
            "id": "caf83c0674c0ccad52b197baa33939ca"
          },
          {
            "type": "code",
            "text": "  void myMethod() {\n  \n  Debug''''''Support.debug = true;",
            "id": "cc6c01fd78b39a5e3b1bca9591685a7b"
          },
          {
            "type": "code",
            "text": "  callOtherStuff();",
            "id": "3a50e0d90a87df820cab16df9b5c7f9e"
          },
          {
            "type": "code",
            "text": "  Debug''''''Support.debug = false;",
            "id": "223ceb3ce17e350765bb7e8c71074c0a"
          },
          {
            "type": "code",
            "text": "  }\n }",
            "id": "94000a8377780b2ab23b053e24b0ff9f"
          },
          {
            "type": "html",
            "text": "This code makes the implicit assumption that debug was set to false beforehand. However, in the general case you do not know the actual value stored in the debug variable, so you would have to write the following.",
            "id": "f9d561375e96ceaff801914d55dbe420"
          },
          {
            "type": "code",
            "text": " class My''''''Class {",
            "id": "caf83c0674c0ccad52b197baa33939ca"
          },
          {
            "type": "code",
            "text": "  void myMethod() {\n  \n  boolean previousDebugState = Debug''''''Support.debug;\n  Debug''''''Support.debug = true;",
            "id": "f5e811faeaadf686a2e7e24c61a2f4ca"
          },
          {
            "type": "code",
            "text": "  callOtherStuff();",
            "id": "3a50e0d90a87df820cab16df9b5c7f9e"
          },
          {
            "type": "code",
            "text": "  Debug''''''Support.debug = previousDebugState;",
            "id": "6bf905001dd274b1b67c1b7024578e42"
          },
          {
            "type": "code",
            "text": "  }\n }",
            "id": "94000a8377780b2ab23b053e24b0ff9f"
          },
          {
            "type": "html",
            "text": "Well, and then there's the possibility that callOtherStuff throws an exception and in this case, the reset code would not be executed. So you would have to provide a try-finally block accordingly. Furthermore, you most likely would need to store the debug state in a [[Thread Local Variable]], and not a global one. What about synchronization? And so it goes on and on and on. You see that manually implementing dynamic scopes in Java is very tedious and dynamically scoped variables as a built-in feature of the language would provide a much easier way to handle such cases.",
            "id": "c00c37555885e1918414398dfc5508d7"
          },
          {
            "type": "html",
            "text": "\n[[Common Lisp]] offers dynamically scoped variables if they are explicitly defined as such (by means of defparameter or defvar), and they are called \"special variables\". Furthermore, there is the convention in the Common Lisp community to always name them with preceding and succeeding stars. So the name for the debug variable of the example given above in equivalent Common Lisp code would be *debug*. (Common Lispers heavily rely on this convention, so you should really abide by it!)",
            "id": "214b2e77082770952574ee7181e4f28c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8e87ee8183331d0123a2ca32f50f82a8"
          },
          {
            "type": "html",
            "text": "<b>Closures and lexical closures</b>",
            "id": "1e9c16ca4b3087aca384ae1bec491de2"
          },
          {
            "type": "html",
            "text": "\nAssume that Java had methods as first-class data types (like delegates in [[Csharp Language]] or function pointers in [[Cee Language]] or [[Cee Plus Plus]]). Assume further that you could declare a method in the local scope of another method. Then you could, for example, write the following.",
            "id": "38c025ac16f380a8676f6873d20b4e86"
          },
          {
            "type": "code",
            "text": " function createAdder(int n) {",
            "id": "bd2ec3754ea5ffeac6562c1581c6b1b2"
          },
          {
            "type": "code",
            "text": "  // define a method\n  int adder(int k) {\n  n = n + k;\n  return n;\n  }",
            "id": "36b92bd4fa1c52c3cea6cf96a66e02e5"
          },
          {
            "type": "code",
            "text": "  // return it as a result  \n  return adder;\n }",
            "id": "d0d1ae433596c024134afaac703e477d"
          },
          {
            "type": "html",
            "text": "Now you can call this method in order to yield an adder with a start value as follows...",
            "id": "23bfcec02d381625de7e36d479fad723"
          },
          {
            "type": "code",
            "text": " f = createAdder(5);",
            "id": "999c4bb2600e90332a97fac00a898485"
          },
          {
            "type": "html",
            "text": "...and afterwards call f repeatedly to increment the start value and return it...",
            "id": "c984b1af96f3b460bb255080d4868860"
          },
          {
            "type": "code",
            "text": " f(6) => yields 11 (5 + 6)\n f(7) => yields 18 (11 + 7)\n f(6) => yields 24 (18 + 6)",
            "id": "f6458d6d6ae00bede756603059bf75b9"
          },
          {
            "type": "html",
            "text": "...and so on. Another call to createAdder would return a fresh adder.",
            "id": "9c8a68d5faaa0d2f92b00b1f9164aead"
          },
          {
            "type": "code",
            "text": " f2 = createAdder(6);",
            "id": "d7f7170e8a0e07c56766d5d45916791c"
          },
          {
            "type": "code",
            "text": " f2(6) => yields 12 (6 + 6)\n f2(5) => yields 17 (12 + 5)",
            "id": "f79b9497c006cdb16d2febe91a09992e"
          },
          {
            "type": "html",
            "text": "...and so on.",
            "id": "bec22ac7b0a2f6cdbb09cd31684d03a9"
          },
          {
            "type": "html",
            "text": "\nWhat happens here in detail? We have already seen that the method createAdder defines the method adder inside of its scope. What's interesting here is that method adder refers to the parameter n that is passed to createAdder. When the method adder is returned as a result by createAdder, this binding to the parameter n is retained. The method adder is said to \"close over\" parameter n; it is said to be a \"closure\". The term \"lexical closure\" is used when a closure preserves lexical scoping, i.e. when the variable references cannot accidentally be overridden by other local definitions (see above). Since almost all languages with closures offer lexical closures by now, it's usually safe to use the terms \"closures\" and \"lexical closures\" synonymously.",
            "id": "8f4e888bbb316e836af5c8c0d673c16e"
          },
          {
            "type": "html",
            "text": "\nNote that the closure is retained even after createAdder has completed and the stack has no reference to n anymore. This is the very reason why closures and local method definitions have not been added to the Java programming language (and other C-like languages): because of their implementation schemes for local variables, these languages would not be able to guarantee safe access to arbitrary variables in the lexical scope in the case of closures.",
            "id": "ee958e56d7e862ecd3632bb5fb28d4ef"
          },
          {
            "type": "html",
            "text": "(Java's [[Inner Class]]es are a variation on the theme of closures. They are, in fact, able to access some variables in their lexical scope, but only if these variables are declared as final. Again, access to non-final variables would not be safe in the general case. The reason is that a local variable would not exist anymore after a stack frame has been cleared on exit of the respective method, so a write access to such a variable would fail. On the other hand, final variables can safely be copied around because they don't need to keep track of possible changes to their values - and this is exactly how Java implements closures over final variables: it just copies them to fields that are implicitly created for inner classes.)",
            "id": "474e386ed21e8f380eb6d1eb1fc7de4b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8e87ee8183331d0123a2ca32f50f82a8"
          },
          {
            "type": "html",
            "text": "<b>Summary</b>",
            "id": "7169351727cea942ac10058f92eb643b"
          },
          {
            "type": "html",
            "text": "\nIn the early days, lexical scoping was a distinguishing feature of [[Algol Language]] and its descendants, whereas early implementations of [[Lisp Language]] were purely dynamically scoped. [[Scheme Language]] has introduced lexical scoping and lexical closures to the Lisp world, and [[Common Lisp]] has incorporated these notions as defaults as well. Since there are cases where dynamic scoping is very useful, [[Common Lisp]] still additionally offers dynamic scoping for specially declared [[Special Variable]]s.",
            "id": "4b063ce81c6174c8a22964b9172f5096"
          },
          {
            "type": "html",
            "text": "<i>I don't know what other languages offer both lexical and dynamic scoping.</i>",
            "id": "298a6864fe5f9d7a50754f0386910995"
          },
          {
            "type": "html",
            "text": "\n[[Perl Language]] does; my() variables are lexicals, whereas local() variables are dynamically scoped.",
            "id": "124a45b7a0bcd864bbfd219b3cf15bd7"
          },
          {
            "type": "html",
            "text": "\n[[Io Language]] does; variables are dynamicly bound to their objects (not their calling context) by default, but blocks can be used for lexical scoping.",
            "id": "6d0c2919e149cc61796f581f92149262"
          },
          {
            "type": "html",
            "text": "\n[[Emacs Lisp]] supports it since version 24.",
            "id": "2a65838fdb7d6a641c7f5ddf9b51858e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "8e87ee8183331d0123a2ca32f50f82a8"
          },
          {
            "type": "html",
            "text": "See also [[Category Closure]], [[Lexical Closure]], [[What Is Closure]], [[Scoping Rules]]",
            "id": "aed0de1b0b7672e4b18b3fb24fd9a68a"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ScopeAndClosures c2.com]",
            "id": "50e636bc7596d0678e55e946f30a3354"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "language.sfw.c2.com",
      "date": 1674055383708
    }
  ]
}