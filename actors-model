{
  "title": "Actors Model",
  "story": [
    {
      "type": "html",
      "text": "A general model of concurrent computation developed by [[Carl Hewitt]], [[Henry Baker]] and [[Gul Agha]] (also \"actor model\"). Several [[Actor Languages]] are based on this model.",
      "id": "d2ecb7b954379e0f7cb49d133e67ec32"
    },
    {
      "type": "html",
      "text": "\nActors are autonomous and concurrent objects which execute asynchronously. The actors model provides flexible mechanisms for building parallel and distributed software systems.",
      "id": "0ff62e5d0bfdcdd025927e7fa9ae661b"
    },
    {
      "type": "html",
      "text": " \"Laws for Communicating Parallel Processes\", C. Hewitt et al, IFIP 77, pp. 987-992, N-H 1977",
      "id": "58f583fd59ee8f053c48fe327b4e5638"
    },
    {
      "type": "html",
      "text": " \"[[Actors And Continuous Functionals]]\", C. Hewitt, and H. Baker, MIT-LCS-TR-194, 1978 [http://www.lcs.mit.edu/publications/pubs/pdf/MIT-LCS-TR-194.pdf www.lcs.mit.edu]",
      "id": "8136b6c3fa458ec536d1a9c3cb1d9b25"
    },
    {
      "type": "html",
      "text": " [[Agha Actors Book]]",
      "id": "d59d7e0709df61cb0717f1dcb828f80f"
    },
    {
      "type": "html",
      "text": "\nThe actors model is closely related to the [[Object Capability Model]] - the locality laws defined in, e.g. \"Actors and Continuous Functionals\", correspond directly to some of the requirements for object capabilities. (This does not necessarily mean that all actor languages are capability secure, but <i>pure</i> actor languages necessarily are.) This may help to revive interest in the actors model in the security community. The connection was recognised in the acknowledgements at the end of \"Actors and Continuous Functionals\":",
      "id": "aced8ed5ccbf0b6dcc8c630f2e1489ea"
    },
    {
      "type": "html",
      "text": "<i>The design of Smalltalk built on the class instance distinction of Simula, the separation of goal language from method language in Planner, the control ideas in David Fisher's thesis, and [[Seymour Papert]]'s \"little person\" model of computation. We </i>[i.e. Baker and Hewitt]<i> have worked to construct a theoretical model that encompasses these ideas in addition to similar abstractions which have been developed in lambda calculus languages and for operating systems such as domains of protection and capabilities.</i>",
      "id": "678f040cfeef778ed3e3a4de5b8b41c7"
    },
    {
      "type": "html",
      "text": "\nThere are lists of on-line papers about the actors model and languages at:",
      "id": "92e306d2c9fcbd271c51a9ef5df5de73"
    },
    {
      "type": "html",
      "text": " [http://www.erights.org/history/actors.html www.erights.org]",
      "id": "fba40e10fcfa8c59ffa584d9d299c302"
    },
    {
      "type": "html",
      "text": " [http://osl.cs.uiuc.edu/ osl.cs.uiuc.edu]",
      "id": "9fe03da4b2991b7c0e1194ff124a35ad"
    },
    {
      "type": "html",
      "text": " [http://www.cap-lore.com/Languages/Actors.html www.cap-lore.com]",
      "id": "a29418d296355ed99fae243efd46a0c5"
    },
    {
      "type": "html",
      "text": " [http://del.icio.us/darius/actors del.icio.us]",
      "id": "97df331504a4aacb174a5236ca38c2f5"
    },
    {
      "type": "html",
      "text": "\nThe corresponding page on the TUNES Wiki is [http://cliki.tunes.org/Actor cliki.tunes.org] .",
      "id": "27fb5a1b0af9978d39f8cd71ba23b3ca"
    },
    {
      "type": "html",
      "text": "\nStrictly speaking, an \"actor\" refers to a particular \"behaviour\" or state. When the actor with a given name specifies its successor behaviour, the name is bound to a <i>new</i> actor with that behaviour (just like processes in CSP). However, it is common to use the term \"actor\" loosely as if it referred to a single entity with behaviour that changes over time. The discussion below does this.",
      "id": "2b1d6815531aa007fe64a1d596b5177a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "The main differences between the [[Actors Model]] and [[Communicating Sequential Processes]] are:",
      "id": "e19ef70bdfff93ec25c6b0bbfc07ff98"
    },
    {
      "type": "html",
      "text": " Actors can receive messages from any sender; CSP processes must explicitly name the sending process.",
      "id": "fd9d337e5450a3ba508d4e62388b1f4e"
    },
    {
      "type": "html",
      "text": " Not strictly true. CSP processes must explicitly name the <i>channel</i> over which they are sending (or receiving) a message. That channel may be used by more than sending process. Modern implementations of CSP-based languages, such as occam-pi and JCSP, support the passing of channel ends from process to process as well.",
      "id": "9c037e9c333bc6d8e0f9bf7dc3e328e8"
    },
    {
      "type": "html",
      "text": " The actor model requires fairness - no message can be delayed indefinitely. This simplifies reasoning about systems of composed actors (although it complicates the definition of actor semantics - but that is arguably a good trade-off).",
      "id": "c59e96b9c96cd2d30b3de39d08443cf8"
    },
    {
      "type": "html",
      "text": " In CSP the sender is delayed until it synchronizes with the receiver. An actor, OTOH, can proceed immediately to its next behaviour/state after sending one or more messages (although it often waits for a reply).",
      "id": "1a0a7a67db6e1b375c37e5af44cb3217"
    },
    {
      "type": "html",
      "text": " Ok, this is strictly true. But not really relevant. It is fairly easy to set up (overwriting) buffers between CSP processes in order to prevent blocking on a message. Again, implementations such as JCSP support this directly with language constructs that provide such buffering.",
      "id": "76f844e69ebf62ce8d95cfcd0d438f3a"
    },
    {
      "type": "html",
      "text": " Yes, it is possible to simulate asynchronous message send on top of synchronous send, and vice versa. However, the different primitive operations are not equally easy to implement:<br>a CSP unbuffered synchronous send is very simple on an SMP, but only an Actor buffered asynchronous send is a sensible distributed system primitive.",
      "id": "158b364f006a7ce2aa5c424d67b1a50c"
    },
    {
      "type": "html",
      "text": "\nThere is a more in-depth comparison with CSP in \"Foundations of Actor Semantics\" (available from\n[http://www.erights.org/history/actors.html www.erights.org]).",
      "id": "c7e031111263aa73e9234c282a99487b"
    },
    {
      "type": "html",
      "text": "<i>Note that the comparison in \"Foundations of Actor Semantics\" deasl with Hoare's original (1978) presentation of CSP, which was then simply a pseudo-programming language. As a result, the comparison doesn't touch on any of the last ~30 years worth of theoretical work on CSP and its associated semantic models. The comparison is of historical interest, but not really relevant to modern CSP.</i>",
      "id": "cbcf8eaae1b39da1667c9b1afde3469c"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "There are close parallels between [[Flow Based Programming]] (FBP) and Actors. The discussion that led to the summary below is at [[Actors And Flow Based Programming Discussion]].",
      "id": "01f164e66627123d342be982d6505883"
    },
    {
      "type": "html",
      "text": "[We'll use \"process\" to refer to either an FBP process, or a \"actor configuration\". The latter is a collection of actors, some of which may have names that are made visible outside the configuration. Actors within a configuration typically share part of their state via [[Lexical Scoping]].]",
      "id": "7edf638c7549d40c049f73cd21408471"
    },
    {
      "type": "html",
      "text": "\nSimilarities:",
      "id": "95779c039d4b2111591cbf3eafc667b7"
    },
    {
      "type": "html",
      "text": " Communication between processes is by way of [[Information Packet]]s/messages, travelling across buffered connections. (In FBP use of [[Bounded Buffer]]s is a primitive part of the model; in actors buffering is implemented by serializers.)",
      "id": "c8033b62687d7df3ec48a1d73246a709"
    },
    {
      "type": "html",
      "text": " A process cannot be affected except by way of an incoming [[Information Packet]]/message. <i>[In the [FBP] implementation with which we have most experience, we did provide a \"named global\" facility, but because of the asynchronism of the system, this could only safely be used for read-only data.  In practice it was mostly used for shared reference tables. Besides we told our programmers that [[Global Variables Are Bad]]!]</i>",
      "id": "d5769e62aa9cadedccdb5e160c27c6ff"
    },
    {
      "type": "html",
      "text": " A process can only receive IPs/messages from a limited set of other processes. (The nature of the limitation is different; see below.)",
      "id": "f9986a8585c0e8924ab7975b71ce8e89"
    },
    {
      "type": "html",
      "text": " Actor names are [[First Class]]; FBP (process, input port name) pairs are also [[First Class]]. <i>[Port names (originally numbers) are [[First Class]]; I am not sure if process names are.  In the static definition case, processes need not even know their own names (the only use that I can think of might be for tracing for debugging).  In the dynamic definition case, it might be useful to have process names be [[First Class]] also.]</i>",
      "id": "e33e1bdeabae0c8804fe6888d4b62dc5"
    },
    {
      "type": "html",
      "text": " Both models introduce nondeterminism as the result of nondeterministic arrival ordering of messages/IPs.",
      "id": "76e02636309a8dfe407bc8e24f3ba434"
    },
    {
      "type": "html",
      "text": " In both models, a collection of connected processes can be viewed as a larger process. I.e. the notions of FBP process or actor configuration are compositional.",
      "id": "45f6b96e92976c330f07ab1e07486729"
    },
    {
      "type": "html",
      "text": " FBP processes can have multiple named input ports. An actor configuration can contain multiple actors whose names are made visible outside the configuration; these serve the same function as input ports.",
      "id": "f54b22ce482d9872097c7e1663b54703"
    },
    {
      "type": "html",
      "text": " Use of shared state is discouraged -- although neither model prevents it.",
      "id": "f44524aeb3a93247214359e2cf65f222"
    },
    {
      "type": "html",
      "text": " Use of pure functional objects is encouraged -- although neither model requires it.",
      "id": "3d4adbee0ff737ed64ccaa16c4d71de4"
    },
    {
      "type": "html",
      "text": "\nDifferences:",
      "id": "946cf834b9bf997a822ad34b7e30851d"
    },
    {
      "type": "html",
      "text": " FBP communication networks are specified by a network description that is given in advance, and is <i>usually</i> static (but see the description of <i>dynamic subnets</i> in [http://www.jpaulmorrison.com/fbp/compos.htm www.jpaulmorrison.com] ).",
      "id": "8c9996c659ab81d4b63c1db40a553cd1"
    },
    {
      "type": "html",
      "text": " FBP does not model the internals of processes, only the communication between them. Actors models both (the internal computation of any particular actor configuration can of course be ignored). This reflects the origins of FBP as a programming paradigm, and actors as a foundational model of computation.",
      "id": "e4302172d02b3a0997e9070cccdbb92d"
    },
    {
      "type": "html",
      "text": " An actor can only send messages to its acquaintances, and there are [[Laws Of Locality]], given in <i>\"Actors and Continuous Functionals\"</i>, that describe how the graph of acquaintances can evolve (these laws can be interpreted as applying either between actors or between actor configurations). Just as in the [[Object Capability Model]], \"only connectivity begets connectivity\". The FBP model does not require any equivalent to these laws, and most FBP systems have been built on top of languages that did not enforce them. In FBP, the main limitations on communication come from the fact that connections must be specified in the network description.",
      "id": "f05cd5b128dad0f9efbda54013d8a967"
    },
    {
      "type": "html",
      "text": " FBP processes also have multiple named output ports. In the [[Actors Model]] there are no output ports as such; each actor can send a message to any of its acquaintances at any time. (However, a system might use the convention that the actor names corresponding to outputs are passed in a standardized way on creating an actor configuration, and a network visualizer could recognize this convention.)",
      "id": "7c9bccb142501f589c2e8da1a7a7e1d3"
    },
    {
      "type": "html",
      "text": " In the [[Actors Model]], messages sent to the same actor name by different senders are guaranteed to be merged fairly. In FBP, the corresponding situation where more than one output port is connected to an input port (see figure 8.12 of [http://www.jpaulmorrison.com/fbp/simpapp2.htm www.jpaulmorrison.com] ) does not <i>require</i> a fair merge, although it might be fair in a particular implementation. In this respect FBP is more similar to CSP.",
      "id": "bc968ff13ad961c560bbfd4f94c53518"
    },
    {
      "type": "html",
      "text": " Each connection in FBP is one-way. In actors most messages include a continuation that allows a reply to be sent; in FBP this would require a separate return channel, and there would be no direct link (except for sequencing) between requests and replies.",
      "id": "cd99039c3362d6b948e7fd0f227a7621"
    },
    {
      "type": "html",
      "text": " The [[Actors Model]] requires automatic memory management; FBP does not. There are restrictions on \"ownership\" of FBP [[Information Packet]]s, apparently intended to allow reference counting (see [http://www.jpaulmorrison.com/fbp/tree.htm www.jpaulmorrison.com] ). An implementation of FBP on a garbage-collected platform could presumably relax these restrictions. See also [http://www.jpaulmorrison.com/cgi-bin/wiki.pl?TreeIP www.jpaulmorrison.com] .",
      "id": "3eaddb396c3ff4e18bc3ebd2b33d4f20"
    },
    {
      "type": "html",
      "text": " [[Actors Model]] messages can reference arbitrary graphs of actors; FBP [[Information Packet]]s can only be trees.",
      "id": "adb1656266ed9ce6da03ba7a8a6299f4"
    },
    {
      "type": "html",
      "text": " There is no equivalent to \"bracketed\" IPs (see the end of [http://www.jpaulmorrison.com/fbp/compos.htm www.jpaulmorrison.com] ) in actors. There is nothing preventing implementing this as a higher-level protocol, but it would be more natural to use messages that reference a list object/actor instead.",
      "id": "f58a4b935146f2c3aac819579656fe59"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "Another question about FBP: is the flow of [[Information Packet]]s always a \"push\" (i.e. packets are sent as soon as they are available, up to the capacity of the [[Bounded Buffer]]), or can packets be \"pulled\" (i.e. a consumer can say that it only needs a given number of packets)? It is obviously possible to do the latter by adding a back-channel, but is it possible without?",
      "id": "711a5e93f838ac0dc8649ba31d2026d8"
    },
    {
      "type": "html",
      "text": "<i>Yes, it's always \"push\".  However, I suppose the receiver can decide how many IPs to receive by \"receiving\" a certain number of IPs, and then by refusing to receive any more, which will eventually fill up the [[Bounded Buffer]], which will in turn suspend the sender.  Not very nice - similar behaviour is often a cause of deadlocks.  OTOH It is the mechanism that lets you process \"infinite\" data streams with a finite amount of resources. (On rereading my sentence, I had a change of heart!)</i>",
      "id": "54b4451e9c732130551cd0c6e021019e"
    },
    {
      "type": "html",
      "text": "\nHmm -- it seems like support for demand-driven dataflow would be a useful extension to FBP, then. See [[Vpl Language]] for example.",
      "id": "4a6f9467478779459c15769a76d0ceac"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "<i>Excellent job of refactoring, David!  I have some minor quibbles, which I will add here as I digest what you have written.  One area of perplexity is what an actor-based Collate would look like in actual code - wouldn't you have to synchronize the cooperating actors somehow?</i> --[[Paul Morrison]]",
      "id": "9b0c6daa0fe5b81dad1b2795442b48a2"
    },
    {
      "type": "html",
      "text": "\nYes, you do have to synchronize the cooperating actors. The most straightforward way to do this is to have one controlling actor representing the Collate itself, and one \"subactor\" per input stream. In most actor languages, messages from the subactors to the controlling actor would be automatically serialized by default.",
      "id": "09fec3ed58345fe913054ebb291793f7"
    },
    {
      "type": "html",
      "text": "\nAlternatively, some hybrid [[Actor Languages]] (e.g. [[Ee Language]]) have the concept of a \"vat\", which is basically a thread shared by several actors. In that case putting the actors that make up the Collate in the same vat would automatically synchronize them.",
      "id": "26e5bd856478a954e8804cf6c3788193"
    },
    {
      "type": "html",
      "text": "<i>Ports are key to the concept of [[Configurable Modularity]], which offers the very real prospect in the future of being able to build quite interesting applications without writing a line of code - just specify the network and parameters, where \"parameters\" can be expanded to include \"mini-languages\" - see the discussion in [http://www.jpaulmorrison.com/fbp/minilang.htm www.jpaulmorrison.com]. Ports are the way the inside of a process communicates with the network definition.  Suppose you have multiple instances of a Reader process: each instance will usually have its OUT port feeding a different [[Bounded Buffer]] connection.  Using the concept of Port, the code for a basic Collate is so stunningly simple that I really fail to see what advantage one would gain by coding it using multiple actors, especially if actors don't support ports.  And anyway, the FBP orientation towards black-box modules surely makes it even less important what language a module is written in.  Maybe you can set me straight, David!</i>",
      "id": "0055bb61c069f3eb0d620232b04150f6"
    },
    {
      "type": "html",
      "text": "\nThe black-box modules in the [[Actors Model]] are actor configurations, not individual actors (see [http://www.cypherpunks.to/erights/history/actors/96jfp.pdf www.cypherpunks.to] for a formal treatment). I've changed the summary above to reflect this.",
      "id": "9b27ba2787f80675f5d8ef2c2662a553"
    },
    {
      "type": "html",
      "text": "\nBecause the [[Actors Model]] is intended as a foundational model of computation, its most basic concept -- an actor -- is deliberately as simple as possible. In a <i>pure</i> actor language, the sublanguage used to specify an actor behaviour is not even [[Turing Complete]]; the model becomes [[Turing Complete]] only when the behaviours change over time and multiple actors (or an actor sending messages to itself) are considered. Writing a program directly in terms of the pure [[Actors Model]] would be like writing it directly in the [[Lambda Calculus]] using [[Continuation Passing Style]]; it's important to know that it can be done, that high level programs have a well-defined translation to this form, and that's about all.",
      "id": "595be747993fce8f8397184618c0b56d"
    },
    {
      "type": "html",
      "text": "<i>As a humble programmer, I keep puzzling over the last sentence: *why* is it important to know it can be done?  I know it is important to know that matter is made of quarks and leptons (or whatever), but how does this apply to the world of computing?  Could someone try to articulate this, or point us at a page that does?</i>",
      "id": "af74007610911dea22a5f8f561089f05"
    },
    {
      "type": "html",
      "text": " I guess it's important as a proof you can solve anything with it you could with other [[Turing Complete]] languges, but is it so? [[Cee Plus Plus Templates]] are [[Turing Complete]] (or so I heard, if not replace with [[Scheme Macros]]), but wouldn't they have to expand to an infinite source to model an infinite loop? Then they would never actually run. Maybe stating something is [[Turing Complete]] or [[Lambda Calculus Equivalent]] gives it some kind of aura.",
      "id": "692ed19589eb61060ae7a6ac394d052c"
    },
    {
      "type": "html",
      "text": " [C++ templates are Turing complete. The expansion to infinite source is its \"infinite loop\".]",
      "id": "8fb019e92f1463557bddbe1549e3999e"
    },
    {
      "type": "html",
      "text": "\nPractical [[Actor Languages]], OTOH, always include various abstractions above the basic model -- serializers, synchronous calls, vats, message queues, promises, sponsors, etc. The fact that you're creating multiple actors in a situation where an FBP network would have multiple ports is a detail that may be exposed in some actor languages, and hidden in others. The <i>model</i> actually says very little about how to design a high-level actor language; basically it only says that all communication must be by a message passing mechanism that satisfies certain laws. So the code in a particular actor language might look identical to how it would look in an FBP system, including the possibility of using graphical network diagrams (something like [[Gee Language]], for example) or direct interaction to connect processes.",
      "id": "3b277f7e6efccc71dda661282ff71e38"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "Because FBP [[Bounded Buffer]]s have finite capacity, [the property that \"no message can be delayed indefinitely\"] above is probably true in FBP.  I have seen a paper stating that this prevents livelock.",
      "id": "c3fba9e3239baec8f3add3ace7d1d424"
    },
    {
      "type": "html",
      "text": "<i>[http://www.jpaulmorrison.com/fbp/deadlock.htm www.jpaulmorrison.com] says: </i>\"Kuse et al. (1986) proved that, although a network with fixed capacity connections (like the ones in FBP) can suffer from deadlock, it can never suffer from livelock.\"<i> The reference is to K. Kuse, M. Sassa, I. Nakata (1986), </i>\"Modelling and Analysis of Concurrent Processes Connected by Streams\"<i>, Journal of Information Processing, Vol. 9, No. 3, abstract at [http://www.ipsj.or.jp/members/JInfP/Eng/0903/article005.html www.ipsj.or.jp] .</i>",
      "id": "bd15f8d13fc5a4fde9bd1149ea11b185"
    },
    {
      "type": "html",
      "text": "<i>The abstract of this paper says that \"A network in this class has some restrictions, for example, a stream must have only one producer and one consumer.\" This is not usually the case for the [[Actors Model]].</i>",
      "id": "6500da1ee06c8cb8d94af9394cf7e63e"
    },
    {
      "type": "html",
      "text": "\nIt is possible they are making a distinction between \"streams\" and \"channels\".  Here is part of a paragraph from [http://www.jpaulmorrison.com/fbp/cognates.htm www.jpaulmorrison.com] : \"In A'UM [K. Yoshida and T. Chikayama (1988)] and some of the other systems related to it, a distinction is made between \"streams\" and \"channels\". ... in A'UM, a \"stream\" runs from one source to one destination, whereas a \"channel\" may contain more than one stream, coming from different sources: the items in each stream must stay in sequence relative to each other, but the streams in a channel are not constrained relative to each other. In A'UM only one reader is allowed for a channel, while in Tribble's paper on channels (Tribble et al. 1987), he allows multiple readers for a channel. The authors of A'UM feel that not allowing multiple readers makes their semantics sounder and the implementation simpler.\" FBP also does not allow multiple readers. --pm",
      "id": "04e0cbbaa5cf944c146b51dac958eddd"
    },
    {
      "type": "html",
      "text": "<i>In actors you could easily construct a stream that had multiple readers, by reifying the stream as an actor. For normal messages, though, an actor receives some interleaving (fair merge) of all the messages sent to it.</i>",
      "id": "a0e0d8dede17da953292031aac58b3f6"
    },
    {
      "type": "html",
      "text": "<i>In FBP it looks as though you could also construct a stream with multiple readers, using something similar to the Collate construct but in reverse, with one input port per reader to request the next item, and one output port per reader to receive the item. It would be more complicated than in actors because FBP has no built-in convention for reply messages.</i>",
      "id": "2612d4530f6dfe4fb0669cc257a19724"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "About the fairness property:",
      "id": "5f3c71c72e1488ef78f4918d8b594ae4"
    },
    {
      "type": "html",
      "text": "<i>The fairness guarantee applies to directly sent messages. Because messages are first-class in the [[Actors Model]], it is possible for an actor to be wrapped by a \"serializer\" or \"guardian\", which can filter, delay or reorder individual messages (this is how an actor would avoid receiving a message when it is in an inconsistent state). A serializer may not pass on a particular message, but this does not contradict fairness, because it received the message with only finite delay. Serializers were a feature of the first actor languages (see \"Issues in the Design and Implementation of Act2\").</i>",
      "id": "34c00a7402ed568a98ebefaf3ab02aac"
    },
    {
      "type": "html",
      "text": "<i>A [[Bounded Buffer]] in FBP corresponds directly to a serializer with a bounded message queue. Suppose, for example, that we have two actors A and B where A is sending messages to B's serializer, and is expecting a reply to each message. Each message from A to B's serializer includes a unique continuation. After each send, A will go into a state where it is waiting to be sent the reply via that continuation. (A would have its own serializer which delays messages directed to A while it is waiting.) The fact that A waits for a response ensures that it will not try to send so many messages that B cannot keep up.</i>",
      "id": "6dd6d6e6db58a1da3bc669d9370ace4e"
    },
    {
      "type": "html",
      "text": "<i>The fact that it is serializers that store any \"delayed\" messages means that the actor system itself can be implemented with only finite memory for pending messages. However, this ducks the issue of how a serializer should deal with \"message overruns\", where other actors try to send an unbounded number of messages to it without waiting for anything. This potential problem is inherent to one-way buffered messaging, and it can be solved by using higher-level abstractions that provide flow control or backpressure (to attempt to prevent the problem), and that account for memory usage (to deal with the effects if prevention fails). The nice thing about this approach is that you're not limited to any fixed set of abstractions.</i>",
      "id": "e201bc6b89998a0c356cedea0f2f8ce1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "From [http://www.jpaulmorrison.com/fbp/cognates.htm www.jpaulmorrison.com] :",
      "id": "58bd879d2d75a8cabe3a8815b1e35bc2"
    },
    {
      "type": "html",
      "text": "<i>Hewitt's Actors take processes down to the finest possible granularity: </i>\"Hewitt declared\"<i>, to quote Robin Milner (1993), </i>\"that a value, an operator on values, and a process should all be the same kind of thing: an actor.\"<i> This approach has considerable theoretical attractiveness, but in my view, to be practical, it basically has to be implemented as hardware, rather than software. There are also of course a number of projects growing out of Hewitt's Actors, which also seem to be on a converging path with all the other work (albeit at the more granular end of the scale), e.g. Agha's COOP (1990).</i>",
      "id": "c6eeb698ddd5d7c5214568fe0364d92a"
    },
    {
      "type": "html",
      "text": "\nThe [[Actors Model]] doesn't have to be implemented in hardware to be practical. Although there was a project to build an actor-oriented machine called the \"Apiary\", AFAIK this was never completed, and so all working implementations of the [[Actors Model]] have been software-based. In terms of sequential computation, the performance cost of the \"[[Everything Isa]]n actor\" approach is similar to the cost of \"[[Everything Isa]]n object\" in languages like Smalltalk. In terms of concurrency, [[Erlang Language]], [[Oz Language]], [[Stackless Python]], etc. demonstrate that user-level threading implementations can easily scale to large numbers (100s of 1000s?) of active threads. Since actors only perform work in response to messages, the number of actors can be much greater again than the number of threads.",
      "id": "e3b7681ab1f70e6e496fbb8cc0751287"
    },
    {
      "type": "html",
      "text": "<i>You touch on a key concern of mine: how would these systems perform processing millions of transactions a day?  I relate to the goal of [[Bridging The Gap]] between the designer's thought and the implementation, but if a program is going to be used for productive work in a large company, it also has to be able to handle (very) large volumes.  This was the thought underlying my comment on hardware. BTW I'm not too excited about the overhead of \"[[Everything Isa]]n object\" either!</i> --[[Paul Morrison]]",
      "id": "730b180c7c4d6555ae7a2519f269ef63"
    },
    {
      "type": "html",
      "text": "\n1 million transactions per day is ~12 transactions per second on average. Suppose it is 100 transactions per second peak. On a 1 GHz processor, that is 10 million cycles to play with for each transaction. Assuming adequate bandwidth and that each transaction is not unreasonably computationally intensive, it would actually be quite difficult to implement a system inefficiently enough that it cannot keep up with this load -- <i>unless</i> the underlying operating system gets in the way.",
      "id": "9a09397b4a517b7b6ab31cb70030c935"
    },
    {
      "type": "html",
      "text": "\nReliability is likely to be <i>much</i> more of an issue for this kind of system than raw performance. After all, we now have supercomputers on our desks. It is only the inefficiency of certain operating system platforms that obscures that fact. -- [[David Sarah Hopwood]]",
      "id": "8d091563f1dc541305a6016006501fd1"
    },
    {
      "type": "html",
      "text": "<i>That makes sense to me.  And it means that we can actually spend quite a lot of CPU time to make systems more reliable, and, I would add, more maintainable.  I have often been struck by how so much of our research goes into better ways to create new code, rather than ways to make code that is more reusable.  I think it was [[Ew Dijkstra]] who said code should be a cost item, not a measure of productivity.</i>",
      "id": "58b2b78df1abd2c981b8cf28d7f70444"
    },
    {
      "type": "html",
      "text": "\nI couldn't agree more -- see my home page when it's finished. -- [[David Sarah Hopwood]]",
      "id": "b0342591322ee24a49b2c1619583755d"
    },
    {
      "type": "html",
      "text": "<i>Still waiting....</i> --[[Paul Morrison]]",
      "id": "d6439dd70794ee74e5ef1d063e413ec0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "I have felt for a while that this architecture probably has considerable relevance for the security world - anyone want to run with this?",
      "id": "6725ff1712bdd6457a054a6b2e4f518e"
    },
    {
      "type": "html",
      "text": "<i>The [[Actors Model]] is the basis of some [[Object Capability Language]]s including [[Ee Language]]. This is a very active area of research. I'm currently working on an actor-based multi-language operating system -- I'll add references here when the design is closer to being cooked. -- [[David Sarah Hopwood]]</i>",
      "id": "8b3ee21f1a666973ea7647dad924ee10"
    },
    {
      "type": "html",
      "text": "\nIn case that's not explicit enough, capability systems are a ... fundamental or foundational model of\nsecurity.  The \"acquaintance\" that one actor has with another is just like a capability.  A capability\nis a one-way channel that one actor (or process or user) has to another, and in these\nsystems, sending requests through capabilities is the only way of doing things.  A capability can't\nbe \"forged\"--that is, you can't create one by casting from a number or guessing an address, you can\nonly acquire one at your creation time or passed to you in a message.  Security is achieved by\ncontrolling who and what processes are given capabilities to access what resources, other processes,\netc.  Authorities for different operations or views on the same thing, e.g. read vs. write, can be\nset up as separate capabilities. --[[Steve Witham]]",
      "id": "1d5233e86449274b199016bdc795b8c4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "Comparison of the [[Actors Model]] with the [[Join Calculus]]:",
      "id": "1d9b27c056dcd673e652650ca66e01c0"
    },
    {
      "type": "html",
      "text": "\nThis is based on the tutorial at [http://pauillac.inria.fr/join/manual/manual002.html pauillac.inria.fr] , and the paper \"The Reflexive CHAM and the join-calculus\", which is at [http://research.microsoft.com/~fournet/biblio.htm research.microsoft.com]",
      "id": "e40530970f9afcc7786f681b9b46f2b7"
    },
    {
      "type": "html",
      "text": "(you may need to use [[Microsoft Internet Explorer]] and/or switch off pop-up blocking to access the latter.)",
      "id": "b36c9a6966e3761173e4983ecf2f416a"
    },
    {
      "type": "html",
      "text": " Channels in the [[Join Calculus]] are equivalent to actor names; both are [[First Class]].",
      "id": "ed56a311a2004d570cf7f47125ec746d"
    },
    {
      "type": "html",
      "text": " Both are message-passing models, with arrival order nondeterminism. It is not clear whether the [[Join Calculus]] requires finite delay.",
      "id": "abc96764059160cc7bff11908c89383d"
    },
    {
      "type": "html",
      "text": " Both are fundamentally based on [[Continuation Passing Style]], with most practical languages that follow each model providing sequential constructs via CPS conversion. (This accounts for the fact that the tutorial distinguishes between \"expressions\" and \"processes\", whereas the [[Actors Model]] has only \"behaviours\" -- after CPS conversion the [[Join Calculus]] also only has one kind of behaviour.)",
      "id": "845e8b087d6691a360a3f5b13a0acf47"
    },
    {
      "type": "html",
      "text": " In both models, a process can send a message to another process if-and-only-if it \"knows\" the latter's channel/name. A new process' channel/name is only initially known by its creator.",
      "id": "21ffcece6a1b6df8c37f6f8924685a85"
    },
    {
      "type": "html",
      "text": " Ordinary (non-join) patterns correspond straightforwardly to actor definitions (with the obvious translation of the 'reply' construct to [[Continuation Passing Style]]).",
      "id": "4e5f8860350f05abefdd2fc08ed092a8"
    },
    {
      "type": "html",
      "text": " Join patterns are primitive in the [[Join Calculus]], but not primitive in actors. It would be easy to support join patterns in an actor language, by representing each subpattern as an actor and having each wait until all subpatterns are triggered.",
      "id": "a9069ee611b85f034256e6741a412fe1"
    },
    {
      "type": "html",
      "text": " The approach to modelling objects described in the tutorial (using lexical scoping to hide internal state) is similar to what would be used in actors. In actors you would normally pattern match on the method name rather than returning a tuple of functions, but you could do that in the [[Join Calculus]] as well.",
      "id": "ab0f20548be9b4e1f6c9678a2e1087fd"
    },
    {
      "type": "html",
      "text": "\nSo, for all intents and purposes, the [[Join Calculus]] and the [[Actors Model]] are almost identical. \"The Reflexive CHAM and the join-calculus\" describes the [[Join Calculus]] as a modification of the [[Pi Calculus]] and the [[Chemical Abstract Machine]], but these modifications are essentially equivalent to enforcing the actor [[Laws Of Locality]], and changing the semantics of channels to follow that of actor message passing.",
      "id": "c0a94e83d7603730dd358c3126833f8d"
    },
    {
      "type": "html",
      "text": "\nThis would be all very well if the [[Join Calculus]] had been developed in the late 1970s or 1980s. Given that it was developed in 1995, you have to wonder why [[Cedric Fournet]] and [[Georges Gonthier]] didn't simply publish a paper relating the [[Pi Calculus]] to the [[Actors Model]], rather than reinventing the wheel with an entirely new terminology. The only new construct in the [[Join Calculus]] is join patterns, and those are trivially simulatable by actors. \"The Reflexive CHAM and the join-calculus\" does reference two papers on actors, but little or no research seems to have been put into any comparison. Also see [http://cliki.tunes.org/Actor cliki.tunes.org] .",
      "id": "a86f0b703b7e41b1af7481461d5e3a16"
    },
    {
      "type": "html",
      "text": "\nOh well -- at least they <i>are</i> promoting the right concurrency model, even if they had to reinvent it 20 years after the fact. -- [[David Sarah Hopwood]]",
      "id": "c3e946158cbdebff30ddb4a8cb463a9a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "\nThis [[Actors Model]] does allow a very intuitive view of the universe in which processes run. Something like [[Processes In The Ether]] or [[Programmable Logic Controller]]s on a factory backbone, it even makes the factory floor model easily conceivable as a model for a robot's software. I think its view of inter-process communication offers a clear and simple single practical view to the designer. All processes are the result of the [[Designated Behaviour]] of another process - invoking a process is an assertion that that process will follow its [[Designated Behaviour]]. I think [[Actors Model]] and [[Flow Based Programming]] are complementary - each Actor implemented using FBP. -- [[Peter Lynch]]",
      "id": "f9b3c8de900d72a504cf94f527c0ab08"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "<b>Some [[Actors Model]] Skepticism</b>",
      "id": "571dfed916c6086a2a5b9c1df1631171"
    },
    {
      "type": "html",
      "text": "\n[[Actors Model]] in its base form has some nice, simple properties that make it easy to reason about and implement. But, after having pursued it for a while based on its being inherently distributed and concurrent, I've grown quite skeptical about its application in practice. Among the problems:",
      "id": "ee9be3f693c759d10a0be285ea7b9860"
    },
    {
      "type": "html",
      "text": " message delivery: [[Actors Model]] makes an assumption that messages will eventually reach their destination. In any open distributed system, this can't be guaranteed. In part, we must deal with the fact that distributed garbage collection in an open system is undecidable, and so actors will need to be deleted heuristically or explicitly when it seems unlikely they will see further use. That said, the [[Actors Model]] is still one of the better models out there for handling dropped messages, since they simply become messages that aren't delivered <i>yet</i>. ",
      "id": "a89756f4b3aab7c25f7f1a079018af1d"
    },
    {
      "type": "html",
      "text": " coordination: 'Pure' [[Actors Model]] coordination is not simple. To the contrary, it is very invasive of actors, often requiring a complex dance of creating new actors to receive messages and process them in a sort of [[Continuation Passing Style]], and yet more actors to operate as serializers. As noted above, <i>\"Practical [[Actor Languages]], OTOH, always include various abstractions above the basic model -- serializers, synchronous calls, vats, message queues, promises, sponsors, etc.\"</i>. And, even with these abstractions, coordination with the [[Actors Model]] is not simple... because now you need to use these abstractions. As mentioned regarding [[Flow Based Programming]] above, some sort of external coordination (both when creating new services and when integrating with pre-existing services) seems far more promising.",
      "id": "fc4081b4fd6463989bd0d0afd9edb770"
    },
    {
      "type": "html",
      "text": " synchronous communications, such as [[Send Receive Reply]], break [[Actors Model]] - the properties that hold in [[Actors Model]] cannot be claimed to hold in a system with synchronous communications. For example, one gets deadlock for free!  Something 'sort of like' synchronous communications is to send messages with an actor identifier to which to send the reply message, which will be further processed in a [[Continuation Passing Style]]. However, the similarities break down if the actor requesting the reply intends to update its own behavior for processing other messages. This behavior can be handled by ever more state and vocabulary within actors (actors keep state regarding which messages have been sent, which are being waited upon, which are waiting for processing until after receiving a message, etc.) but this makes for heavyweight actors and more [[Cross Cutting Concern]]s that, like other forms of coordination, interferes with 'domain' actors. I've developed [[Transactional Actor Model]] to aide with certain forms of synchronization, but have yet to explore how much it helps in enough use-cases to deem it a solution.",
      "id": "0a75176a076ce62c4994f47deda25122"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "See also: [[Actor Languages]], [[Object Capability Model]], [[Transactional Actor Model]], [[Actor Vs Agent]]",
      "id": "02b0226d8997218ee40cf21ec14fe1bd"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "b60ac6c3f83a25312b07199f0c062c30"
    },
    {
      "type": "html",
      "text": "[[Category Concurrency]] [[Category Comparisons]] [[Category Models]]",
      "id": "ca4242fe0381bf1d8ffa871abebe1269"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?ActorsModel c2.com]",
      "id": "32f2bc8fbacdef0e461382162c109139"
    }
  ],
  "journal": [
    {
      "date": 1417692165000,
      "id": "bdf48315cc76b8508aff65df4768682d",
      "type": "create",
      "item": {
        "title": "Actors Model",
        "story": [
          {
            "type": "html",
            "text": "A general model of concurrent computation developed by [[Carl Hewitt]], [[Henry Baker]] and [[Gul Agha]] (also \"actor model\"). Several [[Actor Languages]] are based on this model.",
            "id": "d2ecb7b954379e0f7cb49d133e67ec32"
          },
          {
            "type": "html",
            "text": "\nActors are autonomous and concurrent objects which execute asynchronously. The actors model provides flexible mechanisms for building parallel and distributed software systems.",
            "id": "0ff62e5d0bfdcdd025927e7fa9ae661b"
          },
          {
            "type": "html",
            "text": " \"Laws for Communicating Parallel Processes\", C. Hewitt et al, IFIP 77, pp. 987-992, N-H 1977",
            "id": "58f583fd59ee8f053c48fe327b4e5638"
          },
          {
            "type": "html",
            "text": " \"[[Actors And Continuous Functionals]]\", C. Hewitt, and H. Baker, MIT-LCS-TR-194, 1978 [http://www.lcs.mit.edu/publications/pubs/pdf/MIT-LCS-TR-194.pdf www.lcs.mit.edu]",
            "id": "8136b6c3fa458ec536d1a9c3cb1d9b25"
          },
          {
            "type": "html",
            "text": " [[Agha Actors Book]]",
            "id": "d59d7e0709df61cb0717f1dcb828f80f"
          },
          {
            "type": "html",
            "text": "\nThe actors model is closely related to the [[Object Capability Model]] - the locality laws defined in, e.g. \"Actors and Continuous Functionals\", correspond directly to some of the requirements for object capabilities. (This does not necessarily mean that all actor languages are capability secure, but <i>pure</i> actor languages necessarily are.) This may help to revive interest in the actors model in the security community. The connection was recognised in the acknowledgements at the end of \"Actors and Continuous Functionals\":",
            "id": "aced8ed5ccbf0b6dcc8c630f2e1489ea"
          },
          {
            "type": "html",
            "text": "<i>The design of Smalltalk built on the class instance distinction of Simula, the separation of goal language from method language in Planner, the control ideas in David Fisher's thesis, and [[Seymour Papert]]'s \"little person\" model of computation. We </i>[i.e. Baker and Hewitt]<i> have worked to construct a theoretical model that encompasses these ideas in addition to similar abstractions which have been developed in lambda calculus languages and for operating systems such as domains of protection and capabilities.</i>",
            "id": "678f040cfeef778ed3e3a4de5b8b41c7"
          },
          {
            "type": "html",
            "text": "\nThere are lists of on-line papers about the actors model and languages at:",
            "id": "92e306d2c9fcbd271c51a9ef5df5de73"
          },
          {
            "type": "html",
            "text": " [http://www.erights.org/history/actors.html www.erights.org]",
            "id": "fba40e10fcfa8c59ffa584d9d299c302"
          },
          {
            "type": "html",
            "text": " [http://osl.cs.uiuc.edu/ osl.cs.uiuc.edu]",
            "id": "9fe03da4b2991b7c0e1194ff124a35ad"
          },
          {
            "type": "html",
            "text": " [http://www.cap-lore.com/Languages/Actors.html www.cap-lore.com]",
            "id": "a29418d296355ed99fae243efd46a0c5"
          },
          {
            "type": "html",
            "text": " [http://del.icio.us/darius/actors del.icio.us]",
            "id": "97df331504a4aacb174a5236ca38c2f5"
          },
          {
            "type": "html",
            "text": "\nThe corresponding page on the TUNES Wiki is [http://cliki.tunes.org/Actor cliki.tunes.org] .",
            "id": "27fb5a1b0af9978d39f8cd71ba23b3ca"
          },
          {
            "type": "html",
            "text": "\nStrictly speaking, an \"actor\" refers to a particular \"behaviour\" or state. When the actor with a given name specifies its successor behaviour, the name is bound to a <i>new</i> actor with that behaviour (just like processes in CSP). However, it is common to use the term \"actor\" loosely as if it referred to a single entity with behaviour that changes over time. The discussion below does this.",
            "id": "2b1d6815531aa007fe64a1d596b5177a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "The main differences between the [[Actors Model]] and [[Communicating Sequential Processes]] are:",
            "id": "e19ef70bdfff93ec25c6b0bbfc07ff98"
          },
          {
            "type": "html",
            "text": " Actors can receive messages from any sender; CSP processes must explicitly name the sending process.",
            "id": "fd9d337e5450a3ba508d4e62388b1f4e"
          },
          {
            "type": "html",
            "text": " Not strictly true. CSP processes must explicitly name the <i>channel</i> over which they are sending (or receiving) a message. That channel may be used by more than sending process. Modern implementations of CSP-based languages, such as occam-pi and JCSP, support the passing of channel ends from process to process as well.",
            "id": "9c037e9c333bc6d8e0f9bf7dc3e328e8"
          },
          {
            "type": "html",
            "text": " The actor model requires fairness - no message can be delayed indefinitely. This simplifies reasoning about systems of composed actors (although it complicates the definition of actor semantics - but that is arguably a good trade-off).",
            "id": "c59e96b9c96cd2d30b3de39d08443cf8"
          },
          {
            "type": "html",
            "text": " In CSP the sender is delayed until it synchronizes with the receiver. An actor, OTOH, can proceed immediately to its next behaviour/state after sending one or more messages (although it often waits for a reply).",
            "id": "1a0a7a67db6e1b375c37e5af44cb3217"
          },
          {
            "type": "html",
            "text": " Ok, this is strictly true. But not really relevant. It is fairly easy to set up (overwriting) buffers between CSP processes in order to prevent blocking on a message. Again, implementations such as JCSP support this directly with language constructs that provide such buffering.",
            "id": "76f844e69ebf62ce8d95cfcd0d438f3a"
          },
          {
            "type": "html",
            "text": " Yes, it is possible to simulate asynchronous message send on top of synchronous send, and vice versa. However, the different primitive operations are not equally easy to implement:<br>a CSP unbuffered synchronous send is very simple on an SMP, but only an Actor buffered asynchronous send is a sensible distributed system primitive.",
            "id": "158b364f006a7ce2aa5c424d67b1a50c"
          },
          {
            "type": "html",
            "text": "\nThere is a more in-depth comparison with CSP in \"Foundations of Actor Semantics\" (available from\n[http://www.erights.org/history/actors.html www.erights.org]).",
            "id": "c7e031111263aa73e9234c282a99487b"
          },
          {
            "type": "html",
            "text": "<i>Note that the comparison in \"Foundations of Actor Semantics\" deasl with Hoare's original (1978) presentation of CSP, which was then simply a pseudo-programming language. As a result, the comparison doesn't touch on any of the last ~30 years worth of theoretical work on CSP and its associated semantic models. The comparison is of historical interest, but not really relevant to modern CSP.</i>",
            "id": "cbcf8eaae1b39da1667c9b1afde3469c"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "There are close parallels between [[Flow Based Programming]] (FBP) and Actors. The discussion that led to the summary below is at [[Actors And Flow Based Programming Discussion]].",
            "id": "01f164e66627123d342be982d6505883"
          },
          {
            "type": "html",
            "text": "[We'll use \"process\" to refer to either an FBP process, or a \"actor configuration\". The latter is a collection of actors, some of which may have names that are made visible outside the configuration. Actors within a configuration typically share part of their state via [[Lexical Scoping]].]",
            "id": "7edf638c7549d40c049f73cd21408471"
          },
          {
            "type": "html",
            "text": "\nSimilarities:",
            "id": "95779c039d4b2111591cbf3eafc667b7"
          },
          {
            "type": "html",
            "text": " Communication between processes is by way of [[Information Packet]]s/messages, travelling across buffered connections. (In FBP use of [[Bounded Buffer]]s is a primitive part of the model; in actors buffering is implemented by serializers.)",
            "id": "c8033b62687d7df3ec48a1d73246a709"
          },
          {
            "type": "html",
            "text": " A process cannot be affected except by way of an incoming [[Information Packet]]/message. <i>[In the [FBP] implementation with which we have most experience, we did provide a \"named global\" facility, but because of the asynchronism of the system, this could only safely be used for read-only data.  In practice it was mostly used for shared reference tables. Besides we told our programmers that [[Global Variables Are Bad]]!]</i>",
            "id": "d5769e62aa9cadedccdb5e160c27c6ff"
          },
          {
            "type": "html",
            "text": " A process can only receive IPs/messages from a limited set of other processes. (The nature of the limitation is different; see below.)",
            "id": "f9986a8585c0e8924ab7975b71ce8e89"
          },
          {
            "type": "html",
            "text": " Actor names are [[First Class]]; FBP (process, input port name) pairs are also [[First Class]]. <i>[Port names (originally numbers) are [[First Class]]; I am not sure if process names are.  In the static definition case, processes need not even know their own names (the only use that I can think of might be for tracing for debugging).  In the dynamic definition case, it might be useful to have process names be [[First Class]] also.]</i>",
            "id": "e33e1bdeabae0c8804fe6888d4b62dc5"
          },
          {
            "type": "html",
            "text": " Both models introduce nondeterminism as the result of nondeterministic arrival ordering of messages/IPs.",
            "id": "76e02636309a8dfe407bc8e24f3ba434"
          },
          {
            "type": "html",
            "text": " In both models, a collection of connected processes can be viewed as a larger process. I.e. the notions of FBP process or actor configuration are compositional.",
            "id": "45f6b96e92976c330f07ab1e07486729"
          },
          {
            "type": "html",
            "text": " FBP processes can have multiple named input ports. An actor configuration can contain multiple actors whose names are made visible outside the configuration; these serve the same function as input ports.",
            "id": "f54b22ce482d9872097c7e1663b54703"
          },
          {
            "type": "html",
            "text": " Use of shared state is discouraged -- although neither model prevents it.",
            "id": "f44524aeb3a93247214359e2cf65f222"
          },
          {
            "type": "html",
            "text": " Use of pure functional objects is encouraged -- although neither model requires it.",
            "id": "3d4adbee0ff737ed64ccaa16c4d71de4"
          },
          {
            "type": "html",
            "text": "\nDifferences:",
            "id": "946cf834b9bf997a822ad34b7e30851d"
          },
          {
            "type": "html",
            "text": " FBP communication networks are specified by a network description that is given in advance, and is <i>usually</i> static (but see the description of <i>dynamic subnets</i> in [http://www.jpaulmorrison.com/fbp/compos.htm www.jpaulmorrison.com] ).",
            "id": "8c9996c659ab81d4b63c1db40a553cd1"
          },
          {
            "type": "html",
            "text": " FBP does not model the internals of processes, only the communication between them. Actors models both (the internal computation of any particular actor configuration can of course be ignored). This reflects the origins of FBP as a programming paradigm, and actors as a foundational model of computation.",
            "id": "e4302172d02b3a0997e9070cccdbb92d"
          },
          {
            "type": "html",
            "text": " An actor can only send messages to its acquaintances, and there are [[Laws Of Locality]], given in <i>\"Actors and Continuous Functionals\"</i>, that describe how the graph of acquaintances can evolve (these laws can be interpreted as applying either between actors or between actor configurations). Just as in the [[Object Capability Model]], \"only connectivity begets connectivity\". The FBP model does not require any equivalent to these laws, and most FBP systems have been built on top of languages that did not enforce them. In FBP, the main limitations on communication come from the fact that connections must be specified in the network description.",
            "id": "f05cd5b128dad0f9efbda54013d8a967"
          },
          {
            "type": "html",
            "text": " FBP processes also have multiple named output ports. In the [[Actors Model]] there are no output ports as such; each actor can send a message to any of its acquaintances at any time. (However, a system might use the convention that the actor names corresponding to outputs are passed in a standardized way on creating an actor configuration, and a network visualizer could recognize this convention.)",
            "id": "7c9bccb142501f589c2e8da1a7a7e1d3"
          },
          {
            "type": "html",
            "text": " In the [[Actors Model]], messages sent to the same actor name by different senders are guaranteed to be merged fairly. In FBP, the corresponding situation where more than one output port is connected to an input port (see figure 8.12 of [http://www.jpaulmorrison.com/fbp/simpapp2.htm www.jpaulmorrison.com] ) does not <i>require</i> a fair merge, although it might be fair in a particular implementation. In this respect FBP is more similar to CSP.",
            "id": "bc968ff13ad961c560bbfd4f94c53518"
          },
          {
            "type": "html",
            "text": " Each connection in FBP is one-way. In actors most messages include a continuation that allows a reply to be sent; in FBP this would require a separate return channel, and there would be no direct link (except for sequencing) between requests and replies.",
            "id": "cd99039c3362d6b948e7fd0f227a7621"
          },
          {
            "type": "html",
            "text": " The [[Actors Model]] requires automatic memory management; FBP does not. There are restrictions on \"ownership\" of FBP [[Information Packet]]s, apparently intended to allow reference counting (see [http://www.jpaulmorrison.com/fbp/tree.htm www.jpaulmorrison.com] ). An implementation of FBP on a garbage-collected platform could presumably relax these restrictions. See also [http://www.jpaulmorrison.com/cgi-bin/wiki.pl?TreeIP www.jpaulmorrison.com] .",
            "id": "3eaddb396c3ff4e18bc3ebd2b33d4f20"
          },
          {
            "type": "html",
            "text": " [[Actors Model]] messages can reference arbitrary graphs of actors; FBP [[Information Packet]]s can only be trees.",
            "id": "adb1656266ed9ce6da03ba7a8a6299f4"
          },
          {
            "type": "html",
            "text": " There is no equivalent to \"bracketed\" IPs (see the end of [http://www.jpaulmorrison.com/fbp/compos.htm www.jpaulmorrison.com] ) in actors. There is nothing preventing implementing this as a higher-level protocol, but it would be more natural to use messages that reference a list object/actor instead.",
            "id": "f58a4b935146f2c3aac819579656fe59"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "Another question about FBP: is the flow of [[Information Packet]]s always a \"push\" (i.e. packets are sent as soon as they are available, up to the capacity of the [[Bounded Buffer]]), or can packets be \"pulled\" (i.e. a consumer can say that it only needs a given number of packets)? It is obviously possible to do the latter by adding a back-channel, but is it possible without?",
            "id": "711a5e93f838ac0dc8649ba31d2026d8"
          },
          {
            "type": "html",
            "text": "<i>Yes, it's always \"push\".  However, I suppose the receiver can decide how many IPs to receive by \"receiving\" a certain number of IPs, and then by refusing to receive any more, which will eventually fill up the [[Bounded Buffer]], which will in turn suspend the sender.  Not very nice - similar behaviour is often a cause of deadlocks.  OTOH It is the mechanism that lets you process \"infinite\" data streams with a finite amount of resources. (On rereading my sentence, I had a change of heart!)</i>",
            "id": "54b4451e9c732130551cd0c6e021019e"
          },
          {
            "type": "html",
            "text": "\nHmm -- it seems like support for demand-driven dataflow would be a useful extension to FBP, then. See [[Vpl Language]] for example.",
            "id": "4a6f9467478779459c15769a76d0ceac"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "<i>Excellent job of refactoring, David!  I have some minor quibbles, which I will add here as I digest what you have written.  One area of perplexity is what an actor-based Collate would look like in actual code - wouldn't you have to synchronize the cooperating actors somehow?</i> --[[Paul Morrison]]",
            "id": "9b0c6daa0fe5b81dad1b2795442b48a2"
          },
          {
            "type": "html",
            "text": "\nYes, you do have to synchronize the cooperating actors. The most straightforward way to do this is to have one controlling actor representing the Collate itself, and one \"subactor\" per input stream. In most actor languages, messages from the subactors to the controlling actor would be automatically serialized by default.",
            "id": "09fec3ed58345fe913054ebb291793f7"
          },
          {
            "type": "html",
            "text": "\nAlternatively, some hybrid [[Actor Languages]] (e.g. [[Ee Language]]) have the concept of a \"vat\", which is basically a thread shared by several actors. In that case putting the actors that make up the Collate in the same vat would automatically synchronize them.",
            "id": "26e5bd856478a954e8804cf6c3788193"
          },
          {
            "type": "html",
            "text": "<i>Ports are key to the concept of [[Configurable Modularity]], which offers the very real prospect in the future of being able to build quite interesting applications without writing a line of code - just specify the network and parameters, where \"parameters\" can be expanded to include \"mini-languages\" - see the discussion in [http://www.jpaulmorrison.com/fbp/minilang.htm www.jpaulmorrison.com]. Ports are the way the inside of a process communicates with the network definition.  Suppose you have multiple instances of a Reader process: each instance will usually have its OUT port feeding a different [[Bounded Buffer]] connection.  Using the concept of Port, the code for a basic Collate is so stunningly simple that I really fail to see what advantage one would gain by coding it using multiple actors, especially if actors don't support ports.  And anyway, the FBP orientation towards black-box modules surely makes it even less important what language a module is written in.  Maybe you can set me straight, David!</i>",
            "id": "0055bb61c069f3eb0d620232b04150f6"
          },
          {
            "type": "html",
            "text": "\nThe black-box modules in the [[Actors Model]] are actor configurations, not individual actors (see [http://www.cypherpunks.to/erights/history/actors/96jfp.pdf www.cypherpunks.to] for a formal treatment). I've changed the summary above to reflect this.",
            "id": "9b27ba2787f80675f5d8ef2c2662a553"
          },
          {
            "type": "html",
            "text": "\nBecause the [[Actors Model]] is intended as a foundational model of computation, its most basic concept -- an actor -- is deliberately as simple as possible. In a <i>pure</i> actor language, the sublanguage used to specify an actor behaviour is not even [[Turing Complete]]; the model becomes [[Turing Complete]] only when the behaviours change over time and multiple actors (or an actor sending messages to itself) are considered. Writing a program directly in terms of the pure [[Actors Model]] would be like writing it directly in the [[Lambda Calculus]] using [[Continuation Passing Style]]; it's important to know that it can be done, that high level programs have a well-defined translation to this form, and that's about all.",
            "id": "595be747993fce8f8397184618c0b56d"
          },
          {
            "type": "html",
            "text": "<i>As a humble programmer, I keep puzzling over the last sentence: *why* is it important to know it can be done?  I know it is important to know that matter is made of quarks and leptons (or whatever), but how does this apply to the world of computing?  Could someone try to articulate this, or point us at a page that does?</i>",
            "id": "af74007610911dea22a5f8f561089f05"
          },
          {
            "type": "html",
            "text": " I guess it's important as a proof you can solve anything with it you could with other [[Turing Complete]] languges, but is it so? [[Cee Plus Plus Templates]] are [[Turing Complete]] (or so I heard, if not replace with [[Scheme Macros]]), but wouldn't they have to expand to an infinite source to model an infinite loop? Then they would never actually run. Maybe stating something is [[Turing Complete]] or [[Lambda Calculus Equivalent]] gives it some kind of aura.",
            "id": "692ed19589eb61060ae7a6ac394d052c"
          },
          {
            "type": "html",
            "text": " [C++ templates are Turing complete. The expansion to infinite source is its \"infinite loop\".]",
            "id": "8fb019e92f1463557bddbe1549e3999e"
          },
          {
            "type": "html",
            "text": "\nPractical [[Actor Languages]], OTOH, always include various abstractions above the basic model -- serializers, synchronous calls, vats, message queues, promises, sponsors, etc. The fact that you're creating multiple actors in a situation where an FBP network would have multiple ports is a detail that may be exposed in some actor languages, and hidden in others. The <i>model</i> actually says very little about how to design a high-level actor language; basically it only says that all communication must be by a message passing mechanism that satisfies certain laws. So the code in a particular actor language might look identical to how it would look in an FBP system, including the possibility of using graphical network diagrams (something like [[Gee Language]], for example) or direct interaction to connect processes.",
            "id": "3b277f7e6efccc71dda661282ff71e38"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "Because FBP [[Bounded Buffer]]s have finite capacity, [the property that \"no message can be delayed indefinitely\"] above is probably true in FBP.  I have seen a paper stating that this prevents livelock.",
            "id": "c3fba9e3239baec8f3add3ace7d1d424"
          },
          {
            "type": "html",
            "text": "<i>[http://www.jpaulmorrison.com/fbp/deadlock.htm www.jpaulmorrison.com] says: </i>\"Kuse et al. (1986) proved that, although a network with fixed capacity connections (like the ones in FBP) can suffer from deadlock, it can never suffer from livelock.\"<i> The reference is to K. Kuse, M. Sassa, I. Nakata (1986), </i>\"Modelling and Analysis of Concurrent Processes Connected by Streams\"<i>, Journal of Information Processing, Vol. 9, No. 3, abstract at [http://www.ipsj.or.jp/members/JInfP/Eng/0903/article005.html www.ipsj.or.jp] .</i>",
            "id": "bd15f8d13fc5a4fde9bd1149ea11b185"
          },
          {
            "type": "html",
            "text": "<i>The abstract of this paper says that \"A network in this class has some restrictions, for example, a stream must have only one producer and one consumer.\" This is not usually the case for the [[Actors Model]].</i>",
            "id": "6500da1ee06c8cb8d94af9394cf7e63e"
          },
          {
            "type": "html",
            "text": "\nIt is possible they are making a distinction between \"streams\" and \"channels\".  Here is part of a paragraph from [http://www.jpaulmorrison.com/fbp/cognates.htm www.jpaulmorrison.com] : \"In A'UM [K. Yoshida and T. Chikayama (1988)] and some of the other systems related to it, a distinction is made between \"streams\" and \"channels\". ... in A'UM, a \"stream\" runs from one source to one destination, whereas a \"channel\" may contain more than one stream, coming from different sources: the items in each stream must stay in sequence relative to each other, but the streams in a channel are not constrained relative to each other. In A'UM only one reader is allowed for a channel, while in Tribble's paper on channels (Tribble et al. 1987), he allows multiple readers for a channel. The authors of A'UM feel that not allowing multiple readers makes their semantics sounder and the implementation simpler.\" FBP also does not allow multiple readers. --pm",
            "id": "04e0cbbaa5cf944c146b51dac958eddd"
          },
          {
            "type": "html",
            "text": "<i>In actors you could easily construct a stream that had multiple readers, by reifying the stream as an actor. For normal messages, though, an actor receives some interleaving (fair merge) of all the messages sent to it.</i>",
            "id": "a0e0d8dede17da953292031aac58b3f6"
          },
          {
            "type": "html",
            "text": "<i>In FBP it looks as though you could also construct a stream with multiple readers, using something similar to the Collate construct but in reverse, with one input port per reader to request the next item, and one output port per reader to receive the item. It would be more complicated than in actors because FBP has no built-in convention for reply messages.</i>",
            "id": "2612d4530f6dfe4fb0669cc257a19724"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "About the fairness property:",
            "id": "5f3c71c72e1488ef78f4918d8b594ae4"
          },
          {
            "type": "html",
            "text": "<i>The fairness guarantee applies to directly sent messages. Because messages are first-class in the [[Actors Model]], it is possible for an actor to be wrapped by a \"serializer\" or \"guardian\", which can filter, delay or reorder individual messages (this is how an actor would avoid receiving a message when it is in an inconsistent state). A serializer may not pass on a particular message, but this does not contradict fairness, because it received the message with only finite delay. Serializers were a feature of the first actor languages (see \"Issues in the Design and Implementation of Act2\").</i>",
            "id": "34c00a7402ed568a98ebefaf3ab02aac"
          },
          {
            "type": "html",
            "text": "<i>A [[Bounded Buffer]] in FBP corresponds directly to a serializer with a bounded message queue. Suppose, for example, that we have two actors A and B where A is sending messages to B's serializer, and is expecting a reply to each message. Each message from A to B's serializer includes a unique continuation. After each send, A will go into a state where it is waiting to be sent the reply via that continuation. (A would have its own serializer which delays messages directed to A while it is waiting.) The fact that A waits for a response ensures that it will not try to send so many messages that B cannot keep up.</i>",
            "id": "6dd6d6e6db58a1da3bc669d9370ace4e"
          },
          {
            "type": "html",
            "text": "<i>The fact that it is serializers that store any \"delayed\" messages means that the actor system itself can be implemented with only finite memory for pending messages. However, this ducks the issue of how a serializer should deal with \"message overruns\", where other actors try to send an unbounded number of messages to it without waiting for anything. This potential problem is inherent to one-way buffered messaging, and it can be solved by using higher-level abstractions that provide flow control or backpressure (to attempt to prevent the problem), and that account for memory usage (to deal with the effects if prevention fails). The nice thing about this approach is that you're not limited to any fixed set of abstractions.</i>",
            "id": "e201bc6b89998a0c356cedea0f2f8ce1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "From [http://www.jpaulmorrison.com/fbp/cognates.htm www.jpaulmorrison.com] :",
            "id": "58bd879d2d75a8cabe3a8815b1e35bc2"
          },
          {
            "type": "html",
            "text": "<i>Hewitt's Actors take processes down to the finest possible granularity: </i>\"Hewitt declared\"<i>, to quote Robin Milner (1993), </i>\"that a value, an operator on values, and a process should all be the same kind of thing: an actor.\"<i> This approach has considerable theoretical attractiveness, but in my view, to be practical, it basically has to be implemented as hardware, rather than software. There are also of course a number of projects growing out of Hewitt's Actors, which also seem to be on a converging path with all the other work (albeit at the more granular end of the scale), e.g. Agha's COOP (1990).</i>",
            "id": "c6eeb698ddd5d7c5214568fe0364d92a"
          },
          {
            "type": "html",
            "text": "\nThe [[Actors Model]] doesn't have to be implemented in hardware to be practical. Although there was a project to build an actor-oriented machine called the \"Apiary\", AFAIK this was never completed, and so all working implementations of the [[Actors Model]] have been software-based. In terms of sequential computation, the performance cost of the \"[[Everything Isa]]n actor\" approach is similar to the cost of \"[[Everything Isa]]n object\" in languages like Smalltalk. In terms of concurrency, [[Erlang Language]], [[Oz Language]], [[Stackless Python]], etc. demonstrate that user-level threading implementations can easily scale to large numbers (100s of 1000s?) of active threads. Since actors only perform work in response to messages, the number of actors can be much greater again than the number of threads.",
            "id": "e3b7681ab1f70e6e496fbb8cc0751287"
          },
          {
            "type": "html",
            "text": "<i>You touch on a key concern of mine: how would these systems perform processing millions of transactions a day?  I relate to the goal of [[Bridging The Gap]] between the designer's thought and the implementation, but if a program is going to be used for productive work in a large company, it also has to be able to handle (very) large volumes.  This was the thought underlying my comment on hardware. BTW I'm not too excited about the overhead of \"[[Everything Isa]]n object\" either!</i> --[[Paul Morrison]]",
            "id": "730b180c7c4d6555ae7a2519f269ef63"
          },
          {
            "type": "html",
            "text": "\n1 million transactions per day is ~12 transactions per second on average. Suppose it is 100 transactions per second peak. On a 1 GHz processor, that is 10 million cycles to play with for each transaction. Assuming adequate bandwidth and that each transaction is not unreasonably computationally intensive, it would actually be quite difficult to implement a system inefficiently enough that it cannot keep up with this load -- <i>unless</i> the underlying operating system gets in the way.",
            "id": "9a09397b4a517b7b6ab31cb70030c935"
          },
          {
            "type": "html",
            "text": "\nReliability is likely to be <i>much</i> more of an issue for this kind of system than raw performance. After all, we now have supercomputers on our desks. It is only the inefficiency of certain operating system platforms that obscures that fact. -- [[David Sarah Hopwood]]",
            "id": "8d091563f1dc541305a6016006501fd1"
          },
          {
            "type": "html",
            "text": "<i>That makes sense to me.  And it means that we can actually spend quite a lot of CPU time to make systems more reliable, and, I would add, more maintainable.  I have often been struck by how so much of our research goes into better ways to create new code, rather than ways to make code that is more reusable.  I think it was [[Ew Dijkstra]] who said code should be a cost item, not a measure of productivity.</i>",
            "id": "58b2b78df1abd2c981b8cf28d7f70444"
          },
          {
            "type": "html",
            "text": "\nI couldn't agree more -- see my home page when it's finished. -- [[David Sarah Hopwood]]",
            "id": "b0342591322ee24a49b2c1619583755d"
          },
          {
            "type": "html",
            "text": "<i>Still waiting....</i> --[[Paul Morrison]]",
            "id": "d6439dd70794ee74e5ef1d063e413ec0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "I have felt for a while that this architecture probably has considerable relevance for the security world - anyone want to run with this?",
            "id": "6725ff1712bdd6457a054a6b2e4f518e"
          },
          {
            "type": "html",
            "text": "<i>The [[Actors Model]] is the basis of some [[Object Capability Language]]s including [[Ee Language]]. This is a very active area of research. I'm currently working on an actor-based multi-language operating system -- I'll add references here when the design is closer to being cooked. -- [[David Sarah Hopwood]]</i>",
            "id": "8b3ee21f1a666973ea7647dad924ee10"
          },
          {
            "type": "html",
            "text": "\nIn case that's not explicit enough, capability systems are a ... fundamental or foundational model of\nsecurity.  The \"acquaintance\" that one actor has with another is just like a capability.  A capability\nis a one-way channel that one actor (or process or user) has to another, and in these\nsystems, sending requests through capabilities is the only way of doing things.  A capability can't\nbe \"forged\"--that is, you can't create one by casting from a number or guessing an address, you can\nonly acquire one at your creation time or passed to you in a message.  Security is achieved by\ncontrolling who and what processes are given capabilities to access what resources, other processes,\netc.  Authorities for different operations or views on the same thing, e.g. read vs. write, can be\nset up as separate capabilities. --[[Steve Witham]]",
            "id": "1d5233e86449274b199016bdc795b8c4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "Comparison of the [[Actors Model]] with the [[Join Calculus]]:",
            "id": "1d9b27c056dcd673e652650ca66e01c0"
          },
          {
            "type": "html",
            "text": "\nThis is based on the tutorial at [http://pauillac.inria.fr/join/manual/manual002.html pauillac.inria.fr] , and the paper \"The Reflexive CHAM and the join-calculus\", which is at [http://research.microsoft.com/~fournet/biblio.htm research.microsoft.com]",
            "id": "e40530970f9afcc7786f681b9b46f2b7"
          },
          {
            "type": "html",
            "text": "(you may need to use [[Microsoft Internet Explorer]] and/or switch off pop-up blocking to access the latter.)",
            "id": "b36c9a6966e3761173e4983ecf2f416a"
          },
          {
            "type": "html",
            "text": " Channels in the [[Join Calculus]] are equivalent to actor names; both are [[First Class]].",
            "id": "ed56a311a2004d570cf7f47125ec746d"
          },
          {
            "type": "html",
            "text": " Both are message-passing models, with arrival order nondeterminism. It is not clear whether the [[Join Calculus]] requires finite delay.",
            "id": "abc96764059160cc7bff11908c89383d"
          },
          {
            "type": "html",
            "text": " Both are fundamentally based on [[Continuation Passing Style]], with most practical languages that follow each model providing sequential constructs via CPS conversion. (This accounts for the fact that the tutorial distinguishes between \"expressions\" and \"processes\", whereas the [[Actors Model]] has only \"behaviours\" -- after CPS conversion the [[Join Calculus]] also only has one kind of behaviour.)",
            "id": "845e8b087d6691a360a3f5b13a0acf47"
          },
          {
            "type": "html",
            "text": " In both models, a process can send a message to another process if-and-only-if it \"knows\" the latter's channel/name. A new process' channel/name is only initially known by its creator.",
            "id": "21ffcece6a1b6df8c37f6f8924685a85"
          },
          {
            "type": "html",
            "text": " Ordinary (non-join) patterns correspond straightforwardly to actor definitions (with the obvious translation of the 'reply' construct to [[Continuation Passing Style]]).",
            "id": "4e5f8860350f05abefdd2fc08ed092a8"
          },
          {
            "type": "html",
            "text": " Join patterns are primitive in the [[Join Calculus]], but not primitive in actors. It would be easy to support join patterns in an actor language, by representing each subpattern as an actor and having each wait until all subpatterns are triggered.",
            "id": "a9069ee611b85f034256e6741a412fe1"
          },
          {
            "type": "html",
            "text": " The approach to modelling objects described in the tutorial (using lexical scoping to hide internal state) is similar to what would be used in actors. In actors you would normally pattern match on the method name rather than returning a tuple of functions, but you could do that in the [[Join Calculus]] as well.",
            "id": "ab0f20548be9b4e1f6c9678a2e1087fd"
          },
          {
            "type": "html",
            "text": "\nSo, for all intents and purposes, the [[Join Calculus]] and the [[Actors Model]] are almost identical. \"The Reflexive CHAM and the join-calculus\" describes the [[Join Calculus]] as a modification of the [[Pi Calculus]] and the [[Chemical Abstract Machine]], but these modifications are essentially equivalent to enforcing the actor [[Laws Of Locality]], and changing the semantics of channels to follow that of actor message passing.",
            "id": "c0a94e83d7603730dd358c3126833f8d"
          },
          {
            "type": "html",
            "text": "\nThis would be all very well if the [[Join Calculus]] had been developed in the late 1970s or 1980s. Given that it was developed in 1995, you have to wonder why [[Cedric Fournet]] and [[Georges Gonthier]] didn't simply publish a paper relating the [[Pi Calculus]] to the [[Actors Model]], rather than reinventing the wheel with an entirely new terminology. The only new construct in the [[Join Calculus]] is join patterns, and those are trivially simulatable by actors. \"The Reflexive CHAM and the join-calculus\" does reference two papers on actors, but little or no research seems to have been put into any comparison. Also see [http://cliki.tunes.org/Actor cliki.tunes.org] .",
            "id": "a86f0b703b7e41b1af7481461d5e3a16"
          },
          {
            "type": "html",
            "text": "\nOh well -- at least they <i>are</i> promoting the right concurrency model, even if they had to reinvent it 20 years after the fact. -- [[David Sarah Hopwood]]",
            "id": "c3e946158cbdebff30ddb4a8cb463a9a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "\nThis [[Actors Model]] does allow a very intuitive view of the universe in which processes run. Something like [[Processes In The Ether]] or [[Programmable Logic Controller]]s on a factory backbone, it even makes the factory floor model easily conceivable as a model for a robot's software. I think its view of inter-process communication offers a clear and simple single practical view to the designer. All processes are the result of the [[Designated Behaviour]] of another process - invoking a process is an assertion that that process will follow its [[Designated Behaviour]]. I think [[Actors Model]] and [[Flow Based Programming]] are complementary - each Actor implemented using FBP. -- [[Peter Lynch]]",
            "id": "f9b3c8de900d72a504cf94f527c0ab08"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "<b>Some [[Actors Model]] Skepticism</b>",
            "id": "571dfed916c6086a2a5b9c1df1631171"
          },
          {
            "type": "html",
            "text": "\n[[Actors Model]] in its base form has some nice, simple properties that make it easy to reason about and implement. But, after having pursued it for a while based on its being inherently distributed and concurrent, I've grown quite skeptical about its application in practice. Among the problems:",
            "id": "ee9be3f693c759d10a0be285ea7b9860"
          },
          {
            "type": "html",
            "text": " message delivery: [[Actors Model]] makes an assumption that messages will eventually reach their destination. In any open distributed system, this can't be guaranteed. In part, we must deal with the fact that distributed garbage collection in an open system is undecidable, and so actors will need to be deleted heuristically or explicitly when it seems unlikely they will see further use. That said, the [[Actors Model]] is still one of the better models out there for handling dropped messages, since they simply become messages that aren't delivered <i>yet</i>. ",
            "id": "a89756f4b3aab7c25f7f1a079018af1d"
          },
          {
            "type": "html",
            "text": " coordination: 'Pure' [[Actors Model]] coordination is not simple. To the contrary, it is very invasive of actors, often requiring a complex dance of creating new actors to receive messages and process them in a sort of [[Continuation Passing Style]], and yet more actors to operate as serializers. As noted above, <i>\"Practical [[Actor Languages]], OTOH, always include various abstractions above the basic model -- serializers, synchronous calls, vats, message queues, promises, sponsors, etc.\"</i>. And, even with these abstractions, coordination with the [[Actors Model]] is not simple... because now you need to use these abstractions. As mentioned regarding [[Flow Based Programming]] above, some sort of external coordination (both when creating new services and when integrating with pre-existing services) seems far more promising.",
            "id": "fc4081b4fd6463989bd0d0afd9edb770"
          },
          {
            "type": "html",
            "text": " synchronous communications, such as [[Send Receive Reply]], break [[Actors Model]] - the properties that hold in [[Actors Model]] cannot be claimed to hold in a system with synchronous communications. For example, one gets deadlock for free!  Something 'sort of like' synchronous communications is to send messages with an actor identifier to which to send the reply message, which will be further processed in a [[Continuation Passing Style]]. However, the similarities break down if the actor requesting the reply intends to update its own behavior for processing other messages. This behavior can be handled by ever more state and vocabulary within actors (actors keep state regarding which messages have been sent, which are being waited upon, which are waiting for processing until after receiving a message, etc.) but this makes for heavyweight actors and more [[Cross Cutting Concern]]s that, like other forms of coordination, interferes with 'domain' actors. I've developed [[Transactional Actor Model]] to aide with certain forms of synchronization, but have yet to explore how much it helps in enough use-cases to deem it a solution.",
            "id": "0a75176a076ce62c4994f47deda25122"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "See also: [[Actor Languages]], [[Object Capability Model]], [[Transactional Actor Model]], [[Actor Vs Agent]]",
            "id": "02b0226d8997218ee40cf21ec14fe1bd"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "b60ac6c3f83a25312b07199f0c062c30"
          },
          {
            "type": "html",
            "text": "[[Category Concurrency]] [[Category Comparisons]] [[Category Models]]",
            "id": "ca4242fe0381bf1d8ffa871abebe1269"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?ActorsModel c2.com]",
            "id": "32f2bc8fbacdef0e461382162c109139"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1705486732210
    }
  ]
}