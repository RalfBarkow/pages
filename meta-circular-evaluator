{
  "title": "Meta Circular Evaluator",
  "story": [
    {
      "type": "html",
      "text": "An evaluator that is written in the same language that it evaluates is said to be metacircular <b>if and only if</b> doing so short-circuits the need to specify the precise semantics, because the key language constructs are implemented by themselves, exactly like looking up a word in a dictionary and finding that the definition uses the original word. That's the \"metacircular\" part.",
      "id": "89c8ea3c99ef9a4992faa88adad5b02a"
    },
    {
      "type": "html",
      "text": "<i>How is that different from ordinary recursion?</i>",
      "id": "763a6dda7c4fa4da78a9bb48ed64b90c"
    },
    {
      "type": "html",
      "text": " It's circular recursion. There is no termination condition. It's a chicken-and-the-egg kind of thing. (There's actually a hidden termination condition: the bootstrapping process.)",
      "id": "a05ff4ffd175df275935c315e6b5f4e6"
    },
    {
      "type": "html",
      "text": "\nA C compiler written in C is not a [[Meta Circular Evaluator]], because the compiler must specify extremely detailed and precise semantics for each and every construct. The fact that the compiler is written in the target language does not help at <b>all</b>; the same algorithms could be translated into Pascal or Java or Ada or Cobol, and it would still be a perfectly good C compiler.",
      "id": "f1be9e7df38585ae51795a60a7b0ab91"
    },
    {
      "type": "html",
      "text": "\nBy contrast, a [[Meta Circular Interpreter]] for Lisp can't be translated into a non-Lisp language. That's right, <b>cannot</b> be -- at least, not in any simple one-to one fashion. Lisp written in Lisp implements \"eval\" by calling \"eval\". But there is no \"eval\" in many other languages (and if there is, it has different semantics), so instead a completely new language system would have to be written, one which gives a detailed algorithm for \"eval\" -- which was not necessary in the metacircular case.",
      "id": "5b5b0965d26ebb80bf3722d834fde21e"
    },
    {
      "type": "html",
      "text": "\nAnd <b>that</b> is the magic of [[Meta Circular Evaluator]]s: they reflect an underlying magic of the languages in which they are possible.",
      "id": "01b9a9319224aac11bb3da5f82d87015"
    },
    {
      "type": "html",
      "text": "\nSo it's a mistake to call something a [[Meta Circular Evaluator]] just because it's written in itself; that's not sufficient. [[Boot Strapping]] is a minor kind of magic, but metacircularity is a more major kind of magic. Which is why the C world talks about \"bootstrapping a C compiler\", not about \"metacircular C compilers\". ",
      "id": "f78273ba85cb265ac3a1bed6b25dd764"
    },
    {
      "type": "html",
      "text": "<i>I'm not sure that you can have a metacircular compiler in any language.  Metacircular evaluators are interpreters, right?</i>",
      "id": "cf5df0c2f23efcb3a9becb1873f8c67f"
    },
    {
      "type": "html",
      "text": " That is in fact my understanding (except that a system that behaves as an interpreter can be transparently implemented as a compiler), but after the wars on the [[Homoiconic Languages]] pages, it seems likely that this would be contested, so a persuasive argument would be in order, not just an assertion.",
      "id": "65874d68b15a56cefa3ceb5503323939"
    },
    {
      "type": "html",
      "text": "\nThere are some excellent documents out there about the [[Meta Circular Evaluator]], based on [[Lisp Language]]:",
      "id": "5893b4bdfe676fa1a2618b31cf7092f4"
    },
    {
      "type": "html",
      "text": " [[Paul Graham]], \"The Roots of Lisp\" - [http://www.paulgraham.com/rootsoflisp.html www.paulgraham.com]",
      "id": "bfc776dcef8654cb5f9fce118ecc3961"
    },
    {
      "type": "html",
      "text": " [[Guy Steele]] and [[Gerald Sussman]], \"[[The Art Of The Interpreter]]\"",
      "id": "13f9ad5c4b90b2684a8e0bf413920b2a"
    },
    {
      "type": "html",
      "text": " The book [[Structure And Interpretation Of Computer Programs]] contains a chapter dedicated to [[Meta Circular Evaluator]]s ... although it gives a definition incompatible with the one given on this page.",
      "id": "19f2bf904446d733f8fca23d03a57a79"
    },
    {
      "type": "html",
      "text": " The paper \"A Simple Reflective Interpreter\" (1992) by [[Stanley Jefferson]] and [[Daniel Friedman]] (see [http://citeseer.nj.nec.com/jefferson92simple.html citeseer.nj.nec.com]) contains an implementation of a minimal [[Scheme Language]] interpreter in Scheme such that every instance of the interpreter can be used to run another interpreter while providing access to the next higher level. Also see [[Reflective Tower]].",
      "id": "038e261cb3700e4a99acf50788bf37d4"
    },
    {
      "type": "html",
      "text": "\nTo see the modern outgrowth of such things, web search \"reflective towers\", or see \"A Tutorial on Behavioral Reflection and its Implementation\" at [http://www2.parc.com/csl/groups/sda/projects/reflection96/docs/malenfant/ref96/ref96.html www2.parc.com]",
      "id": "c689a839104546bcee1bdb50c5fe8a5b"
    },
    {
      "type": "html",
      "text": "<i>Are there examples of [[Meta Circular Evaluator]] other than in the Lisp family (CL, Scheme)?</i>",
      "id": "93682bdfd541fc6c916e0991afe7cc56"
    },
    {
      "type": "html",
      "text": "\nMost [[Forth Language]] implementations use a non-extensible interpreter and compiler, because of [[You Aint Gonna Need It]].  So, when it comes time to extend the interpreter and/or compiler in a way that simple colon definitions or immediate words cannot, most folks implement their own interpreter and compiler, suitable extended for their needs, but otherwise relying on the same basic tools that the existing interpreter and compiler use.",
      "id": "23ffb06376ee56ed55496bd737a21b15"
    },
    {
      "type": "html",
      "text": "\nFor example, here is a simple metacircular interpreter in arbitrary dialect Forth:",
      "id": "59e988b504f0edbefb6edcf91bdb7a16"
    },
    {
      "type": "html",
      "text": "myInterpreter",
      "id": "5a3a97f438b03342712353334186e532"
    },
    {
      "type": "code",
      "text": "    begin 32 word find dup if execute else number then again ;",
      "id": "1b6780640b79ee39ca94a3113615fced"
    },
    {
      "type": "html",
      "text": "\nAnd here would be a compiler:",
      "id": "71a0ccd2e8dc9789df5723e50857d37a"
    },
    {
      "type": "html",
      "text": "my-]",
      "id": "1c40ee27251b7827caf986b143d76df8"
    },
    {
      "type": "code",
      "text": "    begin 32 word find dup if dup immediate? if execute else compile then else compile-number then again ;",
      "id": "6bbfc88cb8b029f6150b97c6b5e9761b"
    },
    {
      "type": "html",
      "text": "\nA word such as [ would be an immediate word, which manipulates the return stack (or in ANSI-like dialects, would change the state of a variable imaginatively called STATE) to break out of the compiler loop, while a word like ] usually is the compiler itself.  This preserves Forth's [ and ] semantics.  Of course, you'll also need to re-implement : and :NONAME as well, but these are rather trivial.",
      "id": "72060f311340510fad2bd6f9e8874a5a"
    },
    {
      "type": "html",
      "text": "\nFor a concrete example, here's how to change the compiler so that all words prefixed by the back-tick are POSTPONEd:",
      "id": "0123f3ac1eac91b947b7ef232963c9d5"
    },
    {
      "type": "code",
      "text": "  \\ not tested code; but it would look/feel a lot like this.",
      "id": "9a4e8913d813631f8a77db5053df3309"
    },
    {
      "type": "code",
      "text": "  create macro-buffer 80 allot\n  : create-postpone-macro\n    S\" POSTPONE \" macro-buffer 1+ swap move      ( embed the \"POSTPONE \" part into the buffer )\n    count dup -rot macro-buffer 10 + swap move   ( embed the name of the word after POSTPONE  )\n    9 + macro-buffer c! ;                        ( and set the length of the whole string.    )",
      "id": "cf8e765520ccaa525af1e6fc4675edbe"
    },
    {
      "type": "html",
      "text": "word-starts-with-`?",
      "id": "e9472dd33fb6c5c2610e0fc0608eddc3"
    },
    {
      "type": "code",
      "text": "    dup 1+ c@ [char] ` = ;",
      "id": "8397d9b30d07f0785843f0b12d91bff5"
    },
    {
      "type": "html",
      "text": "new-]",
      "id": "32ac866306daf69f3f6aeceb7a107b6f"
    },
    {
      "type": "code",
      "text": "    state on\n    begin 32 word find dup\n          if   dup 0<\n               if   execute ( it was an immediate word )\n               else compile ( it wasn't an immediate, so compile it instead )\n          else word-starts-with-`?\n               if   compute-postpone-macro  macro-buffer count evaluate\n               else number literal\n               then\n          then\n    state @ 0= until ;",
      "id": "3d3d26421d02a2ebfc685b4975a607f5"
    },
    {
      "type": "html",
      "text": ":",
      "id": "6d396364d31b2aee0b495cd79bebcfb9"
    },
    {
      "type": "html",
      "text": "(:) new-] ;   ( most Forth systems have a word like (:), that implements the core of :<br>without actually invoking the compiler )",
      "id": "5aa6606d7b9b8293d00526b302128d2c"
    },
    {
      "type": "html",
      "text": "]",
      "id": "1b73706833986cbea0465c82093beca8"
    },
    {
      "type": "code",
      "text": "    new-] ; immediate   ( note this word compiled with the \"new\" :-compiler! )",
      "id": "796e0aa9dcaf0387374ca988a1aca5d5"
    },
    {
      "type": "html",
      "text": "\nAnd that <i>should</i> be it.  Yeah, it's a bit more complex than just creating a reader macro in Lisp, but hey, when the whole thing compiles to maybe 300 bytes or less on a 32-bit system, you could afford some 15 of these things in memory before you even hit the complexity of the reader itself, let alone the interpreter and compiler logic.  :-)",
      "id": "ae7107c90133fa4bb534fac781f0f455"
    },
    {
      "type": "html",
      "text": "(Not sure who changed the ] to [ characters.  In Forth, [ is used to enter into interpreter mode from inside a definition.  This allows compile-time pre-computed constants with zero run-time overhead, like this:  : abc  blah [ 2 4 * 5 6 * + ] literal blort ;.  Hence, ] is the entry-point to the compiler, NOT [.)",
      "id": "32f51f158c6217a846c089993730ca7e"
    },
    {
      "type": "html",
      "text": "--[[Samuel Falvo]]",
      "id": "84b9ff71a00502a6986fbfad694342fc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "3ef159e77952ce45cd740a9b2caecdf8"
    },
    {
      "type": "html",
      "text": "\nI'm sure I'm misunderstanding the definition somewhere, because as far as I can tell <i>any</i> dynamic language would inherently be metacircular, since they basically all have some sort of eval instruction.",
      "id": "1f88bdf0354ee5c5dd3bc8e9178ebd5c"
    },
    {
      "type": "code",
      "text": "  def python_interpreter(code):\n    exec code",
      "id": "7748634038ceb511431b8bc1b95faadd"
    },
    {
      "type": "code",
      "text": "  def ruby_interpreter code\n    eval code\n  end",
      "id": "8cf7174a1fc9f5752c58b382e215a39e"
    },
    {
      "type": "html",
      "text": "\nHow is this any different from implementing a Lisp interpeter using Lisp's eval?",
      "id": "654054883c7924a6eccb5f707230de1b"
    },
    {
      "type": "html",
      "text": "--[[David Mc Lean]]",
      "id": "665cc6263d9d1da895d72348689d0c07"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?MetaCircularEvaluator c2.com]",
      "id": "2a6f75629dc96a154ff8503f31a7d201"
    }
  ],
  "journal": [
    {
      "date": 1355460075000,
      "id": "b6caef6682d56c2a27e09b34d9549cfd",
      "type": "create",
      "item": {
        "title": "Meta Circular Evaluator",
        "story": [
          {
            "type": "html",
            "text": "An evaluator that is written in the same language that it evaluates is said to be metacircular <b>if and only if</b> doing so short-circuits the need to specify the precise semantics, because the key language constructs are implemented by themselves, exactly like looking up a word in a dictionary and finding that the definition uses the original word. That's the \"metacircular\" part.",
            "id": "89c8ea3c99ef9a4992faa88adad5b02a"
          },
          {
            "type": "html",
            "text": "<i>How is that different from ordinary recursion?</i>",
            "id": "763a6dda7c4fa4da78a9bb48ed64b90c"
          },
          {
            "type": "html",
            "text": " It's circular recursion. There is no termination condition. It's a chicken-and-the-egg kind of thing. (There's actually a hidden termination condition: the bootstrapping process.)",
            "id": "a05ff4ffd175df275935c315e6b5f4e6"
          },
          {
            "type": "html",
            "text": "\nA C compiler written in C is not a [[Meta Circular Evaluator]], because the compiler must specify extremely detailed and precise semantics for each and every construct. The fact that the compiler is written in the target language does not help at <b>all</b>; the same algorithms could be translated into Pascal or Java or Ada or Cobol, and it would still be a perfectly good C compiler.",
            "id": "f1be9e7df38585ae51795a60a7b0ab91"
          },
          {
            "type": "html",
            "text": "\nBy contrast, a [[Meta Circular Interpreter]] for Lisp can't be translated into a non-Lisp language. That's right, <b>cannot</b> be -- at least, not in any simple one-to one fashion. Lisp written in Lisp implements \"eval\" by calling \"eval\". But there is no \"eval\" in many other languages (and if there is, it has different semantics), so instead a completely new language system would have to be written, one which gives a detailed algorithm for \"eval\" -- which was not necessary in the metacircular case.",
            "id": "5b5b0965d26ebb80bf3722d834fde21e"
          },
          {
            "type": "html",
            "text": "\nAnd <b>that</b> is the magic of [[Meta Circular Evaluator]]s: they reflect an underlying magic of the languages in which they are possible.",
            "id": "01b9a9319224aac11bb3da5f82d87015"
          },
          {
            "type": "html",
            "text": "\nSo it's a mistake to call something a [[Meta Circular Evaluator]] just because it's written in itself; that's not sufficient. [[Boot Strapping]] is a minor kind of magic, but metacircularity is a more major kind of magic. Which is why the C world talks about \"bootstrapping a C compiler\", not about \"metacircular C compilers\". ",
            "id": "f78273ba85cb265ac3a1bed6b25dd764"
          },
          {
            "type": "html",
            "text": "<i>I'm not sure that you can have a metacircular compiler in any language.  Metacircular evaluators are interpreters, right?</i>",
            "id": "cf5df0c2f23efcb3a9becb1873f8c67f"
          },
          {
            "type": "html",
            "text": " That is in fact my understanding (except that a system that behaves as an interpreter can be transparently implemented as a compiler), but after the wars on the [[Homoiconic Languages]] pages, it seems likely that this would be contested, so a persuasive argument would be in order, not just an assertion.",
            "id": "65874d68b15a56cefa3ceb5503323939"
          },
          {
            "type": "html",
            "text": "\nThere are some excellent documents out there about the [[Meta Circular Evaluator]], based on [[Lisp Language]]:",
            "id": "5893b4bdfe676fa1a2618b31cf7092f4"
          },
          {
            "type": "html",
            "text": " [[Paul Graham]], \"The Roots of Lisp\" - [http://www.paulgraham.com/rootsoflisp.html www.paulgraham.com]",
            "id": "bfc776dcef8654cb5f9fce118ecc3961"
          },
          {
            "type": "html",
            "text": " [[Guy Steele]] and [[Gerald Sussman]], \"[[The Art Of The Interpreter]]\"",
            "id": "13f9ad5c4b90b2684a8e0bf413920b2a"
          },
          {
            "type": "html",
            "text": " The book [[Structure And Interpretation Of Computer Programs]] contains a chapter dedicated to [[Meta Circular Evaluator]]s ... although it gives a definition incompatible with the one given on this page.",
            "id": "19f2bf904446d733f8fca23d03a57a79"
          },
          {
            "type": "html",
            "text": " The paper \"A Simple Reflective Interpreter\" (1992) by [[Stanley Jefferson]] and [[Daniel Friedman]] (see [http://citeseer.nj.nec.com/jefferson92simple.html citeseer.nj.nec.com]) contains an implementation of a minimal [[Scheme Language]] interpreter in Scheme such that every instance of the interpreter can be used to run another interpreter while providing access to the next higher level. Also see [[Reflective Tower]].",
            "id": "038e261cb3700e4a99acf50788bf37d4"
          },
          {
            "type": "html",
            "text": "\nTo see the modern outgrowth of such things, web search \"reflective towers\", or see \"A Tutorial on Behavioral Reflection and its Implementation\" at [http://www2.parc.com/csl/groups/sda/projects/reflection96/docs/malenfant/ref96/ref96.html www2.parc.com]",
            "id": "c689a839104546bcee1bdb50c5fe8a5b"
          },
          {
            "type": "html",
            "text": "<i>Are there examples of [[Meta Circular Evaluator]] other than in the Lisp family (CL, Scheme)?</i>",
            "id": "93682bdfd541fc6c916e0991afe7cc56"
          },
          {
            "type": "html",
            "text": "\nMost [[Forth Language]] implementations use a non-extensible interpreter and compiler, because of [[You Aint Gonna Need It]].  So, when it comes time to extend the interpreter and/or compiler in a way that simple colon definitions or immediate words cannot, most folks implement their own interpreter and compiler, suitable extended for their needs, but otherwise relying on the same basic tools that the existing interpreter and compiler use.",
            "id": "23ffb06376ee56ed55496bd737a21b15"
          },
          {
            "type": "html",
            "text": "\nFor example, here is a simple metacircular interpreter in arbitrary dialect Forth:",
            "id": "59e988b504f0edbefb6edcf91bdb7a16"
          },
          {
            "type": "html",
            "text": "myInterpreter",
            "id": "5a3a97f438b03342712353334186e532"
          },
          {
            "type": "code",
            "text": "    begin 32 word find dup if execute else number then again ;",
            "id": "1b6780640b79ee39ca94a3113615fced"
          },
          {
            "type": "html",
            "text": "\nAnd here would be a compiler:",
            "id": "71a0ccd2e8dc9789df5723e50857d37a"
          },
          {
            "type": "html",
            "text": "my-]",
            "id": "1c40ee27251b7827caf986b143d76df8"
          },
          {
            "type": "code",
            "text": "    begin 32 word find dup if dup immediate? if execute else compile then else compile-number then again ;",
            "id": "6bbfc88cb8b029f6150b97c6b5e9761b"
          },
          {
            "type": "html",
            "text": "\nA word such as [ would be an immediate word, which manipulates the return stack (or in ANSI-like dialects, would change the state of a variable imaginatively called STATE) to break out of the compiler loop, while a word like ] usually is the compiler itself.  This preserves Forth's [ and ] semantics.  Of course, you'll also need to re-implement : and :NONAME as well, but these are rather trivial.",
            "id": "72060f311340510fad2bd6f9e8874a5a"
          },
          {
            "type": "html",
            "text": "\nFor a concrete example, here's how to change the compiler so that all words prefixed by the back-tick are POSTPONEd:",
            "id": "0123f3ac1eac91b947b7ef232963c9d5"
          },
          {
            "type": "code",
            "text": "  \\ not tested code; but it would look/feel a lot like this.",
            "id": "9a4e8913d813631f8a77db5053df3309"
          },
          {
            "type": "code",
            "text": "  create macro-buffer 80 allot\n  : create-postpone-macro\n    S\" POSTPONE \" macro-buffer 1+ swap move      ( embed the \"POSTPONE \" part into the buffer )\n    count dup -rot macro-buffer 10 + swap move   ( embed the name of the word after POSTPONE  )\n    9 + macro-buffer c! ;                        ( and set the length of the whole string.    )",
            "id": "cf8e765520ccaa525af1e6fc4675edbe"
          },
          {
            "type": "html",
            "text": "word-starts-with-`?",
            "id": "e9472dd33fb6c5c2610e0fc0608eddc3"
          },
          {
            "type": "code",
            "text": "    dup 1+ c@ [char] ` = ;",
            "id": "8397d9b30d07f0785843f0b12d91bff5"
          },
          {
            "type": "html",
            "text": "new-]",
            "id": "32ac866306daf69f3f6aeceb7a107b6f"
          },
          {
            "type": "code",
            "text": "    state on\n    begin 32 word find dup\n          if   dup 0<\n               if   execute ( it was an immediate word )\n               else compile ( it wasn't an immediate, so compile it instead )\n          else word-starts-with-`?\n               if   compute-postpone-macro  macro-buffer count evaluate\n               else number literal\n               then\n          then\n    state @ 0= until ;",
            "id": "3d3d26421d02a2ebfc685b4975a607f5"
          },
          {
            "type": "html",
            "text": ":",
            "id": "6d396364d31b2aee0b495cd79bebcfb9"
          },
          {
            "type": "html",
            "text": "(:) new-] ;   ( most Forth systems have a word like (:), that implements the core of :<br>without actually invoking the compiler )",
            "id": "5aa6606d7b9b8293d00526b302128d2c"
          },
          {
            "type": "html",
            "text": "]",
            "id": "1b73706833986cbea0465c82093beca8"
          },
          {
            "type": "code",
            "text": "    new-] ; immediate   ( note this word compiled with the \"new\" :-compiler! )",
            "id": "796e0aa9dcaf0387374ca988a1aca5d5"
          },
          {
            "type": "html",
            "text": "\nAnd that <i>should</i> be it.  Yeah, it's a bit more complex than just creating a reader macro in Lisp, but hey, when the whole thing compiles to maybe 300 bytes or less on a 32-bit system, you could afford some 15 of these things in memory before you even hit the complexity of the reader itself, let alone the interpreter and compiler logic.  :-)",
            "id": "ae7107c90133fa4bb534fac781f0f455"
          },
          {
            "type": "html",
            "text": "(Not sure who changed the ] to [ characters.  In Forth, [ is used to enter into interpreter mode from inside a definition.  This allows compile-time pre-computed constants with zero run-time overhead, like this:  : abc  blah [ 2 4 * 5 6 * + ] literal blort ;.  Hence, ] is the entry-point to the compiler, NOT [.)",
            "id": "32f51f158c6217a846c089993730ca7e"
          },
          {
            "type": "html",
            "text": "--[[Samuel Falvo]]",
            "id": "84b9ff71a00502a6986fbfad694342fc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "3ef159e77952ce45cd740a9b2caecdf8"
          },
          {
            "type": "html",
            "text": "\nI'm sure I'm misunderstanding the definition somewhere, because as far as I can tell <i>any</i> dynamic language would inherently be metacircular, since they basically all have some sort of eval instruction.",
            "id": "1f88bdf0354ee5c5dd3bc8e9178ebd5c"
          },
          {
            "type": "code",
            "text": "  def python_interpreter(code):\n    exec code",
            "id": "7748634038ceb511431b8bc1b95faadd"
          },
          {
            "type": "code",
            "text": "  def ruby_interpreter code\n    eval code\n  end",
            "id": "8cf7174a1fc9f5752c58b382e215a39e"
          },
          {
            "type": "html",
            "text": "\nHow is this any different from implementing a Lisp interpeter using Lisp's eval?",
            "id": "654054883c7924a6eccb5f707230de1b"
          },
          {
            "type": "html",
            "text": "--[[David Mc Lean]]",
            "id": "665cc6263d9d1da895d72348689d0c07"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?MetaCircularEvaluator c2.com]",
            "id": "2a6f75629dc96a154ff8503f31a7d201"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1628075575800
    }
  ]
}