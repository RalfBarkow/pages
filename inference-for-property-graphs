{
  "title": "Inference for Property Graphs",
  "story": [
    {
      "type": "paragraph",
      "id": "5a467b869656e797",
      "text": "Existing PG schema inference methods in available graph databases (such as Neo4j) are simplistic in that they can only output basic edge types and node types and do not take into account the complexity of the PG data model. In particular, they cannot handle complex data types, overlapping node types or node hierarchies. [https://openproceedings.org/2021/conf/edbt/p279.pdf pdf]"
    },
    {
      "type": "markdown",
      "id": "d9cfd69cffcfcdf1",
      "text": "Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1664298521267577nzExG:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]\n> *Baseline Comparison*. We first compare the schemas inferred by our label-oriented approach with a baseline, the schemas returned by the Neo4j call db.schema query (cf. Table 2). The latter outputs many spurious types as it only targets single-labeled node types, even in the presence of multi-labeled node instances. Moreover, no property types or cardinality constraints can be captured, as opposed to our proposed method. As a result, the baseline schema is not accurate and error-prone."
    },
    {
      "type": "paragraph",
      "id": "65a53b6da5d2ade9",
      "text": "I wonder what their algorithm would produce for property type for this graph?"
    },
    {
      "type": "paragraph",
      "id": "7fc08d060d2b894e",
      "text": "[…] Their baseline is Neo4j db.schema which was first done with five lines of cypher but then converted to java code to work on larger graphs. I based my version on their cypher, converted to javascript, and added the ability to pick up property keys, but not values or value types. I didn't do the keys until last night when Ralf suggested downloading the schema in a format compatible with the Injector. [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1664299560268196OTusK:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]]\n"
    },
    {
      "type": "paragraph",
      "id": "3dde094e53c73d45",
      "text": "I think I will have to drop the word \"schema\" because most people associate it with a validation that must be passed to be acceptable. We're using it more as guidance of the, \"have you thought about this?\" form."
    },
    {
      "type": "paragraph",
      "id": "87e179cce7dca21d",
      "text": "⇒ [[Schema Evolution]]"
    },
    {
      "type": "markdown",
      "id": "17b4b6d8c1805be3",
      "text": "> The schemas that (property) graph database systems typically provide are descriptive in the sense that they only reflect the data: **the schema can be changed simply by manipulating the data instance directly with no particular restrictions on any such manipulations**. The flexibility that this entails is generally perceived as a valuable characteristic, particularly in the earlier stages of application development, and especially in conjunction with the now ubiquitous agile software development method. A system that allows for the structure of graph elements to be manipulated and refactored freely, as the understanding and modelling of an application’s universe evolves, greatly simplifies the development process in its early stages."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Inference for Property Graphs",
        "story": []
      },
      "date": 1664313953575
    },
    {
      "id": "5a467b869656e797",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "5a467b869656e797",
        "text": "Existing PG schema inference methods in available graph databases (such as Neo4j) are simplistic in that they can only output basic edge types and node types and do not take into account the complexity of the PG data model. In particular, they cannot handle complex data types, overlapping node types or node hierarchies. [https://openproceedings.org/2021/conf/edbt/p279.pdf pdf]"
      },
      "date": 1664313997222
    },
    {
      "id": "d9cfd69cffcfcdf1",
      "type": "add",
      "item": {
        "type": "markdown",
        "id": "d9cfd69cffcfcdf1",
        "text": "Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1664298521267577nzExG:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]\n> Baseline Comparison. We first compare the schemas inferred by our label-oriented approach with a baseline, the schemas returned by the Neo4j call db.schema query (cf. Table 2). The latter outputs many spurious types as it only targets single-labeled node types, even in the presence of multi-labeled node instances. Moreover, no property types or cardinality constraints can be captured, as opposed to our proposed method. As a result, the baseline schema is not accurate and error-prone."
      },
      "after": "5a467b869656e797",
      "date": 1664314002276
    },
    {
      "item": {
        "type": "factory",
        "id": "65a53b6da5d2ade9"
      },
      "id": "65a53b6da5d2ade9",
      "type": "add",
      "after": "d9cfd69cffcfcdf1",
      "date": 1664314047129
    },
    {
      "type": "edit",
      "id": "65a53b6da5d2ade9",
      "item": {
        "type": "paragraph",
        "id": "65a53b6da5d2ade9",
        "text": "I wonder what their algorithm would produce for property type for this graph?"
      },
      "date": 1664314048703
    },
    {
      "item": {
        "type": "factory",
        "id": "7fc08d060d2b894e"
      },
      "id": "7fc08d060d2b894e",
      "type": "add",
      "after": "65a53b6da5d2ade9",
      "date": 1664314080801
    },
    {
      "type": "edit",
      "id": "7fc08d060d2b894e",
      "item": {
        "type": "paragraph",
        "id": "7fc08d060d2b894e",
        "text": "[…] Their baseline is Neo4j db.schema which was first done with five lines of cypher but then converted to java code to work on larger graphs. I based my version on their cypher, converted to javascript, and added the ability to pick up property keys, but not values or value types. I didn't do the keys until last night when Ralf suggested downloading the schema in a format compatible with the Injector.\nI think I will have to drop the word \"schema\" because most people associate it with a validation that must be passed to be acceptable. We're using it more as guidance of the, \"have you thought about this?\" form."
      },
      "date": 1664314084616
    },
    {
      "type": "edit",
      "id": "7fc08d060d2b894e",
      "item": {
        "type": "paragraph",
        "id": "7fc08d060d2b894e",
        "text": "[…] Their baseline is Neo4j db.schema which was first done with five lines of cypher but then converted to java code to work on larger graphs. I based my version on their cypher, converted to javascript, and added the ability to pick up property keys, but not values or value types. I didn't do the keys until last night when Ralf suggested downloading the schema in a format compatible with the Injector.\n"
      },
      "date": 1664314109077
    },
    {
      "type": "add",
      "id": "3dde094e53c73d45",
      "item": {
        "type": "paragraph",
        "id": "3dde094e53c73d45",
        "text": "I think I will have to drop the word \"schema\" because most people associate it with a validation that must be passed to be acceptable. We're using it more as guidance of the, \"have you thought about this?\" form."
      },
      "after": "7fc08d060d2b894e",
      "date": 1664314112552
    },
    {
      "type": "edit",
      "id": "7fc08d060d2b894e",
      "item": {
        "type": "paragraph",
        "id": "7fc08d060d2b894e",
        "text": "[…] Their baseline is Neo4j db.schema which was first done with five lines of cypher but then converted to java code to work on larger graphs. I based my version on their cypher, converted to javascript, and added the ability to pick up property keys, but not values or value types. I didn't do the keys until last night when Ralf suggested downloading the schema in a format compatible with the Injector. [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1664299560268196OTusK:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]]\n"
      },
      "date": 1664314121965
    },
    {
      "item": {
        "type": "paragraph",
        "id": "87e179cce7dca21d",
        "text": "⇒ [[Schema Evolution]]"
      },
      "id": "87e179cce7dca21d",
      "type": "add",
      "after": "3dde094e53c73d45",
      "date": 1664314247091
    },
    {
      "type": "edit",
      "id": "87e179cce7dca21d",
      "item": {
        "type": "paragraph",
        "id": "87e179cce7dca21d",
        "text": "⇒ [[Schema Evolution]]"
      },
      "date": 1664314260926
    },
    {
      "id": "17b4b6d8c1805be3",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "17b4b6d8c1805be3",
        "text": "The schemas that (property) graph database systems typically provide are descriptive in the sense that they only reflect the data: the schema can be changed simply by manipulating the data instance directly with no particular restrictions on any such manipulations. The flexibility that this entails is generally perceived as a valuable characteristic, particularly in the earlier stages of application development, and especially in conjunction with the now ubiquitous agile software development method. A system that allows for the structure of graph elements to be manipulated and refactored freely, as the understanding and modelling of an application’s universe evolves, greatly simplifies the development process in its early stages."
      },
      "after": "87e179cce7dca21d",
      "date": 1664314401886,
      "error": {
        "type": "error",
        "msg": ""
      }
    },
    {
      "type": "fork",
      "date": 1664314471339
    },
    {
      "type": "fork",
      "date": 1664314540591
    },
    {
      "type": "edit",
      "id": "17b4b6d8c1805be3",
      "item": {
        "type": "paragraph",
        "id": "17b4b6d8c1805be3",
        "text": "> The schemas that (property) graph database systems typically provide are descriptive in the sense that they only reflect the data: the schema can be changed simply by manipulating the data instance directly with no particular restrictions on any such manipulations. The flexibility that this entails is generally perceived as a valuable characteristic, particularly in the earlier stages of application development, and especially in conjunction with the now ubiquitous agile software development method. A system that allows for the structure of graph elements to be manipulated and refactored freely, as the understanding and modelling of an application’s universe evolves, greatly simplifies the development process in its early stages."
      },
      "date": 1664314553591
    },
    {
      "type": "edit",
      "id": "17b4b6d8c1805be3",
      "item": {
        "type": "markdown",
        "id": "17b4b6d8c1805be3",
        "text": "> The schemas that (property) graph database systems typically provide are descriptive in the sense that they only reflect the data: the schema can be changed simply by manipulating the data instance directly with no particular restrictions on any such manipulations. The flexibility that this entails is generally perceived as a valuable characteristic, particularly in the earlier stages of application development, and especially in conjunction with the now ubiquitous agile software development method. A system that allows for the structure of graph elements to be manipulated and refactored freely, as the understanding and modelling of an application’s universe evolves, greatly simplifies the development process in its early stages."
      },
      "date": 1664314554763
    },
    {
      "type": "edit",
      "id": "d9cfd69cffcfcdf1",
      "item": {
        "type": "markdown",
        "id": "d9cfd69cffcfcdf1",
        "text": "Ward via [https://matrix.to/#/!ORfrUEFeWFcHAMLFLr:matrix.org/$1664298521267577nzExG:matrix.org?via=matrix.org&via=matrix.allmende.io&via=chat.weho.st matrix]\n> *Baseline Comparison*. We first compare the schemas inferred by our label-oriented approach with a baseline, the schemas returned by the Neo4j call db.schema query (cf. Table 2). The latter outputs many spurious types as it only targets single-labeled node types, even in the presence of multi-labeled node instances. Moreover, no property types or cardinality constraints can be captured, as opposed to our proposed method. As a result, the baseline schema is not accurate and error-prone."
      },
      "date": 1664314683242
    },
    {
      "type": "edit",
      "id": "17b4b6d8c1805be3",
      "item": {
        "type": "markdown",
        "id": "17b4b6d8c1805be3",
        "text": "> The schemas that (property) graph database systems typically provide are descriptive in the sense that they only reflect the data: **the schema can be changed simply by manipulating the data instance directly with no particular restrictions on any such manipulations**. The flexibility that this entails is generally perceived as a valuable characteristic, particularly in the earlier stages of application development, and especially in conjunction with the now ubiquitous agile software development method. A system that allows for the structure of graph elements to be manipulated and refactored freely, as the understanding and modelling of an application’s universe evolves, greatly simplifies the development process in its early stages."
      },
      "date": 1664314816279
    }
  ]
}