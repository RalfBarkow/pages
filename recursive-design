{
  "title": "Recursive Design",
  "story": [
    {
      "type": "html",
      "text": "Originally coined for the [[Shlaer Mellor Method]], [[Recursive Design]] is the\napproach to translative software construction where the translator\nis part of the source code of the project, and the translator is\nalso developed using this translative approach.",
      "id": "6b69f0103323474e5c9ae40389f3066c"
    },
    {
      "type": "html",
      "text": "\nThis contrasts with the approach of many OOD CASE tools which attempt to\ndeliver [[One Size Fits All]] code generators. This approach gives code generation\na bad name, because the impression is given that code generation is only suitable for situations where performance is unimportant.",
      "id": "44a20d8f893a06fc13a3cefc18c6e127"
    },
    {
      "type": "html",
      "text": "\nThe generic approach to code generation works well for translating a low\nlevel language (such as C) to machine code. It is usable for higher level\nlanguages, but there is an increasing disconnect between the source code\nand the target machine. The translation of the higher level descriptions\nrequire tradeoffs to be made in the translation. Once these tradeoffs\ngo beyond basic speed/size tradeoffs then project specific translators\nbecome a sensible approach for optimisation.",
      "id": "397f8b6b3950d0f6eefebc7b43589075"
    },
    {
      "type": "html",
      "text": "\nThe [[Shlaer Mellor Method]] provides a simple formalism that allows you\nto build models that are easy to write translators for. The simplicity\nof this formalism leaves it open to criticisms (some valid, IMHO) that\nit is too simple. Any comparison of Shlaer Mellor against traditional,\nfull-featured, formalisms tend to show SM in an unfavourable light.",
      "id": "94c6200e87fcf02496b3a02cb6adf527"
    },
    {
      "type": "html",
      "text": "\nBut the SM approach truely allows you to draw diagrams that are\nthe source code. SM originally came with its own notation, but is\nhas been shown that you can use a subset of the UML is you prefer.\nAs soon as you have a diagram, you can use a generic\ncode generator to run simple tests (and to gain insight into the\nbehaviour of the code/diagram). SM CASE tools will usually provide\nsimulators: these either interpret the models or generate highly\ninstrucmented code for the model. An orthogonal activity is to\nconstruct (and maintain) a code generator that produces code that\nmeets the performance/interface requirements of the system.",
      "id": "c357d5bccedf3e79821a5ce97c52907e"
    },
    {
      "type": "html",
      "text": "--[[Dave Whipp]]",
      "id": "fd7ed0265a03861e9bff8bf348e67111"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "fac7168c7c31a0cc638d7eadc6542045"
    },
    {
      "type": "html",
      "text": "\nSee [[Aspect Oriented Programming]], [[Meta Refactoring]].",
      "id": "48746cd3bde1e24b66a42728da5243e1"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?RecursiveDesign c2.com]",
      "id": "4b7827e21a9323adf26ff9c0ec3aacd2"
    }
  ],
  "journal": [
    {
      "date": 969975719000,
      "id": "45e498e35dbd815420cb01239a576af1",
      "type": "create",
      "item": {
        "title": "Recursive Design",
        "story": [
          {
            "type": "html",
            "text": "Originally coined for the [[Shlaer Mellor Method]], [[Recursive Design]] is the\napproach to translative software construction where the translator\nis part of the source code of the project, and the translator is\nalso developed using this translative approach.",
            "id": "6b69f0103323474e5c9ae40389f3066c"
          },
          {
            "type": "html",
            "text": "\nThis contrasts with the approach of many OOD CASE tools which attempt to\ndeliver [[One Size Fits All]] code generators. This approach gives code generation\na bad name, because the impression is given that code generation is only suitable for situations where performance is unimportant.",
            "id": "44a20d8f893a06fc13a3cefc18c6e127"
          },
          {
            "type": "html",
            "text": "\nThe generic approach to code generation works well for translating a low\nlevel language (such as C) to machine code. It is usable for higher level\nlanguages, but there is an increasing disconnect between the source code\nand the target machine. The translation of the higher level descriptions\nrequire tradeoffs to be made in the translation. Once these tradeoffs\ngo beyond basic speed/size tradeoffs then project specific translators\nbecome a sensible approach for optimisation.",
            "id": "397f8b6b3950d0f6eefebc7b43589075"
          },
          {
            "type": "html",
            "text": "\nThe [[Shlaer Mellor Method]] provides a simple formalism that allows you\nto build models that are easy to write translators for. The simplicity\nof this formalism leaves it open to criticisms (some valid, IMHO) that\nit is too simple. Any comparison of Shlaer Mellor against traditional,\nfull-featured, formalisms tend to show SM in an unfavourable light.",
            "id": "94c6200e87fcf02496b3a02cb6adf527"
          },
          {
            "type": "html",
            "text": "\nBut the SM approach truely allows you to draw diagrams that are\nthe source code. SM originally came with its own notation, but is\nhas been shown that you can use a subset of the UML is you prefer.\nAs soon as you have a diagram, you can use a generic\ncode generator to run simple tests (and to gain insight into the\nbehaviour of the code/diagram). SM CASE tools will usually provide\nsimulators: these either interpret the models or generate highly\ninstrucmented code for the model. An orthogonal activity is to\nconstruct (and maintain) a code generator that produces code that\nmeets the performance/interface requirements of the system.",
            "id": "c357d5bccedf3e79821a5ce97c52907e"
          },
          {
            "type": "html",
            "text": "--[[Dave Whipp]]",
            "id": "fd7ed0265a03861e9bff8bf348e67111"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "fac7168c7c31a0cc638d7eadc6542045"
          },
          {
            "type": "html",
            "text": "\nSee [[Aspect Oriented Programming]], [[Meta Refactoring]].",
            "id": "48746cd3bde1e24b66a42728da5243e1"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?RecursiveDesign c2.com]",
            "id": "4b7827e21a9323adf26ff9c0ec3aacd2"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1707907539514
    }
  ]
}