{
  "title": "Multiple Inheritance In Smalltalk",
  "story": [
    {
      "type": "html",
      "text": "Yes, there was once a form of [[Multiple Inheritance In Smalltalk]].",
      "id": "ad169f080e7dd7baba0c34a18a6d949c"
    },
    {
      "type": "html",
      "text": "\nIt was even used from time to time, and could probably still be made work. It used basic capabilities defined in standard Smalltalk, and thus requires no special magic (no VM or compiler changes are needed, for example).",
      "id": "8a6e4239fd8195232ef9a43d3f46a705"
    },
    {
      "type": "html",
      "text": "\nThe basic idea was to fake multiple superclasses by judicious use of [[Does Not Understand]]. The good news was that it worked (and can still be made to work once you know the mechanism). The bad news was that it was extremely slow, because every message send outside the \"primary\" (actual) superclass chain had to trap through DNU.",
      "id": "4c606d6a585e03f5f00f75589d52f7ba"
    },
    {
      "type": "html",
      "text": "\nOnce we learned that [[Delegation Is Inheritance]] (see OOPSLA Proceedings from 1987), the need for this was dramatically reduced.",
      "id": "72f77921c48d149c08d3ec655687eb4e"
    },
    {
      "type": "html",
      "text": "\nWhen used within a Liskov type hierarchy and properly resolved, [[Multiple Inheritance]] is still a good thing. For example, consider the design of class \"Matrix\". It has rows, columns, elements, and can be enumerated and pivoted. Thus, it certainly wants to behave like a collection. It also participates in arithmetic operations ... instances respond to \"+\", \"-\", \"=\", and so on (ignoring dot- and cross- products for the time being). Another example is \"Complex\", which wants to act like both an Association and a Magnitude.",
      "id": "573c02e373e9042a041ad3095f8a36fd"
    },
    {
      "type": "html",
      "text": "\nThese are cases where [[Multiple Inheritance]], in my opinion, really <i>is</i> the best and most supportable solution. Yes, it can be simulated through delegation or protocol-copying. But the basic concept is still [[Multiple Inheritance]].",
      "id": "5b3aa1787820a0eca3a2b42db915dc80"
    },
    {
      "type": "html",
      "text": "\nIf anyone really wants to know, I can dig up the old Smalltalk source for [[Multiple Inheritance In Smalltalk]] -- I have it in hard-copy.",
      "id": "56ba57f7fab7d20bf54591f0af2116cf"
    },
    {
      "type": "html",
      "text": "-- [[Tom Stambaugh]]",
      "id": "37ab5d9e811cf8b21f8492f4e8135b92"
    },
    {
      "type": "html",
      "text": "<i>Hmmm.. I'll bet a prototype-based language like [[Java Script]] or [[Self Language]] could do this better.</i>",
      "id": "a187a9ef91383ab230acdc8b10e3c050"
    },
    {
      "type": "html",
      "text": "\nYes, perhaps -- though I'm dubious about [[Java Script]]. [[Self Language]] and [[Lisp Language]] both do fine in this regard, bearing in mind their other limitations. -- [[Tom Stambaugh]]",
      "id": "5a832aac83fd7d42fb1d36ad71f40935"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c71d418c1a88403f5b640517f074ae6d"
    },
    {
      "type": "html",
      "text": "Smalltalk-80 actually had a tool that generated a multiply-inheriting class by generating the delegation mechanisms: you specified the superclasses, it made an instance variable to hold an instance of each one, generated an #initialize method to create the instances, generated a delegation method for every method found in (or inherited by) exactly one of the super classes, and complained about methods defined by more than one superclass (or generated an empty method body for you to resolve, or something like that).  I seem to remember [[Alan Borning]] being the author.  Like Inheritance itself, Multiple Inheritance is both a design concept and an implementation concept, and the two are independent: you can have a non-MI implementation of an MI design and an MI implementation of a non-MI design (for instance, using private base classes in C++ for implementation convenience, as used extensively in the Rogue Wave Tools.h++ collection libarary.)  -- [[Mitchell Model]]",
      "id": "d2165af401f997524502d4a85353e955"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "c71d418c1a88403f5b640517f074ae6d"
    },
    {
      "type": "html",
      "text": "\nSee also [[Is Smalltalk Complete]]? for more MI discussion. And [[Multiple Inheritance Is Not Evil]] for staunch defence.",
      "id": "0e64e95c17631bc261fec0561b50b4aa"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?MultipleInheritanceInSmalltalk c2.com]",
      "id": "1263c15980918fdc6f25711744b85dd2"
    }
  ],
  "journal": [
    {
      "date": 1136348541000,
      "id": "42a6a2ace05dafdbfe9f317179b9d006",
      "type": "create",
      "item": {
        "title": "Multiple Inheritance In Smalltalk",
        "story": [
          {
            "type": "html",
            "text": "Yes, there was once a form of [[Multiple Inheritance In Smalltalk]].",
            "id": "ad169f080e7dd7baba0c34a18a6d949c"
          },
          {
            "type": "html",
            "text": "\nIt was even used from time to time, and could probably still be made work. It used basic capabilities defined in standard Smalltalk, and thus requires no special magic (no VM or compiler changes are needed, for example).",
            "id": "8a6e4239fd8195232ef9a43d3f46a705"
          },
          {
            "type": "html",
            "text": "\nThe basic idea was to fake multiple superclasses by judicious use of [[Does Not Understand]]. The good news was that it worked (and can still be made to work once you know the mechanism). The bad news was that it was extremely slow, because every message send outside the \"primary\" (actual) superclass chain had to trap through DNU.",
            "id": "4c606d6a585e03f5f00f75589d52f7ba"
          },
          {
            "type": "html",
            "text": "\nOnce we learned that [[Delegation Is Inheritance]] (see OOPSLA Proceedings from 1987), the need for this was dramatically reduced.",
            "id": "72f77921c48d149c08d3ec655687eb4e"
          },
          {
            "type": "html",
            "text": "\nWhen used within a Liskov type hierarchy and properly resolved, [[Multiple Inheritance]] is still a good thing. For example, consider the design of class \"Matrix\". It has rows, columns, elements, and can be enumerated and pivoted. Thus, it certainly wants to behave like a collection. It also participates in arithmetic operations ... instances respond to \"+\", \"-\", \"=\", and so on (ignoring dot- and cross- products for the time being). Another example is \"Complex\", which wants to act like both an Association and a Magnitude.",
            "id": "573c02e373e9042a041ad3095f8a36fd"
          },
          {
            "type": "html",
            "text": "\nThese are cases where [[Multiple Inheritance]], in my opinion, really <i>is</i> the best and most supportable solution. Yes, it can be simulated through delegation or protocol-copying. But the basic concept is still [[Multiple Inheritance]].",
            "id": "5b3aa1787820a0eca3a2b42db915dc80"
          },
          {
            "type": "html",
            "text": "\nIf anyone really wants to know, I can dig up the old Smalltalk source for [[Multiple Inheritance In Smalltalk]] -- I have it in hard-copy.",
            "id": "56ba57f7fab7d20bf54591f0af2116cf"
          },
          {
            "type": "html",
            "text": "-- [[Tom Stambaugh]]",
            "id": "37ab5d9e811cf8b21f8492f4e8135b92"
          },
          {
            "type": "html",
            "text": "<i>Hmmm.. I'll bet a prototype-based language like [[Java Script]] or [[Self Language]] could do this better.</i>",
            "id": "a187a9ef91383ab230acdc8b10e3c050"
          },
          {
            "type": "html",
            "text": "\nYes, perhaps -- though I'm dubious about [[Java Script]]. [[Self Language]] and [[Lisp Language]] both do fine in this regard, bearing in mind their other limitations. -- [[Tom Stambaugh]]",
            "id": "5a832aac83fd7d42fb1d36ad71f40935"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c71d418c1a88403f5b640517f074ae6d"
          },
          {
            "type": "html",
            "text": "Smalltalk-80 actually had a tool that generated a multiply-inheriting class by generating the delegation mechanisms: you specified the superclasses, it made an instance variable to hold an instance of each one, generated an #initialize method to create the instances, generated a delegation method for every method found in (or inherited by) exactly one of the super classes, and complained about methods defined by more than one superclass (or generated an empty method body for you to resolve, or something like that).  I seem to remember [[Alan Borning]] being the author.  Like Inheritance itself, Multiple Inheritance is both a design concept and an implementation concept, and the two are independent: you can have a non-MI implementation of an MI design and an MI implementation of a non-MI design (for instance, using private base classes in C++ for implementation convenience, as used extensively in the Rogue Wave Tools.h++ collection libarary.)  -- [[Mitchell Model]]",
            "id": "d2165af401f997524502d4a85353e955"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "c71d418c1a88403f5b640517f074ae6d"
          },
          {
            "type": "html",
            "text": "\nSee also [[Is Smalltalk Complete]]? for more MI discussion. And [[Multiple Inheritance Is Not Evil]] for staunch defence.",
            "id": "0e64e95c17631bc261fec0561b50b4aa"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?MultipleInheritanceInSmalltalk c2.com]",
            "id": "1263c15980918fdc6f25711744b85dd2"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1626999148638
    }
  ]
}