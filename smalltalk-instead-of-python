{
  "title": "Smalltalk Instead Of Python",
  "story": [
    {
      "type": "html",
      "text": "[[Python Language]] and [[Smalltalk Language]] seem comparable in many ways, but their origins and styles are very different. On this page we're trying to figure out when to use [[Smalltalk Instead Of Python]].",
      "id": "e5a36ad519637498e26760ac10988faa"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>Syntax</b>",
      "id": "be8e93cc3d3a3491f6cd8dd057ed7751"
    },
    {
      "type": "html",
      "text": "\nIf, like most programmers, you come from an [[Algol Family]] background, then Smalltalk syntax looks pretty obscure at first. Consider:",
      "id": "a80a593b8ddbeada7139571fa6651fca"
    },
    {
      "type": "html",
      "text": " One of the [[Smalltalk Tutorials]]",
      "id": "0146b73fac40b753f7c60c81fd3882d5"
    },
    {
      "type": "html",
      "text": " [[Smalltalk Syntax]]",
      "id": "bb9c0c9c6cf1444720338f1cbe3747d8"
    },
    {
      "type": "html",
      "text": " [[Smalltalk Message Rules]]",
      "id": "3bb16d774ea7b8c7cacf35d14ef52bc9"
    },
    {
      "type": "html",
      "text": " The short-but-sweet book:<br>[[On To Smalltalk]]",
      "id": "a976982f4e89c40bd4ae71b3ba462042"
    },
    {
      "type": "html",
      "text": "\nPython, on the other hand, is notoriously easy for an [[Algol Family]] programmer to learn, and comes with several truly excellent tutorials. The main difference you'll find is that Python uses indentation rather than braces to control scope. (See [[Python White Space Discussion]].) It's not too much to expect any competent programmer to learn most of the Python syntax in a day, and to become fluent in a couple of weeks.",
      "id": "51206d76c863c2275e40b56ec2f38016"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>Speed</b>",
      "id": "1de30c76ba9c0db67178b768369e626f"
    },
    {
      "type": "html",
      "text": "\n[[Java Python]] is the speed of [[Java Language]] which is about as fast as [[Smalltalk Language]]. <i>Are there any numbers on that claim? The professional Smalltalk vendors still claim that their [[Virtual Machine]]s are faster than Java's.</i> Regular [[Python Language]] is as much as 2.5 times faster than Jython, according to the Jython faq. Some [[Just In Time Compiler]]s may bring Jython up to par with regular Python. Does this mean [[Small Talk]] is slower? <i>Jury's out</i> Who cares: use [[Alternate Hard And Soft Layers]]. <i>[[Smalltalk Em Tee]] produces very fast compiled code on [[Microsoft Windows]]--DLLs, [[Activex Technology]] controls, the lot.</i>",
      "id": "610ed840b949da2249a0f2d05c4d2422"
    },
    {
      "type": "html",
      "text": "\nThe development of [[Python Language]] has focused more on speed of development than speed of program execution. I certainly doubt that CPython is 2.5 times faster than [[Java Language]], which is suggested above. But as you know, benchmarks only tell us how fast the actually benchmarked code is. There are some references to Python performance on the web. [http://www.flat222.org/mac/bench/ www.flat222.org] [http://shootout.alioth.debian.org/ shootout.alioth.debian.org] As usual, these tests focus on tiny, meaningless programs, so I'd take them with a pinch of salt. And they don't compare with [[Smallalk Language]]...  ",
      "id": "e1d9695e1b47f146de2b8edc5adf2dfd"
    },
    {
      "type": "html",
      "text": "<i>[http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=vw&lang2=python shootout.alioth.debian.org] measures Python implementations and Smalltalk implementations.</i>",
      "id": "4c6646606dd6e12a5451539e753167f3"
    },
    {
      "type": "html",
      "text": "\nIs [[Java Python]] really the speed of [[Java Language]]? Sure, Jython can be compiled into Java bytecode, but will it look just as the bytecode of a comparable Java program? I think the dynamic nature of Python/Jython will lead to more complex bytecode.",
      "id": "b8786be8db5bc868f72e402778f6dd07"
    },
    {
      "type": "html",
      "text": "<i>No, Jython is not the speed of Java. I think it's like 10x slower than Java, because many portions are interpreted. (10x slower for what kind of code? Numbers lie...) CPython is faster than Jython. I personally consider Jython to be niche, useful for environments where [[Java Language]] is entrenched or otherwise required.</i>",
      "id": "c13dcdf4731c8807bf3ba6d083f178bd"
    },
    {
      "type": "html",
      "text": "<i>Python performance is Good Enough, for nearly any definition of \"Good Enough\". Because it is easy to use [[Cee Language]] code with [[Python Language]], portions of your code can be refactored to speed up your program. Of course, C is harder than Python, so you only do this as necessary, but there is always at least a path out. Also, you can use C libraries that are created and packaged by other people (which is what I do), and eventually the whole community benefits. -- [[Ian Bicking]]</i>",
      "id": "3a427df9ffa39566ab02b1cdeaa8692a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>Tools</b>",
      "id": "4a7b545bda010d6c28f36eca5bd880ea"
    },
    {
      "type": "html",
      "text": "<b>Smalltalk:</b> IDLE is some of the way there, but there's nothing comparable to the [[Refactoring Browser]], or even an object inspector.",
      "id": "cc1742a8dffc9b3f20fddd631abf0be3"
    },
    {
      "type": "html",
      "text": "<b>Python:</b> If you prefer an editor to an IDE, this is moot. A [[Python Refactoring Browser]] would be really nice though. Thank you, [[Bicycle Repair Man]]!",
      "id": "785bfc26e8ef93ab33750921fc958530"
    },
    {
      "type": "html",
      "text": "\nBut see more on this on [[Ide Instead Of Editor]].",
      "id": "ab712a41ad2879a2f8d1e0ab28a06fb0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>[[Gem Stone]]</b>",
      "id": "bf24a96f7931886c3e8f3e14657a3b98"
    },
    {
      "type": "html",
      "text": "\nOnce unique to the [[Smalltalk Language]] world, a [[Java Language]] version ([[Gem Stonej]]) is evolving nicely. [[Gem Stone]] gives extraordinary power to develop large-scale applications, and is used in telecom, manufacturing, logistics, finance, and commerce. See also [[Gemstone Project]]. It's a high-performance server & scalable [[Object Oriented Database Management System]], capable of supporting over 1 billion objects.  ",
      "id": "71b4da17a6cd01fb6bad8274261427b5"
    },
    {
      "type": "html",
      "text": "\nYou can of course build a large scale python system over any RDBMS, but [[Gem Stone]] would likely trump that solution in flexibility. However, as [[Java Python]] is able to do everything Java can do, use/aggregate/compose/derive from any [[Java Language]] class, there's no difficulty using [[Gem Stone]] from [[Python Language]]. You could also use [[Java Python]] in combination with the Oracle [[Java Virtual Machine]].",
      "id": "c056de2778033bf97032a947d86ed3a8"
    },
    {
      "type": "html",
      "text": "<i>Note that [[Gem Stone]] Smalltalk is in many ways more flexible than the Java/[[Java Python]] route, primarily because it is more mature than [[Gem Stonej]]. It also benefits from Smalltalk's rich reflection & metaobject libraries when designing rich & adaptive frameworks.</i>",
      "id": "8bc2b55cb175f093999a01be5c590166"
    },
    {
      "type": "html",
      "text": "\n[[Zo Db]] (The Zope Object Database) is a (not-quite orthogonal) persistent store with transactional support, as well as other features. It is available separate from Zope, and many people use it as such. And it's [[Open Source]]. For a significant portion of the [[Python Language]] community, software is not valuable if it is [[Closed Source]] (a notable difference from [[Smalltalk Language]] circles), so an imaginary Gemstone/P would not matter much to us.",
      "id": "e9af7828eb8c833e184664d76fd1ea2f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>[[Zope Application Server]] (Zope)</b>",
      "id": "cb42e8f28bb3a59fca28ebf0543b0e7a"
    },
    {
      "type": "html",
      "text": "\nWhat's more Zope provides a free Python [[Object Oriented Database]], and a nice one. Nevertheless, [[Zo Db]]'s scaling attributes haven't been stressed or demonstrated. If you want to do data warehousing in [[Python Language]], you'll probably have to go the [[Java Python]]/[[Gem Stonej]] route.",
      "id": "b5ed09db8dbc8cd3475fb6e98876db66"
    },
    {
      "type": "html",
      "text": "\nZope may not be the ideal choice for mass storage / retrieval of arbitrary Foreign Objects. Still, why not put Zope / [[Zo Db]] to the test by building a Web-Based Python Development Environment, complete with a [[Python Refactoring Browser]]?",
      "id": "68238e072b6fbbe9775e1650f1889390"
    },
    {
      "type": "html",
      "text": "<i>[[Zo Db]] isn't really meant to be separated from Zope and used with other projects though, is it? I'm not asking this as an argument for [[Smalltalk Language]], but rather because I have other projects that I could use a good object store for, and I'm thinking of doing those projects in [[Python Language]] (as opposed to [[Java Language]] or [[Cee Language]]).</i>",
      "id": "6e77105da02d322884842c8038ade72d"
    },
    {
      "type": "html",
      "text": "\nThere's an excellent article on just this topic: [http://starship.python.net/crew/amk/python/writing/zodb-zeo.html starship.python.net]",
      "id": "2a4054eb056ca64c5e4a6e493f535cb5"
    },
    {
      "type": "html",
      "text": "\nZope is made up of several modules, which when used together form a Web Application Development Environment, but each can be used separately. [[Zo Db]] is a direct descendant of \"Bobo\", an [[Open Source]] [[Python Language]] module, that provides Persistence to Python Objects (an ODB). Typically [[Zo Db]] is used in conjunction with the Filestorage module, but the actual storage medium is abstracted, and there are existing alternatives.",
      "id": "c8f6432362721b2920d3e3866a7b797f"
    },
    {
      "type": "html",
      "text": "\nPerhaps the reference to data warehousing (above) is intended to caution against using the Zope native Object Database (ZODB) as an Object Data Warehouse. This is very different than using Zope as a Web Development Environment for building systems to access a \"traditional\" Data Warehouse. In this sense, Zope is very capable of managing the Python Objects that make up Zope itself, components of Web Applications created within Zope, as well as data held in external systems, which are \"objectified\" within the Zope context.",
      "id": "ed209107283670410c1589d9d4e91acc"
    },
    {
      "type": "html",
      "text": "\nIf you're looking at a Zope solution, you'll quickly notice that the interfaces to back-end datastores are quite mature and flexible. Zope is very adequate for accessing any traditional \"backend\" (tabular data, any [[Relational Data Base Management System]] such as [[Oracle Database]], [[Postgre Sql]]). This is the realm of [[Cold Fusion]], [[Active Server Pages]], and [[Php Language]]. Of these only PHP is [[Open Source]] and cross-platform, and none are [[Object Oriented]]. Unlike these, Zope has a powerful security model, and is a capable [[Content Management System]]. ",
      "id": "c4f723aa84237315c3fcdbc1d1815f5e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>Closures</b>",
      "id": "9cfbc845fe4695a87d51330421453281"
    },
    {
      "type": "html",
      "text": "<b>Python:</b> has [[First Class Function]]s that can be used just like [[Smalltalk Blocks And Closures]] (as far as I know). The [[Lambda Calculus]] functions are just [[Syntactic Sugar]] for one liners. They compile down to first class [[Anonymous Function]]s.  ",
      "id": "77332c593ae936aafba1cb104c0e66f5"
    },
    {
      "type": "html",
      "text": "<b>Smalltalk:</b> Something that I love to do in [[Smalltalk Language]], [[Ruby Language]] and [[Lisp Language]] but find frustrating in [[Python Language]] because of the lambdas:",
      "id": "96dfe64ec034396cfdde482c6992139f"
    },
    {
      "type": "html",
      "text": "^ anArray collect:<br>[ :each | each transform ]",
      "id": "4f5b0726d5cfc85f35b86784b201bd23"
    },
    {
      "type": "html",
      "text": "goes to",
      "id": "346eeabc9ad5ac61ca280d5254426beb"
    },
    {
      "type": "code",
      "text": "  map(lambda x:x.transform(), anArray)",
      "id": "4807cf78b2e55a0175afb2b5421c02ab"
    },
    {
      "type": "html",
      "text": "in Python.  Fine, if a mite yucky.  Unfortunately...",
      "id": "6c8ea340584f6c4254651bc0a6ba3591"
    },
    {
      "type": "html",
      "text": "^ anArray collect:<br>[ :each | self transform: each ]",
      "id": "1918a0b7b9a6feb5b6766b4d181955da"
    },
    {
      "type": "html",
      "text": "goes to",
      "id": "346eeabc9ad5ac61ca280d5254426beb"
    },
    {
      "type": "html",
      "text": "map(lambda x, self=self:<br>self.transform(x), anArray)",
      "id": "00cc0b1112959bd034c2eabf939fa672"
    },
    {
      "type": "html",
      "text": "which is yucky as all get out when the list of objects you need to use inside the lambda gets at all long. Python 3000 offers some hope, but the semantics aren't the only problem with doing this kind of mapping in Python <i>(But see Python's nifty [[List Comprehension]] syntax below!)</i>; the syntax is surprisingly klugey. Plus, you don't get the really cool stuff the Collection protocol gives you in Smalltalk: no includes, no isEmpty... you do have a select, but it has the same problems the map does, etc.",
      "id": "c4e2e5d0c81429672eacce33ac1d67c4"
    },
    {
      "type": "html",
      "text": "<i>Note: the second map example can actually be rewritten like this, which is far more readable:</i>",
      "id": "e10719783d8d295038b671d827fafd8d"
    },
    {
      "type": "code",
      "text": "  map( self.transform, anArray )",
      "id": "6dda683b927b909e872879ba9520b677"
    },
    {
      "type": "html",
      "text": "However, code that would use blocks in Smalltalk is less readable when written with functions in Python because code that should belong together is written in two separate places. Also, functions need to be named, which often leads to the auxiliary functions having awkward names or names that carry little useful information.",
      "id": "e69c5dc2052d681b30eadebcbf8c99ee"
    },
    {
      "type": "html",
      "text": "<b>Python:</b> In recent versions of Python (2.0 upwards)\nyou can use [[List Comprehension]]s:",
      "id": "ad9a369cea8b4f678f0cb12e3c7f9cd0"
    },
    {
      "type": "code",
      "text": "  return [x.transform() for x in anArray]\n  return [self.transform(x) for x in anArray]",
      "id": "dac5c17b4d185ba014bb70eeceaeedba"
    },
    {
      "type": "html",
      "text": "Versions 2.1 and up have properly nesting scopes (in 2.1 you need to do a little magic dance to enable them, but that will goes away in 2.2), so the \"foo=foo\" hack is no longer needed.",
      "id": "3bb08358707f47931866e5c2bf68b635"
    },
    {
      "type": "html",
      "text": "\nThere are two forces here: one is that the built-ins in [[Python Language]] tend not to have methods; int('foo') instead of 'foo' asNumber. (As of Python 2.0, strings have methods; though there is still no method for converting to a number.) The other is that [[Anonymous Function]]s are unpleasant in Python (though less so as of 2.1).",
      "id": "36773e175a0bc67213a55e5446abcca7"
    },
    {
      "type": "html",
      "text": "\nWho cares about closures? I practically never use 'em, nor lambdas neither. When would you use [[Closure Instead Of Object]]?",
      "id": "a091b7ba1aefd82f1cfbdf9b4160f460"
    },
    {
      "type": "html",
      "text": "<i>A closure does two things: It avoids giving a name to a block of code that doesn't need it, and it keeps the block of code as close as possible to where it is being used.</i> ",
      "id": "2e7f7537e3366e5f7aafcb64fcd420ea"
    },
    {
      "type": "html",
      "text": "\nIt does more than that, and just because you never use them doesn't mean they aren't extremely useful to those who do. Anonymous closures allow easy and clean use of [[Higher Order Function]]<b></b>'s, and allows a more [[Functional Programming]] style. The entire Smalltalk [[Collection Hierarchies]] [sic, sorry] is based upon higher-order functions and closures, so being able to create closures with an extremely light syntax is a huge, huge boon.",
      "id": "888a240086a324bf5cdfb2e2a1a1ce5b"
    },
    {
      "type": "html",
      "text": "[It's a matter of preference, not a huge boon. I generally prefer named functions, purely as a stylistic and aesthetic matter. It's also slightly easier to refactor. Anonymous blocks are <b>not</b> required for [[Functional Programming]] or the use of HOFs. Reasonable people can agree to disagree about this, but I wouldn't call it a failing on the part of [[Python Language]] (any more than I would count [[Smalltalk Language]]'s non-[[Algol Family]] syntax against it).]",
      "id": "a8b75b2571a0f3ad666583f3b62b6b46"
    },
    {
      "type": "html",
      "text": "\nOkay, so [[Stackless Python]] seems to make this a non-issue. Is there anything else to recommend Smalltalk over Python?",
      "id": "8006dc643774816636183a6cbd8d4693"
    },
    {
      "type": "html",
      "text": "<i>So [[Stackless Python]] adds [[Co Routine]]s. I fail to see how that provides me with the flexibility of a closure/block. This is one of my problems with [[Java Language]]: [[Anonymous Inner Class]]es are a poor & clunky substitute.</i>",
      "id": "ba76f8c5393c22e1af05001242ce905a"
    },
    {
      "type": "html",
      "text": "\nSee also [[Python Vs Ruby]], [[Blocks In Ruby]], [[Blocks In Python]], [[Blocks In Many Languages]].",
      "id": "7075f834591037359d5a62b6f929a4a4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>Books and Portability</b>",
      "id": "a8b87eb297f52e63218ee46b4cb1b34b"
    },
    {
      "type": "html",
      "text": "\n[[Smalltalk Language]] has more books than [[Python Language]], but more Python books are coming out. Some Smalltalk books are specialized to a particular vendor's implementation. This may cause minor problems of applicability, but overall most Smalltalk flavors are quite similar. Python essentially has only two mainstream implementations (Python and [[Java Python]], both free), and those two implementations are available an many platforms. Smalltalk is also available on many platforms ([[Sun Solaris]], [[Microsoft Windows]], [[Apple Macintosh]], [[Linux Os]], etc.)",
      "id": "f976d5edb2ac577f8fd1ac8ac0a0cd3e"
    },
    {
      "type": "html",
      "text": "<i>Smalltalk has a book by [[Kent Beck]] ([ISBN 013476904X]). Python doesn't.</i>",
      "id": "03f403c32f28057202f37a5c750d37e6"
    },
    {
      "type": "html",
      "text": "<i>Actually, Python now has part of a book by [[Kent Beck]] ([ISBN 0321146530]).</i>",
      "id": "5d061956ddf4ae37cc860f03ac03b089"
    },
    {
      "type": "html",
      "text": "<i>Python has several [[Animal Book]]s ([ISBN 1565924649], [ISBN 1565921976], [ISBN 1565926218], [ISBN 1565925009]).  Smalltalk doesn't.</i>",
      "id": "5a29a533f41fca0befb63b654a0afbe7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>Standards and Bindings</b>",
      "id": "3da9b2c5edd6b691939457613c6d3d50"
    },
    {
      "type": "html",
      "text": "\nPython's [[Java Language]], [[Cee Plus Plus]] (via the [[Simplified Wrapper And Interface Generator]]), XML, RDB and COM bindings are all excellent. Smalltalk ([[Visual Works]] and [[Visual Age]]) supports Java, C++, COM and Windows DLL bindings, though it lacks the auto-generated APIs of the [[Simplified Wrapper And Interface Generator]]. [[Distributed Smalltalk]] is a CORBA 2.x ORB. [[Squeak Smalltalk]] can translate a subset of itself into [[Cee Language]]. And [[Python Language]] and [[Squeak Smalltalk]] are both [[Open Source]].",
      "id": "3b7f03de30008f40ef1e21f508d701d8"
    },
    {
      "type": "html",
      "text": "\nPython is far less insular than Smalltalk, as a language in general, and the implementations specifically. Python makes extensive use of libraries and programs not written for Python, and does not insulate the programmer from the system.",
      "id": "e0a1ee49839d970786821339246c3315"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>Marketability and Lifespan</b>",
      "id": "57718264509d4f73e1cd0aebb301c2e2"
    },
    {
      "type": "html",
      "text": "\nNeither language is terribly marketable compared with the corporate-supported languages, but [[Python Language]] is younger, livelier, and easily combined with/evolved from development with other languages, so it seems the more likely to proliferate. Python has strong community participation at all levels of development, including the core language development. The community is transparent and does not depend on commercial success (as the corporate-sponsored or owned [[Smalltalk Language]] implementations do).",
      "id": "48a8c21726a2da84ad0a7c5e65a6564d"
    },
    {
      "type": "html",
      "text": "\nTwo versions of Smalltalk are supported by large corporations ([[Ibm Smalltalk]] and [[Cincom Smalltalk]]), and others are supported by smaller for-profit organizations. [[Ibm Corporation]] supports its products forever, and Smalltalk seems to have settled in a stable, respectable niche. [[Squeak Smalltalk]] provides an [[Open Source]] alternative.",
      "id": "7e3a423f77f097a712384e3821668579"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>Reflection and [[Meta Programming]]</b>",
      "id": "8f6b144a1d666e4ba068bc1953f28c05"
    },
    {
      "type": "html",
      "text": "\n[[Smalltalk Language]] is known to have a very rich, reflective nature, second only to [[Common Lisp]]. How does Python fare?",
      "id": "ee5b4a82f47ca6822a60aafc09a8a85c"
    },
    {
      "type": "html",
      "text": "\n[[Python Language]] is very reflective. Everything in the language, including classes, namespaces and functions, is an object whose properties can be got and set. Python programs can construct and compile Python programs on the fly. Python objects can be serialized and deserialized with a single statement. There are some limitations - see the discussion on Closures - but it's difficult to see where they'd bite you.",
      "id": "0745309877b6d1690e3e5441506a54f9"
    },
    {
      "type": "html",
      "text": "<i>Okay, but how about [[Meta Class]]es?  I was surfing around Python.org, and only got the impression that it was a work-in-progress.</i>",
      "id": "e2d1359978c3ef1652fcfd59e77aaefd"
    },
    {
      "type": "html",
      "text": "[My disclaimer, I don't know beans about Smalltalk.] Perhaps you are accustomed to an automated tool for implementing [[Meta Class]]es, but if you are interested, here's an article with code samples showing use of [[Meta Class]]es in Python: [http://www2.linuxjournal.com/lj-issues/issue73/3882.html www2.linuxjournal.com]",
      "id": "1be96f0c05eed717e18a9d0017f59a3d"
    },
    {
      "type": "html",
      "text": "\n[[Python Language]] has supported [[Meta Class]] programming since version 2.2 or so. [[David Mertz]]'s site also has a few articles on this.",
      "id": "fa56f970de9d093d3c7c316d35848a8e"
    },
    {
      "type": "html",
      "text": " Does Python allow object swizzling? By this I mean that Smalltalk has a method called <b>become:</b> that effectively replaces one instance with another instance, changing all references in the system. <i>No, Python does not have this.</i>",
      "id": "777c75931c7b9b49d3bac1dd8d07d1ad"
    },
    {
      "type": "html",
      "text": "<i>By my understanding of [[Object Swizzling]], it does:</i>",
      "id": "f0afa3f7d20fec2a1982374b48e5eb08"
    },
    {
      "type": "code",
      "text": " class foo:\n   def __init__(self, datum):\n     self.datum = datum\n   def __str__(self): return \"This is a foo with datum %s\" % self.datum",
      "id": "80dba2f35e4458a39d86c45fca9a40c8"
    },
    {
      "type": "code",
      "text": " class bar:\n   def __init__(self, thing):\n     self.thing = thing\n   def __str__(self): return \"This is a bar; contents: %s\" % (self.__dict__, )",
      "id": "23280eed640981e0e04d87e6c0f9d118"
    },
    {
      "type": "code",
      "text": " >>> x = bar(123)\n >>> print x\n This is a bar; contents: {'thing': 123}\n >>> x = foo(123)\n >>> print x\n This is a foo with datum 123\n >>> x.__class__\n <class __main__.foo at 0x00CF3AB0>\n >>> x.__class__ = bar\n >>> x\n <__main__.bar instance at 0x00D64F30>\n >>> print x\n This is a bar; contents: {'datum': 123}",
      "id": "5f5ce55d02d77ffd5a07bd121044017a"
    },
    {
      "type": "html",
      "text": " Does Python allow me to call methods through reflection? (i.e., like Java's [[Method Object]]s or Smalltalk's <b>perform:</b> ) <i>Yes, everything is available through reflection, including modifying class objects, adding methods, etc., at runtime.</i>",
      "id": "b701d0d7d13da2cf424d5bfe1b88cb56"
    },
    {
      "type": "html",
      "text": "\nThere are several aspects to relation.  One is that we can look things up by name:",
      "id": "e80b130c68f8c9368b96044efa680547"
    },
    {
      "type": "code",
      "text": "  >>> import string\n  >>> string.__dict__['uppercase']\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZ'",
      "id": "be1edc7c244bef1222d5769bfab5f507"
    },
    {
      "type": "html",
      "text": "Another is that we can evaluate code at runtime:",
      "id": "701f05e70dae78b75d8ed5d534510af9"
    },
    {
      "type": "code",
      "text": "  >>> eval('\"Hello\" + \"Wiki\"')\n  'HelloWiki'",
      "id": "b6b54801219b781ffc7138bf660b3873"
    },
    {
      "type": "html",
      "text": "Et cetera. Evaluation is usually not necessary for reflection.",
      "id": "955f0b77eea7eccd8e0bf8ec7b8b16df"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>[[Alternate Hard And Soft Layers]]</b>",
      "id": "f4a64afb5bd2d889d92bc5944a6841cf"
    },
    {
      "type": "html",
      "text": "\n[[Python Language]] is trivial to integrate with [[Cee Language]] or other native languages: just build a [[Shared Library]], import it, and start calling.",
      "id": "abb01b236bc7d190d6f2135e39a9cdf0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "\nJust starting with Python, so I don't know: Does Python have Senders/Implementors? Inspectors? Editing in the debugger with restart? ENVY and similar tools to show editions of methods and replace them? Reflection? Hierarchy Browsers? Window drawing and event linking tools? ",
      "id": "777406551df1d788283b830e26e12087"
    },
    {
      "type": "html",
      "text": "<i>bit of a mixed collection of requirements here... Python doesn't have the nice environment that has always been part of Smalltalk -- after all it started life as a [[Scripting Language]]. It does have several user interface toolkits of which I believe the TK port is most popular. It does have reflection, although maybe not quite as much as Smalltalk. It also has, at least for now, one version, there are no vendor wars to lose.</i>",
      "id": "0d6d207013edae08c952908291d81e42"
    },
    {
      "type": "html",
      "text": "''Python's design actually makes on-the-fly editing difficult or impossible.  Classes are created by execution, not defined.  So:",
      "id": "6187cfebdafc7bcc4296f45497fd23a9"
    },
    {
      "type": "html",
      "text": ">>> class A:<br>",
      "id": "cd65d85a0b7960170df2aa95f884ccaf"
    },
    {
      "type": "html",
      "text": "...\tdef answer(self):<br>return \"YES!\"",
      "id": "103b454bbf10494c34dd663fea025724"
    },
    {
      "type": "code",
      "text": "  >>> a = A()\n  >>> class A:\n  ...  def answer(self): return \"NO!\"\n  >>> a.answer()\n  YES!",
      "id": "038fa7488cd0e5e091c338bcb935cbe8"
    },
    {
      "type": "html",
      "text": "\nAs you may see, the a object is still bound to the old definition of A.  You can do some funny tricks with this, but for the most part it causes problems.''",
      "id": "f7a195a0d6f2d3677a7e6b3f4bce6949"
    },
    {
      "type": "html",
      "text": "--",
      "id": "39b4715bee9a8817d6513dbd81039f35"
    },
    {
      "type": "html",
      "text": "\nBut the effect is achievable with:",
      "id": "ed78e0cc1253e2bbd66e237c38076f57"
    },
    {
      "type": "code",
      "text": "  >>> class A:\n  ...     def answer(self): return \"YES!\"\n  >>> a = A()\n  >>> class A:\n  ...     def answer(self): return \"NO!\"\n  >>> a.answer()\n  'YES!'\n  >>> a.__class__ = A #reload class\n  >>> a.answer()\n  'NO!'",
      "id": "fc9e0f25c10bd799a42e6e35889defcb"
    },
    {
      "type": "html",
      "text": "\nor for a single function:",
      "id": "14fd237e1a9e67cfecd53bba446e3ee8"
    },
    {
      "type": "code",
      "text": "  >>> class A:\n  ...  def answer(self): return \"YES!\"\n  >>> a = A()\n  >>> def just_say_no(self): \n  ...  return \"NO!\"\n  >>> A.answer = just_say_no\n  >>> a.answer()\n  NO!",
      "id": "f5afcc564571dce5c393ea21448fce90"
    },
    {
      "type": "html",
      "text": "\nThis happens to work in Ruby:",
      "id": "9da00a86a27de20b987b9a1d36fed594"
    },
    {
      "type": "code",
      "text": "  irb(main):001:0> class A\n  irb(main):002:1>   def answer;  return \"YES!\";  end\n  irb(main):003:1> end\n  => nil\n  irb(main):004:0> a = A.new\n  => #<A:0x298a510>\n  irb(main):005:0> a.answer\n  => \"YES!\"\n  irb(main):006:0> class A\n  irb(main):007:1>   def answer;  return \"NO!\";  end\n  irb(main):008:1> end\n  => nil\n  irb(main):009:0> a.answer\n  => \"NO!\"\n  irb(main):010:0>",
      "id": "0cee5cb57643553f792ec2f8f0b801e6"
    },
    {
      "type": "html",
      "text": "\nI guess that's not too surprising, given the way Ruby is modeled after Smalltalk.",
      "id": "f0b2b82e098e692f2a87e36922f7c314"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "<b>Comments</b>",
      "id": "d8d8b98ed65a35120a7b193262ac111a"
    },
    {
      "type": "html",
      "text": "\nDammit, I like 'em both. Which says a lot for Python, because I'm a die-hard [[Smalltalk Bigot]] (and a [[Knight Of The Square Bracket]]). Python meets my bare minimum usability requirements: [[Late Binding]] and [[Garbage Collection]]. And it has a 1970's hacker community feel to it. And I'm really enjoying using it. --[[Anthony Lander]]",
      "id": "64349e5695d25514f29e66c0b314bbae"
    },
    {
      "type": "html",
      "text": "[Comments on file orientation moved to [[Python Refactoring Browser]]]",
      "id": "701e27048d0febc666f6b7b18c7d2ed4"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "I'm very impressed with [[Ruby Language]]. Does anyone have any ideas on [[Smalltalk Instead Of Ruby]] or [[Ruby Instead Of Python]]? (See [[Python Vs Ruby]]) The only real drawback of Ruby that I see is that it is so young, but that will improve with time, of course, and by definition.",
      "id": "8aa36ab91ed3fa6a41412e848fe4a4f5"
    },
    {
      "type": "html",
      "text": "Since it looks like you have some experience with that, perhaps you could write something at [[Ruby Instead Of Smalltalk]] :-) Would be a good starting point for further discussion and comparisons.",
      "id": "6a89daec4870f7c364b89878fa9d2208"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "One thing going for Python is that it does or can resemble the [[Algol Language]]-roots style that is so common. One can more easily gradually transition instead of doing a mental 180.",
      "id": "00aed85f4ec55260ad8ae5089655acf6"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "\nAt this point (March 2005), Python also has a much larger community and library. It also has high quality free/Free implementations, which (as I understand it), Smalltalk does not. Personally, I wouldn't recommend using smalltalk unless you've already got experienced smalltalk developers and/or existing smalltalk code you need to work from.",
      "id": "dd34ecaa6918e6028ddb84fb1c62086f"
    },
    {
      "type": "html",
      "text": "<i>Squeak is both high quality and free. [[Visual Works]] is free for development. Smalltalk/X ([[Smalltalk Ecks]]) is even free for commercial users.</i>",
      "id": "0fbe4c715c7ada956c2f7b5e8ccbe399"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9832df991d09174ce7b514eeb57f6d13"
    },
    {
      "type": "html",
      "text": "[[Category Programming Language Comparisons]] [[Category Smalltalk]] [[Category Python]]",
      "id": "8f04486b4f8b6ad03761b537aa0c6f88"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?SmalltalkInsteadOfPython c2.com]",
      "id": "910cb6f834dfb81a72bc7c14fbef0970"
    }
  ],
  "journal": [
    {
      "date": 1259132936000,
      "id": "80987087bc6e771d5bbfdb857aa26139",
      "type": "create",
      "item": {
        "title": "Smalltalk Instead Of Python",
        "story": [
          {
            "type": "html",
            "text": "[[Python Language]] and [[Smalltalk Language]] seem comparable in many ways, but their origins and styles are very different. On this page we're trying to figure out when to use [[Smalltalk Instead Of Python]].",
            "id": "e5a36ad519637498e26760ac10988faa"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>Syntax</b>",
            "id": "be8e93cc3d3a3491f6cd8dd057ed7751"
          },
          {
            "type": "html",
            "text": "\nIf, like most programmers, you come from an [[Algol Family]] background, then Smalltalk syntax looks pretty obscure at first. Consider:",
            "id": "a80a593b8ddbeada7139571fa6651fca"
          },
          {
            "type": "html",
            "text": " One of the [[Smalltalk Tutorials]]",
            "id": "0146b73fac40b753f7c60c81fd3882d5"
          },
          {
            "type": "html",
            "text": " [[Smalltalk Syntax]]",
            "id": "bb9c0c9c6cf1444720338f1cbe3747d8"
          },
          {
            "type": "html",
            "text": " [[Smalltalk Message Rules]]",
            "id": "3bb16d774ea7b8c7cacf35d14ef52bc9"
          },
          {
            "type": "html",
            "text": " The short-but-sweet book:<br>[[On To Smalltalk]]",
            "id": "a976982f4e89c40bd4ae71b3ba462042"
          },
          {
            "type": "html",
            "text": "\nPython, on the other hand, is notoriously easy for an [[Algol Family]] programmer to learn, and comes with several truly excellent tutorials. The main difference you'll find is that Python uses indentation rather than braces to control scope. (See [[Python White Space Discussion]].) It's not too much to expect any competent programmer to learn most of the Python syntax in a day, and to become fluent in a couple of weeks.",
            "id": "51206d76c863c2275e40b56ec2f38016"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>Speed</b>",
            "id": "1de30c76ba9c0db67178b768369e626f"
          },
          {
            "type": "html",
            "text": "\n[[Java Python]] is the speed of [[Java Language]] which is about as fast as [[Smalltalk Language]]. <i>Are there any numbers on that claim? The professional Smalltalk vendors still claim that their [[Virtual Machine]]s are faster than Java's.</i> Regular [[Python Language]] is as much as 2.5 times faster than Jython, according to the Jython faq. Some [[Just In Time Compiler]]s may bring Jython up to par with regular Python. Does this mean [[Small Talk]] is slower? <i>Jury's out</i> Who cares: use [[Alternate Hard And Soft Layers]]. <i>[[Smalltalk Em Tee]] produces very fast compiled code on [[Microsoft Windows]]--DLLs, [[Activex Technology]] controls, the lot.</i>",
            "id": "610ed840b949da2249a0f2d05c4d2422"
          },
          {
            "type": "html",
            "text": "\nThe development of [[Python Language]] has focused more on speed of development than speed of program execution. I certainly doubt that CPython is 2.5 times faster than [[Java Language]], which is suggested above. But as you know, benchmarks only tell us how fast the actually benchmarked code is. There are some references to Python performance on the web. [http://www.flat222.org/mac/bench/ www.flat222.org] [http://shootout.alioth.debian.org/ shootout.alioth.debian.org] As usual, these tests focus on tiny, meaningless programs, so I'd take them with a pinch of salt. And they don't compare with [[Smallalk Language]]...  ",
            "id": "e1d9695e1b47f146de2b8edc5adf2dfd"
          },
          {
            "type": "html",
            "text": "<i>[http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=vw&lang2=python shootout.alioth.debian.org] measures Python implementations and Smalltalk implementations.</i>",
            "id": "4c6646606dd6e12a5451539e753167f3"
          },
          {
            "type": "html",
            "text": "\nIs [[Java Python]] really the speed of [[Java Language]]? Sure, Jython can be compiled into Java bytecode, but will it look just as the bytecode of a comparable Java program? I think the dynamic nature of Python/Jython will lead to more complex bytecode.",
            "id": "b8786be8db5bc868f72e402778f6dd07"
          },
          {
            "type": "html",
            "text": "<i>No, Jython is not the speed of Java. I think it's like 10x slower than Java, because many portions are interpreted. (10x slower for what kind of code? Numbers lie...) CPython is faster than Jython. I personally consider Jython to be niche, useful for environments where [[Java Language]] is entrenched or otherwise required.</i>",
            "id": "c13dcdf4731c8807bf3ba6d083f178bd"
          },
          {
            "type": "html",
            "text": "<i>Python performance is Good Enough, for nearly any definition of \"Good Enough\". Because it is easy to use [[Cee Language]] code with [[Python Language]], portions of your code can be refactored to speed up your program. Of course, C is harder than Python, so you only do this as necessary, but there is always at least a path out. Also, you can use C libraries that are created and packaged by other people (which is what I do), and eventually the whole community benefits. -- [[Ian Bicking]]</i>",
            "id": "3a427df9ffa39566ab02b1cdeaa8692a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>Tools</b>",
            "id": "4a7b545bda010d6c28f36eca5bd880ea"
          },
          {
            "type": "html",
            "text": "<b>Smalltalk:</b> IDLE is some of the way there, but there's nothing comparable to the [[Refactoring Browser]], or even an object inspector.",
            "id": "cc1742a8dffc9b3f20fddd631abf0be3"
          },
          {
            "type": "html",
            "text": "<b>Python:</b> If you prefer an editor to an IDE, this is moot. A [[Python Refactoring Browser]] would be really nice though. Thank you, [[Bicycle Repair Man]]!",
            "id": "785bfc26e8ef93ab33750921fc958530"
          },
          {
            "type": "html",
            "text": "\nBut see more on this on [[Ide Instead Of Editor]].",
            "id": "ab712a41ad2879a2f8d1e0ab28a06fb0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>[[Gem Stone]]</b>",
            "id": "bf24a96f7931886c3e8f3e14657a3b98"
          },
          {
            "type": "html",
            "text": "\nOnce unique to the [[Smalltalk Language]] world, a [[Java Language]] version ([[Gem Stonej]]) is evolving nicely. [[Gem Stone]] gives extraordinary power to develop large-scale applications, and is used in telecom, manufacturing, logistics, finance, and commerce. See also [[Gemstone Project]]. It's a high-performance server & scalable [[Object Oriented Database Management System]], capable of supporting over 1 billion objects.  ",
            "id": "71b4da17a6cd01fb6bad8274261427b5"
          },
          {
            "type": "html",
            "text": "\nYou can of course build a large scale python system over any RDBMS, but [[Gem Stone]] would likely trump that solution in flexibility. However, as [[Java Python]] is able to do everything Java can do, use/aggregate/compose/derive from any [[Java Language]] class, there's no difficulty using [[Gem Stone]] from [[Python Language]]. You could also use [[Java Python]] in combination with the Oracle [[Java Virtual Machine]].",
            "id": "c056de2778033bf97032a947d86ed3a8"
          },
          {
            "type": "html",
            "text": "<i>Note that [[Gem Stone]] Smalltalk is in many ways more flexible than the Java/[[Java Python]] route, primarily because it is more mature than [[Gem Stonej]]. It also benefits from Smalltalk's rich reflection & metaobject libraries when designing rich & adaptive frameworks.</i>",
            "id": "8bc2b55cb175f093999a01be5c590166"
          },
          {
            "type": "html",
            "text": "\n[[Zo Db]] (The Zope Object Database) is a (not-quite orthogonal) persistent store with transactional support, as well as other features. It is available separate from Zope, and many people use it as such. And it's [[Open Source]]. For a significant portion of the [[Python Language]] community, software is not valuable if it is [[Closed Source]] (a notable difference from [[Smalltalk Language]] circles), so an imaginary Gemstone/P would not matter much to us.",
            "id": "e9af7828eb8c833e184664d76fd1ea2f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>[[Zope Application Server]] (Zope)</b>",
            "id": "cb42e8f28bb3a59fca28ebf0543b0e7a"
          },
          {
            "type": "html",
            "text": "\nWhat's more Zope provides a free Python [[Object Oriented Database]], and a nice one. Nevertheless, [[Zo Db]]'s scaling attributes haven't been stressed or demonstrated. If you want to do data warehousing in [[Python Language]], you'll probably have to go the [[Java Python]]/[[Gem Stonej]] route.",
            "id": "b5ed09db8dbc8cd3475fb6e98876db66"
          },
          {
            "type": "html",
            "text": "\nZope may not be the ideal choice for mass storage / retrieval of arbitrary Foreign Objects. Still, why not put Zope / [[Zo Db]] to the test by building a Web-Based Python Development Environment, complete with a [[Python Refactoring Browser]]?",
            "id": "68238e072b6fbbe9775e1650f1889390"
          },
          {
            "type": "html",
            "text": "<i>[[Zo Db]] isn't really meant to be separated from Zope and used with other projects though, is it? I'm not asking this as an argument for [[Smalltalk Language]], but rather because I have other projects that I could use a good object store for, and I'm thinking of doing those projects in [[Python Language]] (as opposed to [[Java Language]] or [[Cee Language]]).</i>",
            "id": "6e77105da02d322884842c8038ade72d"
          },
          {
            "type": "html",
            "text": "\nThere's an excellent article on just this topic: [http://starship.python.net/crew/amk/python/writing/zodb-zeo.html starship.python.net]",
            "id": "2a4054eb056ca64c5e4a6e493f535cb5"
          },
          {
            "type": "html",
            "text": "\nZope is made up of several modules, which when used together form a Web Application Development Environment, but each can be used separately. [[Zo Db]] is a direct descendant of \"Bobo\", an [[Open Source]] [[Python Language]] module, that provides Persistence to Python Objects (an ODB). Typically [[Zo Db]] is used in conjunction with the Filestorage module, but the actual storage medium is abstracted, and there are existing alternatives.",
            "id": "c8f6432362721b2920d3e3866a7b797f"
          },
          {
            "type": "html",
            "text": "\nPerhaps the reference to data warehousing (above) is intended to caution against using the Zope native Object Database (ZODB) as an Object Data Warehouse. This is very different than using Zope as a Web Development Environment for building systems to access a \"traditional\" Data Warehouse. In this sense, Zope is very capable of managing the Python Objects that make up Zope itself, components of Web Applications created within Zope, as well as data held in external systems, which are \"objectified\" within the Zope context.",
            "id": "ed209107283670410c1589d9d4e91acc"
          },
          {
            "type": "html",
            "text": "\nIf you're looking at a Zope solution, you'll quickly notice that the interfaces to back-end datastores are quite mature and flexible. Zope is very adequate for accessing any traditional \"backend\" (tabular data, any [[Relational Data Base Management System]] such as [[Oracle Database]], [[Postgre Sql]]). This is the realm of [[Cold Fusion]], [[Active Server Pages]], and [[Php Language]]. Of these only PHP is [[Open Source]] and cross-platform, and none are [[Object Oriented]]. Unlike these, Zope has a powerful security model, and is a capable [[Content Management System]]. ",
            "id": "c4f723aa84237315c3fcdbc1d1815f5e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>Closures</b>",
            "id": "9cfbc845fe4695a87d51330421453281"
          },
          {
            "type": "html",
            "text": "<b>Python:</b> has [[First Class Function]]s that can be used just like [[Smalltalk Blocks And Closures]] (as far as I know). The [[Lambda Calculus]] functions are just [[Syntactic Sugar]] for one liners. They compile down to first class [[Anonymous Function]]s.  ",
            "id": "77332c593ae936aafba1cb104c0e66f5"
          },
          {
            "type": "html",
            "text": "<b>Smalltalk:</b> Something that I love to do in [[Smalltalk Language]], [[Ruby Language]] and [[Lisp Language]] but find frustrating in [[Python Language]] because of the lambdas:",
            "id": "96dfe64ec034396cfdde482c6992139f"
          },
          {
            "type": "html",
            "text": "^ anArray collect:<br>[ :each | each transform ]",
            "id": "4f5b0726d5cfc85f35b86784b201bd23"
          },
          {
            "type": "html",
            "text": "goes to",
            "id": "346eeabc9ad5ac61ca280d5254426beb"
          },
          {
            "type": "code",
            "text": "  map(lambda x:x.transform(), anArray)",
            "id": "4807cf78b2e55a0175afb2b5421c02ab"
          },
          {
            "type": "html",
            "text": "in Python.  Fine, if a mite yucky.  Unfortunately...",
            "id": "6c8ea340584f6c4254651bc0a6ba3591"
          },
          {
            "type": "html",
            "text": "^ anArray collect:<br>[ :each | self transform: each ]",
            "id": "1918a0b7b9a6feb5b6766b4d181955da"
          },
          {
            "type": "html",
            "text": "goes to",
            "id": "346eeabc9ad5ac61ca280d5254426beb"
          },
          {
            "type": "html",
            "text": "map(lambda x, self=self:<br>self.transform(x), anArray)",
            "id": "00cc0b1112959bd034c2eabf939fa672"
          },
          {
            "type": "html",
            "text": "which is yucky as all get out when the list of objects you need to use inside the lambda gets at all long. Python 3000 offers some hope, but the semantics aren't the only problem with doing this kind of mapping in Python <i>(But see Python's nifty [[List Comprehension]] syntax below!)</i>; the syntax is surprisingly klugey. Plus, you don't get the really cool stuff the Collection protocol gives you in Smalltalk: no includes, no isEmpty... you do have a select, but it has the same problems the map does, etc.",
            "id": "c4e2e5d0c81429672eacce33ac1d67c4"
          },
          {
            "type": "html",
            "text": "<i>Note: the second map example can actually be rewritten like this, which is far more readable:</i>",
            "id": "e10719783d8d295038b671d827fafd8d"
          },
          {
            "type": "code",
            "text": "  map( self.transform, anArray )",
            "id": "6dda683b927b909e872879ba9520b677"
          },
          {
            "type": "html",
            "text": "However, code that would use blocks in Smalltalk is less readable when written with functions in Python because code that should belong together is written in two separate places. Also, functions need to be named, which often leads to the auxiliary functions having awkward names or names that carry little useful information.",
            "id": "e69c5dc2052d681b30eadebcbf8c99ee"
          },
          {
            "type": "html",
            "text": "<b>Python:</b> In recent versions of Python (2.0 upwards)\nyou can use [[List Comprehension]]s:",
            "id": "ad9a369cea8b4f678f0cb12e3c7f9cd0"
          },
          {
            "type": "code",
            "text": "  return [x.transform() for x in anArray]\n  return [self.transform(x) for x in anArray]",
            "id": "dac5c17b4d185ba014bb70eeceaeedba"
          },
          {
            "type": "html",
            "text": "Versions 2.1 and up have properly nesting scopes (in 2.1 you need to do a little magic dance to enable them, but that will goes away in 2.2), so the \"foo=foo\" hack is no longer needed.",
            "id": "3bb08358707f47931866e5c2bf68b635"
          },
          {
            "type": "html",
            "text": "\nThere are two forces here: one is that the built-ins in [[Python Language]] tend not to have methods; int('foo') instead of 'foo' asNumber. (As of Python 2.0, strings have methods; though there is still no method for converting to a number.) The other is that [[Anonymous Function]]s are unpleasant in Python (though less so as of 2.1).",
            "id": "36773e175a0bc67213a55e5446abcca7"
          },
          {
            "type": "html",
            "text": "\nWho cares about closures? I practically never use 'em, nor lambdas neither. When would you use [[Closure Instead Of Object]]?",
            "id": "a091b7ba1aefd82f1cfbdf9b4160f460"
          },
          {
            "type": "html",
            "text": "<i>A closure does two things: It avoids giving a name to a block of code that doesn't need it, and it keeps the block of code as close as possible to where it is being used.</i> ",
            "id": "2e7f7537e3366e5f7aafcb64fcd420ea"
          },
          {
            "type": "html",
            "text": "\nIt does more than that, and just because you never use them doesn't mean they aren't extremely useful to those who do. Anonymous closures allow easy and clean use of [[Higher Order Function]]<b></b>'s, and allows a more [[Functional Programming]] style. The entire Smalltalk [[Collection Hierarchies]] [sic, sorry] is based upon higher-order functions and closures, so being able to create closures with an extremely light syntax is a huge, huge boon.",
            "id": "888a240086a324bf5cdfb2e2a1a1ce5b"
          },
          {
            "type": "html",
            "text": "[It's a matter of preference, not a huge boon. I generally prefer named functions, purely as a stylistic and aesthetic matter. It's also slightly easier to refactor. Anonymous blocks are <b>not</b> required for [[Functional Programming]] or the use of HOFs. Reasonable people can agree to disagree about this, but I wouldn't call it a failing on the part of [[Python Language]] (any more than I would count [[Smalltalk Language]]'s non-[[Algol Family]] syntax against it).]",
            "id": "a8b75b2571a0f3ad666583f3b62b6b46"
          },
          {
            "type": "html",
            "text": "\nOkay, so [[Stackless Python]] seems to make this a non-issue. Is there anything else to recommend Smalltalk over Python?",
            "id": "8006dc643774816636183a6cbd8d4693"
          },
          {
            "type": "html",
            "text": "<i>So [[Stackless Python]] adds [[Co Routine]]s. I fail to see how that provides me with the flexibility of a closure/block. This is one of my problems with [[Java Language]]: [[Anonymous Inner Class]]es are a poor & clunky substitute.</i>",
            "id": "ba76f8c5393c22e1af05001242ce905a"
          },
          {
            "type": "html",
            "text": "\nSee also [[Python Vs Ruby]], [[Blocks In Ruby]], [[Blocks In Python]], [[Blocks In Many Languages]].",
            "id": "7075f834591037359d5a62b6f929a4a4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>Books and Portability</b>",
            "id": "a8b87eb297f52e63218ee46b4cb1b34b"
          },
          {
            "type": "html",
            "text": "\n[[Smalltalk Language]] has more books than [[Python Language]], but more Python books are coming out. Some Smalltalk books are specialized to a particular vendor's implementation. This may cause minor problems of applicability, but overall most Smalltalk flavors are quite similar. Python essentially has only two mainstream implementations (Python and [[Java Python]], both free), and those two implementations are available an many platforms. Smalltalk is also available on many platforms ([[Sun Solaris]], [[Microsoft Windows]], [[Apple Macintosh]], [[Linux Os]], etc.)",
            "id": "f976d5edb2ac577f8fd1ac8ac0a0cd3e"
          },
          {
            "type": "html",
            "text": "<i>Smalltalk has a book by [[Kent Beck]] ([ISBN 013476904X]). Python doesn't.</i>",
            "id": "03f403c32f28057202f37a5c750d37e6"
          },
          {
            "type": "html",
            "text": "<i>Actually, Python now has part of a book by [[Kent Beck]] ([ISBN 0321146530]).</i>",
            "id": "5d061956ddf4ae37cc860f03ac03b089"
          },
          {
            "type": "html",
            "text": "<i>Python has several [[Animal Book]]s ([ISBN 1565924649], [ISBN 1565921976], [ISBN 1565926218], [ISBN 1565925009]).  Smalltalk doesn't.</i>",
            "id": "5a29a533f41fca0befb63b654a0afbe7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>Standards and Bindings</b>",
            "id": "3da9b2c5edd6b691939457613c6d3d50"
          },
          {
            "type": "html",
            "text": "\nPython's [[Java Language]], [[Cee Plus Plus]] (via the [[Simplified Wrapper And Interface Generator]]), XML, RDB and COM bindings are all excellent. Smalltalk ([[Visual Works]] and [[Visual Age]]) supports Java, C++, COM and Windows DLL bindings, though it lacks the auto-generated APIs of the [[Simplified Wrapper And Interface Generator]]. [[Distributed Smalltalk]] is a CORBA 2.x ORB. [[Squeak Smalltalk]] can translate a subset of itself into [[Cee Language]]. And [[Python Language]] and [[Squeak Smalltalk]] are both [[Open Source]].",
            "id": "3b7f03de30008f40ef1e21f508d701d8"
          },
          {
            "type": "html",
            "text": "\nPython is far less insular than Smalltalk, as a language in general, and the implementations specifically. Python makes extensive use of libraries and programs not written for Python, and does not insulate the programmer from the system.",
            "id": "e0a1ee49839d970786821339246c3315"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>Marketability and Lifespan</b>",
            "id": "57718264509d4f73e1cd0aebb301c2e2"
          },
          {
            "type": "html",
            "text": "\nNeither language is terribly marketable compared with the corporate-supported languages, but [[Python Language]] is younger, livelier, and easily combined with/evolved from development with other languages, so it seems the more likely to proliferate. Python has strong community participation at all levels of development, including the core language development. The community is transparent and does not depend on commercial success (as the corporate-sponsored or owned [[Smalltalk Language]] implementations do).",
            "id": "48a8c21726a2da84ad0a7c5e65a6564d"
          },
          {
            "type": "html",
            "text": "\nTwo versions of Smalltalk are supported by large corporations ([[Ibm Smalltalk]] and [[Cincom Smalltalk]]), and others are supported by smaller for-profit organizations. [[Ibm Corporation]] supports its products forever, and Smalltalk seems to have settled in a stable, respectable niche. [[Squeak Smalltalk]] provides an [[Open Source]] alternative.",
            "id": "7e3a423f77f097a712384e3821668579"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>Reflection and [[Meta Programming]]</b>",
            "id": "8f6b144a1d666e4ba068bc1953f28c05"
          },
          {
            "type": "html",
            "text": "\n[[Smalltalk Language]] is known to have a very rich, reflective nature, second only to [[Common Lisp]]. How does Python fare?",
            "id": "ee5b4a82f47ca6822a60aafc09a8a85c"
          },
          {
            "type": "html",
            "text": "\n[[Python Language]] is very reflective. Everything in the language, including classes, namespaces and functions, is an object whose properties can be got and set. Python programs can construct and compile Python programs on the fly. Python objects can be serialized and deserialized with a single statement. There are some limitations - see the discussion on Closures - but it's difficult to see where they'd bite you.",
            "id": "0745309877b6d1690e3e5441506a54f9"
          },
          {
            "type": "html",
            "text": "<i>Okay, but how about [[Meta Class]]es?  I was surfing around Python.org, and only got the impression that it was a work-in-progress.</i>",
            "id": "e2d1359978c3ef1652fcfd59e77aaefd"
          },
          {
            "type": "html",
            "text": "[My disclaimer, I don't know beans about Smalltalk.] Perhaps you are accustomed to an automated tool for implementing [[Meta Class]]es, but if you are interested, here's an article with code samples showing use of [[Meta Class]]es in Python: [http://www2.linuxjournal.com/lj-issues/issue73/3882.html www2.linuxjournal.com]",
            "id": "1be96f0c05eed717e18a9d0017f59a3d"
          },
          {
            "type": "html",
            "text": "\n[[Python Language]] has supported [[Meta Class]] programming since version 2.2 or so. [[David Mertz]]'s site also has a few articles on this.",
            "id": "fa56f970de9d093d3c7c316d35848a8e"
          },
          {
            "type": "html",
            "text": " Does Python allow object swizzling? By this I mean that Smalltalk has a method called <b>become:</b> that effectively replaces one instance with another instance, changing all references in the system. <i>No, Python does not have this.</i>",
            "id": "777c75931c7b9b49d3bac1dd8d07d1ad"
          },
          {
            "type": "html",
            "text": "<i>By my understanding of [[Object Swizzling]], it does:</i>",
            "id": "f0afa3f7d20fec2a1982374b48e5eb08"
          },
          {
            "type": "code",
            "text": " class foo:\n   def __init__(self, datum):\n     self.datum = datum\n   def __str__(self): return \"This is a foo with datum %s\" % self.datum",
            "id": "80dba2f35e4458a39d86c45fca9a40c8"
          },
          {
            "type": "code",
            "text": " class bar:\n   def __init__(self, thing):\n     self.thing = thing\n   def __str__(self): return \"This is a bar; contents: %s\" % (self.__dict__, )",
            "id": "23280eed640981e0e04d87e6c0f9d118"
          },
          {
            "type": "code",
            "text": " >>> x = bar(123)\n >>> print x\n This is a bar; contents: {'thing': 123}\n >>> x = foo(123)\n >>> print x\n This is a foo with datum 123\n >>> x.__class__\n <class __main__.foo at 0x00CF3AB0>\n >>> x.__class__ = bar\n >>> x\n <__main__.bar instance at 0x00D64F30>\n >>> print x\n This is a bar; contents: {'datum': 123}",
            "id": "5f5ce55d02d77ffd5a07bd121044017a"
          },
          {
            "type": "html",
            "text": " Does Python allow me to call methods through reflection? (i.e., like Java's [[Method Object]]s or Smalltalk's <b>perform:</b> ) <i>Yes, everything is available through reflection, including modifying class objects, adding methods, etc., at runtime.</i>",
            "id": "b701d0d7d13da2cf424d5bfe1b88cb56"
          },
          {
            "type": "html",
            "text": "\nThere are several aspects to relation.  One is that we can look things up by name:",
            "id": "e80b130c68f8c9368b96044efa680547"
          },
          {
            "type": "code",
            "text": "  >>> import string\n  >>> string.__dict__['uppercase']\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZ'",
            "id": "be1edc7c244bef1222d5769bfab5f507"
          },
          {
            "type": "html",
            "text": "Another is that we can evaluate code at runtime:",
            "id": "701f05e70dae78b75d8ed5d534510af9"
          },
          {
            "type": "code",
            "text": "  >>> eval('\"Hello\" + \"Wiki\"')\n  'HelloWiki'",
            "id": "b6b54801219b781ffc7138bf660b3873"
          },
          {
            "type": "html",
            "text": "Et cetera. Evaluation is usually not necessary for reflection.",
            "id": "955f0b77eea7eccd8e0bf8ec7b8b16df"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>[[Alternate Hard And Soft Layers]]</b>",
            "id": "f4a64afb5bd2d889d92bc5944a6841cf"
          },
          {
            "type": "html",
            "text": "\n[[Python Language]] is trivial to integrate with [[Cee Language]] or other native languages: just build a [[Shared Library]], import it, and start calling.",
            "id": "abb01b236bc7d190d6f2135e39a9cdf0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "\nJust starting with Python, so I don't know: Does Python have Senders/Implementors? Inspectors? Editing in the debugger with restart? ENVY and similar tools to show editions of methods and replace them? Reflection? Hierarchy Browsers? Window drawing and event linking tools? ",
            "id": "777406551df1d788283b830e26e12087"
          },
          {
            "type": "html",
            "text": "<i>bit of a mixed collection of requirements here... Python doesn't have the nice environment that has always been part of Smalltalk -- after all it started life as a [[Scripting Language]]. It does have several user interface toolkits of which I believe the TK port is most popular. It does have reflection, although maybe not quite as much as Smalltalk. It also has, at least for now, one version, there are no vendor wars to lose.</i>",
            "id": "0d6d207013edae08c952908291d81e42"
          },
          {
            "type": "html",
            "text": "''Python's design actually makes on-the-fly editing difficult or impossible.  Classes are created by execution, not defined.  So:",
            "id": "6187cfebdafc7bcc4296f45497fd23a9"
          },
          {
            "type": "html",
            "text": ">>> class A:<br>",
            "id": "cd65d85a0b7960170df2aa95f884ccaf"
          },
          {
            "type": "html",
            "text": "...\tdef answer(self):<br>return \"YES!\"",
            "id": "103b454bbf10494c34dd663fea025724"
          },
          {
            "type": "code",
            "text": "  >>> a = A()\n  >>> class A:\n  ...  def answer(self): return \"NO!\"\n  >>> a.answer()\n  YES!",
            "id": "038fa7488cd0e5e091c338bcb935cbe8"
          },
          {
            "type": "html",
            "text": "\nAs you may see, the a object is still bound to the old definition of A.  You can do some funny tricks with this, but for the most part it causes problems.''",
            "id": "f7a195a0d6f2d3677a7e6b3f4bce6949"
          },
          {
            "type": "html",
            "text": "--",
            "id": "39b4715bee9a8817d6513dbd81039f35"
          },
          {
            "type": "html",
            "text": "\nBut the effect is achievable with:",
            "id": "ed78e0cc1253e2bbd66e237c38076f57"
          },
          {
            "type": "code",
            "text": "  >>> class A:\n  ...     def answer(self): return \"YES!\"\n  >>> a = A()\n  >>> class A:\n  ...     def answer(self): return \"NO!\"\n  >>> a.answer()\n  'YES!'\n  >>> a.__class__ = A #reload class\n  >>> a.answer()\n  'NO!'",
            "id": "fc9e0f25c10bd799a42e6e35889defcb"
          },
          {
            "type": "html",
            "text": "\nor for a single function:",
            "id": "14fd237e1a9e67cfecd53bba446e3ee8"
          },
          {
            "type": "code",
            "text": "  >>> class A:\n  ...  def answer(self): return \"YES!\"\n  >>> a = A()\n  >>> def just_say_no(self): \n  ...  return \"NO!\"\n  >>> A.answer = just_say_no\n  >>> a.answer()\n  NO!",
            "id": "f5afcc564571dce5c393ea21448fce90"
          },
          {
            "type": "html",
            "text": "\nThis happens to work in Ruby:",
            "id": "9da00a86a27de20b987b9a1d36fed594"
          },
          {
            "type": "code",
            "text": "  irb(main):001:0> class A\n  irb(main):002:1>   def answer;  return \"YES!\";  end\n  irb(main):003:1> end\n  => nil\n  irb(main):004:0> a = A.new\n  => #<A:0x298a510>\n  irb(main):005:0> a.answer\n  => \"YES!\"\n  irb(main):006:0> class A\n  irb(main):007:1>   def answer;  return \"NO!\";  end\n  irb(main):008:1> end\n  => nil\n  irb(main):009:0> a.answer\n  => \"NO!\"\n  irb(main):010:0>",
            "id": "0cee5cb57643553f792ec2f8f0b801e6"
          },
          {
            "type": "html",
            "text": "\nI guess that's not too surprising, given the way Ruby is modeled after Smalltalk.",
            "id": "f0b2b82e098e692f2a87e36922f7c314"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "<b>Comments</b>",
            "id": "d8d8b98ed65a35120a7b193262ac111a"
          },
          {
            "type": "html",
            "text": "\nDammit, I like 'em both. Which says a lot for Python, because I'm a die-hard [[Smalltalk Bigot]] (and a [[Knight Of The Square Bracket]]). Python meets my bare minimum usability requirements: [[Late Binding]] and [[Garbage Collection]]. And it has a 1970's hacker community feel to it. And I'm really enjoying using it. --[[Anthony Lander]]",
            "id": "64349e5695d25514f29e66c0b314bbae"
          },
          {
            "type": "html",
            "text": "[Comments on file orientation moved to [[Python Refactoring Browser]]]",
            "id": "701e27048d0febc666f6b7b18c7d2ed4"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "I'm very impressed with [[Ruby Language]]. Does anyone have any ideas on [[Smalltalk Instead Of Ruby]] or [[Ruby Instead Of Python]]? (See [[Python Vs Ruby]]) The only real drawback of Ruby that I see is that it is so young, but that will improve with time, of course, and by definition.",
            "id": "8aa36ab91ed3fa6a41412e848fe4a4f5"
          },
          {
            "type": "html",
            "text": "Since it looks like you have some experience with that, perhaps you could write something at [[Ruby Instead Of Smalltalk]] :-) Would be a good starting point for further discussion and comparisons.",
            "id": "6a89daec4870f7c364b89878fa9d2208"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "One thing going for Python is that it does or can resemble the [[Algol Language]]-roots style that is so common. One can more easily gradually transition instead of doing a mental 180.",
            "id": "00aed85f4ec55260ad8ae5089655acf6"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "\nAt this point (March 2005), Python also has a much larger community and library. It also has high quality free/Free implementations, which (as I understand it), Smalltalk does not. Personally, I wouldn't recommend using smalltalk unless you've already got experienced smalltalk developers and/or existing smalltalk code you need to work from.",
            "id": "dd34ecaa6918e6028ddb84fb1c62086f"
          },
          {
            "type": "html",
            "text": "<i>Squeak is both high quality and free. [[Visual Works]] is free for development. Smalltalk/X ([[Smalltalk Ecks]]) is even free for commercial users.</i>",
            "id": "0fbe4c715c7ada956c2f7b5e8ccbe399"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9832df991d09174ce7b514eeb57f6d13"
          },
          {
            "type": "html",
            "text": "[[Category Programming Language Comparisons]] [[Category Smalltalk]] [[Category Python]]",
            "id": "8f04486b4f8b6ad03761b537aa0c6f88"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?SmalltalkInsteadOfPython c2.com]",
            "id": "910cb6f834dfb81a72bc7c14fbef0970"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1702794203866
    }
  ]
}