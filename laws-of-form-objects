{
  "title": "Laws of Form Objects",
  "story": [
    {
      "type": "markdown",
      "id": "a4633f4334b4f317",
      "text": "Let’s start by creating the class `Form`. As we said earlier, it represents the piece of paper or canvas where we draw distinctions. A number of messages come to mind, such as `size` and `isEmpty`. But while the implementation of collection like behavior is quite straightforward, the question remains: what kind of collection does `Form` resemble the most? To answer that question, we need to examine its interaction with distinctions."
    },
    {
      "type": "paragraph",
      "id": "f45399b823e311a2",
      "text": "If we consider the circles on a piece of paper metaphor for distinctions, we could think of them in terms of these things that divide a space into two regions. We could also see them as these [[portals]] that have the capability of taking us from one space to another. As such, distinctions are the links connecting two different forms.\n\n"
    },
    {
      "type": "markdown",
      "id": "e943e95099f3f569",
      "text": "> Just like in [[Croquet]]."
    },
    {
      "type": "paragraph",
      "id": "a9c1faa81d9c29c1",
      "text": "Because of this, distinctions could be implemented as some sort of association. In particular, distinctions can be named, and hence they should also remember their name."
    },
    {
      "type": "paragraph",
      "id": "9388bc7c4affb9f5",
      "text": "The first axiom of the laws of form says that calling a name twice is the same as calling a name once. Therefore, a natural first approach would be to model forms in terms of a set of named distinctions."
    },
    {
      "type": "markdown",
      "id": "e8b4751526ee76f8",
      "text": "> Watch out for the desire to optimize prematurely at this point."
    },
    {
      "type": "markdown",
      "id": "5f3d07743d0086b2",
      "text": "Now it is time to choose instance names for our objects. We will start with class `Form`. What could we ask `aForm` to obtain a collection of the distinctions it contains? Well, the message `distinctions` sounds quite straightforward, and as such we will use it."
    },
    {
      "type": "markdown",
      "id": "62404b3aedd42e54",
      "text": "The names for distinctions require much more care. Distinctions are drawn on a form, and this is their form — in other words, the form of a distinction is where it is drawn. Therefore, `form` should answer the form where the distinction lives. Since `form` is now taken, what other selector could we use to access the form inside the distinction?"
    },
    {
      "type": "markdown",
      "id": "80c06d4589616723",
      "text": "In these situations, it is good to review the language that is used to talk about distinctions. Let’s see… “distinctions separate a space into two disjoint pieces”, “distinctions are the boundaries between such pieces”, “distinction is perfect continence”. It seems like there is a theme of enclosure, or even containment. The selector `contents` suggests itself. However, it is not clear that it is a good choice. This is because the contents of a distinction can only be accessed by crossing the distinction. As such, `contents` is intention obscuring because it seems to indicate it is fine to know about the contents of a distinction without crossing it — `contents` does not have strong encapsulation connotations. But not all is lost since we did mention the act of crossing distinctions. Thus, we will choose the verb instead of the noun, and send the message `[[cross]]` instead. If we let it be an accessor, then we will have an intention revealing instance name too."
    },
    {
      "type": "paragraph",
      "id": "852503c576ea5098",
      "text": "To summarize, we have the following classes and instance names so far."
    },
    {
      "type": "code",
      "id": "8de3ab54dbdb1376",
      "text": "Object \n  Form (distinctions) \n  Distinction (form cross name)"
    },
    {
      "type": "markdown",
      "id": "af76dcb5d51ce2ee",
      "text": "Now we should design how these objects interact together by means of messages. Clearly, distinctions need a form where to live. This indicates that instances of `Form` will be created first, and that forms will create instances of `Distinction`. What would be a good process for these distinctions to be created and crossed into? What would *we* do if we wanted to distinguish something in a form?"
    },
    {
      "type": "paragraph",
      "id": "eb5656c393c4ceab",
      "text": "At this point, very interesting questions appear. For us, intention distinguishes between different values, and the way in which we care about the differences determines the kind of distinctions we draw. And we just take this for granted. To illustrate the point, every so often I try to look at something as a blob, without further interpretation. In my experience, it is almost impossible to do with letters. The association between the glyph and its meaning happens too quickly for it to be stopped. Drawing distinctions is so automatic for us that it is almost invisible."
    },
    {
      "type": "paragraph",
      "id": "4421638953826a1a",
      "text": "When we try to reproduce this act in Smalltalk, we run into further difficulty. For example, what if we told a form to distinguish something? Certainly, we would tell it what to distinguish by means of an argument to a message. But in Smalltalk everything is an object, and therefore distinguishing something in a form object requires that the very something we are trying to distinguish must exist beforehand, so we can pass it as an argument. What is going on?"
    },
    {
      "type": "paragraph",
      "id": "0b441bb2b23a7eb9",
      "text": "The issues are that objects are distinctions that live in the image, and that the Smalltalk image is a form. In other words, form and distinction objects are redundant because they reproduce what Smalltalk provides for free. Then why should we try to copy what is already given? Because reflecting on these matters can be quite valuable. Redundancy can work on our favor here, as it will make explicit something we usually take for granted. And when this happens, we will be able to change what we take for granted and create new things."
    },
    {
      "type": "paragraph",
      "id": "2c63a39f2bba9921",
      "text": "So we have our form, and an already existing distinction (in some other unspecified form) that we want to distinguish in the new form. In Smalltalk, it would be natural to take the object and put it in the new form. This new distinction would then be identical to the original one, and thus we could think of this re-distinction as some sort of copy or act of reference. But then, as per Laws of Form, if we take a distinction existing in some form, and copy it into another form, then we can refer to the copy as the name for the original distinction. And this is where things become interesting."
    },
    {
      "type": "markdown",
      "id": "23c9a597ce03ef76",
      "text": "> What is being copied is the pointer to the object header, but fortunately we do not have to deal with that."
    },
    {
      "type": "paragraph",
      "id": "d130a3e2c7577c91",
      "text": "Interesting indeed: you could think of the form in your mind being the unspecified form, and the Smalltalk image being the form in which you copy distinctions already present in the unspecified form — oh.\n"
    },
    {
      "type": "paragraph",
      "id": "39e6cf09f18161fa",
      "text": "First of all, since the copy is a name, and because we are in the Smalltalk image the copy is identical to the original, then each object we distinguish in the new form is both the object and its own name. In this way, Smalltalk objects have this very peculiar dual property: they are their own name."
    },
    {
      "type": "markdown",
      "id": "ccc097e473c74a0a",
      "text": "> And when you cannot name them, they are garbage."
    },
    {
      "type": "paragraph",
      "id": "8aec9219f1d7e5e7",
      "text": "But then, if we do not need to care about distinction names explicitly, we can simply distinguish objects in our new form and let them stand for their own names. Our original design for form, a set of named distinctions, now looks very promising. Therefore we implement the following message."
    },
    {
      "type": "code",
      "id": "4e4d96d5bd4ef1ea",
      "text": "Distinction>>= aDistinction \n\n  ^self name = aDistinction name"
    },
    {
      "type": "markdown",
      "id": "bcce2c555beef1a0",
      "text": "In this way, forms would be the equivalent of sets. Of course, if necessary, we could easily implement `IdentityForm` and `IdentityDistinction`, but we will leave those for when we actually need them.\n"
    },
    {
      "type": "markdown",
      "id": "e8f642c3eaa6e612",
      "text": "So all this is great, but. . . hey, aren’t we forgetting something? Well, yes we implemented = but we did not implement `hash`!\n"
    },
    {
      "type": "markdown",
      "id": "7ff351a4df372967",
      "text": "> Baaad programmer! Slap! Slap!"
    },
    {
      "type": "code",
      "id": "c26a9a24be1f14b0",
      "text": "Distinction>>hash \n\n  ^self name hash"
    },
    {
      "type": "markdown",
      "id": "abd168857dc21540",
      "text": "We should not forget to implement `hash` when we refine `=`, as failure to do so  can lead to issues that are quite hard to debug.\n\n"
    },
    {
      "type": "markdown",
      "id": "6171a0c966e74988",
      "text": "> Baaad doggie! Don’t chew on the power co@Σ?# +$∼!&Γ:* — NO TERRIER"
    },
    {
      "type": "paragraph",
      "id": "d406f6db9c466f67",
      "text": "Back to forms and distinctions now. At last, we can start implementing the messages that will allow us to give shape to our silly putty. Since we cannot do much with empty forms, let’s start with the message below."
    },
    {
      "type": "markdown",
      "id": "160d59108c2d3612",
      "text": "> In case you are wondering, the DOS character set includes (among others) the greek letters shown above. In particular, the index of Σ is 228, and that of Γ is 226."
    },
    {
      "type": "code",
      "id": "9906b3b47a2cf8e2",
      "text": "Form>>distinguish: aName \n\n  ^(self distinctionNamed: aName) ifNil: \n    [ \n      | distinction | \n      distinction := Dictinction named: aName.\n      distinction form: self. \n      self distinctions add: distinction. \n      distinction \n    ]"
    },
    {
      "type": "markdown",
      "id": "dd10014457b83ca1",
      "text": "We can enforce the *only one distinction per name* restriction because the first axiom of *[[Laws of Form]]* says that invoking the same name twice is the same as invoking it once. In other words, we are not altering the meaning of the form structure by doing so. To that effect, pay close attention at how `ifNil:` is not being used as a control mechanism, but rather as a means of replacement. Indeed, `ifNil:` should be read as meaning `butIfNil:` instead.\n"
    },
    {
      "type": "markdown",
      "id": "8acdad5a8e6d37d6",
      "text": "So how is `distinctionNamed:` implemented?"
    },
    {
      "type": "code",
      "id": "6abae7a7b4e088ea",
      "text": "Form>>distinctionNamed: aName \n\n  ^self distinctions \n    detect: [:any | any name = aName] \n    ifNone: [nil]"
    },
    {
      "type": "paragraph",
      "id": "9268864a4c1a5af1",
      "text": "You may be tempted to use a dictionary here, but keep that temptation at bay for now — the exercises have the details."
    },
    {
      "type": "paragraph",
      "id": "630cbb042143003a",
      "text": "Once we have these messages, we should be able to cross into another form via a distinction. To do that, we simply implement the following message."
    },
    {
      "type": "code",
      "id": "1379a77958b6ccb9",
      "text": "Form>>cross: aName \n\n  ^(self distinguish: aName) cross"
    },
    {
      "type": "markdown",
      "id": "68c952d43685e168",
      "text": "Note how this can create a distinction the first time, and reuse it thereafter. This is consistent with the *Laws of Form* axiom that says that using a name twice is the same as using it once. Also, note how the distinction answers its contents form when answering the message cross. This emphasizes how important proper names can be."
    },
    {
      "type": "markdown",
      "id": "1746e2a6e100256d",
      "text": "Finally, there should be a way to undistinguish something. And what would a good selector for that be? Certainly, `undistinguish:` seems a bit coarse. The selector `forget:` is also misleading. We need to undo a distinction, and that is not the same as forgetting it."
    },
    {
      "type": "paragraph",
      "id": "b21f34a6d580a3a9",
      "text": "Perhaps we could find a selector by looking at the state of things before the distinction occurred. Before the distinction was drawn, there were no differences in value."
    },
    {
      "type": "paragraph",
      "id": "1c2ba9980489664e",
      "text": "Hmmm… perhaps we are getting somewhere. Let’s continue finding alternate ways to say the same thing."
    },
    {
      "type": "paragraph",
      "id": "f2e6a0edf831f1ab",
      "text": "Both sides of the distinction had the same value to us. We could use them interchangeably. They were equivalent to us. We did not need to care about their differences."
    },
    {
      "type": "paragraph",
      "id": "8b9a2e32b242e215",
      "text": "Well, all of these are positive assertions and we do not seem to be making much headway. How about some negative ones?"
    },
    {
      "type": "markdown",
      "id": "a69ac29532a46798",
      "text": "> The technique is almost automatic, to the point of seeming to have very little merit. However, it relies heavily on how evolution has worked for so much time. If something does not quite work, find a peculiar characteristic of it and apply some change. In other words, purposefully introduce mutations in how the traversal of the space is done, and evaluate the outcome. Do the random walk."
    },
    {
      "type": "paragraph",
      "id": "ba9cce0c2a951300",
      "text": "We were looking at things with a coarser resolution. Both sides fell in the same bucket. We would not care if we picked one or the other. We would confuse one for the other."
    },
    {
      "type": "paragraph",
      "id": "c07130a59b31b807",
      "text": "Hold it right there! That is it!"
    },
    {
      "type": "code",
      "id": "9f00cfe8bbb12aa6",
      "text": "Form>>confuse: aName \n\n  | existingDistinction | \n  existingDistinction := self distinctionNamed: aName. \n  existingDistinction isNil ifTrue: [^self]. \n  self distinctions remove: existingDistinction"
    },
    {
      "type": "markdown",
      "id": "c345c13fda0775ee",
      "text": "Now that we have our basic *[[Laws of Form]]* objects in place, let’s see how this relates to distinctions existing in the Smalltalk form — I mean image."
    },
    {
      "type": "paragraph",
      "id": "b607183e13ebf347",
      "text": "⇒ [[Smalltalk Objects]]"
    },
    {
      "type": "pagefold",
      "id": "fd8133c008489491",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "95e4e1e46cc008c8",
      "text": "Section 5.3.1 of [[A Mentoring Course on Smalltalk]], [[An Efficient Reference Finder]]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Laws of Form Objects",
        "story": []
      },
      "date": 1660219756072
    },
    {
      "item": {
        "type": "factory",
        "id": "a4633f4334b4f317"
      },
      "id": "a4633f4334b4f317",
      "type": "add",
      "date": 1660219765140
    },
    {
      "type": "edit",
      "id": "a4633f4334b4f317",
      "item": {
        "type": "paragraph",
        "id": "a4633f4334b4f317",
        "text": "Let’s start by creating the class Form. As we said earlier, it represents the piece of paper or canvas where we draw distinctions. A number of messages come to mind, such as size and isEmpty. But while the implementation of collection like behavior is quite straightforward, the question remains: what kind of collection does Form resemble the most? To answer that question, we need to examine its interaction with distinctions."
      },
      "date": 1660219766851
    },
    {
      "type": "edit",
      "id": "a4633f4334b4f317",
      "item": {
        "type": "paragraph",
        "id": "a4633f4334b4f317",
        "text": "Let’s start by creating the class `Form`. As we said earlier, it represents the piece of paper or canvas where we draw distinctions. A number of messages come to mind, such as size and isEmpty. But while the implementation of collection like behavior is quite straightforward, the question remains: what kind of collection does Form resemble the most? To answer that question, we need to examine its interaction with distinctions."
      },
      "date": 1660219776141
    },
    {
      "type": "edit",
      "id": "a4633f4334b4f317",
      "item": {
        "type": "markdown",
        "id": "a4633f4334b4f317",
        "text": "Let’s start by creating the class `Form`. As we said earlier, it represents the piece of paper or canvas where we draw distinctions. A number of messages come to mind, such as size and isEmpty. But while the implementation of collection like behavior is quite straightforward, the question remains: what kind of collection does Form resemble the most? To answer that question, we need to examine its interaction with distinctions."
      },
      "date": 1660219777368
    },
    {
      "type": "edit",
      "id": "a4633f4334b4f317",
      "item": {
        "type": "markdown",
        "id": "a4633f4334b4f317",
        "text": "Let’s start by creating the class `Form`. As we said earlier, it represents the piece of paper or canvas where we draw distinctions. A number of messages come to mind, such as `size` and `isEmpty`. But while the implementation of collection like behavior is quite straightforward, the question remains: what kind of collection does Form resemble the most? To answer that question, we need to examine its interaction with distinctions."
      },
      "date": 1660219807625
    },
    {
      "type": "edit",
      "id": "a4633f4334b4f317",
      "item": {
        "type": "markdown",
        "id": "a4633f4334b4f317",
        "text": "Let’s start by creating the class `Form`. As we said earlier, it represents the piece of paper or canvas where we draw distinctions. A number of messages come to mind, such as `size` and `isEmpty`. But while the implementation of collection like behavior is quite straightforward, the question remains: what kind of collection does `Form` resemble the most? To answer that question, we need to examine its interaction with distinctions."
      },
      "date": 1660219819547
    },
    {
      "item": {
        "type": "factory",
        "id": "f45399b823e311a2"
      },
      "id": "f45399b823e311a2",
      "type": "add",
      "after": "a4633f4334b4f317",
      "date": 1660219871620
    },
    {
      "type": "edit",
      "id": "f45399b823e311a2",
      "item": {
        "type": "paragraph",
        "id": "f45399b823e311a2",
        "text": "If we consider the circles on a piece of paper metaphor for distinctions, we could think of them in terms of these things that divide a space into two regions. We could also see them as these portals that have the capability of taking us from one space to another. As such, distinctions are the links connecting two different forms.\n\n"
      },
      "date": 1660219875364
    },
    {
      "type": "add",
      "id": "e943e95099f3f569",
      "item": {
        "type": "paragraph",
        "id": "e943e95099f3f569",
        "text": "> Just like in Croquet."
      },
      "after": "f45399b823e311a2",
      "date": 1660219876368
    },
    {
      "type": "edit",
      "id": "e943e95099f3f569",
      "item": {
        "type": "markdown",
        "id": "e943e95099f3f569",
        "text": "> Just like in Croquet."
      },
      "date": 1660219877180
    },
    {
      "type": "edit",
      "id": "f45399b823e311a2",
      "item": {
        "type": "paragraph",
        "id": "f45399b823e311a2",
        "text": "If we consider the circles on a piece of paper metaphor for distinctions, we could think of them in terms of these things that divide a space into two regions. We could also see them as these [[portals]] that have the capability of taking us from one space to another. As such, distinctions are the links connecting two different forms.\n\n"
      },
      "date": 1660219916174
    },
    {
      "type": "edit",
      "id": "e943e95099f3f569",
      "item": {
        "type": "markdown",
        "id": "e943e95099f3f569",
        "text": "> Just like in [[Croquet]]."
      },
      "date": 1660219921658
    },
    {
      "item": {
        "type": "factory",
        "id": "a9c1faa81d9c29c1"
      },
      "id": "a9c1faa81d9c29c1",
      "type": "add",
      "after": "e943e95099f3f569",
      "date": 1660219988466
    },
    {
      "type": "edit",
      "id": "a9c1faa81d9c29c1",
      "item": {
        "type": "paragraph",
        "id": "a9c1faa81d9c29c1",
        "text": "Because of this, distinctions could be implemented as some sort of association. In particular, distinctions can be named, and hence they should also remember their name."
      },
      "date": 1660219990400
    },
    {
      "item": {
        "type": "factory",
        "id": "9388bc7c4affb9f5"
      },
      "id": "9388bc7c4affb9f5",
      "type": "add",
      "after": "a9c1faa81d9c29c1",
      "date": 1660220008566
    },
    {
      "type": "edit",
      "id": "9388bc7c4affb9f5",
      "item": {
        "type": "paragraph",
        "id": "9388bc7c4affb9f5",
        "text": "The first axiom of the laws of form says that calling a name twice is the same as calling a name once. Therefore, a natural first approach would be to model forms in terms of a set of named distinctions."
      },
      "date": 1660220012134
    },
    {
      "item": {
        "type": "factory",
        "id": "e8b4751526ee76f8"
      },
      "id": "e8b4751526ee76f8",
      "type": "add",
      "after": "9388bc7c4affb9f5",
      "date": 1660220033777
    },
    {
      "type": "edit",
      "id": "e8b4751526ee76f8",
      "item": {
        "type": "markdown",
        "id": "e8b4751526ee76f8",
        "text": "> Watch out for the desire to optimize prematurely at this point."
      },
      "date": 1660220036801
    },
    {
      "item": {
        "type": "factory",
        "id": "5f3d07743d0086b2"
      },
      "id": "5f3d07743d0086b2",
      "type": "add",
      "after": "e8b4751526ee76f8",
      "date": 1660220045493
    },
    {
      "type": "edit",
      "id": "5f3d07743d0086b2",
      "item": {
        "type": "paragraph",
        "id": "5f3d07743d0086b2",
        "text": "Now it is time to choose instance names for our objects. We will start with class Form. What could we ask aForm to obtain a collection of the distinctions it contains? Well, the message distinctions sounds quite straightforward, and as such we will use it."
      },
      "date": 1660220047050
    },
    {
      "type": "edit",
      "id": "5f3d07743d0086b2",
      "item": {
        "type": "paragraph",
        "id": "5f3d07743d0086b2",
        "text": "Now it is time to choose instance names for our objects. We will start with class `Form`. What could we ask aForm to obtain a collection of the distinctions it contains? Well, the message distinctions sounds quite straightforward, and as such we will use it."
      },
      "date": 1660220058455
    },
    {
      "type": "edit",
      "id": "5f3d07743d0086b2",
      "item": {
        "type": "markdown",
        "id": "5f3d07743d0086b2",
        "text": "Now it is time to choose instance names for our objects. We will start with class `Form`. What could we ask aForm to obtain a collection of the distinctions it contains? Well, the message distinctions sounds quite straightforward, and as such we will use it."
      },
      "date": 1660220059875
    },
    {
      "type": "edit",
      "id": "5f3d07743d0086b2",
      "item": {
        "type": "markdown",
        "id": "5f3d07743d0086b2",
        "text": "Now it is time to choose instance names for our objects. We will start with class `Form`. What could we ask `aForm` to obtain a collection of the distinctions it contains? Well, the message distinctions sounds quite straightforward, and as such we will use it."
      },
      "date": 1660220073373
    },
    {
      "type": "edit",
      "id": "5f3d07743d0086b2",
      "item": {
        "type": "markdown",
        "id": "5f3d07743d0086b2",
        "text": "Now it is time to choose instance names for our objects. We will start with class `Form`. What could we ask `aForm` to obtain a collection of the distinctions it contains? Well, the message `distinctions` sounds quite straightforward, and as such we will use it."
      },
      "date": 1660220091283
    },
    {
      "item": {
        "type": "factory",
        "id": "62404b3aedd42e54"
      },
      "id": "62404b3aedd42e54",
      "type": "add",
      "after": "5f3d07743d0086b2",
      "date": 1660220101953
    },
    {
      "type": "edit",
      "id": "62404b3aedd42e54",
      "item": {
        "type": "paragraph",
        "id": "62404b3aedd42e54",
        "text": "The names for distinctions require much more care. Distinctions are drawn on a form, and this is their form — in other words, the form of a distinction is where it is drawn. Therefore, form should answer the form where the distinction lives. Since form is now taken, what other selector could we use to access the form inside the distinction?"
      },
      "date": 1660220115623
    },
    {
      "type": "edit",
      "id": "62404b3aedd42e54",
      "item": {
        "type": "paragraph",
        "id": "62404b3aedd42e54",
        "text": "The names for distinctions require much more care. Distinctions are drawn on a form, and this is their form — in other words, the form of a distinction is where it is drawn. Therefore, `form` should answer the form where the distinction lives. Since form is now taken, what other selector could we use to access the form inside the distinction?"
      },
      "date": 1660220127575
    },
    {
      "type": "edit",
      "id": "62404b3aedd42e54",
      "item": {
        "type": "markdown",
        "id": "62404b3aedd42e54",
        "text": "The names for distinctions require much more care. Distinctions are drawn on a form, and this is their form — in other words, the form of a distinction is where it is drawn. Therefore, `form` should answer the form where the distinction lives. Since form is now taken, what other selector could we use to access the form inside the distinction?"
      },
      "date": 1660220128742
    },
    {
      "type": "edit",
      "id": "62404b3aedd42e54",
      "item": {
        "type": "markdown",
        "id": "62404b3aedd42e54",
        "text": "The names for distinctions require much more care. Distinctions are drawn on a form, and this is their form — in other words, the form of a distinction is where it is drawn. Therefore, `form` should answer the form where the distinction lives. Since `form` is now taken, what other selector could we use to access the form inside the distinction?"
      },
      "date": 1660220139103
    },
    {
      "item": {
        "type": "factory",
        "id": "80c06d4589616723"
      },
      "id": "80c06d4589616723",
      "type": "add",
      "after": "62404b3aedd42e54",
      "date": 1660220181338
    },
    {
      "type": "edit",
      "id": "80c06d4589616723",
      "item": {
        "type": "paragraph",
        "id": "80c06d4589616723",
        "text": "In these situations, it is good to review the language that is used to talk about distinctions. Let’s see. . . “distinctions separate a space into two disjoint pieces”, “distinctions are the boundaries between such pieces”, “distinction is perfect continence”. It seems like there is a theme of enclosure, or even containment. The selector contents suggests itself. However, it is not clear that it is a good choice. This is because the contents of a distinction can only be accessed by crossing the distinction. As such, contents is intention obscuring because it seems to indicate it is fine to know about the contents of a distinction without crossing it — contents does not have strong encapsulation connotations. But not all is lost since we did mention the act of crossing distinctions. Thus, we will choose the verb instead of the noun, and send the message cross instead. If we let it be an accessor, then we will have an intention revealing instance name too."
      },
      "date": 1660220185370
    },
    {
      "type": "edit",
      "id": "80c06d4589616723",
      "item": {
        "type": "paragraph",
        "id": "80c06d4589616723",
        "text": "In these situations, it is good to review the language that is used to talk about distinctions. Let’s see… “distinctions separate a space into two disjoint pieces”, “distinctions are the boundaries between such pieces”, “distinction is perfect continence”. It seems like there is a theme of enclosure, or even containment. The selector `contents` suggests itself. However, it is not clear that it is a good choice. This is because the contents of a distinction can only be accessed by crossing the distinction. As such, contents is intention obscuring because it seems to indicate it is fine to know about the contents of a distinction without crossing it — contents does not have strong encapsulation connotations. But not all is lost since we did mention the act of crossing distinctions. Thus, we will choose the verb instead of the noun, and send the message cross instead. If we let it be an accessor, then we will have an intention revealing instance name too."
      },
      "date": 1660220222237
    },
    {
      "type": "edit",
      "id": "80c06d4589616723",
      "item": {
        "type": "markdown",
        "id": "80c06d4589616723",
        "text": "In these situations, it is good to review the language that is used to talk about distinctions. Let’s see… “distinctions separate a space into two disjoint pieces”, “distinctions are the boundaries between such pieces”, “distinction is perfect continence”. It seems like there is a theme of enclosure, or even containment. The selector `contents` suggests itself. However, it is not clear that it is a good choice. This is because the contents of a distinction can only be accessed by crossing the distinction. As such, contents is intention obscuring because it seems to indicate it is fine to know about the contents of a distinction without crossing it — contents does not have strong encapsulation connotations. But not all is lost since we did mention the act of crossing distinctions. Thus, we will choose the verb instead of the noun, and send the message cross instead. If we let it be an accessor, then we will have an intention revealing instance name too."
      },
      "date": 1660220224751
    },
    {
      "type": "edit",
      "id": "80c06d4589616723",
      "item": {
        "type": "markdown",
        "id": "80c06d4589616723",
        "text": "In these situations, it is good to review the language that is used to talk about distinctions. Let’s see… “distinctions separate a space into two disjoint pieces”, “distinctions are the boundaries between such pieces”, “distinction is perfect continence”. It seems like there is a theme of enclosure, or even containment. The selector `contents` suggests itself. However, it is not clear that it is a good choice. This is because the contents of a distinction can only be accessed by crossing the distinction. As such, `contents` is intention obscuring because it seems to indicate it is fine to know about the contents of a distinction without crossing it — contents does not have strong encapsulation connotations. But not all is lost since we did mention the act of crossing distinctions. Thus, we will choose the verb instead of the noun, and send the message cross instead. If we let it be an accessor, then we will have an intention revealing instance name too."
      },
      "date": 1660220266694
    },
    {
      "type": "edit",
      "id": "80c06d4589616723",
      "item": {
        "type": "markdown",
        "id": "80c06d4589616723",
        "text": "In these situations, it is good to review the language that is used to talk about distinctions. Let’s see… “distinctions separate a space into two disjoint pieces”, “distinctions are the boundaries between such pieces”, “distinction is perfect continence”. It seems like there is a theme of enclosure, or even containment. The selector `contents` suggests itself. However, it is not clear that it is a good choice. This is because the contents of a distinction can only be accessed by crossing the distinction. As such, `contents` is intention obscuring because it seems to indicate it is fine to know about the contents of a distinction without crossing it — `contents` does not have strong encapsulation connotations. But not all is lost since we did mention the act of crossing distinctions. Thus, we will choose the verb instead of the noun, and send the message cross instead. If we let it be an accessor, then we will have an intention revealing instance name too."
      },
      "date": 1660220289859
    },
    {
      "type": "edit",
      "id": "80c06d4589616723",
      "item": {
        "type": "markdown",
        "id": "80c06d4589616723",
        "text": "In these situations, it is good to review the language that is used to talk about distinctions. Let’s see… “distinctions separate a space into two disjoint pieces”, “distinctions are the boundaries between such pieces”, “distinction is perfect continence”. It seems like there is a theme of enclosure, or even containment. The selector `contents` suggests itself. However, it is not clear that it is a good choice. This is because the contents of a distinction can only be accessed by crossing the distinction. As such, `contents` is intention obscuring because it seems to indicate it is fine to know about the contents of a distinction without crossing it — `contents` does not have strong encapsulation connotations. But not all is lost since we did mention the act of crossing distinctions. Thus, we will choose the verb instead of the noun, and send the message `cross` instead. If we let it be an accessor, then we will have an intention revealing instance name too."
      },
      "date": 1660220321954
    },
    {
      "item": {
        "type": "factory",
        "id": "852503c576ea5098"
      },
      "id": "852503c576ea5098",
      "type": "add",
      "after": "80c06d4589616723",
      "date": 1660220337328
    },
    {
      "type": "edit",
      "id": "852503c576ea5098",
      "item": {
        "type": "paragraph",
        "id": "852503c576ea5098",
        "text": "To summarize, we have the following classes and instance names so far."
      },
      "date": 1660220339533
    },
    {
      "item": {
        "type": "factory",
        "id": "8de3ab54dbdb1376"
      },
      "id": "8de3ab54dbdb1376",
      "type": "add",
      "after": "852503c576ea5098",
      "date": 1660220344249
    },
    {
      "type": "edit",
      "id": "8de3ab54dbdb1376",
      "item": {
        "type": "code",
        "id": "8de3ab54dbdb1376",
        "text": "Object Form (distinctions) Distinction (form cross name)"
      },
      "date": 1660220346813
    },
    {
      "type": "edit",
      "id": "8de3ab54dbdb1376",
      "item": {
        "type": "code",
        "id": "8de3ab54dbdb1376",
        "text": "Object \n  Form (distinctions) \n  Distinction (form cross name)"
      },
      "date": 1660220357019
    },
    {
      "item": {
        "type": "factory",
        "id": "af76dcb5d51ce2ee"
      },
      "id": "af76dcb5d51ce2ee",
      "type": "add",
      "after": "8de3ab54dbdb1376",
      "date": 1660220379423
    },
    {
      "type": "edit",
      "id": "af76dcb5d51ce2ee",
      "item": {
        "type": "paragraph",
        "id": "af76dcb5d51ce2ee",
        "text": "Now we should design how these objects interact together by means of messages. Clearly, distinctions need a form where to live. This indicates that instances of Form will be created first, and that forms will create instances of Distinction. What would be a good process for these distinctions to be created and crossed into? What would we do if we wanted to distinguish something in a form?"
      },
      "date": 1660220383174
    },
    {
      "type": "edit",
      "id": "af76dcb5d51ce2ee",
      "item": {
        "type": "paragraph",
        "id": "af76dcb5d51ce2ee",
        "text": "Now we should design how these objects interact together by means of messages. Clearly, distinctions need a form where to live. This indicates that instances of `Form` will be created first, and that forms will create instances of `Distinction`. What would be a good process for these distinctions to be created and crossed into? What would we do if we wanted to distinguish something in a form?"
      },
      "date": 1660220410711
    },
    {
      "type": "edit",
      "id": "af76dcb5d51ce2ee",
      "item": {
        "type": "markdown",
        "id": "af76dcb5d51ce2ee",
        "text": "Now we should design how these objects interact together by means of messages. Clearly, distinctions need a form where to live. This indicates that instances of `Form` will be created first, and that forms will create instances of `Distinction`. What would be a good process for these distinctions to be created and crossed into? What would we do if we wanted to distinguish something in a form?"
      },
      "date": 1660220412021
    },
    {
      "type": "edit",
      "id": "af76dcb5d51ce2ee",
      "item": {
        "type": "markdown",
        "id": "af76dcb5d51ce2ee",
        "text": "Now we should design how these objects interact together by means of messages. Clearly, distinctions need a form where to live. This indicates that instances of `Form` will be created first, and that forms will create instances of `Distinction`. What would be a good process for these distinctions to be created and crossed into? What would *we* do if we wanted to distinguish something in a form?"
      },
      "date": 1660220422837
    },
    {
      "item": {
        "type": "factory",
        "id": "eb5656c393c4ceab"
      },
      "id": "eb5656c393c4ceab",
      "type": "add",
      "after": "af76dcb5d51ce2ee",
      "date": 1660220436451
    },
    {
      "item": {
        "type": "factory",
        "id": "c345c13fda0775ee"
      },
      "id": "c345c13fda0775ee",
      "type": "add",
      "after": "eb5656c393c4ceab",
      "date": 1660220439280
    },
    {
      "type": "edit",
      "id": "eb5656c393c4ceab",
      "item": {
        "type": "paragraph",
        "id": "eb5656c393c4ceab",
        "text": "At this point, very interesting questions appear. For us, intention distinguishes between different values, and the way in which we care about the differences determines the kind of distinctions we draw. And we just take this for granted. To illustrate the point, every so often I try to look at something as a blob, without further interpretation. In my experience, it is almost impossible to do with letters. The association between the glyph and its meaning happens too quickly for it to be stopped. Drawing distinctions is so automatic for us that it is almost invisible."
      },
      "date": 1660220440397
    },
    {
      "type": "edit",
      "id": "c345c13fda0775ee",
      "item": {
        "type": "paragraph",
        "id": "c345c13fda0775ee",
        "text": "[…]"
      },
      "date": 1660220443628
    },
    {
      "item": {
        "type": "factory",
        "id": "4421638953826a1a"
      },
      "id": "4421638953826a1a",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660220481224
    },
    {
      "id": "4421638953826a1a",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "c345c13fda0775ee"
      ],
      "date": 1660220482880
    },
    {
      "type": "edit",
      "id": "4421638953826a1a",
      "item": {
        "type": "paragraph",
        "id": "4421638953826a1a",
        "text": "When we try to reproduce this act in Smalltalk, we run into further difficulty. For example, what if we told a form to distinguish something? Certainly, we would tell it what to distinguish by means of an argument to a message. But in Smalltalk everything is an object, and therefore distinguishing something in a form object requires that the very something we are trying to distinguish must exist beforehand, so we can pass it as an argument. What is going on?"
      },
      "date": 1660220485793
    },
    {
      "type": "add",
      "id": "0b441bb2b23a7eb9",
      "item": {
        "type": "paragraph",
        "id": "0b441bb2b23a7eb9",
        "text": "he issues are that objects are distinctions that live in the image, and that the Smalltalk image is a form. In other words, form and distinction objects are redundant because they reproduce what Smalltalk provides for free. Then why should we try to copy what is already given? Because reflecting on these matters can be quite valuable. Redundancy can work on our favor here, as it will make explicit something we usually take for granted. And when this happens, we will be able to change what we take for granted and create new things."
      },
      "after": "4421638953826a1a",
      "date": 1660220506038
    },
    {
      "type": "edit",
      "id": "0b441bb2b23a7eb9",
      "item": {
        "type": "paragraph",
        "id": "0b441bb2b23a7eb9",
        "text": "The issues are that objects are distinctions that live in the image, and that the Smalltalk image is a form. In other words, form and distinction objects are redundant because they reproduce what Smalltalk provides for free. Then why should we try to copy what is already given? Because reflecting on these matters can be quite valuable. Redundancy can work on our favor here, as it will make explicit something we usually take for granted. And when this happens, we will be able to change what we take for granted and create new things."
      },
      "date": 1660220514054
    },
    {
      "type": "add",
      "id": "2c63a39f2bba9921",
      "item": {
        "type": "paragraph",
        "id": "2c63a39f2bba9921",
        "text": "So we have our form, and an already existing distinction (in some other unspecified form) that we want to distinguish in the new form. In Smalltalk, it would be natural to take the object and put it in the new form. This new distinction would then be identical to the original one, and thus we could think of this re-distinction as some sort of copy or act of reference. But then, as per Laws of Form, if we take a distinction existing in some form, and copy it into another form, then we can refer to the copy as the name for the original distinction. And this is where things become interesting5.\n\n"
      },
      "after": "0b441bb2b23a7eb9",
      "date": 1660220572998
    },
    {
      "type": "add",
      "id": "23c9a597ce03ef76",
      "item": {
        "type": "paragraph",
        "id": "23c9a597ce03ef76",
        "text": "> What is being copied is the pointer to the object header, but fortunately we do not have to deal with that."
      },
      "after": "2c63a39f2bba9921",
      "date": 1660220575006
    },
    {
      "type": "edit",
      "id": "23c9a597ce03ef76",
      "item": {
        "type": "markdown",
        "id": "23c9a597ce03ef76",
        "text": "> What is being copied is the pointer to the object header, but fortunately we do not have to deal with that."
      },
      "date": 1660220576063
    },
    {
      "type": "edit",
      "id": "2c63a39f2bba9921",
      "item": {
        "type": "paragraph",
        "id": "2c63a39f2bba9921",
        "text": "So we have our form, and an already existing distinction (in some other unspecified form) that we want to distinguish in the new form. In Smalltalk, it would be natural to take the object and put it in the new form. This new distinction would then be identical to the original one, and thus we could think of this re-distinction as some sort of copy or act of reference. But then, as per Laws of Form, if we take a distinction existing in some form, and copy it into another form, then we can refer to the copy as the name for the original distinction. And this is where things become interesting."
      },
      "date": 1660220602469
    },
    {
      "type": "add",
      "id": "d130a3e2c7577c91",
      "item": {
        "type": "paragraph",
        "id": "d130a3e2c7577c91",
        "text": "Interesting indeed: you could think of the form in your mind being the unspecified form, and the Smalltalk image being the form in which you copy distinctions already present in the unspecified form — oh.\n"
      },
      "after": "2c63a39f2bba9921",
      "date": 1660220603497
    },
    {
      "id": "d130a3e2c7577c91",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "c345c13fda0775ee"
      ],
      "date": 1660220606233
    },
    {
      "type": "add",
      "id": "39e6cf09f18161fa",
      "item": {
        "type": "paragraph",
        "id": "39e6cf09f18161fa",
        "text": "First of all, since the copy is a name, and because we are in the Smalltalk"
      },
      "after": "d130a3e2c7577c91",
      "date": 1660220630102
    },
    {
      "type": "edit",
      "id": "39e6cf09f18161fa",
      "item": {
        "type": "paragraph",
        "id": "39e6cf09f18161fa",
        "text": "First of all, since the copy is a name, and because we are in the Smalltalk mage the copy is identical to the original, then each object we distinguish in the new form is both the object and its own name. In this way, Smalltalk objects have this very peculiar dual property: they are their own name."
      },
      "date": 1660220637196
    },
    {
      "type": "edit",
      "id": "39e6cf09f18161fa",
      "item": {
        "type": "paragraph",
        "id": "39e6cf09f18161fa",
        "text": "First of all, since the copy is a name, and because we are in the Smalltalk image the copy is identical to the original, then each object we distinguish in the new form is both the object and its own name. In this way, Smalltalk objects have this very peculiar dual property: they are their own name."
      },
      "date": 1660220648732
    },
    {
      "type": "add",
      "id": "ccc097e473c74a0a",
      "item": {
        "type": "paragraph",
        "id": "ccc097e473c74a0a",
        "text": "> And when you cannot name them, they are garbage."
      },
      "after": "39e6cf09f18161fa",
      "date": 1660220671073
    },
    {
      "type": "edit",
      "id": "ccc097e473c74a0a",
      "item": {
        "type": "markdown",
        "id": "ccc097e473c74a0a",
        "text": "> And when you cannot name them, they are garbage."
      },
      "date": 1660220672885
    },
    {
      "type": "add",
      "id": "8aec9219f1d7e5e7",
      "item": {
        "type": "paragraph",
        "id": "8aec9219f1d7e5e7",
        "text": "But then, if we do not need to care about distinction names explicitly, we can simply distinguish objects in our new form and let them stand for their own names. Our original design for form, a set of named distinctions, now looks very promising. Therefore we implement the following message."
      },
      "after": "39e6cf09f18161fa",
      "date": 1660220685568
    },
    {
      "id": "8aec9219f1d7e5e7",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "c345c13fda0775ee"
      ],
      "date": 1660220689336
    },
    {
      "item": {
        "type": "factory",
        "id": "4e4d96d5bd4ef1ea"
      },
      "id": "4e4d96d5bd4ef1ea",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660220710478
    },
    {
      "id": "4e4d96d5bd4ef1ea",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "c345c13fda0775ee"
      ],
      "date": 1660220712341
    },
    {
      "type": "edit",
      "id": "4e4d96d5bd4ef1ea",
      "item": {
        "type": "code",
        "id": "4e4d96d5bd4ef1ea",
        "text": "Distinction>>= aDistinction ^self name = aDistinction name"
      },
      "date": 1660220714319
    },
    {
      "type": "edit",
      "id": "4e4d96d5bd4ef1ea",
      "item": {
        "type": "code",
        "id": "4e4d96d5bd4ef1ea",
        "text": "Distinction>>= aDistinction \n\n  ^self name = aDistinction name"
      },
      "date": 1660220721643
    },
    {
      "item": {
        "type": "factory",
        "id": "bcce2c555beef1a0"
      },
      "id": "bcce2c555beef1a0",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660220760866
    },
    {
      "id": "bcce2c555beef1a0",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "c345c13fda0775ee"
      ],
      "date": 1660220762983
    },
    {
      "type": "edit",
      "id": "bcce2c555beef1a0",
      "item": {
        "type": "paragraph",
        "id": "bcce2c555beef1a0",
        "text": "In this way, forms would be the equivalent of sets. Of course, if necessary, we could easily implement IdentityForm and IdentityDistinction, but we will leave those for when we actually need them."
      },
      "date": 1660220766270
    },
    {
      "type": "edit",
      "id": "bcce2c555beef1a0",
      "item": {
        "type": "paragraph",
        "id": "bcce2c555beef1a0",
        "text": "In this way, forms would be the equivalent of sets. Of course, if necessary, we could easily implement `IdentityForm` and `IdentityDistinction`, but we will leave those for when we actually need them."
      },
      "date": 1660220780980
    },
    {
      "type": "edit",
      "id": "bcce2c555beef1a0",
      "item": {
        "type": "markdown",
        "id": "bcce2c555beef1a0",
        "text": "In this way, forms would be the equivalent of sets. Of course, if necessary, we could easily implement `IdentityForm` and `IdentityDistinction`, but we will leave those for when we actually need them."
      },
      "date": 1660220782268
    },
    {
      "type": "edit",
      "id": "bcce2c555beef1a0",
      "item": {
        "type": "markdown",
        "id": "bcce2c555beef1a0",
        "text": "In this way, forms would be the equivalent of sets. Of course, if necessary, we could easily implement `IdentityForm` and `IdentityDistinction`, but we will leave those for when we actually need them.\n"
      },
      "date": 1660220799485
    },
    {
      "type": "add",
      "id": "e8f642c3eaa6e612",
      "item": {
        "type": "markdown",
        "id": "e8f642c3eaa6e612",
        "text": "So all this is great, but. . . hey, aren’t we forgetting something? Well, yes we implemented = but we did not implement hash!"
      },
      "after": "bcce2c555beef1a0",
      "date": 1660220803445
    },
    {
      "type": "edit",
      "id": "e8f642c3eaa6e612",
      "item": {
        "type": "markdown",
        "id": "e8f642c3eaa6e612",
        "text": "So all this is great, but. . . hey, aren’t we forgetting something? Well, yes we implemented = but we did not implement hash!\n"
      },
      "date": 1660220815054
    },
    {
      "type": "add",
      "id": "7ff351a4df372967",
      "item": {
        "type": "markdown",
        "id": "7ff351a4df372967",
        "text": "> Baaad programmer! Slap! Slap!"
      },
      "after": "e8f642c3eaa6e612",
      "date": 1660220816602
    },
    {
      "type": "edit",
      "id": "e8f642c3eaa6e612",
      "item": {
        "type": "markdown",
        "id": "e8f642c3eaa6e612",
        "text": "So all this is great, but. . . hey, aren’t we forgetting something? Well, yes we implemented = but we did not implement `hash`!\n"
      },
      "date": 1660220825087
    },
    {
      "item": {
        "type": "factory",
        "id": "c26a9a24be1f14b0"
      },
      "id": "c26a9a24be1f14b0",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660220834138
    },
    {
      "id": "c26a9a24be1f14b0",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "c345c13fda0775ee"
      ],
      "date": 1660220836331
    },
    {
      "type": "edit",
      "id": "c26a9a24be1f14b0",
      "item": {
        "type": "code",
        "id": "c26a9a24be1f14b0",
        "text": "Distinction>>hash \n\n  ^self name hash"
      },
      "date": 1660220842616
    },
    {
      "item": {
        "type": "factory",
        "id": "abd168857dc21540"
      },
      "id": "abd168857dc21540",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660220890304
    },
    {
      "id": "abd168857dc21540",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "abd168857dc21540",
        "c345c13fda0775ee"
      ],
      "date": 1660220892051
    },
    {
      "type": "edit",
      "id": "abd168857dc21540",
      "item": {
        "type": "paragraph",
        "id": "abd168857dc21540",
        "text": "We should not forget to implement hash when we refine =, as failure to do so  can lead to issues that are quite hard to debug.\n\n"
      },
      "date": 1660220896012
    },
    {
      "type": "add",
      "id": "6171a0c966e74988",
      "item": {
        "type": "paragraph",
        "id": "6171a0c966e74988",
        "text": "> Baaad doggie! Don’t chew on the power co@Σ?# +$∼!&Γ:* — NO TERRIER"
      },
      "after": "abd168857dc21540",
      "date": 1660220896873
    },
    {
      "type": "edit",
      "id": "6171a0c966e74988",
      "item": {
        "type": "markdown",
        "id": "6171a0c966e74988",
        "text": "> Baaad doggie! Don’t chew on the power co@Σ?# +$∼!&Γ:* — NO TERRIER"
      },
      "date": 1660220898365
    },
    {
      "type": "edit",
      "id": "abd168857dc21540",
      "item": {
        "type": "paragraph",
        "id": "abd168857dc21540",
        "text": "We should not forget to implement `hash` when we refine `=`, as failure to do so  can lead to issues that are quite hard to debug.\n\n"
      },
      "date": 1660220919459
    },
    {
      "type": "edit",
      "id": "abd168857dc21540",
      "item": {
        "type": "markdown",
        "id": "abd168857dc21540",
        "text": "We should not forget to implement `hash` when we refine `=`, as failure to do so  can lead to issues that are quite hard to debug.\n\n"
      },
      "date": 1660220921056
    },
    {
      "item": {
        "type": "factory",
        "id": "d406f6db9c466f67"
      },
      "id": "d406f6db9c466f67",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660220939860
    },
    {
      "type": "edit",
      "id": "d406f6db9c466f67",
      "item": {
        "type": "paragraph",
        "id": "d406f6db9c466f67",
        "text": "Back to forms and distinctions now. At last, we can start implementing the messages that will allow us to give shape to our silly putty. Since we cannot do much with empty forms, let’s start with the message below."
      },
      "date": 1660220942397
    },
    {
      "id": "c345c13fda0775ee",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "abd168857dc21540",
        "6171a0c966e74988",
        "d406f6db9c466f67",
        "c345c13fda0775ee"
      ],
      "date": 1660220944057
    },
    {
      "type": "add",
      "id": "160d59108c2d3612",
      "item": {
        "type": "paragraph",
        "id": "160d59108c2d3612",
        "text": "> In case you are wondering, the DOS character set includes (among others) the greek letters shown above. In particular, the index of Σ is 228, and that of Γ is 226."
      },
      "after": "d406f6db9c466f67",
      "date": 1660220961820
    },
    {
      "type": "edit",
      "id": "160d59108c2d3612",
      "item": {
        "type": "markdown",
        "id": "160d59108c2d3612",
        "text": "> In case you are wondering, the DOS character set includes (among others) the greek letters shown above. In particular, the index of Σ is 228, and that of Γ is 226."
      },
      "date": 1660220963123
    },
    {
      "item": {
        "type": "factory",
        "id": "9906b3b47a2cf8e2"
      },
      "id": "9906b3b47a2cf8e2",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660220973006
    },
    {
      "id": "9906b3b47a2cf8e2",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "abd168857dc21540",
        "6171a0c966e74988",
        "d406f6db9c466f67",
        "160d59108c2d3612",
        "9906b3b47a2cf8e2",
        "c345c13fda0775ee"
      ],
      "date": 1660220974602
    },
    {
      "type": "edit",
      "id": "9906b3b47a2cf8e2",
      "item": {
        "type": "code",
        "id": "9906b3b47a2cf8e2",
        "text": "Form>>distinguish: aName \n\n  ^(self distinctionNamed: aName) ifNil: \n    [ \n      | distinction | \n      distinction := Dictinction named: aName.\n      distinction form: self. self distinctions add: \n      distinction. \n      distinction \n    ]"
      },
      "date": 1660221028763
    },
    {
      "type": "edit",
      "id": "9906b3b47a2cf8e2",
      "item": {
        "type": "code",
        "id": "9906b3b47a2cf8e2",
        "text": "Form>>distinguish: aName \n\n  ^(self distinctionNamed: aName) ifNil: \n    [ \n      | distinction | \n      distinction := Dictinction named: aName.\n      distinction form: self. \n      self distinctions add: distinction. \n      distinction \n    ]"
      },
      "date": 1660221045717
    },
    {
      "item": {
        "type": "factory",
        "id": "dd10014457b83ca1"
      },
      "id": "dd10014457b83ca1",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660221079393
    },
    {
      "id": "dd10014457b83ca1",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "abd168857dc21540",
        "6171a0c966e74988",
        "d406f6db9c466f67",
        "160d59108c2d3612",
        "9906b3b47a2cf8e2",
        "dd10014457b83ca1",
        "c345c13fda0775ee"
      ],
      "date": 1660221081432
    },
    {
      "type": "edit",
      "id": "dd10014457b83ca1",
      "item": {
        "type": "paragraph",
        "id": "dd10014457b83ca1",
        "text": "We can enforce the only one distinction per name restriction because the first axiom of Laws of Form says that invoking the same name twice is the same as invoking it once. In other words, we are not altering the meaning of the form structure by doing so. To that effect, pay close attention at how ifNil: is not being used as a control mechanism, but rather as a means of replacement. Indeed, ifNil: should be read as meaning butIfNil: instead."
      },
      "date": 1660221084156
    },
    {
      "type": "edit",
      "id": "dd10014457b83ca1",
      "item": {
        "type": "paragraph",
        "id": "dd10014457b83ca1",
        "text": "We can enforce the *only one distinction per name* restriction because the first axiom of [[Laws of Form]] says that invoking the same name twice is the same as invoking it once. In other words, we are not altering the meaning of the form structure by doing so. To that effect, pay close attention at how `ifNil:` is not being used as a control mechanism, but rather as a means of replacement. Indeed, ifNil: should be read as meaning butIfNil: instead."
      },
      "date": 1660221129407
    },
    {
      "type": "edit",
      "id": "dd10014457b83ca1",
      "item": {
        "type": "markdown",
        "id": "dd10014457b83ca1",
        "text": "We can enforce the *only one distinction per name* restriction because the first axiom of [[Laws of Form]] says that invoking the same name twice is the same as invoking it once. In other words, we are not altering the meaning of the form structure by doing so. To that effect, pay close attention at how `ifNil:` is not being used as a control mechanism, but rather as a means of replacement. Indeed, ifNil: should be read as meaning butIfNil: instead."
      },
      "date": 1660221130809
    },
    {
      "type": "edit",
      "id": "dd10014457b83ca1",
      "item": {
        "type": "markdown",
        "id": "dd10014457b83ca1",
        "text": "We can enforce the *only one distinction per name* restriction because the first axiom of [[Laws of Form]] says that invoking the same name twice is the same as invoking it once. In other words, we are not altering the meaning of the form structure by doing so. To that effect, pay close attention at how `ifNil:` is not being used as a control mechanism, but rather as a means of replacement. Indeed, `ifNil:` should be read as meaning `butIfNil:` instead."
      },
      "date": 1660221156163
    },
    {
      "type": "edit",
      "id": "dd10014457b83ca1",
      "item": {
        "type": "markdown",
        "id": "dd10014457b83ca1",
        "text": "We can enforce the *only one distinction per name* restriction because the first axiom of [[Laws of Form]] says that invoking the same name twice is the same as invoking it once. In other words, we are not altering the meaning of the form structure by doing so. To that effect, pay close attention at how `ifNil:` is not being used as a control mechanism, but rather as a means of replacement. Indeed, `ifNil:` should be read as meaning `butIfNil:` instead.\n"
      },
      "date": 1660221172993
    },
    {
      "type": "add",
      "id": "8acdad5a8e6d37d6",
      "item": {
        "type": "markdown",
        "id": "8acdad5a8e6d37d6",
        "text": "So how is `distinctionNamed:` implemented?"
      },
      "after": "dd10014457b83ca1",
      "date": 1660221181854
    },
    {
      "item": {
        "type": "factory",
        "id": "6abae7a7b4e088ea"
      },
      "id": "6abae7a7b4e088ea",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660221192814
    },
    {
      "id": "6abae7a7b4e088ea",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "abd168857dc21540",
        "6171a0c966e74988",
        "d406f6db9c466f67",
        "160d59108c2d3612",
        "9906b3b47a2cf8e2",
        "dd10014457b83ca1",
        "8acdad5a8e6d37d6",
        "6abae7a7b4e088ea",
        "c345c13fda0775ee"
      ],
      "date": 1660221194414
    },
    {
      "type": "edit",
      "id": "6abae7a7b4e088ea",
      "item": {
        "type": "code",
        "id": "6abae7a7b4e088ea",
        "text": "Form>>distinctionNamed: aName \n\n  ^self distinctions \n    detect: [:any | any name = aName] \n    ifNone: [nil]"
      },
      "date": 1660221217251
    },
    {
      "item": {
        "type": "factory",
        "id": "9268864a4c1a5af1"
      },
      "id": "9268864a4c1a5af1",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660221237296
    },
    {
      "id": "9268864a4c1a5af1",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "abd168857dc21540",
        "6171a0c966e74988",
        "d406f6db9c466f67",
        "160d59108c2d3612",
        "9906b3b47a2cf8e2",
        "dd10014457b83ca1",
        "8acdad5a8e6d37d6",
        "6abae7a7b4e088ea",
        "9268864a4c1a5af1",
        "c345c13fda0775ee"
      ],
      "date": 1660221238859
    },
    {
      "type": "edit",
      "id": "9268864a4c1a5af1",
      "item": {
        "type": "paragraph",
        "id": "9268864a4c1a5af1",
        "text": "You may be tempted to use a dictionary here, but keep that temptation at bay for now — the exercises have the details."
      },
      "date": 1660221242091
    },
    {
      "type": "add",
      "id": "630cbb042143003a",
      "item": {
        "type": "paragraph",
        "id": "630cbb042143003a",
        "text": "Once we have these messages, we should be able to cross into another form via a distinction. To do that, we simply implement the following message."
      },
      "after": "9268864a4c1a5af1",
      "date": 1660221257345
    },
    {
      "item": {
        "type": "factory",
        "id": "1379a77958b6ccb9"
      },
      "id": "1379a77958b6ccb9",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660221266991
    },
    {
      "id": "1379a77958b6ccb9",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "abd168857dc21540",
        "6171a0c966e74988",
        "d406f6db9c466f67",
        "160d59108c2d3612",
        "9906b3b47a2cf8e2",
        "dd10014457b83ca1",
        "8acdad5a8e6d37d6",
        "6abae7a7b4e088ea",
        "9268864a4c1a5af1",
        "630cbb042143003a",
        "1379a77958b6ccb9",
        "c345c13fda0775ee"
      ],
      "date": 1660221269448
    },
    {
      "type": "edit",
      "id": "1379a77958b6ccb9",
      "item": {
        "type": "code",
        "id": "1379a77958b6ccb9",
        "text": "Form>>cross: aName \n\n  ^(self distinguish: aName) cross"
      },
      "date": 1660221276960
    },
    {
      "item": {
        "type": "factory",
        "id": "68c952d43685e168"
      },
      "id": "68c952d43685e168",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660221286137
    },
    {
      "id": "68c952d43685e168",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "abd168857dc21540",
        "6171a0c966e74988",
        "d406f6db9c466f67",
        "160d59108c2d3612",
        "9906b3b47a2cf8e2",
        "dd10014457b83ca1",
        "8acdad5a8e6d37d6",
        "6abae7a7b4e088ea",
        "9268864a4c1a5af1",
        "630cbb042143003a",
        "1379a77958b6ccb9",
        "68c952d43685e168",
        "c345c13fda0775ee"
      ],
      "date": 1660221288048
    },
    {
      "type": "edit",
      "id": "68c952d43685e168",
      "item": {
        "type": "paragraph",
        "id": "68c952d43685e168",
        "text": "Note how this can create a distinction the first time, and reuse it thereafter. This is consistent with the Laws of Form axiom that says that using a name twice is the same as using it once. Also, note how the distinction answers its contents form when answering the message cross. This emphasizes how important proper names can be."
      },
      "date": 1660221289626
    },
    {
      "type": "add",
      "id": "1746e2a6e100256d",
      "item": {
        "type": "paragraph",
        "id": "1746e2a6e100256d",
        "text": "Finally, there should be a way to undistinguish something. And what would a good selector for that be? Certainly, undistinguish: seems a bit coarse. The selector `forget:` is also misleading. We need to undo a distinction, and that is not the same as forgetting it"
      },
      "after": "68c952d43685e168",
      "date": 1660221316365
    },
    {
      "type": "edit",
      "id": "1746e2a6e100256d",
      "item": {
        "type": "paragraph",
        "id": "1746e2a6e100256d",
        "text": "Finally, there should be a way to undistinguish something. And what would a good selector for that be? Certainly, `undistinguish:` seems a bit coarse. The selector `forget:` is also misleading. We need to undo a distinction, and that is not the same as forgetting it"
      },
      "date": 1660221349724
    },
    {
      "type": "edit",
      "id": "1746e2a6e100256d",
      "item": {
        "type": "markdown",
        "id": "1746e2a6e100256d",
        "text": "Finally, there should be a way to undistinguish something. And what would a good selector for that be? Certainly, `undistinguish:` seems a bit coarse. The selector `forget:` is also misleading. We need to undo a distinction, and that is not the same as forgetting it"
      },
      "date": 1660221350920
    },
    {
      "item": {
        "type": "factory",
        "id": "b21f34a6d580a3a9"
      },
      "id": "b21f34a6d580a3a9",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660221369013
    },
    {
      "id": "b21f34a6d580a3a9",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "abd168857dc21540",
        "6171a0c966e74988",
        "d406f6db9c466f67",
        "160d59108c2d3612",
        "9906b3b47a2cf8e2",
        "dd10014457b83ca1",
        "8acdad5a8e6d37d6",
        "6abae7a7b4e088ea",
        "9268864a4c1a5af1",
        "630cbb042143003a",
        "1379a77958b6ccb9",
        "68c952d43685e168",
        "1746e2a6e100256d",
        "b21f34a6d580a3a9",
        "c345c13fda0775ee"
      ],
      "date": 1660221370929
    },
    {
      "type": "edit",
      "id": "1746e2a6e100256d",
      "item": {
        "type": "markdown",
        "id": "1746e2a6e100256d",
        "text": "Finally, there should be a way to undistinguish something. And what would a good selector for that be? Certainly, `undistinguish:` seems a bit coarse. The selector `forget:` is also misleading. We need to undo a distinction, and that is not the same as forgetting it."
      },
      "date": 1660221371610
    },
    {
      "type": "edit",
      "id": "b21f34a6d580a3a9",
      "item": {
        "type": "paragraph",
        "id": "b21f34a6d580a3a9",
        "text": "Perhaps we could find a selector by looking at the state of things before the distinction occurred. Before the distinction was drawn, there were no differences in value."
      },
      "date": 1660221372336
    },
    {
      "type": "add",
      "id": "1c2ba9980489664e",
      "item": {
        "type": "paragraph",
        "id": "1c2ba9980489664e",
        "text": "Hmmm… perhaps we are getting somewhere. Let’s continue finding alternate ways to say the same thing."
      },
      "after": "b21f34a6d580a3a9",
      "date": 1660221397162
    },
    {
      "type": "add",
      "id": "f2e6a0edf831f1ab",
      "item": {
        "type": "paragraph",
        "id": "f2e6a0edf831f1ab",
        "text": "Both sides of the distinction had the same value to us. We could use them interchangeably. They were equivalent to us. We did not need to care about their"
      },
      "after": "1c2ba9980489664e",
      "date": 1660221409868
    },
    {
      "type": "edit",
      "id": "f2e6a0edf831f1ab",
      "item": {
        "type": "paragraph",
        "id": "f2e6a0edf831f1ab",
        "text": "Both sides of the distinction had the same value to us. We could use them interchangeably. They were equivalent to us. We did not need to care about their differences."
      },
      "date": 1660221416020
    },
    {
      "type": "add",
      "id": "8b9a2e32b242e215",
      "item": {
        "type": "paragraph",
        "id": "8b9a2e32b242e215",
        "text": "Well, all of these are positive assertions and we do not seem to be making much headway. How about some negative ones?"
      },
      "after": "f2e6a0edf831f1ab",
      "date": 1660221446907
    },
    {
      "type": "add",
      "id": "a69ac29532a46798",
      "item": {
        "type": "paragraph",
        "id": "a69ac29532a46798",
        "text": "> The technique is almost automatic, to the point of seeming to have very little merit. However, it relies heavily on how evolution has worked for so much time. If something does not quite work, find a peculiar characteristic of it and apply some change. In other words, purposefully introduce mutations in how the traversal of the space is done, and evaluate the outcome. Do the random walk."
      },
      "after": "8b9a2e32b242e215",
      "date": 1660221463231
    },
    {
      "type": "edit",
      "id": "a69ac29532a46798",
      "item": {
        "type": "markdown",
        "id": "a69ac29532a46798",
        "text": "> The technique is almost automatic, to the point of seeming to have very little merit. However, it relies heavily on how evolution has worked for so much time. If something does not quite work, find a peculiar characteristic of it and apply some change. In other words, purposefully introduce mutations in how the traversal of the space is done, and evaluate the outcome. Do the random walk."
      },
      "date": 1660221464465
    },
    {
      "item": {
        "type": "factory",
        "id": "ba9cce0c2a951300"
      },
      "id": "ba9cce0c2a951300",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660221489622
    },
    {
      "id": "ba9cce0c2a951300",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "abd168857dc21540",
        "6171a0c966e74988",
        "d406f6db9c466f67",
        "160d59108c2d3612",
        "9906b3b47a2cf8e2",
        "dd10014457b83ca1",
        "8acdad5a8e6d37d6",
        "6abae7a7b4e088ea",
        "9268864a4c1a5af1",
        "630cbb042143003a",
        "1379a77958b6ccb9",
        "68c952d43685e168",
        "1746e2a6e100256d",
        "b21f34a6d580a3a9",
        "1c2ba9980489664e",
        "f2e6a0edf831f1ab",
        "8b9a2e32b242e215",
        "a69ac29532a46798",
        "ba9cce0c2a951300",
        "c345c13fda0775ee"
      ],
      "date": 1660221491740
    },
    {
      "type": "edit",
      "id": "ba9cce0c2a951300",
      "item": {
        "type": "paragraph",
        "id": "ba9cce0c2a951300",
        "text": "We were looking at things with a coarser resolution. Both sides fell in the same bucket. We would not care if we picked one or the other. We would confuse one for the other."
      },
      "date": 1660221494682
    },
    {
      "type": "add",
      "id": "c07130a59b31b807",
      "item": {
        "type": "paragraph",
        "id": "c07130a59b31b807",
        "text": "Hold it right there! That is it!"
      },
      "after": "ba9cce0c2a951300",
      "date": 1660221505763
    },
    {
      "item": {
        "type": "factory",
        "id": "9f00cfe8bbb12aa6"
      },
      "id": "9f00cfe8bbb12aa6",
      "type": "add",
      "after": "c345c13fda0775ee",
      "date": 1660221512524
    },
    {
      "id": "9f00cfe8bbb12aa6",
      "type": "move",
      "order": [
        "a4633f4334b4f317",
        "f45399b823e311a2",
        "e943e95099f3f569",
        "a9c1faa81d9c29c1",
        "9388bc7c4affb9f5",
        "e8b4751526ee76f8",
        "5f3d07743d0086b2",
        "62404b3aedd42e54",
        "80c06d4589616723",
        "852503c576ea5098",
        "8de3ab54dbdb1376",
        "af76dcb5d51ce2ee",
        "eb5656c393c4ceab",
        "4421638953826a1a",
        "0b441bb2b23a7eb9",
        "2c63a39f2bba9921",
        "23c9a597ce03ef76",
        "d130a3e2c7577c91",
        "39e6cf09f18161fa",
        "ccc097e473c74a0a",
        "8aec9219f1d7e5e7",
        "4e4d96d5bd4ef1ea",
        "bcce2c555beef1a0",
        "e8f642c3eaa6e612",
        "7ff351a4df372967",
        "c26a9a24be1f14b0",
        "abd168857dc21540",
        "6171a0c966e74988",
        "d406f6db9c466f67",
        "160d59108c2d3612",
        "9906b3b47a2cf8e2",
        "dd10014457b83ca1",
        "8acdad5a8e6d37d6",
        "6abae7a7b4e088ea",
        "9268864a4c1a5af1",
        "630cbb042143003a",
        "1379a77958b6ccb9",
        "68c952d43685e168",
        "1746e2a6e100256d",
        "b21f34a6d580a3a9",
        "1c2ba9980489664e",
        "f2e6a0edf831f1ab",
        "8b9a2e32b242e215",
        "a69ac29532a46798",
        "ba9cce0c2a951300",
        "c07130a59b31b807",
        "9f00cfe8bbb12aa6",
        "c345c13fda0775ee"
      ],
      "date": 1660221515026
    },
    {
      "type": "edit",
      "id": "9f00cfe8bbb12aa6",
      "item": {
        "type": "code",
        "id": "9f00cfe8bbb12aa6",
        "text": "Form>>confuse: aName \n\n  | existingDistinction | \n  existingDistinction := self distinctionNamed: aName. \n  existingDistinction isNil ifTrue: [^self]. \n  self distinctions remove: existingDistinction"
      },
      "date": 1660221540586
    },
    {
      "type": "edit",
      "id": "c345c13fda0775ee",
      "item": {
        "type": "paragraph",
        "id": "c345c13fda0775ee",
        "text": "Now that we have our basic [[Laws of Form]] objects in place, let’s see how this relates to distinctions existing in the Smalltalk form — I mean image."
      },
      "date": 1660221572448
    },
    {
      "type": "add",
      "id": "b607183e13ebf347",
      "item": {
        "type": "paragraph",
        "id": "b607183e13ebf347",
        "text": "– [[Smalltalk Objects]]"
      },
      "after": "c345c13fda0775ee",
      "date": 1660221590854
    },
    {
      "type": "edit",
      "id": "b607183e13ebf347",
      "item": {
        "type": "paragraph",
        "id": "b607183e13ebf347",
        "text": "⇒ [[Smalltalk Objects]]"
      },
      "date": 1660221612880
    },
    {
      "item": {
        "type": "factory",
        "id": "fd8133c008489491"
      },
      "id": "fd8133c008489491",
      "type": "add",
      "after": "b607183e13ebf347",
      "date": 1660221620189
    },
    {
      "type": "edit",
      "id": "fd8133c008489491",
      "item": {
        "type": "pagefold",
        "id": "fd8133c008489491",
        "text": "~"
      },
      "date": 1660221623094
    },
    {
      "item": {
        "type": "factory",
        "id": "95e4e1e46cc008c8"
      },
      "id": "95e4e1e46cc008c8",
      "type": "add",
      "after": "fd8133c008489491",
      "date": 1660221624646
    },
    {
      "type": "edit",
      "id": "95e4e1e46cc008c8",
      "item": {
        "type": "paragraph",
        "id": "95e4e1e46cc008c8",
        "text": "Section 5.3.1 of"
      },
      "date": 1660221632154
    },
    {
      "type": "edit",
      "id": "95e4e1e46cc008c8",
      "item": {
        "type": "paragraph",
        "id": "95e4e1e46cc008c8",
        "text": "Section 5.3.1 of [[A Mentoring Course on Smalltalk]]"
      },
      "date": 1660221637089
    },
    {
      "type": "edit",
      "id": "95e4e1e46cc008c8",
      "item": {
        "type": "paragraph",
        "id": "95e4e1e46cc008c8",
        "text": "Section 5.3.1 of [[A Mentoring Course on Smalltalk]], An Efficient Reference Finder"
      },
      "date": 1660221657126
    },
    {
      "type": "edit",
      "id": "95e4e1e46cc008c8",
      "item": {
        "type": "paragraph",
        "id": "95e4e1e46cc008c8",
        "text": "Section 5.3.1 of [[A Mentoring Course on Smalltalk]], [[An Efficient Reference Finder]]"
      },
      "date": 1660221664566
    },
    {
      "type": "edit",
      "id": "dd10014457b83ca1",
      "item": {
        "type": "markdown",
        "id": "dd10014457b83ca1",
        "text": "We can enforce the *only one distinction per name* restriction because the first axiom of *[[Laws of Form]]* says that invoking the same name twice is the same as invoking it once. In other words, we are not altering the meaning of the form structure by doing so. To that effect, pay close attention at how `ifNil:` is not being used as a control mechanism, but rather as a means of replacement. Indeed, `ifNil:` should be read as meaning `butIfNil:` instead.\n"
      },
      "date": 1660221827080
    },
    {
      "type": "edit",
      "id": "68c952d43685e168",
      "item": {
        "type": "paragraph",
        "id": "68c952d43685e168",
        "text": "Note how this can create a distinction the first time, and reuse it thereafter. This is consistent with the *Laws of Form* axiom that says that using a name twice is the same as using it once. Also, note how the distinction answers its contents form when answering the message cross. This emphasizes how important proper names can be."
      },
      "date": 1660221832415
    },
    {
      "type": "edit",
      "id": "68c952d43685e168",
      "item": {
        "type": "markdown",
        "id": "68c952d43685e168",
        "text": "Note how this can create a distinction the first time, and reuse it thereafter. This is consistent with the *Laws of Form* axiom that says that using a name twice is the same as using it once. Also, note how the distinction answers its contents form when answering the message cross. This emphasizes how important proper names can be."
      },
      "date": 1660221834411
    },
    {
      "type": "edit",
      "id": "c345c13fda0775ee",
      "item": {
        "type": "paragraph",
        "id": "c345c13fda0775ee",
        "text": "Now that we have our basic *[[Laws of Form]]* objects in place, let’s see how this relates to distinctions existing in the Smalltalk form — I mean image."
      },
      "date": 1660221906020
    },
    {
      "type": "edit",
      "id": "c345c13fda0775ee",
      "item": {
        "type": "markdown",
        "id": "c345c13fda0775ee",
        "text": "Now that we have our basic *[[Laws of Form]]* objects in place, let’s see how this relates to distinctions existing in the Smalltalk form — I mean image."
      },
      "date": 1660221908031
    },
    {
      "type": "edit",
      "id": "80c06d4589616723",
      "item": {
        "type": "markdown",
        "id": "80c06d4589616723",
        "text": "In these situations, it is good to review the language that is used to talk about distinctions. Let’s see… “distinctions separate a space into two disjoint pieces”, “distinctions are the boundaries between such pieces”, “distinction is perfect continence”. It seems like there is a theme of enclosure, or even containment. The selector `contents` suggests itself. However, it is not clear that it is a good choice. This is because the contents of a distinction can only be accessed by crossing the distinction. As such, `contents` is intention obscuring because it seems to indicate it is fine to know about the contents of a distinction without crossing it — `contents` does not have strong encapsulation connotations. But not all is lost since we did mention the act of crossing distinctions. Thus, we will choose the verb instead of the noun, and send the message `[[cross]]` instead. If we let it be an accessor, then we will have an intention revealing instance name too."
      },
      "date": 1660800170146
    }
  ]
}