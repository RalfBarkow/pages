{
  "title": "Digital Searching",
  "story": [
    {
      "type": "paragraph",
      "id": "24ee38415f55fa04",
      "text": "Instead of basing a search method on comparisons between keys, we can make use of their representation as a [[Sequence]] of digits or alphabetic characters."
    },
    {
      "type": "paragraph",
      "id": "92f8c57591b75b76",
      "text": "Consider, for example, the thumb index on a large dictionary; from the first letter of a given word, we can immediately locate the pages that contain all words beginning with that letter."
    },
    {
      "type": "paragraph",
      "id": "2bcd8934fb2ae225",
      "text": "If we pursue the thumb-index idea to one of its logical conclusions, we come up with a searching scheme based on repeated “subscripting” as illustrated in Table 1."
    },
    {
      "type": "image",
      "id": "6a6cb29e348f81de",
      "text": "Table 1. A TRIE FOR THE 31 MOST COMMON ENGLISH WORDS",
      "size": "wide",
      "width": 419,
      "height": 427,
      "url": "/assets/plugins/image/9deb72bb64ba1a02d04b6e562ce55f71.jpg"
    },
    {
      "type": "paragraph",
      "id": "d0f43daa48d3c597",
      "text": "Suppose that we want to test a given search argument to see whether it is one of the 31 most common words of English (see Figs. 12 and 13 in Section 6.2.2). The data is represented in Table 1 as a trie structure; this name was suggested by E. Fredkin [CACM 3 (1960), 490–500] because it is a part of information retrieval."
    },
    {
      "type": "paragraph",
      "id": "2eb3abb7cd0badbf",
      "text": "A [[Trie]] — pronounced “try” — is essentially an M-ary tree, whose nodes are M-place vectors with components corresponding to digits or characters. Each node on level l represents the set of all keys that begin with a certain sequence of l characters called its prefix; the node specifies an M-way branch, depending on the (l + 1)st character."
    },
    {
      "type": "paragraph",
      "id": "c5bafe40084153b4",
      "text": "For example, the trie of Table 1 has 12 nodes; node (1) is the root, and we look up the first letter here. If the first letter is, say, N, the table tells us that our word must be NOT (or else it isn’t in the table). On the other hand, if the first letter is W, node (1) tells us to go on to node (9), looking up the second letter in the same way; node (9) says that the second letter should be A, H, or I. The prefix of node (10) is HA. Blank entries in the table stand for null links."
    },
    {
      "type": "paragraph",
      "id": "4bf682530355993f",
      "text": "The node vectors in Table 1 are arranged according to MIX character code. This means that a trie search will be quite fast, since we are merely fetching words of an array by using the characters of our keys as subscripts. Techniques for making quick multiway decisions by subscripting have been called “[[table look-at]]” as opposed to “[[table look-up]]” [see P. M. Sherman, CACM 4 (1961), 172–173, 175]."
    },
    {
      "type": "paragraph",
      "id": "b3c61da75b572bf9",
      "text": "[…] The nodes of the [[Trie]] are vectors whose subscripts run from 0 to M − 1; each component of these vectors is either a key or a link (possibly null)."
    },
    {
      "type": "pagefold",
      "id": "3cebad850d80f616",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "59e308544ee5bdc9",
      "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. v. 3. Sorting and Searching. 2nd ed. Reading, Mass: Addison-Wesley. ISBN 0-201-89685-0, p. 492–493.\n"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Digital Searching",
        "story": []
      },
      "date": 1694253051647
    },
    {
      "item": {
        "type": "factory",
        "id": "24ee38415f55fa04"
      },
      "id": "24ee38415f55fa04",
      "type": "add",
      "date": 1694253060137
    },
    {
      "type": "edit",
      "id": "24ee38415f55fa04",
      "item": {
        "type": "paragraph",
        "id": "24ee38415f55fa04",
        "text": "Instead of Basing a search method on comparisons between keys, we can make use of their representation as a sequence of digits or alphabetic characters. Consider, for example, the thumb index on a large dictionary; from the first letter of a given word, we can immediately locate the pages that contain all words beginning with that letter."
      },
      "date": 1694253062319
    },
    {
      "type": "edit",
      "id": "24ee38415f55fa04",
      "item": {
        "type": "paragraph",
        "id": "24ee38415f55fa04",
        "text": "Instead of basing a search method on comparisons between keys, we can make use of their representation as a sequence of digits or alphabetic characters. Consider, for example, the thumb index on a large dictionary; from the first letter of a given word, we can immediately locate the pages that contain all words beginning with that letter."
      },
      "date": 1694253089606
    },
    {
      "type": "edit",
      "id": "24ee38415f55fa04",
      "item": {
        "type": "paragraph",
        "id": "24ee38415f55fa04",
        "text": "Instead of basing a search method on comparisons between keys, we can make use of their representation as a [[Sequence]] of digits or alphabetic characters. Consider, for example, the thumb index on a large dictionary; from the first letter of a given word, we can immediately locate the pages that contain all words beginning with that letter."
      },
      "date": 1694253105524
    },
    {
      "item": {
        "type": "factory",
        "id": "3cebad850d80f616"
      },
      "id": "3cebad850d80f616",
      "type": "add",
      "after": "24ee38415f55fa04",
      "date": 1694253124234
    },
    {
      "type": "edit",
      "id": "3cebad850d80f616",
      "item": {
        "type": "pagefold",
        "id": "3cebad850d80f616",
        "text": "~"
      },
      "date": 1694253127109
    },
    {
      "item": {
        "type": "factory",
        "id": "59e308544ee5bdc9"
      },
      "id": "59e308544ee5bdc9",
      "type": "add",
      "after": "3cebad850d80f616",
      "date": 1694253128644
    },
    {
      "type": "edit",
      "id": "59e308544ee5bdc9",
      "item": {
        "type": "paragraph",
        "id": "59e308544ee5bdc9",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. 3rd ed. Reading, Mass: Addison-Wesley. ISBN 978-0-201-89683-1, p. 492\n"
      },
      "date": 1694253148860
    },
    {
      "type": "edit",
      "id": "59e308544ee5bdc9",
      "item": {
        "type": "paragraph",
        "id": "59e308544ee5bdc9",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. 3rd ed. Reading, Mass: Addison-Wesley. ISBN 0-201-89683-0, p. 492\n"
      },
      "date": 1694253196606
    },
    {
      "type": "edit",
      "id": "59e308544ee5bdc9",
      "item": {
        "type": "paragraph",
        "id": "59e308544ee5bdc9",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. 3rd ed. Reading, Mass: Addison-Wesley. ISBN 0-201-89685-0, p. 492\n"
      },
      "date": 1694253241191
    },
    {
      "type": "edit",
      "id": "59e308544ee5bdc9",
      "item": {
        "type": "paragraph",
        "id": "59e308544ee5bdc9",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. Volume 3. 3rd ed. Reading, Mass: Addison-Wesley. ISBN 0-201-89685-0, p. 492\n"
      },
      "date": 1694691040485
    },
    {
      "type": "edit",
      "id": "24ee38415f55fa04",
      "item": {
        "type": "paragraph",
        "id": "24ee38415f55fa04",
        "text": "Instead of basing a search method on comparisons between keys, we can make use of their representation as a [[Sequence]] of digits or alphabetic characters."
      },
      "date": 1694691079101
    },
    {
      "type": "add",
      "id": "92f8c57591b75b76",
      "item": {
        "type": "paragraph",
        "id": "92f8c57591b75b76",
        "text": "Consider, for example, the thumb index on a large dictionary; from the first letter of a given word, we can immediately locate the pages that contain all words beginning with that letter."
      },
      "after": "24ee38415f55fa04",
      "date": 1694691079600
    },
    {
      "type": "add",
      "id": "2bcd8934fb2ae225",
      "item": {
        "type": "paragraph",
        "id": "2bcd8934fb2ae225",
        "text": "If we pursue the thumb-index idea to one of its logical conclusions, we come up with a searching scheme based on repeated “subscripting” as illustrated in Table 1."
      },
      "after": "92f8c57591b75b76",
      "date": 1694691674544
    },
    {
      "id": "6a6cb29e348f81de",
      "type": "add",
      "item": {
        "type": "image",
        "id": "6a6cb29e348f81de",
        "text": "A TRIE FOR THE 31 MOST COMMON ENGLISH WORDS",
        "size": "wide",
        "width": 419,
        "height": 427,
        "url": "/assets/plugins/image/9deb72bb64ba1a02d04b6e562ce55f71.jpg"
      },
      "after": "2bcd8934fb2ae225",
      "attribution": {
        "page": "Trie"
      },
      "date": 1694691684166
    },
    {
      "type": "add",
      "id": "d0f43daa48d3c597",
      "item": {
        "type": "paragraph",
        "id": "d0f43daa48d3c597",
        "text": "Suppose that we want to test a given search argument to see whether it is one of the"
      },
      "after": "2bcd8934fb2ae225",
      "date": 1694691733384
    },
    {
      "id": "d0f43daa48d3c597",
      "type": "move",
      "order": [
        "24ee38415f55fa04",
        "92f8c57591b75b76",
        "2bcd8934fb2ae225",
        "6a6cb29e348f81de",
        "d0f43daa48d3c597",
        "3cebad850d80f616",
        "59e308544ee5bdc9"
      ],
      "date": 1694691735801
    },
    {
      "type": "edit",
      "id": "d0f43daa48d3c597",
      "item": {
        "type": "paragraph",
        "id": "d0f43daa48d3c597",
        "text": "Suppose that we want to test a given search argument to see whether it is one of the 31 most common words of English (see Figs. 12 and 13 in Section 6.2.2). The data is represented in Table 1 as a trie structure; this name was suggested by E. Fredkin [CACM 3 (1960), 490–499] because it is a part of information retrieval. A trie — pronounced “try” — is essentially an M-ary tree, whose nodes are M-place vectors with components corresponding to digits or characters. Each node on level l represents the set of all keys that begin with a certain sequence of l characters called its prefix; the node specifies an Mway branch, depending on the (l + 1)st character."
      },
      "date": 1694691755513
    },
    {
      "type": "edit",
      "id": "d0f43daa48d3c597",
      "item": {
        "type": "paragraph",
        "id": "d0f43daa48d3c597",
        "text": "Suppose that we want to test a given search argument to see whether it is one of the 31 most common words of English (see Figs. 12 and 13 in Section 6.2.2). The data is represented in Table 1 as a trie structure; this name was suggested by E. Fredkin [CACM 3 (1960), 490–500] because it is a part of information retrieval. A trie — pronounced “try” — is essentially an M-ary tree, whose nodes are M-place vectors with components corresponding to digits or characters. Each node on level l represents the set of all keys that begin with a certain sequence of l characters called its prefix; the node specifies an Mway branch, depending on the (l + 1)st character."
      },
      "date": 1694691796794
    },
    {
      "type": "edit",
      "id": "d0f43daa48d3c597",
      "item": {
        "type": "paragraph",
        "id": "d0f43daa48d3c597",
        "text": "Suppose that we want to test a given search argument to see whether it is one of the 31 most common words of English (see Figs. 12 and 13 in Section 6.2.2). The data is represented in Table 1 as a trie structure; this name was suggested by E. Fredkin [CACM 3 (1960), 490–500] because it is a part of information retrieval. A trie — pronounced “try” — is essentially an M-ary tree, whose nodes are M-place vectors with components corresponding to digits or characters. Each node on level l represents the set of all keys that begin with a certain sequence of l characters called its prefix; the node specifies an M-way branch, depending on the (l + 1)st character."
      },
      "date": 1694691855078
    },
    {
      "type": "add",
      "id": "c5bafe40084153b4",
      "item": {
        "type": "paragraph",
        "id": "c5bafe40084153b4",
        "text": "For example, the trie of Table 1 has 12 nodes; node (1) is the root, and we look up the first letter here. If the first letter is, say, N, the table tells us that our word must be NOT (or else it isn’t in the table). On the other hand, if the first letter is W, node (1) tells us to go on to node (9), looking up the second letter in the same way; node (9) says that the second letter should be A, H, or I. The prefix of node (10) is HA. Blank entries in the table stand for null links."
      },
      "after": "d0f43daa48d3c597",
      "date": 1694691885748
    },
    {
      "type": "add",
      "id": "4bf682530355993f",
      "item": {
        "type": "paragraph",
        "id": "4bf682530355993f",
        "text": "The node vectors in Table 1 are arranged according to MIX character code. This means that a trie search will be quite fast, since we are merely fetching words of an array by using the characters of our keys as subscripts. Techniques for making quick multiway decisions by subscripting have been called “table look-at” as opposed to “table look-up” [see P. M. Sherman, CACM 4 (1961), 172173, 175]."
      },
      "after": "c5bafe40084153b4",
      "date": 1694691962464
    },
    {
      "type": "edit",
      "id": "4bf682530355993f",
      "item": {
        "type": "paragraph",
        "id": "4bf682530355993f",
        "text": "The node vectors in Table 1 are arranged according to MIX character code. This means that a trie search will be quite fast, since we are merely fetching words of an array by using the characters of our keys as subscripts. Techniques for making quick multiway decisions by subscripting have been called “table look-at” as opposed to “table look-up” [see P. M. Sherman, CACM 4 (1961), 172–173, 175]."
      },
      "date": 1694692017561
    },
    {
      "type": "edit",
      "id": "4bf682530355993f",
      "item": {
        "type": "paragraph",
        "id": "4bf682530355993f",
        "text": "The node vectors in Table 1 are arranged according to MIX character code. This means that a trie search will be quite fast, since we are merely fetching words of an array by using the characters of our keys as subscripts. Techniques for making quick multiway decisions by subscripting have been called “table look-at” as opposed to “[[table look-up]]” [see P. M. Sherman, CACM 4 (1961), 172–173, 175]."
      },
      "date": 1694692050669
    },
    {
      "type": "edit",
      "id": "d0f43daa48d3c597",
      "item": {
        "type": "paragraph",
        "id": "d0f43daa48d3c597",
        "text": "Suppose that we want to test a given search argument to see whether it is one of the 31 most common words of English (see Figs. 12 and 13 in Section 6.2.2). The data is represented in Table 1 as a trie structure; this name was suggested by E. Fredkin [CACM 3 (1960), 490–500] because it is a part of information retrieval. A [[trie]] — pronounced “try” — is essentially an M-ary tree, whose nodes are M-place vectors with components corresponding to digits or characters. Each node on level l represents the set of all keys that begin with a certain sequence of l characters called its prefix; the node specifies an M-way branch, depending on the (l + 1)st character."
      },
      "date": 1694692898686
    },
    {
      "type": "edit",
      "id": "d0f43daa48d3c597",
      "item": {
        "type": "paragraph",
        "id": "d0f43daa48d3c597",
        "text": "Suppose that we want to test a given search argument to see whether it is one of the 31 most common words of English (see Figs. 12 and 13 in Section 6.2.2). The data is represented in Table 1 as a trie structure; this name was suggested by E. Fredkin [CACM 3 (1960), 490–500] because it is a part of information retrieval. A [[Trie]] — pronounced “try” — is essentially an M-ary tree, whose nodes are M-place vectors with components corresponding to digits or characters. Each node on level l represents the set of all keys that begin with a certain sequence of l characters called its prefix; the node specifies an M-way branch, depending on the (l + 1)st character."
      },
      "date": 1694692906351
    },
    {
      "type": "edit",
      "id": "d0f43daa48d3c597",
      "item": {
        "type": "paragraph",
        "id": "d0f43daa48d3c597",
        "text": "Suppose that we want to test a given search argument to see whether it is one of the 31 most common words of English (see Figs. 12 and 13 in Section 6.2.2). The data is represented in Table 1 as a trie structure; this name was suggested by E. Fredkin [CACM 3 (1960), 490–500] because it is a part of information retrieval."
      },
      "date": 1694692922112
    },
    {
      "type": "add",
      "id": "2eb3abb7cd0badbf",
      "item": {
        "type": "paragraph",
        "id": "2eb3abb7cd0badbf",
        "text": "A [[Trie]] — pronounced “try” — is essentially an M-ary tree, whose nodes are M-place vectors with components corresponding to digits or characters. Each node on level l represents the set of all keys that begin with a certain sequence of l characters called its prefix; the node specifies an M-way branch, depending on the (l + 1)st character."
      },
      "after": "d0f43daa48d3c597",
      "date": 1694692923160
    },
    {
      "type": "edit",
      "id": "59e308544ee5bdc9",
      "item": {
        "type": "paragraph",
        "id": "59e308544ee5bdc9",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. Volume 3. 3rd ed. Reading, Mass: Addison-Wesley. ISBN 0-201-89685-0, p. 492–493.\n"
      },
      "date": 1694692951301
    },
    {
      "type": "add",
      "id": "b3c61da75b572bf9",
      "item": {
        "type": "paragraph",
        "id": "b3c61da75b572bf9",
        "text": "[…] The nodes of the trie are vectors whose subscripts run from 0 to M −1; each component of these vectors is either a key or a link (possibly null)."
      },
      "after": "4bf682530355993f",
      "date": 1694755206030
    },
    {
      "type": "edit",
      "id": "b3c61da75b572bf9",
      "item": {
        "type": "paragraph",
        "id": "b3c61da75b572bf9",
        "text": "[…] The nodes of the trie are vectors whose subscripts run from 0 to M − 1; each component of these vectors is either a key or a link (possibly null)."
      },
      "date": 1694755222775
    },
    {
      "type": "edit",
      "id": "59e308544ee5bdc9",
      "item": {
        "type": "paragraph",
        "id": "59e308544ee5bdc9",
        "text": "KNUTH, Donald Ervin, 1997. The art of computer programming. v. 3. Sorting and Searching. 2nd ed. Reading, Mass: Addison-Wesley. ISBN 0-201-89685-0, p. 492–493.\n"
      },
      "date": 1694787232911
    },
    {
      "type": "edit",
      "id": "4bf682530355993f",
      "item": {
        "type": "paragraph",
        "id": "4bf682530355993f",
        "text": "The node vectors in Table 1 are arranged according to MIX character code. This means that a trie search will be quite fast, since we are merely fetching words of an array by using the characters of our keys as subscripts. Techniques for making quick multiway decisions by subscripting have been called “[[table look-at]]” as opposed to “[[table look-up]]” [see P. M. Sherman, CACM 4 (1961), 172–173, 175]."
      },
      "date": 1694791085015
    },
    {
      "type": "edit",
      "id": "b3c61da75b572bf9",
      "item": {
        "type": "paragraph",
        "id": "b3c61da75b572bf9",
        "text": "[…] The nodes of the [[Trie]] are vectors whose subscripts run from 0 to M − 1; each component of these vectors is either a key or a link (possibly null)."
      },
      "date": 1694792175226
    },
    {
      "type": "edit",
      "id": "6a6cb29e348f81de",
      "item": {
        "type": "image",
        "id": "6a6cb29e348f81de",
        "text": "Table 1. A TRIE FOR THE 31 MOST COMMON ENGLISH WORDS",
        "size": "wide",
        "width": 419,
        "height": 427,
        "url": "/assets/plugins/image/9deb72bb64ba1a02d04b6e562ce55f71.jpg"
      },
      "date": 1694793018885
    }
  ]
}