{
  "title": "Delimiter-Directed Translation",
  "story": [
    {
      "type": "paragraph",
      "id": "18afc60270e2e545",
      "text": "The least structured parser that we can imagine is a monolithic component, which reads an input and executes it immediately. One commonly used intuitive parsing solution that follows a more systematic approach is a delimiter-directed translation."
    },
    {
      "type": "paragraph",
      "id": "ec05efb4de89bdbf",
      "text": "See Fowler, M.: [[Domain-Specific Languages]]. Addison-Wesley (2010)"
    },
    {
      "type": "paragraph",
      "id": "d4e8187166d5c4fc",
      "text": "With this approach, the language is divided into chunks, called tokens, by identifying well-recognizable separator characters. Then the actual type of each token can be inferred from its position. For some simple languages, this is a quick and easy solution that can be developed. However, for a more complicated language, the notion of grammar [7] must be introduced."
    },
    {
      "type": "markdown",
      "id": "0517622cba512e75",
      "text": "**Description** The parser searches for separator symbols that separate the tokens of the input language script. The type of each token is then inferred by its position. The parser may build a semantic model in the memory, but it may also be possible to execute the language script on the fly.\n"
    },
    {
      "type": "markdown",
      "id": "a9072b458ad55ba7",
      "text": "**Motivation** The simple structure of the language does not warrant building a fullfledged parser that creates a substantial syntax tree in the memory. This can save memory and reduce execution time. The development overhead of syntax-directed parsers is also avoided. \n\n\n"
    },
    {
      "type": "markdown",
      "id": "8d0a89c79fe74aa8",
      "text": "**Applicability** The language can easily be split into tokens by looking for separator symbols and tokens can easily be interpreted by their position. \n"
    },
    {
      "type": "markdown",
      "id": "41868b390864bfa4",
      "text": "**Structure** The parser remains a major component, but it may also build a semantic model and pass it to an execution component. Figure 3 shows the structure of a delimiter-directed parser. […]\n"
    },
    {
      "type": "markdown",
      "id": "83e13e684abfc8f7",
      "text": "**Consequences** The parser is fast, simple and has a minimal memory footprint because the lack of separate components avoids communication overhead and creating intermediate data structures.\n"
    },
    {
      "type": "markdown",
      "id": "334d0ae0f88f15b5",
      "text": "Its code is somewhat easier to maintain, extend and understand when compared to ad-hoc parser since there is already a stream of clearly distinguished tokens, which are usually reflected in the code as array indexes. Although most languages use several different delimiters, if the syntax is more complex, it is not really easy to capture it with the delimiter-driven approach and the code also becomes difficult to read and modify. This limits the expressiveness of the language under design. \n"
    },
    {
      "type": "markdown",
      "id": "0a880a4e4763b43b",
      "text": "The parser does not have significantly reusable components but the low complexity leads to less time spent on coding. If structured well, the tokenizer may be reused. \n"
    },
    {
      "type": "markdown",
      "id": "7887fe77dc66191f",
      "text": "Building a delimiter-directed parser does not require specific knowledge in language theory or compiler engineering.\n"
    },
    {
      "type": "markdown",
      "id": "7b9fbc3ec1f13b5e",
      "text": "**Implementation** Delimiter-directed parsers are frequently coded with a loop that reads statements one by one. This usually means reading the input line by line. Then, within a loop, the lines are split into tokens that are practically stored in an array or a list structure. Most programming languages also provide tokenizer functions. This may be followed either by populating a semantic model or a direct function call that processes the tokenized information.\n"
    },
    {
      "type": "markdown",
      "id": "fef336283f50408a",
      "text": "**Known Uses** Comma-separated values (CSV) is a common file format that enumerates properties of entities. Each entity is described by its own line and the property values follow a specific order and are separated by commas or semicolons. Such a file can easily be processed by a delimiter-directed parser."
    },
    {
      "type": "pagefold",
      "id": "b129ca9ae1ae2627",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "2d988eaec4e26f3b",
      "text": "KÖVESDÁN, Gábor, ASZTALOS, Márk and LENGYEL, László, 2014. Architectural Design Patterns for Language Parsers. Acta Polytechnica Hungarica. 2014. Vol. 11, no. 5, p. 19. "
    },
    {
      "type": "markdown",
      "id": "6980e3c12a1eab94",
      "text": "> Processing the textual scripts of computer languages is an important field in software development, which has been growing in popularity, recently. It is applied both for general-purpose programming languages and for domain-specific languages. There is a wide range of typical algorithms and patterns that are used to syntactically parse formal languages, each having specific characteristics and implying different software architectures. If we develop parsers at a higher abstraction level, it simplifies the problem domain and facilitates developing more robust software quicker, but there are always some tradeoffs to consider. The main guideline of this paper is [[Abstraction]]: how to increase it in different patterns, how it helps parser development and what kind of tradeoffs are implied. The presented architectural design patterns are organized in a pattern catalog ordered by their abstraction level. This catalog is intended to assist developers in the industry in designing efficient parser software.\n"
    },
    {
      "type": "paragraph",
      "id": "ebd925723f079287",
      "text": "[7] Hopcroft, J. E., Motwani, R., Ullman, J. D.: Introduction to Automata Theory, Languages and Computation. Addison-Wesley (2001)"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Delimiter-Directed Translation",
        "story": []
      },
      "date": 1662976638253
    },
    {
      "item": {
        "type": "factory",
        "id": "18afc60270e2e545"
      },
      "id": "18afc60270e2e545",
      "type": "add",
      "date": 1662976640097
    },
    {
      "type": "edit",
      "id": "18afc60270e2e545",
      "item": {
        "type": "paragraph",
        "id": "18afc60270e2e545",
        "text": "The least structured parser that we can imagine is a monolithic component, which reads an input and executes it immediately. One commonly used intuitive parsing solution that follows a more systematic approach is a delimiter-directed translation [1]. With this approach, the language is divided into chunks, called tokens, by identifying well-recognizable separator characters. Then the actual type of each token can be inferred from its position. For some simple languages, this is a quick and easy solution that can be developed. However, for a more complicated language, the notion of grammar [7] must be introduced."
      },
      "date": 1662976641968
    },
    {
      "item": {
        "type": "factory",
        "id": "b129ca9ae1ae2627"
      },
      "id": "b129ca9ae1ae2627",
      "type": "add",
      "after": "18afc60270e2e545",
      "date": 1662976647194
    },
    {
      "type": "edit",
      "id": "b129ca9ae1ae2627",
      "item": {
        "type": "pagefold",
        "id": "b129ca9ae1ae2627",
        "text": "~"
      },
      "date": 1662976649985
    },
    {
      "item": {
        "type": "factory",
        "id": "2d988eaec4e26f3b"
      },
      "id": "2d988eaec4e26f3b",
      "type": "add",
      "after": "b129ca9ae1ae2627",
      "date": 1662976659176
    },
    {
      "type": "edit",
      "id": "2d988eaec4e26f3b",
      "item": {
        "type": "paragraph",
        "id": "2d988eaec4e26f3b",
        "text": "\nKÖVESDÁN, Gábor, ASZTALOS, Márk and LENGYEL, László, 2014. Architectural Design Patterns for Language Parsers. Acta Polytechnica Hungarica. 2014. Vol. 11, no. 5, p. 19. Processing the textual scripts of computer languages is an important field in software development, which has been growing in popularity, recently. It is applied both for general-purpose programming languages and for domain-specific languages. There is a wide range of typical algorithms and patterns that are used to syntactically parse formal languages, each having specific characteristics and implying different software architectures. If we develop parsers at a higher abstraction level, it simplifies the problem domain and facilitates developing more robust software quicker, but there are always some tradeoffs to consider. The main guideline of this paper is abstraction: how to increase it in different patterns, how it helps parser development and what kind of tradeoffs are implied. The presented architectural design patterns are organized in a pattern catalog ordered by their abstraction level. This catalog is intended to assist developers in the industry in designing efficient parser software.\n"
      },
      "date": 1662976661149
    },
    {
      "type": "edit",
      "id": "2d988eaec4e26f3b",
      "item": {
        "type": "paragraph",
        "id": "2d988eaec4e26f3b",
        "text": "KÖVESDÁN, Gábor, ASZTALOS, Márk and LENGYEL, László, 2014. Architectural Design Patterns for Language Parsers. Acta Polytechnica Hungarica. 2014. Vol. 11, no. 5, p. 19. "
      },
      "date": 1662976670080
    },
    {
      "type": "add",
      "id": "6980e3c12a1eab94",
      "item": {
        "type": "paragraph",
        "id": "6980e3c12a1eab94",
        "text": "> Processing the textual scripts of computer languages is an important field in software development, which has been growing in popularity, recently. It is applied both for general-purpose programming languages and for domain-specific languages. There is a wide range of typical algorithms and patterns that are used to syntactically parse formal languages, each having specific characteristics and implying different software architectures. If we develop parsers at a higher abstraction level, it simplifies the problem domain and facilitates developing more robust software quicker, but there are always some tradeoffs to consider. The main guideline of this paper is abstraction: how to increase it in different patterns, how it helps parser development and what kind of tradeoffs are implied. The presented architectural design patterns are organized in a pattern catalog ordered by their abstraction level. This catalog is intended to assist developers in the industry in designing efficient parser software.\n"
      },
      "after": "2d988eaec4e26f3b",
      "date": 1662976670545
    },
    {
      "type": "edit",
      "id": "6980e3c12a1eab94",
      "item": {
        "type": "markdown",
        "id": "6980e3c12a1eab94",
        "text": "> Processing the textual scripts of computer languages is an important field in software development, which has been growing in popularity, recently. It is applied both for general-purpose programming languages and for domain-specific languages. There is a wide range of typical algorithms and patterns that are used to syntactically parse formal languages, each having specific characteristics and implying different software architectures. If we develop parsers at a higher abstraction level, it simplifies the problem domain and facilitates developing more robust software quicker, but there are always some tradeoffs to consider. The main guideline of this paper is abstraction: how to increase it in different patterns, how it helps parser development and what kind of tradeoffs are implied. The presented architectural design patterns are organized in a pattern catalog ordered by their abstraction level. This catalog is intended to assist developers in the industry in designing efficient parser software.\n"
      },
      "date": 1662976671555
    },
    {
      "type": "edit",
      "id": "6980e3c12a1eab94",
      "item": {
        "type": "markdown",
        "id": "6980e3c12a1eab94",
        "text": "> Processing the textual scripts of computer languages is an important field in software development, which has been growing in popularity, recently. It is applied both for general-purpose programming languages and for domain-specific languages. There is a wide range of typical algorithms and patterns that are used to syntactically parse formal languages, each having specific characteristics and implying different software architectures. If we develop parsers at a higher abstraction level, it simplifies the problem domain and facilitates developing more robust software quicker, but there are always some tradeoffs to consider. The main guideline of this paper is [[Abstraction]]: how to increase it in different patterns, how it helps parser development and what kind of tradeoffs are implied. The presented architectural design patterns are organized in a pattern catalog ordered by their abstraction level. This catalog is intended to assist developers in the industry in designing efficient parser software.\n"
      },
      "date": 1662976708122
    },
    {
      "type": "edit",
      "id": "18afc60270e2e545",
      "item": {
        "type": "paragraph",
        "id": "18afc60270e2e545",
        "text": "The least structured parser that we can imagine is a monolithic component, which reads an input and executes it immediately. One commonly used intuitive parsing solution that follows a more systematic approach is a delimiter-directed translation [1]. "
      },
      "date": 1662976769228
    },
    {
      "type": "add",
      "id": "d4e8187166d5c4fc",
      "item": {
        "type": "paragraph",
        "id": "d4e8187166d5c4fc",
        "text": "With this approach, the language is divided into chunks, called tokens, by identifying well-recognizable separator characters. Then the actual type of each token can be inferred from its position. For some simple languages, this is a quick and easy solution that can be developed. However, for a more complicated language, the notion of grammar [7] must be introduced."
      },
      "after": "18afc60270e2e545",
      "date": 1662976771384
    },
    {
      "type": "edit",
      "id": "18afc60270e2e545",
      "item": {
        "type": "paragraph",
        "id": "18afc60270e2e545",
        "text": "The least structured parser that we can imagine is a monolithic component, which reads an input and executes it immediately. One commonly used intuitive parsing solution that follows a more systematic approach is a delimiter-directed translation."
      },
      "date": 1662976775082
    },
    {
      "type": "add",
      "id": "ec05efb4de89bdbf",
      "item": {
        "type": "paragraph",
        "id": "ec05efb4de89bdbf",
        "text": "A well-formed word is a statement expressed in the language that is considered valid and meaningful. "
      },
      "after": "18afc60270e2e545",
      "date": 1662976776089
    },
    {
      "type": "edit",
      "id": "ec05efb4de89bdbf",
      "item": {
        "type": "paragraph",
        "id": "ec05efb4de89bdbf",
        "text": "See Fowler, M.: Domain-Specific Languages. Addison-Wesley (2010)"
      },
      "date": 1662976811064
    },
    {
      "type": "edit",
      "id": "ec05efb4de89bdbf",
      "item": {
        "type": "paragraph",
        "id": "ec05efb4de89bdbf",
        "text": "See Fowler, M.: [[Domain-Specific Languages]]. Addison-Wesley (2010)"
      },
      "date": 1662976822320
    },
    {
      "item": {
        "type": "factory",
        "id": "ebd925723f079287"
      },
      "id": "ebd925723f079287",
      "type": "add",
      "after": "6980e3c12a1eab94",
      "date": 1662976839703
    },
    {
      "type": "edit",
      "id": "ebd925723f079287",
      "item": {
        "type": "paragraph",
        "id": "ebd925723f079287",
        "text": "[7] Hopcroft, J. E., Motwani, R., Ullman, J. D.: Introduction to Automata Theory, Languages and Computation. Addison-Wesley (2001)"
      },
      "date": 1662976847785
    },
    {
      "item": {
        "type": "factory",
        "id": "0517622cba512e75"
      },
      "id": "0517622cba512e75",
      "type": "add",
      "after": "ebd925723f079287",
      "date": 1662976874749
    },
    {
      "type": "edit",
      "id": "0517622cba512e75",
      "item": {
        "type": "paragraph",
        "id": "0517622cba512e75",
        "text": "Description The parser searches for separator symbols that separate the tokens of the input language script. The type of each token is then inferred by its position. The parser may build a semantic model in the memory, but it may also be possible to execute the language script on the fly."
      },
      "date": 1662976878260
    },
    {
      "id": "0517622cba512e75",
      "type": "move",
      "order": [
        "18afc60270e2e545",
        "ec05efb4de89bdbf",
        "d4e8187166d5c4fc",
        "0517622cba512e75",
        "b129ca9ae1ae2627",
        "2d988eaec4e26f3b",
        "6980e3c12a1eab94",
        "ebd925723f079287"
      ],
      "date": 1662976881979
    },
    {
      "type": "edit",
      "id": "0517622cba512e75",
      "item": {
        "type": "paragraph",
        "id": "0517622cba512e75",
        "text": "**Description** The parser searches for separator symbols that separate the tokens of the input language script. The type of each token is then inferred by its position. The parser may build a semantic model in the memory, but it may also be possible to execute the language script on the fly."
      },
      "date": 1662976889113
    },
    {
      "type": "edit",
      "id": "0517622cba512e75",
      "item": {
        "type": "markdown",
        "id": "0517622cba512e75",
        "text": "**Description** The parser searches for separator symbols that separate the tokens of the input language script. The type of each token is then inferred by its position. The parser may build a semantic model in the memory, but it may also be possible to execute the language script on the fly."
      },
      "date": 1662976890364
    },
    {
      "type": "edit",
      "id": "0517622cba512e75",
      "item": {
        "type": "markdown",
        "id": "0517622cba512e75",
        "text": "**Description** The parser searches for separator symbols that separate the tokens of the input language script. The type of each token is then inferred by its position. The parser may build a semantic model in the memory, but it may also be possible to execute the language script on the fly.\n"
      },
      "date": 1662976909101
    },
    {
      "type": "add",
      "id": "a9072b458ad55ba7",
      "item": {
        "type": "markdown",
        "id": "a9072b458ad55ba7",
        "text": "Motivation The simple structure of the language does not warrant building a fullfledged parser that creates a substantial syntax tree in the memory. This can save memory and reduce execution time. The development overhead of syntax-directed parsers is also avoided. Applicability The language can easily be split into tokens by looking for separator symbols and tokens can easily be interpreted by their position. Structure The parser remains a major component, but it may also build a semantic model and pass it to an execution component. Figure 3 shows the structure of a delimiter-directed parser."
      },
      "after": "0517622cba512e75",
      "date": 1662976914196
    },
    {
      "type": "edit",
      "id": "a9072b458ad55ba7",
      "item": {
        "type": "markdown",
        "id": "a9072b458ad55ba7",
        "text": "**Motivation** The simple structure of the language does not warrant building a fullfledged parser that creates a substantial syntax tree in the memory. This can save memory and reduce execution time. The development overhead of syntax-directed parsers is also avoided. \n\n**Applicability** The language can easily be split into tokens by looking for separator symbols and tokens can easily be interpreted by their position. Structure The parser remains a major component, but it may also build a semantic model and pass it to an execution component. Figure 3 shows the structure of a delimiter-directed parser."
      },
      "date": 1662976944559
    },
    {
      "type": "edit",
      "id": "a9072b458ad55ba7",
      "item": {
        "type": "markdown",
        "id": "a9072b458ad55ba7",
        "text": "**Motivation** The simple structure of the language does not warrant building a fullfledged parser that creates a substantial syntax tree in the memory. This can save memory and reduce execution time. The development overhead of syntax-directed parsers is also avoided. \n\n\n"
      },
      "date": 1662976951432
    },
    {
      "type": "add",
      "id": "8d0a89c79fe74aa8",
      "item": {
        "type": "markdown",
        "id": "8d0a89c79fe74aa8",
        "text": "**Applicability** The language can easily be split into tokens by looking for separator symbols and tokens can easily be interpreted by their position. \n"
      },
      "after": "a9072b458ad55ba7",
      "date": 1662976962366
    },
    {
      "type": "add",
      "id": "41868b390864bfa4",
      "item": {
        "type": "markdown",
        "id": "41868b390864bfa4",
        "text": "**Structure** The parser remains a major component, but it may also build a semantic model and pass it to an execution component. Figure 3 shows the structure of a delimiter-directed parser."
      },
      "after": "8d0a89c79fe74aa8",
      "date": 1662976962944
    },
    {
      "type": "edit",
      "id": "41868b390864bfa4",
      "item": {
        "type": "markdown",
        "id": "41868b390864bfa4",
        "text": "**Structure** The parser remains a major component, but it may also build a semantic model and pass it to an execution component. Figure 3 shows the structure of a delimiter-directed parser. […]"
      },
      "date": 1662977010538
    },
    {
      "type": "edit",
      "id": "41868b390864bfa4",
      "item": {
        "type": "markdown",
        "id": "41868b390864bfa4",
        "text": "**Structure** The parser remains a major component, but it may also build a semantic model and pass it to an execution component. Figure 3 shows the structure of a delimiter-directed parser. […]\n"
      },
      "date": 1662977018468
    },
    {
      "type": "add",
      "id": "83e13e684abfc8f7",
      "item": {
        "type": "markdown",
        "id": "83e13e684abfc8f7",
        "text": "**Consequences** The parser is fast, simple and has a minimal memory footprint because the lack of separate components avoids communication overhead and creating intermediate data structures."
      },
      "after": "41868b390864bfa4",
      "date": 1662977024843
    },
    {
      "type": "edit",
      "id": "83e13e684abfc8f7",
      "item": {
        "type": "markdown",
        "id": "83e13e684abfc8f7",
        "text": "**Consequences** The parser is fast, simple and has a minimal memory footprint because the lack of separate components avoids communication overhead and creating intermediate data structures.\n"
      },
      "date": 1662977039450
    },
    {
      "type": "add",
      "id": "334d0ae0f88f15b5",
      "item": {
        "type": "markdown",
        "id": "334d0ae0f88f15b5",
        "text": "Its code is somewhat easier to maintain, extend and understand when compared to ad-hoc parser since there is already a stream of clearly distinguished tokens, which are usually reflected in the code as array indexes. Although most languages use several different delimiters, if the syntax is more complex, it is not really easy to capture it with the delimiter-driven approach and the code also becomes difficult to read and modify. This limits the expressiveness of the language under design. The parser does not have significantly reusable components but the low complexity leads to less time spent on coding. If structured well, the tokenizer may be reused. Building a delimiter-directed parser does not require specific knowledge in language theory or compiler engineering."
      },
      "after": "83e13e684abfc8f7",
      "date": 1662977040142
    },
    {
      "type": "edit",
      "id": "334d0ae0f88f15b5",
      "item": {
        "type": "markdown",
        "id": "334d0ae0f88f15b5",
        "text": "Its code is somewhat easier to maintain, extend and understand when compared to ad-hoc parser since there is already a stream of clearly distinguished tokens, which are usually reflected in the code as array indexes. Although most languages use several different delimiters, if the syntax is more complex, it is not really easy to capture it with the delimiter-driven approach and the code also becomes difficult to read and modify. This limits the expressiveness of the language under design. \n"
      },
      "date": 1662977056514
    },
    {
      "type": "add",
      "id": "0a880a4e4763b43b",
      "item": {
        "type": "markdown",
        "id": "0a880a4e4763b43b",
        "text": "The parser does not have significantly reusable components but the low complexity leads to less time spent on coding. If structured well, the tokenizer may be reused. Building a delimiter-directed parser does not require specific knowledge in language theory or compiler engineering."
      },
      "after": "334d0ae0f88f15b5",
      "date": 1662977056826
    },
    {
      "type": "edit",
      "id": "0a880a4e4763b43b",
      "item": {
        "type": "markdown",
        "id": "0a880a4e4763b43b",
        "text": "The parser does not have significantly reusable components but the low complexity leads to less time spent on coding. If structured well, the tokenizer may be reused. \n"
      },
      "date": 1662977063289
    },
    {
      "type": "add",
      "id": "7887fe77dc66191f",
      "item": {
        "type": "markdown",
        "id": "7887fe77dc66191f",
        "text": "Building a delimiter-directed parser does not require specific knowledge in language theory or compiler engineering."
      },
      "after": "0a880a4e4763b43b",
      "date": 1662977063558
    },
    {
      "type": "edit",
      "id": "7887fe77dc66191f",
      "item": {
        "type": "markdown",
        "id": "7887fe77dc66191f",
        "text": "Building a delimiter-directed parser does not require specific knowledge in language theory or compiler engineering.\n"
      },
      "date": 1662977077047
    },
    {
      "type": "add",
      "id": "7b9fbc3ec1f13b5e",
      "item": {
        "type": "markdown",
        "id": "7b9fbc3ec1f13b5e",
        "text": "**Implementation** Delimiter-directed parsers are frequently coded with a loop that reads statements one by one. This usually means reading the input line by line. Then, within a loop, the lines are split into tokens that are practically stored in an array or a list structure. Most programming languages also provide tokenizer functions. This may be followed either by populating a semantic model or a direct function call that processes the tokenized information."
      },
      "after": "7887fe77dc66191f",
      "date": 1662977086638
    },
    {
      "type": "edit",
      "id": "7b9fbc3ec1f13b5e",
      "item": {
        "type": "markdown",
        "id": "7b9fbc3ec1f13b5e",
        "text": "**Implementation** Delimiter-directed parsers are frequently coded with a loop that reads statements one by one. This usually means reading the input line by line. Then, within a loop, the lines are split into tokens that are practically stored in an array or a list structure. Most programming languages also provide tokenizer functions. This may be followed either by populating a semantic model or a direct function call that processes the tokenized information.\n"
      },
      "date": 1662977122556
    },
    {
      "type": "add",
      "id": "fef336283f50408a",
      "item": {
        "type": "markdown",
        "id": "fef336283f50408a",
        "text": "**Known Uses** Comma-separated values (CSV) is a common file format that enumerates properties of entities. Each entity is described by its own line and the property values follow a specific order and are separated by commas or semicolons. Such a file can easily be processed by a delimiter-directed parser."
      },
      "after": "7b9fbc3ec1f13b5e",
      "date": 1662977128419
    }
  ]
}