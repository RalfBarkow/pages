{
  "title": "Traits in a Nushell",
  "story": [
    {
      "type": "paragraph",
      "id": "d6b69e40252ed53a",
      "text": "Reusable groups of methods: Traits are units of behavior. They are sets of methods that serve as the behavioral building block of classes and primitive units of [[Code Reuse]] [2]. "
    },
    {
      "type": "paragraph",
      "id": "a99535fa632cf880",
      "text": "In addition to offering behavior, traits also require methods, i.e., methods that are needed so that trait behavior is fulfilled. Traits do not define state, instead they require accessor methods. "
    },
    {
      "type": "paragraph",
      "id": "830d2dd2fa43df80",
      "text": "Fig. A1 shows a class SyncStream that uses two traits, TSyncReadWrite and TStream. The trait TSyncReadWrite provides the methods syncRead, syncWrite and hash. It requires the methods read and write, and the two accessor methods lock and lock:. We use an extension to UML to represent traits (the right column lists required methods while the left one lists the provided methods). "
    },
    {
      "type": "paragraph",
      "id": "33ff136e56e52464",
      "text": "Explicit composition: A class [[contain]]s a super-class reference, uses a set of traits, defines state (variables) and behavior (methods) that glue the traits together; a class implements the required trait methods and resolves any method conflicts. Trait composition respects the following three rules:"
    },
    {
      "type": "paragraph",
      "id": "c3dba67e59d6fdb5",
      "text": "Methods defined in the composer take precedence over trait methods. This allows the methods defined in a composer to override methods with the same name provided by the used traits; we call these methods glue methods."
    },
    {
      "type": "paragraph",
      "id": "587ec4204517fbe2",
      "text": "Flattening property. In any class composer the traits can be in principle in-lined to give an equivalent class definition that does not use traits. "
    },
    {
      "type": "paragraph",
      "id": "890a2368ba61a6df",
      "text": "Composition order is irrelevant. All the traits have the same precedence, and hence conflicting trait methods must be explicitly disambiguated."
    },
    {
      "type": "paragraph",
      "id": "7e828572aaecf858",
      "text": "Conflict resolution: While composing traits, method conflicts may arise. A conflict arises if we combine two or more traits that provide identically named methods that do not originate from the same trait. There are two strategies to resolve a conflict: by implementing a (glue) method at the level of the class that overrides the conflicting methods, or by excluding a method from all but one trait. Traits allow method aliasing; this makes it possible to introduce an additional name for a method provided by a trait. The new name is used to obtain access to a method that would otherwise be unreachable because it has been overridden [2]."
    },
    {
      "type": "paragraph",
      "id": "11b5a6b14ec5131e",
      "text": "[…]"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Traits in a Nushell",
        "story": []
      },
      "date": 1673883477415
    },
    {
      "item": {
        "type": "factory",
        "id": "11b5a6b14ec5131e"
      },
      "id": "11b5a6b14ec5131e",
      "type": "add",
      "date": 1673883480476
    },
    {
      "type": "edit",
      "id": "11b5a6b14ec5131e",
      "item": {
        "type": "paragraph",
        "id": "11b5a6b14ec5131e",
        "text": "[…]"
      },
      "date": 1673883483822
    },
    {
      "item": {
        "type": "factory",
        "id": "8a7734195b6ee2a6"
      },
      "id": "8a7734195b6ee2a6",
      "type": "add",
      "after": "11b5a6b14ec5131e",
      "date": 1673883485410
    },
    {
      "type": "edit",
      "id": "8a7734195b6ee2a6",
      "item": {
        "type": "paragraph",
        "id": "8a7734195b6ee2a6",
        "text": "To ease the understanding of this paper we added this section which presents traits in a nutshell. This part is taken from [4] and is not part of the current article. It is just added here for sake of completeness and understanding the ideas presented in the paper. Reusable groups of methods: Traits are units of behavior. They are sets of methods that serve as the behavioral building block of classes and primitive units of code reuse [2]. In addition to offering behavior, traits also require methods, i.e., methods that are needed so that trait behavior is fulfilled. Traits do not define state, instead they require accessor methods. Fig. A1 shows a class SyncStream that uses two traits, TSyncReadWrite and TStream. The trait TSyncReadWrite provides the methods syncRead, syncWrite and hash. It requires the methods read and write, and the two accessor methods lock and lock:. We use an extension to UML to represent traits (the right column lists required methods while the left one lists the provided methods). Explicit composition: A class contains a super-class reference, uses a set of traits, defines state (variables) and behavior (methods) that glue the traits together; a class implements the required trait methods and resolves any method conflicts. Trait composition respects the following three rules:"
      },
      "date": 1673883487997
    },
    {
      "id": "8a7734195b6ee2a6",
      "type": "move",
      "order": [
        "8a7734195b6ee2a6",
        "11b5a6b14ec5131e"
      ],
      "date": 1673883489898
    },
    {
      "type": "edit",
      "id": "8a7734195b6ee2a6",
      "item": {
        "type": "paragraph",
        "id": "8a7734195b6ee2a6",
        "text": "To ease the understanding of this paper we added this section which presents traits in a nutshell. This part is taken from [4] and is not part of the current article. It is just added here for sake of completeness and understanding the ideas presented in the paper. "
      },
      "date": 1673883509503
    },
    {
      "type": "add",
      "id": "d6b69e40252ed53a",
      "item": {
        "type": "paragraph",
        "id": "d6b69e40252ed53a",
        "text": "Reusable groups of methods: Traits are units of behavior. They are sets of methods that serve as the behavioral building block of classes and primitive units of code reuse [2]. In addition to offering behavior, traits also require methods, i.e., methods that are needed so that trait behavior is fulfilled. Traits do not define state, instead they require accessor methods. Fig. A1 shows a class SyncStream that uses two traits, TSyncReadWrite and TStream. The trait TSyncReadWrite provides the methods syncRead, syncWrite and hash. It requires the methods read and write, and the two accessor methods lock and lock:. We use an extension to UML to represent traits (the right column lists required methods while the left one lists the provided methods). Explicit composition: A class contains a super-class reference, uses a set of traits, defines state (variables) and behavior (methods) that glue the traits together; a class implements the required trait methods and resolves any method conflicts. Trait composition respects the following three rules:"
      },
      "after": "8a7734195b6ee2a6",
      "date": 1673883510694
    },
    {
      "type": "remove",
      "id": "8a7734195b6ee2a6",
      "date": 1673883511878
    },
    {
      "type": "edit",
      "id": "d6b69e40252ed53a",
      "item": {
        "type": "paragraph",
        "id": "d6b69e40252ed53a",
        "text": "Reusable groups of methods: Traits are units of behavior. They are sets of methods that serve as the behavioral building block of classes and primitive units of code reuse [2]. "
      },
      "date": 1673883541016
    },
    {
      "type": "add",
      "id": "a99535fa632cf880",
      "item": {
        "type": "paragraph",
        "id": "a99535fa632cf880",
        "text": "In addition to offering behavior, traits also require methods, i.e., methods that are needed so that trait behavior is fulfilled. Traits do not define state, instead they require accessor methods. Fig. A1 shows a class SyncStream that uses two traits, TSyncReadWrite and TStream. The trait TSyncReadWrite provides the methods syncRead, syncWrite and hash. It requires the methods read and write, and the two accessor methods lock and lock:. We use an extension to UML to represent traits (the right column lists required methods while the left one lists the provided methods). Explicit composition: A class contains a super-class reference, uses a set of traits, defines state (variables) and behavior (methods) that glue the traits together; a class implements the required trait methods and resolves any method conflicts. Trait composition respects the following three rules:"
      },
      "after": "d6b69e40252ed53a",
      "date": 1673883542119
    },
    {
      "type": "edit",
      "id": "a99535fa632cf880",
      "item": {
        "type": "paragraph",
        "id": "a99535fa632cf880",
        "text": "In addition to offering behavior, traits also require methods, i.e., methods that are needed so that trait behavior is fulfilled. Traits do not define state, instead they require accessor methods. "
      },
      "date": 1673883562157
    },
    {
      "type": "add",
      "id": "830d2dd2fa43df80",
      "item": {
        "type": "paragraph",
        "id": "830d2dd2fa43df80",
        "text": "Fig. A1 shows a class SyncStream that uses two traits, TSyncReadWrite and TStream. The trait TSyncReadWrite provides the methods syncRead, syncWrite and hash. It requires the methods read and write, and the two accessor methods lock and lock:. We use an extension to UML to represent traits (the right column lists required methods while the left one lists the provided methods). Explicit composition: A class contains a super-class reference, uses a set of traits, defines state (variables) and behavior (methods) that glue the traits together; a class implements the required trait methods and resolves any method conflicts. Trait composition respects the following three rules:"
      },
      "after": "a99535fa632cf880",
      "date": 1673883563237
    },
    {
      "type": "edit",
      "id": "830d2dd2fa43df80",
      "item": {
        "type": "paragraph",
        "id": "830d2dd2fa43df80",
        "text": "Fig. A1 shows a class SyncStream that uses two traits, TSyncReadWrite and TStream. The trait TSyncReadWrite provides the methods syncRead, syncWrite and hash. It requires the methods read and write, and the two accessor methods lock and lock:. We use an extension to UML to represent traits (the right column lists required methods while the left one lists the provided methods). "
      },
      "date": 1673883591213
    },
    {
      "type": "add",
      "id": "33ff136e56e52464",
      "item": {
        "type": "paragraph",
        "id": "33ff136e56e52464",
        "text": "Explicit composition: A class contains a super-class reference, uses a set of traits, defines state (variables) and behavior (methods) that glue the traits together; a class implements the required trait methods and resolves any method conflicts. Trait composition respects the following three rules:"
      },
      "after": "830d2dd2fa43df80",
      "date": 1673883592346
    },
    {
      "type": "edit",
      "id": "33ff136e56e52464",
      "item": {
        "type": "paragraph",
        "id": "33ff136e56e52464",
        "text": "Explicit composition: A class [[contain]]s a super-class reference, uses a set of traits, defines state (variables) and behavior (methods) that glue the traits together; a class implements the required trait methods and resolves any method conflicts. Trait composition respects the following three rules:"
      },
      "date": 1673883650958
    },
    {
      "item": {
        "type": "factory",
        "id": "c3dba67e59d6fdb5"
      },
      "id": "c3dba67e59d6fdb5",
      "type": "add",
      "after": "11b5a6b14ec5131e",
      "date": 1673883678885
    },
    {
      "id": "c3dba67e59d6fdb5",
      "type": "move",
      "order": [
        "d6b69e40252ed53a",
        "a99535fa632cf880",
        "830d2dd2fa43df80",
        "33ff136e56e52464",
        "c3dba67e59d6fdb5",
        "11b5a6b14ec5131e"
      ],
      "date": 1673883680982
    },
    {
      "type": "edit",
      "id": "c3dba67e59d6fdb5",
      "item": {
        "type": "paragraph",
        "id": "c3dba67e59d6fdb5",
        "text": "Methods defined in the composer take precedence over trait methods. This allows the methods defined in a composer to override methods with the same name provided by the used traits; we call these methods glue methods. • Flattening property. In any class composer the traits can be in principle in-lined to give an equivalent class definition that does not use traits. • Composition order is irrelevant. All the traits have the same precedence, and hence conflicting trait methods must be explicitly disambiguated."
      },
      "date": 1673883682416
    },
    {
      "type": "edit",
      "id": "c3dba67e59d6fdb5",
      "item": {
        "type": "paragraph",
        "id": "c3dba67e59d6fdb5",
        "text": "Methods defined in the composer take precedence over trait methods. This allows the methods defined in a composer to override methods with the same name provided by the used traits; we call these methods glue methods. • "
      },
      "date": 1673883688457
    },
    {
      "type": "add",
      "id": "587ec4204517fbe2",
      "item": {
        "type": "paragraph",
        "id": "587ec4204517fbe2",
        "text": "Flattening property. In any class composer the traits can be in principle in-lined to give an equivalent class definition that does not use traits. • Composition order is irrelevant. All the traits have the same precedence, and hence conflicting trait methods must be explicitly disambiguated."
      },
      "after": "c3dba67e59d6fdb5",
      "date": 1673883690358
    },
    {
      "type": "edit",
      "id": "c3dba67e59d6fdb5",
      "item": {
        "type": "paragraph",
        "id": "c3dba67e59d6fdb5",
        "text": "Methods defined in the composer take precedence over trait methods. This allows the methods defined in a composer to override methods with the same name provided by the used traits; we call these methods glue methods."
      },
      "date": 1673883694388
    },
    {
      "type": "edit",
      "id": "587ec4204517fbe2",
      "item": {
        "type": "paragraph",
        "id": "587ec4204517fbe2",
        "text": "Flattening property. In any class composer the traits can be in principle in-lined to give an equivalent class definition that does not use traits. "
      },
      "date": 1673883698335
    },
    {
      "type": "add",
      "id": "890a2368ba61a6df",
      "item": {
        "type": "paragraph",
        "id": "890a2368ba61a6df",
        "text": "Composition order is irrelevant. All the traits have the same precedence, and hence conflicting trait methods must be explicitly disambiguated."
      },
      "after": "587ec4204517fbe2",
      "date": 1673883700428
    },
    {
      "item": {
        "type": "factory",
        "id": "7e828572aaecf858"
      },
      "id": "7e828572aaecf858",
      "type": "add",
      "after": "11b5a6b14ec5131e",
      "date": 1673883740498
    },
    {
      "id": "7e828572aaecf858",
      "type": "move",
      "order": [
        "d6b69e40252ed53a",
        "a99535fa632cf880",
        "830d2dd2fa43df80",
        "33ff136e56e52464",
        "c3dba67e59d6fdb5",
        "587ec4204517fbe2",
        "890a2368ba61a6df",
        "7e828572aaecf858",
        "11b5a6b14ec5131e"
      ],
      "date": 1673883742667
    },
    {
      "type": "edit",
      "id": "7e828572aaecf858",
      "item": {
        "type": "paragraph",
        "id": "7e828572aaecf858",
        "text": "Conflict resolution: While composing traits, method conflicts may arise. A conflict arises if we combine two or more traits that provide identically named methods that do not originate from the same trait. There are two strategies to resolve a conflict: by implementing a (glue) method at the level of the class that overrides the conflicting methods, or by excluding a method from all but one trait. Traits allow method aliasing; this makes it possible to introduce an additional name for a method provided by a trait. The new name is used to obtain access to a method that would otherwise be unreachable because it has been overridden [2]."
      },
      "date": 1673883744074
    },
    {
      "type": "edit",
      "id": "d6b69e40252ed53a",
      "item": {
        "type": "paragraph",
        "id": "d6b69e40252ed53a",
        "text": "Reusable groups of methods: Traits are units of behavior. They are sets of methods that serve as the behavioral building block of classes and primitive units of [[Code Reuse]] [2]. "
      },
      "date": 1673883809147
    }
  ]
}