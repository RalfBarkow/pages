{
  "title": "Accuracy of the Date object",
  "story": [
    {
      "type": "paragraph",
      "id": "f19ee306d4543bc6",
      "text": "We often find ourselves using 'Date.now()' twice and comparing the numbers to get the duration of time that has passed. Or in ye' olden times the IE 7 compatible \"new Date().getTime()\". It's easy to assume that something sensible happens when we make these calls, but alas, that is not our lot in life. Making comparing two times one of the [[JavaScript Common Pitfalls]]."
    },
    {
      "type": "paragraph",
      "id": "936d26ec86f3d2f4",
      "text": "The first, and most obvious problem is that time in JavaScript is not monotonic. It's only reported to the nearest millisecond, so if you call \"Date.now()\" twice within a millisecond, it reports the same time. This is mostly a problem if you want to use time as part of some sort of key/tagging situation. So, never rely on Date.now() being unique."
    },
    {
      "type": "paragraph",
      "id": "2f16b080a4412287",
      "text": "The bigger, hidden, problem is that Date.now() relies on the operating system for it's time. That may not sound bad on the surface, but who regulates the behavior of the time that the operating system reports to JavaScript? Nobody, that's who."
    },
    {
      "type": "paragraph",
      "id": "25288c9b5cec2126",
      "text": "So, if system time is altered in between two call Date.now() we have a meaningless relationship without even knowing it. We can even have cases where it appears that now is negative milliseconds after some time in the past. That is a really unhelpful result. And most systems have their time automatically adjusted regularly by services out of everyones control, it's not just a mischievous user setting the clock back to fool your timing, but automation who's sole job is to monkey with the system clock."
    },
    {
      "type": "paragraph",
      "id": "03414091e8203222",
      "text": "The accuracy is also entirely arbitrary. In most modern operating systems you'll get 1ms accuracy, as close as the JS Date object can handle anyway. However, a lot of people still run windows XP, and XP has a shockingly bad 15ms minimum time resolution. That's right, time steps in 15ms blocks as far as Date.now() is concerned on an XP machine. Bleh. This really compounds that uniqueness problem above too."
    },
    {
      "type": "paragraph",
      "id": "637a0fe7338f3a7b",
      "text": "So, this is pretty bleak right? Well, only if you need to support old browsers (or Mobile Safari...), the rest of the environments have high resolution time! In Node it's 'process.hrtime()', and in the browser it is 'performance.now()'. These both offer high resolution, and a genuine guarantee that two high res times will have meaning relative to each other. Keep in mind these are both relative times though, not absolute, so don't think you can go replace all of your Date objects!"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Accuracy of the Date object",
        "story": []
      },
      "date": 1433831158912
    },
    {
      "item": {
        "type": "factory",
        "id": "f19ee306d4543bc6"
      },
      "id": "f19ee306d4543bc6",
      "type": "add",
      "date": 1433831160818
    },
    {
      "type": "edit",
      "id": "f19ee306d4543bc6",
      "item": {
        "type": "paragraph",
        "id": "f19ee306d4543bc6",
        "text": "We often find ourselves using 'Date.now()' twice and comparing the numbers to get the duration of time that has passed. Or in ye' olden times the IE 7 compatible \"new Date().getTime()\". It's easy to assume that something sensible happens when we make these calls, but alas, that is not our lot in life. Making comparing two times one of the [[JavaScript Common Pitfalls]]."
      },
      "date": 1433831439993
    },
    {
      "type": "add",
      "id": "936d26ec86f3d2f4",
      "item": {
        "type": "paragraph",
        "id": "936d26ec86f3d2f4",
        "text": "The first, and most obvious problem is that time in JavaScript is not monotonic. It's only reported to the nearest millisecond, so if you call \"Date.now()\" twice within a millisecond, it reports the same time. This is mostly a problem if you want to use time as part of some sort of key/tagging situation. So, never rely on Date.now() being unique."
      },
      "after": "f19ee306d4543bc6",
      "date": 1433831610363
    },
    {
      "type": "add",
      "id": "2f16b080a4412287",
      "item": {
        "type": "paragraph",
        "id": "2f16b080a4412287",
        "text": "The bigger, hidden, problem is that Date.now() relies on the operating system for it's time. That may not sound bad on the surface, but who regulates the behavior of the time that the operating system reports to JavaScript? Nobody, that's who."
      },
      "after": "936d26ec86f3d2f4",
      "date": 1433831759441
    },
    {
      "type": "add",
      "id": "25288c9b5cec2126",
      "item": {
        "type": "paragraph",
        "id": "25288c9b5cec2126",
        "text": "So, if system time is altered in between two call Date.now() we have a meaningless relationship without even knowing it. We can even have cases where it appears that now is negative milliseconds after some time in the past. That is a really unhelpful result."
      },
      "after": "2f16b080a4412287",
      "date": 1433831942487
    },
    {
      "type": "add",
      "id": "03414091e8203222",
      "item": {
        "type": "paragraph",
        "id": "03414091e8203222",
        "text": "The accuracy is also entirely arbitrary. In most modern operating systems you'll get 1ms accuracy, as close as the JS Date object can handle anyway. However, a lot of people still run windows XP, and XP has a shockingly bad 15ms minimum time resolution. That's right, time steps in 15ms blocks as far as Date.now() is concerned on an XP machine. Bleh. This really compounds that uniqueness problem above too."
      },
      "after": "25288c9b5cec2126",
      "date": 1433832104844
    },
    {
      "type": "add",
      "id": "637a0fe7338f3a7b",
      "item": {
        "type": "paragraph",
        "id": "637a0fe7338f3a7b",
        "text": "So, this is pretty bleak right?"
      },
      "after": "03414091e8203222",
      "date": 1433832153885
    },
    {
      "type": "edit",
      "id": "637a0fe7338f3a7b",
      "item": {
        "type": "paragraph",
        "id": "637a0fe7338f3a7b",
        "text": "So, this is pretty bleak right? Well, only if you need to support old browsers (or Mobile Safari...), the rest of the environments have high resolution time! In Node it's 'process.hrtime()', and in the browser it is 'performance.now()'"
      },
      "date": 1433832281090
    },
    {
      "type": "edit",
      "id": "25288c9b5cec2126",
      "item": {
        "type": "paragraph",
        "id": "25288c9b5cec2126",
        "text": "So, if system time is altered in between two call Date.now() we have a meaningless relationship without even knowing it. We can even have cases where it appears that now is negative milliseconds after some time in the past. That is a really unhelpful result. And most systems have their time automatically adjusted regularly by services out of everyones control, it's not just a mischievous user setting the clock back to fool your timing, but automation who's sole job is to monkey with the system clock."
      },
      "date": 1433832497192
    },
    {
      "type": "edit",
      "id": "637a0fe7338f3a7b",
      "item": {
        "type": "paragraph",
        "id": "637a0fe7338f3a7b",
        "text": "So, this is pretty bleak right? Well, only if you need to support old browsers (or Mobile Safari...), the rest of the environments have high resolution time! In Node it's 'process.hrtime()', and in the browser it is 'performance.now()'. These both offer high resolution, and a genuine guarantee that two high res times will have meaning relative to each other."
      },
      "date": 1433832722114
    },
    {
      "type": "edit",
      "id": "637a0fe7338f3a7b",
      "item": {
        "type": "paragraph",
        "id": "637a0fe7338f3a7b",
        "text": "So, this is pretty bleak right? Well, only if you need to support old browsers (or Mobile Safari...), the rest of the environments have high resolution time! In Node it's 'process.hrtime()', and in the browser it is 'performance.now()'. These both offer high resolution, and a genuine guarantee that two high res times will have meaning relative to each other. Keep in mind these are both relative times though, not absolute, so don't think you can go replace all of your Date objects!"
      },
      "date": 1433833178805
    },
    {
      "type": "fork",
      "site": "nrn.io",
      "date": 1652868773400
    }
  ]
}