{
  "title": "2022-08-14",
  "story": [
    {
      "type": "paragraph",
      "id": "cc13ba9cf6817d62",
      "text": "Of Creative Leaps and Surviving Mistakes. [https://ralfbarkow.wordpress.com/2015/11/11/von-kreativen-spruengen-und-ueberlebenden-fehlern/ post] (de)"
    },
    {
      "type": "paragraph",
      "id": "1897a0c2271cc7ef",
      "text": "\"Even less helpful is the distinction between structure and process that is common in sociology. Apart from its obvious deficiencies – namely, that it captures neither the changeability of structures nor the structuredness of processes – it uses objectifying concepts of something fixed and something flowing, in the opposition of which the essence of time remains hidden.\""
    },
    {
      "type": "pagefold",
      "id": "0c31449a55117681",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "ef3ae660a9d5a6ba",
      "text": "[[Multiple Form Logic revisited]]. [https://ralfbarkow.wordpress.com/2007/05/19/multiple-form-logic-revisited-after-one-year/#more-159 post]"
    },
    {
      "type": "paragraph",
      "id": "bb7c46030fdff638",
      "text": "PILE v0.1 Notation. [https://ralfbarkow.wordpress.com/2006/06/28/pile-v01-notation/ post]"
    },
    {
      "type": "markdown",
      "id": "e3f2be65813cca4b",
      "text": "> […] **global Cp2 counter** […]"
    },
    {
      "type": "paragraph",
      "id": "67a50851f27a6f00",
      "text": "⇒ the successor function, +1 ⇒ [[One]]"
    },
    {
      "type": "paragraph",
      "id": "5120ba595dc41db4",
      "text": "\nHARDGRAVE, W. T., 1976. A technique for implementing a set processor. In: Proceedings of the 1976 conference on Data : Abstraction, definition and structure. Online. New York, NY, USA: Association for Computing Machinery. 1 March 1976. p. 86–94. [Accessed 13 August 2022]. ISBN 978-1-4503-7898-7. DOI 10.1145/800237.807126. "
    },
    {
      "type": "markdown",
      "id": "9a4430c0323ec93e",
      "text": "> Extended set theory is an effective method for describing the complex data structures needed to support large-scale data base applications. This paper describes the incorporation of the salient concepts of extended set theory into a general tool for the design and implementation of large-scale database systems. This tool is called a set processor. This implementation is based on the representation of sets of positive integers as bit strings and the application of the Cauchy/Cantor Diagonal Method.\n"
    },
    {
      "type": "paragraph",
      "id": "ffcec0510cd2e124",
      "text": "HARDGRAVE, W. Terry, 1978. Distributed database technology: An assessment. Information & Management. 1978. Vol. 1, no. 3, p. 157–167. \n"
    },
    {
      "type": "markdown",
      "id": "9a4c7c24aa05d7c3",
      "text": "> […] the term [[schema]] is used in two different, but closely related contexts. One interpi:etation of schema is the stored-data-definition. The other interpretation is an attempt to capture the human-user’s perception of the meaning of the data in the data-base. The latter interpretation is also called a logical view of the data-base. Most authors have recognized that an important aspect of data-base technology is the sharing of data among users and further, different users may hold somewhat different views of the same data."
    },
    {
      "type": "paragraph",
      "id": "f2bbdd25a868febc",
      "text": "The simple front-end/back-end analogy breaks down when the complexity of Interface languages is considered."
    },
    {
      "type": "paragraph",
      "id": "30e8c7689d9b8392",
      "text": "[[Statecharts]]: a visual formalism for complex systems. [https://www.sciencedirect.com/science/article/pii/0167642387900359 page]"
    },
    {
      "type": "markdown",
      "id": "38c752492cc6ae66",
      "text": "> Figure 35 shows the notation we use, including a squiggle to indicate that the state comes with a bound, an indication of the bound itself, and a generic event that stands for timeout(entered state, bound), where the state is the source of the transition, and the bound is its specified bound."
    },
    {
      "type": "paragraph",
      "id": "ee73c6ece9b5bf0f",
      "text": "\"Specification by diagram\""
    },
    {
      "type": "pagefold",
      "id": "1b23f9dfabd5c3c7",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "0e32cd657b271f64",
      "text": "Dai, Wenbin, Valeriy Vyatkin, James H. Christensen, und Victor N. Dubinin. „Bridging Service-Oriented Architecture and IEC 61499 for Flexibility and Interoperability“. IEEE Transactions on Industrial Informatics 11, Nr. 3 (Juni 2015): 771–81. https://doi.org/10.1109/TII.2015.2423495.\n"
    },
    {
      "type": "paragraph",
      "id": "b4ae68dd8d85ad52",
      "text": "⇒ [[Programmable Logic Controller]] ⇒ [[IDE4PLC]]  ⇒ [[Soft PLC]] ⇒ [[Dynamic Reconfiguration]] ⇒ [[PLC 3000]]"
    },
    {
      "type": "paragraph",
      "id": "4755b0c19b781c33",
      "text": "PLC3000 success story. [https://github.com/PharoJS/pharojs.github.io/commit/a03d4df7a576ff646ca8fd4eb3cc3b18f76a7d36 github]"
    },
    {
      "type": "paragraph",
      "id": "803303893efc27f4",
      "text": "PLC3000 is a Python3v progam for cross-platform application development PLC. [https://github.com/leraes93/App_Prologer/blob/1fcf6fa6c75d57d47386e1b22963e5bf745bff80/dist/Main8/bin/SampleMode/bin/ReadMe.txt github]"
    },
    {
      "type": "paragraph",
      "id": "10c94f671ca96103",
      "text": "WPS [https://updates.weg.net/wps/300/help/en_US/ page]"
    },
    {
      "type": "pagefold",
      "id": "06a54e42711cb2bf",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "4046fc4871fa4d61",
      "text": "⇒ [[AST Smalltalk]]"
    },
    {
      "type": "pagefold",
      "id": "07b1ebed606bc019",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "1723ee1af84bcd55",
      "text": "⇒ [[Base-Free Exponents]] ⇒ [[0000000010…]]"
    },
    {
      "type": "graphviz",
      "id": "6d60dbb42fb3a7de",
      "text": "DOT FROM lambda-browsing"
    },
    {
      "type": "markdown",
      "id": "ffc631343763f82d",
      "text": "[[Natural Numbers]]\n**depending upon the focus of the reader**:"
    },
    {
      "type": "paragraph",
      "id": "f457ffa40d864356",
      "text": "Vol. 1, p. 181:"
    },
    {
      "type": "paragraph",
      "id": "f5296a4843bed197",
      "text": "Explicit outermost boundaries explicitly locate the reader on the outside. Implicit outermost boundaries invite participation on the inside. On the page we actually have a series of nested boundaries or distinctions, each with a conventional meaning. The page itself distinguishes the book from its content. The page margin distinguishes typographical from non-typographical space. The boundary in Figure 7-1 distinguishes text from display. Each row in the figure distinguishes a numeral. The shellbracket distinguishes formal from informal text. Each of the round forms distinguishes a whole from nothing. Oh, and yes, this endnote is a clever mechanism to distinguish primary from incidental text, effectively extending the boundaries of the page containing the endnote marker into the endnote section. Had we been using footnotes rather than endnotes, the boundary of the incidental text would have been carved out of the original page."
    },
    {
      "type": "paragraph",
      "id": "c3544f05d52b2a49",
      "text": "⇒ [[Equality]] ⇒ [[IdentitySet]], #=="
    },
    {
      "type": "paragraph",
      "id": "aac54fcd7f3f2f93",
      "text": "Containers with equal contents are equal. "
    },
    {
      "type": "paragraph",
      "id": "898d97a34aff0926",
      "text": "Equals can be substituted for equals. "
    },
    {
      "type": "paragraph",
      "id": "079ec77eeee63083",
      "text": "Removing identical outer boundaries maintains equality. "
    },
    {
      "type": "paragraph",
      "id": "70ba41a1b04c8710",
      "text": "Removing equal contents maintains equality. "
    },
    {
      "type": "paragraph",
      "id": "be91b27745bc71c7",
      "text": "Equality is quantized dynamically by transformation steps. "
    },
    {
      "type": "paragraph",
      "id": "159254db0623b1fa",
      "text": "Forms change meaning only when they cross a boundary."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "2022-08-14",
        "story": []
      },
      "date": 1660441637704
    },
    {
      "item": {
        "type": "paragraph",
        "id": "cc13ba9cf6817d62",
        "text": "Of Creative Leaps and Surviving Mistakes. [https://ralfbarkow.wordpress.com/2015/11/11/von-kreativen-spruengen-und-ueberlebenden-fehlern/ post] (de)"
      },
      "id": "cc13ba9cf6817d62",
      "type": "add",
      "date": 1660441640252
    },
    {
      "type": "edit",
      "id": "cc13ba9cf6817d62",
      "item": {
        "type": "paragraph",
        "id": "cc13ba9cf6817d62",
        "text": "Of Creative Leaps and Surviving Mistakes. [https://ralfbarkow.wordpress.com/2015/11/11/von-kreativen-spruengen-und-ueberlebenden-fehlern/ post] (de)"
      },
      "date": 1660441647519
    },
    {
      "type": "edit",
      "id": "cc13ba9cf6817d62",
      "item": {
        "type": "paragraph",
        "id": "cc13ba9cf6817d62",
        "text": "Of Creative Leaps and Surviving Mistakes. [https://ralfbarkow.wordpress.com/2015/11/11/von-kreativen-spruengen-und-ueberlebenden-fehlern/ post] (de)"
      },
      "date": 1660441662103
    },
    {
      "item": {
        "type": "paragraph",
        "id": "1897a0c2271cc7ef",
        "text": "\"Even less helpful is the distinction between structure and process that is common in sociology. Apart from its obvious deficiencies - namely, that it captures neither the changeability of structures nor the structuredness of processes - it uses objectifying concepts of something fixed and something flowing, in the opposition of which the essence of time remains hidden.\""
      },
      "id": "1897a0c2271cc7ef",
      "type": "add",
      "after": "cc13ba9cf6817d62",
      "date": 1660441676198
    },
    {
      "type": "edit",
      "id": "1897a0c2271cc7ef",
      "item": {
        "type": "paragraph",
        "id": "1897a0c2271cc7ef",
        "text": "\"Even less helpful is the distinction between structure and process that is common in sociology. Apart from its obvious deficiencies - namely, that it captures neither the changeability of structures nor the structuredness of processes - it uses objectifying concepts of something fixed and something flowing, in the opposition of which the essence of time remains hidden.\""
      },
      "date": 1660441677657
    },
    {
      "item": {
        "type": "pagefold",
        "id": "0c31449a55117681",
        "text": "~"
      },
      "id": "0c31449a55117681",
      "type": "add",
      "after": "1897a0c2271cc7ef",
      "date": 1660442459152
    },
    {
      "type": "edit",
      "id": "0c31449a55117681",
      "item": {
        "type": "pagefold",
        "id": "0c31449a55117681",
        "text": "~"
      },
      "date": 1660442463361
    },
    {
      "item": {
        "type": "paragraph",
        "id": "bb7c46030fdff638",
        "text": "PILE v0.1 Notation. [https://ralfbarkow.wordpress.com/2006/06/28/pile-v01-notation/ post]"
      },
      "id": "bb7c46030fdff638",
      "type": "add",
      "after": "0c31449a55117681",
      "date": 1660442465183
    },
    {
      "type": "edit",
      "id": "bb7c46030fdff638",
      "item": {
        "type": "paragraph",
        "id": "bb7c46030fdff638",
        "text": "PILE v0.1 Notation. [https://ralfbarkow.wordpress.com/2006/06/28/pile-v01-notation/ post]"
      },
      "date": 1660442470517
    },
    {
      "type": "edit",
      "id": "bb7c46030fdff638",
      "item": {
        "type": "paragraph",
        "id": "bb7c46030fdff638",
        "text": "PILE v0.1 Notation. [https://ralfbarkow.wordpress.com/2006/06/28/pile-v01-notation/ post]"
      },
      "date": 1660442486482
    },
    {
      "item": {
        "type": "paragraph",
        "id": "ef3ae660a9d5a6ba",
        "text": "Multiple Form Logic revisited. [https://ralfbarkow.wordpress.com/2007/05/19/multiple-form-logic-revisited-after-one-year/#more-159 post]"
      },
      "id": "ef3ae660a9d5a6ba",
      "type": "add",
      "after": "bb7c46030fdff638",
      "date": 1660442496521
    },
    {
      "id": "ef3ae660a9d5a6ba",
      "type": "move",
      "order": [
        "cc13ba9cf6817d62",
        "1897a0c2271cc7ef",
        "0c31449a55117681",
        "ef3ae660a9d5a6ba",
        "bb7c46030fdff638"
      ],
      "date": 1660442500781
    },
    {
      "type": "edit",
      "id": "ef3ae660a9d5a6ba",
      "item": {
        "type": "paragraph",
        "id": "ef3ae660a9d5a6ba",
        "text": "Multiple Form Logic revisited. [https://ralfbarkow.wordpress.com/2007/05/19/multiple-form-logic-revisited-after-one-year/#more-159 post]"
      },
      "date": 1660442505672
    },
    {
      "type": "edit",
      "id": "ef3ae660a9d5a6ba",
      "item": {
        "type": "paragraph",
        "id": "ef3ae660a9d5a6ba",
        "text": "Multiple Form Logic revisited. [https://ralfbarkow.wordpress.com/2007/05/19/multiple-form-logic-revisited-after-one-year/#more-159 post]"
      },
      "date": 1660442541741
    },
    {
      "item": {
        "type": "markdown",
        "id": "e3f2be65813cca4b",
        "text": "> […] **global Cp2 counter** […]"
      },
      "id": "e3f2be65813cca4b",
      "type": "add",
      "after": "bb7c46030fdff638",
      "date": 1660442856442
    },
    {
      "type": "edit",
      "id": "e3f2be65813cca4b",
      "item": {
        "type": "markdown",
        "id": "e3f2be65813cca4b",
        "text": "> […] **global Cp2 counter** […]"
      },
      "date": 1660442885704
    },
    {
      "type": "edit",
      "id": "e3f2be65813cca4b",
      "item": {
        "type": "markdown",
        "id": "e3f2be65813cca4b",
        "text": "> […] **global Cp2 counter** […]"
      },
      "date": 1660442913805
    },
    {
      "item": {
        "type": "paragraph",
        "id": "67a50851f27a6f00",
        "text": "⇒ the successor function, +1 ⇒ [[One]]"
      },
      "id": "67a50851f27a6f00",
      "type": "add",
      "after": "e3f2be65813cca4b",
      "date": 1660442918407
    },
    {
      "type": "edit",
      "id": "67a50851f27a6f00",
      "item": {
        "type": "paragraph",
        "id": "67a50851f27a6f00",
        "text": "⇒ the successor function, +1 ⇒ [[One]]"
      },
      "date": 1660442922015
    },
    {
      "type": "edit",
      "id": "67a50851f27a6f00",
      "item": {
        "type": "paragraph",
        "id": "67a50851f27a6f00",
        "text": "⇒ the successor function, +1 ⇒ [[One]]"
      },
      "date": 1660442930976
    },
    {
      "type": "edit",
      "id": "67a50851f27a6f00",
      "item": {
        "type": "paragraph",
        "id": "67a50851f27a6f00",
        "text": "⇒ the successor function, +1 ⇒ [[One]]"
      },
      "date": 1660442951443
    },
    {
      "type": "edit",
      "id": "67a50851f27a6f00",
      "item": {
        "type": "paragraph",
        "id": "67a50851f27a6f00",
        "text": "⇒ the successor function, +1 ⇒ [[One]]"
      },
      "date": 1660442955622
    },
    {
      "item": {
        "type": "paragraph",
        "id": "5120ba595dc41db4",
        "text": "\nHARDGRAVE, W. T., 1976. A technique for implementing a set processor. In: Proceedings of the 1976 conference on Data : Abstraction, definition and structure. Online. New York, NY, USA: Association for Computing Machinery. 1 March 1976. p. 86–94. [Accessed 13 August 2022]. ISBN 978-1-4503-7898-7. DOI 10.1145/800237.807126. "
      },
      "id": "5120ba595dc41db4",
      "type": "add",
      "after": "67a50851f27a6f00",
      "date": 1660443356871
    },
    {
      "type": "edit",
      "id": "5120ba595dc41db4",
      "item": {
        "type": "paragraph",
        "id": "5120ba595dc41db4",
        "text": "\nHARDGRAVE, W. T., 1976. A technique for implementing a set processor. In: Proceedings of the 1976 conference on Data : Abstraction, definition and structure. Online. New York, NY, USA: Association for Computing Machinery. 1 March 1976. p. 86–94. [Accessed 13 August 2022]. ISBN 978-1-4503-7898-7. DOI 10.1145/800237.807126. "
      },
      "date": 1660443364160
    },
    {
      "type": "add",
      "id": "9a4430c0323ec93e",
      "item": {
        "type": "markdown",
        "id": "9a4430c0323ec93e",
        "text": "> Extended set theory is an effective method for describing the complex data structures needed to support large-scale data base applications. This paper describes the incorporation of the salient concepts of extended set theory into a general tool for the design and implementation of large-scale database systems. This tool is called a set processor. This implementation is based on the representation of sets of positive integers as bit strings and the application of the Cauchy/Cantor Diagonal Method.\n"
      },
      "after": "5120ba595dc41db4",
      "date": 1660443365497
    },
    {
      "type": "edit",
      "id": "9a4430c0323ec93e",
      "item": {
        "type": "markdown",
        "id": "9a4430c0323ec93e",
        "text": "> Extended set theory is an effective method for describing the complex data structures needed to support large-scale data base applications. This paper describes the incorporation of the salient concepts of extended set theory into a general tool for the design and implementation of large-scale database systems. This tool is called a set processor. This implementation is based on the representation of sets of positive integers as bit strings and the application of the Cauchy/Cantor Diagonal Method.\n"
      },
      "date": 1660443366789
    },
    {
      "item": {
        "type": "factory",
        "id": "ffcec0510cd2e124"
      },
      "id": "ffcec0510cd2e124",
      "type": "add",
      "after": "9a4430c0323ec93e",
      "date": 1660445343044,
      "error": {
        "type": "error",
        "msg": "Forbidden",
        "response": "Forbidden"
      }
    },
    {
      "type": "edit",
      "id": "ffcec0510cd2e124",
      "item": {
        "type": "paragraph",
        "id": "ffcec0510cd2e124",
        "text": "HARDGRAVE, W. Terry, 1978. Distributed database technology: An assessment. Information & Management. 1978. Vol. 1, no. 3, p. 157–167. \n"
      },
      "date": 1660445349229,
      "error": {
        "type": "error",
        "msg": "Forbidden",
        "response": "Forbidden"
      }
    },
    {
      "type": "fork",
      "date": 1660445351290,
      "error": {
        "type": "error",
        "msg": "Forbidden",
        "response": "Forbidden"
      }
    },
    {
      "type": "fork",
      "date": 1660445358995,
      "error": {
        "type": "error",
        "msg": "Forbidden",
        "response": "Forbidden"
      }
    },
    {
      "type": "fork",
      "date": 1660445370262,
      "error": {
        "type": "error",
        "msg": "Forbidden",
        "response": "Forbidden"
      }
    },
    {
      "type": "fork",
      "date": 1660445407172
    },
    {
      "item": {
        "type": "factory",
        "id": "9a4c7c24aa05d7c3"
      },
      "id": "9a4c7c24aa05d7c3",
      "type": "add",
      "after": "ffcec0510cd2e124",
      "date": 1660445445978
    },
    {
      "type": "edit",
      "id": "9a4c7c24aa05d7c3",
      "item": {
        "type": "markdown",
        "id": "9a4c7c24aa05d7c3",
        "text": "> […] the term schema is used in two different, but closely related contexts. One interpi:etation of schema is the storcddata-definition. The other interpretation is an attempt to capture the human-user’s perception of the meaning of the data in the data-base. The latter interpretation is also called a logical view of the data-base. Most authors have recognized that an important aspect of data-base technology is the sharing of data amasng users and further, different users may hold somewhat different views of the same data."
      },
      "date": 1660445458061
    },
    {
      "type": "edit",
      "id": "9a4c7c24aa05d7c3",
      "item": {
        "type": "markdown",
        "id": "9a4c7c24aa05d7c3",
        "text": "> […] the term schema is used in two different, but closely related contexts. One interpi:etation of schema is the stored-data-definition. The other interpretation is an attempt to capture the human-user’s perception of the meaning of the data in the data-base. The latter interpretation is also called a logical view of the data-base. Most authors have recognized that an important aspect of data-base technology is the sharing of data amasng users and further, different users may hold somewhat different views of the same data."
      },
      "date": 1660445476222
    },
    {
      "type": "edit",
      "id": "9a4c7c24aa05d7c3",
      "item": {
        "type": "markdown",
        "id": "9a4c7c24aa05d7c3",
        "text": "> […] the term schema is used in two different, but closely related contexts. One interpi:etation of schema is the stored-data-definition. The other interpretation is an attempt to capture the human-user’s perception of the meaning of the data in the data-base. The latter interpretation is also called a logical view of the data-base. Most authors have recognized that an important aspect of data-base technology is the sharing of data among users and further, different users may hold somewhat different views of the same data."
      },
      "date": 1660445505847
    },
    {
      "type": "fork",
      "date": 1660445761564
    },
    {
      "type": "edit",
      "id": "9a4c7c24aa05d7c3",
      "item": {
        "type": "markdown",
        "id": "9a4c7c24aa05d7c3",
        "text": "> […] the term [[schema]] is used in two different, but closely related contexts. One interpi:etation of schema is the stored-data-definition. The other interpretation is an attempt to capture the human-user’s perception of the meaning of the data in the data-base. The latter interpretation is also called a logical view of the data-base. Most authors have recognized that an important aspect of data-base technology is the sharing of data among users and further, different users may hold somewhat different views of the same data."
      },
      "date": 1660445776740
    },
    {
      "item": {
        "type": "factory",
        "id": "f2bbdd25a868febc"
      },
      "id": "f2bbdd25a868febc",
      "type": "add",
      "after": "9a4c7c24aa05d7c3",
      "date": 1660445940197
    },
    {
      "type": "edit",
      "id": "f2bbdd25a868febc",
      "item": {
        "type": "paragraph",
        "id": "f2bbdd25a868febc",
        "text": "The simple front-end/back-end analogy breaks down when the complexity of Interface languages is considered."
      },
      "date": 1660445943374
    },
    {
      "item": {
        "type": "factory",
        "id": "30e8c7689d9b8392"
      },
      "id": "30e8c7689d9b8392",
      "type": "add",
      "after": "f2bbdd25a868febc",
      "date": 1660446147115
    },
    {
      "type": "edit",
      "id": "30e8c7689d9b8392",
      "item": {
        "type": "paragraph",
        "id": "30e8c7689d9b8392",
        "text": "Statecharts: a visual formalism for complex systems"
      },
      "date": 1660446150250
    },
    {
      "type": "edit",
      "id": "30e8c7689d9b8392",
      "item": {
        "type": "paragraph",
        "id": "30e8c7689d9b8392",
        "text": "Statecharts: a visual formalism for complex systems. [https://www.sciencedirect.com/science/article/pii/0167642387900359 page]"
      },
      "date": 1660446161803
    },
    {
      "item": {
        "type": "factory",
        "id": "38c752492cc6ae66"
      },
      "id": "38c752492cc6ae66",
      "type": "add",
      "after": "30e8c7689d9b8392",
      "date": 1660446422636
    },
    {
      "type": "edit",
      "id": "38c752492cc6ae66",
      "item": {
        "type": "paragraph",
        "id": "38c752492cc6ae66",
        "text": "> Figure 35 shows the notation we use, including a squiggle to indicate that the state comes with a bound, an indication of the bound itself, and a generic event that stands for timeout(entered state, bound), where the state is the source of the transition, and the bound is its specified bound."
      },
      "date": 1660446425374
    },
    {
      "type": "edit",
      "id": "38c752492cc6ae66",
      "item": {
        "type": "markdown",
        "id": "38c752492cc6ae66",
        "text": "> Figure 35 shows the notation we use, including a squiggle to indicate that the state comes with a bound, an indication of the bound itself, and a generic event that stands for timeout(entered state, bound), where the state is the source of the transition, and the bound is its specified bound."
      },
      "date": 1660446426706
    },
    {
      "item": {
        "type": "factory",
        "id": "5d94be326dc7f9d3"
      },
      "id": "5d94be326dc7f9d3",
      "type": "add",
      "after": "38c752492cc6ae66",
      "date": 1660446467008
    },
    {
      "type": "edit",
      "id": "5d94be326dc7f9d3",
      "item": {
        "type": "paragraph",
        "id": "5d94be326dc7f9d3",
        "text": "\nHAREL, David, 1987. Statecharts: a visual formalism for complex systems. Science of Computer Programming. 1 June 1987. Vol. 8, no. 3, p. 231–274. DOI 10.1016/0167-6423(87)90035-9. "
      },
      "date": 1660446474690
    },
    {
      "type": "add",
      "id": "6e3f9109b4f6b8dd",
      "item": {
        "type": "paragraph",
        "id": "6e3f9109b4f6b8dd",
        "text": "> We present a broad extension of the conventional formalism of state machines and state diagrams, that is relevant to the specification and design of complex discrete-event systems, such as multi-computer real-time systems, communication protocols and digital control units. Our diagrams, which we call statecharts, extend conventional state-transition diagrams with essentially three elements, dealing, respectively, with the notions of hierarchy, concurrency and communication. These transform the language of state diagrams into a highly structured and economical description language. Statecharts are thus compact and expressive—small diagrams can express complex behavior—as well as compositional and modular. When coupled with the capabilities of computerized graphics, statecharts enable viewing the description at different levels of detail, and make even very large specifications manageable and comprehensible. In fact, we intend to demonstrate here that statecharts counter many of the objections raised against conventional state diagrams, and thus appear to render specification by diagrams an attractive and plausible approach. Statecharts can be used either as a stand-alone behavioral description or as part of a more general design methodology that deals also with the system’s other aspects, such as functional decomposition and data-flow specification. We also discuss some practical experience that was gained over the last three years in applying the statechart formalism to the specification of a particularly complex system.\n"
      },
      "after": "5d94be326dc7f9d3",
      "date": 1660446476120
    },
    {
      "type": "edit",
      "id": "6e3f9109b4f6b8dd",
      "item": {
        "type": "markdown",
        "id": "6e3f9109b4f6b8dd",
        "text": "> We present a broad extension of the conventional formalism of state machines and state diagrams, that is relevant to the specification and design of complex discrete-event systems, such as multi-computer real-time systems, communication protocols and digital control units. Our diagrams, which we call statecharts, extend conventional state-transition diagrams with essentially three elements, dealing, respectively, with the notions of hierarchy, concurrency and communication. These transform the language of state diagrams into a highly structured and economical description language. Statecharts are thus compact and expressive—small diagrams can express complex behavior—as well as compositional and modular. When coupled with the capabilities of computerized graphics, statecharts enable viewing the description at different levels of detail, and make even very large specifications manageable and comprehensible. In fact, we intend to demonstrate here that statecharts counter many of the objections raised against conventional state diagrams, and thus appear to render specification by diagrams an attractive and plausible approach. Statecharts can be used either as a stand-alone behavioral description or as part of a more general design methodology that deals also with the system’s other aspects, such as functional decomposition and data-flow specification. We also discuss some practical experience that was gained over the last three years in applying the statechart formalism to the specification of a particularly complex system.\n"
      },
      "date": 1660446477275
    },
    {
      "type": "edit",
      "id": "5d94be326dc7f9d3",
      "item": {
        "type": "paragraph",
        "id": "5d94be326dc7f9d3",
        "text": "HAREL, David, 1987. [[Statecharts]]: a visual formalism for complex systems. Science of Computer Programming. 1 June 1987. Vol. 8, no. 3, p. 231–274. DOI 10.1016/0167-6423(87)90035-9. "
      },
      "date": 1660446510908
    },
    {
      "id": "5d94be326dc7f9d3",
      "type": "remove",
      "date": 1660446522312
    },
    {
      "id": "6e3f9109b4f6b8dd",
      "type": "remove",
      "date": 1660446525758
    },
    {
      "type": "edit",
      "id": "30e8c7689d9b8392",
      "item": {
        "type": "paragraph",
        "id": "30e8c7689d9b8392",
        "text": "[[Statecharts]]: a visual formalism for complex systems. [https://www.sciencedirect.com/science/article/pii/0167642387900359 page]"
      },
      "date": 1660446538979
    },
    {
      "item": {
        "type": "factory",
        "id": "ee73c6ece9b5bf0f"
      },
      "id": "ee73c6ece9b5bf0f",
      "type": "add",
      "after": "38c752492cc6ae66",
      "date": 1660446670053
    },
    {
      "type": "edit",
      "id": "ee73c6ece9b5bf0f",
      "item": {
        "type": "paragraph",
        "id": "ee73c6ece9b5bf0f",
        "text": "\"Specification by diagram\""
      },
      "date": 1660446678409
    },
    {
      "type": "edit",
      "id": "1897a0c2271cc7ef",
      "item": {
        "type": "paragraph",
        "id": "1897a0c2271cc7ef",
        "text": "\"Even less helpful is the distinction between structure and process that is common in sociology. Apart from its obvious deficiencies – namely, that it captures neither the changeability of structures nor the structuredness of processes – it uses objectifying concepts of something fixed and something flowing, in the opposition of which the essence of time remains hidden.\""
      },
      "date": 1660446706478
    },
    {
      "item": {
        "type": "factory",
        "id": "1b23f9dfabd5c3c7"
      },
      "id": "1b23f9dfabd5c3c7",
      "type": "add",
      "after": "ee73c6ece9b5bf0f",
      "date": 1660465719041
    },
    {
      "type": "edit",
      "id": "1b23f9dfabd5c3c7",
      "item": {
        "type": "pagefold",
        "id": "1b23f9dfabd5c3c7",
        "text": "~"
      },
      "date": 1660465721975
    },
    {
      "item": {
        "type": "factory",
        "id": "ed6e9dbd3b6ca092"
      },
      "id": "ed6e9dbd3b6ca092",
      "type": "add",
      "after": "1b23f9dfabd5c3c7",
      "date": 1660465723518
    },
    {
      "type": "remove",
      "id": "ed6e9dbd3b6ca092",
      "date": 1660465727770
    },
    {
      "item": {
        "type": "factory",
        "id": "b4ae68dd8d85ad52"
      },
      "id": "b4ae68dd8d85ad52",
      "type": "add",
      "after": "1b23f9dfabd5c3c7",
      "date": 1660465730538
    },
    {
      "type": "edit",
      "id": "b4ae68dd8d85ad52",
      "item": {
        "type": "paragraph",
        "id": "b4ae68dd8d85ad52",
        "text": "Flexibility requirements are tightly intertwined with the implementation of functional and nonfunctional requirements. For example, even a standalone part of an automation system, such as a safety subsystem that is handling emergency situations, may require the reconfiguration of hardware or software. It is often the case that the safety subsystem needs updates to cover hazards discovered during system operation, which is done by the deployment of new software components to PLCs. Similarly, in airport baggage handling systems (BHSs), baggage screening policies are continuously improving to ensure safety and security. These new functionalities in the baggage screening process must be introduced without stopping systems in airports operating 24 h a day."
      },
      "date": 1660465733624
    },
    {
      "item": {
        "type": "factory",
        "id": "10c94f671ca96103"
      },
      "id": "10c94f671ca96103",
      "type": "add",
      "after": "b4ae68dd8d85ad52",
      "date": 1660466156196
    },
    {
      "type": "edit",
      "id": "10c94f671ca96103",
      "item": {
        "type": "paragraph",
        "id": "10c94f671ca96103",
        "text": "WPS [https://updates.weg.net/wps/300/help/en_US/ page]"
      },
      "date": 1660466169507
    },
    {
      "type": "add",
      "id": "4755b0c19b781c33",
      "item": {
        "type": "paragraph",
        "id": "4755b0c19b781c33",
        "text": "PLC3000 success story "
      },
      "after": "b4ae68dd8d85ad52",
      "date": 1660466225833
    },
    {
      "type": "edit",
      "id": "4755b0c19b781c33",
      "item": {
        "type": "paragraph",
        "id": "4755b0c19b781c33",
        "text": "PLC3000 success story. [https://github.com/PharoJS/pharojs.github.io/commit/a03d4df7a576ff646ca8fd4eb3cc3b18f76a7d36 github]"
      },
      "date": 1660466241383
    },
    {
      "type": "add",
      "id": "803303893efc27f4",
      "item": {
        "type": "paragraph",
        "id": "803303893efc27f4",
        "text": "PLC3000 is a Python3v progam for cross-platform application development PLC."
      },
      "after": "4755b0c19b781c33",
      "date": 1660466341651
    },
    {
      "type": "edit",
      "id": "803303893efc27f4",
      "item": {
        "type": "paragraph",
        "id": "803303893efc27f4",
        "text": "PLC3000 is a Python3v progam for cross-platform application development PLC. [https://github.com/leraes93/App_Prologer/blob/1fcf6fa6c75d57d47386e1b22963e5bf745bff80/dist/Main8/bin/SampleMode/bin/ReadMe.txt github]"
      },
      "date": 1660466356572
    },
    {
      "item": {
        "type": "factory",
        "id": "06a54e42711cb2bf"
      },
      "id": "06a54e42711cb2bf",
      "type": "add",
      "after": "10c94f671ca96103",
      "date": 1660467376857
    },
    {
      "type": "edit",
      "id": "06a54e42711cb2bf",
      "item": {
        "type": "pagefold",
        "id": "06a54e42711cb2bf",
        "text": "~"
      },
      "date": 1660467380067
    },
    {
      "item": {
        "type": "factory",
        "id": "4046fc4871fa4d61"
      },
      "id": "4046fc4871fa4d61",
      "type": "add",
      "after": "06a54e42711cb2bf",
      "date": 1660467381928
    },
    {
      "type": "edit",
      "id": "4046fc4871fa4d61",
      "item": {
        "type": "paragraph",
        "id": "4046fc4871fa4d61",
        "text": "[[AST Smalltalk]]"
      },
      "date": 1660467390599
    },
    {
      "type": "edit",
      "id": "b4ae68dd8d85ad52",
      "item": {
        "type": "paragraph",
        "id": "b4ae68dd8d85ad52",
        "text": "Flexibility requirements are tightly intertwined with the implementation of functional and nonfunctional requirements. For example, even a standalone part of an automation system, such as a safety subsystem that is handling emergency situations, may require the reconfiguration of hardware or software. It is often the case that the safety subsystem needs updates to cover hazards discovered during system operation, which is done by the deployment of new software components to [[PLC]]s. Similarly, in airport baggage handling systems (BHSs), baggage screening policies are continuously improving to ensure safety and security. These new functionalities in the baggage screening process must be introduced without stopping systems in airports operating 24 h a day."
      },
      "date": 1660467535744
    },
    {
      "type": "edit",
      "id": "b4ae68dd8d85ad52",
      "item": {
        "type": "paragraph",
        "id": "b4ae68dd8d85ad52",
        "text": "⇒ [[Programmable Logic Controller]]"
      },
      "date": 1660467563000
    },
    {
      "type": "add",
      "id": "0e32cd657b271f64",
      "item": {
        "type": "paragraph",
        "id": "0e32cd657b271f64",
        "text": "Flexibility requirements are tightly intertwined with the implementation of functional and nonfunctional requirements. For example, even a standalone part of an automation system, such as a safety subsystem that is handling emergency situations, may require the reconfiguration of hardware or software. It is often the case that the safety subsystem needs updates to cover hazards discovered during system operation, which is done by the deployment of new software components to [[PLC]]s. Similarly, in airport baggage handling systems (BHSs), baggage screening policies are continuously improving to ensure safety and security. These new functionalities in the baggage screening process must be introduced without stopping systems in airports operating 24 h a day."
      },
      "after": "b4ae68dd8d85ad52",
      "date": 1660467564982
    },
    {
      "type": "edit",
      "id": "4046fc4871fa4d61",
      "item": {
        "type": "paragraph",
        "id": "4046fc4871fa4d61",
        "text": "⇒ [[AST Smalltalk]]"
      },
      "date": 1660467573141
    },
    {
      "type": "add",
      "id": "97268edbfe2caa73",
      "item": {
        "type": "paragraph",
        "id": "97268edbfe2caa73",
        "text": " PLC 3000"
      },
      "after": "0e32cd657b271f64",
      "date": 1660467650005
    },
    {
      "type": "edit",
      "id": "97268edbfe2caa73",
      "item": {
        "type": "paragraph",
        "id": "97268edbfe2caa73",
        "text": "⇒ [[PLC 3000]]"
      },
      "date": 1660467660834
    },
    {
      "item": {
        "type": "factory",
        "id": "324cb169d7749927"
      },
      "id": "324cb169d7749927",
      "type": "add",
      "after": "4046fc4871fa4d61",
      "date": 1660467701825
    },
    {
      "id": "324cb169d7749927",
      "type": "move",
      "order": [
        "cc13ba9cf6817d62",
        "1897a0c2271cc7ef",
        "0c31449a55117681",
        "ef3ae660a9d5a6ba",
        "bb7c46030fdff638",
        "e3f2be65813cca4b",
        "67a50851f27a6f00",
        "5120ba595dc41db4",
        "9a4430c0323ec93e",
        "ffcec0510cd2e124",
        "9a4c7c24aa05d7c3",
        "f2bbdd25a868febc",
        "30e8c7689d9b8392",
        "38c752492cc6ae66",
        "ee73c6ece9b5bf0f",
        "1b23f9dfabd5c3c7",
        "b4ae68dd8d85ad52",
        "0e32cd657b271f64",
        "97268edbfe2caa73",
        "4755b0c19b781c33",
        "803303893efc27f4",
        "10c94f671ca96103",
        "324cb169d7749927",
        "06a54e42711cb2bf",
        "4046fc4871fa4d61"
      ],
      "date": 1660467704269
    },
    {
      "type": "edit",
      "id": "324cb169d7749927",
      "item": {
        "type": "paragraph",
        "id": "324cb169d7749927",
        "text": "[[IDE4PLC]]"
      },
      "date": 1660467711202
    },
    {
      "type": "edit",
      "id": "b4ae68dd8d85ad52",
      "item": {
        "type": "paragraph",
        "id": "b4ae68dd8d85ad52",
        "text": "⇒ [[Programmable Logic Controller]] ⇒ [[IDE4PLC]]"
      },
      "date": 1660467753552
    },
    {
      "type": "edit",
      "id": "324cb169d7749927",
      "item": {
        "type": "paragraph",
        "id": "324cb169d7749927",
        "text": "[[Soft PLC]]"
      },
      "date": 1660467774024
    },
    {
      "type": "remove",
      "id": "324cb169d7749927",
      "date": 1660467784179
    },
    {
      "type": "edit",
      "id": "b4ae68dd8d85ad52",
      "item": {
        "type": "paragraph",
        "id": "b4ae68dd8d85ad52",
        "text": "⇒ [[Programmable Logic Controller]] ⇒ [[IDE4PLC]]  ⇒ [[Soft PLC]]"
      },
      "date": 1660467792558
    },
    {
      "type": "edit",
      "id": "0e32cd657b271f64",
      "item": {
        "type": "paragraph",
        "id": "0e32cd657b271f64",
        "text": "Dai, Wenbin, Valeriy Vyatkin, James H. Christensen, und Victor N. Dubinin. „Bridging Service-Oriented Architecture and IEC 61499 for Flexibility and Interoperability“. IEEE Transactions on Industrial Informatics 11, Nr. 3 (Juni 2015): 771–81. https://doi.org/10.1109/TII.2015.2423495.\n"
      },
      "date": 1660467856348
    },
    {
      "type": "add",
      "id": "a8e571950497850c",
      "item": {
        "type": "paragraph",
        "id": "a8e571950497850c",
        "text": "Flexibility requirements are tightly intertwined with the implementation of functional and nonfunctional requirements. For example, even a standalone part of an automation system, such as a safety subsystem that is handling emergency situations, may require the reconfiguration of hardware or software. It is often the case that the safety subsystem needs updates to cover hazards discovered during system operation, which is done by the deployment of new software components to [[PLC]]s. Similarly, in airport baggage handling systems (BHSs), baggage screening policies are continuously improving to ensure safety and security. These new functionalities in the baggage screening process must be introduced without stopping systems in airports operating 24 h a day."
      },
      "after": "0e32cd657b271f64",
      "date": 1660467863134
    },
    {
      "type": "edit",
      "id": "b4ae68dd8d85ad52",
      "item": {
        "type": "paragraph",
        "id": "b4ae68dd8d85ad52",
        "text": "⇒ [[Programmable Logic Controller]] ⇒ [[IDE4PLC]]  ⇒ [[Soft PLC]] ⇒ [[Dynamic Reconfiguration]]"
      },
      "date": 1660468001198
    },
    {
      "id": "a8e571950497850c",
      "type": "remove",
      "date": 1660468322884
    },
    {
      "id": "0e32cd657b271f64",
      "type": "move",
      "order": [
        "cc13ba9cf6817d62",
        "1897a0c2271cc7ef",
        "0c31449a55117681",
        "ef3ae660a9d5a6ba",
        "bb7c46030fdff638",
        "e3f2be65813cca4b",
        "67a50851f27a6f00",
        "5120ba595dc41db4",
        "9a4430c0323ec93e",
        "ffcec0510cd2e124",
        "9a4c7c24aa05d7c3",
        "f2bbdd25a868febc",
        "30e8c7689d9b8392",
        "38c752492cc6ae66",
        "ee73c6ece9b5bf0f",
        "1b23f9dfabd5c3c7",
        "0e32cd657b271f64",
        "b4ae68dd8d85ad52",
        "97268edbfe2caa73",
        "4755b0c19b781c33",
        "803303893efc27f4",
        "10c94f671ca96103",
        "06a54e42711cb2bf",
        "4046fc4871fa4d61"
      ],
      "date": 1660468337513
    },
    {
      "type": "remove",
      "id": "97268edbfe2caa73",
      "date": 1660468349326
    },
    {
      "type": "edit",
      "id": "b4ae68dd8d85ad52",
      "item": {
        "type": "paragraph",
        "id": "b4ae68dd8d85ad52",
        "text": "⇒ [[Programmable Logic Controller]] ⇒ [[IDE4PLC]]  ⇒ [[Soft PLC]] ⇒ [[Dynamic Reconfiguration]] ⇒ [[PLC 3000]]"
      },
      "date": 1660468350764
    },
    {
      "item": {
        "type": "factory",
        "id": "07b1ebed606bc019"
      },
      "id": "07b1ebed606bc019",
      "type": "add",
      "after": "4046fc4871fa4d61",
      "date": 1660474507282
    },
    {
      "type": "edit",
      "id": "07b1ebed606bc019",
      "item": {
        "type": "pagefold",
        "id": "07b1ebed606bc019",
        "text": "~"
      },
      "date": 1660474510832
    },
    {
      "item": {
        "type": "factory",
        "id": "1723ee1af84bcd55"
      },
      "id": "1723ee1af84bcd55",
      "type": "add",
      "after": "07b1ebed606bc019",
      "date": 1660474513747
    },
    {
      "type": "edit",
      "id": "1723ee1af84bcd55",
      "item": {
        "type": "paragraph",
        "id": "1723ee1af84bcd55",
        "text": "⇒ [[Base-Free Exponents]]"
      },
      "date": 1660474516250
    },
    {
      "type": "edit",
      "id": "1723ee1af84bcd55",
      "item": {
        "type": "paragraph",
        "id": "1723ee1af84bcd55",
        "text": "⇒ [[Base-Free Exponents]] ⇒ [0000000010…]"
      },
      "date": 1660474583259
    },
    {
      "type": "edit",
      "id": "1723ee1af84bcd55",
      "item": {
        "type": "paragraph",
        "id": "1723ee1af84bcd55",
        "text": "⇒ [[Base-Free Exponents]] ⇒ [[0000000010…]]"
      },
      "date": 1660474591719
    },
    {
      "item": {
        "type": "factory",
        "id": "6d60dbb42fb3a7de"
      },
      "id": "6d60dbb42fb3a7de",
      "type": "add",
      "after": "1723ee1af84bcd55",
      "date": 1660474966597
    },
    {
      "type": "edit",
      "id": "6d60dbb42fb3a7de",
      "item": {
        "type": "graphviz",
        "id": "6d60dbb42fb3a7de",
        "text": "DOT FROM lambda-browsing"
      },
      "date": 1660474978014
    },
    {
      "type": "edit",
      "id": "ef3ae660a9d5a6ba",
      "item": {
        "type": "paragraph",
        "id": "ef3ae660a9d5a6ba",
        "text": "[[Multiple Form Logic revisited]]. [https://ralfbarkow.wordpress.com/2007/05/19/multiple-form-logic-revisited-after-one-year/#more-159 post]"
      },
      "date": 1660476429127
    },
    {
      "item": {
        "type": "factory",
        "id": "ffc631343763f82d"
      },
      "id": "ffc631343763f82d",
      "type": "add",
      "after": "6d60dbb42fb3a7de",
      "date": 1660476823507
    },
    {
      "type": "edit",
      "id": "ffc631343763f82d",
      "item": {
        "type": "paragraph",
        "id": "ffc631343763f82d",
        "text": "Explicit outermost boundaries explicitly locate the reader on the outside. Implicit outermost boundaries invite participation on the inside. On the page we actually have a series of nested boundaries or distinctions, each with a conventional meaning. The page itself distinguishes the book from its content. The page margin distinguishes typographical from non-typographical space. The boundary in Figure 7-1 distinguishes text from display. Each row in the figure distinguishes a numeral. The shellbracket distinguishes formal from informal text. Each of the round forms distinguishes a whole from nothing. Oh, and yes, this endnote is a clever mechanism to distinguish primary from incidental text, effectively extending the boundaries of the page containing the endnote marker into the endnote section. Had we been using footnotes rather than endnotes, the boundary of the incidental text would have been carved out of the original page."
      },
      "date": 1660476831390
    },
    {
      "type": "edit",
      "id": "ffc631343763f82d",
      "item": {
        "type": "paragraph",
        "id": "ffc631343763f82d",
        "text": "Vol. 1, p. 181:"
      },
      "date": 1660476853069
    },
    {
      "type": "add",
      "id": "f5296a4843bed197",
      "item": {
        "type": "paragraph",
        "id": "f5296a4843bed197",
        "text": "Explicit outermost boundaries explicitly locate the reader on the outside. Implicit outermost boundaries invite participation on the inside. On the page we actually have a series of nested boundaries or distinctions, each with a conventional meaning. The page itself distinguishes the book from its content. The page margin distinguishes typographical from non-typographical space. The boundary in Figure 7-1 distinguishes text from display. Each row in the figure distinguishes a numeral. The shellbracket distinguishes formal from informal text. Each of the round forms distinguishes a whole from nothing. Oh, and yes, this endnote is a clever mechanism to distinguish primary from incidental text, effectively extending the boundaries of the page containing the endnote marker into the endnote section. Had we been using footnotes rather than endnotes, the boundary of the incidental text would have been carved out of the original page."
      },
      "after": "ffc631343763f82d",
      "date": 1660476855130
    },
    {
      "type": "edit",
      "id": "ffc631343763f82d",
      "item": {
        "type": "paragraph",
        "id": "ffc631343763f82d",
        "text": "20. depending upon the focus of the reader:"
      },
      "date": 1660476970699
    },
    {
      "type": "add",
      "id": "f457ffa40d864356",
      "item": {
        "type": "paragraph",
        "id": "f457ffa40d864356",
        "text": "Vol. 1, p. 181:"
      },
      "after": "ffc631343763f82d",
      "date": 1660476975783
    },
    {
      "type": "edit",
      "id": "ffc631343763f82d",
      "item": {
        "type": "paragraph",
        "id": "ffc631343763f82d",
        "text": "20. **depending upon the focus of the reader**:"
      },
      "date": 1660476985233
    },
    {
      "type": "edit",
      "id": "ffc631343763f82d",
      "item": {
        "type": "markdown",
        "id": "ffc631343763f82d",
        "text": "20. **depending upon the focus of the reader**:"
      },
      "date": 1660476990322
    },
    {
      "type": "edit",
      "id": "ffc631343763f82d",
      "item": {
        "type": "markdown",
        "id": "ffc631343763f82d",
        "text": "**depending upon the focus of the reader**:"
      },
      "date": 1660477001404
    },
    {
      "type": "edit",
      "id": "ffc631343763f82d",
      "item": {
        "type": "markdown",
        "id": "ffc631343763f82d",
        "text": "[[Natural Numbers]]\n**depending upon the focus of the reader**:"
      },
      "date": 1660477143306
    },
    {
      "item": {
        "type": "factory",
        "id": "c3544f05d52b2a49"
      },
      "id": "c3544f05d52b2a49",
      "type": "add",
      "after": "f5296a4843bed197",
      "date": 1660501072522
    },
    {
      "type": "edit",
      "id": "c3544f05d52b2a49",
      "item": {
        "type": "paragraph",
        "id": "c3544f05d52b2a49",
        "text": "[[Equality]]"
      },
      "date": 1660501079716
    },
    {
      "type": "edit",
      "id": "c3544f05d52b2a49",
      "item": {
        "type": "paragraph",
        "id": "c3544f05d52b2a49",
        "text": "[[Equality]] – [[IdentitySet]]"
      },
      "date": 1660501099772
    },
    {
      "type": "edit",
      "id": "c3544f05d52b2a49",
      "item": {
        "type": "paragraph",
        "id": "c3544f05d52b2a49",
        "text": "[[Equality]] ⇒ [[IdentitySet]]"
      },
      "date": 1660501107070
    },
    {
      "type": "edit",
      "id": "c3544f05d52b2a49",
      "item": {
        "type": "paragraph",
        "id": "c3544f05d52b2a49",
        "text": "[[Equality]] ⇒ [[IdentitySet]], #=="
      },
      "date": 1660501121750
    },
    {
      "type": "edit",
      "id": "c3544f05d52b2a49",
      "item": {
        "type": "paragraph",
        "id": "c3544f05d52b2a49",
        "text": "⇒ [[Equality]] ⇒ [[IdentitySet]], #=="
      },
      "date": 1660501130673
    },
    {
      "item": {
        "type": "factory",
        "id": "aac54fcd7f3f2f93"
      },
      "id": "aac54fcd7f3f2f93",
      "type": "add",
      "after": "c3544f05d52b2a49",
      "date": 1660501139668
    },
    {
      "type": "edit",
      "id": "aac54fcd7f3f2f93",
      "item": {
        "type": "paragraph",
        "id": "aac54fcd7f3f2f93",
        "text": "Containers with equal contents are equal. Equals can be substituted for equals. Removing identical outer boundaries maintains equality. Removing equal contents maintains equality. Equality is quantized dynamically by transformation steps. Forms change meaning only when they cross a boundary."
      },
      "date": 1660501141249
    },
    {
      "type": "edit",
      "id": "aac54fcd7f3f2f93",
      "item": {
        "type": "paragraph",
        "id": "aac54fcd7f3f2f93",
        "text": "Containers with equal contents are equal. "
      },
      "date": 1660501146424
    },
    {
      "type": "add",
      "id": "898d97a34aff0926",
      "item": {
        "type": "paragraph",
        "id": "898d97a34aff0926",
        "text": "Equals can be substituted for equals. "
      },
      "after": "aac54fcd7f3f2f93",
      "date": 1660501150986
    },
    {
      "type": "add",
      "id": "079ec77eeee63083",
      "item": {
        "type": "paragraph",
        "id": "079ec77eeee63083",
        "text": "Removing identical outer boundaries maintains equality. Removing equal contents maintains equality. Equality is quantized dynamically by transformation steps. Forms change meaning only when they cross a boundary."
      },
      "after": "898d97a34aff0926",
      "date": 1660501151542
    },
    {
      "type": "edit",
      "id": "079ec77eeee63083",
      "item": {
        "type": "paragraph",
        "id": "079ec77eeee63083",
        "text": "Removing identical outer boundaries maintains equality. "
      },
      "date": 1660501156619
    },
    {
      "type": "add",
      "id": "70ba41a1b04c8710",
      "item": {
        "type": "paragraph",
        "id": "70ba41a1b04c8710",
        "text": "Removing equal contents maintains equality. Equality is quantized dynamically by transformation steps. Forms change meaning only when they cross a boundary."
      },
      "after": "079ec77eeee63083",
      "date": 1660501157251
    },
    {
      "type": "edit",
      "id": "70ba41a1b04c8710",
      "item": {
        "type": "paragraph",
        "id": "70ba41a1b04c8710",
        "text": "Removing equal contents maintains equality. "
      },
      "date": 1660501162131
    },
    {
      "type": "add",
      "id": "be91b27745bc71c7",
      "item": {
        "type": "paragraph",
        "id": "be91b27745bc71c7",
        "text": "Equality is quantized dynamically by transformation steps. "
      },
      "after": "70ba41a1b04c8710",
      "date": 1660501165923
    },
    {
      "type": "add",
      "id": "159254db0623b1fa",
      "item": {
        "type": "paragraph",
        "id": "159254db0623b1fa",
        "text": "Forms change meaning only when they cross a boundary."
      },
      "after": "be91b27745bc71c7",
      "date": 1660501166441
    }
  ]
}