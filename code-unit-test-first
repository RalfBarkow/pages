{
  "title": "Code Unit Test First",
  "story": [
    {
      "type": "html",
      "text": "Rule: [[Never Writea Line Of Code Withouta Failing Test]]. ",
      "id": "13c6866e3bff7fdd5cfdf2921dd92b20"
    },
    {
      "type": "html",
      "text": "\nThe interface & output of an object are more important than its implementation, so write the former first, in terms of code trying to exercise it. ",
      "id": "3fd4c27a3ed93dfef8467630608c2852"
    },
    {
      "type": "html",
      "text": "\nSee [[Code Unit Test First Example]], [[Test First Design]], [[Test Driven Programming]], [[Test Driven Development]], [[Write Just One Test]], [[One Unit Test Ata Time]] ",
      "id": "936e4d764ce87519e1ea17e9ed0d7b88"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "Here is a really good way to develop new functionality: ",
      "id": "e002a5e519778a344fc87473ac024722"
    },
    {
      "type": "html",
      "text": " Find out what you have to do. ",
      "id": "10a817eb301d172323b8049c0066b088"
    },
    {
      "type": "html",
      "text": " Write a [[Unit Test]] for the desired new capability. Pick the smallest increment of new capability you can think of. ",
      "id": "a8a458c807051431af25acfd10468cde"
    },
    {
      "type": "html",
      "text": " Run the [[Unit Test]]. If it succeeds, you're done; go to step 1, or if you are completely finished, go home. ",
      "id": "88e71a62a924ee136d948ec1eca2d1bd"
    },
    {
      "type": "html",
      "text": "4. Fix the immediate problem:<br>maybe it's the fact that you didn't write the new method yet. Maybe the method doesn't quite work. Fix whatever it is. Go to step 3. ",
      "id": "c52d68d0a8781eb8700592ed27cf4d50"
    },
    {
      "type": "html",
      "text": "\nA key aspect of this process: don't try to implement two things at a time, don't try to fix two things at a time. Just do one. ",
      "id": "b5b4daeec7e27e80f637455610f83a8b"
    },
    {
      "type": "html",
      "text": "\nWhen you get this right, development turns into a very pleasant cycle of testing, seeing a simple thing to fix, fixing it, testing, getting positive feedback all the way. ",
      "id": "d2f7b4c0e9e0223897be5c4e6a3e9bff"
    },
    {
      "type": "html",
      "text": "\nGuaranteed flow. And you go so fast! ",
      "id": "508a2c94a909c53df8d397bc552f4e61"
    },
    {
      "type": "html",
      "text": "\nTry it, you'll like it. ",
      "id": "08117e410545ba1010f443f45c193bfb"
    },
    {
      "type": "html",
      "text": "-- [[Ron Jeffries]] ",
      "id": "8e5905b5532a0023cea0920b5174e7a7"
    },
    {
      "type": "html",
      "text": "\nDoesn't step 1 imply [[Acceptance Tests First]]? -- [[John Whitlock]]",
      "id": "b98760af8cf74e868fd3848e4ab1df7b"
    },
    {
      "type": "html",
      "text": "\nThe way I work, yes. I typically write a [[Cucumber Framework]] story and watch <i>that</i> fail before writing a [[Unit Test]] for my implementation. --[[Marnen Laibow Koser]], 14 April 2011",
      "id": "c1c2fc9f3bff29acbf0dc90077708333"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "When you run a test, if it works, check the test and all your changes into your version control system (with a meaningful comment). Then you're done. -- [[Dave Whipp]] ",
      "id": "1f7a78c01c83f1ea78bc95d17f2df811"
    },
    {
      "type": "html",
      "text": "\nNo. These tests and increments are too small. Do the checkin after you've done a few hours of work (or less if you have a very well automated checkin process that's quick and easy). -- unsigned",
      "id": "03b66744d989ac461ce8d065c924b2d5"
    },
    {
      "type": "html",
      "text": "<i>Why? Small checkins make it easier to just pick the changes you actually wanted when merging. --[[Marnen Laibow Koser]], 14 April 2011</i>",
      "id": "6b8107fc701f25ea08ea5e7bb8706548"
    },
    {
      "type": "html",
      "text": "\nI do as Dave does, waiting a few hours to checkin just increases the chance of a conflict or that I will lose a few hours of work rather than ten minutes worth. So I like to checkin all the time, and would suggest you do the same, unless your checkin process is slow and hard (in which case my advice is you had better make it quick and easy). -- [[Erik Meade]].",
      "id": "9c12069218eb6ac392cb3fa3c13d449f"
    },
    {
      "type": "html",
      "text": "\nI am not sure of all the advantages of checking in every change. But one is you can count line of code(LOC) changes (added, modified, deleted, etc). This counting could be automated by the Version Controler. A change control like [[Change Log]] can help this case. -- [[Alex Vicente]]",
      "id": "4eadab21f449642965c4276b725cb752"
    },
    {
      "type": "html",
      "text": "\nSee [[Extreme Version Control]]",
      "id": "611e579b9fd79613ff5a1835c19b2a19"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "Do you ever write all the [[Unit Test]]s for a class before starting to implement the class? Do you ever have a [[Master Programmer]] write the [[Unit Test]]s and a [[Grunt Programmer]] change the system to satisfy them? Do you ever use [[Unit Test]]s as specifications? ",
      "id": "754bb26b939c8dd414fa00f83fff87cd"
    },
    {
      "type": "html",
      "text": "\nI'm expecting the answer \"No\". The very notion of a [[Grunt Programmer]] is probably antithetical to XP, that division of labour being superseded by [[Pair Programming]]. I thought I'd ask, to check, and to get the answers explicit and on the record. I'm currently coming at this from the direction of [[Design By Contract]] and assertions. -- [[Dave Harris]] ",
      "id": "64ce0815fa93bc80f3c86efe467128ae"
    },
    {
      "type": "html",
      "text": "\nWe generally don't do those things. Since we practice [[You Arent Gonna Need It]], we couldn't in general write all the [[Unit Test]]s for a class. We do sometimes write a batch of [[Unit Test]]s for some piece of functionality we're working on, especially if they are all variations on a theme. For example: check SUB with one day less than the max, at the max, one day more. ",
      "id": "e36c926cd18eb8d0d5cd4ae5aa1eed73"
    },
    {
      "type": "html",
      "text": "\nWe might well invite a [[Master Programmer]] to sit with us for some hard bit. In general we strive to have everyone cross-trained on everything. Even so there are areas of model or infrastructure expertise. Personally I believe that there are some short-term advantages in specialization, and I'm sorely tempted to use specialization in times of stress. Sorting out what is going wrong with our process and getting it back on track seems to work better. ",
      "id": "3f6017afee286fcfad2b6ef01d6d3155"
    },
    {
      "type": "html",
      "text": "\nBut some people seem better at design, at seeing consequences faster, while others are better at painstaking programming. In theory, specialization would allow each to do his best. Does [[Chrysler Comprehensive Compensation]] take it as an axiom that [[Pair Programming]] is always better? -- [[Aamod Sane]] ",
      "id": "b0aba1a0deb552db8f6d9d06194c5814"
    },
    {
      "type": "html",
      "text": "\nNo, they took it as a hypothesis, tested it, and found that the more they paired, the faster they went and the fewer problems they caused. I showed them how to do it. Taking it to such ridiculous extremes was their idea. And it works ... -- [[Kent Beck]] ",
      "id": "9e878683de08ca443ca92b39f975b23a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "[[Code Unit Test First]]. Why don't people like testing? Well, the traditional way of testing is tough to take. You write what seems to be perfectly sensible code, then you write a test and the test tells you that you failed. No one wants to hear that. ",
      "id": "d03ddf7bb935cbe6db72fcce703e87e8"
    },
    {
      "type": "html",
      "text": "\nLet's turn it around. Write the test first; run it. Of course it fails.. You haven't written the code under test yet. Start writing code.. keep testing. Soon, the test will tell you that you've succeeded! ",
      "id": "a2e4d51b999bbbfac3ef42299d9b03c2"
    },
    {
      "type": "html",
      "text": "-- [[Michael Feathers]] ",
      "id": "231a922dc382df497a4b72630f3a7a23"
    },
    {
      "type": "html",
      "text": "\nNice, Michael! That really captures what [[Test Driven Programming]] feels like. It really is a blast to do! -- [[Kiel Hodges]] ",
      "id": "76cf2db5136b0ee139aa561d2c91c82d"
    },
    {
      "type": "html",
      "text": "<i>Michael, let me get this straight. You write a test and you know it will fail, since you haven't written any code for it to pass. So you run it anyway knowing it will fail. Here's a hint: you don't need to run that test, because it will fail. you know the outcome of that test so there is no reason to run it first. Running it only proves that you prefer wasting time. You know it will fail, so there is no reason for the test to be run. The only reason you would want to run the test is if there was a reason to run the test. There isn't one.  A religious ritual of running the test for no reason could be created, but it wouldn't serve any purpose other than religious.  Software programming has certainly turned into Quackery. Sad.</i>",
      "id": "2933481a3398322f7ee92823bb3e63bc"
    },
    {
      "type": "html",
      "text": " [Actually there is a purpose in running that test before you write the code.  It verifies that the test can fail.  There are bugs in tests too, so having some built in sanity checks are not a bad thing.]",
      "id": "851b774a616eac914bdbfdc9759d5dcb"
    },
    {
      "type": "html",
      "text": " There's another purpose too. It sometimes happens that I write a test for what I believe is new functionality. When I run it, it passes. After making sure that my test is correctly written, I discover that the functionality I thought was new was, in fact, already in the system -- so I don't need to write any new code to implement it! In cases like this, the habit of watching the test fail saves me lots of work. --[[Marnen Laibow Koser]], 6 Apr 2013",
      "id": "2aa275a850bfdb00b840b05e83f3fc64"
    },
    {
      "type": "html",
      "text": "\nAnother (apparently overlooked) benefit of coding the [[Unit Test]] first is that you get to test the [[Unit Test]]. When it says your code failed (because it wasn't written yet), the [[Unit Test]] has itself succeeded. -- [[Eric Scouten]] ",
      "id": "64ef096a2598d8c644f86bb991099eac"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "In a static language, the compiler/type-checker does some of the job of [[Unit Test]]s. Thus instead of running the tests, you attempt a compile (or a link). Now the compile fails because the method doesn't exist yet. Never mind - continue as for step 3. -- [[Dave Harris]] ",
      "id": "d05afb1d9ba20dc53a6f24723d364e57"
    },
    {
      "type": "html",
      "text": "\nThat was very much my experience with [[Modula Three]] ([http://www.research.digital.com/SRC/modula-3/html/home.html www.research.digital.com]) which had the nicest type system I've come across. You sometimes have to work a bit to get the types in your program lined up, but once you do the code usually just works. -- [[Steve Freeman]] ",
      "id": "5bdb65b97b656f7bb76a3e18456b5d9e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "Another strong advantage of writing [[Unit Test]]s as early as appropriate is that you can use [[Unit Test As Documentation]] - if they're written properly, they provide a great example for people who have to use or work on the code later. -- [[Martin Pool]] ",
      "id": "122202dff34ab226b90c54fde3fc98da"
    },
    {
      "type": "html",
      "text": "\nIt struck me last night while painting a wall: [[Code Unit Test First]] is the programming equivalent of using masking tape and drop cloths. On the surface it doesn't look like you're making \"progress\", but the safety it gives you lets you work faster and safer. -- [[Rob Crawford]] ",
      "id": "bfbedadef3f12a103dcb2c019adb591a"
    },
    {
      "type": "html",
      "text": "\nUmm .. isn't that a negative example?  In XP you start by painting, drip some, and then fix the problem.  If you start with drop cloths and you finish painting,  and then find them all clean, then you have violated YAGNI.  Your example seems to justify [[Planning Ahead]]  which is the right thing to do when you're painting a house, because your requirements are fixed. -- [[Nissim Hadar]]",
      "id": "31566b9ef6d83c98dd77b65dfbc9e309"
    },
    {
      "type": "html",
      "text": "<i>Another example is a technique used for drawing life-like pictures of just about anything. The idea is to focus your awareness on the Negative Spaces of your subject. By focusing on the negative, you trick your mind in not making assumptions about your subject, and your mind becomes aware of the true shape of your subject. See [[Drawing On The Right Side Of The Brain]] by Betty Edwards.</i>",
      "id": "f51016f90c059dce63290a16dc0693a2"
    },
    {
      "type": "html",
      "text": "<i>For a beginning artist, the results of this technique are shockingly effective. And this analogy of life-like drawing is so fitting to Extreme Programming -- I think a comparison of the before-and-after drawing of someone using this technique would make a persuasive book cover for [[Extreme Programming]]. For a better and fuller description of this technique, read any book by Betty Edwards on the subject of drawing . -- [[Stephan Branczyk]]</i>",
      "id": "857e6a04830e7d697fd90512d6ea0bfe"
    },
    {
      "type": "html",
      "text": "\nHow can you say that a test is the same as negative space? A test represents a positive intent.",
      "id": "072b6455089c74e5cf4ffd1bedb3dfa5"
    },
    {
      "type": "html",
      "text": "<i>\"Negative space\" in the context of drawing doesn't map to \"failure conditions\" in programming.  If you have a nameable object (like a book) leaning against another nameable object (like a wall), negative space means instead of drawing the book (positive space) and the wall (positive space), you draw the area between them (negative space) first.  The result is you get a boundary for your book and boundary for your wall before you start drawing them.  The reason is that when we have a name for something, it's usually attached to a generic model in our heads, but that generic model isn't a very good representation, because it's so vague.  Just a sketch, really, even though we give it a lot more credit.  By starting with an unnamed (and hence, unstored) shape, we have to focus on each angle, edge and proportion for this particular instance, because we don't \"know\" what it's \"supposed\" to look like.  When you then draw the positive shapes, you can't slip into automatic mode, because they won't fit the edges you've already defined.  It really is a ground-breaking technique.</i>",
      "id": "eb31458f93c9a72157c40a5281b1a724"
    },
    {
      "type": "html",
      "text": "<i>In programming, the [[Use Case]]s you start with (and implement as [[Unit Test]]s) are the negative space, in the sense that they're not your code, they're the stuff your code needs to fit against.  Your code is the positive space, but if it doesn't match every nook and cranny of the [[Use Case]]s, the code's not right.  When you start with the code, you might be tempted to think, \"I know what a file reader class should do, I'll just slap one together!\" and end up missing some bits that are required by this particular project.  Working from the [[Use Case]] (implemented as [[Unit Test]]s) inward, you define the edges and ensure that the code you eventually write matches this project's requirements precisely.</i>",
      "id": "aca370b153258bcd1de50e137f31f198"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "Another advantage of coding tests first is that tests exert a beneficial influence on the design. The tests themselves become additional users of your class interface, which ameliorates the problem of \"you can't reuse code before you've at least used the code once\" - because you start, right off the bat, with at least one extra user of each class. ",
      "id": "2dc5dff02baea68c36af5be3a8baad8c"
    },
    {
      "type": "html",
      "text": "\nConcrete example: you need to test code which (usually) takes input from an external device. But the device is not present during testing. So, in order to code [[Unit Test]]s, you are forced to create an interface for your code to talk to: one implemented for the real device, and another implemented for the \"fake\" testing device. Having done that, you're in a much better position to further implement the interface for multiple other devices. ",
      "id": "99ec97dbc9223b16c8506c85f000a36a"
    },
    {
      "type": "html",
      "text": "-- [[Pieter Nagel]] ",
      "id": "0ce3766bba934f6b64eb67c55ae52ba1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "How do you adapt [[Unit Test]]ing, in the more realistic scenario, where you are adding functionality to an existing product? Do you unit code retroactively or just for new units? The advantage of the first approach is, you may catch errors that were previously overlooked. The advantage of the latter is you save time and focus on where errors are likely to occur. -- [[Cayte Lindner]] ",
      "id": "4a10fe2f584e9c5eeb40a0f8c540b3ac"
    },
    {
      "type": "html",
      "text": "\nBefore you change a method, you have to write a test for what you think it does. Either it runs, and then you're sure that you aren't breaking anything, or it doesn't work, and you learn something about what the code does.",
      "id": "5a86261c7ff7964d3f354e32f2407e63"
    },
    {
      "type": "html",
      "text": "(Unless the design is a mess, the function has side effects you don't detect and don't capture in the unit test, and thus have a false sense of confidence in your unit test.)",
      "id": "1e83fe94373bd301233f2a81bb6b14a3"
    },
    {
      "type": "html",
      "text": "\nWriting \"retroactive\" tests on demand reduces the amount of up-front investment (you won't ever get permission to spend two months writing tests). It also makes sure that the most rapidly changing code is tested soonest. ",
      "id": "66e2f169c4fda3b543ddd46666b38d93"
    },
    {
      "type": "html",
      "text": "\nNew code gets tested as above. ",
      "id": "b59c55d4c4f457f28e84f11dc2408eda"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "What is a good way to organize [[Unit Test]]s for a non-trivial project? Does one usually write a whole slew of tiny test programs, or are they usually amalgamated into a \"test app\"? -- [[Maciej Kalisiak]] ",
      "id": "e92e25d68da9bbf4f486ac0da3e632b2"
    },
    {
      "type": "html",
      "text": "\nLots of small [[Unit Test]]s are generally added to larger [[Test Suite]]s.",
      "id": "d14fb587deefe3b8b6d695b1e34dc1fe"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "Questions: ",
      "id": "f44c71aca7c6dbf44b751304c01d4c34"
    },
    {
      "type": "html",
      "text": " What if your application has a heavy GUI? ",
      "id": "9d7ce19e7c44f8b13d3e78127ea0981d"
    },
    {
      "type": "html",
      "text": " How do you [[Code Unit Test First]]? ",
      "id": "5d2a043389da0719a06ba4e7e6c6f7e7"
    },
    {
      "type": "html",
      "text": " How do you [[Unit Test]]s at all? ",
      "id": "e6aa5375ae562e178822c73d19c897df"
    },
    {
      "type": "html",
      "text": " There are a number of good automated tools on the market for testing GUIs, but they generally compare the GUI with the results of a previously successful run, that you checked by hand; you can't write the test first. ",
      "id": "9ca023286ee0040cf6fd7526c83c9fcf"
    },
    {
      "type": "html",
      "text": "\nThe best HTML testing strategy I've seen (thanks to [[Massimo Arnoldi]] and the folks at [[Life Ware]]) is to regression test the HTML, then [[Unit Test]] everything under the hood. Since there is only one way to see if HTML is \"correct\", that is, look at it in every browser you care about, the best you can do is run a test that produces a page, manually verify that it is satisfactory, then set up the test so you are notified if the results ever change. When they change, you have to manually verify again, so you don't want lots of these tests, you want to test most of the variations with finer-grained tests. However, you can write a tool that will shoot the HTML to IE and Netscape, then save it somewhere if you say everything is OK. -- [[Kent Beck]] ",
      "id": "7478ec27e653e7324c5864ba3101dd3b"
    },
    {
      "type": "html",
      "text": "\nI just did a toy case of this - a Perl CGI that produces a 30-day, free-trial [[Jera Works]] license certificate. While developing, I ran the CGI in offline mode, and just piped the output to the input of a shell-based Java program. Programming consisted of modifying the Java code to use the new feature (like including Product Name in the license cookie), and then modifying the Perl code to generate the new feature that the Java code was testing for. Development was fast and fluid. Deployment was very smooth for a CGI. The only semi-major defect I found was that I hadn't uncommented the line \"use CGI qw(carp);\", which was disabled for offline testing. -- [[John Brewer]] ",
      "id": "729ec66567d2705d3a4b35fa00090e7d"
    },
    {
      "type": "html",
      "text": "\nWhat about [[Micro Soft]] [[Active Server Pages]] (ASP), which have embedded script (code) that generates the HTML? ",
      "id": "46250dbc3f8636b5ee54b16db1116a1f"
    },
    {
      "type": "html",
      "text": "\nOh, ick. ASP is all about embedding the code in the web page. You'll want to push everything even slightly complicated into external objects called from your ASP script code. Then you can [[Unit Test]] those external objects. -- [[John Brewer]] ",
      "id": "4b224204d4a052def87812b31287ff33"
    },
    {
      "type": "html",
      "text": "\nNot anymore in ASP+ ",
      "id": "4bd7da6e94d98508ee95cd02932c715e"
    },
    {
      "type": "html",
      "text": "\nI agree. I program mainly in Perl and put all of the real stuff into objects. Lately I've been writing [[Unit Test]]s for everything (after I code the functionality; I'll try beforehand) and it makes everything much nicer. You do have to test the HTML output (for browser compat, etc ...) but at least you know that the core of the app already works. -- [[Dave Tauzell]] ",
      "id": "ce2ec159c33797e0a93f7ca0ce33e168"
    },
    {
      "type": "html",
      "text": "\nHas anyone used XP with [[Procedural Language]]s? How did you adapt it? -- [[Jim Hart]]",
      "id": "ce93f2c8a345abfcf7d19ef8c3f943f2"
    },
    {
      "type": "html",
      "text": " What makes you think it needs adapting?",
      "id": "5f629e2b193a4f88108082fdb0bdaac3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "People have been doing so much [[Test First]] that there has been a growing interest in [[Test Driven Programming]], and claims that there may be something to [[Test First Design]]. -- [[Erik Meade]] ",
      "id": "74e1a1d07d877d042b043e7ad827c1a9"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "Is writing only [[One Unit Test Ata Time]] a requirement? ",
      "id": "898bc6cda16e3b5228308c005e650cb0"
    },
    {
      "type": "html",
      "text": "\nThe object is to write, test, and resolve one line of a UT at a time. This minimizes the number of changes before you check for mistakes, thus minimizing the number of places the mistake could be at. ",
      "id": "64d398e76c31432703db8a679ddb8e31"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "When you [[Code Unit Test First]] (manually) you could let a machine (automatically) implement classes to check against the test until the test is satisfied. This way extreme testers can move the complexity of developing some stuff to developing some tests for the stuff. I think the complexity is same. That is why I [[Dont Write Unit Tests]]. -- [[Albrecht Scheidig]] ",
      "id": "4ab3fba29f2f522306100425b2c6a27d"
    },
    {
      "type": "html",
      "text": "\nHow do you know your program works? ",
      "id": "74247e2e128efcf7284111d6d2172197"
    },
    {
      "type": "html",
      "text": "\nI do not know (but it sells). How do you know your test works? -- [[Albrecht Scheidig]] ",
      "id": "6a399255e71287acc1247365860b3049"
    },
    {
      "type": "html",
      "text": "\nWe know our tests work because they fail before we write the code, and pass afterwards. At this point, we know that our code works. -- [[Laurent Bossavit]] ",
      "id": "02954f6a2286879afe58f4516574cff5"
    },
    {
      "type": "html",
      "text": "\nYou could also write a wrong test, that fails before you write the code, and pass afterwards. At this point, you have a wrong test and a matching, wrong code. How do you avoid errors when you write test code? Do you write test code for the test earlier? And what about that meta-test-code? Etc. ",
      "id": "59092dca457969dca3c6917f306181b8"
    },
    {
      "type": "html",
      "text": "\nSee [[Bugs In The Tests]]. In a nutshell : it could happen... but then, you could also get run over by a car tomorrow. In both cases, you don't worry about it all the time - you just look both ways before you cross the street, and you avoid writing complex test code. ",
      "id": "9475a2dffd45775423643503cd7f827f"
    },
    {
      "type": "html",
      "text": "\nAnother thing to consider is that while you could, in principle, automate the generation of code that passes the test, that would be unlikely to yield valuable results. Rather, coding test-first lets you focus, all the time, on two sides of a single question : what do I need the code to do (the test) and how does the code do it. Both aspects involve conceptual reasoning that could not be automated. -- lb ",
      "id": "d3d6fc52d5af1c07335dba2a61aeaef2"
    },
    {
      "type": "html",
      "text": "\nThe test verifies the code and the code verifies the test. You have written two different implementations of the same problem and the likelihood of having made the same mistake in both is very low. When a test fails, you really do not know if the test or the code is at fault, however, since the test is usually much simpler than the code, it is most probable the fault is in the code. -- anon ",
      "id": "141473d8de733fa87270dc984b9db501"
    },
    {
      "type": "html",
      "text": "\nYes, it is not very likely that you mistype in both the test and the code in a way that the test passes, but: What if you are conceptually wrong? You write a wrong test and very likely a matching wrong code. What if you are conceptually right? You write the right test and very likely a matching right code. So why not automate the generation of an implementation of the interface expressed by the test? Because if I do it manually I have twice the time to think about the concept? -- as ",
      "id": "2eaf2a3d6e5ff7d2aa3deef3b4f4e513"
    },
    {
      "type": "html",
      "text": "\nI don't think you can \"automate\" the writing of code that passes tests - it's an AI-complete problem. Yes, having to think about \"what I want the code to do\" and then having to think once more about \"how does the code do it\" is what protects you against conceptual errors. But you have to do both anyway; no program will do either kind of thinking for you. -- lb ",
      "id": "9710d386a819b463918a0f9bde8d1d95"
    },
    {
      "type": "html",
      "text": "\nThe only way to be \"conceptually\" wrong is miscommunication with your users concerning the requirements. The only real way to resolve this (in any development approach) is to get the software into the hands of the users. [[Code Unit Test First]] ensures that the program works as intended, it does not verify whether the intentions were correct. ",
      "id": "bb8330736a889225dd334e188b367f4e"
    },
    {
      "type": "html",
      "text": "\nAs for having an automated way of generating code from tests, let me know when you find one. Until then, however, I am stuck having to write my own code. ",
      "id": "dfc896caa39debff9dbbe8bc47f2dbf9"
    },
    {
      "type": "html",
      "text": "\nThere is Genetic Programming, which does exactly that. BUT you would need a vast amount of test cases... -- [[Gerriet Backer]]",
      "id": "b8157f5920eef6cd176b68bd80a01645"
    },
    {
      "type": "html",
      "text": "\nI have found an algorithm for automated programming, but I cannot express it... ",
      "id": "1be686d9a3530e13dde18f2f83398fe7"
    },
    {
      "type": "html",
      "text": "\nLet me summarize it: [[Unit Test]]s are highly recommended for developers that tend to concentrate on implementation and technical details (How much percent will that be?). [[Unit Test]]s require to think about specifications, interfaces, external views, \"what I want the code to do\". [[Code Unit Test First]] is a rule that says: \"Think first about what the code should do before you think how the code can do it.\" An excellent side effect is that the output ([[Unit Test]]s) provides test mechanisms that can be executed by the machine and are independent of implementation changes. -- as ",
      "id": "3a3b355ca56b89de026cc3414cc8194b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "A thought that I'm playing with is the task of writing \"[[Unit Test]]s\" after the units themselves (classes) have been written. ",
      "id": "d4a514fc862991ebccdd1724d6e553e9"
    },
    {
      "type": "html",
      "text": "\nMy current thinking is that this task is nearly impossible. Once the code is written, the sorts of tests I can write against it tend to be tests which describe the behavior of the implementation, not tests describing the needs which the implementation was addressing. ",
      "id": "0ed70926a87176389365a5f5b254e169"
    },
    {
      "type": "html",
      "text": "\nConsequently, I find that when I [[Code Unit Test Later]], I end up with tests which don't help me at all when I try to refactor. It's like I've surrounded the code with a thick, hard crust of tests that actually inhibit refactoring, rather than supporting it. ",
      "id": "a0d411228267edd8b826d55b96854918"
    },
    {
      "type": "html",
      "text": "\nNot surprisingly, I also notice that the character of these after-the-fact \"[[Unit Test]]s\" resembles the character of acceptance tests much more closely than [[Test First]] style [[Unit Test]]s. -- [[Eric Herman]] ",
      "id": "65246a0ebb6f7565e435b4d98bcb7fde"
    },
    {
      "type": "html",
      "text": "\nPerhaps a useful tactic would be to code the [[Unit Test]]s specifically for the purpose of helping you refactor. For instance, I recently found myself - pairing with a junior coder - working on an awkward method gleaned from an untested JSP page that pried into private details of other classes; we wrote an \"outer\" test to pin down the behaviour, then started extracting bits of the code into other methods, writing one or two [[Unit Test]]s for each extracted method. Pretty soon we had three or so classes and an interface, with a more balanced design, tests that didn't look like mere afterthoughts, and two significant bugs fixed. We did have some inelegant code still lying around but... \"it's a [[Green Bar]], let's go home\". ",
      "id": "6425e4c4b4fc13ab39033a85e7451137"
    },
    {
      "type": "html",
      "text": "\nEven after-the-fact [[Unit Test]]s help if they are written with the attitude of [[Test First]] style tests. ",
      "id": "41c2e6ebef19c47cb4af056be037d63f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "I find it curious given the above that many people have expended time and effort writing tools to generate test cases from existing classes (I do realize this may be useful in a legacy situation). You can find examples at [http://www.junit.org/ www.junit.org]. Look under the IDE section, and there's more under the extensions section. No one seems to have attempted [[Code Generation]] in the other direction. ",
      "id": "8d530d64eb5ec008eec0a2afc22a8e8a"
    },
    {
      "type": "html",
      "text": "\nWhile there is some comment further up that writing (working) code from tests is an 'AI complete problem' it is surely not that hard to generate method signatures by examining test methods. I doubt generating code to pass tests is what people need from a tool anyway - generating code fragments is the time-saving step, and generating code to fail tests is a little easier. Just throw a [[Runtime Exception]], or the equivalent in your [[Language Of Choice]]. <i>I love the [[Eclipse Ide]] little red x cue-balls that with a couple of clicks add classes, fields, and methods to the code being tested by my unit tests. Still have to do the method bodies by hand of course.</i>",
      "id": "06fbc17be42cfe15d47f1816dc812ad5"
    },
    {
      "type": "html",
      "text": "\nBy not that hard (since doubt was expressed above) what I mean is this: work so that your test class is named the same as the tested class up to a 'wart' (eg Money and [[Money Test]]). An intelligent editor like emacs can then figure out the intended class name by removing the wart. Next, search for variable declarations. Next, look for method calls on those variables which have the same type as the tested class. Determine (a) method signature required by examining the variables or constants passed in (remember we already know the variable types). Finally open the class under test, check to see if the required methods exist, and insert them (possibly interactively) if they don't. A complete language parser is not required for any of this, the mechanics are there in any language-aware editor in order to fontify, indent, and navigate code. ",
      "id": "646615c88928c5e0570c1f39e2d09943"
    },
    {
      "type": "html",
      "text": "\nIt will not generally be practical to produce an exhaustive set of unit tests for a given function. It would just take too long. Take for example a unit test for a routine which implements y=sin(x). You can feed it various samples and possibly test some boundary cases, but you will not be able to test all values of input/output. Thus, the unit tests underspecify the function and could not be used to generate the function's behaviour other than at the points that are tested.",
      "id": "e021c751a869cfc3f8e5c0df4de39542"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "y=sin(x). ",
      "id": "30f29c2124b09bb586135f1510c36286"
    },
    {
      "type": "html",
      "text": "\nHere is the complete test:\nsin(x) = x - x^3/3! + x^5/5! - x^7/7! + x^9/9! - ... + (-1)^(n-1)*x^(2n-1)/(2n-1)! + ... go on until you run out of precision.",
      "id": "50feb8c3ad06c1d33c06bbc1c9e8c8a8"
    },
    {
      "type": "html",
      "text": "\nDefinitions:  ",
      "id": "37427a405e1fd55b9d292774dce672db"
    },
    {
      "type": "html",
      "text": " x^n is the regular power function: x * x * .... * x  (n x's multiplied together) ",
      "id": "28df85a72dbbeaaee339bae07d6e408d"
    },
    {
      "type": "html",
      "text": " k! is the factorial function: k * (k-1) * (k-2) * ... * 2 *1 (example: 5! = 5*4*3*2*1 = 120) ",
      "id": "7e849aadd350a99032bc42ee12f5ea86"
    },
    {
      "type": "html",
      "text": "\nExhaustive testing may be necessary in medical equipment like pacemakers.\tYou want to get it right before you use it in real life.",
      "id": "8a49bbec39cd405e17ba64c97b1dbbff"
    },
    {
      "type": "html",
      "text": "<i>\"...you will not be able to test all values of [x].\"  The infinite sum above provides a mathematical verification of one value.  On a machine with 64-bit floating-point math, you will wait a long time for 2^64 iterations of the algorithm.  How does your machine respond to special floating-point values like Infinity or [[Nota Number]]?  How does your machine respond to mathematical functions when tested at discontinuities?</i>",
      "id": "0db2b97ebc24ce0c22e17b130c8fbcc8"
    },
    {
      "type": "html",
      "text": "<i>In safety-critical or life-critical applications, it may not be sufficient to verify code with more code.  It is possible (though unlikely) that the [[Unit Under Test]] implements the same algorithm you have devised for the [[Unit Test]].  In any case, to satisfy certification criteria you may need to manually verify that your [[Unit Test]] produces a correct result to compare with the [[Unit Under Test]].  Manual verification cannot be performed exhaustively within any reasonable scope of time.</i>",
      "id": "5e2fcf875a0bab479910cb8fbbe3f30d"
    },
    {
      "type": "html",
      "text": "\nIf only all functions were periodic, had bounded derivatives, and could be decomposed into monotonic pieces!  There are three ways to comprehensively verify a function:  formal methods, a comprehensive list of inputs and outputs, and a trusted function to compare against.  Depending on the accuracy requirements, it may be quite easy to provide a trusted function that is easy to prove correct but is unsuitable as an implementation.  For instance, if sin(x) is required to give a value within d of the \"correct\" answer, you can create a lookup table implementation of sin(x) that is proven to be accurate within d/3, then verify that sin(x) gives answers within 2d/3 of the table.  Since sine is so well-behaved, it is easy to produce such a table, and it will be small for reasonable values of d.  Another way that a relaxed standard of accuracy simplifies the problem is that it may be possible to restrict the number of inputs.  If you have a formally verified 64 bit -> 16 bit converter, you can compose it with an exhaustively tested 16 bit -> 64 bit sin function to get a 64 bit -> 64 bit sin function of known accuracy.  ",
      "id": "5cde390a72bb5cc888e4a85999dde39c"
    },
    {
      "type": "html",
      "text": "\nProducing a verified 64 bit -> 64 bit sin function that is correct for almost all of its bits of precision is much harder, but even this task can be cut down considerably by producing a formally verified modulus function, verifying sin1 on [0, 2pi), and implementing sin(x) as sin1(mod(x, 2pi)). ",
      "id": "0549ad5460c2d055bc18ab5de4c70f12"
    },
    {
      "type": "html",
      "text": "\nPerhaps these methods seem too heavyweight to qualify as [[Unit Test]]s<b></b>, but I imagine that in the situation you describe, changes to the sin function would be undertaken with great care and deliberation, and these methods would be used much like [[Unit Test]]s<b></b> are -- to decide when code is ready for integration, to check whether changes broke the code, etc.",
      "id": "f3462fc8ec7a4efaa2771fd98dc347df"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "Is it necessary to write [[Unit Test]]s that don't fail the first time they are run? See [[Unit Tests That Dont Break]]. ",
      "id": "f9df438b67065b97c4775bdbbc21c451"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "For an interesting take on [[Code Unit Test First]], see [[Code Unit Test Third]]. ",
      "id": "e3d9f1e2c2342189a898d7c62c1394d8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "I want to know how to covert legacy code to [[Extreme Programming]]. It would seem that what is needed is to add tests to the legacy code so that you can do the refactoring. Does anybody know how to do this? -- [[Jon Grover]] ",
      "id": "7aca64d3afd3ae3c1d9bceba79c30c5b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "Moved from [[Unit In Unit Test Isnt The Unit You Are Thinking Of]] ",
      "id": "c2eb10ba9c948dc2c9e6de5f6a6ba0c0"
    },
    {
      "type": "html",
      "text": "\nInteresting fact-ette about this 'radical' [[Code Unit Test First]] philosophy: it may not be so new after all. My mother started her career as a PL1 and COBOL programmer way back when computers were larger than my house. We were chatting recently about XP and she mentioned that when she started all developers were required to write a unit test plan before they went near any code. The test plan was then used as the basis for the code. I'm guessing that compile and debug times were so much greater that they simply couldn't afford to spend ages fixing silly mistakes. Perhaps its one of those universally good ideas that was simply forgotten about for a while, probably during the excitement of seeing the first computer that was small enough to fit on your desk... ",
      "id": "40028460253e37d80c3faa8d4f503baa"
    },
    {
      "type": "html",
      "text": "\nThose who do not learn from history are doomed to repeat it. Guess we programmers prefer thinking about the future to studying history. ",
      "id": "8409092fa0e406f2ddaab9fc09cf1d6b"
    },
    {
      "type": "html",
      "text": "-- [[Darren Hobbs]] ",
      "id": "e9b22aedf70b950e0e929fbc93ae06c7"
    },
    {
      "type": "html",
      "text": "\nThat is interesting. Could you get your mother to expand a little on what was in a \"unit test plan\"? ",
      "id": "e7f79f87733d78bab708cda2ff39343f"
    },
    {
      "type": "html",
      "text": "\nIt's a curious thing about our industry: not only do we not learn from our mistakes, we also don't learn from our successes. -- [[Keith Braithwaite]] ",
      "id": "4f1e1af30c7dfa921cacdba4644b4aa9"
    },
    {
      "type": "html",
      "text": "\nUnit Test First programming in PHP",
      "id": "d10b439d81b3ec09c1b162cd8c9bc8d7"
    },
    {
      "type": "html",
      "text": "\nI tried the above the other day, just for the heck of it ... It's actually far smoother than you'd expect. Here are the steps I went through:",
      "id": "8fca61dc5940de58dd9f0efcbcc06bc9"
    },
    {
      "type": "html",
      "text": " I installed the PHPUnit package from pear.php.net",
      "id": "44bd4afd93d391456ab856809238ae1b"
    },
    {
      "type": "html",
      "text": " I used it as described above :)",
      "id": "db98d646fef9f91096cf02eaaa1e89d6"
    },
    {
      "type": "html",
      "text": "That's it. It actually ended up being no different from coding with a Java tool... Of course, I had to use proper OO design in my script for the unit-testing to be effective, but that's probably a good thing, so I can safely say that not only unit-testing in PHP was easy, but that it improved my code.\t",
      "id": "928646293fb76aaf65755dad03ae94ff"
    },
    {
      "type": "html",
      "text": "-- [[Danny Cook]]",
      "id": "54f79632c628ce02a850c8f3e2de6e15"
    },
    {
      "type": "html",
      "text": "\nAm I missing the point somewhere? Unit testing always sounds like a good idea to me, until I come to actually start using it, at which point I get bogged down in problems. Allow me a real life example: I am currently writing a database application, and I have a function which simply adds a record to a table, using some details passed in as parameters. Very simple, but certainly possible to fail, so it needs a test. How do I test it? It seems that a test would need to relocate the record which has just been added, then read it and check that the correct information was written to it. This is actually more complicated than the original function, and more prone to errors. Which surely defeats the object! What should I be doing? -- Chris Sandow",
      "id": "6d3a2152f3de0d4bf9ab1eba66cf7211"
    },
    {
      "type": "html",
      "text": "\nAn approach is to save the record that was added, do a get, and then compare the records.\nDepending on your system this can be made generic. -- [[Anonymous Donor]]",
      "id": "90f589913a60002155a5693cd7996438"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "What about testing classes which produce graphical output which cannot be tested by simply comparing every pixel with a test image? For example, one might create a class which has only one publicly accessible function named \"drawStuff()\". drawStuff() uses OpenGL to draw some stuff. One cannot simply compare the pixels because the graphical output will most likely vary between various OpenGL implementations and will depend on the hardware. How do you write a unit test first for something like that? What if the output is very complex making it very hard to have a test image made prior to the test? -- tomek",
      "id": "4ccead0a22b9cd4a5358796e867c3d9f"
    },
    {
      "type": "html",
      "text": "<i>Well, you can still guarantee a few things about the function: you know that under such-and-such conditions, it will produce an image, and will not throw an exception or some fatal error. Depending on your application, you may also be able to say that it should throw an error under certain other conditions and check that it does. You can also check some basic things about the image: it should have a size in a certain range (a 1x1 image is probably an error), it shouldn't be all one color, the image produced by input A should be different from the one produced by input B, etc.</i>",
      "id": "c07055da47fc78a9871c25b75117d4a4"
    },
    {
      "type": "html",
      "text": "<i>Then of course you add to this basic unit test as bug reports come in - as soon as a bug is reproducible, write a unit test that fails because of the bug. Then fix the bug and re-run the test.</i>",
      "id": "cf223eecbe711952b330516faaf39874"
    },
    {
      "type": "html",
      "text": "\nIf you are in a situation in which defining the expected output seems equally difficult as actually producing it, maybe you are trying to test at the wrong level of abstraction (too much at once). Quite probably, your complex function can be split into multiple helpers, the output of which is easier to check. Take one further step and you will find yourself dealing with multiple objects. If these components all produce correct output given their inputs, and if the master object (formerly the complex function) composes them together correctly, then the whole test passes. Note that the correctness of the master (putting the components together appropriately) should be testable even without their concrete implementations, by relying on [[Mock Object]]s. The only concern is that by making your code testable in this manner (following [[Code Unit Test First]]) you might sacrifice the necessary performance. I guess you can always optimize (and obfuscate) your perfectly correct code later on, though.",
      "id": "ae755dcff03c4f9da38ebf6ea9c822c9"
    },
    {
      "type": "html",
      "text": "\n[[Code Unit Test First]] is (almost?) always technically possible, but it is difficult. Don't believe those who tell you it's \"sooo easy\". No, it takes extra time and consideration, and it takes practice to get there. Sometimes the time and consideration is better spent on other activities - my favorite example is learning/exploring/experimenting with code. Does XP advocate programming \"spike solutions\" with the [[Code Unit Test First]] approach? I would argue that if you know that you are going to throw away your tests in the next hour together with your experimental code), don't write them. Writing tests slows you down in the short term. Admit it.",
      "id": "174173ac8291595931e1456c7b61b83a"
    },
    {
      "type": "html",
      "text": "<i>Everything I've read says don't write unit tests for spikes or prototypes. Maybe that was just [[Kent Beck]]. Anyway you can probably just use the [[Pair Programming]] rule that says only do it with production code.</i>",
      "id": "ad4bb5ca10997ee1c5dfcc7f1995c3fc"
    },
    {
      "type": "html",
      "text": "\nI think one should look at why he is doing the spike or prototype.  If one is merely trying to learn about a particular development environment, language, etc., then tests are not necessary.  In other words, don't write tests for \"Hello World\" programs.  If, however, one is trying to prove or disprove something, write the test.  The test is an explicit definition of what one is trying to prove, and it is invaluable when explaining to others the result of the spike.  Everyone will know exactly what was verified and can reproduce the result.",
      "id": "937aa0e78f3d7261629f9315a53b016a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "Coding [[Test First]] is like climbing with protection. You wedge various pieces of gear into the face of the rock and you have your partner belay a rope attached to you so that when you fall off, as you will frequently, you won't waste your time with being injured.",
      "id": "da84023dea853744d4ae3668e8f0cd4e"
    },
    {
      "type": "html",
      "text": "\nA [[Spike Solution]] is like free-climbing. No gear, no one to belay you, just you and the naked face of the rock. A really skilled climber can just zoom up the mountain, almost like skiing in reverse. But pride comes before ...",
      "id": "7d62cc9654501a85f66d9b84150ff4d5"
    },
    {
      "type": "html",
      "text": "\nSomething I want to try:  after I write a Spike which does the job, or some piece of it, I want to refactor it into a set of tests, kind of like the [[Fake It]] method of writing unit tests in reverse.  Not sure how it'll turn out, anyone else ever try anything like this?",
      "id": "87f24ae45a15baa7ed5ae02fdbc7b4d3"
    },
    {
      "type": "html",
      "text": "-- [[William Underwood]]",
      "id": "af4bce50981a709f6a5b010c553cc97e"
    },
    {
      "type": "html",
      "text": "\nActually, my usual development method ([[Stop Using The Word Methodology]]) is like this. Except that I usually don't end up automating the tests (at least not very well); I just keep a set of things to test in mind, and run my \"suite\" with every recompile. This works well with games because of the \"I know (in)correct behaviour when I see it\" problem, but you end up with tests that are more [[Regression Test]] than [[Unit Test]] in nature.",
      "id": "f46073debe6139a0cde36919dfcd6443"
    },
    {
      "type": "html",
      "text": "\nI do things like this because frankly, trying to write the tests first feels tedious to me - it slows me down <b>artificially</b>, because of psychological factors (i.e. the first test - as well as the process of refactoring towards a solution for the first few tests - seem to insult my intelligence, because I've already figured out how to generalize things. I'd like to start a new page about that, but I'm not sure what to call it...).",
      "id": "25caecd4553bc1e7473574488e912a22"
    },
    {
      "type": "html",
      "text": "-- [[Karl Knechtel]]",
      "id": "3ed8722414b7e5c3f478e16ba4f9f604"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "I'm wondering about [[Test First And Functional Programming Synergy]], and if it is worth keeping in mind while writing tests and refactoring. -- [[David Plumpton]]",
      "id": "4ac8fcc31addbd9d46a82a4bedc46536"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "See [[Test Driven Development For Aggregate Methods]]",
      "id": "f3d17213669b540444d0f89bebf4b232"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "\nI think there may be something slightly naive about the idea that you could write a unit test for a non-trivial method before you write the code for it. I think this comes from the assumption that you know enough to write a unit test once you have the signature, or even the complete \"contract\" to its callers, of the method under test. In order to write a unit test you must also have a clear specification of all the objects and their methods which your particular method under test uses and how it uses them. In other words, you need to know the \"calling out\" contracts as well as the \"calling in\" one. Then your unit tests can use [[Mock Objects]] to simulate the call-outs and to check they are correctly used.",
      "id": "32cb2c56f600454db82e055978403dc4"
    },
    {
      "type": "html",
      "text": "\nIn my opinion, this extra \"specification\" of a method is probably best documented simply by writing the code for the method (see [[Design From The Inside Out]]), and that actually ends up with you writing the code for a method before its unit test. [[Richard Develyn]]",
      "id": "6bbba051cba747aa0f689c9186c20361"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "(I took this comment out of the main body of my text)",
      "id": "81a55f28c4a21136f74a8ab0ff43f382"
    },
    {
      "type": "html",
      "text": "<i>Solution: Don't write non-trivial methods.</i>",
      "id": "29380618cd7253610fae8b31aef53f72"
    },
    {
      "type": "html",
      "text": "\nAny method which uses another object is non-trivial in the context of the discussion above. It isn't possible to avoid these. -- [[Richard Develyn]]",
      "id": "fcae1fe96ad8ece0edb8c39c76a2f434"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "I can't see how to apply this to programs that produce complex PDF reports.  I work for a document-processing company.  We take data files from our customers, and print bills, statements, etc. to PDF.  If we were doing plain text reports, we could create a test output file by hand and use diff to check the program-generated output.  I actually tried creating a PDF mock-up by printing from Word to Acrobat, but even though the PDF looks a lot like the one generated out of my code, the files are totally different. -- [[Kevin Kleinfelter]]",
      "id": "076cbfb225a67d7f51e0acf4fe38b350"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "I did something similar but wrote a system to generate word documents from data using the Aspose component. I found it was impossible to test the actual content of the document, as there is no way to get to it - but I could write tests for the framework that built the document. I also wrote tests for the gateway classes that retrieved the data for the document. Not perfect I guess, but there was no easy way to navigate through the document to verify the data. I suppose you could use mock objects and verify that all calls are being correctly made, then at least you would have some confidence in the interactions, if not the state. -- Gareth Jones",
      "id": "a27d9b82c3c5682a35d8fe50bfe67a72"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "How should we go about [[Choosing The First Test]]?",
      "id": "e308a6ce41c8b27e43b71896cd5b3364"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "21402e25fa3b621d1c2c32cdfca833f2"
    },
    {
      "type": "html",
      "text": "[[Category Extreme Programming]] [[Category Testing]]",
      "id": "f9be3a857481a4c8a08da23b166866d9"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?CodeUnitTestFirst c2.com]",
      "id": "3bc86df2613bab6a20cdcb85bd7280b2"
    }
  ],
  "journal": [
    {
      "date": 1373257182000,
      "id": "42277b6d647b07c8917a9ffd65211e21",
      "type": "create",
      "item": {
        "title": "Code Unit Test First",
        "story": [
          {
            "type": "html",
            "text": "Rule: [[Never Writea Line Of Code Withouta Failing Test]]. ",
            "id": "13c6866e3bff7fdd5cfdf2921dd92b20"
          },
          {
            "type": "html",
            "text": "\nThe interface & output of an object are more important than its implementation, so write the former first, in terms of code trying to exercise it. ",
            "id": "3fd4c27a3ed93dfef8467630608c2852"
          },
          {
            "type": "html",
            "text": "\nSee [[Code Unit Test First Example]], [[Test First Design]], [[Test Driven Programming]], [[Test Driven Development]], [[Write Just One Test]], [[One Unit Test Ata Time]] ",
            "id": "936e4d764ce87519e1ea17e9ed0d7b88"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "Here is a really good way to develop new functionality: ",
            "id": "e002a5e519778a344fc87473ac024722"
          },
          {
            "type": "html",
            "text": " Find out what you have to do. ",
            "id": "10a817eb301d172323b8049c0066b088"
          },
          {
            "type": "html",
            "text": " Write a [[Unit Test]] for the desired new capability. Pick the smallest increment of new capability you can think of. ",
            "id": "a8a458c807051431af25acfd10468cde"
          },
          {
            "type": "html",
            "text": " Run the [[Unit Test]]. If it succeeds, you're done; go to step 1, or if you are completely finished, go home. ",
            "id": "88e71a62a924ee136d948ec1eca2d1bd"
          },
          {
            "type": "html",
            "text": "4. Fix the immediate problem:<br>maybe it's the fact that you didn't write the new method yet. Maybe the method doesn't quite work. Fix whatever it is. Go to step 3. ",
            "id": "c52d68d0a8781eb8700592ed27cf4d50"
          },
          {
            "type": "html",
            "text": "\nA key aspect of this process: don't try to implement two things at a time, don't try to fix two things at a time. Just do one. ",
            "id": "b5b4daeec7e27e80f637455610f83a8b"
          },
          {
            "type": "html",
            "text": "\nWhen you get this right, development turns into a very pleasant cycle of testing, seeing a simple thing to fix, fixing it, testing, getting positive feedback all the way. ",
            "id": "d2f7b4c0e9e0223897be5c4e6a3e9bff"
          },
          {
            "type": "html",
            "text": "\nGuaranteed flow. And you go so fast! ",
            "id": "508a2c94a909c53df8d397bc552f4e61"
          },
          {
            "type": "html",
            "text": "\nTry it, you'll like it. ",
            "id": "08117e410545ba1010f443f45c193bfb"
          },
          {
            "type": "html",
            "text": "-- [[Ron Jeffries]] ",
            "id": "8e5905b5532a0023cea0920b5174e7a7"
          },
          {
            "type": "html",
            "text": "\nDoesn't step 1 imply [[Acceptance Tests First]]? -- [[John Whitlock]]",
            "id": "b98760af8cf74e868fd3848e4ab1df7b"
          },
          {
            "type": "html",
            "text": "\nThe way I work, yes. I typically write a [[Cucumber Framework]] story and watch <i>that</i> fail before writing a [[Unit Test]] for my implementation. --[[Marnen Laibow Koser]], 14 April 2011",
            "id": "c1c2fc9f3bff29acbf0dc90077708333"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "When you run a test, if it works, check the test and all your changes into your version control system (with a meaningful comment). Then you're done. -- [[Dave Whipp]] ",
            "id": "1f7a78c01c83f1ea78bc95d17f2df811"
          },
          {
            "type": "html",
            "text": "\nNo. These tests and increments are too small. Do the checkin after you've done a few hours of work (or less if you have a very well automated checkin process that's quick and easy). -- unsigned",
            "id": "03b66744d989ac461ce8d065c924b2d5"
          },
          {
            "type": "html",
            "text": "<i>Why? Small checkins make it easier to just pick the changes you actually wanted when merging. --[[Marnen Laibow Koser]], 14 April 2011</i>",
            "id": "6b8107fc701f25ea08ea5e7bb8706548"
          },
          {
            "type": "html",
            "text": "\nI do as Dave does, waiting a few hours to checkin just increases the chance of a conflict or that I will lose a few hours of work rather than ten minutes worth. So I like to checkin all the time, and would suggest you do the same, unless your checkin process is slow and hard (in which case my advice is you had better make it quick and easy). -- [[Erik Meade]].",
            "id": "9c12069218eb6ac392cb3fa3c13d449f"
          },
          {
            "type": "html",
            "text": "\nI am not sure of all the advantages of checking in every change. But one is you can count line of code(LOC) changes (added, modified, deleted, etc). This counting could be automated by the Version Controler. A change control like [[Change Log]] can help this case. -- [[Alex Vicente]]",
            "id": "4eadab21f449642965c4276b725cb752"
          },
          {
            "type": "html",
            "text": "\nSee [[Extreme Version Control]]",
            "id": "611e579b9fd79613ff5a1835c19b2a19"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "Do you ever write all the [[Unit Test]]s for a class before starting to implement the class? Do you ever have a [[Master Programmer]] write the [[Unit Test]]s and a [[Grunt Programmer]] change the system to satisfy them? Do you ever use [[Unit Test]]s as specifications? ",
            "id": "754bb26b939c8dd414fa00f83fff87cd"
          },
          {
            "type": "html",
            "text": "\nI'm expecting the answer \"No\". The very notion of a [[Grunt Programmer]] is probably antithetical to XP, that division of labour being superseded by [[Pair Programming]]. I thought I'd ask, to check, and to get the answers explicit and on the record. I'm currently coming at this from the direction of [[Design By Contract]] and assertions. -- [[Dave Harris]] ",
            "id": "64ce0815fa93bc80f3c86efe467128ae"
          },
          {
            "type": "html",
            "text": "\nWe generally don't do those things. Since we practice [[You Arent Gonna Need It]], we couldn't in general write all the [[Unit Test]]s for a class. We do sometimes write a batch of [[Unit Test]]s for some piece of functionality we're working on, especially if they are all variations on a theme. For example: check SUB with one day less than the max, at the max, one day more. ",
            "id": "e36c926cd18eb8d0d5cd4ae5aa1eed73"
          },
          {
            "type": "html",
            "text": "\nWe might well invite a [[Master Programmer]] to sit with us for some hard bit. In general we strive to have everyone cross-trained on everything. Even so there are areas of model or infrastructure expertise. Personally I believe that there are some short-term advantages in specialization, and I'm sorely tempted to use specialization in times of stress. Sorting out what is going wrong with our process and getting it back on track seems to work better. ",
            "id": "3f6017afee286fcfad2b6ef01d6d3155"
          },
          {
            "type": "html",
            "text": "\nBut some people seem better at design, at seeing consequences faster, while others are better at painstaking programming. In theory, specialization would allow each to do his best. Does [[Chrysler Comprehensive Compensation]] take it as an axiom that [[Pair Programming]] is always better? -- [[Aamod Sane]] ",
            "id": "b0aba1a0deb552db8f6d9d06194c5814"
          },
          {
            "type": "html",
            "text": "\nNo, they took it as a hypothesis, tested it, and found that the more they paired, the faster they went and the fewer problems they caused. I showed them how to do it. Taking it to such ridiculous extremes was their idea. And it works ... -- [[Kent Beck]] ",
            "id": "9e878683de08ca443ca92b39f975b23a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "[[Code Unit Test First]]. Why don't people like testing? Well, the traditional way of testing is tough to take. You write what seems to be perfectly sensible code, then you write a test and the test tells you that you failed. No one wants to hear that. ",
            "id": "d03ddf7bb935cbe6db72fcce703e87e8"
          },
          {
            "type": "html",
            "text": "\nLet's turn it around. Write the test first; run it. Of course it fails.. You haven't written the code under test yet. Start writing code.. keep testing. Soon, the test will tell you that you've succeeded! ",
            "id": "a2e4d51b999bbbfac3ef42299d9b03c2"
          },
          {
            "type": "html",
            "text": "-- [[Michael Feathers]] ",
            "id": "231a922dc382df497a4b72630f3a7a23"
          },
          {
            "type": "html",
            "text": "\nNice, Michael! That really captures what [[Test Driven Programming]] feels like. It really is a blast to do! -- [[Kiel Hodges]] ",
            "id": "76cf2db5136b0ee139aa561d2c91c82d"
          },
          {
            "type": "html",
            "text": "<i>Michael, let me get this straight. You write a test and you know it will fail, since you haven't written any code for it to pass. So you run it anyway knowing it will fail. Here's a hint: you don't need to run that test, because it will fail. you know the outcome of that test so there is no reason to run it first. Running it only proves that you prefer wasting time. You know it will fail, so there is no reason for the test to be run. The only reason you would want to run the test is if there was a reason to run the test. There isn't one.  A religious ritual of running the test for no reason could be created, but it wouldn't serve any purpose other than religious.  Software programming has certainly turned into Quackery. Sad.</i>",
            "id": "2933481a3398322f7ee92823bb3e63bc"
          },
          {
            "type": "html",
            "text": " [Actually there is a purpose in running that test before you write the code.  It verifies that the test can fail.  There are bugs in tests too, so having some built in sanity checks are not a bad thing.]",
            "id": "851b774a616eac914bdbfdc9759d5dcb"
          },
          {
            "type": "html",
            "text": " There's another purpose too. It sometimes happens that I write a test for what I believe is new functionality. When I run it, it passes. After making sure that my test is correctly written, I discover that the functionality I thought was new was, in fact, already in the system -- so I don't need to write any new code to implement it! In cases like this, the habit of watching the test fail saves me lots of work. --[[Marnen Laibow Koser]], 6 Apr 2013",
            "id": "2aa275a850bfdb00b840b05e83f3fc64"
          },
          {
            "type": "html",
            "text": "\nAnother (apparently overlooked) benefit of coding the [[Unit Test]] first is that you get to test the [[Unit Test]]. When it says your code failed (because it wasn't written yet), the [[Unit Test]] has itself succeeded. -- [[Eric Scouten]] ",
            "id": "64ef096a2598d8c644f86bb991099eac"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "In a static language, the compiler/type-checker does some of the job of [[Unit Test]]s. Thus instead of running the tests, you attempt a compile (or a link). Now the compile fails because the method doesn't exist yet. Never mind - continue as for step 3. -- [[Dave Harris]] ",
            "id": "d05afb1d9ba20dc53a6f24723d364e57"
          },
          {
            "type": "html",
            "text": "\nThat was very much my experience with [[Modula Three]] ([http://www.research.digital.com/SRC/modula-3/html/home.html www.research.digital.com]) which had the nicest type system I've come across. You sometimes have to work a bit to get the types in your program lined up, but once you do the code usually just works. -- [[Steve Freeman]] ",
            "id": "5bdb65b97b656f7bb76a3e18456b5d9e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "Another strong advantage of writing [[Unit Test]]s as early as appropriate is that you can use [[Unit Test As Documentation]] - if they're written properly, they provide a great example for people who have to use or work on the code later. -- [[Martin Pool]] ",
            "id": "122202dff34ab226b90c54fde3fc98da"
          },
          {
            "type": "html",
            "text": "\nIt struck me last night while painting a wall: [[Code Unit Test First]] is the programming equivalent of using masking tape and drop cloths. On the surface it doesn't look like you're making \"progress\", but the safety it gives you lets you work faster and safer. -- [[Rob Crawford]] ",
            "id": "bfbedadef3f12a103dcb2c019adb591a"
          },
          {
            "type": "html",
            "text": "\nUmm .. isn't that a negative example?  In XP you start by painting, drip some, and then fix the problem.  If you start with drop cloths and you finish painting,  and then find them all clean, then you have violated YAGNI.  Your example seems to justify [[Planning Ahead]]  which is the right thing to do when you're painting a house, because your requirements are fixed. -- [[Nissim Hadar]]",
            "id": "31566b9ef6d83c98dd77b65dfbc9e309"
          },
          {
            "type": "html",
            "text": "<i>Another example is a technique used for drawing life-like pictures of just about anything. The idea is to focus your awareness on the Negative Spaces of your subject. By focusing on the negative, you trick your mind in not making assumptions about your subject, and your mind becomes aware of the true shape of your subject. See [[Drawing On The Right Side Of The Brain]] by Betty Edwards.</i>",
            "id": "f51016f90c059dce63290a16dc0693a2"
          },
          {
            "type": "html",
            "text": "<i>For a beginning artist, the results of this technique are shockingly effective. And this analogy of life-like drawing is so fitting to Extreme Programming -- I think a comparison of the before-and-after drawing of someone using this technique would make a persuasive book cover for [[Extreme Programming]]. For a better and fuller description of this technique, read any book by Betty Edwards on the subject of drawing . -- [[Stephan Branczyk]]</i>",
            "id": "857e6a04830e7d697fd90512d6ea0bfe"
          },
          {
            "type": "html",
            "text": "\nHow can you say that a test is the same as negative space? A test represents a positive intent.",
            "id": "072b6455089c74e5cf4ffd1bedb3dfa5"
          },
          {
            "type": "html",
            "text": "<i>\"Negative space\" in the context of drawing doesn't map to \"failure conditions\" in programming.  If you have a nameable object (like a book) leaning against another nameable object (like a wall), negative space means instead of drawing the book (positive space) and the wall (positive space), you draw the area between them (negative space) first.  The result is you get a boundary for your book and boundary for your wall before you start drawing them.  The reason is that when we have a name for something, it's usually attached to a generic model in our heads, but that generic model isn't a very good representation, because it's so vague.  Just a sketch, really, even though we give it a lot more credit.  By starting with an unnamed (and hence, unstored) shape, we have to focus on each angle, edge and proportion for this particular instance, because we don't \"know\" what it's \"supposed\" to look like.  When you then draw the positive shapes, you can't slip into automatic mode, because they won't fit the edges you've already defined.  It really is a ground-breaking technique.</i>",
            "id": "eb31458f93c9a72157c40a5281b1a724"
          },
          {
            "type": "html",
            "text": "<i>In programming, the [[Use Case]]s you start with (and implement as [[Unit Test]]s) are the negative space, in the sense that they're not your code, they're the stuff your code needs to fit against.  Your code is the positive space, but if it doesn't match every nook and cranny of the [[Use Case]]s, the code's not right.  When you start with the code, you might be tempted to think, \"I know what a file reader class should do, I'll just slap one together!\" and end up missing some bits that are required by this particular project.  Working from the [[Use Case]] (implemented as [[Unit Test]]s) inward, you define the edges and ensure that the code you eventually write matches this project's requirements precisely.</i>",
            "id": "aca370b153258bcd1de50e137f31f198"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "Another advantage of coding tests first is that tests exert a beneficial influence on the design. The tests themselves become additional users of your class interface, which ameliorates the problem of \"you can't reuse code before you've at least used the code once\" - because you start, right off the bat, with at least one extra user of each class. ",
            "id": "2dc5dff02baea68c36af5be3a8baad8c"
          },
          {
            "type": "html",
            "text": "\nConcrete example: you need to test code which (usually) takes input from an external device. But the device is not present during testing. So, in order to code [[Unit Test]]s, you are forced to create an interface for your code to talk to: one implemented for the real device, and another implemented for the \"fake\" testing device. Having done that, you're in a much better position to further implement the interface for multiple other devices. ",
            "id": "99ec97dbc9223b16c8506c85f000a36a"
          },
          {
            "type": "html",
            "text": "-- [[Pieter Nagel]] ",
            "id": "0ce3766bba934f6b64eb67c55ae52ba1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "How do you adapt [[Unit Test]]ing, in the more realistic scenario, where you are adding functionality to an existing product? Do you unit code retroactively or just for new units? The advantage of the first approach is, you may catch errors that were previously overlooked. The advantage of the latter is you save time and focus on where errors are likely to occur. -- [[Cayte Lindner]] ",
            "id": "4a10fe2f584e9c5eeb40a0f8c540b3ac"
          },
          {
            "type": "html",
            "text": "\nBefore you change a method, you have to write a test for what you think it does. Either it runs, and then you're sure that you aren't breaking anything, or it doesn't work, and you learn something about what the code does.",
            "id": "5a86261c7ff7964d3f354e32f2407e63"
          },
          {
            "type": "html",
            "text": "(Unless the design is a mess, the function has side effects you don't detect and don't capture in the unit test, and thus have a false sense of confidence in your unit test.)",
            "id": "1e83fe94373bd301233f2a81bb6b14a3"
          },
          {
            "type": "html",
            "text": "\nWriting \"retroactive\" tests on demand reduces the amount of up-front investment (you won't ever get permission to spend two months writing tests). It also makes sure that the most rapidly changing code is tested soonest. ",
            "id": "66e2f169c4fda3b543ddd46666b38d93"
          },
          {
            "type": "html",
            "text": "\nNew code gets tested as above. ",
            "id": "b59c55d4c4f457f28e84f11dc2408eda"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "What is a good way to organize [[Unit Test]]s for a non-trivial project? Does one usually write a whole slew of tiny test programs, or are they usually amalgamated into a \"test app\"? -- [[Maciej Kalisiak]] ",
            "id": "e92e25d68da9bbf4f486ac0da3e632b2"
          },
          {
            "type": "html",
            "text": "\nLots of small [[Unit Test]]s are generally added to larger [[Test Suite]]s.",
            "id": "d14fb587deefe3b8b6d695b1e34dc1fe"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "Questions: ",
            "id": "f44c71aca7c6dbf44b751304c01d4c34"
          },
          {
            "type": "html",
            "text": " What if your application has a heavy GUI? ",
            "id": "9d7ce19e7c44f8b13d3e78127ea0981d"
          },
          {
            "type": "html",
            "text": " How do you [[Code Unit Test First]]? ",
            "id": "5d2a043389da0719a06ba4e7e6c6f7e7"
          },
          {
            "type": "html",
            "text": " How do you [[Unit Test]]s at all? ",
            "id": "e6aa5375ae562e178822c73d19c897df"
          },
          {
            "type": "html",
            "text": " There are a number of good automated tools on the market for testing GUIs, but they generally compare the GUI with the results of a previously successful run, that you checked by hand; you can't write the test first. ",
            "id": "9ca023286ee0040cf6fd7526c83c9fcf"
          },
          {
            "type": "html",
            "text": "\nThe best HTML testing strategy I've seen (thanks to [[Massimo Arnoldi]] and the folks at [[Life Ware]]) is to regression test the HTML, then [[Unit Test]] everything under the hood. Since there is only one way to see if HTML is \"correct\", that is, look at it in every browser you care about, the best you can do is run a test that produces a page, manually verify that it is satisfactory, then set up the test so you are notified if the results ever change. When they change, you have to manually verify again, so you don't want lots of these tests, you want to test most of the variations with finer-grained tests. However, you can write a tool that will shoot the HTML to IE and Netscape, then save it somewhere if you say everything is OK. -- [[Kent Beck]] ",
            "id": "7478ec27e653e7324c5864ba3101dd3b"
          },
          {
            "type": "html",
            "text": "\nI just did a toy case of this - a Perl CGI that produces a 30-day, free-trial [[Jera Works]] license certificate. While developing, I ran the CGI in offline mode, and just piped the output to the input of a shell-based Java program. Programming consisted of modifying the Java code to use the new feature (like including Product Name in the license cookie), and then modifying the Perl code to generate the new feature that the Java code was testing for. Development was fast and fluid. Deployment was very smooth for a CGI. The only semi-major defect I found was that I hadn't uncommented the line \"use CGI qw(carp);\", which was disabled for offline testing. -- [[John Brewer]] ",
            "id": "729ec66567d2705d3a4b35fa00090e7d"
          },
          {
            "type": "html",
            "text": "\nWhat about [[Micro Soft]] [[Active Server Pages]] (ASP), which have embedded script (code) that generates the HTML? ",
            "id": "46250dbc3f8636b5ee54b16db1116a1f"
          },
          {
            "type": "html",
            "text": "\nOh, ick. ASP is all about embedding the code in the web page. You'll want to push everything even slightly complicated into external objects called from your ASP script code. Then you can [[Unit Test]] those external objects. -- [[John Brewer]] ",
            "id": "4b224204d4a052def87812b31287ff33"
          },
          {
            "type": "html",
            "text": "\nNot anymore in ASP+ ",
            "id": "4bd7da6e94d98508ee95cd02932c715e"
          },
          {
            "type": "html",
            "text": "\nI agree. I program mainly in Perl and put all of the real stuff into objects. Lately I've been writing [[Unit Test]]s for everything (after I code the functionality; I'll try beforehand) and it makes everything much nicer. You do have to test the HTML output (for browser compat, etc ...) but at least you know that the core of the app already works. -- [[Dave Tauzell]] ",
            "id": "ce2ec159c33797e0a93f7ca0ce33e168"
          },
          {
            "type": "html",
            "text": "\nHas anyone used XP with [[Procedural Language]]s? How did you adapt it? -- [[Jim Hart]]",
            "id": "ce93f2c8a345abfcf7d19ef8c3f943f2"
          },
          {
            "type": "html",
            "text": " What makes you think it needs adapting?",
            "id": "5f629e2b193a4f88108082fdb0bdaac3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "People have been doing so much [[Test First]] that there has been a growing interest in [[Test Driven Programming]], and claims that there may be something to [[Test First Design]]. -- [[Erik Meade]] ",
            "id": "74e1a1d07d877d042b043e7ad827c1a9"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "Is writing only [[One Unit Test Ata Time]] a requirement? ",
            "id": "898bc6cda16e3b5228308c005e650cb0"
          },
          {
            "type": "html",
            "text": "\nThe object is to write, test, and resolve one line of a UT at a time. This minimizes the number of changes before you check for mistakes, thus minimizing the number of places the mistake could be at. ",
            "id": "64d398e76c31432703db8a679ddb8e31"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "When you [[Code Unit Test First]] (manually) you could let a machine (automatically) implement classes to check against the test until the test is satisfied. This way extreme testers can move the complexity of developing some stuff to developing some tests for the stuff. I think the complexity is same. That is why I [[Dont Write Unit Tests]]. -- [[Albrecht Scheidig]] ",
            "id": "4ab3fba29f2f522306100425b2c6a27d"
          },
          {
            "type": "html",
            "text": "\nHow do you know your program works? ",
            "id": "74247e2e128efcf7284111d6d2172197"
          },
          {
            "type": "html",
            "text": "\nI do not know (but it sells). How do you know your test works? -- [[Albrecht Scheidig]] ",
            "id": "6a399255e71287acc1247365860b3049"
          },
          {
            "type": "html",
            "text": "\nWe know our tests work because they fail before we write the code, and pass afterwards. At this point, we know that our code works. -- [[Laurent Bossavit]] ",
            "id": "02954f6a2286879afe58f4516574cff5"
          },
          {
            "type": "html",
            "text": "\nYou could also write a wrong test, that fails before you write the code, and pass afterwards. At this point, you have a wrong test and a matching, wrong code. How do you avoid errors when you write test code? Do you write test code for the test earlier? And what about that meta-test-code? Etc. ",
            "id": "59092dca457969dca3c6917f306181b8"
          },
          {
            "type": "html",
            "text": "\nSee [[Bugs In The Tests]]. In a nutshell : it could happen... but then, you could also get run over by a car tomorrow. In both cases, you don't worry about it all the time - you just look both ways before you cross the street, and you avoid writing complex test code. ",
            "id": "9475a2dffd45775423643503cd7f827f"
          },
          {
            "type": "html",
            "text": "\nAnother thing to consider is that while you could, in principle, automate the generation of code that passes the test, that would be unlikely to yield valuable results. Rather, coding test-first lets you focus, all the time, on two sides of a single question : what do I need the code to do (the test) and how does the code do it. Both aspects involve conceptual reasoning that could not be automated. -- lb ",
            "id": "d3d6fc52d5af1c07335dba2a61aeaef2"
          },
          {
            "type": "html",
            "text": "\nThe test verifies the code and the code verifies the test. You have written two different implementations of the same problem and the likelihood of having made the same mistake in both is very low. When a test fails, you really do not know if the test or the code is at fault, however, since the test is usually much simpler than the code, it is most probable the fault is in the code. -- anon ",
            "id": "141473d8de733fa87270dc984b9db501"
          },
          {
            "type": "html",
            "text": "\nYes, it is not very likely that you mistype in both the test and the code in a way that the test passes, but: What if you are conceptually wrong? You write a wrong test and very likely a matching wrong code. What if you are conceptually right? You write the right test and very likely a matching right code. So why not automate the generation of an implementation of the interface expressed by the test? Because if I do it manually I have twice the time to think about the concept? -- as ",
            "id": "2eaf2a3d6e5ff7d2aa3deef3b4f4e513"
          },
          {
            "type": "html",
            "text": "\nI don't think you can \"automate\" the writing of code that passes tests - it's an AI-complete problem. Yes, having to think about \"what I want the code to do\" and then having to think once more about \"how does the code do it\" is what protects you against conceptual errors. But you have to do both anyway; no program will do either kind of thinking for you. -- lb ",
            "id": "9710d386a819b463918a0f9bde8d1d95"
          },
          {
            "type": "html",
            "text": "\nThe only way to be \"conceptually\" wrong is miscommunication with your users concerning the requirements. The only real way to resolve this (in any development approach) is to get the software into the hands of the users. [[Code Unit Test First]] ensures that the program works as intended, it does not verify whether the intentions were correct. ",
            "id": "bb8330736a889225dd334e188b367f4e"
          },
          {
            "type": "html",
            "text": "\nAs for having an automated way of generating code from tests, let me know when you find one. Until then, however, I am stuck having to write my own code. ",
            "id": "dfc896caa39debff9dbbe8bc47f2dbf9"
          },
          {
            "type": "html",
            "text": "\nThere is Genetic Programming, which does exactly that. BUT you would need a vast amount of test cases... -- [[Gerriet Backer]]",
            "id": "b8157f5920eef6cd176b68bd80a01645"
          },
          {
            "type": "html",
            "text": "\nI have found an algorithm for automated programming, but I cannot express it... ",
            "id": "1be686d9a3530e13dde18f2f83398fe7"
          },
          {
            "type": "html",
            "text": "\nLet me summarize it: [[Unit Test]]s are highly recommended for developers that tend to concentrate on implementation and technical details (How much percent will that be?). [[Unit Test]]s require to think about specifications, interfaces, external views, \"what I want the code to do\". [[Code Unit Test First]] is a rule that says: \"Think first about what the code should do before you think how the code can do it.\" An excellent side effect is that the output ([[Unit Test]]s) provides test mechanisms that can be executed by the machine and are independent of implementation changes. -- as ",
            "id": "3a3b355ca56b89de026cc3414cc8194b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "A thought that I'm playing with is the task of writing \"[[Unit Test]]s\" after the units themselves (classes) have been written. ",
            "id": "d4a514fc862991ebccdd1724d6e553e9"
          },
          {
            "type": "html",
            "text": "\nMy current thinking is that this task is nearly impossible. Once the code is written, the sorts of tests I can write against it tend to be tests which describe the behavior of the implementation, not tests describing the needs which the implementation was addressing. ",
            "id": "0ed70926a87176389365a5f5b254e169"
          },
          {
            "type": "html",
            "text": "\nConsequently, I find that when I [[Code Unit Test Later]], I end up with tests which don't help me at all when I try to refactor. It's like I've surrounded the code with a thick, hard crust of tests that actually inhibit refactoring, rather than supporting it. ",
            "id": "a0d411228267edd8b826d55b96854918"
          },
          {
            "type": "html",
            "text": "\nNot surprisingly, I also notice that the character of these after-the-fact \"[[Unit Test]]s\" resembles the character of acceptance tests much more closely than [[Test First]] style [[Unit Test]]s. -- [[Eric Herman]] ",
            "id": "65246a0ebb6f7565e435b4d98bcb7fde"
          },
          {
            "type": "html",
            "text": "\nPerhaps a useful tactic would be to code the [[Unit Test]]s specifically for the purpose of helping you refactor. For instance, I recently found myself - pairing with a junior coder - working on an awkward method gleaned from an untested JSP page that pried into private details of other classes; we wrote an \"outer\" test to pin down the behaviour, then started extracting bits of the code into other methods, writing one or two [[Unit Test]]s for each extracted method. Pretty soon we had three or so classes and an interface, with a more balanced design, tests that didn't look like mere afterthoughts, and two significant bugs fixed. We did have some inelegant code still lying around but... \"it's a [[Green Bar]], let's go home\". ",
            "id": "6425e4c4b4fc13ab39033a85e7451137"
          },
          {
            "type": "html",
            "text": "\nEven after-the-fact [[Unit Test]]s help if they are written with the attitude of [[Test First]] style tests. ",
            "id": "41c2e6ebef19c47cb4af056be037d63f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "I find it curious given the above that many people have expended time and effort writing tools to generate test cases from existing classes (I do realize this may be useful in a legacy situation). You can find examples at [http://www.junit.org/ www.junit.org]. Look under the IDE section, and there's more under the extensions section. No one seems to have attempted [[Code Generation]] in the other direction. ",
            "id": "8d530d64eb5ec008eec0a2afc22a8e8a"
          },
          {
            "type": "html",
            "text": "\nWhile there is some comment further up that writing (working) code from tests is an 'AI complete problem' it is surely not that hard to generate method signatures by examining test methods. I doubt generating code to pass tests is what people need from a tool anyway - generating code fragments is the time-saving step, and generating code to fail tests is a little easier. Just throw a [[Runtime Exception]], or the equivalent in your [[Language Of Choice]]. <i>I love the [[Eclipse Ide]] little red x cue-balls that with a couple of clicks add classes, fields, and methods to the code being tested by my unit tests. Still have to do the method bodies by hand of course.</i>",
            "id": "06fbc17be42cfe15d47f1816dc812ad5"
          },
          {
            "type": "html",
            "text": "\nBy not that hard (since doubt was expressed above) what I mean is this: work so that your test class is named the same as the tested class up to a 'wart' (eg Money and [[Money Test]]). An intelligent editor like emacs can then figure out the intended class name by removing the wart. Next, search for variable declarations. Next, look for method calls on those variables which have the same type as the tested class. Determine (a) method signature required by examining the variables or constants passed in (remember we already know the variable types). Finally open the class under test, check to see if the required methods exist, and insert them (possibly interactively) if they don't. A complete language parser is not required for any of this, the mechanics are there in any language-aware editor in order to fontify, indent, and navigate code. ",
            "id": "646615c88928c5e0570c1f39e2d09943"
          },
          {
            "type": "html",
            "text": "\nIt will not generally be practical to produce an exhaustive set of unit tests for a given function. It would just take too long. Take for example a unit test for a routine which implements y=sin(x). You can feed it various samples and possibly test some boundary cases, but you will not be able to test all values of input/output. Thus, the unit tests underspecify the function and could not be used to generate the function's behaviour other than at the points that are tested.",
            "id": "e021c751a869cfc3f8e5c0df4de39542"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "y=sin(x). ",
            "id": "30f29c2124b09bb586135f1510c36286"
          },
          {
            "type": "html",
            "text": "\nHere is the complete test:\nsin(x) = x - x^3/3! + x^5/5! - x^7/7! + x^9/9! - ... + (-1)^(n-1)*x^(2n-1)/(2n-1)! + ... go on until you run out of precision.",
            "id": "50feb8c3ad06c1d33c06bbc1c9e8c8a8"
          },
          {
            "type": "html",
            "text": "\nDefinitions:  ",
            "id": "37427a405e1fd55b9d292774dce672db"
          },
          {
            "type": "html",
            "text": " x^n is the regular power function: x * x * .... * x  (n x's multiplied together) ",
            "id": "28df85a72dbbeaaee339bae07d6e408d"
          },
          {
            "type": "html",
            "text": " k! is the factorial function: k * (k-1) * (k-2) * ... * 2 *1 (example: 5! = 5*4*3*2*1 = 120) ",
            "id": "7e849aadd350a99032bc42ee12f5ea86"
          },
          {
            "type": "html",
            "text": "\nExhaustive testing may be necessary in medical equipment like pacemakers.\tYou want to get it right before you use it in real life.",
            "id": "8a49bbec39cd405e17ba64c97b1dbbff"
          },
          {
            "type": "html",
            "text": "<i>\"...you will not be able to test all values of [x].\"  The infinite sum above provides a mathematical verification of one value.  On a machine with 64-bit floating-point math, you will wait a long time for 2^64 iterations of the algorithm.  How does your machine respond to special floating-point values like Infinity or [[Nota Number]]?  How does your machine respond to mathematical functions when tested at discontinuities?</i>",
            "id": "0db2b97ebc24ce0c22e17b130c8fbcc8"
          },
          {
            "type": "html",
            "text": "<i>In safety-critical or life-critical applications, it may not be sufficient to verify code with more code.  It is possible (though unlikely) that the [[Unit Under Test]] implements the same algorithm you have devised for the [[Unit Test]].  In any case, to satisfy certification criteria you may need to manually verify that your [[Unit Test]] produces a correct result to compare with the [[Unit Under Test]].  Manual verification cannot be performed exhaustively within any reasonable scope of time.</i>",
            "id": "5e2fcf875a0bab479910cb8fbbe3f30d"
          },
          {
            "type": "html",
            "text": "\nIf only all functions were periodic, had bounded derivatives, and could be decomposed into monotonic pieces!  There are three ways to comprehensively verify a function:  formal methods, a comprehensive list of inputs and outputs, and a trusted function to compare against.  Depending on the accuracy requirements, it may be quite easy to provide a trusted function that is easy to prove correct but is unsuitable as an implementation.  For instance, if sin(x) is required to give a value within d of the \"correct\" answer, you can create a lookup table implementation of sin(x) that is proven to be accurate within d/3, then verify that sin(x) gives answers within 2d/3 of the table.  Since sine is so well-behaved, it is easy to produce such a table, and it will be small for reasonable values of d.  Another way that a relaxed standard of accuracy simplifies the problem is that it may be possible to restrict the number of inputs.  If you have a formally verified 64 bit -> 16 bit converter, you can compose it with an exhaustively tested 16 bit -> 64 bit sin function to get a 64 bit -> 64 bit sin function of known accuracy.  ",
            "id": "5cde390a72bb5cc888e4a85999dde39c"
          },
          {
            "type": "html",
            "text": "\nProducing a verified 64 bit -> 64 bit sin function that is correct for almost all of its bits of precision is much harder, but even this task can be cut down considerably by producing a formally verified modulus function, verifying sin1 on [0, 2pi), and implementing sin(x) as sin1(mod(x, 2pi)). ",
            "id": "0549ad5460c2d055bc18ab5de4c70f12"
          },
          {
            "type": "html",
            "text": "\nPerhaps these methods seem too heavyweight to qualify as [[Unit Test]]s<b></b>, but I imagine that in the situation you describe, changes to the sin function would be undertaken with great care and deliberation, and these methods would be used much like [[Unit Test]]s<b></b> are -- to decide when code is ready for integration, to check whether changes broke the code, etc.",
            "id": "f3462fc8ec7a4efaa2771fd98dc347df"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "Is it necessary to write [[Unit Test]]s that don't fail the first time they are run? See [[Unit Tests That Dont Break]]. ",
            "id": "f9df438b67065b97c4775bdbbc21c451"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "For an interesting take on [[Code Unit Test First]], see [[Code Unit Test Third]]. ",
            "id": "e3d9f1e2c2342189a898d7c62c1394d8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "I want to know how to covert legacy code to [[Extreme Programming]]. It would seem that what is needed is to add tests to the legacy code so that you can do the refactoring. Does anybody know how to do this? -- [[Jon Grover]] ",
            "id": "7aca64d3afd3ae3c1d9bceba79c30c5b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "Moved from [[Unit In Unit Test Isnt The Unit You Are Thinking Of]] ",
            "id": "c2eb10ba9c948dc2c9e6de5f6a6ba0c0"
          },
          {
            "type": "html",
            "text": "\nInteresting fact-ette about this 'radical' [[Code Unit Test First]] philosophy: it may not be so new after all. My mother started her career as a PL1 and COBOL programmer way back when computers were larger than my house. We were chatting recently about XP and she mentioned that when she started all developers were required to write a unit test plan before they went near any code. The test plan was then used as the basis for the code. I'm guessing that compile and debug times were so much greater that they simply couldn't afford to spend ages fixing silly mistakes. Perhaps its one of those universally good ideas that was simply forgotten about for a while, probably during the excitement of seeing the first computer that was small enough to fit on your desk... ",
            "id": "40028460253e37d80c3faa8d4f503baa"
          },
          {
            "type": "html",
            "text": "\nThose who do not learn from history are doomed to repeat it. Guess we programmers prefer thinking about the future to studying history. ",
            "id": "8409092fa0e406f2ddaab9fc09cf1d6b"
          },
          {
            "type": "html",
            "text": "-- [[Darren Hobbs]] ",
            "id": "e9b22aedf70b950e0e929fbc93ae06c7"
          },
          {
            "type": "html",
            "text": "\nThat is interesting. Could you get your mother to expand a little on what was in a \"unit test plan\"? ",
            "id": "e7f79f87733d78bab708cda2ff39343f"
          },
          {
            "type": "html",
            "text": "\nIt's a curious thing about our industry: not only do we not learn from our mistakes, we also don't learn from our successes. -- [[Keith Braithwaite]] ",
            "id": "4f1e1af30c7dfa921cacdba4644b4aa9"
          },
          {
            "type": "html",
            "text": "\nUnit Test First programming in PHP",
            "id": "d10b439d81b3ec09c1b162cd8c9bc8d7"
          },
          {
            "type": "html",
            "text": "\nI tried the above the other day, just for the heck of it ... It's actually far smoother than you'd expect. Here are the steps I went through:",
            "id": "8fca61dc5940de58dd9f0efcbcc06bc9"
          },
          {
            "type": "html",
            "text": " I installed the PHPUnit package from pear.php.net",
            "id": "44bd4afd93d391456ab856809238ae1b"
          },
          {
            "type": "html",
            "text": " I used it as described above :)",
            "id": "db98d646fef9f91096cf02eaaa1e89d6"
          },
          {
            "type": "html",
            "text": "That's it. It actually ended up being no different from coding with a Java tool... Of course, I had to use proper OO design in my script for the unit-testing to be effective, but that's probably a good thing, so I can safely say that not only unit-testing in PHP was easy, but that it improved my code.\t",
            "id": "928646293fb76aaf65755dad03ae94ff"
          },
          {
            "type": "html",
            "text": "-- [[Danny Cook]]",
            "id": "54f79632c628ce02a850c8f3e2de6e15"
          },
          {
            "type": "html",
            "text": "\nAm I missing the point somewhere? Unit testing always sounds like a good idea to me, until I come to actually start using it, at which point I get bogged down in problems. Allow me a real life example: I am currently writing a database application, and I have a function which simply adds a record to a table, using some details passed in as parameters. Very simple, but certainly possible to fail, so it needs a test. How do I test it? It seems that a test would need to relocate the record which has just been added, then read it and check that the correct information was written to it. This is actually more complicated than the original function, and more prone to errors. Which surely defeats the object! What should I be doing? -- Chris Sandow",
            "id": "6d3a2152f3de0d4bf9ab1eba66cf7211"
          },
          {
            "type": "html",
            "text": "\nAn approach is to save the record that was added, do a get, and then compare the records.\nDepending on your system this can be made generic. -- [[Anonymous Donor]]",
            "id": "90f589913a60002155a5693cd7996438"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "What about testing classes which produce graphical output which cannot be tested by simply comparing every pixel with a test image? For example, one might create a class which has only one publicly accessible function named \"drawStuff()\". drawStuff() uses OpenGL to draw some stuff. One cannot simply compare the pixels because the graphical output will most likely vary between various OpenGL implementations and will depend on the hardware. How do you write a unit test first for something like that? What if the output is very complex making it very hard to have a test image made prior to the test? -- tomek",
            "id": "4ccead0a22b9cd4a5358796e867c3d9f"
          },
          {
            "type": "html",
            "text": "<i>Well, you can still guarantee a few things about the function: you know that under such-and-such conditions, it will produce an image, and will not throw an exception or some fatal error. Depending on your application, you may also be able to say that it should throw an error under certain other conditions and check that it does. You can also check some basic things about the image: it should have a size in a certain range (a 1x1 image is probably an error), it shouldn't be all one color, the image produced by input A should be different from the one produced by input B, etc.</i>",
            "id": "c07055da47fc78a9871c25b75117d4a4"
          },
          {
            "type": "html",
            "text": "<i>Then of course you add to this basic unit test as bug reports come in - as soon as a bug is reproducible, write a unit test that fails because of the bug. Then fix the bug and re-run the test.</i>",
            "id": "cf223eecbe711952b330516faaf39874"
          },
          {
            "type": "html",
            "text": "\nIf you are in a situation in which defining the expected output seems equally difficult as actually producing it, maybe you are trying to test at the wrong level of abstraction (too much at once). Quite probably, your complex function can be split into multiple helpers, the output of which is easier to check. Take one further step and you will find yourself dealing with multiple objects. If these components all produce correct output given their inputs, and if the master object (formerly the complex function) composes them together correctly, then the whole test passes. Note that the correctness of the master (putting the components together appropriately) should be testable even without their concrete implementations, by relying on [[Mock Object]]s. The only concern is that by making your code testable in this manner (following [[Code Unit Test First]]) you might sacrifice the necessary performance. I guess you can always optimize (and obfuscate) your perfectly correct code later on, though.",
            "id": "ae755dcff03c4f9da38ebf6ea9c822c9"
          },
          {
            "type": "html",
            "text": "\n[[Code Unit Test First]] is (almost?) always technically possible, but it is difficult. Don't believe those who tell you it's \"sooo easy\". No, it takes extra time and consideration, and it takes practice to get there. Sometimes the time and consideration is better spent on other activities - my favorite example is learning/exploring/experimenting with code. Does XP advocate programming \"spike solutions\" with the [[Code Unit Test First]] approach? I would argue that if you know that you are going to throw away your tests in the next hour together with your experimental code), don't write them. Writing tests slows you down in the short term. Admit it.",
            "id": "174173ac8291595931e1456c7b61b83a"
          },
          {
            "type": "html",
            "text": "<i>Everything I've read says don't write unit tests for spikes or prototypes. Maybe that was just [[Kent Beck]]. Anyway you can probably just use the [[Pair Programming]] rule that says only do it with production code.</i>",
            "id": "ad4bb5ca10997ee1c5dfcc7f1995c3fc"
          },
          {
            "type": "html",
            "text": "\nI think one should look at why he is doing the spike or prototype.  If one is merely trying to learn about a particular development environment, language, etc., then tests are not necessary.  In other words, don't write tests for \"Hello World\" programs.  If, however, one is trying to prove or disprove something, write the test.  The test is an explicit definition of what one is trying to prove, and it is invaluable when explaining to others the result of the spike.  Everyone will know exactly what was verified and can reproduce the result.",
            "id": "937aa0e78f3d7261629f9315a53b016a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "Coding [[Test First]] is like climbing with protection. You wedge various pieces of gear into the face of the rock and you have your partner belay a rope attached to you so that when you fall off, as you will frequently, you won't waste your time with being injured.",
            "id": "da84023dea853744d4ae3668e8f0cd4e"
          },
          {
            "type": "html",
            "text": "\nA [[Spike Solution]] is like free-climbing. No gear, no one to belay you, just you and the naked face of the rock. A really skilled climber can just zoom up the mountain, almost like skiing in reverse. But pride comes before ...",
            "id": "7d62cc9654501a85f66d9b84150ff4d5"
          },
          {
            "type": "html",
            "text": "\nSomething I want to try:  after I write a Spike which does the job, or some piece of it, I want to refactor it into a set of tests, kind of like the [[Fake It]] method of writing unit tests in reverse.  Not sure how it'll turn out, anyone else ever try anything like this?",
            "id": "87f24ae45a15baa7ed5ae02fdbc7b4d3"
          },
          {
            "type": "html",
            "text": "-- [[William Underwood]]",
            "id": "af4bce50981a709f6a5b010c553cc97e"
          },
          {
            "type": "html",
            "text": "\nActually, my usual development method ([[Stop Using The Word Methodology]]) is like this. Except that I usually don't end up automating the tests (at least not very well); I just keep a set of things to test in mind, and run my \"suite\" with every recompile. This works well with games because of the \"I know (in)correct behaviour when I see it\" problem, but you end up with tests that are more [[Regression Test]] than [[Unit Test]] in nature.",
            "id": "f46073debe6139a0cde36919dfcd6443"
          },
          {
            "type": "html",
            "text": "\nI do things like this because frankly, trying to write the tests first feels tedious to me - it slows me down <b>artificially</b>, because of psychological factors (i.e. the first test - as well as the process of refactoring towards a solution for the first few tests - seem to insult my intelligence, because I've already figured out how to generalize things. I'd like to start a new page about that, but I'm not sure what to call it...).",
            "id": "25caecd4553bc1e7473574488e912a22"
          },
          {
            "type": "html",
            "text": "-- [[Karl Knechtel]]",
            "id": "3ed8722414b7e5c3f478e16ba4f9f604"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "I'm wondering about [[Test First And Functional Programming Synergy]], and if it is worth keeping in mind while writing tests and refactoring. -- [[David Plumpton]]",
            "id": "4ac8fcc31addbd9d46a82a4bedc46536"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "See [[Test Driven Development For Aggregate Methods]]",
            "id": "f3d17213669b540444d0f89bebf4b232"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "\nI think there may be something slightly naive about the idea that you could write a unit test for a non-trivial method before you write the code for it. I think this comes from the assumption that you know enough to write a unit test once you have the signature, or even the complete \"contract\" to its callers, of the method under test. In order to write a unit test you must also have a clear specification of all the objects and their methods which your particular method under test uses and how it uses them. In other words, you need to know the \"calling out\" contracts as well as the \"calling in\" one. Then your unit tests can use [[Mock Objects]] to simulate the call-outs and to check they are correctly used.",
            "id": "32cb2c56f600454db82e055978403dc4"
          },
          {
            "type": "html",
            "text": "\nIn my opinion, this extra \"specification\" of a method is probably best documented simply by writing the code for the method (see [[Design From The Inside Out]]), and that actually ends up with you writing the code for a method before its unit test. [[Richard Develyn]]",
            "id": "6bbba051cba747aa0f689c9186c20361"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "(I took this comment out of the main body of my text)",
            "id": "81a55f28c4a21136f74a8ab0ff43f382"
          },
          {
            "type": "html",
            "text": "<i>Solution: Don't write non-trivial methods.</i>",
            "id": "29380618cd7253610fae8b31aef53f72"
          },
          {
            "type": "html",
            "text": "\nAny method which uses another object is non-trivial in the context of the discussion above. It isn't possible to avoid these. -- [[Richard Develyn]]",
            "id": "fcae1fe96ad8ece0edb8c39c76a2f434"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "I can't see how to apply this to programs that produce complex PDF reports.  I work for a document-processing company.  We take data files from our customers, and print bills, statements, etc. to PDF.  If we were doing plain text reports, we could create a test output file by hand and use diff to check the program-generated output.  I actually tried creating a PDF mock-up by printing from Word to Acrobat, but even though the PDF looks a lot like the one generated out of my code, the files are totally different. -- [[Kevin Kleinfelter]]",
            "id": "076cbfb225a67d7f51e0acf4fe38b350"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "I did something similar but wrote a system to generate word documents from data using the Aspose component. I found it was impossible to test the actual content of the document, as there is no way to get to it - but I could write tests for the framework that built the document. I also wrote tests for the gateway classes that retrieved the data for the document. Not perfect I guess, but there was no easy way to navigate through the document to verify the data. I suppose you could use mock objects and verify that all calls are being correctly made, then at least you would have some confidence in the interactions, if not the state. -- Gareth Jones",
            "id": "a27d9b82c3c5682a35d8fe50bfe67a72"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "How should we go about [[Choosing The First Test]]?",
            "id": "e308a6ce41c8b27e43b71896cd5b3364"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "21402e25fa3b621d1c2c32cdfca833f2"
          },
          {
            "type": "html",
            "text": "[[Category Extreme Programming]] [[Category Testing]]",
            "id": "f9be3a857481a4c8a08da23b166866d9"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?CodeUnitTestFirst c2.com]",
            "id": "3bc86df2613bab6a20cdcb85bd7280b2"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1705840205531
    }
  ]
}