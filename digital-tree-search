{
  "title": "Digital Tree Search",
  "story": [
    {
      "type": "paragraph",
      "id": "cccda01fcad789b0",
      "text": "In order to provide binary data for this illustration, the words have been expressed in [[MIX]] character code, and the codes have been converted into binary numbers with 5 bits per byte. Thus, the word WHICH is represented as the bit sequence 11010 01000 01001 00011 01000. (TAOCP, v. 3, p. 496)"
    },
    {
      "type": "paragraph",
      "id": "bc7a70335e911218",
      "text": "To search for this word WHICH in Fig. 32, we compare it first with the word THE at the root of the tree. Since there is no match and since the first bit of WHICH is 1, we move to the right and compare with OF. Since there is no match and since the second bit of WHICH is 1, we move to the right and compare with WITH; and so on. Alphabetic order of the keys in a digital search tree no longer corresponds to symmetric order of the nodes."
    },
    {
      "type": "paragraph",
      "id": "1faae8f5e7b676df",
      "text": "The first method, which we call digital tree search, is due to E. G. Coffman and J. Eve [CACM 13 (1970), 427–432, 436]."
    },
    {
      "type": "paragraph",
      "id": "5808eb11b4e4afb1",
      "text": "The idea is to store full keys in the nodes just as we did in the tree search algorithm of Section 6.2.2, but to use bits of the argument (instead of results of the comparisons) to govern whether to take the left or right branch at each step. Figure 32 shows the binary tree constructed by this method when we insert the 31 most common English words in order of decreasing frequency."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Digital Tree Search",
        "story": []
      },
      "date": 1695047730502
    },
    {
      "item": {
        "type": "factory",
        "id": "1faae8f5e7b676df"
      },
      "id": "1faae8f5e7b676df",
      "type": "add",
      "date": 1695047746433
    },
    {
      "type": "edit",
      "id": "1faae8f5e7b676df",
      "item": {
        "type": "paragraph",
        "id": "1faae8f5e7b676df",
        "text": "The first method, which we call digital tree search, is due to E. G. Coffman and J. Eve [CACM 13 (1970), 427–432, 436]. The idea is to store full keys in the nodes just as we did in the tree search algorithm of Section 6.2.2, but to use bits of the argument (instead of results of the comparisons) to govern whether to take the left or right branch at each step. Figure 32 shows the binary tree constructed by this method when we insert the 31 most common English words in order of decreasing frequency. In order to provide binary data for this illustration, the words have been expressed in MIX character code, and the codes have been converted into binary numbers with 5 bits per byte. Thus, the word WHICH is represented as the bit sequence 11010 01000 01001 00011 01000."
      },
      "date": 1695047747907
    },
    {
      "type": "edit",
      "id": "1faae8f5e7b676df",
      "item": {
        "type": "paragraph",
        "id": "1faae8f5e7b676df",
        "text": "The first method, which we call digital tree search, is due to E. G. Coffman and J. Eve [CACM 13 (1970), 427–432, 436]. The idea is to store full keys in the nodes just as we did in the tree search algorithm of Section 6.2.2, but to use bits of the argument (instead of results of the comparisons) to govern whether to take the left or right branch at each step. Figure 32 shows the binary tree constructed by this method when we insert the 31 most common English words in order of decreasing frequency."
      },
      "date": 1695047825211
    },
    {
      "id": "cccda01fcad789b0",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "cccda01fcad789b0",
        "text": "In order to provide binary data for this illustration, the words have been expressed in [[MIX]] character code, and the codes have been converted into binary numbers with 5 bits per byte. Thus, the word WHICH is represented as the bit sequence 11010 01000 01001 00011 01000. (TAOCP, v. 3, p. 496)"
      },
      "after": "02663077be2ee8ea",
      "attribution": {
        "page": "2023-09-18"
      },
      "date": 1695047830047
    },
    {
      "type": "edit",
      "id": "1faae8f5e7b676df",
      "item": {
        "type": "paragraph",
        "id": "1faae8f5e7b676df",
        "text": "The first method, which we call digital tree search, is due to E. G. Coffman and J. Eve [CACM 13 (1970), 427–432, 436]."
      },
      "date": 1695047889992
    },
    {
      "type": "add",
      "id": "5808eb11b4e4afb1",
      "item": {
        "type": "paragraph",
        "id": "5808eb11b4e4afb1",
        "text": "The idea is to store full keys in the nodes just as we did in the tree search algorithm of Section 6.2.2, but to use bits of the argument (instead of results of the comparisons) to govern whether to take the left or right branch at each step. Figure 32 shows the binary tree constructed by this method when we insert the 31 most common English words in order of decreasing frequency."
      },
      "after": "1faae8f5e7b676df",
      "date": 1695047890615
    },
    {
      "item": {
        "type": "factory",
        "id": "bc7a70335e911218"
      },
      "id": "bc7a70335e911218",
      "type": "add",
      "after": "cccda01fcad789b0",
      "date": 1695047958685
    },
    {
      "type": "edit",
      "id": "bc7a70335e911218",
      "item": {
        "type": "paragraph",
        "id": "bc7a70335e911218",
        "text": "To search for this word WHICH in Fig. 32, we compare it first with the word THE at the root of the tree. Since there is no match and since the first bit of WHICH is 1, we move to the right and compare with OF. Since there is no match and since the second bit of WHICH is 1, we move to the right and compare with WITH; and so on. Alphabetic order of the keys in a digital search tree no longer corresponds to symmetric order of the nodes."
      },
      "date": 1695047960217
    }
  ]
}