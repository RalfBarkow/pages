{
  "title": "Heisen Bug",
  "story": [
    {
      "type": "html",
      "text": "A [[Heisen Bug]] is a bug whose presence is affected by act of observing it. ",
      "id": "c3c1a38773f49fc8c55077d8a4050bd9"
    },
    {
      "type": "html",
      "text": "\nFor example, a bug which disappears in debug mode. It's normally dispersed by depressing dangerous digits in the direction of the dirty dangling doughnut. ",
      "id": "ab2893776000a65212d2c3244c164946"
    },
    {
      "type": "html",
      "text": "\nFor more examples, see [[Heisen Bug Examples]].",
      "id": "da5a5aa8a85a0edc548202fe2b7db434"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "Wow, that happened to me...",
      "id": "2a9f6cf86773917fd41a98ec24aaada5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "Back when I was hardware troubleshooting, a wise supervisor corrected my use of the phrase \"intermittent problem\". \"There is no such thing!\", he pronounced,  \"But some problems do have intermittent symptoms!\"",
      "id": "3ca55e9238039a467a6defcceb52bbd8"
    },
    {
      "type": "html",
      "text": "<i>This gives rise to the rather philosophical question: If no symptoms manifest, does a problem exist?</i>",
      "id": "e570a69fdfa7ca90151e2297e2f98280"
    },
    {
      "type": "html",
      "text": "\n[http://paul.merton.ox.ac.uk/computing/msbug.html paul.merton.ox.ac.uk]",
      "id": "363baa2644477e09551f71442e3f4bf0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "Once I had a bug which appeared only during step-by-step debugging. The Delphi debugger can display values of properties of objects. The values of properties can be computed by methods which can modify the object. So when I stepped through the code, the debugger displayed the value of the property and modified the observed object. Very confusing. ",
      "id": "fc30c9bb4b2898860d0f57e53db80fab"
    },
    {
      "type": "html",
      "text": "<i>So you had a method to tell you what the properties of some object were, but that method actually modified the object? I'm confused as to how this can ever be a [[Good Thing]] and would appreciate being enlightened.</i>",
      "id": "ed26d9ae1cd7fd7dfb32c2b7bb59ab9a"
    },
    {
      "type": "html",
      "text": "\nYes. I am not sure whether this is always a [[Bad Thing]], it was kind of [[Lazy Initialization]]. However in this particular case it was really confusing obscure stuff deep in the Delphi's framework VCL. The problem was that in the Watch window I have had displayed some properties of some object. I was debugging through the code trying to find out, when the method Initialize is being called. So I placed a breakpoint into the method Initialize and debugged some other methods. When I jumped over one method, Initialize has been called right after the other method terminated; when I debugged the method step by step, Initialize has been called right after the first line. Actually, the Watch window updated itself every time the debugger interrupted the program. So, after every break, the Watch window read the property and the property read-method called Initialize. So not the normal flow of the program, but the debugger called the method Initialize. A very true [[Heisen Bug]] indeed.",
      "id": "f0c895ac45a24d388ff4fa33a3ba624f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "Here's one really nasty typo-turned-[[Heisen Bug]]:  \"assert( x = 5 );\"...  -- [[An Aspirant]]",
      "id": "1b4d9a1857eb76428eec6698843e5aff"
    },
    {
      "type": "html",
      "text": "<i>See [[Assert Idea]]</i>",
      "id": "a07a9a6eb59ad6fc2263e48971221761"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "I tripped over one of these \"debugger changed my code\" bugs.  [[Visual Studio]].NET allows me to put conditions on a breakpoint, but no one bothered to check whether the code I entered was a boolean phrase.  It's surprising hard to see the difference between \"x == 5\" and \"x = 5\", especially with some fonts.",
      "id": "dac8a7ad2c8beff4a8666bb2813dd72b"
    },
    {
      "type": "html",
      "text": "\nInterestingly enough, you can put any code in the breakpoint condition.  And I do mean \"any\".  -- [[Dean Chalker]]",
      "id": "86f60278d5e1d0b3b990e4b429cf86c5"
    },
    {
      "type": "html",
      "text": "<i>To avoid this [[Compare Constants From The Left]]. And see also [[Code Complete]] or [[Writing Solid Code]].</i>",
      "id": "4d1987f82cf8c53889a0fb9d1e4fae63"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "I had a similar problem with MS [[Dev Studio]] (C++) a few years back. Calling a third-party DLL (DB driver) caused GPF problems that were unreproduceable in debug mode, regardless of whether I was stepping through or letting it run (which is why it didn't show up during regular dev testing, but was instead caught by the external testers). Turns out that the compiler optimizations were turned off by default in debug mode, and turned on in release mode, and it was the optimization module in [[Dev Studio]] that introduced the bug. Turning on optimizations in debug let me watch the call into the DLL tromp the stack below the calling point for the function, thereby trashing data that didn't belong to the DLL. Nice. Turning optimization off for the compilation of the file that called the DLL function in question removed the problem. (As it turned out, I discovered the same problem with a driver DLL for a different DB by another vendor, which reinforced the probability that the problem really was with [[Micro Soft]]'s C++ optimizer.) -- [[Earl Jenkins]]",
      "id": "016799ecdd922b434c93589442705904"
    },
    {
      "type": "html",
      "text": "\nI've had plenty of similar bugs that appear in release builds but not in debug builds.  Without exception, the problem has always been a bug in my code.  When you tell MSVC to compile in debug mode, it puts padding on the stack so that it can detect when your code trashes the stack.  It will put an epilogue on each function that checks the contents of the stack padding to make sure it wasn't overwritten.  That mechanism generally works, but not always.  If you happen to trash the stack in a way that leaves the padding intact, then it will go undetected in debug builds, but in release builds, it will actually trash the stack.  Other times, the epilogue doesn't get executed for whatever reason, so the padding just swallows the stack trash and gives you a false sense of security. -- [[Michael Sparks]]",
      "id": "f05547813ae72fb9db1239bb7949e4c6"
    },
    {
      "type": "html",
      "text": "\nFWIW: if you happen to overwrite the padding with zeros it won't be detected either, but if you overwrite real data with zeros you have got a big problem.",
      "id": "85caa6ed3a637d6dcd3358ae5db31236"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "It is our destiny to create more and more hard-to-analyze [[Heisen Bug]]s by the creation of less intrusive debuggers. Maybe it is possible to create a system theoretic approach that actually makes the bugs show themselves rather than to hide.",
      "id": "a6733cd10e0b12cc739610c7034d03e1"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "This happens in event-driven debugging sessions. You can't effectively simulate [[Lost Focus]], for example, when the debugger itself forces focus changes.",
      "id": "d5ffa4cdb748f0c34050aa36e75cd7c3"
    },
    {
      "type": "html",
      "text": "<i>For the few occasions when I've debugged a problem like that (and knew that was the area to suspect), I've had luck using \"remote debugging\".  That way the debugger's UI can't interfere with the debuggee's UI.</i>",
      "id": "6aebc2286e83fe50544f1482e3f9ce32"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "Ayep.  Had a nasty one.  A long time ago in a galaxy far far away I was working on a server application that needed to gracefully deal with DDOS attack level traffic.  We'd slap 2 nics in the thing and let it burn for days. (Running NT4 and a bunch of [[Micro Soft]] C++ code.)  It would always eventually crash spectacularly and in seemingly random places in the code.  Memory usage was stable and relatively low.  All of our databases were elsewhere and the server was ostensibly stateless.",
      "id": "411be665be8e7826b72276d85e1b6284"
    },
    {
      "type": "html",
      "text": "\nWe switched to release-mode libraries and the problem went away. Switch back, and it would yack.  We scoured the code for weeks trying to find this bit of nasty.",
      "id": "afa196993de49f7599abce4d6af3a22e"
    },
    {
      "type": "html",
      "text": "\nAfter searching in arcane tomes of library lore it was revealed that the microsoft debug runtime libraries had a malloc counter and some *ahem* then junior level programmer adored standard library maps of strings.  They were copied by value all over the place.",
      "id": "e6df65bb286216ff3659faee903b899b"
    },
    {
      "type": "html",
      "text": "\nFinally, yes, the 32 bit signed malloc counter rolled over, and all hell broke loose.",
      "id": "58b07cdb37cfa2c224f9b79cda9a87b8"
    },
    {
      "type": "html",
      "text": "\nAnd a junior programmer became a little less junior.  -- [[Michael Wilson]]",
      "id": "d7a352dba36be59832d70a9632bdc9e5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "\nwhen I worked at Microsoft, we saw this problem all the time, bugs that existed in live code disappeared in debug mode.  The most common culprit is that somebody forgot to initialize a variable.  When you run in the debugger it first zeros out all of your memory, thus a defacto init.  But when you run live, you get whatever random value was already in that memory location.  If your program then assumes that the var has already been initialized to zero, you are in trouble and with a very hard to find bug.  I can't even count how many times this happened.  It's one of the reasons that I came to the conclusion that C is a menace to the software industry.",
      "id": "daf50e85e06381b75a1b5e52d80dfb42"
    },
    {
      "type": "code",
      "text": "  -- codeslinger  www.compsalot.com",
      "id": "0a226de8a5a45dab345e4127f9a2f98c"
    },
    {
      "type": "html",
      "text": "\nAfter going through the phases of loving C, then hating C, then entertaining the notion that C is a menace, then realizing its the ideal tool for a huge number of rather specific things I gradually came to realize that C isn't a problem at all, the problem is choosing C when it is the wrong tool for the job at hand. -- [[Craig Everett]]",
      "id": "ccfcd2c73d980f6d9a827a4cb686b336"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "\nSee also: [[Bug Theory]], [[Bohr Bug]], [[Mandel Bug]], [[Schroedin Bug]], [[Heisenberg Uncertainty Principle]], [[Programmer Proximity Detector]]",
      "id": "c3ea91a813629206346f7ef4c3483b11"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "7b7140530763fdedb23285ca4b5d7860"
    },
    {
      "type": "html",
      "text": "[[Category Bug]]",
      "id": "d3f089a53a942af77e52f01b18f2b587"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?HeisenBug c2.com]",
      "id": "21d7773506baa8693802138f8c2f656a"
    }
  ],
  "journal": [
    {
      "date": 1399440804000,
      "id": "c6c0917fa8dc9218321ac2bcb7bfcee3",
      "type": "create",
      "item": {
        "title": "Heisen Bug",
        "story": [
          {
            "type": "html",
            "text": "A [[Heisen Bug]] is a bug whose presence is affected by act of observing it. ",
            "id": "c3c1a38773f49fc8c55077d8a4050bd9"
          },
          {
            "type": "html",
            "text": "\nFor example, a bug which disappears in debug mode. It's normally dispersed by depressing dangerous digits in the direction of the dirty dangling doughnut. ",
            "id": "ab2893776000a65212d2c3244c164946"
          },
          {
            "type": "html",
            "text": "\nFor more examples, see [[Heisen Bug Examples]].",
            "id": "da5a5aa8a85a0edc548202fe2b7db434"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "Wow, that happened to me...",
            "id": "2a9f6cf86773917fd41a98ec24aaada5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "Back when I was hardware troubleshooting, a wise supervisor corrected my use of the phrase \"intermittent problem\". \"There is no such thing!\", he pronounced,  \"But some problems do have intermittent symptoms!\"",
            "id": "3ca55e9238039a467a6defcceb52bbd8"
          },
          {
            "type": "html",
            "text": "<i>This gives rise to the rather philosophical question: If no symptoms manifest, does a problem exist?</i>",
            "id": "e570a69fdfa7ca90151e2297e2f98280"
          },
          {
            "type": "html",
            "text": "\n[http://paul.merton.ox.ac.uk/computing/msbug.html paul.merton.ox.ac.uk]",
            "id": "363baa2644477e09551f71442e3f4bf0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "Once I had a bug which appeared only during step-by-step debugging. The Delphi debugger can display values of properties of objects. The values of properties can be computed by methods which can modify the object. So when I stepped through the code, the debugger displayed the value of the property and modified the observed object. Very confusing. ",
            "id": "fc30c9bb4b2898860d0f57e53db80fab"
          },
          {
            "type": "html",
            "text": "<i>So you had a method to tell you what the properties of some object were, but that method actually modified the object? I'm confused as to how this can ever be a [[Good Thing]] and would appreciate being enlightened.</i>",
            "id": "ed26d9ae1cd7fd7dfb32c2b7bb59ab9a"
          },
          {
            "type": "html",
            "text": "\nYes. I am not sure whether this is always a [[Bad Thing]], it was kind of [[Lazy Initialization]]. However in this particular case it was really confusing obscure stuff deep in the Delphi's framework VCL. The problem was that in the Watch window I have had displayed some properties of some object. I was debugging through the code trying to find out, when the method Initialize is being called. So I placed a breakpoint into the method Initialize and debugged some other methods. When I jumped over one method, Initialize has been called right after the other method terminated; when I debugged the method step by step, Initialize has been called right after the first line. Actually, the Watch window updated itself every time the debugger interrupted the program. So, after every break, the Watch window read the property and the property read-method called Initialize. So not the normal flow of the program, but the debugger called the method Initialize. A very true [[Heisen Bug]] indeed.",
            "id": "f0c895ac45a24d388ff4fa33a3ba624f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "Here's one really nasty typo-turned-[[Heisen Bug]]:  \"assert( x = 5 );\"...  -- [[An Aspirant]]",
            "id": "1b4d9a1857eb76428eec6698843e5aff"
          },
          {
            "type": "html",
            "text": "<i>See [[Assert Idea]]</i>",
            "id": "a07a9a6eb59ad6fc2263e48971221761"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "I tripped over one of these \"debugger changed my code\" bugs.  [[Visual Studio]].NET allows me to put conditions on a breakpoint, but no one bothered to check whether the code I entered was a boolean phrase.  It's surprising hard to see the difference between \"x == 5\" and \"x = 5\", especially with some fonts.",
            "id": "dac8a7ad2c8beff4a8666bb2813dd72b"
          },
          {
            "type": "html",
            "text": "\nInterestingly enough, you can put any code in the breakpoint condition.  And I do mean \"any\".  -- [[Dean Chalker]]",
            "id": "86f60278d5e1d0b3b990e4b429cf86c5"
          },
          {
            "type": "html",
            "text": "<i>To avoid this [[Compare Constants From The Left]]. And see also [[Code Complete]] or [[Writing Solid Code]].</i>",
            "id": "4d1987f82cf8c53889a0fb9d1e4fae63"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "I had a similar problem with MS [[Dev Studio]] (C++) a few years back. Calling a third-party DLL (DB driver) caused GPF problems that were unreproduceable in debug mode, regardless of whether I was stepping through or letting it run (which is why it didn't show up during regular dev testing, but was instead caught by the external testers). Turns out that the compiler optimizations were turned off by default in debug mode, and turned on in release mode, and it was the optimization module in [[Dev Studio]] that introduced the bug. Turning on optimizations in debug let me watch the call into the DLL tromp the stack below the calling point for the function, thereby trashing data that didn't belong to the DLL. Nice. Turning optimization off for the compilation of the file that called the DLL function in question removed the problem. (As it turned out, I discovered the same problem with a driver DLL for a different DB by another vendor, which reinforced the probability that the problem really was with [[Micro Soft]]'s C++ optimizer.) -- [[Earl Jenkins]]",
            "id": "016799ecdd922b434c93589442705904"
          },
          {
            "type": "html",
            "text": "\nI've had plenty of similar bugs that appear in release builds but not in debug builds.  Without exception, the problem has always been a bug in my code.  When you tell MSVC to compile in debug mode, it puts padding on the stack so that it can detect when your code trashes the stack.  It will put an epilogue on each function that checks the contents of the stack padding to make sure it wasn't overwritten.  That mechanism generally works, but not always.  If you happen to trash the stack in a way that leaves the padding intact, then it will go undetected in debug builds, but in release builds, it will actually trash the stack.  Other times, the epilogue doesn't get executed for whatever reason, so the padding just swallows the stack trash and gives you a false sense of security. -- [[Michael Sparks]]",
            "id": "f05547813ae72fb9db1239bb7949e4c6"
          },
          {
            "type": "html",
            "text": "\nFWIW: if you happen to overwrite the padding with zeros it won't be detected either, but if you overwrite real data with zeros you have got a big problem.",
            "id": "85caa6ed3a637d6dcd3358ae5db31236"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "It is our destiny to create more and more hard-to-analyze [[Heisen Bug]]s by the creation of less intrusive debuggers. Maybe it is possible to create a system theoretic approach that actually makes the bugs show themselves rather than to hide.",
            "id": "a6733cd10e0b12cc739610c7034d03e1"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "This happens in event-driven debugging sessions. You can't effectively simulate [[Lost Focus]], for example, when the debugger itself forces focus changes.",
            "id": "d5ffa4cdb748f0c34050aa36e75cd7c3"
          },
          {
            "type": "html",
            "text": "<i>For the few occasions when I've debugged a problem like that (and knew that was the area to suspect), I've had luck using \"remote debugging\".  That way the debugger's UI can't interfere with the debuggee's UI.</i>",
            "id": "6aebc2286e83fe50544f1482e3f9ce32"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "Ayep.  Had a nasty one.  A long time ago in a galaxy far far away I was working on a server application that needed to gracefully deal with DDOS attack level traffic.  We'd slap 2 nics in the thing and let it burn for days. (Running NT4 and a bunch of [[Micro Soft]] C++ code.)  It would always eventually crash spectacularly and in seemingly random places in the code.  Memory usage was stable and relatively low.  All of our databases were elsewhere and the server was ostensibly stateless.",
            "id": "411be665be8e7826b72276d85e1b6284"
          },
          {
            "type": "html",
            "text": "\nWe switched to release-mode libraries and the problem went away. Switch back, and it would yack.  We scoured the code for weeks trying to find this bit of nasty.",
            "id": "afa196993de49f7599abce4d6af3a22e"
          },
          {
            "type": "html",
            "text": "\nAfter searching in arcane tomes of library lore it was revealed that the microsoft debug runtime libraries had a malloc counter and some *ahem* then junior level programmer adored standard library maps of strings.  They were copied by value all over the place.",
            "id": "e6df65bb286216ff3659faee903b899b"
          },
          {
            "type": "html",
            "text": "\nFinally, yes, the 32 bit signed malloc counter rolled over, and all hell broke loose.",
            "id": "58b07cdb37cfa2c224f9b79cda9a87b8"
          },
          {
            "type": "html",
            "text": "\nAnd a junior programmer became a little less junior.  -- [[Michael Wilson]]",
            "id": "d7a352dba36be59832d70a9632bdc9e5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "\nwhen I worked at Microsoft, we saw this problem all the time, bugs that existed in live code disappeared in debug mode.  The most common culprit is that somebody forgot to initialize a variable.  When you run in the debugger it first zeros out all of your memory, thus a defacto init.  But when you run live, you get whatever random value was already in that memory location.  If your program then assumes that the var has already been initialized to zero, you are in trouble and with a very hard to find bug.  I can't even count how many times this happened.  It's one of the reasons that I came to the conclusion that C is a menace to the software industry.",
            "id": "daf50e85e06381b75a1b5e52d80dfb42"
          },
          {
            "type": "code",
            "text": "  -- codeslinger  www.compsalot.com",
            "id": "0a226de8a5a45dab345e4127f9a2f98c"
          },
          {
            "type": "html",
            "text": "\nAfter going through the phases of loving C, then hating C, then entertaining the notion that C is a menace, then realizing its the ideal tool for a huge number of rather specific things I gradually came to realize that C isn't a problem at all, the problem is choosing C when it is the wrong tool for the job at hand. -- [[Craig Everett]]",
            "id": "ccfcd2c73d980f6d9a827a4cb686b336"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "\nSee also: [[Bug Theory]], [[Bohr Bug]], [[Mandel Bug]], [[Schroedin Bug]], [[Heisenberg Uncertainty Principle]], [[Programmer Proximity Detector]]",
            "id": "c3ea91a813629206346f7ef4c3483b11"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "7b7140530763fdedb23285ca4b5d7860"
          },
          {
            "type": "html",
            "text": "[[Category Bug]]",
            "id": "d3f089a53a942af77e52f01b18f2b587"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?HeisenBug c2.com]",
            "id": "21d7773506baa8693802138f8c2f656a"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1707812446755
    }
  ]
}