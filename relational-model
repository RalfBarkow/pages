{
  "title": "Relational Model",
  "story": [
    {
      "type": "html",
      "text": "The [[Relational Model]] was the first theoretically founded and well thought out [[Data Model]], proposed by [[Ef Codd]] in 1970. It has been the foundation of most database software and theoretical database research ever since.",
      "id": "8f7d6ec7cb557a706843ac9572034295"
    },
    {
      "type": "html",
      "text": "\nIt is ironic, however, that largely because of historical circumstances, its faithful implementations haven't yet succeeded in the marketplace. Early on, computers were thought not powerful enough to support it, and later on users got used to the shortcuts and the compatibility with previous implementations was a good enough excuse. While research in database theory built upon the foundation of the relational model, the DBMS industry has yet to faithfully implement the ideas that Codd laid out in the 70's.",
      "id": "6e9e8ab353ef4e812178007916b09c94"
    },
    {
      "type": "html",
      "text": "\nSome of the foundation for Codd's relational model (1970) was laid by research from David Childs of the University of Michigan. Childs published two papers in 1968 about set-theoretic data structures that supported operations such as intersection, union, domain, and range and that enabled applications to query data without knowing its physical structure. The first citation by Codd in his 1970 paper was \"Feasibility of a set-theoretic data structure : a general structure based on a reconstituted definition of relation\", a paper Childs presented at the 1968 IFIP Congress.  See [[Extended Set Theory]].",
      "id": "e1a0b14dbeddaf24e4f237ff776682d3"
    },
    {
      "type": "html",
      "text": "\nBriefly, the relational model structures the logical view of data around two mathematical constructs: domains (i.e., data types) and relations. The name relational comes from \"relation\" as known and widely used in mathematics (math n00bs, see [http://simple.wikipedia.org/wiki/Relation_%28mathematics%29 simple.wikipedia.org] ), although in database theory the definition of relation is slightly extended.",
      "id": "36556e5fc6ce6ff8fd6dbc751cfaf367"
    },
    {
      "type": "html",
      "text": "\nA domain is simply a set of values, together with its associated operators. It is equivalent to the notion of a type in programming languages. ",
      "id": "ec426105456b2ac4afe834db9b7c0487"
    },
    {
      "type": "html",
      "text": "\nA relation over the domains D1, D2, ..., Dn is simply a subset of the cartesian product; the usual notation is R <i>\"included in\"</i> D1 x D2 x ... x Dn. An element of the cartesian set is called a tuple. A database is a a collection of \"relation valued\" variables (aka [[Rel Var]]s, variables whose value at any point in time is a relation), together with the set of integrity constraints that the data must satisfy. ",
      "id": "876fc22da09f6b18bc450b2ed6bc24a4"
    },
    {
      "type": "html",
      "text": "\nIn order to facilitate programming, a named perspective has been introduced. Each domain that defines a relation is associated with a string label (that will be called column name). A column is then the association between a column name and a domain. A relation header is then a set of columns. A tuple becomes then the mapping between each column in the relation header and a value. And a relation is a set of tuples, all corresponding to the relation header. Because column names are unique in a \"relation header\", the positional ordering in the mathematical definition becomes inessential, and we can therefore identify each data value in a tuple by its column name. This is essentially a programming convenience and the two definitions are essentially equivalent.",
      "id": "223c408afec66350bbaaa71ab3ec0d6f"
    },
    {
      "type": "html",
      "text": "\nBesides the structure of data, the relational model also defines the means for data manipulation (relational algebra or relational calculus) and the means for specifying and enforcing data integrity (integrity constraints). ",
      "id": "595b034475404cbced9db56a44c89603"
    },
    {
      "type": "html",
      "text": "\nThat's the basics of the relational model. Despite its apparent simplicity, the relational model is very rich and powerful, and is a wonderful tool for doing real software engineering as well as theoretical research. ",
      "id": "8c4b27baf3ad28939f3de4b610fe2ad7"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "38afaeedae37049dbd993cef89ef4fc6"
    },
    {
      "type": "html",
      "text": "\nA [[Relational Database]] as implemented today (with tables, rows, SQL as query language) is much more complicated and less powerful than what a database should be in the [[Relational Model]]. Tables and rows aren't equivalent to relations and tuples, because SQL doesn't support user-defined data types and because tables are bags, not sets. What is <i>good enough</i> varies with the complexity of the problem you are facing, and for some problems, the implementation of the relational model by current SQL DBMSes becomes really annoying. It is, unfortunately, one of the many cases of [[Software Engineering Vs Computer Science]].",
      "id": "e78605e5cc1cbae3d9b4a40286742dd9"
    },
    {
      "type": "html",
      "text": "<i>The drawbacks of \"bags\" have been exaggerated by those overly enamored by purity. While I agree that query languages and RDBMS should gently discourage their use, they shouldn't forbid them outright. Related: [[Bag Versus Set Controversy Roadmap]].</i>",
      "id": "24354c58ae838302f2ab66d69817b414"
    },
    {
      "type": "html",
      "text": "{The benefits of \"bags\" have not been convincingly portrayed, and the defence of \"bags\" appears to be limited to a single participant on the C2 wiki.  The downsides of bags are considerable, and are understood,  recognised, and accepted throughout the database community.  Whether there should be NULLs or not, or how to handle update-able views, or what degree of normalisation is an acceptable minimum -- these are all subject to debate amongst both database practitioners and theoreticians.  But whether duplicate rows should be allowed or not?  The answer is obvious, resounding, and universal:  Not.}",
      "id": "0dfa8411ba2108dda594b454d28b38f5"
    },
    {
      "type": "html",
      "text": "\nAlmost all the existing RDBMS vendors have also \"voted\" to allow bags. That's at least a dozen companies/organizations. In that sense it can be considered the road-tested option of the two, which should give it some weight. I know some of you feel the case against bags is very strong. However, I've yet to see a convincing practical argument, especially when it comes to interfacing to existing systems, which are not going away anytime soon even if you want them to really badly. -t",
      "id": "886ead2bbadf797f25810b8ac31b031e"
    },
    {
      "type": "html",
      "text": "{Beware of naively conflating historical conceptual mistakes, and performance hacks imposed by old hardware limitations -- plus an awkward \"need\" to provide legacy support for those within a vendor's line of products -- with any genuine requirement for \"bags\".  There are programming languages that still support GOTOs, for essentially the same reason.}",
      "id": "6d2f45524e735fe1f39c4fd51fe5ba02"
    },
    {
      "type": "html",
      "text": "\nThere are also people who agree that GOTO's are on occasion the best solution to a problem, regardless of legacy support issues. And further, performance issues can still be a bottleneck on today's equipment. Customers always want \"more\".",
      "id": "065e40fd8309eefb09ad687154b58daa"
    },
    {
      "type": "html",
      "text": "{In those rare cases when GOTOs seem appropriate, GOTOs are <b>never</b> a best solution in general, they are only a local \"best\" when a limited language provides nothing better.  Performance issues related to using bags inside DBMSs are virtually unknown on modern hardware of any kind, including highly-restricted mobile and embedded devices.  A device that is so constrained as to actually require \"bags\" in order to meet performance minima will inevitably have so many other limitations that anything mistakenly still called a \"DBMS\" in that context will be virtually unrecognisable as such.}",
      "id": "3a1f70dd7d0bc9265d10c7f1e466d559"
    },
    {
      "type": "html",
      "text": "\nObjective techniques to measure whether goto's are or can be \"good\" have yet to be found. As far as an illustrative performance case where bags are more efficient, consider the case of a event logger table. Non-keyed inserts will generally be faster than keyed inserts because processing the key takes resources and is difficult to split to multiple processors (unique numbering requires central coordination unless pre-assigned ranges are used, making them time-ignorant). But we are digressing off-topic here. There are already plenty of bag-versus-set topics. We should try to link to them rather than copy their concepts here. -t",
      "id": "20b8a1cd607bfdc004dee58140d6d097"
    },
    {
      "type": "html",
      "text": "{Objective techniques to measure whether the smell of poop on your shoe is or can be \"unpleasant\" have yet to be found, too.  That doesn't mean it's any less obviously unpleasant.  As for your event-logger table, yes, it might be that inserting into a \"bag\" is faster than inserting into a [[Rel Var]], but by the same argument it would probably be faster to turn off ACID compliance or not use a DBMS at all.  Performance, aside from that implied by algorithmic complexity, is never a reasonable basis for an argument about theoretical matters.  Feel free to move this to one of the bag-versus-set topics.}",
      "id": "3b1f80fa10e139c3ee2cee60ccb8429d"
    },
    {
      "type": "html",
      "text": "\nYour \"obvious\" has something to be desired. You've been poor at communicating why it's \"obvious\" to you, and thus remains [[Walled Garden]] evidence for you and you alone. As best I can tell, they appear tied to your personal esthetic but impractical obsession with conceptual \"purity\". And one person's shit is another's fertilizer. Choice can be a good thing.",
      "id": "56bf68c57ea369ee80f825101d791a02"
    },
    {
      "type": "html",
      "text": "{It's obvious to almost the entire database community.  It's you who seems stuck in a [[Walled Garden]].}",
      "id": "ceee242adb0fefc038ee874a2b98161e"
    },
    {
      "type": "html",
      "text": "[I can tell you that he isn't the only one.  Bags are an elegant way to implement the vertices of a sparse-matrix implementation for a weighted graph, for example -- a data structure <i>par excellence</i> for relational modelling.  So, sush now, an apologize already.  (At issue, is really whether databases <i>themselves</i> with their preimposed taxonomies are right for relational modelling.)  --[[Mark Janssen]]]",
      "id": "848cd66453e40b5e142ec235cf859bb4"
    },
    {
      "type": "html",
      "text": " <I'm not clear whether you're using the [[Relational Model]] (or some derivative, which it would have to be if there are bags) to represent a graph -- in which case bags would most certainly <b>not</b> be appropriate for any graph representation -- or you're using some other model to implement relations which is not necessarily the [[Relational Model]].  As for databases being \"right for relational modelling\" or not, I'm not clear what you mean by \"preimposed taxonomies\".  Indeed, I'm not clear what you mean at all.>",
      "id": "1d111042d223529ad2a0a695ea35df4f"
    },
    {
      "type": "html",
      "text": "\nI could again say the same thing about DB implimentors. Enough [[Argument From Authority]]. Show the reasoning in clear steps, not gab. This ain't the goddam dark-ages anymore.",
      "id": "a3c389957ec62d42e14716ea36db2cd0"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "38afaeedae37049dbd993cef89ef4fc6"
    },
    {
      "type": "html",
      "text": "<b>Goto Discussion:</b>",
      "id": "19bf28552e0bd3660c74959328254a80"
    },
    {
      "type": "html",
      "text": "\nThe \"Structured Programming\" articles and notes written decades ago showed that goto's are <i>mostly</i> bad (\"mostly\", because even Knuth makes an exception, and many programmers use Halt(), Break(), Exit(), Return() which are higher level forms of Goto).  Does anyone read or study the history of programming and the progress we made decades ago with structured programming? If you have read anything about structured programming you would know that there IS in fact objective evidence against goto's and there is logical reasoning against goto's. The latest kids on the block and programmers haven't even read \"structured programming\" articles and notes - this is a serious problem. ",
      "id": "09e65b542763d337f37484e4b8dcf967"
    },
    {
      "type": "html",
      "text": "\nI think Top's continual demand for \"objective evidence\" is kind of like the Creationist Christian who demands more and more evidence for evolution, even though there is plenty of evidence for evolution. If we provide the Creationist Christian evidence, that christian shouts \"[[Book Stop]], I'm not reading more books or articles from Dawkins or Hitchens on evolution, sorry\". There is plenty of evidence out there that goto's are bad (but semi-okay for local jumps, like exit() and break() or return(). Have you read [[Donald Knuth]]'s \"structured programming with Goto's\" and have you read anything on structured programming before Knuth wrote that? Please don't yell [[Book Stop]] because in order for you to actually find the objective evidence, you'll have to read some things that PROVIDE the evidence (not necessarily books, some are articles, some are essays, some are notes).  ",
      "id": "68ccb467ec3c5fb1854c36702e658486"
    },
    {
      "type": "html",
      "text": "\nAre you looking for scientific statistics and data on Goto's? Sort of like how a creationist christian will argue that <b>evolution still doesn't have enough stats and science</b> behind it? ",
      "id": "d4c42797a13051a80bc701265be9d0e1"
    },
    {
      "type": "html",
      "text": "\nAlso, an [[Edit Hint]]: should Goto discussion be moved to some page?",
      "id": "4b3a6a643f50b28399c89126424435f3"
    },
    {
      "type": "html",
      "text": "<i>See [[Objective Evidence Against Gotos]]</i>",
      "id": "cc1deb35c43c3999bf22875a3ed61e53"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "38afaeedae37049dbd993cef89ef4fc6"
    },
    {
      "type": "html",
      "text": "Advantages of the relational model:",
      "id": "1e7c41c77ef9b37ac8acc0575bf9ccd4"
    },
    {
      "type": "html",
      "text": " It is extensively studied, proven in practice, and based on a formal theoretical model. Almost all of the things that are known about it are actually proven as mathematical theorems. The data manipulation paradigm is based on first order logic and is in full support of [[Database Is Representer Of Facts]].",
      "id": "4e5a978764c0f0069ab53dbc1dc77664"
    },
    {
      "type": "html",
      "text": " It offers an abstracted view of data. It was among the first major application of abstraction as a way to manage software complexity. It basically abstracts the physical structure of data storage, from the logical structure of data. ",
      "id": "5d698a43abc380f6d1a73c0dda6457b4"
    },
    {
      "type": "html",
      "text": " It offers a declarative interface (relational calculus) for the specification of data manipulation, that is actually translated to an efficient (sometimes the most efficient) implementation, given a physical data layout and within reasonable heuristic limits. ",
      "id": "cd55adb4ed562d274ea8da9b045dbc6c"
    },
    {
      "type": "html",
      "text": "\nDrawbacks:",
      "id": "c080112d76a2db8b472b32d354375501"
    },
    {
      "type": "html",
      "text": " It's never been fully, faithfully implemented. This is by far its biggest handicap.",
      "id": "8bbb612db60f313ac823870426fbd361"
    },
    {
      "type": "html",
      "text": " In spite its simplicity, it's likely you'll find lots of developers, architects, DBAs, book authors, committees who have no clue, but pretend that they have. After all, it would be quite embarrassing for someone to admit that he doesn't know what the [[Relational Model]] is.",
      "id": "b656aef57129a115d705abf32f0b65d7"
    },
    {
      "type": "html",
      "text": " <i>Much of this can perhaps be blamed on existing implementations and not the theory or concept. See [[Sql Flaws]].</i>",
      "id": "0111df40cc1c1a0a6391355d2b05d063"
    },
    {
      "type": "html",
      "text": "\nNumber 1) and 2) usually generate a vicious circle, because DBMS vendors react to what the market demands and spend money and time implementing purportedly useful extension, which are in fact not only less useful than having a true implementation of the relational model, but they are actually harmful. These extensions tend to be generically called Object/Relational features. The most glaring example is Oracle RDBMS, which introduced \"objects\", \"references\" and \"collections\", together with other essential accompanying features like the cool sounding operator IS_DANGLING. IS_DANGLING is supposed to rhyme with data integrity. Project managers, CTOs and other staff can read some very nice brochures, PDFs and even be entertained with cool sales movies on O/R features. IS_DANGLING hasn't made it to any marketing presentation as yet.",
      "id": "b5417c96bbc6503cb28c5a540f47872a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "38afaeedae37049dbd993cef89ef4fc6"
    },
    {
      "type": "html",
      "text": "References:",
      "id": "8ecd1b746bbe5b3da64f441aaaa1d836"
    },
    {
      "type": "html",
      "text": " [[Ef Codd]]'s initial paper is available at [http://www.acm.org/classics/nov95/ www.acm.org]",
      "id": "aca2f89994fd7aa684ce14d09303dc96"
    },
    {
      "type": "html",
      "text": " For a substantial exposition of the relational model and the reasons it is so powerful and valuable for the modern software technology, see [[An Introduction To Database Systems]]. ",
      "id": "7a12fde958d2749bdeb12534f75cf1e9"
    },
    {
      "type": "html",
      "text": " For the more <i>mathematically inclined</i> people, [[Foundations Of Databases]] is an absolutely delightful reading, although the connection between the theory and the practical engineering values is to some extent left as an exercise for the reader.",
      "id": "c1f12f40a021246e37bc3b0ab41b34ad"
    },
    {
      "type": "html",
      "text": " For the layman software engineer who won't spend money on database theory, [http://www.brcommunity.com/cgi-local/x.pl/commentary/b006.html www.brcommunity.com] [[[Broken Link]]] and the subsequent articles should be convincing enough to make him buy a book (free subscription to the site is required, but won't hurt). ",
      "id": "0d9f53fd6e3e381b66c1dd57db9a7de5"
    },
    {
      "type": "html",
      "text": " Any standard text book on databases (like [[Elmasri And Navathe]], O'Neil and O'Neil, Ullman). Each of these book tend to elaborate more on some aspects, while taking some shortcuts on others.",
      "id": "3e8249406b7033b962d617be8af27e5f"
    },
    {
      "type": "html",
      "text": "\nFor funny examples from really unexpected sources, you can read books like \"Oracle XXX, The Complete Reference\" where XXX in (7,8,8i), right from Oracle Press. ",
      "id": "9dce377337f0ac8022f622558b0a5154"
    },
    {
      "type": "html",
      "text": "\nThe most spread misconception about the relational model is that \"relational\" comes from primary keys and foreign keys that represent a \"relation\" or \"relationships\", \"relating\" rows in different tables. It is not the case; relation is a well-established mathematical concept and the relational model builds upon mathematical properties of relations. ",
      "id": "d0af0da31ed73dcc3a9626b1e40bc1b2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "38afaeedae37049dbd993cef89ef4fc6"
    },
    {
      "type": "html",
      "text": "See also [[Db Debunk]]",
      "id": "f9d71820294ef3b8d5812e2a33bb5216"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "38afaeedae37049dbd993cef89ef4fc6"
    },
    {
      "type": "html",
      "text": "[[Category Relational Database]]",
      "id": "8b4c393d71e56baf587bfecb50624a1f"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "38afaeedae37049dbd993cef89ef4fc6"
    },
    {
      "type": "html",
      "text": "[[February Zero Nine]]",
      "id": "67c99afcd50fcdcadac068ba87b3ada9"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?RelationalModel c2.com]",
      "id": "31b06f5fc8eab9989829e0c4718ae5d4"
    }
  ],
  "journal": [
    {
      "date": 1369314072000,
      "id": "44cf549c58ccb4e095bc00c5214024d7",
      "type": "create",
      "item": {
        "title": "Relational Model",
        "story": [
          {
            "type": "html",
            "text": "The [[Relational Model]] was the first theoretically founded and well thought out [[Data Model]], proposed by [[Ef Codd]] in 1970. It has been the foundation of most database software and theoretical database research ever since.",
            "id": "8f7d6ec7cb557a706843ac9572034295"
          },
          {
            "type": "html",
            "text": "\nIt is ironic, however, that largely because of historical circumstances, its faithful implementations haven't yet succeeded in the marketplace. Early on, computers were thought not powerful enough to support it, and later on users got used to the shortcuts and the compatibility with previous implementations was a good enough excuse. While research in database theory built upon the foundation of the relational model, the DBMS industry has yet to faithfully implement the ideas that Codd laid out in the 70's.",
            "id": "6e9e8ab353ef4e812178007916b09c94"
          },
          {
            "type": "html",
            "text": "\nSome of the foundation for Codd's relational model (1970) was laid by research from David Childs of the University of Michigan. Childs published two papers in 1968 about set-theoretic data structures that supported operations such as intersection, union, domain, and range and that enabled applications to query data without knowing its physical structure. The first citation by Codd in his 1970 paper was \"Feasibility of a set-theoretic data structure : a general structure based on a reconstituted definition of relation\", a paper Childs presented at the 1968 IFIP Congress.  See [[Extended Set Theory]].",
            "id": "e1a0b14dbeddaf24e4f237ff776682d3"
          },
          {
            "type": "html",
            "text": "\nBriefly, the relational model structures the logical view of data around two mathematical constructs: domains (i.e., data types) and relations. The name relational comes from \"relation\" as known and widely used in mathematics (math n00bs, see [http://simple.wikipedia.org/wiki/Relation_%28mathematics%29 simple.wikipedia.org] ), although in database theory the definition of relation is slightly extended.",
            "id": "36556e5fc6ce6ff8fd6dbc751cfaf367"
          },
          {
            "type": "html",
            "text": "\nA domain is simply a set of values, together with its associated operators. It is equivalent to the notion of a type in programming languages. ",
            "id": "ec426105456b2ac4afe834db9b7c0487"
          },
          {
            "type": "html",
            "text": "\nA relation over the domains D1, D2, ..., Dn is simply a subset of the cartesian product; the usual notation is R <i>\"included in\"</i> D1 x D2 x ... x Dn. An element of the cartesian set is called a tuple. A database is a a collection of \"relation valued\" variables (aka [[Rel Var]]s, variables whose value at any point in time is a relation), together with the set of integrity constraints that the data must satisfy. ",
            "id": "876fc22da09f6b18bc450b2ed6bc24a4"
          },
          {
            "type": "html",
            "text": "\nIn order to facilitate programming, a named perspective has been introduced. Each domain that defines a relation is associated with a string label (that will be called column name). A column is then the association between a column name and a domain. A relation header is then a set of columns. A tuple becomes then the mapping between each column in the relation header and a value. And a relation is a set of tuples, all corresponding to the relation header. Because column names are unique in a \"relation header\", the positional ordering in the mathematical definition becomes inessential, and we can therefore identify each data value in a tuple by its column name. This is essentially a programming convenience and the two definitions are essentially equivalent.",
            "id": "223c408afec66350bbaaa71ab3ec0d6f"
          },
          {
            "type": "html",
            "text": "\nBesides the structure of data, the relational model also defines the means for data manipulation (relational algebra or relational calculus) and the means for specifying and enforcing data integrity (integrity constraints). ",
            "id": "595b034475404cbced9db56a44c89603"
          },
          {
            "type": "html",
            "text": "\nThat's the basics of the relational model. Despite its apparent simplicity, the relational model is very rich and powerful, and is a wonderful tool for doing real software engineering as well as theoretical research. ",
            "id": "8c4b27baf3ad28939f3de4b610fe2ad7"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "38afaeedae37049dbd993cef89ef4fc6"
          },
          {
            "type": "html",
            "text": "\nA [[Relational Database]] as implemented today (with tables, rows, SQL as query language) is much more complicated and less powerful than what a database should be in the [[Relational Model]]. Tables and rows aren't equivalent to relations and tuples, because SQL doesn't support user-defined data types and because tables are bags, not sets. What is <i>good enough</i> varies with the complexity of the problem you are facing, and for some problems, the implementation of the relational model by current SQL DBMSes becomes really annoying. It is, unfortunately, one of the many cases of [[Software Engineering Vs Computer Science]].",
            "id": "e78605e5cc1cbae3d9b4a40286742dd9"
          },
          {
            "type": "html",
            "text": "<i>The drawbacks of \"bags\" have been exaggerated by those overly enamored by purity. While I agree that query languages and RDBMS should gently discourage their use, they shouldn't forbid them outright. Related: [[Bag Versus Set Controversy Roadmap]].</i>",
            "id": "24354c58ae838302f2ab66d69817b414"
          },
          {
            "type": "html",
            "text": "{The benefits of \"bags\" have not been convincingly portrayed, and the defence of \"bags\" appears to be limited to a single participant on the C2 wiki.  The downsides of bags are considerable, and are understood,  recognised, and accepted throughout the database community.  Whether there should be NULLs or not, or how to handle update-able views, or what degree of normalisation is an acceptable minimum -- these are all subject to debate amongst both database practitioners and theoreticians.  But whether duplicate rows should be allowed or not?  The answer is obvious, resounding, and universal:  Not.}",
            "id": "0dfa8411ba2108dda594b454d28b38f5"
          },
          {
            "type": "html",
            "text": "\nAlmost all the existing RDBMS vendors have also \"voted\" to allow bags. That's at least a dozen companies/organizations. In that sense it can be considered the road-tested option of the two, which should give it some weight. I know some of you feel the case against bags is very strong. However, I've yet to see a convincing practical argument, especially when it comes to interfacing to existing systems, which are not going away anytime soon even if you want them to really badly. -t",
            "id": "886ead2bbadf797f25810b8ac31b031e"
          },
          {
            "type": "html",
            "text": "{Beware of naively conflating historical conceptual mistakes, and performance hacks imposed by old hardware limitations -- plus an awkward \"need\" to provide legacy support for those within a vendor's line of products -- with any genuine requirement for \"bags\".  There are programming languages that still support GOTOs, for essentially the same reason.}",
            "id": "6d2f45524e735fe1f39c4fd51fe5ba02"
          },
          {
            "type": "html",
            "text": "\nThere are also people who agree that GOTO's are on occasion the best solution to a problem, regardless of legacy support issues. And further, performance issues can still be a bottleneck on today's equipment. Customers always want \"more\".",
            "id": "065e40fd8309eefb09ad687154b58daa"
          },
          {
            "type": "html",
            "text": "{In those rare cases when GOTOs seem appropriate, GOTOs are <b>never</b> a best solution in general, they are only a local \"best\" when a limited language provides nothing better.  Performance issues related to using bags inside DBMSs are virtually unknown on modern hardware of any kind, including highly-restricted mobile and embedded devices.  A device that is so constrained as to actually require \"bags\" in order to meet performance minima will inevitably have so many other limitations that anything mistakenly still called a \"DBMS\" in that context will be virtually unrecognisable as such.}",
            "id": "3a1f70dd7d0bc9265d10c7f1e466d559"
          },
          {
            "type": "html",
            "text": "\nObjective techniques to measure whether goto's are or can be \"good\" have yet to be found. As far as an illustrative performance case where bags are more efficient, consider the case of a event logger table. Non-keyed inserts will generally be faster than keyed inserts because processing the key takes resources and is difficult to split to multiple processors (unique numbering requires central coordination unless pre-assigned ranges are used, making them time-ignorant). But we are digressing off-topic here. There are already plenty of bag-versus-set topics. We should try to link to them rather than copy their concepts here. -t",
            "id": "20b8a1cd607bfdc004dee58140d6d097"
          },
          {
            "type": "html",
            "text": "{Objective techniques to measure whether the smell of poop on your shoe is or can be \"unpleasant\" have yet to be found, too.  That doesn't mean it's any less obviously unpleasant.  As for your event-logger table, yes, it might be that inserting into a \"bag\" is faster than inserting into a [[Rel Var]], but by the same argument it would probably be faster to turn off ACID compliance or not use a DBMS at all.  Performance, aside from that implied by algorithmic complexity, is never a reasonable basis for an argument about theoretical matters.  Feel free to move this to one of the bag-versus-set topics.}",
            "id": "3b1f80fa10e139c3ee2cee60ccb8429d"
          },
          {
            "type": "html",
            "text": "\nYour \"obvious\" has something to be desired. You've been poor at communicating why it's \"obvious\" to you, and thus remains [[Walled Garden]] evidence for you and you alone. As best I can tell, they appear tied to your personal esthetic but impractical obsession with conceptual \"purity\". And one person's shit is another's fertilizer. Choice can be a good thing.",
            "id": "56bf68c57ea369ee80f825101d791a02"
          },
          {
            "type": "html",
            "text": "{It's obvious to almost the entire database community.  It's you who seems stuck in a [[Walled Garden]].}",
            "id": "ceee242adb0fefc038ee874a2b98161e"
          },
          {
            "type": "html",
            "text": "[I can tell you that he isn't the only one.  Bags are an elegant way to implement the vertices of a sparse-matrix implementation for a weighted graph, for example -- a data structure <i>par excellence</i> for relational modelling.  So, sush now, an apologize already.  (At issue, is really whether databases <i>themselves</i> with their preimposed taxonomies are right for relational modelling.)  --[[Mark Janssen]]]",
            "id": "848cd66453e40b5e142ec235cf859bb4"
          },
          {
            "type": "html",
            "text": " <I'm not clear whether you're using the [[Relational Model]] (or some derivative, which it would have to be if there are bags) to represent a graph -- in which case bags would most certainly <b>not</b> be appropriate for any graph representation -- or you're using some other model to implement relations which is not necessarily the [[Relational Model]].  As for databases being \"right for relational modelling\" or not, I'm not clear what you mean by \"preimposed taxonomies\".  Indeed, I'm not clear what you mean at all.>",
            "id": "1d111042d223529ad2a0a695ea35df4f"
          },
          {
            "type": "html",
            "text": "\nI could again say the same thing about DB implimentors. Enough [[Argument From Authority]]. Show the reasoning in clear steps, not gab. This ain't the goddam dark-ages anymore.",
            "id": "a3c389957ec62d42e14716ea36db2cd0"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "38afaeedae37049dbd993cef89ef4fc6"
          },
          {
            "type": "html",
            "text": "<b>Goto Discussion:</b>",
            "id": "19bf28552e0bd3660c74959328254a80"
          },
          {
            "type": "html",
            "text": "\nThe \"Structured Programming\" articles and notes written decades ago showed that goto's are <i>mostly</i> bad (\"mostly\", because even Knuth makes an exception, and many programmers use Halt(), Break(), Exit(), Return() which are higher level forms of Goto).  Does anyone read or study the history of programming and the progress we made decades ago with structured programming? If you have read anything about structured programming you would know that there IS in fact objective evidence against goto's and there is logical reasoning against goto's. The latest kids on the block and programmers haven't even read \"structured programming\" articles and notes - this is a serious problem. ",
            "id": "09e65b542763d337f37484e4b8dcf967"
          },
          {
            "type": "html",
            "text": "\nI think Top's continual demand for \"objective evidence\" is kind of like the Creationist Christian who demands more and more evidence for evolution, even though there is plenty of evidence for evolution. If we provide the Creationist Christian evidence, that christian shouts \"[[Book Stop]], I'm not reading more books or articles from Dawkins or Hitchens on evolution, sorry\". There is plenty of evidence out there that goto's are bad (but semi-okay for local jumps, like exit() and break() or return(). Have you read [[Donald Knuth]]'s \"structured programming with Goto's\" and have you read anything on structured programming before Knuth wrote that? Please don't yell [[Book Stop]] because in order for you to actually find the objective evidence, you'll have to read some things that PROVIDE the evidence (not necessarily books, some are articles, some are essays, some are notes).  ",
            "id": "68ccb467ec3c5fb1854c36702e658486"
          },
          {
            "type": "html",
            "text": "\nAre you looking for scientific statistics and data on Goto's? Sort of like how a creationist christian will argue that <b>evolution still doesn't have enough stats and science</b> behind it? ",
            "id": "d4c42797a13051a80bc701265be9d0e1"
          },
          {
            "type": "html",
            "text": "\nAlso, an [[Edit Hint]]: should Goto discussion be moved to some page?",
            "id": "4b3a6a643f50b28399c89126424435f3"
          },
          {
            "type": "html",
            "text": "<i>See [[Objective Evidence Against Gotos]]</i>",
            "id": "cc1deb35c43c3999bf22875a3ed61e53"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "38afaeedae37049dbd993cef89ef4fc6"
          },
          {
            "type": "html",
            "text": "Advantages of the relational model:",
            "id": "1e7c41c77ef9b37ac8acc0575bf9ccd4"
          },
          {
            "type": "html",
            "text": " It is extensively studied, proven in practice, and based on a formal theoretical model. Almost all of the things that are known about it are actually proven as mathematical theorems. The data manipulation paradigm is based on first order logic and is in full support of [[Database Is Representer Of Facts]].",
            "id": "4e5a978764c0f0069ab53dbc1dc77664"
          },
          {
            "type": "html",
            "text": " It offers an abstracted view of data. It was among the first major application of abstraction as a way to manage software complexity. It basically abstracts the physical structure of data storage, from the logical structure of data. ",
            "id": "5d698a43abc380f6d1a73c0dda6457b4"
          },
          {
            "type": "html",
            "text": " It offers a declarative interface (relational calculus) for the specification of data manipulation, that is actually translated to an efficient (sometimes the most efficient) implementation, given a physical data layout and within reasonable heuristic limits. ",
            "id": "cd55adb4ed562d274ea8da9b045dbc6c"
          },
          {
            "type": "html",
            "text": "\nDrawbacks:",
            "id": "c080112d76a2db8b472b32d354375501"
          },
          {
            "type": "html",
            "text": " It's never been fully, faithfully implemented. This is by far its biggest handicap.",
            "id": "8bbb612db60f313ac823870426fbd361"
          },
          {
            "type": "html",
            "text": " In spite its simplicity, it's likely you'll find lots of developers, architects, DBAs, book authors, committees who have no clue, but pretend that they have. After all, it would be quite embarrassing for someone to admit that he doesn't know what the [[Relational Model]] is.",
            "id": "b656aef57129a115d705abf32f0b65d7"
          },
          {
            "type": "html",
            "text": " <i>Much of this can perhaps be blamed on existing implementations and not the theory or concept. See [[Sql Flaws]].</i>",
            "id": "0111df40cc1c1a0a6391355d2b05d063"
          },
          {
            "type": "html",
            "text": "\nNumber 1) and 2) usually generate a vicious circle, because DBMS vendors react to what the market demands and spend money and time implementing purportedly useful extension, which are in fact not only less useful than having a true implementation of the relational model, but they are actually harmful. These extensions tend to be generically called Object/Relational features. The most glaring example is Oracle RDBMS, which introduced \"objects\", \"references\" and \"collections\", together with other essential accompanying features like the cool sounding operator IS_DANGLING. IS_DANGLING is supposed to rhyme with data integrity. Project managers, CTOs and other staff can read some very nice brochures, PDFs and even be entertained with cool sales movies on O/R features. IS_DANGLING hasn't made it to any marketing presentation as yet.",
            "id": "b5417c96bbc6503cb28c5a540f47872a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "38afaeedae37049dbd993cef89ef4fc6"
          },
          {
            "type": "html",
            "text": "References:",
            "id": "8ecd1b746bbe5b3da64f441aaaa1d836"
          },
          {
            "type": "html",
            "text": " [[Ef Codd]]'s initial paper is available at [http://www.acm.org/classics/nov95/ www.acm.org]",
            "id": "aca2f89994fd7aa684ce14d09303dc96"
          },
          {
            "type": "html",
            "text": " For a substantial exposition of the relational model and the reasons it is so powerful and valuable for the modern software technology, see [[An Introduction To Database Systems]]. ",
            "id": "7a12fde958d2749bdeb12534f75cf1e9"
          },
          {
            "type": "html",
            "text": " For the more <i>mathematically inclined</i> people, [[Foundations Of Databases]] is an absolutely delightful reading, although the connection between the theory and the practical engineering values is to some extent left as an exercise for the reader.",
            "id": "c1f12f40a021246e37bc3b0ab41b34ad"
          },
          {
            "type": "html",
            "text": " For the layman software engineer who won't spend money on database theory, [http://www.brcommunity.com/cgi-local/x.pl/commentary/b006.html www.brcommunity.com] [[[Broken Link]]] and the subsequent articles should be convincing enough to make him buy a book (free subscription to the site is required, but won't hurt). ",
            "id": "0d9f53fd6e3e381b66c1dd57db9a7de5"
          },
          {
            "type": "html",
            "text": " Any standard text book on databases (like [[Elmasri And Navathe]], O'Neil and O'Neil, Ullman). Each of these book tend to elaborate more on some aspects, while taking some shortcuts on others.",
            "id": "3e8249406b7033b962d617be8af27e5f"
          },
          {
            "type": "html",
            "text": "\nFor funny examples from really unexpected sources, you can read books like \"Oracle XXX, The Complete Reference\" where XXX in (7,8,8i), right from Oracle Press. ",
            "id": "9dce377337f0ac8022f622558b0a5154"
          },
          {
            "type": "html",
            "text": "\nThe most spread misconception about the relational model is that \"relational\" comes from primary keys and foreign keys that represent a \"relation\" or \"relationships\", \"relating\" rows in different tables. It is not the case; relation is a well-established mathematical concept and the relational model builds upon mathematical properties of relations. ",
            "id": "d0af0da31ed73dcc3a9626b1e40bc1b2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "38afaeedae37049dbd993cef89ef4fc6"
          },
          {
            "type": "html",
            "text": "See also [[Db Debunk]]",
            "id": "f9d71820294ef3b8d5812e2a33bb5216"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "38afaeedae37049dbd993cef89ef4fc6"
          },
          {
            "type": "html",
            "text": "[[Category Relational Database]]",
            "id": "8b4c393d71e56baf587bfecb50624a1f"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "38afaeedae37049dbd993cef89ef4fc6"
          },
          {
            "type": "html",
            "text": "[[February Zero Nine]]",
            "id": "67c99afcd50fcdcadac068ba87b3ada9"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?RelationalModel c2.com]",
            "id": "31b06f5fc8eab9989829e0c4718ae5d4"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1627476667707
    }
  ]
}