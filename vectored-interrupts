{
  "title": "Vectored Interrupts",
  "story": [
    {
      "type": "paragraph",
      "id": "ae0e06c227f1db1b",
      "text": "I've found that my await step strategy for controlling a long running computation has some limitations. First, my original strategy of driving the computation with a timer heartbeat didn't work well with this. So I change my approach to having producer and consumer infinite loops with await step for control and await sleep for throttling. This lead to a new kind of bug: un-throttled looping starving the rest of deno of cycles to do its work. [https://github.com/WardCunningham/denowiki/blob/4ed3cacdfdd314d7c472f7f6aec6de26b9cad6ab/meta-sites/scrape.localhost.ts#L147-L157 github]"
    },
    {
      "type": "paragraph",
      "id": "47e3430c99237518",
      "text": "Ward Remembers ..."
    },
    {
      "type": "paragraph",
      "id": "c9061c97341ca881",
      "text": "In the old days we did multiprocessing with vectored interrupts. If you wanted your debugger to retain control, you gave it a priority vector. "
    },
    {
      "type": "paragraph",
      "id": "95c77b84ba2a8529",
      "text": "Then Seymour Cray built the 6600 which was so fast that it couldn't be bothered with interrupts so he added 10x hardware multiprogrammed peripheral processing units (PPUs) which was really just one full speed PPU and 10x register file in barrel shifters. [https://archive.computerhistory.org/resources/text/CDC/cdc.6600.thornton.design_of_a_computer_the_control_data_6600.1970.102630394.pdf pdf]"
    },
    {
      "type": "paragraph",
      "id": "f033e3ae84c0e96f",
      "text": "The Xerox Alto designers thought that this was so cool they built their whole machine around hardware multitasking including even the dynamic ram refresh. This had the effect that if you stopped the clock for more than a few hundred milliseconds, like say, to single step, then the Alto memory forgot everything that you might be debugging."
    },
    {
      "type": "paragraph",
      "id": "6c385d0b3a711d79",
      "text": "The Cray design had some limitations too. The CPU polled location zero for indication that it should halt. The model 6500 ran two cost-reduced 6400 CPUs in parallel. It turns out that if both CPUs were writing location zero in a tight loop it was impossible to stop this computation short of powering down the whole system at the motor-generator power conditioning equipment."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Vectored Interrupts",
        "story": []
      },
      "date": 1584286176372
    },
    {
      "item": {
        "type": "factory",
        "id": "ae0e06c227f1db1b"
      },
      "id": "ae0e06c227f1db1b",
      "type": "add",
      "date": 1584286178966
    },
    {
      "type": "edit",
      "id": "ae0e06c227f1db1b",
      "item": {
        "type": "paragraph",
        "id": "ae0e06c227f1db1b",
        "text": "I've found that my await step strategy for controlling a long running computation has some limitations. First, my original strategy of driving the computation with a timer heartbeat didn't work well with this. So I change my approach to having producer and consumer infinite loops with await step for control and await sleep for throttling. This lead to a new kind of bug: un-throttled looping starving the rest of deno cycles to do its work."
      },
      "date": 1584286226947
    },
    {
      "type": "add",
      "id": "47e3430c99237518",
      "item": {
        "type": "paragraph",
        "id": "47e3430c99237518",
        "text": "Ward Remembers ..."
      },
      "after": "ae0e06c227f1db1b",
      "date": 1584286254200
    },
    {
      "item": {
        "type": "factory",
        "id": "c9061c97341ca881"
      },
      "id": "c9061c97341ca881",
      "type": "add",
      "after": "47e3430c99237518",
      "date": 1584286271620
    },
    {
      "type": "edit",
      "id": "c9061c97341ca881",
      "item": {
        "type": "paragraph",
        "id": "c9061c97341ca881",
        "text": "In the old days we did multiprocessing with vectored interrupts. If you wanted your debugger to retain control, you gave it a priority vector. Then Seymour Cray built the 6600 which was so fast that it couldn't be bothered with interrupts so he added 10x hardware multiprogrammed peripheral processing units (PPUs) which was really just one full speed PPU and 10x register file in barrel shifters. The Xerox Alto designers thought that this was so cool they built their whole machine around hardware multitasking including even the dynamic ram refresh. This had the effect that if you stopped the clock for more than a few hundred milliseconds, like say, to single step, then the Alto memory forgot everything that you might be debugging."
      },
      "date": 1584286275058
    },
    {
      "type": "fork",
      "date": 1584286317826
    },
    {
      "type": "edit",
      "id": "ae0e06c227f1db1b",
      "item": {
        "type": "paragraph",
        "id": "ae0e06c227f1db1b",
        "text": "I've found that my await step strategy for controlling a long running computation has some limitations. First, my original strategy of driving the computation with a timer heartbeat didn't work well with this. So I change my approach to having producer and consumer infinite loops with await step for control and await sleep for throttling. This lead to a new kind of bug: un-throttled looping starving the rest of deno cycles to do its work. [https://github.com/WardCunningham/denowiki/blob/4ed3cacdfdd314d7c472f7f6aec6de26b9cad6ab/meta-sites/scrape.localhost.ts#L118-L127 github]"
      },
      "date": 1584286553202
    },
    {
      "type": "edit",
      "id": "ae0e06c227f1db1b",
      "item": {
        "type": "paragraph",
        "id": "ae0e06c227f1db1b",
        "text": "I've found that my await step strategy for controlling a long running computation has some limitations. First, my original strategy of driving the computation with a timer heartbeat didn't work well with this. So I change my approach to having producer and consumer infinite loops with await step for control and await sleep for throttling. This lead to a new kind of bug: un-throttled looping starving the rest of deno cycles to do its work. [https://github.com/WardCunningham/denowiki/blob/4ed3cacdfdd314d7c472f7f6aec6de26b9cad6ab/meta-sites/scrape.localhost.ts#L147-L157 github]"
      },
      "date": 1584286651901
    },
    {
      "type": "edit",
      "id": "ae0e06c227f1db1b",
      "item": {
        "type": "paragraph",
        "id": "ae0e06c227f1db1b",
        "text": "I've found that my await step strategy for controlling a long running computation has some limitations. First, my original strategy of driving the computation with a timer heartbeat didn't work well with this. So I change my approach to having producer and consumer infinite loops with await step for control and await sleep for throttling. This lead to a new kind of bug: un-throttled looping starving the rest of deno of cycles to do its work. [https://github.com/WardCunningham/denowiki/blob/4ed3cacdfdd314d7c472f7f6aec6de26b9cad6ab/meta-sites/scrape.localhost.ts#L147-L157 github]"
      },
      "date": 1584286752995
    },
    {
      "type": "edit",
      "id": "c9061c97341ca881",
      "item": {
        "type": "paragraph",
        "id": "c9061c97341ca881",
        "text": "In the old days we did multiprocessing with vectored interrupts. If you wanted your debugger to retain control, you gave it a priority vector. Then Seymour Cray built the 6600 which was so fast that it couldn't be bothered with interrupts so he added 10x hardware multiprogrammed peripheral processing units (PPUs) which was really just one full speed PPU and 10x register file in barrel shifters. "
      },
      "date": 1584286791544
    },
    {
      "type": "add",
      "id": "f033e3ae84c0e96f",
      "item": {
        "type": "paragraph",
        "id": "f033e3ae84c0e96f",
        "text": "The Xerox Alto designers thought that this was so cool they built their whole machine around hardware multitasking including even the dynamic ram refresh. This had the effect that if you stopped the clock for more than a few hundred milliseconds, like say, to single step, then the Alto memory forgot everything that you might be debugging."
      },
      "after": "c9061c97341ca881",
      "date": 1584286792692
    },
    {
      "type": "add",
      "id": "6c385d0b3a711d79",
      "item": {
        "type": "paragraph",
        "id": "6c385d0b3a711d79",
        "text": "The Cray design had some limitations too. A PPU could halt the CPU by writing to memory location zero. "
      },
      "after": "f033e3ae84c0e96f",
      "date": 1584287000083
    },
    {
      "type": "edit",
      "id": "c9061c97341ca881",
      "item": {
        "type": "paragraph",
        "id": "c9061c97341ca881",
        "text": "In the old days we did multiprocessing with vectored interrupts. If you wanted your debugger to retain control, you gave it a priority vector. Then Seymour Cray built the 6600 which was so fast that it couldn't be bothered with interrupts so he added 10x hardware multiprogrammed peripheral processing units (PPUs) which was really just one full speed PPU and 10x register file in barrel shifters. [https://archive.computerhistory.org/resources/text/CDC/cdc.6600.thornton.design_of_a_computer_the_control_data_6600.1970.102630394.pdf pdf]"
      },
      "date": 1584287404674
    },
    {
      "type": "edit",
      "id": "c9061c97341ca881",
      "item": {
        "type": "paragraph",
        "id": "c9061c97341ca881",
        "text": "In the old days we did multiprocessing with vectored interrupts. If you wanted your debugger to retain control, you gave it a priority vector. "
      },
      "date": 1584287413577
    },
    {
      "type": "add",
      "id": "95c77b84ba2a8529",
      "item": {
        "type": "paragraph",
        "id": "95c77b84ba2a8529",
        "text": "Then Seymour Cray built the 6600 which was so fast that it couldn't be bothered with interrupts so he added 10x hardware multiprogrammed peripheral processing units (PPUs) which was really just one full speed PPU and 10x register file in barrel shifters. [https://archive.computerhistory.org/resources/text/CDC/cdc.6600.thornton.design_of_a_computer_the_control_data_6600.1970.102630394.pdf pdf]"
      },
      "after": "c9061c97341ca881",
      "date": 1584287414861
    },
    {
      "type": "edit",
      "id": "6c385d0b3a711d79",
      "item": {
        "type": "paragraph",
        "id": "6c385d0b3a711d79",
        "text": "The Cray design had some limitations too. The CPU polled location zero for indication that it should halt. The model 6500 ran two cost-reduced 6400 CPUs in parallel. It turns out that if both CPUs were writing location zero in a tight loop it was impossible to stop this computation short of powering down the whole system at the motor-generator power conditioning equipment."
      },
      "date": 1584287647363
    },
    {
      "type": "fork",
      "site": "code.fed.wiki.org",
      "date": 1638268954519
    }
  ]
}