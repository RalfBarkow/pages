{
  "title": "Duplicated Code",
  "story": [
    {
      "type": "html",
      "text": "<i>Perhaps this is already covered by [[Copy And Paste Programming]] and [[Code Smell]]s?  [[Deletion Candidate]]</i>",
      "id": "41b2c28bedbdc7926e363a7050cf2fb7"
    },
    {
      "type": "html",
      "text": "\nI don't think so. [[Copy And Paste Programming]] is the process, that often leads to [[Duplicated Code]], but ",
      "id": "39e2c2d476aa4840e3ecf0eff01c11c7"
    },
    {
      "type": "html",
      "text": "it also leads to [[Badly Factored Code]]",
      "id": "5f26d332c02e9731fdfc27feaf55474e"
    },
    {
      "type": "html",
      "text": "there are other sources of [[Duplicated Code]] (e.g. [[Badly Factored Code]])\nwhich means that these two are often related, but none is a special case of the other.",
      "id": "ad8ccf975fa3b558a22e4f5b18638341"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "What constitutes [[Duplicated Code]]?",
      "id": "8c542ec161631a921e4ce80e7fde4ec0"
    },
    {
      "type": "html",
      "text": "<i>Code is duplicated if more succinct code exists that describes the same functionality (gives same desired(excluding noise) results after running).</i> --[[Aleksey Pavlichenko]]",
      "id": "b912988753bf43fe05fdd4f9c2bcade5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "Analogy with Zip data compression:",
      "id": "b2b581f2683d1caa5cb76425a62bbb18"
    },
    {
      "type": "html",
      "text": "\nRefactoring is deduplication of source code done by human. Zip compression is deduplication of data done by machine.",
      "id": "d971f5d2d08565a304996d271c327227"
    },
    {
      "type": "html",
      "text": "\nCompression (deduplication) of one unit of information is many times more CPU-expensive than decompression (duplication).\nSimilarly deduplication of one unit of functionality of software code is many times more human-expensive than duplication.",
      "id": "42b47d3d18ed3fcc52d5bab4969629d0"
    },
    {
      "type": "html",
      "text": "\nConsequently if a company spent X dollars to develop a product with duplicated code it will have to spend X * K dollars on code refactoring without any single visible improvement of the product, where K is between 3 and 100 depending on skills, complexity, language, etc.",
      "id": "50119d2bf3284e4d769bc6d86d5ccb0e"
    },
    {
      "type": "html",
      "text": "\nSome companies hire more and more developers to pay interest on that duplication debt or keep changing developers wondering why production emergencies don’t disappear even with best minds on it.",
      "id": "f3b383a07fbc18e152749e9416fe92ce"
    },
    {
      "type": "html",
      "text": "--[[Aleksey Pavlichenko]]",
      "id": "27889e4d17482a031f96302451ba93ce"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "Analogy with financial interest:",
      "id": "44ab733b5cd8c16fbc47df2e341f41df"
    },
    {
      "type": "html",
      "text": "\n[[Duplicated Code]] represents [[Technical Debt]]. Cost of repayment of that debt equals to cost of human labor that is required to deduplicate the code.\nThat debt has interest in form of decreased productivity of developers.",
      "id": "97572b4abf617f7dacda416002014f46"
    },
    {
      "type": "html",
      "text": "\nThat interest is many times higher than financial interest for business loans, which is why it’s financially prudent for a company to borrow money or significantly increase R&D budget to repay technical debt.\nSince technical debt has similar properties as financial debt it is also possible to build [[Technical Debt Bubble]].\nThat bubble will appear by itself when company never allows developers to repay debts after deadline is met.",
      "id": "8a3d20b34fb87477612e3c7ee5564982"
    },
    {
      "type": "html",
      "text": "--[[Aleksey Pavlichenko]]",
      "id": "27889e4d17482a031f96302451ba93ce"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "In [[Smalltalk Language]], I think duplicated code is more apparent than in other languages (and certainly easier to refactor away).  In Java, though, I find that duplicated code isn't always obvious and sometimes impossible to refactor out.",
      "id": "a8c51db3e85b4bd5edc5d76178b69be2"
    },
    {
      "type": "html",
      "text": "\nFor example, suppose you have the following code in one method:",
      "id": "b561a4e70926134d2f61ace2fce46c68"
    },
    {
      "type": "code",
      "text": " if (this.o.isSomeCondition()) {\n  doSomething1();\n }",
      "id": "fa78f44d98b8babbb09ddae72e1f38c4"
    },
    {
      "type": "html",
      "text": "and in another method you have:",
      "id": "fb8570abe489e954785638e8ae33a65c"
    },
    {
      "type": "code",
      "text": " if (this.o.isSomeCondition()) {\n  doSomething2();\n }",
      "id": "61c3a143d12ea82efa497014fe51583d"
    },
    {
      "type": "html",
      "text": "\nDoes the if test itself constitute duplicated code?  If so, it could be refactored away through some form of [[Double Dispatch]].  If I were doing [[Big Design Up Front]], I might decide that a [[Double Dispatch]] mechanism might be useful some time in the future, but since [[You Arent Gonna Need It]], I don't do that now.  Does [[Refactor Mercilessly]] dictate that it is, in fact, duplicated code and should be immediately replaced?",
      "id": "5f0e41104f33355a599a9b27b7e9d804"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nBalance the smell against the cost of reducing it <i>in your environment.</i>  Each environment (language, linkers, etc) has its own threshold for how much duplication you can remove without it being too painful or too obfuscating.  These language features lend themselves to removing duplication without excessive pain (and you get to choose what's too painful):",
      "id": "c6388e5f0cd3b29fe7bc7045836036c3"
    },
    {
      "type": "html",
      "text": " Objects",
      "id": "122b580aef7305bcf1b0f4e2e57ca825"
    },
    {
      "type": "html",
      "text": " Dynamic Typing",
      "id": "6c55d82bb07dee63f10e9ba91c57e842"
    },
    {
      "type": "html",
      "text": " Meta-classes",
      "id": "029b96cc3f469c7b156916189b7c697c"
    },
    {
      "type": "html",
      "text": " Reflection",
      "id": "16c57e0d0274f85d37e52cd22d22ea68"
    },
    {
      "type": "html",
      "text": " Macros",
      "id": "a33ea9915447506df7d067db0cc0203b"
    },
    {
      "type": "html",
      "text": " Interpretation",
      "id": "1b6451f2c52c94815d2b9304124f781d"
    },
    {
      "type": "html",
      "text": " Closures / Lambda expressions",
      "id": "4e5ff770f994aa3bb85be929718bf425"
    },
    {
      "type": "html",
      "text": " Inheritance",
      "id": "66835c771be97f7d5542d5a68641016c"
    },
    {
      "type": "html",
      "text": " Templates / Parameterized Types",
      "id": "fc76cf6c1d8f2c1a7d9d387422aa742d"
    },
    {
      "type": "html",
      "text": " [[Aspect Oriented Programming]]",
      "id": "34d077b042754f1a73175b66ccfbde37"
    },
    {
      "type": "html",
      "text": "\nFor example, here's some duplicated (pseudo-) code:",
      "id": "a54214f68383fe0b5dcdde1df7f2dc87"
    },
    {
      "type": "code",
      "text": " def findAManager:\n  for each employee in employees:\n   if employee.isManager:\n    return employee\n  return nil",
      "id": "6adfc89333938ec7337a24d5a4f56343"
    },
    {
      "type": "code",
      "text": " def findASupervisor:\n  for each employee in employees:\n   if employee.isSupervisor:\n    return employee\n  return nil",
      "id": "fcc7a069e1fa8c630980a95899593f67"
    },
    {
      "type": "code",
      "text": " def findAWorkerBee:\n  for each employee in employees:\n   if employee.isWorkerBee:\n    return employee\n  return nil",
      "id": "493b4fb4aad6dc2d7797be1065bcaad9"
    },
    {
      "type": "html",
      "text": "\nHere the loop is duplicated, but removing the loop will obfuscate the code without making it any clearer what you're doing.  If, however, you have something like closures or lambda expressions, you can abstract the loop out:",
      "id": "170f783260fd77382d3fdb3d5c294425"
    },
    {
      "type": "code",
      "text": " def findFirstThat (condition):\n  for each employee in employees:\n   if condition (employee):\n    return employee\n  return nil",
      "id": "dd51274b725ae9cdec473fe7db84bd34"
    },
    {
      "type": "code",
      "text": " def findAManager:\n  return findFirstThat (lambda worker: worker.isManager)",
      "id": "c8b33f8b98332ae7876bf708ad98ca7f"
    },
    {
      "type": "code",
      "text": " def findASupervisor:\n  return findFirstThat (lambda worker: worker.isSupervisor)",
      "id": "b26b234882777b90f158f839eb9ee738"
    },
    {
      "type": "code",
      "text": " def findAWorkerBee:\n  return findFirstThat (lambda worker: worker.isWorkerBee)",
      "id": "4d0528243b1c3c87ae0c4628efa48bdf"
    },
    {
      "type": "html",
      "text": "\nThere are other ways to abstract out the loop, some easier, and some harder.  You just have to balance how hard the abstraction is against how painful the duplicated code is.  Without lambda expressions/closures/continuations/whatever, the little bit of duplication in this little example isn't painful enough to do something about.",
      "id": "3cedd0e0f5406facef7e0bab87441fc6"
    },
    {
      "type": "html",
      "text": "\nSo: Balance smell against pain.",
      "id": "50f201c3c34574d3e12d42ba9f918ca3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "<i>Is it sheer coincidence that the pseudocode above is almost executable [[Python Language]] code? :) [[Burkhard Kloss]]</i>",
      "id": "a9bbbe51498c24745e4828a738666410"
    },
    {
      "type": "html",
      "text": "\nAh.  That's what all the lambdas are doing.  When <i>I</i> write pseudocode, I assume the language lets me say what I want.  e.g.:",
      "id": "9c2837b175e7e896893b76e0ed2fc7b3"
    },
    {
      "type": "code",
      "text": " def findAManager:\n  return findFirstThat (.isManager)",
      "id": "45eb7c6ef85f2aeffa8fa874a2d0b2fe"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nAs a (kind of) counter-example, you can do something similar in C++:",
      "id": "068ece8eb364ccc5ae469f740161b661"
    },
    {
      "type": "code",
      "text": " struct Find''''''Supervisor {\n  bool operator() (const Employee &e) { return e.isSupervisor; }\n } f;",
      "id": "30ed02802742107c4a999f8d467760c4"
    },
    {
      "type": "code",
      "text": " Employees::iterator i = std::find_first_of(employees.begin(),\n  employees.end(), f);\n  if (i != employees.end()) {\n  Employee e = *i;\n  }",
      "id": "154b3c60c5ab21e5e90a511bec8de497"
    },
    {
      "type": "html",
      "text": "\nRepeat as necessary for the other types of worker.",
      "id": "3a83f306a937596d1efc23814ae0a4fd"
    },
    {
      "type": "html",
      "text": "\nMy point being that, because C++ doesn't have real closures, you'll have to find some other way to refactor the expression (or leave it alone).",
      "id": "3ba2a54049a60bf4a6e6940bbf5067c6"
    },
    {
      "type": "html",
      "text": "\nJust reinforcing the point: Balance smell against pain.  You might consider this to be more painful than necessary.",
      "id": "608fa01ea648d21cbbcabda6ad09baa8"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nCheck out [[Once And Only Once]]. Also check [[Pattern Overdose]] and [[Pattern Abuse]]. Your first example on this page has this drift. --[[Bernd Goetz]]",
      "id": "66251f0a2cd321f9636d0e1fd64a1e6e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nFailure to factor out duplicated code is one way to get the dreaded [[Monster Subroutine]].",
      "id": "4c7c21a065b6769b5eb9ec362936fdd8"
    },
    {
      "type": "html",
      "text": "<i>I absolutely agree.  But, when is it time to factor out duplicated code?  Particularly because [[You Arent Gonna Need It]].  Clearly these forces need to be balanced, but how?  <b></i>[[Extreme Programming Master]]</b><i>s can do it through intuition and experience, but I am but a grasshopper.</i> ",
      "id": "67be9d7e34f51f790bbeda702661fc42"
    },
    {
      "type": "html",
      "text": "[My (outsider's) understanding is that [[You Arent Gonna Need It]] doesn't apply to refactorings -- If a particular refactoring brings you closer to [[The Simplest Code]], then you need it.  -- [[An Aspirant]]]",
      "id": "89266196e22b16593ee26030f228326a"
    },
    {
      "type": "html",
      "text": "\nI think that the modification I describe below should set off the alarm - the code is absolutely identical. If there is a chance that the code will at some time differ for the different invocations of the function being replaced, then duplicating the code may make sense.",
      "id": "d6c2b946a4ca064150d9fb42642a22f1"
    },
    {
      "type": "html",
      "text": "\nBesides the scenario described in [[Monster Subroutine]], another arises from code like:",
      "id": "192a695774702b3c9fc36aa05281a4cb"
    },
    {
      "type": "code",
      "text": " modify_it(&X);\n ...\n modify_it(&Y);\n ... more code with modify_it() calls",
      "id": "0225cbddf9b8c47844665200ce8a7dff"
    },
    {
      "type": "html",
      "text": "\nThen a change requires that modify_it()'s functionality be replaced by:",
      "id": "4e4617e29eb3e7121c74f5ad57fa0782"
    },
    {
      "type": "code",
      "text": " prep_modify_it(&X, some_other_variable);\n new_modify_it(&X);\n for ( I = 23; I < 999; ++I) {\n  some_complicated_stuff(&X, I, third_variable + I);\n }",
      "id": "24773a66c0065bc857b9bf4783440ea1"
    },
    {
      "type": "html",
      "text": "and then instead of factoring this into a function, it is edited in place for every modify_it() call, leading to code bloat and difficult maintenance. -- [[Robert Field]]",
      "id": "b5e916b148aaa4c0cde5b467a544f111"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nConsider instead...",
      "id": "beefc0a1f2f1f91e1105de0359b23494"
    },
    {
      "type": "code",
      "text": " modify_it(&X, some_other_variable, third_variable);\n ...\n modify_it(&Y, some_other_variable, third_variable);\n ... more code with modify_it() calls  ''[And change these too, in the obvious way.]''",
      "id": "2350bfcb0c03fdd2d74b9f218f4c3867"
    },
    {
      "type": "code",
      "text": " void modify_it(typeX *pX, type2 some_other_variable, type3 third_variable) {\n  prep_modify_it(pX, some_other_variable);\n  new_modify_it(pX);\n  for ( I = 23; I < 999; ++I) {\n  some_complicated_stuff(pX, I, third_variable + I);\n  }\n }",
      "id": "9b442598c19013d0498c89388715664c"
    },
    {
      "type": "html",
      "text": "-- [[Jeff Grigg]]",
      "id": "cb1b536c84034a78ba7a88a6b0c09fb2"
    },
    {
      "type": "html",
      "text": "<i>Precisely. It is the failure to do something like this refactoring that gives rise to the monsters. -- [[Robert Field]]</i>",
      "id": "9975bcac6a5b8457e1584b481c8de0c2"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nIf we could replace the original with:",
      "id": "6c16d7546cd5c5a24f63449634c04ac7"
    },
    {
      "type": "code",
      "text": " if (isSomeOtherCondition())\n  doSomething1();",
      "id": "3e347b82440aef6b2422e7a8bca2be2f"
    },
    {
      "type": "html",
      "text": "\nso that the expression is at least factored out:",
      "id": "367337b054eb701e7ae3ed2d7995b7ac"
    },
    {
      "type": "code",
      "text": " bool isSomeOtherCondition() {\n  return this.o.isSomeCondition();\n }",
      "id": "8fd1278bc2b322fabbd9f6aba74782a1"
    },
    {
      "type": "html",
      "text": "\nthen the repetition is less painful. (I think it helps to omit the unnecessary braces, too.) See also the [[Law Of Demeter]] for why having hardwiring long dotted-paths like this.o.isSomeCondition() is intrinsically dubious.",
      "id": "83d961dba9e2bac5a11ef0e138f6c736"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nBeg to differ slightly...  this.o.isSomeCondition() simply calls a method on an instance variable, although I would likely use an accessor instead of going directly to the var.  Perhaps the answer is related to \"why can't 'o' decide to doSomething1() or doSomething2() itself?\"",
      "id": "0a614c9eec674e96b065d799c28fc8ca"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nReferring back to:",
      "id": "770cc6f2cbce51c00b43c2267e47fba0"
    },
    {
      "type": "code",
      "text": " def findAManager:\n  for each employee in employees:\n   if employee.isManager:\n    return employee\n  return nil",
      "id": "6adfc89333938ec7337a24d5a4f56343"
    },
    {
      "type": "code",
      "text": " def findASupervisor:\n  for each employee in employees:\n   if employee.isSupervisor:\n    return employee\n  return nil",
      "id": "fcc7a069e1fa8c630980a95899593f67"
    },
    {
      "type": "code",
      "text": " def findAWorkerBee:\n  for each employee in employees:\n   if employee.isWorkerBee:\n    return employee\n  return nil",
      "id": "493b4fb4aad6dc2d7797be1065bcaad9"
    },
    {
      "type": "html",
      "text": "\nThis could also be written as",
      "id": "1690d665a992d412c39a550b00b87288"
    },
    {
      "type": "code",
      "text": " def findType(type)\n  for each employee in employees:\n   if employee.isType(type)\n    return employee\n  return nil",
      "id": "d681bda046ed6817cf9c827bc30d1a44"
    },
    {
      "type": "html",
      "text": "\nIt requires a different way of managing types. I personally prefer this way because you don't have a method per way, plus it allows for iteration over a series of types in a list. For those who want the isType() methods, have them call the generic one.",
      "id": "22e0d32a1a1fc44c3fd1dfb5660304b5"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nA [[Relational Weenie]] version:",
      "id": "d9ba212b0777017462a13795ab5472d4"
    },
    {
      "type": "code",
      "text": "  getEmployees(criteria) {\n    return(query(stdConn, \"select * from employees where %1\", criteria));\n  }",
      "id": "89b69a1e2e111efbd8ce6070d1e12ad1"
    },
    {
      "type": "html",
      "text": "\nNote that this example is not limited to just [[Employee Types]]. However, the downside is that some may consider it a security risk because it is more open-ended ([[Sql Strings And Security]]). Then again, so is the original because one can simply get a list of all employees by calling it 3 times. ",
      "id": "41e079237ab36078dc9b5d79db43b84b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nAn interesting paper on redundant code that shows some statistically significant positive correlation between seemingly harmless duplicated code and real errors is at [http://www.stanford.edu/~engler/p401-xie.pdf www.stanford.edu].  \"We expect that redundancies, even when harmless, strongly correlate with hard errors.  Our relatively uncontroversial hypothesis is that confused or incompetent programmers tend to make mistakes.\"  --[[Steven Newton]]",
      "id": "7ad52c811a85a18236e23589b8be4e6e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nFor automated support finding duplicated code, see [[Sim Scan]], [[Dup Tective]] and [[Same Tool]] (or [[Category Duplication Finding Tool]])",
      "id": "d7d48aaabf1c0ebf52eb75ababe0b1fc"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "The [[Eclipse Ide]] will have in its release 3 a simple(?) refactoring tool for creating methods out of [[Duplicated Code]].  -- [[Andreas Schweikardt]]",
      "id": "596cae6637183fe36d8e27e6b4656575"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "356a00844fe1c84b5b66d25659304fda"
    },
    {
      "type": "html",
      "text": "\nSee also [[Copy And Paste Programming]], [[Once And Only Once]]",
      "id": "2d427ef73a4cf220b50e60a4e2a989cd"
    },
    {
      "type": "html",
      "text": "\n[[Category Anti Pattern]]",
      "id": "264851f89ab3342c5681862474e4eeb0"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?DuplicatedCode c2.com]",
      "id": "670a609f3e86761e3c2f65ab7ddd31fe"
    }
  ],
  "journal": [
    {
      "date": 1416114494000,
      "id": "9129d869576d2a0c0f82a92952f14282",
      "type": "create",
      "item": {
        "title": "Duplicated Code",
        "story": [
          {
            "type": "html",
            "text": "<i>Perhaps this is already covered by [[Copy And Paste Programming]] and [[Code Smell]]s?  [[Deletion Candidate]]</i>",
            "id": "41b2c28bedbdc7926e363a7050cf2fb7"
          },
          {
            "type": "html",
            "text": "\nI don't think so. [[Copy And Paste Programming]] is the process, that often leads to [[Duplicated Code]], but ",
            "id": "39e2c2d476aa4840e3ecf0eff01c11c7"
          },
          {
            "type": "html",
            "text": "it also leads to [[Badly Factored Code]]",
            "id": "5f26d332c02e9731fdfc27feaf55474e"
          },
          {
            "type": "html",
            "text": "there are other sources of [[Duplicated Code]] (e.g. [[Badly Factored Code]])\nwhich means that these two are often related, but none is a special case of the other.",
            "id": "ad8ccf975fa3b558a22e4f5b18638341"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "What constitutes [[Duplicated Code]]?",
            "id": "8c542ec161631a921e4ce80e7fde4ec0"
          },
          {
            "type": "html",
            "text": "<i>Code is duplicated if more succinct code exists that describes the same functionality (gives same desired(excluding noise) results after running).</i> --[[Aleksey Pavlichenko]]",
            "id": "b912988753bf43fe05fdd4f9c2bcade5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "Analogy with Zip data compression:",
            "id": "b2b581f2683d1caa5cb76425a62bbb18"
          },
          {
            "type": "html",
            "text": "\nRefactoring is deduplication of source code done by human. Zip compression is deduplication of data done by machine.",
            "id": "d971f5d2d08565a304996d271c327227"
          },
          {
            "type": "html",
            "text": "\nCompression (deduplication) of one unit of information is many times more CPU-expensive than decompression (duplication).\nSimilarly deduplication of one unit of functionality of software code is many times more human-expensive than duplication.",
            "id": "42b47d3d18ed3fcc52d5bab4969629d0"
          },
          {
            "type": "html",
            "text": "\nConsequently if a company spent X dollars to develop a product with duplicated code it will have to spend X * K dollars on code refactoring without any single visible improvement of the product, where K is between 3 and 100 depending on skills, complexity, language, etc.",
            "id": "50119d2bf3284e4d769bc6d86d5ccb0e"
          },
          {
            "type": "html",
            "text": "\nSome companies hire more and more developers to pay interest on that duplication debt or keep changing developers wondering why production emergencies don’t disappear even with best minds on it.",
            "id": "f3b383a07fbc18e152749e9416fe92ce"
          },
          {
            "type": "html",
            "text": "--[[Aleksey Pavlichenko]]",
            "id": "27889e4d17482a031f96302451ba93ce"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "Analogy with financial interest:",
            "id": "44ab733b5cd8c16fbc47df2e341f41df"
          },
          {
            "type": "html",
            "text": "\n[[Duplicated Code]] represents [[Technical Debt]]. Cost of repayment of that debt equals to cost of human labor that is required to deduplicate the code.\nThat debt has interest in form of decreased productivity of developers.",
            "id": "97572b4abf617f7dacda416002014f46"
          },
          {
            "type": "html",
            "text": "\nThat interest is many times higher than financial interest for business loans, which is why it’s financially prudent for a company to borrow money or significantly increase R&D budget to repay technical debt.\nSince technical debt has similar properties as financial debt it is also possible to build [[Technical Debt Bubble]].\nThat bubble will appear by itself when company never allows developers to repay debts after deadline is met.",
            "id": "8a3d20b34fb87477612e3c7ee5564982"
          },
          {
            "type": "html",
            "text": "--[[Aleksey Pavlichenko]]",
            "id": "27889e4d17482a031f96302451ba93ce"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "In [[Smalltalk Language]], I think duplicated code is more apparent than in other languages (and certainly easier to refactor away).  In Java, though, I find that duplicated code isn't always obvious and sometimes impossible to refactor out.",
            "id": "a8c51db3e85b4bd5edc5d76178b69be2"
          },
          {
            "type": "html",
            "text": "\nFor example, suppose you have the following code in one method:",
            "id": "b561a4e70926134d2f61ace2fce46c68"
          },
          {
            "type": "code",
            "text": " if (this.o.isSomeCondition()) {\n  doSomething1();\n }",
            "id": "fa78f44d98b8babbb09ddae72e1f38c4"
          },
          {
            "type": "html",
            "text": "and in another method you have:",
            "id": "fb8570abe489e954785638e8ae33a65c"
          },
          {
            "type": "code",
            "text": " if (this.o.isSomeCondition()) {\n  doSomething2();\n }",
            "id": "61c3a143d12ea82efa497014fe51583d"
          },
          {
            "type": "html",
            "text": "\nDoes the if test itself constitute duplicated code?  If so, it could be refactored away through some form of [[Double Dispatch]].  If I were doing [[Big Design Up Front]], I might decide that a [[Double Dispatch]] mechanism might be useful some time in the future, but since [[You Arent Gonna Need It]], I don't do that now.  Does [[Refactor Mercilessly]] dictate that it is, in fact, duplicated code and should be immediately replaced?",
            "id": "5f0e41104f33355a599a9b27b7e9d804"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nBalance the smell against the cost of reducing it <i>in your environment.</i>  Each environment (language, linkers, etc) has its own threshold for how much duplication you can remove without it being too painful or too obfuscating.  These language features lend themselves to removing duplication without excessive pain (and you get to choose what's too painful):",
            "id": "c6388e5f0cd3b29fe7bc7045836036c3"
          },
          {
            "type": "html",
            "text": " Objects",
            "id": "122b580aef7305bcf1b0f4e2e57ca825"
          },
          {
            "type": "html",
            "text": " Dynamic Typing",
            "id": "6c55d82bb07dee63f10e9ba91c57e842"
          },
          {
            "type": "html",
            "text": " Meta-classes",
            "id": "029b96cc3f469c7b156916189b7c697c"
          },
          {
            "type": "html",
            "text": " Reflection",
            "id": "16c57e0d0274f85d37e52cd22d22ea68"
          },
          {
            "type": "html",
            "text": " Macros",
            "id": "a33ea9915447506df7d067db0cc0203b"
          },
          {
            "type": "html",
            "text": " Interpretation",
            "id": "1b6451f2c52c94815d2b9304124f781d"
          },
          {
            "type": "html",
            "text": " Closures / Lambda expressions",
            "id": "4e5ff770f994aa3bb85be929718bf425"
          },
          {
            "type": "html",
            "text": " Inheritance",
            "id": "66835c771be97f7d5542d5a68641016c"
          },
          {
            "type": "html",
            "text": " Templates / Parameterized Types",
            "id": "fc76cf6c1d8f2c1a7d9d387422aa742d"
          },
          {
            "type": "html",
            "text": " [[Aspect Oriented Programming]]",
            "id": "34d077b042754f1a73175b66ccfbde37"
          },
          {
            "type": "html",
            "text": "\nFor example, here's some duplicated (pseudo-) code:",
            "id": "a54214f68383fe0b5dcdde1df7f2dc87"
          },
          {
            "type": "code",
            "text": " def findAManager:\n  for each employee in employees:\n   if employee.isManager:\n    return employee\n  return nil",
            "id": "6adfc89333938ec7337a24d5a4f56343"
          },
          {
            "type": "code",
            "text": " def findASupervisor:\n  for each employee in employees:\n   if employee.isSupervisor:\n    return employee\n  return nil",
            "id": "fcc7a069e1fa8c630980a95899593f67"
          },
          {
            "type": "code",
            "text": " def findAWorkerBee:\n  for each employee in employees:\n   if employee.isWorkerBee:\n    return employee\n  return nil",
            "id": "493b4fb4aad6dc2d7797be1065bcaad9"
          },
          {
            "type": "html",
            "text": "\nHere the loop is duplicated, but removing the loop will obfuscate the code without making it any clearer what you're doing.  If, however, you have something like closures or lambda expressions, you can abstract the loop out:",
            "id": "170f783260fd77382d3fdb3d5c294425"
          },
          {
            "type": "code",
            "text": " def findFirstThat (condition):\n  for each employee in employees:\n   if condition (employee):\n    return employee\n  return nil",
            "id": "dd51274b725ae9cdec473fe7db84bd34"
          },
          {
            "type": "code",
            "text": " def findAManager:\n  return findFirstThat (lambda worker: worker.isManager)",
            "id": "c8b33f8b98332ae7876bf708ad98ca7f"
          },
          {
            "type": "code",
            "text": " def findASupervisor:\n  return findFirstThat (lambda worker: worker.isSupervisor)",
            "id": "b26b234882777b90f158f839eb9ee738"
          },
          {
            "type": "code",
            "text": " def findAWorkerBee:\n  return findFirstThat (lambda worker: worker.isWorkerBee)",
            "id": "4d0528243b1c3c87ae0c4628efa48bdf"
          },
          {
            "type": "html",
            "text": "\nThere are other ways to abstract out the loop, some easier, and some harder.  You just have to balance how hard the abstraction is against how painful the duplicated code is.  Without lambda expressions/closures/continuations/whatever, the little bit of duplication in this little example isn't painful enough to do something about.",
            "id": "3cedd0e0f5406facef7e0bab87441fc6"
          },
          {
            "type": "html",
            "text": "\nSo: Balance smell against pain.",
            "id": "50f201c3c34574d3e12d42ba9f918ca3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "<i>Is it sheer coincidence that the pseudocode above is almost executable [[Python Language]] code? :) [[Burkhard Kloss]]</i>",
            "id": "a9bbbe51498c24745e4828a738666410"
          },
          {
            "type": "html",
            "text": "\nAh.  That's what all the lambdas are doing.  When <i>I</i> write pseudocode, I assume the language lets me say what I want.  e.g.:",
            "id": "9c2837b175e7e896893b76e0ed2fc7b3"
          },
          {
            "type": "code",
            "text": " def findAManager:\n  return findFirstThat (.isManager)",
            "id": "45eb7c6ef85f2aeffa8fa874a2d0b2fe"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nAs a (kind of) counter-example, you can do something similar in C++:",
            "id": "068ece8eb364ccc5ae469f740161b661"
          },
          {
            "type": "code",
            "text": " struct Find''''''Supervisor {\n  bool operator() (const Employee &e) { return e.isSupervisor; }\n } f;",
            "id": "30ed02802742107c4a999f8d467760c4"
          },
          {
            "type": "code",
            "text": " Employees::iterator i = std::find_first_of(employees.begin(),\n  employees.end(), f);\n  if (i != employees.end()) {\n  Employee e = *i;\n  }",
            "id": "154b3c60c5ab21e5e90a511bec8de497"
          },
          {
            "type": "html",
            "text": "\nRepeat as necessary for the other types of worker.",
            "id": "3a83f306a937596d1efc23814ae0a4fd"
          },
          {
            "type": "html",
            "text": "\nMy point being that, because C++ doesn't have real closures, you'll have to find some other way to refactor the expression (or leave it alone).",
            "id": "3ba2a54049a60bf4a6e6940bbf5067c6"
          },
          {
            "type": "html",
            "text": "\nJust reinforcing the point: Balance smell against pain.  You might consider this to be more painful than necessary.",
            "id": "608fa01ea648d21cbbcabda6ad09baa8"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nCheck out [[Once And Only Once]]. Also check [[Pattern Overdose]] and [[Pattern Abuse]]. Your first example on this page has this drift. --[[Bernd Goetz]]",
            "id": "66251f0a2cd321f9636d0e1fd64a1e6e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nFailure to factor out duplicated code is one way to get the dreaded [[Monster Subroutine]].",
            "id": "4c7c21a065b6769b5eb9ec362936fdd8"
          },
          {
            "type": "html",
            "text": "<i>I absolutely agree.  But, when is it time to factor out duplicated code?  Particularly because [[You Arent Gonna Need It]].  Clearly these forces need to be balanced, but how?  <b></i>[[Extreme Programming Master]]</b><i>s can do it through intuition and experience, but I am but a grasshopper.</i> ",
            "id": "67be9d7e34f51f790bbeda702661fc42"
          },
          {
            "type": "html",
            "text": "[My (outsider's) understanding is that [[You Arent Gonna Need It]] doesn't apply to refactorings -- If a particular refactoring brings you closer to [[The Simplest Code]], then you need it.  -- [[An Aspirant]]]",
            "id": "89266196e22b16593ee26030f228326a"
          },
          {
            "type": "html",
            "text": "\nI think that the modification I describe below should set off the alarm - the code is absolutely identical. If there is a chance that the code will at some time differ for the different invocations of the function being replaced, then duplicating the code may make sense.",
            "id": "d6c2b946a4ca064150d9fb42642a22f1"
          },
          {
            "type": "html",
            "text": "\nBesides the scenario described in [[Monster Subroutine]], another arises from code like:",
            "id": "192a695774702b3c9fc36aa05281a4cb"
          },
          {
            "type": "code",
            "text": " modify_it(&X);\n ...\n modify_it(&Y);\n ... more code with modify_it() calls",
            "id": "0225cbddf9b8c47844665200ce8a7dff"
          },
          {
            "type": "html",
            "text": "\nThen a change requires that modify_it()'s functionality be replaced by:",
            "id": "4e4617e29eb3e7121c74f5ad57fa0782"
          },
          {
            "type": "code",
            "text": " prep_modify_it(&X, some_other_variable);\n new_modify_it(&X);\n for ( I = 23; I < 999; ++I) {\n  some_complicated_stuff(&X, I, third_variable + I);\n }",
            "id": "24773a66c0065bc857b9bf4783440ea1"
          },
          {
            "type": "html",
            "text": "and then instead of factoring this into a function, it is edited in place for every modify_it() call, leading to code bloat and difficult maintenance. -- [[Robert Field]]",
            "id": "b5e916b148aaa4c0cde5b467a544f111"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nConsider instead...",
            "id": "beefc0a1f2f1f91e1105de0359b23494"
          },
          {
            "type": "code",
            "text": " modify_it(&X, some_other_variable, third_variable);\n ...\n modify_it(&Y, some_other_variable, third_variable);\n ... more code with modify_it() calls  ''[And change these too, in the obvious way.]''",
            "id": "2350bfcb0c03fdd2d74b9f218f4c3867"
          },
          {
            "type": "code",
            "text": " void modify_it(typeX *pX, type2 some_other_variable, type3 third_variable) {\n  prep_modify_it(pX, some_other_variable);\n  new_modify_it(pX);\n  for ( I = 23; I < 999; ++I) {\n  some_complicated_stuff(pX, I, third_variable + I);\n  }\n }",
            "id": "9b442598c19013d0498c89388715664c"
          },
          {
            "type": "html",
            "text": "-- [[Jeff Grigg]]",
            "id": "cb1b536c84034a78ba7a88a6b0c09fb2"
          },
          {
            "type": "html",
            "text": "<i>Precisely. It is the failure to do something like this refactoring that gives rise to the monsters. -- [[Robert Field]]</i>",
            "id": "9975bcac6a5b8457e1584b481c8de0c2"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nIf we could replace the original with:",
            "id": "6c16d7546cd5c5a24f63449634c04ac7"
          },
          {
            "type": "code",
            "text": " if (isSomeOtherCondition())\n  doSomething1();",
            "id": "3e347b82440aef6b2422e7a8bca2be2f"
          },
          {
            "type": "html",
            "text": "\nso that the expression is at least factored out:",
            "id": "367337b054eb701e7ae3ed2d7995b7ac"
          },
          {
            "type": "code",
            "text": " bool isSomeOtherCondition() {\n  return this.o.isSomeCondition();\n }",
            "id": "8fd1278bc2b322fabbd9f6aba74782a1"
          },
          {
            "type": "html",
            "text": "\nthen the repetition is less painful. (I think it helps to omit the unnecessary braces, too.) See also the [[Law Of Demeter]] for why having hardwiring long dotted-paths like this.o.isSomeCondition() is intrinsically dubious.",
            "id": "83d961dba9e2bac5a11ef0e138f6c736"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nBeg to differ slightly...  this.o.isSomeCondition() simply calls a method on an instance variable, although I would likely use an accessor instead of going directly to the var.  Perhaps the answer is related to \"why can't 'o' decide to doSomething1() or doSomething2() itself?\"",
            "id": "0a614c9eec674e96b065d799c28fc8ca"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nReferring back to:",
            "id": "770cc6f2cbce51c00b43c2267e47fba0"
          },
          {
            "type": "code",
            "text": " def findAManager:\n  for each employee in employees:\n   if employee.isManager:\n    return employee\n  return nil",
            "id": "6adfc89333938ec7337a24d5a4f56343"
          },
          {
            "type": "code",
            "text": " def findASupervisor:\n  for each employee in employees:\n   if employee.isSupervisor:\n    return employee\n  return nil",
            "id": "fcc7a069e1fa8c630980a95899593f67"
          },
          {
            "type": "code",
            "text": " def findAWorkerBee:\n  for each employee in employees:\n   if employee.isWorkerBee:\n    return employee\n  return nil",
            "id": "493b4fb4aad6dc2d7797be1065bcaad9"
          },
          {
            "type": "html",
            "text": "\nThis could also be written as",
            "id": "1690d665a992d412c39a550b00b87288"
          },
          {
            "type": "code",
            "text": " def findType(type)\n  for each employee in employees:\n   if employee.isType(type)\n    return employee\n  return nil",
            "id": "d681bda046ed6817cf9c827bc30d1a44"
          },
          {
            "type": "html",
            "text": "\nIt requires a different way of managing types. I personally prefer this way because you don't have a method per way, plus it allows for iteration over a series of types in a list. For those who want the isType() methods, have them call the generic one.",
            "id": "22e0d32a1a1fc44c3fd1dfb5660304b5"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nA [[Relational Weenie]] version:",
            "id": "d9ba212b0777017462a13795ab5472d4"
          },
          {
            "type": "code",
            "text": "  getEmployees(criteria) {\n    return(query(stdConn, \"select * from employees where %1\", criteria));\n  }",
            "id": "89b69a1e2e111efbd8ce6070d1e12ad1"
          },
          {
            "type": "html",
            "text": "\nNote that this example is not limited to just [[Employee Types]]. However, the downside is that some may consider it a security risk because it is more open-ended ([[Sql Strings And Security]]). Then again, so is the original because one can simply get a list of all employees by calling it 3 times. ",
            "id": "41e079237ab36078dc9b5d79db43b84b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nAn interesting paper on redundant code that shows some statistically significant positive correlation between seemingly harmless duplicated code and real errors is at [http://www.stanford.edu/~engler/p401-xie.pdf www.stanford.edu].  \"We expect that redundancies, even when harmless, strongly correlate with hard errors.  Our relatively uncontroversial hypothesis is that confused or incompetent programmers tend to make mistakes.\"  --[[Steven Newton]]",
            "id": "7ad52c811a85a18236e23589b8be4e6e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nFor automated support finding duplicated code, see [[Sim Scan]], [[Dup Tective]] and [[Same Tool]] (or [[Category Duplication Finding Tool]])",
            "id": "d7d48aaabf1c0ebf52eb75ababe0b1fc"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "The [[Eclipse Ide]] will have in its release 3 a simple(?) refactoring tool for creating methods out of [[Duplicated Code]].  -- [[Andreas Schweikardt]]",
            "id": "596cae6637183fe36d8e27e6b4656575"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "356a00844fe1c84b5b66d25659304fda"
          },
          {
            "type": "html",
            "text": "\nSee also [[Copy And Paste Programming]], [[Once And Only Once]]",
            "id": "2d427ef73a4cf220b50e60a4e2a989cd"
          },
          {
            "type": "html",
            "text": "\n[[Category Anti Pattern]]",
            "id": "264851f89ab3342c5681862474e4eeb0"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?DuplicatedCode c2.com]",
            "id": "670a609f3e86761e3c2f65ab7ddd31fe"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "code.sfw.c2.com",
      "date": 1708086504067
    }
  ]
}