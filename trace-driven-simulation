{
  "title": "Trace Driven Simulation",
  "story": [
    {
      "type": "paragraph",
      "id": "9592bf6ce1464f40",
      "text": "One of the problems with trace driven simulation is that trace collection and storage are time and space consuming procedures. "
    },
    {
      "type": "paragraph",
      "id": "e72a090a84a3440b",
      "text": "To collect a trace, hardware or software monitors are used. The amount of data to be saved is of the order of hundreds or thousands of megabytes for some minutes the program executions. This is necessary to produce reliable results [15]. "
    },
    {
      "type": "paragraph",
      "id": "3a174f69cf53214b",
      "text": "Due to the large amount of data to be processed the computer time is also very long. Several techniques have been proposed to reduce the cache simulation time: trace stripping, trace sampling, simulation of several cache configurations in one pass of the trace [26] and parallel simulation [14], [23]. "
    },
    {
      "type": "paragraph",
      "id": "4f39d1c305631369",
      "text": "Synthetic traces have been proposed as an alternative to secondary-storage based traces since they are faster and do not demand disk space. They are also attractive since and they could be controlled by a reduced set of parameters which regulate the workload behavior. The problem of Synthetic traces is that it is difficult to exactly mimic the real behavior of the addressed program, thus limiting the use of the traces to early evaluation stages. Many studies, for example [9], [27], have highlighted the difficulty to exactly describe original characteristics of the memory references, such as locality, with analytic models."
    },
    {
      "type": "pagefold",
      "id": "f3454d001978ec26",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "75fb0014bfc1f553",
      "text": "\nCUZZOCREA, Alfredo, MUMOLO, Enzo, HASSANI, Marwan and GRASSO, Giorgio Mario, 2018. Towards Effective Generation of Synthetic Memory References Via Markovian Models. In: 2018 IEEE 42nd Annual Computer Software and Applications Conference (COMPSAC). July 2018. p. 199–203. DOI 10.1109/COMPSAC.2018.10229. "
    },
    {
      "type": "paragraph",
      "id": "8dc57e4f1f231800",
      "text": "In this paper we introduce a technique for the synthetic generation of memory references which behave as those generated by given running programs. Our approach is based on a novel Machine Learning algorithm we called Hierarchical Hidden/non Hidden Markov Model (HHnHMM). Short chunks of memory references from a running program are classified as Sequential, Periodic, Random, Jump or Other. Such execution classes are used to train an HHnHMM for that program. "
    },
    {
      "type": "paragraph",
      "id": "ea56eef44ebc978e",
      "text": "Trained HHnHMM are used as stochastic generators of memory reference addresses. In this way we can [[generate]] in real time memory reference streams of any length, which mimic the behavior of given programs without the need to store anything."
    },
    {
      "type": "paragraph",
      "id": "2e57beb07340ed4d",
      "text": "[…]"
    },
    {
      "type": "paragraph",
      "id": "db41837a910cb8d2",
      "text": "p. 201: Memory Reference Pattern of Matrix Multiplication Example […] Fig. 4: Memory references generated by the matrix multiplication example"
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Trace Driven Simulation",
        "story": []
      },
      "date": 1674257077581
    },
    {
      "item": {
        "type": "factory",
        "id": "9592bf6ce1464f40"
      },
      "id": "9592bf6ce1464f40",
      "type": "add",
      "date": 1674257081030
    },
    {
      "type": "edit",
      "id": "9592bf6ce1464f40",
      "item": {
        "type": "paragraph",
        "id": "9592bf6ce1464f40",
        "text": "One of the problems with trace driven simulation is that trace collection and storage are time and space consuming procedures. To collect a trace, hardware or software monitors are used. The amount of data to be saved is of the order of hundreds or thousands of megabytes for some minutes the program executions. This is necessary to produce reliable results [15]. Due to the large amount of data to be processed the computer time is also very long. Several techniques have been proposed to reduce the cache simulation time: trace stripping, trace sampling, simulation of several cache configurations in one pass of the trace [26] and parallel simulation [14], [23]. Synthetic traces have been proposed as an alternative to secondary-storage based traces since they are faster and do not demand disk space. They are also attractive since and they could be controlled by a reduced set of parameters which regulate the workload behavior. The problem of Synthetic traces is that it is difficult to exactly mimic the real behavior of the addressed program, thus limiting the use of the traces to early evaluation stages. Many studies, for example [9], [27], have highlighted the difficulty to exactly describe original characteristics of the memory references, such as locality, with analytic models."
      },
      "date": 1674257093831
    },
    {
      "item": {
        "type": "factory",
        "id": "f3454d001978ec26"
      },
      "id": "f3454d001978ec26",
      "type": "add",
      "after": "9592bf6ce1464f40",
      "date": 1674257103828
    },
    {
      "type": "edit",
      "id": "f3454d001978ec26",
      "item": {
        "type": "pagefold",
        "id": "f3454d001978ec26",
        "text": "~"
      },
      "date": 1674257108542
    },
    {
      "item": {
        "type": "factory",
        "id": "75fb0014bfc1f553"
      },
      "id": "75fb0014bfc1f553",
      "type": "add",
      "after": "f3454d001978ec26",
      "date": 1674257110258
    },
    {
      "type": "edit",
      "id": "75fb0014bfc1f553",
      "item": {
        "type": "paragraph",
        "id": "75fb0014bfc1f553",
        "text": "\nCUZZOCREA, Alfredo, MUMOLO, Enzo, HASSANI, Marwan and GRASSO, Giorgio Mario, 2018. Towards Effective Generation of Synthetic Memory References Via Markovian Models. In: 2018 IEEE 42nd Annual Computer Software and Applications Conference (COMPSAC). July 2018. p. 199–203. DOI 10.1109/COMPSAC.2018.10229. "
      },
      "date": 1674257121840
    },
    {
      "type": "add",
      "id": "8dc57e4f1f231800",
      "item": {
        "type": "paragraph",
        "id": "8dc57e4f1f231800",
        "text": "In this paper we introduce a technique for the synthetic generation of memory references which behave as those generated by given running programs. Our approach is based on a novel Machine Learning algorithm we called Hierarchical Hidden/non Hidden Markov Model (HHnHMM). Short chunks of memory references from a running program are classified as Sequential, Periodic, Random, Jump or Other. Such execution classes are used to train an HHnHMM for that program. Trained HHnHMM are used as stochastic generators of memory reference addresses. In this way we can generate in real time memory reference streams of any length, which mimic the behavior of given programs without the need to store anything.\n"
      },
      "after": "75fb0014bfc1f553",
      "date": 1674257122762
    },
    {
      "type": "edit",
      "id": "9592bf6ce1464f40",
      "item": {
        "type": "paragraph",
        "id": "9592bf6ce1464f40",
        "text": "One of the problems with trace driven simulation is that trace collection and storage are time and space consuming procedures. "
      },
      "date": 1674257137896
    },
    {
      "type": "add",
      "id": "e72a090a84a3440b",
      "item": {
        "type": "paragraph",
        "id": "e72a090a84a3440b",
        "text": "To collect a trace, hardware or software monitors are used. The amount of data to be saved is of the order of hundreds or thousands of megabytes for some minutes the program executions. This is necessary to produce reliable results [15]. Due to the large amount of data to be processed the computer time is also very long. Several techniques have been proposed to reduce the cache simulation time: trace stripping, trace sampling, simulation of several cache configurations in one pass of the trace [26] and parallel simulation [14], [23]. Synthetic traces have been proposed as an alternative to secondary-storage based traces since they are faster and do not demand disk space. They are also attractive since and they could be controlled by a reduced set of parameters which regulate the workload behavior. The problem of Synthetic traces is that it is difficult to exactly mimic the real behavior of the addressed program, thus limiting the use of the traces to early evaluation stages. Many studies, for example [9], [27], have highlighted the difficulty to exactly describe original characteristics of the memory references, such as locality, with analytic models."
      },
      "after": "9592bf6ce1464f40",
      "date": 1674257139111
    },
    {
      "type": "edit",
      "id": "e72a090a84a3440b",
      "item": {
        "type": "paragraph",
        "id": "e72a090a84a3440b",
        "text": "To collect a trace, hardware or software monitors are used. The amount of data to be saved is of the order of hundreds or thousands of megabytes for some minutes the program executions. This is necessary to produce reliable results [15]. "
      },
      "date": 1674257158817
    },
    {
      "type": "add",
      "id": "3a174f69cf53214b",
      "item": {
        "type": "paragraph",
        "id": "3a174f69cf53214b",
        "text": "Due to the large amount of data to be processed the computer time is also very long. Several techniques have been proposed to reduce the cache simulation time: trace stripping, trace sampling, simulation of several cache configurations in one pass of the trace [26] and parallel simulation [14], [23]. Synthetic traces have been proposed as an alternative to secondary-storage based traces since they are faster and do not demand disk space. They are also attractive since and they could be controlled by a reduced set of parameters which regulate the workload behavior. The problem of Synthetic traces is that it is difficult to exactly mimic the real behavior of the addressed program, thus limiting the use of the traces to early evaluation stages. Many studies, for example [9], [27], have highlighted the difficulty to exactly describe original characteristics of the memory references, such as locality, with analytic models."
      },
      "after": "e72a090a84a3440b",
      "date": 1674257159778
    },
    {
      "type": "edit",
      "id": "3a174f69cf53214b",
      "item": {
        "type": "paragraph",
        "id": "3a174f69cf53214b",
        "text": "Due to the large amount of data to be processed the computer time is also very long. Several techniques have been proposed to reduce the cache simulation time: trace stripping, trace sampling, simulation of several cache configurations in one pass of the trace [26] and parallel simulation [14], [23]. "
      },
      "date": 1674257179624
    },
    {
      "type": "add",
      "id": "4f39d1c305631369",
      "item": {
        "type": "paragraph",
        "id": "4f39d1c305631369",
        "text": "Synthetic traces have been proposed as an alternative to secondary-storage based traces since they are faster and do not demand disk space. They are also attractive since and they could be controlled by a reduced set of parameters which regulate the workload behavior. The problem of Synthetic traces is that it is difficult to exactly mimic the real behavior of the addressed program, thus limiting the use of the traces to early evaluation stages. Many studies, for example [9], [27], have highlighted the difficulty to exactly describe original characteristics of the memory references, such as locality, with analytic models."
      },
      "after": "3a174f69cf53214b",
      "date": 1674257180075
    },
    {
      "type": "edit",
      "id": "8dc57e4f1f231800",
      "item": {
        "type": "paragraph",
        "id": "8dc57e4f1f231800",
        "text": "In this paper we introduce a technique for the synthetic generation of memory references which behave as those generated by given running programs. Our approach is based on a novel Machine Learning algorithm we called Hierarchical Hidden/non Hidden Markov Model (HHnHMM). Short chunks of memory references from a running program are classified as Sequential, Periodic, Random, Jump or Other. Such execution classes are used to train an HHnHMM for that program. Trained HHnHMM are used as stochastic generators of memory reference addresses. In this way we can [[generate]] in real time memory reference streams of any length, which mimic the behavior of given programs without the need to store anything.\n"
      },
      "date": 1674257238461
    },
    {
      "type": "edit",
      "id": "8dc57e4f1f231800",
      "item": {
        "type": "paragraph",
        "id": "8dc57e4f1f231800",
        "text": "In this paper we introduce a technique for the synthetic generation of memory references which behave as those generated by given running programs. Our approach is based on a novel Machine Learning algorithm we called Hierarchical Hidden/non Hidden Markov Model (HHnHMM). Short chunks of memory references from a running program are classified as Sequential, Periodic, Random, Jump or Other. Such execution classes are used to train an HHnHMM for that program. "
      },
      "date": 1674257262666
    },
    {
      "type": "add",
      "id": "ea56eef44ebc978e",
      "item": {
        "type": "paragraph",
        "id": "ea56eef44ebc978e",
        "text": "Trained HHnHMM are used as stochastic generators of memory reference addresses. In this way we can [[generate]] in real time memory reference streams of any length, which mimic the behavior of given programs without the need to store anything.\n"
      },
      "after": "8dc57e4f1f231800",
      "date": 1674257266457
    },
    {
      "type": "edit",
      "id": "ea56eef44ebc978e",
      "item": {
        "type": "paragraph",
        "id": "ea56eef44ebc978e",
        "text": "Trained HHnHMM are used as stochastic generators of memory reference addresses. In this way we can [[generate]] in real time memory reference streams of any length, which mimic the behavior of given programs without the need to store anything."
      },
      "date": 1674259528420
    },
    {
      "type": "add",
      "id": "2e57beb07340ed4d",
      "item": {
        "type": "paragraph",
        "id": "2e57beb07340ed4d",
        "text": "[…]"
      },
      "after": "ea56eef44ebc978e",
      "date": 1674259533789
    },
    {
      "type": "add",
      "id": "db41837a910cb8d2",
      "item": {
        "type": "paragraph",
        "id": "db41837a910cb8d2",
        "text": "Memory Reference Pattern of Matrix Multiplication Example"
      },
      "after": "2e57beb07340ed4d",
      "date": 1674259590146
    },
    {
      "type": "edit",
      "id": "db41837a910cb8d2",
      "item": {
        "type": "paragraph",
        "id": "db41837a910cb8d2",
        "text": "Memory Reference Pattern of Matrix Multiplication Example […] Fig. 4: Memory references generated by the matrix multiplication example"
      },
      "date": 1674259612397
    },
    {
      "type": "edit",
      "id": "db41837a910cb8d2",
      "item": {
        "type": "paragraph",
        "id": "db41837a910cb8d2",
        "text": "p. 201: Memory Reference Pattern of Matrix Multiplication Example […] Fig. 4: Memory references generated by the matrix multiplication example"
      },
      "date": 1674259628836
    }
  ]
}