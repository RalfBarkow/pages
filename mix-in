{
  "title": "Mix In",
  "story": [
    {
      "type": "html",
      "text": "[[Mix In]] programming is a style of software development where units of functionality are created in a class and then mixed in with other classes.",
      "id": "8380fc8ef850bbf3a4076f2d1f684420"
    },
    {
      "type": "html",
      "text": "\nA mixin class is a parent class that is inherited from - but not as a means of specialization. Typically, the mixin will export services to a child class, but no semantics will be implied about the child \"being a kind of\" the parent.",
      "id": "542e86dad0540cf9c3276881774b9f3f"
    },
    {
      "type": "html",
      "text": "\nA [[Mix In]] is also called an [[Abstract Subclass]] since [[Mix In]] can provide other services based on the services the original class provides.",
      "id": "4a3bc2a600df7ba6a199f986ce545545"
    },
    {
      "type": "html",
      "text": "\nMixins are controversial because the prescribed way of providing such services is by association. However, they are useful because inheritance places the services within the child itself. For this reason they are commonly found in windows class libraries where there is a need for certain features to be generalized for \"mixing in\" later.",
      "id": "b44b9a8e880f72b97ff1a7a2e81dcffe"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "Actually Mixins are only 'controversial' because people try to use them in languages\nwith no support for them. This makes all kinds of problems. See the [[Flavors]] mixins.",
      "id": "313d19903dfd7c867ecc62d3da0333ff"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nAlso see [[Mixins For Cee Plus Plus]]",
      "id": "ce73136b75e19f7395886b0641cbe28b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nMixins are coming from Flavors. Flavors is an early Object System for the [[Lisp Machine]].",
      "id": "4ca3e7b0d83eeeb0c9e4cbef3f4f2436"
    },
    {
      "type": "html",
      "text": "\nImagine you have vanilla ice where you can add in different stuff. So the base class in Flavors was called Vanilla. Parts of the Lisp Machine operating system were programmed using mixins. An example is the window system, where you can mixin borders-mixins into window classes. So it does not mixin the borders itself, but adds the feature that the window has borders. In Flavors the classes slots are extended AND (and that is the big AND) the methods get extended OR overwritten, too. In the case of the border-mixin the idea is that it also extends (!!) the window-draw method to draw the borders.",
      "id": "42cf9cd25eff05aa78504a449c0cfba3"
    },
    {
      "type": "html",
      "text": "\n[[Common Lisp]] also supports the mixin style of programming. Most other programming languages make it difficult, because they don't have [[Method Combination]]s.",
      "id": "cbd5cfe8d12aa685cb74bfeb404b0d06"
    },
    {
      "type": "html",
      "text": "\nSee: David A. Moon. Object-oriented programming with Flavors. In Proc. First Annual Conference on Object-Oriented Programming Systems, Languages, and Applications. ACM, 1986.",
      "id": "5a2eb3cada8664e084c31b8ddd10b532"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nAn example for the mechanism using the [[Common Lisp Object System]]:",
      "id": "4e591331133944e0e40d41dfbbfc66d0"
    },
    {
      "type": "code",
      "text": "  (defclass window ()\n    ((width\n    :accessor window-width\n    :initarg :width\n    :type integer\n    :initform 200)))",
      "id": "b585daf72d6be83416561a44248dc22e"
    },
    {
      "type": "code",
      "text": "  (defclass border-mixin ()\n    ((border-width\n    :type integer\n    :initarg :border-width\n    :initform 1)))",
      "id": "3a0be4938223ab98a72d38480ad008bb"
    },
    {
      "type": "html",
      "text": "\nThis next function is the key element, which is not really possible in most object oriented languages.\nMost don't have :around, :before or :after methods. This facility is known as [[Method Combination]].",
      "id": "80eaddf7dd91189f7b2ff89510138a27"
    },
    {
      "type": "code",
      "text": "  (defmethod window-width :around ((window border-mixin))\n    (+ (call-next-method)\n    (* 2 (slot-value window 'border-width))))",
      "id": "06c004e199a7584314e5a8c53e739727"
    },
    {
      "type": "html",
      "text": "Now we define our own window class, which also inherits from our mixin class:",
      "id": "012f558c4b61c963aa9b067cb37b3c60"
    },
    {
      "type": "code",
      "text": "  (defclass my-window-with-border (border-mixin window)\n    ())",
      "id": "6252790c0f7970df00ccccfe69beaf27"
    },
    {
      "type": "html",
      "text": "An instance:",
      "id": "1ca9d7d2abb0ca701b88786c4527c2e9"
    },
    {
      "type": "code",
      "text": "  (defvar *my-window* (make-instance 'my-window-with-border\n        :width 400\n        :border-width 10)",
      "id": "da5e8ebfa91dc3f6a7ad5807937a7b4f"
    },
    {
      "type": "html",
      "text": "We call the WINDOW-WIDTH method, which then runs the :AROUND method around the\nprimary WINDOW-WIDTH method. So it computes (+ width (* 2 border-width)) :",
      "id": "94bf412c242e5142b4bab55facad6101"
    },
    {
      "type": "code",
      "text": "  (window-width *my-window*)  ->  420",
      "id": "758944c3bddb97ab011e62f62b4b80df"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nDo you really need full-fledged [[Method Combination]], or is it enough to have a well-defined class-precedence list and the ability to call the next method in the list? I'm thinking of [[Dylan Language]], which doesn't have [[Method Combination]], but does copy [[Common Lisp]]'s [[Generic Function]] paradigm, along with how to compute the class precedence list. It seems like the above example could be done just by translating the classes into Dylan syntax and then writing window-width like this:",
      "id": "5025dcc037ff50db20617ac67ecce6f0"
    },
    {
      "type": "html",
      "text": "define method window-width (window ::<br><border-mixin>)",
      "id": "1ab0a3c04e275dc6cc1772c9c52e4a92"
    },
    {
      "type": "code",
      "text": "  next-method() + 2 * window.border-width;\n  end window-width;",
      "id": "98104e06b1b650f65ae61a4a629a17d9"
    },
    {
      "type": "html",
      "text": "\nYou do have to make sure that <border-mixin> precedes <window> in the class hierarchy for <my-window-with-border>, but it seems like you would run into that problem even with CLOS if you ever tried to combine 2 or more mixins (since the various :around methods get ordered by the class precedence list too).",
      "id": "3f7350630bacc0d56ca34630588cb03a"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nWell, in this case the ordering is not important for the CLOS example.\nAll :AROUND methods are used.",
      "id": "df45e4c4663bbfe4f5a86b62d2aad1cc"
    },
    {
      "type": "html",
      "text": "\nIn CLOS one could also use a + method combination, where the results of all methods get collected. So, you would define a bunch of WIDTH methods for the various elements that contribute to the window width and have them added by the method combination.",
      "id": "9c6ab2f769f60555b62e15f0a4d3a384"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nThe word \"mixin\" comes from Steve's Ice Cream, a favorite ice cream shop of MIT students located in Somerville, Mass., in the late '70s. Steve's made its own (very rich) ice cream in a motorized old-fashioned ice cream maker in the window of the shop. Sometimes the line for an ice cream cone was out the door and down the block!",
      "id": "b1a33b52fbe36e8ee01553ea03eee666"
    },
    {
      "type": "html",
      "text": "\nYou would order a cone or dish, and specify the base flavor and any mixins you wanted. The person behind the counter would plop your scoop of ice cream on a marble slab, dump a spoonful of mixins on top, and knead the two together, using two metal spatulas. My personal favorite was chocolate ice cream with crushed Oreo cookies mixed in. -- [[Stan Silver]]",
      "id": "a42cd894d55c7cfe0fcf2ac7e371d6da"
    },
    {
      "type": "html",
      "text": "\"The term mixin comes from an ice cream store in Somerville, Massachusetts, where candies and cakes were mixed into the basic ice cream flavors. This seemed like a good metaphor to some of the object-oriented programmers who used to take a summer break there, especially while working with the object-oriented programming language SCOOPS.\" (<i>SAMS Teach Yourself C++ in 21 Days,</i> 4th ed., p. 458.)",
      "id": "14868f69b3b16f663c99f49137c6383b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nThe grapevine informs me that Symbolics' object-oriented Flavors system is most likely the earliest appearance of bona fide mix-ins. The designers were inspired by Steve's Ice Cream Parlor in Cambridge, Massachusetts where customers started with a basic flavor of ice cream (vanilla, chocolate, etc.) and added any combination of mix-ins (nuts, fudge, chocolate chips, etc.). In the Symbolics system, large, standalone classes were known as flavors while smaller helper classes designed for enhancing other classes were known as mix-ins. ",
      "id": "d7b1b87f8f896eb252b38a258d06733f"
    },
    {
      "type": "html",
      "text": "[<i>From Chuck Esterbrook's article in Linux Journal #84 April, 2001</i> [http://noframes.linuxjournal.com/lj-issues/issue84/4540.html noframes.linuxjournal.com]]",
      "id": "d47e507c98d0a00e772d44bfcb3559ba"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nOne interesting way in which mixins are used in the [[Common Lisp Object System]] is by having them add to the list of applicable methods. E.g., you might have a class <i>base</i>, and a class <i>derived</i>, which want to specialize method <i>foo</i>. But you might also want to, say, add notification, as in an [[Observer Pattern]]. You create the <i>observed-mixin</i>, and do",
      "id": "21504edaf3198f3f433c0d0acf2417a7"
    },
    {
      "type": "code",
      "text": "  (defclass derived (base observed-mixin)\n  ())",
      "id": "2b22acac24375890958c984afb491e0b"
    },
    {
      "type": "code",
      "text": "  (defmethod foo ((self base))\n  ;; do foo type stuff\n  )",
      "id": "2475b3a632aade080229cd519f3456f3"
    },
    {
      "type": "html",
      "text": "And the author of the mixin can write",
      "id": "bebc2d6182b112ee0fdcaf2c61543981"
    },
    {
      "type": "code",
      "text": "  (defmethod foo :after ((self observed-mixin))\n  (notify-all-observers (format nil \"~A is being fooed!\" self)))",
      "id": "45f6b22af645bb334afa4f1d75bd3043"
    },
    {
      "type": "html",
      "text": "This doesn't change anything to how foo acts on a derived, but lets all derived\nthat want to be observed do so by simply inheriting the mixin.\nThe use of the :before after :after methods that are part of the standard [[Method Combination]] makes this a handy pattern in the [[Common Lisp Object System]].",
      "id": "bf94e99361e723c4907cfbf848bf8faf"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nIn addition to the [[Common Lisp Object System]], the [[Xo Tcl Extension]] (for the [[Tool Command Language]]) has good support for mixins.",
      "id": "11ae22f39d85c3e3c4d569d0a0312030"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nAlso see [[Mixins For Python]]",
      "id": "63530fc596e7943b31da1bdc69e73b47"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\n[[Category Polymorphism]]",
      "id": "84633e4b9ea9cd9d8e3cc891dde47966"
    },
    {
      "type": "html",
      "text": "\nIt has become doubtful as to whether [[Mix In]] techniques can be called polymorphism. According to [[Non Polymorphic Inheritance]], using a [[Mix In]] does not entail delegation (see [[What Is Delegation]]), and so lacking the requisite indirection, does not have polymorphic behavior.",
      "id": "133b923ee2fb112ae2143cc672e5f701"
    },
    {
      "type": "html",
      "text": "<i>Delegation does not imply polymorphism (though in some cases it does). See [[Different Styles Of Delegation]]</i>",
      "id": "b735fe682b2a6c5b329880428a8546e8"
    },
    {
      "type": "html",
      "text": "\nThis is true, but delegation + indirection = [[Poly Morphism]]. See [[What Is Delegation]]. [[Mix In]] does not require indirection.",
      "id": "ce655e16e41fe5ad7a73a3107ef3f3a5"
    },
    {
      "type": "html",
      "text": "<i>I'm not sure I grok what you mean by \"indirection\" here -- polymorphism is usually defined in terms of type substitutability, however that is implemented. If you are referring to how vtables work (a virtual function call in [[Cee Plus Plus]] gets an extra level of indirection compared to a non-virtual call)...that's an implementation detail. An important one to be sure, but not fundamental to polymorphism.</i>",
      "id": "3394f1c419d7317725234b9e67f44efa"
    },
    {
      "type": "html",
      "text": "<i>Many other languages don't have vtables like C++, they perform name lookup at runtime.</i>",
      "id": "6f1b0887e23c4d68262a4513151c69cb"
    },
    {
      "type": "html",
      "text": "\nVtables or pick-your-preferred-implementation-details are not relevant, [[Poly Morphism]] is not fundamentally dependent on types, and focusing on substitutability has some subtle problems (see [[What Are Types]]).",
      "id": "2f7b7f492da8d13c72613d12394ef11f"
    },
    {
      "type": "html",
      "text": "\nPlease grok [[Non Polymorphic Inheritance]]. The point made there is that a [[Mix In]] can be implemented without any polymorphism whatsoever. This kind of [[Mix In]] is for implementation reuse, not type substitution, and does not have polymorphic behavior.",
      "id": "efa03d8fd26f1e25d297e86ebf9e239b"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nNobody pointed out [[Ruby Language]] in this page. Most of the Ruby world is based around [[Mix Ins]] via Modules. Worth noting that Observable is_a [[Mix In]] in ruby similar to the example class from [[Common Lisp Object System]]. Still, decorating methods is quite more ugly in Ruby. Ruby even allows you to add a [[Mix In]] to a single object like:",
      "id": "41a5b295e72b7e4411a78b9e656fcc58"
    },
    {
      "type": "code",
      "text": " class << my_object\n  include MixInModule\n end",
      "id": "d06c47a479d924916696364b307f38a8"
    },
    {
      "type": "html",
      "text": "Is this considered [[Allo Morphism]]?",
      "id": "17b89aeb0463f7dd0fb3d5c64562f357"
    },
    {
      "type": "html",
      "text": "-- I don't know what you mean by \"decorating methods\", so I'll have to re-read this page. -- <i>[[Gavin Sinclair]]</i>",
      "id": "f47fca213ffb7b4b206856ece9874351"
    },
    {
      "type": "html",
      "text": "\nI think it means method decorators, like \":before\", \":after\", \":around\", etc. -- <i>[[John Duncan]]</i>",
      "id": "939a7a04e43ff238f1a31da9a133485c"
    },
    {
      "type": "html",
      "text": "-- However, the Ruby concept/implementation of mixins is the complete opposite of ugly. For example, <i>Comparable</i> is a <i>module</i> (namespace for a collection of methods) that defines the methods <, <=, ==, !=, >=, and >, all based on the <i>comparison operator</i> \"<=>\". So I can define a class that can be compared - say <i>Name</i>, and then mix in the Comparable module to get all those methods for free:",
      "id": "b6284c799d772dcacb09d6f703ea7a3e"
    },
    {
      "type": "code",
      "text": "  class Name\n    attr_accessor :first, :middle, :last  # getter and setter methods\n    def initialize(f, m, l)\n      @first, @middle, @last = f, m, l\n    end",
      "id": "c6330a40c1401ad7a3f96dbce20f4b04"
    },
    {
      "type": "code",
      "text": "    # Here's the comparison operator.\n    def <=>(other)\n      [@first, @middle, @last] <=> [other.first, other.middle, other.last]\n    end",
      "id": "e04051e23507012f2a81a28933f0c5e1"
    },
    {
      "type": "code",
      "text": "    # Here's the good bit - I get <, <=, etc. for free.\n    include Comparable\n  end",
      "id": "64d1897906cafea70e85822db4ea613c"
    },
    {
      "type": "code",
      "text": "  n1 = Name.new('John', 'Q', 'Smith')\n  n2 = Name.new('John', 'M', 'Schmidt')",
      "id": "bce17dd921ce74c5087c114fec3c24d5"
    },
    {
      "type": "code",
      "text": "  n1 < n2    # false\n  n1 >= n2        # true\n  # etc.",
      "id": "a387f0b063b73c075ffbcfd745dd09fb"
    },
    {
      "type": "html",
      "text": "An even better example is the built-in <i>Enumerable</i> module, which provides methods like 'find', 'find_all', 'include?', 'map', 'sort', and several others, all based on the method 'each', which iterates over a collection. All of Ruby's collection-style classes therefore have all these methods. And if you write a collection-style class, you can 'include Enumerable' and get all these really powerful methods for free. Understanding Ruby's 'each' method is difficult for those not already familiar with Ruby, though. See [[Blocks In Ruby]] for that.",
      "id": "879bb65f756390ec91e959d16036dbee"
    },
    {
      "type": "html",
      "text": "-- [[Gavin Sinclair]]",
      "id": "bd7c116a5d28dd779a8f19fe771004ba"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nA little sample in [[Scala Language]]:",
      "id": "371661c6c83dbed4f1bb1a160dc7fa56"
    },
    {
      "type": "html",
      "text": "class Point2D(xc:<br>Int, yc: Int) {",
      "id": "595710dd165e3ad12b1d0d0e1cd8af19"
    },
    {
      "type": "code",
      "text": "    val x = xc;\n    val y = yc;\n    override def toString() =\n    \"x = \" + x + \", y = \" + y;\n  }\n  class ColoredPoint2D(u: Int, v: Int, c: String)\n      extends Point2D(u, v) {\n    var color = c;\n    def setColor(newCol: String): Unit = color = newCol;\n    override def toString() =\n    super.toString() + \", col = \" + color;\n  }\n  class Point3D(xc: Int, yc: Int, zc: Int)\n      extends Point2D(xc, yc) {\n    val z = zc;\n    override def toString() =\n    super.toString() + \", z = \" + z;\n  }\n  class ColoredPoint3D(xc: Int, yc: Int, zc: Int, col: String)\n    extends Point3D(xc, yc, zc)\n    with ColoredPoint2D(xc, yc, col);",
      "id": "b2c0bdee7d7a8bb47f31cca9a8a0c10e"
    },
    {
      "type": "html",
      "text": "And new ColoredPoint3D(1, 2, 3, \"blue\").toString() would return \"x = 1, y = 2, z = 3, col = blue\".",
      "id": "eb3e1e800027d8d6e00e7861cfb0dcc3"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "\nSee also: the [[Traits Paper]].",
      "id": "c754a4db7283be38f0b57d50cfe9671e"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "[[Category Language Feature]]",
      "id": "01832282db4d2416f13598dbb5c1daea"
    },
    {
      "type": "html",
      "text": "<hr>",
      "id": "9e3f3493709e224d2d39f1a1a8416c28"
    },
    {
      "type": "html",
      "text": "Having glanced briefly at much of this page and spent more time on a few parts, it seems that a lot of confusion and controversy could be prevented if we avoid using the language of inheritance to describe the Mixin. In particular, I find the first few lines talking about \"inheriting\" but saying the child is not the same kind of thing as the parent class contradictory. After all: long before anyone thought of applying the language of 'hierarchy' -- with all the implications from Aristotle's Categories -- to OOP, it has always been understood: the child is the same kind of thing as the parent, else the hierarchy is badly broken. Remember that this language was developed before anyone had to deal with the problems of hierarchies changing over time as evolution took place!",
      "id": "3641e45c93b47f2bd6d5fb5867d2730d"
    },
    {
      "type": "html",
      "text": "\nSo I propose that instead of calling the classes 'parent' and 'child', and instead of saying the child 'inherits' from the parent, we should call the Mixin phenomenon \"alien adoption\", since this makes quite clear that the child is NOT the same kind of thing the parent is, but has only what the adopting parent has granted to it.",
      "id": "d78af9747a5ff757e661d759f3d4e174"
    },
    {
      "type": "html",
      "text": "\nIs it not indeed the case that the use of Mixins really is different from OOP? If so, then this language makes that clearer, too.",
      "id": "200732e97f2040e7d5a00a1709be9cb2"
    },
    {
      "type": "html",
      "text": "See original on  [http://c2.com/cgi/wiki?MixIn c2.com]",
      "id": "272a818fe4911bb114dcfbb1a12e81d4"
    }
  ],
  "journal": [
    {
      "date": 1320135751000,
      "id": "41117a71a18bcfc921174126df005d2e",
      "type": "create",
      "item": {
        "title": "Mix In",
        "story": [
          {
            "type": "html",
            "text": "[[Mix In]] programming is a style of software development where units of functionality are created in a class and then mixed in with other classes.",
            "id": "8380fc8ef850bbf3a4076f2d1f684420"
          },
          {
            "type": "html",
            "text": "\nA mixin class is a parent class that is inherited from - but not as a means of specialization. Typically, the mixin will export services to a child class, but no semantics will be implied about the child \"being a kind of\" the parent.",
            "id": "542e86dad0540cf9c3276881774b9f3f"
          },
          {
            "type": "html",
            "text": "\nA [[Mix In]] is also called an [[Abstract Subclass]] since [[Mix In]] can provide other services based on the services the original class provides.",
            "id": "4a3bc2a600df7ba6a199f986ce545545"
          },
          {
            "type": "html",
            "text": "\nMixins are controversial because the prescribed way of providing such services is by association. However, they are useful because inheritance places the services within the child itself. For this reason they are commonly found in windows class libraries where there is a need for certain features to be generalized for \"mixing in\" later.",
            "id": "b44b9a8e880f72b97ff1a7a2e81dcffe"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nActually Mixins are only 'controversial' because people try to use them in languages\nwith no support for them. This makes all kinds of problems. See the Flavors mixins.",
            "id": "313d19903dfd7c867ecc62d3da0333ff"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nAlso see [[Mixins For Cee Plus Plus]]",
            "id": "ce73136b75e19f7395886b0641cbe28b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nMixins are coming from Flavors. Flavors is an early Object System for the [[Lisp Machine]].",
            "id": "4ca3e7b0d83eeeb0c9e4cbef3f4f2436"
          },
          {
            "type": "html",
            "text": "\nImagine you have vanilla ice where you can add in different stuff. So the base class in Flavors was called Vanilla. Parts of the Lisp Machine operating system were programmed using mixins. An example is the window system, where you can mixin borders-mixins into window classes. So it does not mixin the borders itself, but adds the feature that the window has borders. In Flavors the classes slots are extended AND (and that is the big AND) the methods get extended OR overwritten, too. In the case of the border-mixin the idea is that it also extends (!!) the window-draw method to draw the borders.",
            "id": "42cf9cd25eff05aa78504a449c0cfba3"
          },
          {
            "type": "html",
            "text": "\n[[Common Lisp]] also supports the mixin style of programming. Most other programming languages make it difficult, because they don't have [[Method Combination]]s.",
            "id": "cbd5cfe8d12aa685cb74bfeb404b0d06"
          },
          {
            "type": "html",
            "text": "\nSee: David A. Moon. Object-oriented programming with Flavors. In Proc. First Annual Conference on Object-Oriented Programming Systems, Languages, and Applications. ACM, 1986.",
            "id": "5a2eb3cada8664e084c31b8ddd10b532"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nAn example for the mechanism using the [[Common Lisp Object System]]:",
            "id": "4e591331133944e0e40d41dfbbfc66d0"
          },
          {
            "type": "code",
            "text": "  (defclass window ()\n    ((width\n    :accessor window-width\n    :initarg :width\n    :type integer\n    :initform 200)))",
            "id": "b585daf72d6be83416561a44248dc22e"
          },
          {
            "type": "code",
            "text": "  (defclass border-mixin ()\n    ((border-width\n    :type integer\n    :initarg :border-width\n    :initform 1)))",
            "id": "3a0be4938223ab98a72d38480ad008bb"
          },
          {
            "type": "html",
            "text": "\nThis next function is the key element, which is not really possible in most object oriented languages.\nMost don't have :around, :before or :after methods. This facility is known as [[Method Combination]].",
            "id": "80eaddf7dd91189f7b2ff89510138a27"
          },
          {
            "type": "code",
            "text": "  (defmethod window-width :around ((window border-mixin))\n    (+ (call-next-method)\n    (* 2 (slot-value window 'border-width))))",
            "id": "06c004e199a7584314e5a8c53e739727"
          },
          {
            "type": "html",
            "text": "Now we define our own window class, which also inherits from our mixin class:",
            "id": "012f558c4b61c963aa9b067cb37b3c60"
          },
          {
            "type": "code",
            "text": "  (defclass my-window-with-border (border-mixin window)\n    ())",
            "id": "6252790c0f7970df00ccccfe69beaf27"
          },
          {
            "type": "html",
            "text": "An instance:",
            "id": "1ca9d7d2abb0ca701b88786c4527c2e9"
          },
          {
            "type": "code",
            "text": "  (defvar *my-window* (make-instance 'my-window-with-border\n        :width 400\n        :border-width 10)",
            "id": "da5e8ebfa91dc3f6a7ad5807937a7b4f"
          },
          {
            "type": "html",
            "text": "We call the WINDOW-WIDTH method, which then runs the :AROUND method around the\nprimary WINDOW-WIDTH method. So it computes (+ width (* 2 border-width)) :",
            "id": "94bf412c242e5142b4bab55facad6101"
          },
          {
            "type": "code",
            "text": "  (window-width *my-window*)  ->  420",
            "id": "758944c3bddb97ab011e62f62b4b80df"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nDo you really need full-fledged [[Method Combination]], or is it enough to have a well-defined class-precedence list and the ability to call the next method in the list? I'm thinking of [[Dylan Language]], which doesn't have [[Method Combination]], but does copy [[Common Lisp]]'s [[Generic Function]] paradigm, along with how to compute the class precedence list. It seems like the above example could be done just by translating the classes into Dylan syntax and then writing window-width like this:",
            "id": "5025dcc037ff50db20617ac67ecce6f0"
          },
          {
            "type": "html",
            "text": "define method window-width (window ::<br><border-mixin>)",
            "id": "1ab0a3c04e275dc6cc1772c9c52e4a92"
          },
          {
            "type": "code",
            "text": "  next-method() + 2 * window.border-width;\n  end window-width;",
            "id": "98104e06b1b650f65ae61a4a629a17d9"
          },
          {
            "type": "html",
            "text": "\nYou do have to make sure that <border-mixin> precedes <window> in the class hierarchy for <my-window-with-border>, but it seems like you would run into that problem even with CLOS if you ever tried to combine 2 or more mixins (since the various :around methods get ordered by the class precedence list too).",
            "id": "3f7350630bacc0d56ca34630588cb03a"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nWell, in this case the ordering is not important for the CLOS example.\nAll :AROUND methods are used.",
            "id": "df45e4c4663bbfe4f5a86b62d2aad1cc"
          },
          {
            "type": "html",
            "text": "\nIn CLOS one could also use a + method combination, where the results of all methods get collected. So, you would define a bunch of WIDTH methods for the various elements that contribute to the window width and have them added by the method combination.",
            "id": "9c6ab2f769f60555b62e15f0a4d3a384"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nThe word \"mixin\" comes from Steve's Ice Cream, a favorite ice cream shop of MIT students located in Somerville, Mass., in the late '70s. Steve's made its own (very rich) ice cream in a motorized old-fashioned ice cream maker in the window of the shop. Sometimes the line for an ice cream cone was out the door and down the block!",
            "id": "b1a33b52fbe36e8ee01553ea03eee666"
          },
          {
            "type": "html",
            "text": "\nYou would order a cone or dish, and specify the base flavor and any mixins you wanted. The person behind the counter would plop your scoop of ice cream on a marble slab, dump a spoonful of mixins on top, and knead the two together, using two metal spatulas. My personal favorite was chocolate ice cream with crushed Oreo cookies mixed in. -- [[Stan Silver]]",
            "id": "a42cd894d55c7cfe0fcf2ac7e371d6da"
          },
          {
            "type": "html",
            "text": "\"The term mixin comes from an ice cream store in Somerville, Massachusetts, where candies and cakes were mixed into the basic ice cream flavors. This seemed like a good metaphor to some of the object-oriented programmers who used to take a summer break there, especially while working with the object-oriented programming language SCOOPS.\" (<i>SAMS Teach Yourself C++ in 21 Days,</i> 4th ed., p. 458.)",
            "id": "14868f69b3b16f663c99f49137c6383b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nThe grapevine informs me that Symbolics' object-oriented Flavors system is most likely the earliest appearance of bona fide mix-ins. The designers were inspired by Steve's Ice Cream Parlor in Cambridge, Massachusetts where customers started with a basic flavor of ice cream (vanilla, chocolate, etc.) and added any combination of mix-ins (nuts, fudge, chocolate chips, etc.). In the Symbolics system, large, standalone classes were known as flavors while smaller helper classes designed for enhancing other classes were known as mix-ins. ",
            "id": "d7b1b87f8f896eb252b38a258d06733f"
          },
          {
            "type": "html",
            "text": "[<i>From Chuck Esterbrook's article in Linux Journal #84 April, 2001</i> [http://noframes.linuxjournal.com/lj-issues/issue84/4540.html noframes.linuxjournal.com]]",
            "id": "d47e507c98d0a00e772d44bfcb3559ba"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nOne interesting way in which mixins are used in the [[Common Lisp Object System]] is by having them add to the list of applicable methods. E.g., you might have a class <i>base</i>, and a class <i>derived</i>, which want to specialize method <i>foo</i>. But you might also want to, say, add notification, as in an [[Observer Pattern]]. You create the <i>observed-mixin</i>, and do",
            "id": "21504edaf3198f3f433c0d0acf2417a7"
          },
          {
            "type": "code",
            "text": "  (defclass derived (base observed-mixin)\n  ())",
            "id": "2b22acac24375890958c984afb491e0b"
          },
          {
            "type": "code",
            "text": "  (defmethod foo ((self base))\n  ;; do foo type stuff\n  )",
            "id": "2475b3a632aade080229cd519f3456f3"
          },
          {
            "type": "html",
            "text": "And the author of the mixin can write",
            "id": "bebc2d6182b112ee0fdcaf2c61543981"
          },
          {
            "type": "code",
            "text": "  (defmethod foo :after ((self observed-mixin))\n  (notify-all-observers (format nil \"~A is being fooed!\" self)))",
            "id": "45f6b22af645bb334afa4f1d75bd3043"
          },
          {
            "type": "html",
            "text": "This doesn't change anything to how foo acts on a derived, but lets all derived\nthat want to be observed do so by simply inheriting the mixin.\nThe use of the :before after :after methods that are part of the standard [[Method Combination]] makes this a handy pattern in the [[Common Lisp Object System]].",
            "id": "bf94e99361e723c4907cfbf848bf8faf"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nIn addition to the [[Common Lisp Object System]], the [[Xo Tcl Extension]] (for the [[Tool Command Language]]) has good support for mixins.",
            "id": "11ae22f39d85c3e3c4d569d0a0312030"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nAlso see [[Mixins For Python]]",
            "id": "63530fc596e7943b31da1bdc69e73b47"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\n[[Category Polymorphism]]",
            "id": "84633e4b9ea9cd9d8e3cc891dde47966"
          },
          {
            "type": "html",
            "text": "\nIt has become doubtful as to whether [[Mix In]] techniques can be called polymorphism. According to [[Non Polymorphic Inheritance]], using a [[Mix In]] does not entail delegation (see [[What Is Delegation]]), and so lacking the requisite indirection, does not have polymorphic behavior.",
            "id": "133b923ee2fb112ae2143cc672e5f701"
          },
          {
            "type": "html",
            "text": "<i>Delegation does not imply polymorphism (though in some cases it does). See [[Different Styles Of Delegation]]</i>",
            "id": "b735fe682b2a6c5b329880428a8546e8"
          },
          {
            "type": "html",
            "text": "\nThis is true, but delegation + indirection = [[Poly Morphism]]. See [[What Is Delegation]]. [[Mix In]] does not require indirection.",
            "id": "ce655e16e41fe5ad7a73a3107ef3f3a5"
          },
          {
            "type": "html",
            "text": "<i>I'm not sure I grok what you mean by \"indirection\" here -- polymorphism is usually defined in terms of type substitutability, however that is implemented. If you are referring to how vtables work (a virtual function call in [[Cee Plus Plus]] gets an extra level of indirection compared to a non-virtual call)...that's an implementation detail. An important one to be sure, but not fundamental to polymorphism.</i>",
            "id": "3394f1c419d7317725234b9e67f44efa"
          },
          {
            "type": "html",
            "text": "<i>Many other languages don't have vtables like C++, they perform name lookup at runtime.</i>",
            "id": "6f1b0887e23c4d68262a4513151c69cb"
          },
          {
            "type": "html",
            "text": "\nVtables or pick-your-preferred-implementation-details are not relevant, [[Poly Morphism]] is not fundamentally dependent on types, and focusing on substitutability has some subtle problems (see [[What Are Types]]).",
            "id": "2f7b7f492da8d13c72613d12394ef11f"
          },
          {
            "type": "html",
            "text": "\nPlease grok [[Non Polymorphic Inheritance]]. The point made there is that a [[Mix In]] can be implemented without any polymorphism whatsoever. This kind of [[Mix In]] is for implementation reuse, not type substitution, and does not have polymorphic behavior.",
            "id": "efa03d8fd26f1e25d297e86ebf9e239b"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nNobody pointed out [[Ruby Language]] in this page. Most of the Ruby world is based around [[Mix Ins]] via Modules. Worth noting that Observable is_a [[Mix In]] in ruby similar to the example class from [[Common Lisp Object System]]. Still, decorating methods is quite more ugly in Ruby. Ruby even allows you to add a [[Mix In]] to a single object like:",
            "id": "41a5b295e72b7e4411a78b9e656fcc58"
          },
          {
            "type": "code",
            "text": " class << my_object\n  include MixInModule\n end",
            "id": "d06c47a479d924916696364b307f38a8"
          },
          {
            "type": "html",
            "text": "Is this considered [[Allo Morphism]]?",
            "id": "17b89aeb0463f7dd0fb3d5c64562f357"
          },
          {
            "type": "html",
            "text": "-- I don't know what you mean by \"decorating methods\", so I'll have to re-read this page. -- <i>[[Gavin Sinclair]]</i>",
            "id": "f47fca213ffb7b4b206856ece9874351"
          },
          {
            "type": "html",
            "text": "\nI think it means method decorators, like \":before\", \":after\", \":around\", etc. -- <i>[[John Duncan]]</i>",
            "id": "939a7a04e43ff238f1a31da9a133485c"
          },
          {
            "type": "html",
            "text": "-- However, the Ruby concept/implementation of mixins is the complete opposite of ugly. For example, <i>Comparable</i> is a <i>module</i> (namespace for a collection of methods) that defines the methods <, <=, ==, !=, >=, and >, all based on the <i>comparison operator</i> \"<=>\". So I can define a class that can be compared - say <i>Name</i>, and then mix in the Comparable module to get all those methods for free:",
            "id": "b6284c799d772dcacb09d6f703ea7a3e"
          },
          {
            "type": "code",
            "text": "  class Name\n    attr_accessor :first, :middle, :last  # getter and setter methods\n    def initialize(f, m, l)\n      @first, @middle, @last = f, m, l\n    end",
            "id": "c6330a40c1401ad7a3f96dbce20f4b04"
          },
          {
            "type": "code",
            "text": "    # Here's the comparison operator.\n    def <=>(other)\n      [@first, @middle, @last] <=> [other.first, other.middle, other.last]\n    end",
            "id": "e04051e23507012f2a81a28933f0c5e1"
          },
          {
            "type": "code",
            "text": "    # Here's the good bit - I get <, <=, etc. for free.\n    include Comparable\n  end",
            "id": "64d1897906cafea70e85822db4ea613c"
          },
          {
            "type": "code",
            "text": "  n1 = Name.new('John', 'Q', 'Smith')\n  n2 = Name.new('John', 'M', 'Schmidt')",
            "id": "bce17dd921ce74c5087c114fec3c24d5"
          },
          {
            "type": "code",
            "text": "  n1 < n2    # false\n  n1 >= n2        # true\n  # etc.",
            "id": "a387f0b063b73c075ffbcfd745dd09fb"
          },
          {
            "type": "html",
            "text": "An even better example is the built-in <i>Enumerable</i> module, which provides methods like 'find', 'find_all', 'include?', 'map', 'sort', and several others, all based on the method 'each', which iterates over a collection. All of Ruby's collection-style classes therefore have all these methods. And if you write a collection-style class, you can 'include Enumerable' and get all these really powerful methods for free. Understanding Ruby's 'each' method is difficult for those not already familiar with Ruby, though. See [[Blocks In Ruby]] for that.",
            "id": "879bb65f756390ec91e959d16036dbee"
          },
          {
            "type": "html",
            "text": "-- [[Gavin Sinclair]]",
            "id": "bd7c116a5d28dd779a8f19fe771004ba"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nA little sample in [[Scala Language]]:",
            "id": "371661c6c83dbed4f1bb1a160dc7fa56"
          },
          {
            "type": "html",
            "text": "class Point2D(xc:<br>Int, yc: Int) {",
            "id": "595710dd165e3ad12b1d0d0e1cd8af19"
          },
          {
            "type": "code",
            "text": "    val x = xc;\n    val y = yc;\n    override def toString() =\n    \"x = \" + x + \", y = \" + y;\n  }\n  class ColoredPoint2D(u: Int, v: Int, c: String)\n      extends Point2D(u, v) {\n    var color = c;\n    def setColor(newCol: String): Unit = color = newCol;\n    override def toString() =\n    super.toString() + \", col = \" + color;\n  }\n  class Point3D(xc: Int, yc: Int, zc: Int)\n      extends Point2D(xc, yc) {\n    val z = zc;\n    override def toString() =\n    super.toString() + \", z = \" + z;\n  }\n  class ColoredPoint3D(xc: Int, yc: Int, zc: Int, col: String)\n    extends Point3D(xc, yc, zc)\n    with ColoredPoint2D(xc, yc, col);",
            "id": "b2c0bdee7d7a8bb47f31cca9a8a0c10e"
          },
          {
            "type": "html",
            "text": "And new ColoredPoint3D(1, 2, 3, \"blue\").toString() would return \"x = 1, y = 2, z = 3, col = blue\".",
            "id": "eb3e1e800027d8d6e00e7861cfb0dcc3"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "\nSee also: the [[Traits Paper]].",
            "id": "c754a4db7283be38f0b57d50cfe9671e"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "[[Category Language Feature]]",
            "id": "01832282db4d2416f13598dbb5c1daea"
          },
          {
            "type": "html",
            "text": "<hr>",
            "id": "9e3f3493709e224d2d39f1a1a8416c28"
          },
          {
            "type": "html",
            "text": "Having glanced briefly at much of this page and spent more time on a few parts, it seems that a lot of confusion and controversy could be prevented if we avoid using the language of inheritance to describe the Mixin. In particular, I find the first few lines talking about \"inheriting\" but saying the child is not the same kind of thing as the parent class contradictory. After all: long before anyone thought of applying the language of 'hierarchy' -- with all the implications from Aristotle's Categories -- to OOP, it has always been understood: the child is the same kind of thing as the parent, else the hierarchy is badly broken. Remember that this language was developed before anyone had to deal with the problems of hierarchies changing over time as evolution took place!",
            "id": "3641e45c93b47f2bd6d5fb5867d2730d"
          },
          {
            "type": "html",
            "text": "\nSo I propose that instead of calling the classes 'parent' and 'child', and instead of saying the child 'inherits' from the parent, we should call the Mixin phenomenon \"alien adoption\", since this makes quite clear that the child is NOT the same kind of thing the parent is, but has only what the adopting parent has granted to it.",
            "id": "d78af9747a5ff757e661d759f3d4e174"
          },
          {
            "type": "html",
            "text": "\nIs it not indeed the case that the use of Mixins really is different from OOP? If so, then this language makes that clearer, too.",
            "id": "200732e97f2040e7d5a00a1709be9cb2"
          },
          {
            "type": "html",
            "text": "See original on  [http://c2.com/cgi/wiki?MixIn c2.com]",
            "id": "272a818fe4911bb114dcfbb1a12e81d4"
          }
        ]
      }
    },
    {
      "type": "fork",
      "site": "sfw.c2.com",
      "date": 1631860093860
    },
    {
      "type": "edit",
      "id": "313d19903dfd7c867ecc62d3da0333ff",
      "item": {
        "type": "html",
        "text": "Actually Mixins are only 'controversial' because people try to use them in languages\nwith no support for them. This makes all kinds of problems. See the [[Flavors]] mixins.",
        "id": "313d19903dfd7c867ecc62d3da0333ff"
      },
      "date": 1631865016130
    }
  ]
}