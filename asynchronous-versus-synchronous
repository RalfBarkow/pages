{
  "title": "Asynchronous Versus Synchronous",
  "story": [
    {
      "type": "paragraph",
      "id": "d1dd1c4b5ede7317",
      "text": "But there is an interesting point about asynchronous versus synchronous, isn’t synchronous a more natural way of implementing a sequential algorithm versus implementing lots of callbacks, what do you think about that?"
    },
    {
      "type": "paragraph",
      "id": "a6d74105dba4c099",
      "text": "I (Ward) think, well I like to say the most important words or verbs or operators are the shortest ones, like + is pretty important so it doesn’t take a lot of space, but if you think about a sequencing, putting one thing after another, that sequential nature is that one operation that is just implicit in just about every language. So, yes we think of things sequentially and that was a real advance when Unix came along and said “let’s make simple little things that read from input and write to output and then you can put something at the other end and catch that and read it and write it and that [[Pipeline Is an Architectural Form]]”, very successful, I consider it [[The Latin of Our Discipline]], to go back and think in those terms. But, as we build the really high performance data driven multi computer things just the response times that people expect it gets in the way, [[Process]] is too heavy, so it’s a pendulum that is swinging back and forth, before Unix, people they were doing some synchronous, some asynchronous, you never knew what you were doing, so I think all synchronous, all asynchronous, keep it straight, what idiom you are using. That’s why I say JavaScript is yet to really fully settle down on how it’s properly written. I think Java is way ahead on that regard. But then you’ve got the mavericks there, the Scalas and so forth that say “well, yes, but we can do better too’, and that’s pretty impressive stuff."
    },
    {
      "type": "pagefold",
      "id": "b4e07c29b8939c56",
      "text": "~"
    },
    {
      "type": "reference",
      "id": "967d6da559c5dd6a",
      "site": "wiki.ralfbarkow.ch",
      "slug": "2024-04-09",
      "title": "2024-04-09",
      "text": "Ward Cunningham on the Appeal of OOP and Dynamic Languages, Federated Wiki. [https://www.infoq.com/interviews/cunningham-federated-wiki/ page]"
    },
    {
      "type": "paragraph",
      "id": "6f56ddc286dc44d4",
      "text": "See also \"Next Generation Visual Programming System\" [https://github.com/samuelmtimbo/unit github] ⇒ [[Unit Programming Language]] ⇒ [[~/unit/0]]"
    },
    {
      "type": "paragraph",
      "id": "aeeec6a79da60717",
      "text": "[[J Programming Language]]"
    },
    {
      "type": "pagefold",
      "id": "0d3d2ab09f08cd27",
      "text": "~"
    },
    {
      "type": "paragraph",
      "id": "c1445365eee5a915",
      "text": "Werner: [[Smalltalk]], I think, had this notion of lightweight threads for instance, which I guess is one idea of implementing sequential programming in a lightweight way.\n\nI forgot exactly what it was called but basically there was some way you could reach up and grab your own stack and store it in an object and then you could have another stack do something. One of the coolest things was you could work on an application in Smalltalk and it could throw an exception and you could just look at it in the debugger and just “ah, I don’t care about that”, and throw it away, throw the runtime stack away and your application kept running because there was nothing in the stack that was particularly important, because it was all in the objects and that made it easy to layer on top of Smalltalk, a process model because inconsequential, “oh, yes, we have a process but if you want to throw it away, throw it away, nothing much, it will start back at the window”, windows were more important as a thing that did something than processes and that was educational, part of that was because Smalltalk existed before it had processes, but then when they added processes they said “well, let’s use processes to model [[Simulation]]” and they said “here’s how to reach up and grab onto your own processes and manage them for the purpose of building a simulator” and so this is going full circle. Remember, I said to understand that computing can be thought of as a simulation and now here we are thinking of computing as simulation again, so the fact that it did that well said something about the clarity of abstraction in Smalltalk. Smalltalk I think has still the best abstractions for a single environment.\n\nSmalltalk wanted to talk to itself, when I left Smalltalk I fell in love with [[Perl]] for a while because it wanted to talk to everybody “oh, the internet is here, everything, just rummage through this file hierarchy and send it over there where it will sort into some other file hierarchy and things go back and forth”, and Perl was good for that, you never knew what you got so you [[Regex It for a While Until You Found Something Interesting]]. In fact that was a style that I adopted for Wiki, I said “well, let’s just read this text that the user types in, see if we can find something that looks like a heading or some italics, if you see a bunch of quotes or some italics in there somewhere” and it was pretty casual. Wikipedia suffers with that now because I followed that lead and discovered that “we can write one program that interprets this text, but we can’t write two, because it’s not all that clear, it’s defined by the program that interprets it”.\n\nOf course, nature does that too, our genes are defined by the enzymes and proteins that interpret it, so if it’s good enough for life. And in fact, thinking about Barbara, we were talking about [[Barbara Liskov]], gave an excellent keynote here at QCon, and of course I think of her as the objects that are specified and I thing of Smalltalk as the objects that work. [[Dan Ingalls]] described it as training animals, it felt like training dogs, you just keep asking them to do something and tweaking them until they kind of worked right, that’s not a specification, but you can train dogs, maybe we can train computers, maybe we can breed computers to do our bidding in the future, what will that mean?\n\nWerner: Well, lots of cleaning up behind them.\n\nThat’s true."
    },
    {
      "type": "paragraph",
      "id": "d4faec7159d086b7",
      "text": "Werner: So, in a way I think what Barbara Liskov did in the 70’s with her style of object orientation having data types...\n\nData types and you took a body of code and you put an interface on it and that interface had a specification. And then she reminds people that you know that in Java, of course, and she got the Turing award for recognizing that and naming that and describing how to think about that and push things forward. She also described that kind of community that worked in that and the Smalltalk community kind of came and met and I think that they get along, I describe it as more of a peace treaty than a unification, but again now we have ten other things that are demanding our attention so a peace treaty is good enough and then we pick and choose from all of that to build real systems."
    }
  ],
  "journal": [
    {
      "type": "create",
      "item": {
        "title": "Asynchronous Versus Synchronous",
        "story": []
      },
      "date": 1712783515121
    },
    {
      "item": {
        "type": "factory",
        "id": "d1dd1c4b5ede7317"
      },
      "id": "d1dd1c4b5ede7317",
      "type": "add",
      "date": 1712783516597
    },
    {
      "type": "edit",
      "id": "d1dd1c4b5ede7317",
      "item": {
        "type": "paragraph",
        "id": "d1dd1c4b5ede7317",
        "text": "But there is an interesting point about asynchronous versus synchronous, isn’t synchronous a more natural way of implementing a sequential algorithm versus implementing lots of callbacks, what do you think about that?\n\nI think, well I like to say the most important words or verbs or operators are the shortest ones, like + is pretty important so it doesn’t take a lot of space, but if you think about a sequencing, putting one thing after another, that sequential nature is that one operation that is just implicit in just about every language. So, yes we think of things sequentially and that was a real advance when Unix came along and said “let’s make simple little things that read from input and write to output and then you can put something at the other end and catch that and read it and write it and that pipeline is an architectural form”, very successful, I consider it the Latin of our discipline, to go back and think in those terms. But, as we build the really high performance data driven multi computer things just the response times that people expect it gets in the way, process is too heavy, so it’s a pendulum that is swinging back and forth, before Unix, people they were doing some synchronous, some asynchronous, you never knew what you were doing, so I think all synchronous, all asynchronous, keep it straight, what idiom you are using. That’s why I say JavaScript is yet to really fully settle down on how it’s properly written. I think Java is way ahead on that regard. But then you’ve got the mavericks there, the Scalas and so forth that say “well, yes, but we can do better too’, and that’s pretty impressive stuff."
      },
      "date": 1712783518518
    },
    {
      "item": {
        "type": "factory",
        "id": "b4e07c29b8939c56"
      },
      "id": "b4e07c29b8939c56",
      "type": "add",
      "after": "d1dd1c4b5ede7317",
      "date": 1712783522694
    },
    {
      "type": "edit",
      "id": "b4e07c29b8939c56",
      "item": {
        "type": "pagefold",
        "id": "b4e07c29b8939c56",
        "text": "~"
      },
      "date": 1712783526501
    },
    {
      "id": "967d6da559c5dd6a",
      "type": "add",
      "item": {
        "type": "reference",
        "id": "967d6da559c5dd6a",
        "site": "wiki.ralfbarkow.ch",
        "slug": "2024-04-09",
        "title": "2024-04-09",
        "text": "Ward Cunningham on the Appeal of OOP and Dynamic Languages, Federated Wiki. [https://www.infoq.com/interviews/cunningham-federated-wiki/ page]"
      },
      "after": "b4e07c29b8939c56",
      "attribution": {
        "page": "2024-04-10"
      },
      "date": 1712783529657
    },
    {
      "type": "edit",
      "id": "d1dd1c4b5ede7317",
      "item": {
        "type": "paragraph",
        "id": "d1dd1c4b5ede7317",
        "text": "But there is an interesting point about asynchronous versus synchronous, isn’t synchronous a more natural way of implementing a sequential algorithm versus implementing lots of callbacks, what do you think about that?\n\nI (Ward) think, well I like to say the most important words or verbs or operators are the shortest ones, like + is pretty important so it doesn’t take a lot of space, but if you think about a sequencing, putting one thing after another, that sequential nature is that one operation that is just implicit in just about every language. So, yes we think of things sequentially and that was a real advance when Unix came along and said “let’s make simple little things that read from input and write to output and then you can put something at the other end and catch that and read it and write it and that pipeline is an architectural form”, very successful, I consider it the Latin of our discipline, to go back and think in those terms. But, as we build the really high performance data driven multi computer things just the response times that people expect it gets in the way, process is too heavy, so it’s a pendulum that is swinging back and forth, before Unix, people they were doing some synchronous, some asynchronous, you never knew what you were doing, so I think all synchronous, all asynchronous, keep it straight, what idiom you are using. That’s why I say JavaScript is yet to really fully settle down on how it’s properly written. I think Java is way ahead on that regard. But then you’ve got the mavericks there, the Scalas and so forth that say “well, yes, but we can do better too’, and that’s pretty impressive stuff."
      },
      "date": 1712783552385
    },
    {
      "id": "aeeec6a79da60717",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "aeeec6a79da60717",
        "text": "[[J Programming Language]]"
      },
      "after": "967d6da559c5dd6a",
      "attribution": {
        "page": "J"
      },
      "date": 1712783599520
    },
    {
      "id": "6f56ddc286dc44d4",
      "type": "add",
      "item": {
        "type": "paragraph",
        "id": "6f56ddc286dc44d4",
        "text": "See also \"Next Generation Visual Programming System\" [https://github.com/samuelmtimbo/unit github] ⇒ [[Unit Programming Language]] ⇒ [[~/unit/0]]"
      },
      "after": "967d6da559c5dd6a",
      "attribution": {
        "page": "Unit",
        "site": "wiki.ralfbarkow.ch"
      },
      "date": 1712783705420
    },
    {
      "type": "edit",
      "id": "d1dd1c4b5ede7317",
      "item": {
        "type": "paragraph",
        "id": "d1dd1c4b5ede7317",
        "text": "But there is an interesting point about asynchronous versus synchronous, isn’t synchronous a more natural way of implementing a sequential algorithm versus implementing lots of callbacks, what do you think about that?\n\nI (Ward) think, well I like to say the most important words or verbs or operators are the shortest ones, like + is pretty important so it doesn’t take a lot of space, but if you think about a sequencing, putting one thing after another, that sequential nature is that one operation that is just implicit in just about every language. So, yes we think of things sequentially and that was a real advance when Unix came along and said “let’s make simple little things that read from input and write to output and then you can put something at the other end and catch that and read it and write it and that pipeline is an architectural form”, very successful, I consider it the Latin of our discipline, to go back and think in those terms. But, as we build the really high performance data driven multi computer things just the response times that people expect it gets in the way, [[process]] is too heavy, so it’s a pendulum that is swinging back and forth, before Unix, people they were doing some synchronous, some asynchronous, you never knew what you were doing, so I think all synchronous, all asynchronous, keep it straight, what idiom you are using. That’s why I say JavaScript is yet to really fully settle down on how it’s properly written. I think Java is way ahead on that regard. But then you’ve got the mavericks there, the Scalas and so forth that say “well, yes, but we can do better too’, and that’s pretty impressive stuff."
      },
      "date": 1712783778418
    },
    {
      "type": "edit",
      "id": "d1dd1c4b5ede7317",
      "item": {
        "type": "paragraph",
        "id": "d1dd1c4b5ede7317",
        "text": "But there is an interesting point about asynchronous versus synchronous, isn’t synchronous a more natural way of implementing a sequential algorithm versus implementing lots of callbacks, what do you think about that?\n\nI (Ward) think, well I like to say the most important words or verbs or operators are the shortest ones, like + is pretty important so it doesn’t take a lot of space, but if you think about a sequencing, putting one thing after another, that sequential nature is that one operation that is just implicit in just about every language. So, yes we think of things sequentially and that was a real advance when Unix came along and said “let’s make simple little things that read from input and write to output and then you can put something at the other end and catch that and read it and write it and that pipeline is an architectural form”, very successful, I consider it the Latin of our discipline, to go back and think in those terms. But, as we build the really high performance data driven multi computer things just the response times that people expect it gets in the way, [[Process]] is too heavy, so it’s a pendulum that is swinging back and forth, before Unix, people they were doing some synchronous, some asynchronous, you never knew what you were doing, so I think all synchronous, all asynchronous, keep it straight, what idiom you are using. That’s why I say JavaScript is yet to really fully settle down on how it’s properly written. I think Java is way ahead on that regard. But then you’ve got the mavericks there, the Scalas and so forth that say “well, yes, but we can do better too’, and that’s pretty impressive stuff."
      },
      "date": 1712783798420
    },
    {
      "item": {
        "type": "factory",
        "id": "0d3d2ab09f08cd27"
      },
      "id": "0d3d2ab09f08cd27",
      "type": "add",
      "after": "aeeec6a79da60717",
      "date": 1712784623350
    },
    {
      "type": "edit",
      "id": "0d3d2ab09f08cd27",
      "item": {
        "type": "pagefold",
        "id": "0d3d2ab09f08cd27",
        "text": "~"
      },
      "date": 1712784626465
    },
    {
      "item": {
        "type": "factory",
        "id": "c1445365eee5a915"
      },
      "id": "c1445365eee5a915",
      "type": "add",
      "after": "0d3d2ab09f08cd27",
      "date": 1712784658061
    },
    {
      "type": "edit",
      "id": "c1445365eee5a915",
      "item": {
        "type": "paragraph",
        "id": "c1445365eee5a915",
        "text": "Werner: Smalltalk, I think, had this notion of lightweight threads for instance, which I guess is one idea of implementing sequential programming in a lightweight way.\n\nI forgot exactly what it was called but basically there was some way you could reach up and grab your own stack and store it in an object and then you could have another stack do something. One of the coolest things was you could work on an application in Smalltalk and it could throw an exception and you could just look at it in the debugger and just “ah, I don’t care about that”, and throw it away, throw the runtime stack away and your application kept running because there was nothing in the stack that was particularly important, because it was all in the objects and that made it easy to layer on top of Smalltalk, a process model because inconsequential, “oh, yes, we have a process but if you want to throw it away, throw it away, nothing much, it will start back at the window”, windows were more important as a thing that did something than processes and that was educational, part of that was because Smalltalk existed before it had processes, but then when they added processes they said “well, let’s use processes to model simulation” and they said “here’s how to reach up and grab onto your own processes and manage them for the purpose of building a simulator” and so this is going full circle. Remember, I said to understand that computing can be thought of as a simulation and now here we are thinking of computing as simulation again, so the fact that it did that well said something about the clarity of abstraction in Smalltalk. Smalltalk I think has still the best abstractions for a single environment.\n\nSmalltalk wanted to talk to itself, when I left Smalltalk I fell in love with Perl for a while because it wanted to talk to everybody “oh, the internet is here, everything, just rummage through this file hierarchy and send it over there where it will sort into some other file hierarchy and things go back and forth”, and Perl was good for that, you never knew what you got so you regex it for a while until you found something interesting. In fact that was a style that I adopted for Wiki, I said “well, let’s just read this text that the user types in, see if we can find something that looks like a heading or some italics, if you see a bunch of quotes or some italics in there somewhere” and it was pretty casual. Wikipedia suffers with that now because I followed that lead and discovered that “we can write one program that interprets this text, but we can’t write two, because it’s not all that clear, it’s defined by the program that interprets it”.\n\nOf course, nature does that too, our genes are defined by the enzymes and proteins that interpret it, so if it’s good enough for life. And in fact, thinking about Barbara, we were talking about Barbara Liskov, gave an excellent keynote here at QCon, and of course I think of her as the objects that are specified and I thing of Smalltalk as the objects that work. Dan Ingalls described it as training animals, it felt like training dogs, you just keep asking them to do something and tweaking them until they kind of worked right, that’s not a specification, but you can train dogs, maybe we can train computers, maybe we can breed computers to do our bidding in the future, what will that mean?\n\nWerner: Well, lots of cleaning up behind them.\n\nThat’s true.\n\nWerner: So, in a way I think what Barbara Liskov did in the 70’s with her style of object orientation having data types...\n\nData types and you took a body of code and you put an interface on it and that interface had a specification. And then she reminds people that you know that in Java, of course, and she got the Turing award for recognizing that and naming that and describing how to think about that and push things forward. She also described that kind of community that worked in that and the Smalltalk community kind of came and met and I think that they get along, I describe it as more of a peace treaty than a unification, but again now we have ten other things that are demanding our attention so a peace treaty is good enough and then we pick and choose from all of that to build real systems."
      },
      "date": 1712784659887
    },
    {
      "type": "edit",
      "id": "c1445365eee5a915",
      "item": {
        "type": "paragraph",
        "id": "c1445365eee5a915",
        "text": "Werner: Smalltalk, I think, had this notion of lightweight threads for instance, which I guess is one idea of implementing sequential programming in a lightweight way.\n\nI forgot exactly what it was called but basically there was some way you could reach up and grab your own stack and store it in an object and then you could have another stack do something. One of the coolest things was you could work on an application in Smalltalk and it could throw an exception and you could just look at it in the debugger and just “ah, I don’t care about that”, and throw it away, throw the runtime stack away and your application kept running because there was nothing in the stack that was particularly important, because it was all in the objects and that made it easy to layer on top of Smalltalk, a process model because inconsequential, “oh, yes, we have a process but if you want to throw it away, throw it away, nothing much, it will start back at the window”, windows were more important as a thing that did something than processes and that was educational, part of that was because Smalltalk existed before it had processes, but then when they added processes they said “well, let’s use processes to model [[Simulation]]” and they said “here’s how to reach up and grab onto your own processes and manage them for the purpose of building a simulator” and so this is going full circle. Remember, I said to understand that computing can be thought of as a simulation and now here we are thinking of computing as simulation again, so the fact that it did that well said something about the clarity of abstraction in Smalltalk. Smalltalk I think has still the best abstractions for a single environment.\n\nSmalltalk wanted to talk to itself, when I left Smalltalk I fell in love with Perl for a while because it wanted to talk to everybody “oh, the internet is here, everything, just rummage through this file hierarchy and send it over there where it will sort into some other file hierarchy and things go back and forth”, and Perl was good for that, you never knew what you got so you regex it for a while until you found something interesting. In fact that was a style that I adopted for Wiki, I said “well, let’s just read this text that the user types in, see if we can find something that looks like a heading or some italics, if you see a bunch of quotes or some italics in there somewhere” and it was pretty casual. Wikipedia suffers with that now because I followed that lead and discovered that “we can write one program that interprets this text, but we can’t write two, because it’s not all that clear, it’s defined by the program that interprets it”.\n\nOf course, nature does that too, our genes are defined by the enzymes and proteins that interpret it, so if it’s good enough for life. And in fact, thinking about Barbara, we were talking about Barbara Liskov, gave an excellent keynote here at QCon, and of course I think of her as the objects that are specified and I thing of Smalltalk as the objects that work. Dan Ingalls described it as training animals, it felt like training dogs, you just keep asking them to do something and tweaking them until they kind of worked right, that’s not a specification, but you can train dogs, maybe we can train computers, maybe we can breed computers to do our bidding in the future, what will that mean?\n\nWerner: Well, lots of cleaning up behind them.\n\nThat’s true.\n\nWerner: So, in a way I think what Barbara Liskov did in the 70’s with her style of object orientation having data types...\n\nData types and you took a body of code and you put an interface on it and that interface had a specification. And then she reminds people that you know that in Java, of course, and she got the Turing award for recognizing that and naming that and describing how to think about that and push things forward. She also described that kind of community that worked in that and the Smalltalk community kind of came and met and I think that they get along, I describe it as more of a peace treaty than a unification, but again now we have ten other things that are demanding our attention so a peace treaty is good enough and then we pick and choose from all of that to build real systems."
      },
      "date": 1712784747771
    },
    {
      "type": "edit",
      "id": "c1445365eee5a915",
      "item": {
        "type": "paragraph",
        "id": "c1445365eee5a915",
        "text": "Werner: Smalltalk, I think, had this notion of lightweight threads for instance, which I guess is one idea of implementing sequential programming in a lightweight way.\n\nI forgot exactly what it was called but basically there was some way you could reach up and grab your own stack and store it in an object and then you could have another stack do something. One of the coolest things was you could work on an application in Smalltalk and it could throw an exception and you could just look at it in the debugger and just “ah, I don’t care about that”, and throw it away, throw the runtime stack away and your application kept running because there was nothing in the stack that was particularly important, because it was all in the objects and that made it easy to layer on top of Smalltalk, a process model because inconsequential, “oh, yes, we have a process but if you want to throw it away, throw it away, nothing much, it will start back at the window”, windows were more important as a thing that did something than processes and that was educational, part of that was because Smalltalk existed before it had processes, but then when they added processes they said “well, let’s use processes to model [[Simulation]]” and they said “here’s how to reach up and grab onto your own processes and manage them for the purpose of building a simulator” and so this is going full circle. Remember, I said to understand that computing can be thought of as a simulation and now here we are thinking of computing as simulation again, so the fact that it did that well said something about the clarity of abstraction in Smalltalk. Smalltalk I think has still the best abstractions for a single environment.\n\nSmalltalk wanted to talk to itself, when I left Smalltalk I fell in love with [[Perl]] for a while because it wanted to talk to everybody “oh, the internet is here, everything, just rummage through this file hierarchy and send it over there where it will sort into some other file hierarchy and things go back and forth”, and Perl was good for that, you never knew what you got so you regex it for a while until you found something interesting. In fact that was a style that I adopted for Wiki, I said “well, let’s just read this text that the user types in, see if we can find something that looks like a heading or some italics, if you see a bunch of quotes or some italics in there somewhere” and it was pretty casual. Wikipedia suffers with that now because I followed that lead and discovered that “we can write one program that interprets this text, but we can’t write two, because it’s not all that clear, it’s defined by the program that interprets it”.\n\nOf course, nature does that too, our genes are defined by the enzymes and proteins that interpret it, so if it’s good enough for life. And in fact, thinking about Barbara, we were talking about Barbara Liskov, gave an excellent keynote here at QCon, and of course I think of her as the objects that are specified and I thing of Smalltalk as the objects that work. Dan Ingalls described it as training animals, it felt like training dogs, you just keep asking them to do something and tweaking them until they kind of worked right, that’s not a specification, but you can train dogs, maybe we can train computers, maybe we can breed computers to do our bidding in the future, what will that mean?\n\nWerner: Well, lots of cleaning up behind them.\n\nThat’s true.\n\nWerner: So, in a way I think what Barbara Liskov did in the 70’s with her style of object orientation having data types...\n\nData types and you took a body of code and you put an interface on it and that interface had a specification. And then she reminds people that you know that in Java, of course, and she got the Turing award for recognizing that and naming that and describing how to think about that and push things forward. She also described that kind of community that worked in that and the Smalltalk community kind of came and met and I think that they get along, I describe it as more of a peace treaty than a unification, but again now we have ten other things that are demanding our attention so a peace treaty is good enough and then we pick and choose from all of that to build real systems."
      },
      "date": 1712784827585
    },
    {
      "type": "edit",
      "id": "c1445365eee5a915",
      "item": {
        "type": "paragraph",
        "id": "c1445365eee5a915",
        "text": "Werner: Smalltalk, I think, had this notion of lightweight threads for instance, which I guess is one idea of implementing sequential programming in a lightweight way.\n\nI forgot exactly what it was called but basically there was some way you could reach up and grab your own stack and store it in an object and then you could have another stack do something. One of the coolest things was you could work on an application in Smalltalk and it could throw an exception and you could just look at it in the debugger and just “ah, I don’t care about that”, and throw it away, throw the runtime stack away and your application kept running because there was nothing in the stack that was particularly important, because it was all in the objects and that made it easy to layer on top of Smalltalk, a process model because inconsequential, “oh, yes, we have a process but if you want to throw it away, throw it away, nothing much, it will start back at the window”, windows were more important as a thing that did something than processes and that was educational, part of that was because Smalltalk existed before it had processes, but then when they added processes they said “well, let’s use processes to model [[Simulation]]” and they said “here’s how to reach up and grab onto your own processes and manage them for the purpose of building a simulator” and so this is going full circle. Remember, I said to understand that computing can be thought of as a simulation and now here we are thinking of computing as simulation again, so the fact that it did that well said something about the clarity of abstraction in Smalltalk. Smalltalk I think has still the best abstractions for a single environment.\n\nSmalltalk wanted to talk to itself, when I left Smalltalk I fell in love with [[Perl]] for a while because it wanted to talk to everybody “oh, the internet is here, everything, just rummage through this file hierarchy and send it over there where it will sort into some other file hierarchy and things go back and forth”, and Perl was good for that, you never knew what you got so you [[regex it for a while until you found something interesting]]. In fact that was a style that I adopted for Wiki, I said “well, let’s just read this text that the user types in, see if we can find something that looks like a heading or some italics, if you see a bunch of quotes or some italics in there somewhere” and it was pretty casual. Wikipedia suffers with that now because I followed that lead and discovered that “we can write one program that interprets this text, but we can’t write two, because it’s not all that clear, it’s defined by the program that interprets it”.\n\nOf course, nature does that too, our genes are defined by the enzymes and proteins that interpret it, so if it’s good enough for life. And in fact, thinking about Barbara, we were talking about Barbara Liskov, gave an excellent keynote here at QCon, and of course I think of her as the objects that are specified and I thing of Smalltalk as the objects that work. Dan Ingalls described it as training animals, it felt like training dogs, you just keep asking them to do something and tweaking them until they kind of worked right, that’s not a specification, but you can train dogs, maybe we can train computers, maybe we can breed computers to do our bidding in the future, what will that mean?\n\nWerner: Well, lots of cleaning up behind them.\n\nThat’s true.\n\nWerner: So, in a way I think what Barbara Liskov did in the 70’s with her style of object orientation having data types...\n\nData types and you took a body of code and you put an interface on it and that interface had a specification. And then she reminds people that you know that in Java, of course, and she got the Turing award for recognizing that and naming that and describing how to think about that and push things forward. She also described that kind of community that worked in that and the Smalltalk community kind of came and met and I think that they get along, I describe it as more of a peace treaty than a unification, but again now we have ten other things that are demanding our attention so a peace treaty is good enough and then we pick and choose from all of that to build real systems."
      },
      "date": 1712784897439
    },
    {
      "type": "edit",
      "id": "c1445365eee5a915",
      "item": {
        "type": "paragraph",
        "id": "c1445365eee5a915",
        "text": "Werner: Smalltalk, I think, had this notion of lightweight threads for instance, which I guess is one idea of implementing sequential programming in a lightweight way.\n\nI forgot exactly what it was called but basically there was some way you could reach up and grab your own stack and store it in an object and then you could have another stack do something. One of the coolest things was you could work on an application in Smalltalk and it could throw an exception and you could just look at it in the debugger and just “ah, I don’t care about that”, and throw it away, throw the runtime stack away and your application kept running because there was nothing in the stack that was particularly important, because it was all in the objects and that made it easy to layer on top of Smalltalk, a process model because inconsequential, “oh, yes, we have a process but if you want to throw it away, throw it away, nothing much, it will start back at the window”, windows were more important as a thing that did something than processes and that was educational, part of that was because Smalltalk existed before it had processes, but then when they added processes they said “well, let’s use processes to model [[Simulation]]” and they said “here’s how to reach up and grab onto your own processes and manage them for the purpose of building a simulator” and so this is going full circle. Remember, I said to understand that computing can be thought of as a simulation and now here we are thinking of computing as simulation again, so the fact that it did that well said something about the clarity of abstraction in Smalltalk. Smalltalk I think has still the best abstractions for a single environment.\n\nSmalltalk wanted to talk to itself, when I left Smalltalk I fell in love with [[Perl]] for a while because it wanted to talk to everybody “oh, the internet is here, everything, just rummage through this file hierarchy and send it over there where it will sort into some other file hierarchy and things go back and forth”, and Perl was good for that, you never knew what you got so you [[Regex It for a While Until You Found Something Interesting]]. In fact that was a style that I adopted for Wiki, I said “well, let’s just read this text that the user types in, see if we can find something that looks like a heading or some italics, if you see a bunch of quotes or some italics in there somewhere” and it was pretty casual. Wikipedia suffers with that now because I followed that lead and discovered that “we can write one program that interprets this text, but we can’t write two, because it’s not all that clear, it’s defined by the program that interprets it”.\n\nOf course, nature does that too, our genes are defined by the enzymes and proteins that interpret it, so if it’s good enough for life. And in fact, thinking about Barbara, we were talking about Barbara Liskov, gave an excellent keynote here at QCon, and of course I think of her as the objects that are specified and I thing of Smalltalk as the objects that work. Dan Ingalls described it as training animals, it felt like training dogs, you just keep asking them to do something and tweaking them until they kind of worked right, that’s not a specification, but you can train dogs, maybe we can train computers, maybe we can breed computers to do our bidding in the future, what will that mean?\n\nWerner: Well, lots of cleaning up behind them.\n\nThat’s true.\n\nWerner: So, in a way I think what Barbara Liskov did in the 70’s with her style of object orientation having data types...\n\nData types and you took a body of code and you put an interface on it and that interface had a specification. And then she reminds people that you know that in Java, of course, and she got the Turing award for recognizing that and naming that and describing how to think about that and push things forward. She also described that kind of community that worked in that and the Smalltalk community kind of came and met and I think that they get along, I describe it as more of a peace treaty than a unification, but again now we have ten other things that are demanding our attention so a peace treaty is good enough and then we pick and choose from all of that to build real systems."
      },
      "date": 1712784925577
    },
    {
      "type": "fork",
      "site": "localhost:3000",
      "date": 1712784986304
    },
    {
      "type": "edit",
      "id": "c1445365eee5a915",
      "item": {
        "type": "paragraph",
        "id": "c1445365eee5a915",
        "text": "Werner: Smalltalk, I think, had this notion of lightweight threads for instance, which I guess is one idea of implementing sequential programming in a lightweight way.\n\nI forgot exactly what it was called but basically there was some way you could reach up and grab your own stack and store it in an object and then you could have another stack do something. One of the coolest things was you could work on an application in Smalltalk and it could throw an exception and you could just look at it in the debugger and just “ah, I don’t care about that”, and throw it away, throw the runtime stack away and your application kept running because there was nothing in the stack that was particularly important, because it was all in the objects and that made it easy to layer on top of Smalltalk, a process model because inconsequential, “oh, yes, we have a process but if you want to throw it away, throw it away, nothing much, it will start back at the window”, windows were more important as a thing that did something than processes and that was educational, part of that was because Smalltalk existed before it had processes, but then when they added processes they said “well, let’s use processes to model [[Simulation]]” and they said “here’s how to reach up and grab onto your own processes and manage them for the purpose of building a simulator” and so this is going full circle. Remember, I said to understand that computing can be thought of as a simulation and now here we are thinking of computing as simulation again, so the fact that it did that well said something about the clarity of abstraction in Smalltalk. Smalltalk I think has still the best abstractions for a single environment.\n\nSmalltalk wanted to talk to itself, when I left Smalltalk I fell in love with [[Perl]] for a while because it wanted to talk to everybody “oh, the internet is here, everything, just rummage through this file hierarchy and send it over there where it will sort into some other file hierarchy and things go back and forth”, and Perl was good for that, you never knew what you got so you [[Regex It for a While Until You Found Something Interesting]]. In fact that was a style that I adopted for Wiki, I said “well, let’s just read this text that the user types in, see if we can find something that looks like a heading or some italics, if you see a bunch of quotes or some italics in there somewhere” and it was pretty casual. Wikipedia suffers with that now because I followed that lead and discovered that “we can write one program that interprets this text, but we can’t write two, because it’s not all that clear, it’s defined by the program that interprets it”.\n\nOf course, nature does that too, our genes are defined by the enzymes and proteins that interpret it, so if it’s good enough for life. And in fact, thinking about Barbara, we were talking about Barbara Liskov, gave an excellent keynote here at QCon, and of course I think of her as the objects that are specified and I thing of Smalltalk as the objects that work. Dan Ingalls described it as training animals, it felt like training dogs, you just keep asking them to do something and tweaking them until they kind of worked right, that’s not a specification, but you can train dogs, maybe we can train computers, maybe we can breed computers to do our bidding in the future, what will that mean?\n\nWerner: Well, lots of cleaning up behind them.\n\nThat’s true."
      },
      "date": 1712785012856
    },
    {
      "type": "add",
      "id": "d4faec7159d086b7",
      "item": {
        "type": "paragraph",
        "id": "d4faec7159d086b7",
        "text": "Werner: So, in a way I think what Barbara Liskov did in the 70’s with her style of object orientation having data types...\n\nData types and you took a body of code and you put an interface on it and that interface had a specification. And then she reminds people that you know that in Java, of course, and she got the Turing award for recognizing that and naming that and describing how to think about that and push things forward. She also described that kind of community that worked in that and the Smalltalk community kind of came and met and I think that they get along, I describe it as more of a peace treaty than a unification, but again now we have ten other things that are demanding our attention so a peace treaty is good enough and then we pick and choose from all of that to build real systems."
      },
      "after": "c1445365eee5a915",
      "date": 1712785017743
    },
    {
      "type": "edit",
      "id": "c1445365eee5a915",
      "item": {
        "type": "paragraph",
        "id": "c1445365eee5a915",
        "text": "Werner: Smalltalk, I think, had this notion of lightweight threads for instance, which I guess is one idea of implementing sequential programming in a lightweight way.\n\nI forgot exactly what it was called but basically there was some way you could reach up and grab your own stack and store it in an object and then you could have another stack do something. One of the coolest things was you could work on an application in Smalltalk and it could throw an exception and you could just look at it in the debugger and just “ah, I don’t care about that”, and throw it away, throw the runtime stack away and your application kept running because there was nothing in the stack that was particularly important, because it was all in the objects and that made it easy to layer on top of Smalltalk, a process model because inconsequential, “oh, yes, we have a process but if you want to throw it away, throw it away, nothing much, it will start back at the window”, windows were more important as a thing that did something than processes and that was educational, part of that was because Smalltalk existed before it had processes, but then when they added processes they said “well, let’s use processes to model [[Simulation]]” and they said “here’s how to reach up and grab onto your own processes and manage them for the purpose of building a simulator” and so this is going full circle. Remember, I said to understand that computing can be thought of as a simulation and now here we are thinking of computing as simulation again, so the fact that it did that well said something about the clarity of abstraction in Smalltalk. Smalltalk I think has still the best abstractions for a single environment.\n\nSmalltalk wanted to talk to itself, when I left Smalltalk I fell in love with [[Perl]] for a while because it wanted to talk to everybody “oh, the internet is here, everything, just rummage through this file hierarchy and send it over there where it will sort into some other file hierarchy and things go back and forth”, and Perl was good for that, you never knew what you got so you [[Regex It for a While Until You Found Something Interesting]]. In fact that was a style that I adopted for Wiki, I said “well, let’s just read this text that the user types in, see if we can find something that looks like a heading or some italics, if you see a bunch of quotes or some italics in there somewhere” and it was pretty casual. Wikipedia suffers with that now because I followed that lead and discovered that “we can write one program that interprets this text, but we can’t write two, because it’s not all that clear, it’s defined by the program that interprets it”.\n\nOf course, nature does that too, our genes are defined by the enzymes and proteins that interpret it, so if it’s good enough for life. And in fact, thinking about Barbara, we were talking about [[Barbara Liskov]], gave an excellent keynote here at QCon, and of course I think of her as the objects that are specified and I thing of Smalltalk as the objects that work. [[Dan Ingalls]] described it as training animals, it felt like training dogs, you just keep asking them to do something and tweaking them until they kind of worked right, that’s not a specification, but you can train dogs, maybe we can train computers, maybe we can breed computers to do our bidding in the future, what will that mean?\n\nWerner: Well, lots of cleaning up behind them.\n\nThat’s true."
      },
      "date": 1712785038613
    },
    {
      "type": "edit",
      "id": "c1445365eee5a915",
      "item": {
        "type": "paragraph",
        "id": "c1445365eee5a915",
        "text": "Werner: [[Smalltalk]], I think, had this notion of lightweight threads for instance, which I guess is one idea of implementing sequential programming in a lightweight way.\n\nI forgot exactly what it was called but basically there was some way you could reach up and grab your own stack and store it in an object and then you could have another stack do something. One of the coolest things was you could work on an application in Smalltalk and it could throw an exception and you could just look at it in the debugger and just “ah, I don’t care about that”, and throw it away, throw the runtime stack away and your application kept running because there was nothing in the stack that was particularly important, because it was all in the objects and that made it easy to layer on top of Smalltalk, a process model because inconsequential, “oh, yes, we have a process but if you want to throw it away, throw it away, nothing much, it will start back at the window”, windows were more important as a thing that did something than processes and that was educational, part of that was because Smalltalk existed before it had processes, but then when they added processes they said “well, let’s use processes to model [[Simulation]]” and they said “here’s how to reach up and grab onto your own processes and manage them for the purpose of building a simulator” and so this is going full circle. Remember, I said to understand that computing can be thought of as a simulation and now here we are thinking of computing as simulation again, so the fact that it did that well said something about the clarity of abstraction in Smalltalk. Smalltalk I think has still the best abstractions for a single environment.\n\nSmalltalk wanted to talk to itself, when I left Smalltalk I fell in love with [[Perl]] for a while because it wanted to talk to everybody “oh, the internet is here, everything, just rummage through this file hierarchy and send it over there where it will sort into some other file hierarchy and things go back and forth”, and Perl was good for that, you never knew what you got so you [[Regex It for a While Until You Found Something Interesting]]. In fact that was a style that I adopted for Wiki, I said “well, let’s just read this text that the user types in, see if we can find something that looks like a heading or some italics, if you see a bunch of quotes or some italics in there somewhere” and it was pretty casual. Wikipedia suffers with that now because I followed that lead and discovered that “we can write one program that interprets this text, but we can’t write two, because it’s not all that clear, it’s defined by the program that interprets it”.\n\nOf course, nature does that too, our genes are defined by the enzymes and proteins that interpret it, so if it’s good enough for life. And in fact, thinking about Barbara, we were talking about [[Barbara Liskov]], gave an excellent keynote here at QCon, and of course I think of her as the objects that are specified and I thing of Smalltalk as the objects that work. [[Dan Ingalls]] described it as training animals, it felt like training dogs, you just keep asking them to do something and tweaking them until they kind of worked right, that’s not a specification, but you can train dogs, maybe we can train computers, maybe we can breed computers to do our bidding in the future, what will that mean?\n\nWerner: Well, lots of cleaning up behind them.\n\nThat’s true."
      },
      "date": 1712785566754
    },
    {
      "type": "edit",
      "id": "d1dd1c4b5ede7317",
      "item": {
        "type": "paragraph",
        "id": "d1dd1c4b5ede7317",
        "text": "But there is an interesting point about asynchronous versus synchronous, isn’t synchronous a more natural way of implementing a sequential algorithm versus implementing lots of callbacks, what do you think about that?\n\nI (Ward) think, well I like to say the most important words or verbs or operators are the shortest ones, like + is pretty important so it doesn’t take a lot of space, but if you think about a sequencing, putting one thing after another, that sequential nature is that one operation that is just implicit in just about every language. So, yes we think of things sequentially and that was a real advance when Unix came along and said “let’s make simple little things that read from input and write to output and then you can put something at the other end and catch that and read it and write it and that [[Pipeline Is an Architectural Form]]”, very successful, I consider it the Latin of our discipline, to go back and think in those terms. But, as we build the really high performance data driven multi computer things just the response times that people expect it gets in the way, [[Process]] is too heavy, so it’s a pendulum that is swinging back and forth, before Unix, people they were doing some synchronous, some asynchronous, you never knew what you were doing, so I think all synchronous, all asynchronous, keep it straight, what idiom you are using. That’s why I say JavaScript is yet to really fully settle down on how it’s properly written. I think Java is way ahead on that regard. But then you’ve got the mavericks there, the Scalas and so forth that say “well, yes, but we can do better too’, and that’s pretty impressive stuff."
      },
      "date": 1712811484383
    },
    {
      "type": "edit",
      "id": "d1dd1c4b5ede7317",
      "item": {
        "type": "paragraph",
        "id": "d1dd1c4b5ede7317",
        "text": "But there is an interesting point about asynchronous versus synchronous, isn’t synchronous a more natural way of implementing a sequential algorithm versus implementing lots of callbacks, what do you think about that?\n\nI (Ward) think, well I like to say the most important words or verbs or operators are the shortest ones, like + is pretty important so it doesn’t take a lot of space, but if you think about a sequencing, putting one thing after another, that sequential nature is that one operation that is just implicit in just about every language. So, yes we think of things sequentially and that was a real advance when Unix came along and said “let’s make simple little things that read from input and write to output and then you can put something at the other end and catch that and read it and write it and that [[Pipeline Is an Architectural Form]]”, very successful, I consider it [[The Latin of Our Discipline]], to go back and think in those terms. But, as we build the really high performance data driven multi computer things just the response times that people expect it gets in the way, [[Process]] is too heavy, so it’s a pendulum that is swinging back and forth, before Unix, people they were doing some synchronous, some asynchronous, you never knew what you were doing, so I think all synchronous, all asynchronous, keep it straight, what idiom you are using. That’s why I say JavaScript is yet to really fully settle down on how it’s properly written. I think Java is way ahead on that regard. But then you’ve got the mavericks there, the Scalas and so forth that say “well, yes, but we can do better too’, and that’s pretty impressive stuff."
      },
      "date": 1712811790093
    },
    {
      "type": "edit",
      "id": "d1dd1c4b5ede7317",
      "item": {
        "type": "paragraph",
        "id": "d1dd1c4b5ede7317",
        "text": "But there is an interesting point about asynchronous versus synchronous, isn’t synchronous a more natural way of implementing a sequential algorithm versus implementing lots of callbacks, what do you think about that?"
      },
      "date": 1712811823720
    },
    {
      "type": "add",
      "id": "a6d74105dba4c099",
      "item": {
        "type": "paragraph",
        "id": "a6d74105dba4c099",
        "text": "I (Ward) think, well I like to say the most important words or verbs or operators are the shortest ones, like + is pretty important so it doesn’t take a lot of space, but if you think about a sequencing, putting one thing after another, that sequential nature is that one operation that is just implicit in just about every language. So, yes we think of things sequentially and that was a real advance when Unix came along and said “let’s make simple little things that read from input and write to output and then you can put something at the other end and catch that and read it and write it and that [[Pipeline Is an Architectural Form]]”, very successful, I consider it [[The Latin of Our Discipline]], to go back and think in those terms. But, as we build the really high performance data driven multi computer things just the response times that people expect it gets in the way, [[Process]] is too heavy, so it’s a pendulum that is swinging back and forth, before Unix, people they were doing some synchronous, some asynchronous, you never knew what you were doing, so I think all synchronous, all asynchronous, keep it straight, what idiom you are using. That’s why I say JavaScript is yet to really fully settle down on how it’s properly written. I think Java is way ahead on that regard. But then you’ve got the mavericks there, the Scalas and so forth that say “well, yes, but we can do better too’, and that’s pretty impressive stuff."
      },
      "after": "d1dd1c4b5ede7317",
      "date": 1712811824639
    }
  ]
}